internal static class FxResources.PresentationFramework.SR : object {
}
public abstract class Microsoft.Win32.CommonDialog : object {
    private object _userData;
    private Thread _thread;
    private IntPtr _hwndOwnerWindow;
    public object Tag { get; public set; }
    public abstract virtual void Reset();
    public virtual Nullable`1<bool> ShowDialog();
    public Nullable`1<bool> ShowDialog(Window owner);
    public object get_Tag();
    public void set_Tag(object value);
    protected virtual IntPtr HookProc(IntPtr hwnd, int msg, IntPtr wParam, IntPtr lParam);
    protected abstract virtual bool RunDialog(IntPtr hwndOwner);
    protected virtual void CheckPermissionsToShowDialog();
    internal void MoveToScreenCenter(HandleRef hWnd);
}
public abstract class Microsoft.Win32.FileDialog : CommonDialog {
    [CompilerGeneratedAttribute]
private CancelEventHandler FileOk;
    [CompilerGeneratedAttribute]
private IList`1<FileDialogCustomPlace> <CustomPlaces>k__BackingField;
    private static FOS c_VistaFileDialogMask;
    private SecurityCriticalDataForSet`1<int> _dialogOptions;
    private bool _ignoreSecondFileOkNotification;
    private int _fileOkNotificationCount;
    private SecurityCriticalDataForSet`1<string> _title;
    private SecurityCriticalDataForSet`1<string> _initialDirectory;
    private string _defaultExtension;
    private string _filter;
    private int _filterIndex;
    private CharBuffer _charBuffer;
    private IntPtr _hwndFileDialog;
    private String[] _fileNames;
    private static int FILEBUFSIZE;
    private static int OPTION_ADDEXTENSION;
    public bool AddExtension { get; public set; }
    public bool CheckFileExists { get; public set; }
    public bool CheckPathExists { get; public set; }
    public string DefaultExt { get; public set; }
    public bool DereferenceLinks { get; public set; }
    public string SafeFileName { get; }
    public String[] SafeFileNames { get; }
    public string FileName { get; public set; }
    public String[] FileNames { get; }
    public string Filter { get; public set; }
    public int FilterIndex { get; public set; }
    public string InitialDirectory { get; public set; }
    public bool RestoreDirectory { get; public set; }
    public string Title { get; public set; }
    public bool ValidateNames { get; public set; }
    internal String[] FileNamesInternal { get; }
    private string CriticalFileName { get; }
    private string DialogCaption { get; }
    protected int Options { get; }
    public IList`1<FileDialogCustomPlace> CustomPlaces { get; public set; }
    private bool UseVistaDialog { get; }
    public virtual void Reset();
    public virtual string ToString();
    public bool get_AddExtension();
    public void set_AddExtension(bool value);
    public virtual bool get_CheckFileExists();
    public virtual void set_CheckFileExists(bool value);
    public bool get_CheckPathExists();
    public void set_CheckPathExists(bool value);
    public string get_DefaultExt();
    public void set_DefaultExt(string value);
    public bool get_DereferenceLinks();
    public void set_DereferenceLinks(bool value);
    public string get_SafeFileName();
    public String[] get_SafeFileNames();
    public string get_FileName();
    public void set_FileName(string value);
    public String[] get_FileNames();
    public string get_Filter();
    public void set_Filter(string value);
    public int get_FilterIndex();
    public void set_FilterIndex(int value);
    public string get_InitialDirectory();
    public void set_InitialDirectory(string value);
    public bool get_RestoreDirectory();
    public void set_RestoreDirectory(bool value);
    public string get_Title();
    public void set_Title(string value);
    public bool get_ValidateNames();
    public void set_ValidateNames(bool value);
    [CompilerGeneratedAttribute]
public void add_FileOk(CancelEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_FileOk(CancelEventHandler value);
    protected virtual IntPtr HookProc(IntPtr hwnd, int msg, IntPtr wParam, IntPtr lParam);
    protected void OnFileOk(CancelEventArgs e);
    protected virtual bool RunDialog(IntPtr hwndOwner);
    private bool RunLegacyDialog(IntPtr hwndOwner);
    internal bool GetOption(int option);
    internal void SetOption(int option, bool value);
    internal bool MessageBoxWithFocusRestore(string message, MessageBoxButton buttons, MessageBoxImage image);
    internal virtual bool PromptUserIfAppropriate(string fileName);
    internal abstract virtual bool RunFileDialog(OPENFILENAME_I ofn);
    internal String[] get_FileNamesInternal();
    private bool DoFileOk(IntPtr lpOFN);
    private static String[] GetMultiselectFiles(CharBuffer charBuffer);
    private void Initialize();
    private static string MakeFilterString(string s, bool dereferenceLinks);
    private bool ProcessFileNames();
    private void PromptFileNotFound(string fileName);
    private string get_CriticalFileName();
    private string get_DialogCaption();
    private String[] GetFilterExtensions();
    protected int get_Options();
    [CompilerGeneratedAttribute]
public IList`1<FileDialogCustomPlace> get_CustomPlaces();
    [CompilerGeneratedAttribute]
public void set_CustomPlaces(IList`1<FileDialogCustomPlace> value);
    internal abstract virtual IFileDialog CreateVistaDialog();
    internal abstract virtual String[] ProcessVistaFiles(IFileDialog dialog);
    internal virtual void PrepareVistaDialog(IFileDialog dialog);
    private bool get_UseVistaDialog();
    private bool RunVistaDialog(IntPtr hwndOwner);
    private bool HandleVistaFileOk(IFileDialog dialog);
    private static COMDLG_FILTERSPEC[] GetFilterItems(string filter);
    private static IShellItem ResolveCustomPlace(FileDialogCustomPlace customPlace);
}
public class Microsoft.Win32.FileDialogCustomPlace : object {
    [CompilerGeneratedAttribute]
private Guid <KnownFolder>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    public Guid KnownFolder { get; private set; }
    public string Path { get; private set; }
    public FileDialogCustomPlace(Guid knownFolder);
    public FileDialogCustomPlace(string path);
    [CompilerGeneratedAttribute]
public Guid get_KnownFolder();
    [CompilerGeneratedAttribute]
private void set_KnownFolder(Guid value);
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
private void set_Path(string value);
}
public static class Microsoft.Win32.FileDialogCustomPlaces : object {
    public static FileDialogCustomPlace RoamingApplicationData { get; }
    public static FileDialogCustomPlace LocalApplicationData { get; }
    public static FileDialogCustomPlace Cookies { get; }
    public static FileDialogCustomPlace Contacts { get; }
    public static FileDialogCustomPlace Favorites { get; }
    public static FileDialogCustomPlace Programs { get; }
    public static FileDialogCustomPlace Music { get; }
    public static FileDialogCustomPlace Pictures { get; }
    public static FileDialogCustomPlace SendTo { get; }
    public static FileDialogCustomPlace StartMenu { get; }
    public static FileDialogCustomPlace Startup { get; }
    public static FileDialogCustomPlace System { get; }
    public static FileDialogCustomPlace Templates { get; }
    public static FileDialogCustomPlace Desktop { get; }
    public static FileDialogCustomPlace Documents { get; }
    public static FileDialogCustomPlace ProgramFiles { get; }
    public static FileDialogCustomPlace ProgramFilesCommon { get; }
    public static FileDialogCustomPlace get_RoamingApplicationData();
    public static FileDialogCustomPlace get_LocalApplicationData();
    public static FileDialogCustomPlace get_Cookies();
    public static FileDialogCustomPlace get_Contacts();
    public static FileDialogCustomPlace get_Favorites();
    public static FileDialogCustomPlace get_Programs();
    public static FileDialogCustomPlace get_Music();
    public static FileDialogCustomPlace get_Pictures();
    public static FileDialogCustomPlace get_SendTo();
    public static FileDialogCustomPlace get_StartMenu();
    public static FileDialogCustomPlace get_Startup();
    public static FileDialogCustomPlace get_System();
    public static FileDialogCustomPlace get_Templates();
    public static FileDialogCustomPlace get_Desktop();
    public static FileDialogCustomPlace get_Documents();
    public static FileDialogCustomPlace get_ProgramFiles();
    public static FileDialogCustomPlace get_ProgramFilesCommon();
}
public class Microsoft.Win32.OpenFileDialog : FileDialog {
    public bool Multiselect { get; public set; }
    public bool ReadOnlyChecked { get; public set; }
    public bool ShowReadOnly { get; public set; }
    public Stream OpenFile();
    public Stream[] OpenFiles();
    public virtual void Reset();
    public bool get_Multiselect();
    public void set_Multiselect(bool value);
    public bool get_ReadOnlyChecked();
    public void set_ReadOnlyChecked(bool value);
    public bool get_ShowReadOnly();
    public void set_ShowReadOnly(bool value);
    protected virtual void CheckPermissionsToShowDialog();
    internal virtual bool RunFileDialog(OPENFILENAME_I ofn);
    internal virtual String[] ProcessVistaFiles(IFileDialog dialog);
    internal virtual IFileDialog CreateVistaDialog();
    private void Initialize();
}
public class Microsoft.Win32.SaveFileDialog : FileDialog {
    public bool CreatePrompt { get; public set; }
    public bool OverwritePrompt { get; public set; }
    public Stream OpenFile();
    public virtual void Reset();
    public bool get_CreatePrompt();
    public void set_CreatePrompt(bool value);
    public bool get_OverwritePrompt();
    public void set_OverwritePrompt(bool value);
    internal virtual bool PromptUserIfAppropriate(string fileName);
    internal virtual bool RunFileDialog(OPENFILENAME_I ofn);
    internal virtual String[] ProcessVistaFiles(IFileDialog dialog);
    internal virtual IFileDialog CreateVistaDialog();
    private void Initialize();
    private bool PromptFileCreate(string fileName);
    private bool PromptFileOverwrite(string fileName);
}
internal class MS.Internal.Annotations.Anchoring.AttachedAnnotation : object {
    private Annotation _annotation;
    private AnnotationResource _anchor;
    private object _attachedAnchor;
    private object _fullyAttachedAnchor;
    private AttachmentLevel _attachmentLevel;
    private DependencyObject _parent;
    private SelectionProcessor _selectionProcessor;
    private LocatorManager _locatorManager;
    private Point _cachedPoint;
    public Annotation Annotation { get; }
    public AnnotationResource Anchor { get; }
    public object AttachedAnchor { get; }
    public object ResolvedAnchor { get; }
    public object FullyAttachedAnchor { get; }
    public AttachmentLevel AttachmentLevel { get; }
    public DependencyObject Parent { get; }
    public Point AnchorPoint { get; }
    public AnnotationStore Store { get; }
    internal AttachedAnnotation(LocatorManager manager, Annotation annotation, AnnotationResource anchor, object attachedAnchor, AttachmentLevel attachmentLevel);
    internal AttachedAnnotation(LocatorManager manager, Annotation annotation, AnnotationResource anchor, object attachedAnchor, AttachmentLevel attachmentLevel, DependencyObject parent);
    public sealed virtual bool IsAnchorEqual(object o);
    public sealed virtual Annotation get_Annotation();
    public sealed virtual AnnotationResource get_Anchor();
    public sealed virtual object get_AttachedAnchor();
    public sealed virtual object get_ResolvedAnchor();
    public sealed virtual object get_FullyAttachedAnchor();
    public sealed virtual AttachmentLevel get_AttachmentLevel();
    public sealed virtual DependencyObject get_Parent();
    public sealed virtual Point get_AnchorPoint();
    public sealed virtual AnnotationStore get_Store();
    internal void Update(object attachedAnchor, AttachmentLevel attachmentLevel, DependencyObject parent);
    internal void SetFullyAttachedAnchor(object fullyAttachedAnchor);
    private AnnotationStore GetStore();
}
internal class MS.Internal.Annotations.Anchoring.DataIdProcessor : SubTreeProcessor {
    public static string Id;
    public static DependencyProperty DataIdProperty;
    public static DependencyProperty FetchAnnotationsAsBatchProperty;
    private static XmlQualifiedName DataIdElementName;
    private static string ValueAttributeName;
    private static XmlQualifiedName[] LocatorPartTypeNames;
    public DataIdProcessor(LocatorManager manager);
    private static DataIdProcessor();
    public virtual IList`1<IAttachedAnnotation> PreProcessNode(DependencyObject node, Boolean& calledProcessAnnotations);
    public virtual IList`1<IAttachedAnnotation> PostProcessNode(DependencyObject node, bool childrenCalledProcessAnnotations, Boolean& calledProcessAnnotations);
    public virtual ContentLocator GenerateLocator(PathNode node, Boolean& continueGenerating);
    public virtual DependencyObject ResolveLocatorPart(ContentLocatorPart locatorPart, DependencyObject startNode, Boolean& continueResolving);
    public virtual XmlQualifiedName[] GetLocatorPartTypes();
    public static void SetDataId(DependencyObject d, string id);
    [DesignerSerializationVisibilityAttribute("0")]
public static string GetDataId(DependencyObject d);
    public static void SetFetchAnnotationsAsBatch(DependencyObject d, bool id);
    [DesignerSerializationVisibilityAttribute("0")]
public static bool GetFetchAnnotationsAsBatch(DependencyObject d);
    private static void OnDataIdPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static object CoerceDataId(DependencyObject d, object value);
    private ContentLocatorPart CreateLocatorPart(DependencyObject node);
    internal string GetNodeId(DependencyObject d);
}
internal class MS.Internal.Annotations.Anchoring.FixedPageProcessor : SubTreeProcessor {
    public static string Id;
    private static string ValueAttributeName;
    private static XmlQualifiedName PageNumberElementName;
    private static XmlQualifiedName[] LocatorPartTypeNames;
    private bool _useLogicalTree;
    unknown bool UseLogicalTree {internal set; }
    public FixedPageProcessor(LocatorManager manager);
    private static FixedPageProcessor();
    public virtual IList`1<IAttachedAnnotation> PreProcessNode(DependencyObject node, Boolean& calledProcessAnnotations);
    public virtual ContentLocator GenerateLocator(PathNode node, Boolean& continueGenerating);
    public virtual DependencyObject ResolveLocatorPart(ContentLocatorPart locatorPart, DependencyObject startNode, Boolean& continueResolving);
    public virtual XmlQualifiedName[] GetLocatorPartTypes();
    internal void set_UseLogicalTree(bool value);
    internal static ContentLocatorPart CreateLocatorPart(int page);
}
internal class MS.Internal.Annotations.Anchoring.FixedTextSelectionProcessor : SelectionProcessor {
    private static XmlQualifiedName FixedTextElementName;
    private static XmlQualifiedName[] LocatorPartTypeNames;
    private static FixedTextSelectionProcessor();
    public virtual bool MergeSelections(object anchor1, object anchor2, Object& newAnchor);
    public virtual IList`1<DependencyObject> GetSelectedNodes(object selection);
    public virtual UIElement GetParent(object selection);
    public virtual Point GetAnchorPoint(object selection);
    public virtual IList`1<ContentLocatorPart> GenerateLocatorParts(object selection, DependencyObject startNode);
    public virtual object ResolveLocatorPart(ContentLocatorPart locatorPart, DependencyObject startNode, AttachmentLevel& attachmentLevel);
    public virtual XmlQualifiedName[] GetLocatorPartTypes();
    private DocumentPage GetDocumentPage(FixedPage page);
    private IList`1<TextSegment> CheckSelection(object selection);
    private TextAnchor CheckAnchor(object selection);
    private void GetLocatorPartSegmentValues(ContentLocatorPart locatorPart, int segmentNumber, Point& start, Point& end);
    private Point GetPoint(string xstr, string ystr);
    private static ITextPointer FindStartVisibleTextPointer(DocumentPage documentPage);
    private static ITextPointer FindEndVisibleTextPointer(DocumentPage documentPage);
    private static bool GetTextViewRange(DocumentPage documentPage, ITextPointer& start, ITextPointer& end);
}
internal class MS.Internal.Annotations.Anchoring.LocatorManager : DispatcherObject {
    public static DependencyProperty SubTreeProcessorIdProperty;
    private Hashtable _locatorPartHandlers;
    private Hashtable _subtreeProcessors;
    private Hashtable _selectionProcessors;
    private static Char[] Separators;
    private AnnotationStore _internalStore;
    public LocatorManager(AnnotationStore store);
    private static LocatorManager();
    public void RegisterSubTreeProcessor(SubTreeProcessor processor, string processorId);
    public SubTreeProcessor GetSubTreeProcessor(DependencyObject node);
    public SubTreeProcessor GetSubTreeProcessorForLocatorPart(ContentLocatorPart locatorPart);
    public void RegisterSelectionProcessor(SelectionProcessor processor, Type selectionType);
    public SelectionProcessor GetSelectionProcessor(Type selectionType);
    public SelectionProcessor GetSelectionProcessorForLocatorPart(ContentLocatorPart locatorPart);
    public IList`1<IAttachedAnnotation> ProcessAnnotations(DependencyObject node);
    public IList`1<ContentLocatorBase> GenerateLocators(object selection);
    public object ResolveLocator(ContentLocatorBase locator, int offset, DependencyObject startNode, AttachmentLevel& attachmentLevel);
    public static void SetSubTreeProcessorId(DependencyObject d, string id);
    [DesignerSerializationVisibilityAttribute("0")]
public static string GetSubTreeProcessorId(DependencyObject d);
    internal IList`1<IAttachedAnnotation> ProcessSubTree(DependencyObject subTree);
    internal object FindAttachedAnchor(DependencyObject startNode, ContentLocator[] prefixes, ContentLocatorBase locator, AttachmentLevel& attachmentLevel);
    private int FindMatchingPrefix(ContentLocator[] prefixes, ContentLocatorBase locator, Boolean& matched);
    private IList`1<ContentLocatorBase> GenerateLocators(SubTreeProcessor processor, PathNode startNode, object selection);
    private ContentLocatorBase GenerateLocatorGroup(PathNode node, object selection);
    private bool PreVisit(DependencyObject dependencyObject, ProcessingTreeState data, bool visitedViaVisualTree);
    private bool PostVisit(DependencyObject dependencyObject, ProcessingTreeState data, bool visitedViaVisualTree);
    private object InternalResolveLocator(ContentLocatorBase locator, int offset, DependencyObject startNode, bool skipStartNode, AttachmentLevel& attachmentLevel);
    private ResolvingLocatorState ResolveSingleLocator(Object& selection, AttachmentLevel& attachmentLevel, AttachmentLevel attemptedLevel, ContentLocator locator, int offset, DependencyObject startNode, bool skipStartNode);
    private bool ResolveLocatorPart(DependencyObject dependencyObject, ResolvingLocatorState data, bool visitedViaVisualTree);
    private bool TerminateResolve(DependencyObject dependencyObject, ResolvingLocatorState data, bool visitedViaVisualTree);
    private IList`1<ContentLocatorBase> Merge(ContentLocatorBase initialLocator, IList`1<ContentLocatorBase> additionalLocators);
}
internal class MS.Internal.Annotations.Anchoring.PathNode : object {
    internal static DependencyProperty HiddenParentProperty;
    private DependencyObject _node;
    private ArrayList _children;
    public DependencyObject Node { get; }
    public IList Children { get; }
    internal PathNode(DependencyObject node);
    private static PathNode();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public DependencyObject get_Node();
    public IList get_Children();
    internal static PathNode BuildPathForElements(ICollection nodes);
    internal static DependencyObject GetParent(DependencyObject node);
    private static PathNode BuildPathForElement(DependencyObject node);
    private static PathNode AddBranchToPath(PathNode path, PathNode branch);
    private void AddChild(object child);
    private void FreezeChildren();
}
internal abstract class MS.Internal.Annotations.Anchoring.SelectionProcessor : object {
    public abstract virtual bool MergeSelections(object selection1, object selection2, Object& newSelection);
    public abstract virtual IList`1<DependencyObject> GetSelectedNodes(object selection);
    public abstract virtual UIElement GetParent(object selection);
    public abstract virtual Point GetAnchorPoint(object selection);
    public abstract virtual IList`1<ContentLocatorPart> GenerateLocatorParts(object selection, DependencyObject startNode);
    public abstract virtual object ResolveLocatorPart(ContentLocatorPart locatorPart, DependencyObject startNode, AttachmentLevel& attachmentLevel);
    public abstract virtual XmlQualifiedName[] GetLocatorPartTypes();
}
internal abstract class MS.Internal.Annotations.Anchoring.SubTreeProcessor : object {
    private LocatorManager _manager;
    protected LocatorManager Manager { get; }
    protected SubTreeProcessor(LocatorManager manager);
    public abstract virtual IList`1<IAttachedAnnotation> PreProcessNode(DependencyObject node, Boolean& calledProcessAnnotations);
    public virtual IList`1<IAttachedAnnotation> PostProcessNode(DependencyObject node, bool childrenCalledProcessAnnotations, Boolean& calledProcessAnnotations);
    public abstract virtual ContentLocator GenerateLocator(PathNode node, Boolean& continueGenerating);
    public abstract virtual DependencyObject ResolveLocatorPart(ContentLocatorPart locatorPart, DependencyObject startNode, Boolean& continueResolving);
    public abstract virtual XmlQualifiedName[] GetLocatorPartTypes();
    protected LocatorManager get_Manager();
}
internal class MS.Internal.Annotations.Anchoring.TextSelectionHelper : object {
    public static bool MergeSelections(object anchor1, object anchor2, Object& newAnchor);
    public static IList`1<DependencyObject> GetSelectedNodes(object selection);
    public static UIElement GetParent(object selection);
    public static UIElement GetParent(ITextPointer pointer);
    public static Point GetAnchorPoint(object selection);
    public static Point GetAnchorPointForPointer(ITextPointer pointer);
    public static Point GetPointForPointer(ITextPointer pointer);
    public static Rect GetAnchorRectangle(ITextPointer pointer);
    public static IDocumentPaginatorSource GetPointerPage(ITextPointer pointer, Int32& pageNumber);
    internal static void CheckSelection(object selection, ITextPointer& start, ITextPointer& end, IList`1& segments);
    internal static ITextView GetDocumentPageTextView(ITextPointer pointer);
    internal static List`1<ITextView> GetDocumentPageTextViews(TextSegment segment);
    private static List`1<ITextView> ProcessSinglePage(IDocumentPaginatorSource idp, int pageNumber);
    private static List`1<ITextView> ProcessMultiplePages(IDocumentPaginatorSource idp, int startPageNumber, int endPageNumber);
}
internal class MS.Internal.Annotations.Anchoring.TextSelectionProcessor : SelectionProcessor {
    internal static string SegmentAttribute;
    internal static string CountAttribute;
    internal static string IncludeOverlaps;
    internal static Char[] Separator;
    internal static XmlQualifiedName CharacterRangeElementName;
    private static XmlQualifiedName[] LocatorPartTypeNames;
    private DocumentPageView _targetPage;
    private bool _clamping;
    unknown bool Clamping {internal set; }
    private static TextSelectionProcessor();
    public virtual bool MergeSelections(object anchor1, object anchor2, Object& newAnchor);
    public virtual IList`1<DependencyObject> GetSelectedNodes(object selection);
    public virtual UIElement GetParent(object selection);
    public virtual Point GetAnchorPoint(object selection);
    public virtual IList`1<ContentLocatorPart> GenerateLocatorParts(object selection, DependencyObject startNode);
    public virtual object ResolveLocatorPart(ContentLocatorPart locatorPart, DependencyObject startNode, AttachmentLevel& attachmentLevel);
    public virtual XmlQualifiedName[] GetLocatorPartTypes();
    internal void set_Clamping(bool value);
    internal static void GetMaxMinLocatorPartValues(ContentLocatorPart locatorPart, Int32& startOffset, Int32& endOffset);
    internal void SetTargetDocumentPageView(DocumentPageView target);
    private static void GetLocatorPartSegmentValues(ContentLocatorPart locatorPart, int segmentNumber, Int32& startOffset, Int32& endOffset);
    private ITextContainer GetTextContainer(DependencyObject startNode);
    private bool GetNodesStartAndEnd(DependencyObject startNode, ITextPointer& start, ITextPointer& end);
    private void GetTextSegmentValues(TextSegment segment, ITextPointer elementStart, ITextPointer elementEnd, Int32& startOffset, Int32& endOffset);
}
internal class MS.Internal.Annotations.Anchoring.TextViewSelectionProcessor : SelectionProcessor {
    private static XmlQualifiedName[] LocatorPartTypeNames;
    private static TextViewSelectionProcessor();
    public virtual bool MergeSelections(object selection1, object selection2, Object& newSelection);
    public virtual IList`1<DependencyObject> GetSelectedNodes(object selection);
    public virtual UIElement GetParent(object selection);
    public virtual Point GetAnchorPoint(object selection);
    public virtual IList`1<ContentLocatorPart> GenerateLocatorParts(object selection, DependencyObject startNode);
    public virtual object ResolveLocatorPart(ContentLocatorPart locatorPart, DependencyObject startNode, AttachmentLevel& attachmentLevel);
    public virtual XmlQualifiedName[] GetLocatorPartTypes();
    internal static TextRange GetTextViewTextRange(ITextView textView, Int32& startOffset, Int32& endOffset);
    private ITextView VerifySelection(object selection);
}
internal class MS.Internal.Annotations.Anchoring.TreeNodeSelectionProcessor : SelectionProcessor {
    private static XmlQualifiedName[] LocatorPartTypeNames;
    private static TreeNodeSelectionProcessor();
    public virtual bool MergeSelections(object selection1, object selection2, Object& newSelection);
    public virtual IList`1<DependencyObject> GetSelectedNodes(object selection);
    public virtual UIElement GetParent(object selection);
    public virtual Point GetAnchorPoint(object selection);
    public virtual IList`1<ContentLocatorPart> GenerateLocatorParts(object selection, DependencyObject startNode);
    public virtual object ResolveLocatorPart(ContentLocatorPart locatorPart, DependencyObject startNode, AttachmentLevel& attachmentLevel);
    public virtual XmlQualifiedName[] GetLocatorPartTypes();
}
internal class MS.Internal.Annotations.AnnotationMap : object {
    private Dictionary`2<Guid, List`1<IAttachedAnnotation>> _annotationIdToAttachedAnnotations;
    private static List`1<IAttachedAnnotation> _emptyList;
    internal bool IsEmpty { get; }
    private static AnnotationMap();
    internal void AddAttachedAnnotation(IAttachedAnnotation attachedAnnotation);
    internal void RemoveAttachedAnnotation(IAttachedAnnotation attachedAnnotation);
    internal bool get_IsEmpty();
    internal List`1<IAttachedAnnotation> GetAttachedAnnotations(Guid annotationId);
    internal List`1<IAttachedAnnotation> GetAllAttachedAnnotations();
}
internal class MS.Internal.Annotations.AnnotationObservableCollection`1 : ObservableCollection`1<T> {
    private PropertyChangedEventHandler _listener;
    internal string CountString;
    internal string IndexerName;
    public AnnotationObservableCollection`1(List`1<T> list);
    protected virtual void ClearItems();
    protected virtual void RemoveItem(int index);
    protected virtual void InsertItem(int index, T item);
    protected virtual void SetItem(int index, T item);
    protected virtual void ProtectedClearItems();
    protected virtual void ProtectedSetItem(int index, T item);
    protected void ObservableCollectionSetItem(int index, T item);
    protected virtual void OnItemPropertyChanged(object sender, PropertyChangedEventArgs e);
    private bool ItemOwned(object item);
    private void SetOwned(object item, bool owned);
}
internal class MS.Internal.Annotations.AnnotationResourceCollection : AnnotationObservableCollection`1<AnnotationResource> {
    [CompilerGeneratedAttribute]
private PropertyChangedEventHandler ItemChanged;
    [CompilerGeneratedAttribute]
public void add_ItemChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_ItemChanged(PropertyChangedEventHandler value);
    protected virtual void ProtectedClearItems();
    protected virtual void ProtectedSetItem(int index, AnnotationResource item);
    private void OnCollectionCleared(IEnumerable`1<AnnotationResource> list);
    private void OnPropertyChanged(string propertyName);
    protected virtual void OnItemPropertyChanged(object sender, PropertyChangedEventArgs e);
}
internal class MS.Internal.Annotations.AnnotationXmlConstants : ValueType {
}
internal enum MS.Internal.Annotations.AttachedAnnotationAction : Enum {
    public int value__;
    public static AttachedAnnotationAction Loaded;
    public static AttachedAnnotationAction Unloaded;
    public static AttachedAnnotationAction AnchorModified;
    public static AttachedAnnotationAction Added;
    public static AttachedAnnotationAction Deleted;
}
internal class MS.Internal.Annotations.AttachedAnnotationChangedEventArgs : EventArgs {
    private AttachedAnnotationAction _action;
    private IAttachedAnnotation _attachedAnnotation;
    private object _previousAttachedAnchor;
    private AttachmentLevel _previousAttachmentLevel;
    public AttachedAnnotationAction Action { get; }
    public IAttachedAnnotation AttachedAnnotation { get; }
    public object PreviousAttachedAnchor { get; }
    public AttachmentLevel PreviousAttachmentLevel { get; }
    internal AttachedAnnotationChangedEventArgs(AttachedAnnotationAction action, IAttachedAnnotation attachedAnnotation, object previousAttachedAnchor, AttachmentLevel previousAttachmentLevel);
    public AttachedAnnotationAction get_Action();
    public IAttachedAnnotation get_AttachedAnnotation();
    public object get_PreviousAttachedAnchor();
    public AttachmentLevel get_PreviousAttachmentLevel();
    internal static AttachedAnnotationChangedEventArgs Added(IAttachedAnnotation attachedAnnotation);
    internal static AttachedAnnotationChangedEventArgs Loaded(IAttachedAnnotation attachedAnnotation);
    internal static AttachedAnnotationChangedEventArgs Deleted(IAttachedAnnotation attachedAnnotation);
    internal static AttachedAnnotationChangedEventArgs Unloaded(IAttachedAnnotation attachedAnnotation);
    internal static AttachedAnnotationChangedEventArgs Modified(IAttachedAnnotation attachedAnnotation, object previousAttachedAnchor, AttachmentLevel previousAttachmentLevel);
}
internal class MS.Internal.Annotations.AttachedAnnotationChangedEventHandler : MulticastDelegate {
    public AttachedAnnotationChangedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, AttachedAnnotationChangedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, AttachedAnnotationChangedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[FlagsAttribute]
internal enum MS.Internal.Annotations.AttachmentLevel : Enum {
    public int value__;
    public static AttachmentLevel Full;
    public static AttachmentLevel StartPortion;
    public static AttachmentLevel MiddlePortion;
    public static AttachmentLevel EndPortion;
    public static AttachmentLevel Incomplete;
    public static AttachmentLevel Unresolved;
}
internal class MS.Internal.Annotations.Component.AdornerPresentationContext : PresentationContext {
    private AnnotationAdorner _annotationAdorner;
    private AdornerLayer _adornerLayer;
    private static Hashtable _ZLevel;
    private static Hashtable _ZRanges;
    public UIElement Host { get; }
    public PresentationContext EnclosingContext { get; }
    private AdornerPresentationContext(AdornerLayer adornerLayer, AnnotationAdorner adorner);
    private static AdornerPresentationContext();
    internal static void HostComponent(AdornerLayer adornerLayer, IAnnotationComponent component, UIElement annotatedElement, bool reorder);
    internal static void SetTypeZLevel(Type type, int level);
    internal static void SetZLevelRange(int level, int min, int max);
    public virtual UIElement get_Host();
    public virtual PresentationContext get_EnclosingContext();
    public virtual void AddToHost(IAnnotationComponent component);
    public virtual void RemoveFromHost(IAnnotationComponent component, bool reorder);
    public virtual void InvalidateTransform(IAnnotationComponent component);
    public virtual void BringToFront(IAnnotationComponent component);
    public virtual void SendToBack(IAnnotationComponent component);
    public virtual bool Equals(object o);
    public static bool op_Equality(AdornerPresentationContext left, AdornerPresentationContext right);
    public static bool op_Inequality(AdornerPresentationContext c1, AdornerPresentationContext c2);
    public virtual int GetHashCode();
    public void UpdateComponentZOrder(IAnnotationComponent component);
    private void ResetInternalAnnotationAdorner();
    private bool IsInternalComponent(IAnnotationComponent component);
    private AnnotationAdorner FindAnnotationAdorner(IAnnotationComponent component);
    private List`1<AnnotationAdorner> GetTopAnnotationAdorners(int level, IAnnotationComponent component);
    private void AddAdorner(List`1<AnnotationAdorner> adorners, AnnotationAdorner adorner);
    private static int GetNextZOrder(AdornerLayer adornerLayer, int level);
    private AnnotationAdorner GetAnnotationAdorner(IAnnotationComponent component);
    private static int GetComponentLevel(IAnnotationComponent component);
    private static int ComponentToAdorner(int zOrder, int level);
}
internal class MS.Internal.Annotations.Component.AnnotationAdorner : Adorner {
    private IAnnotationComponent _annotationComponent;
    private UIElement _annotatedElement;
    protected int VisualChildrenCount { get; }
    internal IAnnotationComponent AnnotationComponent { get; }
    public AnnotationAdorner(IAnnotationComponent component, UIElement annotatedElement);
    public virtual GeneralTransform GetDesiredTransform(GeneralTransform transform);
    protected virtual Visual GetVisualChild(int index);
    protected virtual int get_VisualChildrenCount();
    protected virtual Size MeasureOverride(Size availableSize);
    protected virtual Size ArrangeOverride(Size finalSize);
    internal void RemoveChildren();
    internal void InvalidateTransform();
    internal IAnnotationComponent get_AnnotationComponent();
    private void OnLayoutUpdated(object sender, EventArgs args);
}
internal class MS.Internal.Annotations.Component.AnnotationComponentManager : DependencyObject {
    private Dictionary`2<IAttachedAnnotation, IList`1<IAnnotationComponent>> _attachedAnnotations;
    internal AnnotationComponentManager(AnnotationService service);
    internal void AddAttachedAnnotation(IAttachedAnnotation attachedAnnotation, bool reorder);
    internal void RemoveAttachedAnnotation(IAttachedAnnotation attachedAnnotation, bool reorder);
    private void AttachedAnnotationUpdateEventHandler(object sender, AttachedAnnotationChangedEventArgs e);
    private IAnnotationComponent FindComponent(IAttachedAnnotation attachedAnnotation);
    private void AddComponent(IAttachedAnnotation attachedAnnotation, IAnnotationComponent component, bool reorder);
    private void ModifyAttachedAnnotation(IAttachedAnnotation attachedAnnotation, object previousAttachedAnchor, AttachmentLevel previousAttachmentLevel);
    private void AddToAttachedAnnotations(IAttachedAnnotation attachedAnnotation, IAnnotationComponent component);
}
internal class MS.Internal.Annotations.Component.AnnotationHighlightLayer : HighlightLayer {
    [CompilerGeneratedAttribute]
private HighlightChangedEventHandler Changed;
    private List`1<HighlightSegment> _segments;
    private bool _isFixedContainer;
    internal Type OwnerType { get; }
    private bool IsFixedContainer { get; private set; }
    internal void AddRange(IHighlightRange highlightRange);
    internal void RemoveRange(IHighlightRange highlightRange);
    internal void ModifiedRange(IHighlightRange highlightRange);
    internal void ActivateRange(IHighlightRange highlightRange, bool activate);
    internal virtual object GetHighlightValue(StaticTextPointer textPosition, LogicalDirection direction);
    internal virtual bool IsContentHighlighted(StaticTextPointer staticTextPosition, LogicalDirection direction);
    internal virtual StaticTextPointer GetNextChangePosition(StaticTextPointer textPosition, LogicalDirection direction);
    internal virtual Type get_OwnerType();
    [CompilerGeneratedAttribute]
internal virtual void add_Changed(HighlightChangedEventHandler value);
    [CompilerGeneratedAttribute]
internal virtual void remove_Changed(HighlightChangedEventHandler value);
    private void ProcessOverlapingSegments(IHighlightRange highlightRange, ITextPointer& invalidateStart, ITextPointer& invalidateEnd);
    private ITextPointer GetNextForwardPosition(StaticTextPointer pos);
    private ITextPointer GetNextBackwardPosition(StaticTextPointer pos);
    private void GetSpannedSegments(ITextPointer start, ITextPointer end, Int32& startSeg, Int32& endSeg);
    private bool get_IsFixedContainer();
    private void set_IsFixedContainer(bool value);
}
internal class MS.Internal.Annotations.Component.HighlightComponent : Canvas {
    public static DependencyProperty HighlightBrushProperty;
    public static string HighlightResourceName;
    public static string ColorsContentName;
    public static string BackgroundAttributeName;
    public static string ActiveBackgroundAttributeName;
    private Color _background;
    private Color _selectedBackground;
    private TextAnchor _range;
    private IAttachedAnnotation _attachedAnnotation;
    private PresentationContext _presentationContext;
    private static XmlQualifiedName _name;
    private XmlQualifiedName _type;
    private int _priority;
    private bool _highlightContent;
    private bool _active;
    private bool _isDirty;
    private Color _defaultBackroundColor;
    private Color _defaultActiveBackgroundColor;
    public IList AttachedAnnotations { get; }
    public PresentationContext PresentationContext { get; public set; }
    public int ZOrder { get; public set; }
    public static XmlQualifiedName TypeName { get; }
    public Color DefaultBackground { get; public set; }
    public Color DefaultActiveBackground { get; public set; }
    unknown Brush HighlightBrush {public set; }
    public UIElement AnnotatedElement { get; }
    public bool IsDirty { get; public set; }
    private Color MS.Internal.Annotations.Component.IHighlightRange.Background { get; }
    private Color MS.Internal.Annotations.Component.IHighlightRange.SelectedBackground { get; }
    private TextAnchor MS.Internal.Annotations.Component.IHighlightRange.Range { get; }
    private int MS.Internal.Annotations.Component.IHighlightRange.Priority { get; }
    private bool MS.Internal.Annotations.Component.IHighlightRange.HighlightContent { get; }
    public HighlightComponent(int priority, bool highlightContent, XmlQualifiedName type);
    private static HighlightComponent();
    public sealed virtual IList get_AttachedAnnotations();
    public sealed virtual PresentationContext get_PresentationContext();
    public sealed virtual void set_PresentationContext(PresentationContext value);
    public sealed virtual int get_ZOrder();
    public sealed virtual void set_ZOrder(int value);
    public static XmlQualifiedName get_TypeName();
    public Color get_DefaultBackground();
    public void set_DefaultBackground(Color value);
    public Color get_DefaultActiveBackground();
    public void set_DefaultActiveBackground(Color value);
    public void set_HighlightBrush(Brush value);
    public sealed virtual UIElement get_AnnotatedElement();
    public sealed virtual bool get_IsDirty();
    public sealed virtual void set_IsDirty(bool value);
    public sealed virtual GeneralTransform GetDesiredTransform(GeneralTransform transform);
    public sealed virtual void AddAttachedAnnotation(IAttachedAnnotation attachedAnnotation);
    public sealed virtual void RemoveAttachedAnnotation(IAttachedAnnotation attachedAnnotation);
    public sealed virtual void ModifyAttachedAnnotation(IAttachedAnnotation attachedAnnotation, object previousAttachedAnchor, AttachmentLevel previousAttachmentLevel);
    public void Activate(bool active);
    private sealed virtual override void MS.Internal.Annotations.Component.IHighlightRange.AddChild(Shape child);
    private sealed virtual override void MS.Internal.Annotations.Component.IHighlightRange.RemoveChild(Shape child);
    private sealed virtual override Color MS.Internal.Annotations.Component.IHighlightRange.get_Background();
    private sealed virtual override Color MS.Internal.Annotations.Component.IHighlightRange.get_SelectedBackground();
    private sealed virtual override TextAnchor MS.Internal.Annotations.Component.IHighlightRange.get_Range();
    private sealed virtual override int MS.Internal.Annotations.Component.IHighlightRange.get_Priority();
    private sealed virtual override bool MS.Internal.Annotations.Component.IHighlightRange.get_HighlightContent();
    internal bool IsSelected(ITextRange selection);
    internal static void GetCargoColors(Annotation annot, Nullable`1& backgroundColor, Nullable`1& activeBackgroundColor);
    private ITextContainer CheckInputData(IAttachedAnnotation attachedAnnotation);
    private static Color GetColor(string color);
    private void GetColors(Annotation annot, Color& backgroundColor, Color& activeBackgroundColor);
    private void OnAnnotationUpdated(object sender, AnnotationResourceChangedEventArgs args);
    private void InvalidateChildren();
}
internal interface MS.Internal.Annotations.Component.IAnnotationComponent {
    public IList AttachedAnnotations { get; }
    public PresentationContext PresentationContext { get; public set; }
    public int ZOrder { get; public set; }
    public bool IsDirty { get; public set; }
    public UIElement AnnotatedElement { get; }
    public abstract virtual IList get_AttachedAnnotations();
    public abstract virtual PresentationContext get_PresentationContext();
    public abstract virtual void set_PresentationContext(PresentationContext value);
    public abstract virtual int get_ZOrder();
    public abstract virtual void set_ZOrder(int value);
    public abstract virtual bool get_IsDirty();
    public abstract virtual void set_IsDirty(bool value);
    public abstract virtual GeneralTransform GetDesiredTransform(GeneralTransform transform);
    public abstract virtual UIElement get_AnnotatedElement();
    public abstract virtual void AddAttachedAnnotation(IAttachedAnnotation attachedAnnotation);
    public abstract virtual void RemoveAttachedAnnotation(IAttachedAnnotation attachedAnnotation);
    public abstract virtual void ModifyAttachedAnnotation(IAttachedAnnotation attachedAnnotation, object previousAttachedAnchor, AttachmentLevel previousAttachmentLevel);
}
internal interface MS.Internal.Annotations.Component.IHighlightRange {
    public Color Background { get; }
    public Color SelectedBackground { get; }
    public TextAnchor Range { get; }
    public int Priority { get; }
    public bool HighlightContent { get; }
    public abstract virtual void AddChild(Shape child);
    public abstract virtual void RemoveChild(Shape child);
    public abstract virtual Color get_Background();
    public abstract virtual Color get_SelectedBackground();
    public abstract virtual TextAnchor get_Range();
    public abstract virtual int get_Priority();
    public abstract virtual bool get_HighlightContent();
}
internal class MS.Internal.Annotations.Component.MarkedHighlightComponent : Canvas {
    public static DependencyProperty MarkerBrushProperty;
    public static DependencyProperty StrokeThicknessProperty;
    internal static Color DefaultAnchorBackground;
    internal static Color DefaultMarkerColor;
    internal static Color DefaultActiveAnchorBackground;
    internal static Color DefaultActiveMarkerColor;
    internal static double MarkerStrokeThickness;
    internal static double ActiveMarkerStrokeThickness;
    internal static double MarkerVerticalSpace;
    private static Hashtable _documentHandlers;
    private byte _state;
    private HighlightComponent _highlightAnchor;
    private double _bodyHeight;
    private double _bottomTailHeight;
    private double _topTailHeight;
    private Path _leftMarker;
    private Path _rightMarker;
    private DependencyObject _DPHost;
    private static byte FocusFlag;
    private static byte FocusFlagComplement;
    private static byte SelectedFlag;
    private static byte SelectedFlagComplement;
    private IAttachedAnnotation _attachedAnnotation;
    private PresentationContext _presentationContext;
    private bool _isDirty;
    private ITextRange _selection;
    private UIElement _uiParent;
    public IList AttachedAnnotations { get; }
    public PresentationContext PresentationContext { get; public set; }
    public int ZOrder { get; public set; }
    public UIElement AnnotatedElement { get; }
    public bool IsDirty { get; public set; }
    unknown bool Focused {public set; }
    unknown Brush MarkerBrush {public set; }
    unknown double StrokeThickness {public set; }
    internal HighlightComponent HighlightAnchor { get; internal set; }
    public MarkedHighlightComponent(XmlQualifiedName type, DependencyObject host);
    private static MarkedHighlightComponent();
    public sealed virtual IList get_AttachedAnnotations();
    public sealed virtual PresentationContext get_PresentationContext();
    public sealed virtual void set_PresentationContext(PresentationContext value);
    public sealed virtual int get_ZOrder();
    public sealed virtual void set_ZOrder(int value);
    public sealed virtual UIElement get_AnnotatedElement();
    public sealed virtual bool get_IsDirty();
    public sealed virtual void set_IsDirty(bool value);
    public sealed virtual GeneralTransform GetDesiredTransform(GeneralTransform transform);
    public sealed virtual void AddAttachedAnnotation(IAttachedAnnotation attachedAnnotation);
    public sealed virtual void RemoveAttachedAnnotation(IAttachedAnnotation attachedAnnotation);
    public sealed virtual void ModifyAttachedAnnotation(IAttachedAnnotation attachedAnnotation, object previousAttachedAnchor, AttachmentLevel previousAttachmentLevel);
    public void set_Focused(bool value);
    public void set_MarkerBrush(Brush value);
    public void set_StrokeThickness(double value);
    internal void SetTabIndex(int index);
    private void SetMarkerTransform(Path marker, ITextPointer anchor, ITextPointer baseAnchor, int xScaleFactor);
    private void SetSelected(bool selected);
    private void RemoveHighlightMarkers();
    private void RegisterAnchor();
    private void CleanUpAnchor();
    private void SetState();
    private Path CreateMarker(Geometry geometry);
    private void RegisterComponent();
    private void UnregisterComponent();
    private void UpdateGeometry();
    private Geometry GetMarkerGeometry();
    private void CheckPosition(ITextPointer position);
    private void OnContainerGotFocus(object sender, KeyboardFocusChangedEventArgs args);
    private void OnContainerLostFocus(object sender, KeyboardFocusChangedEventArgs args);
    internal HighlightComponent get_HighlightAnchor();
    internal void set_HighlightAnchor(HighlightComponent value);
    private static FlowDirection GetTextFlowDirection(ITextPointer pointer);
    private static void OnSelectionChanged(object sender, EventArgs args);
    private static void OnMouseMove(object sender, MouseEventArgs args);
    private static void CheckAllHighlightRanges(ITextPointer pos);
}
internal abstract class MS.Internal.Annotations.Component.PresentationContext : object {
    public UIElement Host { get; }
    public PresentationContext EnclosingContext { get; }
    public abstract virtual UIElement get_Host();
    public abstract virtual PresentationContext get_EnclosingContext();
    public abstract virtual void AddToHost(IAnnotationComponent component);
    public abstract virtual void RemoveFromHost(IAnnotationComponent component, bool reorder);
    public abstract virtual void InvalidateTransform(IAnnotationComponent component);
    public abstract virtual void BringToFront(IAnnotationComponent component);
    public abstract virtual void SendToBack(IAnnotationComponent component);
}
internal interface MS.Internal.Annotations.IAttachedAnnotation {
    public object AttachedAnchor { get; }
    public object FullyAttachedAnchor { get; }
    public AttachmentLevel AttachmentLevel { get; }
    public DependencyObject Parent { get; }
    public Point AnchorPoint { get; }
    public AnnotationStore Store { get; }
    public abstract virtual object get_AttachedAnchor();
    public abstract virtual object get_FullyAttachedAnchor();
    public abstract virtual AttachmentLevel get_AttachmentLevel();
    public abstract virtual DependencyObject get_Parent();
    public abstract virtual Point get_AnchorPoint();
    public abstract virtual bool IsAnchorEqual(object o);
    public abstract virtual AnnotationStore get_Store();
}
internal interface MS.Internal.Annotations.INotifyPropertyChanged2 {
}
internal interface MS.Internal.Annotations.IOwnedObject {
    public bool Owned { get; public set; }
    public abstract virtual bool get_Owned();
    public abstract virtual void set_Owned(bool value);
}
[DefaultMemberAttribute("Item")]
internal class MS.Internal.Annotations.ObservableDictionary : object {
    [CompilerGeneratedAttribute]
private PropertyChangedEventHandler PropertyChanged;
    private Dictionary`2<string, string> _nameValues;
    public int Count { get; }
    public string Item { get; public set; }
    public bool IsReadOnly { get; }
    public ICollection`1<string> Keys { get; }
    public ICollection`1<string> Values { get; }
    public sealed virtual void Add(string key, string val);
    public sealed virtual void Clear();
    public sealed virtual bool ContainsKey(string key);
    public sealed virtual bool Remove(string key);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual IEnumerator`1<KeyValuePair`2<string, string>> GetEnumerator();
    public sealed virtual bool TryGetValue(string key, String& value);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.String>>.Add(KeyValuePair`2<string, string> pair);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.String>>.Contains(KeyValuePair`2<string, string> pair);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.String>>.Remove(KeyValuePair`2<string, string> pair);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.String>>.CopyTo(KeyValuePair`2[] target, int startIndex);
    public sealed virtual int get_Count();
    public sealed virtual string get_Item(string key);
    public sealed virtual void set_Item(string key, string value);
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual ICollection`1<string> get_Keys();
    public sealed virtual ICollection`1<string> get_Values();
    [CompilerGeneratedAttribute]
public sealed virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
    private void FireDictionaryChanged();
}
internal class MS.Internal.Annotations.Serializer : object {
    private XmlRootAttribute _attribute;
    private ConstructorInfo _ctor;
    public Serializer(Type type);
    public void Serialize(XmlWriter writer, object obj);
    public object Deserialize(XmlReader reader);
}
internal class MS.Internal.Annotations.Storage.StoreAnnotationsMap : object {
    private Dictionary`2<Guid, CachedAnnotation> _currentAnnotations;
    private AnnotationAuthorChangedEventHandler _authorChanged;
    private AnnotationResourceChangedEventHandler _anchorChanged;
    private AnnotationResourceChangedEventHandler _cargoChanged;
    internal StoreAnnotationsMap(AnnotationAuthorChangedEventHandler authorChanged, AnnotationResourceChangedEventHandler anchorChanged, AnnotationResourceChangedEventHandler cargoChanged);
    public void AddAnnotation(Annotation annotation, bool dirty);
    public void RemoveAnnotation(Guid id);
    public Dictionary`2<Guid, Annotation> FindAnnotations(ContentLocator anchorLocator);
    public Dictionary`2<Guid, Annotation> FindAnnotations();
    public Annotation FindAnnotation(Guid id);
    public List`1<Annotation> FindDirtyAnnotations();
    public void ValidateDirtyAnnotations();
    private void OnAnchorChanged(object sender, AnnotationResourceChangedEventArgs args);
    private void OnCargoChanged(object sender, AnnotationResourceChangedEventArgs args);
    private void OnAuthorChanged(object sender, AnnotationAuthorChangedEventArgs args);
}
internal class MS.Internal.Annotations.XmlElementCollection : ObservableCollection`1<XmlElement> {
    private Dictionary`2<XmlDocument, int> _xmlDocsRefCounts;
    protected virtual void ClearItems();
    protected virtual void RemoveItem(int index);
    protected virtual void InsertItem(int index, XmlElement item);
    protected virtual void SetItem(int index, XmlElement item);
    private void UnregisterForElement(XmlElement element);
    private void RegisterForElement(XmlElement element);
    private void OnNodeChanged(object sender, XmlNodeChangedEventArgs args);
    private void OnCollectionReset();
}
internal enum MS.Internal.AppModel.AppCommands : Enum {
    public int value__;
    public static AppCommands Edit_Cut;
    public static AppCommands Edit_Copy;
    public static AppCommands Edit_Paste;
    public static AppCommands Edit_SelectAll;
    public static AppCommands Edit_Find;
    public static AppCommands Edit_Digitalsignatures;
    public static AppCommands Edit_Digitalsignatures_SignDocument;
    public static AppCommands Edit_Digitalsignatures_RequestSignature;
    public static AppCommands Edit_Digitalsignatures_ViewSignature;
    public static AppCommands Edit_Permission;
    public static AppCommands Edit_Permission_Set;
    public static AppCommands Edit_Permission_View;
    public static AppCommands Edit_Permission_Restrict;
    public static AppCommands View_StatusBar;
    public static AppCommands View_Stop;
    public static AppCommands View_Refresh;
    public static AppCommands View_FullScreen;
    public static AppCommands View_Zoom;
    public static AppCommands View_Zoom_In;
    public static AppCommands View_Zoom_Out;
    public static AppCommands View_Zoom_400;
    public static AppCommands View_Zoom_250;
    public static AppCommands View_Zoom_150;
    public static AppCommands View_Zoom_100;
    public static AppCommands View_Zoom_75;
    public static AppCommands View_Zoom_50;
    public static AppCommands View_Zoom_25;
    public static AppCommands View_Zoom_PageWidth;
    public static AppCommands View_Zoom_WholePage;
    public static AppCommands View_Zoom_TwoPages;
    public static AppCommands View_Zoom_Thumbnails;
}
internal enum MS.Internal.AppModel.AppMenus : Enum {
    public int value__;
    public static AppMenus EditMenu;
    public static AppMenus ViewMenu;
}
internal static class MS.Internal.AppModel.AppModelKnownContentFactory : object {
    internal static object BamlConverter(Stream stream, Uri baseUri, bool canUseTopLevelBrowser, bool sandboxExternalContent, bool allowAsync, bool isJournalNavigation, XamlReader& asyncObjectConverter);
    internal static object XamlConverter(Stream stream, Uri baseUri, bool canUseTopLevelBrowser, bool sandboxExternalContent, bool allowAsync, bool isJournalNavigation, XamlReader& asyncObjectConverter);
    private static void OnParserComplete(object sender, AsyncCompletedEventArgs args);
    internal static object HtmlXappConverter(Stream stream, Uri baseUri, bool canUseTopLevelBrowser, bool sandboxExternalContent, bool allowAsync, bool isJournalNavigation, XamlReader& asyncObjectConverter);
}
internal static class MS.Internal.AppModel.AppSecurityManager : object {
    private static string RefererHeader;
    private static string BrowserOpenCommandLookupKey;
    private static object _lockObj;
    private static IInternetSecurityManager _secMgr;
    private static SecurityMgrSite _secMgrSite;
    private static AppSecurityManager();
    internal static void SafeLaunchBrowserDemandWhenUnsafe(Uri originatingUri, Uri destinationUri, bool fIsTopLevel);
    internal static LaunchResult SafeLaunchBrowserOnlyIfPossible(Uri originatingUri, Uri destinationUri, bool fIsTopLevel);
    internal static LaunchResult SafeLaunchBrowserOnlyIfPossible(Uri originatingUri, Uri destinationUri, string targetName, bool fIsTopLevel);
    internal static void UnsafeLaunchBrowser(Uri uri, string targetFrame);
    internal static void ShellExecuteDefaultBrowser(Uri uri);
    private static string GetHeaders(Uri destinationUri);
    private static LaunchResult CanNavigateToUrlWithZoneCheck(Uri originatingUri, Uri destinationUri);
    private static LaunchResult CheckBlockNavigation(Uri originatingUri, Uri destinationUri, bool fEnabled);
    private static bool IsZoneElevationSettingPrompt(Uri target);
    private static void EnsureSecurityManager();
    internal static void ClearSecurityManager();
    internal static int MapUrlToZone(Uri url);
}
internal class MS.Internal.AppModel.BamlStream : Stream {
    private SecurityCriticalDataForSet`1<Assembly> _assembly;
    private Stream _stream;
    private Assembly System.Windows.Markup.IStreamInfo.Assembly { get; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    internal BamlStream(Stream stream, Assembly assembly);
    private sealed virtual override Assembly System.Windows.Markup.IStreamInfo.get_Assembly();
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual void Close();
    public virtual int EndRead(IAsyncResult asyncResult);
    public virtual void EndWrite(IAsyncResult asyncResult);
    public virtual bool Equals(object obj);
    public virtual void Flush();
    public virtual int GetHashCode();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual int ReadByte();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual string ToString();
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void WriteByte(byte value);
}
internal static class MS.Internal.AppModel.CLSID : object {
    public static string EnumerableObjectCollection;
    public static string FileOpenDialog;
    public static string FileSaveDialog;
    public static string ShellLink;
    public static string TaskbarList;
    public static string WebBrowser;
    public static string DestinationList;
    public static string ApplicationDestinations;
    public static string ApplicationDocumentLists;
}
internal class MS.Internal.AppModel.COMDLG_FILTERSPEC : ValueType {
    public string pszName;
    public string pszSpec;
}
internal class MS.Internal.AppModel.CommandWithArgument : object {
    private object _argument;
    private SecurityCriticalDataForSet`1<RoutedCommand> _command;
    public RoutedCommand Command { get; }
    public CommandWithArgument(RoutedCommand command);
    public CommandWithArgument(RoutedCommand command, object argument);
    public bool Execute(IInputElement target, object argument);
    public bool QueryEnabled(IInputElement target, object argument);
    public RoutedCommand get_Command();
}
internal class MS.Internal.AppModel.ContentFilePart : PackagePart {
    private string _fullPath;
    internal ContentFilePart(Package container, Uri uri);
    protected virtual Stream GetStreamCore(FileMode mode, FileAccess access);
    protected virtual string GetContentTypeCore();
    private Uri GetEntryAssemblyLocation();
    private Stream CriticalOpenFile(string filename);
}
internal abstract class MS.Internal.AppModel.CustomJournalStateInternal : object {
    internal virtual void PrepareForSerialization();
}
internal class MS.Internal.AppModel.DataStreams : object {
    [ThreadStaticAttribute]
private static BinaryFormatter _formatter;
    private HybridDictionary _subStreams;
    private HybridDictionary _customJournaledObjects;
    internal bool HasAnyData { get; }
    private BinaryFormatter Formatter { get; }
    internal bool get_HasAnyData();
    private bool HasSubStreams(object key);
    private ArrayList GetSubStreams(object key);
    private ArrayList SaveSubStreams(UIElement element);
    private void SaveState(object node);
    internal void PrepareForSerialization();
    private void LoadSubStreams(UIElement element, ArrayList subStreams);
    private void LoadState(object node);
    private void WalkLogicalTree(object node, NodeOperation operation);
    internal void Save(object root);
    internal void Load(object root);
    internal void Clear();
    private BinaryFormatter get_Formatter();
}
internal enum MS.Internal.AppModel.EditingCommandIds : Enum {
    public UInt32 value__;
    public static EditingCommandIds Backspace;
    public static EditingCommandIds Delete;
}
[FlagsAttribute]
internal enum MS.Internal.AppModel.HostingFlags : Enum {
    public int value__;
    public static HostingFlags hfHostedInIE;
    public static HostingFlags hfHostedInWebOC;
    public static HostingFlags hfHostedInIEorWebOC;
    public static HostingFlags hfHostedInMozilla;
    public static HostingFlags hfHostedInFrame;
    public static HostingFlags hfIsBrowserLowIntegrityProcess;
    public static HostingFlags hfInDebugMode;
}
[GuidAttribute("12337d35-94c6-48a0-bce7-6a9c69d4d600")]
[InterfaceTypeAttribute("1")]
internal interface MS.Internal.AppModel.IApplicationDestinations {
    public abstract virtual void SetAppID(string pszAppID);
    public abstract virtual void RemoveDestination(object punk);
    public abstract virtual void RemoveAllDestinations();
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("3c594f9f-9f30-47a1-979a-c9e83d3d0a06")]
internal interface MS.Internal.AppModel.IApplicationDocumentLists {
    public abstract virtual void SetAppID(string pszAppID);
    public abstract virtual object GetList(ADLT listtype, UInt32 cItemsDesired, Guid& riid);
}
internal static class MS.Internal.AppModel.IconHelper : object {
    private static Size s_smallIconSize;
    private static Size s_iconSize;
    private static int s_systemBitDepth;
    private static void EnsureSystemMetrics();
    public static void GetDefaultIconHandles(IconHandle& largeIconHandle, IconHandle& smallIconHandle);
    public static void GetIconHandlesFromImageSource(ImageSource image, IconHandle& largeIconHandle, IconHandle& smallIconHandle);
    public static IconHandle CreateIconHandleFromImageSource(ImageSource image, Size size);
    private static BitmapSource GenerateBitmapSource(ImageSource img, Size renderSize);
    private static IconHandle CreateIconHandleFromBitmapFrame(BitmapFrame sourceBitmapFrame);
    internal static IconHandle CreateIconCursor(Byte[] colorArray, int width, int height, int xHotspot, int yHotspot, bool isIcon);
    private static Byte[] GenerateMaskArray(int width, int height, Byte[] colorArray);
    internal static int AlignToBytes(double original, int nBytesCount);
    private static int MatchImage(BitmapFrame frame, Size size, int bpp);
    private static int MyAbs(int valueHave, int valueWant, bool fPunish);
    private static BitmapFrame GetBestMatch(ReadOnlyCollection`1<BitmapFrame> frames, Size size);
}
internal interface MS.Internal.AppModel.IContentContainer {
    public abstract virtual void OnContentReady(ContentType contentType, object content, Uri uri, object navState);
    public abstract virtual void OnNavigationProgress(Uri uri, long bytesRead, long maxBytes);
    public abstract virtual void OnStreamClosed(Uri uri);
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("6332debf-87b5-4670-90c0-5e57b408a49e")]
internal interface MS.Internal.AppModel.ICustomDestinationList {
    public abstract virtual void SetAppID(string pszAppID);
    public abstract virtual object BeginList(UInt32& pcMaxSlots, Guid& riid);
    public abstract virtual HRESULT AppendCategory(string pszCategory, IObjectArray poa);
    public abstract virtual void AppendKnownCategory(KDC category);
    public abstract virtual HRESULT AddUserTasks(IObjectArray poa);
    public abstract virtual void CommitList();
    public abstract virtual object GetRemovedDestinations(Guid& riid);
    public abstract virtual void DeleteList(string pszAppID);
    public abstract virtual void AbortList();
}
internal interface MS.Internal.AppModel.IDownloader {
    public NavigationService Downloader { get; }
    public abstract virtual NavigationService get_Downloader();
    [CompilerGeneratedAttribute]
public abstract virtual void add_ContentRendered(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_ContentRendered(EventHandler value);
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("000214F2-0000-0000-C000-000000000046")]
internal interface MS.Internal.AppModel.IEnumIDList {
    public abstract virtual HRESULT Next(UInt32 celt, IntPtr& rgelt, Int32& pceltFetched);
    public abstract virtual HRESULT Skip(UInt32 celt);
    public abstract virtual void Reset();
    public abstract virtual IEnumIDList Clone();
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("42f85136-db7e-439c-85f1-e4075d135fc8")]
internal interface MS.Internal.AppModel.IFileDialog {
    public abstract virtual HRESULT Show(IntPtr parent);
    public abstract virtual void SetFileTypes(UInt32 cFileTypes, COMDLG_FILTERSPEC[] rgFilterSpec);
    public abstract virtual void SetFileTypeIndex(UInt32 iFileType);
    public abstract virtual UInt32 GetFileTypeIndex();
    public abstract virtual UInt32 Advise(IFileDialogEvents pfde);
    public abstract virtual void Unadvise(UInt32 dwCookie);
    public abstract virtual void SetOptions(FOS fos);
    public abstract virtual FOS GetOptions();
    public abstract virtual void SetDefaultFolder(IShellItem psi);
    public abstract virtual void SetFolder(IShellItem psi);
    public abstract virtual IShellItem GetFolder();
    public abstract virtual IShellItem GetCurrentSelection();
    public abstract virtual void SetFileName(string pszName);
    public abstract virtual string GetFileName();
    public abstract virtual void SetTitle(string pszTitle);
    public abstract virtual void SetOkButtonLabel(string pszText);
    public abstract virtual void SetFileNameLabel(string pszLabel);
    public abstract virtual IShellItem GetResult();
    public abstract virtual void AddPlace(IShellItem psi, FDAP alignment);
    public abstract virtual void SetDefaultExtension(string pszDefaultExtension);
    public abstract virtual void Close(int hr);
    public abstract virtual void SetClientGuid(Guid& guid);
    public abstract virtual void ClearClientData();
    public abstract virtual void SetFilter(object pFilter);
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("973510DB-7D7F-452B-8975-74A85828D354")]
internal interface MS.Internal.AppModel.IFileDialogEvents {
    public abstract virtual HRESULT OnFileOk(IFileDialog pfd);
    public abstract virtual HRESULT OnFolderChanging(IFileDialog pfd, IShellItem psiFolder);
    public abstract virtual HRESULT OnFolderChange(IFileDialog pfd);
    public abstract virtual HRESULT OnSelectionChange(IFileDialog pfd);
    public abstract virtual HRESULT OnShareViolation(IFileDialog pfd, IShellItem psi, FDESVR& pResponse);
    public abstract virtual HRESULT OnTypeChange(IFileDialog pfd);
    public abstract virtual HRESULT OnOverwrite(IFileDialog pfd, IShellItem psi, FDEOR& pResponse);
}
[GuidAttribute("d57c7288-d4ad-4768-be02-9d969532d960")]
[InterfaceTypeAttribute("1")]
internal interface MS.Internal.AppModel.IFileOpenDialog {
    public abstract virtual HRESULT Show(IntPtr parent);
    public abstract virtual void SetFileTypes(UInt32 cFileTypes, COMDLG_FILTERSPEC[] rgFilterSpec);
    public abstract virtual void SetFileTypeIndex(UInt32 iFileType);
    public abstract virtual UInt32 GetFileTypeIndex();
    public abstract virtual UInt32 Advise(IFileDialogEvents pfde);
    public abstract virtual void Unadvise(UInt32 dwCookie);
    public abstract virtual void SetOptions(FOS fos);
    public abstract virtual FOS GetOptions();
    public abstract virtual void SetDefaultFolder(IShellItem psi);
    public abstract virtual void SetFolder(IShellItem psi);
    public abstract virtual IShellItem GetFolder();
    public abstract virtual IShellItem GetCurrentSelection();
    public abstract virtual void SetFileName(string pszName);
    public abstract virtual void GetFileName();
    public abstract virtual void SetTitle(string pszTitle);
    public abstract virtual void SetOkButtonLabel(string pszText);
    public abstract virtual void SetFileNameLabel(string pszLabel);
    public abstract virtual IShellItem GetResult();
    public abstract virtual void AddPlace(IShellItem psi, FDAP fdcp);
    public abstract virtual void SetDefaultExtension(string pszDefaultExtension);
    public abstract virtual void Close(int hr);
    public abstract virtual void SetClientGuid(Guid& guid);
    public abstract virtual void ClearClientData();
    public abstract virtual void SetFilter(object pFilter);
    public abstract virtual IShellItemArray GetResults();
    public abstract virtual IShellItemArray GetSelectedItems();
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("84bccd23-5fde-4cdb-aea4-af64b83d78ab")]
internal interface MS.Internal.AppModel.IFileSaveDialog {
    public abstract virtual HRESULT Show(IntPtr parent);
    public abstract virtual void SetFileTypes(UInt32 cFileTypes, COMDLG_FILTERSPEC[] rgFilterSpec);
    public abstract virtual void SetFileTypeIndex(UInt32 iFileType);
    public abstract virtual UInt32 GetFileTypeIndex();
    public abstract virtual UInt32 Advise(IFileDialogEvents pfde);
    public abstract virtual void Unadvise(UInt32 dwCookie);
    public abstract virtual void SetOptions(FOS fos);
    public abstract virtual FOS GetOptions();
    public abstract virtual void SetDefaultFolder(IShellItem psi);
    public abstract virtual void SetFolder(IShellItem psi);
    public abstract virtual IShellItem GetFolder();
    public abstract virtual IShellItem GetCurrentSelection();
    public abstract virtual void SetFileName(string pszName);
    public abstract virtual void GetFileName();
    public abstract virtual void SetTitle(string pszTitle);
    public abstract virtual void SetOkButtonLabel(string pszText);
    public abstract virtual void SetFileNameLabel(string pszLabel);
    public abstract virtual IShellItem GetResult();
    public abstract virtual void AddPlace(IShellItem psi, FDAP fdcp);
    public abstract virtual void SetDefaultExtension(string pszDefaultExtension);
    public abstract virtual void Close(int hr);
    public abstract virtual void SetClientGuid(Guid& guid);
    public abstract virtual void ClearClientData();
    public abstract virtual void SetFilter(object pFilter);
    public abstract virtual void SetSaveAsItem(IShellItem psi);
    public abstract virtual void SetProperties(object pStore);
    public abstract virtual void SetCollectedProperties(object pList, int fAppendDefault);
    public abstract virtual object GetProperties();
    public abstract virtual void ApplyProperties(IShellItem psi, object pStore, IntPtr& hwnd, object pSink);
}
internal static class MS.Internal.AppModel.IID : object {
    public static string Accessible;
    public static string EnumIdList;
    public static string EnumObjects;
    public static string FileDialog;
    public static string FileDialogEvents;
    public static string FileOpenDialog;
    public static string FileSaveDialog;
    public static string ModalWindow;
    public static string ObjectArray;
    public static string ObjectCollection;
    public static string PropertyStore;
    public static string ShellFolder;
    public static string ShellLink;
    public static string ShellItem;
    public static string ShellItem2;
    public static string ShellItemArray;
    public static string TaskbarList;
    public static string TaskbarList2;
    public static string Unknown;
    public static string ApplicationDestinations;
    public static string ApplicationDocumentLists;
    public static string CustomDestinationList;
    public static string ObjectWithAppUserModelId;
    public static string ObjectWithProgId;
    public static string TaskbarList3;
    public static string TaskbarList4;
}
internal interface MS.Internal.AppModel.IJournalNavigationScopeHost {
    public NavigationService NavigationService { get; }
    public abstract virtual NavigationService get_NavigationService();
    public abstract virtual void VerifyContextAndObjectState();
    public abstract virtual void OnJournalAvailable();
    public abstract virtual bool GoBackOverride();
    public abstract virtual bool GoForwardOverride();
}
internal interface MS.Internal.AppModel.IJournalState {
    public abstract virtual CustomJournalStateInternal GetJournalState(JournalReason journalReason);
    public abstract virtual void RestoreJournalState(CustomJournalStateInternal state);
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("b4db1657-70d7-485e-8e3e-6fcb5a5c1802")]
internal interface MS.Internal.AppModel.IModalWindow {
    public abstract virtual HRESULT Show(IntPtr parent);
}
[GuidAttribute("1f681651-1024-4798-af36-119bbe5e5665")]
[InterfaceTypeAttribute("1")]
internal interface MS.Internal.AppModel.INativeProgressPage {
    public abstract virtual HRESULT Show();
    public abstract virtual HRESULT Hide();
    public abstract virtual HRESULT ShowProgressMessage(string message);
    public abstract virtual HRESULT SetApplicationName(string appName);
    public abstract virtual HRESULT SetPublisherName(string publisherName);
    public abstract virtual HRESULT OnDownloadProgress(ulong bytesDownloaded, ulong bytesTotal);
}
internal interface MS.Internal.AppModel.INavigator {
    public bool CanGoForward { get; }
    public bool CanGoBack { get; }
    public IEnumerable BackStack { get; }
    public IEnumerable ForwardStack { get; }
    public abstract virtual JournalNavigationScope GetJournal(bool create);
    public abstract virtual bool get_CanGoForward();
    public abstract virtual bool get_CanGoBack();
    public abstract virtual void GoForward();
    public abstract virtual void GoBack();
    public abstract virtual void AddBackEntry(CustomContentState state);
    public abstract virtual JournalEntry RemoveBackEntry();
    public abstract virtual IEnumerable get_BackStack();
    public abstract virtual IEnumerable get_ForwardStack();
}
internal interface MS.Internal.AppModel.INavigatorBase {
    public Uri Source { get; public set; }
    public Uri CurrentSource { get; }
    public object Content { get; public set; }
    public abstract virtual Uri get_Source();
    public abstract virtual void set_Source(Uri value);
    public abstract virtual Uri get_CurrentSource();
    public abstract virtual object get_Content();
    public abstract virtual void set_Content(object value);
    public abstract virtual bool Navigate(Uri source);
    public abstract virtual bool Navigate(Uri source, object extraData);
    public abstract virtual bool Navigate(object content);
    public abstract virtual bool Navigate(object content, object extraData);
    public abstract virtual void StopLoading();
    public abstract virtual void Refresh();
    [CompilerGeneratedAttribute]
public abstract virtual void add_Navigating(NavigatingCancelEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Navigating(NavigatingCancelEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_NavigationProgress(NavigationProgressEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_NavigationProgress(NavigationProgressEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_NavigationFailed(NavigationFailedEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_NavigationFailed(NavigationFailedEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_Navigated(NavigatedEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Navigated(NavigatedEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_LoadCompleted(LoadCompletedEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_LoadCompleted(LoadCompletedEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_NavigationStopped(NavigationStoppedEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_NavigationStopped(NavigationStoppedEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_FragmentNavigation(FragmentNavigationEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_FragmentNavigation(FragmentNavigationEventHandler value);
}
internal interface MS.Internal.AppModel.INavigatorImpl {
    public abstract virtual void OnSourceUpdatedFromNavService(bool journalOrCancel);
    public abstract virtual Visual FindRootViewer();
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("92CA9DCD-5622-4bba-A805-5E9F541BD8C9")]
internal interface MS.Internal.AppModel.IObjectArray {
    public abstract virtual UInt32 GetCount();
    public abstract virtual object GetAt(UInt32 uiIndex, Guid& riid);
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("92CA9DCD-5622-4bba-A805-5E9F541BD8C9")]
internal interface MS.Internal.AppModel.IObjectCollection {
    public abstract virtual UInt32 GetCount();
    public abstract virtual object GetAt(UInt32 uiIndex, Guid& riid);
    public abstract virtual void AddObject(object punk);
    public abstract virtual void AddFromArray(IObjectArray poaSource);
    public abstract virtual void RemoveObjectAt(UInt32 uiIndex);
    public abstract virtual void Clear();
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("36db0196-9665-46d1-9ba7-d3709eecf9ed")]
internal interface MS.Internal.AppModel.IObjectWithAppUserModelId {
    public abstract virtual void SetAppID(string pszAppID);
    public abstract virtual string GetAppID();
}
[GuidAttribute("71e806fb-8dee-46fc-bf8c-7748a8a1ae13")]
[InterfaceTypeAttribute("1")]
internal interface MS.Internal.AppModel.IObjectWithProgId {
    public abstract virtual void SetProgID(string pszProgID);
    public abstract virtual string GetProgID();
}
internal interface MS.Internal.AppModel.IProgressPage2 {
    public abstract virtual void ShowProgressMessage(string message);
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("886d8eeb-8cf2-4446-8d02-cdba1dbdcf99")]
internal interface MS.Internal.AppModel.IPropertyStore {
    public abstract virtual UInt32 GetCount();
    public abstract virtual PKEY GetAt(UInt32 iProp);
    public abstract virtual void GetValue(PKEY& pkey, PROPVARIANT pv);
    public abstract virtual void SetValue(PKEY& pkey, PROPVARIANT pv);
    public abstract virtual void Commit();
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("000214E6-0000-0000-C000-000000000046")]
internal interface MS.Internal.AppModel.IShellFolder {
    public abstract virtual void ParseDisplayName(IntPtr hwnd, IBindCtx pbc, string pszDisplayName, Int32& pchEaten, IntPtr& ppidl, UInt32& pdwAttributes);
    public abstract virtual IEnumIDList EnumObjects(IntPtr hwnd, SHCONTF grfFlags);
    public abstract virtual object BindToObject(IntPtr pidl, IBindCtx pbc, Guid& riid);
    public abstract virtual object BindToStorage(IntPtr pidl, IBindCtx pbc, Guid& riid);
    public abstract virtual HRESULT CompareIDs(IntPtr lParam, IntPtr pidl1, IntPtr pidl2);
    public abstract virtual object CreateViewObject(IntPtr hwndOwner, Guid& riid);
    public abstract virtual void GetAttributesOf(UInt32 cidl, IntPtr apidl, SFGAO& rgfInOut);
    public abstract virtual object GetUIObjectOf(IntPtr hwndOwner, UInt32 cidl, IntPtr apidl, Guid& riid, UInt32& rgfReserved);
    public abstract virtual void GetDisplayNameOf(IntPtr pidl, SHGDN uFlags, IntPtr& pName);
    public abstract virtual void SetNameOf(IntPtr hwnd, IntPtr pidl, string pszName, SHGDN uFlags, IntPtr& ppidlOut);
}
[GuidAttribute("43826d1e-e718-42ee-bc55-a1e261c37bfe")]
[InterfaceTypeAttribute("1")]
internal interface MS.Internal.AppModel.IShellItem {
    public abstract virtual object BindToHandler(IBindCtx pbc, Guid& bhid, Guid& riid);
    public abstract virtual IShellItem GetParent();
    public abstract virtual string GetDisplayName(SIGDN sigdnName);
    public abstract virtual UInt32 GetAttributes(SFGAO sfgaoMask);
    public abstract virtual int Compare(IShellItem psi, SICHINT hint);
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("7e9fb0d3-919f-4307-ab2e-9b1860310c93")]
internal interface MS.Internal.AppModel.IShellItem2 {
    public abstract virtual object BindToHandler(IBindCtx pbc, Guid& bhid, Guid& riid);
    public abstract virtual IShellItem GetParent();
    public abstract virtual string GetDisplayName(SIGDN sigdnName);
    public abstract virtual SFGAO GetAttributes(SFGAO sfgaoMask);
    public abstract virtual int Compare(IShellItem psi, SICHINT hint);
    public abstract virtual object GetPropertyStore(GPS flags, Guid& riid);
    public abstract virtual object GetPropertyStoreWithCreateObject(GPS flags, object punkCreateObject, Guid& riid);
    public abstract virtual object GetPropertyStoreForKeys(IntPtr rgKeys, UInt32 cKeys, GPS flags, Guid& riid);
    public abstract virtual object GetPropertyDescriptionList(IntPtr keyType, Guid& riid);
    public abstract virtual void Update(IBindCtx pbc);
    public abstract virtual void GetProperty(IntPtr key, PROPVARIANT pv);
    public abstract virtual Guid GetCLSID(IntPtr key);
    public abstract virtual FILETIME GetFileTime(IntPtr key);
    public abstract virtual int GetInt32(IntPtr key);
    public abstract virtual string GetString(IntPtr key);
    public abstract virtual UInt32 GetUInt32(IntPtr key);
    public abstract virtual ulong GetUInt64(IntPtr key);
    public abstract virtual bool GetBool(IntPtr key);
}
[GuidAttribute("B63EA76D-1F85-456F-A19C-48159EFA858B")]
[InterfaceTypeAttribute("1")]
internal interface MS.Internal.AppModel.IShellItemArray {
    public abstract virtual object BindToHandler(IBindCtx pbc, Guid& rbhid, Guid& riid);
    public abstract virtual object GetPropertyStore(int flags, Guid& riid);
    public abstract virtual object GetPropertyDescriptionList(PKEY& keyType, Guid& riid);
    public abstract virtual UInt32 GetAttributes(SIATTRIBFLAGS dwAttribFlags, UInt32 sfgaoMask);
    public abstract virtual UInt32 GetCount();
    public abstract virtual IShellItem GetItemAt(UInt32 dwIndex);
    public abstract virtual object EnumItems();
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("000214F9-0000-0000-C000-000000000046")]
internal interface MS.Internal.AppModel.IShellLinkW {
    public abstract virtual void GetPath(StringBuilder pszFile, int cchMaxPath, WIN32_FIND_DATAW pfd, SLGP fFlags);
    public abstract virtual IntPtr GetIDList();
    public abstract virtual void SetIDList(IntPtr pidl);
    public abstract virtual void GetDescription(StringBuilder pszFile, int cchMaxName);
    public abstract virtual void SetDescription(string pszName);
    public abstract virtual void GetWorkingDirectory(StringBuilder pszDir, int cchMaxPath);
    public abstract virtual void SetWorkingDirectory(string pszDir);
    public abstract virtual void GetArguments(StringBuilder pszArgs, int cchMaxPath);
    public abstract virtual void SetArguments(string pszArgs);
    public abstract virtual short GetHotKey();
    public abstract virtual void SetHotKey(short wHotKey);
    public abstract virtual UInt32 GetShowCmd();
    public abstract virtual void SetShowCmd(UInt32 iShowCmd);
    public abstract virtual void GetIconLocation(StringBuilder pszIconPath, int cchIconPath, Int32& piIcon);
    public abstract virtual void SetIconLocation(string pszIconPath, int iIcon);
    public abstract virtual void SetRelativePath(string pszPathRel, UInt32 dwReserved);
    public abstract virtual void Resolve(IntPtr hwnd, UInt32 fFlags);
    public abstract virtual void SetPath(string pszFile);
}
[GuidAttribute("56FDF342-FD6D-11d0-958A-006097C9A090")]
[InterfaceTypeAttribute("1")]
internal interface MS.Internal.AppModel.ITaskbarList {
    public abstract virtual void HrInit();
    public abstract virtual void AddTab(IntPtr hwnd);
    public abstract virtual void DeleteTab(IntPtr hwnd);
    public abstract virtual void ActivateTab(IntPtr hwnd);
    public abstract virtual void SetActiveAlt(IntPtr hwnd);
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("602D4995-B13A-429b-A66E-1935E44F4317")]
internal interface MS.Internal.AppModel.ITaskbarList2 {
    public abstract virtual void HrInit();
    public abstract virtual void AddTab(IntPtr hwnd);
    public abstract virtual void DeleteTab(IntPtr hwnd);
    public abstract virtual void ActivateTab(IntPtr hwnd);
    public abstract virtual void SetActiveAlt(IntPtr hwnd);
    public abstract virtual void MarkFullscreenWindow(IntPtr hwnd, bool fFullscreen);
}
[GuidAttribute("ea1afb91-9e28-4b86-90e9-9e9f8a5eefaf")]
[InterfaceTypeAttribute("1")]
internal interface MS.Internal.AppModel.ITaskbarList3 {
    public abstract virtual void HrInit();
    public abstract virtual void AddTab(IntPtr hwnd);
    public abstract virtual void DeleteTab(IntPtr hwnd);
    public abstract virtual void ActivateTab(IntPtr hwnd);
    public abstract virtual void SetActiveAlt(IntPtr hwnd);
    public abstract virtual void MarkFullscreenWindow(IntPtr hwnd, bool fFullscreen);
    public abstract virtual HRESULT SetProgressValue(IntPtr hwnd, ulong ullCompleted, ulong ullTotal);
    public abstract virtual HRESULT SetProgressState(IntPtr hwnd, TBPF tbpFlags);
    public abstract virtual HRESULT RegisterTab(IntPtr hwndTab, IntPtr hwndMDI);
    public abstract virtual HRESULT UnregisterTab(IntPtr hwndTab);
    public abstract virtual HRESULT SetTabOrder(IntPtr hwndTab, IntPtr hwndInsertBefore);
    public abstract virtual HRESULT SetTabActive(IntPtr hwndTab, IntPtr hwndMDI, UInt32 dwReserved);
    public abstract virtual HRESULT ThumbBarAddButtons(IntPtr hwnd, UInt32 cButtons, THUMBBUTTON[] pButtons);
    public abstract virtual HRESULT ThumbBarUpdateButtons(IntPtr hwnd, UInt32 cButtons, THUMBBUTTON[] pButtons);
    public abstract virtual HRESULT ThumbBarSetImageList(IntPtr hwnd, object himl);
    public abstract virtual HRESULT SetOverlayIcon(IntPtr hwnd, IconHandle hIcon, string pszDescription);
    public abstract virtual HRESULT SetThumbnailTooltip(IntPtr hwnd, string pszTip);
    public abstract virtual HRESULT SetThumbnailClip(IntPtr hwnd, RefRECT prcClip);
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("ea1afb91-9e28-4b86-90e9-9e9f8a5eefaf")]
internal interface MS.Internal.AppModel.ITaskbarList4 {
    public abstract virtual void HrInit();
    public abstract virtual void AddTab(IntPtr hwnd);
    public abstract virtual void DeleteTab(IntPtr hwnd);
    public abstract virtual void ActivateTab(IntPtr hwnd);
    public abstract virtual void SetActiveAlt(IntPtr hwnd);
    public abstract virtual void MarkFullscreenWindow(IntPtr hwnd, bool fFullscreen);
    public abstract virtual HRESULT SetProgressValue(IntPtr hwnd, ulong ullCompleted, ulong ullTotal);
    public abstract virtual HRESULT SetProgressState(IntPtr hwnd, TBPF tbpFlags);
    public abstract virtual HRESULT RegisterTab(IntPtr hwndTab, IntPtr hwndMDI);
    public abstract virtual HRESULT UnregisterTab(IntPtr hwndTab);
    public abstract virtual HRESULT SetTabOrder(IntPtr hwndTab, IntPtr hwndInsertBefore);
    public abstract virtual HRESULT SetTabActive(IntPtr hwndTab, IntPtr hwndMDI, UInt32 dwReserved);
    public abstract virtual HRESULT ThumbBarAddButtons(IntPtr hwnd, UInt32 cButtons, THUMBBUTTON[] pButtons);
    public abstract virtual HRESULT ThumbBarUpdateButtons(IntPtr hwnd, UInt32 cButtons, THUMBBUTTON[] pButtons);
    public abstract virtual HRESULT ThumbBarSetImageList(IntPtr hwnd, object himl);
    public abstract virtual HRESULT SetOverlayIcon(IntPtr hwnd, IconHandle hIcon, string pszDescription);
    public abstract virtual HRESULT SetThumbnailTooltip(IntPtr hwnd, string pszTip);
    public abstract virtual HRESULT SetThumbnailClip(IntPtr hwnd, RefRECT prcClip);
    public abstract virtual HRESULT SetTabProperties(IntPtr hwndTab, STPF stpFlags);
}
internal class MS.Internal.AppModel.JournalEntryGroupState : object {
    private Guid _navigationServiceId;
    private UInt32 _contentId;
    private DataStreams _journalDataStreams;
    private JournalEntry _groupExitEntry;
    internal Guid NavigationServiceId { get; internal set; }
    internal UInt32 ContentId { get; internal set; }
    internal DataStreams JournalDataStreams { get; internal set; }
    internal JournalEntry GroupExitEntry { get; internal set; }
    internal JournalEntryGroupState(Guid navSvcId, UInt32 contentId);
    internal Guid get_NavigationServiceId();
    internal void set_NavigationServiceId(Guid value);
    internal UInt32 get_ContentId();
    internal void set_ContentId(UInt32 value);
    internal DataStreams get_JournalDataStreams();
    internal void set_JournalDataStreams(DataStreams value);
    internal JournalEntry get_GroupExitEntry();
    internal void set_GroupExitEntry(JournalEntry value);
}
internal class MS.Internal.AppModel.JournalEntryKeepAlive : JournalEntry {
    private object _keepAliveRoot;
    internal object KeepAliveRoot { get; }
    internal JournalEntryKeepAlive(JournalEntryGroupState jeGroupState, Uri uri, object keepAliveRoot);
    internal object get_KeepAliveRoot();
    internal virtual bool IsAlive();
    internal virtual void SaveState(object contentObject);
    internal virtual bool Navigate(INavigator navigator, NavigationMode navMode);
}
internal abstract class MS.Internal.AppModel.JournalEntryPageFunction : JournalEntry {
    private Guid _pageFunctionId;
    private Guid _parentPageFunctionId;
    internal static int _NoParentPage;
    internal Guid PageFunctionId { get; internal set; }
    internal Guid ParentPageFunctionId { get; internal set; }
    internal JournalEntryPageFunction(JournalEntryGroupState jeGroupState, PageFunctionBase pageFunction);
    protected JournalEntryPageFunction(SerializationInfo info, StreamingContext context);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    internal Guid get_PageFunctionId();
    internal void set_PageFunctionId(Guid value);
    internal Guid get_ParentPageFunctionId();
    internal void set_ParentPageFunctionId(Guid value);
    internal virtual bool IsPageFunction();
    internal virtual bool IsAlive();
    internal abstract virtual PageFunctionBase ResumePageFunction();
    internal static int GetParentPageJournalIndex(NavigationService NavigationService, Journal journal, PageFunctionBase endingPF);
}
internal class MS.Internal.AppModel.JournalEntryPageFunctionKeepAlive : JournalEntryPageFunction {
    private PageFunctionBase _keepAlivePageFunction;
    internal PageFunctionBase KeepAlivePageFunction { get; }
    internal JournalEntryPageFunctionKeepAlive(JournalEntryGroupState jeGroupState, PageFunctionBase pageFunction);
    internal virtual bool IsPageFunction();
    internal virtual bool IsAlive();
    internal PageFunctionBase get_KeepAlivePageFunction();
    internal virtual PageFunctionBase ResumePageFunction();
    internal virtual void SaveState(object contentObject);
    internal virtual bool Navigate(INavigator navigator, NavigationMode navMode);
}
internal abstract class MS.Internal.AppModel.JournalEntryPageFunctionSaver : JournalEntryPageFunction {
    private ReturnEventSaver _returnEventSaver;
    internal JournalEntryPageFunctionSaver(JournalEntryGroupState jeGroupState, PageFunctionBase pageFunction);
    protected JournalEntryPageFunctionSaver(SerializationInfo info, StreamingContext context);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    internal virtual void SaveState(object contentObject);
    internal virtual void RestoreState(object contentObject);
    internal virtual bool Navigate(INavigator navigator, NavigationMode navMode);
}
internal class MS.Internal.AppModel.JournalEntryPageFunctionType : JournalEntryPageFunctionSaver {
    private SecurityCriticalDataForSet`1<string> _typeName;
    internal JournalEntryPageFunctionType(JournalEntryGroupState jeGroupState, PageFunctionBase pageFunction);
    protected JournalEntryPageFunctionType(SerializationInfo info, StreamingContext context);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    internal virtual void SaveState(object contentObject);
    internal virtual PageFunctionBase ResumePageFunction();
    private void InitializeComponent(PageFunctionBase pageFunction);
}
internal class MS.Internal.AppModel.JournalEntryPageFunctionUri : JournalEntryPageFunctionSaver {
    private Uri _markupUri;
    internal JournalEntryPageFunctionUri(JournalEntryGroupState jeGroupState, PageFunctionBase pageFunction, Uri markupUri);
    protected JournalEntryPageFunctionUri(SerializationInfo info, StreamingContext context);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    internal virtual PageFunctionBase ResumePageFunction();
}
internal enum MS.Internal.AppModel.JournalEntryType : Enum {
    public byte value__;
    public static JournalEntryType Navigable;
    public static JournalEntryType UiLess;
}
internal class MS.Internal.AppModel.JournalEntryUri : JournalEntry {
    internal JournalEntryUri(JournalEntryGroupState jeGroupState, Uri uri);
    protected JournalEntryUri(SerializationInfo info, StreamingContext context);
    internal virtual void SaveState(object contentObject);
}
internal class MS.Internal.AppModel.JournalNavigationScope : DependencyObject {
    private static DependencyPropertyKey CanGoBackPropertyKey;
    internal static DependencyProperty CanGoBackProperty;
    private static DependencyPropertyKey CanGoForwardPropertyKey;
    internal static DependencyProperty CanGoForwardProperty;
    private static DependencyPropertyKey BackStackPropertyKey;
    internal static DependencyProperty BackStackProperty;
    private static DependencyPropertyKey ForwardStackPropertyKey;
    internal static DependencyProperty ForwardStackProperty;
    private IJournalNavigationScopeHost _host;
    private NavigationService _rootNavSvc;
    private Journal _journal;
    public Uri Source { get; public set; }
    public Uri CurrentSource { get; }
    public object Content { get; public set; }
    public bool CanGoForward { get; }
    public bool CanGoBack { get; }
    public IEnumerable BackStack { get; }
    public IEnumerable ForwardStack { get; }
    internal Journal Journal { get; internal set; }
    internal NavigationService RootNavigationService { get; }
    internal INavigatorBase NavigatorHost { get; }
    private bool InAppShutdown { get; }
    internal JournalNavigationScope(IJournalNavigationScopeHost host);
    private static JournalNavigationScope();
    public sealed virtual Uri get_Source();
    public sealed virtual void set_Source(Uri value);
    public sealed virtual Uri get_CurrentSource();
    public sealed virtual object get_Content();
    public sealed virtual void set_Content(object value);
    public sealed virtual bool Navigate(Uri source);
    public sealed virtual bool Navigate(Uri source, object extraData);
    public sealed virtual bool Navigate(object content);
    public sealed virtual bool Navigate(object content, object extraData);
    public sealed virtual void StopLoading();
    public sealed virtual void Refresh();
    public sealed virtual void add_Navigating(NavigatingCancelEventHandler value);
    public sealed virtual void remove_Navigating(NavigatingCancelEventHandler value);
    public sealed virtual void add_NavigationProgress(NavigationProgressEventHandler value);
    public sealed virtual void remove_NavigationProgress(NavigationProgressEventHandler value);
    public sealed virtual void add_NavigationFailed(NavigationFailedEventHandler value);
    public sealed virtual void remove_NavigationFailed(NavigationFailedEventHandler value);
    public sealed virtual void add_Navigated(NavigatedEventHandler value);
    public sealed virtual void remove_Navigated(NavigatedEventHandler value);
    public sealed virtual void add_LoadCompleted(LoadCompletedEventHandler value);
    public sealed virtual void remove_LoadCompleted(LoadCompletedEventHandler value);
    public sealed virtual void add_NavigationStopped(NavigationStoppedEventHandler value);
    public sealed virtual void remove_NavigationStopped(NavigationStoppedEventHandler value);
    public sealed virtual void add_FragmentNavigation(FragmentNavigationEventHandler value);
    public sealed virtual void remove_FragmentNavigation(FragmentNavigationEventHandler value);
    public sealed virtual bool get_CanGoForward();
    public sealed virtual bool get_CanGoBack();
    public sealed virtual void GoForward();
    public sealed virtual void GoBack();
    public sealed virtual void AddBackEntry(CustomContentState state);
    public sealed virtual JournalEntry RemoveBackEntry();
    public sealed virtual IEnumerable get_BackStack();
    public sealed virtual IEnumerable get_ForwardStack();
    private sealed virtual override JournalNavigationScope MS.Internal.AppModel.INavigator.GetJournal(bool create);
    internal void EnsureJournal();
    internal bool CanInvokeJournalEntry(int entryId);
    internal bool NavigateToEntry(int index);
    internal bool NavigateToEntry(JournalEntry entry);
    internal void AbortJournalNavigation();
    internal INavigatorBase FindTarget(string name);
    internal static void ClearDPValues(DependencyObject navigator);
    internal Journal get_Journal();
    internal void set_Journal(Journal value);
    internal NavigationService get_RootNavigationService();
    internal INavigatorBase get_NavigatorHost();
    private void OnBackForwardStateChange(object sender, EventArgs e);
    private bool IsEntryNavigable(JournalEntry entry);
    private bool get_InAppShutdown();
}
internal enum MS.Internal.AppModel.JournalReason : Enum {
    public int value__;
    public static JournalReason NewContentNavigation;
    public static JournalReason FragmentNavigation;
    public static JournalReason AddBackEntry;
}
internal enum MS.Internal.AppModel.LaunchResult : Enum {
    public int value__;
    public static LaunchResult Launched;
    public static LaunchResult NotLaunched;
    public static LaunchResult NotLaunchedDueToPrompt;
}
internal static class MS.Internal.AppModel.MimeObjectFactory : object {
    private static Dictionary`2<ContentType, StreamToObjectFactoryDelegate> _objectConverters;
    private static MimeObjectFactory();
    internal static object GetObjectAndCloseStream(Stream s, ContentType contentType, Uri baseUri, bool canUseTopLevelBrowser, bool sandboxExternalContent, bool allowAsync, bool isJournalNavigation, XamlReader& asyncObjectConverter);
    internal static void Register(ContentType contentType, StreamToObjectFactoryDelegate method);
}
internal enum MS.Internal.AppModel.MimeType : Enum {
    public int value__;
    public static MimeType Unknown;
    public static MimeType Document;
    public static MimeType Application;
    public static MimeType Markup;
}
internal static class MS.Internal.AppModel.NativeMethods2 : object {
    private static void SHAddToRecentDocsString(SHARD uFlags, string pv);
    private static void SHAddToRecentDocs_ShellLink(SHARD uFlags, IShellLinkW pv);
    internal static void SHAddToRecentDocs(string path);
    internal static void SHAddToRecentDocs(IShellLinkW shellLink);
    internal static HRESULT SHCreateItemFromParsingName(string pszPath, IBindCtx pbc, Guid& riid, Object& ppv);
    internal static HRESULT SHGetFolderPathEx(Guid& rfid, KF_FLAG dwFlags, IntPtr hToken, StringBuilder pszPath, UInt32 cchPath);
    internal static void SetCurrentProcessExplicitAppUserModelID(string AppID);
    internal static HRESULT GetCurrentProcessExplicitAppUserModelID(String& AppID);
}
internal class MS.Internal.AppModel.NativeProgressPageProxy : object {
    private INativeProgressPage _npp;
    public Uri DeploymentPath { get; public set; }
    public DispatcherOperationCallback StopCallback { get; public set; }
    public DispatcherOperationCallback RefreshCallback { get; public set; }
    public string ApplicationName { get; public set; }
    public string PublisherName { get; public set; }
    internal NativeProgressPageProxy(INativeProgressPage npp);
    public sealed virtual void ShowProgressMessage(string message);
    public sealed virtual void set_DeploymentPath(Uri value);
    public sealed virtual Uri get_DeploymentPath();
    public sealed virtual void set_StopCallback(DispatcherOperationCallback value);
    public sealed virtual DispatcherOperationCallback get_StopCallback();
    public sealed virtual void set_RefreshCallback(DispatcherOperationCallback value);
    public sealed virtual DispatcherOperationCallback get_RefreshCallback();
    public sealed virtual void set_ApplicationName(string value);
    public sealed virtual string get_ApplicationName();
    public sealed virtual void set_PublisherName(string value);
    public sealed virtual string get_PublisherName();
    public sealed virtual void UpdateProgress(long bytesDownloaded, long bytesTotal);
}
internal static class MS.Internal.AppModel.NavigationHelper : object {
    internal static Visual FindRootViewer(ContentControl navigator, string contentPresenterName);
}
internal enum MS.Internal.AppModel.NavigationStatus : Enum {
    public int value__;
    public static NavigationStatus Idle;
    public static NavigationStatus Navigating;
    public static NavigationStatus NavigationFailed;
    public static NavigationStatus Navigated;
    public static NavigationStatus Stopped;
}
internal class MS.Internal.AppModel.OleCmdHelper : MarshalByRefObject {
    internal static int OLECMDERR_E_NOTSUPPORTED;
    internal static int OLECMDERR_E_DISABLED;
    internal static int OLECMDERR_E_UNKNOWNGROUP;
    internal static UInt32 CommandUnsupported;
    internal static UInt32 CommandEnabled;
    internal static UInt32 CommandDisabled;
    internal static Guid CGID_ApplicationCommands;
    internal static Guid CGID_EditingCommands;
    private SecurityCriticalDataForSet`1<SortedList> _oleCmdMappingTable;
    private SecurityCriticalDataForSet`1<Hashtable> _applicationCommandsMappingTable;
    private SecurityCriticalDataForSet`1<SortedList> _editingCommandsMappingTable;
    private static OleCmdHelper();
    internal void QueryStatus(Guid guidCmdGroup, UInt32 cmdId, UInt32& flags);
    private object QueryEnabled(object command);
    internal void ExecCommand(Guid guidCmdGroup, UInt32 commandId, object arg);
    private object ExecCommandCallback(object arguments);
    private IDictionary GetOleCmdMappingTable(Guid guidCmdGroup);
    private void EnsureOleCmdMappingTable();
    private void EnsureApplicationCommandsTable();
    private void EnsureEditingCommandsTable();
}
internal class MS.Internal.AppModel.PKEY : ValueType {
    private Guid _fmtid;
    private UInt32 _pid;
    public static PKEY Title;
    public static PKEY AppUserModel_ID;
    public static PKEY AppUserModel_IsDestListSeparator;
    public static PKEY AppUserModel_RelaunchCommand;
    public static PKEY AppUserModel_RelaunchDisplayNameResource;
    public static PKEY AppUserModel_RelaunchIconResource;
    private PKEY(Guid fmtid, UInt32 pid);
    private static PKEY();
}
internal class MS.Internal.AppModel.RequestSetStatusBarEventArgs : RoutedEventArgs {
    private SecurityCriticalDataForSet`1<string> _text;
    internal string Text { get; }
    internal static RequestSetStatusBarEventArgs Clear { get; }
    internal RequestSetStatusBarEventArgs(string text);
    internal RequestSetStatusBarEventArgs(Uri targetUri);
    internal string get_Text();
    internal static RequestSetStatusBarEventArgs get_Clear();
}
internal class MS.Internal.AppModel.ResourceContainer : Package {
    internal static string XamlExt;
    internal static string BamlExt;
    private static Dictionary`2<string, ResourceManagerWrapper> _registeredResourceManagers;
    private static ResourceManagerWrapper _applicationResourceManagerWrapper;
    private static FileShare _fileShare;
    private static bool assemblyLoadhandlerAttached;
    internal static ResourceManagerWrapper ApplicationResourceManagerWrapper { get; }
    internal static FileShare FileShare { get; }
    private static ResourceContainer();
    internal static ResourceManagerWrapper get_ApplicationResourceManagerWrapper();
    internal static FileShare get_FileShare();
    public virtual bool PartExists(Uri uri);
    protected virtual PackagePart GetPartCore(Uri uri);
    private void OnAssemblyLoadEventHandler(object sender, AssemblyLoadEventArgs args);
    private void UpdateCachedRMW(string key, Assembly assembly);
    private ResourceManagerWrapper GetResourceManagerWrapper(Uri uri, String& partName, Boolean& isContentFile);
    protected virtual PackagePart CreatePartCore(Uri uri, string contentType, CompressionOption compressionOption);
    protected virtual void DeletePartCore(Uri uri);
    protected virtual PackagePart[] GetPartsCore();
    protected virtual void FlushCore();
}
internal class MS.Internal.AppModel.ResourcePart : PackagePart {
    private SecurityCriticalDataForSet`1<ResourceManagerWrapper> _rmWrapper;
    private bool _ensureResourceIsCalled;
    private string _name;
    private object _globalLock;
    public ResourcePart(Package container, Uri uri, string name, ResourceManagerWrapper rmWrapper);
    protected virtual Stream GetStreamCore(FileMode mode, FileAccess access);
    protected virtual string GetContentTypeCore();
    private Stream EnsureResourceLocationSet();
}
internal class MS.Internal.AppModel.ReturnEventSaver : object {
    private ReturnEventSaverInfo[] _returnList;
    internal void _Detach(PageFunctionBase pf);
    internal void _Attach(object caller, PageFunctionBase child);
}
internal class MS.Internal.AppModel.ReturnEventSaverInfo : ValueType {
    internal string _delegateTypeName;
    internal string _targetTypeName;
    internal string _delegateMethodName;
    internal bool _delegateInSamePF;
    internal ReturnEventSaverInfo(string delegateTypeName, string targetTypeName, string delegateMethodName, bool fSamePf);
}
internal static class MS.Internal.AppModel.ShellUtil : object {
    public static string GetPathFromShellItem(IShellItem item);
    public static string GetPathForKnownFolder(Guid knownFolder);
    public static IShellItem2 GetShellItemForPath(string path);
}
internal class MS.Internal.AppModel.StreamToObjectFactoryDelegate : MulticastDelegate {
    public StreamToObjectFactoryDelegate(object object, IntPtr method);
    public virtual object Invoke(Stream s, Uri baseUri, bool canUseTopLevelBrowser, bool sandboxExternalContent, bool allowAsync, bool isJournalNavigation, XamlReader& asyncObjectConverter);
    public virtual IAsyncResult BeginInvoke(Stream s, Uri baseUri, bool canUseTopLevelBrowser, bool sandboxExternalContent, bool allowAsync, bool isJournalNavigation, XamlReader& asyncObjectConverter, AsyncCallback callback, object object);
    public virtual object EndInvoke(XamlReader& asyncObjectConverter, IAsyncResult result);
}
internal class MS.Internal.AppModel.SubStream : ValueType {
    internal string _propertyName;
    internal Byte[] _data;
    internal SubStream(string propertyName, Byte[] dataBytes);
}
internal class MS.Internal.AppModel.THUMBBUTTON : ValueType {
    public static int THBN_CLICKED;
    public THB dwMask;
    public UInt32 iId;
    public UInt32 iBitmap;
    public IntPtr hIcon;
    public string szTip;
    public THBF dwFlags;
}
internal class MS.Internal.AssemblyFilter : object {
    private static SecurityCriticalDataForSet`1<List`1<string>> _assemblyList;
    private static SecurityCriticalDataForSet`1<bool> _disallowedListExtracted;
    private static object _lock;
    private static string FILEVERSION_STRING;
    private static string KILL_BIT_REGISTRY_HIVE;
    private static string KILL_BIT_REGISTRY_LOCATION;
    private static string SUBKEY_VALUE;
    private static AssemblyFilter();
    internal void FilterCallback(object sender, AssemblyLoadEventArgs args);
    private string AssemblyNameWithFileVersion(Assembly a);
    private bool AssemblyOnDisallowedList(string assemblyToCheck);
    private void ExtractDisallowedRegistryList();
}
internal class MS.Internal.Automation.TextAdaptor : object {
    private AutomationPeer _textPeer;
    private ITextContainer _textContainer;
    private ITextRangeProvider System.Windows.Automation.Provider.ITextProvider.DocumentRange { get; }
    private SupportedTextSelection System.Windows.Automation.Provider.ITextProvider.SupportedTextSelection { get; }
    internal TextAdaptor(AutomationPeer textPeer, ITextContainer textContainer);
    public sealed virtual void Dispose();
    internal Rect[] GetBoundingRectangles(ITextPointer start, ITextPointer end, bool clipToView, bool transformToScreen);
    internal ITextView GetUpdatedTextView();
    internal void Select(ITextPointer start, ITextPointer end);
    internal void ScrollIntoView(ITextPointer start, ITextPointer end, bool alignToTop);
    private void OnTextContainerChanged(object sender, TextContainerChangedEventArgs e);
    private void OnTextSelectionChanged(object sender, EventArgs e);
    private Rect GetVisibleRectangle(ITextView textView);
    private Point ClientToScreen(Point point, Visual visual);
    private Point ObsoleteClientToScreen(Point point, Visual visual);
    private Point ScreenToClient(Point point, Visual visual);
    private Point ObsoleteScreenToClient(Point point, Visual visual);
    private sealed virtual override ITextRangeProvider[] System.Windows.Automation.Provider.ITextProvider.GetSelection();
    private sealed virtual override ITextRangeProvider[] System.Windows.Automation.Provider.ITextProvider.GetVisibleRanges();
    private sealed virtual override ITextRangeProvider System.Windows.Automation.Provider.ITextProvider.RangeFromChild(IRawElementProviderSimple childElementProvider);
    private sealed virtual override ITextRangeProvider System.Windows.Automation.Provider.ITextProvider.RangeFromPoint(Point location);
    private sealed virtual override ITextRangeProvider System.Windows.Automation.Provider.ITextProvider.get_DocumentRange();
    private sealed virtual override SupportedTextSelection System.Windows.Automation.Provider.ITextProvider.get_SupportedTextSelection();
}
internal class MS.Internal.Automation.TextRangeAdaptor : object {
    private ITextPointer _start;
    private ITextPointer _end;
    private TextAdaptor _textAdaptor;
    private AutomationPeer _textPeer;
    private static Hashtable _textPatternAttributes;
    private static string _defaultFamilyName;
    private static TextRangeAdaptor();
    internal TextRangeAdaptor(TextAdaptor textAdaptor, ITextPointer start, ITextPointer end, AutomationPeer textPeer);
    internal static bool MoveToInsertionPosition(ITextPointer position, LogicalDirection direction);
    private TextRangeAdaptor ValidateAndThrow(ITextRangeProvider range);
    private void ExpandToEnclosingUnit(TextUnit unit, bool expandStart, bool expandEnd);
    private bool MoveToUnitBoundary(ITextPointer position, bool isStart, LogicalDirection direction, TextUnit unit);
    private int MovePositionByUnits(ITextPointer position, TextUnit unit, int count);
    private object GetAttributeValue(TextAttributeHelper attr);
    private bool IsElementBoundary(TextPointerContext symbolType);
    private static int ColorFromBrush(object brush);
    private static string GetFontFamilyName(FontFamily fontFamily, ITextPointer context);
    private static int GetTextDecorationColor(TextDecorationCollection decorations, TextDecorationLocation location);
    private static TextDecorationLineStyle GetTextDecorationLineStyle(TextDecorationCollection decorations, TextDecorationLocation location);
    private static double NativeObjectLengthToPoints(double length);
    private AutomationPeer GetEnclosingAutomationPeer(ITextPointer start, ITextPointer end);
    private IRawElementProviderSimple ProviderFromPeer(AutomationPeer peer);
    private List`1<AutomationPeer> GetAutomationPeersFromRange(AutomationPeer peer, ITextPointer start, ITextPointer end);
    private static bool IsAtWordBoundary(ITextPointer position);
    private static bool MoveToNextWordBoundary(ITextPointer position, LogicalDirection direction);
    private void Normalize();
    private ITextPointer GetInsertionPosition(ITextPointer position, LogicalDirection direction);
    private sealed virtual override ITextRangeProvider System.Windows.Automation.Provider.ITextRangeProvider.Clone();
    private sealed virtual override bool System.Windows.Automation.Provider.ITextRangeProvider.Compare(ITextRangeProvider range);
    private sealed virtual override int System.Windows.Automation.Provider.ITextRangeProvider.CompareEndpoints(TextPatternRangeEndpoint endpoint, ITextRangeProvider targetRange, TextPatternRangeEndpoint targetEndpoint);
    private sealed virtual override void System.Windows.Automation.Provider.ITextRangeProvider.ExpandToEnclosingUnit(TextUnit unit);
    private sealed virtual override ITextRangeProvider System.Windows.Automation.Provider.ITextRangeProvider.FindAttribute(int attributeId, object value, bool backward);
    private sealed virtual override ITextRangeProvider System.Windows.Automation.Provider.ITextRangeProvider.FindText(string text, bool backward, bool ignoreCase);
    private sealed virtual override object System.Windows.Automation.Provider.ITextRangeProvider.GetAttributeValue(int attributeId);
    private sealed virtual override Double[] System.Windows.Automation.Provider.ITextRangeProvider.GetBoundingRectangles();
    private sealed virtual override IRawElementProviderSimple System.Windows.Automation.Provider.ITextRangeProvider.GetEnclosingElement();
    private sealed virtual override string System.Windows.Automation.Provider.ITextRangeProvider.GetText(int maxLength);
    private sealed virtual override int System.Windows.Automation.Provider.ITextRangeProvider.Move(TextUnit unit, int count);
    private sealed virtual override int System.Windows.Automation.Provider.ITextRangeProvider.MoveEndpointByUnit(TextPatternRangeEndpoint endpoint, TextUnit unit, int count);
    private sealed virtual override void System.Windows.Automation.Provider.ITextRangeProvider.MoveEndpointByRange(TextPatternRangeEndpoint endpoint, ITextRangeProvider targetRange, TextPatternRangeEndpoint targetEndpoint);
    private sealed virtual override void System.Windows.Automation.Provider.ITextRangeProvider.Select();
    private sealed virtual override void System.Windows.Automation.Provider.ITextRangeProvider.AddToSelection();
    private sealed virtual override void System.Windows.Automation.Provider.ITextRangeProvider.RemoveFromSelection();
    private sealed virtual override void System.Windows.Automation.Provider.ITextRangeProvider.ScrollIntoView(bool alignToTop);
    private sealed virtual override IRawElementProviderSimple[] System.Windows.Automation.Provider.ITextRangeProvider.GetChildren();
}
internal static class MS.Internal.Commands.CommandHelpers : object {
    internal static void RegisterCommandHandler(Type controlType, RoutedCommand command, ExecutedRoutedEventHandler executedRoutedEventHandler);
    internal static void RegisterCommandHandler(Type controlType, RoutedCommand command, ExecutedRoutedEventHandler executedRoutedEventHandler, InputGesture inputGesture);
    internal static void RegisterCommandHandler(Type controlType, RoutedCommand command, ExecutedRoutedEventHandler executedRoutedEventHandler, Key key);
    internal static void RegisterCommandHandler(Type controlType, RoutedCommand command, ExecutedRoutedEventHandler executedRoutedEventHandler, InputGesture inputGesture, InputGesture inputGesture2);
    internal static void RegisterCommandHandler(Type controlType, RoutedCommand command, ExecutedRoutedEventHandler executedRoutedEventHandler, CanExecuteRoutedEventHandler canExecuteRoutedEventHandler);
    internal static void RegisterCommandHandler(Type controlType, RoutedCommand command, ExecutedRoutedEventHandler executedRoutedEventHandler, CanExecuteRoutedEventHandler canExecuteRoutedEventHandler, InputGesture inputGesture);
    internal static void RegisterCommandHandler(Type controlType, RoutedCommand command, ExecutedRoutedEventHandler executedRoutedEventHandler, CanExecuteRoutedEventHandler canExecuteRoutedEventHandler, Key key);
    internal static void RegisterCommandHandler(Type controlType, RoutedCommand command, ExecutedRoutedEventHandler executedRoutedEventHandler, CanExecuteRoutedEventHandler canExecuteRoutedEventHandler, InputGesture inputGesture, InputGesture inputGesture2);
    internal static void RegisterCommandHandler(Type controlType, RoutedCommand command, ExecutedRoutedEventHandler executedRoutedEventHandler, CanExecuteRoutedEventHandler canExecuteRoutedEventHandler, InputGesture inputGesture, InputGesture inputGesture2, InputGesture inputGesture3, InputGesture inputGesture4);
    internal static void RegisterCommandHandler(Type controlType, RoutedCommand command, Key key, ModifierKeys modifierKeys, ExecutedRoutedEventHandler executedRoutedEventHandler, CanExecuteRoutedEventHandler canExecuteRoutedEventHandler);
    internal static void RegisterCommandHandler(Type controlType, RoutedCommand command, ExecutedRoutedEventHandler executedRoutedEventHandler, string srid1, string srid2);
    internal static void RegisterCommandHandler(Type controlType, RoutedCommand command, ExecutedRoutedEventHandler executedRoutedEventHandler, CanExecuteRoutedEventHandler canExecuteRoutedEventHandler, string srid1, string srid2);
    private static void PrivateRegisterCommandHandler(Type controlType, RoutedCommand command, ExecutedRoutedEventHandler executedRoutedEventHandler, CanExecuteRoutedEventHandler canExecuteRoutedEventHandler, InputGesture[] inputGestures);
    internal static bool CanExecuteCommandSource(ICommandSource commandSource);
    internal static void ExecuteCommandSource(ICommandSource commandSource);
    internal static void CriticalExecuteCommandSource(ICommandSource commandSource, bool userInitiated);
    internal static void ExecuteCommand(ICommand command, object parameter, IInputElement target);
}
internal class MS.Internal.Controls.ActiveXContainer : object {
    private ActiveXHost _host;
    private ActiveXHost _siteUIActive;
    internal ActiveXHost ActiveXHost { get; }
    internal ActiveXContainer(ActiveXHost host);
    private sealed virtual override int MS.Win32.UnsafeNativeMethods.IOleContainer.ParseDisplayName(object pbc, string pszDisplayName, Int32[] pchEaten, Object[] ppmkOut);
    private sealed virtual override int MS.Win32.UnsafeNativeMethods.IOleContainer.EnumObjects(int grfFlags, IEnumUnknown& ppenum);
    private sealed virtual override int MS.Win32.UnsafeNativeMethods.IOleContainer.LockContainer(bool fLock);
    private sealed virtual override IntPtr MS.Win32.UnsafeNativeMethods.IOleInPlaceFrame.GetWindow();
    private sealed virtual override int MS.Win32.UnsafeNativeMethods.IOleInPlaceFrame.ContextSensitiveHelp(int fEnterMode);
    private sealed virtual override int MS.Win32.UnsafeNativeMethods.IOleInPlaceFrame.GetBorder(COMRECT lprectBorder);
    private sealed virtual override int MS.Win32.UnsafeNativeMethods.IOleInPlaceFrame.RequestBorderSpace(COMRECT pborderwidths);
    private sealed virtual override int MS.Win32.UnsafeNativeMethods.IOleInPlaceFrame.SetBorderSpace(COMRECT pborderwidths);
    private sealed virtual override int MS.Win32.UnsafeNativeMethods.IOleInPlaceFrame.SetActiveObject(IOleInPlaceActiveObject pActiveObject, string pszObjName);
    private sealed virtual override int MS.Win32.UnsafeNativeMethods.IOleInPlaceFrame.InsertMenus(IntPtr hmenuShared, tagOleMenuGroupWidths lpMenuWidths);
    private sealed virtual override int MS.Win32.UnsafeNativeMethods.IOleInPlaceFrame.SetMenu(IntPtr hmenuShared, IntPtr holemenu, IntPtr hwndActiveObject);
    private sealed virtual override int MS.Win32.UnsafeNativeMethods.IOleInPlaceFrame.RemoveMenus(IntPtr hmenuShared);
    private sealed virtual override int MS.Win32.UnsafeNativeMethods.IOleInPlaceFrame.SetStatusText(string pszStatusText);
    private sealed virtual override int MS.Win32.UnsafeNativeMethods.IOleInPlaceFrame.EnableModeless(bool fEnable);
    private sealed virtual override int MS.Win32.UnsafeNativeMethods.IOleInPlaceFrame.TranslateAccelerator(MSG& lpmsg, short wID);
    internal void OnUIActivate(ActiveXHost site);
    internal void OnUIDeactivate(ActiveXHost site);
    internal void OnInPlaceDeactivate(ActiveXHost site);
    internal ActiveXHost get_ActiveXHost();
}
internal class MS.Internal.Controls.ActiveXHelper : object {
    public static int sinkAttached;
    public static int inTransition;
    public static int processingKeyUp;
    private static int logPixelsX;
    private static int logPixelsY;
    private static int HMperInch;
    public static int LogPixelsX { get; }
    public static int LogPixelsY { get; }
    private static ActiveXHelper();
    public static int Pix2HM(int pix, int logP);
    public static int HM2Pix(int hm, int logP);
    public static int get_LogPixelsX();
    public static void ResetLogPixelsX();
    public static int get_LogPixelsY();
    public static void ResetLogPixelsY();
    internal static object CreateIDispatchSTAForwarder(object pDispatchDelegate);
}
internal class MS.Internal.Controls.ActiveXSite : object {
    private ActiveXHost _host;
    private ConnectionPointCookie _connectionPoint;
    private ActiveXState HostState { get; private set; }
    internal COMRECT HostBounds { get; }
    internal ActiveXHost Host { get; }
    internal ActiveXSite(ActiveXHost host);
    private sealed virtual override int MS.Win32.UnsafeNativeMethods.IOleControlSite.OnControlInfoChanged();
    private sealed virtual override int MS.Win32.UnsafeNativeMethods.IOleControlSite.LockInPlaceActive(int fLock);
    private sealed virtual override int MS.Win32.UnsafeNativeMethods.IOleControlSite.GetExtendedControl(Object& ppDisp);
    private sealed virtual override int MS.Win32.UnsafeNativeMethods.IOleControlSite.TransformCoords(POINT pPtlHimetric, POINTF pPtfContainer, int dwFlags);
    private sealed virtual override int MS.Win32.UnsafeNativeMethods.IOleControlSite.TranslateAccelerator(MSG& pMsg, int grfModifiers);
    private sealed virtual override int MS.Win32.UnsafeNativeMethods.IOleControlSite.OnFocus(int fGotFocus);
    private sealed virtual override int MS.Win32.UnsafeNativeMethods.IOleControlSite.ShowPropertyFrame();
    private sealed virtual override int MS.Win32.UnsafeNativeMethods.IOleClientSite.SaveObject();
    private sealed virtual override int MS.Win32.UnsafeNativeMethods.IOleClientSite.GetMoniker(int dwAssign, int dwWhichMoniker, Object& moniker);
    private sealed virtual override int MS.Win32.UnsafeNativeMethods.IOleClientSite.GetContainer(IOleContainer& container);
    private sealed virtual override int MS.Win32.UnsafeNativeMethods.IOleClientSite.ShowObject();
    private sealed virtual override int MS.Win32.UnsafeNativeMethods.IOleClientSite.OnShowWindow(int fShow);
    private sealed virtual override int MS.Win32.UnsafeNativeMethods.IOleClientSite.RequestNewObjectLayout();
    private sealed virtual override IntPtr MS.Win32.UnsafeNativeMethods.IOleInPlaceSite.GetWindow();
    private sealed virtual override int MS.Win32.UnsafeNativeMethods.IOleInPlaceSite.ContextSensitiveHelp(int fEnterMode);
    private sealed virtual override int MS.Win32.UnsafeNativeMethods.IOleInPlaceSite.CanInPlaceActivate();
    private sealed virtual override int MS.Win32.UnsafeNativeMethods.IOleInPlaceSite.OnInPlaceActivate();
    private sealed virtual override int MS.Win32.UnsafeNativeMethods.IOleInPlaceSite.OnUIActivate();
    private sealed virtual override int MS.Win32.UnsafeNativeMethods.IOleInPlaceSite.GetWindowContext(IOleInPlaceFrame& ppFrame, IOleInPlaceUIWindow& ppDoc, COMRECT lprcPosRect, COMRECT lprcClipRect, OLEINPLACEFRAMEINFO lpFrameInfo);
    private sealed virtual override int MS.Win32.UnsafeNativeMethods.IOleInPlaceSite.Scroll(SIZE scrollExtant);
    private sealed virtual override int MS.Win32.UnsafeNativeMethods.IOleInPlaceSite.OnUIDeactivate(int fUndoable);
    private sealed virtual override int MS.Win32.UnsafeNativeMethods.IOleInPlaceSite.OnInPlaceDeactivate();
    private sealed virtual override int MS.Win32.UnsafeNativeMethods.IOleInPlaceSite.DiscardUndoState();
    private sealed virtual override int MS.Win32.UnsafeNativeMethods.IOleInPlaceSite.DeactivateAndUndo();
    private sealed virtual override int MS.Win32.UnsafeNativeMethods.IOleInPlaceSite.OnPosRectChange(COMRECT lprcPosRect);
    private ActiveXState get_HostState();
    private void set_HostState(ActiveXState value);
    internal COMRECT get_HostBounds();
    private sealed virtual override void MS.Win32.UnsafeNativeMethods.IPropertyNotifySink.OnChanged(int dispid);
    private sealed virtual override int MS.Win32.UnsafeNativeMethods.IPropertyNotifySink.OnRequestEdit(int dispid);
    internal virtual void OnPropertyChanged(int dispid);
    internal ActiveXHost get_Host();
    internal void StartEvents();
    internal void StopEvents();
    internal int OnActiveXRectChange(COMRECT lprcPosRect);
}
internal class MS.Internal.Controls.ConnectionPointCookie : object {
    private IConnectionPoint connectionPoint;
    private int cookie;
    internal ConnectionPointCookie(object source, object sink, Type eventInterface);
    internal void Disconnect();
    protected virtual override void Finalize();
}
internal class MS.Internal.Controls.ContentModelTreeEnumerator : ModelTreeEnumerator {
    private ContentControl _owner;
    protected bool IsUnchanged { get; }
    internal ContentModelTreeEnumerator(ContentControl contentControl, object content);
    protected virtual bool get_IsUnchanged();
}
internal class MS.Internal.Controls.EmptyEnumerable : object {
    private static IEnumerable _instance;
    public static IEnumerable Instance { get; }
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public static IEnumerable get_Instance();
}
internal class MS.Internal.Controls.EmptyEnumerator : object {
    private static IEnumerator _instance;
    public static IEnumerator Instance { get; }
    public object Current { get; }
    public static IEnumerator get_Instance();
    public sealed virtual void Reset();
    public sealed virtual bool MoveNext();
    public sealed virtual object get_Current();
}
internal class MS.Internal.Controls.EnumUnknown : object {
    private Object[] arr;
    private int loc;
    private int size;
    internal EnumUnknown(Object[] arr);
    private EnumUnknown(Object[] arr, int loc);
    private sealed virtual override int MS.Win32.UnsafeNativeMethods.IEnumUnknown.Next(int celt, IntPtr rgelt, IntPtr pceltFetched);
    private sealed virtual override int MS.Win32.UnsafeNativeMethods.IEnumUnknown.Skip(int celt);
    private sealed virtual override void MS.Win32.UnsafeNativeMethods.IEnumUnknown.Reset();
    private sealed virtual override void MS.Win32.UnsafeNativeMethods.IEnumUnknown.Clone(IEnumUnknown& ppenum);
}
internal class MS.Internal.Controls.HeaderedContentModelTreeEnumerator : ModelTreeEnumerator {
    private HeaderedContentControl _owner;
    private object _content;
    protected object Current { get; }
    protected bool IsUnchanged { get; }
    internal HeaderedContentModelTreeEnumerator(HeaderedContentControl headeredContentControl, object content, object header);
    protected virtual object get_Current();
    protected virtual bool MoveNext();
    protected virtual bool get_IsUnchanged();
}
internal class MS.Internal.Controls.HeaderedItemsModelTreeEnumerator : ModelTreeEnumerator {
    private HeaderedItemsControl _owner;
    private IEnumerator _items;
    protected object Current { get; }
    protected bool IsUnchanged { get; }
    internal HeaderedItemsModelTreeEnumerator(HeaderedItemsControl headeredItemsControl, IEnumerator items, object header);
    protected virtual object get_Current();
    protected virtual bool MoveNext();
    protected virtual void Reset();
    protected virtual bool get_IsUnchanged();
}
internal interface MS.Internal.Controls.IGeneratorHost {
    public ItemCollection View { get; }
    public int AlternationCount { get; }
    public abstract virtual ItemCollection get_View();
    public abstract virtual bool IsItemItsOwnContainer(object item);
    public abstract virtual DependencyObject GetContainerForItem(object item);
    public abstract virtual void PrepareItemContainer(DependencyObject container, object item);
    public abstract virtual void ClearContainerForItem(DependencyObject container, object item);
    public abstract virtual bool IsHostForItemContainer(DependencyObject container);
    public abstract virtual GroupStyle GetGroupStyle(CollectionViewGroup group, int level);
    public abstract virtual void SetIsGrouping(bool isGrouping);
    public abstract virtual int get_AlternationCount();
}
internal class MS.Internal.Controls.InkCanvasFeedbackAdorner : Adorner {
    private InkCanvas _inkCanvas;
    private Size _frameSize;
    private Rect _previousRect;
    private double _offsetX;
    private double _offsetY;
    private Pen _adornerBorderPen;
    private static int CornerResizeHandleSize;
    private static double BorderMargin;
    internal InkCanvasFeedbackAdorner(InkCanvas inkCanvas);
    public virtual GeneralTransform GetDesiredTransform(GeneralTransform transform);
    private void OnBoundsUpdated(Rect rect);
    protected virtual Size MeasureOverride(Size constraint);
    protected virtual void OnRender(DrawingContext drawingContext);
    internal void UpdateBounds(Rect rect);
}
internal class MS.Internal.Controls.InkCanvasInnerCanvas : Panel {
    private InkCanvas _inkCanvas;
    protected internal IEnumerator LogicalChildren { get; }
    internal IEnumerator PrivateLogicalChildren { get; }
    internal InkCanvas InkCanvas { get; }
    internal InkCanvasInnerCanvas(InkCanvas inkCanvas);
    protected internal virtual void OnVisualChildrenChanged(DependencyObject visualAdded, DependencyObject visualRemoved);
    protected virtual Size MeasureOverride(Size constraint);
    protected virtual Size ArrangeOverride(Size arrangeSize);
    protected virtual void OnChildDesiredSizeChanged(UIElement child);
    protected virtual UIElementCollection CreateUIElementCollection(FrameworkElement logicalParent);
    protected internal virtual IEnumerator get_LogicalChildren();
    protected virtual Geometry GetLayoutClip(Size layoutSlotSize);
    internal UIElement HitTestOnElements(Point point);
    internal IEnumerator get_PrivateLogicalChildren();
    internal InkCanvas get_InkCanvas();
}
internal class MS.Internal.Controls.InkCanvasSelectionAdorner : Adorner {
    private Pen _adornerBorderPen;
    private Pen _adornerPenBrush;
    private Brush _adornerFillBrush;
    private Pen _hatchPen;
    private Rect _strokesBounds;
    private List`1<Rect> _elementsBounds;
    private static double BorderMargin;
    private static double HatchBorderMargin;
    private static int CornerResizeHandleSize;
    private static int MiddleResizeHandleSize;
    private static double ResizeHandleTolerance;
    private static double LineThickness;
    internal InkCanvasSelectionAdorner(UIElement adornedElement);
    internal InkCanvasSelectionHitResult SelectionHandleHitTest(Point point);
    internal void UpdateSelectionWireFrame(Rect strokesBounds, List`1<Rect> hatchBounds);
    protected virtual void OnRender(DrawingContext drawingContext);
    private void DrawHandles(DrawingContext drawingContext, Rect rectWireFrame);
    private void DrawBackgound(DrawingContext drawingContext);
    private void GetHandleRect(InkCanvasSelectionHitResult hitResult, Rect rectWireFrame, Rect& visibleRect, Rect& toleranceRect);
    private Rect GetWireFrameRect();
}
[DefaultMemberAttribute("Item")]
internal class MS.Internal.Controls.InnerItemCollectionView : CollectionView {
    private SortDescriptionCollection _sort;
    private ArrayList _viewList;
    private ArrayList _rawList;
    private ItemCollection _itemCollection;
    private bool _isModified;
    private bool _currentElementWasRemoved;
    public SortDescriptionCollection SortDescriptions { get; }
    public bool CanSort { get; }
    public object Item { get; public set; }
    public bool IsReadOnly { get; }
    public bool IsFixedSize { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public IEnumerable SourceCollection { get; }
    public int Count { get; }
    public bool IsEmpty { get; }
    public bool NeedsRefresh { get; }
    internal ItemCollection ItemCollection { get; }
    internal IEnumerator LogicalChildren { get; }
    internal int RawCount { get; }
    private int ViewCount { get; }
    private bool IsCachedMode { get; }
    private FrameworkElement ModelParentFE { get; }
    private bool IsCurrentInView { get; }
    public InnerItemCollectionView(int capacity, ItemCollection itemCollection);
    public virtual SortDescriptionCollection get_SortDescriptions();
    public virtual bool get_CanSort();
    public virtual bool Contains(object item);
    public sealed virtual object get_Item(int index);
    public sealed virtual void set_Item(int index, object value);
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual int Add(object item);
    public sealed virtual void Clear();
    public sealed virtual void Insert(int index, object item);
    public sealed virtual void Remove(object item);
    public sealed virtual void RemoveAt(int index);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public virtual IEnumerable get_SourceCollection();
    public virtual int get_Count();
    public virtual bool get_IsEmpty();
    public virtual bool get_NeedsRefresh();
    public virtual int IndexOf(object item);
    public virtual object GetItemAt(int index);
    public virtual bool MoveCurrentTo(object item);
    public virtual bool MoveCurrentToPosition(int position);
    protected virtual void RefreshOverride();
    protected virtual IEnumerator GetEnumerator();
    internal ItemCollection get_ItemCollection();
    internal IEnumerator get_LogicalChildren();
    internal int get_RawCount();
    private int get_ViewCount();
    private bool get_IsCachedMode();
    private FrameworkElement get_ModelParentFE();
    private bool get_IsCurrentInView();
    private void SetIsModified();
    private void ClearIsModified();
    private void _RemoveAt(int index, int indexR, object item);
    private DependencyObject AssertPristineModelChild(object item);
    private void SetModelParent(object item);
    private void ClearModelParent(object item);
    private void SetSortDescriptions(SortDescriptionCollection descriptions);
    private void SortDescriptionsChanged(object sender, NotifyCollectionChangedEventArgs e);
    private void _MoveCurrentToPosition(int position);
    private void AdjustCurrencyForAdd(int index);
    private void AdjustCurrencyForRemove(int index);
    private void MoveCurrencyOffDeletedElement();
    private void OnPropertyChanged(string propertyName);
}
internal abstract class MS.Internal.Controls.ModelTreeEnumerator : object {
    private int _index;
    private object _content;
    private object System.Collections.IEnumerator.Current { get; }
    protected object Content { get; }
    protected int Index { get; protected set; }
    protected object Current { get; }
    protected bool IsUnchanged { get; }
    internal ModelTreeEnumerator(object content);
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    private sealed virtual override bool System.Collections.IEnumerator.MoveNext();
    private sealed virtual override void System.Collections.IEnumerator.Reset();
    protected object get_Content();
    protected int get_Index();
    protected void set_Index(int value);
    protected virtual object get_Current();
    protected virtual bool MoveNext();
    protected virtual void Reset();
    protected abstract virtual bool get_IsUnchanged();
    protected void VerifyUnchanged();
}
internal class MS.Internal.Controls.StickyNote.LockHelper : object {
    private LockFlag _backingStore;
    public bool IsLocked(LockFlag flag);
    private void Lock(LockFlag flag);
    private void Unlock(LockFlag flag);
}
internal static class MS.Internal.Controls.StickyNote.SNBConstants : object {
    internal static string c_CloseButtonId;
    internal static string c_TitleThumbId;
    internal static string c_BottomRightResizeThumbId;
    internal static string c_ContentControlId;
    internal static string c_IconButtonId;
    internal static string c_CopyMenuId;
    internal static string c_PasteMenuId;
    internal static string c_ClipboardSeparatorId;
    internal static string c_DeleteMenuId;
    internal static string c_InkMenuId;
    internal static string c_SelectMenuId;
    internal static string c_EraseMenuId;
    internal static string MetaResourceName;
    internal static string TextResourceName;
    internal static string InkResourceName;
}
internal class MS.Internal.Controls.StickyNote.SNCAnnotation : object {
    public static XmlToken AllValues;
    public static XmlToken PositionValues;
    public static XmlToken Sizes;
    public static XmlToken AllContents;
    public static XmlToken NegativeAllContents;
    private static Dictionary`2<XmlToken, string> s_xmlTokeFullNames;
    private Dictionary`2<XmlToken, object> _cachedXmlElements;
    private Annotation _annotation;
    private bool _isNewAnnotation;
    public bool IsNewAnnotation { get; }
    public bool HasInkData { get; }
    public bool HasTextData { get; }
    private static SNCAnnotation();
    public SNCAnnotation(Annotation annotation);
    public static void UpdateAnnotation(XmlToken token, StickyNoteControl snc, SNCAnnotation sncAnnotation);
    public static void UpdateStickyNoteControl(XmlToken token, StickyNoteControl snc, SNCAnnotation sncAnnotation);
    public bool get_IsNewAnnotation();
    public bool get_HasInkData();
    public bool get_HasTextData();
    private AnnotationResource FindCargo(string cargoName);
    private object FindData(XmlToken token);
    private static void GetCargoAndRoot(SNCAnnotation annotation, XmlToken token, AnnotationResource& cargo, XmlElement& root, Boolean& newCargo, Boolean& newRoot);
    private void UpdateAttribute(XmlElement root, XmlToken token, string value);
    private static string GetXmlName(XmlToken token);
    private static void AddXmlTokenNames(XmlToken token);
    private static string GetCargoName(XmlToken token);
    private static XmlElement FindRootXmlElement(XmlToken token, AnnotationResource cargo);
    private static object FindContent(XmlToken token, AnnotationResource cargo);
    private void UpdateContent(StickyNoteControl snc, bool updateAnnotation, XmlToken token);
    private static void UpdateMetaData(XmlToken token, StickyNoteControl snc, SNCAnnotation sncAnnotation);
}
internal abstract class MS.Internal.Controls.StickyNote.StickyNoteContentControl : object {
    protected FrameworkElement _innerControl;
    protected static long MaxBufferSize;
    public bool IsEmpty { get; }
    public StickyNoteType Type { get; }
    public FrameworkElement InnerControl { get; }
    protected StickyNoteContentControl(FrameworkElement innerControl);
    public abstract virtual void Save(XmlNode node);
    public abstract virtual void Load(XmlNode node);
    public abstract virtual void Clear();
    public abstract virtual bool get_IsEmpty();
    public abstract virtual StickyNoteType get_Type();
    public FrameworkElement get_InnerControl();
    protected void SetInnerControl(FrameworkElement innerControl);
}
internal static class MS.Internal.Controls.StickyNote.StickyNoteContentControlFactory : object {
    public static StickyNoteContentControl CreateContentControl(StickyNoteType type, UIElement content);
}
[FlagsAttribute]
internal enum MS.Internal.Controls.StickyNote.XmlToken : Enum {
    public int value__;
    public static XmlToken MetaData;
    public static XmlToken Left;
    public static XmlToken Top;
    public static XmlToken XOffset;
    public static XmlToken YOffset;
    public static XmlToken Width;
    public static XmlToken Height;
    public static XmlToken IsExpanded;
    public static XmlToken Author;
    public static XmlToken Text;
    public static XmlToken Ink;
    public static XmlToken ZOrder;
}
internal class MS.Internal.Controls.TemplatedAdorner : Adorner {
    private Control _child;
    private FrameworkElement _referenceElement;
    public FrameworkElement ReferenceElement { get; public set; }
    protected int VisualChildrenCount { get; }
    public TemplatedAdorner(UIElement adornedElement, ControlTemplate adornerTemplate);
    public void ClearChild();
    public virtual GeneralTransform GetDesiredTransform(GeneralTransform transform);
    public FrameworkElement get_ReferenceElement();
    public void set_ReferenceElement(FrameworkElement value);
    protected virtual Visual GetVisualChild(int index);
    protected virtual int get_VisualChildrenCount();
    protected virtual Size MeasureOverride(Size constraint);
    protected virtual Size ArrangeOverride(Size size);
    internal virtual bool NeedsUpdate(Size oldSize);
}
internal class MS.Internal.Controls.ValidationErrorCollection : ObservableCollection`1<ValidationError> {
    public static ReadOnlyObservableCollection`1<ValidationError> Empty;
    private static ValidationErrorCollection();
}
internal class MS.Internal.Controls.ValidationRuleCollection : Collection`1<ValidationRule> {
    protected virtual void InsertItem(int index, ValidationRule item);
    protected virtual void SetItem(int index, ValidationRule item);
}
[ClassInterfaceAttribute("0")]
internal class MS.Internal.Controls.WebBrowserEvent : InternalDispatchObject`1<DWebBrowserEvents2> {
    private WebBrowser _parent;
    public WebBrowserEvent(WebBrowser parent);
    public sealed virtual void BeforeNavigate2(object pDisp, Object& url, Object& flags, Object& targetFrameName, Object& postData, Object& headers, Boolean& cancel);
    private static bool IsAllowedScriptScheme(Uri uri);
    public sealed virtual void NavigateComplete2(object pDisp, Object& url);
    public sealed virtual void DocumentComplete(object pDisp, Object& url);
    private bool ShouldIgnoreCompletionEvent(Object& url);
    public sealed virtual void CommandStateChange(long command, bool enable);
    public sealed virtual void TitleChange(string text);
    public sealed virtual void SetSecureLockIcon(int secureLockIcon);
    public sealed virtual void NewWindow2(Object& ppDisp, Boolean& cancel);
    public sealed virtual void ProgressChange(int progress, int progressMax);
    public sealed virtual void StatusTextChange(string text);
    public sealed virtual void DownloadBegin();
    public sealed virtual void FileDownload(Boolean& activeDocument, Boolean& cancel);
    public sealed virtual void PrivacyImpactedStateChange(bool bImpacted);
    public sealed virtual void UpdatePageStatus(object pDisp, Object& nPage, Object& fDone);
    public sealed virtual void PrintTemplateTeardown(object pDisp);
    public sealed virtual void PrintTemplateInstantiation(object pDisp);
    public sealed virtual void NavigateError(object pDisp, Object& url, Object& frame, Object& statusCode, Boolean& cancel);
    public sealed virtual void ClientToHostWindow(Int64& cX, Int64& cY);
    public sealed virtual void WindowClosing(bool isChildWindow, Boolean& cancel);
    public sealed virtual void WindowSetHeight(int height);
    public sealed virtual void WindowSetWidth(int width);
    public sealed virtual void WindowSetTop(int top);
    public sealed virtual void WindowSetLeft(int left);
    public sealed virtual void WindowSetResizable(bool resizable);
    public sealed virtual void OnTheaterMode(bool theaterMode);
    public sealed virtual void OnFullScreen(bool fullScreen);
    public sealed virtual void OnStatusBar(bool statusBar);
    public sealed virtual void OnMenuBar(bool menuBar);
    public sealed virtual void OnToolBar(bool toolBar);
    public sealed virtual void OnVisible(bool visible);
    public sealed virtual void OnQuit();
    public sealed virtual void PropertyChange(string szProperty);
    public sealed virtual void DownloadComplete();
    public sealed virtual void SetPhishingFilterStatus(UInt32 phishingFilterStatus);
    public sealed virtual void WindowStateChanged(UInt32 dwFlags, UInt32 dwValidFlagsMask);
}
internal class MS.Internal.Controls.WebBrowserSite : ActiveXSite {
    internal WebBrowserSite(WebBrowser host);
    private sealed virtual override int MS.Win32.UnsafeNativeMethods.IDocHostUIHandler.ShowContextMenu(int dwID, POINT pt, object pcmdtReserved, object pdispReserved);
    private sealed virtual override int MS.Win32.UnsafeNativeMethods.IDocHostUIHandler.GetHostInfo(DOCHOSTUIINFO info);
    private sealed virtual override int MS.Win32.UnsafeNativeMethods.IDocHostUIHandler.EnableModeless(bool fEnable);
    private sealed virtual override int MS.Win32.UnsafeNativeMethods.IDocHostUIHandler.ShowUI(int dwID, IOleInPlaceActiveObject activeObject, IOleCommandTarget commandTarget, IOleInPlaceFrame frame, IOleInPlaceUIWindow doc);
    private sealed virtual override int MS.Win32.UnsafeNativeMethods.IDocHostUIHandler.HideUI();
    private sealed virtual override int MS.Win32.UnsafeNativeMethods.IDocHostUIHandler.UpdateUI();
    private sealed virtual override int MS.Win32.UnsafeNativeMethods.IDocHostUIHandler.OnDocWindowActivate(bool fActivate);
    private sealed virtual override int MS.Win32.UnsafeNativeMethods.IDocHostUIHandler.OnFrameWindowActivate(bool fActivate);
    private sealed virtual override int MS.Win32.UnsafeNativeMethods.IDocHostUIHandler.ResizeBorder(COMRECT rect, IOleInPlaceUIWindow doc, bool fFrameWindow);
    private sealed virtual override int MS.Win32.UnsafeNativeMethods.IDocHostUIHandler.GetOptionKeyPath(String[] pbstrKey, int dw);
    private sealed virtual override int MS.Win32.UnsafeNativeMethods.IDocHostUIHandler.GetDropTarget(IOleDropTarget pDropTarget, IOleDropTarget& ppDropTarget);
    private sealed virtual override int MS.Win32.UnsafeNativeMethods.IDocHostUIHandler.GetExternal(Object& ppDispatch);
    private sealed virtual override int MS.Win32.UnsafeNativeMethods.IDocHostUIHandler.TranslateAccelerator(MSG& msg, Guid& group, int nCmdID);
    private sealed virtual override int MS.Win32.UnsafeNativeMethods.IDocHostUIHandler.TranslateUrl(int dwTranslate, string strUrlIn, String& pstrUrlOut);
    private sealed virtual override int MS.Win32.UnsafeNativeMethods.IDocHostUIHandler.FilterDataObject(IDataObject pDO, IDataObject& ppDORet);
    private sealed virtual override int MS.Win32.UnsafeNativeMethods.IOleControlSite.TranslateAccelerator(MSG& msg, int grfModifiers);
    private void MoveFocusCallback(object direction);
}
internal class MS.Internal.Data.AbandonedGroupItem : object {
    private LiveShapingItem _lsi;
    private CollectionViewGroupInternal _group;
    public LiveShapingItem Item { get; }
    public CollectionViewGroupInternal Group { get; }
    public AbandonedGroupItem(LiveShapingItem lsi, CollectionViewGroupInternal group);
    public LiveShapingItem get_Item();
    public CollectionViewGroupInternal get_Group();
}
internal class MS.Internal.Data.AccessorInfo : object {
    private object _accessor;
    private Type _propertyType;
    private Object[] _args;
    private int _generation;
    internal object Accessor { get; }
    internal Type PropertyType { get; }
    internal Object[] Args { get; }
    internal int Generation { get; internal set; }
    internal AccessorInfo(object accessor, Type propertyType, Object[] args);
    internal object get_Accessor();
    internal Type get_PropertyType();
    internal Object[] get_Args();
    internal int get_Generation();
    internal void set_Generation(int value);
}
[DefaultMemberAttribute("Item")]
internal class MS.Internal.Data.AccessorTable : object {
    private static int AgeLimit;
    private Hashtable _table;
    private int _generation;
    private bool _cleanupRequested;
    private bool _traceSize;
    internal AccessorInfo Item { get; internal set; }
    internal bool TraceSize { get; internal set; }
    internal AccessorInfo get_Item(SourceValueType sourceValueType, Type type, string name);
    internal void set_Item(SourceValueType sourceValueType, Type type, string name, AccessorInfo value);
    private void RequestCleanup();
    private object CleanupOperation(object arg);
    internal void PrintStats();
    internal bool get_TraceSize();
    internal void set_TraceSize(bool value);
}
internal class MS.Internal.Data.AsyncDataRequest : object {
    private AsyncRequestStatus _status;
    private object _result;
    private object _bindingState;
    private Object[] _args;
    private Exception _exception;
    private AsyncRequestCallback _workCallback;
    private AsyncRequestCallback _completedCallback;
    private object SyncRoot;
    public object Result { get; }
    public AsyncRequestStatus Status { get; }
    public Exception Exception { get; }
    internal Object[] Args { get; }
    internal AsyncDataRequest(object bindingState, AsyncRequestCallback workCallback, AsyncRequestCallback completedCallback, Object[] args);
    public object get_Result();
    public AsyncRequestStatus get_Status();
    public Exception get_Exception();
    public object DoWork();
    public bool DoBeginWork();
    public void Complete(object result);
    public void Cancel();
    public void Fail(Exception exception);
    internal Object[] get_Args();
    private bool ChangeStatus(AsyncRequestStatus newStatus);
}
internal class MS.Internal.Data.AsyncGetValueRequest : AsyncDataRequest {
    private object _item;
    private string _propertyName;
    public object SourceItem { get; }
    internal AsyncGetValueRequest(object item, string propertyName, object bindingState, AsyncRequestCallback workCallback, AsyncRequestCallback completedCallback, Object[] args);
    public object get_SourceItem();
}
internal class MS.Internal.Data.AsyncRequestCallback : MulticastDelegate {
    public AsyncRequestCallback(object object, IntPtr method);
    public virtual object Invoke(AsyncDataRequest request);
    public virtual IAsyncResult BeginInvoke(AsyncDataRequest request, AsyncCallback callback, object object);
    public virtual object EndInvoke(IAsyncResult result);
}
internal enum MS.Internal.Data.AsyncRequestStatus : Enum {
    public int value__;
    public static AsyncRequestStatus Waiting;
    public static AsyncRequestStatus Working;
    public static AsyncRequestStatus Completed;
    public static AsyncRequestStatus Cancelled;
    public static AsyncRequestStatus Failed;
}
internal class MS.Internal.Data.AsyncSetValueRequest : AsyncDataRequest {
    private object _item;
    private string _propertyName;
    private object _value;
    public object TargetItem { get; }
    public object Value { get; }
    internal AsyncSetValueRequest(object item, string propertyName, object value, object bindingState, AsyncRequestCallback workCallback, AsyncRequestCallback completedCallback, Object[] args);
    public object get_TargetItem();
    public object get_Value();
}
internal class MS.Internal.Data.BindingCollection : Collection`1<BindingBase> {
    private BindingBase _owner;
    private BindingCollectionChangedCallback _collectionChangedCallback;
    internal BindingCollection(BindingBase owner, BindingCollectionChangedCallback callback);
    protected virtual void ClearItems();
    protected virtual void RemoveItem(int index);
    protected virtual void InsertItem(int index, BindingBase item);
    protected virtual void SetItem(int index, BindingBase item);
    private void ValidateItem(BindingBase binding);
    private void OnBindingCollectionChanged();
}
internal class MS.Internal.Data.BindingCollectionChangedCallback : MulticastDelegate {
    public BindingCollectionChangedCallback(object object, IntPtr method);
    public virtual void Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class MS.Internal.Data.BindingExpressionUncommonField : UncommonField`1<BindingExpression> {
    internal void SetValue(DependencyObject instance, BindingExpression bindingExpr);
    internal void ClearValue(DependencyObject instance);
}
internal class MS.Internal.Data.BindingValueChangedEventArgs : EventArgs {
    private object _oldValue;
    private object _newValue;
    public object OldValue { get; }
    public object NewValue { get; }
    internal BindingValueChangedEventArgs(object oldValue, object newValue);
    public object get_OldValue();
    public object get_NewValue();
}
internal abstract class MS.Internal.Data.BindingWorker : object {
    private BindingExpression _bindingExpression;
    private UncommonValueTable _values;
    internal Type SourcePropertyType { get; }
    internal bool CanUpdate { get; }
    internal BindingExpression ParentBindingExpression { get; }
    internal Type TargetPropertyType { get; }
    internal bool IsDBNullValidForUpdate { get; }
    internal object SourceItem { get; }
    internal string SourcePropertyName { get; }
    protected Binding ParentBinding { get; }
    protected bool IsDynamic { get; }
    internal bool IsReflective { get; }
    protected bool IgnoreSourcePropertyChange { get; }
    protected object DataItem { get; }
    protected DependencyObject TargetElement { get; }
    protected DependencyProperty TargetProperty { get; }
    protected DataBindEngine Engine { get; }
    protected Dispatcher Dispatcher { get; }
    protected BindingStatusInternal Status { get; protected set; }
    private static BindingWorker();
    protected BindingWorker(BindingExpression b);
    internal virtual Type get_SourcePropertyType();
    internal virtual bool get_CanUpdate();
    internal BindingExpression get_ParentBindingExpression();
    internal Type get_TargetPropertyType();
    internal virtual bool get_IsDBNullValidForUpdate();
    internal virtual object get_SourceItem();
    internal virtual string get_SourcePropertyName();
    internal virtual void AttachDataItem();
    internal virtual void DetachDataItem();
    internal virtual void OnCurrentChanged(ICollectionView collectionView, EventArgs args);
    internal virtual object RawValue();
    internal virtual void UpdateValue(object value);
    internal virtual void RefreshValue();
    internal virtual bool UsesDependencyProperty(DependencyObject d, DependencyProperty dp);
    internal virtual void OnSourceInvalidation(DependencyObject d, DependencyProperty dp, bool isASubPropertyChange);
    internal virtual bool IsPathCurrent();
    protected Binding get_ParentBinding();
    protected bool get_IsDynamic();
    internal bool get_IsReflective();
    protected bool get_IgnoreSourcePropertyChange();
    protected object get_DataItem();
    protected DependencyObject get_TargetElement();
    protected DependencyProperty get_TargetProperty();
    protected DataBindEngine get_Engine();
    protected Dispatcher get_Dispatcher();
    protected BindingStatusInternal get_Status();
    protected void set_Status(BindingStatusInternal value);
    protected void SetTransferIsPending(bool value);
    internal bool HasValue(Feature id);
    internal object GetValue(Feature id, object defaultValue);
    internal void SetValue(Feature id, object value);
    internal void SetValue(Feature id, object value, object defaultValue);
    internal void ClearValue(Feature id);
}
internal class MS.Internal.Data.ClrBindingWorker : BindingWorker {
    private static AsyncRequestCallback DoGetValueCallback;
    private static AsyncRequestCallback CompleteGetValueCallback;
    private static DispatcherOperationCallback CompleteGetValueLocalCallback;
    private static AsyncRequestCallback DoSetValueCallback;
    private static AsyncRequestCallback CompleteSetValueCallback;
    private static DispatcherOperationCallback CompleteSetValueLocalCallback;
    private PropertyPathWorker _pathWorker;
    internal Type SourcePropertyType { get; }
    internal bool IsDBNullValidForUpdate { get; }
    internal object SourceItem { get; }
    internal string SourcePropertyName { get; }
    internal bool CanUpdate { get; }
    internal bool TransfersDefaultValue { get; }
    internal bool ValidatesOnNotifyDataErrors { get; }
    private PropertyPathWorker PW { get; }
    private XmlBindingWorker XmlWorker { get; }
    internal ClrBindingWorker(BindingExpression b, DataBindEngine engine);
    private static ClrBindingWorker();
    private PropertyPath PrepareXmlBinding(PropertyPath path);
    internal virtual Type get_SourcePropertyType();
    internal virtual bool get_IsDBNullValidForUpdate();
    internal virtual object get_SourceItem();
    internal virtual string get_SourcePropertyName();
    internal virtual bool get_CanUpdate();
    internal virtual void AttachDataItem();
    internal virtual void DetachDataItem();
    internal virtual object RawValue();
    internal virtual void RefreshValue();
    internal virtual void UpdateValue(object value);
    internal virtual void OnCurrentChanged(ICollectionView collectionView, EventArgs args);
    internal virtual bool UsesDependencyProperty(DependencyObject d, DependencyProperty dp);
    internal virtual void OnSourceInvalidation(DependencyObject d, DependencyProperty dp, bool isASubPropertyChange);
    internal virtual bool IsPathCurrent();
    internal bool get_TransfersDefaultValue();
    internal bool get_ValidatesOnNotifyDataErrors();
    internal void CancelPendingTasks();
    internal bool AsyncGet(object item, int level);
    internal void ReplaceCurrentItem(ICollectionView oldCollectionView, ICollectionView newCollectionView);
    internal void NewValueAvailable(bool dependencySourcesChanged, bool initialValue, bool isASubPropertyChange);
    internal void SetupDefaultValueConverter(Type type);
    internal bool IsValidValue(object value);
    internal void OnSourcePropertyChanged(object o, string propName);
    internal void OnDataErrorsChanged(INotifyDataErrorInfo indei, string propName);
    internal void OnXmlValueChanged();
    internal void UseNewXmlItem(object item);
    internal object GetResultNode();
    internal DependencyObject CheckTarget();
    internal void ReportGetValueError(int k, object item, Exception ex);
    internal void ReportSetValueError(int k, object item, object value, Exception ex);
    internal void ReportRawValueErrors(int k, object item, object info);
    internal void ReportBadXPath(TraceEventType traceType);
    private PropertyPathWorker get_PW();
    private XmlBindingWorker get_XmlWorker();
    private void SetStatus(PropertyPathStatus status);
    private void ReplaceDependencySources();
    private void RequestAsyncGetValue(object item, int level);
    private static object OnGetValueCallback(AsyncDataRequest adr);
    private static object OnCompleteGetValueCallback(AsyncDataRequest adr);
    private static object OnCompleteGetValueOperation(object arg);
    private void CompleteGetValue(AsyncGetValueRequest request);
    private void RequestAsyncSetValue(object item, object value);
    private static object OnSetValueCallback(AsyncDataRequest adr);
    private static object OnCompleteSetValueCallback(AsyncDataRequest adr);
    private static object OnCompleteSetValueOperation(object arg);
    private void CompleteSetValue(AsyncSetValueRequest request);
    private string GetNameFromInfo(object info);
    private object ScheduleTransferOperation(object arg);
    [CompilerGeneratedAttribute]
private object <OnDataErrorsChanged>b__32_0(object arg);
}
internal class MS.Internal.Data.CollectionRecord : object {
    public SynchronizationInfo SynchronizationInfo;
    private WeakReference _wrViewTable;
    public ViewTable ViewTable { get; public set; }
    public bool IsAlive { get; }
    public ViewTable get_ViewTable();
    public void set_ViewTable(ViewTable value);
    public bool get_IsAlive();
}
internal class MS.Internal.Data.CollectionViewGroupInternal : CollectionViewGroup {
    private GroupDescription _groupBy;
    private CollectionViewGroupInternal _parentGroup;
    private IComparer _groupComparer;
    private int _fullCount;
    private int _lastIndex;
    private int _version;
    private Hashtable _nameToGroupMap;
    private bool _mapCleanupScheduled;
    private bool _isExplicit;
    private static NamedObject _nullGroupNameKey;
    public bool IsBottomLevel { get; }
    internal GroupDescription GroupBy { get; internal set; }
    internal int FullCount { get; internal set; }
    internal int LastIndex { get; internal set; }
    internal object SeedItem { get; }
    internal CollectionViewGroupInternal Parent { get; }
    private bool IsExplicit { get; }
    internal CollectionViewGroupInternal(object name, CollectionViewGroupInternal parent, bool isExplicit);
    private static CollectionViewGroupInternal();
    public virtual bool get_IsBottomLevel();
    internal GroupDescription get_GroupBy();
    internal void set_GroupBy(GroupDescription value);
    internal int get_FullCount();
    internal void set_FullCount(int value);
    internal int get_LastIndex();
    internal void set_LastIndex(int value);
    internal object get_SeedItem();
    internal void Add(object item);
    internal int Remove(object item, bool returnLeafIndex);
    internal void Clear();
    internal int LeafIndexOf(object item);
    internal int LeafIndexFromItem(object item, int index);
    internal object LeafAt(int index);
    internal IEnumerator GetLeafEnumerator();
    internal int Insert(object item, object seed, IComparer comparer);
    protected virtual int FindIndex(object item, object seed, IComparer comparer, int low, int high);
    internal bool Move(object item, IList list, Int32& oldIndex, Int32& newIndex);
    protected virtual void OnGroupByChanged();
    internal void AddSubgroupToMap(object nameKey, CollectionViewGroupInternal subgroup);
    private void RemoveSubgroupFromMap(CollectionViewGroupInternal subgroup);
    internal CollectionViewGroupInternal GetSubgroupFromMap(object nameKey);
    private void ScheduleMapCleanup();
    internal CollectionViewGroupInternal get_Parent();
    private bool get_IsExplicit();
    protected void ChangeCounts(object item, int delta);
    private void OnGroupByChanged(object sender, PropertyChangedEventArgs e);
    [CompilerGeneratedAttribute]
private CollectionView <set_GroupBy>b__5_0();
    [CompilerGeneratedAttribute]
private void <ScheduleMapCleanup>b__28_0();
}
internal class MS.Internal.Data.CollectionViewGroupRoot : CollectionViewGroupInternal {
    [CompilerGeneratedAttribute]
private NotifyCollectionChangedEventHandler CollectionChanged;
    [CompilerGeneratedAttribute]
private EventHandler GroupDescriptionChanged;
    private CollectionView _view;
    private IComparer _comparer;
    private bool _isDataInGroupOrder;
    private ObservableCollection`1<GroupDescription> _groupBy;
    private GroupDescriptionSelectorCallback _groupBySelector;
    private static GroupDescription _topLevelGroupDescription;
    private static object UseAsItemDirectly;
    public ObservableCollection`1<GroupDescription> GroupDescriptions { get; }
    public GroupDescriptionSelectorCallback GroupBySelector { get; public set; }
    internal IComparer ActiveComparer { get; internal set; }
    internal CultureInfo Culture { get; }
    internal bool IsDataInGroupOrder { get; internal set; }
    internal CollectionView View { get; }
    internal CollectionViewGroupRoot(CollectionView view);
    private static CollectionViewGroupRoot();
    [CompilerGeneratedAttribute]
public sealed virtual void add_CollectionChanged(NotifyCollectionChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_CollectionChanged(NotifyCollectionChangedEventHandler value);
    public void OnCollectionChanged(NotifyCollectionChangedEventArgs args);
    public virtual ObservableCollection`1<GroupDescription> get_GroupDescriptions();
    public virtual GroupDescriptionSelectorCallback get_GroupBySelector();
    public virtual void set_GroupBySelector(GroupDescriptionSelectorCallback value);
    protected virtual void OnGroupByChanged();
    [CompilerGeneratedAttribute]
internal void add_GroupDescriptionChanged(EventHandler value);
    [CompilerGeneratedAttribute]
internal void remove_GroupDescriptionChanged(EventHandler value);
    internal IComparer get_ActiveComparer();
    internal void set_ActiveComparer(IComparer value);
    internal CultureInfo get_Culture();
    internal bool get_IsDataInGroupOrder();
    internal void set_IsDataInGroupOrder(bool value);
    internal CollectionView get_View();
    internal void Initialize();
    internal void AddToSubgroups(object item, LiveShapingItem lsi, bool loading);
    internal bool RemoveFromSubgroups(object item);
    internal void RemoveItemFromSubgroupsByExhaustiveSearch(object item);
    internal void InsertSpecialItem(int index, object item, bool loading);
    internal void RemoveSpecialItem(int index, object item, bool loading);
    internal void MoveWithinSubgroups(object item, LiveShapingItem lsi, IList list, int oldIndex, int newIndex);
    protected virtual int FindIndex(object item, object seed, IComparer comparer, int low, int high);
    internal void RestoreGrouping(LiveShapingItem lsi, List`1<AbandonedGroupItem> deleteList);
    private void RestoreGrouping(LiveShapingItem lsi, GroupTreeNode node, int level, List`1<AbandonedGroupItem> deleteList);
    private GroupTreeNode BuildGroupTree(LiveShapingItem lsi);
    internal void DeleteAbandonedGroupItems(List`1<AbandonedGroupItem> deleteList);
    private void InitializeGroup(CollectionViewGroupInternal group, GroupDescription parentDescription, int level);
    private GroupDescription GetGroupDescription(CollectionViewGroup group, GroupDescription parentDescription, int level);
    private void AddToSubgroups(object item, LiveShapingItem lsi, CollectionViewGroupInternal group, int level, bool loading);
    private void AddToSubgroup(object item, LiveShapingItem lsi, CollectionViewGroupInternal group, int level, object name, bool loading);
    private void MoveWithinSubgroups(object item, CollectionViewGroupInternal group, int level, IList list, int oldIndex, int newIndex);
    private void MoveWithinSubgroup(object item, CollectionViewGroupInternal group, int level, object name, IList list, int oldIndex, int newIndex);
    private void MoveWithinSubgroup(object item, CollectionViewGroupInternal group, IList list, int oldIndex, int newIndex);
    private object GetGroupNameKey(object name, CollectionViewGroupInternal group);
    private bool RemoveFromSubgroups(object item, CollectionViewGroupInternal group, int level);
    private bool RemoveFromSubgroup(object item, CollectionViewGroupInternal group, int level, object name);
    private bool RemoveFromGroupDirectly(CollectionViewGroupInternal group, object item);
    private void RemoveItemFromSubgroupsByExhaustiveSearch(CollectionViewGroupInternal group, object item);
    private object GetGroupName(object item, GroupDescription groupDescription, int level);
}
internal class MS.Internal.Data.CollectionViewProxy : CollectionView {
    private ICollectionView _view;
    private IndexedEnumerable _indexer;
    [CompilerGeneratedAttribute]
private CurrentChangingEventHandler PrivateCurrentChanging;
    [CompilerGeneratedAttribute]
private EventHandler PrivateCurrentChanged;
    private ObservableCollection`1<string> _liveSortingProperties;
    private ObservableCollection`1<string> _liveFilteringProperties;
    private ObservableCollection`1<string> _liveGroupingProperties;
    public CultureInfo Culture { get; public set; }
    public IEnumerable SourceCollection { get; }
    public Predicate`1<object> Filter { get; public set; }
    public bool CanFilter { get; }
    public SortDescriptionCollection SortDescriptions { get; }
    public bool CanSort { get; }
    public bool CanGroup { get; }
    public ObservableCollection`1<GroupDescription> GroupDescriptions { get; }
    public ReadOnlyObservableCollection`1<object> Groups { get; }
    public object CurrentItem { get; }
    public int CurrentPosition { get; }
    public bool IsCurrentAfterLast { get; }
    public bool IsCurrentBeforeFirst { get; }
    public int Count { get; }
    public bool IsEmpty { get; }
    public ICollectionView ProxiedView { get; }
    private NewItemPlaceholderPosition System.ComponentModel.IEditableCollectionView.NewItemPlaceholderPosition { get; private set; }
    private bool System.ComponentModel.IEditableCollectionView.CanAddNew { get; }
    private bool System.ComponentModel.IEditableCollectionView.IsAddingNew { get; }
    private object System.ComponentModel.IEditableCollectionView.CurrentAddItem { get; }
    private bool System.ComponentModel.IEditableCollectionView.CanRemove { get; }
    private bool System.ComponentModel.IEditableCollectionView.CanCancelEdit { get; }
    private bool System.ComponentModel.IEditableCollectionView.IsEditingItem { get; }
    private object System.ComponentModel.IEditableCollectionView.CurrentEditItem { get; }
    private bool System.ComponentModel.IEditableCollectionViewAddNewItem.CanAddNewItem { get; }
    private bool System.ComponentModel.ICollectionViewLiveShaping.CanChangeLiveSorting { get; }
    private bool System.ComponentModel.ICollectionViewLiveShaping.CanChangeLiveFiltering { get; }
    private bool System.ComponentModel.ICollectionViewLiveShaping.CanChangeLiveGrouping { get; }
    private Nullable`1<bool> System.ComponentModel.ICollectionViewLiveShaping.IsLiveSorting { get; private set; }
    private Nullable`1<bool> System.ComponentModel.ICollectionViewLiveShaping.IsLiveFiltering { get; private set; }
    private Nullable`1<bool> System.ComponentModel.ICollectionViewLiveShaping.IsLiveGrouping { get; private set; }
    private ObservableCollection`1<string> System.ComponentModel.ICollectionViewLiveShaping.LiveSortingProperties { get; }
    private ObservableCollection`1<string> System.ComponentModel.ICollectionViewLiveShaping.LiveFilteringProperties { get; }
    private ObservableCollection`1<string> System.ComponentModel.ICollectionViewLiveShaping.LiveGroupingProperties { get; }
    private ReadOnlyCollection`1<ItemPropertyInfo> System.ComponentModel.IItemProperties.ItemProperties { get; }
    private IndexedEnumerable EnumerableWrapper { get; }
    internal CollectionViewProxy(ICollectionView view);
    public virtual CultureInfo get_Culture();
    public virtual void set_Culture(CultureInfo value);
    public virtual bool Contains(object item);
    public virtual IEnumerable get_SourceCollection();
    public virtual Predicate`1<object> get_Filter();
    public virtual void set_Filter(Predicate`1<object> value);
    public virtual bool get_CanFilter();
    public virtual SortDescriptionCollection get_SortDescriptions();
    public virtual bool get_CanSort();
    public virtual bool get_CanGroup();
    public virtual ObservableCollection`1<GroupDescription> get_GroupDescriptions();
    public virtual ReadOnlyObservableCollection`1<object> get_Groups();
    public virtual void Refresh();
    public virtual IDisposable DeferRefresh();
    public virtual object get_CurrentItem();
    public virtual int get_CurrentPosition();
    public virtual bool get_IsCurrentAfterLast();
    public virtual bool get_IsCurrentBeforeFirst();
    public virtual bool MoveCurrentToFirst();
    public virtual bool MoveCurrentToPrevious();
    public virtual bool MoveCurrentToNext();
    public virtual bool MoveCurrentToLast();
    public virtual bool MoveCurrentTo(object item);
    public virtual bool MoveCurrentToPosition(int position);
    public virtual void add_CurrentChanging(CurrentChangingEventHandler value);
    public virtual void remove_CurrentChanging(CurrentChangingEventHandler value);
    public virtual void add_CurrentChanged(EventHandler value);
    public virtual void remove_CurrentChanged(EventHandler value);
    public virtual int get_Count();
    public virtual bool get_IsEmpty();
    public ICollectionView get_ProxiedView();
    public virtual int IndexOf(object item);
    public virtual bool PassesFilter(object item);
    public virtual object GetItemAt(int index);
    public virtual void DetachFromSourceCollection();
    private sealed virtual override NewItemPlaceholderPosition System.ComponentModel.IEditableCollectionView.get_NewItemPlaceholderPosition();
    private sealed virtual override void System.ComponentModel.IEditableCollectionView.set_NewItemPlaceholderPosition(NewItemPlaceholderPosition value);
    private sealed virtual override bool System.ComponentModel.IEditableCollectionView.get_CanAddNew();
    private sealed virtual override object System.ComponentModel.IEditableCollectionView.AddNew();
    private sealed virtual override void System.ComponentModel.IEditableCollectionView.CommitNew();
    private sealed virtual override void System.ComponentModel.IEditableCollectionView.CancelNew();
    private sealed virtual override bool System.ComponentModel.IEditableCollectionView.get_IsAddingNew();
    private sealed virtual override object System.ComponentModel.IEditableCollectionView.get_CurrentAddItem();
    private sealed virtual override bool System.ComponentModel.IEditableCollectionView.get_CanRemove();
    private sealed virtual override void System.ComponentModel.IEditableCollectionView.RemoveAt(int index);
    private sealed virtual override void System.ComponentModel.IEditableCollectionView.Remove(object item);
    private sealed virtual override void System.ComponentModel.IEditableCollectionView.EditItem(object item);
    private sealed virtual override void System.ComponentModel.IEditableCollectionView.CommitEdit();
    private sealed virtual override void System.ComponentModel.IEditableCollectionView.CancelEdit();
    private sealed virtual override bool System.ComponentModel.IEditableCollectionView.get_CanCancelEdit();
    private sealed virtual override bool System.ComponentModel.IEditableCollectionView.get_IsEditingItem();
    private sealed virtual override object System.ComponentModel.IEditableCollectionView.get_CurrentEditItem();
    private sealed virtual override bool System.ComponentModel.IEditableCollectionViewAddNewItem.get_CanAddNewItem();
    private sealed virtual override object System.ComponentModel.IEditableCollectionViewAddNewItem.AddNewItem(object newItem);
    private sealed virtual override bool System.ComponentModel.ICollectionViewLiveShaping.get_CanChangeLiveSorting();
    private sealed virtual override bool System.ComponentModel.ICollectionViewLiveShaping.get_CanChangeLiveFiltering();
    private sealed virtual override bool System.ComponentModel.ICollectionViewLiveShaping.get_CanChangeLiveGrouping();
    private sealed virtual override Nullable`1<bool> System.ComponentModel.ICollectionViewLiveShaping.get_IsLiveSorting();
    private sealed virtual override void System.ComponentModel.ICollectionViewLiveShaping.set_IsLiveSorting(Nullable`1<bool> value);
    private sealed virtual override Nullable`1<bool> System.ComponentModel.ICollectionViewLiveShaping.get_IsLiveFiltering();
    private sealed virtual override void System.ComponentModel.ICollectionViewLiveShaping.set_IsLiveFiltering(Nullable`1<bool> value);
    private sealed virtual override Nullable`1<bool> System.ComponentModel.ICollectionViewLiveShaping.get_IsLiveGrouping();
    private sealed virtual override void System.ComponentModel.ICollectionViewLiveShaping.set_IsLiveGrouping(Nullable`1<bool> value);
    private sealed virtual override ObservableCollection`1<string> System.ComponentModel.ICollectionViewLiveShaping.get_LiveSortingProperties();
    private sealed virtual override ObservableCollection`1<string> System.ComponentModel.ICollectionViewLiveShaping.get_LiveFilteringProperties();
    private sealed virtual override ObservableCollection`1<string> System.ComponentModel.ICollectionViewLiveShaping.get_LiveGroupingProperties();
    private sealed virtual override ReadOnlyCollection`1<ItemPropertyInfo> System.ComponentModel.IItemProperties.get_ItemProperties();
    protected virtual IEnumerator GetEnumerator();
    internal virtual void GetCollectionChangedSources(int level, Action`4<int, object, Nullable`1<bool>, List`1<string>> format, List`1<string> sources);
    private void _OnPropertyChanged(object sender, PropertyChangedEventArgs args);
    private void _OnViewChanged(object sender, NotifyCollectionChangedEventArgs args);
    private void _OnCurrentChanging(object sender, CurrentChangingEventArgs args);
    private void _OnCurrentChanged(object sender, EventArgs args);
    private IndexedEnumerable get_EnumerableWrapper();
    [CompilerGeneratedAttribute]
private void add_PrivateCurrentChanging(CurrentChangingEventHandler value);
    [CompilerGeneratedAttribute]
private void remove_PrivateCurrentChanging(CurrentChangingEventHandler value);
    [CompilerGeneratedAttribute]
private void add_PrivateCurrentChanged(EventHandler value);
    [CompilerGeneratedAttribute]
private void remove_PrivateCurrentChanged(EventHandler value);
}
internal class MS.Internal.Data.CommitManager : object {
    private Set`1<BindingGroup> _bindingGroups;
    private Set`1<BindingExpressionBase> _bindings;
    private static List`1<BindingGroup> EmptyBindingGroupList;
    private static List`1<BindingExpressionBase> EmptyBindingList;
    internal bool IsEmpty { get; }
    private static CommitManager();
    internal bool get_IsEmpty();
    internal void AddBindingGroup(BindingGroup bindingGroup);
    internal void RemoveBindingGroup(BindingGroup bindingGroup);
    internal void AddBinding(BindingExpressionBase binding);
    internal void RemoveBinding(BindingExpressionBase binding);
    internal List`1<BindingGroup> GetBindingGroupsInScope(DependencyObject element);
    internal List`1<BindingExpressionBase> GetBindingsInScope(DependencyObject element);
    internal bool Purge();
    private bool IsInScope(DependencyObject ancestor, DependencyObject element);
}
internal class MS.Internal.Data.CompositeCollectionView : CollectionView {
    private TraceLog _traceLog;
    private CompositeCollection _collection;
    private int _count;
    private int _version;
    private int _currentPositionX;
    private int _currentPositionY;
    private static object s_afterLast;
    public int Count { get; }
    public bool IsEmpty { get; }
    private bool PrivateIsEmpty { get; }
    public bool IsCurrentAfterLast { get; }
    public bool IsCurrentBeforeFirst { get; }
    public bool CanFilter { get; }
    private bool IsCurrentInView { get; }
    internal CompositeCollectionView(CompositeCollection collection);
    private static CompositeCollectionView();
    public virtual int get_Count();
    public virtual bool get_IsEmpty();
    private bool get_PrivateIsEmpty();
    public virtual bool get_IsCurrentAfterLast();
    public virtual bool get_IsCurrentBeforeFirst();
    public virtual bool get_CanFilter();
    public virtual bool Contains(object item);
    public virtual int IndexOf(object item);
    public virtual object GetItemAt(int index);
    public virtual bool MoveCurrentTo(object item);
    public virtual bool MoveCurrentToFirst();
    public virtual bool MoveCurrentToLast();
    public virtual bool MoveCurrentToNext();
    public virtual bool MoveCurrentToPrevious();
    public virtual bool MoveCurrentToPosition(int position);
    protected virtual void RefreshOverride();
    protected virtual IEnumerator GetEnumerator();
    protected virtual void ProcessCollectionChanged(NotifyCollectionChangedEventArgs args);
    internal void OnContainedCollectionChanged(object sender, NotifyCollectionChangedEventArgs args);
    internal virtual bool HasReliableHashCodes();
    internal virtual void GetCollectionChangedSources(int level, Action`4<int, object, Nullable`1<bool>, List`1<string>> format, List`1<string> sources);
    private bool get_IsCurrentInView();
    private int FindItem(object item, bool changeCurrent);
    private object GetItem(int flatIndex, Int32& positionX, Int32& positionY);
    private object GetNextItemFromXY(int positionX, int positionY);
    private int CountDeep(int end);
    private void CacheCount(int count);
    private bool _MoveTo(int proposed);
    private int DeduceFlatIndexForAdd(CollectionContainer sender, int x);
    private int DeduceFlatIndexForRemove(CollectionContainer sender, int x, object item);
    private void UpdateCurrencyAfterAdd(int flatIndex, int positionX, bool isCompositeItem);
    private void UpdateCurrencyAfterRemove(int flatIndex, int positionX, bool isCompositeItem);
    private void UpdateCurrencyAfterMove(int oldIndex, int newIndex, int positionX, bool isCompositeItem);
    private void UpdateCurrencyAfterRefresh(object refreshedObject);
    private void MoveCurrencyOffDeletedElement();
    private object GetLastItem(Int32& positionX, Int32& positionY);
    private void SetCurrentBeforeFirst();
    private void SetCurrentPositionFromXY(int x, int y);
    private void InitializeTraceLog();
    private void TraceContainerCollectionChange(object sender, NotifyCollectionChangedAction action, object oldItem, object newItem);
    private void ValidateCollectionChangedEventArgs(NotifyCollectionChangedEventArgs e);
    private void OnPropertyChanged(string propertyName);
}
internal class MS.Internal.Data.DataBindEngine : DispatcherObject {
    private HybridDictionary _mostRecentTask;
    private Task _head;
    private Task _tail;
    private UIElement _layoutElement;
    private ViewManager _viewManager;
    private CommitManager _commitManager;
    private ValueConverterTable _valueConverterTable;
    private PathParser _pathParser;
    private IAsyncDataDispatcher _defaultAsyncDataDispatcher;
    private HybridDictionary _asyncDispatchers;
    private ValueConverterContext _valueConverterContext;
    private bool _cleanupEnabled;
    private ValueTable _valueTable;
    private AccessorTable _accessorTable;
    private int _cleanupRequests;
    private CleanupHelper _cleanupHelper;
    private Queue`1<DataBindOperation> _crossThreadQueue;
    private object _crossThreadQueueLock;
    private int _crossThreadCost;
    private DispatcherOperation _crossThreadDispatcherOperation;
    internal static int CrossThreadThreshold;
    [ThreadStaticAttribute]
private static DataBindEngine _currentEngine;
    internal PathParser PathParser { get; }
    internal ValueConverterContext ValueConverterContext { get; }
    internal AccessorTable AccessorTable { get; }
    internal bool IsShutDown { get; }
    internal bool CleanupEnabled { get; internal set; }
    internal IAsyncDataDispatcher AsyncDataDispatcher { get; }
    internal static DataBindEngine CurrentDataBindEngine { get; }
    internal ViewManager ViewManager { get; }
    internal CommitManager CommitManager { get; }
    internal PathParser get_PathParser();
    internal ValueConverterContext get_ValueConverterContext();
    internal AccessorTable get_AccessorTable();
    internal bool get_IsShutDown();
    internal bool get_CleanupEnabled();
    internal void set_CleanupEnabled(bool value);
    internal IAsyncDataDispatcher get_AsyncDataDispatcher();
    internal static DataBindEngine get_CurrentDataBindEngine();
    internal ViewManager get_ViewManager();
    internal CommitManager get_CommitManager();
    internal void AddTask(IDataBindEngineClient c, TaskOps op);
    internal void CancelTask(IDataBindEngineClient c, TaskOps op);
    internal void CancelTasks(IDataBindEngineClient c);
    internal object Run(object arg);
    internal ViewRecord GetViewRecord(object collection, CollectionViewSource key, Type collectionViewType, bool createView, Func`2<object, object> GetSourceItem);
    internal void RegisterCollectionSynchronizationCallback(IEnumerable collection, object context, CollectionSynchronizationCallback synchronizationCallback);
    internal IValueConverter GetDefaultValueConverter(Type sourceType, Type targetType, bool targetToSource);
    internal void AddAsyncRequest(DependencyObject target, AsyncDataRequest request);
    internal object GetValue(object item, PropertyDescriptor pd, bool indexerIsNext);
    internal void RegisterForCacheChanges(object item, object descriptor);
    internal void ScheduleCleanup();
    private bool DoCleanup(bool forceCleanup);
    internal bool Cleanup();
    private bool DoCleanup();
    internal DataBindOperation Marshal(DispatcherOperationCallback method, object arg, int cost);
    internal void ChangeCost(DataBindOperation op, int delta);
    private void ProcessCrossThreadRequests();
    private void RequestRun();
    private object CleanupOperation(object arg);
    private void OnShutDown();
    private void OnLayoutUpdated(object sender, EventArgs e);
}
internal class MS.Internal.Data.DataBindOperation : object {
    private DispatcherOperationCallback _method;
    private object _arg;
    private int _cost;
    public int Cost { get; public set; }
    public DataBindOperation(DispatcherOperationCallback method, object arg, int cost);
    public int get_Cost();
    public void set_Cost(int value);
    public void Invoke();
}
[ExtensionAttribute]
internal static class MS.Internal.Data.DataExtensionMethods : object {
    [ExtensionAttribute]
internal static int Search(IList list, int index, int count, object value, IComparer comparer);
    [ExtensionAttribute]
internal static int Search(IList list, object value, IComparer comparer);
    [ExtensionAttribute]
internal static void Move(IList list, int oldIndex, int newIndex);
    [ExtensionAttribute]
internal static void Sort(IList list, IComparer comparer);
}
internal class MS.Internal.Data.DefaultAsyncDataDispatcher : object {
    private ArrayList _list;
    private sealed virtual override void MS.Internal.Data.IAsyncDataDispatcher.AddRequest(AsyncDataRequest request);
    private sealed virtual override void MS.Internal.Data.IAsyncDataDispatcher.CancelAllRequests();
    private void ProcessRequest(object o);
}
internal class MS.Internal.Data.DefaultValueConverter : object {
    internal static IValueConverter ValueConverterNotNeeded;
    protected Type _sourceType;
    protected Type _targetType;
    private TypeConverter _typeConverter;
    private bool _shouldConvertFrom;
    private bool _shouldConvertTo;
    private DataBindEngine _engine;
    private static Type StringType;
    protected DataBindEngine Engine { get; }
    protected DefaultValueConverter(TypeConverter typeConverter, Type sourceType, Type targetType, bool shouldConvertFrom, bool shouldConvertTo, DataBindEngine engine);
    private static DefaultValueConverter();
    internal static IValueConverter Create(Type sourceType, Type targetType, bool targetToSource, DataBindEngine engine);
    internal static TypeConverter GetConverter(Type type);
    internal static object TryParse(object o, Type targetType, CultureInfo culture);
    protected object ConvertFrom(object o, Type destinationType, DependencyObject targetElement, CultureInfo culture);
    protected object ConvertTo(object o, Type destinationType, DependencyObject targetElement, CultureInfo culture);
    protected void EnsureConverter(Type type);
    private object ConvertHelper(object o, Type destinationType, DependencyObject targetElement, CultureInfo culture, bool isForward);
    protected DataBindEngine get_Engine();
}
internal class MS.Internal.Data.DifferencingCollection : ObservableCollection`1<object> {
    private static object Unset;
    internal DifferencingCollection(IEnumerable enumerable);
    private static DifferencingCollection();
    internal void Update(IEnumerable enumerable);
    private void LoadItems(IEnumerable enumerable);
    private void Reload(IEnumerable enumerable);
}
internal class MS.Internal.Data.DisplayMemberTemplateSelector : DataTemplateSelector {
    private string _displayMemberPath;
    private string _stringFormat;
    private DataTemplate _xmlNodeContentTemplate;
    private DataTemplate _clrNodeContentTemplate;
    public DisplayMemberTemplateSelector(string displayMemberPath, string stringFormat);
    public virtual DataTemplate SelectTemplate(object item, DependencyObject container);
}
internal enum MS.Internal.Data.DrillIn : Enum {
    public int value__;
    public static DrillIn Never;
    public static DrillIn IfNeeded;
    public static DrillIn Always;
}
internal abstract class MS.Internal.Data.DynamicIndexerAccessor : DynamicObjectAccessor {
    protected DynamicIndexerAccessor(Type ownerType, string propertyName);
    public abstract virtual object GetValue(object component, Object[] args);
    public abstract virtual void SetValue(object component, Object[] args, object value);
}
internal class MS.Internal.Data.DynamicObjectAccessor : object {
    private Type _ownerType;
    private string _propertyName;
    public Type OwnerType { get; }
    public string PropertyName { get; }
    public bool IsReadOnly { get; }
    public Type PropertyType { get; }
    protected DynamicObjectAccessor(Type ownerType, string propertyName);
    public Type get_OwnerType();
    public string get_PropertyName();
    public bool get_IsReadOnly();
    public Type get_PropertyType();
    public static string MissingMemberErrorString(object target, string name);
}
internal abstract class MS.Internal.Data.DynamicPropertyAccessor : DynamicObjectAccessor {
    protected DynamicPropertyAccessor(Type ownerType, string propertyName);
    public abstract virtual object GetValue(object component);
    public abstract virtual void SetValue(object component, object value);
}
internal class MS.Internal.Data.DynamicValueConverter : object {
    private Type _sourceType;
    private Type _targetType;
    private IValueConverter _converter;
    private bool _targetToSourceNeeded;
    private DataBindEngine _engine;
    internal DynamicValueConverter(bool targetToSourceNeeded);
    internal DynamicValueConverter(bool targetToSourceNeeded, Type sourceType, Type targetType);
    internal object Convert(object value, Type targetType);
    public sealed virtual object Convert(object value, Type targetType, object parameter, CultureInfo culture);
    public sealed virtual object ConvertBack(object value, Type sourceType, object parameter, CultureInfo culture);
    private void EnsureConverter(Type sourceType, Type targetType);
}
internal class MS.Internal.Data.ElementObjectRef : ObjectRef {
    private string _name;
    internal ElementObjectRef(string name);
    internal virtual object GetObject(DependencyObject d, ObjectRefArgs args);
    public virtual string ToString();
    internal virtual string Identify();
}
internal class MS.Internal.Data.EnumerableCollectionView : CollectionView {
    private ListCollectionView _view;
    private ObservableCollection`1<object> _snapshot;
    private IEnumerator _trackingEnumerator;
    private int _ignoreEventsLevel;
    private bool _pollForChanges;
    private bool _warningHasBeenRaised;
    public CultureInfo Culture { get; public set; }
    public Predicate`1<object> Filter { get; public set; }
    public bool CanFilter { get; }
    public SortDescriptionCollection SortDescriptions { get; }
    public bool CanSort { get; }
    public bool CanGroup { get; }
    public ObservableCollection`1<GroupDescription> GroupDescriptions { get; }
    public ReadOnlyObservableCollection`1<object> Groups { get; }
    public object CurrentItem { get; }
    public int CurrentPosition { get; }
    public bool IsCurrentAfterLast { get; }
    public bool IsCurrentBeforeFirst { get; }
    public ReadOnlyCollection`1<ItemPropertyInfo> ItemProperties { get; }
    public int Count { get; }
    public bool IsEmpty { get; }
    public bool NeedsRefresh { get; }
    internal EnumerableCollectionView(IEnumerable source);
    public virtual CultureInfo get_Culture();
    public virtual void set_Culture(CultureInfo value);
    public virtual bool Contains(object item);
    public virtual Predicate`1<object> get_Filter();
    public virtual void set_Filter(Predicate`1<object> value);
    public virtual bool get_CanFilter();
    public virtual SortDescriptionCollection get_SortDescriptions();
    public virtual bool get_CanSort();
    public virtual bool get_CanGroup();
    public virtual ObservableCollection`1<GroupDescription> get_GroupDescriptions();
    public virtual ReadOnlyObservableCollection`1<object> get_Groups();
    public virtual IDisposable DeferRefresh();
    public virtual object get_CurrentItem();
    public virtual int get_CurrentPosition();
    public virtual bool get_IsCurrentAfterLast();
    public virtual bool get_IsCurrentBeforeFirst();
    public virtual bool MoveCurrentToFirst();
    public virtual bool MoveCurrentToPrevious();
    public virtual bool MoveCurrentToNext();
    public virtual bool MoveCurrentToLast();
    public virtual bool MoveCurrentTo(object item);
    public virtual bool MoveCurrentToPosition(int position);
    public sealed virtual ReadOnlyCollection`1<ItemPropertyInfo> get_ItemProperties();
    public virtual int get_Count();
    public virtual bool get_IsEmpty();
    public virtual bool get_NeedsRefresh();
    public virtual int IndexOf(object item);
    public virtual bool PassesFilter(object item);
    public virtual object GetItemAt(int index);
    protected virtual IEnumerator GetEnumerator();
    protected virtual void RefreshOverride();
    protected virtual void ProcessCollectionChanged(NotifyCollectionChangedEventArgs args);
    private void LoadSnapshot(IEnumerable source);
    private void LoadSnapshotCore(IEnumerable source);
    private void EnsureSnapshot();
    private IDisposable IgnoreViewEvents();
    private void BeginIgnoreEvents();
    private void EndIgnoreEvents();
    private void _OnPropertyChanged(object sender, PropertyChangedEventArgs args);
    private void _OnViewChanged(object sender, NotifyCollectionChangedEventArgs args);
    private void _OnCurrentChanging(object sender, CurrentChangingEventArgs args);
    private void _OnCurrentChanged(object sender, EventArgs args);
}
internal class MS.Internal.Data.ExplicitObjectRef : ObjectRef {
    private object _object;
    private WeakReference _element;
    protected bool ProtectedUsesMentor { get; }
    internal ExplicitObjectRef(object o);
    internal virtual object GetObject(DependencyObject d, ObjectRefArgs args);
    protected virtual bool get_ProtectedUsesMentor();
    internal virtual string Identify();
}
internal interface MS.Internal.Data.IAsyncDataDispatcher {
    public abstract virtual void AddRequest(AsyncDataRequest request);
    public abstract virtual void CancelAllRequests();
}
internal interface MS.Internal.Data.IDataBindEngineClient {
    public DependencyObject TargetElement { get; }
    public abstract virtual void TransferValue();
    public abstract virtual void UpdateValue();
    public abstract virtual bool AttachToContext(bool lastChance);
    public abstract virtual void VerifySourceReference(bool lastChance);
    public abstract virtual void OnTargetUpdated();
    public abstract virtual DependencyObject get_TargetElement();
}
[DefaultMemberAttribute("Item")]
internal class MS.Internal.Data.IndexedEnumerable : object {
    private IEnumerable _enumerable;
    private IEnumerator _enumerator;
    private IEnumerator _changeTracker;
    private ICollection _collection;
    private IList _list;
    private CollectionView _collectionView;
    private int _enumeratorVersion;
    private object _cachedItem;
    private int _cachedIndex;
    private int _cachedVersion;
    private int _cachedCount;
    private Nullable`1<bool> _cachedIsEmpty;
    private PropertyInfo _reflectedCount;
    private PropertyInfo _reflectedItemAt;
    private MethodInfo _reflectedIndexOf;
    private Predicate`1<object> _filterCallback;
    internal int Count { get; }
    internal bool IsEmpty { get; }
    internal object Item { get; }
    internal IEnumerable Enumerable { get; }
    internal ICollection Collection { get; }
    internal IList List { get; }
    internal CollectionView CollectionView { get; }
    private Predicate`1<object> FilterCallback { get; }
    internal IndexedEnumerable(IEnumerable collection);
    internal IndexedEnumerable(IEnumerable collection, Predicate`1<object> filterCallback);
    internal int IndexOf(object item);
    internal int get_Count();
    internal bool get_IsEmpty();
    internal object get_Item(int index);
    internal IEnumerable get_Enumerable();
    internal ICollection get_Collection();
    internal IList get_List();
    internal CollectionView get_CollectionView();
    public sealed virtual IEnumerator GetEnumerator();
    internal static void CopyTo(IEnumerable collection, Array array, int index);
    internal void Invalidate();
    private Predicate`1<object> get_FilterCallback();
    private void CacheCurrentItem(int index, object item);
    private bool EnsureCacheCurrent();
    private int EnsureEnumerator();
    private void UseNewEnumerator();
    private void InvalidateEnumerator();
    private void DisposeEnumerator(IEnumerator& ie);
    private void ClearAllCaches();
    private void SetCollection(IEnumerable collection);
    private bool GetNativeCount(Int32& value);
    private bool GetNativeIsEmpty(Boolean& isEmpty);
    private bool GetNativeIndexOf(object item, Int32& value);
    private bool GetNativeItemAt(int index, Object& value);
    private sealed virtual override bool System.Windows.IWeakEventListener.ReceiveWeakEvent(Type managerType, object sender, EventArgs e);
    protected virtual bool ReceiveWeakEvent(Type managerType, object sender, EventArgs e);
    private void OnCollectionChanged(object sender, NotifyCollectionChangedEventArgs e);
}
internal class MS.Internal.Data.IndexerParamInfo : ValueType {
    public string parenString;
    public string valueString;
    public IndexerParamInfo(string paren, string value);
}
internal class MS.Internal.Data.IndexerPropertyInfo : PropertyInfo {
    private static IndexerPropertyInfo _instance;
    internal static IndexerPropertyInfo Instance { get; }
    public PropertyAttributes Attributes { get; }
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public Type PropertyType { get; }
    public Type DeclaringType { get; }
    public string Name { get; }
    public Type ReflectedType { get; }
    private static IndexerPropertyInfo();
    internal static IndexerPropertyInfo get_Instance();
    public virtual PropertyAttributes get_Attributes();
    public virtual bool get_CanRead();
    public virtual bool get_CanWrite();
    public virtual MethodInfo[] GetAccessors(bool nonPublic);
    public virtual MethodInfo GetGetMethod(bool nonPublic);
    public virtual ParameterInfo[] GetIndexParameters();
    public virtual MethodInfo GetSetMethod(bool nonPublic);
    public virtual object GetValue(object obj, BindingFlags invokeAttr, Binder binder, Object[] index, CultureInfo culture);
    public virtual Type get_PropertyType();
    public virtual void SetValue(object obj, object value, BindingFlags invokeAttr, Binder binder, Object[] index, CultureInfo culture);
    public virtual Type get_DeclaringType();
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual string get_Name();
    public virtual Type get_ReflectedType();
}
internal class MS.Internal.Data.InterfaceConverter : object {
    private Type _sourceType;
    private Type _targetType;
    internal InterfaceConverter(Type sourceType, Type targetType);
    public sealed virtual object Convert(object o, Type type, object parameter, CultureInfo culture);
    public sealed virtual object ConvertBack(object o, Type type, object parameter, CultureInfo culture);
    private object ConvertTo(object o, Type type);
}
internal class MS.Internal.Data.ListSourceConverter : object {
    public sealed virtual object Convert(object o, Type type, object parameter, CultureInfo culture);
    public sealed virtual object ConvertBack(object o, Type type, object parameter, CultureInfo culture);
}
internal class MS.Internal.Data.LivePropertyInfo : ValueType {
    private string _path;
    private DependencyProperty _dp;
    public string Path { get; }
    public DependencyProperty Property { get; }
    public LivePropertyInfo(string path, DependencyProperty dp);
    public string get_Path();
    public DependencyProperty get_Property();
}
internal class MS.Internal.Data.LiveShapingBlock : RBNode`1<LiveShapingItem> {
    private LiveShapingBlock ParentBlock { get; }
    private LiveShapingBlock LeftChildBlock { get; }
    private LiveShapingBlock RightChildBlock { get; }
    internal LiveShapingList List { get; }
    internal LiveShapingBlock(bool b);
    private LiveShapingBlock get_ParentBlock();
    private LiveShapingBlock get_LeftChildBlock();
    private LiveShapingBlock get_RightChildBlock();
    internal LiveShapingList get_List();
    public virtual LiveShapingItem SetItemAt(int offset, LiveShapingItem lsi);
    protected virtual void Copy(RBNode`1<LiveShapingItem> sourceNode, int sourceOffset, RBNode`1<LiveShapingItem> destNode, int destOffset, int count);
    internal RBFinger`1<LiveShapingItem> GetFinger(LiveShapingItem lsi);
    internal void FindPosition(LiveShapingItem item, RBFinger`1& oldFinger, RBFinger`1& newFinger, Comparison`1<LiveShapingItem> comparison);
    private RBFinger`1<LiveShapingItem> LocalSearch(LiveShapingItem item, int left, int right, Comparison`1<LiveShapingItem> comparison);
    private RBFinger`1<LiveShapingItem> SearchLeft(LiveShapingItem item, int offset, Comparison`1<LiveShapingItem> comparison);
    private RBFinger`1<LiveShapingItem> SearchRight(LiveShapingItem item, int offset, Comparison`1<LiveShapingItem> comparison);
    private void GetFirstAndLastCleanItems(Int32& first, Int32& last, Int32& size);
}
[FlagsAttribute]
internal enum MS.Internal.Data.LiveShapingFlags : Enum {
    public int value__;
    public static LiveShapingFlags Sorting;
    public static LiveShapingFlags Filtering;
    public static LiveShapingFlags Grouping;
}
internal class MS.Internal.Data.LiveShapingItem : DependencyObject {
    private static DependencyProperty StartingIndexProperty;
    private static DependencyProperty ParentGroupsProperty;
    private LiveShapingBlock _block;
    private object _item;
    private PrivateFlags _flags;
    internal object Item { get; internal set; }
    internal LiveShapingBlock Block { get; internal set; }
    private LiveShapingList List { get; }
    internal bool IsSortDirty { get; internal set; }
    internal bool IsSortPendingClean { get; internal set; }
    internal bool IsFilterDirty { get; internal set; }
    internal bool IsGroupDirty { get; internal set; }
    internal bool FailsFilter { get; internal set; }
    internal bool ForwardChanges { get; internal set; }
    internal bool IsDeleted { get; internal set; }
    internal int StartingIndex { get; internal set; }
    internal List`1<CollectionViewGroupInternal> ParentGroups { get; }
    internal CollectionViewGroupInternal ParentGroup { get; }
    internal LiveShapingItem(object item, LiveShapingList list, bool filtered, LiveShapingBlock block, bool oneTime);
    private static LiveShapingItem();
    internal object get_Item();
    internal void set_Item(object value);
    internal LiveShapingBlock get_Block();
    internal void set_Block(LiveShapingBlock value);
    private LiveShapingList get_List();
    internal bool get_IsSortDirty();
    internal void set_IsSortDirty(bool value);
    internal bool get_IsSortPendingClean();
    internal void set_IsSortPendingClean(bool value);
    internal bool get_IsFilterDirty();
    internal void set_IsFilterDirty(bool value);
    internal bool get_IsGroupDirty();
    internal void set_IsGroupDirty(bool value);
    internal bool get_FailsFilter();
    internal void set_FailsFilter(bool value);
    internal bool get_ForwardChanges();
    internal void set_ForwardChanges(bool value);
    internal bool get_IsDeleted();
    internal void set_IsDeleted(bool value);
    internal void FindPosition(RBFinger`1& oldFinger, RBFinger`1& newFinger, Comparison`1<LiveShapingItem> comparison);
    internal RBFinger`1<LiveShapingItem> GetFinger();
    internal int get_StartingIndex();
    internal void set_StartingIndex(int value);
    internal int GetAndClearStartingIndex();
    internal void SetBinding(string path, DependencyProperty dp, bool oneTime, bool enableXT);
    internal object GetValue(string path, DependencyProperty dp);
    internal void Clear();
    internal void OnCrossThreadPropertyChange(DependencyProperty dp);
    internal void AddParentGroup(CollectionViewGroupInternal group);
    internal void RemoveParentGroup(CollectionViewGroupInternal group);
    internal List`1<CollectionViewGroupInternal> get_ParentGroups();
    internal CollectionViewGroupInternal get_ParentGroup();
    protected virtual void OnPropertyChanged(DependencyPropertyChangedEventArgs e);
    private void OnPropertyChanged(object sender, PropertyChangedEventArgs e);
    private bool TestFlag(PrivateFlags flag);
    private void ChangeFlag(PrivateFlags flag, bool value);
}
[DefaultMemberAttribute("Item")]
internal class MS.Internal.Data.LiveShapingList : object {
    [CompilerGeneratedAttribute]
private EventHandler LiveShapingDirty;
    private ICollectionViewLiveShaping _view;
    private DPFromPath _dpFromPath;
    private LivePropertyInfo[] _compInfos;
    private LivePropertyInfo[] _sortInfos;
    private LivePropertyInfo[] _filterInfos;
    private LivePropertyInfo[] _groupInfos;
    private IComparer _comparer;
    private LiveShapingTree _root;
    private LiveShapingTree _filterRoot;
    private List`1<LiveShapingItem> _sortDirtyItems;
    private List`1<LiveShapingItem> _filterDirtyItems;
    private List`1<LiveShapingItem> _groupDirtyItems;
    private bool _isRestoringLiveSorting;
    private bool _isCustomSorting;
    private static List`1<DependencyProperty> s_dpList;
    private static object s_Sync;
    internal ICollectionViewLiveShaping View { get; }
    internal Dictionary`2<string, DependencyProperty> ObservedProperties { get; }
    internal List`1<LiveShapingItem> SortDirtyItems { get; }
    internal List`1<LiveShapingItem> FilterDirtyItems { get; }
    internal List`1<LiveShapingItem> GroupDirtyItems { get; }
    internal bool IsRestoringLiveSorting { get; }
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    public object Item { get; public set; }
    public int Count { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    internal LiveShapingList(ICollectionViewLiveShaping view, LiveShapingFlags flags, IComparer comparer);
    private static LiveShapingList();
    internal ICollectionViewLiveShaping get_View();
    internal Dictionary`2<string, DependencyProperty> get_ObservedProperties();
    internal void SetLiveShapingProperties(LiveShapingFlags flags);
    private bool TestLiveShapingFlag(LiveShapingFlags flags, LiveShapingFlags flag);
    internal int Search(int index, int count, object value);
    internal void Sort();
    internal int CompareLiveShapingItems(LiveShapingItem x, LiveShapingItem y);
    internal void Move(int oldIndex, int newIndex);
    internal void RestoreLiveSortingByInsertionSort(Action`3<NotifyCollectionChangedEventArgs, int, int> RaiseMoveEvent);
    internal void AddFilteredItem(object item);
    internal void AddFilteredItem(LiveShapingItem lsi);
    internal void SetStartingIndexForFilteredItem(object item, int value);
    internal void RemoveFilteredItem(LiveShapingItem lsi);
    internal void RemoveFilteredItem(object item);
    internal void ReplaceFilteredItem(object oldItem, object newItem);
    internal int IndexOf(LiveShapingItem lsi);
    internal void InitializeItem(LiveShapingItem lsi, object item, bool filtered, bool oneTime);
    internal void ClearItem(LiveShapingItem lsi);
    private string NormalizePath(string path);
    internal void OnItemPropertyChanged(LiveShapingItem lsi, DependencyProperty dp);
    internal void OnItemPropertyChangedCrossThread(LiveShapingItem lsi, DependencyProperty dp);
    [CompilerGeneratedAttribute]
internal void add_LiveShapingDirty(EventHandler value);
    [CompilerGeneratedAttribute]
internal void remove_LiveShapingDirty(EventHandler value);
    private void OnLiveShapingDirty();
    private bool ContainsDP(LivePropertyInfo[] infos, DependencyProperty dp);
    internal void FindPosition(LiveShapingItem lsi, Int32& oldIndex, Int32& newIndex);
    internal List`1<LiveShapingItem> get_SortDirtyItems();
    internal List`1<LiveShapingItem> get_FilterDirtyItems();
    internal List`1<LiveShapingItem> get_GroupDirtyItems();
    internal LiveShapingItem ItemAt(int index);
    internal bool get_IsRestoringLiveSorting();
    public sealed virtual int Add(object value);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(object value);
    public sealed virtual int IndexOf(object value);
    public sealed virtual void Insert(int index, object value);
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual void Remove(object value);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual object get_Item(int index);
    public sealed virtual void set_Item(int index, object value);
    public sealed virtual void CopyTo(Array array, int index);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    public sealed virtual IEnumerator GetEnumerator();
    private void ForEach(Action`1<LiveShapingItem> action);
    private void ForEachUntil(Func`2<LiveShapingItem, bool> action);
    internal bool VerifyLiveSorting(LiveShapingItem lsi);
    [CompilerGeneratedAttribute]
private void <Clear>b__40_0(LiveShapingItem x);
}
internal class MS.Internal.Data.LiveShapingTree : RBTree`1<LiveShapingItem> {
    private LiveShapingList _list;
    private LiveShapingBlock _placeholderBlock;
    internal LiveShapingList List { get; }
    internal LiveShapingBlock PlaceholderBlock { get; }
    internal LiveShapingTree(LiveShapingList list);
    internal LiveShapingList get_List();
    internal LiveShapingBlock get_PlaceholderBlock();
    internal virtual RBNode`1<LiveShapingItem> NewNode();
    internal void Move(int oldIndex, int newIndex);
    internal void RestoreLiveSortingByInsertionSort(Action`3<NotifyCollectionChangedEventArgs, int, int> RaiseMoveEvent);
    internal void FindPosition(LiveShapingItem lsi, Int32& oldIndex, Int32& newIndex);
    internal void ReplaceAt(int index, object item);
    internal LiveShapingItem FindItem(object item);
    public virtual int IndexOf(LiveShapingItem lsi);
}
internal abstract class MS.Internal.Data.ObjectRef : object {
    internal bool UsesMentor { get; }
    protected bool ProtectedUsesMentor { get; }
    internal virtual object GetObject(DependencyObject d, ObjectRefArgs args);
    internal virtual object GetDataObject(DependencyObject d, ObjectRefArgs args);
    internal bool TreeContextIsRequired(DependencyObject target);
    protected virtual bool ProtectedTreeContextIsRequired(DependencyObject target);
    internal bool get_UsesMentor();
    protected virtual bool get_ProtectedUsesMentor();
    internal abstract virtual string Identify();
}
internal class MS.Internal.Data.ObjectRefArgs : object {
    [CompilerGeneratedAttribute]
private bool <IsTracing>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ResolveNamesInTemplate>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <NameResolvedInOuterScope>k__BackingField;
    internal bool IsTracing { get; internal set; }
    internal bool ResolveNamesInTemplate { get; internal set; }
    internal bool NameResolvedInOuterScope { get; internal set; }
    [CompilerGeneratedAttribute]
internal bool get_IsTracing();
    [CompilerGeneratedAttribute]
internal void set_IsTracing(bool value);
    [CompilerGeneratedAttribute]
internal bool get_ResolveNamesInTemplate();
    [CompilerGeneratedAttribute]
internal void set_ResolveNamesInTemplate(bool value);
    [CompilerGeneratedAttribute]
internal bool get_NameResolvedInOuterScope();
    [CompilerGeneratedAttribute]
internal void set_NameResolvedInOuterScope(bool value);
}
internal class MS.Internal.Data.ObjectSourceConverter : DefaultValueConverter {
    public ObjectSourceConverter(Type targetType, DataBindEngine engine);
    public sealed virtual object Convert(object o, Type type, object parameter, CultureInfo culture);
    public sealed virtual object ConvertBack(object o, Type type, object parameter, CultureInfo culture);
}
internal class MS.Internal.Data.ObjectTargetConverter : DefaultValueConverter {
    public ObjectTargetConverter(Type sourceType, DataBindEngine engine);
    public sealed virtual object Convert(object o, Type type, object parameter, CultureInfo culture);
    public sealed virtual object ConvertBack(object o, Type type, object parameter, CultureInfo culture);
}
internal class MS.Internal.Data.ParameterCollection : Collection`1<object> {
    private bool _isReadOnly;
    private ParameterCollectionChanged _parametersChanged;
    private bool System.Collections.IList.IsReadOnly { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    protected bool IsReadOnly { get; protected set; }
    protected bool IsFixedSize { get; }
    public ParameterCollection(ParameterCollectionChanged parametersChanged);
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    protected virtual void ClearItems();
    protected virtual void InsertItem(int index, object value);
    protected virtual void RemoveItem(int index);
    protected virtual void SetItem(int index, object value);
    protected virtual bool get_IsReadOnly();
    protected virtual void set_IsReadOnly(bool value);
    protected bool get_IsFixedSize();
    internal void SetReadOnly(bool isReadOnly);
    internal void ClearInternal();
    private void CheckReadOnly();
    private void OnCollectionChanged();
}
internal class MS.Internal.Data.ParameterCollectionChanged : MulticastDelegate {
    public ParameterCollectionChanged(object object, IntPtr method);
    public virtual void Invoke(ParameterCollection parameters);
    public virtual IAsyncResult BeginInvoke(ParameterCollection parameters, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class MS.Internal.Data.PathParser : object {
    private string _error;
    private State _state;
    private string _path;
    private int _index;
    private int _n;
    private DrillIn _drillIn;
    private ArrayList _al;
    private static char NullChar;
    private static char EscapeChar;
    private static SourceValueInfo[] EmptyInfo;
    private static string SpecialChars;
    public string Error { get; }
    private static PathParser();
    public string get_Error();
    private void SetError(string id, Object[] args);
    public SourceValueInfo[] Parse(string path);
    private void AddProperty();
    private void AddIndexer();
    private void StartNewLevel();
}
internal class MS.Internal.Data.PropertyPathWorker : object {
    private static Char[] s_comma;
    private static Char[] s_dot;
    private static object NoParent;
    private static object AsyncRequestPending;
    internal static object IListIndexOutOfRange;
    private static IList`1<Type> IListIndexerWhitelist;
    private PropertyPath _parent;
    private PropertyPathStatus _status;
    private object _treeContext;
    private object _rootItem;
    private SourceValueState[] _arySVS;
    private ContextHelper _contextHelper;
    private ClrBindingWorker _host;
    private DataBindEngine _engine;
    private bool _dependencySourcesChanged;
    private bool _isDynamic;
    private bool _needsDirectNotification;
    private Nullable`1<bool> _isDBNullValidForUpdate;
    internal int Length { get; }
    internal PropertyPathStatus Status { get; }
    internal DependencyObject TreeContext { get; internal set; }
    internal bool IsDBNullValidForUpdate { get; }
    internal object SourceItem { get; }
    internal string SourcePropertyName { get; }
    internal bool NeedsDirectNotification { get; private set; }
    private bool IsDynamic { get; }
    private SourceValueInfo[] SVI { get; }
    private DataBindEngine Engine { get; }
    internal PropertyPathWorker(PropertyPath path);
    internal PropertyPathWorker(PropertyPath path, ClrBindingWorker host, bool isDynamic, DataBindEngine engine);
    private PropertyPathWorker(PropertyPath path, DataBindEngine engine);
    private static PropertyPathWorker();
    internal int get_Length();
    internal PropertyPathStatus get_Status();
    internal DependencyObject get_TreeContext();
    internal void set_TreeContext(DependencyObject value);
    internal void SetTreeContext(WeakReference wr);
    internal bool get_IsDBNullValidForUpdate();
    internal object get_SourceItem();
    internal string get_SourcePropertyName();
    internal bool get_NeedsDirectNotification();
    private void set_NeedsDirectNotification(bool value);
    internal object GetItem(int level);
    internal object GetAccessor(int level);
    internal Object[] GetIndexerArguments(int level);
    internal Type GetType(int level);
    internal IDisposable SetContext(object rootItem);
    internal void AttachToRootItem(object rootItem);
    internal void DetachFromRootItem();
    internal object GetValue(object item, int level);
    internal void SetValue(object item, object value);
    internal object RawValue();
    internal void RefreshValue();
    internal int LevelForPropertyChange(object item, string propertyName);
    internal void OnPropertyChangedAtLevel(int level);
    internal void OnCurrentChanged(ICollectionView collectionView);
    internal bool UsesDependencyProperty(DependencyObject d, DependencyProperty dp);
    internal void OnDependencyPropertyChanged(DependencyObject d, DependencyProperty dp, bool isASubPropertyChange);
    internal void OnNewValue(int level, object value);
    internal SourceValueInfo GetSourceValueInfo(int level);
    internal static bool IsIndexedProperty(PropertyInfo pi);
    private bool get_IsDynamic();
    private SourceValueInfo[] get_SVI();
    private DataBindEngine get_Engine();
    private void UpdateSourceValueState(int k, ICollectionView collectionView);
    private void UpdateSourceValueState(int k, ICollectionView collectionView, object newValue, bool isASubPropertyChange);
    private void ReplaceItem(int k, object newO, object parent);
    private void ReportNoInfoError(int k, object parent);
    internal bool IsPathCurrent(object rootItem);
    private bool IsNonIdempotentProperty(int level);
    private void GetInfo(int k, object item, SourceValueState& svs);
    private MemberInfo[] GetIndexers(Type type, int k);
    private bool MatchIndexerParameters(PropertyInfo pi, IndexerParameterInfo[] aryInfo, Object[] args, bool isIList);
    private bool ShouldConvertIndexerToProperty(object item, String& name);
    private object RawValue(int k);
    private void SetPropertyInfo(object info, PropertyInfo& pi, PropertyDescriptor& pd, DependencyProperty& dp, DynamicPropertyAccessor& dpa);
    private void CheckReadOnly(object item, object info);
    private bool IsPropertyReadOnly(object item, PropertyInfo pi);
    private void DetermineWhetherDBNullIsValid();
    private bool DetermineWhetherDBNullIsValid(object item);
    private sealed virtual override bool System.Windows.IWeakEventListener.ReceiveWeakEvent(Type managerType, object sender, EventArgs e);
    private void OnPropertyChanged(object sender, PropertyChangedEventArgs e);
    private void OnValueChanged(object sender, ValueChangedEventArgs e);
    private void OnErrorsChanged(object sender, DataErrorsChangedEventArgs e);
    private void OnStaticPropertyChanged(object sender, PropertyChangedEventArgs e);
    private bool IsExtendedTraceEnabled(TraceDataLevel level);
}
internal class MS.Internal.Data.RBFinger`1 : ValueType {
    [CompilerGeneratedAttribute]
private RBNode`1<T> <Node>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Offset>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Index>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Found>k__BackingField;
    public RBNode`1<T> Node { get; public set; }
    public int Offset { get; public set; }
    public int Index { get; public set; }
    public bool Found { get; public set; }
    public T Item { get; }
    public bool IsValid { get; }
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public RBNode`1<T> get_Node();
    [CompilerGeneratedAttribute]
public void set_Node(RBNode`1<T> value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_Offset();
    [CompilerGeneratedAttribute]
public void set_Offset(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_Index();
    [CompilerGeneratedAttribute]
public void set_Index(int value);
    [CompilerGeneratedAttribute]
[IsReadOnlyAttribute]
public bool get_Found();
    [CompilerGeneratedAttribute]
public void set_Found(bool value);
    public T get_Item();
    public void SetItem(T x);
    public bool get_IsValid();
    public static RBFinger`1<T> op_Addition(RBFinger`1<T> finger, int delta);
    public static RBFinger`1<T> op_Subtraction(RBFinger`1<T> finger, int delta);
    public static int op_Subtraction(RBFinger`1<T> f1, RBFinger`1<T> f2);
    public static RBFinger`1<T> op_Increment(RBFinger`1<T> finger);
    public static RBFinger`1<T> op_Decrement(RBFinger`1<T> finger);
    public static bool op_LessThan(RBFinger`1<T> f1, RBFinger`1<T> f2);
    public static bool op_GreaterThan(RBFinger`1<T> f1, RBFinger`1<T> f2);
}
internal class MS.Internal.Data.RBNode`1 : object {
    protected static int MaxSize;
    protected static int BinarySearchThreshold;
    [CompilerGeneratedAttribute]
private RBNode`1<T> <LeftChild>k__BackingField;
    [CompilerGeneratedAttribute]
private RBNode`1<T> <RightChild>k__BackingField;
    [CompilerGeneratedAttribute]
private RBNode`1<T> <Parent>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsRed>k__BackingField;
    private int _size;
    private int _leftSize;
    [CompilerGeneratedAttribute]
private PropertyChangedEventHandler PropertyChanged;
    private T[] _data;
    public RBNode`1<T> LeftChild { get; public set; }
    public RBNode`1<T> RightChild { get; public set; }
    public RBNode`1<T> Parent { get; public set; }
    public bool IsRed { get; public set; }
    public bool HasData { get; }
    public int Size { get; public set; }
    public int LeftSize { get; public set; }
    protected RBNode`1(bool b);
    [CompilerGeneratedAttribute]
public RBNode`1<T> get_LeftChild();
    [CompilerGeneratedAttribute]
public void set_LeftChild(RBNode`1<T> value);
    [CompilerGeneratedAttribute]
public RBNode`1<T> get_RightChild();
    [CompilerGeneratedAttribute]
public void set_RightChild(RBNode`1<T> value);
    [CompilerGeneratedAttribute]
public RBNode`1<T> get_Parent();
    [CompilerGeneratedAttribute]
public void set_Parent(RBNode`1<T> value);
    [CompilerGeneratedAttribute]
public bool get_IsRed();
    [CompilerGeneratedAttribute]
public void set_IsRed(bool value);
    public virtual bool get_HasData();
    public int get_Size();
    public void set_Size(int value);
    public int get_LeftSize();
    public void set_LeftSize(int value);
    public T GetItemAt(int offset);
    public virtual T SetItemAt(int offset, T x);
    public int OffsetOf(T x);
    internal RBNode`1<T> GetSuccessor();
    internal RBNode`1<T> GetPredecessor();
    protected RBFinger`1<T> FindIndex(int index, bool exists);
    protected RBFinger`1<T> Find(T x, Comparison`1<T> comparison);
    protected RBFinger`1<T> BoundedSearch(T x, int low, int high, Comparison`1<T> comparison);
    private int BinarySearch(T x, int low, int high, Comparison`1<T> comparison, int compHigh, Boolean& found);
    protected RBFinger`1<T> LocateItem(RBFinger`1<T> finger, Comparison`1<T> comparison);
    protected virtual void Copy(RBNode`1<T> sourceNode, int sourceOffset, RBNode`1<T> destNode, int destOffset, int count);
    protected void ReInsert(RBFinger`1& oldFinger, RBFinger`1<T> newFinger);
    protected void RemoveAt(RBFinger`1& finger);
    protected RBNode`1<T> InsertNodeAfter(RBNode`1<T> node);
    protected RBTree`1<T> GetRoot(RBNode`1<T> node);
    protected RBTree`1<T> GetRootAndIndex(RBNode`1<T> node, Int32& index);
    internal void InsertAt(int offset, T x, RBNode`1<T> successor, RBNode`1<T> succsucc);
    protected RBNode`1<T> InsertNode(RBTree`1<T> root, RBNode`1<T> parent, RBNode`1<T> node, int index, RBNode`1& newNode);
    protected void ChangeSize(int delta);
    private RBNode`1<T> Substitute(RBNode`1<T> node, RBNode`1<T> sub, RBNode`1<T> parent);
    protected RBNode`1<T> DeleteNode(RBNode`1<T> parent, RBNode`1<T> node, int index);
    private RBNode`1<T> DeleteLeftmost(RBNode`1<T> node, RBNode`1& leftmost);
    private bool IsNodeRed(RBNode`1<T> node);
    private RBNode`1<T> RotateLeft();
    private RBNode`1<T> RotateRight();
    private void ColorFlip();
    private RBNode`1<T> Fixup(RBNode`1<T> node);
    private RBNode`1<T> MoveRedRight(RBNode`1<T> node);
    private RBNode`1<T> MoveRedLeft(RBNode`1<T> node);
    [CompilerGeneratedAttribute]
public sealed virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
    protected void OnPropertyChanged(string name);
}
[DefaultMemberAttribute("Item")]
internal class MS.Internal.Data.RBTree`1 : RBNode`1<T> {
    private static int QuickSortThreshold;
    private Comparison`1<T> _comparison;
    public bool HasData { get; }
    public Comparison`1<T> Comparison { get; public set; }
    public T Item { get; public set; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public virtual bool get_HasData();
    public Comparison`1<T> get_Comparison();
    public void set_Comparison(Comparison`1<T> value);
    public RBFinger`1<T> BoundedSearch(T x, int low, int high);
    public void Insert(T x);
    private void Insert(RBFinger`1<T> finger, T x, bool checkSort);
    public void Sort();
    public void QuickSort();
    public void InsertionSort();
    private void QuickSort3(RBFinger`1<T> low, RBFinger`1<T> high);
    private void Trade(RBFinger`1<T> left, RBFinger`1<T> mid, RBFinger`1<T> right);
    private void Exchange(RBFinger`1<T> f1, RBFinger`1<T> f2);
    private void InsertionSortImpl();
    internal RBNode`1<T> InsertNode(int index);
    internal void RemoveNode(int index);
    internal virtual RBNode`1<T> NewNode();
    internal void ForEach(Action`1<T> action);
    internal void ForEachUntil(Func`2<T, bool> action);
    internal int IndexOf(T item, Func`3<T, T, bool> AreEqual);
    public virtual int IndexOf(T item);
    public sealed virtual void Insert(int index, T item);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual T get_Item(int index);
    public sealed virtual void set_Item(int index, T value);
    public sealed virtual void Add(T item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T item);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool Remove(T item);
    [IteratorStateMachineAttribute("MS.Internal.Data.RBTree`1/<GetEnumerator>d__38")]
public sealed virtual IEnumerator`1<T> GetEnumerator();
    [IteratorStateMachineAttribute("MS.Internal.Data.RBTree`1/<System-Collections-IEnumerable-GetEnumerator>d__39")]
private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private void VerifyIndex(int index, int delta);
    private void Verify(int expectedSize, bool checkSort);
    private void SaveTree();
    public void LoadTree(string s);
}
internal class MS.Internal.Data.RelativeObjectRef : ObjectRef {
    private RelativeSource _relativeSource;
    internal bool ReturnsDataContext { get; }
    protected bool ProtectedUsesMentor { get; }
    internal RelativeObjectRef(RelativeSource relativeSource);
    public virtual string ToString();
    internal virtual object GetObject(DependencyObject d, ObjectRefArgs args);
    internal virtual object GetDataObject(DependencyObject d, ObjectRefArgs args);
    private object GetDataObjectImpl(DependencyObject d, ObjectRefArgs args);
    internal bool get_ReturnsDataContext();
    protected virtual bool ProtectedTreeContextIsRequired(DependencyObject target);
    protected virtual bool get_ProtectedUsesMentor();
    internal virtual string Identify();
    private object GetPreviousData(DependencyObject d);
    private DependencyObject FindAncestorOfType(Type type, int level, DependencyObject d, bool isTracing);
    private int IndexOf(Visual parent, Visual child, Visual& prevChild);
}
internal class MS.Internal.Data.SortFieldComparer : object {
    private SortPropertyInfo[] _fields;
    private SortDescriptionCollection _sortFields;
    private Comparer _comparer;
    internal IComparer BaseComparer { get; }
    internal SortFieldComparer(SortDescriptionCollection sortFields, CultureInfo culture);
    internal IComparer get_BaseComparer();
    public sealed virtual int Compare(object o1, object o2);
    internal static void SortHelper(ArrayList al, IComparer comparer);
    private SortPropertyInfo[] CreatePropertyInfo(SortDescriptionCollection sortFields);
}
internal class MS.Internal.Data.SourceDefaultValueConverter : DefaultValueConverter {
    public SourceDefaultValueConverter(TypeConverter typeConverter, Type sourceType, Type targetType, bool shouldConvertFrom, bool shouldConvertTo, DataBindEngine engine);
    public sealed virtual object Convert(object o, Type type, object parameter, CultureInfo culture);
    public sealed virtual object ConvertBack(object o, Type type, object parameter, CultureInfo culture);
}
internal class MS.Internal.Data.SourceValueInfo : ValueType {
    public SourceValueType type;
    public DrillIn drillIn;
    public string name;
    public FrugalObjectList`1<IndexerParamInfo> paramList;
    public string propertyName;
    public SourceValueInfo(SourceValueType t, DrillIn d, string n);
    public SourceValueInfo(SourceValueType t, DrillIn d, FrugalObjectList`1<IndexerParamInfo> list);
}
internal enum MS.Internal.Data.SourceValueType : Enum {
    public int value__;
    public static SourceValueType Property;
    public static SourceValueType Indexer;
    public static SourceValueType Direct;
}
internal class MS.Internal.Data.StaticPropertyChangedEventManager : WeakEventManager {
    private static string AllListenersKey;
    private static string StaticPropertyChanged;
    private static StaticPropertyChangedEventManager CurrentManager { get; }
    private static StaticPropertyChangedEventManager();
    public static void AddHandler(Type type, EventHandler`1<PropertyChangedEventArgs> handler, string propertyName);
    public static void RemoveHandler(Type type, EventHandler`1<PropertyChangedEventArgs> handler, string propertyName);
    protected virtual ListenerList NewListenerList();
    protected virtual void StartListening(object source);
    protected virtual void StopListening(object source);
    protected virtual bool Purge(object source, object data, bool purgeAll);
    private static StaticPropertyChangedEventManager get_CurrentManager();
    private void PrivateAddHandler(Type type, EventHandler`1<PropertyChangedEventArgs> handler, string propertyName);
    private void PrivateRemoveHandler(Type type, EventHandler`1<PropertyChangedEventArgs> handler, string propertyName);
    private void OnStaticPropertyChanged(TypeRecord typeRecord, PropertyChangedEventArgs args);
}
internal class MS.Internal.Data.SynchronizationInfo : ValueType {
    public static SynchronizationInfo None;
    private object _context;
    private MethodInfo _callbackMethod;
    private WeakReference _callbackTarget;
    public bool IsSynchronized { get; }
    public bool IsAlive { get; }
    public SynchronizationInfo(object context, CollectionSynchronizationCallback callback);
    private static SynchronizationInfo();
    public bool get_IsSynchronized();
    public void AccessCollection(IEnumerable collection, Action accessMethod, bool writeAccess);
    public bool get_IsAlive();
}
internal class MS.Internal.Data.SystemConvertConverter : object {
    private Type _sourceType;
    private Type _targetType;
    private static Type[] SupportedTypes;
    private static Type[] CharSupportedTypes;
    public SystemConvertConverter(Type sourceType, Type targetType);
    private static SystemConvertConverter();
    public sealed virtual object Convert(object o, Type type, object parameter, CultureInfo culture);
    public sealed virtual object ConvertBack(object o, Type type, object parameter, CultureInfo culture);
    public static bool CanConvert(Type sourceType, Type targetType);
    private static bool CanConvertChar(Type type);
}
internal class MS.Internal.Data.TargetDefaultValueConverter : DefaultValueConverter {
    public TargetDefaultValueConverter(TypeConverter typeConverter, Type sourceType, Type targetType, bool shouldConvertFrom, bool shouldConvertTo, DataBindEngine engine);
    public sealed virtual object Convert(object o, Type type, object parameter, CultureInfo culture);
    public sealed virtual object ConvertBack(object o, Type type, object parameter, CultureInfo culture);
}
internal enum MS.Internal.Data.TaskOps : Enum {
    public int value__;
    public static TaskOps TransferValue;
    public static TaskOps UpdateValue;
    public static TaskOps AttachToContext;
    public static TaskOps VerifySourceReference;
    public static TaskOps RaiseTargetUpdatedEvent;
}
internal class MS.Internal.Data.ValueChangedEventArgs : EventArgs {
    private PropertyDescriptor _pd;
    internal PropertyDescriptor PropertyDescriptor { get; }
    internal ValueChangedEventArgs(PropertyDescriptor pd);
    internal PropertyDescriptor get_PropertyDescriptor();
}
internal class MS.Internal.Data.ValueChangedEventManager : WeakEventManager {
    private List`1<PropertyDescriptor> _toRemove;
    private static ValueChangedEventManager CurrentManager { get; }
    public static void AddListener(object source, IWeakEventListener listener, PropertyDescriptor pd);
    public static void RemoveListener(object source, IWeakEventListener listener, PropertyDescriptor pd);
    public static void AddHandler(object source, EventHandler`1<ValueChangedEventArgs> handler, PropertyDescriptor pd);
    public static void RemoveHandler(object source, EventHandler`1<ValueChangedEventArgs> handler, PropertyDescriptor pd);
    protected virtual ListenerList NewListenerList();
    protected virtual void StartListening(object source);
    protected virtual void StopListening(object source);
    protected virtual bool Purge(object source, object data, bool purgeAll);
    private static ValueChangedEventManager get_CurrentManager();
    private void PrivateAddListener(object source, IWeakEventListener listener, PropertyDescriptor pd);
    private void PrivateRemoveListener(object source, IWeakEventListener listener, PropertyDescriptor pd);
    private void PrivateAddHandler(object source, EventHandler`1<ValueChangedEventArgs> handler, PropertyDescriptor pd);
    private void PrivateRemoveHandler(object source, EventHandler`1<ValueChangedEventArgs> handler, PropertyDescriptor pd);
    private void AddListener(object source, PropertyDescriptor pd, IWeakEventListener listener, EventHandler`1<ValueChangedEventArgs> handler);
    private void RemoveListener(object source, PropertyDescriptor pd, IWeakEventListener listener, EventHandler`1<ValueChangedEventArgs> handler);
}
internal class MS.Internal.Data.ValueConverterContext : object {
    private DependencyObject _targetElement;
    private int _nestingLevel;
    private Uri _cachedBaseUri;
    public Uri BaseUri { get; public set; }
    internal bool IsInUse { get; }
    public IContainer Container { get; }
    public object Instance { get; }
    public PropertyDescriptor PropertyDescriptor { get; }
    public virtual object GetService(Type serviceType);
    public sealed virtual Uri get_BaseUri();
    public sealed virtual void set_BaseUri(Uri value);
    internal void SetTargetElement(DependencyObject target);
    internal bool get_IsInUse();
    public sealed virtual IContainer get_Container();
    public sealed virtual object get_Instance();
    public sealed virtual PropertyDescriptor get_PropertyDescriptor();
    public sealed virtual void OnComponentChanged();
    public sealed virtual bool OnComponentChanging();
}
internal class MS.Internal.Data.ValueTable : object {
    private HybridDictionary _table;
    private static object CachedNull;
    private static ValueTable();
    internal static bool ShouldCache(object item, PropertyDescriptor pd);
    internal object GetValue(object item, PropertyDescriptor pd, bool indexerIsNext);
    internal void RegisterForChanges(object item, PropertyDescriptor pd, DataBindEngine engine);
    private void OnPropertyChanged(object sender, PropertyChangedEventArgs e);
    private void OnValueChanged(object sender, ValueChangedEventArgs e);
    private sealed virtual override bool System.Windows.IWeakEventListener.ReceiveWeakEvent(Type managerType, object sender, EventArgs e);
    private void InvalidateCache(object item, string name);
    private void InvalidateCache(object item, PropertyDescriptor pd);
    private IEnumerable`1<PropertyDescriptor> GetPropertiesForItem(object item);
    internal bool Purge();
}
[DefaultMemberAttribute("Item")]
internal class MS.Internal.Data.ViewManager : HybridDictionary {
    private static int InactivityThreshold;
    private HybridDictionary _inactiveViewTables;
    private static object StaticObject;
    internal static WeakReference StaticWeakRef;
    internal static WeakReference NullWeakRef;
    public CollectionRecord Item { get; }
    internal static ViewManager Current { get; }
    private static ViewManager();
    public CollectionRecord get_Item(object o);
    internal void Add(object collection, CollectionRecord cr);
    internal ViewRecord GetViewRecord(object collection, CollectionViewSource cvs, Type collectionViewType, bool createView, Func`2<object, object> GetSourceItem);
    private CollectionRecord EnsureCollectionRecord(object collection, Func`2<object, object> GetSourceItem);
    internal void RegisterCollectionSynchronizationCallback(IEnumerable collection, object context, CollectionSynchronizationCallback synchronizationCallback);
    internal SynchronizationInfo GetSynchronizationInfo(IEnumerable collection);
    public void AccessCollection(IEnumerable collection, Action accessMethod, bool writeAccess);
    internal static ViewManager get_Current();
    private ViewRecord GetExistingView(object collection, CollectionViewSource cvs, Type collectionViewType, Func`2<object, object> GetSourceItem);
    private ViewRecord CacheView(object collection, CollectionViewSource cvs, CollectionView cv, ViewRecord vr);
    internal bool Purge();
    private void ValidateViewType(CollectionView cv, Type collectionViewType);
}
internal class MS.Internal.Data.ViewRecord : object {
    private ICollectionView _view;
    private int _version;
    private bool _isInitialized;
    internal ICollectionView View { get; }
    internal int Version { get; internal set; }
    internal bool IsInitialized { get; }
    internal ViewRecord(ICollectionView view);
    internal ICollectionView get_View();
    internal int get_Version();
    internal void set_Version(int value);
    internal bool get_IsInitialized();
    internal void InitializeView();
}
[DefaultMemberAttribute("Item")]
internal class MS.Internal.Data.ViewTable : HybridDictionary {
    internal ViewRecord Item { get; internal set; }
    internal ViewRecord get_Item(CollectionViewSource cvs);
    internal void set_Item(CollectionViewSource cvs, ViewRecord value);
    internal bool Purge();
}
internal class MS.Internal.Data.WeakDependencySource : object {
    private object _item;
    private DependencyProperty _dp;
    internal DependencyObject DependencyObject { get; }
    internal DependencyProperty DependencyProperty { get; }
    internal WeakDependencySource(DependencyObject item, DependencyProperty dp);
    internal WeakDependencySource(WeakReference wr, DependencyProperty dp);
    internal DependencyObject get_DependencyObject();
    internal DependencyProperty get_DependencyProperty();
}
internal class MS.Internal.Data.WeakRefKey : ValueType {
    private WeakReference _weakRef;
    private int _hashCode;
    internal object Target { get; }
    internal WeakRefKey(object target);
    internal object get_Target();
    public virtual int GetHashCode();
    public virtual bool Equals(object o);
    public static bool op_Equality(WeakRefKey left, WeakRefKey right);
    public static bool op_Inequality(WeakRefKey left, WeakRefKey right);
}
[DefaultMemberAttribute("Item")]
internal class MS.Internal.Data.XDeferredAxisSource : object {
    private WeakReference _component;
    private PropertyDescriptor _propertyDescriptor;
    private HybridDictionary _table;
    private static string FullCollectionKey;
    public IEnumerable Item { get; }
    internal IEnumerable FullCollection { get; }
    internal XDeferredAxisSource(object component, PropertyDescriptor pd);
    public IEnumerable get_Item(string name);
    internal IEnumerable get_FullCollection();
}
internal class MS.Internal.Data.XmlBindingWorker : BindingWorker {
    private bool _collectionMode;
    private XPathType _xpathType;
    private XmlNode _contextNode;
    private XmlDataCollection _queriedCollection;
    private ICollectionView _collectionView;
    private XmlDataProvider _xmlDataProvider;
    private ClrBindingWorker _hostWorker;
    private string _xpath;
    private XmlDataCollection QueriedCollection { get; private set; }
    private ICollectionView CollectionView { get; private set; }
    private XmlNode ContextNode { get; private set; }
    private string XPath { get; }
    private XmlNamespaceManager NamespaceManager { get; }
    private XmlDataProvider XmlDataProvider { get; }
    internal XmlBindingWorker(ClrBindingWorker worker, bool collectionMode);
    internal virtual void AttachDataItem();
    internal virtual void DetachDataItem();
    internal virtual void OnCurrentChanged(ICollectionView collectionView, EventArgs args);
    internal virtual object RawValue();
    internal void ReportBadXPath(TraceEventType traceType);
    private XmlDataCollection get_QueriedCollection();
    private void set_QueriedCollection(XmlDataCollection value);
    private ICollectionView get_CollectionView();
    private void set_CollectionView(ICollectionView value);
    private XmlNode get_ContextNode();
    private void set_ContextNode(XmlNode value);
    private string get_XPath();
    private XmlNamespaceManager get_NamespaceManager();
    private XmlDataProvider get_XmlDataProvider();
    private void UpdateContextNode(bool hookNotifications);
    private void HookNotifications();
    private void UnHookNotifications();
    private XmlDocument DocumentFor(XmlNode node);
    private XmlDataCollection BuildQueriedCollection(XmlNodeList nodes);
    private sealed virtual override bool System.Windows.IWeakEventListener.ReceiveWeakEvent(Type managerType, object sender, EventArgs args);
    private void OnXmlNodeChanged(object sender, XmlNodeChangedEventArgs e);
    private void ProcessXmlNodeChanged(EventArgs args);
    private XmlNodeList SelectNodes();
    private string IdentifyNode(XmlNode node);
    private string IdentifyNodeList(XmlNodeList nodeList);
    private static XPathType GetXPathType(string xpath);
    private bool IsChangeRelevant(EventArgs rawArgs);
}
internal class MS.Internal.Data.XmlDataCollection : ReadOnlyObservableCollection`1<XmlNode> {
    private XmlDataProvider _xds;
    private XmlNamespaceManager _nsMgr;
    internal XmlNamespaceManager XmlNamespaceManager { get; internal set; }
    internal XmlDataProvider ParentXmlDataProvider { get; }
    internal XmlDataCollection(XmlDataProvider xmlDataProvider);
    internal XmlNamespaceManager get_XmlNamespaceManager();
    internal void set_XmlNamespaceManager(XmlNamespaceManager value);
    internal XmlDataProvider get_ParentXmlDataProvider();
    internal bool CollectionHasChanged(XmlNodeList nodes);
    internal void SynchronizeCollection(XmlNodeList nodes);
}
internal class MS.Internal.Data.XmlNodeChangedEventManager : WeakEventManager {
    private static XmlNodeChangedEventManager CurrentManager { get; }
    public static void AddListener(XmlDocument source, IWeakEventListener listener);
    public static void RemoveListener(XmlDocument source, IWeakEventListener listener);
    public static void AddHandler(XmlDocument source, EventHandler`1<XmlNodeChangedEventArgs> handler);
    public static void RemoveHandler(XmlDocument source, EventHandler`1<XmlNodeChangedEventArgs> handler);
    protected virtual ListenerList NewListenerList();
    protected virtual void StartListening(object source);
    protected virtual void StopListening(object source);
    private static XmlNodeChangedEventManager get_CurrentManager();
    private void OnXmlNodeChanged(object sender, XmlNodeChangedEventArgs args);
}
internal class MS.Internal.Documents.Application.DocumentApplicationJournalEntry : CustomContentState {
    private object _state;
    private string _displayName;
    public string JournalEntryName { get; }
    public DocumentApplicationJournalEntry(object state, string name);
    public DocumentApplicationJournalEntry(object state);
    public virtual void Replay(NavigationService navigationService, NavigationMode mode);
    public virtual string get_JournalEntryName();
}
internal class MS.Internal.Documents.BreakRecordTableInvalidatedEventHandler : MulticastDelegate {
    public BreakRecordTableInvalidatedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, EventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, EventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class MS.Internal.Documents.ColumnResult : object {
    private FlowDocumentPage _page;
    private BaseParaClient _subpage;
    private IntPtr _columnHandle;
    private Rect _layoutBox;
    private Vector _columnOffset;
    private TextContentRange _contentRange;
    private ReadOnlyCollection`1<ParagraphResult> _paragraphs;
    private bool _hasTextContent;
    internal ITextPointer StartPosition { get; }
    internal ITextPointer EndPosition { get; }
    internal Rect LayoutBox { get; }
    internal ReadOnlyCollection`1<ParagraphResult> Paragraphs { get; }
    internal bool HasTextContent { get; }
    internal TextContentRange TextContentRange { get; }
    internal ColumnResult(FlowDocumentPage page, FSTRACKDESCRIPTION& trackDesc, Vector contentOffset);
    internal ColumnResult(BaseParaClient subpage, FSTRACKDESCRIPTION& trackDesc, Vector contentOffset);
    internal bool Contains(ITextPointer position, bool strict);
    internal ITextPointer get_StartPosition();
    internal ITextPointer get_EndPosition();
    internal Rect get_LayoutBox();
    internal ReadOnlyCollection`1<ParagraphResult> get_Paragraphs();
    internal bool get_HasTextContent();
    internal TextContentRange get_TextContentRange();
    private void EnsureTextContentRange();
}
internal class MS.Internal.Documents.ContainerParagraphResult : ParagraphResult {
    private ReadOnlyCollection`1<ParagraphResult> _paragraphs;
    internal ReadOnlyCollection`1<ParagraphResult> Paragraphs { get; }
    internal bool HasTextContent { get; }
    internal ContainerParagraphResult(ContainerParaClient paraClient);
    internal Geometry GetTightBoundingGeometryFromTextPositions(ITextPointer startPosition, ITextPointer endPosition, Rect visibleRect);
    internal ReadOnlyCollection`1<ParagraphResult> get_Paragraphs();
    internal virtual bool get_HasTextContent();
}
[DefaultMemberAttribute("Item")]
internal abstract class MS.Internal.Documents.ContentElementCollection`2 : object {
    private TParent _owner;
    private TItem[] _items;
    private int _size;
    private int _version;
    protected static int c_defaultCapacity;
    private bool System.Collections.IList.IsFixedSize { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private object System.Collections.IList.Item { get; private set; }
    public TItem Item { get; public set; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public int Capacity { get; public set; }
    public TParent Owner { get; }
    protected TItem[] Items { get; private set; }
    protected int Size { get; protected set; }
    protected int Version { get; protected set; }
    protected int DefaultCapacity { get; }
    internal int PrivateCapacity { get; internal set; }
    internal ContentElementCollection`2(TParent owner);
    public sealed virtual void CopyTo(Array array, int index);
    public sealed virtual void CopyTo(TItem[] array, int index);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    internal IEnumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<TItem> System.Collections.Generic.IEnumerable<TItem>.GetEnumerator();
    public abstract virtual void Add(TItem item);
    public abstract virtual void Clear();
    public sealed virtual bool Contains(TItem item);
    public sealed virtual int IndexOf(TItem item);
    public abstract virtual void Insert(int index, TItem item);
    public abstract virtual bool Remove(TItem item);
    public abstract virtual void RemoveAt(int index);
    public abstract virtual void RemoveRange(int index, int count);
    public void TrimToSize();
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override void System.Collections.IList.Clear();
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.IList.RemoveAt(int index);
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public abstract virtual TItem get_Item(int index);
    public abstract virtual void set_Item(int index, TItem value);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    public int get_Capacity();
    public void set_Capacity(int value);
    public TParent get_Owner();
    protected TItem[] get_Items();
    private void set_Items(TItem[] value);
    protected int get_Size();
    protected void set_Size(int value);
    protected int get_Version();
    protected void set_Version(int value);
    protected int get_DefaultCapacity();
    internal void EnsureCapacity(int min);
    internal abstract virtual void PrivateConnectChild(int index, TItem item);
    internal abstract virtual void PrivateDisconnectChild(TItem item);
    internal void PrivateRemove(TItem item);
    internal bool BelongsToOwner(TItem item);
    internal int get_PrivateCapacity();
    internal void set_PrivateCapacity(int value);
}
internal static class MS.Internal.Documents.ContentHostHelper : object {
    internal static IContentHost FindContentHost(ContentElement contentElement);
    private static IContentHost GetICHFromFlowDocument(TextElement contentElement, FlowDocument flowDocument);
    private static void FindDocumentPageViews(Visual root, List`1<DocumentPageView> pageViews);
}
internal class MS.Internal.Documents.DesiredSizeChangedEventArgs : EventArgs {
    private UIElement _child;
    internal UIElement Child { get; }
    internal DesiredSizeChangedEventArgs(UIElement child);
    internal UIElement get_Child();
}
internal class MS.Internal.Documents.DesiredSizeChangedEventHandler : MulticastDelegate {
    public DesiredSizeChangedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, DesiredSizeChangedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, DesiredSizeChangedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class MS.Internal.Documents.DocumentGrid : FrameworkElement {
    private PageCache _pageCache;
    private RowCache _rowCache;
    private ReadOnlyCollection`1<DocumentPageView> _pageViews;
    private bool _canHorizontallyScroll;
    private bool _canVerticallyScroll;
    private double _verticalOffset;
    private double _horizontalOffset;
    private double _viewportHeight;
    private double _viewportWidth;
    private int _firstVisibleRow;
    private int _visibleRowCount;
    private int _firstVisiblePageNumber;
    private int _lastVisiblePageNumber;
    private ScrollViewer _scrollOwner;
    private DocumentViewer _documentViewerOwner;
    private bool _showPageBorders;
    private bool _lockViewModes;
    private int _maxPagesAcross;
    private Size _previousConstraint;
    private DocumentLayout _documentLayout;
    private int _documentLayoutsPending;
    private RowInfo _savedPivotRow;
    private double _lastRowChangeExtentWidth;
    private double _lastRowChangeVerticalOffset;
    private ITextContainer _textContainer;
    private RubberbandSelector _rubberBandSelector;
    private bool _isLayoutRequested;
    private bool _pageJumpAfterLayout;
    private int _pageJumpAfterLayoutPageNumber;
    private bool _firstRowLayout;
    private bool _scrollChangedEventAttached;
    private Border _documentGridBackground;
    private static int _backgroundVisualIndex;
    private static int _firstPageVisualIndex;
    private Size _defaultConstraint;
    private VisualCollection _childrenCollection;
    private int _makeVisiblePageNeeded;
    private DispatcherOperation _makeVisibleDispatcher;
    private DispatcherOperation _setScaleOperation;
    private static double _verticalLineScrollAmount;
    private static double _horizontalLineScrollAmount;
    public bool CanHorizontallyScroll { get; public set; }
    public bool CanVerticallyScroll { get; public set; }
    public double ExtentWidth { get; }
    public double ExtentHeight { get; }
    public double ViewportWidth { get; }
    public double ViewportHeight { get; }
    public double HorizontalOffset { get; }
    public double VerticalOffset { get; }
    public DynamicDocumentPaginator Content { get; public set; }
    public int PageCount { get; }
    public int FirstVisiblePageNumber { get; }
    public double Scale { get; }
    public int MaxPagesAcross { get; }
    public double VerticalPageSpacing { get; public set; }
    public double HorizontalPageSpacing { get; public set; }
    public bool ShowPageBorders { get; public set; }
    public bool LockViewModes { get; public set; }
    public ITextContainer TextContainer { get; }
    public ITextView TextView { get; }
    public ReadOnlyCollection`1<DocumentPageView> PageViews { get; }
    public ScrollViewer ScrollOwner { get; public set; }
    public DocumentViewer DocumentViewerOwner { get; public set; }
    protected int VisualChildrenCount { get; }
    private bool IsViewportNonzero { get; }
    private TextEditor TextEditor { get; }
    private double MouseWheelVerticalScrollAmount { get; }
    private bool CanMouseWheelVerticallyScroll { get; }
    private double MouseWheelHorizontalScrollAmount { get; }
    private bool CanMouseWheelHorizontallyScroll { get; }
    private double CurrentMinimumScale { get; }
    private static DocumentGrid();
    internal DocumentPage GetDocumentPageFromPoint(Point point);
    public sealed virtual void LineUp();
    public sealed virtual void LineDown();
    public sealed virtual void LineLeft();
    public sealed virtual void LineRight();
    public sealed virtual void PageUp();
    public sealed virtual void PageDown();
    public sealed virtual void PageLeft();
    public sealed virtual void PageRight();
    public sealed virtual void MouseWheelUp();
    public sealed virtual void MouseWheelDown();
    public sealed virtual void MouseWheelLeft();
    public sealed virtual void MouseWheelRight();
    public sealed virtual Rect MakeVisible(Visual v, Rect r);
    public sealed virtual Rect MakeVisible(object o, Rect r, int pageNumber);
    public sealed virtual void MakeSelectionVisible();
    public sealed virtual void MakePageVisible(int pageNumber);
    public sealed virtual void ScrollToNextRow();
    public sealed virtual void ScrollToPreviousRow();
    public sealed virtual void ScrollToHome();
    public sealed virtual void ScrollToEnd();
    public sealed virtual void SetScale(double scale);
    public sealed virtual void SetColumns(int columns);
    public sealed virtual void FitColumns(int columns);
    public sealed virtual void FitToPageWidth();
    public sealed virtual void FitToPageHeight();
    public sealed virtual void ViewThumbnails();
    public sealed virtual bool get_CanHorizontallyScroll();
    public sealed virtual void set_CanHorizontallyScroll(bool value);
    public sealed virtual bool get_CanVerticallyScroll();
    public sealed virtual void set_CanVerticallyScroll(bool value);
    public sealed virtual double get_ExtentWidth();
    public sealed virtual double get_ExtentHeight();
    public sealed virtual double get_ViewportWidth();
    public sealed virtual double get_ViewportHeight();
    public sealed virtual double get_HorizontalOffset();
    public sealed virtual void SetHorizontalOffset(double offset);
    public sealed virtual double get_VerticalOffset();
    public sealed virtual void SetVerticalOffset(double offset);
    public sealed virtual DynamicDocumentPaginator get_Content();
    public sealed virtual void set_Content(DynamicDocumentPaginator value);
    public sealed virtual int get_PageCount();
    public sealed virtual int get_FirstVisiblePageNumber();
    public sealed virtual double get_Scale();
    public sealed virtual int get_MaxPagesAcross();
    public sealed virtual double get_VerticalPageSpacing();
    public sealed virtual void set_VerticalPageSpacing(double value);
    public sealed virtual double get_HorizontalPageSpacing();
    public sealed virtual void set_HorizontalPageSpacing(double value);
    public sealed virtual bool get_ShowPageBorders();
    public sealed virtual void set_ShowPageBorders(bool value);
    public sealed virtual bool get_LockViewModes();
    public sealed virtual void set_LockViewModes(bool value);
    public sealed virtual ITextContainer get_TextContainer();
    public sealed virtual ITextView get_TextView();
    public sealed virtual ReadOnlyCollection`1<DocumentPageView> get_PageViews();
    public sealed virtual ScrollViewer get_ScrollOwner();
    public sealed virtual void set_ScrollOwner(ScrollViewer value);
    public sealed virtual DocumentViewer get_DocumentViewerOwner();
    public sealed virtual void set_DocumentViewerOwner(DocumentViewer value);
    protected virtual Visual GetVisualChild(int index);
    protected virtual int get_VisualChildrenCount();
    protected virtual Size MeasureOverride(Size constraint);
    protected virtual Size ArrangeOverride(Size arrangeSize);
    protected virtual void OnPreviewMouseLeftButtonDown(MouseButtonEventArgs e);
    protected internal virtual void OnVisualParentChanged(DependencyObject oldParent);
    private void RecalculateVisualPages(double offset, Size constraint);
    private void OnPageLoaded(object sender, EventArgs args);
    private void CalculateRowOffsets(int row, Double& xOffset, Double& yOffset);
    private void ResetVisualTree(bool pruneOnly);
    private void ResetPageViewCollection();
    private void OnGetPageNumberCompleted(object sender, GetPageNumberCompletedEventArgs e);
    private void MakeVisibleAsync(MakeVisibleData data, int pageNumber);
    private void BringPageIntoViewDelegate(MakeVisibleData data, int pageNumber);
    private void MakeVisibleImpl(MakeVisibleData data);
    private void MakeRectVisible(Rect r, bool alwaysCenter);
    private void MakeIPVisible(Rect r);
    private void MakeContentPositionVisibleAsync(MakeVisibleData data);
    private void QueueSetScale(double scale);
    private object SetScaleDelegate(object scale);
    private void UpdateLayoutScale(double scale);
    private void QueueUpdateDocumentLayout(DocumentLayout layout);
    private object UpdateDocumentLayoutDelegate(object layout);
    private void UpdateDocumentLayout(DocumentLayout layout);
    private bool ExecutePendingLayoutRequests();
    private void SetHorizontalOffsetInternal(double offset);
    private void SetVerticalOffsetInternal(double offset);
    private void UpdateTextView();
    private int CalculateThumbnailColumns();
    private void InvalidateChildMeasure();
    private bool RowIsClean(RowInfo row);
    private void EnsureFit(RowInfo pivotRow);
    private void ApplyViewParameters(RowInfo pivotRow);
    private double CalculateScaleFactor(RowInfo pivotRow);
    private void Initialize();
    private void InvalidateDocumentScrollInfo();
    private void InvalidatePageViews();
    private ITextPointer GetVisibleSelection();
    private bool HasSelection();
    private int GetPageNumberForVisibleSelection(ITextPointer selection);
    private Point GetActiveFocusPoint();
    private int GetActiveFocusPage();
    private DocumentPageView GetDocumentPageViewFromPoint(Point point);
    private bool TextViewContains(ITextPointer tp);
    private double GetHorizontalOffsetForPage(RowInfo row, int pageNumber);
    private bool RowCacheChangeIsVisible(RowCacheChange change);
    private bool IsPageLoaded(int pageNumber);
    private bool IsViewLoaded();
    private DocumentGridPage GetDocumentGridPageForPageNumber(int pageNumber);
    private static void OnRequestBringIntoView(object sender, RequestBringIntoViewEventArgs args);
    private void OnScrollChanged(object sender, EventArgs args);
    private void OnZoomLayoutUpdated(object sender, EventArgs args);
    private void OnRowCacheChanged(object source, RowCacheChangedEventArgs args);
    private void OnRowLayoutCompleted(object source, RowLayoutCompletedEventArgs args);
    private bool get_IsViewportNonzero();
    private TextEditor get_TextEditor();
    private double get_MouseWheelVerticalScrollAmount();
    private bool get_CanMouseWheelVerticallyScroll();
    private double get_MouseWheelHorizontalScrollAmount();
    private bool get_CanMouseWheelHorizontallyScroll();
    private double get_CurrentMinimumScale();
    [CompilerGeneratedAttribute]
private object <BringPageIntoViewDelegate>b__98_0(object arg);
}
internal static class MS.Internal.Documents.DocumentGridContextMenu : object {
    private static double KeyboardInvokedSentinel;
    internal static void RegisterClassHandler();
    private static void OnDocumentViewerContextMenuOpening(object sender, ContextMenuEventArgs e);
    private static void OnContextMenuOpening(object sender, ContextMenuEventArgs e);
}
internal class MS.Internal.Documents.DocumentGridPage : FrameworkElement {
    [CompilerGeneratedAttribute]
private EventHandler PageLoaded;
    private bool hasAddedChildren;
    private DocumentPaginator _paginator;
    private DocumentPageView _documentPageView;
    private Rectangle _dropShadowRight;
    private Rectangle _dropShadowBottom;
    private Border _pageBorder;
    private bool _showPageBorders;
    private bool _loaded;
    private static double _dropShadowOpacity;
    private static double _dropShadowWidth;
    private Thickness _pageBorderVisibleThickness;
    private Thickness _pageBorderInvisibleThickness;
    private bool _disposed;
    public DocumentPage DocumentPage { get; }
    public int PageNumber { get; public set; }
    public DocumentPageView DocumentPageView { get; }
    public bool ShowPageBorders { get; public set; }
    public bool IsPageLoaded { get; }
    protected int VisualChildrenCount { get; }
    public DocumentGridPage(DocumentPaginator paginator);
    public DocumentPage get_DocumentPage();
    public int get_PageNumber();
    public void set_PageNumber(int value);
    public DocumentPageView get_DocumentPageView();
    public bool get_ShowPageBorders();
    public void set_ShowPageBorders(bool value);
    public bool get_IsPageLoaded();
    [CompilerGeneratedAttribute]
public void add_PageLoaded(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_PageLoaded(EventHandler value);
    protected virtual Visual GetVisualChild(int index);
    protected virtual int get_VisualChildrenCount();
    protected sealed virtual Size MeasureOverride(Size availableSize);
    protected sealed virtual Size ArrangeOverride(Size arrangeSize);
    private void Init();
    private void OnGetPageCompleted(object sender, GetPageCompletedEventArgs e);
    protected void Dispose();
    private void CheckDisposed();
    private sealed virtual override void System.IDisposable.Dispose();
}
internal class MS.Internal.Documents.DocumentPageHost : FrameworkElement {
    internal Point CachedOffset;
    private Visual _pageVisual;
    internal Visual PageVisual { get; internal set; }
    protected int VisualChildrenCount { get; }
    internal static void DisconnectPageVisual(Visual pageVisual);
    internal Visual get_PageVisual();
    internal void set_PageVisual(Visual value);
    protected virtual Visual GetVisualChild(int index);
    protected virtual int get_VisualChildrenCount();
}
internal class MS.Internal.Documents.DocumentPageTextView : TextViewBase {
    private UIElement _owner;
    private ITextContainer _textContainer;
    private DocumentPage _page;
    private ITextView _pageTextView;
    internal UIElement RenderScope { get; }
    internal ITextContainer TextContainer { get; }
    internal bool IsValid { get; }
    internal bool RendersOwnSelection { get; }
    internal ReadOnlyCollection`1<TextSegment> TextSegments { get; }
    internal DocumentPageView DocumentPageView { get; }
    private bool IsPageMissing { get; }
    internal DocumentPageTextView(DocumentPageView owner, ITextContainer textContainer);
    internal DocumentPageTextView(FlowDocumentView owner, ITextContainer textContainer);
    internal virtual ITextPointer GetTextPositionFromPoint(Point point, bool snapToText);
    internal virtual Rect GetRawRectangleFromTextPosition(ITextPointer position, Transform& transform);
    internal virtual Geometry GetTightBoundingGeometryFromTextPositions(ITextPointer startPosition, ITextPointer endPosition);
    internal virtual ITextPointer GetPositionAtNextLine(ITextPointer position, double suggestedX, int count, Double& newSuggestedX, Int32& linesMoved);
    internal virtual ITextPointer GetPositionAtNextPage(ITextPointer position, Point suggestedOffset, int count, Point& newSuggestedOffset, Int32& pagesMoved);
    internal virtual bool IsAtCaretUnitBoundary(ITextPointer position);
    internal virtual ITextPointer GetNextCaretUnitPosition(ITextPointer position, LogicalDirection direction);
    internal virtual ITextPointer GetBackspaceCaretUnitPosition(ITextPointer position);
    internal virtual TextSegment GetLineRange(ITextPointer position);
    internal virtual ReadOnlyCollection`1<GlyphRun> GetGlyphRuns(ITextPointer start, ITextPointer end);
    internal virtual bool Contains(ITextPointer position);
    internal void OnPageConnected();
    internal void OnPageDisconnected();
    internal void OnTransformChanged();
    internal virtual bool Validate();
    internal virtual bool Validate(ITextPointer position);
    internal virtual void ThrottleBackgroundTasksForUserInput();
    internal virtual UIElement get_RenderScope();
    internal virtual ITextContainer get_TextContainer();
    internal virtual bool get_IsValid();
    internal virtual bool get_RendersOwnSelection();
    internal virtual ReadOnlyCollection`1<TextSegment> get_TextSegments();
    internal DocumentPageView get_DocumentPageView();
    private void HandlePageTextViewUpdated(object sender, EventArgs e);
    private Transform GetTransformToAncestor();
    private Point TransformToAncestor(Point point);
    private Point TransformToDescendant(Point point);
    private double GetYOffsetAtNextPage(double offset, int count, Int32& pagesMoved);
    private bool get_IsPageMissing();
}
internal class MS.Internal.Documents.DocumentsTrace : object {
    public bool IsEnabled { get; }
    private static DocumentsTrace();
    public DocumentsTrace(string switchName);
    public DocumentsTrace(string switchName, bool initialState);
    [ConditionalAttribute("DEBUG")]
public void Trace(string message);
    [ConditionalAttribute("DEBUG")]
public void TraceCallers(int Depth);
    [ConditionalAttribute("DEBUG")]
public void Indent();
    [ConditionalAttribute("DEBUG")]
public void Unindent();
    [ConditionalAttribute("DEBUG")]
public void Enable();
    [ConditionalAttribute("DEBUG")]
public void Disable();
    public bool get_IsEnabled();
}
internal static class MS.Internal.Documents.DocumentViewerConstants : object {
    private static double _minimumZoom;
    private static double _minimumThumbnailsZoom;
    private static double _maximumZoom;
    private static int _maximumMaxPagesAcross;
    public static double MinimumZoom { get; }
    public static double MaximumZoom { get; }
    public static double MinimumScale { get; }
    public static double MinimumThumbnailsScale { get; }
    public static double MaximumScale { get; }
    public static int MaximumMaxPagesAcross { get; }
    public static double get_MinimumZoom();
    public static double get_MaximumZoom();
    public static double get_MinimumScale();
    public static double get_MinimumThumbnailsScale();
    public static double get_MaximumScale();
    public static int get_MaximumMaxPagesAcross();
}
internal static class MS.Internal.Documents.DocumentViewerHelper : object {
    private static ResourceKey _findToolBarStyleKey;
    private static ResourceKey FindToolBarStyleKey { get; }
    internal static void ToggleFindToolBar(Decorator findToolBarHost, EventHandler handlerFindClicked, bool enable);
    internal static ITextRange Find(FindToolBar findToolBar, TextEditor textEditor, ITextView textView, ITextView masterPageTextView);
    private static CultureInfo GetDocumentCultureInfo(ITextContainer textContainer);
    internal static void ShowFindUnsuccessfulMessage(FindToolBar findToolBar);
    private static ResourceKey get_FindToolBarStyleKey();
    internal static bool IsLogicalDescendent(DependencyObject child, DependencyObject parent);
    internal static void KeyDownHelper(KeyEventArgs e, DependencyObject findToolBarHost);
    internal static void OnContextMenuOpening(FlowDocument document, Control viewer, ContextMenuEventArgs e);
    internal static Rect CalculateVisibleRect(Rect visibleRect, Visual originalVisual);
}
internal class MS.Internal.Documents.FigureParagraphResult : ParagraphResult {
    private ReadOnlyCollection`1<ColumnResult> _columns;
    private ReadOnlyCollection`1<ParagraphResult> _floatingElements;
    internal ReadOnlyCollection`1<ColumnResult> Columns { get; }
    internal bool HasTextContent { get; }
    internal ReadOnlyCollection`1<ParagraphResult> FloatingElements { get; }
    internal Vector ContentOffset { get; }
    internal FigureParagraphResult(BaseParaClient paraClient);
    internal ReadOnlyCollection`1<ColumnResult> get_Columns();
    internal virtual bool get_HasTextContent();
    internal ReadOnlyCollection`1<ParagraphResult> get_FloatingElements();
    internal Vector get_ContentOffset();
    internal Geometry GetTightBoundingGeometryFromTextPositions(ITextPointer startPosition, ITextPointer endPosition, Rect visibleRect, Boolean& success);
}
internal class MS.Internal.Documents.FixedDocumentPaginator : DynamicDocumentPaginator {
    private FixedDocument _document;
    public bool IsPageCountValid { get; }
    public int PageCount { get; }
    public Size PageSize { get; public set; }
    public IDocumentPaginatorSource Source { get; }
    internal FixedDocumentPaginator(FixedDocument document);
    public virtual DocumentPage GetPage(int pageNumber);
    public virtual void GetPageAsync(int pageNumber, object userState);
    public virtual void CancelAsync(object userState);
    public virtual int GetPageNumber(ContentPosition contentPosition);
    public virtual ContentPosition GetPagePosition(DocumentPage page);
    public virtual ContentPosition GetObjectPosition(object o);
    public virtual bool get_IsPageCountValid();
    public virtual int get_PageCount();
    public virtual Size get_PageSize();
    public virtual void set_PageSize(Size value);
    public virtual IDocumentPaginatorSource get_Source();
    internal void NotifyGetPageCompleted(GetPageCompletedEventArgs e);
    internal void NotifyPaginationCompleted(EventArgs e);
    internal void NotifyPaginationProgress(PaginationProgressEventArgs e);
    internal void NotifyPagesChanged(PagesChangedEventArgs e);
    private sealed virtual override object System.IServiceProvider.GetService(Type serviceType);
}
internal class MS.Internal.Documents.FixedDocumentSequencePaginator : DynamicDocumentPaginator {
    private FixedDocumentSequence _document;
    public bool IsPageCountValid { get; }
    public int PageCount { get; }
    public Size PageSize { get; public set; }
    public IDocumentPaginatorSource Source { get; }
    internal FixedDocumentSequencePaginator(FixedDocumentSequence document);
    public virtual DocumentPage GetPage(int pageNumber);
    public virtual void GetPageAsync(int pageNumber, object userState);
    public virtual void CancelAsync(object userState);
    public virtual int GetPageNumber(ContentPosition contentPosition);
    public virtual ContentPosition GetPagePosition(DocumentPage page);
    public virtual ContentPosition GetObjectPosition(object o);
    public virtual bool get_IsPageCountValid();
    public virtual int get_PageCount();
    public virtual Size get_PageSize();
    public virtual void set_PageSize(Size value);
    public virtual IDocumentPaginatorSource get_Source();
    internal void NotifyGetPageCompleted(GetPageCompletedEventArgs e);
    internal void NotifyPaginationCompleted(EventArgs e);
    internal void NotifyPaginationProgress(PaginationProgressEventArgs e);
    internal void NotifyPagesChanged(PagesChangedEventArgs e);
    private sealed virtual override object System.IServiceProvider.GetService(Type serviceType);
}
internal abstract class MS.Internal.Documents.FloaterBaseParagraphResult : ParagraphResult {
    internal FloaterBaseParagraphResult(BaseParaClient paraClient);
}
internal class MS.Internal.Documents.FloaterParagraphResult : FloaterBaseParagraphResult {
    private ReadOnlyCollection`1<ColumnResult> _columns;
    private ReadOnlyCollection`1<ParagraphResult> _floatingElements;
    internal ReadOnlyCollection`1<ColumnResult> Columns { get; }
    internal bool HasTextContent { get; }
    internal ReadOnlyCollection`1<ParagraphResult> FloatingElements { get; }
    internal Vector ContentOffset { get; }
    internal FloaterParagraphResult(BaseParaClient paraClient);
    internal ReadOnlyCollection`1<ColumnResult> get_Columns();
    internal virtual bool get_HasTextContent();
    internal ReadOnlyCollection`1<ParagraphResult> get_FloatingElements();
    internal Vector get_ContentOffset();
    internal Geometry GetTightBoundingGeometryFromTextPositions(ITextPointer startPosition, ITextPointer endPosition, Rect visibleRect, Boolean& success);
}
internal class MS.Internal.Documents.FlowDocumentFormatter : object {
    [CompilerGeneratedAttribute]
private EventHandler ContentInvalidated;
    [CompilerGeneratedAttribute]
private EventHandler Suspended;
    private FlowDocument _document;
    private FlowDocumentPage _documentPage;
    private bool _arrangedAfterFormat;
    private bool _lastFormatSuccessful;
    private static double _defaultWidth;
    private bool _isContentFormatValid;
    internal FlowDocumentPage DocumentPage { get; }
    private bool MS.Internal.Documents.IFlowDocumentFormatter.IsLayoutDataValid { get; }
    internal FlowDocumentFormatter(FlowDocument document);
    internal void Format(Size constraint);
    internal void Arrange(Size arrangeSize, Rect viewport);
    internal FlowDocumentPage get_DocumentPage();
    [CompilerGeneratedAttribute]
internal void add_ContentInvalidated(EventHandler value);
    [CompilerGeneratedAttribute]
internal void remove_ContentInvalidated(EventHandler value);
    [CompilerGeneratedAttribute]
internal void add_Suspended(EventHandler value);
    [CompilerGeneratedAttribute]
internal void remove_Suspended(EventHandler value);
    private Size ComputePageSize(Size constraint);
    private Thickness ComputePageMargin();
    private sealed virtual override void MS.Internal.Documents.IFlowDocumentFormatter.OnContentInvalidated(bool affectsLayout);
    private sealed virtual override void MS.Internal.Documents.IFlowDocumentFormatter.OnContentInvalidated(bool affectsLayout, ITextPointer start, ITextPointer end);
    private sealed virtual override void MS.Internal.Documents.IFlowDocumentFormatter.Suspend();
    private sealed virtual override bool MS.Internal.Documents.IFlowDocumentFormatter.get_IsLayoutDataValid();
}
internal class MS.Internal.Documents.FlowDocumentPaginator : DynamicDocumentPaginator {
    [CompilerGeneratedAttribute]
private BreakRecordTableInvalidatedEventHandler BreakRecordTableInvalidated;
    private FlowDocument _document;
    private CustomDispatcherObject _dispatcherObject;
    private BreakRecordTable _brt;
    private Size _pageSize;
    private bool _backgroundPagination;
    private static int _paginationTimeout;
    private static Size _defaultPageSize;
    private List`1<AsyncRequest> _asyncRequests;
    private DispatcherOperation _backgroundPaginationOperation;
    public bool IsPageCountValid { get; }
    public int PageCount { get; }
    public Size PageSize { get; public set; }
    public bool IsBackgroundPaginationEnabled { get; public set; }
    public IDocumentPaginatorSource Source { get; }
    private bool MS.Internal.Documents.IFlowDocumentFormatter.IsLayoutDataValid { get; }
    internal FlowDocumentPaginator(FlowDocument document);
    private static FlowDocumentPaginator();
    public virtual void GetPageAsync(int pageNumber, object userState);
    public virtual DocumentPage GetPage(int pageNumber);
    public virtual void GetPageNumberAsync(ContentPosition contentPosition, object userState);
    public virtual int GetPageNumber(ContentPosition contentPosition);
    public virtual ContentPosition GetPagePosition(DocumentPage page);
    public virtual ContentPosition GetObjectPosition(object o);
    public virtual void CancelAsync(object userState);
    public virtual bool get_IsPageCountValid();
    public virtual int get_PageCount();
    public virtual Size get_PageSize();
    public virtual void set_PageSize(Size value);
    public virtual bool get_IsBackgroundPaginationEnabled();
    public virtual void set_IsBackgroundPaginationEnabled(bool value);
    public virtual IDocumentPaginatorSource get_Source();
    internal void InitiateNextAsyncOperation();
    internal void CancelAllAsyncOperations();
    internal void OnPagesChanged(int pageStart, int pageCount);
    internal void OnPaginationProgress(int pageStart, int pageCount);
    internal void OnPaginationCompleted();
    [CompilerGeneratedAttribute]
internal void add_BreakRecordTableInvalidated(BreakRecordTableInvalidatedEventHandler value);
    [CompilerGeneratedAttribute]
internal void remove_BreakRecordTableInvalidated(BreakRecordTableInvalidatedEventHandler value);
    private void InvalidateBRT();
    private void InvalidateBRTLayout(ITextPointer start, ITextPointer end);
    private DocumentPage FormatPagesTill(int pageNumber);
    private DocumentPage FormatPage(int pageNumber);
    private object OnBackgroundPagination(object arg);
    private Size ComputePageSize();
    private sealed virtual override object System.IServiceProvider.GetService(Type serviceType);
    private sealed virtual override void MS.Internal.Documents.IFlowDocumentFormatter.OnContentInvalidated(bool affectsLayout);
    private sealed virtual override void MS.Internal.Documents.IFlowDocumentFormatter.OnContentInvalidated(bool affectsLayout, ITextPointer start, ITextPointer end);
    private sealed virtual override void MS.Internal.Documents.IFlowDocumentFormatter.Suspend();
    private sealed virtual override bool MS.Internal.Documents.IFlowDocumentFormatter.get_IsLayoutDataValid();
}
internal class MS.Internal.Documents.FlowDocumentPrintingState : object {
    internal XpsDocumentWriter XpsDocumentWriter;
    internal Size PageSize;
    internal Thickness PagePadding;
    internal double ColumnWidth;
    internal bool IsSelectionEnabled;
}
internal class MS.Internal.Documents.FlowDocumentView : FrameworkElement {
    private FlowDocument _document;
    private PageVisual _pageVisual;
    private FlowDocumentFormatter _formatter;
    private ScrollData _scrollData;
    private DocumentPageTextView _textView;
    private bool _suspendLayout;
    protected int VisualChildrenCount { get; }
    internal FlowDocument Document { get; internal set; }
    internal FlowDocumentPage DocumentPage { get; }
    private bool System.Windows.Controls.Primitives.IScrollInfo.CanVerticallyScroll { get; private set; }
    private bool System.Windows.Controls.Primitives.IScrollInfo.CanHorizontallyScroll { get; private set; }
    private double System.Windows.Controls.Primitives.IScrollInfo.ExtentWidth { get; }
    private double System.Windows.Controls.Primitives.IScrollInfo.ExtentHeight { get; }
    private double System.Windows.Controls.Primitives.IScrollInfo.ViewportWidth { get; }
    private double System.Windows.Controls.Primitives.IScrollInfo.ViewportHeight { get; }
    private double System.Windows.Controls.Primitives.IScrollInfo.HorizontalOffset { get; }
    private double System.Windows.Controls.Primitives.IScrollInfo.VerticalOffset { get; }
    private ScrollViewer System.Windows.Controls.Primitives.IScrollInfo.ScrollOwner { get; private set; }
    private static FlowDocumentView();
    protected sealed virtual Size MeasureOverride(Size constraint);
    protected sealed virtual Size ArrangeOverride(Size arrangeSize);
    protected virtual Visual GetVisualChild(int index);
    protected virtual int get_VisualChildrenCount();
    internal void SuspendLayout();
    internal void ResumeLayout();
    internal FlowDocument get_Document();
    internal void set_Document(FlowDocument value);
    internal FlowDocumentPage get_DocumentPage();
    private void EnsureFormatter();
    private void HandleContentInvalidated(object sender, EventArgs e);
    private void HandleFormatterSuspended(object sender, EventArgs e);
    private sealed virtual override void System.Windows.Controls.Primitives.IScrollInfo.LineUp();
    private sealed virtual override void System.Windows.Controls.Primitives.IScrollInfo.LineDown();
    private sealed virtual override void System.Windows.Controls.Primitives.IScrollInfo.LineLeft();
    private sealed virtual override void System.Windows.Controls.Primitives.IScrollInfo.LineRight();
    private sealed virtual override void System.Windows.Controls.Primitives.IScrollInfo.PageUp();
    private sealed virtual override void System.Windows.Controls.Primitives.IScrollInfo.PageDown();
    private sealed virtual override void System.Windows.Controls.Primitives.IScrollInfo.PageLeft();
    private sealed virtual override void System.Windows.Controls.Primitives.IScrollInfo.PageRight();
    private sealed virtual override void System.Windows.Controls.Primitives.IScrollInfo.MouseWheelUp();
    private sealed virtual override void System.Windows.Controls.Primitives.IScrollInfo.MouseWheelDown();
    private sealed virtual override void System.Windows.Controls.Primitives.IScrollInfo.MouseWheelLeft();
    private sealed virtual override void System.Windows.Controls.Primitives.IScrollInfo.MouseWheelRight();
    private sealed virtual override void System.Windows.Controls.Primitives.IScrollInfo.SetHorizontalOffset(double offset);
    private sealed virtual override void System.Windows.Controls.Primitives.IScrollInfo.SetVerticalOffset(double offset);
    private sealed virtual override Rect System.Windows.Controls.Primitives.IScrollInfo.MakeVisible(Visual visual, Rect rectangle);
    private sealed virtual override bool System.Windows.Controls.Primitives.IScrollInfo.get_CanVerticallyScroll();
    private sealed virtual override void System.Windows.Controls.Primitives.IScrollInfo.set_CanVerticallyScroll(bool value);
    private sealed virtual override bool System.Windows.Controls.Primitives.IScrollInfo.get_CanHorizontallyScroll();
    private sealed virtual override void System.Windows.Controls.Primitives.IScrollInfo.set_CanHorizontallyScroll(bool value);
    private sealed virtual override double System.Windows.Controls.Primitives.IScrollInfo.get_ExtentWidth();
    private sealed virtual override double System.Windows.Controls.Primitives.IScrollInfo.get_ExtentHeight();
    private sealed virtual override double System.Windows.Controls.Primitives.IScrollInfo.get_ViewportWidth();
    private sealed virtual override double System.Windows.Controls.Primitives.IScrollInfo.get_ViewportHeight();
    private sealed virtual override double System.Windows.Controls.Primitives.IScrollInfo.get_HorizontalOffset();
    private sealed virtual override double System.Windows.Controls.Primitives.IScrollInfo.get_VerticalOffset();
    private sealed virtual override ScrollViewer System.Windows.Controls.Primitives.IScrollInfo.get_ScrollOwner();
    private sealed virtual override void System.Windows.Controls.Primitives.IScrollInfo.set_ScrollOwner(ScrollViewer value);
    private sealed virtual override object System.IServiceProvider.GetService(Type serviceType);
}
internal interface MS.Internal.Documents.IAcceptInsertion {
    public int InsertionIndex { get; public set; }
    public abstract virtual int get_InsertionIndex();
    public abstract virtual void set_InsertionIndex(int value);
}
internal interface MS.Internal.Documents.IDocumentScrollInfo {
    public DynamicDocumentPaginator Content { get; public set; }
    public int PageCount { get; }
    public int FirstVisiblePageNumber { get; }
    public double Scale { get; }
    public int MaxPagesAcross { get; }
    public double VerticalPageSpacing { get; public set; }
    public double HorizontalPageSpacing { get; public set; }
    public bool ShowPageBorders { get; public set; }
    public bool LockViewModes { get; public set; }
    public ITextView TextView { get; }
    public ITextContainer TextContainer { get; }
    public ReadOnlyCollection`1<DocumentPageView> PageViews { get; }
    public DocumentViewer DocumentViewerOwner { get; public set; }
    public abstract virtual void MakePageVisible(int pageNumber);
    public abstract virtual void MakeSelectionVisible();
    public abstract virtual Rect MakeVisible(object o, Rect r, int pageNumber);
    public abstract virtual void ScrollToNextRow();
    public abstract virtual void ScrollToPreviousRow();
    public abstract virtual void ScrollToHome();
    public abstract virtual void ScrollToEnd();
    public abstract virtual void SetScale(double scale);
    public abstract virtual void SetColumns(int columns);
    public abstract virtual void FitColumns(int columns);
    public abstract virtual void FitToPageWidth();
    public abstract virtual void FitToPageHeight();
    public abstract virtual void ViewThumbnails();
    public abstract virtual DynamicDocumentPaginator get_Content();
    public abstract virtual void set_Content(DynamicDocumentPaginator value);
    public abstract virtual int get_PageCount();
    public abstract virtual int get_FirstVisiblePageNumber();
    public abstract virtual double get_Scale();
    public abstract virtual int get_MaxPagesAcross();
    public abstract virtual double get_VerticalPageSpacing();
    public abstract virtual void set_VerticalPageSpacing(double value);
    public abstract virtual double get_HorizontalPageSpacing();
    public abstract virtual void set_HorizontalPageSpacing(double value);
    public abstract virtual bool get_ShowPageBorders();
    public abstract virtual void set_ShowPageBorders(bool value);
    public abstract virtual bool get_LockViewModes();
    public abstract virtual void set_LockViewModes(bool value);
    public abstract virtual ITextView get_TextView();
    public abstract virtual ITextContainer get_TextContainer();
    public abstract virtual ReadOnlyCollection`1<DocumentPageView> get_PageViews();
    public abstract virtual DocumentViewer get_DocumentViewerOwner();
    public abstract virtual void set_DocumentViewerOwner(DocumentViewer value);
}
internal interface MS.Internal.Documents.IFlowDocumentFormatter {
    public bool IsLayoutDataValid { get; }
    public abstract virtual void OnContentInvalidated(bool affectsLayout);
    public abstract virtual void OnContentInvalidated(bool affectsLayout, ITextPointer start, ITextPointer end);
    public abstract virtual void Suspend();
    public abstract virtual bool get_IsLayoutDataValid();
}
internal interface MS.Internal.Documents.IFlowDocumentViewer {
    public ContentPosition ContentPosition { get; public set; }
    public ITextSelection TextSelection { get; public set; }
    public bool CanGoToPreviousPage { get; }
    public bool CanGoToNextPage { get; }
    public int PageNumber { get; }
    public int PageCount { get; }
    public abstract virtual void PreviousPage();
    public abstract virtual void NextPage();
    public abstract virtual void FirstPage();
    public abstract virtual void LastPage();
    public abstract virtual void Print();
    public abstract virtual void CancelPrint();
    public abstract virtual void ShowFindResult(ITextRange findResult);
    public abstract virtual bool CanGoToPage(int pageNumber);
    public abstract virtual void GoToPage(int pageNumber);
    public abstract virtual void SetDocument(FlowDocument document);
    public abstract virtual ContentPosition get_ContentPosition();
    public abstract virtual void set_ContentPosition(ContentPosition value);
    public abstract virtual ITextSelection get_TextSelection();
    public abstract virtual void set_TextSelection(ITextSelection value);
    public abstract virtual bool get_CanGoToPreviousPage();
    public abstract virtual bool get_CanGoToNextPage();
    public abstract virtual int get_PageNumber();
    public abstract virtual int get_PageCount();
    [CompilerGeneratedAttribute]
public abstract virtual void add_PageNumberChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_PageNumberChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_PageCountChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_PageCountChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_PrintStarted(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_PrintStarted(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_PrintCompleted(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_PrintCompleted(EventHandler value);
}
internal interface MS.Internal.Documents.IIndexedChild`1 {
    public int Index { get; public set; }
    public abstract virtual void OnEnterParentTree();
    public abstract virtual void OnExitParentTree();
    public abstract virtual void OnAfterExitParentTree(TParent parent);
    public abstract virtual int get_Index();
    public abstract virtual void set_Index(int value);
}
internal interface MS.Internal.Documents.IParentUndoUnit {
    public IUndoUnit LastUnit { get; }
    public IParentUndoUnit OpenedUnit { get; }
    public string Description { get; public set; }
    public bool Locked { get; }
    public object Container { get; public set; }
    public abstract virtual void Clear();
    public abstract virtual void Open(IParentUndoUnit newUnit);
    public abstract virtual void Close(UndoCloseAction closeAction);
    public abstract virtual void Close(IParentUndoUnit closingUnit, UndoCloseAction closeAction);
    public abstract virtual void Add(IUndoUnit newUnit);
    public abstract virtual void OnNextAdd();
    public abstract virtual void OnNextDiscard();
    public abstract virtual IUndoUnit get_LastUnit();
    public abstract virtual IParentUndoUnit get_OpenedUnit();
    public abstract virtual string get_Description();
    public abstract virtual void set_Description(string value);
    public abstract virtual bool get_Locked();
    public abstract virtual object get_Container();
    public abstract virtual void set_Container(object value);
}
internal interface MS.Internal.Documents.IUndoUnit {
    public abstract virtual void Do();
    public abstract virtual bool Merge(IUndoUnit unit);
}
internal abstract class MS.Internal.Documents.LineResult : object {
    internal ITextPointer StartPosition { get; }
    internal ITextPointer EndPosition { get; }
    internal int StartPositionCP { get; }
    internal int EndPositionCP { get; }
    internal Rect LayoutBox { get; }
    internal double Baseline { get; }
    internal abstract virtual ITextPointer GetTextPositionFromDistance(double distance);
    internal abstract virtual bool IsAtCaretUnitBoundary(ITextPointer position);
    internal abstract virtual ITextPointer GetNextCaretUnitPosition(ITextPointer position, LogicalDirection direction);
    internal abstract virtual ITextPointer GetBackspaceCaretUnitPosition(ITextPointer position);
    internal abstract virtual ReadOnlyCollection`1<GlyphRun> GetGlyphRuns(ITextPointer start, ITextPointer end);
    internal abstract virtual ITextPointer GetContentEndPosition();
    internal abstract virtual ITextPointer GetEllipsesPosition();
    internal abstract virtual int GetContentEndPositionCP();
    internal abstract virtual int GetEllipsesPositionCP();
    internal abstract virtual ITextPointer get_StartPosition();
    internal abstract virtual ITextPointer get_EndPosition();
    internal abstract virtual int get_StartPositionCP();
    internal abstract virtual int get_EndPositionCP();
    internal abstract virtual Rect get_LayoutBox();
    internal abstract virtual double get_Baseline();
}
internal class MS.Internal.Documents.MultiPageTextView : TextViewBase {
    private DocumentViewerBase _viewer;
    private UIElement _renderScope;
    private ITextContainer _textContainer;
    private List`1<DocumentPageTextView> _pageTextViews;
    private BringIntoViewRequest _pendingRequest;
    internal UIElement RenderScope { get; }
    internal ITextContainer TextContainer { get; }
    internal bool IsValid { get; }
    internal bool RendersOwnSelection { get; }
    internal ReadOnlyCollection`1<TextSegment> TextSegments { get; }
    internal MultiPageTextView(DocumentViewerBase viewer, UIElement renderScope, ITextContainer textContainer);
    protected virtual void OnUpdated(EventArgs e);
    internal virtual ITextPointer GetTextPositionFromPoint(Point point, bool snapToText);
    internal virtual Rect GetRawRectangleFromTextPosition(ITextPointer position, Transform& transform);
    internal virtual Geometry GetTightBoundingGeometryFromTextPositions(ITextPointer startPosition, ITextPointer endPosition);
    internal virtual ITextPointer GetPositionAtNextLine(ITextPointer position, double suggestedX, int count, Double& newSuggestedX, Int32& linesMoved);
    internal virtual ITextPointer GetPositionAtNextPage(ITextPointer position, Point suggestedOffset, int count, Point& newSuggestedOffset, Int32& pagesMoved);
    internal virtual bool IsAtCaretUnitBoundary(ITextPointer position);
    internal virtual ITextPointer GetNextCaretUnitPosition(ITextPointer position, LogicalDirection direction);
    internal virtual ITextPointer GetBackspaceCaretUnitPosition(ITextPointer position);
    internal virtual TextSegment GetLineRange(ITextPointer position);
    internal virtual bool Contains(ITextPointer position);
    internal virtual void BringPositionIntoViewAsync(ITextPointer position, object userState);
    internal virtual void BringPointIntoViewAsync(Point point, object userState);
    internal virtual void BringLineIntoViewAsync(ITextPointer position, double suggestedX, int count, object userState);
    internal virtual void BringPageIntoViewAsync(ITextPointer position, Point suggestedOffset, int count, object userState);
    internal virtual void CancelAsync(object userState);
    internal void OnPagesUpdated();
    internal void OnPageLayoutChanged();
    internal ITextView GetPageTextViewFromPosition(ITextPointer position);
    internal virtual UIElement get_RenderScope();
    internal virtual ITextContainer get_TextContainer();
    internal virtual bool get_IsValid();
    internal virtual bool get_RendersOwnSelection();
    internal virtual ReadOnlyCollection`1<TextSegment> get_TextSegments();
    private void OnPagesUpdatedCore();
    private void HandlePageTextViewUpdated(object sender, EventArgs e);
    private void BringLineIntoViewCore(BringLineIntoViewRequest request);
    private void BringPageIntoViewCore(BringPageIntoViewRequest request);
    private ITextPointer GetPositionAtNextLineCore(ITextPointer position, double suggestedX, int count, Double& newSuggestedX, Int32& linesMoved, Int32& pageNumber);
    private ITextPointer GetPositionAtNextPageCore(ITextPointer position, Point suggestedOffset, int count, Point& newSuggestedOffset, Int32& pagesMoved, Int32& pageNumber);
    private ITextPointer GetPositionAtPageBoundary(bool pageTop, ITextView pageTextView, ITextPointer position, double suggestedX);
    private DocumentPageTextView GetTextViewFromPoint(Point point, bool snap);
    private DocumentPageTextView GetTextViewFromPosition(ITextPointer position);
    private DocumentPageTextView GetTextViewFromPageNumber(int pageNumber);
    private DocumentPageTextView GetTextViewForNextPage(int pageNumber, int count, Int32& newPageNumber);
    private Transform GetTransformToAncestor(Visual innerScope);
    private Rect TransformToAncestor(Visual innerScope, Rect rect);
    private Point TransformToAncestor(Visual innerScope, Point point);
    private Point TransformToDescendant(Visual innerScope, Point point);
    private void OnBringPositionIntoViewCompleted(BringPositionIntoViewRequest request);
    private void OnBringPointIntoViewCompleted(BringPointIntoViewRequest request);
    private void OnBringLineIntoViewCompleted(BringLineIntoViewRequest request);
    private void OnBringPageIntoViewCompleted(BringPageIntoViewRequest request);
    private object OnUpdatedWorker(object o);
    private bool IsPageNumberOutOfRange(int pageNumber);
}
internal class MS.Internal.Documents.PageCache : object {
    [CompilerGeneratedAttribute]
private PaginationProgressEventHandler PaginationProgress;
    [CompilerGeneratedAttribute]
private EventHandler PaginationCompleted;
    [CompilerGeneratedAttribute]
private PagesChangedEventHandler PagesChanged;
    [CompilerGeneratedAttribute]
private GetPageCompletedEventHandler GetPageCompleted;
    [CompilerGeneratedAttribute]
private PageCacheChangedEventHandler PageCacheChanged;
    private List`1<PageCacheEntry> _cache;
    private PageDestroyedWatcher _pageDestroyedWatcher;
    private DynamicDocumentPaginator _documentPaginator;
    private bool _originalIsBackgroundPaginationEnabled;
    private bool _dynamicPageSizes;
    private bool _isContentRightToLeft;
    private bool _isPaginationCompleted;
    private bool _isDefaultSizeKnown;
    private Size _defaultPageSize;
    private Size _lastPageSize;
    private Size _initialDefaultPageSize;
    private int _defaultCacheSize;
    public DynamicDocumentPaginator Content { get; public set; }
    public int PageCount { get; }
    public bool DynamicPageSizes { get; }
    public bool IsContentRightToLeft { get; }
    public bool IsPaginationCompleted { get; }
    public void set_Content(DynamicDocumentPaginator value);
    public DynamicDocumentPaginator get_Content();
    public int get_PageCount();
    public bool get_DynamicPageSizes();
    public bool get_IsContentRightToLeft();
    public bool get_IsPaginationCompleted();
    [CompilerGeneratedAttribute]
public void add_PaginationProgress(PaginationProgressEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_PaginationProgress(PaginationProgressEventHandler value);
    [CompilerGeneratedAttribute]
public void add_PaginationCompleted(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_PaginationCompleted(EventHandler value);
    [CompilerGeneratedAttribute]
public void add_PagesChanged(PagesChangedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_PagesChanged(PagesChangedEventHandler value);
    [CompilerGeneratedAttribute]
public void add_GetPageCompleted(GetPageCompletedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_GetPageCompleted(GetPageCompletedEventHandler value);
    [CompilerGeneratedAttribute]
public void add_PageCacheChanged(PageCacheChangedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_PageCacheChanged(PageCacheChangedEventHandler value);
    public Size GetPageSize(int pageNumber);
    public bool IsPageDirty(int pageNumber);
    private void OnPaginationProgress(object sender, PaginationProgressEventArgs args);
    private object PaginationProgressDelegate(object parameter);
    private void OnPaginationCompleted(object sender, EventArgs args);
    private object PaginationCompletedDelegate(object parameter);
    private void OnPagesChanged(object sender, PagesChangedEventArgs args);
    private object PagesChangedDelegate(object parameter);
    private void OnGetPageCompleted(object sender, GetPageCompletedEventArgs args);
    private object GetPageCompletedDelegate(object parameter);
    private void ValidatePaginationArgs(int start, int count);
    private void SetDefaultPageSize(bool dirtyOnly);
    private void FirePageCacheChangedEvent(List`1<PageCacheChange> changes);
    private PageCacheChange AddRange(int start, int count);
    private PageCacheChange UpdateEntry(int index, PageCacheEntry newEntry);
    private PageCacheChange DirtyRange(int start, int count);
    private void ClearCache();
}
internal class MS.Internal.Documents.PageCacheChange : object {
    private int _start;
    private int _count;
    private PageCacheChangeType _type;
    public int Start { get; }
    public int Count { get; }
    public PageCacheChangeType Type { get; }
    public PageCacheChange(int start, int count, PageCacheChangeType type);
    public int get_Start();
    public int get_Count();
    public PageCacheChangeType get_Type();
}
internal class MS.Internal.Documents.PageCacheChangedEventArgs : EventArgs {
    private List`1<PageCacheChange> _changes;
    public List`1<PageCacheChange> Changes { get; }
    public PageCacheChangedEventArgs(List`1<PageCacheChange> changes);
    public List`1<PageCacheChange> get_Changes();
}
internal class MS.Internal.Documents.PageCacheChangedEventHandler : MulticastDelegate {
    public PageCacheChangedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, PageCacheChangedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, PageCacheChangedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal enum MS.Internal.Documents.PageCacheChangeType : Enum {
    public int value__;
    public static PageCacheChangeType Add;
    public static PageCacheChangeType Remove;
    public static PageCacheChangeType Update;
}
internal class MS.Internal.Documents.PageCacheEntry : ValueType {
    public Size PageSize;
    public bool Dirty;
}
internal class MS.Internal.Documents.PageDestroyedWatcher : object {
    private Hashtable _table;
    public void AddPage(DocumentPage page);
    public void RemovePage(DocumentPage page);
    public bool IsDestroyed(DocumentPage page);
    private void OnPageDestroyed(object sender, EventArgs e);
}
internal abstract class MS.Internal.Documents.ParagraphResult : object {
    protected BaseParaClient _paraClient;
    protected Rect _layoutBox;
    protected DependencyObject _element;
    private TextContentRange _contentRange;
    protected bool _hasTextContent;
    internal ITextPointer StartPosition { get; }
    internal ITextPointer EndPosition { get; }
    internal Rect LayoutBox { get; }
    internal DependencyObject Element { get; }
    internal bool HasTextContent { get; }
    internal ParagraphResult(BaseParaClient paraClient);
    internal ParagraphResult(BaseParaClient paraClient, Rect layoutBox, DependencyObject element);
    internal virtual bool Contains(ITextPointer position, bool strict);
    internal ITextPointer get_StartPosition();
    internal ITextPointer get_EndPosition();
    internal Rect get_LayoutBox();
    internal DependencyObject get_Element();
    internal virtual bool get_HasTextContent();
    private void EnsureTextContentRange();
}
internal class MS.Internal.Documents.ParentUndoUnit : object {
    private string _description;
    private bool _locked;
    private IParentUndoUnit _openedUnit;
    private IUndoUnit _lastUnit;
    private Stack _units;
    private object _container;
    public string Description { get; public set; }
    public IParentUndoUnit OpenedUnit { get; }
    public IUndoUnit LastUnit { get; }
    public bool Locked { get; protected set; }
    public object Container { get; public set; }
    protected IParentUndoUnit DeepestOpenUnit { get; }
    protected object TopContainer { get; }
    protected Stack Units { get; }
    public ParentUndoUnit(string description);
    public virtual void Open(IParentUndoUnit newUnit);
    public virtual void Close(UndoCloseAction closeAction);
    public virtual void Close(IParentUndoUnit unit, UndoCloseAction closeAction);
    public virtual void Add(IUndoUnit unit);
    public virtual void Clear();
    public virtual void OnNextAdd();
    public virtual void OnNextDiscard();
    public virtual void Do();
    public virtual bool Merge(IUndoUnit unit);
    public sealed virtual string get_Description();
    public sealed virtual void set_Description(string value);
    public sealed virtual IParentUndoUnit get_OpenedUnit();
    public sealed virtual IUndoUnit get_LastUnit();
    public virtual bool get_Locked();
    protected virtual void set_Locked(bool value);
    public sealed virtual object get_Container();
    public sealed virtual void set_Container(object value);
    protected void Init(string description);
    protected void SetOpenedUnit(IParentUndoUnit value);
    protected void SetLastUnit(IUndoUnit value);
    protected virtual IParentUndoUnit CreateParentUndoUnitForSelf();
    protected IParentUndoUnit get_DeepestOpenUnit();
    protected object get_TopContainer();
    protected Stack get_Units();
    private bool IsInParentUnitChain(IUndoUnit unit);
}
internal class MS.Internal.Documents.ReaderPageViewer : FlowDocumentPageViewer {
    private EventHandler _pageNumberChanged;
    private EventHandler _pageCountChanged;
    private EventHandler _printCompleted;
    private EventHandler _printStarted;
    private bool _raisePageNumberChanged;
    private bool _raisePageCountChanged;
    private ContentPosition MS.Internal.Documents.IFlowDocumentViewer.ContentPosition { get; private set; }
    private ITextSelection MS.Internal.Documents.IFlowDocumentViewer.TextSelection { get; private set; }
    private bool MS.Internal.Documents.IFlowDocumentViewer.CanGoToPreviousPage { get; }
    private bool MS.Internal.Documents.IFlowDocumentViewer.CanGoToNextPage { get; }
    private int MS.Internal.Documents.IFlowDocumentViewer.PageNumber { get; }
    private int MS.Internal.Documents.IFlowDocumentViewer.PageCount { get; }
    protected virtual void OnPrintCompleted();
    protected virtual void OnPrintCommand();
    protected virtual void OnPropertyChanged(DependencyPropertyChangedEventArgs e);
    private object SetTextSelection(object arg);
    private object RaisePropertyChangedAsync(object arg);
    private sealed virtual override void MS.Internal.Documents.IFlowDocumentViewer.PreviousPage();
    private sealed virtual override void MS.Internal.Documents.IFlowDocumentViewer.NextPage();
    private sealed virtual override void MS.Internal.Documents.IFlowDocumentViewer.FirstPage();
    private sealed virtual override void MS.Internal.Documents.IFlowDocumentViewer.LastPage();
    private sealed virtual override void MS.Internal.Documents.IFlowDocumentViewer.Print();
    private sealed virtual override void MS.Internal.Documents.IFlowDocumentViewer.CancelPrint();
    private sealed virtual override void MS.Internal.Documents.IFlowDocumentViewer.ShowFindResult(ITextRange findResult);
    private sealed virtual override bool MS.Internal.Documents.IFlowDocumentViewer.CanGoToPage(int pageNumber);
    private sealed virtual override void MS.Internal.Documents.IFlowDocumentViewer.GoToPage(int pageNumber);
    private sealed virtual override void MS.Internal.Documents.IFlowDocumentViewer.SetDocument(FlowDocument document);
    private sealed virtual override ContentPosition MS.Internal.Documents.IFlowDocumentViewer.get_ContentPosition();
    private sealed virtual override void MS.Internal.Documents.IFlowDocumentViewer.set_ContentPosition(ContentPosition value);
    private sealed virtual override ITextSelection MS.Internal.Documents.IFlowDocumentViewer.get_TextSelection();
    private sealed virtual override void MS.Internal.Documents.IFlowDocumentViewer.set_TextSelection(ITextSelection value);
    private sealed virtual override bool MS.Internal.Documents.IFlowDocumentViewer.get_CanGoToPreviousPage();
    private sealed virtual override bool MS.Internal.Documents.IFlowDocumentViewer.get_CanGoToNextPage();
    private sealed virtual override int MS.Internal.Documents.IFlowDocumentViewer.get_PageNumber();
    private sealed virtual override int MS.Internal.Documents.IFlowDocumentViewer.get_PageCount();
    private sealed virtual override void MS.Internal.Documents.IFlowDocumentViewer.add_PageNumberChanged(EventHandler value);
    private sealed virtual override void MS.Internal.Documents.IFlowDocumentViewer.remove_PageNumberChanged(EventHandler value);
    private sealed virtual override void MS.Internal.Documents.IFlowDocumentViewer.add_PageCountChanged(EventHandler value);
    private sealed virtual override void MS.Internal.Documents.IFlowDocumentViewer.remove_PageCountChanged(EventHandler value);
    private sealed virtual override void MS.Internal.Documents.IFlowDocumentViewer.add_PrintStarted(EventHandler value);
    private sealed virtual override void MS.Internal.Documents.IFlowDocumentViewer.remove_PrintStarted(EventHandler value);
    private sealed virtual override void MS.Internal.Documents.IFlowDocumentViewer.add_PrintCompleted(EventHandler value);
    private sealed virtual override void MS.Internal.Documents.IFlowDocumentViewer.remove_PrintCompleted(EventHandler value);
}
internal class MS.Internal.Documents.ReaderScrollViewer : FlowDocumentScrollViewer {
    private EventHandler _pageNumberChanged;
    private EventHandler _pageCountChanged;
    private EventHandler _printCompleted;
    private EventHandler _printStarted;
    private ContentPosition MS.Internal.Documents.IFlowDocumentViewer.ContentPosition { get; private set; }
    private ITextSelection MS.Internal.Documents.IFlowDocumentViewer.TextSelection { get; private set; }
    private bool MS.Internal.Documents.IFlowDocumentViewer.CanGoToPreviousPage { get; }
    private bool MS.Internal.Documents.IFlowDocumentViewer.CanGoToNextPage { get; }
    private int MS.Internal.Documents.IFlowDocumentViewer.PageNumber { get; }
    private int MS.Internal.Documents.IFlowDocumentViewer.PageCount { get; }
    protected virtual void OnPrintCompleted();
    protected virtual void OnPrintCommand();
    protected virtual void OnPropertyChanged(DependencyPropertyChangedEventArgs e);
    private bool IsValidTextSelectionForDocument(ITextSelection textSelection, FlowDocument flowDocument);
    private object SetTextSelection(object arg);
    private sealed virtual override void MS.Internal.Documents.IFlowDocumentViewer.PreviousPage();
    private sealed virtual override void MS.Internal.Documents.IFlowDocumentViewer.NextPage();
    private sealed virtual override void MS.Internal.Documents.IFlowDocumentViewer.FirstPage();
    private sealed virtual override void MS.Internal.Documents.IFlowDocumentViewer.LastPage();
    private sealed virtual override void MS.Internal.Documents.IFlowDocumentViewer.Print();
    private sealed virtual override void MS.Internal.Documents.IFlowDocumentViewer.CancelPrint();
    private sealed virtual override void MS.Internal.Documents.IFlowDocumentViewer.ShowFindResult(ITextRange findResult);
    private sealed virtual override bool MS.Internal.Documents.IFlowDocumentViewer.CanGoToPage(int pageNumber);
    private sealed virtual override void MS.Internal.Documents.IFlowDocumentViewer.GoToPage(int pageNumber);
    private sealed virtual override void MS.Internal.Documents.IFlowDocumentViewer.SetDocument(FlowDocument document);
    private sealed virtual override ContentPosition MS.Internal.Documents.IFlowDocumentViewer.get_ContentPosition();
    private sealed virtual override void MS.Internal.Documents.IFlowDocumentViewer.set_ContentPosition(ContentPosition value);
    private sealed virtual override ITextSelection MS.Internal.Documents.IFlowDocumentViewer.get_TextSelection();
    private sealed virtual override void MS.Internal.Documents.IFlowDocumentViewer.set_TextSelection(ITextSelection value);
    private sealed virtual override bool MS.Internal.Documents.IFlowDocumentViewer.get_CanGoToPreviousPage();
    private sealed virtual override bool MS.Internal.Documents.IFlowDocumentViewer.get_CanGoToNextPage();
    private sealed virtual override int MS.Internal.Documents.IFlowDocumentViewer.get_PageNumber();
    private sealed virtual override int MS.Internal.Documents.IFlowDocumentViewer.get_PageCount();
    private sealed virtual override void MS.Internal.Documents.IFlowDocumentViewer.add_PageNumberChanged(EventHandler value);
    private sealed virtual override void MS.Internal.Documents.IFlowDocumentViewer.remove_PageNumberChanged(EventHandler value);
    private sealed virtual override void MS.Internal.Documents.IFlowDocumentViewer.add_PageCountChanged(EventHandler value);
    private sealed virtual override void MS.Internal.Documents.IFlowDocumentViewer.remove_PageCountChanged(EventHandler value);
    private sealed virtual override void MS.Internal.Documents.IFlowDocumentViewer.add_PrintStarted(EventHandler value);
    private sealed virtual override void MS.Internal.Documents.IFlowDocumentViewer.remove_PrintStarted(EventHandler value);
    private sealed virtual override void MS.Internal.Documents.IFlowDocumentViewer.add_PrintCompleted(EventHandler value);
    private sealed virtual override void MS.Internal.Documents.IFlowDocumentViewer.remove_PrintCompleted(EventHandler value);
}
internal class MS.Internal.Documents.ReaderTwoPageViewer : ReaderPageViewer {
    private static ReaderTwoPageViewer();
    protected virtual void OnPreviousPageCommand();
    protected virtual void OnNextPageCommand();
    protected virtual void OnLastPageCommand();
    protected virtual void OnGoToPageCommand(int pageNumber);
    protected virtual void OnPropertyChanged(DependencyPropertyChangedEventArgs e);
    private static object CoerceCanGoToNextPage(DependencyObject d, object value);
}
internal class MS.Internal.Documents.RowCache : object {
    [CompilerGeneratedAttribute]
private RowCacheChangedEventHandler RowCacheChanged;
    [CompilerGeneratedAttribute]
private RowLayoutCompletedEventHandler RowLayoutCompleted;
    private List`1<RowInfo> _rowCache;
    private int _layoutPivotPage;
    private int _layoutColumns;
    private int _pivotRowIndex;
    private PageCache _pageCache;
    private bool _isLayoutRequested;
    private bool _isLayoutCompleted;
    private double _verticalPageSpacing;
    private double _horizontalPageSpacing;
    private double _scale;
    private double _extentHeight;
    private double _extentWidth;
    private bool _hasValidLayout;
    private int _defaultRowCacheSize;
    private int _findOffsetPrecision;
    private double _visibleDelta;
    public PageCache PageCache { get; public set; }
    public int RowCount { get; }
    public double VerticalPageSpacing { get; public set; }
    public double HorizontalPageSpacing { get; public set; }
    public double Scale { get; public set; }
    public double ExtentHeight { get; }
    public double ExtentWidth { get; }
    public bool HasValidLayout { get; }
    private int LastPageInCache { get; }
    public void set_PageCache(PageCache value);
    public PageCache get_PageCache();
    public int get_RowCount();
    public void set_VerticalPageSpacing(double value);
    public double get_VerticalPageSpacing();
    public void set_HorizontalPageSpacing(double value);
    public double get_HorizontalPageSpacing();
    public void set_Scale(double value);
    public double get_Scale();
    public double get_ExtentHeight();
    public double get_ExtentWidth();
    public bool get_HasValidLayout();
    [CompilerGeneratedAttribute]
public void add_RowCacheChanged(RowCacheChangedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_RowCacheChanged(RowCacheChangedEventHandler value);
    [CompilerGeneratedAttribute]
public void add_RowLayoutCompleted(RowLayoutCompletedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_RowLayoutCompleted(RowLayoutCompletedEventHandler value);
    public RowInfo GetRow(int index);
    public RowInfo GetRowForPageNumber(int pageNumber);
    public int GetRowIndexForPageNumber(int pageNumber);
    public int GetRowIndexForVerticalOffset(double offset);
    public void GetVisibleRowIndices(double startOffset, double endOffset, Int32& startRowIndex, Int32& rowCount);
    public void RecalcLayoutForScaleOrSpacing();
    public void RecalcRows(int pivotPage, int columns);
    private int get_LastPageInCache();
    private bool WithinVisibleDelta(double offset1, double offset2);
    private int RecalcRowsForDynamicPageSizes(int pivotPage, int columns);
    private RowInfo CreateDynamicRow(int startPage, double rowWidth, bool createForward);
    private int RecalcRowsForFixedPageSizes(int startPage, int columns);
    private RowInfo CreateFixedRow(int startPage, int columns);
    private RowCacheChange AddPageRange(int startPage, int count);
    private void AddRow(RowInfo newRow);
    private RowCacheChange UpdatePageRange(int startPage, int count);
    private void UpdateRow(int index, RowInfo newRow);
    private RowCacheChange TrimPageRange(int startPage);
    private Size GetScaledPageSize(int pageNumber);
    private void OnPageCacheChanged(object sender, PageCacheChangedEventArgs args);
    private void OnPaginationCompleted(object sender, EventArgs args);
}
internal class MS.Internal.Documents.RowCacheChange : object {
    private int _start;
    private int _count;
    public int Start { get; }
    public int Count { get; }
    public RowCacheChange(int start, int count);
    public int get_Start();
    public int get_Count();
}
internal class MS.Internal.Documents.RowCacheChangedEventArgs : EventArgs {
    private List`1<RowCacheChange> _changes;
    public List`1<RowCacheChange> Changes { get; }
    public RowCacheChangedEventArgs(List`1<RowCacheChange> changes);
    public List`1<RowCacheChange> get_Changes();
}
internal class MS.Internal.Documents.RowCacheChangedEventHandler : MulticastDelegate {
    public RowCacheChangedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, RowCacheChangedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, RowCacheChangedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class MS.Internal.Documents.RowInfo : object {
    private Size _rowSize;
    private double _verticalOffset;
    private int _firstPage;
    private int _pageCount;
    public Size RowSize { get; }
    public double VerticalOffset { get; public set; }
    public int FirstPage { get; public set; }
    public int PageCount { get; }
    public void AddPage(Size pageSize);
    public void ClearPages();
    public Size get_RowSize();
    public double get_VerticalOffset();
    public void set_VerticalOffset(double value);
    public int get_FirstPage();
    public void set_FirstPage(int value);
    public int get_PageCount();
}
internal class MS.Internal.Documents.RowLayoutCompletedEventArgs : EventArgs {
    private int _pivotRowIndex;
    public int PivotRowIndex { get; }
    public RowLayoutCompletedEventArgs(int pivotRowIndex);
    public int get_PivotRowIndex();
}
internal class MS.Internal.Documents.RowLayoutCompletedEventHandler : MulticastDelegate {
    public RowLayoutCompletedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, RowLayoutCompletedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, RowLayoutCompletedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class MS.Internal.Documents.RowParagraphResult : ParagraphResult {
    private ReadOnlyCollection`1<ParagraphResult> _cells;
    private int _index;
    internal ReadOnlyCollection`1<ParagraphResult> CellParagraphs { get; }
    internal bool HasTextContent { get; }
    internal RowParagraphResult(BaseParaClient paraClient, int index, Rect rowRect, RowParagraph rowParagraph);
    internal ReadOnlyCollection`1<ParagraphResult> get_CellParagraphs();
    internal virtual bool get_HasTextContent();
}
internal class MS.Internal.Documents.ScrollData : object {
    private bool _disableHorizonalScroll;
    private bool _disableVerticalScroll;
    private Vector _offset;
    private Size _viewport;
    private Size _extent;
    private ScrollViewer _scrollOwner;
    internal bool CanVerticallyScroll { get; internal set; }
    internal bool CanHorizontallyScroll { get; internal set; }
    internal double ExtentWidth { get; internal set; }
    internal double ExtentHeight { get; internal set; }
    internal double ViewportWidth { get; }
    internal double ViewportHeight { get; }
    internal double HorizontalOffset { get; }
    internal double VerticalOffset { get; }
    internal ScrollViewer ScrollOwner { get; }
    internal Vector Offset { get; internal set; }
    internal Size Extent { get; internal set; }
    internal Size Viewport { get; internal set; }
    internal void LineUp(UIElement owner);
    internal void LineDown(UIElement owner);
    internal void LineLeft(UIElement owner);
    internal void LineRight(UIElement owner);
    internal void PageUp(UIElement owner);
    internal void PageDown(UIElement owner);
    internal void PageLeft(UIElement owner);
    internal void PageRight(UIElement owner);
    internal void MouseWheelUp(UIElement owner);
    internal void MouseWheelDown(UIElement owner);
    internal void MouseWheelLeft(UIElement owner);
    internal void MouseWheelRight(UIElement owner);
    internal void SetHorizontalOffset(UIElement owner, double offset);
    internal void SetVerticalOffset(UIElement owner, double offset);
    internal Rect MakeVisible(UIElement owner, Visual visual, Rect rectangle);
    internal void SetScrollOwner(UIElement owner, ScrollViewer value);
    internal bool get_CanVerticallyScroll();
    internal void set_CanVerticallyScroll(bool value);
    internal bool get_CanHorizontallyScroll();
    internal void set_CanHorizontallyScroll(bool value);
    internal double get_ExtentWidth();
    internal void set_ExtentWidth(double value);
    internal double get_ExtentHeight();
    internal void set_ExtentHeight(double value);
    internal double get_ViewportWidth();
    internal double get_ViewportHeight();
    internal double get_HorizontalOffset();
    internal double get_VerticalOffset();
    internal ScrollViewer get_ScrollOwner();
    internal Vector get_Offset();
    internal void set_Offset(Vector value);
    internal Size get_Extent();
    internal void set_Extent(Size value);
    internal Size get_Viewport();
    internal void set_Viewport(Size value);
    private double ComputeScrollOffset(double topView, double bottomView, double topChild, double bottomChild);
}
internal class MS.Internal.Documents.SubpageParagraphResult : ParagraphResult {
    private ReadOnlyCollection`1<ColumnResult> _columns;
    private ReadOnlyCollection`1<ParagraphResult> _floatingElements;
    internal ReadOnlyCollection`1<ColumnResult> Columns { get; }
    internal bool HasTextContent { get; }
    internal ReadOnlyCollection`1<ParagraphResult> FloatingElements { get; }
    internal Vector ContentOffset { get; }
    internal SubpageParagraphResult(BaseParaClient paraClient);
    internal ReadOnlyCollection`1<ColumnResult> get_Columns();
    internal virtual bool get_HasTextContent();
    internal ReadOnlyCollection`1<ParagraphResult> get_FloatingElements();
    internal Vector get_ContentOffset();
}
[DefaultMemberAttribute("Item")]
internal class MS.Internal.Documents.TableColumnCollectionInternal : ContentElementCollection`2<Table, TableColumn> {
    public TableColumn Item { get; public set; }
    internal TableColumnCollectionInternal(Table owner);
    public virtual void Add(TableColumn item);
    public virtual void Clear();
    public virtual void Insert(int index, TableColumn item);
    internal virtual void PrivateConnectChild(int index, TableColumn item);
    internal virtual void PrivateDisconnectChild(TableColumn item);
    public virtual bool Remove(TableColumn item);
    public virtual void RemoveAt(int index);
    public virtual void RemoveRange(int index, int count);
    public virtual TableColumn get_Item(int index);
    public virtual void set_Item(int index, TableColumn value);
}
internal class MS.Internal.Documents.TableParagraphResult : ParagraphResult {
    private ReadOnlyCollection`1<ParagraphResult> _paragraphs;
    internal ReadOnlyCollection`1<ParagraphResult> Paragraphs { get; }
    internal bool HasTextContent { get; }
    internal TableParagraphResult(BaseParaClient paraClient);
    internal ReadOnlyCollection`1<ParagraphResult> GetParagraphsFromPoint(Point point, bool snapToText);
    internal ReadOnlyCollection`1<ParagraphResult> GetParagraphsFromPosition(ITextPointer position);
    internal Geometry GetTightBoundingGeometryFromTextPositions(ITextPointer startPosition, ITextPointer endPosition, Rect visibleRect);
    internal CellParaClient GetCellParaClientFromPosition(ITextPointer position);
    internal CellParaClient GetCellAbove(double suggestedX, int rowGroupIndex, int rowIndex);
    internal CellParaClient GetCellBelow(double suggestedX, int rowGroupIndex, int rowIndex);
    internal CellInfo GetCellInfoFromPoint(Point point);
    internal Rect GetRectangleFromRowEndPosition(ITextPointer position);
    internal ReadOnlyCollection`1<ParagraphResult> get_Paragraphs();
    internal virtual bool get_HasTextContent();
}
[DefaultMemberAttribute("Item")]
internal class MS.Internal.Documents.TableTextElementCollectionInternal`2 : ContentElementCollection`2<TParent, TElementType> {
    public TElementType Item { get; public set; }
    internal TableTextElementCollectionInternal`2(TParent owner);
    public virtual void Add(TElementType item);
    public virtual void Clear();
    public virtual void Insert(int index, TElementType item);
    public virtual bool Remove(TElementType item);
    public virtual void RemoveAt(int index);
    public virtual void RemoveRange(int index, int count);
    internal virtual void PrivateConnectChild(int index, TElementType item);
    internal virtual void PrivateDisconnectChild(TElementType item);
    internal int FindInsertionIndex(TElementType item);
    internal void InternalAdd(TElementType item);
    internal void InternalRemove(TElementType item);
    public virtual TElementType get_Item(int index);
    public virtual void set_Item(int index, TElementType value);
}
internal static class MS.Internal.Documents.TextContainerHelper : object {
    internal static int ElementEdgeCharacterLength;
    internal static int EmbeddedObjectLength { get; }
    private static TextContainerHelper();
    internal static List`1<AutomationPeer> GetAutomationPeersFromRange(ITextPointer start, ITextPointer end, ITextPointer ownerContentStart);
    internal static bool IsImmediateAutomationChild(ITextPointer elementStart, ITextPointer ownerContentStart);
    internal static AutomationPeer GetEnclosingAutomationPeer(ITextPointer start, ITextPointer end, ITextPointer& elementStart, ITextPointer& elementEnd);
    internal static TextContentRange GetTextContentRangeForTextElement(TextElement textElement);
    internal static TextContentRange GetTextContentRangeForTextElementEdge(TextElement textElement, ElementEdge edge);
    internal static ITextPointer GetContentStart(ITextContainer textContainer, DependencyObject element);
    internal static int GetElementLength(ITextContainer textContainer, DependencyObject element);
    internal static int get_EmbeddedObjectLength();
    internal static ITextPointer GetTextPointerFromCP(ITextContainer textContainer, int cp, LogicalDirection direction);
    internal static StaticTextPointer GetStaticTextPointerFromCP(ITextContainer textContainer, int cp);
    internal static ITextPointer GetTextPointerForEmbeddedObject(FrameworkElement embeddedObject);
    internal static int GetCPFromElement(ITextContainer textContainer, DependencyObject element, ElementEdge edge);
    internal static int GetCchFromElement(ITextContainer textContainer, DependencyObject element);
    internal static int GetCPFromEmbeddedObject(UIElement embeddedObject, ElementEdge edge);
    private static void iterate(Visual parent, List`1<AutomationPeer> peers);
}
internal class MS.Internal.Documents.TextContentRange : object {
    private int _cpFirst;
    private int _cpLast;
    private int _size;
    private Int32[] _ranges;
    private ITextContainer _textContainer;
    internal ITextPointer StartPosition { get; }
    internal ITextPointer EndPosition { get; }
    private bool IsSimple { get; }
    internal TextContentRange(int cpFirst, int cpLast, ITextContainer textContainer);
    internal void Merge(TextContentRange other);
    internal ReadOnlyCollection`1<TextSegment> GetTextSegments();
    internal bool Contains(ITextPointer position, bool strict);
    internal ITextPointer get_StartPosition();
    internal ITextPointer get_EndPosition();
    private void Merge(int cpFirst, int cpLast);
    private bool MergeWithNext(int pos);
    private void EnsureSize();
    private void Normalize();
    private bool get_IsSimple();
}
internal class MS.Internal.Documents.TextDocumentView : TextViewBase {
    private FlowDocumentPage _owner;
    private ITextContainer _textContainer;
    private ReadOnlyCollection`1<ColumnResult> _columns;
    private ReadOnlyCollection`1<ParagraphResult> _floatingElements;
    private static ReadOnlyCollection`1<ParagraphResult> _emptyParagraphCollection;
    private ReadOnlyCollection`1<TextSegment> _segments;
    private bool _hasTextContent;
    internal UIElement RenderScope { get; }
    internal ITextContainer TextContainer { get; }
    internal bool IsValid { get; }
    internal ReadOnlyCollection`1<TextSegment> TextSegments { get; }
    private ReadOnlyCollection`1<TextSegment> TextSegmentsCore { get; }
    internal ReadOnlyCollection`1<ColumnResult> Columns { get; }
    internal ReadOnlyCollection`1<ParagraphResult> FloatingElements { get; }
    internal TextDocumentView(FlowDocumentPage owner, ITextContainer textContainer);
    private static TextDocumentView();
    internal virtual ITextPointer GetTextPositionFromPoint(Point point, bool snapToText);
    internal virtual Rect GetRawRectangleFromTextPosition(ITextPointer position, Transform& transform);
    internal virtual Geometry GetTightBoundingGeometryFromTextPositions(ITextPointer startPosition, ITextPointer endPosition);
    private Rect CalculateViewportRect();
    internal virtual ITextPointer GetPositionAtNextLine(ITextPointer position, double suggestedX, int count, Double& newSuggestedX, Int32& linesMoved);
    internal virtual bool IsAtCaretUnitBoundary(ITextPointer position);
    internal virtual ITextPointer GetNextCaretUnitPosition(ITextPointer position, LogicalDirection direction);
    internal virtual ITextPointer GetBackspaceCaretUnitPosition(ITextPointer position);
    internal virtual TextSegment GetLineRange(ITextPointer position);
    internal virtual ReadOnlyCollection`1<GlyphRun> GetGlyphRuns(ITextPointer start, ITextPointer end);
    internal virtual bool Contains(ITextPointer position);
    internal virtual bool Validate();
    internal virtual void ThrottleBackgroundTasksForUserInput();
    internal CellInfo GetCellInfoFromPoint(Point point, Table tableFilter);
    internal void OnUpdated();
    internal void Invalidate();
    internal static bool Contains(ITextPointer position, ReadOnlyCollection`1<TextSegment> segments);
    internal virtual UIElement get_RenderScope();
    internal virtual ITextContainer get_TextContainer();
    internal virtual bool get_IsValid();
    internal virtual ReadOnlyCollection`1<TextSegment> get_TextSegments();
    private ReadOnlyCollection`1<TextSegment> get_TextSegmentsCore();
    internal ReadOnlyCollection`1<ColumnResult> get_Columns();
    internal ReadOnlyCollection`1<ParagraphResult> get_FloatingElements();
    private ITextPointer GetTextPositionFromPoint(ReadOnlyCollection`1<ParagraphResult> paragraphs, ReadOnlyCollection`1<ParagraphResult> floatingElements, Point point, bool snapToText, bool snapToTextInFloatingElements);
    private ITextPointer GetTextPositionFromPoint(ParagraphResult paragraph, Point point, bool snapToText);
    private ITextPointer GetTextPositionFromPoint(ReadOnlyCollection`1<ColumnResult> columns, ReadOnlyCollection`1<ParagraphResult> floatingElements, Point point, bool snapToText);
    private CellInfo GetCellInfoFromPoint(ReadOnlyCollection`1<ParagraphResult> paragraphs, ReadOnlyCollection`1<ParagraphResult> floatingElements, Point point, Table tableFilter);
    private CellInfo GetCellInfoFromPoint(ParagraphResult paragraph, Point point, Table tableFilter);
    private CellInfo GetCellInfoFromPoint(ReadOnlyCollection`1<ColumnResult> columns, ReadOnlyCollection`1<ParagraphResult> floatingElements, Point point, Table tableFilter);
    private Rect GetRectangleFromTextPosition(ReadOnlyCollection`1<ParagraphResult> paragraphs, ReadOnlyCollection`1<ParagraphResult> floatingElements, ITextPointer position);
    private Rect GetRectangleFromTextPosition(ParagraphResult paragraph, ITextPointer position);
    private Rect GetRectangleFromTextPosition(ReadOnlyCollection`1<ColumnResult> columns, ReadOnlyCollection`1<ParagraphResult> floatingElements, ITextPointer position);
    internal static Geometry GetTightBoundingGeometryFromTextPositionsHelper(ReadOnlyCollection`1<ParagraphResult> paragraphs, ITextPointer startPosition, ITextPointer endPosition, double paragraphTopSpace, Rect visibleRect);
    internal static Geometry GetTightBoundingGeometryFromTextPositionsHelper(ReadOnlyCollection`1<ParagraphResult> paragraphs, ReadOnlyCollection`1<ParagraphResult> floatingElements, ITextPointer startPosition, ITextPointer endPosition, double paragraphTopSpace, Rect visibleRect);
    private static Geometry GetTightBoundingGeometryFromTextPositionsInFloatingElements(ReadOnlyCollection`1<ParagraphResult> floatingElements, ITextPointer startPosition, ITextPointer endPosition, double paragraphTopSpace, Rect visibleRect, Boolean& success);
    private static Rect GetLayoutBox(ParagraphResult paragraph);
    private bool IsAtCaretUnitBoundary(ReadOnlyCollection`1<ParagraphResult> paragraphs, ReadOnlyCollection`1<ParagraphResult> floatingElements, ITextPointer position);
    private bool IsAtCaretUnitBoundary(ParagraphResult paragraph, ITextPointer position);
    private bool IsAtCaretUnitBoundary(ReadOnlyCollection`1<ColumnResult> columns, ReadOnlyCollection`1<ParagraphResult> floatingElements, ITextPointer position);
    private ITextPointer GetNextCaretUnitPosition(ReadOnlyCollection`1<ParagraphResult> paragraphs, ReadOnlyCollection`1<ParagraphResult> floatingElements, ITextPointer position, LogicalDirection direction);
    private ITextPointer GetNextCaretUnitPosition(ParagraphResult paragraph, ITextPointer position, LogicalDirection direction);
    private ITextPointer GetNextCaretUnitPosition(ReadOnlyCollection`1<ColumnResult> columns, ReadOnlyCollection`1<ParagraphResult> floatingElements, ITextPointer position, LogicalDirection direction);
    private ITextPointer GetBackspaceCaretUnitPosition(ReadOnlyCollection`1<ParagraphResult> paragraphs, ReadOnlyCollection`1<ParagraphResult> floatingElements, ITextPointer position);
    private ITextPointer GetBackspaceCaretUnitPosition(ParagraphResult paragraph, ITextPointer position);
    private ITextPointer GetBackspaceCaretUnitPosition(ReadOnlyCollection`1<ColumnResult> columns, ReadOnlyCollection`1<ParagraphResult> floatingElements, ITextPointer position);
    private int GetColumnFromPoint(ReadOnlyCollection`1<ColumnResult> columns, Point point, bool snapToText);
    private int GetParagraphFromPoint(ReadOnlyCollection`1<ParagraphResult> paragraphs, Point point, bool snapToText);
    private int GetParagraphFromPointInFloatingElements(ReadOnlyCollection`1<ParagraphResult> floatingElements, Point point, bool snapToText);
    private int GetColumnFromPosition(ReadOnlyCollection`1<ColumnResult> columns, ITextPointer position);
    private static int GetParagraphFromPosition(ReadOnlyCollection`1<ParagraphResult> paragraphs, ReadOnlyCollection`1<ParagraphResult> floatingElements, ITextPointer position, Boolean& isFloatingPara);
    private static int GetParagraphFromPosition(ReadOnlyCollection`1<ParagraphResult> paragraphs, ITextPointer position);
    private TextSegment GetLineRangeFromPosition(ReadOnlyCollection`1<ParagraphResult> paragraphs, ReadOnlyCollection`1<ParagraphResult> floatingElements, ITextPointer position);
    private TextSegment GetLineRangeFromPosition(ParagraphResult paragraph, ITextPointer position);
    private TextSegment GetLineRangeFromPosition(ReadOnlyCollection`1<ColumnResult> columns, ReadOnlyCollection`1<ParagraphResult> floatingElements, ITextPointer position);
    private ITextPointer GetPositionAtNextLine(ReadOnlyCollection`1<ParagraphResult> paragraphs, ITextPointer position, double suggestedX, Int32& count, Boolean& positionFound);
    private ITextPointer GetPositionAtNextLineInFloatingElements(ReadOnlyCollection`1<ParagraphResult> floatingElements, ITextPointer position, double suggestedX, Int32& count, Boolean& positionFound);
    private ITextPointer GetPositionAtNextLine(ReadOnlyCollection`1<ColumnResult> columns, ReadOnlyCollection`1<ParagraphResult> floatingElements, ITextPointer position, double suggestedX, Int32& count, Double& newSuggestedX, Boolean& positionFound);
    private ITextPointer GetPositionAtNextLineFromSiblingPara(ReadOnlyCollection`1<ParagraphResult> paragraphs, int paragraphIndex, double suggestedX, Int32& count);
    private ITextPointer GetPositionAtNextLineFromSiblingTextPara(TextParagraphResult paragraph, double suggestedX, Int32& count);
    private ITextPointer GetPositionAtNextLineFromSiblingColumn(ReadOnlyCollection`1<ColumnResult> columns, int columnIndex, double columnSuggestedX, Double& newSuggestedX, Int32& count);
    private bool ContainsCore(ITextPointer position);
    private bool GetGlyphRunsFromParagraphs(List`1<GlyphRun> glyphRuns, ITextPointer start, ITextPointer end, ReadOnlyCollection`1<ParagraphResult> paragraphs);
    private void GetGlyphRunsFromFloatingElements(List`1<GlyphRun> glyphRuns, ITextPointer start, ITextPointer end, ReadOnlyCollection`1<ParagraphResult> floatingElements, Boolean& success);
    private void GetGlyphRuns(List`1<GlyphRun> glyphRuns, ITextPointer start, ITextPointer end, ReadOnlyCollection`1<ColumnResult> columns, ReadOnlyCollection`1<ParagraphResult> floatingElements);
    private ReadOnlyCollection`1<TextSegment> GetTextSegments();
    private void TransformToContent(Point& point);
    private void TransformToContent(Rect& rect);
    private void TransformFromContent(Rect& rect, Transform& transform);
    private void TransformFromContent(Point& point);
    private void TransformFromContent(Geometry geometry);
    private static void TransformToSubpage(Point& point, Vector subpageOffset);
    private static void TransformToSubpage(Rect& rect, Vector subpageOffset);
    private static void TransformFromSubpage(Rect& rect, Vector subpageOffset);
    private static void TransformFromSubpage(Geometry geometry, Vector subpageOffset);
    private Rect GetRectangleFromEdge(ParagraphResult paragraphResult, ITextPointer textPointer);
    private Rect GetRectangleFromContentEdge(ParagraphResult paragraphResult, ITextPointer textPointer);
}
internal class MS.Internal.Documents.TextParagraphResult : ParagraphResult {
    private ReadOnlyCollection`1<LineResult> _lines;
    private ReadOnlyCollection`1<ParagraphResult> _floaters;
    private ReadOnlyCollection`1<ParagraphResult> _figures;
    internal ReadOnlyCollection`1<LineResult> Lines { get; }
    internal ReadOnlyCollection`1<ParagraphResult> Floaters { get; }
    internal ReadOnlyCollection`1<ParagraphResult> Figures { get; }
    internal bool HasTextContent { get; }
    private bool ContainsOnlyFloatingElements { get; }
    internal TextParagraphResult(TextParaClient paraClient);
    internal Rect GetRectangleFromTextPosition(ITextPointer position);
    internal Geometry GetTightBoundingGeometryFromTextPositions(ITextPointer startPosition, ITextPointer endPosition, double paragraphTopSpace, Rect visibleRect);
    internal bool IsAtCaretUnitBoundary(ITextPointer position);
    internal ITextPointer GetNextCaretUnitPosition(ITextPointer position, LogicalDirection direction);
    internal ITextPointer GetBackspaceCaretUnitPosition(ITextPointer position);
    internal void GetGlyphRuns(List`1<GlyphRun> glyphRuns, ITextPointer start, ITextPointer end);
    internal virtual bool Contains(ITextPointer position, bool strict);
    internal ReadOnlyCollection`1<LineResult> get_Lines();
    internal ReadOnlyCollection`1<ParagraphResult> get_Floaters();
    internal ReadOnlyCollection`1<ParagraphResult> get_Figures();
    internal virtual bool get_HasTextContent();
    private bool get_ContainsOnlyFloatingElements();
}
internal class MS.Internal.Documents.TextParagraphView : TextViewBase {
    private TextBlock _owner;
    private ITextContainer _textContainer;
    private ReadOnlyCollection`1<LineResult> _lines;
    internal UIElement RenderScope { get; }
    internal ITextContainer TextContainer { get; }
    internal bool IsValid { get; }
    internal ReadOnlyCollection`1<TextSegment> TextSegments { get; }
    internal ReadOnlyCollection`1<LineResult> Lines { get; }
    internal TextParagraphView(TextBlock owner, ITextContainer textContainer);
    internal virtual ITextPointer GetTextPositionFromPoint(Point point, bool snapToText);
    internal virtual Rect GetRawRectangleFromTextPosition(ITextPointer position, Transform& transform);
    internal virtual Geometry GetTightBoundingGeometryFromTextPositions(ITextPointer startPosition, ITextPointer endPosition);
    internal virtual ITextPointer GetPositionAtNextLine(ITextPointer position, double suggestedX, int count, Double& newSuggestedX, Int32& linesMoved);
    internal virtual bool IsAtCaretUnitBoundary(ITextPointer position);
    internal virtual ITextPointer GetNextCaretUnitPosition(ITextPointer position, LogicalDirection direction);
    internal virtual ITextPointer GetBackspaceCaretUnitPosition(ITextPointer position);
    internal virtual TextSegment GetLineRange(ITextPointer position);
    internal virtual bool Contains(ITextPointer position);
    internal virtual bool Validate();
    internal static ITextPointer GetTextPositionFromPoint(ReadOnlyCollection`1<LineResult> lines, Point point, bool snapToText);
    internal static int GetLineFromPosition(ReadOnlyCollection`1<LineResult> lines, ITextPointer position);
    internal void OnUpdated();
    internal void Invalidate();
    internal virtual UIElement get_RenderScope();
    internal virtual ITextContainer get_TextContainer();
    internal virtual bool get_IsValid();
    internal virtual ReadOnlyCollection`1<TextSegment> get_TextSegments();
    internal ReadOnlyCollection`1<LineResult> get_Lines();
    internal static int GetLineFromPoint(ReadOnlyCollection`1<LineResult> lines, Point point, bool snapToText);
    private static bool GetVerticalLineFromPoint(ReadOnlyCollection`1<LineResult> lines, Point point, bool snapToText, Int32& lineIndex);
    private static bool GetHorizontalLineFromPoint(ReadOnlyCollection`1<LineResult> lines, Point point, bool snapToText, Int32& lineIndex);
}
internal abstract class MS.Internal.Documents.TextViewBase : object {
    [CompilerGeneratedAttribute]
private BringPositionIntoViewCompletedEventHandler BringPositionIntoViewCompleted;
    [CompilerGeneratedAttribute]
private BringPointIntoViewCompletedEventHandler BringPointIntoViewCompleted;
    [CompilerGeneratedAttribute]
private BringLineIntoViewCompletedEventHandler BringLineIntoViewCompleted;
    [CompilerGeneratedAttribute]
private BringPageIntoViewCompletedEventHandler BringPageIntoViewCompleted;
    [CompilerGeneratedAttribute]
private EventHandler Updated;
    internal UIElement RenderScope { get; }
    internal ITextContainer TextContainer { get; }
    internal bool IsValid { get; }
    internal bool RendersOwnSelection { get; }
    internal ReadOnlyCollection`1<TextSegment> TextSegments { get; }
    private UIElement System.Windows.Documents.ITextView.RenderScope { get; }
    private ITextContainer System.Windows.Documents.ITextView.TextContainer { get; }
    private bool System.Windows.Documents.ITextView.IsValid { get; }
    private bool System.Windows.Documents.ITextView.RendersOwnSelection { get; }
    private ReadOnlyCollection`1<TextSegment> System.Windows.Documents.ITextView.TextSegments { get; }
    internal abstract virtual ITextPointer GetTextPositionFromPoint(Point point, bool snapToText);
    internal virtual Rect GetRectangleFromTextPosition(ITextPointer position);
    internal abstract virtual Rect GetRawRectangleFromTextPosition(ITextPointer position, Transform& transform);
    internal abstract virtual Geometry GetTightBoundingGeometryFromTextPositions(ITextPointer startPosition, ITextPointer endPosition);
    internal abstract virtual ITextPointer GetPositionAtNextLine(ITextPointer position, double suggestedX, int count, Double& newSuggestedX, Int32& linesMoved);
    internal virtual ITextPointer GetPositionAtNextPage(ITextPointer position, Point suggestedOffset, int count, Point& newSuggestedOffset, Int32& pagesMoved);
    internal abstract virtual bool IsAtCaretUnitBoundary(ITextPointer position);
    internal abstract virtual ITextPointer GetNextCaretUnitPosition(ITextPointer position, LogicalDirection direction);
    internal abstract virtual ITextPointer GetBackspaceCaretUnitPosition(ITextPointer position);
    internal abstract virtual TextSegment GetLineRange(ITextPointer position);
    internal virtual ReadOnlyCollection`1<GlyphRun> GetGlyphRuns(ITextPointer start, ITextPointer end);
    internal abstract virtual bool Contains(ITextPointer position);
    internal static void BringRectIntoViewMinimally(ITextView textView, Rect rect);
    internal virtual void BringPositionIntoViewAsync(ITextPointer position, object userState);
    internal virtual void BringPointIntoViewAsync(Point point, object userState);
    internal virtual void BringLineIntoViewAsync(ITextPointer position, double suggestedX, int count, object userState);
    internal virtual void BringPageIntoViewAsync(ITextPointer position, Point suggestedOffset, int count, object userState);
    internal virtual void CancelAsync(object userState);
    internal virtual bool Validate();
    internal virtual bool Validate(Point point);
    internal virtual bool Validate(ITextPointer position);
    internal virtual void ThrottleBackgroundTasksForUserInput();
    internal abstract virtual UIElement get_RenderScope();
    internal abstract virtual ITextContainer get_TextContainer();
    internal abstract virtual bool get_IsValid();
    internal virtual bool get_RendersOwnSelection();
    internal abstract virtual ReadOnlyCollection`1<TextSegment> get_TextSegments();
    [CompilerGeneratedAttribute]
public sealed virtual void add_BringPositionIntoViewCompleted(BringPositionIntoViewCompletedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_BringPositionIntoViewCompleted(BringPositionIntoViewCompletedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_BringPointIntoViewCompleted(BringPointIntoViewCompletedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_BringPointIntoViewCompleted(BringPointIntoViewCompletedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_BringLineIntoViewCompleted(BringLineIntoViewCompletedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_BringLineIntoViewCompleted(BringLineIntoViewCompletedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_BringPageIntoViewCompleted(BringPageIntoViewCompletedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_BringPageIntoViewCompleted(BringPageIntoViewCompletedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_Updated(EventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_Updated(EventHandler value);
    protected virtual void OnBringPositionIntoViewCompleted(BringPositionIntoViewCompletedEventArgs e);
    protected virtual void OnBringPointIntoViewCompleted(BringPointIntoViewCompletedEventArgs e);
    protected virtual void OnBringLineIntoViewCompleted(BringLineIntoViewCompletedEventArgs e);
    protected virtual void OnBringPageIntoViewCompleted(BringPageIntoViewCompletedEventArgs e);
    protected virtual void OnUpdated(EventArgs e);
    protected virtual Transform GetAggregateTransform(Transform firstTransform, Transform secondTransform);
    private sealed virtual override ITextPointer System.Windows.Documents.ITextView.GetTextPositionFromPoint(Point point, bool snapToText);
    private sealed virtual override Rect System.Windows.Documents.ITextView.GetRectangleFromTextPosition(ITextPointer position);
    private sealed virtual override Rect System.Windows.Documents.ITextView.GetRawRectangleFromTextPosition(ITextPointer position, Transform& transform);
    private sealed virtual override Geometry System.Windows.Documents.ITextView.GetTightBoundingGeometryFromTextPositions(ITextPointer startPosition, ITextPointer endPosition);
    private sealed virtual override ITextPointer System.Windows.Documents.ITextView.GetPositionAtNextLine(ITextPointer position, double suggestedX, int count, Double& newSuggestedX, Int32& linesMoved);
    private sealed virtual override ITextPointer System.Windows.Documents.ITextView.GetPositionAtNextPage(ITextPointer position, Point suggestedOffset, int count, Point& newSuggestedOffset, Int32& pagesMoved);
    private sealed virtual override bool System.Windows.Documents.ITextView.IsAtCaretUnitBoundary(ITextPointer position);
    private sealed virtual override ITextPointer System.Windows.Documents.ITextView.GetNextCaretUnitPosition(ITextPointer position, LogicalDirection direction);
    private sealed virtual override ITextPointer System.Windows.Documents.ITextView.GetBackspaceCaretUnitPosition(ITextPointer position);
    private sealed virtual override TextSegment System.Windows.Documents.ITextView.GetLineRange(ITextPointer position);
    private sealed virtual override ReadOnlyCollection`1<GlyphRun> System.Windows.Documents.ITextView.GetGlyphRuns(ITextPointer start, ITextPointer end);
    private sealed virtual override bool System.Windows.Documents.ITextView.Contains(ITextPointer position);
    private sealed virtual override void System.Windows.Documents.ITextView.BringPositionIntoViewAsync(ITextPointer position, object userState);
    private sealed virtual override void System.Windows.Documents.ITextView.BringPointIntoViewAsync(Point point, object userState);
    private sealed virtual override void System.Windows.Documents.ITextView.BringLineIntoViewAsync(ITextPointer position, double suggestedX, int count, object userState);
    private sealed virtual override void System.Windows.Documents.ITextView.BringPageIntoViewAsync(ITextPointer position, Point suggestedOffset, int count, object userState);
    private sealed virtual override void System.Windows.Documents.ITextView.CancelAsync(object userState);
    private sealed virtual override bool System.Windows.Documents.ITextView.Validate();
    private sealed virtual override bool System.Windows.Documents.ITextView.Validate(Point point);
    private sealed virtual override bool System.Windows.Documents.ITextView.Validate(ITextPointer position);
    private sealed virtual override void System.Windows.Documents.ITextView.ThrottleBackgroundTasksForUserInput();
    private sealed virtual override UIElement System.Windows.Documents.ITextView.get_RenderScope();
    private sealed virtual override ITextContainer System.Windows.Documents.ITextView.get_TextContainer();
    private sealed virtual override bool System.Windows.Documents.ITextView.get_IsValid();
    private sealed virtual override bool System.Windows.Documents.ITextView.get_RendersOwnSelection();
    private sealed virtual override ReadOnlyCollection`1<TextSegment> System.Windows.Documents.ITextView.get_TextSegments();
}
internal class MS.Internal.Documents.UIElementIsland : ContainerVisual {
    [CompilerGeneratedAttribute]
private DesiredSizeChangedEventHandler DesiredSizeChanged;
    private UIElement _child;
    private bool _layoutInProgress;
    internal UIElement Root { get; }
    private IEnumerator`1<IInputElement> System.Windows.IContentHost.HostedElements { get; }
    internal UIElementIsland(UIElement child);
    internal Size DoLayout(Size availableSize, bool horizontalAutoSize, bool verticalAutoSize);
    internal UIElement get_Root();
    [CompilerGeneratedAttribute]
internal void add_DesiredSizeChanged(DesiredSizeChangedEventHandler value);
    [CompilerGeneratedAttribute]
internal void remove_DesiredSizeChanged(DesiredSizeChangedEventHandler value);
    public sealed virtual void Dispose();
    private sealed virtual override IInputElement System.Windows.IContentHost.InputHitTest(Point point);
    private sealed virtual override ReadOnlyCollection`1<Rect> System.Windows.IContentHost.GetRectangles(ContentElement child);
    private sealed virtual override IEnumerator`1<IInputElement> System.Windows.IContentHost.get_HostedElements();
    private sealed virtual override void System.Windows.IContentHost.OnChildDesiredSizeChanged(UIElement child);
}
internal class MS.Internal.Documents.UIElementParagraphResult : FloaterBaseParagraphResult {
    internal bool HasTextContent { get; }
    internal UIElementParagraphResult(BaseParaClient paraClient);
    internal virtual bool get_HasTextContent();
    internal Geometry GetTightBoundingGeometryFromTextPositions(ITextPointer startPosition, ITextPointer endPosition);
}
internal enum MS.Internal.Documents.UndoCloseAction : Enum {
    public int value__;
    public static UndoCloseAction Commit;
    public static UndoCloseAction Rollback;
    public static UndoCloseAction Discard;
}
internal class MS.Internal.Documents.UndoManager : object {
    private static DependencyProperty UndoManagerInstanceProperty;
    private DependencyObject _scope;
    private IParentUndoUnit _openedUnit;
    private IUndoUnit _lastUnit;
    private List`1<IUndoUnit> _undoStack;
    private Stack _redoStack;
    private UndoState _state;
    private bool _isEnabled;
    private IParentUndoUnit _lastReopenedUnit;
    private int _topUndoIndex;
    private int _bottomUndoIndex;
    private int _undoLimit;
    private int _minUndoStackCount;
    private bool _imeSupportModeEnabled;
    private static int _undoLimitDefaultValue;
    internal bool IsImeSupportModeEnabled { get; internal set; }
    internal int UndoLimit { get; internal set; }
    internal UndoState State { get; }
    internal bool IsEnabled { get; internal set; }
    internal IParentUndoUnit OpenedUnit { get; }
    internal IUndoUnit LastUnit { get; }
    internal IParentUndoUnit LastReopenedUnit { get; }
    internal int UndoCount { get; }
    internal int RedoCount { get; }
    internal static int UndoLimitDefaultValue { get; }
    internal int MinUndoStackCount { get; internal set; }
    protected IParentUndoUnit DeepestOpenUnit { get; }
    protected List`1<IUndoUnit> UndoStack { get; }
    protected Stack RedoStack { get; }
    private static UndoManager();
    internal static void AttachUndoManager(DependencyObject scope, UndoManager undoManager);
    internal static void DetachUndoManager(DependencyObject scope);
    internal static UndoManager GetUndoManager(DependencyObject target);
    internal void Open(IParentUndoUnit unit);
    internal void Reopen(IParentUndoUnit unit);
    internal void Close(UndoCloseAction closeAction);
    internal void Close(IParentUndoUnit unit, UndoCloseAction closeAction);
    internal void Add(IUndoUnit unit);
    internal void Clear();
    internal void Undo(int count);
    internal void Redo(int count);
    internal virtual void OnNextDiscard();
    internal IUndoUnit PeekUndoStack();
    internal Stack SetRedoStack(Stack value);
    internal bool get_IsImeSupportModeEnabled();
    internal void set_IsImeSupportModeEnabled(bool value);
    internal int get_UndoLimit();
    internal void set_UndoLimit(int value);
    internal UndoState get_State();
    internal bool get_IsEnabled();
    internal void set_IsEnabled(bool value);
    internal IParentUndoUnit get_OpenedUnit();
    internal IUndoUnit get_LastUnit();
    internal IParentUndoUnit get_LastReopenedUnit();
    internal int get_UndoCount();
    internal int get_RedoCount();
    internal static int get_UndoLimitDefaultValue();
    internal IUndoUnit GetUndoUnit(int index);
    internal void RemoveUndoRange(int index, int count);
    internal int get_MinUndoStackCount();
    internal void set_MinUndoStackCount(int value);
    protected void SetState(UndoState value);
    protected void SetOpenedUnit(IParentUndoUnit value);
    protected void SetLastUnit(IUndoUnit value);
    protected IParentUndoUnit get_DeepestOpenUnit();
    protected List`1<IUndoUnit> get_UndoStack();
    protected Stack get_RedoStack();
    private void DoClear();
    private IUndoUnit PopUndoStack();
}
internal enum MS.Internal.Documents.UndoState : Enum {
    public int value__;
    public static UndoState Normal;
    public static UndoState Undo;
    public static UndoState Redo;
    public static UndoState Rollback;
}
internal abstract class MS.Internal.FixedPageInfo : object {
    internal int GlyphRunCount { get; }
    internal abstract virtual GlyphRunInfo GlyphRunAtPosition(int position);
    internal abstract virtual int get_GlyphRunCount();
}
internal static class MS.Internal.FrameworkAppContextSwitches : object {
    internal static string DoNotApplyLayoutRoundingToMarginsAndBorderThicknessSwitchName;
    private static int _doNotApplyLayoutRoundingToMarginsAndBorderThickness;
    internal static string GridStarDefinitionsCanExceedAvailableSpaceSwitchName;
    private static int _gridStarDefinitionsCanExceedAvailableSpace;
    internal static string SelectionPropertiesCanLagBehindSelectionChangedEventSwitchName;
    private static int _selectionPropertiesCanLagBehindSelectionChangedEvent;
    internal static string DoNotUseFollowParentWhenBindingToADODataRelationSwitchName;
    private static int _doNotUseFollowParentWhenBindingToADODataRelation;
    internal static string UseAdornerForTextboxSelectionRenderingSwitchName;
    private static int _useAdornerForTextboxSelectionRendering;
    internal static string AppendLocalAssemblyVersionForSourceUriSwitchName;
    private static int _AppendLocalAssemblyVersionForSourceUriSwitchName;
    internal static string IListIndexerHidesCustomIndexerSwitchName;
    private static int _IListIndexerHidesCustomIndexer;
    internal static string KeyboardNavigationFromHyperlinkInItemsControlIsNotRelativeToFocusedElementSwitchName;
    private static int _KeyboardNavigationFromHyperlinkInItemsControlIsNotRelativeToFocusedElement;
    internal static string ItemAutomationPeerKeepsItsItemAliveSwitchName;
    private static int _ItemAutomationPeerKeepsItsItemAlive;
    public static bool DoNotApplyLayoutRoundingToMarginsAndBorderThickness { get; }
    public static bool GridStarDefinitionsCanExceedAvailableSpace { get; }
    public static bool SelectionPropertiesCanLagBehindSelectionChangedEvent { get; }
    public static bool DoNotUseFollowParentWhenBindingToADODataRelation { get; }
    public static bool UseAdornerForTextboxSelectionRendering { get; }
    public static bool AppendLocalAssemblyVersionForSourceUri { get; }
    public static bool IListIndexerHidesCustomIndexer { get; }
    public static bool KeyboardNavigationFromHyperlinkInItemsControlIsNotRelativeToFocusedElement { get; }
    public static bool ItemAutomationPeerKeepsItsItemAlive { get; }
    public static bool get_DoNotApplyLayoutRoundingToMarginsAndBorderThickness();
    public static bool get_GridStarDefinitionsCanExceedAvailableSpace();
    public static bool get_SelectionPropertiesCanLagBehindSelectionChangedEvent();
    public static bool get_DoNotUseFollowParentWhenBindingToADODataRelation();
    public static bool get_UseAdornerForTextboxSelectionRendering();
    public static bool get_AppendLocalAssemblyVersionForSourceUri();
    public static bool get_IListIndexerHidesCustomIndexer();
    public static bool get_KeyboardNavigationFromHyperlinkInItemsControlIsNotRelativeToFocusedElement();
    public static bool get_ItemAutomationPeerKeepsItsItemAlive();
}
internal class MS.Internal.FrameworkObject : ValueType {
    private FrameworkElement _fe;
    private FrameworkContentElement _fce;
    private DependencyObject _do;
    internal FrameworkElement FE { get; }
    internal FrameworkContentElement FCE { get; }
    internal DependencyObject DO { get; }
    internal bool IsFE { get; }
    internal bool IsFCE { get; }
    internal bool IsValid { get; }
    internal DependencyObject Parent { get; }
    internal int TemplateChildIndex { get; }
    internal DependencyObject TemplatedParent { get; }
    internal Style ThemeStyle { get; }
    internal XmlLanguage Language { get; }
    internal FrameworkTemplate TemplateInternal { get; }
    internal FrameworkObject FrameworkParent { get; }
    internal Style Style { get; internal set; }
    internal bool IsStyleSetFromGenerator { get; internal set; }
    internal DependencyObject EffectiveParent { get; }
    internal FrameworkObject PreferVisualParent { get; }
    internal bool IsLoaded { get; }
    internal bool IsInitialized { get; }
    internal bool ThisHasLoadedChangeEventHandler { get; }
    internal bool SubtreeHasLoadedChangeHandler { get; internal set; }
    internal InheritanceBehavior InheritanceBehavior { get; }
    internal bool StoresParentTemplateValues { get; internal set; }
    unknown bool HasResourceReference {internal set; }
    unknown bool HasTemplateChanged {internal set; }
    internal bool ShouldLookupImplicitStyles { get; internal set; }
    internal FrameworkObject(DependencyObject d);
    internal FrameworkObject(DependencyObject d, bool throwIfNeither);
    internal FrameworkObject(FrameworkElement fe, FrameworkContentElement fce);
    internal void Reset(DependencyObject d);
    internal FrameworkElement get_FE();
    internal FrameworkContentElement get_FCE();
    internal DependencyObject get_DO();
    internal bool get_IsFE();
    internal bool get_IsFCE();
    internal bool get_IsValid();
    internal DependencyObject get_Parent();
    internal int get_TemplateChildIndex();
    internal DependencyObject get_TemplatedParent();
    internal Style get_ThemeStyle();
    internal XmlLanguage get_Language();
    internal FrameworkTemplate get_TemplateInternal();
    internal FrameworkObject get_FrameworkParent();
    internal static FrameworkObject GetContainingFrameworkElement(DependencyObject current);
    internal Style get_Style();
    internal void set_Style(Style value);
    internal bool get_IsStyleSetFromGenerator();
    internal void set_IsStyleSetFromGenerator(bool value);
    internal DependencyObject get_EffectiveParent();
    internal FrameworkObject get_PreferVisualParent();
    internal bool get_IsLoaded();
    internal bool get_IsInitialized();
    internal bool get_ThisHasLoadedChangeEventHandler();
    internal bool get_SubtreeHasLoadedChangeHandler();
    internal void set_SubtreeHasLoadedChangeHandler(bool value);
    internal InheritanceBehavior get_InheritanceBehavior();
    internal bool get_StoresParentTemplateValues();
    internal void set_StoresParentTemplateValues(bool value);
    internal void set_HasResourceReference(bool value);
    internal void set_HasTemplateChanged(bool value);
    internal bool get_ShouldLookupImplicitStyles();
    internal void set_ShouldLookupImplicitStyles(bool value);
    internal static bool IsEffectiveAncestor(DependencyObject d1, DependencyObject d2);
    internal void ChangeLogicalParent(DependencyObject newParent);
    internal void BeginInit();
    internal void EndInit();
    internal object FindName(string name, DependencyObject& scopeOwner);
    internal FrameworkObject GetPreferVisualParent(bool force);
    private FrameworkObject GetRawPreferVisualParent();
    internal void RaiseEvent(RoutedEventArgs args);
    internal void OnLoaded(RoutedEventArgs args);
    internal void OnUnloaded(RoutedEventArgs args);
    internal void ChangeSubtreeHasLoadedChangedHandler(DependencyObject mentor);
    internal void OnInheritedPropertyChanged(InheritablePropertyChangeInfo& info);
    internal void SetShouldLookupImplicitStyles();
    internal void add_Loaded(RoutedEventHandler value);
    internal void remove_Loaded(RoutedEventHandler value);
    internal void add_Unloaded(RoutedEventHandler value);
    internal void remove_Unloaded(RoutedEventHandler value);
    internal void add_InheritedPropertyChanged(InheritedPropertyChangedEventHandler value);
    internal void remove_InheritedPropertyChanged(InheritedPropertyChangedEventHandler value);
    internal void add_ResourcesChanged(EventHandler value);
    internal void remove_ResourcesChanged(EventHandler value);
    private void UnexpectedCall();
    public virtual string ToString();
}
internal class MS.Internal.Globalization.BamlConnectionIdNode : BamlTreeNode {
    private int _connectionId;
    internal BamlConnectionIdNode(int connectionId);
    internal virtual void Serialize(BamlWriter writer);
    internal virtual BamlTreeNode Copy();
}
internal static class MS.Internal.Globalization.BamlConst : object {
    internal static string ContentSuffix;
    internal static string LiteralContentSuffix;
    internal static char KeySeperator;
    internal static char ChildStart;
    internal static char ChildEnd;
    internal static char EscapeChar;
}
internal class MS.Internal.Globalization.BamlContentPropertyNode : BamlTreeNode {
    private string _assemblyName;
    private string _typeFullName;
    private string _propertyName;
    internal BamlContentPropertyNode(string assemblyName, string typeFullName, string propertyName);
    internal virtual void Serialize(BamlWriter writer);
    internal virtual BamlTreeNode Copy();
}
internal class MS.Internal.Globalization.BamlDefAttributeNode : BamlTreeNode {
    private string _name;
    private string _value;
    internal BamlDefAttributeNode(string name, string value);
    internal virtual void Serialize(BamlWriter writer);
    internal virtual BamlTreeNode Copy();
}
internal class MS.Internal.Globalization.BamlEndComplexPropertyNode : BamlTreeNode {
    internal virtual void Serialize(BamlWriter writer);
    internal virtual BamlTreeNode Copy();
}
internal class MS.Internal.Globalization.BamlEndConstructorNode : BamlTreeNode {
    internal virtual void Serialize(BamlWriter writer);
    internal virtual BamlTreeNode Copy();
}
internal class MS.Internal.Globalization.BamlEndDocumentNode : BamlTreeNode {
    internal virtual void Serialize(BamlWriter writer);
    internal virtual BamlTreeNode Copy();
}
internal class MS.Internal.Globalization.BamlEndElementNode : BamlTreeNode {
    internal virtual void Serialize(BamlWriter writer);
    internal virtual BamlTreeNode Copy();
}
internal class MS.Internal.Globalization.BamlEventNode : BamlTreeNode {
    private string _eventName;
    private string _handlerName;
    internal BamlEventNode(string eventName, string handlerName);
    internal virtual void Serialize(BamlWriter writer);
    internal virtual BamlTreeNode Copy();
}
internal class MS.Internal.Globalization.BamlLiteralContentNode : BamlTreeNode {
    private string _literalContent;
    internal string Content { get; internal set; }
    internal BamlLiteralContentNode(string literalContent);
    internal virtual void Serialize(BamlWriter writer);
    internal virtual BamlTreeNode Copy();
    internal string get_Content();
    internal void set_Content(string value);
}
internal class MS.Internal.Globalization.BamlPIMappingNode : BamlTreeNode {
    private string _xmlNamespace;
    private string _clrNamespace;
    private string _assemblyName;
    internal BamlPIMappingNode(string xmlNamespace, string clrNamespace, string assemblyName);
    internal virtual void Serialize(BamlWriter writer);
    internal virtual BamlTreeNode Copy();
}
internal class MS.Internal.Globalization.BamlPresentationOptionsAttributeNode : BamlTreeNode {
    private string _name;
    private string _value;
    internal BamlPresentationOptionsAttributeNode(string name, string value);
    internal virtual void Serialize(BamlWriter writer);
    internal virtual BamlTreeNode Copy();
}
internal class MS.Internal.Globalization.BamlPropertyNode : BamlStartComplexPropertyNode {
    private string _value;
    private BamlAttributeUsage _attributeUsage;
    private int _index;
    internal string Value { get; internal set; }
    internal int Index { get; internal set; }
    internal BamlPropertyNode(string assemblyName, string ownerTypeFullName, string propertyName, string value, BamlAttributeUsage usage);
    internal virtual void Serialize(BamlWriter writer);
    internal virtual BamlTreeNode Copy();
    internal string get_Value();
    internal void set_Value(string value);
    internal int get_Index();
    internal void set_Index(int value);
}
internal static class MS.Internal.Globalization.BamlResourceContentUtil : object {
    private static Regex UnescapePattern;
    private static MatchEvaluator UnescapeMatchEvaluator;
    private static BamlResourceContentUtil();
    internal static string EscapeString(string content);
    internal static string UnescapeString(string content);
    private static string UnescapeMatch(Match match);
    internal static BamlStringToken[] ParseChildPlaceholder(string input);
}
internal class MS.Internal.Globalization.BamlResourceDeserializer : object {
    private Stack`1<BamlTreeNode> _bamlTreeStack;
    private Dictionary`2<string, Stack`1<ILocalizabilityInheritable>> _propertyInheritanceTreeStack;
    private BamlTreeNode _currentParent;
    private BamlStartDocumentNode _root;
    private BamlReader _reader;
    private int _nodeCount;
    internal static BamlTree LoadBaml(Stream bamlStream);
    private BamlTree LoadBamlImp(Stream bamlSteam);
    private void PushNodeToStack(BamlTreeNode node);
    private void AddChildToCurrentParent(BamlTreeNode node);
    private void PopStack();
    private void PushPropertyToStack(string propertyName, ILocalizabilityInheritable node);
    private void PopPropertyFromStack(string propertyName);
    private ILocalizabilityInheritable PeekPropertyStack(string propertyName);
}
internal class MS.Internal.Globalization.BamlResourceSerializer : object {
    private BamlWriter _writer;
    private Stack`1<BamlTreeNode> _bamlTreeStack;
    internal static void Serialize(BamlLocalizer localizer, BamlTree tree, Stream output);
    private void SerializeImp(BamlLocalizer localizer, BamlTree tree, Stream output);
    private void PushChildrenToStack(List`1<BamlTreeNode> children);
}
internal class MS.Internal.Globalization.BamlRoutedEventNode : BamlTreeNode {
    private string _assemblyName;
    private string _ownerTypeFullName;
    private string _eventIdName;
    private string _handlerName;
    internal BamlRoutedEventNode(string assemblyName, string ownerTypeFullName, string eventIdName, string handlerName);
    internal virtual void Serialize(BamlWriter writer);
    internal virtual BamlTreeNode Copy();
}
internal class MS.Internal.Globalization.BamlStartComplexPropertyNode : BamlTreeNode {
    protected string _assemblyName;
    protected string _ownerTypeFullName;
    protected string _propertyName;
    private ILocalizabilityInheritable _localizabilityAncestor;
    private LocalizabilityAttribute _inheritableAttribute;
    private bool _isIgnored;
    internal string AssemblyName { get; }
    internal string PropertyName { get; }
    internal string OwnerTypeFullName { get; }
    public ILocalizabilityInheritable LocalizabilityAncestor { get; public set; }
    public LocalizabilityAttribute InheritableAttribute { get; public set; }
    public bool IsIgnored { get; public set; }
    internal BamlStartComplexPropertyNode(string assemblyName, string ownerTypeFullName, string propertyName);
    internal virtual void Serialize(BamlWriter writer);
    internal virtual BamlTreeNode Copy();
    internal string get_AssemblyName();
    internal string get_PropertyName();
    internal string get_OwnerTypeFullName();
    public sealed virtual ILocalizabilityInheritable get_LocalizabilityAncestor();
    public void set_LocalizabilityAncestor(ILocalizabilityInheritable value);
    public sealed virtual LocalizabilityAttribute get_InheritableAttribute();
    public sealed virtual void set_InheritableAttribute(LocalizabilityAttribute value);
    public sealed virtual bool get_IsIgnored();
    public sealed virtual void set_IsIgnored(bool value);
}
internal class MS.Internal.Globalization.BamlStartConstructorNode : BamlTreeNode {
    internal virtual void Serialize(BamlWriter writer);
    internal virtual BamlTreeNode Copy();
}
internal class MS.Internal.Globalization.BamlStartDocumentNode : BamlTreeNode {
    public ILocalizabilityInheritable LocalizabilityAncestor { get; }
    public LocalizabilityAttribute InheritableAttribute { get; public set; }
    public bool IsIgnored { get; public set; }
    internal virtual void Serialize(BamlWriter writer);
    internal virtual BamlTreeNode Copy();
    public sealed virtual ILocalizabilityInheritable get_LocalizabilityAncestor();
    public sealed virtual LocalizabilityAttribute get_InheritableAttribute();
    public sealed virtual void set_InheritableAttribute(LocalizabilityAttribute value);
    public sealed virtual bool get_IsIgnored();
    public sealed virtual void set_IsIgnored(bool value);
}
internal class MS.Internal.Globalization.BamlStartElementNode : BamlTreeNode {
    private string _assemblyName;
    private string _typeFullName;
    private string _content;
    private string _uid;
    private LocalizabilityAttribute _inheritableAttribute;
    private ILocalizabilityInheritable _localizabilityAncestor;
    private bool _isIgnored;
    private bool _isInjected;
    private bool _useTypeConverter;
    internal string AssemblyName { get; }
    internal string TypeFullName { get; }
    internal string Content { get; internal set; }
    internal string Uid { get; internal set; }
    public ILocalizabilityInheritable LocalizabilityAncestor { get; }
    public LocalizabilityAttribute InheritableAttribute { get; public set; }
    public bool IsIgnored { get; public set; }
    internal BamlStartElementNode(string assemblyName, string typeFullName, bool isInjected, bool useTypeConverter);
    internal virtual void Serialize(BamlWriter writer);
    internal virtual BamlTreeNode Copy();
    internal void InsertProperty(BamlTreeNode child);
    internal string get_AssemblyName();
    internal string get_TypeFullName();
    internal string get_Content();
    internal void set_Content(string value);
    internal string get_Uid();
    internal void set_Uid(string value);
    public sealed virtual ILocalizabilityInheritable get_LocalizabilityAncestor();
    public sealed virtual LocalizabilityAttribute get_InheritableAttribute();
    public sealed virtual void set_InheritableAttribute(LocalizabilityAttribute value);
    public sealed virtual bool get_IsIgnored();
    public sealed virtual void set_IsIgnored(bool value);
}
internal class MS.Internal.Globalization.BamlStringToken : ValueType {
    internal TokenType Type;
    internal string Value;
    internal BamlStringToken(TokenType type, string value);
}
internal class MS.Internal.Globalization.BamlTextNode : BamlTreeNode {
    private string _content;
    private string _typeConverterAssemblyName;
    private string _typeConverterName;
    internal string Content { get; }
    internal BamlTextNode(string text);
    internal BamlTextNode(string text, string typeConverterAssemblyName, string typeConverterName);
    internal virtual void Serialize(BamlWriter writer);
    internal virtual BamlTreeNode Copy();
    internal string get_Content();
}
[DefaultMemberAttribute("Item")]
internal class MS.Internal.Globalization.BamlTree : object {
    private BamlTreeNode _root;
    private List`1<BamlTreeNode> _nodeList;
    internal BamlTreeNode Root { get; }
    internal int Size { get; }
    internal BamlTreeNode Item { get; }
    internal BamlTree(BamlTreeNode root, int size);
    internal BamlTreeNode get_Root();
    internal int get_Size();
    internal BamlTreeNode get_Item(int i);
    internal BamlTree Copy();
    internal void AddTreeNode(BamlTreeNode node);
    private void CreateInternalIndex(BamlTreeNode& parent, List`1& nodeList, bool toCopy);
}
internal class MS.Internal.Globalization.BamlTreeMap : object {
    private Hashtable _keyToBamlNodeIndexMap;
    private Hashtable _uidToBamlNodeIndexMap;
    private LocalizableResourceBuilder _localizableResourceBuilder;
    private BamlLocalizationDictionary _localizableResources;
    private BamlTree _tree;
    private InternalBamlLocalizabilityResolver _resolver;
    internal BamlLocalizationDictionary LocalizationDictionary { get; }
    internal InternalBamlLocalizabilityResolver Resolver { get; }
    internal BamlTreeMap(BamlLocalizer localizer, BamlTree tree, BamlLocalizabilityResolver resolver, TextReader comments);
    internal BamlLocalizationDictionary get_LocalizationDictionary();
    internal InternalBamlLocalizabilityResolver get_Resolver();
    internal BamlTreeNode MapKeyToBamlTreeNode(BamlLocalizableResourceKey key, BamlTree tree);
    internal BamlStartElementNode MapUidToBamlTreeElementNode(string uid, BamlTree tree);
    internal void EnsureMap();
    internal static BamlLocalizableResourceKey GetKey(BamlTreeNode node);
}
internal abstract class MS.Internal.Globalization.BamlTreeNode : object {
    protected BamlNodeType _nodeType;
    protected List`1<BamlTreeNode> _children;
    protected BamlTreeNode _parent;
    private BamlTreeNodeState _state;
    internal BamlNodeType NodeType { get; internal set; }
    internal List`1<BamlTreeNode> Children { get; internal set; }
    internal BamlTreeNode Parent { get; internal set; }
    internal bool Formatted { get; internal set; }
    internal bool Visited { get; internal set; }
    internal bool Unidentifiable { get; internal set; }
    internal BamlTreeNode(BamlNodeType type);
    internal void AddChild(BamlTreeNode child);
    internal abstract virtual BamlTreeNode Copy();
    internal abstract virtual void Serialize(BamlWriter writer);
    internal BamlNodeType get_NodeType();
    internal void set_NodeType(BamlNodeType value);
    internal List`1<BamlTreeNode> get_Children();
    internal void set_Children(List`1<BamlTreeNode> value);
    internal BamlTreeNode get_Parent();
    internal void set_Parent(BamlTreeNode value);
    internal bool get_Formatted();
    internal void set_Formatted(bool value);
    internal bool get_Visited();
    internal void set_Visited(bool value);
    internal bool get_Unidentifiable();
    internal void set_Unidentifiable(bool value);
}
internal static class MS.Internal.Globalization.BamlTreeUpdater : object {
    internal static void UpdateTree(BamlTree tree, BamlTreeMap treeMap, BamlLocalizationDictionary dictionary);
    private static void CreateMissingBamlTreeNode(BamlLocalizationDictionary dictionary, BamlTreeUpdateMap treeMap);
    private static bool ApplyChangeToBamlTree(BamlLocalizableResourceKey key, BamlLocalizableResource resource, BamlTreeUpdateMap treeMap);
    private static void ReArrangeChildren(BamlLocalizableResourceKey key, BamlTreeNode node, string translation, BamlTreeUpdateMap treeMap);
    private static void MergeChildrenList(BamlLocalizableResourceKey key, BamlTreeUpdateMap treeMap, BamlTreeNode parent, IList`1<BamlTreeNode> newChildren);
    private static void TryFlushTextToBamlNode(BamlTreeNode parent, StringBuilder textContent);
    private static IList`1<BamlTreeNode> SplitXmlContent(BamlLocalizableResourceKey key, string content, BamlTreeUpdateMap bamlTreeMap);
    private static bool GetBamlTreeNodeFromXmlNode(BamlLocalizableResourceKey key, XmlNode node, BamlTreeUpdateMap bamlTreeMap, IList`1<BamlTreeNode> newChildrenList);
    private static bool GetBamlTreeNodeFromText(BamlLocalizableResourceKey key, string content, BamlTreeUpdateMap bamlTreeMap, IList`1<BamlTreeNode> newChildrenList);
    private static void TryAddContentPropertyToNewElement(BamlTreeUpdateMap bamlTreeMap, BamlStartElementNode bamlNode);
}
internal class MS.Internal.Globalization.BamlXmlnsPropertyNode : BamlTreeNode {
    private string _prefix;
    private string _xmlns;
    internal BamlXmlnsPropertyNode(string prefix, string xmlns);
    internal virtual void Serialize(BamlWriter writer);
    internal virtual BamlTreeNode Copy();
}
internal interface MS.Internal.Globalization.ILocalizabilityInheritable {
    public ILocalizabilityInheritable LocalizabilityAncestor { get; }
    public LocalizabilityAttribute InheritableAttribute { get; public set; }
    public bool IsIgnored { get; public set; }
    public abstract virtual ILocalizabilityInheritable get_LocalizabilityAncestor();
    public abstract virtual LocalizabilityAttribute get_InheritableAttribute();
    public abstract virtual void set_InheritableAttribute(LocalizabilityAttribute value);
    public abstract virtual bool get_IsIgnored();
    public abstract virtual void set_IsIgnored(bool value);
}
internal class MS.Internal.Globalization.InternalBamlLocalizabilityResolver : BamlLocalizabilityResolver {
    private BamlLocalizabilityResolver _externalResolver;
    private FrugalObjectList`1<string> _assemblyNames;
    private Hashtable _classNameToAssemblyIndex;
    private Dictionary`2<string, ElementLocalizability> _classAttributeTable;
    private Dictionary`2<string, LocalizabilityAttribute> _propertyAttributeTable;
    private ElementComments[] _comments;
    private int _commentsIndex;
    private XmlDocument _commentsDocument;
    private BamlLocalizer _localizer;
    private TextReader _commentingText;
    private LocalizabilityAttribute DefaultAttribute { get; }
    internal InternalBamlLocalizabilityResolver(BamlLocalizer localizer, BamlLocalizabilityResolver externalResolver, TextReader comments);
    internal void AddClassAndAssembly(string className, string assemblyName);
    internal void InitLocalizabilityCache();
    internal void ReleaseLocalizabilityCache();
    internal LocalizabilityGroup GetLocalizabilityComment(BamlStartElementNode node, string localName);
    internal string GetStringComment(BamlStartElementNode node, string localName);
    internal void RaiseErrorNotifyEvent(BamlLocalizerErrorNotifyEventArgs e);
    public virtual ElementLocalizability GetElementLocalizability(string assembly, string className);
    public virtual LocalizabilityAttribute GetPropertyLocalizability(string assembly, string className, string property);
    public virtual string ResolveFormattingTagToClass(string formattingTag);
    public virtual string ResolveAssemblyFromClass(string className);
    private LocalizabilityAttribute get_DefaultAttribute();
    private ElementComments LookupCommentForElement(BamlStartElementNode node);
    private static XmlElement FindElementByID(XmlDocument doc, string uid);
    private void SetLocalizationAttributes(BamlStartElementNode node, ElementComments comments, string attributes);
    private void SetLocalizationComments(BamlStartElementNode node, ElementComments comments, string stringComment);
}
internal class MS.Internal.Globalization.LocalizabilityGroup : object {
    private static int InvalidValue;
    internal Modifiability Modifiability;
    internal Readability Readability;
    internal LocalizationCategory Category;
    internal LocalizabilityAttribute Override(LocalizabilityAttribute attribute);
}
internal class MS.Internal.Globalization.LocalizableResourceBuilder : object {
    private InternalBamlLocalizabilityResolver _resolver;
    private LocalizabilityAttribute LocalizabilityIgnore;
    internal LocalizableResourceBuilder(InternalBamlLocalizabilityResolver resolver);
    internal BamlLocalizableResource BuildFromNode(BamlLocalizableResourceKey key, BamlTreeNode node);
    internal bool TryGetContent(BamlLocalizableResourceKey key, BamlTreeNode currentNode, String& content);
    private bool TryFormatElementContent(BamlLocalizableResourceKey key, BamlStartElementNode node, String& content);
    private void GetLocalizabilityForElementNode(BamlStartElementNode node, LocalizabilityAttribute& localizability, String& formattingTag);
    private void GetLocalizabilityForPropertyNode(BamlStartComplexPropertyNode node, LocalizabilityAttribute& localizability);
    private LocalizabilityAttribute CombineAndPropagateInheritanceValues(ILocalizabilityInheritable node, LocalizabilityAttribute localizabilityFromSource);
    private LocalizabilityAttribute CreateInheritedLocalizability(LocalizabilityAttribute source, LocalizabilityAttribute inheritable);
    private LocalizabilityAttribute CombineMinimumLocalizability(LocalizabilityAttribute first, LocalizabilityAttribute second);
}
internal static class MS.Internal.Globalization.LocComments : object {
    private static char CommentStart;
    private static char CommentEnd;
    private static char EscapeChar;
    internal static string LocDocumentRoot;
    internal static string LocResourcesElement;
    internal static string LocCommentsElement;
    internal static string LocFileNameAttribute;
    internal static string LocCommentIDAttribute;
    internal static string LocCommentsAttribute;
    internal static string LocLocalizabilityAttribute;
    private static EnumNameIndexTable ReadabilityIndexTable;
    private static EnumNameIndexTable ModifiabilityIndexTable;
    private static EnumNameIndexTable LocalizationCategoryIndexTable;
    private static LocComments();
    internal static bool IsLocLocalizabilityProperty(string type, string property);
    internal static bool IsLocCommentsProperty(string type, string property);
    internal static PropertyComment[] ParsePropertyLocalizabilityAttributes(string input);
    internal static PropertyComment[] ParsePropertyComments(string input);
    private static LocalizabilityGroup LookupAndSetLocalizabilityAttribute(string input);
    private static void ParseLocalizabilityString(string value, LocalizabilityGroup attributeGroup);
}
internal class MS.Internal.Globalization.PropertyComment : object {
    private string _target;
    private object _value;
    internal string PropertyName { get; internal set; }
    internal object Value { get; internal set; }
    internal string get_PropertyName();
    internal void set_PropertyName(string value);
    internal object get_Value();
    internal void set_Value(object value);
}
internal abstract class MS.Internal.GlyphRunInfo : object {
    internal Point StartPosition { get; }
    internal Point EndPosition { get; }
    internal double WidthEmFontSize { get; }
    internal double HeightEmFontSize { get; }
    internal bool GlyphsHaveSidewaysOrientation { get; }
    internal int BidiLevel { get; }
    internal UInt32 LanguageID { get; }
    internal string UnicodeString { get; }
    internal abstract virtual Point get_StartPosition();
    internal abstract virtual Point get_EndPosition();
    internal abstract virtual double get_WidthEmFontSize();
    internal abstract virtual double get_HeightEmFontSize();
    internal abstract virtual bool get_GlyphsHaveSidewaysOrientation();
    internal abstract virtual int get_BidiLevel();
    internal abstract virtual UInt32 get_LanguageID();
    internal abstract virtual string get_UnicodeString();
}
internal static class MS.Internal.Hashing.PresentationFramework.HashHelper : object {
    private static HashHelper();
    internal static bool HasReliableHashCode(object item);
    internal static void Initialize();
}
internal static class MS.Internal.Helper : object {
    private static Type NullableType;
    private static UncommonField`1<WeakDictionary`2<object, List`1<KeyValuePair`2<int, object>>>> ItemValueStorageField;
    private static Int32[] ItemValueStorageIndices;
    private static Helper();
    internal static object ResourceFailureThrow(object key);
    internal static object FindTemplateResourceFromAppOrSystem(DependencyObject target, ArrayList keys, int exactMatch, Int32& bestMatch);
    internal static DependencyObject FindMentor(DependencyObject d);
    internal static bool HasDefaultValue(DependencyObject d, DependencyProperty dp);
    internal static bool HasDefaultOrInheritedValue(DependencyObject d, DependencyProperty dp);
    internal static bool HasUnmodifiedDefaultValue(DependencyObject d, DependencyProperty dp);
    internal static bool HasUnmodifiedDefaultOrInheritedValue(DependencyObject d, DependencyProperty dp);
    private static bool HasDefaultOrInheritedValueImpl(DependencyObject d, DependencyProperty dp, bool checkInherited, bool ignoreModifiers);
    internal static void DowncastToFEorFCE(DependencyObject d, FrameworkElement& fe, FrameworkContentElement& fce, bool throwIfNeither);
    internal static void CheckStyleAndStyleSelector(string name, DependencyProperty styleProperty, DependencyProperty styleSelectorProperty, DependencyObject d);
    internal static void CheckTemplateAndTemplateSelector(string name, DependencyProperty templateProperty, DependencyProperty templateSelectorProperty, DependencyObject d);
    internal static bool IsTemplateSelectorDefined(DependencyProperty templateSelectorProperty, DependencyObject d);
    internal static bool IsTemplateDefined(DependencyProperty templateProperty, DependencyObject d);
    internal static object FindNameInTemplate(string name, DependencyObject templatedParent);
    internal static IGeneratorHost GeneratorHostForElement(DependencyObject element);
    internal static DependencyObject GetTemplatedParent(DependencyObject d);
    internal static XmlDataProvider XmlDataProviderForElement(DependencyObject d);
    internal static Size MeasureElementWithSingleChild(UIElement element, Size constraint);
    internal static Size ArrangeElementWithSingleChild(UIElement element, Size arrangeSize);
    internal static bool IsDoubleValid(double value);
    internal static void CheckCanReceiveMarkupExtension(MarkupExtension markupExtension, IServiceProvider serviceProvider, DependencyObject& targetDependencyObject, DependencyProperty& targetDependencyProperty);
    private static EventHandler`1<XamlSetMarkupExtensionEventArgs> LookupSetMarkupExtensionHandler(Type type);
    internal static string GetEffectiveStringFormat(string stringFormat);
    internal static object ReadItemValue(DependencyObject owner, object item, int dpIndex);
    internal static void StoreItemValue(DependencyObject owner, object item, int dpIndex, object value);
    internal static void ClearItemValue(DependencyObject owner, object item, int dpIndex);
    internal static List`1<KeyValuePair`2<int, object>> GetItemValues(DependencyObject owner, object item);
    internal static List`1<KeyValuePair`2<int, object>> GetItemValues(DependencyObject owner, object item, WeakDictionary`2<object, List`1<KeyValuePair`2<int, object>>> itemValueStorage);
    internal static List`1<KeyValuePair`2<int, object>> EnsureItemValues(DependencyObject owner, object item);
    internal static WeakDictionary`2<object, List`1<KeyValuePair`2<int, object>>> EnsureItemValueStorage(DependencyObject owner);
    internal static void SetItemValuesOnContainer(DependencyObject owner, DependencyObject container, object item);
    internal static void StoreItemValues(IContainItemStorage owner, DependencyObject container, object item);
    internal static void ClearItemValueStorage(DependencyObject owner);
    internal static void ClearItemValueStorage(DependencyObject owner, Int32[] dpIndices);
    private static void ClearItemValueStorageRecursive(WeakDictionary`2<object, List`1<KeyValuePair`2<int, object>>> itemValueStorage, Int32[] dpIndices);
    internal static void ApplyCorrectionFactorToPixelHeaderSize(ItemsControl scrollingItemsControl, FrameworkElement virtualizingElement, Panel itemsHost, Size& headerSize);
    internal static HierarchicalVirtualizationItemDesiredSizes ApplyCorrectionFactorToItemDesiredSizes(FrameworkElement virtualizingElement, Panel itemsHost);
    internal static void ComputeCorrectionFactor(ItemsControl scrollingItemsControl, FrameworkElement virtualizingElement, Panel itemsHost, FrameworkElement headerElement);
    internal static void ClearVirtualizingElement(IHierarchicalVirtualizationAndScrollInfo virtualizingElement);
    internal static T FindTemplatedDescendant(FrameworkElement searchStart, FrameworkElement templatedParent);
    internal static T FindVisualAncestor(DependencyObject element, Func`2<DependencyObject, bool> shouldContinueFunc);
    internal static void InvalidateMeasureOnPath(DependencyObject pathStartElement, DependencyObject pathEndElement, bool duringMeasure);
    internal static void InvalidateMeasureOnPath(DependencyObject pathStartElement, DependencyObject pathEndElement, bool duringMeasure, bool includePathEnd);
    internal static void InvalidateMeasureForSubtree(DependencyObject d);
    internal static bool IsAnyAncestorOf(DependencyObject ancestor, DependencyObject element);
    internal static DependencyObject FindAnyAncestor(DependencyObject element, Predicate`1<DependencyObject> predicate);
    internal static DependencyObject GetAnyParent(DependencyObject element);
    internal static bool IsDefaultValue(DependencyProperty dp, DependencyObject element);
    internal static bool IsComposing(DependencyObject d, DependencyProperty dp);
    internal static bool IsComposing(TextBoxBase tbb);
}
internal class MS.Internal.InheritedPropertyChangedEventArgs : EventArgs {
    private InheritablePropertyChangeInfo _info;
    internal InheritablePropertyChangeInfo Info { get; }
    internal InheritedPropertyChangedEventArgs(InheritablePropertyChangeInfo& info);
    internal InheritablePropertyChangeInfo get_Info();
}
internal class MS.Internal.InheritedPropertyChangedEventHandler : MulticastDelegate {
    public InheritedPropertyChangedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, InheritedPropertyChangedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, InheritedPropertyChangedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal abstract class MS.Internal.Ink.ClipboardData : object {
    internal bool CopyToDataObject(IDataObject dataObject);
    internal void PasteFromDataObject(IDataObject dataObject);
    internal abstract virtual bool CanPaste(IDataObject dataObject);
    protected abstract virtual bool CanCopy();
    protected abstract virtual void DoCopy(IDataObject dataObject);
    protected abstract virtual void DoPaste(IDataObject dataObject);
}
internal class MS.Internal.Ink.ClipboardProcessor : object {
    private InkCanvas _inkCanvas;
    private static DependencyObjectType s_InkCanvasDType;
    private Dictionary`2<InkCanvasClipboardFormat, ClipboardData> _preferredClipboardData;
    internal IEnumerable`1<InkCanvasClipboardFormat> PreferredFormats { get; internal set; }
    private InkCanvas InkCanvas { get; }
    private static DependencyObjectType InkCanvasDType { get; }
    internal ClipboardProcessor(InkCanvas inkCanvas);
    internal bool CheckDataFormats(IDataObject dataObject);
    internal InkCanvasClipboardDataFormats CopySelectedData(IDataObject dataObject);
    internal bool PasteData(IDataObject dataObject, StrokeCollection& newStrokes, List`1& newElements);
    [IteratorStateMachineAttribute("MS.Internal.Ink.ClipboardProcessor/<get_PreferredFormats>d__5")]
internal IEnumerable`1<InkCanvasClipboardFormat> get_PreferredFormats();
    internal void set_PreferredFormats(IEnumerable`1<InkCanvasClipboardFormat> value);
    private bool CopySelectionInXAML(IDataObject dataObject, StrokeCollection strokes, List`1<UIElement> elements, Matrix transform, Size size);
    private void TearDownInkCanvasContainer(InkCanvas rootInkCanvas, StrokeCollection& newStrokes, List`1& newElements);
    private InkCanvas get_InkCanvas();
    private static DependencyObjectType get_InkCanvasDType();
}
internal class MS.Internal.Ink.DrawingAttributesDefaultValueFactory : DefaultValueFactory {
    internal object DefaultValue { get; }
    internal virtual object get_DefaultValue();
    internal virtual object CreateDefaultValue(DependencyObject owner, DependencyProperty property);
}
internal abstract class MS.Internal.Ink.EditingBehavior : object {
    private InkCanvas _inkCanvas;
    private EditingCoordinator _editingCoordinator;
    private Cursor _cachedCursor;
    public Cursor Cursor { get; }
    protected InkCanvas InkCanvas { get; }
    protected EditingCoordinator EditingCoordinator { get; }
    internal EditingBehavior(EditingCoordinator editingCoordinator, InkCanvas inkCanvas);
    public void Activate();
    public void Deactivate();
    public void Commit(bool commit);
    public void UpdateTransform();
    public Cursor get_Cursor();
    protected abstract virtual void OnActivate();
    protected abstract virtual void OnDeactivate();
    protected abstract virtual void OnCommit(bool commit);
    protected abstract virtual Cursor GetCurrentCursor();
    protected void SelfDeactivate();
    protected Matrix GetElementTransformMatrix();
    protected virtual void OnTransformChanged();
    protected InkCanvas get_InkCanvas();
    protected EditingCoordinator get_EditingCoordinator();
}
internal class MS.Internal.Ink.EditingCoordinator : object {
    private InkCanvas _inkCanvas;
    private Stack`1<EditingBehavior> _activationStack;
    private InkCollectionBehavior _inkCollectionBehavior;
    private EraserBehavior _eraserBehavior;
    private LassoSelectionBehavior _lassoSelectionBehavior;
    private SelectionEditingBehavior _selectionEditingBehavior;
    private SelectionEditor _selectionEditor;
    private bool _moveEnabled;
    private bool _resizeEnabled;
    private bool _userIsEditing;
    private bool _stylusIsInverted;
    private StylusPointDescription _commonDescription;
    private StylusDevice _capturedStylus;
    private MouseDevice _capturedMouse;
    private BehaviorValidFlag _behaviorValidFlag;
    internal bool MoveEnabled { get; internal set; }
    internal bool UserIsEditing { get; internal set; }
    internal bool StylusOrMouseIsDown { get; }
    internal bool ResizeEnabled { get; internal set; }
    internal LassoSelectionBehavior LassoSelectionBehavior { get; }
    internal SelectionEditingBehavior SelectionEditingBehavior { get; }
    internal InkCanvasEditingMode ActiveEditingMode { get; }
    internal SelectionEditor SelectionEditor { get; }
    internal bool IsInMidStroke { get; }
    internal bool IsStylusInverted { get; }
    private EditingBehavior ActiveEditingBehavior { get; }
    internal InkCollectionBehavior InkCollectionBehavior { get; }
    private EraserBehavior EraserBehavior { get; }
    internal EditingCoordinator(InkCanvas inkCanvas);
    internal void ActivateDynamicBehavior(EditingBehavior dynamicBehavior, InputDevice inputDevice);
    internal void DeactivateDynamicBehavior();
    internal void UpdateActiveEditingState();
    internal void UpdateEditingState(bool inverted);
    internal void UpdatePointEraserCursor();
    internal void InvalidateTransform();
    internal void InvalidateBehaviorCursor(EditingBehavior behavior);
    internal bool IsCursorValid(EditingBehavior behavior);
    internal bool IsTransformValid(EditingBehavior behavior);
    internal IStylusEditing ChangeStylusEditingMode(StylusEditingBehavior sourceBehavior, InkCanvasEditingMode newMode);
    [ConditionalAttribute("DEBUG")]
internal void DebugCheckActiveBehavior(EditingBehavior behavior);
    [ConditionalAttribute("DEBUG")]
private void DebugCheckDynamicBehavior(EditingBehavior behavior);
    [ConditionalAttribute("DEBUG")]
private void DebugCheckNonDynamicBehavior(EditingBehavior behavior);
    internal bool get_MoveEnabled();
    internal void set_MoveEnabled(bool value);
    internal bool get_UserIsEditing();
    internal void set_UserIsEditing(bool value);
    internal bool get_StylusOrMouseIsDown();
    internal InputDevice GetInputDeviceForReset();
    internal bool get_ResizeEnabled();
    internal void set_ResizeEnabled(bool value);
    internal LassoSelectionBehavior get_LassoSelectionBehavior();
    internal SelectionEditingBehavior get_SelectionEditingBehavior();
    internal InkCanvasEditingMode get_ActiveEditingMode();
    internal SelectionEditor get_SelectionEditor();
    internal bool get_IsInMidStroke();
    internal bool get_IsStylusInverted();
    private EditingBehavior GetBehavior(InkCanvasEditingMode editingMode);
    private void PushEditingBehavior(EditingBehavior newEditingBehavior);
    private void PopEditingBehavior();
    private void OnInkCanvasStylusInAirOrInRangeMove(object sender, StylusEventArgs args);
    private void OnInkCanvasStylusOutOfRange(object sender, StylusEventArgs args);
    internal void OnInkCanvasDeviceDown(object sender, InputEventArgs args);
    private void OnInkCanvasDeviceMove(object sender, TEventArgs args);
    internal void OnInkCanvasDeviceUp(object sender, InputEventArgs args);
    private void OnInkCanvasLostDeviceCapture(object sender, TEventArgs args);
    private void InitializeCapture(InputDevice inputDevice, IStylusEditing stylusEditingBehavior, bool userInitiated, bool resetDynamicRenderer);
    private void ReleaseCapture(bool releaseDevice);
    private bool IsInputDeviceCaptured(InputDevice inputDevice);
    internal Cursor GetActiveBehaviorCursor();
    private bool GetCursorValid(EditingBehavior behavior);
    private void SetCursorValid(EditingBehavior behavior, bool isValid);
    private bool GetTransformValid(EditingBehavior behavior);
    private void SetTransformValid(EditingBehavior behavior, bool isValid);
    private bool GetBitFlag(BehaviorValidFlag flag);
    private void SetBitFlag(BehaviorValidFlag flag, bool value);
    private BehaviorValidFlag GetBehaviorCursorFlag(EditingBehavior behavior);
    private BehaviorValidFlag GetBehaviorTransformFlag(EditingBehavior behavior);
    private void ChangeEditingBehavior(EditingBehavior newBehavior);
    private bool UpdateInvertedState(StylusDevice stylusDevice, bool stylusIsInverted);
    private EditingBehavior get_ActiveEditingBehavior();
    internal InkCollectionBehavior get_InkCollectionBehavior();
    private EraserBehavior get_EraserBehavior();
}
internal abstract class MS.Internal.Ink.ElementsClipboardData : ClipboardData {
    private List`1<UIElement> _elementList;
    internal List`1<UIElement> Elements { get; }
    protected List`1<UIElement> ElementList { get; protected set; }
    internal ElementsClipboardData(UIElement[] elements);
    internal List`1<UIElement> get_Elements();
    protected List`1<UIElement> get_ElementList();
    protected void set_ElementList(List`1<UIElement> value);
}
internal class MS.Internal.Ink.EraserBehavior : StylusEditingBehavior {
    private InkCanvasEditingMode _cachedEraseMode;
    private IncrementalStrokeHitTester _incrementalStrokeHitTester;
    private Cursor _cachedPointEraserCursor;
    private StylusShape _cachedStylusShape;
    private StylusPointCollection _stylusPoints;
    internal EraserBehavior(EditingCoordinator editingCoordinator, InkCanvas inkCanvas);
    protected virtual void OnSwitchToMode(InkCanvasEditingMode mode);
    protected virtual void OnActivate();
    protected virtual void StylusInputBegin(StylusPointCollection stylusPoints, bool userInitiated);
    protected virtual void StylusInputContinue(StylusPointCollection stylusPoints, bool userInitiated);
    protected virtual void StylusInputEnd(bool commit);
    protected virtual Cursor GetCurrentCursor();
    protected virtual void OnTransformChanged();
    private void ResetCachedPointEraserCursor();
    private void OnStrokeEraseResultChanged(object sender, StrokeHitEventArgs e);
    private void OnPointEraseResultChanged(object sender, StrokeHitEventArgs e);
}
internal abstract class MS.Internal.Ink.HighContrastCallback : object {
    internal Dispatcher Dispatcher { get; }
    internal abstract virtual void TurnHighContrastOn(Color highContrastColor);
    internal abstract virtual void TurnHighContrastOff();
    internal abstract virtual Dispatcher get_Dispatcher();
}
internal static class MS.Internal.Ink.HighContrastHelper : object {
    private static object __lock;
    private static List`1<WeakReference> __highContrastCallbackList;
    private static int __increaseCount;
    private static int CleanTolerance;
    private static HighContrastHelper();
    internal static void RegisterHighContrastCallback(HighContrastCallback highContrastCallback);
    internal static void OnSettingChanged();
    private static void UpdateHighContrast();
    private static void OnUpdateHighContrast(HighContrastCallback highContrastCallback);
}
[FlagsAttribute]
internal enum MS.Internal.Ink.InkCanvasClipboardDataFormats : Enum {
    public int value__;
    public static InkCanvasClipboardDataFormats None;
    public static InkCanvasClipboardDataFormats XAML;
    public static InkCanvasClipboardDataFormats ISF;
}
internal class MS.Internal.Ink.InkCanvasSelection : object {
    private InkCanvas _inkCanvas;
    private StrokeCollection _selectedStrokes;
    private Rect _cachedStrokesBounds;
    private bool _areStrokesChanged;
    private List`1<UIElement> _selectedElements;
    private EventHandler _layoutUpdatedHandler;
    private Nullable`1<InkCanvasSelectionHitResult> _activeSelectionHitResult;
    internal StrokeCollection SelectedStrokes { get; }
    internal ReadOnlyCollection`1<UIElement> SelectedElements { get; }
    internal bool HasSelection { get; }
    internal Rect SelectionBounds { get; }
    private IEnumerable`1<Rect> SelectedElementsBoundsEnumerator { get; }
    internal InkCanvasSelection(InkCanvas inkCanvas);
    internal StrokeCollection get_SelectedStrokes();
    internal ReadOnlyCollection`1<UIElement> get_SelectedElements();
    internal bool get_HasSelection();
    internal Rect get_SelectionBounds();
    internal void StartFeedbackAdorner(Rect feedbackRect, InkCanvasSelectionHitResult activeSelectionHitResult);
    internal void UpdateFeedbackAdorner(Rect feedbackRect);
    internal void EndFeedbackAdorner(Rect finalRectangle);
    internal void Select(StrokeCollection strokes, IList`1<UIElement> elements, bool raiseSelectionChanged);
    internal void CommitChanges(Rect finalRectangle, bool raiseEvent);
    internal void RemoveElement(UIElement removedElement);
    internal void UpdateElementBounds(UIElement element, Matrix transform);
    internal void UpdateElementBounds(UIElement originalElement, UIElement updatedElement, Matrix transform);
    internal void TransformStrokes(StrokeCollection strokes, Matrix matrix);
    internal InkCanvasSelectionHitResult HitTestSelection(Point pointOnInkCanvas);
    internal void SelectionIsDifferentThanCurrent(StrokeCollection strokes, Boolean& strokesAreDifferent, IList`1<UIElement> elements, Boolean& elementsAreDifferent);
    private bool HasHitSingleSelectedElement(Point pointOnInnerCanvas);
    private void QuitListeningToStrokeChanges();
    private void ListenToStrokeChanges();
    private void CommitMoveChange(Rect finalRectangle);
    private void CommitResizeChange(Rect finalRectangle);
    private void MoveSelection(Rect previousRect, Rect newRect);
    private void OnCanvasLayoutUpdated(object sender, EventArgs e);
    private void OnStrokeInvalidated(object sender, EventArgs e);
    private void OnStrokeCollectionChanged(object target, StrokeCollectionChangedEventArgs e);
    private Rect GetStrokesBounds();
    private List`1<Rect> GetElementsBounds();
    private Rect GetElementsUnionBounds();
    private void UpdateSelectionAdorner();
    private void EnusreElementsBounds();
    private static Matrix MapRectToRect(Rect target, Rect source);
    private void UpdateCanvasLayoutUpdatedHandler();
    private static bool StrokesAreEqual(StrokeCollection strokes1, StrokeCollection strokes2);
    private static bool FrameworkElementArraysAreEqual(IList`1<UIElement> elements1, IList`1<UIElement> elements2);
    [IteratorStateMachineAttribute("MS.Internal.Ink.InkCanvasSelection/<get_SelectedElementsBoundsEnumerator>d__39")]
private IEnumerable`1<Rect> get_SelectedElementsBoundsEnumerator();
}
internal class MS.Internal.Ink.InkCollectionBehavior : StylusEditingBehavior {
    private bool _resetDynamicRenderer;
    private StylusPointCollection _stylusPoints;
    private bool _userInitiated;
    private DrawingAttributes _strokeDrawingAttributes;
    private DrawingAttributes _cursorDrawingAttributes;
    private Cursor _cachedPenCursor;
    private Cursor PenCursor { get; }
    internal InkCollectionBehavior(EditingCoordinator editingCoordinator, InkCanvas inkCanvas);
    internal void ResetDynamicRenderer();
    protected virtual void OnSwitchToMode(InkCanvasEditingMode mode);
    protected virtual void OnActivate();
    protected virtual void OnDeactivate();
    protected virtual Cursor GetCurrentCursor();
    protected virtual void StylusInputBegin(StylusPointCollection stylusPoints, bool userInitiated);
    protected virtual void StylusInputContinue(StylusPointCollection stylusPoints, bool userInitiated);
    protected virtual void StylusInputEnd(bool commit);
    protected virtual void OnTransformChanged();
    private Cursor get_PenCursor();
}
internal class MS.Internal.Ink.ISFClipboardData : ClipboardData {
    private StrokeCollection _strokes;
    internal StrokeCollection Strokes { get; }
    internal ISFClipboardData(StrokeCollection strokes);
    internal virtual bool CanPaste(IDataObject dataObject);
    protected virtual bool CanCopy();
    protected virtual void DoCopy(IDataObject dataObject);
    protected virtual void DoPaste(IDataObject dataObject);
    internal StrokeCollection get_Strokes();
}
internal interface MS.Internal.Ink.IStylusEditing {
    public abstract virtual void AddStylusPoints(StylusPointCollection stylusPoints, bool userInitiated);
}
internal class MS.Internal.Ink.LassoHelper : object {
    private DrawingVisual _containerVisual;
    private Brush _brush;
    private Pen _pen;
    private bool _isActivated;
    private Point _firstLassoPoint;
    private Point _lastLassoPoint;
    private int _count;
    private List`1<Point> _lasso;
    private Rect _boundingBox;
    public static double MinDistanceSquared;
    private static double DotRadius;
    private static double DotCircumferenceThickness;
    private static double ConnectLineThickness;
    private static double ConnectLineOpacity;
    private static Color DotColor;
    private static Color DotCircumferenceColor;
    public Visual Visual { get; }
    private static LassoHelper();
    public Visual get_Visual();
    public Point[] AddPoints(List`1<Point> points);
    private void AddLassoPoint(Point lassoPoint);
    public bool ArePointsInLasso(Point[] points, int percentIntersect);
    private bool Contains(Point point);
    private void EnsureVisual();
    private void EnsureReady();
}
internal class MS.Internal.Ink.LassoSelectionBehavior : StylusEditingBehavior {
    private Point _startPoint;
    private bool _disableLasso;
    private LassoHelper _lassoHelper;
    private IncrementalLassoHitTester _incrementalLassoHitTester;
    private double _xDiff;
    private double _yDiff;
    private static double _maxThreshold;
    private static double _minThreshold;
    private static int _percentIntersectForInk;
    private static int _percentIntersectForElements;
    internal LassoSelectionBehavior(EditingCoordinator editingCoordinator, InkCanvas inkCanvas);
    protected virtual void OnSwitchToMode(InkCanvasEditingMode mode);
    protected virtual void StylusInputBegin(StylusPointCollection stylusPoints, bool userInitiated);
    protected virtual void StylusInputContinue(StylusPointCollection stylusPoints, bool userInitiated);
    protected virtual void StylusInputEnd(bool commit);
    protected virtual void OnCommitWithoutStylusInput(bool commit);
    protected virtual Cursor GetCurrentCursor();
    private void OnSelectionChanged(object sender, LassoSelectionChangedEventArgs e);
    private List`1<UIElement> HitTestForElements();
    private void HitTestElement(InkCanvasInnerCanvas parent, UIElement uiElement, List`1<UIElement> elementsToSelect);
    private static ElementCornerPoints GetTransformedElementCornerPoints(InkCanvasInnerCanvas canvas, UIElement childElement);
    private Point[] GeneratePointGrid(ElementCornerPoints elementPoints);
    private void FillInPoints(ArrayList pointArray, Point point1, Point point2);
    private void FillInGrid(ArrayList pointArray, Point upperLeft, Point upperRight, Point lowerRight, Point lowerLeft);
    private static Point GeneratePointBetweenPoints(Point point1, Point point2);
    private bool PointsAreCloseEnough(Point point1, Point point2);
    private void UpdatePointDistances(ElementCornerPoints elementPoints);
    private void StartLasso(List`1<Point> points);
    private void TapSelectObject(Point point, Stroke& tappedStroke, UIElement& tappedElement);
}
internal static class MS.Internal.Ink.PenCursorManager : object {
    private static Cursor s_StrokeEraserCursor;
    internal static Cursor GetPenCursor(DrawingAttributes drawingAttributes, bool isHollow, bool isRightToLeft, double dpiScaleX, double dpiScaleY);
    internal static Cursor GetPointEraserCursor(StylusShape stylusShape, Matrix tranform, double dpiScaleX, double dpiScaleY);
    internal static Cursor GetStrokeEraserCursor();
    internal static Cursor GetSelectionCursor(InkCanvasSelectionHitResult hitResult, bool isRightToLeft);
    private static Cursor CreateCursorFromDrawing(Drawing drawing, Point hotspot);
    private static DrawingVisual CreateCursorDrawingVisual(Drawing drawing, int width, int height);
    private static RenderTargetBitmap RenderVisualToBitmap(Visual visual, int width, int height);
    private static Byte[] GetPixels(RenderTargetBitmap rtb, int width, int height);
    private static Drawing CreatePenDrawing(DrawingAttributes drawingAttributes, bool isHollow, bool isRightToLeft, double dpiScaleX, double dpiScaleY);
    private static Drawing CreateStrokeEraserDrawing();
    private static double ConvertToPixel(double value, double dpiScale);
}
internal class MS.Internal.Ink.SelectionEditingBehavior : EditingBehavior {
    private static double MinimumHeightWidthSize;
    private Point _previousLocation;
    private Rect _previousRect;
    private Rect _selectionRect;
    private InkCanvasSelectionHitResult _hitResult;
    private bool _actionStarted;
    internal SelectionEditingBehavior(EditingCoordinator editingCoordinator, InkCanvas inkCanvas);
    protected virtual void OnActivate();
    protected virtual void OnDeactivate();
    protected virtual void OnCommit(bool commit);
    protected virtual Cursor GetCurrentCursor();
    private void OnMouseMove(object sender, MouseEventArgs args);
    private void OnMouseUp(object sender, MouseButtonEventArgs args);
    private void OnLostMouseCapture(object sender, MouseEventArgs args);
    private Rect ChangeFeedbackRectangle(Point newPoint);
    private Rect CalculateRect(double x, double y);
    private static Rect ExtendSelectionLeft(Rect rect, double extendBy);
    private static Rect ExtendSelectionTop(Rect rect, double extendBy);
    private static Rect ExtendSelectionRight(Rect rect, double extendBy);
    private static Rect ExtendSelectionBottom(Rect rect, double extendBy);
    private void InitializeCapture();
    private void ReleaseCapture(bool releaseDevice, bool commit);
}
internal class MS.Internal.Ink.SelectionEditor : EditingBehavior {
    private InkCanvasSelectionHitResult _hitResult;
    internal SelectionEditor(EditingCoordinator editingCoordinator, InkCanvas inkCanvas);
    internal void OnInkCanvasSelectionChanged();
    protected virtual void OnActivate();
    protected virtual void OnDeactivate();
    protected virtual void OnCommit(bool commit);
    protected virtual Cursor GetCurrentCursor();
    private void OnAdornerMouseButtonDownEvent(object sender, MouseButtonEventArgs args);
    private void OnAdornerMouseMoveEvent(object sender, MouseEventArgs args);
    private void OnAdornerMouseLeaveEvent(object sender, MouseEventArgs args);
    private InkCanvasSelectionHitResult HitTestOnSelectionAdorner(Point position);
    private void UpdateSelectionCursor(Point hitPoint);
}
internal class MS.Internal.Ink.StrokeCollectionDefaultValueFactory : DefaultValueFactory {
    internal object DefaultValue { get; }
    internal virtual object get_DefaultValue();
    internal virtual object CreateDefaultValue(DependencyObject owner, DependencyProperty property);
}
internal abstract class MS.Internal.Ink.StylusEditingBehavior : EditingBehavior {
    private bool _disableInput;
    internal StylusEditingBehavior(EditingCoordinator editingCoordinator, InkCanvas inkCanvas);
    internal void SwitchToMode(InkCanvasEditingMode mode);
    private sealed virtual override void MS.Internal.Ink.IStylusEditing.AddStylusPoints(StylusPointCollection stylusPoints, bool userInitiated);
    protected abstract virtual void OnSwitchToMode(InkCanvasEditingMode mode);
    protected virtual void OnActivate();
    protected virtual void OnDeactivate();
    protected sealed virtual void OnCommit(bool commit);
    protected virtual void StylusInputBegin(StylusPointCollection stylusPoints, bool userInitiated);
    protected virtual void StylusInputContinue(StylusPointCollection stylusPoints, bool userInitiated);
    protected virtual void StylusInputEnd(bool commit);
    protected virtual void OnCommitWithoutStylusInput(bool commit);
}
internal class MS.Internal.Ink.TextClipboardData : ElementsClipboardData {
    private string _text;
    internal TextClipboardData(string text);
    internal virtual bool CanPaste(IDataObject dataObject);
    protected virtual bool CanCopy();
    protected virtual void DoCopy(IDataObject dataObject);
    protected virtual void DoPaste(IDataObject dataObject);
}
internal class MS.Internal.Ink.XamlClipboardData : ElementsClipboardData {
    internal XamlClipboardData(UIElement[] elements);
    internal virtual bool CanPaste(IDataObject dataObject);
    protected virtual bool CanCopy();
    protected virtual void DoCopy(IDataObject dataObject);
    protected virtual void DoPaste(IDataObject dataObject);
}
internal enum MS.Internal.Interop.CHUNK_BREAKTYPE : Enum {
    public int value__;
    public static CHUNK_BREAKTYPE CHUNK_NO_BREAK;
    public static CHUNK_BREAKTYPE CHUNK_EOW;
    public static CHUNK_BREAKTYPE CHUNK_EOS;
    public static CHUNK_BREAKTYPE CHUNK_EOP;
    public static CHUNK_BREAKTYPE CHUNK_EOC;
}
[FlagsAttribute]
internal enum MS.Internal.Interop.CHUNKSTATE : Enum {
    public int value__;
    public static CHUNKSTATE CHUNK_TEXT;
    public static CHUNKSTATE CHUNK_VALUE;
    public static CHUNKSTATE CHUNK_FILTER_OWNED_VALUE;
}
internal enum MS.Internal.Interop.FilterErrorCode : Enum {
    public int value__;
    public static FilterErrorCode FILTER_E_END_OF_CHUNKS;
    public static FilterErrorCode FILTER_E_NO_MORE_TEXT;
    public static FilterErrorCode FILTER_E_NO_MORE_VALUES;
    public static FilterErrorCode FILTER_E_ACCESS;
    public static FilterErrorCode FILTER_W_MONIKER_CLIPPED;
    public static FilterErrorCode FILTER_E_NO_TEXT;
    public static FilterErrorCode FILTER_E_NO_VALUES;
    public static FilterErrorCode FILTER_E_EMBEDDING_UNAVAILABLE;
    public static FilterErrorCode FILTER_E_LINK_UNAVAILABLE;
    public static FilterErrorCode FILTER_S_LAST_TEXT;
    public static FilterErrorCode FILTER_S_LAST_VALUES;
    public static FilterErrorCode FILTER_E_PASSWORD;
    public static FilterErrorCode FILTER_E_UNKNOWNFORMAT;
}
internal class MS.Internal.Interop.FILTERREGION : ValueType {
    private UInt32 idChunk;
    private UInt32 cwcStart;
    private UInt32 cwcExtent;
}
internal class MS.Internal.Interop.FULLPROPSPEC : ValueType {
    internal Guid guid;
    internal PROPSPEC property;
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("89BCB740-6119-101A-BCB7-00DD010655AF")]
[ComVisibleAttribute("True")]
internal interface MS.Internal.Interop.IFilter {
    public abstract virtual IFILTER_FLAGS Init(IFILTER_INIT grfFlags, UInt32 cAttributes, FULLPROPSPEC[] aAttributes);
    public abstract virtual STAT_CHUNK GetChunk();
    public abstract virtual void GetText(UInt32& pcwcBuffer, IntPtr pBuffer);
    public abstract virtual IntPtr GetValue();
    public abstract virtual IntPtr BindRegion(FILTERREGION origPos, Guid& riid);
}
[FlagsAttribute]
internal enum MS.Internal.Interop.IFILTER_FLAGS : Enum {
    public int value__;
    public static IFILTER_FLAGS IFILTER_FLAGS_NONE;
    public static IFILTER_FLAGS IFILTER_FLAGS_OLE_PROPERTIES;
}
[FlagsAttribute]
internal enum MS.Internal.Interop.IFILTER_INIT : Enum {
    public int value__;
    public static IFILTER_INIT IFILTER_INIT_CANON_PARAGRAPHS;
    public static IFILTER_INIT IFILTER_INIT_HARD_LINE_BREAKS;
    public static IFILTER_INIT IFILTER_INIT_CANON_HYPHENS;
    public static IFILTER_INIT IFILTER_INIT_CANON_SPACES;
    public static IFILTER_INIT IFILTER_INIT_APPLY_INDEX_ATTRIBUTES;
    public static IFILTER_INIT IFILTER_INIT_APPLY_OTHER_ATTRIBUTES;
    public static IFILTER_INIT IFILTER_INIT_INDEXING_ONLY;
    public static IFILTER_INIT IFILTER_INIT_SEARCH_LINKS;
    public static IFILTER_INIT IFILTER_INIT_APPLY_CRAWL_ATTRIBUTES;
    public static IFILTER_INIT IFILTER_INIT_FILTER_OWNED_VALUE_OK;
}
internal abstract class MS.Internal.Interop.InternalDispatchObject`1 : object {
    private Dictionary`2<int, MethodInfo> _dispId2MethodMap;
    private Type System.Reflection.IReflect.UnderlyingSystemType { get; }
    private sealed virtual override FieldInfo System.Reflection.IReflect.GetField(string name, BindingFlags bindingAttr);
    private sealed virtual override FieldInfo[] System.Reflection.IReflect.GetFields(BindingFlags bindingAttr);
    private sealed virtual override MemberInfo[] System.Reflection.IReflect.GetMember(string name, BindingFlags bindingAttr);
    private sealed virtual override MemberInfo[] System.Reflection.IReflect.GetMembers(BindingFlags bindingAttr);
    private sealed virtual override MethodInfo System.Reflection.IReflect.GetMethod(string name, BindingFlags bindingAttr);
    private sealed virtual override MethodInfo System.Reflection.IReflect.GetMethod(string name, BindingFlags bindingAttr, Binder binder, Type[] types, ParameterModifier[] modifiers);
    private sealed virtual override MethodInfo[] System.Reflection.IReflect.GetMethods(BindingFlags bindingAttr);
    private sealed virtual override PropertyInfo[] System.Reflection.IReflect.GetProperties(BindingFlags bindingAttr);
    private sealed virtual override PropertyInfo System.Reflection.IReflect.GetProperty(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers);
    private sealed virtual override PropertyInfo System.Reflection.IReflect.GetProperty(string name, BindingFlags bindingAttr);
    private sealed virtual override object System.Reflection.IReflect.InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, Object[] args, ParameterModifier[] modifiers, CultureInfo culture, String[] namedParameters);
    private sealed virtual override Type System.Reflection.IReflect.get_UnderlyingSystemType();
}
[ComVisibleAttribute("True")]
[GuidAttribute("0000010b-0000-0000-C000-000000000046")]
[InterfaceTypeAttribute("1")]
internal interface MS.Internal.Interop.IPersistFile {
    public abstract virtual void GetClassID(Guid& pClassID);
    public abstract virtual int IsDirty();
    public abstract virtual void Load(string pszFileName, int dwMode);
    public abstract virtual void Save(string pszFileName, bool fRemember);
    public abstract virtual void SaveCompleted(string pszFileName);
    public abstract virtual int GetCurFile(String& ppszFileName);
}
[ComVisibleAttribute("True")]
[GuidAttribute("00000109-0000-0000-C000-000000000046")]
[InterfaceTypeAttribute("1")]
internal interface MS.Internal.Interop.IPersistStream {
    public abstract virtual void GetClassID(Guid& pClassID);
    public abstract virtual int IsDirty();
    public abstract virtual void Load(IStream pstm);
    public abstract virtual void Save(IStream pstm, bool fRemember);
    public abstract virtual void GetSizeMax(Int64& pcbSize);
}
[GuidAttribute("00000109-0000-0000-C000-000000000046")]
[ComVisibleAttribute("True")]
[InterfaceTypeAttribute("1")]
internal interface MS.Internal.Interop.IPersistStreamWithArrays {
    public abstract virtual void GetClassID(Guid& pClassID);
    public abstract virtual int IsDirty();
    public abstract virtual void Load(IStream pstm);
    public abstract virtual void Save(IStream pstm, bool fRemember);
    public abstract virtual void GetSizeMax(Int64& pcbSize);
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("0000000C-0000-0000-C000-000000000046")]
[ComVisibleAttribute("True")]
internal interface MS.Internal.Interop.IStream {
    public abstract virtual void Read(IntPtr bufferBase, int sizeInBytes, IntPtr refToNumBytesRead);
    public abstract virtual void Write(IntPtr bufferBase, int sizeInBytes, IntPtr refToNumBytesWritten);
    public abstract virtual void Seek(long offset, int origin, IntPtr refToNewOffsetNullAllowed);
    public abstract virtual void SetSize(long newSize);
    public abstract virtual void CopyTo(IStream targetStream, long bytesToCopy, IntPtr refToNumBytesRead, IntPtr refToNumBytesWritten);
    public abstract virtual void Commit(int commitFlags);
    public abstract virtual void Revert();
    public abstract virtual void LockRegion(long offset, long sizeInBytes, int lockType);
    public abstract virtual void UnlockRegion(long offset, long sizeInBytes, int lockType);
    public abstract virtual void Stat(STATSTG& statStructure, int statFlag);
    public abstract virtual void Clone(IStream& newStream);
}
internal enum MS.Internal.Interop.PID_STG : Enum {
    public int value__;
    public static PID_STG DIRECTORY;
    public static PID_STG CLASSID;
    public static PID_STG STORAGETYPE;
    public static PID_STG VOLUME_ID;
    public static PID_STG PARENT_WORKID;
    public static PID_STG SECONDARYSTORE;
    public static PID_STG FILEINDEX;
    public static PID_STG LASTCHANGEUSN;
    public static PID_STG NAME;
    public static PID_STG PATH;
    public static PID_STG SIZE;
    public static PID_STG ATTRIBUTES;
    public static PID_STG WRITETIME;
    public static PID_STG CREATETIME;
    public static PID_STG ACCESSTIME;
    public static PID_STG CHANGETIME;
    public static PID_STG ALLOCSIZE;
    public static PID_STG CONTENTS;
    public static PID_STG SHORTNAME;
}
internal class MS.Internal.Interop.STAT_CHUNK : ValueType {
    internal UInt32 idChunk;
    internal CHUNK_BREAKTYPE breakType;
    internal CHUNKSTATE flags;
    internal UInt32 locale;
    internal FULLPROPSPEC attribute;
    internal UInt32 idChunkSource;
    internal UInt32 cwcStartSource;
    internal UInt32 cwcLenSource;
}
[FlagsAttribute]
internal enum MS.Internal.Interop.STGM_FLAGS : Enum {
    public int value__;
    public static STGM_FLAGS CREATE;
    public static STGM_FLAGS MODE;
    public static STGM_FLAGS READ;
    public static STGM_FLAGS WRITE;
    public static STGM_FLAGS READWRITE;
    public static STGM_FLAGS ACCESS;
    public static STGM_FLAGS SHARE_DENY_NONE;
    public static STGM_FLAGS SHARE_DENY_READ;
    public static STGM_FLAGS SHARE_DENY_WRITE;
    public static STGM_FLAGS SHARE_EXCLUSIVE;
    public static STGM_FLAGS SHARING;
}
internal class MS.Internal.IO.Packaging.ByteStream : Stream {
    private SecurityCriticalDataForSet`1<SecuritySuppressedIStream> _securitySuppressedIStream;
    private FileAccess _access;
    private long _length;
    private bool _isLengthInitialized;
    private bool _disposed;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    private bool StreamDisposed { get; }
    internal ByteStream(object underlyingStream, FileAccess openAccess);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Flush();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long newLength);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void Close();
    internal void CheckDisposedStatus();
    private bool get_StreamDisposed();
}
internal class MS.Internal.IO.Packaging.ContentDescriptor : object {
    internal static string ResourceKeyName;
    internal static string ResourceName;
    private bool _hasIndexableContent;
    private bool _isInline;
    private string _contentProp;
    private string _titleProp;
    internal bool HasIndexableContent { get; internal set; }
    internal bool IsInline { get; internal set; }
    internal string ContentProp { get; internal set; }
    internal string TitleProp { get; internal set; }
    internal ContentDescriptor(bool hasIndexableContent, bool isInline, string contentProp, string titleProp);
    internal ContentDescriptor(bool hasIndexableContent);
    internal bool get_HasIndexableContent();
    internal void set_HasIndexableContent(bool value);
    internal bool get_IsInline();
    internal void set_IsInline(bool value);
    internal string get_ContentProp();
    internal void set_ContentProp(string value);
    internal string get_TitleProp();
    internal void set_TitleProp(string value);
}
internal class MS.Internal.IO.Packaging.CorePropertiesFilter : object {
    private IFILTER_INIT _grfFlags;
    private ManagedFullPropSpec[] _aAttributes;
    private UInt32 _chunkID;
    private bool _pendingGetValue;
    private CorePropertyEnumerator _corePropertyEnumerator;
    private PackageProperties _coreProperties;
    private CorePropertyEnumerator CorePropertyEnumerator { get; }
    internal CorePropertiesFilter(PackageProperties coreProperties);
    public sealed virtual IFILTER_FLAGS Init(IFILTER_INIT grfFlags, ManagedFullPropSpec[] aAttributes);
    public sealed virtual ManagedChunk GetChunk();
    public sealed virtual string GetText(int bufferCharacterCount);
    public sealed virtual object GetValue();
    private UInt32 AllocateChunkID();
    private CorePropertyEnumerator get_CorePropertyEnumerator();
}
internal class MS.Internal.IO.Packaging.CorePropertyEnumerator : object {
    private PackageProperties _coreProperties;
    private ManagedFullPropSpec[] _attributes;
    private int _currentIndex;
    internal Guid CurrentGuid { get; }
    internal UInt32 CurrentPropId { get; }
    internal object CurrentValue { get; }
    internal CorePropertyEnumerator(PackageProperties coreProperties, IFILTER_INIT grfFlags, ManagedFullPropSpec[] attributes);
    internal bool MoveNext();
    internal Guid get_CurrentGuid();
    internal UInt32 get_CurrentPropId();
    internal object get_CurrentValue();
    private void ValidateCurrent();
    private object GetValue(Guid guid, UInt32 propId);
}
internal class MS.Internal.IO.Packaging.ElementTableKey : object {
    private string _baseName;
    private string _xmlNamespace;
    public static string XamlNamespace;
    public static string FixedMarkupNamespace;
    internal string XmlNamespace { get; }
    internal string BaseName { get; }
    internal ElementTableKey(string xmlNamespace, string baseName);
    private static ElementTableKey();
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
    internal string get_XmlNamespace();
    internal string get_BaseName();
}
internal class MS.Internal.IO.Packaging.EncryptedPackageFilter : object {
    private IFilter _filter;
    internal EncryptedPackageFilter(EncryptedPackageEnvelope encryptedPackage);
    public sealed virtual IFILTER_FLAGS Init(IFILTER_INIT grfFlags, UInt32 cAttributes, FULLPROPSPEC[] aAttributes);
    public sealed virtual STAT_CHUNK GetChunk();
    public sealed virtual void GetText(UInt32& bufCharacterCount, IntPtr pBuffer);
    public sealed virtual IntPtr GetValue();
    public sealed virtual IntPtr BindRegion(FILTERREGION origPos, Guid& riid);
}
internal class MS.Internal.IO.Packaging.FixedPageContentExtractor : object {
    private XmlFixedPageInfo _fixedPageInfo;
    private int _nextGlyphRun;
    internal bool AtEndOfPage { get; }
    internal FixedPageContentExtractor(XmlNode fixedPage);
    internal string NextGlyphContent(Boolean& inline, UInt32& lcid);
    internal bool get_AtEndOfPage();
}
internal interface MS.Internal.IO.Packaging.IManagedFilter {
    public abstract virtual IFILTER_FLAGS Init(IFILTER_INIT grfFlags, ManagedFullPropSpec[] aAttributes);
    public abstract virtual ManagedChunk GetChunk();
    public abstract virtual string GetText(int bufferCharacterCount);
    public abstract virtual object GetValue();
}
internal class MS.Internal.IO.Packaging.IndexingContentUnit : ManagedChunk {
    private string _contents;
    internal string Text { get; }
    internal IndexingContentUnit(string contents, UInt32 chunkID, CHUNK_BREAKTYPE breakType, ManagedFullPropSpec attribute, UInt32 lcid);
    internal void InitIndexingContentUnit(string contents, UInt32 chunkID, CHUNK_BREAKTYPE breakType, ManagedFullPropSpec attribute, UInt32 lcid);
    internal string get_Text();
}
internal class MS.Internal.IO.Packaging.IndexingFilterMarshaler : object {
    internal static Guid PSGUID_STORAGE;
    internal static int _int16Size;
    private IManagedFilter _implementation;
    private bool _throwOnEndOfChunks;
    internal bool ThrowOnEndOfChunks { get; internal set; }
    internal IndexingFilterMarshaler(IManagedFilter managedFilter);
    private static IndexingFilterMarshaler();
    internal static ManagedFullPropSpec[] MarshalFullPropSpecArray(UInt32 cAttributes, FULLPROPSPEC[] aAttributes);
    internal static void MarshalStringToPtr(string s, UInt32& bufCharacterCount, IntPtr p);
    internal static void MarshalPropSpec(ManagedPropSpec propSpec, PROPSPEC& native);
    internal static void MarshalFullPropSpec(ManagedFullPropSpec fullPropSpec, FULLPROPSPEC& native);
    internal static STAT_CHUNK MarshalChunk(ManagedChunk chunk);
    internal static IntPtr MarshalPropVariant(object obj);
    public sealed virtual IFILTER_FLAGS Init(IFILTER_INIT grfFlags, UInt32 cAttributes, FULLPROPSPEC[] aAttributes);
    public sealed virtual STAT_CHUNK GetChunk();
    public sealed virtual void GetText(UInt32& bufCharacterCount, IntPtr pBuffer);
    public sealed virtual IntPtr GetValue();
    public sealed virtual IntPtr BindRegion(FILTERREGION origPos, Guid& riid);
    internal bool get_ThrowOnEndOfChunks();
    internal void set_ThrowOnEndOfChunks(bool value);
}
internal class MS.Internal.IO.Packaging.ManagedChunk : object {
    private UInt32 _index;
    private CHUNK_BREAKTYPE _breakType;
    private CHUNKSTATE _flags;
    private UInt32 _lcid;
    private ManagedFullPropSpec _attribute;
    private UInt32 _idChunkSource;
    private UInt32 _startSource;
    private UInt32 _lenSource;
    internal UInt32 ID { get; internal set; }
    internal CHUNKSTATE Flags { get; }
    internal CHUNK_BREAKTYPE BreakType { get; internal set; }
    internal UInt32 Locale { get; internal set; }
    internal UInt32 ChunkSource { get; }
    internal UInt32 StartSource { get; }
    internal UInt32 LenSource { get; }
    internal ManagedFullPropSpec Attribute { get; internal set; }
    internal ManagedChunk(UInt32 index, CHUNK_BREAKTYPE breakType, ManagedFullPropSpec attribute, UInt32 lcid, CHUNKSTATE flags);
    internal UInt32 get_ID();
    internal void set_ID(UInt32 value);
    internal CHUNKSTATE get_Flags();
    internal CHUNK_BREAKTYPE get_BreakType();
    internal void set_BreakType(CHUNK_BREAKTYPE value);
    internal UInt32 get_Locale();
    internal void set_Locale(UInt32 value);
    internal UInt32 get_ChunkSource();
    internal UInt32 get_StartSource();
    internal UInt32 get_LenSource();
    internal ManagedFullPropSpec get_Attribute();
    internal void set_Attribute(ManagedFullPropSpec value);
}
internal class MS.Internal.IO.Packaging.ManagedFullPropSpec : object {
    private Guid _guid;
    private ManagedPropSpec _property;
    internal Guid Guid { get; }
    internal ManagedPropSpec Property { get; }
    internal ManagedFullPropSpec(Guid guid, UInt32 propId);
    internal ManagedFullPropSpec(FULLPROPSPEC nativePropSpec);
    internal Guid get_Guid();
    internal ManagedPropSpec get_Property();
}
internal class MS.Internal.IO.Packaging.ManagedIStream : object {
    private Stream _ioStream;
    internal ManagedIStream(Stream ioStream);
    private sealed virtual override void System.Runtime.InteropServices.ComTypes.IStream.Read(Byte[] buffer, int bufferSize, IntPtr bytesReadPtr);
    private sealed virtual override void System.Runtime.InteropServices.ComTypes.IStream.Seek(long offset, int origin, IntPtr newPositionPtr);
    private sealed virtual override void System.Runtime.InteropServices.ComTypes.IStream.SetSize(long libNewSize);
    private sealed virtual override void System.Runtime.InteropServices.ComTypes.IStream.Stat(STATSTG& streamStats, int grfStatFlag);
    private sealed virtual override void System.Runtime.InteropServices.ComTypes.IStream.Write(Byte[] buffer, int bufferSize, IntPtr bytesWrittenPtr);
    private sealed virtual override void System.Runtime.InteropServices.ComTypes.IStream.Clone(IStream& streamCopy);
    private sealed virtual override void System.Runtime.InteropServices.ComTypes.IStream.CopyTo(IStream targetStream, long bufferSize, IntPtr buffer, IntPtr bytesWrittenPtr);
    private sealed virtual override void System.Runtime.InteropServices.ComTypes.IStream.Commit(int flags);
    private sealed virtual override void System.Runtime.InteropServices.ComTypes.IStream.LockRegion(long offset, long byteCount, int lockType);
    private sealed virtual override void System.Runtime.InteropServices.ComTypes.IStream.Revert();
    private sealed virtual override void System.Runtime.InteropServices.ComTypes.IStream.UnlockRegion(long offset, long byteCount, int lockType);
}
internal class MS.Internal.IO.Packaging.ManagedPropSpec : object {
    private PropSpecType _propType;
    private UInt32 _id;
    private string _name;
    internal PropSpecType PropType { get; }
    internal string PropName { get; internal set; }
    internal UInt32 PropId { get; internal set; }
    internal ManagedPropSpec(UInt32 id);
    internal ManagedPropSpec(PROPSPEC propSpec);
    internal PropSpecType get_PropType();
    internal string get_PropName();
    internal void set_PropName(string value);
    internal UInt32 get_PropId();
    internal void set_PropId(UInt32 value);
}
internal class MS.Internal.IO.Packaging.PackageFilter : object {
    private String[] _IFilterAddinPath;
    private String[] _mimeContentTypeKey;
    private String[] _persistentHandlerKey;
    private Package _package;
    private UInt32 _currentChunkID;
    private IEnumerator _partIterator;
    private IFilter _currentFilter;
    private Stream _currentStream;
    private bool _firstChunkFromFilter;
    private Progress _progress;
    private bool _isInternalFilter;
    private IFILTER_INIT _grfFlags;
    private UInt32 _cAttributes;
    private FULLPROPSPEC[] _aAttributes;
    private static string _extension;
    internal PackageFilter(Package package);
    public sealed virtual IFILTER_FLAGS Init(IFILTER_INIT grfFlags, UInt32 cAttributes, FULLPROPSPEC[] aAttributes);
    public sealed virtual STAT_CHUNK GetChunk();
    public sealed virtual void GetText(UInt32& bufferCharacterCount, IntPtr pBuffer);
    public sealed virtual IntPtr GetValue();
    public sealed virtual IntPtr BindRegion(FILTERREGION origPos, Guid& riid);
    private IFilter GetFilterFromClsid(Guid clsid);
    private void MoveToNextFilter();
    private UInt32 AllocateChunkID();
    private string GetFilterClsid(ContentType contentType, Uri partUri);
    private static RegistryKey FindSubkey(RegistryKey containingKey, String[] keyPath);
    private string FileTypeGuidFromMimeType(ContentType contentType);
    private string FileTypeGuidFromFileExtension(string dottedExtensionName);
    private string GetPartExtension(Uri partUri);
    private static String[] MakeRegistryPath(String[] pathWithGaps, String[] stopGaps);
}
internal class MS.Internal.IO.Packaging.UnsafeIndexingFilterStream : Stream {
    private IStream _oleStream;
    private bool _disposed;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Position { get; public set; }
    public long Length { get; }
    internal UnsafeIndexingFilterStream(IStream oleStream);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long newLength);
    public virtual void Write(Byte[] buf, int offset, int count);
    public virtual void Flush();
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual long get_Length();
    protected virtual void Dispose(bool disposing);
    private void ThrowIfStreamDisposed();
}
internal class MS.Internal.IO.Packaging.XamlFilter : object {
    private static string _inDocumentCodeURI;
    private static string _pageContentName;
    private static string _glyphRunName;
    private static string _pageContentSourceAttribute;
    private static string _fixedPageName;
    private static string _xmlLangAttribute;
    private static string _paragraphSeparator;
    private static string _unicodeStringAttribute;
    private ContentDescriptor _defaultContentDescriptor;
    private ContentDescriptor _nonIndexableElementDescriptor;
    private static ManagedFullPropSpec _propSpec;
    private Stack _contextStack;
    private FilterState _filterState;
    private string _currentContent;
    private UInt32 _currentChunkID;
    private int _countOfCharactersReturned;
    private IndexingContentUnit _indexingContentUnit;
    private bool _expectingBlockStart;
    private XmlReader _topLevelReader;
    private FixedPageContentExtractor _fixedPageContentExtractor;
    private XmlDocument _fixedPageDomTree;
    private Stream _xamlStream;
    private bool _filterContents;
    private bool _returnCanonicalParagraphBreaks;
    private XmlReader _xamlReader;
    private AttributesToIgnore _attributesToIgnore;
    private Hashtable _xamlElementContentDescriptorDictionary;
    private Dictionary`2<string, UInt32> _lcidDictionary;
    internal XamlFilter(Stream stream);
    private static XamlFilter();
    private void AddPresentationDescriptor(string Key);
    private void AddPresentationDescriptor(string Key, string Value);
    private void InitElementDictionary();
    private void InitializeDeclaredFields();
    public sealed virtual IFILTER_FLAGS Init(IFILTER_INIT grfFlags, ManagedFullPropSpec[] aAttributes);
    public sealed virtual ManagedChunk GetChunk();
    public sealed virtual string GetText(int bufferCharacterCount);
    public sealed virtual object GetValue();
    internal IndexingContentUnit NextContentUnit();
    private void LoadContentDescriptorDictionary();
    private IndexingContentUnit BuildIndexingContentUnit(string text, UInt32 lcid);
    private ContentDescriptor GetContentInformationAboutCustomElement(ElementTableKey customElement);
    private IndexingContentUnit HandleTextData();
    private IndexingContentUnit HandleElementStart();
    private IndexingContentUnit HandleElementEnd();
    private IndexingContentUnit HandleFixedFormatTag(ElementTableKey elementFullName, Boolean& handled);
    private IndexingContentUnit ProcessGlyphRun();
    private IndexingContentUnit ProcessFixedPage();
    private void CreateXmlReader();
    private void EnsureXmlReaderIsClosed();
    private UInt32 GetCurrentLcid();
    private string GetLanguageString();
    private void SkipCurrentElement();
    private bool IsPrefixedPropertyName(string name, String& propertyName);
    private UInt32 AllocateChunkID();
    private string GetPropertyAsAttribute(string propertyName);
    private ContentDescriptor TopOfStack();
    private void Push(ContentDescriptor contentDescriptor);
    private ContentDescriptor Pop();
    private void ClearStack();
}
internal class MS.Internal.IO.Packaging.XmlFixedPageInfo : FixedPageInfo {
    private static string _fixedPageName;
    private static string _glyphRunName;
    private XmlNode _pageNode;
    private XmlNodeList _nodeList;
    private XmlGlyphRunInfo[] _glyphRunList;
    internal int GlyphRunCount { get; }
    private XmlGlyphRunInfo[] GlyphRunList { get; }
    private XmlNodeList NodeList { get; }
    internal XmlFixedPageInfo(XmlNode fixedPageNode);
    internal virtual GlyphRunInfo GlyphRunAtPosition(int position);
    internal virtual int get_GlyphRunCount();
    private XmlGlyphRunInfo[] get_GlyphRunList();
    private XmlNodeList get_NodeList();
}
internal class MS.Internal.IO.Packaging.XmlGlyphRunInfo : GlyphRunInfo {
    private static string _glyphRunName;
    private static string _xmlLangAttribute;
    private static string _unicodeStringAttribute;
    private static string _undeterminedLanguageStringUpper;
    private XmlElement _glyphsNode;
    private string _unicodeString;
    private Nullable`1<UInt32> _languageID;
    internal Point StartPosition { get; }
    internal Point EndPosition { get; }
    internal double WidthEmFontSize { get; }
    internal double HeightEmFontSize { get; }
    internal bool GlyphsHaveSidewaysOrientation { get; }
    internal int BidiLevel { get; }
    internal UInt32 LanguageID { get; }
    internal string UnicodeString { get; }
    internal XmlGlyphRunInfo(XmlNode glyphsNode);
    internal virtual Point get_StartPosition();
    internal virtual Point get_EndPosition();
    internal virtual double get_WidthEmFontSize();
    internal virtual double get_HeightEmFontSize();
    internal virtual bool get_GlyphsHaveSidewaysOrientation();
    internal virtual int get_BidiLevel();
    internal virtual UInt32 get_LanguageID();
    internal virtual string get_UnicodeString();
}
[ComVisibleAttribute("True")]
[GuidAttribute("0B8732A6-AF74-498c-A251-9DC86B0538B0")]
internal class MS.Internal.IO.Packaging.XpsFilter : object {
    [ComVisibleAttribute("False")]
private static Guid _filterClsid;
    [ComVisibleAttribute("False")]
private IFilter _filter;
    [ComVisibleAttribute("False")]
private Package _package;
    [ComVisibleAttribute("False")]
private EncryptedPackageEnvelope _encryptedPackage;
    [ComVisibleAttribute("False")]
private string _xpsFileName;
    [ComVisibleAttribute("False")]
private Stream _packageStream;
    [ComVisibleAttribute("False")]
private static int _int16Size;
    [ComVisibleAttribute("False")]
private static UInt32 _maxTextBufferSizeInCharacters;
    [ComVisibleAttribute("False")]
private static int _maxMemoryStreamBuffer;
    private static XpsFilter();
    private sealed virtual override IFILTER_FLAGS MS.Internal.Interop.IFilter.Init(IFILTER_INIT grfFlags, UInt32 cAttributes, FULLPROPSPEC[] aAttributes);
    private sealed virtual override STAT_CHUNK MS.Internal.Interop.IFilter.GetChunk();
    private sealed virtual override void MS.Internal.Interop.IFilter.GetText(UInt32& bufCharacterCount, IntPtr pBuffer);
    private sealed virtual override IntPtr MS.Internal.Interop.IFilter.GetValue();
    private sealed virtual override IntPtr MS.Internal.Interop.IFilter.BindRegion(FILTERREGION origPos, Guid& riid);
    private sealed virtual override void MS.Internal.Interop.IPersistFile.GetClassID(Guid& pClassID);
    private sealed virtual override int MS.Internal.Interop.IPersistFile.GetCurFile(String& ppszFileName);
    private sealed virtual override int MS.Internal.Interop.IPersistFile.IsDirty();
    private sealed virtual override void MS.Internal.Interop.IPersistFile.Load(string pszFileName, int dwMode);
    private sealed virtual override void MS.Internal.Interop.IPersistFile.Save(string pszFileName, bool fRemember);
    private sealed virtual override void MS.Internal.Interop.IPersistFile.SaveCompleted(string pszFileName);
    private sealed virtual override void MS.Internal.Interop.IPersistStream.GetClassID(Guid& pClassID);
    private sealed virtual override int MS.Internal.Interop.IPersistStream.IsDirty();
    private sealed virtual override void MS.Internal.Interop.IPersistStream.Load(IStream stream);
    private sealed virtual override void MS.Internal.Interop.IPersistStream.Save(IStream stream, bool fClearDirty);
    private sealed virtual override void MS.Internal.Interop.IPersistStream.GetSizeMax(Int64& pcbSize);
    private void ReleaseResources();
    private static Stream FileToStream(string filePath, FileMode fileMode, FileAccess fileAccess, FileShare fileSharing, long maxMemoryStream);
}
[DefaultMemberAttribute("Item")]
internal interface MS.Internal.IWeakHashtable {
    public object Item { get; }
    public ICollection Keys { get; }
    public int Count { get; }
    public abstract virtual object get_Item(object key);
    public abstract virtual ICollection get_Keys();
    public abstract virtual int get_Count();
    public abstract virtual bool ContainsKey(object key);
    public abstract virtual void Remove(object key);
    public abstract virtual void Clear();
    public abstract virtual void SetWeak(object key, object value);
    public abstract virtual object UnwrapKey(object key);
}
internal class MS.Internal.KnownBoxes.SizeBox : object {
    private double _width;
    private double _height;
    internal double Width { get; internal set; }
    internal double Height { get; internal set; }
    internal SizeBox(double width, double height);
    internal SizeBox(Size size);
    internal double get_Width();
    internal void set_Width(double value);
    internal double get_Height();
    internal void set_Height(double value);
}
internal static class MS.Internal.LayoutDump : object {
    private static Hashtable _elementToDumpHandler;
    private static Hashtable _documentPageToDumpHandler;
    private static LayoutDump();
    internal static string DumpLayoutAndVisualTreeToString(string tagName, Visual root);
    internal static void DumpLayoutAndVisualTree(XmlTextWriter writer, string tagName, Visual root);
    internal static void DumpLayoutTreeToFile(string tagName, UIElement root, string fileName);
    internal static string DumpLayoutTreeToString(string tagName, UIElement root);
    internal static void DumpLayoutTree(XmlTextWriter writer, string tagName, UIElement root);
    internal static void AddUIElementDumpHandler(Type type, DumpCustomUIElement dumper);
    internal static void AddDocumentPageDumpHandler(Type type, DumpCustomDocumentPage dumper);
    internal static void DumpVisual(XmlTextWriter writer, Visual visual, Visual parent);
    private static void DumpUIElement(XmlTextWriter writer, UIElement element, Visual parent, bool uiElementsOnly);
    internal static void DumpDocumentPage(XmlTextWriter writer, DocumentPage page, Visual parent);
    private static void DumpVisualChildren(XmlTextWriter writer, string tagName, Visual visualParent);
    internal static void DumpUIElementChildren(XmlTextWriter writer, string tagName, Visual visualParent);
    internal static void DumpPoint(XmlTextWriter writer, string tagName, Point point);
    internal static void DumpSize(XmlTextWriter writer, string tagName, Size size);
    internal static void DumpRect(XmlTextWriter writer, string tagName, Rect rect);
    internal static void GetUIElementsFromVisual(Visual visual, List`1<UIElement> uiElements);
    private static bool DumpDocumentPageView(XmlTextWriter writer, UIElement element, bool uiElementsOnly);
    private static bool DumpText(XmlTextWriter writer, UIElement element, bool uiElementsOnly);
    private static bool DumpFlowDocumentScrollViewer(XmlTextWriter writer, UIElement element, bool uiElementsOnly);
    private static bool DumpFlowDocumentView(XmlTextWriter writer, UIElement element, bool uiElementsOnly);
    private static void DumpFlowDocumentPage(XmlTextWriter writer, DocumentPage page);
    private static void DumpTextRange(XmlTextWriter writer, string content);
    private static void DumpTextRange(XmlTextWriter writer, ITextPointer start, ITextPointer end);
    private static void DumpLineRange(XmlTextWriter writer, int cpStart, int cpEnd, int cpContentEnd, int cpEllipses);
    private static void DumpLineResults(XmlTextWriter writer, ReadOnlyCollection`1<LineResult> lines, Visual visualParent);
    private static void DumpParagraphResults(XmlTextWriter writer, string tagName, ReadOnlyCollection`1<ParagraphResult> paragraphs, Visual visualParent);
    private static void DumpTextParagraphResult(XmlTextWriter writer, TextParagraphResult paragraph, Visual visualParent);
    private static void DumpContainerParagraphResult(XmlTextWriter writer, ContainerParagraphResult paragraph, Visual visualParent);
    private static void DumpFloaterParagraphResult(XmlTextWriter writer, FloaterParagraphResult paragraph, Visual visualParent);
    private static void DumpUIElementParagraphResult(XmlTextWriter writer, UIElementParagraphResult paragraph, Visual visualParent);
    private static void DumpFigureParagraphResult(XmlTextWriter writer, FigureParagraphResult paragraph, Visual visualParent);
    private static void DumpTableParagraphResult(XmlTextWriter writer, TableParagraphResult paragraph, Visual visualParent);
    private static void DumpSubpageParagraphResult(XmlTextWriter writer, SubpageParagraphResult paragraph, Visual visualParent);
    private static void DumpColumnResults(XmlTextWriter writer, ReadOnlyCollection`1<ColumnResult> columns, Visual visualParent);
    private static Visual DumpParagraphOffset(XmlTextWriter writer, ParagraphResult paragraph, Visual visualParent);
    private static void DumpTableCalculatedMetrics(XmlTextWriter writer, object element);
    private static void DumpTableCell(XmlTextWriter writer, ParagraphResult paragraph, Visual cellVisual, Visual tableVisual);
}
internal class MS.Internal.ListOfObject : object {
    private IList _list;
    private object System.Collections.Generic.IList<System.Object>.Item { get; private set; }
    private int System.Collections.Generic.ICollection<System.Object>.Count { get; }
    private bool System.Collections.Generic.ICollection<System.Object>.IsReadOnly { get; }
    internal ListOfObject(IList list);
    private sealed virtual override int System.Collections.Generic.IList<System.Object>.IndexOf(object item);
    private sealed virtual override void System.Collections.Generic.IList<System.Object>.Insert(int index, object item);
    private sealed virtual override void System.Collections.Generic.IList<System.Object>.RemoveAt(int index);
    private sealed virtual override object System.Collections.Generic.IList<System.Object>.get_Item(int index);
    private sealed virtual override void System.Collections.Generic.IList<System.Object>.set_Item(int index, object value);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Object>.Add(object item);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Object>.Clear();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Object>.Contains(object item);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Object>.CopyTo(Object[] array, int arrayIndex);
    private sealed virtual override int System.Collections.Generic.ICollection<System.Object>.get_Count();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Object>.get_IsReadOnly();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Object>.Remove(object item);
    private sealed virtual override IEnumerator`1<object> System.Collections.Generic.IEnumerable<System.Object>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal class MS.Internal.Markup.StaticExtension : StaticExtension {
    public StaticExtension(string member);
    public virtual object ProvideValue(IServiceProvider serviceProvider);
}
internal class MS.Internal.Navigation.BindStream : Stream {
    private long _bytesRead;
    private long _maxBytes;
    private long _lastProgressEventByte;
    private Stream _stream;
    private Uri _uri;
    private IContentContainer _cc;
    private Dispatcher _callbackDispatcher;
    private static long _bytesInterval;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public Stream Stream { get; }
    private Assembly System.Windows.Markup.IStreamInfo.Assembly { get; }
    internal BindStream(Stream stream, long maxBytes, Uri uri, IContentContainer cc, Dispatcher callbackDispatcher);
    private void UpdateNavigationProgress();
    private void UpdateNavProgressHelper(long numBytes);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual void Close();
    public virtual int EndRead(IAsyncResult asyncResult);
    public virtual void EndWrite(IAsyncResult asyncResult);
    public virtual bool Equals(object obj);
    public virtual void Flush();
    public virtual int GetHashCode();
    public virtual object InitializeLifetimeService();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual int ReadByte();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual string ToString();
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void WriteByte(byte value);
    public Stream get_Stream();
    private sealed virtual override Assembly System.Windows.Markup.IStreamInfo.get_Assembly();
    [CompilerGeneratedAttribute]
private object <Close>b__16_0(object unused);
}
internal class MS.Internal.PrePostDescendentsWalker`1 : DescendentsWalker`1<T> {
    private VisitedCallback`1<T> _postCallback;
    public PrePostDescendentsWalker`1(TreeWalkPriority priority, VisitedCallback`1<T> preCallback, VisitedCallback`1<T> postCallback, T data);
    public virtual void StartWalk(DependencyObject startNode, bool skipStartNode);
    protected virtual void _VisitNode(DependencyObject d, bool visitedViaVisualTree);
}
internal static class MS.Internal.PresentationFramework.AnimatedTypeHelpers : object {
    private static double InterpolateDouble(double from, double to, double progress);
    internal static Thickness InterpolateThickness(Thickness from, Thickness to, double progress);
    private static double AddDouble(double value1, double value2);
    internal static Thickness AddThickness(Thickness value1, Thickness value2);
    internal static Thickness SubtractThickness(Thickness value1, Thickness value2);
    private static double GetSegmentLengthDouble(double from, double to);
    internal static double GetSegmentLengthThickness(Thickness from, Thickness to);
    private static double ScaleDouble(double value, double factor);
    internal static Thickness ScaleThickness(Thickness value, double factor);
    private static bool IsValidAnimationValueDouble(double value);
    internal static bool IsValidAnimationValueThickness(Thickness value);
    private static double GetZeroValueDouble(double baseValue);
    internal static Thickness GetZeroValueThickness(Thickness baseValue);
    private static bool IsInvalidDouble(double value);
}
internal static class MS.Internal.PresentationFramework.BuildInfo : object {
    internal static string WCP_VERSION;
    internal static string WCP_VERSION_SUFFIX;
    internal static string MIL_VERSION_SUFFIX;
    internal static string WCP_PUBLIC_KEY_TOKEN;
    internal static string WCP_PUBLIC_KEY_STRING;
    internal static string DEVDIV_PUBLIC_KEY_STRING;
    internal static string DEVDIV_PUBLIC_KEY_TOKEN;
    internal static string DirectWriteForwarder;
    internal static string PresentationCore;
    internal static string PresentationCFFRasterizer;
    internal static string PresentationFramework;
    internal static string PresentationUI;
    internal static string PresentationFrameworkLuna;
    internal static string PresentationFrameworkRoyale;
    internal static string PresentationFrameworkAero;
    internal static string PresentationFrameworkAero2;
    internal static string PresentationFrameworkAeroLite;
    internal static string PresentationFrameworkClassic;
    internal static string PresentationFrameworkSystemCore;
    internal static string PresentationFrameworkSystemData;
    internal static string PresentationFrameworkSystemDrawing;
    internal static string PresentationFrameworkSystemXml;
    internal static string PresentationFrameworkSystemXmlLinq;
    internal static string ReachFramework;
    internal static string SystemPrinting;
    internal static string SystemXaml;
    internal static string WindowsFormsIntegration;
    internal static string SystemWindowsPresentation;
    internal static string SystemWindowsControlsRibbon;
}
[ConditionalAttribute("COMMONDPS")]
[AttributeUsageAttribute("256")]
internal class MS.Internal.PresentationFramework.CommonDependencyPropertyAttribute : Attribute {
}
internal static class MS.Internal.PresentationFramework.DllImport : object {
    internal static string PresentationNative;
    internal static string PresentationCFFRasterizerNative;
    internal static string MilCore;
    internal static string UIAutomationCore;
    internal static string Wininet;
    internal static string WindowsCodecs;
    internal static string WindowsCodecsExt;
    internal static string Mscms;
    internal static string PrntvPt;
    internal static string Ole32;
    internal static string User32;
    internal static string NInput;
}
[AttributeUsageAttribute("5628")]
internal class MS.Internal.PresentationFramework.FriendAccessAllowedAttribute : Attribute {
}
internal enum MS.Internal.PresentationFramework.Interop.OperatingSystemVersion : Enum {
    public int value__;
    public static OperatingSystemVersion WindowsXPSP2;
    public static OperatingSystemVersion WindowsXPSP3;
    public static OperatingSystemVersion WindowsVista;
    public static OperatingSystemVersion WindowsVistaSP1;
    public static OperatingSystemVersion WindowsVistaSP2;
    public static OperatingSystemVersion Windows7;
    public static OperatingSystemVersion Windows7SP1;
    public static OperatingSystemVersion Windows8;
    public static OperatingSystemVersion Windows8Point1;
    public static OperatingSystemVersion Windows10;
    public static OperatingSystemVersion Windows10TH2;
    public static OperatingSystemVersion Windows10RS1;
    public static OperatingSystemVersion Windows10RS2;
    public static OperatingSystemVersion Windows10RS3;
    public static OperatingSystemVersion Windows10RS5;
}
internal static class MS.Internal.PresentationFramework.Interop.OSVersionHelper : object {
    [CompilerGeneratedAttribute]
private static bool <IsOsWindows10RS5OrGreater>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <IsOsWindows10RS3OrGreater>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <IsOsWindows10RS2OrGreater>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <IsOsWindows10RS1OrGreater>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <IsOsWindows10TH2OrGreater>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <IsOsWindows10TH1OrGreater>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <IsOsWindows10OrGreater>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <IsOsWindows8Point1OrGreater>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <IsOsWindows8OrGreater>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <IsOsWindows7SP1OrGreater>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <IsOsWindows7OrGreater>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <IsOsWindowsVistaSP2OrGreater>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <IsOsWindowsVistaSP1OrGreater>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <IsOsWindowsVistaOrGreater>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <IsOsWindowsXPSP3OrGreater>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <IsOsWindowsXPSP2OrGreater>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <IsOsWindowsXPSP1OrGreater>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <IsOsWindowsXPOrGreater>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <IsOsWindowsServer>k__BackingField;
    internal static bool IsOsWindows10RS5OrGreater { get; internal set; }
    internal static bool IsOsWindows10RS3OrGreater { get; internal set; }
    internal static bool IsOsWindows10RS2OrGreater { get; internal set; }
    internal static bool IsOsWindows10RS1OrGreater { get; internal set; }
    internal static bool IsOsWindows10TH2OrGreater { get; internal set; }
    internal static bool IsOsWindows10TH1OrGreater { get; internal set; }
    internal static bool IsOsWindows10OrGreater { get; internal set; }
    internal static bool IsOsWindows8Point1OrGreater { get; internal set; }
    internal static bool IsOsWindows8OrGreater { get; internal set; }
    internal static bool IsOsWindows7SP1OrGreater { get; internal set; }
    internal static bool IsOsWindows7OrGreater { get; internal set; }
    internal static bool IsOsWindowsVistaSP2OrGreater { get; internal set; }
    internal static bool IsOsWindowsVistaSP1OrGreater { get; internal set; }
    internal static bool IsOsWindowsVistaOrGreater { get; internal set; }
    internal static bool IsOsWindowsXPSP3OrGreater { get; internal set; }
    internal static bool IsOsWindowsXPSP2OrGreater { get; internal set; }
    internal static bool IsOsWindowsXPSP1OrGreater { get; internal set; }
    internal static bool IsOsWindowsXPOrGreater { get; internal set; }
    internal static bool IsOsWindowsServer { get; internal set; }
    private static OSVersionHelper();
    [CompilerGeneratedAttribute]
internal static bool get_IsOsWindows10RS5OrGreater();
    [CompilerGeneratedAttribute]
internal static void set_IsOsWindows10RS5OrGreater(bool value);
    [CompilerGeneratedAttribute]
internal static bool get_IsOsWindows10RS3OrGreater();
    [CompilerGeneratedAttribute]
internal static void set_IsOsWindows10RS3OrGreater(bool value);
    [CompilerGeneratedAttribute]
internal static bool get_IsOsWindows10RS2OrGreater();
    [CompilerGeneratedAttribute]
internal static void set_IsOsWindows10RS2OrGreater(bool value);
    [CompilerGeneratedAttribute]
internal static bool get_IsOsWindows10RS1OrGreater();
    [CompilerGeneratedAttribute]
internal static void set_IsOsWindows10RS1OrGreater(bool value);
    [CompilerGeneratedAttribute]
internal static bool get_IsOsWindows10TH2OrGreater();
    [CompilerGeneratedAttribute]
internal static void set_IsOsWindows10TH2OrGreater(bool value);
    [CompilerGeneratedAttribute]
internal static bool get_IsOsWindows10TH1OrGreater();
    [CompilerGeneratedAttribute]
internal static void set_IsOsWindows10TH1OrGreater(bool value);
    [CompilerGeneratedAttribute]
internal static bool get_IsOsWindows10OrGreater();
    [CompilerGeneratedAttribute]
internal static void set_IsOsWindows10OrGreater(bool value);
    [CompilerGeneratedAttribute]
internal static bool get_IsOsWindows8Point1OrGreater();
    [CompilerGeneratedAttribute]
internal static void set_IsOsWindows8Point1OrGreater(bool value);
    [CompilerGeneratedAttribute]
internal static bool get_IsOsWindows8OrGreater();
    [CompilerGeneratedAttribute]
internal static void set_IsOsWindows8OrGreater(bool value);
    [CompilerGeneratedAttribute]
internal static bool get_IsOsWindows7SP1OrGreater();
    [CompilerGeneratedAttribute]
internal static void set_IsOsWindows7SP1OrGreater(bool value);
    [CompilerGeneratedAttribute]
internal static bool get_IsOsWindows7OrGreater();
    [CompilerGeneratedAttribute]
internal static void set_IsOsWindows7OrGreater(bool value);
    [CompilerGeneratedAttribute]
internal static bool get_IsOsWindowsVistaSP2OrGreater();
    [CompilerGeneratedAttribute]
internal static void set_IsOsWindowsVistaSP2OrGreater(bool value);
    [CompilerGeneratedAttribute]
internal static bool get_IsOsWindowsVistaSP1OrGreater();
    [CompilerGeneratedAttribute]
internal static void set_IsOsWindowsVistaSP1OrGreater(bool value);
    [CompilerGeneratedAttribute]
internal static bool get_IsOsWindowsVistaOrGreater();
    [CompilerGeneratedAttribute]
internal static void set_IsOsWindowsVistaOrGreater(bool value);
    [CompilerGeneratedAttribute]
internal static bool get_IsOsWindowsXPSP3OrGreater();
    [CompilerGeneratedAttribute]
internal static void set_IsOsWindowsXPSP3OrGreater(bool value);
    [CompilerGeneratedAttribute]
internal static bool get_IsOsWindowsXPSP2OrGreater();
    [CompilerGeneratedAttribute]
internal static void set_IsOsWindowsXPSP2OrGreater(bool value);
    [CompilerGeneratedAttribute]
internal static bool get_IsOsWindowsXPSP1OrGreater();
    [CompilerGeneratedAttribute]
internal static void set_IsOsWindowsXPSP1OrGreater(bool value);
    [CompilerGeneratedAttribute]
internal static bool get_IsOsWindowsXPOrGreater();
    [CompilerGeneratedAttribute]
internal static void set_IsOsWindowsXPOrGreater(bool value);
    [CompilerGeneratedAttribute]
internal static bool get_IsOsWindowsServer();
    [CompilerGeneratedAttribute]
internal static void set_IsOsWindowsServer(bool value);
    private static bool IsWindows10RS5OrGreater();
    private static bool IsWindows10RS3OrGreater();
    private static bool IsWindows10RS2OrGreater();
    private static bool IsWindows10RS1OrGreater();
    private static bool IsWindows10TH2OrGreater();
    private static bool IsWindows10TH1OrGreater();
    private static bool IsWindows10OrGreater();
    private static bool IsWindows8Point1OrGreater();
    private static bool IsWindows8OrGreater();
    private static bool IsWindows7SP1OrGreater();
    private static bool IsWindows7OrGreater();
    private static bool IsWindowsVistaSP2OrGreater();
    private static bool IsWindowsVistaSP1OrGreater();
    private static bool IsWindowsVistaOrGreater();
    private static bool IsWindowsXPSP3OrGreater();
    private static bool IsWindowsXPSP2OrGreater();
    private static bool IsWindowsXPSP1OrGreater();
    private static bool IsWindowsXPOrGreater();
    private static bool IsWindowsServer();
    internal static bool IsOsVersionOrGreater(OperatingSystemVersion osVer);
    internal static OperatingSystemVersion GetOsVersion();
}
internal class MS.Internal.PresentationFramework.Markup.XamlReaderProxy : object {
    private static XamlLoadDelegate3 _xamlLoad3;
    private static XamlLoadDelegate2 _xamlLoad2;
    private static Type _xamlReaderType;
    private static string XamlLoadMethodName;
    private static XamlReaderProxy();
    public static object Load(Stream stream, ParserContext parserContext, bool useRestrictiveXamlReader);
    public static object Load(XmlReader reader, bool useRestrictiveXamlReader);
}
internal static class MS.Internal.PresentationFramework.SafeSecurityHelper : object {
    internal static string IMAGE;
    internal static string GetAssemblyPartialName(Assembly assembly);
    internal static string GetFullAssemblyNameFromPartialName(Assembly protoAssembly, string partialName);
    internal static Point ClientToScreen(UIElement relativeTo, Point point);
    internal static bool IsSameKeyToken(Byte[] reqKeyToken, Byte[] curKeyToken);
    internal static bool IsFeatureDisabled(KeyToRead key);
    internal static bool IsConnectedToPresentationSource(Visual visual);
}
internal static class MS.Internal.PresentationFramework.SecurityHelper : object {
    internal static Exception GetExceptionForHR(int hr);
    internal static void ShowMessageBoxHelper(Window parent, string text, string title, MessageBoxButton buttons, MessageBoxImage image);
    internal static void ShowMessageBoxHelper(IntPtr parentHwnd, string text, string title, MessageBoxButton buttons, MessageBoxImage image);
    internal static bool AreStringTypesEqual(string m1, string m2);
}
internal static class MS.Internal.Printing.NativeMethods : object {
    internal static UInt32 PD_ALLPAGES;
    internal static UInt32 PD_SELECTION;
    internal static UInt32 PD_PAGENUMS;
    internal static UInt32 PD_NOSELECTION;
    internal static UInt32 PD_NOPAGENUMS;
    internal static UInt32 PD_USEDEVMODECOPIESANDCOLLATE;
    internal static UInt32 PD_DISABLEPRINTTOFILE;
    internal static UInt32 PD_HIDEPRINTTOFILE;
    internal static UInt32 PD_CURRENTPAGE;
    internal static UInt32 PD_NOCURRENTPAGE;
    internal static UInt32 PD_RESULT_CANCEL;
    internal static UInt32 PD_RESULT_PRINT;
    internal static UInt32 PD_RESULT_APPLY;
    internal static UInt32 START_PAGE_GENERAL;
}
internal static class MS.Internal.Printing.UnsafeNativeMethods : object {
    internal static int PrintDlgEx(IntPtr pdex);
    internal static IntPtr GlobalFree(IntPtr hMem);
    internal static IntPtr GlobalLock(IntPtr hMem);
    internal static bool GlobalUnlock(IntPtr hMem);
}
internal class MS.Internal.Printing.Win32PrintDialog : object {
    private PrintTicket _printTicket;
    private PrintQueue _printQueue;
    private PageRangeSelection _pageRangeSelection;
    private PageRange _pageRange;
    private bool _pageRangeEnabled;
    private bool _selectedPagesEnabled;
    private bool _currentPageEnabled;
    private UInt32 _minPage;
    private UInt32 _maxPage;
    private static char RightToLeftMark;
    internal PrintTicket PrintTicket { get; internal set; }
    internal PrintQueue PrintQueue { get; internal set; }
    internal UInt32 MinPage { get; internal set; }
    internal UInt32 MaxPage { get; internal set; }
    internal PageRangeSelection PageRangeSelection { get; internal set; }
    internal PageRange PageRange { get; internal set; }
    internal bool PageRangeEnabled { get; internal set; }
    internal bool SelectedPagesEnabled { get; internal set; }
    internal bool CurrentPageEnabled { get; internal set; }
    internal UInt32 ShowDialog();
    internal PrintTicket get_PrintTicket();
    internal void set_PrintTicket(PrintTicket value);
    internal PrintQueue get_PrintQueue();
    internal void set_PrintQueue(PrintQueue value);
    internal UInt32 get_MinPage();
    internal void set_MinPage(UInt32 value);
    internal UInt32 get_MaxPage();
    internal void set_MaxPage(UInt32 value);
    internal PageRangeSelection get_PageRangeSelection();
    internal void set_PageRangeSelection(PageRangeSelection value);
    internal PageRange get_PageRange();
    internal void set_PageRange(PageRange value);
    internal bool get_PageRangeEnabled();
    internal void set_PageRangeEnabled(bool value);
    internal bool get_SelectedPagesEnabled();
    internal void set_SelectedPagesEnabled(bool value);
    internal bool get_CurrentPageEnabled();
    internal void set_CurrentPageEnabled(bool value);
    private void ProbeForPrintingSupport();
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("e7b92912-c7ca-4629-8f39-0f537cfab57e")]
internal interface MS.Internal.Progressivity.IByteRangeDownloaderService {
    public abstract virtual void InitializeByteRangeDownloader(string url, string tempFile, SafeWaitHandle eventHandle);
    public abstract virtual void RequestDownloadByteRanges(Int32[] byteRanges, int size);
    public abstract virtual void GetDownloadedByteRanges(Int32[]& byteRanges, Int32& size);
    public abstract virtual void ReleaseByteRangeDownloader();
}
internal class MS.Internal.PtsHost.AttachedObject : EmbeddedObject {
    internal BaseParagraph Para;
    internal DependencyObject Element { get; }
    internal AttachedObject(int dcp, BaseParagraph para);
    internal virtual void Dispose();
    internal virtual void Update(EmbeddedObject newObject);
    internal virtual DependencyObject get_Element();
}
internal class MS.Internal.PtsHost.BackgroundFormatInfo : object {
    private double _viewportHeight;
    private bool _doesFinalDTRCoverRestOfText;
    private int _lastCPUninterruptible;
    private DateTime _backgroundFormatStopTime;
    private int _cchAllText;
    private int _cpInterrupted;
    private static bool _isBackgroundFormatEnabled;
    private StructuralCache _structuralCache;
    private DateTime _throttleTimeout;
    private DispatcherTimer _throttleBackgroundTimer;
    private IFlowDocumentFormatter _pendingBackgroundFormatter;
    private static UInt32 _throttleBackgroundSeconds;
    private static UInt32 _stopTimeDelta;
    internal int LastCPUninterruptible { get; }
    internal DateTime BackgroundFormatStopTime { get; }
    internal int CchAllText { get; }
    internal static bool IsBackgroundFormatEnabled { get; }
    internal bool DoesFinalDTRCoverRestOfText { get; }
    internal int CPInterrupted { get; internal set; }
    internal double ViewportHeight { get; internal set; }
    internal BackgroundFormatInfo(StructuralCache structuralCache);
    private static BackgroundFormatInfo();
    internal void UpdateBackgroundFormatInfo();
    internal void ThrottleBackgroundFormatting();
    internal void BackgroundFormat(IFlowDocumentFormatter formatter, bool ignoreThrottle);
    internal int get_LastCPUninterruptible();
    internal DateTime get_BackgroundFormatStopTime();
    internal int get_CchAllText();
    internal static bool get_IsBackgroundFormatEnabled();
    internal bool get_DoesFinalDTRCoverRestOfText();
    internal int get_CPInterrupted();
    internal void set_CPInterrupted(int value);
    internal double get_ViewportHeight();
    internal void set_ViewportHeight(double value);
    private void OnThrottleBackgroundTimeout(object sender, EventArgs e);
}
internal abstract class MS.Internal.PtsHost.BaseParaClient : UnmanagedHandle {
    protected BaseParagraph _paragraph;
    protected SecurityCriticalDataForSet`1<IntPtr> _paraHandle;
    protected FSRECT _rect;
    protected int _dvrTopSpace;
    protected ParagraphVisual _visual;
    protected PageContext _pageContext;
    protected FlowDirection _flowDirectionParent;
    protected FlowDirection _flowDirection;
    internal ParagraphVisual Visual { get; }
    internal bool IsFirstChunk { get; }
    internal bool IsLastChunk { get; }
    internal BaseParagraph Paragraph { get; }
    internal FSRECT Rect { get; }
    internal FlowDirection ThisFlowDirection { get; }
    internal FlowDirection ParentFlowDirection { get; }
    internal FlowDirection PageFlowDirection { get; }
    protected BaseParaClient(BaseParagraph paragraph);
    internal void Arrange(IntPtr pfspara, FSRECT rcPara, int dvrTopSpace, UInt32 fswdirParent);
    internal virtual int GetFirstTextLineBaseline();
    internal void TransferDisplayInfo(BaseParaClient oldParaClient);
    internal virtual IInputElement InputHitTest(FSPOINT pt);
    internal virtual List`1<Rect> GetRectangles(ContentElement e, int start, int length);
    internal virtual void GetRectanglesForParagraphElement(List`1& rectangles);
    internal virtual void ValidateVisual(FSKUPDATE fskupdInherited);
    internal virtual void UpdateViewport(FSRECT& viewport);
    internal abstract virtual ParagraphResult CreateParagraphResult();
    internal abstract virtual TextContentRange GetTextContentRange();
    internal virtual ParagraphVisual get_Visual();
    internal virtual bool get_IsFirstChunk();
    internal virtual bool get_IsLastChunk();
    internal BaseParagraph get_Paragraph();
    internal FSRECT get_Rect();
    internal FlowDirection get_ThisFlowDirection();
    internal FlowDirection get_ParentFlowDirection();
    internal FlowDirection get_PageFlowDirection();
    protected virtual void OnArrange();
}
internal abstract class MS.Internal.PtsHost.BaseParagraph : UnmanagedHandle {
    protected FSKCHANGE _changeType;
    protected bool _stopAsking;
    protected int _lastFormatCch;
    internal BaseParagraph Next;
    internal BaseParagraph Previous;
    protected StructuralCache _structuralCache;
    protected DependencyObject _element;
    internal int ParagraphStartCharacterPosition { get; }
    internal int ParagraphEndCharacterPosition { get; }
    internal int Cch { get; }
    internal int LastFormatCch { get; }
    internal StructuralCache StructuralCache { get; }
    internal DependencyObject Element { get; }
    protected BaseParagraph(DependencyObject element, StructuralCache structuralCache);
    internal virtual void UpdGetParaChange(FSKCHANGE& fskch, Int32& fNoFurtherChanges);
    internal virtual void CollapseMargin(BaseParaClient paraClient, MarginCollapsingState mcs, UInt32 fswdir, bool suppressTopSpace, Int32& dvr);
    internal abstract virtual void GetParaProperties(FSPAP& fspap);
    internal abstract virtual void CreateParaclient(IntPtr& pfsparaclient);
    internal virtual void SetUpdateInfo(FSKCHANGE fskch, bool stopAsking);
    internal virtual void ClearUpdateInfo();
    internal virtual bool InvalidateStructure(int startPosition);
    internal virtual void InvalidateFormatCache();
    internal void UpdateLastFormatPositions();
    protected void GetParaProperties(FSPAP& fspap, bool ignoreElementProps);
    internal int get_ParagraphStartCharacterPosition();
    internal int get_ParagraphEndCharacterPosition();
    internal int get_Cch();
    internal int get_LastFormatCch();
    internal StructuralCache get_StructuralCache();
    internal DependencyObject get_Element();
}
internal class MS.Internal.PtsHost.BreakRecordTable : object {
    private FlowDocumentPaginator _owner;
    private List`1<BreakRecordTableEntry> _breakRecords;
    internal int Count { get; }
    internal bool IsClean { get; }
    internal BreakRecordTable(FlowDocumentPaginator owner);
    internal PageBreakRecord GetPageBreakRecord(int pageNumber);
    internal FlowDocumentPage GetCachedDocumentPage(int pageNumber);
    internal bool GetPageNumberForContentPosition(TextPointer contentPosition, Int32& pageNumber);
    internal void OnInvalidateLayout();
    internal void OnInvalidateLayout(ITextPointer start, ITextPointer end);
    internal void OnInvalidateRender();
    internal void OnInvalidateRender(ITextPointer start, ITextPointer end);
    internal void UpdateEntry(int pageNumber, FlowDocumentPage page, PageBreakRecord brOut, TextPointer dependentMax);
    internal bool HasPageBreakRecord(int pageNumber);
    internal int get_Count();
    internal bool get_IsClean();
    private void DisposePages(int start, int count);
    private void InvalidateBreakRecords(int start, int count);
    private void GetAffectedPages(ITextPointer start, ITextPointer end, Int32& pageStart, Int32& pageCount);
}
internal class MS.Internal.PtsHost.CellInfo : object {
    private Rect _rectCell;
    private Rect _rectTable;
    private TableCell _cell;
    private Double[] _columnWidths;
    private double _autofitWidth;
    internal TableCell Cell { get; }
    internal Double[] TableColumnWidths { get; }
    internal double TableAutofitWidth { get; }
    internal Rect TableArea { get; }
    internal Rect CellArea { get; }
    internal CellInfo(TableParaClient tpc, CellParaClient cpc);
    internal void Adjust(Point ptAdjust);
    internal TableCell get_Cell();
    internal Double[] get_TableColumnWidths();
    internal double get_TableAutofitWidth();
    internal Rect get_TableArea();
    internal Rect get_CellArea();
}
internal class MS.Internal.PtsHost.CellParaClient : SubpageParaClient {
    private double _arrangeHeight;
    private TableParaClient _tableParaClient;
    internal TableCell Cell { get; }
    internal Table Table { get; }
    internal CellParagraph CellParagraph { get; }
    internal int ColumnIndex { get; }
    unknown double ArrangeHeight {internal set; }
    internal TableParaClient TableParaClient { get; }
    internal CellParaClient(CellParagraph cellParagraph, TableParaClient tableParaClient);
    internal void Arrange(int du, int dv, FSRECT rcTable, FlowDirection tableFlowDirection, PageContext pageContext);
    internal void ValidateVisual();
    internal void FormatCellFinite(Size subpageSize, IntPtr breakRecordIn, bool isEmptyOk, UInt32 fswdir, FSKSUPPRESSHARDBREAKBEFOREFIRSTPARA fsksuppresshardbreakbeforefirstparaIn, FSFMTR& fsfmtr, Int32& dvrUsed, IntPtr& breakRecordOut);
    internal void FormatCellBottomless(UInt32 fswdir, double width, FSFMTRBL& fmtrbl, Int32& dvrUsed);
    internal void UpdateBottomlessCell(UInt32 fswdir, double width, FSFMTRBL& fmtrbl, Int32& dvrUsed);
    internal Geometry GetTightBoundingGeometryFromTextPositions(ITextPointer startPosition, ITextPointer endPosition, Rect visibleRect);
    internal double CalculateCellWidth(TableParaClient tableParaClient);
    internal TableCell get_Cell();
    internal Table get_Table();
    internal CellParagraph get_CellParagraph();
    internal int get_ColumnIndex();
    internal void set_ArrangeHeight(double value);
    internal TableParaClient get_TableParaClient();
}
internal class MS.Internal.PtsHost.CellParagraph : SubpageParagraph {
    internal TableCell Cell { get; }
    internal CellParagraph(DependencyObject element, StructuralCache structuralCache);
    internal TableCell get_Cell();
    internal void FormatCellFinite(TableParaClient tableParaClient, IntPtr pfsbrkcellIn, IntPtr pfsFtnRejector, int fEmptyOK, UInt32 fswdirTable, int dvrAvailable, FSFMTR& pfmtr, IntPtr& ppfscell, IntPtr& pfsbrkcellOut, Int32& dvrUsed);
    internal void FormatCellBottomless(TableParaClient tableParaClient, UInt32 fswdirTable, FSFMTRBL& fmtrbl, IntPtr& ppfscell, Int32& dvrUsed);
    internal void UpdateBottomlessCell(CellParaClient cellParaClient, TableParaClient tableParaClient, UInt32 fswdirTable, FSFMTRBL& fmtrbl, Int32& dvrUsed);
    internal void SetCellHeight(CellParaClient cellParaClient, TableParaClient tableParaClient, IntPtr subpageBreakRecord, int fBrokenHere, UInt32 fswdirTable, int dvrActual);
    internal void UpdGetCellChange(Int32& fWidthChanged, FSKCHANGE& fskchCell);
}
internal class MS.Internal.PtsHost.ColumnPropertiesGroup : object {
    private double _columnWidth;
    private bool _isColumnWidthFlexible;
    private double _columnGap;
    private Brush _columnRuleBrush;
    private double _columnRuleWidth;
    internal double ColumnWidth { get; }
    internal bool IsColumnWidthFlexible { get; }
    internal ColumnSpaceDistribution ColumnSpaceDistribution { get; }
    internal double ColumnGap { get; }
    internal Brush ColumnRuleBrush { get; }
    internal double ColumnRuleWidth { get; }
    internal bool ColumnWidthAuto { get; }
    internal bool ColumnGapAuto { get; }
    internal ColumnPropertiesGroup(DependencyObject o);
    internal double get_ColumnWidth();
    internal bool get_IsColumnWidthFlexible();
    internal ColumnSpaceDistribution get_ColumnSpaceDistribution();
    internal double get_ColumnGap();
    internal Brush get_ColumnRuleBrush();
    internal double get_ColumnRuleWidth();
    internal bool get_ColumnWidthAuto();
    internal bool get_ColumnGapAuto();
}
internal class MS.Internal.PtsHost.ContainerParaClient : BaseParaClient {
    private bool _isFirstChunk;
    private bool _isLastChunk;
    internal bool IsFirstChunk { get; }
    internal bool IsLastChunk { get; }
    internal ContainerParaClient(ContainerParagraph paragraph);
    protected virtual void OnArrange();
    internal virtual IInputElement InputHitTest(FSPOINT pt);
    internal virtual List`1<Rect> GetRectangles(ContentElement e, int start, int length);
    internal virtual void ValidateVisual(FSKUPDATE fskupdInherited);
    internal virtual void UpdateViewport(FSRECT& viewport);
    internal virtual ParagraphResult CreateParagraphResult();
    internal virtual TextContentRange GetTextContentRange();
    internal ReadOnlyCollection`1<ParagraphResult> GetChildrenParagraphResults(Boolean& hasTextContent);
    internal void SetChunkInfo(bool isFirstChunk, bool isLastChunk);
    internal virtual int GetFirstTextLineBaseline();
    internal Geometry GetTightBoundingGeometryFromTextPositions(ITextPointer startPosition, ITextPointer endPosition, Rect visibleRect);
    internal virtual bool get_IsFirstChunk();
    internal virtual bool get_IsLastChunk();
}
internal class MS.Internal.PtsHost.ContainerParagraph : BaseParagraph {
    private BaseParagraph _firstChild;
    private BaseParagraph _lastFetchedChild;
    private UpdateRecord _ur;
    private bool _firstParaValidInUpdateMode;
    internal ContainerParagraph(DependencyObject element, StructuralCache structuralCache);
    public virtual void Dispose();
    private sealed virtual override void MS.Internal.PtsHost.ISegment.GetFirstPara(Int32& fSuccessful, IntPtr& firstParaName);
    private sealed virtual override void MS.Internal.PtsHost.ISegment.GetNextPara(BaseParagraph prevParagraph, Int32& fFound, IntPtr& nextParaName);
    private sealed virtual override void MS.Internal.PtsHost.ISegment.UpdGetFirstChangeInSegment(Int32& fFound, Int32& fChangeFirst, IntPtr& nmpBeforeChange);
    internal void UpdGetSegmentChange(FSKCHANGE& fskch);
    internal virtual void GetParaProperties(FSPAP& fspap);
    internal virtual void CreateParaclient(IntPtr& paraClientHandle);
    internal void FormatParaFinite(ContainerParaClient paraClient, IntPtr pbrkrecIn, int fBRFromPreviousPage, int iArea, IntPtr footnoteRejector, IntPtr geometry, int fEmptyOk, int fSuppressTopSpace, UInt32 fswdir, FSRECT& fsrcToFill, MarginCollapsingState mcs, FSKCLEAR fskclearIn, FSKSUPPRESSHARDBREAKBEFOREFIRSTPARA fsksuppresshardbreakbeforefirstparaIn, FSFMTR& fsfmtr, IntPtr& pfspara, IntPtr& pbrkrecOut, Int32& dvrUsed, FSBBOX& fsbbox, IntPtr& pmcsclientOut, FSKCLEAR& fskclearOut, Int32& dvrTopSpace);
    internal void FormatParaBottomless(ContainerParaClient paraClient, int iArea, IntPtr geometry, int fSuppressTopSpace, UInt32 fswdir, int urTrack, int durTrack, int vrTrack, MarginCollapsingState mcs, FSKCLEAR fskclearIn, int fInterruptable, FSFMTRBL& fsfmtrbl, IntPtr& pfspara, Int32& dvrUsed, FSBBOX& fsbbox, IntPtr& pmcsclientOut, FSKCLEAR& fskclearOut, Int32& dvrTopSpace, Int32& fPageBecomesUninterruptable);
    internal void UpdateBottomlessPara(IntPtr pfspara, ContainerParaClient paraClient, int iArea, IntPtr pfsgeom, int fSuppressTopSpace, UInt32 fswdir, int urTrack, int durTrack, int vrTrack, MarginCollapsingState mcs, FSKCLEAR fskclearIn, int fInterruptable, FSFMTRBL& fsfmtrbl, Int32& dvrUsed, FSBBOX& fsbbox, IntPtr& pmcsclientOut, FSKCLEAR& fskclearOut, Int32& dvrTopSpace, Int32& fPageBecomesUninterruptable);
    internal virtual void ClearUpdateInfo();
    internal virtual bool InvalidateStructure(int startPosition);
    internal virtual void InvalidateFormatCache();
    protected virtual BaseParagraph GetParagraph(ITextPointer textPointer, bool fEmptyOk);
    private bool NeedsUpdate();
    private void BuildUpdateRecord();
    private UpdateRecord UpdateRecordFromDtr(DtrList dtrs, DirtyTextRange dtr, int dcpContent);
}
internal class MS.Internal.PtsHost.DirtyTextRange : ValueType {
    [CompilerGeneratedAttribute]
private int <StartIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private int <PositionsAdded>k__BackingField;
    [CompilerGeneratedAttribute]
private int <PositionsRemoved>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <FromHighlightLayer>k__BackingField;
    internal int StartIndex { get; internal set; }
    internal int PositionsAdded { get; internal set; }
    internal int PositionsRemoved { get; internal set; }
    internal bool FromHighlightLayer { get; internal set; }
    internal DirtyTextRange(int startIndex, int positionsAdded, int positionsRemoved, bool fromHighlightLayer);
    internal DirtyTextRange(TextContainerChangeEventArgs change);
    [CompilerGeneratedAttribute]
[IsReadOnlyAttribute]
internal int get_StartIndex();
    [CompilerGeneratedAttribute]
internal void set_StartIndex(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
internal int get_PositionsAdded();
    [CompilerGeneratedAttribute]
internal void set_PositionsAdded(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
internal int get_PositionsRemoved();
    [CompilerGeneratedAttribute]
internal void set_PositionsRemoved(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
internal bool get_FromHighlightLayer();
    [CompilerGeneratedAttribute]
internal void set_FromHighlightLayer(bool value);
}
[DefaultMemberAttribute("Item")]
internal class MS.Internal.PtsHost.DtrList : object {
    private DirtyTextRange[] _dtrs;
    private static int _defaultCapacity;
    private int _count;
    internal int Length { get; }
    internal DirtyTextRange Item { get; }
    internal void Merge(DirtyTextRange dtr);
    internal DirtyTextRange GetMergedRange();
    internal DtrList DtrsFromRange(int dcpNew, int cchOld);
    private void MergeWithNext(int index);
    private void Append(DirtyTextRange dtr);
    private void Resize();
    internal int get_Length();
    internal DirtyTextRange get_Item(int index);
}
internal abstract class MS.Internal.PtsHost.EmbeddedObject : object {
    internal int Dcp;
    internal DependencyObject Element { get; }
    protected EmbeddedObject(int dcp);
    internal virtual void Dispose();
    internal abstract virtual void Update(EmbeddedObject newObject);
    internal abstract virtual DependencyObject get_Element();
}
internal static class MS.Internal.PtsHost.ErrorHandler : object {
    internal static string PtsCacheAlreadyCreated;
    internal static string PtsCacheAlreadyDestroyed;
    internal static string NullPtsHost;
    internal static string CreateContextFailed;
    internal static string EnumIntegrationError;
    internal static string NoNeedToDestroyPtsPage;
    internal static string NotSupportedFiniteIncremental;
    internal static string NotSupportedFootnotes;
    internal static string NotSupportedCompositeColumns;
    internal static string NotSupportedDropCap;
    internal static string NotSupportedForcedLineBreaks;
    internal static string NotSupportedMultiSection;
    internal static string NotSupportedSubtrackShift;
    internal static string NullObjectInCreateHandle;
    internal static string InvalidHandle;
    internal static string HandleOutOfRange;
    internal static string BreakRecordDisposed;
    internal static string BreakRecordNotNeeded;
    internal static string BrokenParaHasMcs;
    internal static string BrokenParaHasTopSpace;
    internal static string GoalReachedHasBreakRecord;
    internal static string BrokenContentRequiresBreakRecord;
    internal static string PTSAssert;
    internal static string ParaHandleMismatch;
    internal static string PTSObjectsCountMismatch;
    internal static string SubmitForEmptyRange;
    internal static string SubmitInvalidList;
    internal static string HandledInsideSegmentPara;
    internal static string EmptyParagraph;
    internal static string ParaStartsWithEOP;
    internal static string FetchParaAtTextRangePosition;
    internal static string ParagraphCharacterCountMismatch;
    internal static string ContainerNeedsTextElement;
    internal static string CannotPositionInsideUIElement;
    internal static string CannotFindUIElement;
    internal static string InvalidDocumentPage;
    internal static string NoVisualToTransfer;
    internal static string UpdateShiftedNotValid;
    internal static string ColumnVisualCountMismatch;
    internal static string VisualTypeMismatch;
    internal static string EmbeddedObjectTypeMismatch;
    internal static string EmbeddedObjectOwnerMismatch;
    internal static string LineAlreadyDestroyed;
    internal static string OnlyOneRectIsExpected;
    internal static string NotInLineBoundary;
    internal static string FetchRunAtTextArrayStart;
    internal static string TextFormatterHostNotInitialized;
    internal static string NegativeCharacterIndex;
    internal static string NoClientDataForObjectRun;
    internal static string UnknownDOTypeInTextArray;
    internal static string NegativeObjectWidth;
    internal static string NoUIElementForObjectPosition;
    internal static string InlineObjectCacheCorrupted;
    private static ErrorHandler();
    internal static void Assert(bool condition, string message);
    internal static void Assert(bool condition, string format, Object[] args);
}
internal static class MS.Internal.PtsHost.FigureHelper : object {
    internal static bool IsVerticalPageAnchor(FigureVerticalAnchor verticalAnchor);
    internal static bool IsVerticalContentAnchor(FigureVerticalAnchor verticalAnchor);
    internal static bool IsHorizontalPageAnchor(FigureHorizontalAnchor horizontalAnchor);
    internal static bool IsHorizontalContentAnchor(FigureHorizontalAnchor horizontalAnchor);
    internal static bool IsHorizontalColumnAnchor(FigureHorizontalAnchor horizontalAnchor);
    internal static double CalculateFigureWidth(StructuralCache structuralCache, Figure figure, FigureLength figureLength, Boolean& isWidthAuto);
    internal static double CalculateFigureHeight(StructuralCache structuralCache, Figure figure, FigureLength figureLength, Boolean& isHeightAuto);
    internal static double CalculateFigureCommon(FigureLength figureLength);
    internal static void GetColumnMetrics(StructuralCache structuralCache, Int32& cColumns, Double& width, Double& gap, Double& rule);
}
internal class MS.Internal.PtsHost.FigureObject : AttachedObject {
    internal FigureObject(int dcp, FigureParagraph para);
}
internal class MS.Internal.PtsHost.FigureParaClient : BaseParaClient {
    private FSRECT _contentRect;
    private FSRECT _paddingRect;
    private PageContext _pageContextOfThisPage;
    internal IntPtr SubpageHandle { get; internal set; }
    internal FSRECT ContentRect { get; }
    internal ReadOnlyCollection`1<ParagraphResult> FloatingElementResults { get; }
    internal FigureParaClient(FigureParagraph paragraph);
    public virtual void Dispose();
    protected virtual void OnArrange();
    internal virtual void UpdateViewport(FSRECT& viewport);
    internal void ArrangeFigure(FSRECT rcFigure, FSRECT rcHostPara, UInt32 fswdirParent, PageContext pageContext);
    internal virtual IInputElement InputHitTest(FSPOINT pt);
    internal virtual List`1<Rect> GetRectangles(ContentElement e, int start, int length);
    internal virtual void ValidateVisual(FSKUPDATE fskupdInherited);
    internal virtual ParagraphResult CreateParagraphResult();
    internal virtual TextContentRange GetTextContentRange();
    private ReadOnlyCollection`1<ParagraphResult> GetChildrenParagraphResults(Boolean& hasTextContent);
    internal ReadOnlyCollection`1<ColumnResult> GetColumnResults(Boolean& hasTextContent);
    internal ReadOnlyCollection`1<ParagraphResult> GetParagraphResultsFromColumn(IntPtr pfstrack, Vector parentOffset, Boolean& hasTextContent);
    internal TextContentRange GetTextContentRangeFromColumn(IntPtr pfstrack);
    internal Geometry GetTightBoundingGeometryFromTextPositions(ReadOnlyCollection`1<ColumnResult> columns, ReadOnlyCollection`1<ParagraphResult> floatingElements, ITextPointer startPosition, ITextPointer endPosition, Rect visibleRect);
    internal IntPtr get_SubpageHandle();
    internal void set_SubpageHandle(IntPtr value);
    internal FSRECT get_ContentRect();
    internal ReadOnlyCollection`1<ParagraphResult> get_FloatingElementResults();
}
internal class MS.Internal.PtsHost.FigureParagraph : BaseParagraph {
    private BaseParagraph _mainTextSegment;
    internal FigureParagraph(DependencyObject element, StructuralCache structuralCache);
    public virtual void Dispose();
    internal virtual void GetParaProperties(FSPAP& fspap);
    internal virtual void CreateParaclient(IntPtr& paraClientHandle);
    internal void GetFigureProperties(FigureParaClient paraClient, int fInTextLine, UInt32 fswdir, int fBottomUndefined, Int32& dur, Int32& dvr, FSFIGUREPROPS& fsfigprops, Int32& cPolygons, Int32& cVertices, Int32& durDistTextLeft, Int32& durDistTextRight, Int32& dvrDistTextTop, Int32& dvrDistTextBottom);
    internal void GetFigurePolygons(FigureParaClient paraClient, UInt32 fswdir, int ncVertices, int nfspt, Int32* rgcVertices, Int32& ccVertices, FSPOINT* rgfspt, Int32& cfspt, Int32& fWrapThrough);
    internal void CalcFigurePosition(FigureParaClient paraClient, UInt32 fswdir, FSRECT& fsrcPage, FSRECT& fsrcMargin, FSRECT& fsrcTrack, FSRECT& fsrcFigurePreliminary, int fMustPosition, int fInTextLine, Int32& fPushToNextTrack, FSRECT& fsrcFlow, FSRECT& fsrcOverlap, FSBBOX& fsbbox, FSRECT& fsrcSearch);
    internal virtual void ClearUpdateInfo();
    internal virtual bool InvalidateStructure(int startPosition);
    internal virtual void InvalidateFormatCache();
    internal void UpdateSegmentLastFormatPositions();
    private void CreateSubpageFiniteHelper(PtsContext ptsContext, IntPtr brParaIn, int fFromPreviousPage, IntPtr nSeg, IntPtr pFtnRej, int fEmptyOk, int fSuppressTopSpace, UInt32 fswdir, int lWidth, int lHeight, FSRECT& rcMargin, int cColumns, FSCOLUMNINFO[] columnInfoCollection, int fApplyColumnBalancing, FSFMTR& fsfmtr, IntPtr& pSubPage, IntPtr& brParaOut, Int32& dvrUsed, FSBBOX& fsBBox, IntPtr& pfsMcsClient, Int32& topSpace);
    private int CalculateParagraphToColumnOffset(FigureHorizontalAnchor horizontalAnchor, FSRECT fsrcInColumn);
    private double LimitTotalWidthFromAnchor(double width, double elementMarginWidth);
    private double LimitTotalHeightFromAnchor(double height, double elementMarginHeight);
    private FSRECT CalculateSearchArea(FigureHorizontalAnchor horizAnchor, FigureVerticalAnchor vertAnchor, FSRECT& fsrcPage, FSRECT& fsrcMargin, FSRECT& fsrcTrack, FSRECT& fsrcFigurePreliminary);
}
internal abstract class MS.Internal.PtsHost.FloaterBaseParaClient : BaseParaClient {
    protected FloaterBaseParaClient(FloaterBaseParagraph paragraph);
    internal virtual void ArrangeFloater(FSRECT rcFloater, FSRECT rcHostPara, UInt32 fswdirParent, PageContext pageContext);
    internal abstract virtual TextContentRange GetTextContentRange();
}
internal abstract class MS.Internal.PtsHost.FloaterBaseParagraph : BaseParagraph {
    protected FloaterBaseParagraph(TextElement element, StructuralCache structuralCache);
    public virtual void Dispose();
    internal virtual void UpdGetParaChange(FSKCHANGE& fskch, Int32& fNoFurtherChanges);
    internal virtual void GetParaProperties(FSPAP& fspap);
    internal abstract virtual void CreateParaclient(IntPtr& paraClientHandle);
    internal abstract virtual void CollapseMargin(BaseParaClient paraClient, MarginCollapsingState mcs, UInt32 fswdir, bool suppressTopSpace, Int32& dvr);
    internal abstract virtual void GetFloaterProperties(UInt32 fswdirTrack, FSFLOATERPROPS& fsfloaterprops);
    internal virtual void GetFloaterPolygons(FloaterBaseParaClient paraClient, UInt32 fswdirTrack, int ncVertices, int nfspt, Int32* rgcVertices, Int32& ccVertices, FSPOINT* rgfspt, Int32& cfspt, Int32& fWrapThrough);
    internal abstract virtual void FormatFloaterContentFinite(FloaterBaseParaClient paraClient, IntPtr pbrkrecIn, int fBRFromPreviousPage, IntPtr footnoteRejector, int fEmptyOk, int fSuppressTopSpace, UInt32 fswdir, int fAtMaxWidth, int durAvailable, int dvrAvailable, FSKSUPPRESSHARDBREAKBEFOREFIRSTPARA fsksuppresshardbreakbeforefirstparaIn, FSFMTR& fsfmtr, IntPtr& pfsFloatContent, IntPtr& pbrkrecOut, Int32& durFloaterWidth, Int32& dvrFloaterHeight, FSBBOX& fsbbox, Int32& cPolygons, Int32& cVertices);
    internal abstract virtual void FormatFloaterContentBottomless(FloaterBaseParaClient paraClient, int fSuppressTopSpace, UInt32 fswdir, int fAtMaxWidth, int durAvailable, int dvrAvailable, FSFMTRBL& fsfmtrbl, IntPtr& pfsFloatContent, Int32& durFloaterWidth, Int32& dvrFloaterHeight, FSBBOX& fsbbox, Int32& cPolygons, Int32& cVertices);
    internal abstract virtual void UpdateBottomlessFloaterContent(FloaterBaseParaClient paraClient, int fSuppressTopSpace, UInt32 fswdir, int fAtMaxWidth, int durAvailable, int dvrAvailable, IntPtr pfsFloatContent, FSFMTRBL& fsfmtrbl, Int32& durFloaterWidth, Int32& dvrFloaterHeight, FSBBOX& fsbbox, Int32& cPolygons, Int32& cVertices);
    internal abstract virtual void GetMCSClientAfterFloater(UInt32 fswdirTrack, MarginCollapsingState mcs, IntPtr& pmcsclientOut);
    internal virtual void GetDvrUsedForFloater(UInt32 fswdirTrack, MarginCollapsingState mcs, int dvrDisplaced, Int32& dvrUsed);
}
internal class MS.Internal.PtsHost.FloaterObject : AttachedObject {
    internal FloaterObject(int dcp, FloaterParagraph para);
}
internal class MS.Internal.PtsHost.FloaterParaClient : FloaterBaseParaClient {
    private FSRECT _contentRect;
    private FSRECT _paddingRect;
    private PageContext _pageContextOfThisPage;
    unknown IntPtr SubpageHandle {internal set; }
    internal FSRECT ContentRect { get; }
    internal ReadOnlyCollection`1<ParagraphResult> FloatingElementResults { get; }
    internal FloaterParaClient(FloaterParagraph paragraph);
    public virtual void Dispose();
    protected virtual void OnArrange();
    internal virtual void UpdateViewport(FSRECT& viewport);
    internal virtual void ArrangeFloater(FSRECT rcFloater, FSRECT rcHostPara, UInt32 fswdirParent, PageContext pageContext);
    internal virtual IInputElement InputHitTest(FSPOINT pt);
    internal virtual List`1<Rect> GetRectangles(ContentElement e, int start, int length);
    internal virtual void ValidateVisual(FSKUPDATE fskupdInherited);
    internal virtual ParagraphResult CreateParagraphResult();
    internal virtual TextContentRange GetTextContentRange();
    private ReadOnlyCollection`1<ParagraphResult> GetChildrenParagraphResults(Boolean& hasTextContent);
    internal ReadOnlyCollection`1<ColumnResult> GetColumnResults(Boolean& hasTextContent);
    internal ReadOnlyCollection`1<ParagraphResult> GetParagraphResultsFromColumn(IntPtr pfstrack, Vector parentOffset, Boolean& hasTextContent);
    internal TextContentRange GetTextContentRangeFromColumn(IntPtr pfstrack);
    internal Geometry GetTightBoundingGeometryFromTextPositions(ReadOnlyCollection`1<ColumnResult> columns, ReadOnlyCollection`1<ParagraphResult> floatingElements, ITextPointer startPosition, ITextPointer endPosition, Rect visibleRect);
    internal void set_SubpageHandle(IntPtr value);
    internal FSRECT get_ContentRect();
    internal ReadOnlyCollection`1<ParagraphResult> get_FloatingElementResults();
    private bool IsFloaterHorizontallyCentered(FSRECT rcFloater, FSRECT rcHostPara);
}
internal class MS.Internal.PtsHost.FloaterParagraph : FloaterBaseParagraph {
    private BaseParagraph _mainTextSegment;
    private HorizontalAlignment HorizontalAlignment { get; }
    private WrapDirection WrapDirection { get; }
    internal FloaterParagraph(TextElement element, StructuralCache structuralCache);
    internal virtual void UpdGetParaChange(FSKCHANGE& fskch, Int32& fNoFurtherChanges);
    public virtual void Dispose();
    internal virtual void CreateParaclient(IntPtr& paraClientHandle);
    internal virtual void CollapseMargin(BaseParaClient paraClient, MarginCollapsingState mcs, UInt32 fswdir, bool suppressTopSpace, Int32& dvr);
    internal virtual void GetFloaterProperties(UInt32 fswdirTrack, FSFLOATERPROPS& fsfloaterprops);
    internal virtual void FormatFloaterContentFinite(FloaterBaseParaClient paraClient, IntPtr pbrkrecIn, int fBRFromPreviousPage, IntPtr footnoteRejector, int fEmptyOk, int fSuppressTopSpace, UInt32 fswdir, int fAtMaxWidth, int durAvailable, int dvrAvailable, FSKSUPPRESSHARDBREAKBEFOREFIRSTPARA fsksuppresshardbreakbeforefirstparaIn, FSFMTR& fsfmtr, IntPtr& pfsFloatContent, IntPtr& pbrkrecOut, Int32& durFloaterWidth, Int32& dvrFloaterHeight, FSBBOX& fsbbox, Int32& cPolygons, Int32& cVertices);
    internal virtual void FormatFloaterContentBottomless(FloaterBaseParaClient paraClient, int fSuppressTopSpace, UInt32 fswdir, int fAtMaxWidth, int durAvailable, int dvrAvailable, FSFMTRBL& fsfmtrbl, IntPtr& pfsFloatContent, Int32& durFloaterWidth, Int32& dvrFloaterHeight, FSBBOX& fsbbox, Int32& cPolygons, Int32& cVertices);
    internal virtual void UpdateBottomlessFloaterContent(FloaterBaseParaClient paraClient, int fSuppressTopSpace, UInt32 fswdir, int fAtMaxWidth, int durAvailable, int dvrAvailable, IntPtr pfsFloatContent, FSFMTRBL& fsfmtrbl, Int32& durFloaterWidth, Int32& dvrFloaterHeight, FSBBOX& fsbbox, Int32& cPolygons, Int32& cVertices);
    internal virtual void GetMCSClientAfterFloater(UInt32 fswdirTrack, MarginCollapsingState mcs, IntPtr& pmcsclientOut);
    internal virtual void ClearUpdateInfo();
    internal virtual bool InvalidateStructure(int startPosition);
    internal virtual void InvalidateFormatCache();
    internal void UpdateSegmentLastFormatPositions();
    private void AdjustDurAvailable(double specifiedWidth, Int32& durAvailable, Int32& subpageWidth);
    private void CreateSubpageFiniteHelper(PtsContext ptsContext, IntPtr brParaIn, int fFromPreviousPage, IntPtr nSeg, IntPtr pFtnRej, int fEmptyOk, int fSuppressTopSpace, UInt32 fswdir, int lWidth, int lHeight, FSRECT& rcMargin, int cColumns, FSCOLUMNINFO[] columnInfoCollection, int fApplyColumnBalancing, FSKSUPPRESSHARDBREAKBEFOREFIRSTPARA fsksuppresshardbreakbeforefirstparaIn, FSFMTR& fsfmtr, IntPtr& pSubPage, IntPtr& brParaOut, Int32& dvrUsed, FSBBOX& fsBBox, IntPtr& pfsMcsClient, Int32& topSpace);
    private void CreateSubpageBottomlessHelper(PtsContext ptsContext, IntPtr nSeg, int fSuppressTopSpace, UInt32 fswdir, int lWidth, int urMargin, int durMargin, int vrMargin, int cColumns, FSCOLUMNINFO[] columnInfoCollection, FSFMTRBL& pfsfmtr, IntPtr& ppSubPage, Int32& pdvrUsed, FSBBOX& pfsBBox, IntPtr& pfsMcsClient, Int32& pTopSpace, Int32& fPageBecomesUninterruptible);
    private void InvalidateMainTextSegment();
    private HorizontalAlignment get_HorizontalAlignment();
    private WrapDirection get_WrapDirection();
    private double CalculateWidth(double spaceAvailable);
    private bool IsFloaterRejected(bool fAtMaxWidth, double availableSpace);
}
internal class MS.Internal.PtsHost.FloatingRun : TextHidden {
    private bool _figure;
    internal bool Figure { get; }
    internal FloatingRun(int length, bool figure);
    internal bool get_Figure();
}
internal class MS.Internal.PtsHost.FlowDocumentPage : DocumentPage {
    private PtsPage _ptsPage;
    private StructuralCache _structuralCache;
    private int _formattedLinesCount;
    private TextDocumentView _textView;
    private Size _partitionSize;
    private Thickness _pageMargin;
    private int _disposed;
    private TextPointer _DependentMax;
    private bool _visualNeedsUpdate;
    private double _lastFormatWidth;
    public Visual Visual { get; }
    internal IEnumerator`1<IInputElement> HostedElementsCore { get; }
    internal ReadOnlyCollection`1<ParagraphResult> FloatingElementResults { get; }
    internal bool UseSizingWorkaroundForTextBox { get; internal set; }
    internal Thickness Margin { get; }
    internal bool IsDisposed { get; }
    internal Size ContentSize { get; }
    internal bool FinitePage { get; }
    internal PageContext PageContext { get; }
    internal bool IncrementalUpdate { get; }
    internal StructuralCache StructuralCache { get; }
    internal int FormattedLinesCount { get; }
    internal bool IsLayoutDataValid { get; }
    internal TextPointer DependentMax { get; internal set; }
    internal Rect Viewport { get; }
    private PageVisual PageVisual { get; }
    private IEnumerator`1<IInputElement> System.Windows.IContentHost.HostedElements { get; }
    internal FlowDocumentPage(StructuralCache structuralCache);
    protected virtual override void Finalize();
    public virtual void Dispose();
    public virtual Visual get_Visual();
    internal void FormatBottomless(Size pageSize, Thickness pageMargin);
    internal PageBreakRecord FormatFinite(Size pageSize, Thickness pageMargin, PageBreakRecord breakRecord);
    internal void Arrange(Size partitionSize);
    internal void ForceReformat();
    internal IInputElement InputHitTestCore(Point point);
    internal ReadOnlyCollection`1<Rect> GetRectanglesCore(ContentElement child, bool isLimitedToTextView);
    internal IEnumerator`1<IInputElement> get_HostedElementsCore();
    internal ReadOnlyCollection`1<ParagraphResult> get_FloatingElementResults();
    internal void OnChildDesiredSizeChangedCore(UIElement child);
    internal ReadOnlyCollection`1<ColumnResult> GetColumnResults(Boolean& hasTextContent);
    internal TextContentRange GetTextContentRangeFromColumn(IntPtr pfstrack);
    internal ReadOnlyCollection`1<ParagraphResult> GetParagraphResultsFromColumn(IntPtr pfstrack, Vector parentOffset, Boolean& hasTextContent);
    internal void OnFormatLine();
    internal void EnsureValidVisuals();
    internal void UpdateViewport(FSRECT& viewport, bool drawBackground);
    internal bool get_UseSizingWorkaroundForTextBox();
    internal void set_UseSizingWorkaroundForTextBox(bool value);
    internal Thickness get_Margin();
    internal bool get_IsDisposed();
    internal Size get_ContentSize();
    internal bool get_FinitePage();
    internal PageContext get_PageContext();
    internal bool get_IncrementalUpdate();
    internal StructuralCache get_StructuralCache();
    internal int get_FormattedLinesCount();
    internal bool get_IsLayoutDataValid();
    internal TextPointer get_DependentMax();
    internal void set_DependentMax(TextPointer value);
    internal Rect get_Viewport();
    private void Dispose(bool disposing);
    private void UpdateVisual();
    private void OnBeforeFormatPage();
    private void OnAfterFormatPage();
    private TextPointer FindElementPosition(IInputElement e, bool isLimitedToTextView);
    private void DestroyVisualLinks(ContainerVisual visual);
    private void ValidateTextView();
    private TextDocumentView GetTextView();
    private PageVisual get_PageVisual();
    private sealed virtual override object System.IServiceProvider.GetService(Type serviceType);
    private sealed virtual override IInputElement System.Windows.IContentHost.InputHitTest(Point point);
    private sealed virtual override ReadOnlyCollection`1<Rect> System.Windows.IContentHost.GetRectangles(ContentElement child);
    private sealed virtual override IEnumerator`1<IInputElement> System.Windows.IContentHost.get_HostedElements();
    private sealed virtual override void System.Windows.IContentHost.OnChildDesiredSizeChanged(UIElement child);
}
internal class MS.Internal.PtsHost.InlineObject : EmbeddedObject {
    private UIElementIsland _uiElementIsland;
    private TextParagraph _para;
    internal DependencyObject Element { get; }
    internal InlineObject(int dcp, UIElementIsland uiElementIsland, TextParagraph para);
    internal virtual void Dispose();
    internal virtual void Update(EmbeddedObject newObject);
    internal virtual DependencyObject get_Element();
}
internal class MS.Internal.PtsHost.InlineObjectRun : TextEmbeddedObject {
    private int _cch;
    private TextRunProperties _textProps;
    private TextParagraph _host;
    private InlineUIContainer _inlineUIContainer;
    public CharacterBufferReference CharacterBufferReference { get; }
    public int Length { get; }
    public TextRunProperties Properties { get; }
    public LineBreakCondition BreakBefore { get; }
    public LineBreakCondition BreakAfter { get; }
    public bool HasFixedSize { get; }
    internal UIElementIsland UIElementIsland { get; }
    internal InlineObjectRun(int cch, UIElement element, TextRunProperties textProps, TextParagraph host);
    public virtual TextEmbeddedObjectMetrics Format(double remainingParagraphWidth);
    public virtual Rect ComputeBoundingBox(bool rightToLeft, bool sideways);
    public virtual void Draw(DrawingContext drawingContext, Point origin, bool rightToLeft, bool sideways);
    public virtual CharacterBufferReference get_CharacterBufferReference();
    public virtual int get_Length();
    public virtual TextRunProperties get_Properties();
    public virtual LineBreakCondition get_BreakBefore();
    public virtual LineBreakCondition get_BreakAfter();
    public virtual bool get_HasFixedSize();
    internal UIElementIsland get_UIElementIsland();
}
internal interface MS.Internal.PtsHost.ISegment {
    public abstract virtual void GetFirstPara(Int32& successful, IntPtr& firstParaName);
    public abstract virtual void GetNextPara(BaseParagraph currentParagraph, Int32& found, IntPtr& nextParaName);
    public abstract virtual void UpdGetFirstChangeInSegment(Int32& fFound, Int32& fChangeFirst, IntPtr& nmpBeforeChange);
}
internal class MS.Internal.PtsHost.Line : LineBase {
    private TextFormatterHost _host;
    private int _cpPara;
    private FormattingContext _formattingContext;
    private TextLine _line;
    private IList`1<TextSpan`1<TextRun>> _runs;
    private int _dcp;
    private double _wrappingWidth;
    private double _trackWidth;
    private bool _mirror;
    private double _indent;
    private TextAlignment _textAlignment;
    internal int Start { get; }
    internal int Width { get; }
    internal int Height { get; }
    internal int Baseline { get; }
    internal bool EndOfParagraph { get; }
    internal int SafeLength { get; }
    internal int ActualLength { get; }
    internal int ContentLength { get; }
    internal int DependantLength { get; }
    internal bool IsTruncated { get; }
    internal FSFLRES FormattingResult { get; }
    private bool HasLineBreak { get; }
    private bool IsUOffsetAdjusted { get; }
    private bool IsWidthAdjusted { get; }
    private bool ShowEllipses { get; }
    private TextParagraph TextParagraph { get; }
    internal Line(TextFormatterHost host, TextParaClient paraClient, int cpPara);
    public virtual void Dispose();
    internal void GetDvrSuppressibleBottomSpace(Int32& dvrSuppressible);
    internal void GetDurFigureAnchor(FigureParagraph paraFigure, UInt32 fswdir, Int32& dur);
    internal virtual TextRun GetTextRun(int dcp);
    internal virtual TextSpan`1<CultureSpecificCharacterBufferRange> GetPrecedingText(int dcp);
    internal virtual int GetTextEffectCharacterIndexFromTextSourceCharacterIndex(int dcp);
    internal void Format(FormattingContext ctx, int dcp, int width, int trackWidth, TextParagraphProperties lineProps, TextLineBreak textLineBreak);
    internal Size MeasureChild(InlineObjectRun inlineObject);
    internal ContainerVisual CreateVisual();
    internal Rect GetBoundsFromTextPosition(int textPosition, FlowDirection& flowDirection);
    internal List`1<Rect> GetRangeBounds(int cp, int cch, double xOffset, double yOffset);
    internal TextLineBreak GetTextLineBreak();
    internal CharacterHit GetTextPositionFromDistance(int urDistance);
    internal IInputElement InputHitTest(int urOffset);
    internal int GetEllipsesLength();
    internal void GetGlyphRuns(List`1<GlyphRun> glyphRuns, int dcpStart, int dcpEnd);
    internal CharacterHit GetNextCaretCharacterHit(CharacterHit index);
    internal CharacterHit GetPreviousCaretCharacterHit(CharacterHit index);
    internal CharacterHit GetBackspaceCaretCharacterHit(CharacterHit index);
    internal bool IsAtCaretCharacterHit(CharacterHit charHit);
    internal int get_Start();
    internal int get_Width();
    internal int get_Height();
    internal int get_Baseline();
    internal bool get_EndOfParagraph();
    internal int get_SafeLength();
    internal int get_ActualLength();
    internal int get_ContentLength();
    internal int get_DependantLength();
    internal bool get_IsTruncated();
    internal FSFLRES get_FormattingResult();
    private bool HasInlineObjects();
    private Rect GetBoundsFromPosition(int cp, int cch, FlowDirection& flowDirection);
    private TextCollapsingProperties GetCollapsingProps(double wrappingWidth, LineProperties paraProperties);
    private void AddGlyphRunRecursive(Drawing drawing, IList glyphRunsCollection, Int32& cchGlyphRuns);
    internal int CalculateUOffsetShift();
    private bool get_HasLineBreak();
    private bool get_IsUOffsetAdjusted();
    private bool get_IsWidthAdjusted();
    private bool get_ShowEllipses();
    private TextParagraph get_TextParagraph();
}
internal abstract class MS.Internal.PtsHost.LineBase : UnmanagedHandle {
    protected BaseParaClient _paraClient;
    protected bool _hasFigures;
    protected bool _hasFloaters;
    protected static int _syntheticCharacterLength;
    protected static int _elementEdgeCharacterLength;
    internal static int SyntheticCharacterLength { get; }
    internal bool HasFigures { get; }
    internal bool HasFloaters { get; }
    internal LineBase(BaseParaClient paraClient);
    private static LineBase();
    internal abstract virtual TextRun GetTextRun(int dcp);
    internal abstract virtual TextSpan`1<CultureSpecificCharacterBufferRange> GetPrecedingText(int dcp);
    internal abstract virtual int GetTextEffectCharacterIndexFromTextSourceCharacterIndex(int dcp);
    protected TextRun HandleText(StaticTextPointer position);
    protected TextRun HandleElementStartEdge(StaticTextPointer position);
    protected TextRun HandleElementEndEdge(StaticTextPointer position);
    protected TextRun HandleEmbeddedObject(int dcp, StaticTextPointer position);
    internal static int get_SyntheticCharacterLength();
    internal bool get_HasFigures();
    internal bool get_HasFloaters();
}
internal class MS.Internal.PtsHost.LineBreakpoint : UnmanagedHandle {
    private TextBreakpoint _textBreakpoint;
    private OptimalBreakSession _optimalBreakSession;
    internal OptimalBreakSession OptimalBreakSession { get; }
    internal LineBreakpoint(OptimalBreakSession optimalBreakSession, TextBreakpoint textBreakpoint);
    public virtual void Dispose();
    internal OptimalBreakSession get_OptimalBreakSession();
}
internal class MS.Internal.PtsHost.LineBreakRecord : UnmanagedHandle {
    private TextLineBreak _textLineBreak;
    internal TextLineBreak TextLineBreak { get; }
    internal LineBreakRecord(PtsContext ptsContext, TextLineBreak textLineBreak);
    public virtual void Dispose();
    internal LineBreakRecord Clone();
    internal TextLineBreak get_TextLineBreak();
}
internal class MS.Internal.PtsHost.LineBreakRun : TextEndOfLine {
    internal FSFLRES BreakReason;
    internal LineBreakRun(int length, FSFLRES breakReason);
}
internal class MS.Internal.PtsHost.LineVisual : DrawingVisual {
    internal double WidthIncludingTrailingWhitespace;
    internal DrawingContext Open();
}
internal class MS.Internal.PtsHost.ListItemParagraph : ContainerParagraph {
    internal ListItemParagraph(DependencyObject element, StructuralCache structuralCache);
}
internal class MS.Internal.PtsHost.ListMarkerLine : LineBase {
    private TextFormatterHost _host;
    internal ListMarkerLine(TextFormatterHost host, ListParaClient paraClient);
    internal virtual TextRun GetTextRun(int dcp);
    internal virtual TextSpan`1<CultureSpecificCharacterBufferRange> GetPrecedingText(int dcp);
    internal virtual int GetTextEffectCharacterIndexFromTextSourceCharacterIndex(int dcp);
    internal void FormatAndDrawVisual(DrawingContext ctx, LineProperties lineProps, int ur, int vrBaseline);
}
internal class MS.Internal.PtsHost.ListMarkerSourceInfo : object {
    private static char NumberSuffix;
    private static string DecimalNumerics;
    private static string LowerLatinNumerics;
    private static string UpperLatinNumerics;
    private static string LargestRomanMarkerUpper;
    private static string LargestRomanMarkerLower;
    private static String[][] RomanNumerics;
    private static Int32[] RomanNumericSizeIncrements;
    private static ListMarkerSourceInfo();
    internal static Thickness CalculatePadding(List list, double lineHeight, double pixelsPerDip);
    private static FormattedText GetFormattedMarker(List list, double pixelsPerDip);
    private static string ConvertNumberToString(int number, bool oneBased, string numericSymbols);
    private static string GetStringForLargestRomanMarker(int startIndex, int highestIndex, bool uppercase);
    private static int GetIndexForLargestRomanMarker(int startIndex, int highestIndex);
    private static string ConvertNumberToRomanString(int number, bool uppercase);
    private static void AddRomanNumeric(StringBuilder builder, int number, string oneFiveTen);
    private static bool IsKnownSymbolMarkerStyle(TextMarkerStyle markerStyle);
    private static bool IsKnownIndexMarkerStyle(TextMarkerStyle markerStyle);
}
internal class MS.Internal.PtsHost.ListParaClient : ContainerParaClient {
    internal ListParaClient(ListParagraph paragraph);
    internal virtual void ValidateVisual(FSKUPDATE fskupdInherited);
}
internal class MS.Internal.PtsHost.ListParagraph : ContainerParagraph {
    internal ListParagraph(DependencyObject element, StructuralCache structuralCache);
    internal virtual void CreateParaclient(IntPtr& paraClientHandle);
    protected virtual BaseParagraph GetParagraph(ITextPointer textPointer, bool fEmptyOk);
}
internal class MS.Internal.PtsHost.MarginCollapsingState : UnmanagedHandle {
    private int _maxPositive;
    private int _minNegative;
    internal int Margin { get; }
    internal MarginCollapsingState(PtsContext ptsContext, int margin);
    private MarginCollapsingState(MarginCollapsingState mcs);
    internal static void CollapseTopMargin(PtsContext ptsContext, MbpInfo mbp, MarginCollapsingState mcsCurrent, MarginCollapsingState& mcsNew, Int32& margin);
    internal static void CollapseBottomMargin(PtsContext ptsContext, MbpInfo mbp, MarginCollapsingState mcsCurrent, MarginCollapsingState& mcsNew, Int32& margin);
    internal MarginCollapsingState Clone();
    internal bool IsEqual(MarginCollapsingState mcs);
    internal void Collapse(MarginCollapsingState mcs);
    internal int get_Margin();
}
internal class MS.Internal.PtsHost.MbpInfo : object {
    private Thickness _margin;
    private Thickness _border;
    private Thickness _padding;
    private Brush _borderBrush;
    private static MbpInfo _empty;
    internal int MBPLeft { get; }
    internal int MBPRight { get; }
    internal int MBPTop { get; }
    internal int MBPBottom { get; }
    internal int BPLeft { get; }
    internal int BPRight { get; }
    internal int BPTop { get; }
    internal int BPBottom { get; }
    internal int BorderLeft { get; }
    internal int BorderRight { get; }
    internal int BorderTop { get; }
    internal int BorderBottom { get; }
    internal int MarginLeft { get; }
    internal int MarginRight { get; }
    internal int MarginTop { get; }
    internal int MarginBottom { get; }
    internal Thickness Margin { get; internal set; }
    internal Thickness Border { get; internal set; }
    internal Thickness Padding { get; internal set; }
    internal Brush BorderBrush { get; }
    private bool IsPaddingAuto { get; }
    private bool IsMarginAuto { get; }
    private static MbpInfo();
    private MbpInfo(TextElement block);
    internal static MbpInfo FromElement(DependencyObject o, double pixelsPerDip);
    internal void MirrorMargin();
    internal void MirrorBP();
    private static void ReverseFlowDirection(Thickness& thickness);
    private static void ResolveAutoMargin(MbpInfo mbp, DependencyObject o, double lineHeight);
    private static void ResolveAutoPadding(MbpInfo mbp, DependencyObject o, double lineHeight, double pixelsPerDip);
    internal int get_MBPLeft();
    internal int get_MBPRight();
    internal int get_MBPTop();
    internal int get_MBPBottom();
    internal int get_BPLeft();
    internal int get_BPRight();
    internal int get_BPTop();
    internal int get_BPBottom();
    internal int get_BorderLeft();
    internal int get_BorderRight();
    internal int get_BorderTop();
    internal int get_BorderBottom();
    internal int get_MarginLeft();
    internal int get_MarginRight();
    internal int get_MarginTop();
    internal int get_MarginBottom();
    internal Thickness get_Margin();
    internal void set_Margin(Thickness value);
    internal Thickness get_Border();
    internal void set_Border(Thickness value);
    internal Thickness get_Padding();
    internal void set_Padding(Thickness value);
    internal Brush get_BorderBrush();
    private bool get_IsPaddingAuto();
    private bool get_IsMarginAuto();
}
internal class MS.Internal.PtsHost.OptimalBreakSession : UnmanagedHandle {
    private TextParagraphCache _textParagraphCache;
    private TextParagraph _textParagraph;
    private TextParaClient _textParaClient;
    private OptimalTextSource _optimalTextSource;
    internal TextParagraphCache TextParagraphCache { get; }
    internal TextParagraph TextParagraph { get; }
    internal TextParaClient TextParaClient { get; }
    internal OptimalTextSource OptimalTextSource { get; }
    internal OptimalBreakSession(TextParagraph textParagraph, TextParaClient textParaClient, TextParagraphCache TextParagraphCache, OptimalTextSource optimalTextSource);
    public virtual void Dispose();
    internal TextParagraphCache get_TextParagraphCache();
    internal TextParagraph get_TextParagraph();
    internal TextParaClient get_TextParaClient();
    internal OptimalTextSource get_OptimalTextSource();
}
internal class MS.Internal.PtsHost.OptimalTextSource : LineBase {
    private TextFormatterHost _host;
    private TextRunCache _runCache;
    private int _durTrack;
    private int _cpPara;
    internal OptimalTextSource(TextFormatterHost host, int cpPara, int durTrack, TextParaClient paraClient, TextRunCache runCache);
    public virtual void Dispose();
    internal virtual TextRun GetTextRun(int dcp);
    internal virtual TextSpan`1<CultureSpecificCharacterBufferRange> GetPrecedingText(int dcp);
    internal virtual int GetTextEffectCharacterIndexFromTextSourceCharacterIndex(int dcp);
    internal FSFLRES GetFormatResultForBreakpoint(int dcp, TextBreakpoint textBreakpoint);
    internal Size MeasureChild(InlineObjectRun inlineObject);
}
internal class MS.Internal.PtsHost.PageBreakRecord : object {
    private SecurityCriticalDataForSet`1<IntPtr> _br;
    private int _pageNumber;
    private WeakReference _ptsContext;
    private int _disposed;
    internal IntPtr BreakRecord { get; }
    internal int PageNumber { get; }
    internal PageBreakRecord(PtsContext ptsContext, SecurityCriticalDataForSet`1<IntPtr> br, int pageNumber);
    protected virtual override void Finalize();
    public sealed virtual void Dispose();
    internal IntPtr get_BreakRecord();
    internal int get_PageNumber();
    private void Dispose(bool disposing);
}
internal class MS.Internal.PtsHost.PageContext : object {
    private List`1<BaseParaClient> _floatingElementList;
    private FSRECT _pageRect;
    internal FSRECT PageRect { get; internal set; }
    internal List`1<BaseParaClient> FloatingElementList { get; }
    internal FSRECT get_PageRect();
    internal void set_PageRect(FSRECT value);
    internal List`1<BaseParaClient> get_FloatingElementList();
    internal void AddFloatingParaClient(BaseParaClient floatingElement);
    internal void RemoveFloatingParaClient(BaseParaClient floatingElement);
}
internal class MS.Internal.PtsHost.PageVisual : DrawingVisual {
    private WeakReference _owner;
    private Brush _backgroundBrush;
    private Rect _renderBounds;
    internal Visual Child { get; internal set; }
    private IEnumerator`1<IInputElement> System.Windows.IContentHost.HostedElements { get; }
    internal PageVisual(FlowDocumentPage owner);
    internal void DrawBackground(Brush backgroundBrush, Rect renderBounds);
    internal Visual get_Child();
    internal void set_Child(Visual value);
    internal void ClearDrawingContext();
    private sealed virtual override IInputElement System.Windows.IContentHost.InputHitTest(Point point);
    private sealed virtual override ReadOnlyCollection`1<Rect> System.Windows.IContentHost.GetRectangles(ContentElement child);
    private sealed virtual override IEnumerator`1<IInputElement> System.Windows.IContentHost.get_HostedElements();
    private sealed virtual override void System.Windows.IContentHost.OnChildDesiredSizeChanged(UIElement child);
}
internal class MS.Internal.PtsHost.ParagraphBreakRun : TextEndOfParagraph {
    internal FSFLRES BreakReason;
    internal ParagraphBreakRun(int length, FSFLRES breakReason);
}
internal class MS.Internal.PtsHost.ParagraphElementVisual : ContainerVisual {
}
internal class MS.Internal.PtsHost.ParagraphVisual : DrawingVisual {
    private Brush _backgroundBrush;
    private Brush _borderBrush;
    private Thickness _borderThickness;
    private Rect _renderBounds;
    internal void DrawBackgroundAndBorder(Brush backgroundBrush, Brush borderBrush, Thickness borderThickness, Rect renderBounds, bool isFirstChunk, bool isLastChunk);
    internal void DrawBackgroundAndBorderIntoContext(DrawingContext dc, Brush backgroundBrush, Brush borderBrush, Thickness borderThickness, Rect renderBounds, bool isFirstChunk, bool isLastChunk);
}
internal class MS.Internal.PtsHost.PtsCache : object {
    private List`1<ContextDesc> _contextPool;
    private List`1<PtsContext> _releaseQueue;
    private object _lock;
    private int _disposed;
    private PtsCache(Dispatcher dispatcher);
    internal static PtsHost AcquireContext(PtsContext ptsContext, TextFormattingMode textFormattingMode);
    internal static void ReleaseContext(PtsContext ptsContext);
    internal static void GetFloaterHandlerInfo(PtsHost ptsHost, IntPtr pobjectinfo);
    internal static void GetTableObjHandlerInfo(PtsHost ptsHost, IntPtr pobjectinfo);
    internal static bool IsDisposed();
    protected virtual override void Finalize();
    private PtsHost AcquireContextCore(PtsContext ptsContext, TextFormattingMode textFormattingMode);
    private void ReleaseContextCore(PtsContext ptsContext);
    private void GetFloaterHandlerInfoCore(PtsHost ptsHost, IntPtr pobjectinfo);
    private void GetTableObjHandlerInfoCore(PtsHost ptsHost, IntPtr pobjectinfo);
    private void Shutdown();
    private void DestroyPTSContexts();
    private object OnPtsContextReleased(object args);
    private void OnPtsContextReleased(bool cleanContextPool);
    private IntPtr CreatePTSContext(int index, TextFormattingMode textFormattingMode);
    private void InitGenericInfo(PtsHost ptsHost, IntPtr clientData, IntPtr installedObjects, int installedObjectsCount, FSCONTEXTINFO& contextInfo);
    private void InitInstalledObjectsInfo(PtsHost ptsHost, FSIMETHODS& subtrackParaInfo, FSIMETHODS& subpageParaInfo, IntPtr& installedObjects, Int32& installedObjectsCount);
    private void InitFloaterObjInfo(PtsHost ptsHost, FSFLOATERINIT& floaterInit);
    private void InitTableObjInfo(PtsHost ptsHost, FSTABLEOBJINIT& tableobjInit);
}
internal class MS.Internal.PtsHost.PtsContext : DispatcherObject {
    private HandleIndex[] _unmanagedHandles;
    private ArrayList _pages;
    private ArrayList _pageBreakRecords;
    private Exception _callbackException;
    private PtsHost _ptsHost;
    private bool _isOptimalParagraphEnabled;
    private TextFormatter _textFormatter;
    private int _disposed;
    private bool _disposeCompleted;
    private static int _defaultHandlesCapacity;
    internal bool Disposed { get; }
    internal IntPtr Context { get; }
    internal bool IsOptimalParagraphEnabled { get; }
    internal TextFormatter TextFormatter { get; internal set; }
    internal Exception CallbackException { get; internal set; }
    internal PtsContext(bool isOptimalParagraphEnabled, TextFormattingMode textFormattingMode);
    public sealed virtual void Dispose();
    internal IntPtr CreateHandle(object obj);
    internal void ReleaseHandle(IntPtr handle);
    internal bool IsValidHandle(IntPtr handle);
    internal object HandleToObject(IntPtr handle);
    internal void Enter();
    internal void Leave();
    internal void OnPageCreated(SecurityCriticalDataForSet`1<IntPtr> ptsPage);
    internal void OnPageDisposed(SecurityCriticalDataForSet`1<IntPtr> ptsPage, bool disposing, bool enterContext);
    internal void OnPageBreakRecordCreated(SecurityCriticalDataForSet`1<IntPtr> br);
    internal void OnPageBreakRecordDisposed(SecurityCriticalDataForSet`1<IntPtr> br, bool disposing);
    internal bool get_Disposed();
    internal IntPtr get_Context();
    internal bool get_IsOptimalParagraphEnabled();
    internal TextFormatter get_TextFormatter();
    internal void set_TextFormatter(TextFormatter value);
    internal Exception get_CallbackException();
    internal void set_CallbackException(Exception value);
    private void BuildFreeList(int freeIndex);
    private void Resize();
    private object OnDestroyPage(object args);
    private void OnDestroyPage(SecurityCriticalDataForSet`1<IntPtr> ptsPage, bool enterContext);
    private object OnDestroyBreakRecord(object args);
}
internal static class MS.Internal.PtsHost.PtsHelper : object {
    internal static void UpdateMirroringTransform(FlowDirection parentFD, FlowDirection childFD, ContainerVisual visualChild, double width);
    internal static void ClipChildrenToRect(ContainerVisual visual, Rect rect);
    internal static void UpdateFloatingElementVisuals(ContainerVisual visual, List`1<BaseParaClient> floatingElementList);
    internal static void ArrangeTrack(PtsContext ptsContext, FSTRACKDESCRIPTION& trackDesc, UInt32 fswdirTrack);
    internal static void ArrangeParaList(PtsContext ptsContext, FSRECT rcTrackContent, FSPARADESCRIPTION[] arrayParaDesc, UInt32 fswdirTrack);
    internal static void UpdateTrackVisuals(PtsContext ptsContext, VisualCollection visualCollection, FSKUPDATE fskupdInherited, FSTRACKDESCRIPTION& trackDesc);
    internal static void UpdateParaListVisuals(PtsContext ptsContext, VisualCollection visualCollection, FSKUPDATE fskupdInherited, FSPARADESCRIPTION[] arrayParaDesc);
    internal static void UpdateViewportTrack(PtsContext ptsContext, FSTRACKDESCRIPTION& trackDesc, FSRECT& viewport);
    internal static void UpdateViewportParaList(PtsContext ptsContext, FSPARADESCRIPTION[] arrayParaDesc, FSRECT& viewport);
    internal static IInputElement InputHitTestTrack(PtsContext ptsContext, FSPOINT pt, FSTRACKDESCRIPTION& trackDesc);
    internal static IInputElement InputHitTestParaList(PtsContext ptsContext, FSPOINT pt, FSRECT& rcTrack, FSPARADESCRIPTION[] arrayParaDesc);
    internal static List`1<Rect> GetRectanglesInTrack(PtsContext ptsContext, ContentElement e, int start, int length, FSTRACKDESCRIPTION& trackDesc);
    internal static List`1<Rect> GetRectanglesInParaList(PtsContext ptsContext, ContentElement e, int start, int length, FSPARADESCRIPTION[] arrayParaDesc);
    internal static List`1<Rect> OffsetRectangleList(List`1<Rect> rectangleList, double xOffset, double yOffset);
    internal static void SectionListFromPage(PtsContext ptsContext, IntPtr page, FSPAGEDETAILS& pageDetails, FSSECTIONDESCRIPTION[]& arraySectionDesc);
    internal static void TrackListFromSubpage(PtsContext ptsContext, IntPtr subpage, FSSUBPAGEDETAILS& subpageDetails, FSTRACKDESCRIPTION[]& arrayTrackDesc);
    internal static void TrackListFromSection(PtsContext ptsContext, IntPtr section, FSSECTIONDETAILS& sectionDetails, FSTRACKDESCRIPTION[]& arrayTrackDesc);
    internal static void ParaListFromTrack(PtsContext ptsContext, IntPtr track, FSTRACKDETAILS& trackDetails, FSPARADESCRIPTION[]& arrayParaDesc);
    internal static void ParaListFromSubtrack(PtsContext ptsContext, IntPtr subtrack, FSSUBTRACKDETAILS& subtrackDetails, FSPARADESCRIPTION[]& arrayParaDesc);
    internal static void LineListSimpleFromTextPara(PtsContext ptsContext, IntPtr para, FSTEXTDETAILSFULL& textDetails, FSLINEDESCRIPTIONSINGLE[]& arrayLineDesc);
    internal static void LineListCompositeFromTextPara(PtsContext ptsContext, IntPtr para, FSTEXTDETAILSFULL& textDetails, FSLINEDESCRIPTIONCOMPOSITE[]& arrayLineDesc);
    internal static void LineElementListFromCompositeLine(PtsContext ptsContext, FSLINEDESCRIPTIONCOMPOSITE& lineDesc, FSLINEELEMENT[]& arrayLineElement);
    internal static void AttachedObjectListFromParagraph(PtsContext ptsContext, IntPtr para, int cAttachedObject, FSATTACHEDOBJECTDESCRIPTION[]& arrayAttachedObjectDesc);
    internal static TextContentRange TextContentRangeFromTrack(PtsContext ptsContext, IntPtr pfstrack);
    internal static double CalculatePageMarginAdjustment(StructuralCache structuralCache, double pageMarginWidth);
    internal static int CalculateColumnCount(ColumnPropertiesGroup columnProperties, double lineHeight, double pageWidth, double pageFontSize, FontFamily pageFontFamily, bool enableColumns);
    internal static void GetColumnMetrics(ColumnPropertiesGroup columnProperties, double pageWidth, double pageFontSize, FontFamily pageFontFamily, bool enableColumns, int cColumns, Double& lineHeight, Double& columnWidth, Double& freeSpace, Double& gapSpace);
    internal static void GetColumnsInfo(ColumnPropertiesGroup columnProperties, double lineHeight, double pageWidth, double pageFontSize, FontFamily pageFontFamily, int cColumns, FSCOLUMNINFO* pfscolinfo, bool enableColumns);
}
internal class MS.Internal.PtsHost.PtsHost : object {
    private PtsContext _ptsContext;
    private SecurityCriticalDataForSet`1<IntPtr> _context;
    private static int _objectContextOffset;
    private static int _customParaId;
    private PtsContext PtsContext { get; }
    internal IntPtr Context { get; internal set; }
    internal static int ContainerParagraphId { get; }
    internal static int SubpageParagraphId { get; }
    internal static int FloaterParagraphId { get; }
    internal static int TableParagraphId { get; }
    private static PtsHost();
    internal void EnterContext(PtsContext ptsContext);
    internal void LeaveContext(PtsContext ptsContext);
    private PtsContext get_PtsContext();
    internal IntPtr get_Context();
    internal void set_Context(IntPtr value);
    internal static int get_ContainerParagraphId();
    internal static int get_SubpageParagraphId();
    internal static int get_FloaterParagraphId();
    internal static int get_TableParagraphId();
    internal void AssertFailed(string arg1, string arg2, int arg3, UInt32 arg4);
    internal int GetFigureProperties(IntPtr pfsclient, IntPtr pfsparaclientFigure, IntPtr nmpFigure, int fInTextLine, UInt32 fswdir, int fBottomUndefined, Int32& dur, Int32& dvr, FSFIGUREPROPS& fsfigprops, Int32& cPolygons, Int32& cVertices, Int32& durDistTextLeft, Int32& durDistTextRight, Int32& dvrDistTextTop, Int32& dvrDistTextBottom);
    internal int GetFigurePolygons(IntPtr pfsclient, IntPtr pfsparaclientFigure, IntPtr nmpFigure, UInt32 fswdir, int ncVertices, int nfspt, Int32* rgcVertices, Int32& ccVertices, FSPOINT* rgfspt, Int32& cfspt, Int32& fWrapThrough);
    internal int CalcFigurePosition(IntPtr pfsclient, IntPtr pfsparaclientFigure, IntPtr nmpFigure, UInt32 fswdir, FSRECT& fsrcPage, FSRECT& fsrcMargin, FSRECT& fsrcTrack, FSRECT& fsrcFigurePreliminary, int fMustPosition, int fInTextLine, Int32& fPushToNextTrack, FSRECT& fsrcFlow, FSRECT& fsrcOverlap, FSBBOX& fsbbox, FSRECT& fsrcSearch);
    internal int FSkipPage(IntPtr pfsclient, IntPtr nms, Int32& fSkip);
    internal int GetPageDimensions(IntPtr pfsclient, IntPtr nms, UInt32& fswdir, Int32& fHeaderFooterAtTopBottom, Int32& durPage, Int32& dvrPage, FSRECT& fsrcMargin);
    internal int GetNextSection(IntPtr pfsclient, IntPtr nmsCur, Int32& fSuccess, IntPtr& nmsNext);
    internal int GetSectionProperties(IntPtr pfsclient, IntPtr nms, Int32& fNewPage, UInt32& fswdir, Int32& fApplyColumnBalancing, Int32& ccol, Int32& cSegmentDefinedColumnSpanAreas, Int32& cHeightDefinedColumnSpanAreas);
    internal int GetJustificationProperties(IntPtr pfsclient, IntPtr* rgnms, int cnms, int fLastSectionNotBroken, Int32& fJustify, FSKALIGNPAGE& fskal, Int32& fCancelAtLastColumn);
    internal int GetMainTextSegment(IntPtr pfsclient, IntPtr nmsSection, IntPtr& nmSegment);
    internal int GetHeaderSegment(IntPtr pfsclient, IntPtr nms, IntPtr pfsbrpagePrelim, UInt32 fswdir, Int32& fHeaderPresent, Int32& fHardMargin, Int32& dvrMaxHeight, Int32& dvrFromEdge, UInt32& fswdirHeader, IntPtr& nmsHeader);
    internal int GetFooterSegment(IntPtr pfsclient, IntPtr nms, IntPtr pfsbrpagePrelim, UInt32 fswdir, Int32& fFooterPresent, Int32& fHardMargin, Int32& dvrMaxHeight, Int32& dvrFromEdge, UInt32& fswdirFooter, IntPtr& nmsFooter);
    internal int UpdGetSegmentChange(IntPtr pfsclient, IntPtr nms, FSKCHANGE& fskch);
    internal int GetSectionColumnInfo(IntPtr pfsclient, IntPtr nms, UInt32 fswdir, int ncol, FSCOLUMNINFO* fscolinfo, Int32& ccol);
    internal int GetSegmentDefinedColumnSpanAreaInfo(IntPtr pfsclient, IntPtr nms, int cAreas, IntPtr* rgnmSeg, Int32* rgcColumns, Int32& cAreasActual);
    internal int GetHeightDefinedColumnSpanAreaInfo(IntPtr pfsclient, IntPtr nms, int cAreas, Int32* rgdvrAreaHeight, Int32* rgcColumns, Int32& cAreasActual);
    internal int GetFirstPara(IntPtr pfsclient, IntPtr nms, Int32& fSuccessful, IntPtr& nmp);
    internal int GetNextPara(IntPtr pfsclient, IntPtr nms, IntPtr nmpCur, Int32& fFound, IntPtr& nmpNext);
    internal int UpdGetFirstChangeInSegment(IntPtr pfsclient, IntPtr nms, Int32& fFound, Int32& fChangeFirst, IntPtr& nmpBeforeChange);
    internal int UpdGetParaChange(IntPtr pfsclient, IntPtr nmp, FSKCHANGE& fskch, Int32& fNoFurtherChanges);
    internal int GetParaProperties(IntPtr pfsclient, IntPtr nmp, FSPAP& fspap);
    internal int CreateParaclient(IntPtr pfsclient, IntPtr nmp, IntPtr& pfsparaclient);
    internal int TransferDisplayInfo(IntPtr pfsclient, IntPtr pfsparaclientOld, IntPtr pfsparaclientNew);
    internal int DestroyParaclient(IntPtr pfsclient, IntPtr pfsparaclient);
    internal int FInterruptFormattingAfterPara(IntPtr pfsclient, IntPtr pfsparaclient, IntPtr nmp, int vr, Int32& fInterruptFormatting);
    internal int GetEndnoteSeparators(IntPtr pfsclient, IntPtr nmsSection, IntPtr& nmsEndnoteSeparator, IntPtr& nmsEndnoteContSeparator, IntPtr& nmsEndnoteContNotice);
    internal int GetEndnoteSegment(IntPtr pfsclient, IntPtr nmsSection, Int32& fEndnotesPresent, IntPtr& nmsEndnotes);
    internal int GetNumberEndnoteColumns(IntPtr pfsclient, IntPtr nms, Int32& ccolEndnote);
    internal int GetEndnoteColumnInfo(IntPtr pfsclient, IntPtr nms, UInt32 fswdir, int ncolEndnote, FSCOLUMNINFO* fscolinfoEndnote, Int32& ccolEndnote);
    internal int GetFootnoteSeparators(IntPtr pfsclient, IntPtr nmsSection, IntPtr& nmsFtnSeparator, IntPtr& nmsFtnContSeparator, IntPtr& nmsFtnContNotice);
    internal int FFootnoteBeneathText(IntPtr pfsclient, IntPtr nms, Int32& fFootnoteBeneathText);
    internal int GetNumberFootnoteColumns(IntPtr pfsclient, IntPtr nms, Int32& ccolFootnote);
    internal int GetFootnoteColumnInfo(IntPtr pfsclient, IntPtr nms, UInt32 fswdir, int ncolFootnote, FSCOLUMNINFO* fscolinfoFootnote, Int32& ccolFootnote);
    internal int GetFootnoteSegment(IntPtr pfsclient, IntPtr nmftn, IntPtr& nmsFootnote);
    internal int GetFootnotePresentationAndRejectionOrder(IntPtr pfsclient, int cFootnotes, IntPtr* rgProposedPresentationOrder, IntPtr* rgProposedRejectionOrder, Int32& fProposedPresentationOrderAccepted, IntPtr* rgFinalPresentationOrder, Int32& fProposedRejectionOrderAccepted, IntPtr* rgFinalRejectionOrder);
    internal int FAllowFootnoteSeparation(IntPtr pfsclient, IntPtr nmftn, Int32& fAllow);
    internal int DuplicateMcsclient(IntPtr pfsclient, IntPtr pmcsclientIn, IntPtr& pmcsclientNew);
    internal int DestroyMcsclient(IntPtr pfsclient, IntPtr pmcsclient);
    internal int FEqualMcsclient(IntPtr pfsclient, IntPtr pmcsclient1, IntPtr pmcsclient2, Int32& fEqual);
    internal int ConvertMcsclient(IntPtr pfsclient, IntPtr pfsparaclient, IntPtr nmp, UInt32 fswdir, IntPtr pmcsclient, int fSuppressTopSpace, Int32& dvr);
    internal int GetObjectHandlerInfo(IntPtr pfsclient, int idobj, IntPtr pObjectInfo);
    internal int CreateParaBreakingSession(IntPtr pfsclient, IntPtr pfsparaclient, IntPtr nmp, int iArea, int fsdcpStart, IntPtr pfsbreakreclineclient, UInt32 fswdir, int urStartTrack, int durTrack, int urPageLeftMargin, IntPtr& ppfsparabreakingsession, Int32& fParagraphJustified);
    internal int DestroyParaBreakingSession(IntPtr pfsclient, IntPtr pfsparabreakingsession);
    internal int GetTextProperties(IntPtr pfsclient, IntPtr nmp, int iArea, FSTXTPROPS& fstxtprops);
    internal int GetNumberFootnotes(IntPtr pfsclient, IntPtr nmp, int fsdcpStart, int fsdcpLim, Int32& nFootnote);
    internal int GetFootnotes(IntPtr pfsclient, IntPtr nmp, int fsdcpStart, int fsdcpLim, int nFootnotes, IntPtr* rgnmftn, Int32* rgdcp, Int32& cFootnotes);
    internal int FormatDropCap(IntPtr pfsclient, IntPtr pfsparaclient, IntPtr nmp, int iArea, UInt32 fswdir, int fSuppressTopSpace, IntPtr& pfsdropc, Int32& fInMargin, Int32& dur, Int32& dvr, Int32& cPolygons, Int32& cVertices, Int32& durText);
    internal int GetDropCapPolygons(IntPtr pfsclient, IntPtr pfsdropc, IntPtr nmp, UInt32 fswdir, int ncVertices, int nfspt, Int32* rgcVertices, Int32& ccVertices, FSPOINT* rgfspt, Int32& cfspt, Int32& fWrapThrough);
    internal int DestroyDropCap(IntPtr pfsclient, IntPtr pfsdropc);
    internal int FormatBottomText(IntPtr pfsclient, IntPtr pfsparaclient, IntPtr nmp, int iArea, UInt32 fswdir, IntPtr pfslineLast, int dvrLine, IntPtr& pmcsclientOut);
    internal int FormatLine(IntPtr pfsclient, IntPtr pfsparaclient, IntPtr nmp, int iArea, int dcp, IntPtr pbrlineIn, UInt32 fswdir, int urStartLine, int durLine, int urStartTrack, int durTrack, int urPageLeftMargin, int fAllowHyphenation, int fClearOnLeft, int fClearOnRight, int fTreatAsFirstInPara, int fTreatAsLastInPara, int fSuppressTopSpace, IntPtr& pfsline, Int32& dcpLine, IntPtr& ppbrlineOut, Int32& fForcedBroken, FSFLRES& fsflres, Int32& dvrAscent, Int32& dvrDescent, Int32& urBBox, Int32& durBBox, Int32& dcpDepend, Int32& fReformatNeighborsAsLastLine);
    internal int FormatLineForced(IntPtr pfsclient, IntPtr pfsparaclient, IntPtr nmp, int iArea, int dcp, IntPtr pbrlineIn, UInt32 fswdir, int urStartLine, int durLine, int urStartTrack, int durTrack, int urPageLeftMargin, int fClearOnLeft, int fClearOnRight, int fTreatAsFirstInPara, int fTreatAsLastInPara, int fSuppressTopSpace, int dvrAvailable, IntPtr& pfsline, Int32& dcpLine, IntPtr& ppbrlineOut, FSFLRES& fsflres, Int32& dvrAscent, Int32& dvrDescent, Int32& urBBox, Int32& durBBox, Int32& dcpDepend);
    internal int FormatLineVariants(IntPtr pfsclient, IntPtr pfsparabreakingsession, int dcp, IntPtr pbrlineIn, UInt32 fswdir, int urStartLine, int durLine, int fAllowHyphenation, int fClearOnLeft, int fClearOnRight, int fTreatAsFirstInPara, int fTreatAsLastInPara, int fSuppressTopSpace, IntPtr lineVariantRestriction, int nLineVariantsAlloc, FSLINEVARIANT* rgfslinevariant, Int32& nLineVariantsActual, Int32& iLineVariantBest);
    internal int ReconstructLineVariant(IntPtr pfsclient, IntPtr pfsparaclient, IntPtr nmp, int iArea, int dcpStart, IntPtr pbrlineIn, int dcpLine, UInt32 fswdir, int urStartLine, int durLine, int urStartTrack, int durTrack, int urPageLeftMargin, int fAllowHyphenation, int fClearOnLeft, int fClearOnRight, int fTreatAsFirstInPara, int fTreatAsLastInPara, int fSuppressTopSpace, IntPtr& pfsline, IntPtr& ppbrlineOut, Int32& fForcedBroken, FSFLRES& fsflres, Int32& dvrAscent, Int32& dvrDescent, Int32& urBBox, Int32& durBBox, Int32& dcpDepend, Int32& fReformatNeighborsAsLastLine);
    internal int DestroyLine(IntPtr pfsclient, IntPtr pfsline);
    internal int DuplicateLineBreakRecord(IntPtr pfsclient, IntPtr pbrlineIn, IntPtr& pbrlineDup);
    internal int DestroyLineBreakRecord(IntPtr pfsclient, IntPtr pbrlineIn);
    internal int SnapGridVertical(IntPtr pfsclient, UInt32 fswdir, int vrMargin, int vrCurrent, Int32& vrNew);
    internal int GetDvrSuppressibleBottomSpace(IntPtr pfsclient, IntPtr pfsparaclient, IntPtr pfsline, UInt32 fswdir, Int32& dvrSuppressible);
    internal int GetDvrAdvance(IntPtr pfsclient, IntPtr pfsparaclient, IntPtr nmp, int dcp, UInt32 fswdir, Int32& dvr);
    internal int UpdGetChangeInText(IntPtr pfsclient, IntPtr nmp, Int32& dcpStart, Int32& ddcpOld, Int32& ddcpNew);
    internal int UpdGetDropCapChange(IntPtr pfsclient, IntPtr nmp, Int32& fChanged);
    internal int FInterruptFormattingText(IntPtr pfsclient, IntPtr pfsparaclient, IntPtr nmp, int dcp, int vr, Int32& fInterruptFormatting);
    internal int GetTextParaCache(IntPtr pfsclient, IntPtr pfsparaclient, IntPtr nmp, int iArea, UInt32 fswdir, int urStartLine, int durLine, int urStartTrack, int durTrack, int urPageLeftMargin, int fClearOnLeft, int fClearOnRight, int fSuppressTopSpace, Int32& fFound, Int32& dcpPara, Int32& urBBox, Int32& durBBox, Int32& dvrPara, FSKCLEAR& fskclear, IntPtr& pmcsclientAfterPara, Int32& cLines, Int32& fOptimalLines, Int32& fOptimalLineDcpsCached, Int32& dvrMinLineHeight);
    internal int SetTextParaCache(IntPtr pfsclient, IntPtr pfsparaclient, IntPtr nmp, int iArea, UInt32 fswdir, int urStartLine, int durLine, int urStartTrack, int durTrack, int urPageLeftMargin, int fClearOnLeft, int fClearOnRight, int fSuppressTopSpace, int dcpPara, int urBBox, int durBBox, int dvrPara, FSKCLEAR fskclear, IntPtr pmcsclientAfterPara, int cLines, int fOptimalLines, Int32* rgdcpOptimalLines, int dvrMinLineHeight);
    internal int GetOptimalLineDcpCache(IntPtr pfsclient, int cLines, Int32* rgdcp);
    internal int GetNumberAttachedObjectsBeforeTextLine(IntPtr pfsclient, IntPtr nmp, int dcpFirst, Int32& cAttachedObjects);
    internal int GetAttachedObjectsBeforeTextLine(IntPtr pfsclient, IntPtr nmp, int dcpFirst, int nAttachedObjects, IntPtr* rgnmpAttachedObject, Int32* rgidobj, Int32* rgdcpAnchor, Int32& cObjects, Int32& fEndOfParagraph);
    internal int GetNumberAttachedObjectsInTextLine(IntPtr pfsclient, IntPtr pfsline, IntPtr nmp, int dcpFirst, int dcpLim, int fFoundAttachedObjectsBeforeLine, int dcpMaxAnchorAttachedObjectBeforeLine, Int32& cAttachedObjects);
    internal int GetAttachedObjectsInTextLine(IntPtr pfsclient, IntPtr pfsline, IntPtr nmp, int dcpFirst, int dcpLim, int fFoundAttachedObjectsBeforeLine, int dcpMaxAnchorAttachedObjectBeforeLine, int nAttachedObjects, IntPtr* rgnmpAttachedObject, Int32* rgidobj, Int32* rgdcpAnchor, Int32& cObjects);
    internal int UpdGetAttachedObjectChange(IntPtr pfsclient, IntPtr nmp, IntPtr nmpObject, FSKCHANGE& fskchObject);
    internal int GetDurFigureAnchor(IntPtr pfsclient, IntPtr pfsparaclient, IntPtr pfsparaclientFigure, IntPtr pfsline, IntPtr nmpFigure, UInt32 fswdir, IntPtr pfsfmtlinein, Int32& dur);
    internal int GetFloaterProperties(IntPtr pfsclient, IntPtr nmFloater, UInt32 fswdirTrack, FSFLOATERPROPS& fsfloaterprops);
    internal int FormatFloaterContentFinite(IntPtr pfsclient, IntPtr pfsparaclient, IntPtr pfsbrkFloaterContentIn, int fBreakRecordFromPreviousPage, IntPtr nmFloater, IntPtr pftnrej, int fEmptyOk, int fSuppressTopSpace, UInt32 fswdirTrack, int fAtMaxWidth, int durAvailable, int dvrAvailable, FSKSUPPRESSHARDBREAKBEFOREFIRSTPARA fsksuppresshardbreakbeforefirstparaIn, FSFMTR& fsfmtr, IntPtr& pfsFloatContent, IntPtr& pbrkrecpara, Int32& durFloaterWidth, Int32& dvrFloaterHeight, FSBBOX& fsbbox, Int32& cPolygons, Int32& cVertices);
    internal int FormatFloaterContentBottomless(IntPtr pfsclient, IntPtr pfsparaclient, IntPtr nmFloater, int fSuppressTopSpace, UInt32 fswdirTrack, int fAtMaxWidth, int durAvailable, int dvrAvailable, FSFMTRBL& fsfmtrbl, IntPtr& pfsFloatContent, Int32& durFloaterWidth, Int32& dvrFloaterHeight, FSBBOX& fsbbox, Int32& cPolygons, Int32& cVertices);
    internal int UpdateBottomlessFloaterContent(IntPtr pfsFloaterContent, IntPtr pfsparaclient, IntPtr nmFloater, int fSuppressTopSpace, UInt32 fswdirTrack, int fAtMaxWidth, int durAvailable, int dvrAvailable, FSFMTRBL& fsfmtrbl, Int32& durFloaterWidth, Int32& dvrFloaterHeight, FSBBOX& fsbbox, Int32& cPolygons, Int32& cVertices);
    internal int GetFloaterPolygons(IntPtr pfsparaclient, IntPtr pfsFloaterContent, IntPtr nmFloater, UInt32 fswdirTrack, int ncVertices, int nfspt, Int32* rgcVertices, Int32& ccVertices, FSPOINT* rgfspt, Int32& cfspt, Int32& fWrapThrough);
    internal int ClearUpdateInfoInFloaterContent(IntPtr pfsFloaterContent);
    internal int CompareFloaterContents(IntPtr pfsFloaterContentOld, IntPtr pfsFloaterContentNew, FSCOMPRESULT& fscmpr);
    internal int DestroyFloaterContent(IntPtr pfsFloaterContent);
    internal int DuplicateFloaterContentBreakRecord(IntPtr pfsclient, IntPtr pfsbrkFloaterContent, IntPtr& pfsbrkFloaterContentDup);
    internal int DestroyFloaterContentBreakRecord(IntPtr pfsclient, IntPtr pfsbrkFloaterContent);
    internal int GetFloaterContentColumnBalancingInfo(IntPtr pfsFloaterContent, UInt32 fswdir, Int32& nlines, Int32& dvrSumHeight, Int32& dvrMinHeight);
    internal int GetFloaterContentNumberFootnotes(IntPtr pfsFloaterContent, Int32& cftn);
    internal int GetFloaterContentFootnoteInfo(IntPtr pfsFloaterContent, UInt32 fswdir, int nftn, int iftnFirst, FSFTNINFO& fsftninf, Int32& iftnLim);
    internal int TransferDisplayInfoInFloaterContent(IntPtr pfsFloaterContentOld, IntPtr pfsFloaterContentNew);
    internal int GetMCSClientAfterFloater(IntPtr pfsclient, IntPtr pfsparaclient, IntPtr nmFloater, UInt32 fswdirTrack, IntPtr pmcsclientIn, IntPtr& pmcsclientOut);
    internal int GetDvrUsedForFloater(IntPtr pfsclient, IntPtr pfsparaclient, IntPtr nmFloater, UInt32 fswdirTrack, IntPtr pmcsclientIn, int dvrDisplaced, Int32& dvrUsed);
    internal int SubtrackCreateContext(IntPtr pfsclient, IntPtr pfsc, IntPtr pfscbkobj, UInt32 ffi, int idobj, IntPtr& pfssobjc);
    internal int SubtrackDestroyContext(IntPtr pfssobjc);
    internal int SubtrackFormatParaFinite(IntPtr pfssobjc, IntPtr pfsparaclient, IntPtr pfsobjbrk, int fBreakRecordFromPreviousPage, IntPtr nmp, int iArea, IntPtr pftnrej, IntPtr pfsgeom, int fEmptyOk, int fSuppressTopSpace, UInt32 fswdir, FSRECT& fsrcToFill, IntPtr pmcsclientIn, FSKCLEAR fskclearIn, FSKSUPPRESSHARDBREAKBEFOREFIRSTPARA fsksuppresshardbreakbeforefirstparaIn, int fBreakInside, FSFMTR& fsfmtr, IntPtr& pfspara, IntPtr& pbrkrecpara, Int32& dvrUsed, FSBBOX& fsbbox, IntPtr& pmcsclientOut, FSKCLEAR& fskclearOut, Int32& dvrTopSpace, Int32& fBreakInsidePossible);
    internal int SubtrackFormatParaBottomless(IntPtr pfssobjc, IntPtr pfsparaclient, IntPtr nmp, int iArea, IntPtr pfsgeom, int fSuppressTopSpace, UInt32 fswdir, int urTrack, int durTrack, int vrTrack, IntPtr pmcsclientIn, FSKCLEAR fskclearIn, int fInterruptable, FSFMTRBL& fsfmtrbl, IntPtr& pfspara, Int32& dvrUsed, FSBBOX& fsbbox, IntPtr& pmcsclientOut, FSKCLEAR& fskclearOut, Int32& dvrTopSpace, Int32& fPageBecomesUninterruptable);
    internal int SubtrackUpdateBottomlessPara(IntPtr pfspara, IntPtr pfsparaclient, IntPtr nmp, int iArea, IntPtr pfsgeom, int fSuppressTopSpace, UInt32 fswdir, int urTrack, int durTrack, int vrTrack, IntPtr pmcsclientIn, FSKCLEAR fskclearIn, int fInterruptable, FSFMTRBL& fsfmtrbl, Int32& dvrUsed, FSBBOX& fsbbox, IntPtr& pmcsclientOut, FSKCLEAR& fskclearOut, Int32& dvrTopSpace, Int32& fPageBecomesUninterruptable);
    internal int SubtrackSynchronizeBottomlessPara(IntPtr pfspara, IntPtr pfsparaclient, IntPtr pfsgeom, UInt32 fswdir, int dvrShift);
    internal int SubtrackComparePara(IntPtr pfsparaclientOld, IntPtr pfsparaOld, IntPtr pfsparaclientNew, IntPtr pfsparaNew, UInt32 fswdir, FSCOMPRESULT& fscmpr, Int32& dvrShifted);
    internal int SubtrackClearUpdateInfoInPara(IntPtr pfspara);
    internal int SubtrackDestroyPara(IntPtr pfspara);
    internal int SubtrackDuplicateBreakRecord(IntPtr pfssobjc, IntPtr pfsbrkrecparaOrig, IntPtr& pfsbrkrecparaDup);
    internal int SubtrackDestroyBreakRecord(IntPtr pfssobjc, IntPtr pfsobjbrk);
    internal int SubtrackGetColumnBalancingInfo(IntPtr pfspara, UInt32 fswdir, Int32& nlines, Int32& dvrSumHeight, Int32& dvrMinHeight);
    internal int SubtrackGetNumberFootnotes(IntPtr pfspara, Int32& nftn);
    internal int SubtrackGetFootnoteInfo(IntPtr pfspara, UInt32 fswdir, int nftn, int iftnFirst, FSFTNINFO* pfsftninf, Int32& iftnLim);
    internal int SubtrackShiftVertical(IntPtr pfspara, IntPtr pfsparaclient, IntPtr pfsshift, UInt32 fswdir, FSBBOX& pfsbbox);
    internal int SubtrackTransferDisplayInfoPara(IntPtr pfsparaOld, IntPtr pfsparaNew);
    internal int SubpageCreateContext(IntPtr pfsclient, IntPtr pfsc, IntPtr pfscbkobj, UInt32 ffi, int idobj, IntPtr& pfssobjc);
    internal int SubpageDestroyContext(IntPtr pfssobjc);
    internal int SubpageFormatParaFinite(IntPtr pfssobjc, IntPtr pfsparaclient, IntPtr pfsobjbrk, int fBreakRecordFromPreviousPage, IntPtr nmp, int iArea, IntPtr pftnrej, IntPtr pfsgeom, int fEmptyOk, int fSuppressTopSpace, UInt32 fswdir, FSRECT& fsrcToFill, IntPtr pmcsclientIn, FSKCLEAR fskclearIn, FSKSUPPRESSHARDBREAKBEFOREFIRSTPARA fsksuppresshardbreakbeforefirstparaIn, int fBreakInside, FSFMTR& fsfmtr, IntPtr& pfspara, IntPtr& pbrkrecpara, Int32& dvrUsed, FSBBOX& fsbbox, IntPtr& pmcsclientOut, FSKCLEAR& fskclearOut, Int32& dvrTopSpace, Int32& fBreakInsidePossible);
    internal int SubpageFormatParaBottomless(IntPtr pfssobjc, IntPtr pfsparaclient, IntPtr nmp, int iArea, IntPtr pfsgeom, int fSuppressTopSpace, UInt32 fswdir, int urTrack, int durTrack, int vrTrack, IntPtr pmcsclientIn, FSKCLEAR fskclearIn, int fInterruptable, FSFMTRBL& fsfmtrbl, IntPtr& pfspara, Int32& dvrUsed, FSBBOX& fsbbox, IntPtr& pmcsclientOut, FSKCLEAR& fskclearOut, Int32& dvrTopSpace, Int32& fPageBecomesUninterruptable);
    internal int SubpageUpdateBottomlessPara(IntPtr pfspara, IntPtr pfsparaclient, IntPtr nmp, int iArea, IntPtr pfsgeom, int fSuppressTopSpace, UInt32 fswdir, int urTrack, int durTrack, int vrTrack, IntPtr pmcsclientIn, FSKCLEAR fskclearIn, int fInterruptable, FSFMTRBL& fsfmtrbl, Int32& dvrUsed, FSBBOX& fsbbox, IntPtr& pmcsclientOut, FSKCLEAR& fskclearOut, Int32& dvrTopSpace, Int32& fPageBecomesUninterruptable);
    internal int SubpageSynchronizeBottomlessPara(IntPtr pfspara, IntPtr pfsparaclient, IntPtr pfsgeom, UInt32 fswdir, int dvrShift);
    internal int SubpageComparePara(IntPtr pfsparaclientOld, IntPtr pfsparaOld, IntPtr pfsparaclientNew, IntPtr pfsparaNew, UInt32 fswdir, FSCOMPRESULT& fscmpr, Int32& dvrShifted);
    internal int SubpageClearUpdateInfoInPara(IntPtr pfspara);
    internal int SubpageDestroyPara(IntPtr pfspara);
    internal int SubpageDuplicateBreakRecord(IntPtr pfssobjc, IntPtr pfsbrkrecparaOrig, IntPtr& pfsbrkrecparaDup);
    internal int SubpageDestroyBreakRecord(IntPtr pfssobjc, IntPtr pfsobjbrk);
    internal int SubpageGetColumnBalancingInfo(IntPtr pfspara, UInt32 fswdir, Int32& nlines, Int32& dvrSumHeight, Int32& dvrMinHeight);
    internal int SubpageGetNumberFootnotes(IntPtr pfspara, Int32& nftn);
    internal int SubpageGetFootnoteInfo(IntPtr pfspara, UInt32 fswdir, int nftn, int iftnFirst, FSFTNINFO* pfsftninf, Int32& iftnLim);
    internal int SubpageShiftVertical(IntPtr pfspara, IntPtr pfsparaclient, IntPtr pfsshift, UInt32 fswdir, FSBBOX& pfsbbox);
    internal int SubpageTransferDisplayInfoPara(IntPtr pfsparaOld, IntPtr pfsparaNew);
    internal int GetTableProperties(IntPtr pfsclient, IntPtr nmTable, UInt32 fswdirTrack, FSTABLEOBJPROPS& fstableobjprops);
    internal int AutofitTable(IntPtr pfsclient, IntPtr pfsparaclientTable, IntPtr nmTable, UInt32 fswdirTrack, int durAvailableSpace, Int32& durTableWidth);
    internal int UpdAutofitTable(IntPtr pfsclient, IntPtr pfsparaclientTable, IntPtr nmTable, UInt32 fswdirTrack, int durAvailableSpace, Int32& durTableWidth, Int32& fNoChangeInCellWidths);
    internal int GetMCSClientAfterTable(IntPtr pfsclient, IntPtr pfsparaclientTable, IntPtr nmTable, UInt32 fswdirTrack, IntPtr pmcsclientIn, IntPtr& ppmcsclientOut);
    internal int GetFirstHeaderRow(IntPtr pfsclient, IntPtr nmTable, int fRepeatedHeader, Int32& fFound, IntPtr& pnmFirstHeaderRow);
    internal int GetNextHeaderRow(IntPtr pfsclient, IntPtr nmTable, IntPtr nmHeaderRow, int fRepeatedHeader, Int32& fFound, IntPtr& pnmNextHeaderRow);
    internal int GetFirstFooterRow(IntPtr pfsclient, IntPtr nmTable, int fRepeatedFooter, Int32& fFound, IntPtr& pnmFirstFooterRow);
    internal int GetNextFooterRow(IntPtr pfsclient, IntPtr nmTable, IntPtr nmFooterRow, int fRepeatedFooter, Int32& fFound, IntPtr& pnmNextFooterRow);
    internal int GetFirstRow(IntPtr pfsclient, IntPtr nmTable, Int32& fFound, IntPtr& pnmFirstRow);
    internal int GetNextRow(IntPtr pfsclient, IntPtr nmTable, IntPtr nmRow, Int32& fFound, IntPtr& pnmNextRow);
    internal int UpdFChangeInHeaderFooter(IntPtr pfsclient, IntPtr nmTable, Int32& fHeaderChanged, Int32& fFooterChanged, Int32& fRepeatedHeaderChanged, Int32& fRepeatedFooterChanged);
    internal int UpdGetFirstChangeInTable(IntPtr pfsclient, IntPtr nmTable, Int32& fFound, Int32& fChangeFirst, IntPtr& pnmRowBeforeChange);
    internal int UpdGetRowChange(IntPtr pfsclient, IntPtr nmTable, IntPtr nmRow, FSKCHANGE& fskch, Int32& fNoFurtherChanges);
    internal int UpdGetCellChange(IntPtr pfsclient, IntPtr nmRow, IntPtr nmCell, Int32& fWidthChanged, FSKCHANGE& fskchCell);
    internal int GetDistributionKind(IntPtr pfsclient, IntPtr nmTable, UInt32 fswdirTable, FSKTABLEHEIGHTDISTRIBUTION& tabledistr);
    internal int GetRowProperties(IntPtr pfsclient, IntPtr nmRow, UInt32 fswdirTable, FSTABLEROWPROPS& rowprops);
    internal int GetCells(IntPtr pfsclient, IntPtr nmRow, int cCells, IntPtr* rgnmCell, FSTABLEKCELLMERGE* rgkcellmerge);
    internal int FInterruptFormattingTable(IntPtr pfsclient, IntPtr pfsparaclient, IntPtr nmRow, int dvr, Int32& fInterrupt);
    internal int CalcHorizontalBBoxOfRow(IntPtr pfsclient, IntPtr nmRow, int cCells, IntPtr* rgnmCell, IntPtr* rgpfscell, Int32& urBBox, Int32& durBBox);
    internal int FormatCellFinite(IntPtr pfsclient, IntPtr pfsparaclientTable, IntPtr pfsbrkcell, IntPtr nmCell, IntPtr pfsFtnRejector, int fEmptyOK, UInt32 fswdirTable, int dvrExtraHeight, int dvrAvailable, FSFMTR& pfmtr, IntPtr& ppfscell, IntPtr& pfsbrkcellOut, Int32& dvrUsed);
    internal int FormatCellBottomless(IntPtr pfsclient, IntPtr pfsparaclientTable, IntPtr nmCell, UInt32 fswdirTable, FSFMTRBL& fmtrbl, IntPtr& ppfscell, Int32& dvrUsed);
    internal int UpdateBottomlessCell(IntPtr pfscell, IntPtr pfsparaclientTable, IntPtr nmCell, UInt32 fswdirTable, FSFMTRBL& fmtrbl, Int32& dvrUsed);
    internal int CompareCells(IntPtr pfscellOld, IntPtr pfscellNew, FSCOMPRESULT& fscmpr);
    internal int ClearUpdateInfoInCell(IntPtr pfscell);
    internal int SetCellHeight(IntPtr pfscell, IntPtr pfsparaclientTable, IntPtr pfsbrkcell, IntPtr nmCell, int fBrokenHere, UInt32 fswdirTable, int dvrActual);
    internal int DuplicateCellBreakRecord(IntPtr pfsclient, IntPtr pfsbrkcell, IntPtr& ppfsbrkcellDup);
    internal int DestroyCellBreakRecord(IntPtr pfsclient, IntPtr pfsbrkcell);
    internal int DestroyCell(IntPtr pfsCell);
    internal int GetCellNumberFootnotes(IntPtr pfsCell, Int32& cFtn);
    internal int GetCellMinColumnBalancingStep(IntPtr pfscell, UInt32 fswdir, Int32& dvrMinStep);
    internal int TransferDisplayInfoCell(IntPtr pfscellOld, IntPtr pfscellNew);
}
internal class MS.Internal.PtsHost.PtsPage : object {
    private static DispatcherOperationCallback BackgroundUpdateCallback;
    private Section _section;
    private PageBreakRecord _breakRecord;
    private ContainerVisual _visual;
    private DispatcherOperation _backgroundFormatOperation;
    private Size _calculatedSize;
    private Size _contentSize;
    private PageContext _pageContextOfThisPage;
    private SecurityCriticalDataForSet`1<IntPtr> _ptsPage;
    private bool _finitePage;
    private bool _incrementalUpdate;
    internal bool _useSizingWorkaroundForTextBox;
    private int _disposed;
    internal PageBreakRecord BreakRecord { get; }
    internal Size CalculatedSize { get; }
    internal Size ContentSize { get; }
    internal bool FinitePage { get; }
    internal PageContext PageContext { get; }
    internal bool IncrementalUpdate { get; }
    internal PtsContext PtsContext { get; }
    internal IntPtr PageHandle { get; }
    internal bool UseSizingWorkaroundForTextBox { get; internal set; }
    private bool IsEmpty { get; }
    internal PtsPage(Section section);
    private static PtsPage();
    protected virtual override void Finalize();
    public sealed virtual void Dispose();
    internal bool PrepareForBottomlessUpdate();
    internal bool PrepareForFiniteUpdate(PageBreakRecord breakRecord);
    internal IInputElement InputHitTest(Point p);
    internal List`1<Rect> GetRectangles(ContentElement e, int start, int length);
    private static object BackgroundFormatStatic(object arg);
    private void BackgroundFormat();
    private void DeferFormattingToBackground();
    internal void CreateBottomlessPage();
    internal void UpdateBottomlessPage();
    internal void CreateFinitePage(PageBreakRecord breakRecord);
    internal void UpdateFinitePage(PageBreakRecord breakRecord);
    internal void ArrangePage();
    internal void UpdateViewport(FSRECT& viewport);
    internal void ClearUpdateInfo();
    internal ContainerVisual GetPageVisual();
    internal PageBreakRecord get_BreakRecord();
    internal Size get_CalculatedSize();
    internal Size get_ContentSize();
    internal bool get_FinitePage();
    internal PageContext get_PageContext();
    internal bool get_IncrementalUpdate();
    internal PtsContext get_PtsContext();
    internal IntPtr get_PageHandle();
    internal bool get_UseSizingWorkaroundForTextBox();
    internal void set_UseSizingWorkaroundForTextBox(bool value);
    private void Dispose(bool disposing);
    private void OnBeforeFormatPage(bool finitePage, bool incremental);
    private void OnAfterFormatPage(bool setSize, bool incremental);
    private FSRECT GetRect();
    private FSBBOX GetBoundingBox();
    private void ArrangeSection(FSSECTIONDESCRIPTION& sectionDesc);
    private void UpdateViewportSection(FSSECTIONDESCRIPTION& sectionDesc, FSRECT& viewport);
    private void UpdatePageVisuals(Size arrangeSize);
    private void UpdateSectionVisuals(SectionVisual visual, FSKUPDATE fskupdInherited, FSSECTIONDESCRIPTION& sectionDesc);
    private IInputElement InputHitTestPage(FSPOINT pt);
    private List`1<Rect> GetRectanglesInPage(ContentElement e, int start, int length);
    private IInputElement InputHitTestSection(FSPOINT pt, FSSECTIONDESCRIPTION& sectionDesc);
    private List`1<Rect> GetRectanglesInSection(ContentElement e, int start, int length, FSSECTIONDESCRIPTION& sectionDesc);
    private void DestroyPage();
    private bool get_IsEmpty();
}
internal class MS.Internal.PtsHost.RowParagraph : BaseParagraph {
    private CellParagraph[] _cellParagraphs;
    private CellParagraph[] _spannedCells;
    internal TableRow Row { get; }
    internal Table Table { get; }
    internal CellParagraph[] Cells { get; }
    internal RowParagraph(DependencyObject element, StructuralCache structuralCache);
    public virtual void Dispose();
    internal virtual void GetParaProperties(FSPAP& fspap);
    internal virtual void CreateParaclient(IntPtr& paraClientHandle);
    internal virtual void UpdGetParaChange(FSKCHANGE& fskch, Int32& fNoFurtherChanges);
    internal void GetRowProperties(UInt32 fswdirTable, FSTABLEROWPROPS& rowprops);
    internal void FInterruptFormattingTable(int dvr, Int32& fInterrupt);
    internal void CalcHorizontalBBoxOfRow(int cCells, IntPtr* rgnmCell, IntPtr* rgpfsCell, Int32& urBBox, Int32& durBBox);
    internal void GetCells(int cCells, IntPtr* rgnmCell, FSTABLEKCELLMERGE* rgkcellmerge);
    internal void CalculateRowSpans();
    internal void GetRowHeight(FSKROWHEIGHTRESTRICTION& fskrowheight, Int32& dvrAboveBelow);
    internal TableRow get_Row();
    internal Table get_Table();
    internal CellParagraph[] get_Cells();
    private CellParagraph FindCellParagraphForCell(RowParagraph previousRow, TableCell cell);
}
internal class MS.Internal.PtsHost.RowVisual : ContainerVisual {
    private TableRow _row;
    internal TableRow Row { get; }
    internal RowVisual(TableRow row);
    internal TableRow get_Row();
}
internal class MS.Internal.PtsHost.Section : UnmanagedHandle {
    private BaseParagraph _mainTextSegment;
    private StructuralCache _structuralCache;
    internal bool CanUpdate { get; }
    internal StructuralCache StructuralCache { get; }
    internal DependencyObject Element { get; }
    internal Section(StructuralCache structuralCache);
    public virtual void Dispose();
    internal void FSkipPage(Int32& fSkip);
    internal void GetPageDimensions(UInt32& fswdir, Int32& fHeaderFooterAtTopBottom, Int32& durPage, Int32& dvrPage, FSRECT& fsrcMargin);
    internal void GetJustificationProperties(IntPtr* rgnms, int cnms, int fLastSectionNotBroken, Int32& fJustify, FSKALIGNPAGE& fskal, Int32& fCancelAtLastColumn);
    internal void GetNextSection(Int32& fSuccess, IntPtr& nmsNext);
    internal void GetSectionProperties(Int32& fNewPage, UInt32& fswdir, Int32& fApplyColumnBalancing, Int32& ccol, Int32& cSegmentDefinedColumnSpanAreas, Int32& cHeightDefinedColumnSpanAreas);
    internal void GetMainTextSegment(IntPtr& nmSegment);
    internal void GetHeaderSegment(IntPtr pfsbrpagePrelim, UInt32 fswdir, Int32& fHeaderPresent, Int32& fHardMargin, Int32& dvrMaxHeight, Int32& dvrFromEdge, UInt32& fswdirHeader, IntPtr& nmsHeader);
    internal void GetFooterSegment(IntPtr pfsbrpagePrelim, UInt32 fswdir, Int32& fFooterPresent, Int32& fHardMargin, Int32& dvrMaxHeight, Int32& dvrFromEdge, UInt32& fswdirFooter, IntPtr& nmsFooter);
    internal void GetSectionColumnInfo(UInt32 fswdir, int ncol, FSCOLUMNINFO* pfscolinfo, Int32& ccol);
    internal void GetEndnoteSegment(Int32& fEndnotesPresent, IntPtr& nmsEndnotes);
    internal void GetEndnoteSeparators(IntPtr& nmsEndnoteSeparator, IntPtr& nmsEndnoteContSeparator, IntPtr& nmsEndnoteContNotice);
    internal void InvalidateFormatCache();
    internal void ClearUpdateInfo();
    internal void InvalidateStructure();
    internal void DestroyStructure();
    internal void UpdateSegmentLastFormatPositions();
    internal bool get_CanUpdate();
    internal StructuralCache get_StructuralCache();
    internal DependencyObject get_Element();
}
internal class MS.Internal.PtsHost.SectionVisual : DrawingVisual {
    private Point[] _rulePositions;
    private double _ruleWidth;
    internal void DrawColumnRules(FSTRACKDESCRIPTION[]& arrayColumnDesc, double columnVStart, double columnHeight, ColumnPropertiesGroup columnProperties);
}
internal class MS.Internal.PtsHost.StructuralCache : object {
    private FlowDocument _owner;
    private PtsContext _ptsContext;
    private Section _section;
    private TextContainer _textContainer;
    private TextFormatterHost _textFormatterHost;
    private FlowDocumentPage _currentPage;
    private DocumentFormatContext _documentFormatContext;
    private DocumentArrangeContext _documentArrangeContext;
    private DtrList _dtrs;
    private bool _illegalTreeChangeDetected;
    private bool _forceReformat;
    private bool _destroyStructure;
    private BackgroundFormatInfo _backgroundFormatInfo;
    private FlowDirection _pageFlowDirection;
    private NaturalLanguageHyphenator _hyphenator;
    private Flags _flags;
    internal DependencyObject PropertyOwner { get; }
    internal FlowDocument FormattingOwner { get; }
    internal Section Section { get; }
    internal NaturalLanguageHyphenator Hyphenator { get; }
    internal PtsContext PtsContext { get; }
    internal DocumentFormatContext CurrentFormatContext { get; }
    internal DocumentArrangeContext CurrentArrangeContext { get; }
    internal TextFormatterHost TextFormatterHost { get; }
    internal TextContainer TextContainer { get; }
    internal FlowDirection PageFlowDirection { get; internal set; }
    internal bool ForceReformat { get; internal set; }
    internal bool DestroyStructure { get; }
    internal DtrList DtrList { get; }
    internal bool IsDeferredVisualCreationSupported { get; }
    internal BackgroundFormatInfo BackgroundFormatInfo { get; }
    internal bool IsOptimalParagraphEnabled { get; }
    internal bool IsFormattingInProgress { get; internal set; }
    internal bool IsContentChangeInProgress { get; internal set; }
    internal bool IsFormattedOnce { get; internal set; }
    internal StructuralCache(FlowDocument owner, TextContainer textContainer);
    protected virtual override void Finalize();
    internal IDisposable SetDocumentFormatContext(FlowDocumentPage currentPage);
    internal IDisposable SetDocumentArrangeContext(FlowDocumentPage currentPage);
    internal IDisposable SetDocumentVisualValidationContext(FlowDocumentPage currentPage);
    internal void DetectInvalidOperation();
    internal void OnInvalidOperationDetected();
    internal void InvalidateFormatCache(bool destroyStructure);
    internal void AddDirtyTextRange(DirtyTextRange dtr);
    internal DtrList DtrsFromRange(int dcpNew, int cchOld);
    internal void ClearUpdateInfo(bool destroyStructureCache);
    internal void ThrottleBackgroundFormatting();
    internal bool HasPtsContext();
    internal DependencyObject get_PropertyOwner();
    internal FlowDocument get_FormattingOwner();
    internal Section get_Section();
    internal NaturalLanguageHyphenator get_Hyphenator();
    internal PtsContext get_PtsContext();
    internal DocumentFormatContext get_CurrentFormatContext();
    internal DocumentArrangeContext get_CurrentArrangeContext();
    internal TextFormatterHost get_TextFormatterHost();
    internal TextContainer get_TextContainer();
    internal FlowDirection get_PageFlowDirection();
    internal void set_PageFlowDirection(FlowDirection value);
    internal bool get_ForceReformat();
    internal void set_ForceReformat(bool value);
    internal bool get_DestroyStructure();
    internal DtrList get_DtrList();
    internal bool get_IsDeferredVisualCreationSupported();
    internal BackgroundFormatInfo get_BackgroundFormatInfo();
    internal bool get_IsOptimalParagraphEnabled();
    internal bool get_IsFormattingInProgress();
    internal void set_IsFormattingInProgress(bool value);
    internal bool get_IsContentChangeInProgress();
    internal void set_IsContentChangeInProgress(bool value);
    internal bool get_IsFormattedOnce();
    internal void set_IsFormattedOnce(bool value);
    private void EnsureHyphenator();
    private void EnsurePtsContext();
    private void SetFlags(bool value, Flags flags);
    private bool CheckFlags(Flags flags);
}
internal class MS.Internal.PtsHost.SubpageParaClient : BaseParaClient {
    private bool _isFirstChunk;
    private bool _isLastChunk;
    private FSRECT _contentRect;
    private FSRECT _paddingRect;
    private PageContext _pageContextOfThisPage;
    internal bool IsFirstChunk { get; }
    internal bool IsLastChunk { get; }
    internal ReadOnlyCollection`1<ParagraphResult> FloatingElementResults { get; }
    internal FSRECT ContentRect { get; }
    internal SubpageParaClient(SubpageParagraph paragraph);
    public virtual void Dispose();
    protected virtual void OnArrange();
    internal virtual IInputElement InputHitTest(FSPOINT pt);
    internal virtual List`1<Rect> GetRectangles(ContentElement e, int start, int length);
    internal virtual void ValidateVisual(FSKUPDATE fskupdInherited);
    internal virtual void UpdateViewport(FSRECT& viewport);
    internal virtual ParagraphResult CreateParagraphResult();
    internal virtual TextContentRange GetTextContentRange();
    internal ReadOnlyCollection`1<ColumnResult> GetColumnResults(Boolean& hasTextContent);
    internal ReadOnlyCollection`1<ParagraphResult> GetParagraphResultsFromColumn(IntPtr pfstrack, Vector parentOffset, Boolean& hasTextContent);
    internal TextContentRange GetTextContentRangeFromColumn(IntPtr pfstrack);
    internal void SetChunkInfo(bool isFirstChunk, bool isLastChunk);
    internal virtual bool get_IsFirstChunk();
    internal virtual bool get_IsLastChunk();
    internal ReadOnlyCollection`1<ParagraphResult> get_FloatingElementResults();
    internal FSRECT get_ContentRect();
}
internal class MS.Internal.PtsHost.SubpageParagraph : BaseParagraph {
    private BaseParagraph _mainTextSegment;
    protected bool _isInterruptible;
    internal SubpageParagraph(DependencyObject element, StructuralCache structuralCache);
    public virtual void Dispose();
    internal virtual void GetParaProperties(FSPAP& fspap);
    internal virtual void CreateParaclient(IntPtr& paraClientHandle);
    internal void FormatParaFinite(SubpageParaClient paraClient, IntPtr pbrkrecIn, int fBRFromPreviousPage, IntPtr footnoteRejector, int fEmptyOk, int fSuppressTopSpace, UInt32 fswdir, FSRECT& fsrcToFill, MarginCollapsingState mcs, FSKCLEAR fskclearIn, FSKSUPPRESSHARDBREAKBEFOREFIRSTPARA fsksuppresshardbreakbeforefirstparaIn, FSFMTR& fsfmtr, IntPtr& pfspara, IntPtr& pbrkrecOut, Int32& dvrUsed, FSBBOX& fsbbox, IntPtr& pmcsclientOut, FSKCLEAR& fskclearOut, Int32& dvrTopSpace);
    internal void FormatParaBottomless(SubpageParaClient paraClient, int fSuppressTopSpace, UInt32 fswdir, int urTrack, int durTrack, int vrTrack, MarginCollapsingState mcs, FSKCLEAR fskclearIn, int fInterruptable, FSFMTRBL& fsfmtrbl, IntPtr& pfspara, Int32& dvrUsed, FSBBOX& fsbbox, IntPtr& pmcsclientOut, FSKCLEAR& fskclearOut, Int32& dvrTopSpace, Int32& fPageBecomesUninterruptable);
    internal void UpdateBottomlessPara(IntPtr pfspara, SubpageParaClient paraClient, int fSuppressTopSpace, UInt32 fswdir, int urTrack, int durTrack, int vrTrack, MarginCollapsingState mcs, FSKCLEAR fskclearIn, int fInterruptable, FSFMTRBL& fsfmtrbl, Int32& dvrUsed, FSBBOX& fsbbox, IntPtr& pmcsclientOut, FSKCLEAR& fskclearOut, Int32& dvrTopSpace, Int32& fPageBecomesUninterruptable);
    internal virtual void ClearUpdateInfo();
    internal virtual bool InvalidateStructure(int startPosition);
    internal virtual void InvalidateFormatCache();
    internal void UpdateSegmentLastFormatPositions();
}
internal class MS.Internal.PtsHost.TableParaClient : BaseParaClient {
    private bool _isFirstChunk;
    private bool _isLastChunk;
    private FSRECT _columnRect;
    private CalculatedColumn[] _calculatedColumns;
    private double _durMinWidth;
    private double _durMaxWidth;
    private double _previousAutofitWidth;
    private double _previousTableWidth;
    internal TableParagraph TableParagraph { get; }
    internal Table Table { get; }
    internal double TableDesiredWidth { get; }
    internal CalculatedColumn[] CalculatedColumns { get; }
    internal double AutofitWidth { get; }
    internal bool IsFirstChunk { get; }
    internal bool IsLastChunk { get; }
    internal TableParaClient(TableParagraph paragraph);
    protected virtual void OnArrange();
    internal virtual void ValidateVisual(FSKUPDATE fskupdInherited);
    internal virtual void UpdateViewport(FSRECT& viewport);
    internal virtual IInputElement InputHitTest(FSPOINT pt);
    internal virtual List`1<Rect> GetRectangles(ContentElement e, int start, int length);
    internal virtual ParagraphResult CreateParagraphResult();
    internal virtual TextContentRange GetTextContentRange();
    internal CellParaClient GetCellParaClientFromPoint(Point point, bool snapToText);
    internal ReadOnlyCollection`1<ParagraphResult> GetChildrenParagraphResults(Boolean& hasTextContent);
    internal ReadOnlyCollection`1<ParagraphResult> GetChildrenParagraphResultsForRow(int rowIndex, Boolean& hasTextContent);
    internal ReadOnlyCollection`1<ParagraphResult> GetParagraphsFromPoint(Point point, bool snapToText);
    internal ReadOnlyCollection`1<ParagraphResult> GetParagraphsFromPosition(ITextPointer position);
    internal Geometry GetTightBoundingGeometryFromTextPositions(ITextPointer startPosition, ITextPointer endPosition, Rect visibleRect);
    internal CellParaClient GetCellParaClientFromPosition(ITextPointer position);
    internal CellParaClient GetCellAbove(double suggestedX, int rowGroupIndex, int rowIndex);
    internal CellParaClient GetCellBelow(double suggestedX, int rowGroupIndex, int rowIndex);
    internal CellInfo GetCellInfoFromPoint(Point point);
    internal Rect GetRectangleFromRowEndPosition(ITextPointer position);
    internal void AutofitTable(UInt32 fswdirTrack, int durAvailableSpace, Int32& durTableWidth);
    internal void UpdAutofitTable(UInt32 fswdirTrack, int durAvailableSpace, Int32& durTableWidth, Int32& fNoChangeInCellWidths);
    internal int Autofit(double availableWidth, Double& tableWidth);
    internal TableParagraph get_TableParagraph();
    internal Table get_Table();
    internal double get_TableDesiredWidth();
    internal CalculatedColumn[] get_CalculatedColumns();
    internal double get_AutofitWidth();
    internal virtual bool get_IsFirstChunk();
    internal virtual bool get_IsLastChunk();
    private void UpdateChunkInfo(FSTABLEROWDESCRIPTION[] arrayTableRowDesc);
    private bool QueryTableDetails(FSTABLEROWDESCRIPTION[]& arrayTableRowDesc, FSKUPDATE& fskupdTable, FSRECT& rect);
    private void QueryRowDetails(IntPtr pfstablerow, IntPtr[]& arrayFsCell, FSKUPDATE[]& arrayUpdate, FSTABLEKCELLMERGE[]& arrayTableCellMerge);
    private void SynchronizeRowVisualsCollection(VisualCollection rowVisualsCollection, int firstIndex, TableRow row);
    private void SynchronizeCellVisualsCollection(VisualCollection cellVisualsCollection, int firstIndex, Visual visual);
    private void ValidateRowVisualSimple(RowVisual rowVisual, IntPtr pfstablerow, FSKUPDATE fskupdRow, CalculatedColumn[] calculatedColumns);
    private void ValidateRowVisualComplex(RowVisual rowVisual, IntPtr pfstablerow, int tableColumnCount, FSKUPDATE fskupdRow, CalculatedColumn[] calculatedColumns);
    private void DrawColumnBackgrounds(DrawingContext dc, Rect tableContentRect);
    private double GetActualRowHeight(FSTABLEROWDESCRIPTION[] arrayTableRowDesc, int rowIndex, MbpInfo mbpInfo);
    private void DrawRowGroupBackgrounds(DrawingContext dc, FSTABLEROWDESCRIPTION[] arrayTableRowDesc, Rect tableContentRect, MbpInfo mbpInfo);
    private void DrawRowBackgrounds(DrawingContext dc, FSTABLEROWDESCRIPTION[] arrayTableRowDesc, Rect tableContentRect, MbpInfo mbpInfo);
    private void ValidateCalculatedColumns();
    private int ValidateTableWidths(double durAvailableWidth, Double& durTableWidth);
    private FSRECT GetTableContentRect(MbpInfo mbpInfo);
    private int GetTableOffsetFirstRowTop();
}
internal class MS.Internal.PtsHost.TableParagraph : BaseParagraph {
    private BaseParagraph _firstChild;
    internal Table Table { get; }
    internal TableParagraph(DependencyObject element, StructuralCache structuralCache);
    public virtual void Dispose();
    internal virtual void CollapseMargin(BaseParaClient paraClient, MarginCollapsingState mcs, UInt32 fswdir, bool suppressTopSpace, Int32& dvr);
    internal virtual void GetParaProperties(FSPAP& fspap);
    internal virtual void CreateParaclient(IntPtr& pfsparaclient);
    internal void GetTableProperties(UInt32 fswdirTrack, FSTABLEOBJPROPS& fstableobjprops);
    internal void GetMCSClientAfterTable(UInt32 fswdirTrack, IntPtr pmcsclientIn, IntPtr& ppmcsclientOut);
    internal void GetFirstHeaderRow(int fRepeatedHeader, Int32& fFound, IntPtr& pnmFirstHeaderRow);
    internal void GetNextHeaderRow(int fRepeatedHeader, IntPtr nmHeaderRow, Int32& fFound, IntPtr& pnmNextHeaderRow);
    internal void GetFirstFooterRow(int fRepeatedFooter, Int32& fFound, IntPtr& pnmFirstFooterRow);
    internal void GetNextFooterRow(int fRepeatedFooter, IntPtr nmFooterRow, Int32& fFound, IntPtr& pnmNextFooterRow);
    internal void GetFirstRow(Int32& fFound, IntPtr& pnmFirstRow);
    internal void GetNextRow(IntPtr nmRow, Int32& fFound, IntPtr& pnmNextRow);
    internal void UpdFChangeInHeaderFooter(Int32& fHeaderChanged, Int32& fFooterChanged, Int32& fRepeatedHeaderChanged, Int32& fRepeatedFooterChanged);
    internal void UpdGetFirstChangeInTable(Int32& fFound, Int32& fChangeFirst, IntPtr& pnmRowBeforeChange);
    internal void GetDistributionKind(UInt32 fswdirTable, FSKTABLEHEIGHTDISTRIBUTION& tabledistr);
    internal virtual void UpdGetParaChange(FSKCHANGE& fskch, Int32& fNoFurtherChanges);
    internal virtual bool InvalidateStructure(int startPosition);
    internal virtual void InvalidateFormatCache();
    internal Table get_Table();
    private bool InvalidateRowStructure(RowParagraph rowParagraph, int startPosition);
    private void InvalidateRowFormatCache(RowParagraph rowParagraph);
    private void TableStructureChanged(object sender, EventArgs e);
}
internal class MS.Internal.PtsHost.TextFormatterHost : TextSource {
    internal LineBase Context;
    internal TextFormatter TextFormatter;
    internal TextFormatterHost(TextFormatter textFormatter, TextFormattingMode textFormattingMode, double pixelsPerDip);
    public virtual TextRun GetTextRun(int textSourceCharacterIndex);
    public virtual TextSpan`1<CultureSpecificCharacterBufferRange> GetPrecedingText(int textSourceCharacterIndexLimit);
    public virtual int GetTextEffectCharacterIndexFromTextSourceCharacterIndex(int textSourceCharacterIndex);
}
internal class MS.Internal.PtsHost.TextParaClient : BaseParaClient {
    private int _lineIndexFirstVisual;
    internal TextParagraph TextParagraph { get; }
    internal bool HasEOP { get; }
    internal bool IsFirstChunk { get; }
    internal bool IsLastChunk { get; }
    private bool IsOptimalParagraph { get; }
    internal TextParaClient(TextParagraph paragraph);
    internal virtual void ValidateVisual(FSKUPDATE fskupdInherited);
    internal virtual void UpdateViewport(FSRECT& viewport);
    internal virtual IInputElement InputHitTest(FSPOINT pt);
    internal virtual List`1<Rect> GetRectangles(ContentElement e, int start, int length);
    internal virtual ParagraphResult CreateParagraphResult();
    internal ReadOnlyCollection`1<LineResult> GetLineResults();
    internal ReadOnlyCollection`1<ParagraphResult> GetFloaters();
    internal ReadOnlyCollection`1<ParagraphResult> GetFigures();
    internal virtual TextContentRange GetTextContentRange();
    internal void GetLineDetails(int dcpLine, Int32& cchContent, Int32& cchEllipses);
    internal virtual int GetFirstTextLineBaseline();
    internal ITextPointer GetTextPosition(int dcp, LogicalDirection direction);
    internal Rect GetRectangleFromTextPosition(ITextPointer position);
    internal Geometry GetTightBoundingGeometryFromTextPositions(ITextPointer startPosition, ITextPointer endPosition, double paragraphTopSpace, Rect visibleRect);
    internal bool IsAtCaretUnitBoundary(ITextPointer position);
    internal ITextPointer GetNextCaretUnitPosition(ITextPointer position, LogicalDirection direction);
    internal ITextPointer GetBackspaceCaretUnitPosition(ITextPointer position);
    internal ITextPointer GetTextPositionFromDistance(int dcpLine, double distance);
    internal void GetGlyphRuns(List`1<GlyphRun> glyphRuns, ITextPointer start, ITextPointer end);
    internal TextParagraph get_TextParagraph();
    internal bool get_HasEOP();
    internal virtual bool get_IsFirstChunk();
    internal virtual bool get_IsLastChunk();
    protected virtual void OnArrange();
    private void SyncUpdateDeferredLineVisuals(VisualCollection lineVisuals, FSTEXTDETAILSFULL& textDetails, bool ignoreUpdateInfo);
    private ReadOnlyCollection`1<LineResult> LineResultsFromSimpleLines(FSTEXTDETAILSFULL& textDetails);
    private ReadOnlyCollection`1<LineResult> LineResultsFromCompositeLines(FSTEXTDETAILSFULL& textDetails);
    private void RectFromDcpSimpleLines(int dcp, int originalDcp, LogicalDirection orientation, TextPointerContext context, FSTEXTDETAILSFULL& textDetails, Rect& rect, Int32& vrBaseline);
    private void RectFromDcpCompositeLines(int dcp, int originalDcp, LogicalDirection orientation, TextPointerContext context, FSTEXTDETAILSFULL& textDetails, Rect& rect, Int32& vrBaseline);
    private Geometry PathGeometryFromDcpRangeSimpleLines(int dcpStart, int dcpEnd, double paragraphTopSpace, bool handleEndOfPara, FSTEXTDETAILSFULL& textDetails, Rect visibleRect);
    private Geometry PathGeometryFromDcpRangeCompositeLines(int dcpStart, int dcpEnd, double paragraphTopSpace, bool handleEndOfPara, FSTEXTDETAILSFULL& textDetails, Rect visibleRect);
    private bool HasAnyLineBreakAtCp(int dcp);
    private List`1<Rect> RectanglesFromDcpRangeOfSimpleLine(int dcpRangeStart, int cchRange, double lineTopSpace, double lineRightSpace, FSLINEDESCRIPTIONSINGLE& lineDesc, int lineIndex, Rect visibleRect);
    private List`1<Rect> RectanglesFromDcpRangeOfCompositeLineElement(int dcpRangeStart, int cchRange, double lineTopSpace, double lineRightSpace, FSLINEDESCRIPTIONCOMPOSITE& lineDesc, int lineIndex, FSLINEELEMENT& elemDesc, int elemIndex, Rect visibleRect);
    private LineVisual FetchLineVisual(int index);
    private LineVisual FetchLineVisualComposite(int lineIndex, int elemIndex);
    private Geometry PathGeometryFromDcpRangeFloatersAndFigures(int dcpStart, int dcpEnd, FSTEXTDETAILSFULL& textDetails);
    private bool IsAtCaretUnitBoundaryFromDcpSimpleLines(int dcp, ITextPointer position, FSTEXTDETAILSFULL& textDetails);
    private bool IsAtCaretUnitBoundaryFromDcpCompositeLines(int dcp, ITextPointer position, FSTEXTDETAILSFULL& textDetails);
    private ITextPointer NextCaretUnitPositionFromDcpSimpleLines(int dcp, ITextPointer position, LogicalDirection direction, FSTEXTDETAILSFULL& textDetails);
    private ITextPointer NextCaretUnitPositionFromDcpCompositeLines(int dcp, ITextPointer position, LogicalDirection direction, FSTEXTDETAILSFULL& textDetails);
    private ITextPointer BackspaceCaretUnitPositionFromDcpSimpleLines(int dcp, ITextPointer position, FSTEXTDETAILSFULL& textDetails);
    private ITextPointer BackspaceCaretUnitPositionFromDcpCompositeLines(int dcp, ITextPointer position, FSTEXTDETAILSFULL& textDetails);
    private void GetGlyphRunsFromSimpleLines(List`1<GlyphRun> glyphRuns, int dcpStart, int dcpEnd, FSTEXTDETAILSFULL& textDetails);
    private void GetGlyphRunsFromCompositeLines(List`1<GlyphRun> glyphRuns, int dcpStart, int dcpEnd, FSTEXTDETAILSFULL& textDetails);
    private void RenderSimpleLines(ContainerVisual visual, FSTEXTDETAILSFULL& textDetails, bool ignoreUpdateInfo);
    private bool IntersectsWithRectOnV(FSRECT& rect);
    private bool ContainedInRectOnV(FSRECT& rect);
    private ContainerVisual CreateLineVisual(FSLINEDESCRIPTIONSINGLE& lineDesc, int cpTextParaStart);
    private void UpdateViewportSimpleLines(ContainerVisual visual, FSTEXTDETAILSFULL& textDetails, FSRECT& viewport);
    private void RenderCompositeLines(ContainerVisual visual, FSTEXTDETAILSFULL& textDetails, bool ignoreUpdateInfo);
    private void ValidateVisualFloatersAndFigures(FSKUPDATE fskupdInherited, int cAttachedObjects);
    private IInputElement InputHitTestSimpleLines(FSPOINT pt, FSTEXTDETAILSFULL& textDetails);
    private bool IsDeferredVisualCreationSupported(FSTEXTDETAILSFULL& textDetails);
    private List`1<Rect> GetRectanglesInSimpleLines(ContentElement e, int start, int length, FSTEXTDETAILSFULL& textDetails);
    private List`1<Rect> GetRectanglesInSingleLine(FSLINEDESCRIPTIONSINGLE lineDesc, ContentElement e, int start, int length);
    private IInputElement InputHitTestCompositeLines(FSPOINT pt, FSTEXTDETAILSFULL& textDetails);
    private List`1<Rect> GetRectanglesInCompositeLines(ContentElement e, int start, int length, FSTEXTDETAILSFULL& textDetails);
    private List`1<Rect> GetRectanglesInCompositeLine(FSLINEDESCRIPTIONCOMPOSITE lineDesc, ContentElement e, int start, int length);
    private bool get_IsOptimalParagraph();
}
internal class MS.Internal.PtsHost.TextParagraph : BaseParagraph {
    private List`1<AttachedObject> _attachedObjects;
    private List`1<InlineObject> _inlineObjects;
    private LineProperties _lineProperties;
    private TextRunCache _textRunCache;
    private Line _currentLine;
    internal TextRunCache TextRunCache { get; }
    internal LineProperties Properties { get; }
    internal bool IsOptimalParagraph { get; }
    internal TextParagraph(DependencyObject element, StructuralCache structuralCache);
    public virtual void Dispose();
    internal virtual void GetParaProperties(FSPAP& fspap);
    internal virtual void CreateParaclient(IntPtr& paraClientHandle);
    internal void GetTextProperties(int iArea, FSTXTPROPS& fstxtprops);
    internal void CreateOptimalBreakSession(TextParaClient textParaClient, int dcpStart, int durTrack, LineBreakRecord lineBreakRecord, OptimalBreakSession& optimalBreakSession, Boolean& isParagraphJustified);
    internal void GetNumberFootnotes(int fsdcpStart, int fsdcpLim, Int32& nFootnote);
    internal void FormatBottomText(int iArea, UInt32 fswdir, Line lastLine, int dvrLine, IntPtr& mcsClient);
    internal bool InterruptFormatting(int dcpCur, int vrCur);
    internal IList`1<TextBreakpoint> FormatLineVariants(TextParaClient textParaClient, TextParagraphCache textParagraphCache, OptimalTextSource optimalTextSource, int dcp, TextLineBreak textLineBreak, UInt32 fswdir, int urStartLine, int durLine, bool allowHyphenation, bool clearOnLeft, bool clearOnRight, bool treatAsFirstInPara, bool treatAsLastInPara, bool suppressTopSpace, IntPtr lineVariantRestriction, Int32& iLineBestVariant);
    internal void ReconstructLineVariant(TextParaClient paraClient, int iArea, int dcp, IntPtr pbrlineIn, int dcpLineIn, UInt32 fswdir, int urStartLine, int durLine, int urStartTrack, int durTrack, int urPageLeftMargin, bool fAllowHyphenation, bool fClearOnLeft, bool fClearOnRight, bool fTreatAsFirstInPara, bool fTreatAsLastInPara, bool fSuppressTopSpace, IntPtr& lineHandle, Int32& dcpLine, IntPtr& ppbrlineOut, Int32& fForcedBroken, FSFLRES& fsflres, Int32& dvrAscent, Int32& dvrDescent, Int32& urBBox, Int32& durBBox, Int32& dcpDepend, Int32& fReformatNeighborsAsLastLine);
    internal void FormatLine(TextParaClient paraClient, int iArea, int dcp, IntPtr pbrlineIn, UInt32 fswdir, int urStartLine, int durLine, int urStartTrack, int durTrack, int urPageLeftMargin, bool fAllowHyphenation, bool fClearOnLeft, bool fClearOnRight, bool fTreatAsFirstInPara, bool fTreatAsLastInPara, bool fSuppressTopSpace, IntPtr& lineHandle, Int32& dcpLine, IntPtr& ppbrlineOut, Int32& fForcedBroken, FSFLRES& fsflres, Int32& dvrAscent, Int32& dvrDescent, Int32& urBBox, Int32& durBBox, Int32& dcpDepend, Int32& fReformatNeighborsAsLastLine);
    internal void UpdGetChangeInText(Int32& dcpStart, Int32& ddcpOld, Int32& ddcpNew);
    internal void GetDvrAdvance(int dcp, UInt32 fswdir, Int32& dvr);
    internal int GetLastDcpAttachedObjectBeforeLine(int dcpFirst);
    private List`1<TextElement> GetAttachedObjectElements(int dcpFirst, int dcpLast);
    internal int GetAttachedObjectCount(int dcpFirst, int dcpLast);
    internal List`1<AttachedObject> GetAttachedObjects(int dcpFirst, int dcpLast);
    internal void SubmitInlineObjects(int dcpStart, int dcpLim, List`1<InlineObject> inlineObjects);
    internal void SubmitAttachedObjects(int dcpStart, int dcpLim, List`1<AttachedObject> attachedObjects);
    internal List`1<InlineObject> InlineObjectsFromRange(int dcpStart, int dcpLast);
    internal void CalcLineAscentDescent(int dcp, Int32& dvrAscent, Int32& dvrDescent);
    internal virtual void SetUpdateInfo(FSKCHANGE fskch, bool stopAsking);
    internal virtual void ClearUpdateInfo();
    internal virtual bool InvalidateStructure(int startPosition);
    internal virtual void InvalidateFormatCache();
    internal void InvalidateTextFormatCache();
    internal void FormatLineCore(Line line, IntPtr pbrLineIn, FormattingContext ctx, int dcp, int width, bool firstLine, int dcpLine);
    internal void FormatLineCore(Line line, IntPtr pbrLineIn, FormattingContext ctx, int dcp, int width, int trackWidth, bool firstLine, int dcpLine);
    internal Size MeasureChild(InlineObjectRun inlineObject);
    internal bool HasFiguresFloatersOrInlineObjects();
    internal bool HasFiguresOrFloaters();
    internal void UpdateTextContentRangeFromAttachedObjects(TextContentRange textContentRange, int dcpFirst, int dcpLast, FSATTACHEDOBJECTDESCRIPTION[] arrayAttachedObjectDesc);
    internal void OnUIElementDesiredSizeChanged(object sender, DesiredSizeChangedEventArgs e);
    internal TextRunCache get_TextRunCache();
    internal LineProperties get_Properties();
    internal bool get_IsOptimalParagraph();
    private void EnsureLineProperties();
    private void SubmitEmbeddedObjects(List`1& objectsCached, int dcpStart, int dcpLim, List`1<T> objectsNew);
    private void UpdateEmbeddedObjectsCache(List`1& objectsCached, int dcpStart, int cchDeleted, int cchDiff);
    private TextParagraphProperties GetLineProperties(bool firstLine, int dcpLine);
}
internal class MS.Internal.PtsHost.TextParaLineResult : LineResult {
    private TextParaClient _owner;
    private int _dcp;
    private int _cch;
    private Rect _layoutBox;
    private double _baseline;
    private ITextPointer _startPosition;
    private ITextPointer _endPosition;
    private int _cchContent;
    private int _cchEllipses;
    internal ITextPointer StartPosition { get; }
    internal ITextPointer EndPosition { get; }
    internal int StartPositionCP { get; }
    internal int EndPositionCP { get; }
    internal Rect LayoutBox { get; }
    internal double Baseline { get; }
    internal int DcpLast { get; internal set; }
    internal TextParaLineResult(TextParaClient owner, int dcp, int cch, Rect layoutBox, double baseline);
    internal virtual ITextPointer GetTextPositionFromDistance(double distance);
    internal virtual bool IsAtCaretUnitBoundary(ITextPointer position);
    internal virtual ITextPointer GetNextCaretUnitPosition(ITextPointer position, LogicalDirection direction);
    internal virtual ITextPointer GetBackspaceCaretUnitPosition(ITextPointer position);
    internal virtual ReadOnlyCollection`1<GlyphRun> GetGlyphRuns(ITextPointer start, ITextPointer end);
    internal virtual ITextPointer GetContentEndPosition();
    internal virtual ITextPointer GetEllipsesPosition();
    internal virtual int GetContentEndPositionCP();
    internal virtual int GetEllipsesPositionCP();
    internal virtual ITextPointer get_StartPosition();
    internal virtual ITextPointer get_EndPosition();
    internal virtual int get_StartPositionCP();
    internal virtual int get_EndPositionCP();
    internal virtual Rect get_LayoutBox();
    internal virtual double get_Baseline();
    internal int get_DcpLast();
    internal void set_DcpLast(int value);
    private void EnsureComplexData();
}
internal class MS.Internal.PtsHost.UIElementParaClient : FloaterBaseParaClient {
    internal UIElementParaClient(FloaterBaseParagraph paragraph);
    protected virtual void OnArrange();
    internal virtual List`1<Rect> GetRectangles(ContentElement e, int start, int length);
    internal virtual void ValidateVisual(FSKUPDATE fskupdInherited);
    internal Geometry GetTightBoundingGeometryFromTextPositions(ITextPointer startPosition, ITextPointer endPosition);
    internal virtual ParagraphResult CreateParagraphResult();
    internal virtual IInputElement InputHitTest(FSPOINT pt);
    internal virtual TextContentRange GetTextContentRange();
}
internal class MS.Internal.PtsHost.UIElementParagraph : FloaterBaseParagraph {
    private UIElementIsland _uiElementIsland;
    internal UIElementIsland UIElementIsland { get; }
    private bool SizeToFigureParent { get; }
    private bool IsOnlyChildOfFigure { get; }
    internal UIElementParagraph(TextElement element, StructuralCache structuralCache);
    public virtual void Dispose();
    internal virtual bool InvalidateStructure(int startPosition);
    internal virtual void CreateParaclient(IntPtr& paraClientHandle);
    internal virtual void CollapseMargin(BaseParaClient paraClient, MarginCollapsingState mcs, UInt32 fswdir, bool suppressTopSpace, Int32& dvr);
    internal virtual void GetFloaterProperties(UInt32 fswdirTrack, FSFLOATERPROPS& fsfloaterprops);
    internal virtual void FormatFloaterContentFinite(FloaterBaseParaClient paraClient, IntPtr pbrkrecIn, int fBRFromPreviousPage, IntPtr footnoteRejector, int fEmptyOk, int fSuppressTopSpace, UInt32 fswdir, int fAtMaxWidth, int durAvailable, int dvrAvailable, FSKSUPPRESSHARDBREAKBEFOREFIRSTPARA fsksuppresshardbreakbeforefirstparaIn, FSFMTR& fsfmtr, IntPtr& pfsFloatContent, IntPtr& pbrkrecOut, Int32& durFloaterWidth, Int32& dvrFloaterHeight, FSBBOX& fsbbox, Int32& cPolygons, Int32& cVertices);
    internal virtual void FormatFloaterContentBottomless(FloaterBaseParaClient paraClient, int fSuppressTopSpace, UInt32 fswdir, int fAtMaxWidth, int durAvailable, int dvrAvailable, FSFMTRBL& fsfmtrbl, IntPtr& pfsFloatContent, Int32& durFloaterWidth, Int32& dvrFloaterHeight, FSBBOX& fsbbox, Int32& cPolygons, Int32& cVertices);
    internal virtual void UpdateBottomlessFloaterContent(FloaterBaseParaClient paraClient, int fSuppressTopSpace, UInt32 fswdir, int fAtMaxWidth, int durAvailable, int dvrAvailable, IntPtr pfsFloatContent, FSFMTRBL& fsfmtrbl, Int32& durFloaterWidth, Int32& dvrFloaterHeight, FSBBOX& fsbbox, Int32& cPolygons, Int32& cVertices);
    internal virtual void GetMCSClientAfterFloater(UInt32 fswdirTrack, MarginCollapsingState mcs, IntPtr& pmcsclientOut);
    private void FormatUIElement(int durAvailable, FSBBOX& fsbbox);
    private void EnsureUIElementIsland();
    private void ClearUIElementIsland();
    private void OnUIElementDesiredSizeChanged(object sender, DesiredSizeChangedEventArgs e);
    internal UIElementIsland get_UIElementIsland();
    private bool get_SizeToFigureParent();
    private bool get_IsOnlyChildOfFigure();
}
internal class MS.Internal.PtsHost.UnmanagedHandle : object {
    private IntPtr _handle;
    private PtsContext _ptsContext;
    internal IntPtr Handle { get; }
    internal PtsContext PtsContext { get; }
    protected UnmanagedHandle(PtsContext ptsContext);
    public virtual void Dispose();
    internal IntPtr get_Handle();
    internal PtsContext get_PtsContext();
}
internal static class MS.Internal.PtsHost.UnsafeNativeMethods.PTS : object {
    internal static int True;
    internal static int False;
    internal static int dvBottomUndefined;
    internal static int MaxFontSize;
    internal static int MaxPageSize;
    internal static int fsffiWordFlowTextFinite;
    internal static int fsffiWordClashFootnotesWithText;
    internal static int fsffiWordNewSectionAboveFootnotes;
    internal static int fsffiWordStopAfterFirstCollision;
    internal static int fsffiUseTextParaCache;
    internal static int fsffiKeepClientLines;
    internal static int fsffiUseTextQuickLoop;
    internal static int fsffiAvalonDisableOptimalInChains;
    internal static int fsffiWordAdjustTrackWidthsForFigureInWebView;
    internal static int fsidobjText;
    internal static int fsidobjFigure;
    internal static int fswdirDefault;
    internal static int fswdirES;
    internal static int fswdirEN;
    internal static int fswdirSE;
    internal static int fswdirSW;
    internal static int fswdirWS;
    internal static int fswdirWN;
    internal static int fswdirNE;
    internal static int fswdirNW;
    internal static int fUDirection;
    internal static int fVDirection;
    internal static int fUVertical;
    internal static int fserrNone;
    internal static int fserrOutOfMemory;
    internal static int fserrNotImplemented;
    internal static int fserrCallbackException;
    internal static int tserrNone;
    internal static int tserrInvalidParameter;
    internal static int tserrOutOfMemory;
    internal static int tserrNullOutputParameter;
    internal static int tserrInvalidLsContext;
    internal static int tserrInvalidLine;
    internal static int tserrInvalidDnode;
    internal static int tserrInvalidDeviceResolution;
    internal static int tserrInvalidRun;
    internal static int tserrMismatchLineContext;
    internal static int tserrContextInUse;
    internal static int tserrDuplicateSpecialCharacter;
    internal static int tserrInvalidAutonumRun;
    internal static int tserrFormattingFunctionDisabled;
    internal static int tserrUnfinishedDnode;
    internal static int tserrInvalidDnodeType;
    internal static int tserrInvalidPenDnode;
    internal static int tserrInvalidNonPenDnode;
    internal static int tserrInvalidBaselinePenDnode;
    internal static int tserrInvalidFormatterResult;
    internal static int tserrInvalidObjectIdFetched;
    internal static int tserrInvalidDcpFetched;
    internal static int tserrInvalidCpContentFetched;
    internal static int tserrInvalidBookmarkType;
    internal static int tserrSetDocDisabled;
    internal static int tserrFiniFunctionDisabled;
    internal static int tserrCurrentDnodeIsNotTab;
    internal static int tserrPendingTabIsNotResolved;
    internal static int tserrWrongFiniFunction;
    internal static int tserrInvalidBreakingClass;
    internal static int tserrBreakingTableNotSet;
    internal static int tserrInvalidModWidthClass;
    internal static int tserrModWidthPairsNotSet;
    internal static int tserrWrongTruncationPoint;
    internal static int tserrWrongBreak;
    internal static int tserrDupInvalid;
    internal static int tserrRubyInvalidVersion;
    internal static int tserrTatenakayokoInvalidVersion;
    internal static int tserrWarichuInvalidVersion;
    internal static int tserrWarichuInvalidData;
    internal static int tserrCreateSublineDisabled;
    internal static int tserrCurrentSublineDoesNotExist;
    internal static int tserrCpOutsideSubline;
    internal static int tserrHihInvalidVersion;
    internal static int tserrInsufficientQueryDepth;
    internal static int tserrInvalidBreakRecord;
    internal static int tserrInvalidPap;
    internal static int tserrContradictoryQueryInput;
    internal static int tserrLineIsNotActive;
    internal static int tserrTooLongParagraph;
    internal static int tserrTooManyCharsToGlyph;
    internal static int tserrWrongHyphenationPosition;
    internal static int tserrTooManyPriorities;
    internal static int tserrWrongGivenCp;
    internal static int tserrWrongCpFirstForGetBreaks;
    internal static int tserrWrongJustTypeForGetBreaks;
    internal static int tserrWrongJustTypeForCreateLineGivenCp;
    internal static int tserrTooLongGlyphContext;
    internal static int tserrInvalidCharToGlyphMapping;
    internal static int tserrInvalidMathUsage;
    internal static int tserrInconsistentChp;
    internal static int tserrStoppedInSubline;
    internal static int tserrPenPositionCouldNotBeUsed;
    internal static int tserrDebugFlagsInShip;
    internal static int tserrInvalidOrderTabs;
    internal static int tserrSystemRestrictionsExceeded;
    internal static int tserrInvalidPtsContext;
    internal static int tserrInvalidClientOutput;
    internal static int tserrInvalidObjectOutput;
    internal static int tserrInvalidGeometry;
    internal static int tserrInvalidFootnoteRejector;
    internal static int tserrInvalidFootnoteInfo;
    internal static int tserrOutputArrayTooSmall;
    internal static int tserrWordNotSupportedInBottomless;
    internal static int tserrPageTooLong;
    internal static int tserrInvalidQuery;
    internal static int tserrWrongWritingDirection;
    internal static int tserrPageNotClearedForUpdate;
    internal static int tserrInternalError;
    internal static int tserrNotImplemented;
    internal static int tserrClientAbort;
    internal static int tserrPageSizeMismatch;
    internal static int tserrCallbackException;
    internal static int fsfdbgCheckVariantsConsistency;
    internal static void IgnoreError(int fserr);
    internal static void Validate(int fserr);
    internal static void Validate(int fserr, PtsContext ptsContext);
    private static void Error(int fserr, PtsContext ptsContext);
    internal static void ValidateAndTrace(int fserr, PtsContext ptsContext);
    private static void ErrorTrace(int fserr, PtsContext ptsContext);
    private static Exception GetInnermostException(PtsContext ptsContext);
    internal static void ValidateHandle(object handle);
    private static void InvalidHandle();
    internal static int FromBoolean(bool condition);
    internal static bool ToBoolean(int flag);
    internal static FSKWRAP WrapDirectionToFskwrap(WrapDirection wrapDirection);
    internal static FSKCLEAR WrapDirectionToFskclear(WrapDirection wrapDirection);
    internal static FlowDirection FswdirToFlowDirection(UInt32 fswdir);
    internal static UInt32 FlowDirectionToFswdir(FlowDirection fd);
    internal static int GetFloaterHandlerInfo(FSFLOATERINIT& pfsfloaterinit, IntPtr pFloaterObjectInfo);
    internal static int GetTableObjHandlerInfo(FSTABLEOBJINIT& pfstableobjinit, IntPtr pTableObjectInfo);
    internal static int CreateInstalledObjectsInfo(FSIMETHODS& fssubtrackparamethods, FSIMETHODS& fssubpageparamethods, IntPtr& pInstalledObjects, Int32& cInstalledObjects);
    internal static int DestroyInstalledObjectsInfo(IntPtr pInstalledObjects);
    internal static int CreateDocContext(FSCONTEXTINFO& fscontextinfo, IntPtr& pfscontext);
    internal static int DestroyDocContext(IntPtr pfscontext);
    internal static int FsCreatePageFinite(IntPtr pfscontext, IntPtr pfsBRPageStart, IntPtr fsnmSectStart, FSFMTR& pfsfmtrOut, IntPtr& ppfsPageOut, IntPtr& ppfsBRPageOut);
    internal static int FsUpdateFinitePage(IntPtr pfscontext, IntPtr pfspage, IntPtr pfsBRPageStart, IntPtr fsnmSectStart, FSFMTR& pfsfmtrOut, IntPtr& ppfsBRPageOut);
    internal static int FsCreatePageBottomless(IntPtr pfscontext, IntPtr fsnmsect, FSFMTRBL& pfsfmtrbl, IntPtr& ppfspage);
    internal static int FsUpdateBottomlessPage(IntPtr pfscontext, IntPtr pfspage, IntPtr fsnmsect, FSFMTRBL& pfsfmtrbl);
    internal static int FsClearUpdateInfoInPage(IntPtr pfscontext, IntPtr pfspage);
    internal static int FsDestroyPage(IntPtr pfscontext, IntPtr pfspage);
    internal static int FsDestroyPageBreakRecord(IntPtr pfscontext, IntPtr pfsbreakrec);
    internal static int FsCreateSubpageFinite(IntPtr pfsContext, IntPtr pBRSubPageStart, int fFromPreviousPage, IntPtr nSeg, IntPtr pFtnRej, int fEmptyOk, int fSuppressTopSpace, UInt32 fswdir, int lWidth, int lHeight, FSRECT& rcMargin, int cColumns, FSCOLUMNINFO* rgColumnInfo, int fApplyColumnBalancing, int cSegmentAreas, IntPtr* rgnSegmentForArea, Int32* rgSpanForSegmentArea, int cHeightAreas, Int32* rgHeightForArea, Int32* rgSpanForHeightArea, int fAllowOverhangBottom, FSKSUPPRESSHARDBREAKBEFOREFIRSTPARA fsksuppresshardbreakbeforefirstparaIn, FSFMTR& fsfmtr, IntPtr& pSubPage, IntPtr& pBRSubPageOut, Int32& dvrUsed, FSBBOX& fsBBox, IntPtr& pfsMcsClient, Int32& topSpace);
    internal static int FsCreateSubpageBottomless(IntPtr pfsContext, IntPtr nSeg, int fSuppressTopSpace, UInt32 fswdir, int lWidth, int urMargin, int durMargin, int vrMargin, int cColumns, FSCOLUMNINFO* rgColumnInfo, int cSegmentAreas, IntPtr* rgnSegmentForArea, Int32* rgSpanForSegmentArea, int cHeightAreas, Int32* rgHeightForArea, Int32* rgSpanForHeightArea, int fINterrruptible, FSFMTRBL& pfsfmtr, IntPtr& ppSubPage, Int32& pdvrUsed, FSBBOX& pfsBBox, IntPtr& pfsMcsClient, Int32& pTopSpace, Int32& fPageBecomesUninterruptible);
    internal static int FsUpdateBottomlessSubpage(IntPtr pfsContext, IntPtr pfsSubpage, IntPtr nmSeg, int fSuppressTopSpace, UInt32 fswdir, int lWidth, int urMargin, int durMargin, int vrMargin, int cColumns, FSCOLUMNINFO* rgColumnInfo, int cSegmentAreas, IntPtr* rgnSegmentForArea, Int32* rgSpanForSegmentArea, int cHeightAreas, Int32* rgHeightForArea, Int32* rgSpanForHeightArea, int fINterrruptible, FSFMTRBL& pfsfmtr, Int32& pdvrUsed, FSBBOX& pfsBBox, IntPtr& pfsMcsClient, Int32& pTopSpace, Int32& fPageBecomesUninterruptible);
    internal static int FsCompareSubpages(IntPtr pfsContext, IntPtr pfsSubpageOld, IntPtr pfsSubpageNew, FSCOMPRESULT& fsCompResult);
    internal static int FsClearUpdateInfoInSubpage(IntPtr pfscontext, IntPtr pSubpage);
    internal static int FsDestroySubpage(IntPtr pfsContext, IntPtr pSubpage);
    internal static int FsDuplicateSubpageBreakRecord(IntPtr pfsContext, IntPtr pBreakRecSubPageIn, IntPtr& ppBreakRecSubPageOut);
    internal static int FsDestroySubpageBreakRecord(IntPtr pfscontext, IntPtr pfsbreakrec);
    internal static int FsGetSubpageColumnBalancingInfo(IntPtr pfsContext, IntPtr pSubpage, UInt32& fswdir, Int32& lLineNumber, Int32& lLineHeights, Int32& lMinimumLineHeight);
    internal static int FsGetNumberSubpageFootnotes(IntPtr pfsContext, IntPtr pSubpage, Int32& cFootnotes);
    internal static int FsGetSubpageFootnoteInfo(IntPtr pfsContext, IntPtr pSubpage, int cArraySize, int indexStart, UInt32& fswdir, FSFTNINFO* rgFootnoteInfo, Int32& indexLim);
    internal static int FsTransferDisplayInfoSubpage(IntPtr pfsContext, IntPtr pSubpageOld, IntPtr pfsSubpageNew);
    internal static int FsFormatSubtrackFinite(IntPtr pfsContext, IntPtr pfsBRSubtackIn, int fFromPreviousPage, IntPtr fsnmSegment, int iArea, IntPtr pfsFtnRej, IntPtr pfsGeom, int fEmptyOk, int fSuppressTopSpace, UInt32 fswdir, FSRECT& fsRectToFill, IntPtr pfsMcsClientIn, FSKCLEAR fsKClearIn, FSKSUPPRESSHARDBREAKBEFOREFIRSTPARA fsksuppresshardbreakbeforefirstpara, FSFMTR& pfsfmtr, IntPtr& ppfsSubtrack, IntPtr& pfsBRSubtrackOut, Int32& pdvrUsed, FSBBOX& pfsBBox, IntPtr& ppfsMcsClientOut, FSKCLEAR& pfsKClearOut, Int32& pTopSpace);
    internal static int FsFormatSubtrackBottomless(IntPtr pfsContext, IntPtr fsnmSegment, int iArea, IntPtr pfsGeom, int fSuppressTopSpace, UInt32 fswdir, int ur, int dur, int vr, IntPtr pfsMcsClientIn, FSKCLEAR fsKClearIn, int fCanBeInterruptedIn, FSFMTRBL& pfsfmtrbl, IntPtr& ppfsSubtrack, Int32& pdvrUsed, FSBBOX& pfsBBox, IntPtr& ppfsMcsClientOut, FSKCLEAR& pfsKClearOut, Int32& pTopSpace, Int32& pfCanBeInterruptedOut);
    internal static int FsUpdateBottomlessSubtrack(IntPtr pfsContext, IntPtr pfsSubtrack, IntPtr fsnmSegment, int iArea, IntPtr pfsGeom, int fSuppressTopSpace, UInt32 fswdir, int ur, int dur, int vr, IntPtr pfsMcsClientIn, FSKCLEAR fsKClearIn, int fCanBeInterruptedIn, FSFMTRBL& pfsfmtrbl, Int32& pdvrUsed, FSBBOX& pfsBBox, IntPtr& ppfsMcsClientOut, FSKCLEAR& pfsKClearOut, Int32& pTopSpace, Int32& pfCanBeInterruptedOut);
    internal static int FsSynchronizeBottomlessSubtrack(IntPtr pfsContext, IntPtr pfsSubtrack, IntPtr pfsGeom, UInt32 fswdir, int vrShift);
    internal static int FsCompareSubtrack(IntPtr pfsContext, IntPtr pfsSubtrackOld, IntPtr pfsSubtrackNew, UInt32 fswdir, FSCOMPRESULT& fsCompResult, Int32& dvrShifted);
    internal static int FsClearUpdateInfoInSubtrack(IntPtr pfsContext, IntPtr pfsSubtrack);
    internal static int FsDestroySubtrack(IntPtr pfsContext, IntPtr pfsSubtrack);
    internal static int FsDuplicateSubtrackBreakRecord(IntPtr pfsContext, IntPtr pfsBRSubtrackIn, IntPtr& ppfsBRSubtrackOut);
    internal static int FsDestroySubtrackBreakRecord(IntPtr pfscontext, IntPtr pfsbreakrec);
    internal static int FsGetSubtrackColumnBalancingInfo(IntPtr pfscontext, IntPtr pfsSubtrack, UInt32 fswdir, Int32& lLineNumber, Int32& lLineHeights, Int32& lMinimumLineHeight);
    internal static int FsGetNumberSubtrackFootnotes(IntPtr pfscontext, IntPtr pfsSubtrack, Int32& cFootnotes);
    internal static int FsTransferDisplayInfoSubtrack(IntPtr pfscontext, IntPtr pfsSubtrackOld, IntPtr pfsSubtrackNew);
    internal static int FsQueryFloaterDetails(IntPtr pfsContext, IntPtr pfsfloater, FSFLOATERDETAILS& fsfloaterdetails);
    internal static int FsQueryPageDetails(IntPtr pfsContext, IntPtr pPage, FSPAGEDETAILS& pPageDetails);
    internal static int FsQueryPageSectionList(IntPtr pfsContext, IntPtr pPage, int cArraySize, FSSECTIONDESCRIPTION* rgSectionDescription, Int32& cActualSize);
    internal static int FsQuerySectionDetails(IntPtr pfsContext, IntPtr pSection, FSSECTIONDETAILS& pSectionDetails);
    internal static int FsQuerySectionBasicColumnList(IntPtr pfsContext, IntPtr pSection, int cArraySize, FSTRACKDESCRIPTION* rgColumnDescription, Int32& cActualSize);
    internal static int FsQueryTrackDetails(IntPtr pfsContext, IntPtr pTrack, FSTRACKDETAILS& pTrackDetails);
    internal static int FsQueryTrackParaList(IntPtr pfsContext, IntPtr pTrack, int cParas, FSPARADESCRIPTION* rgParaDesc, Int32& cParaDesc);
    internal static int FsQuerySubpageDetails(IntPtr pfsContext, IntPtr pSubPage, FSSUBPAGEDETAILS& pSubPageDetails);
    internal static int FsQuerySubpageBasicColumnList(IntPtr pfsContext, IntPtr pSubPage, int cArraySize, FSTRACKDESCRIPTION* rgColumnDescription, Int32& cActualSize);
    internal static int FsQuerySubtrackDetails(IntPtr pfsContext, IntPtr pSubTrack, FSSUBTRACKDETAILS& pSubTrackDetails);
    internal static int FsQuerySubtrackParaList(IntPtr pfsContext, IntPtr pSubTrack, int cParas, FSPARADESCRIPTION* rgParaDesc, Int32& cParaDesc);
    internal static int FsQueryTextDetails(IntPtr pfsContext, IntPtr pPara, FSTEXTDETAILS& pTextDetails);
    internal static int FsQueryLineListSingle(IntPtr pfsContext, IntPtr pPara, int cLines, FSLINEDESCRIPTIONSINGLE* rgLineDesc, Int32& cLineDesc);
    internal static int FsQueryLineListComposite(IntPtr pfsContext, IntPtr pPara, int cElements, FSLINEDESCRIPTIONCOMPOSITE* rgLineDescription, Int32& cLineElements);
    internal static int FsQueryLineCompositeElementList(IntPtr pfsContext, IntPtr pLine, int cElements, FSLINEELEMENT* rgLineElement, Int32& cLineElements);
    internal static int FsQueryAttachedObjectList(IntPtr pfsContext, IntPtr pPara, int cAttachedObject, FSATTACHEDOBJECTDESCRIPTION* rgAttachedObjects, Int32& cAttachedObjectDesc);
    internal static int FsQueryFigureObjectDetails(IntPtr pfsContext, IntPtr pPara, FSFIGUREDETAILS& fsFigureDetails);
    internal static int FsQueryTableObjDetails(IntPtr pfscontext, IntPtr pfstableobj, FSTABLEOBJDETAILS& pfstableobjdetails);
    internal static int FsQueryTableObjTableProperDetails(IntPtr pfscontext, IntPtr pfstableProper, FSTABLEDETAILS& pfstabledetailsProper);
    internal static int FsQueryTableObjRowList(IntPtr pfscontext, IntPtr pfstableProper, int cRows, FSTABLEROWDESCRIPTION* rgtablerowdescr, Int32& pcRowsActual);
    internal static int FsQueryTableObjRowDetails(IntPtr pfscontext, IntPtr pfstablerow, FSTABLEROWDETAILS& ptableorowdetails);
    internal static int FsQueryTableObjCellList(IntPtr pfscontext, IntPtr pfstablerow, int cCells, FSKUPDATE* rgfskupd, IntPtr* rgpfscell, FSTABLEKCELLMERGE* rgkcellmerge, Int32& pcCellsActual);
    internal static int FsTransformRectangle(UInt32 fswdirIn, FSRECT& rectPage, FSRECT& rectTransform, UInt32 fswdirOut, FSRECT& rectOut);
    internal static int FsTransformBbox(UInt32 fswdirIn, FSRECT& rectPage, FSBBOX& bboxTransform, UInt32 fswdirOut, FSBBOX& bboxOut);
}
internal class MS.Internal.PtsHost.UpdateRecord : object {
    internal DirtyTextRange Dtr;
    internal BaseParagraph FirstPara;
    internal BaseParagraph SyncPara;
    internal FSKCHANGE ChangeType;
    internal UpdateRecord Next;
    internal bool InProcessing;
    internal void MergeWithNext();
}
internal class MS.Internal.PtsTable.CalculatedColumn : ValueType {
    private GridLength _userWidth;
    private double _durWidth;
    private double _durMinWidth;
    private double _durMaxWidth;
    private double _urOffset;
    private Flags _flags;
    internal int PtsWidthChanged { get; }
    internal double DurMinWidth { get; }
    internal double DurMaxWidth { get; }
    internal GridLength UserWidth { get; internal set; }
    internal double DurWidth { get; internal set; }
    internal double UrOffset { get; internal set; }
    internal void ValidateAuto(double durMinWidth, double durMaxWidth);
    internal int get_PtsWidthChanged();
    internal double get_DurMinWidth();
    internal double get_DurMaxWidth();
    internal GridLength get_UserWidth();
    internal void set_UserWidth(GridLength value);
    internal double get_DurWidth();
    internal void set_DurWidth(double value);
    internal double get_UrOffset();
    internal void set_UrOffset(double value);
    private void SetFlags(bool value, Flags flags);
    private bool CheckFlags(Flags flags);
}
internal class MS.Internal.PtsTable.RowSpanVector : object {
    private Entry[] _entries;
    private int _size;
    private int _index;
    private static int c_defaultCapacity;
    private static TableCell[] s_noCells;
    private static RowSpanVector();
    internal void Register(TableCell cell);
    internal void GetFirstAvailableRange(Int32& firstAvailableIndex, Int32& firstOccupiedIndex);
    internal void GetNextAvailableRange(Int32& firstAvailableIndex, Int32& firstOccupiedIndex);
    internal void GetSpanCells(TableCell[]& cells, Boolean& isLastRowOfAnySpan);
    internal bool Empty();
    private void InflateCapacity();
}
internal class MS.Internal.SecurityMgrSite : object {
    public sealed virtual void GetWindow(IntPtr& phwnd);
    public sealed virtual void EnableModeless(bool fEnable);
}
internal static class MS.Internal.SystemCoreHelper : object {
    internal static bool IsIDynamicMetaObjectProvider(object item);
    internal static object NewDynamicPropertyAccessor(Type ownerType, string propertyName);
    internal static object GetIndexerAccessor(int rank);
}
internal static class MS.Internal.SystemDataHelper : object {
    internal static bool IsDataView(IBindingList list);
    internal static bool IsDataRowView(object item);
    internal static bool IsSqlNull(object value);
    internal static bool IsSqlNullableType(Type type);
    internal static bool IsDataSetCollectionProperty(PropertyDescriptor pd);
    internal static object GetValue(object item, PropertyDescriptor pd, bool useFollowParent);
    internal static bool DetermineWhetherDBNullIsValid(object item, string columnName, object arg);
    internal static object NullValueForSqlNullableType(Type type);
}
internal static class MS.Internal.SystemXmlHelper : object {
    internal static bool IsXmlNode(object item);
    internal static bool IsXmlNamespaceManager(object item);
    internal static bool TryGetValueFromXmlNode(object item, string name, Object& value);
    internal static IComparer PrepareXmlComparer(IEnumerable collection, SortDescriptionCollection sort, CultureInfo culture);
    internal static bool IsEmptyXmlDataCollection(object parent);
    internal static string GetXmlTagName(object item, DependencyObject target);
    internal static object FindXmlNodeWithInnerText(IEnumerable items, object innerText, Int32& index);
    internal static object GetInnerText(object item);
}
internal static class MS.Internal.SystemXmlLinqHelper : object {
    internal static bool IsXElement(object item);
    internal static string GetXElementTagName(object item);
    internal static bool IsXLinqCollectionProperty(PropertyDescriptor pd);
    internal static bool IsXLinqNonIdempotentProperty(PropertyDescriptor pd);
}
internal static class MS.Internal.Telemetry.PresentationFramework.ControlsTraceLogger : object {
    private static string ControlsUsed;
    private static TelemetryControls _telemetryControls;
    private static ControlsTraceLogger();
    internal static void LogUsedControlsDetails();
    internal static void AddControl(TelemetryControls control);
}
internal class MS.Internal.Telemetry.PresentationFramework.EventSourceActivity : object {
    private static Guid _emptyGuid;
    private EventSource _eventSource;
    private EventSourceOptions _startStopOptions;
    private Guid _parentId;
    private Guid _id;
    private State _state;
    internal EventSource EventSource { get; }
    internal Guid Id { get; }
    internal EventSourceActivity(EventSource eventSource);
    internal EventSourceActivity(EventSource eventSource, EventSourceOptions startStopOptions);
    internal EventSourceActivity(EventSource eventSource, EventSourceOptions startStopOptions, Guid parentActivityId);
    internal EventSourceActivity(EventSourceActivity parentActivity);
    internal EventSourceActivity(EventSourceActivity parentActivity, EventSourceOptions startStopOptions);
    internal EventSource get_EventSource();
    internal Guid get_Id();
    internal void Start(string eventName);
    internal void Start(string eventName, T data);
    internal void Stop(string eventName);
    internal void Stop(string eventName, T data);
    internal void Write(string eventName);
    internal void Write(string eventName, EventSourceOptions options);
    internal void Write(string eventName, T data);
    internal void Write(string eventName, EventSourceOptions options, T data);
    public sealed virtual void Dispose();
    private void Start(string eventName, T& data);
    private void Write(string eventName, EventSourceOptions& options, T& data);
    private void Stop(string eventName, T& data);
}
[FlagsAttribute]
internal enum MS.Internal.Telemetry.PresentationFramework.TelemetryControls : Enum {
    public long value__;
    public static TelemetryControls None;
    public static TelemetryControls Border;
    public static TelemetryControls Button;
    public static TelemetryControls Calendar;
    public static TelemetryControls Canvas;
    public static TelemetryControls CheckBox;
    public static TelemetryControls ComboBox;
    public static TelemetryControls ContentControl;
    public static TelemetryControls DataGrid;
    public static TelemetryControls DatePicker;
    public static TelemetryControls DockPanel;
    public static TelemetryControls DocumentViewer;
    public static TelemetryControls Expander;
    public static TelemetryControls Frame;
    public static TelemetryControls Grid;
    public static TelemetryControls GridSplitter;
    public static TelemetryControls GroupBox;
    public static TelemetryControls Image;
    public static TelemetryControls Label;
    public static TelemetryControls ListBox;
    public static TelemetryControls ListView;
    public static TelemetryControls MediaElement;
    public static TelemetryControls Menu;
    public static TelemetryControls PasswordBox;
    public static TelemetryControls ProgressBar;
    public static TelemetryControls RadioButton;
    public static TelemetryControls RichTextBox;
    public static TelemetryControls ScrollBar;
    public static TelemetryControls ScrollViewer;
    public static TelemetryControls Separator;
    public static TelemetryControls Slider;
    public static TelemetryControls StackPanel;
    public static TelemetryControls StatusBar;
    public static TelemetryControls TabControl;
    public static TelemetryControls TextBlock;
    public static TelemetryControls TextBox;
    public static TelemetryControls ToolBar;
    public static TelemetryControls ToolBarPanel;
    public static TelemetryControls ToolBarTray;
    public static TelemetryControls TreeView;
    public static TelemetryControls ViewBox;
    public static TelemetryControls WebBrowser;
    public static TelemetryControls WrapPanel;
    public static TelemetryControls FlowDocument;
}
internal class MS.Internal.Telemetry.PresentationFramework.TelemetryEventSource : EventSource {
    internal static EventKeywords Reserved44Keyword;
    internal static EventKeywords TelemetryKeyword;
    internal static EventKeywords MeasuresKeyword;
    internal static EventKeywords CriticalDataKeyword;
    internal static EventTags CoreData;
    internal static EventTags InjectXToken;
    internal static EventTags RealtimeLatency;
    internal static EventTags NormalLatency;
    internal static EventTags CriticalPersistence;
    internal static EventTags NormalPersistence;
    internal static EventTags DropPii;
    internal static EventTags HashPii;
    internal static EventTags MarkPii;
    internal static EventFieldTags DropPiiField;
    internal static EventFieldTags HashPiiField;
    private static String[] telemetryTraits;
    internal TelemetryEventSource(string eventSourceName);
    private static TelemetryEventSource();
    internal static EventSourceOptions TelemetryOptions();
    internal static EventSourceOptions MeasuresOptions();
    internal static EventSourceOptions CriticalDataOptions();
}
internal static class MS.Internal.Telemetry.PresentationFramework.TraceLoggingProvider : object {
    private static EventSource _logger;
    private static object _lockObject;
    private static string ProviderName;
    private static TraceLoggingProvider();
    internal static EventSource GetProvider();
}
internal class MS.Internal.Text.ComplexLine : Line {
    private static int _elementEdgeCharacterLength;
    internal ComplexLine(TextBlock owner);
    private static ComplexLine();
    public virtual TextRun GetTextRun(int dcp);
    public virtual TextSpan`1<CultureSpecificCharacterBufferRange> GetPrecedingText(int dcp);
    public virtual int GetTextEffectCharacterIndexFromTextSourceCharacterIndex(int textSourceCharacterIndex);
    internal virtual void Arrange(VisualCollection vc, Vector lineOffset);
    internal virtual bool HasInlineObjects();
    internal virtual IInputElement InputHitTest(double offset);
    private TextRun HandleText(StaticTextPointer position);
    private TextRun HandleElementStartEdge(StaticTextPointer position);
    private TextRun HandleElementEndEdge(StaticTextPointer position);
    private TextRun HandleInlineObject(StaticTextPointer position, int dcp);
    private int CalcPositionOffset(CharacterHit charHit);
}
internal static class MS.Internal.Text.DynamicPropertyReader : object {
    internal static Typeface GetTypeface(DependencyObject element);
    internal static Typeface GetModifiedTypeface(DependencyObject element, FontFamily fontFamily);
    internal static TextDecorationCollection GetTextDecorationsForInlineObject(DependencyObject element, TextDecorationCollection textDecorations);
    internal static TextDecorationCollection GetTextDecorations(DependencyObject element);
    internal static TextEffectCollection GetTextEffects(DependencyObject element);
    private static object GetCollectionValue(DependencyObject element, DependencyProperty property);
    internal static bool GetKeepTogether(DependencyObject element);
    internal static bool GetKeepWithNext(DependencyObject element);
    internal static int GetMinWidowLines(DependencyObject element);
    internal static int GetMinOrphanLines(DependencyObject element);
    internal static double GetLineHeightValue(DependencyObject d);
    internal static Brush GetBackgroundBrush(DependencyObject element);
    internal static Brush GetBackgroundBrushForInlineObject(StaticTextPointer position);
    internal static BaselineAlignment GetBaselineAlignment(DependencyObject element);
    internal static BaselineAlignment GetBaselineAlignmentForInlineObject(DependencyObject element);
    internal static CultureInfo GetCultureInfo(DependencyObject element);
    internal static NumberSubstitution GetNumberSubstitution(DependencyObject element);
    private static bool CanApplyBackgroundBrush(DependencyObject element);
    private static bool BaselineAlignmentIsDefault(DependencyObject element);
}
internal class MS.Internal.Text.InlineObject : TextEmbeddedObject {
    private int _dcp;
    private int _cch;
    private UIElement _element;
    private TextRunProperties _textProps;
    private TextBlock _host;
    public CharacterBufferReference CharacterBufferReference { get; }
    public int Length { get; }
    public TextRunProperties Properties { get; }
    public LineBreakCondition BreakBefore { get; }
    public LineBreakCondition BreakAfter { get; }
    public bool HasFixedSize { get; }
    internal int Dcp { get; }
    internal UIElement Element { get; }
    internal InlineObject(int dcp, int cch, UIElement element, TextRunProperties textProps, TextBlock host);
    public virtual TextEmbeddedObjectMetrics Format(double remainingParagraphWidth);
    public virtual Rect ComputeBoundingBox(bool rightToLeft, bool sideways);
    public virtual void Draw(DrawingContext drawingContext, Point origin, bool rightToLeft, bool sideways);
    public virtual CharacterBufferReference get_CharacterBufferReference();
    public virtual int get_Length();
    public virtual TextRunProperties get_Properties();
    public virtual LineBreakCondition get_BreakBefore();
    public virtual LineBreakCondition get_BreakAfter();
    public virtual bool get_HasFixedSize();
    internal int get_Dcp();
    internal UIElement get_Element();
}
internal static class MS.Internal.Text.InternalEncoding : object {
    private static InternalEncoding();
    internal static Encoding GetEncoding(int codepage);
    internal static Byte[] Convert(Encoding srcEncoding, Encoding dstEncoding, Byte[] bytes);
}
internal abstract class MS.Internal.Text.Line : TextSource {
    protected TextBlock _owner;
    protected TextLine _line;
    protected int _dcp;
    protected static int _syntheticCharacterLength;
    protected bool _mirror;
    protected TextAlignment _textAlignment;
    protected bool _showParagraphEllipsis;
    protected double _wrappingWidth;
    internal double Width { get; }
    internal double Start { get; }
    internal double Height { get; }
    internal double BaselineOffset { get; }
    internal bool EndOfParagraph { get; }
    internal int Length { get; }
    internal int ContentLength { get; }
    protected bool ShowEllipsis { get; }
    protected bool HasLineBreak { get; }
    protected bool IsXOffsetAdjusted { get; }
    protected bool IsWidthAdjusted { get; }
    internal Line(TextBlock owner);
    private static Line();
    public sealed virtual void Dispose();
    internal void Format(int dcp, double width, TextParagraphProperties lineProperties, TextLineBreak textLineBreak, TextRunCache textRunCache, bool showParagraphEllipsis);
    internal virtual void Arrange(VisualCollection vc, Vector lineOffset);
    internal void Render(DrawingContext ctx, Point lineOffset);
    internal Rect GetBoundsFromTextPosition(int characterIndex, FlowDirection& flowDirection);
    internal List`1<Rect> GetRangeBounds(int cp, int cch, double xOffset, double yOffset);
    internal CharacterHit GetTextPositionFromDistance(double distance);
    internal CharacterHit GetNextCaretCharacterHit(CharacterHit index);
    internal CharacterHit GetPreviousCaretCharacterHit(CharacterHit index);
    internal CharacterHit GetBackspaceCaretCharacterHit(CharacterHit index);
    internal bool IsAtCaretCharacterHit(CharacterHit charHit);
    internal virtual bool HasInlineObjects();
    internal virtual IInputElement InputHitTest(double offset);
    internal TextLineBreak GetTextLineBreak();
    internal int GetEllipsesLength();
    internal double GetCollapsedWidth();
    internal double get_Width();
    internal double get_Start();
    internal double get_Height();
    internal double get_BaselineOffset();
    internal bool get_EndOfParagraph();
    internal int get_Length();
    internal int get_ContentLength();
    protected Rect GetBoundsFromPosition(int cp, int cch, FlowDirection& flowDirection);
    protected TextCollapsingProperties GetCollapsingProps(double wrappingWidth, LineProperties paraProperties);
    protected double CalculateXOffsetShift();
    protected bool get_ShowEllipsis();
    protected bool get_HasLineBreak();
    protected bool get_IsXOffsetAdjusted();
    protected bool get_IsWidthAdjusted();
}
internal class MS.Internal.Text.LineMetrics : ValueType {
    private UInt32 _packedData;
    private double _width;
    private double _height;
    private double _start;
    private double _baseline;
    private TextLineBreak _textLineBreak;
    private static UInt32 HasBeenUpdatedMask;
    private static UInt32 LengthMask;
    private static UInt32 HasInlineObjectsMask;
    internal int Length { get; }
    internal double Width { get; }
    internal double Height { get; }
    internal double Start { get; }
    internal double Baseline { get; }
    internal bool HasInlineObjects { get; }
    internal TextLineBreak TextLineBreak { get; }
    internal LineMetrics(int length, double width, double height, double baseline, bool hasInlineObjects, TextLineBreak textLineBreak);
    internal LineMetrics(LineMetrics source, double start, double width);
    private static LineMetrics();
    internal LineMetrics Dispose(bool returnUpdatedMetrics);
    internal int get_Length();
    internal double get_Width();
    internal double get_Height();
    internal double get_Start();
    internal double get_Baseline();
    internal bool get_HasInlineObjects();
    internal TextLineBreak get_TextLineBreak();
}
internal class MS.Internal.Text.LineProperties : TextParagraphProperties {
    private TextRunProperties _defaultTextProperties;
    private TextMarkerProperties _markerProperties;
    private FirstLineProperties _firstLineProperties;
    private bool _ignoreTextAlignment;
    private FlowDirection _flowDirection;
    private TextAlignment _textAlignment;
    private TextWrapping _textWrapping;
    private TextTrimming _textTrimming;
    private double _lineHeight;
    private double _textIndent;
    private LineStackingStrategy _lineStackingStrategy;
    public FlowDirection FlowDirection { get; }
    public TextAlignment TextAlignment { get; }
    public double LineHeight { get; }
    public bool FirstLineInParagraph { get; }
    public TextRunProperties DefaultTextRunProperties { get; }
    public TextDecorationCollection TextDecorations { get; }
    public TextWrapping TextWrapping { get; }
    public TextMarkerProperties TextMarkerProperties { get; }
    public double Indent { get; }
    internal TextAlignment TextAlignmentInternal { get; }
    internal bool IgnoreTextAlignment { get; internal set; }
    internal LineStackingStrategy LineStackingStrategy { get; }
    internal TextTrimming TextTrimming { get; }
    internal bool HasFirstLineProperties { get; }
    internal TextParagraphProperties FirstLineProps { get; }
    internal LineProperties(DependencyObject element, DependencyObject contentHost, TextProperties defaultTextProperties, MarkerProperties markerProperties);
    internal LineProperties(DependencyObject element, DependencyObject contentHost, TextProperties defaultTextProperties, MarkerProperties markerProperties, TextAlignment textAlignment);
    public virtual FlowDirection get_FlowDirection();
    public virtual TextAlignment get_TextAlignment();
    public virtual double get_LineHeight();
    public virtual bool get_FirstLineInParagraph();
    public virtual TextRunProperties get_DefaultTextRunProperties();
    public virtual TextDecorationCollection get_TextDecorations();
    public virtual TextWrapping get_TextWrapping();
    public virtual TextMarkerProperties get_TextMarkerProperties();
    public virtual double get_Indent();
    internal double CalcLineAdvanceForTextParagraph(TextParagraph textParagraph, int dcp, double lineAdvance);
    internal double CalcLineAdvance(double lineAdvance);
    internal TextAlignment get_TextAlignmentInternal();
    internal bool get_IgnoreTextAlignment();
    internal void set_IgnoreTextAlignment(bool value);
    internal LineStackingStrategy get_LineStackingStrategy();
    internal TextTrimming get_TextTrimming();
    internal bool get_HasFirstLineProperties();
    internal TextParagraphProperties get_FirstLineProps();
    internal TextParagraphProperties GetParaEllipsisLineProps(bool firstLine);
}
internal class MS.Internal.Text.MarkerProperties : object {
    private TextMarkerStyle _style;
    private double _offset;
    private int _index;
    internal MarkerProperties(List list, int index);
    internal TextMarkerProperties GetTextMarkerProperties(TextParagraphProperties textParaProps);
}
internal class MS.Internal.Text.SimpleLine : Line {
    private string _content;
    private TextRunProperties _textProps;
    internal SimpleLine(TextBlock owner, string content, TextRunProperties textProps);
    public virtual TextRun GetTextRun(int dcp);
    public virtual TextSpan`1<CultureSpecificCharacterBufferRange> GetPrecedingText(int dcp);
    public virtual int GetTextEffectCharacterIndexFromTextSourceCharacterIndex(int textSourceCharacterIndex);
}
internal static class MS.Internal.Text.TextDpi : object {
    private static double _scale;
    private static int _maxSizeInt;
    private static double _maxSize;
    private static int _minSizeInt;
    private static double _minSize;
    private static double _maxObjSize;
    internal static double MinWidth { get; }
    internal static double MaxWidth { get; }
    internal static double get_MinWidth();
    internal static double get_MaxWidth();
    internal static int ToTextDpi(double d);
    internal static double FromTextDpi(int i);
    internal static FSPOINT ToTextPoint(Point point);
    internal static FSVECTOR ToTextSize(Size size);
    internal static Rect FromTextRect(FSRECT fsrect);
    internal static void EnsureValidLineOffset(Double& offset);
    internal static void SnapToTextDpi(Size& size);
    internal static void EnsureValidLineWidth(Double& width);
    internal static void EnsureValidLineWidth(Size& size);
    internal static void EnsureValidLineWidth(Int32& width);
    internal static void EnsureValidPageSize(Size& size);
    internal static void EnsureValidPageWidth(Double& width);
    internal static void EnsureValidPageMargin(Thickness& pageMargin, Size pageSize);
    internal static void EnsureValidObjSize(Size& size);
}
internal class MS.Internal.Text.TextLineResult : LineResult {
    private TextBlock _owner;
    private int _dcp;
    private int _cch;
    private Rect _layoutBox;
    private int _index;
    private double _baseline;
    private ITextPointer _startPosition;
    private ITextPointer _endPosition;
    private int _cchContent;
    private int _cchEllipses;
    internal ITextPointer StartPosition { get; }
    internal ITextPointer EndPosition { get; }
    internal int StartPositionCP { get; }
    internal int EndPositionCP { get; }
    internal Rect LayoutBox { get; }
    internal double Baseline { get; }
    internal TextLineResult(TextBlock owner, int dcp, int cch, Rect layoutBox, double baseline, int index);
    internal virtual ITextPointer GetTextPositionFromDistance(double distance);
    internal virtual bool IsAtCaretUnitBoundary(ITextPointer position);
    internal virtual ITextPointer GetNextCaretUnitPosition(ITextPointer position, LogicalDirection direction);
    internal virtual ITextPointer GetBackspaceCaretUnitPosition(ITextPointer position);
    internal virtual ReadOnlyCollection`1<GlyphRun> GetGlyphRuns(ITextPointer start, ITextPointer end);
    internal virtual ITextPointer GetContentEndPosition();
    internal virtual ITextPointer GetEllipsesPosition();
    internal virtual int GetContentEndPositionCP();
    internal virtual int GetEllipsesPositionCP();
    internal virtual ITextPointer get_StartPosition();
    internal virtual ITextPointer get_EndPosition();
    internal virtual int get_StartPositionCP();
    internal virtual int get_EndPositionCP();
    internal virtual Rect get_LayoutBox();
    internal virtual double get_Baseline();
    private void EnsureComplexData();
}
internal class MS.Internal.Text.TextProperties : TextRunProperties {
    private Typeface _typeface;
    private double _fontSize;
    private Brush _foreground;
    private TextEffectCollection _textEffects;
    private TextDecorationCollection _textDecorations;
    private BaselineAlignment _baselineAlignment;
    private Brush _backgroundBrush;
    private CultureInfo _cultureInfo;
    private NumberSubstitution _numberSubstitution;
    private TextRunTypographyProperties _typographyProperties;
    public Typeface Typeface { get; }
    public double FontRenderingEmSize { get; }
    public double FontHintingEmSize { get; }
    public TextDecorationCollection TextDecorations { get; }
    public Brush ForegroundBrush { get; }
    public Brush BackgroundBrush { get; }
    public BaselineAlignment BaselineAlignment { get; }
    public CultureInfo CultureInfo { get; }
    public NumberSubstitution NumberSubstitution { get; }
    public TextRunTypographyProperties TypographyProperties { get; }
    public TextEffectCollection TextEffects { get; }
    internal TextProperties(FrameworkElement target, bool isTypographyDefaultValue);
    internal TextProperties(DependencyObject target, StaticTextPointer position, bool inlineObjects, bool getBackground, double pixelsPerDip);
    internal TextProperties(TextProperties source, TextDecorationCollection textDecorations);
    public virtual Typeface get_Typeface();
    public virtual double get_FontRenderingEmSize();
    public virtual double get_FontHintingEmSize();
    public virtual TextDecorationCollection get_TextDecorations();
    public virtual Brush get_ForegroundBrush();
    public virtual Brush get_BackgroundBrush();
    public virtual BaselineAlignment get_BaselineAlignment();
    public virtual CultureInfo get_CultureInfo();
    public virtual NumberSubstitution get_NumberSubstitution();
    public virtual TextRunTypographyProperties get_TypographyProperties();
    public virtual TextEffectCollection get_TextEffects();
    private void InitCommon(DependencyObject target);
    private static TextDecorationCollection GetHighlightTextDecorations(StaticTextPointer highlightPosition);
    private static TypographyProperties GetTypographyProperties(DependencyObject element);
    internal void SetBackgroundBrush(Brush backgroundBrush);
    internal void SetForegroundBrush(Brush foregroundBrush);
}
internal class MS.Internal.Text.TextSpanModifier : TextModifier {
    private int _length;
    private TextDecorationCollection _modifierDecorations;
    private Brush _modifierBrush;
    private FlowDirection _flowDirection;
    private bool _hasDirectionalEmbedding;
    public int Length { get; }
    public TextRunProperties Properties { get; }
    public bool HasDirectionalEmbedding { get; }
    public FlowDirection FlowDirection { get; }
    public TextSpanModifier(int length, TextDecorationCollection textDecorations, Brush foregroundBrush);
    public TextSpanModifier(int length, TextDecorationCollection textDecorations, Brush foregroundBrush, FlowDirection flowDirection);
    public sealed virtual int get_Length();
    public sealed virtual TextRunProperties get_Properties();
    public sealed virtual TextRunProperties ModifyProperties(TextRunProperties properties);
    public virtual bool get_HasDirectionalEmbedding();
    public virtual FlowDirection get_FlowDirection();
    private TextDecorationCollection CopyTextDecorations(TextDecorationCollection textDecorations, Brush brush);
}
internal class MS.Internal.Text.TypographyProperties : TextRunTypographyProperties {
    private UInt32 _idPropertySetFlags;
    private int _standardSwashes;
    private int _contextualSwashes;
    private int _stylisticAlternates;
    private int _annotationAlternates;
    private FontVariants _variant;
    private FontCapitals _capitals;
    private FontFraction _fraction;
    private FontNumeralStyle _numeralStyle;
    private FontNumeralAlignment _numeralAlignment;
    private FontEastAsianWidths _eastAsianWidths;
    private FontEastAsianLanguage _eastAsianLanguage;
    public bool StandardLigatures { get; }
    public bool ContextualLigatures { get; }
    public bool DiscretionaryLigatures { get; }
    public bool HistoricalLigatures { get; }
    public bool CaseSensitiveForms { get; }
    public bool ContextualAlternates { get; }
    public bool HistoricalForms { get; }
    public bool Kerning { get; }
    public bool CapitalSpacing { get; }
    public bool StylisticSet1 { get; }
    public bool StylisticSet2 { get; }
    public bool StylisticSet3 { get; }
    public bool StylisticSet4 { get; }
    public bool StylisticSet5 { get; }
    public bool StylisticSet6 { get; }
    public bool StylisticSet7 { get; }
    public bool StylisticSet8 { get; }
    public bool StylisticSet9 { get; }
    public bool StylisticSet10 { get; }
    public bool StylisticSet11 { get; }
    public bool StylisticSet12 { get; }
    public bool StylisticSet13 { get; }
    public bool StylisticSet14 { get; }
    public bool StylisticSet15 { get; }
    public bool StylisticSet16 { get; }
    public bool StylisticSet17 { get; }
    public bool StylisticSet18 { get; }
    public bool StylisticSet19 { get; }
    public bool StylisticSet20 { get; }
    public FontFraction Fraction { get; }
    public bool SlashedZero { get; }
    public bool MathematicalGreek { get; }
    public bool EastAsianExpertForms { get; }
    public FontVariants Variants { get; }
    public FontCapitals Capitals { get; }
    public FontNumeralStyle NumeralStyle { get; }
    public FontNumeralAlignment NumeralAlignment { get; }
    public FontEastAsianWidths EastAsianWidths { get; }
    public FontEastAsianLanguage EastAsianLanguage { get; }
    public int StandardSwashes { get; }
    public int ContextualSwashes { get; }
    public int StylisticAlternates { get; }
    public int AnnotationAlternates { get; }
    public virtual bool get_StandardLigatures();
    public void SetStandardLigatures(bool value);
    public virtual bool get_ContextualLigatures();
    public void SetContextualLigatures(bool value);
    public virtual bool get_DiscretionaryLigatures();
    public void SetDiscretionaryLigatures(bool value);
    public virtual bool get_HistoricalLigatures();
    public void SetHistoricalLigatures(bool value);
    public virtual bool get_CaseSensitiveForms();
    public void SetCaseSensitiveForms(bool value);
    public virtual bool get_ContextualAlternates();
    public void SetContextualAlternates(bool value);
    public virtual bool get_HistoricalForms();
    public void SetHistoricalForms(bool value);
    public virtual bool get_Kerning();
    public void SetKerning(bool value);
    public virtual bool get_CapitalSpacing();
    public void SetCapitalSpacing(bool value);
    public virtual bool get_StylisticSet1();
    public void SetStylisticSet1(bool value);
    public virtual bool get_StylisticSet2();
    public void SetStylisticSet2(bool value);
    public virtual bool get_StylisticSet3();
    public void SetStylisticSet3(bool value);
    public virtual bool get_StylisticSet4();
    public void SetStylisticSet4(bool value);
    public virtual bool get_StylisticSet5();
    public void SetStylisticSet5(bool value);
    public virtual bool get_StylisticSet6();
    public void SetStylisticSet6(bool value);
    public virtual bool get_StylisticSet7();
    public void SetStylisticSet7(bool value);
    public virtual bool get_StylisticSet8();
    public void SetStylisticSet8(bool value);
    public virtual bool get_StylisticSet9();
    public void SetStylisticSet9(bool value);
    public virtual bool get_StylisticSet10();
    public void SetStylisticSet10(bool value);
    public virtual bool get_StylisticSet11();
    public void SetStylisticSet11(bool value);
    public virtual bool get_StylisticSet12();
    public void SetStylisticSet12(bool value);
    public virtual bool get_StylisticSet13();
    public void SetStylisticSet13(bool value);
    public virtual bool get_StylisticSet14();
    public void SetStylisticSet14(bool value);
    public virtual bool get_StylisticSet15();
    public void SetStylisticSet15(bool value);
    public virtual bool get_StylisticSet16();
    public void SetStylisticSet16(bool value);
    public virtual bool get_StylisticSet17();
    public void SetStylisticSet17(bool value);
    public virtual bool get_StylisticSet18();
    public void SetStylisticSet18(bool value);
    public virtual bool get_StylisticSet19();
    public void SetStylisticSet19(bool value);
    public virtual bool get_StylisticSet20();
    public void SetStylisticSet20(bool value);
    public virtual FontFraction get_Fraction();
    public void SetFraction(FontFraction value);
    public virtual bool get_SlashedZero();
    public void SetSlashedZero(bool value);
    public virtual bool get_MathematicalGreek();
    public void SetMathematicalGreek(bool value);
    public virtual bool get_EastAsianExpertForms();
    public void SetEastAsianExpertForms(bool value);
    public virtual FontVariants get_Variants();
    public void SetVariants(FontVariants value);
    public virtual FontCapitals get_Capitals();
    public void SetCapitals(FontCapitals value);
    public virtual FontNumeralStyle get_NumeralStyle();
    public void SetNumeralStyle(FontNumeralStyle value);
    public virtual FontNumeralAlignment get_NumeralAlignment();
    public void SetNumeralAlignment(FontNumeralAlignment value);
    public virtual FontEastAsianWidths get_EastAsianWidths();
    public void SetEastAsianWidths(FontEastAsianWidths value);
    public virtual FontEastAsianLanguage get_EastAsianLanguage();
    public void SetEastAsianLanguage(FontEastAsianLanguage value);
    public virtual int get_StandardSwashes();
    public void SetStandardSwashes(int value);
    public virtual int get_ContextualSwashes();
    public void SetContextualSwashes(int value);
    public virtual int get_StylisticAlternates();
    public void SetStylisticAlternates(int value);
    public virtual int get_AnnotationAlternates();
    public void SetAnnotationAlternates(int value);
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
    public static bool op_Equality(TypographyProperties first, TypographyProperties second);
    public static bool op_Inequality(TypographyProperties first, TypographyProperties second);
    private void ResetProperties();
    private bool IsBooleanPropertySet(PropertyId propertyId);
    private void SetBooleanProperty(PropertyId propertyId, bool flagValue);
}
internal static class MS.Internal.TraceData : object {
    private static AvTrace _avTrace;
    private static AvTraceDetails _CannotCreateDefaultValueConverter;
    private static AvTraceDetails _NoMentor;
    private static AvTraceDetails _NoDataContext;
    private static AvTraceDetails _NoSource;
    private static AvTraceDetails _BadValueAtTransfer;
    private static AvTraceDetails _BadConverterForTransfer;
    private static AvTraceDetails _BadConverterForUpdate;
    private static AvTraceDetails _WorkerUpdateFailed;
    private static AvTraceDetails _RequiresExplicitCulture;
    private static AvTraceDetails _NoValueToTransfer;
    private static AvTraceDetails _FallbackConversionFailed;
    private static AvTraceDetails _TargetNullValueConversionFailed;
    private static AvTraceDetails _BindingGroupNameMatchFailed;
    private static AvTraceDetails _BindingGroupWrongProperty;
    private static AvTraceDetails _BindingGroupMultipleInheritance;
    private static AvTraceDetails _SharesProposedValuesRequriesImplicitBindingGroup;
    private static AvTraceDetails _CannotGetClrRawValue;
    private static AvTraceDetails _CannotSetClrRawValue;
    private static AvTraceDetails _MissingDataItem;
    private static AvTraceDetails _MissingInfo;
    private static AvTraceDetails _NullDataItem;
    private static AvTraceDetails _DefaultValueConverterFailed;
    private static AvTraceDetails _DefaultValueConverterFailedForCulture;
    private static AvTraceDetails _StyleAndStyleSelectorDefined;
    private static AvTraceDetails _TemplateAndTemplateSelectorDefined;
    private static AvTraceDetails _ItemTemplateForDirectItem;
    private static AvTraceDetails _BadMultiConverterForUpdate;
    private static AvTraceDetails _MultiValueConverterMissingForTransfer;
    private static AvTraceDetails _MultiValueConverterMissingForUpdate;
    private static AvTraceDetails _MultiValueConverterMismatch;
    private static AvTraceDetails _MultiBindingHasNoConverter;
    private static AvTraceDetails _UnsetValueInMultiBindingExpressionUpdate;
    private static AvTraceDetails _ObjectDataProviderHasNoSource;
    private static AvTraceDetails _ObjDPCreateFailed;
    private static AvTraceDetails _ObjDPInvokeFailed;
    private static AvTraceDetails _RefPreviousNotInContext;
    private static AvTraceDetails _RefNoWrapperInChildren;
    private static AvTraceDetails _RefAncestorTypeNotSpecified;
    private static AvTraceDetails _RefAncestorLevelInvalid;
    private static AvTraceDetails _ClrReplaceItem;
    private static AvTraceDetails _NullItem;
    private static AvTraceDetails _PlaceholderItem;
    private static AvTraceDetails _DataErrorInfoFailed;
    private static AvTraceDetails _DisallowTwoWay;
    private static AvTraceDetails _XmlBindingToNonXml;
    private static AvTraceDetails _XmlBindingToNonXmlCollection;
    private static AvTraceDetails _CannotGetXmlNodeCollection;
    private static AvTraceDetails _BadXPath;
    private static AvTraceDetails _XmlDPInlineDocError;
    private static AvTraceDetails _XmlNamespaceNotSet;
    private static AvTraceDetails _XmlDPAsyncDocError;
    private static AvTraceDetails _XmlDPSelectNodesFailed;
    private static AvTraceDetails _CollectionViewIsUnsupported;
    private static AvTraceDetails _CollectionChangedWithoutNotification;
    private static AvTraceDetails _CannotSort;
    private static AvTraceDetails _CreatedExpression;
    private static AvTraceDetails _CreatedExpressionInParent;
    private static AvTraceDetails _BindingPath;
    private static AvTraceDetails _BindingXPathAndPath;
    private static AvTraceDetails _ResolveDefaultMode;
    private static AvTraceDetails _ResolveDefaultUpdate;
    private static AvTraceDetails _AttachExpression;
    private static AvTraceDetails _DetachExpression;
    private static AvTraceDetails _UseMentor;
    private static AvTraceDetails _DeferAttachToContext;
    private static AvTraceDetails _SourceRequiresTreeContext;
    private static AvTraceDetails _AttachToContext;
    private static AvTraceDetails _PathRequiresTreeContext;
    private static AvTraceDetails _NoMentorExtended;
    private static AvTraceDetails _ContextElement;
    private static AvTraceDetails _NullDataContext;
    private static AvTraceDetails _RelativeSource;
    private static AvTraceDetails _AncestorLookup;
    private static AvTraceDetails _ElementNameQuery;
    private static AvTraceDetails _ElementNameQueryTemplate;
    private static AvTraceDetails _UseCVS;
    private static AvTraceDetails _UseDataProvider;
    private static AvTraceDetails _ActivateItem;
    private static AvTraceDetails _Deactivate;
    private static AvTraceDetails _GetRawValue;
    private static AvTraceDetails _ConvertDBNull;
    private static AvTraceDetails _UserConverter;
    private static AvTraceDetails _NullConverter;
    private static AvTraceDetails _DefaultConverter;
    private static AvTraceDetails _FormattedValue;
    private static AvTraceDetails _FormattingFailed;
    private static AvTraceDetails _BadValueAtTransferExtended;
    private static AvTraceDetails _UseFallback;
    private static AvTraceDetails _TransferValue;
    private static AvTraceDetails _UpdateRawValue;
    private static AvTraceDetails _ValidationRuleFailed;
    private static AvTraceDetails _UserConvertBack;
    private static AvTraceDetails _DefaultConvertBack;
    private static AvTraceDetails _Update;
    private static AvTraceDetails _GotEvent;
    private static AvTraceDetails _GotPropertyChanged;
    private static AvTraceDetails _PriorityTransfer;
    private static AvTraceDetails _ChildNotAttached;
    private static AvTraceDetails _GetRawValueMulti;
    private static AvTraceDetails _UserConvertBackMulti;
    private static AvTraceDetails _GetValue;
    private static AvTraceDetails _SetValue;
    private static AvTraceDetails _ReplaceItemShort;
    private static AvTraceDetails _ReplaceItemLong;
    private static AvTraceDetails _GetInfo_Reuse;
    private static AvTraceDetails _GetInfo_Null;
    private static AvTraceDetails _GetInfo_Cache;
    private static AvTraceDetails _GetInfo_Property;
    private static AvTraceDetails _GetInfo_Indexer;
    private static AvTraceDetails _XmlContextNode;
    private static AvTraceDetails _XmlNewCollection;
    private static AvTraceDetails _XmlSynchronizeCollection;
    private static AvTraceDetails _SelectNodes;
    private static AvTraceDetails _BeginQuery;
    private static AvTraceDetails _QueryFinished;
    private static AvTraceDetails _QueryResult;
    private static AvTraceDetails _XmlLoadSource;
    private static AvTraceDetails _XmlLoadDoc;
    private static AvTraceDetails _XmlLoadInline;
    private static AvTraceDetails _XmlBuildCollection;
    public static AvTraceDetails NoMentor { get; }
    public static AvTraceDetails NoDataContext { get; }
    public static AvTraceDetails BadValueAtTransfer { get; }
    public static AvTraceDetails WorkerUpdateFailed { get; }
    public static AvTraceDetails RequiresExplicitCulture { get; }
    public static AvTraceDetails NoValueToTransfer { get; }
    public static AvTraceDetails BindingGroupMultipleInheritance { get; }
    public static AvTraceDetails MissingDataItem { get; }
    public static AvTraceDetails MissingInfo { get; }
    public static AvTraceDetails NullDataItem { get; }
    public static AvTraceDetails ItemTemplateForDirectItem { get; }
    public static AvTraceDetails MultiValueConverterMissingForTransfer { get; }
    public static AvTraceDetails MultiValueConverterMissingForUpdate { get; }
    public static AvTraceDetails MultiValueConverterMismatch { get; }
    public static AvTraceDetails MultiBindingHasNoConverter { get; }
    public static AvTraceDetails ObjectDataProviderHasNoSource { get; }
    public static AvTraceDetails ObjDPCreateFailed { get; }
    public static AvTraceDetails ObjDPInvokeFailed { get; }
    public static AvTraceDetails RefPreviousNotInContext { get; }
    public static AvTraceDetails RefNoWrapperInChildren { get; }
    public static AvTraceDetails RefAncestorTypeNotSpecified { get; }
    public static AvTraceDetails RefAncestorLevelInvalid { get; }
    public static AvTraceDetails XmlBindingToNonXml { get; }
    public static AvTraceDetails XmlBindingToNonXmlCollection { get; }
    public static AvTraceDetails CannotGetXmlNodeCollection { get; }
    public static AvTraceDetails XmlDPInlineDocError { get; }
    public static AvTraceDetails XmlNamespaceNotSet { get; }
    public static AvTraceDetails XmlDPAsyncDocError { get; }
    public static AvTraceDetails XmlDPSelectNodesFailed { get; }
    public static AvTraceDetails CollectionViewIsUnsupported { get; }
    public static bool IsEnabled { get; }
    public static bool IsEnabledOverride { get; }
    private static TraceData();
    public static AvTraceDetails CannotCreateDefaultValueConverter(Object[] args);
    public static AvTraceDetails get_NoMentor();
    public static AvTraceDetails get_NoDataContext();
    public static AvTraceDetails NoSource(Object[] args);
    public static AvTraceDetails get_BadValueAtTransfer();
    public static AvTraceDetails BadConverterForTransfer(Object[] args);
    public static AvTraceDetails BadConverterForUpdate(Object[] args);
    public static AvTraceDetails get_WorkerUpdateFailed();
    public static AvTraceDetails get_RequiresExplicitCulture();
    public static AvTraceDetails get_NoValueToTransfer();
    public static AvTraceDetails FallbackConversionFailed(Object[] args);
    public static AvTraceDetails TargetNullValueConversionFailed(Object[] args);
    public static AvTraceDetails BindingGroupNameMatchFailed(Object[] args);
    public static AvTraceDetails BindingGroupWrongProperty(Object[] args);
    public static AvTraceDetails get_BindingGroupMultipleInheritance();
    public static AvTraceDetails SharesProposedValuesRequriesImplicitBindingGroup(Object[] args);
    public static AvTraceDetails CannotGetClrRawValue(Object[] args);
    public static AvTraceDetails CannotSetClrRawValue(Object[] args);
    public static AvTraceDetails get_MissingDataItem();
    public static AvTraceDetails get_MissingInfo();
    public static AvTraceDetails get_NullDataItem();
    public static AvTraceDetails DefaultValueConverterFailed(Object[] args);
    public static AvTraceDetails DefaultValueConverterFailedForCulture(Object[] args);
    public static AvTraceDetails StyleAndStyleSelectorDefined(Object[] args);
    public static AvTraceDetails TemplateAndTemplateSelectorDefined(Object[] args);
    public static AvTraceDetails get_ItemTemplateForDirectItem();
    public static AvTraceDetails BadMultiConverterForUpdate(Object[] args);
    public static AvTraceDetails get_MultiValueConverterMissingForTransfer();
    public static AvTraceDetails get_MultiValueConverterMissingForUpdate();
    public static AvTraceDetails get_MultiValueConverterMismatch();
    public static AvTraceDetails get_MultiBindingHasNoConverter();
    public static AvTraceDetails UnsetValueInMultiBindingExpressionUpdate(Object[] args);
    public static AvTraceDetails get_ObjectDataProviderHasNoSource();
    public static AvTraceDetails get_ObjDPCreateFailed();
    public static AvTraceDetails get_ObjDPInvokeFailed();
    public static AvTraceDetails get_RefPreviousNotInContext();
    public static AvTraceDetails get_RefNoWrapperInChildren();
    public static AvTraceDetails get_RefAncestorTypeNotSpecified();
    public static AvTraceDetails get_RefAncestorLevelInvalid();
    public static AvTraceDetails ClrReplaceItem(Object[] args);
    public static AvTraceDetails NullItem(Object[] args);
    public static AvTraceDetails PlaceholderItem(Object[] args);
    public static AvTraceDetails DataErrorInfoFailed(Object[] args);
    public static AvTraceDetails DisallowTwoWay(Object[] args);
    public static AvTraceDetails get_XmlBindingToNonXml();
    public static AvTraceDetails get_XmlBindingToNonXmlCollection();
    public static AvTraceDetails get_CannotGetXmlNodeCollection();
    public static AvTraceDetails BadXPath(Object[] args);
    public static AvTraceDetails get_XmlDPInlineDocError();
    public static AvTraceDetails get_XmlNamespaceNotSet();
    public static AvTraceDetails get_XmlDPAsyncDocError();
    public static AvTraceDetails get_XmlDPSelectNodesFailed();
    public static AvTraceDetails get_CollectionViewIsUnsupported();
    public static AvTraceDetails CollectionChangedWithoutNotification(Object[] args);
    public static AvTraceDetails CannotSort(Object[] args);
    public static AvTraceDetails CreatedExpression(Object[] args);
    public static AvTraceDetails CreatedExpressionInParent(Object[] args);
    public static AvTraceDetails BindingPath(Object[] args);
    public static AvTraceDetails BindingXPathAndPath(Object[] args);
    public static AvTraceDetails ResolveDefaultMode(Object[] args);
    public static AvTraceDetails ResolveDefaultUpdate(Object[] args);
    public static AvTraceDetails AttachExpression(Object[] args);
    public static AvTraceDetails DetachExpression(Object[] args);
    public static AvTraceDetails UseMentor(Object[] args);
    public static AvTraceDetails DeferAttachToContext(Object[] args);
    public static AvTraceDetails SourceRequiresTreeContext(Object[] args);
    public static AvTraceDetails AttachToContext(Object[] args);
    public static AvTraceDetails PathRequiresTreeContext(Object[] args);
    public static AvTraceDetails NoMentorExtended(Object[] args);
    public static AvTraceDetails ContextElement(Object[] args);
    public static AvTraceDetails NullDataContext(Object[] args);
    public static AvTraceDetails RelativeSource(Object[] args);
    public static AvTraceDetails AncestorLookup(Object[] args);
    public static AvTraceDetails ElementNameQuery(Object[] args);
    public static AvTraceDetails ElementNameQueryTemplate(Object[] args);
    public static AvTraceDetails UseCVS(Object[] args);
    public static AvTraceDetails UseDataProvider(Object[] args);
    public static AvTraceDetails ActivateItem(Object[] args);
    public static AvTraceDetails Deactivate(Object[] args);
    public static AvTraceDetails GetRawValue(Object[] args);
    public static AvTraceDetails ConvertDBNull(Object[] args);
    public static AvTraceDetails UserConverter(Object[] args);
    public static AvTraceDetails NullConverter(Object[] args);
    public static AvTraceDetails DefaultConverter(Object[] args);
    public static AvTraceDetails FormattedValue(Object[] args);
    public static AvTraceDetails FormattingFailed(Object[] args);
    public static AvTraceDetails BadValueAtTransferExtended(Object[] args);
    public static AvTraceDetails UseFallback(Object[] args);
    public static AvTraceDetails TransferValue(Object[] args);
    public static AvTraceDetails UpdateRawValue(Object[] args);
    public static AvTraceDetails ValidationRuleFailed(Object[] args);
    public static AvTraceDetails UserConvertBack(Object[] args);
    public static AvTraceDetails DefaultConvertBack(Object[] args);
    public static AvTraceDetails Update(Object[] args);
    public static AvTraceDetails GotEvent(Object[] args);
    public static AvTraceDetails GotPropertyChanged(Object[] args);
    public static AvTraceDetails PriorityTransfer(Object[] args);
    public static AvTraceDetails ChildNotAttached(Object[] args);
    public static AvTraceDetails GetRawValueMulti(Object[] args);
    public static AvTraceDetails UserConvertBackMulti(Object[] args);
    public static AvTraceDetails GetValue(Object[] args);
    public static AvTraceDetails SetValue(Object[] args);
    public static AvTraceDetails ReplaceItemShort(Object[] args);
    public static AvTraceDetails ReplaceItemLong(Object[] args);
    public static AvTraceDetails GetInfo_Reuse(Object[] args);
    public static AvTraceDetails GetInfo_Null(Object[] args);
    public static AvTraceDetails GetInfo_Cache(Object[] args);
    public static AvTraceDetails GetInfo_Property(Object[] args);
    public static AvTraceDetails GetInfo_Indexer(Object[] args);
    public static AvTraceDetails XmlContextNode(Object[] args);
    public static AvTraceDetails XmlNewCollection(Object[] args);
    public static AvTraceDetails XmlSynchronizeCollection(Object[] args);
    public static AvTraceDetails SelectNodes(Object[] args);
    public static AvTraceDetails BeginQuery(Object[] args);
    public static AvTraceDetails QueryFinished(Object[] args);
    public static AvTraceDetails QueryResult(Object[] args);
    public static AvTraceDetails XmlLoadSource(Object[] args);
    public static AvTraceDetails XmlLoadDoc(Object[] args);
    public static AvTraceDetails XmlLoadInline(Object[] args);
    public static AvTraceDetails XmlBuildCollection(Object[] args);
    public static void Trace(TraceEventType type, AvTraceDetails traceDetails, Object[] parameters);
    public static void Trace(TraceEventType type, AvTraceDetails traceDetails);
    public static void Trace(TraceEventType type, AvTraceDetails traceDetails, object p1);
    public static void Trace(TraceEventType type, AvTraceDetails traceDetails, object p1, object p2);
    public static void Trace(TraceEventType type, AvTraceDetails traceDetails, object p1, object p2, object p3);
    public static void TraceActivityItem(AvTraceDetails traceDetails, Object[] parameters);
    public static void TraceActivityItem(AvTraceDetails traceDetails);
    public static void TraceActivityItem(AvTraceDetails traceDetails, object p1);
    public static void TraceActivityItem(AvTraceDetails traceDetails, object p1, object p2);
    public static void TraceActivityItem(AvTraceDetails traceDetails, object p1, object p2, object p3);
    public static bool get_IsEnabled();
    public static bool get_IsEnabledOverride();
    public static void Refresh();
    public static bool IsExtendedTraceEnabled(object element, TraceDataLevel level);
    public static void OnTrace(AvTraceBuilder traceBuilder, Object[] parameters, int start);
    public static void Describe(AvTraceBuilder traceBuilder, object o);
    public static void DescribeSourceObject(AvTraceBuilder traceBuilder, object o);
    public static string DescribeSourceObject(object o);
    public static void DescribeTarget(AvTraceBuilder traceBuilder, DependencyObject targetElement, DependencyProperty targetProperty);
    public static string DescribeTarget(DependencyObject targetElement, DependencyProperty targetProperty);
    public static string Identify(object o);
    public static string IdentifyWeakEvent(Type type);
    public static string IdentifyAccessor(object accessor);
    public static string IdentifyException(Exception ex);
    private static string Format(string format, Object[] args);
}
internal enum MS.Internal.TraceDataLevel : Enum {
    public int value__;
    public static TraceDataLevel CreateExpression;
    public static TraceDataLevel ShowPath;
    public static TraceDataLevel ResolveDefaults;
    public static TraceDataLevel Attach;
    public static TraceDataLevel AttachToContext;
    public static TraceDataLevel SourceLookup;
    public static TraceDataLevel Activate;
    public static TraceDataLevel Transfer;
    public static TraceDataLevel Update;
    public static TraceDataLevel Validation;
    public static TraceDataLevel Events;
    public static TraceDataLevel GetValue;
    public static TraceDataLevel ReplaceItem;
    public static TraceDataLevel GetInfo;
    public static TraceDataLevel ProviderQuery;
    public static TraceDataLevel XmlProvider;
    public static TraceDataLevel XmlBuildCollection;
}
internal static class MS.Internal.TraceHwndHost : object {
    private static AvTrace _avTrace;
    private static AvTraceDetails _HwndHostIn3D;
    public static AvTraceDetails HwndHostIn3D { get; }
    public static bool IsEnabled { get; }
    public static bool IsEnabledOverride { get; }
    private static TraceHwndHost();
    public static AvTraceDetails get_HwndHostIn3D();
    public static void Trace(TraceEventType type, AvTraceDetails traceDetails, Object[] parameters);
    public static void Trace(TraceEventType type, AvTraceDetails traceDetails);
    public static void Trace(TraceEventType type, AvTraceDetails traceDetails, object p1);
    public static void Trace(TraceEventType type, AvTraceDetails traceDetails, object p1, object p2);
    public static void Trace(TraceEventType type, AvTraceDetails traceDetails, object p1, object p2, object p3);
    public static void TraceActivityItem(AvTraceDetails traceDetails, Object[] parameters);
    public static void TraceActivityItem(AvTraceDetails traceDetails);
    public static void TraceActivityItem(AvTraceDetails traceDetails, object p1);
    public static void TraceActivityItem(AvTraceDetails traceDetails, object p1, object p2);
    public static void TraceActivityItem(AvTraceDetails traceDetails, object p1, object p2, object p3);
    public static bool get_IsEnabled();
    public static bool get_IsEnabledOverride();
    public static void Refresh();
}
internal static class MS.Internal.TraceMarkup : object {
    private static AvTrace _avTrace;
    private static AvTraceDetails _AddValueToAddChild;
    private static AvTraceDetails _AddValueToArray;
    private static AvTraceDetails _AddValueToDictionary;
    private static AvTraceDetails _AddValueToList;
    private static AvTraceDetails _BeginInit;
    private static AvTraceDetails _CreateMarkupExtension;
    private static AvTraceDetails _CreateObject;
    private static AvTraceDetails _EndInit;
    private static AvTraceDetails _Load;
    private static AvTraceDetails _ProcessConstructorParameter;
    private static AvTraceDetails _ProvideValue;
    private static AvTraceDetails _SetCPA;
    private static AvTraceDetails _SetPropertyValue;
    private static AvTraceDetails _ThrowException;
    private static AvTraceDetails _TypeConvert;
    private static AvTraceDetails _TypeConvertFallback;
    public static AvTraceDetails AddValueToAddChild { get; }
    public static AvTraceDetails AddValueToArray { get; }
    public static AvTraceDetails AddValueToDictionary { get; }
    public static AvTraceDetails AddValueToList { get; }
    public static AvTraceDetails BeginInit { get; }
    public static AvTraceDetails CreateMarkupExtension { get; }
    public static AvTraceDetails CreateObject { get; }
    public static AvTraceDetails EndInit { get; }
    public static AvTraceDetails Load { get; }
    public static AvTraceDetails ProcessConstructorParameter { get; }
    public static AvTraceDetails ProvideValue { get; }
    public static AvTraceDetails SetCPA { get; }
    public static AvTraceDetails SetPropertyValue { get; }
    public static AvTraceDetails ThrowException { get; }
    public static AvTraceDetails TypeConvert { get; }
    public static AvTraceDetails TypeConvertFallback { get; }
    public static bool IsEnabled { get; }
    public static bool IsEnabledOverride { get; }
    private static TraceMarkup();
    public static AvTraceDetails get_AddValueToAddChild();
    public static AvTraceDetails get_AddValueToArray();
    public static AvTraceDetails get_AddValueToDictionary();
    public static AvTraceDetails get_AddValueToList();
    public static AvTraceDetails get_BeginInit();
    public static AvTraceDetails get_CreateMarkupExtension();
    public static AvTraceDetails get_CreateObject();
    public static AvTraceDetails get_EndInit();
    public static AvTraceDetails get_Load();
    public static AvTraceDetails get_ProcessConstructorParameter();
    public static AvTraceDetails get_ProvideValue();
    public static AvTraceDetails get_SetCPA();
    public static AvTraceDetails get_SetPropertyValue();
    public static AvTraceDetails get_ThrowException();
    public static AvTraceDetails get_TypeConvert();
    public static AvTraceDetails get_TypeConvertFallback();
    public static void Trace(TraceEventType type, AvTraceDetails traceDetails, Object[] parameters);
    public static void Trace(TraceEventType type, AvTraceDetails traceDetails);
    public static void Trace(TraceEventType type, AvTraceDetails traceDetails, object p1);
    public static void Trace(TraceEventType type, AvTraceDetails traceDetails, object p1, object p2);
    public static void Trace(TraceEventType type, AvTraceDetails traceDetails, object p1, object p2, object p3);
    public static void TraceActivityItem(AvTraceDetails traceDetails, Object[] parameters);
    public static void TraceActivityItem(AvTraceDetails traceDetails);
    public static void TraceActivityItem(AvTraceDetails traceDetails, object p1);
    public static void TraceActivityItem(AvTraceDetails traceDetails, object p1, object p2);
    public static void TraceActivityItem(AvTraceDetails traceDetails, object p1, object p2, object p3);
    public static bool get_IsEnabled();
    public static bool get_IsEnabledOverride();
    public static void Refresh();
}
internal static class MS.Internal.TracePageFormatting : object {
    private static AvTrace _avTrace;
    private static AvTraceDetails _FormatPage;
    private static AvTraceDetails _PageFormattingError;
    private static AvTraceDetails _UnableToFreezeFreezableSubProperty;
    private static AvTraceDetails _UnableToFreezeAnimatedProperties;
    public static AvTraceDetails FormatPage { get; }
    public static AvTraceDetails PageFormattingError { get; }
    public static AvTraceDetails UnableToFreezeFreezableSubProperty { get; }
    public static AvTraceDetails UnableToFreezeAnimatedProperties { get; }
    public static bool IsEnabled { get; }
    public static bool IsEnabledOverride { get; }
    private static TracePageFormatting();
    public static AvTraceDetails get_FormatPage();
    public static AvTraceDetails get_PageFormattingError();
    public static AvTraceDetails get_UnableToFreezeFreezableSubProperty();
    public static AvTraceDetails get_UnableToFreezeAnimatedProperties();
    public static void Trace(TraceEventType type, AvTraceDetails traceDetails, Object[] parameters);
    public static void Trace(TraceEventType type, AvTraceDetails traceDetails);
    public static void Trace(TraceEventType type, AvTraceDetails traceDetails, object p1);
    public static void Trace(TraceEventType type, AvTraceDetails traceDetails, object p1, object p2);
    public static void Trace(TraceEventType type, AvTraceDetails traceDetails, object p1, object p2, object p3);
    public static void TraceActivityItem(AvTraceDetails traceDetails, Object[] parameters);
    public static void TraceActivityItem(AvTraceDetails traceDetails);
    public static void TraceActivityItem(AvTraceDetails traceDetails, object p1);
    public static void TraceActivityItem(AvTraceDetails traceDetails, object p1, object p2);
    public static void TraceActivityItem(AvTraceDetails traceDetails, object p1, object p2, object p3);
    public static bool get_IsEnabled();
    public static bool get_IsEnabledOverride();
    public static void Refresh();
}
internal static class MS.Internal.TraceResourceDictionary : object {
    private static AvTrace _avTrace;
    private static AvTraceDetails _AddResource;
    private static AvTraceDetails _RealizeDeferContent;
    private static AvTraceDetails _FoundResourceOnElement;
    private static AvTraceDetails _FoundResourceInStyle;
    private static AvTraceDetails _FoundResourceInTemplate;
    private static AvTraceDetails _FoundResourceInThemeStyle;
    private static AvTraceDetails _FoundResourceInApplication;
    private static AvTraceDetails _FoundResourceInTheme;
    private static AvTraceDetails _ResourceNotFound;
    private static AvTraceDetails _NewResourceDictionary;
    private static AvTraceDetails _FindResource;
    private static AvTraceDetails _SetKey;
    public static AvTraceDetails AddResource { get; }
    public static AvTraceDetails RealizeDeferContent { get; }
    public static AvTraceDetails FoundResourceOnElement { get; }
    public static AvTraceDetails FoundResourceInStyle { get; }
    public static AvTraceDetails FoundResourceInTemplate { get; }
    public static AvTraceDetails FoundResourceInThemeStyle { get; }
    public static AvTraceDetails FoundResourceInApplication { get; }
    public static AvTraceDetails FoundResourceInTheme { get; }
    public static AvTraceDetails ResourceNotFound { get; }
    public static AvTraceDetails NewResourceDictionary { get; }
    public static AvTraceDetails FindResource { get; }
    public static AvTraceDetails SetKey { get; }
    public static bool IsEnabled { get; }
    public static bool IsEnabledOverride { get; }
    private static TraceResourceDictionary();
    public static AvTraceDetails get_AddResource();
    public static AvTraceDetails get_RealizeDeferContent();
    public static AvTraceDetails get_FoundResourceOnElement();
    public static AvTraceDetails get_FoundResourceInStyle();
    public static AvTraceDetails get_FoundResourceInTemplate();
    public static AvTraceDetails get_FoundResourceInThemeStyle();
    public static AvTraceDetails get_FoundResourceInApplication();
    public static AvTraceDetails get_FoundResourceInTheme();
    public static AvTraceDetails get_ResourceNotFound();
    public static AvTraceDetails get_NewResourceDictionary();
    public static AvTraceDetails get_FindResource();
    public static AvTraceDetails get_SetKey();
    public static void Trace(TraceEventType type, AvTraceDetails traceDetails, Object[] parameters);
    public static void Trace(TraceEventType type, AvTraceDetails traceDetails);
    public static void Trace(TraceEventType type, AvTraceDetails traceDetails, object p1);
    public static void Trace(TraceEventType type, AvTraceDetails traceDetails, object p1, object p2);
    public static void Trace(TraceEventType type, AvTraceDetails traceDetails, object p1, object p2, object p3);
    public static void TraceActivityItem(AvTraceDetails traceDetails, Object[] parameters);
    public static void TraceActivityItem(AvTraceDetails traceDetails);
    public static void TraceActivityItem(AvTraceDetails traceDetails, object p1);
    public static void TraceActivityItem(AvTraceDetails traceDetails, object p1, object p2);
    public static void TraceActivityItem(AvTraceDetails traceDetails, object p1, object p2, object p3);
    public static bool get_IsEnabled();
    public static bool get_IsEnabledOverride();
    public static void Refresh();
}
internal static class MS.Internal.TraceShell : object {
    private static AvTrace _avTrace;
    private static AvTraceDetails _NotOnWindows7;
    private static AvTraceDetails _ExplorerTaskbarTimeout;
    private static AvTraceDetails _ExplorerTaskbarRetrying;
    private static AvTraceDetails _ExplorerTaskbarNotRunning;
    private static AvTraceDetails _NativeTaskbarError;
    private static AvTraceDetails _RejectingJumpItemsBecauseCatastrophicFailure;
    private static AvTraceDetails _RejectingJumpListCategoryBecauseNoRegisteredHandler;
    public static AvTraceDetails NotOnWindows7 { get; }
    public static AvTraceDetails ExplorerTaskbarTimeout { get; }
    public static AvTraceDetails ExplorerTaskbarRetrying { get; }
    public static AvTraceDetails ExplorerTaskbarNotRunning { get; }
    public static AvTraceDetails RejectingJumpItemsBecauseCatastrophicFailure { get; }
    public static bool IsEnabled { get; }
    public static bool IsEnabledOverride { get; }
    private static TraceShell();
    public static AvTraceDetails get_NotOnWindows7();
    public static AvTraceDetails get_ExplorerTaskbarTimeout();
    public static AvTraceDetails get_ExplorerTaskbarRetrying();
    public static AvTraceDetails get_ExplorerTaskbarNotRunning();
    public static AvTraceDetails NativeTaskbarError(Object[] args);
    public static AvTraceDetails get_RejectingJumpItemsBecauseCatastrophicFailure();
    public static AvTraceDetails RejectingJumpListCategoryBecauseNoRegisteredHandler(Object[] args);
    public static void Trace(TraceEventType type, AvTraceDetails traceDetails, Object[] parameters);
    public static void Trace(TraceEventType type, AvTraceDetails traceDetails);
    public static void Trace(TraceEventType type, AvTraceDetails traceDetails, object p1);
    public static void Trace(TraceEventType type, AvTraceDetails traceDetails, object p1, object p2);
    public static void Trace(TraceEventType type, AvTraceDetails traceDetails, object p1, object p2, object p3);
    public static void TraceActivityItem(AvTraceDetails traceDetails, Object[] parameters);
    public static void TraceActivityItem(AvTraceDetails traceDetails);
    public static void TraceActivityItem(AvTraceDetails traceDetails, object p1);
    public static void TraceActivityItem(AvTraceDetails traceDetails, object p1, object p2);
    public static void TraceActivityItem(AvTraceDetails traceDetails, object p1, object p2, object p3);
    public static bool get_IsEnabled();
    public static bool get_IsEnabledOverride();
    public static void Refresh();
}
internal class MS.Internal.UncommonValueTable : ValueType {
    private Object[] _table;
    private UInt32 _bitmask;
    public bool HasValue(int id);
    public object GetValue(int id);
    public object GetValue(int id, object defaultValue);
    public void SetValue(int id, object value);
    public void ClearValue(int id);
    private int IndexOf(int id);
    private int Find(int id);
    private int GetIndex(int id);
}
internal static class MS.Internal.Utility.BindUriHelper : object {
    private static int MAX_PATH_LENGTH;
    private static int MAX_SCHEME_LENGTH;
    public static int MAX_URL_LENGTH;
    private static string PLACEBOURI;
    private static Uri placeboBase;
    private static string FRAGMENTMARKER;
    internal static Uri BaseUri { get; internal set; }
    private static BindUriHelper();
    internal static string UriToString(Uri uri);
    internal static Uri get_BaseUri();
    internal static void set_BaseUri(Uri value);
    internal static bool DoSchemeAndHostMatch(Uri first, Uri second);
    internal static Uri GetResolvedUri(Uri baseUri, Uri orgUri);
    internal static string GetReferer(Uri destinationUri);
    internal static Uri GetResolvedUri(Uri originalUri);
    internal static Uri GetUriToNavigate(DependencyObject element, Uri baseUri, Uri inputUri);
    internal static bool StartWithFragment(Uri uri);
    internal static string GetFragment(Uri uri);
    internal static Uri GetUriRelativeToPackAppBase(Uri original);
    internal static bool IsXamlMimeType(ContentType mimeType);
}
internal class MS.Internal.Utility.MonitorWrapper : object {
    private int _enterCount;
    private object _syncRoot;
    public bool Busy { get; }
    public IDisposable Enter();
    public void Exit();
    public bool get_Busy();
}
internal class MS.Internal.Utility.TraceLog : object {
    private ArrayList _log;
    private int _size;
    internal TraceLog(int size);
    internal void Add(string message, Object[] args);
    internal void WriteLog();
    internal static string IdFor(object o);
}
[DefaultMemberAttribute("Item")]
internal class MS.Internal.WeakDictionary`2 : object {
    private IWeakHashtable _hashTable;
    private KeyCollection`2<TKey, TValue, TKey, TValue> _keys;
    private ValueCollection`2<TKey, TValue, TKey, TValue> _values;
    public ICollection`1<TKey> Keys { get; }
    public ICollection`1<TValue> Values { get; }
    public TValue Item { get; public set; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public sealed virtual void Add(TKey key, TValue value);
    public sealed virtual bool ContainsKey(TKey key);
    public sealed virtual ICollection`1<TKey> get_Keys();
    public sealed virtual bool Remove(TKey key);
    public sealed virtual bool TryGetValue(TKey key, TValue& value);
    public sealed virtual ICollection`1<TValue> get_Values();
    public sealed virtual TValue get_Item(TKey key);
    public sealed virtual void set_Item(TKey key, TValue value);
    public sealed virtual void Add(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual void CopyTo(KeyValuePair`2[] array, int arrayIndex);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool Remove(KeyValuePair`2<TKey, TValue> item);
    [IteratorStateMachineAttribute("MS.Internal.WeakDictionary`2/<GetEnumerator>d__22")]
public sealed virtual IEnumerator`1<KeyValuePair`2<TKey, TValue>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal class MS.Internal.WeakHashSet`1 : object {
    private WeakHashtable _hashTable;
    public int Count { get; }
    public bool IsReadOnly { get; }
    public sealed virtual void Add(T item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T item);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool Remove(T item);
    [IteratorStateMachineAttribute("MS.Internal.WeakHashSet`1/<GetEnumerator>d__9")]
public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal class MS.Internal.WeakHashtable : Hashtable {
    private static IEqualityComparer _comparer;
    private long _lastGlobalMem;
    private int _lastHashCount;
    private static WeakHashtable();
    public virtual void Clear();
    public virtual void Remove(object key);
    public sealed virtual void SetWeak(object key, object value);
    public sealed virtual object UnwrapKey(object key);
    private void ScavengeKeys();
    public static IWeakHashtable FromKeyType(Type tKey);
}
internal class MS.Internal.WeakObjectHashtable : Hashtable {
    private static IEqualityComparer _comparer;
    private long _lastGlobalMem;
    private int _lastHashCount;
    private static WeakObjectHashtable();
    public sealed virtual void SetWeak(object key, object value);
    private void WrapKey(Object& key);
    public sealed virtual object UnwrapKey(object key);
    private void ScavengeKeys();
}
[ExtensionAttribute]
internal static class MS.Internal.WindowsRuntime.ReflectionHelper : object {
    [ExtensionAttribute]
public static TResult ReflectionStaticCall(Type type, string methodName);
    [ExtensionAttribute]
public static TResult ReflectionStaticCall(Type type, string methodName, TArg arg);
    [ExtensionAttribute]
public static TResult ReflectionCall(object obj, string methodName);
    [ExtensionAttribute]
public static object ReflectionCall(object obj, string methodName);
    [ExtensionAttribute]
public static object ReflectionCall(object obj, string methodName, TArg1 arg1);
    [ExtensionAttribute]
public static TResult ReflectionCall(object obj, string methodName, TArg1 arg1);
    [ExtensionAttribute]
public static object ReflectionCall(object obj, string methodName, TArg1 arg1, TArg2 arg2);
    [ExtensionAttribute]
public static TResult ReflectionCall(object obj, string methodName, TArg1 arg1, TArg2 arg2);
    [ExtensionAttribute]
public static TResult ReflectionGetField(object obj, string fieldName);
    [ExtensionAttribute]
public static object ReflectionNew(Type type);
    [ExtensionAttribute]
public static object ReflectionNew(Type type, TArg1 arg1);
    [ExtensionAttribute]
public static object ReflectionNew(Type type, TArg1 arg1, TArg2 arg2);
    [ExtensionAttribute]
public static TResult ReflectionGetProperty(object obj, string propertyName);
    [ExtensionAttribute]
public static object ReflectionGetProperty(object obj, string propertyName);
    [ExtensionAttribute]
public static TResult ReflectionStaticGetProperty(Type type, string propertyName);
}
internal enum MS.Internal.WindowsRuntime.Windows.Data.Text.AlternateNormalizationFormat : Enum {
    public int value__;
    public static AlternateNormalizationFormat NotNormalized;
    public static AlternateNormalizationFormat Number;
    public static AlternateNormalizationFormat Currency;
    public static AlternateNormalizationFormat Date;
    public static AlternateNormalizationFormat Time;
}
internal class MS.Internal.WindowsRuntime.Windows.Data.Text.AlternateWordForm : object {
    private static Type s_WinRTType;
    private static string s_TypeName;
    private object _alternateWordForm;
    private TextSegment _sourceTextSegment;
    private Nullable`1<AlternateNormalizationFormat> _alternateNormalizationFormat;
    private string _alternateText;
    public string AlternateText { get; }
    public AlternateNormalizationFormat NormalizationFormat { get; }
    public TextSegment SourceTextSegment { get; }
    public static Type WinRTType { get; }
    private static AlternateWordForm();
    public AlternateWordForm(object alternateWordForm);
    public string get_AlternateText();
    public AlternateNormalizationFormat get_NormalizationFormat();
    public TextSegment get_SourceTextSegment();
    public static Type get_WinRTType();
}
internal class MS.Internal.WindowsRuntime.Windows.Data.Text.TextSegment : object {
    private static Type s_WinRTType;
    private static string s_TypeName;
    private object _textSegment;
    private Nullable`1<UInt32> _length;
    private Nullable`1<UInt32> _startPosition;
    public UInt32 Length { get; }
    public UInt32 StartPosition { get; }
    public static Type WinRTType { get; }
    private static TextSegment();
    public TextSegment(object textSegment);
    public UInt32 get_Length();
    public UInt32 get_StartPosition();
    public static Type get_WinRTType();
}
internal class MS.Internal.WindowsRuntime.Windows.Data.Text.WordSegment : object {
    private object _wordSegment;
    private IReadOnlyList`1<AlternateWordForm> _alternateForms;
    private TextSegment _sourceTextSegment;
    private string _text;
    private static string s_TypeName;
    private static Type s_WinRTType;
    public IReadOnlyList`1<AlternateWordForm> AlternateForms { get; }
    public TextSegment SourceTextSegment { get; }
    public string Text { get; }
    public static Type WinRTType { get; }
    private static WordSegment();
    public WordSegment(object wordSegment);
    public IReadOnlyList`1<AlternateWordForm> get_AlternateForms();
    public TextSegment get_SourceTextSegment();
    public string get_Text();
    public static Type get_WinRTType();
}
internal class MS.Internal.WindowsRuntime.Windows.Data.Text.WordSegmentsTokenizingHandler : MulticastDelegate {
    public WordSegmentsTokenizingHandler(object object, IntPtr method);
    public virtual void Invoke(IEnumerable`1<WordSegment> precedingWords, IEnumerable`1<WordSegment> words);
    public virtual IAsyncResult BeginInvoke(IEnumerable`1<WordSegment> precedingWords, IEnumerable`1<WordSegment> words, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class MS.Internal.WindowsRuntime.Windows.Data.Text.WordsSegmenter : object {
    [CompilerGeneratedAttribute]
private static List`1<string> <ScriptCodesRequiringDedicatedSegmenter>k__BackingField;
    public static string Undetermined;
    private static string s_TypeName;
    private static Type s_WinRTType;
    private static bool s_PlatformSupported;
    private object _wordsSegmenter;
    private string _resolvedLanguage;
    public string ResolvedLanguage { get; }
    public static Type WinRTType { get; }
    private static List`1<string> ScriptCodesRequiringDedicatedSegmenter { get; }
    private static WordsSegmenter();
    private WordsSegmenter(string language);
    public static WordsSegmenter Create(string language, bool shouldPreferNeutralSegmenter);
    public WordSegment GetTokenAt(string text, UInt32 startIndex);
    public IReadOnlyList`1<WordSegment> GetTokens(string text);
    public void Tokenize(string text, UInt32 startIndex, WordSegmentsTokenizingHandler handler);
    public string get_ResolvedLanguage();
    public static Type get_WinRTType();
    private static bool ShouldUseDedicatedSegmenter(string languageTag);
    [CompilerGeneratedAttribute]
private static List`1<string> get_ScriptCodesRequiringDedicatedSegmenter();
}
internal class MS.Internal.WindowsRuntime.Windows.Globalization.Language : object {
    private static Type s_WinRTType;
    private static bool s_Supported;
    private static string s_TypeName;
    private object _language;
    public static string CurrentInputMethodLanguageTag { get; }
    public string DisplayName { get; }
    public string LanguageTag { get; }
    public string NativeName { get; }
    public string Script { get; }
    private static Language();
    public Language(string languageTag);
    public IReadOnlyList`1<string> GetExtensionSubtags(string singleton);
    public static bool IsWellFormed(string languageTag);
    public static bool TrySetInputMethodLanguageTag(string languageTag);
    public static string get_CurrentInputMethodLanguageTag();
    public string get_DisplayName();
    public string get_LanguageTag();
    public string get_NativeName();
    public string get_Script();
}
internal class MS.Internal.Xaml.Context.XamlContextStack`1 : object {
    private int _depth;
    private T _currentFrame;
    private T _recycledFrame;
    private Func`1<T> _creationDelegate;
    public T CurrentFrame { get; }
    public T PreviousFrame { get; }
    public T PreviousPreviousFrame { get; }
    public int Depth { get; public set; }
    public string Frames { get; }
    public XamlContextStack`1(Func`1<T> creationDelegate);
    public XamlContextStack`1(XamlContextStack`1<T> source, bool copy);
    private void Grow();
    public T get_CurrentFrame();
    public T get_PreviousFrame();
    public T get_PreviousPreviousFrame();
    public T GetFrame(int depth);
    public void PushScope();
    public void PopScope();
    public int get_Depth();
    public void set_Depth(int value);
    public void Trim();
    public string get_Frames();
    private void ShowFrame(StringBuilder sb, T iteratorFrame);
}
internal abstract class MS.Internal.Xaml.Context.XamlFrame : object {
    private int _depth;
    private XamlFrame _previous;
    public int Depth { get; }
    public XamlFrame Previous { get; public set; }
    protected XamlFrame(XamlFrame source);
    public virtual XamlFrame Clone();
    public abstract virtual void Reset();
    public int get_Depth();
    public XamlFrame get_Previous();
    public void set_Previous(XamlFrame value);
}
internal class MS.Internal.Xaml.Parser.SpecialBracketCharacters : object {
    private string _startChars;
    private string _endChars;
    private static ISet`1<char> _restrictedCharSet;
    private bool _initializing;
    private StringBuilder _startCharactersStringBuilder;
    private StringBuilder _endCharactersStringBuilder;
    internal string StartBracketCharacters { get; }
    internal string EndBracketCharacters { get; }
    internal SpecialBracketCharacters(IReadOnlyDictionary`2<char, char> attributeList);
    private static SpecialBracketCharacters();
    internal void AddBracketCharacters(char openingBracket, char closingBracket);
    private void Tokenize(IReadOnlyDictionary`2<char, char> attributeList);
    private bool IsValidBracketCharacter(char openingBracket, char closingBracket);
    internal bool IsSpecialCharacter(char ch);
    internal bool StartsEscapeSequence(char ch);
    internal bool EndsEscapeSequence(char ch);
    internal bool Match(char start, char end);
    internal string get_StartBracketCharacters();
    internal string get_EndBracketCharacters();
    public sealed virtual void BeginInit();
    public sealed virtual void EndInit();
}
internal class MS.Utility.ItemStructMap`1 : ValueType {
    private static int SearchTypeThreshold;
    public Entry[] Entries;
    public int Count;
    private static Entry<T> EmptyEntry;
    public int EnsureEntry(int key);
    public int Search(int key);
}
internal static class MS.Win32.UxThemeWrapper : object {
    private static ThemeState _themeState;
    private static bool _isActive;
    private static string _themeName;
    private static string _themeColor;
    internal static bool IsActive { get; }
    internal static string ThemeName { get; }
    internal static string ThemeColor { get; }
    internal static string ThemedResourceName { get; }
    private static bool IsAppSupported { get; }
    private static bool IsActiveCompatWrapper { get; }
    private static string ThemeNameCompatWrapper { get; }
    private static string ThemeColorCompatWrapper { get; }
    private static string ThemedResourceNameCompatWrapper { get; }
    private static UxThemeWrapper();
    internal static bool get_IsActive();
    internal static string get_ThemeName();
    internal static string get_ThemeColor();
    internal static string get_ThemedResourceName();
    private static ThemeState EnsureThemeState(bool themeChanged);
    private static void GetThemeNameAndColor(String& themeName, String& themeColor);
    internal static void OnThemeChanged();
    private static bool get_IsAppSupported();
    private static bool get_IsActiveCompatWrapper();
    private static string get_ThemeNameCompatWrapper();
    private static string get_ThemeColorCompatWrapper();
    private static string get_ThemedResourceNameCompatWrapper();
    private static void RestoreSupportedState();
}
internal enum Standard.AC : Enum {
    public byte value__;
    public static AC SRC_OVER;
    public static AC SRC_ALPHA;
}
internal enum Standard.APPDOCLISTTYPE : Enum {
    public int value__;
    public static APPDOCLISTTYPE ADLT_RECENT;
    public static APPDOCLISTTYPE ADLT_FREQUENT;
}
internal static class Standard.Assert : object {
    private static void _Break();
    [ConditionalAttribute("DEBUG")]
public static void Evaluate(EvaluateFunction argument);
    [ConditionalAttribute("DEBUG")]
[ObsoleteAttribute("Use Assert.AreEqual instead of Assert.Equals", "False")]
public static void Equals(T expected, T actual);
    [ConditionalAttribute("DEBUG")]
public static void AreEqual(T expected, T actual);
    [ConditionalAttribute("DEBUG")]
public static void AreNotEqual(T notExpected, T actual);
    [ConditionalAttribute("DEBUG")]
public static void Implies(bool condition, bool result);
    [ConditionalAttribute("DEBUG")]
public static void Implies(bool condition, ImplicationFunction result);
    [ConditionalAttribute("DEBUG")]
public static void IsNeitherNullNorEmpty(string value);
    [ConditionalAttribute("DEBUG")]
public static void IsNeitherNullNorWhitespace(string value);
    [ConditionalAttribute("DEBUG")]
public static void IsNotNull(T value);
    [ConditionalAttribute("DEBUG")]
public static void IsDefault(T value);
    [ConditionalAttribute("DEBUG")]
public static void IsNotDefault(T value);
    [ConditionalAttribute("DEBUG")]
public static void IsFalse(bool condition);
    [ConditionalAttribute("DEBUG")]
public static void IsFalse(bool condition, string message);
    [ConditionalAttribute("DEBUG")]
public static void IsTrue(bool condition);
    [ConditionalAttribute("DEBUG")]
public static void IsTrue(bool condition, string message);
    [ConditionalAttribute("DEBUG")]
public static void Fail();
    [ConditionalAttribute("DEBUG")]
public static void Fail(string message);
    [ConditionalAttribute("DEBUG")]
public static void IsNull(T item);
    [ConditionalAttribute("DEBUG")]
public static void BoundedDoubleInc(double lowerBoundInclusive, double value, double upperBoundInclusive);
    [ConditionalAttribute("DEBUG")]
public static void BoundedInteger(int lowerBoundInclusive, int value, int upperBoundExclusive);
    [ConditionalAttribute("DEBUG")]
public static void IsApartmentState(ApartmentState expectedState);
    [ConditionalAttribute("DEBUG")]
public static void NullableIsNotNull(Nullable`1<T> value);
    [ConditionalAttribute("DEBUG")]
public static void NullableIsNull(Nullable`1<T> value);
    [ConditionalAttribute("DEBUG")]
public static void IsNotOnMainThread();
}
internal enum Standard.BI : Enum {
    public int value__;
    public static BI RGB;
}
internal class Standard.BITMAPINFO : ValueType {
    public BITMAPINFOHEADER bmiHeader;
    public RGBQUAD bmiColors;
}
internal class Standard.BITMAPINFOHEADER : ValueType {
    public int biSize;
    public int biWidth;
    public int biHeight;
    public short biPlanes;
    public short biBitCount;
    public BI biCompression;
    public int biSizeImage;
    public int biXPelsPerMeter;
    public int biYPelsPerMeter;
    public int biClrUsed;
    public int biClrImportant;
}
internal class Standard.BLENDFUNCTION : ValueType {
    public AC BlendOp;
    public byte BlendFlags;
    public byte SourceConstantAlpha;
    public AC AlphaFormat;
}
internal class Standard.CHANGEFILTERSTRUCT : ValueType {
    public UInt32 cbSize;
    public MSGFLTINFO ExtStatus;
}
internal static class Standard.CLSID : object {
    public static string TaskbarList;
    public static string EnumerableObjectCollection;
    public static string ShellLink;
    public static string DestinationList;
    public static string ApplicationDestinations;
    public static string ApplicationDocumentLists;
    public static T CoCreateInstance(string clsid);
}
internal enum Standard.CombineRgnResult : Enum {
    public int value__;
    public static CombineRgnResult ERROR;
    public static CombineRgnResult NULLREGION;
    public static CombineRgnResult SIMPLEREGION;
    public static CombineRgnResult COMPLEXREGION;
}
internal class Standard.CREATESTRUCT : ValueType {
    public IntPtr lpCreateParams;
    public IntPtr hInstance;
    public IntPtr hMenu;
    public IntPtr hwndParent;
    public int cy;
    public int cx;
    public int y;
    public int x;
    public WS style;
    public string lpszName;
    public string lpszClass;
    public WS_EX dwExStyle;
}
[FlagsAttribute]
internal enum Standard.CS : Enum {
    public UInt32 value__;
    public static CS VREDRAW;
    public static CS HREDRAW;
    public static CS DBLCLKS;
    public static CS OWNDC;
    public static CS CLASSDC;
    public static CS PARENTDC;
    public static CS NOCLOSE;
    public static CS SAVEBITS;
    public static CS BYTEALIGNCLIENT;
    public static CS BYTEALIGNWINDOW;
    public static CS GLOBALCLASS;
    public static CS IME;
    public static CS DROPSHADOW;
}
internal enum Standard.DeviceCap : Enum {
    public int value__;
    public static DeviceCap BITSPIXEL;
    public static DeviceCap PLANES;
    public static DeviceCap LOGPIXELSX;
    public static DeviceCap LOGPIXELSY;
}
internal enum Standard.DOGIF : Enum {
    public int value__;
    public static DOGIF DEFAULT;
    public static DOGIF TRAVERSE_LINK;
    public static DOGIF NO_HDROP;
    public static DOGIF NO_URL;
    public static DOGIF ONLY_IF_ONE;
}
internal static class Standard.DoubleUtilities : object {
    private static double Epsilon;
    public static bool AreClose(double value1, double value2);
    public static bool LessThan(double value1, double value2);
    public static bool GreaterThan(double value1, double value2);
    public static bool LessThanOrClose(double value1, double value2);
    public static bool GreaterThanOrClose(double value1, double value2);
    public static bool IsFinite(double value);
    public static bool IsValidSize(double value);
}
internal static class Standard.DpiHelper : object {
    [ThreadStaticAttribute]
private static Matrix _transformToDevice;
    [ThreadStaticAttribute]
private static Matrix _transformToDip;
    public static Point LogicalPixelsToDevice(Point logicalPoint, double dpiScaleX, double dpiScaleY);
    public static Point DevicePixelsToLogical(Point devicePoint, double dpiScaleX, double dpiScaleY);
    public static Rect LogicalRectToDevice(Rect logicalRectangle, double dpiScaleX, double dpiScaleY);
    public static Rect DeviceRectToLogical(Rect deviceRectangle, double dpiScaleX, double dpiScaleY);
    public static Size LogicalSizeToDevice(Size logicalSize, double dpiScaleX, double dpiScaleY);
    public static Size DeviceSizeToLogical(Size deviceSize, double dpiScaleX, double dpiScaleY);
    public static Thickness LogicalThicknessToDevice(Thickness logicalThickness, double dpiScaleX, double dpiScaleY);
}
internal enum Standard.DWM_SIT : Enum {
    public int value__;
    public static DWM_SIT None;
    public static DWM_SIT DISPLAYFRAME;
}
internal class Standard.DWM_TIMING_INFO : ValueType {
    public int cbSize;
    public UNSIGNED_RATIO rateRefresh;
    public ulong qpcRefreshPeriod;
    public UNSIGNED_RATIO rateCompose;
    public ulong qpcVBlank;
    public ulong cRefresh;
    public UInt32 cDXRefresh;
    public ulong qpcCompose;
    public ulong cFrame;
    public UInt32 cDXPresent;
    public ulong cRefreshFrame;
    public ulong cFrameSubmitted;
    public UInt32 cDXPresentSubmitted;
    public ulong cFrameConfirmed;
    public UInt32 cDXPresentConfirmed;
    public ulong cRefreshConfirmed;
    public UInt32 cDXRefreshConfirmed;
    public ulong cFramesLate;
    public UInt32 cFramesOutstanding;
    public ulong cFrameDisplayed;
    public ulong qpcFrameDisplayed;
    public ulong cRefreshFrameDisplayed;
    public ulong cFrameComplete;
    public ulong qpcFrameComplete;
    public ulong cFramePending;
    public ulong qpcFramePending;
    public ulong cFramesDisplayed;
    public ulong cFramesComplete;
    public ulong cFramesPending;
    public ulong cFramesAvailable;
    public ulong cFramesDropped;
    public ulong cFramesMissed;
    public ulong cRefreshNextDisplayed;
    public ulong cRefreshNextPresented;
    public ulong cRefreshesDisplayed;
    public ulong cRefreshesPresented;
    public ulong cRefreshStarted;
    public ulong cPixelsReceived;
    public ulong cPixelsDrawn;
    public ulong cBuffersEmpty;
}
internal enum Standard.DWMFLIP3D : Enum {
    public int value__;
    public static DWMFLIP3D DEFAULT;
    public static DWMFLIP3D EXCLUDEBELOW;
    public static DWMFLIP3D EXCLUDEABOVE;
}
internal enum Standard.DWMNCRP : Enum {
    public int value__;
    public static DWMNCRP USEWINDOWSTYLE;
    public static DWMNCRP DISABLED;
    public static DWMNCRP ENABLED;
}
internal enum Standard.DWMWA : Enum {
    public int value__;
    public static DWMWA NCRENDERING_ENABLED;
    public static DWMWA NCRENDERING_POLICY;
    public static DWMWA TRANSITIONS_FORCEDISABLED;
    public static DWMWA ALLOW_NCPAINT;
    public static DWMWA CAPTION_BUTTON_BOUNDS;
    public static DWMWA NONCLIENT_RTL_LAYOUT;
    public static DWMWA FORCE_ICONIC_REPRESENTATION;
    public static DWMWA FLIP3D_POLICY;
    public static DWMWA EXTENDED_FRAME_BOUNDS;
    public static DWMWA HAS_ICONIC_BITMAP;
    public static DWMWA DISALLOW_PEEK;
    public static DWMWA EXCLUDED_FROM_PEEK;
}
[FlagsAttribute]
internal enum Standard.ErrorModes : Enum {
    public int value__;
    public static ErrorModes Default;
    public static ErrorModes FailCriticalErrors;
    public static ErrorModes NoGpFaultErrorBox;
    public static ErrorModes NoAlignmentFaultExcept;
    public static ErrorModes NoOpenFileErrorBox;
}
internal enum Standard.Facility : Enum {
    public int value__;
    public static Facility Null;
    public static Facility Rpc;
    public static Facility Dispatch;
    public static Facility Storage;
    public static Facility Itf;
    public static Facility Win32;
    public static Facility Windows;
    public static Facility Control;
    public static Facility Ese;
    public static Facility WinCodec;
}
internal enum Standard.FO : Enum {
    public int value__;
    public static FO MOVE;
    public static FO COPY;
    public static FO DELETE;
    public static FO RENAME;
}
internal enum Standard.FOF : Enum {
    public ushort value__;
    public static FOF MULTIDESTFILES;
    public static FOF CONFIRMMOUSE;
    public static FOF SILENT;
    public static FOF RENAMEONCOLLISION;
    public static FOF NOCONFIRMATION;
    public static FOF WANTMAPPINGHANDLE;
    public static FOF ALLOWUNDO;
    public static FOF FILESONLY;
    public static FOF SIMPLEPROGRESS;
    public static FOF NOCONFIRMMKDIR;
    public static FOF NOERRORUI;
    public static FOF NOCOPYSECURITYATTRIBS;
    public static FOF NORECURSION;
    public static FOF NO_CONNECTED_ELEMENTS;
    public static FOF WANTNUKEWARNING;
    public static FOF NORECURSEREPARSE;
}
internal enum Standard.GCLP : Enum {
    public int value__;
    public static GCLP HBRBACKGROUND;
}
internal enum Standard.GPS : Enum {
    public int value__;
    public static GPS DEFAULT;
    public static GPS HANDLERPROPERTIESONLY;
    public static GPS READWRITE;
    public static GPS TEMPORARY;
    public static GPS FASTPROPERTIESONLY;
    public static GPS OPENSLOWITEM;
    public static GPS DELAYCREATION;
    public static GPS BESTEFFORT;
    public static GPS NO_OPLOCK;
    public static GPS MASK_VALID;
}
internal enum Standard.GWL : Enum {
    public int value__;
    public static GWL WNDPROC;
    public static GWL HINSTANCE;
    public static GWL HWNDPARENT;
    public static GWL STYLE;
    public static GWL EXSTYLE;
    public static GWL USERDATA;
    public static GWL ID;
}
[FlagsAttribute]
internal enum Standard.HCF : Enum {
    public int value__;
    public static HCF HIGHCONTRASTON;
    public static HCF AVAILABLE;
    public static HCF HOTKEYACTIVE;
    public static HCF CONFIRMHOTKEY;
    public static HCF HOTKEYSOUND;
    public static HCF INDICATOR;
    public static HCF HOTKEYAVAILABLE;
}
internal class Standard.HIGHCONTRAST : ValueType {
    public int cbSize;
    public HCF dwFlags;
    public IntPtr lpszDefaultScheme;
}
internal class Standard.HRESULT : ValueType {
    private UInt32 _value;
    public static HRESULT S_OK;
    public static HRESULT S_FALSE;
    public static HRESULT E_PENDING;
    public static HRESULT E_NOTIMPL;
    public static HRESULT E_NOINTERFACE;
    public static HRESULT E_POINTER;
    public static HRESULT E_ABORT;
    public static HRESULT E_FAIL;
    public static HRESULT E_UNEXPECTED;
    public static HRESULT STG_E_INVALIDFUNCTION;
    public static HRESULT REGDB_E_CLASSNOTREG;
    public static HRESULT DESTS_E_NO_MATCHING_ASSOC_HANDLER;
    public static HRESULT DESTS_E_NORECDOCS;
    public static HRESULT DESTS_E_NOTALLCLEARED;
    public static HRESULT E_ACCESSDENIED;
    public static HRESULT E_OUTOFMEMORY;
    public static HRESULT E_INVALIDARG;
    public static HRESULT INTSAFE_E_ARITHMETIC_OVERFLOW;
    public static HRESULT COR_E_OBJECTDISPOSED;
    public static HRESULT WC_E_GREATERTHAN;
    public static HRESULT WC_E_SYNTAX;
    public Facility Facility { get; }
    public int Code { get; }
    public bool Succeeded { get; }
    public bool Failed { get; }
    public HRESULT(UInt32 i);
    private static HRESULT();
    public static HRESULT Make(bool severe, Facility facility, int code);
    public Facility get_Facility();
    public static Facility GetFacility(int errorCode);
    public int get_Code();
    public static int GetCode(int error);
    public virtual string ToString();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(HRESULT hrLeft, HRESULT hrRight);
    public static bool op_Inequality(HRESULT hrLeft, HRESULT hrRight);
    public bool get_Succeeded();
    public bool get_Failed();
    public void ThrowIfFailed();
    public void ThrowIfFailed(string message);
    public static void ThrowLastError();
    private static Exception CreateWin32Exception(int code, string message);
}
internal enum Standard.HT : Enum {
    public int value__;
    public static HT ERROR;
    public static HT TRANSPARENT;
    public static HT NOWHERE;
    public static HT CLIENT;
    public static HT CAPTION;
    public static HT SYSMENU;
    public static HT GROWBOX;
    public static HT SIZE;
    public static HT MENU;
    public static HT HSCROLL;
    public static HT VSCROLL;
    public static HT MINBUTTON;
    public static HT MAXBUTTON;
    public static HT LEFT;
    public static HT RIGHT;
    public static HT TOP;
    public static HT TOPLEFT;
    public static HT TOPRIGHT;
    public static HT BOTTOM;
    public static HT BOTTOMLEFT;
    public static HT BOTTOMRIGHT;
    public static HT BORDER;
    public static HT REDUCE;
    public static HT ZOOM;
    public static HT SIZEFIRST;
    public static HT SIZELAST;
    public static HT OBJECT;
    public static HT CLOSE;
    public static HT HELP;
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("12337d35-94c6-48a0-bce7-6a9c69d4d600")]
internal interface Standard.IApplicationDestinations {
    public abstract virtual void SetAppID(string pszAppID);
    public abstract virtual void RemoveDestination(object punk);
    public abstract virtual void RemoveAllDestinations();
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("3c594f9f-9f30-47a1-979a-c9e83d3d0a06")]
internal interface Standard.IApplicationDocumentLists {
    public abstract virtual void SetAppID(string pszAppID);
    public abstract virtual object GetList(APPDOCLISTTYPE listtype, UInt32 cItemsDesired, Guid& riid);
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("6332debf-87b5-4670-90c0-5e57b408a49e")]
internal interface Standard.ICustomDestinationList {
    public abstract virtual void SetAppID(string pszAppID);
    public abstract virtual object BeginList(UInt32& pcMaxSlots, Guid& riid);
    public abstract virtual HRESULT AppendCategory(string pszCategory, IObjectArray poa);
    public abstract virtual void AppendKnownCategory(KDC category);
    public abstract virtual HRESULT AddUserTasks(IObjectArray poa);
    public abstract virtual void CommitList();
    public abstract virtual object GetRemovedDestinations(Guid& riid);
    public abstract virtual void DeleteList(string pszAppID);
    public abstract virtual void AbortList();
}
[GuidAttribute("000214F2-0000-0000-C000-000000000046")]
[InterfaceTypeAttribute("1")]
internal interface Standard.IEnumIDList {
    public abstract virtual HRESULT Next(UInt32 celt, IntPtr& rgelt, Int32& pceltFetched);
    public abstract virtual HRESULT Skip(UInt32 celt);
    public abstract virtual void Reset();
    public abstract virtual void Clone(IEnumIDList& ppenum);
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("2c1c7e2e-2d0e-4059-831e-1e6f82335c2e")]
internal interface Standard.IEnumObjects {
    public abstract virtual void Next(UInt32 celt, Guid& riid, Object[] rgelt, UInt32& pceltFetched);
    public abstract virtual void Skip(UInt32 celt);
    public abstract virtual void Reset();
    public abstract virtual IEnumObjects Clone();
}
internal static class Standard.IID : object {
    public static string EnumIdList;
    public static string EnumObjects;
    public static string HtmlDocument2;
    public static string ModalWindow;
    public static string ObjectArray;
    public static string ObjectCollection;
    public static string PropertyNotifySink;
    public static string PropertyStore;
    public static string ServiceProvider;
    public static string ShellFolder;
    public static string ShellLink;
    public static string ShellItem;
    public static string ShellItem2;
    public static string ShellItemArray;
    public static string TaskbarList;
    public static string TaskbarList2;
    public static string Unknown;
    public static string ApplicationDestinations;
    public static string ApplicationDocumentLists;
    public static string CustomDestinationList;
    public static string ObjectWithAppUserModelId;
    public static string ObjectWithProgId;
    public static string TaskbarList3;
    public static string TaskbarList4;
}
internal class Standard.INPUT : ValueType {
    public UInt32 type;
    public MOUSEINPUT mi;
}
internal enum Standard.INPUT_TYPE : Enum {
    public UInt32 value__;
    public static INPUT_TYPE MOUSE;
}
[GuidAttribute("92CA9DCD-5622-4bba-A805-5E9F541BD8C9")]
[InterfaceTypeAttribute("1")]
internal interface Standard.IObjectArray {
    public abstract virtual UInt32 GetCount();
    public abstract virtual object GetAt(UInt32 uiIndex, Guid& riid);
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("92CA9DCD-5622-4bba-A805-5E9F541BD8C9")]
internal interface Standard.IObjectCollection {
    public abstract virtual UInt32 GetCount();
    public abstract virtual object GetAt(UInt32 uiIndex, Guid& riid);
    public abstract virtual void AddObject(object punk);
    public abstract virtual void AddFromArray(IObjectArray poaSource);
    public abstract virtual void RemoveObjectAt(UInt32 uiIndex);
    public abstract virtual void Clear();
}
[GuidAttribute("36db0196-9665-46d1-9ba7-d3709eecf9ed")]
[InterfaceTypeAttribute("1")]
internal interface Standard.IObjectWithAppUserModelId {
    public abstract virtual void SetAppID(string pszAppID);
    public abstract virtual string GetAppID();
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("71e806fb-8dee-46fc-bf8c-7748a8a1ae13")]
internal interface Standard.IObjectWithProgId {
    public abstract virtual void SetProgID(string pszProgID);
    public abstract virtual string GetProgID();
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("886d8eeb-8cf2-4446-8d02-cdba1dbdcf99")]
internal interface Standard.IPropertyStore {
    public abstract virtual UInt32 GetCount();
    public abstract virtual PKEY GetAt(UInt32 iProp);
    public abstract virtual void GetValue(PKEY& pkey, PROPVARIANT pv);
    public abstract virtual void SetValue(PKEY& pkey, PROPVARIANT pv);
    public abstract virtual void Commit();
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("000214E6-0000-0000-C000-000000000046")]
internal interface Standard.IShellFolder {
    public abstract virtual void ParseDisplayName(IntPtr hwnd, IBindCtx pbc, string pszDisplayName, Int32& pchEaten, IntPtr& ppidl, UInt32& pdwAttributes);
    public abstract virtual IEnumIDList EnumObjects(IntPtr hwnd, SHCONTF grfFlags);
    public abstract virtual object BindToObject(IntPtr pidl, IBindCtx pbc, Guid& riid);
    public abstract virtual object BindToStorage(IntPtr pidl, IBindCtx pbc, Guid& riid);
    public abstract virtual HRESULT CompareIDs(IntPtr lParam, IntPtr pidl1, IntPtr pidl2);
    public abstract virtual object CreateViewObject(IntPtr hwndOwner, Guid& riid);
    public abstract virtual void GetAttributesOf(UInt32 cidl, IntPtr apidl, SFGAO& rgfInOut);
    public abstract virtual object GetUIObjectOf(IntPtr hwndOwner, UInt32 cidl, IntPtr apidl, Guid& riid, UInt32& rgfReserved);
    public abstract virtual void GetDisplayNameOf(IntPtr pidl, SHGDN uFlags, IntPtr& pName);
    public abstract virtual void SetNameOf(IntPtr hwnd, IntPtr pidl, string pszName, SHGDN uFlags, IntPtr& ppidlOut);
}
[GuidAttribute("43826d1e-e718-42ee-bc55-a1e261c37bfe")]
[InterfaceTypeAttribute("1")]
internal interface Standard.IShellItem {
    public abstract virtual object BindToHandler(IBindCtx pbc, Guid& bhid, Guid& riid);
    public abstract virtual IShellItem GetParent();
    public abstract virtual string GetDisplayName(SIGDN sigdnName);
    public abstract virtual SFGAO GetAttributes(SFGAO sfgaoMask);
    public abstract virtual int Compare(IShellItem psi, SICHINT hint);
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("7e9fb0d3-919f-4307-ab2e-9b1860310c93")]
internal interface Standard.IShellItem2 {
    public abstract virtual object BindToHandler(IBindCtx pbc, Guid& bhid, Guid& riid);
    public abstract virtual IShellItem GetParent();
    public abstract virtual string GetDisplayName(SIGDN sigdnName);
    public abstract virtual SFGAO GetAttributes(SFGAO sfgaoMask);
    public abstract virtual int Compare(IShellItem psi, SICHINT hint);
    public abstract virtual object GetPropertyStore(GPS flags, Guid& riid);
    public abstract virtual object GetPropertyStoreWithCreateObject(GPS flags, object punkCreateObject, Guid& riid);
    public abstract virtual object GetPropertyStoreForKeys(IntPtr rgKeys, UInt32 cKeys, GPS flags, Guid& riid);
    public abstract virtual object GetPropertyDescriptionList(IntPtr keyType, Guid& riid);
    public abstract virtual void Update(IBindCtx pbc);
    public abstract virtual PROPVARIANT GetProperty(IntPtr key);
    public abstract virtual Guid GetCLSID(IntPtr key);
    public abstract virtual FILETIME GetFileTime(IntPtr key);
    public abstract virtual int GetInt32(IntPtr key);
    public abstract virtual string GetString(IntPtr key);
    public abstract virtual UInt32 GetUInt32(IntPtr key);
    public abstract virtual ulong GetUInt64(IntPtr key);
    public abstract virtual void GetBool(IntPtr key);
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("B63EA76D-1F85-456F-A19C-48159EFA858B")]
internal interface Standard.IShellItemArray {
    public abstract virtual object BindToHandler(IBindCtx pbc, Guid& rbhid, Guid& riid);
    public abstract virtual object GetPropertyStore(int flags, Guid& riid);
    public abstract virtual object GetPropertyDescriptionList(PKEY& keyType, Guid& riid);
    public abstract virtual UInt32 GetAttributes(SIATTRIBFLAGS dwAttribFlags, UInt32 sfgaoMask);
    public abstract virtual UInt32 GetCount();
    public abstract virtual IShellItem GetItemAt(UInt32 dwIndex);
    public abstract virtual object EnumItems();
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("000214F9-0000-0000-C000-000000000046")]
internal interface Standard.IShellLinkW {
    public abstract virtual void GetPath(StringBuilder pszFile, int cchMaxPath, WIN32_FIND_DATAW pfd, SLGP fFlags);
    public abstract virtual void GetIDList(IntPtr& ppidl);
    public abstract virtual void SetIDList(IntPtr pidl);
    public abstract virtual void GetDescription(StringBuilder pszFile, int cchMaxName);
    public abstract virtual void SetDescription(string pszName);
    public abstract virtual void GetWorkingDirectory(StringBuilder pszDir, int cchMaxPath);
    public abstract virtual void SetWorkingDirectory(string pszDir);
    public abstract virtual void GetArguments(StringBuilder pszArgs, int cchMaxPath);
    public abstract virtual void SetArguments(string pszArgs);
    public abstract virtual short GetHotKey();
    public abstract virtual void SetHotKey(short wHotKey);
    public abstract virtual UInt32 GetShowCmd();
    public abstract virtual void SetShowCmd(UInt32 iShowCmd);
    public abstract virtual void GetIconLocation(StringBuilder pszIconPath, int cchIconPath, Int32& piIcon);
    public abstract virtual void SetIconLocation(string pszIconPath, int iIcon);
    public abstract virtual void SetRelativePath(string pszPathRel, UInt32 dwReserved);
    public abstract virtual void Resolve(IntPtr hwnd, UInt32 fFlags);
    public abstract virtual void SetPath(string pszFile);
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("56FDF342-FD6D-11d0-958A-006097C9A090")]
internal interface Standard.ITaskbarList {
    public abstract virtual void HrInit();
    public abstract virtual void AddTab(IntPtr hwnd);
    public abstract virtual void DeleteTab(IntPtr hwnd);
    public abstract virtual void ActivateTab(IntPtr hwnd);
    public abstract virtual void SetActiveAlt(IntPtr hwnd);
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("602D4995-B13A-429b-A66E-1935E44F4317")]
internal interface Standard.ITaskbarList2 {
    public abstract virtual void HrInit();
    public abstract virtual void AddTab(IntPtr hwnd);
    public abstract virtual void DeleteTab(IntPtr hwnd);
    public abstract virtual void ActivateTab(IntPtr hwnd);
    public abstract virtual void SetActiveAlt(IntPtr hwnd);
    public abstract virtual void MarkFullscreenWindow(IntPtr hwnd, bool fFullscreen);
}
[GuidAttribute("ea1afb91-9e28-4b86-90e9-9e9f8a5eefaf")]
[InterfaceTypeAttribute("1")]
internal interface Standard.ITaskbarList3 {
    public abstract virtual void HrInit();
    public abstract virtual void AddTab(IntPtr hwnd);
    public abstract virtual void DeleteTab(IntPtr hwnd);
    public abstract virtual void ActivateTab(IntPtr hwnd);
    public abstract virtual void SetActiveAlt(IntPtr hwnd);
    public abstract virtual void MarkFullscreenWindow(IntPtr hwnd, bool fFullscreen);
    public abstract virtual HRESULT SetProgressValue(IntPtr hwnd, ulong ullCompleted, ulong ullTotal);
    public abstract virtual HRESULT SetProgressState(IntPtr hwnd, TBPF tbpFlags);
    public abstract virtual HRESULT RegisterTab(IntPtr hwndTab, IntPtr hwndMDI);
    public abstract virtual HRESULT UnregisterTab(IntPtr hwndTab);
    public abstract virtual HRESULT SetTabOrder(IntPtr hwndTab, IntPtr hwndInsertBefore);
    public abstract virtual HRESULT SetTabActive(IntPtr hwndTab, IntPtr hwndMDI, UInt32 dwReserved);
    public abstract virtual HRESULT ThumbBarAddButtons(IntPtr hwnd, UInt32 cButtons, THUMBBUTTON[] pButtons);
    public abstract virtual HRESULT ThumbBarUpdateButtons(IntPtr hwnd, UInt32 cButtons, THUMBBUTTON[] pButtons);
    public abstract virtual HRESULT ThumbBarSetImageList(IntPtr hwnd, object himl);
    public abstract virtual HRESULT SetOverlayIcon(IntPtr hwnd, IntPtr hIcon, string pszDescription);
    public abstract virtual HRESULT SetThumbnailTooltip(IntPtr hwnd, string pszTip);
    public abstract virtual HRESULT SetThumbnailClip(IntPtr hwnd, RefRECT prcClip);
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("ea1afb91-9e28-4b86-90e9-9e9f8a5eefaf")]
internal interface Standard.ITaskbarList4 {
    public abstract virtual void HrInit();
    public abstract virtual void AddTab(IntPtr hwnd);
    public abstract virtual void DeleteTab(IntPtr hwnd);
    public abstract virtual void ActivateTab(IntPtr hwnd);
    public abstract virtual void SetActiveAlt(IntPtr hwnd);
    public abstract virtual void MarkFullscreenWindow(IntPtr hwnd, bool fFullscreen);
    public abstract virtual HRESULT SetProgressValue(IntPtr hwnd, ulong ullCompleted, ulong ullTotal);
    public abstract virtual HRESULT SetProgressState(IntPtr hwnd, TBPF tbpFlags);
    public abstract virtual HRESULT RegisterTab(IntPtr hwndTab, IntPtr hwndMDI);
    public abstract virtual HRESULT UnregisterTab(IntPtr hwndTab);
    public abstract virtual HRESULT SetTabOrder(IntPtr hwndTab, IntPtr hwndInsertBefore);
    public abstract virtual HRESULT SetTabActive(IntPtr hwndTab, IntPtr hwndMDI, UInt32 dwReserved);
    public abstract virtual HRESULT ThumbBarAddButtons(IntPtr hwnd, UInt32 cButtons, THUMBBUTTON[] pButtons);
    public abstract virtual HRESULT ThumbBarUpdateButtons(IntPtr hwnd, UInt32 cButtons, THUMBBUTTON[] pButtons);
    public abstract virtual HRESULT ThumbBarSetImageList(IntPtr hwnd, object himl);
    public abstract virtual HRESULT SetOverlayIcon(IntPtr hwnd, IntPtr hIcon, string pszDescription);
    public abstract virtual HRESULT SetThumbnailTooltip(IntPtr hwnd, string pszTip);
    public abstract virtual HRESULT SetThumbnailClip(IntPtr hwnd, RefRECT prcClip);
    public abstract virtual void SetTabProperties(IntPtr hwndTab, STPF stpFlags);
}
internal enum Standard.KDC : Enum {
    public int value__;
    public static KDC FREQUENT;
    public static KDC RECENT;
}
internal class Standard.LOGFONT : ValueType {
    public int lfHeight;
    public int lfWidth;
    public int lfEscapement;
    public int lfOrientation;
    public int lfWeight;
    public byte lfItalic;
    public byte lfUnderline;
    public byte lfStrikeOut;
    public byte lfCharSet;
    public byte lfOutPrecision;
    public byte lfClipPrecision;
    public byte lfQuality;
    public byte lfPitchAndFamily;
    public string lfFaceName;
}
internal class Standard.MARGINS : ValueType {
    public int cxLeftWidth;
    public int cxRightWidth;
    public int cyTopHeight;
    public int cyBottomHeight;
}
internal class Standard.MessageHandler : MulticastDelegate {
    public MessageHandler(object object, IntPtr method);
    public virtual IntPtr Invoke(WM uMsg, IntPtr wParam, IntPtr lParam, Boolean& handled);
    public virtual IAsyncResult BeginInvoke(WM uMsg, IntPtr wParam, IntPtr lParam, Boolean& handled, AsyncCallback callback, object object);
    public virtual IntPtr EndInvoke(Boolean& handled, IAsyncResult result);
}
internal class Standard.MessageWindow : CriticalFinalizerObject {
    private static WndProc s_WndProc;
    private static Dictionary`2<IntPtr, MessageWindow> s_windowLookup;
    private WndProc _wndProcCallback;
    private string _className;
    private bool _isDisposed;
    private Dispatcher _dispatcher;
    [CompilerGeneratedAttribute]
private IntPtr <Handle>k__BackingField;
    public IntPtr Handle { get; private set; }
    private static MessageWindow();
    public MessageWindow(CS classStyle, WS style, WS_EX exStyle, Rect location, string name, WndProc callback);
    [CompilerGeneratedAttribute]
public IntPtr get_Handle();
    [CompilerGeneratedAttribute]
private void set_Handle(IntPtr value);
    protected virtual override void Finalize();
    public void Release();
    private void _Dispose(bool disposing, bool isHwndBeingDestroyed);
    private object _DestroyWindowCallback(object arg);
    private static IntPtr _WndProc(IntPtr hwnd, WM msg, IntPtr wParam, IntPtr lParam);
    private static void _DestroyWindow(IntPtr hwnd, string className);
}
[FlagsAttribute]
internal enum Standard.MF : Enum {
    public UInt32 value__;
    public static MF DOES_NOT_EXIST;
    public static MF ENABLED;
    public static MF BYCOMMAND;
    public static MF GRAYED;
    public static MF DISABLED;
}
internal class Standard.MINMAXINFO : ValueType {
    public POINT ptReserved;
    public POINT ptMaxSize;
    public POINT ptMaxPosition;
    public POINT ptMinTrackSize;
    public POINT ptMaxTrackSize;
}
internal class Standard.MONITORINFO : object {
    public int cbSize;
    public RECT rcMonitor;
    public RECT rcWork;
    public int dwFlags;
}
internal enum Standard.MOUSEEVENTF : Enum {
    public int value__;
    public static MOUSEEVENTF LEFTDOWN;
    public static MOUSEEVENTF LEFTUP;
}
internal class Standard.MOUSEINPUT : ValueType {
    public int dx;
    public int dy;
    public int mouseData;
    public int dwFlags;
    public int time;
    public IntPtr dwExtraInfo;
}
internal enum Standard.MSGFLT : Enum {
    public int value__;
    public static MSGFLT RESET;
    public static MSGFLT ALLOW;
    public static MSGFLT DISALLOW;
}
internal enum Standard.MSGFLTINFO : Enum {
    public int value__;
    public static MSGFLTINFO NONE;
    public static MSGFLTINFO ALREADYALLOWED_FORWND;
    public static MSGFLTINFO ALREADYDISALLOWED_FORWND;
    public static MSGFLTINFO ALLOWED_HIGHER;
}
internal static class Standard.NativeMethods : object {
    private static bool _AdjustWindowRectEx(RECT& lpRect, WS dwStyle, bool bMenu, WS_EX dwExStyle);
    public static RECT AdjustWindowRectEx(RECT lpRect, WS dwStyle, bool bMenu, WS_EX dwExStyle);
    private static bool _ChangeWindowMessageFilter(WM message, MSGFLT dwFlag);
    private static bool _ChangeWindowMessageFilterEx(IntPtr hwnd, WM message, MSGFLT action, CHANGEFILTERSTRUCT& pChangeFilterStruct);
    public static HRESULT ChangeWindowMessageFilterEx(IntPtr hwnd, WM message, MSGFLT action, MSGFLTINFO& filterInfo);
    public static CombineRgnResult CombineRgn(IntPtr hrgnDest, IntPtr hrgnSrc1, IntPtr hrgnSrc2, RGN fnCombineMode);
    private static IntPtr _CommandLineToArgvW(string cmdLine, Int32& numArgs);
    public static String[] CommandLineToArgvW(string cmdLine);
    private static SafeHBITMAP _CreateDIBSection(SafeDC hdc, BITMAPINFO& bitmapInfo, int iUsage, IntPtr& ppvBits, IntPtr hSection, int dwOffset);
    private static SafeHBITMAP _CreateDIBSectionIntPtr(IntPtr hdc, BITMAPINFO& bitmapInfo, int iUsage, IntPtr& ppvBits, IntPtr hSection, int dwOffset);
    public static SafeHBITMAP CreateDIBSection(SafeDC hdc, BITMAPINFO& bitmapInfo, IntPtr& ppvBits, IntPtr hSection, int dwOffset);
    private static IntPtr _CreateRoundRectRgn(int nLeftRect, int nTopRect, int nRightRect, int nBottomRect, int nWidthEllipse, int nHeightEllipse);
    public static IntPtr CreateRoundRectRgn(int nLeftRect, int nTopRect, int nRightRect, int nBottomRect, int nWidthEllipse, int nHeightEllipse);
    private static IntPtr _CreateRectRgn(int nLeftRect, int nTopRect, int nRightRect, int nBottomRect);
    public static IntPtr CreateRectRgn(int nLeftRect, int nTopRect, int nRightRect, int nBottomRect);
    private static IntPtr _CreateRectRgnIndirect(RECT& lprc);
    public static IntPtr CreateRectRgnIndirect(RECT lprc);
    public static IntPtr CreateSolidBrush(int crColor);
    private static IntPtr _CreateWindowEx(WS_EX dwExStyle, string lpClassName, string lpWindowName, WS dwStyle, int x, int y, int nWidth, int nHeight, IntPtr hWndParent, IntPtr hMenu, IntPtr hInstance, IntPtr lpParam);
    public static IntPtr CreateWindowEx(WS_EX dwExStyle, string lpClassName, string lpWindowName, WS dwStyle, int x, int y, int nWidth, int nHeight, IntPtr hWndParent, IntPtr hMenu, IntPtr hInstance, IntPtr lpParam);
    public static IntPtr DefWindowProc(IntPtr hWnd, WM Msg, IntPtr wParam, IntPtr lParam);
    public static bool DeleteObject(IntPtr hObject);
    public static bool DestroyIcon(IntPtr handle);
    public static bool DestroyWindow(IntPtr hwnd);
    public static bool IsWindow(IntPtr hwnd);
    public static void DwmExtendFrameIntoClientArea(IntPtr hwnd, MARGINS& pMarInset);
    private static bool _DwmIsCompositionEnabled();
    private static HRESULT _DwmGetColorizationColor(UInt32& pcrColorization, Boolean& pfOpaqueBlend);
    public static bool DwmGetColorizationColor(UInt32& pcrColorization, Boolean& pfOpaqueBlend);
    public static bool DwmIsCompositionEnabled();
    public static bool DwmDefWindowProc(IntPtr hwnd, WM msg, IntPtr wParam, IntPtr lParam, IntPtr& plResult);
    private static void _DwmSetWindowAttribute(IntPtr hwnd, DWMWA dwAttribute, Int32& pvAttribute, int cbAttribute);
    public static void DwmSetWindowAttributeFlip3DPolicy(IntPtr hwnd, DWMFLIP3D flip3dPolicy);
    public static void DwmSetWindowAttributeDisallowPeek(IntPtr hwnd, bool disallowPeek);
    private static int _EnableMenuItem(IntPtr hMenu, SC uIDEnableItem, MF uEnable);
    public static MF EnableMenuItem(IntPtr hMenu, SC uIDEnableItem, MF uEnable);
    private static bool _RemoveMenu(IntPtr hMenu, UInt32 uPosition, UInt32 uFlags);
    public static void RemoveMenu(IntPtr hMenu, SC uPosition, MF uFlags);
    private static bool _DrawMenuBar(IntPtr hWnd);
    public static void DrawMenuBar(IntPtr hWnd);
    [ReliabilityContractAttribute("3", "2")]
public static bool FindClose(IntPtr handle);
    public static SafeFindHandle FindFirstFileW(string lpFileName, WIN32_FIND_DATAW lpFindFileData);
    public static bool FindNextFileW(SafeFindHandle hndFindFile, WIN32_FIND_DATAW lpFindFileData);
    private static bool _GetClientRect(IntPtr hwnd, RECT& lpRect);
    public static RECT GetClientRect(IntPtr hwnd);
    private static HRESULT _GetCurrentThemeName(StringBuilder pszThemeFileName, int dwMaxNameChars, StringBuilder pszColorBuff, int cchMaxColorChars, StringBuilder pszSizeBuff, int cchMaxSizeChars);
    public static void GetCurrentThemeName(String& themeFileName, String& color, String& size);
    public static bool IsThemeActive();
    public static int GetDeviceCaps(SafeDC hdc, DeviceCap nIndex);
    private static int _GetModuleFileName(IntPtr hModule, StringBuilder lpFilename, int nSize);
    public static string GetModuleFileName(IntPtr hModule);
    private static IntPtr _GetModuleHandle(string lpModuleName);
    public static IntPtr GetModuleHandle(string lpModuleName);
    private static bool _GetMonitorInfo(IntPtr hMonitor, MONITORINFO lpmi);
    public static MONITORINFO GetMonitorInfo(IntPtr hMonitor);
    private static IntPtr _GetStockObject(StockObject fnObject);
    public static IntPtr GetStockObject(StockObject fnObject);
    public static IntPtr GetSystemMenu(IntPtr hWnd, bool bRevert);
    public static int GetSystemMetrics(SM nIndex);
    public static IntPtr GetWindowLongPtr(IntPtr hwnd, GWL nIndex);
    public static void SetWindowThemeAttribute(IntPtr hwnd, WINDOWTHEMEATTRIBUTETYPE eAttribute, WTA_OPTIONS& pvAttribute, UInt32 cbAttribute);
    private static bool GetWindowPlacement(IntPtr hwnd, WINDOWPLACEMENT lpwndpl);
    public static WINDOWPLACEMENT GetWindowPlacement(IntPtr hwnd);
    private static bool _GetWindowRect(IntPtr hWnd, RECT& lpRect);
    public static RECT GetWindowRect(IntPtr hwnd);
    public static Status GdipCreateBitmapFromStream(IStream stream, IntPtr& bitmap);
    public static Status GdipCreateHBITMAPFromBitmap(IntPtr bitmap, IntPtr& hbmReturn, int background);
    public static Status GdipCreateHICONFromBitmap(IntPtr bitmap, IntPtr& hbmReturn);
    public static Status GdipDisposeImage(IntPtr image);
    public static Status GdipImageForceValidation(IntPtr image);
    public static Status GdiplusStartup(IntPtr& token, StartupInput input, StartupOutput& output);
    public static Status GdiplusShutdown(IntPtr token);
    public static bool IsWindowVisible(IntPtr hwnd);
    private static IntPtr _LocalFree(IntPtr hMem);
    public static IntPtr MonitorFromWindow(IntPtr hwnd, UInt32 dwFlags);
    private static bool _PostMessage(IntPtr hWnd, WM Msg, IntPtr wParam, IntPtr lParam);
    public static void PostMessage(IntPtr hWnd, WM Msg, IntPtr wParam, IntPtr lParam);
    private static short _RegisterClassEx(WNDCLASSEX& lpwcx);
    public static short RegisterClassEx(WNDCLASSEX& lpwcx);
    private static UInt32 _RegisterWindowMessage(string lpString);
    public static WM RegisterWindowMessage(string lpString);
    private static IntPtr _SetActiveWindow(IntPtr hWnd);
    public static IntPtr SetActiveWindow(IntPtr hwnd);
    public static IntPtr SetClassLongPtr(IntPtr hwnd, GCLP nIndex, IntPtr dwNewLong);
    private static int SetClassLongPtr32(IntPtr hWnd, GCLP nIndex, int dwNewLong);
    private static IntPtr SetClassLongPtr64(IntPtr hWnd, GCLP nIndex, IntPtr dwNewLong);
    public static ErrorModes SetErrorMode(ErrorModes newMode);
    private static bool _SetProcessWorkingSetSize(IntPtr hProcess, IntPtr dwMinimiumWorkingSetSize, IntPtr dwMaximumWorkingSetSize);
    public static void SetProcessWorkingSetSize(IntPtr hProcess, int dwMinimumWorkingSetSize, int dwMaximumWorkingSetSize);
    public static IntPtr SetWindowLongPtr(IntPtr hwnd, GWL nIndex, IntPtr dwNewLong);
    private static int _SetWindowRgn(IntPtr hWnd, IntPtr hRgn, bool bRedraw);
    public static void SetWindowRgn(IntPtr hWnd, IntPtr hRgn, bool bRedraw);
    private static bool _SetWindowPos(IntPtr hWnd, IntPtr hWndInsertAfter, int x, int y, int cx, int cy, SWP uFlags);
    public static bool SetWindowPos(IntPtr hWnd, IntPtr hWndInsertAfter, int x, int y, int cx, int cy, SWP uFlags);
    public static Win32Error SHFileOperation(SHFILEOPSTRUCT& lpFileOp);
    public static bool ShowWindow(IntPtr hwnd, SW nCmdShow);
    private static bool _SystemParametersInfo_String(SPI uiAction, int uiParam, string pvParam, SPIF fWinIni);
    private static bool _SystemParametersInfo_NONCLIENTMETRICS(SPI uiAction, int uiParam, NONCLIENTMETRICS& pvParam, SPIF fWinIni);
    private static bool _SystemParametersInfo_HIGHCONTRAST(SPI uiAction, int uiParam, HIGHCONTRAST& pvParam, SPIF fWinIni);
    public static void SystemParametersInfo(SPI uiAction, int uiParam, string pvParam, SPIF fWinIni);
    public static NONCLIENTMETRICS SystemParameterInfo_GetNONCLIENTMETRICS();
    public static HIGHCONTRAST SystemParameterInfo_GetHIGHCONTRAST();
    public static UInt32 TrackPopupMenuEx(IntPtr hmenu, UInt32 fuFlags, int x, int y, IntPtr hwnd, IntPtr lptpm);
    private static IntPtr _SelectObject(SafeDC hdc, IntPtr hgdiobj);
    public static IntPtr SelectObject(SafeDC hdc, IntPtr hgdiobj);
    private static IntPtr _SelectObjectSafeHBITMAP(SafeDC hdc, SafeHBITMAP hgdiobj);
    public static IntPtr SelectObject(SafeDC hdc, SafeHBITMAP hgdiobj);
    public static int SendInput(int nInputs, INPUT& pInputs, int cbSize);
    public static IntPtr SendMessage(IntPtr hWnd, WM Msg, IntPtr wParam, IntPtr lParam);
    private static bool _UnregisterClassAtom(IntPtr lpClassName, IntPtr hInstance);
    private static bool _UnregisterClassName(string lpClassName, IntPtr hInstance);
    public static void UnregisterClass(short atom, IntPtr hinstance);
    public static void UnregisterClass(string lpClassName, IntPtr hInstance);
    private static bool _UpdateLayeredWindow(IntPtr hwnd, SafeDC hdcDst, POINT& pptDst, SIZE& psize, SafeDC hdcSrc, POINT& pptSrc, int crKey, BLENDFUNCTION& pblend, ULW dwFlags);
    private static bool _UpdateLayeredWindowIntPtr(IntPtr hwnd, IntPtr hdcDst, IntPtr pptDst, IntPtr psize, IntPtr hdcSrc, IntPtr pptSrc, int crKey, BLENDFUNCTION& pblend, ULW dwFlags);
    public static void UpdateLayeredWindow(IntPtr hwnd, SafeDC hdcDst, POINT& pptDst, SIZE& psize, SafeDC hdcSrc, POINT& pptSrc, int crKey, BLENDFUNCTION& pblend, ULW dwFlags);
    public static void UpdateLayeredWindow(IntPtr hwnd, int crKey, BLENDFUNCTION& pblend, ULW dwFlags);
    private static void _SHAddToRecentDocs_String(SHARD uFlags, string pv);
    private static void _SHAddToRecentDocs_ShellLink(SHARD uFlags, IShellLinkW pv);
    public static void SHAddToRecentDocs(string path);
    public static void SHAddToRecentDocs(IShellLinkW shellLink);
    private static HRESULT _DwmGetCompositionTimingInfo(IntPtr hwnd, DWM_TIMING_INFO& pTimingInfo);
    public static Nullable`1<DWM_TIMING_INFO> DwmGetCompositionTimingInfo(IntPtr hwnd);
    public static void DwmInvalidateIconicBitmaps(IntPtr hwnd);
    public static void DwmSetIconicThumbnail(IntPtr hwnd, IntPtr hbmp, DWM_SIT dwSITFlags);
    public static void DwmSetIconicLivePreviewBitmap(IntPtr hwnd, IntPtr hbmp, RefPOINT pptClient, DWM_SIT dwSITFlags);
    public static void SHGetItemFromDataObject(IDataObject pdtobj, DOGIF dwFlags, Guid& riid, Object& ppv);
    public static HRESULT SHCreateItemFromParsingName(string pszPath, IBindCtx pbc, Guid& riid, Object& ppv);
    public static bool Shell_NotifyIcon(NIM dwMessage, NOTIFYICONDATA lpdata);
    public static void SetCurrentProcessExplicitAppUserModelID(string AppID);
    public static HRESULT GetCurrentProcessExplicitAppUserModelID(String& AppID);
}
[FlagsAttribute]
internal enum Standard.NIF : Enum {
    public UInt32 value__;
    public static NIF MESSAGE;
    public static NIF ICON;
    public static NIF TIP;
    public static NIF STATE;
    public static NIF INFO;
    public static NIF GUID;
    public static NIF REALTIME;
    public static NIF SHOWTIP;
    public static NIF XP_MASK;
    public static NIF VISTA_MASK;
}
internal enum Standard.NIIF : Enum {
    public int value__;
    public static NIIF NONE;
    public static NIIF INFO;
    public static NIIF WARNING;
    public static NIIF ERROR;
    public static NIIF USER;
    public static NIIF NOSOUND;
    public static NIIF LARGE_ICON;
    public static NIIF NIIF_RESPECT_QUIET_TIME;
    public static NIIF XP_ICON_MASK;
}
internal enum Standard.NIM : Enum {
    public UInt32 value__;
    public static NIM ADD;
    public static NIM MODIFY;
    public static NIM DELETE;
    public static NIM SETFOCUS;
    public static NIM SETVERSION;
}
internal class Standard.NONCLIENTMETRICS : ValueType {
    public int cbSize;
    public int iBorderWidth;
    public int iScrollWidth;
    public int iScrollHeight;
    public int iCaptionWidth;
    public int iCaptionHeight;
    public LOGFONT lfCaptionFont;
    public int iSmCaptionWidth;
    public int iSmCaptionHeight;
    public LOGFONT lfSmCaptionFont;
    public int iMenuWidth;
    public int iMenuHeight;
    public LOGFONT lfMenuFont;
    public LOGFONT lfStatusFont;
    public LOGFONT lfMessageFont;
    public int iPaddedBorderWidth;
    public static NONCLIENTMETRICS VistaMetricsStruct { get; }
    public static NONCLIENTMETRICS XPMetricsStruct { get; }
    public static NONCLIENTMETRICS get_VistaMetricsStruct();
    public static NONCLIENTMETRICS get_XPMetricsStruct();
}
internal class Standard.NOTIFYICONDATA : object {
    public int cbSize;
    public IntPtr hWnd;
    public int uID;
    public NIF uFlags;
    public int uCallbackMessage;
    public IntPtr hIcon;
    public Char[] szTip;
    public UInt32 dwState;
    public UInt32 dwStateMask;
    public Char[] szInfo;
    public UInt32 uVersion;
    public Char[] szInfoTitle;
    public UInt32 dwInfoFlags;
    public Guid guidItem;
    private IntPtr hBalloonIcon;
}
internal enum Standard.OLECMDEXECOPT : Enum {
    public int value__;
    public static OLECMDEXECOPT DODEFAULT;
    public static OLECMDEXECOPT PROMPTUSER;
    public static OLECMDEXECOPT DONTPROMPTUSER;
    public static OLECMDEXECOPT SHOWHELP;
}
internal enum Standard.OLECMDF : Enum {
    public int value__;
    public static OLECMDF SUPPORTED;
    public static OLECMDF ENABLED;
    public static OLECMDF LATCHED;
    public static OLECMDF NINCHED;
    public static OLECMDF INVISIBLE;
    public static OLECMDF DEFHIDEONCTXTMENU;
}
internal enum Standard.OLECMDID : Enum {
    public int value__;
    public static OLECMDID OPEN;
    public static OLECMDID NEW;
    public static OLECMDID SAVE;
    public static OLECMDID SAVEAS;
    public static OLECMDID SAVECOPYAS;
    public static OLECMDID PRINT;
    public static OLECMDID PRINTPREVIEW;
    public static OLECMDID PAGESETUP;
    public static OLECMDID SPELL;
    public static OLECMDID PROPERTIES;
    public static OLECMDID CUT;
    public static OLECMDID COPY;
    public static OLECMDID PASTE;
    public static OLECMDID PASTESPECIAL;
    public static OLECMDID UNDO;
    public static OLECMDID REDO;
    public static OLECMDID SELECTALL;
    public static OLECMDID CLEARSELECTION;
    public static OLECMDID ZOOM;
    public static OLECMDID GETZOOMRANGE;
    public static OLECMDID UPDATECOMMANDS;
    public static OLECMDID REFRESH;
    public static OLECMDID STOP;
    public static OLECMDID HIDETOOLBARS;
    public static OLECMDID SETPROGRESSMAX;
    public static OLECMDID SETPROGRESSPOS;
    public static OLECMDID SETPROGRESSTEXT;
    public static OLECMDID SETTITLE;
    public static OLECMDID SETDOWNLOADSTATE;
    public static OLECMDID STOPDOWNLOAD;
    public static OLECMDID ONTOOLBARACTIVATED;
    public static OLECMDID FIND;
    public static OLECMDID DELETE;
    public static OLECMDID HTTPEQUIV;
    public static OLECMDID HTTPEQUIV_DONE;
    public static OLECMDID ENABLE_INTERACTION;
    public static OLECMDID ONUNLOAD;
    public static OLECMDID PROPERTYBAG2;
    public static OLECMDID PREREFRESH;
    public static OLECMDID SHOWSCRIPTERROR;
    public static OLECMDID SHOWMESSAGE;
    public static OLECMDID SHOWFIND;
    public static OLECMDID SHOWPAGESETUP;
    public static OLECMDID SHOWPRINT;
    public static OLECMDID CLOSE;
    public static OLECMDID ALLOWUILESSSAVEAS;
    public static OLECMDID DONTDOWNLOADCSS;
    public static OLECMDID UPDATEPAGESTATUS;
    public static OLECMDID PRINT2;
    public static OLECMDID PRINTPREVIEW2;
    public static OLECMDID SETPRINTTEMPLATE;
    public static OLECMDID GETPRINTTEMPLATE;
    public static OLECMDID PAGEACTIONBLOCKED;
    public static OLECMDID PAGEACTIONUIQUERY;
    public static OLECMDID FOCUSVIEWCONTROLS;
    public static OLECMDID FOCUSVIEWCONTROLSQUERY;
    public static OLECMDID SHOWPAGEACTIONMENU;
}
internal class Standard.PKEY : ValueType {
    private Guid _fmtid;
    private UInt32 _pid;
    public static PKEY Title;
    public static PKEY AppUserModel_ID;
    public static PKEY AppUserModel_IsDestListSeparator;
    public static PKEY AppUserModel_RelaunchCommand;
    public static PKEY AppUserModel_RelaunchDisplayNameResource;
    public static PKEY AppUserModel_RelaunchIconResource;
    public PKEY(Guid fmtid, UInt32 pid);
    private static PKEY();
}
internal class Standard.POINT : ValueType {
    public int x;
    public int y;
}
internal enum Standard.READYSTATE : Enum {
    public int value__;
    public static READYSTATE UNINITIALIZED;
    public static READYSTATE LOADING;
    public static READYSTATE LOADED;
    public static READYSTATE INTERACTIVE;
    public static READYSTATE COMPLETE;
}
internal class Standard.RECT : ValueType {
    private int _left;
    private int _top;
    private int _right;
    private int _bottom;
    public int Left { get; public set; }
    public int Right { get; public set; }
    public int Top { get; public set; }
    public int Bottom { get; public set; }
    public int Width { get; }
    public int Height { get; }
    public POINT Position { get; }
    public SIZE Size { get; }
    public void Offset(int dx, int dy);
    public int get_Left();
    public void set_Left(int value);
    public int get_Right();
    public void set_Right(int value);
    public int get_Top();
    public void set_Top(int value);
    public int get_Bottom();
    public void set_Bottom(int value);
    public int get_Width();
    public int get_Height();
    public POINT get_Position();
    public SIZE get_Size();
    public static RECT Union(RECT rect1, RECT rect2);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class Standard.RefPOINT : object {
    public int x;
    public int y;
}
internal class Standard.RefRECT : object {
    private int _left;
    private int _top;
    private int _right;
    private int _bottom;
    public int Width { get; }
    public int Height { get; }
    public int Left { get; public set; }
    public int Right { get; public set; }
    public int Top { get; public set; }
    public int Bottom { get; public set; }
    public RefRECT(int left, int top, int right, int bottom);
    public int get_Width();
    public int get_Height();
    public int get_Left();
    public void set_Left(int value);
    public int get_Right();
    public void set_Right(int value);
    public int get_Top();
    public void set_Top(int value);
    public int get_Bottom();
    public void set_Bottom(int value);
    public void Offset(int dx, int dy);
}
internal class Standard.RGBQUAD : ValueType {
    public byte rgbBlue;
    public byte rgbGreen;
    public byte rgbRed;
    public byte rgbReserved;
}
internal enum Standard.RGN : Enum {
    public int value__;
    public static RGN AND;
    public static RGN OR;
    public static RGN XOR;
    public static RGN DIFF;
    public static RGN COPY;
}
internal class Standard.SafeConnectionPointCookie : SafeHandleZeroOrMinusOneIsInvalid {
    private IConnectionPoint _cp;
    public SafeConnectionPointCookie(IConnectionPointContainer target, object sink, Guid eventId);
    public void Disconnect();
    [ReliabilityContractAttribute("3", "1")]
protected virtual bool ReleaseHandle();
}
internal class Standard.SafeDC : SafeHandleZeroOrMinusOneIsInvalid {
    private Nullable`1<IntPtr> _hwnd;
    private bool _created;
    unknown IntPtr Hwnd {public set; }
    public void set_Hwnd(IntPtr value);
    [ReliabilityContractAttribute("3", "1")]
protected virtual bool ReleaseHandle();
    public static SafeDC CreateDC(string deviceName);
    public static SafeDC CreateCompatibleDC(SafeDC hdc);
    public static SafeDC GetDC(IntPtr hwnd);
    public static SafeDC GetDesktop();
    public static SafeDC WrapDC(IntPtr hdc);
}
internal class Standard.SafeFindHandle : SafeHandleZeroOrMinusOneIsInvalid {
    protected virtual bool ReleaseHandle();
}
internal class Standard.SafeGdiplusStartupToken : SafeHandleZeroOrMinusOneIsInvalid {
    [ReliabilityContractAttribute("3", "1")]
protected virtual bool ReleaseHandle();
    public static SafeGdiplusStartupToken Startup();
}
internal class Standard.SafeHBITMAP : SafeHandleZeroOrMinusOneIsInvalid {
    [ReliabilityContractAttribute("3", "1")]
protected virtual bool ReleaseHandle();
}
internal enum Standard.SC : Enum {
    public int value__;
    public static SC SIZE;
    public static SC MOVE;
    public static SC MINIMIZE;
    public static SC MAXIMIZE;
    public static SC NEXTWINDOW;
    public static SC PREVWINDOW;
    public static SC CLOSE;
    public static SC VSCROLL;
    public static SC HSCROLL;
    public static SC MOUSEMENU;
    public static SC KEYMENU;
    public static SC ARRANGE;
    public static SC RESTORE;
    public static SC TASKLIST;
    public static SC SCREENSAVE;
    public static SC HOTKEY;
    public static SC DEFAULT;
    public static SC MONITORPOWER;
    public static SC CONTEXTHELP;
    public static SC SEPARATOR;
    public static SC F_ISSECURE;
    public static SC ICON;
    public static SC ZOOM;
}
[FlagsAttribute]
internal enum Standard.SFGAO : Enum {
    public UInt32 value__;
    public static SFGAO CANCOPY;
    public static SFGAO CANMOVE;
    public static SFGAO CANLINK;
    public static SFGAO STORAGE;
    public static SFGAO CANRENAME;
    public static SFGAO CANDELETE;
    public static SFGAO HASPROPSHEET;
    public static SFGAO DROPTARGET;
    public static SFGAO CAPABILITYMASK;
    public static SFGAO ENCRYPTED;
    public static SFGAO ISSLOW;
    public static SFGAO GHOSTED;
    public static SFGAO LINK;
    public static SFGAO SHARE;
    public static SFGAO READONLY;
    public static SFGAO HIDDEN;
    public static SFGAO DISPLAYATTRMASK;
    public static SFGAO FILESYSANCESTOR;
    public static SFGAO FOLDER;
    public static SFGAO FILESYSTEM;
    public static SFGAO HASSUBFOLDER;
    public static SFGAO CONTENTSMASK;
    public static SFGAO VALIDATE;
    public static SFGAO REMOVABLE;
    public static SFGAO COMPRESSED;
    public static SFGAO BROWSABLE;
    public static SFGAO NONENUMERATED;
    public static SFGAO NEWCONTENT;
    public static SFGAO CANMONIKER;
    public static SFGAO HASSTORAGE;
    public static SFGAO STREAM;
    public static SFGAO STORAGEANCESTOR;
    public static SFGAO STORAGECAPMASK;
    public static SFGAO PKEYSFGAOMASK;
}
internal enum Standard.SHARD : Enum {
    public int value__;
    public static SHARD PIDL;
    public static SHARD PATHA;
    public static SHARD PATHW;
    public static SHARD APPIDINFO;
    public static SHARD APPIDINFOIDLIST;
    public static SHARD LINK;
    public static SHARD APPIDINFOLINK;
}
internal class Standard.SHARDAPPIDINFO : object {
    private object psi;
    private string pszAppID;
}
internal class Standard.SHARDAPPIDINFOIDLIST : object {
    private IntPtr pidl;
    private string pszAppID;
}
internal class Standard.SHARDAPPIDINFOLINK : object {
    private IntPtr psl;
    private string pszAppID;
}
internal enum Standard.SHCONTF : Enum {
    public int value__;
    public static SHCONTF CHECKING_FOR_CHILDREN;
    public static SHCONTF FOLDERS;
    public static SHCONTF NONFOLDERS;
    public static SHCONTF INCLUDEHIDDEN;
    public static SHCONTF INIT_ON_FIRST_NEXT;
    public static SHCONTF NETPRINTERSRCH;
    public static SHCONTF SHAREABLE;
    public static SHCONTF STORAGE;
    public static SHCONTF NAVIGATION_ENUM;
    public static SHCONTF FASTITEMS;
    public static SHCONTF FLATLIST;
    public static SHCONTF ENABLE_ASYNC;
}
internal class Standard.SHFILEOPSTRUCT : ValueType {
    public IntPtr hwnd;
    public FO wFunc;
    public string pFrom;
    public string pTo;
    public FOF fFlags;
    public int fAnyOperationsAborted;
    public IntPtr hNameMappings;
    public string lpszProgressTitle;
}
[FlagsAttribute]
internal enum Standard.SHGDN : Enum {
    public int value__;
    public static SHGDN SHGDN_NORMAL;
    public static SHGDN SHGDN_INFOLDER;
    public static SHGDN SHGDN_FOREDITING;
    public static SHGDN SHGDN_FORADDRESSBAR;
    public static SHGDN SHGDN_FORPARSING;
}
internal enum Standard.SIATTRIBFLAGS : Enum {
    public int value__;
    public static SIATTRIBFLAGS AND;
    public static SIATTRIBFLAGS OR;
    public static SIATTRIBFLAGS APPCOMPAT;
}
internal enum Standard.SICHINT : Enum {
    public UInt32 value__;
    public static SICHINT DISPLAY;
    public static SICHINT ALLFIELDS;
    public static SICHINT CANONICAL;
    public static SICHINT TEST_FILESYSPATH_IF_NOT_EQUAL;
}
internal enum Standard.SIGDN : Enum {
    public UInt32 value__;
    public static SIGDN NORMALDISPLAY;
    public static SIGDN PARENTRELATIVEPARSING;
    public static SIGDN DESKTOPABSOLUTEPARSING;
    public static SIGDN PARENTRELATIVEEDITING;
    public static SIGDN DESKTOPABSOLUTEEDITING;
    public static SIGDN FILESYSPATH;
    public static SIGDN URL;
    public static SIGDN PARENTRELATIVEFORADDRESSBAR;
    public static SIGDN PARENTRELATIVE;
}
internal class Standard.SIZE : ValueType {
    public int cx;
    public int cy;
}
[FlagsAttribute]
internal enum Standard.SLGP : Enum {
    public int value__;
    public static SLGP SHORTPATH;
    public static SLGP UNCPRIORITY;
    public static SLGP RAWPATH;
}
internal enum Standard.SM : Enum {
    public int value__;
    public static SM CXSCREEN;
    public static SM CYSCREEN;
    public static SM CXVSCROLL;
    public static SM CYHSCROLL;
    public static SM CYCAPTION;
    public static SM CXBORDER;
    public static SM CYBORDER;
    public static SM CXFIXEDFRAME;
    public static SM CYFIXEDFRAME;
    public static SM CYVTHUMB;
    public static SM CXHTHUMB;
    public static SM CXICON;
    public static SM CYICON;
    public static SM CXCURSOR;
    public static SM CYCURSOR;
    public static SM CYMENU;
    public static SM CXFULLSCREEN;
    public static SM CYFULLSCREEN;
    public static SM CYKANJIWINDOW;
    public static SM MOUSEPRESENT;
    public static SM CYVSCROLL;
    public static SM CXHSCROLL;
    public static SM DEBUG;
    public static SM SWAPBUTTON;
    public static SM CXMIN;
    public static SM CYMIN;
    public static SM CXSIZE;
    public static SM CYSIZE;
    public static SM CXFRAME;
    public static SM CXSIZEFRAME;
    public static SM CYFRAME;
    public static SM CYSIZEFRAME;
    public static SM CXMINTRACK;
    public static SM CYMINTRACK;
    public static SM CXDOUBLECLK;
    public static SM CYDOUBLECLK;
    public static SM CXICONSPACING;
    public static SM CYICONSPACING;
    public static SM MENUDROPALIGNMENT;
    public static SM PENWINDOWS;
    public static SM DBCSENABLED;
    public static SM CMOUSEBUTTONS;
    public static SM SECURE;
    public static SM CXEDGE;
    public static SM CYEDGE;
    public static SM CXMINSPACING;
    public static SM CYMINSPACING;
    public static SM CXSMICON;
    public static SM CYSMICON;
    public static SM CYSMCAPTION;
    public static SM CXSMSIZE;
    public static SM CYSMSIZE;
    public static SM CXMENUSIZE;
    public static SM CYMENUSIZE;
    public static SM ARRANGE;
    public static SM CXMINIMIZED;
    public static SM CYMINIMIZED;
    public static SM CXMAXTRACK;
    public static SM CYMAXTRACK;
    public static SM CXMAXIMIZED;
    public static SM CYMAXIMIZED;
    public static SM NETWORK;
    public static SM CLEANBOOT;
    public static SM CXDRAG;
    public static SM CYDRAG;
    public static SM SHOWSOUNDS;
    public static SM CXMENUCHECK;
    public static SM CYMENUCHECK;
    public static SM SLOWMACHINE;
    public static SM MIDEASTENABLED;
    public static SM MOUSEWHEELPRESENT;
    public static SM XVIRTUALSCREEN;
    public static SM YVIRTUALSCREEN;
    public static SM CXVIRTUALSCREEN;
    public static SM CYVIRTUALSCREEN;
    public static SM CMONITORS;
    public static SM SAMEDISPLAYFORMAT;
    public static SM IMMENABLED;
    public static SM CXFOCUSBORDER;
    public static SM CYFOCUSBORDER;
    public static SM TABLETPC;
    public static SM MEDIACENTER;
    public static SM REMOTESESSION;
    public static SM REMOTECONTROL;
}
internal enum Standard.SPI : Enum {
    public int value__;
    public static SPI GETBEEP;
    public static SPI SETBEEP;
    public static SPI GETMOUSE;
    public static SPI SETMOUSE;
    public static SPI GETBORDER;
    public static SPI SETBORDER;
    public static SPI GETKEYBOARDSPEED;
    public static SPI SETKEYBOARDSPEED;
    public static SPI LANGDRIVER;
    public static SPI ICONHORIZONTALSPACING;
    public static SPI GETSCREENSAVETIMEOUT;
    public static SPI SETSCREENSAVETIMEOUT;
    public static SPI GETSCREENSAVEACTIVE;
    public static SPI SETSCREENSAVEACTIVE;
    public static SPI GETGRIDGRANULARITY;
    public static SPI SETGRIDGRANULARITY;
    public static SPI SETDESKWALLPAPER;
    public static SPI SETDESKPATTERN;
    public static SPI GETKEYBOARDDELAY;
    public static SPI SETKEYBOARDDELAY;
    public static SPI ICONVERTICALSPACING;
    public static SPI GETICONTITLEWRAP;
    public static SPI SETICONTITLEWRAP;
    public static SPI GETMENUDROPALIGNMENT;
    public static SPI SETMENUDROPALIGNMENT;
    public static SPI SETDOUBLECLKWIDTH;
    public static SPI SETDOUBLECLKHEIGHT;
    public static SPI GETICONTITLELOGFONT;
    public static SPI SETDOUBLECLICKTIME;
    public static SPI SETMOUSEBUTTONSWAP;
    public static SPI SETICONTITLELOGFONT;
    public static SPI GETFASTTASKSWITCH;
    public static SPI SETFASTTASKSWITCH;
    public static SPI SETDRAGFULLWINDOWS;
    public static SPI GETDRAGFULLWINDOWS;
    public static SPI GETNONCLIENTMETRICS;
    public static SPI SETNONCLIENTMETRICS;
    public static SPI GETMINIMIZEDMETRICS;
    public static SPI SETMINIMIZEDMETRICS;
    public static SPI GETICONMETRICS;
    public static SPI SETICONMETRICS;
    public static SPI SETWORKAREA;
    public static SPI GETWORKAREA;
    public static SPI SETPENWINDOWS;
    public static SPI GETHIGHCONTRAST;
    public static SPI SETHIGHCONTRAST;
    public static SPI GETKEYBOARDPREF;
    public static SPI SETKEYBOARDPREF;
    public static SPI GETSCREENREADER;
    public static SPI SETSCREENREADER;
    public static SPI GETANIMATION;
    public static SPI SETANIMATION;
    public static SPI GETFONTSMOOTHING;
    public static SPI SETFONTSMOOTHING;
    public static SPI SETDRAGWIDTH;
    public static SPI SETDRAGHEIGHT;
    public static SPI SETHANDHELD;
    public static SPI GETLOWPOWERTIMEOUT;
    public static SPI GETPOWEROFFTIMEOUT;
    public static SPI SETLOWPOWERTIMEOUT;
    public static SPI SETPOWEROFFTIMEOUT;
    public static SPI GETLOWPOWERACTIVE;
    public static SPI GETPOWEROFFACTIVE;
    public static SPI SETLOWPOWERACTIVE;
    public static SPI SETPOWEROFFACTIVE;
    public static SPI SETCURSORS;
    public static SPI SETICONS;
    public static SPI GETDEFAULTINPUTLANG;
    public static SPI SETDEFAULTINPUTLANG;
    public static SPI SETLANGTOGGLE;
    public static SPI GETWINDOWSEXTENSION;
    public static SPI SETMOUSETRAILS;
    public static SPI GETMOUSETRAILS;
    public static SPI SETSCREENSAVERRUNNING;
    public static SPI SCREENSAVERRUNNING;
    public static SPI GETFILTERKEYS;
    public static SPI SETFILTERKEYS;
    public static SPI GETTOGGLEKEYS;
    public static SPI SETTOGGLEKEYS;
    public static SPI GETMOUSEKEYS;
    public static SPI SETMOUSEKEYS;
    public static SPI GETSHOWSOUNDS;
    public static SPI SETSHOWSOUNDS;
    public static SPI GETSTICKYKEYS;
    public static SPI SETSTICKYKEYS;
    public static SPI GETACCESSTIMEOUT;
    public static SPI SETACCESSTIMEOUT;
    public static SPI GETSERIALKEYS;
    public static SPI SETSERIALKEYS;
    public static SPI GETSOUNDSENTRY;
    public static SPI SETSOUNDSENTRY;
    public static SPI GETSNAPTODEFBUTTON;
    public static SPI SETSNAPTODEFBUTTON;
    public static SPI GETMOUSEHOVERWIDTH;
    public static SPI SETMOUSEHOVERWIDTH;
    public static SPI GETMOUSEHOVERHEIGHT;
    public static SPI SETMOUSEHOVERHEIGHT;
    public static SPI GETMOUSEHOVERTIME;
    public static SPI SETMOUSEHOVERTIME;
    public static SPI GETWHEELSCROLLLINES;
    public static SPI SETWHEELSCROLLLINES;
    public static SPI GETMENUSHOWDELAY;
    public static SPI SETMENUSHOWDELAY;
    public static SPI GETWHEELSCROLLCHARS;
    public static SPI SETWHEELSCROLLCHARS;
    public static SPI GETSHOWIMEUI;
    public static SPI SETSHOWIMEUI;
    public static SPI GETMOUSESPEED;
    public static SPI SETMOUSESPEED;
    public static SPI GETSCREENSAVERRUNNING;
    public static SPI GETDESKWALLPAPER;
    public static SPI GETAUDIODESCRIPTION;
    public static SPI SETAUDIODESCRIPTION;
    public static SPI GETSCREENSAVESECURE;
    public static SPI SETSCREENSAVESECURE;
    public static SPI GETHUNGAPPTIMEOUT;
    public static SPI SETHUNGAPPTIMEOUT;
    public static SPI GETWAITTOKILLTIMEOUT;
    public static SPI SETWAITTOKILLTIMEOUT;
    public static SPI GETWAITTOKILLSERVICETIMEOUT;
    public static SPI SETWAITTOKILLSERVICETIMEOUT;
    public static SPI GETMOUSEDOCKTHRESHOLD;
    public static SPI SETMOUSEDOCKTHRESHOLD;
    public static SPI GETPENDOCKTHRESHOLD;
    public static SPI SETPENDOCKTHRESHOLD;
    public static SPI GETWINARRANGING;
    public static SPI SETWINARRANGING;
    public static SPI GETMOUSEDRAGOUTTHRESHOLD;
    public static SPI SETMOUSEDRAGOUTTHRESHOLD;
    public static SPI GETPENDRAGOUTTHRESHOLD;
    public static SPI SETPENDRAGOUTTHRESHOLD;
    public static SPI GETMOUSESIDEMOVETHRESHOLD;
    public static SPI SETMOUSESIDEMOVETHRESHOLD;
    public static SPI GETPENSIDEMOVETHRESHOLD;
    public static SPI SETPENSIDEMOVETHRESHOLD;
    public static SPI GETDRAGFROMMAXIMIZE;
    public static SPI SETDRAGFROMMAXIMIZE;
    public static SPI GETSNAPSIZING;
    public static SPI SETSNAPSIZING;
    public static SPI GETDOCKMOVING;
    public static SPI SETDOCKMOVING;
    public static SPI GETACTIVEWINDOWTRACKING;
    public static SPI SETACTIVEWINDOWTRACKING;
    public static SPI GETMENUANIMATION;
    public static SPI SETMENUANIMATION;
    public static SPI GETCOMBOBOXANIMATION;
    public static SPI SETCOMBOBOXANIMATION;
    public static SPI GETLISTBOXSMOOTHSCROLLING;
    public static SPI SETLISTBOXSMOOTHSCROLLING;
    public static SPI GETGRADIENTCAPTIONS;
    public static SPI SETGRADIENTCAPTIONS;
    public static SPI GETKEYBOARDCUES;
    public static SPI SETKEYBOARDCUES;
    public static SPI GETMENUUNDERLINES;
    public static SPI SETMENUUNDERLINES;
    public static SPI GETACTIVEWNDTRKZORDER;
    public static SPI SETACTIVEWNDTRKZORDER;
    public static SPI GETHOTTRACKING;
    public static SPI SETHOTTRACKING;
    public static SPI GETMENUFADE;
    public static SPI SETMENUFADE;
    public static SPI GETSELECTIONFADE;
    public static SPI SETSELECTIONFADE;
    public static SPI GETTOOLTIPANIMATION;
    public static SPI SETTOOLTIPANIMATION;
    public static SPI GETTOOLTIPFADE;
    public static SPI SETTOOLTIPFADE;
    public static SPI GETCURSORSHADOW;
    public static SPI SETCURSORSHADOW;
    public static SPI GETMOUSESONAR;
    public static SPI SETMOUSESONAR;
    public static SPI GETMOUSECLICKLOCK;
    public static SPI SETMOUSECLICKLOCK;
    public static SPI GETMOUSEVANISH;
    public static SPI SETMOUSEVANISH;
    public static SPI GETFLATMENU;
    public static SPI SETFLATMENU;
    public static SPI GETDROPSHADOW;
    public static SPI SETDROPSHADOW;
    public static SPI GETBLOCKSENDINPUTRESETS;
    public static SPI SETBLOCKSENDINPUTRESETS;
    public static SPI GETUIEFFECTS;
    public static SPI SETUIEFFECTS;
    public static SPI GETDISABLEOVERLAPPEDCONTENT;
    public static SPI SETDISABLEOVERLAPPEDCONTENT;
    public static SPI GETCLIENTAREAANIMATION;
    public static SPI SETCLIENTAREAANIMATION;
    public static SPI GETCLEARTYPE;
    public static SPI SETCLEARTYPE;
    public static SPI GETSPEECHRECOGNITION;
    public static SPI SETSPEECHRECOGNITION;
    public static SPI GETFOREGROUNDLOCKTIMEOUT;
    public static SPI SETFOREGROUNDLOCKTIMEOUT;
    public static SPI GETACTIVEWNDTRKTIMEOUT;
    public static SPI SETACTIVEWNDTRKTIMEOUT;
    public static SPI GETFOREGROUNDFLASHCOUNT;
    public static SPI SETFOREGROUNDFLASHCOUNT;
    public static SPI GETCARETWIDTH;
    public static SPI SETCARETWIDTH;
    public static SPI GETMOUSECLICKLOCKTIME;
    public static SPI SETMOUSECLICKLOCKTIME;
    public static SPI GETFONTSMOOTHINGTYPE;
    public static SPI SETFONTSMOOTHINGTYPE;
    public static SPI GETFONTSMOOTHINGCONTRAST;
    public static SPI SETFONTSMOOTHINGCONTRAST;
    public static SPI GETFOCUSBORDERWIDTH;
    public static SPI SETFOCUSBORDERWIDTH;
    public static SPI GETFOCUSBORDERHEIGHT;
    public static SPI SETFOCUSBORDERHEIGHT;
    public static SPI GETFONTSMOOTHINGORIENTATION;
    public static SPI SETFONTSMOOTHINGORIENTATION;
    public static SPI GETMINIMUMHITRADIUS;
    public static SPI SETMINIMUMHITRADIUS;
    public static SPI GETMESSAGEDURATION;
    public static SPI SETMESSAGEDURATION;
}
[FlagsAttribute]
internal enum Standard.SPIF : Enum {
    public int value__;
    public static SPIF None;
    public static SPIF UPDATEINIFILE;
    public static SPIF SENDCHANGE;
    public static SPIF SENDWININICHANGE;
}
internal class Standard.StartupInput : object {
    public int GdiplusVersion;
    public IntPtr DebugEventCallback;
    public bool SuppressBackgroundThread;
    public bool SuppressExternalCodecs;
}
internal class Standard.StartupOutput : ValueType {
    public IntPtr hook;
    public IntPtr unhook;
}
[FlagsAttribute]
internal enum Standard.STATE_SYSTEM : Enum {
    public int value__;
    public static STATE_SYSTEM UNAVAILABLE;
    public static STATE_SYSTEM SELECTED;
    public static STATE_SYSTEM FOCUSED;
    public static STATE_SYSTEM PRESSED;
    public static STATE_SYSTEM CHECKED;
    public static STATE_SYSTEM MIXED;
    public static STATE_SYSTEM INDETERMINATE;
    public static STATE_SYSTEM READONLY;
    public static STATE_SYSTEM HOTTRACKED;
    public static STATE_SYSTEM DEFAULT;
    public static STATE_SYSTEM EXPANDED;
    public static STATE_SYSTEM COLLAPSED;
    public static STATE_SYSTEM BUSY;
    public static STATE_SYSTEM FLOATING;
    public static STATE_SYSTEM MARQUEED;
    public static STATE_SYSTEM ANIMATED;
    public static STATE_SYSTEM INVISIBLE;
    public static STATE_SYSTEM OFFSCREEN;
    public static STATE_SYSTEM SIZEABLE;
    public static STATE_SYSTEM MOVEABLE;
    public static STATE_SYSTEM SELFVOICING;
    public static STATE_SYSTEM FOCUSABLE;
    public static STATE_SYSTEM SELECTABLE;
    public static STATE_SYSTEM LINKED;
    public static STATE_SYSTEM TRAVERSED;
    public static STATE_SYSTEM MULTISELECTABLE;
    public static STATE_SYSTEM EXTSELECTABLE;
    public static STATE_SYSTEM ALERT_LOW;
    public static STATE_SYSTEM ALERT_MEDIUM;
    public static STATE_SYSTEM ALERT_HIGH;
    public static STATE_SYSTEM PROTECTED;
    public static STATE_SYSTEM VALID;
}
internal enum Standard.Status : Enum {
    public int value__;
    public static Status Ok;
    public static Status GenericError;
    public static Status InvalidParameter;
    public static Status OutOfMemory;
    public static Status ObjectBusy;
    public static Status InsufficientBuffer;
    public static Status NotImplemented;
    public static Status Win32Error;
    public static Status WrongState;
    public static Status Aborted;
    public static Status FileNotFound;
    public static Status ValueOverflow;
    public static Status AccessDenied;
    public static Status UnknownImageFormat;
    public static Status FontFamilyNotFound;
    public static Status FontStyleNotFound;
    public static Status NotTrueTypeFont;
    public static Status UnsupportedGdiplusVersion;
    public static Status GdiplusNotInitialized;
    public static Status PropertyNotFound;
    public static Status PropertyNotSupported;
    public static Status ProfileNotFound;
}
internal enum Standard.StockObject : Enum {
    public int value__;
    public static StockObject WHITE_BRUSH;
    public static StockObject LTGRAY_BRUSH;
    public static StockObject GRAY_BRUSH;
    public static StockObject DKGRAY_BRUSH;
    public static StockObject BLACK_BRUSH;
    public static StockObject NULL_BRUSH;
    public static StockObject HOLLOW_BRUSH;
    public static StockObject WHITE_PEN;
    public static StockObject BLACK_PEN;
    public static StockObject NULL_PEN;
    public static StockObject SYSTEM_FONT;
    public static StockObject DEFAULT_PALETTE;
}
[FlagsAttribute]
internal enum Standard.STPF : Enum {
    public int value__;
    public static STPF NONE;
    public static STPF USEAPPTHUMBNAILALWAYS;
    public static STPF USEAPPTHUMBNAILWHENACTIVE;
    public static STPF USEAPPPEEKALWAYS;
    public static STPF USEAPPPEEKWHENACTIVE;
}
internal static class Standard.STR_GPS : object {
    public static string HANDLERPROPERTIESONLY;
    public static string FASTPROPERTIESONLY;
    public static string OPENSLOWITEM;
    public static string DELAYCREATION;
    public static string BESTEFFORT;
    public static string NO_OPLOCK;
}
internal enum Standard.SW : Enum {
    public int value__;
    public static SW HIDE;
    public static SW SHOWNORMAL;
    public static SW NORMAL;
    public static SW SHOWMINIMIZED;
    public static SW SHOWMAXIMIZED;
    public static SW MAXIMIZE;
    public static SW SHOWNOACTIVATE;
    public static SW SHOW;
    public static SW MINIMIZE;
    public static SW SHOWMINNOACTIVE;
    public static SW SHOWNA;
    public static SW RESTORE;
    public static SW SHOWDEFAULT;
    public static SW FORCEMINIMIZE;
}
[FlagsAttribute]
internal enum Standard.SWP : Enum {
    public int value__;
    public static SWP ASYNCWINDOWPOS;
    public static SWP DEFERERASE;
    public static SWP DRAWFRAME;
    public static SWP FRAMECHANGED;
    public static SWP HIDEWINDOW;
    public static SWP NOACTIVATE;
    public static SWP NOCOPYBITS;
    public static SWP NOMOVE;
    public static SWP NOOWNERZORDER;
    public static SWP NOREDRAW;
    public static SWP NOREPOSITION;
    public static SWP NOSENDCHANGING;
    public static SWP NOSIZE;
    public static SWP NOZORDER;
    public static SWP SHOWWINDOW;
}
internal enum Standard.TBPF : Enum {
    public int value__;
    public static TBPF NOPROGRESS;
    public static TBPF INDETERMINATE;
    public static TBPF NORMAL;
    public static TBPF ERROR;
    public static TBPF PAUSED;
}
[FlagsAttribute]
internal enum Standard.THB : Enum {
    public UInt32 value__;
    public static THB BITMAP;
    public static THB ICON;
    public static THB TOOLTIP;
    public static THB FLAGS;
}
[FlagsAttribute]
internal enum Standard.THBF : Enum {
    public UInt32 value__;
    public static THBF ENABLED;
    public static THBF DISABLED;
    public static THBF DISMISSONCLICK;
    public static THBF NOBACKGROUND;
    public static THBF HIDDEN;
    public static THBF NONINTERACTIVE;
}
internal class Standard.THUMBBUTTON : ValueType {
    public static int THBN_CLICKED;
    public THB dwMask;
    public UInt32 iId;
    public UInt32 iBitmap;
    public IntPtr hIcon;
    public string szTip;
    public THBF dwFlags;
}
internal class Standard.TITLEBARINFO : ValueType {
    public int cbSize;
    public RECT rcTitleBar;
    public STATE_SYSTEM rgstate_TitleBar;
    public STATE_SYSTEM rgstate_Reserved;
    public STATE_SYSTEM rgstate_MinimizeButton;
    public STATE_SYSTEM rgstate_MaximizeButton;
    public STATE_SYSTEM rgstate_HelpButton;
    public STATE_SYSTEM rgstate_CloseButton;
}
internal class Standard.TITLEBARINFOEX : ValueType {
    public int cbSize;
    public RECT rcTitleBar;
    public STATE_SYSTEM rgstate_TitleBar;
    public STATE_SYSTEM rgstate_Reserved;
    public STATE_SYSTEM rgstate_MinimizeButton;
    public STATE_SYSTEM rgstate_MaximizeButton;
    public STATE_SYSTEM rgstate_HelpButton;
    public STATE_SYSTEM rgstate_CloseButton;
    public RECT rgrect_TitleBar;
    public RECT rgrect_Reserved;
    public RECT rgrect_MinimizeButton;
    public RECT rgrect_MaximizeButton;
    public RECT rgrect_HelpButton;
    public RECT rgrect_CloseButton;
}
internal enum Standard.ULW : Enum {
    public int value__;
    public static ULW ALPHA;
    public static ULW COLORKEY;
    public static ULW OPAQUE;
}
internal class Standard.UNSIGNED_RATIO : ValueType {
    public UInt32 uiNumerator;
    public UInt32 uiDenominator;
}
internal static class Standard.Utility : object {
    private static Version _osVersion;
    private static Version _presentationFrameworkVersion;
    private static int s_bitDepth;
    public static bool IsOSVistaOrNewer { get; }
    public static bool IsOSWindows7OrNewer { get; }
    public static bool IsPresentationFrameworkVersionLessThan4 { get; }
    private static Utility();
    public static Color ColorFromArgbDword(UInt32 color);
    public static int GET_X_LPARAM(IntPtr lParam);
    public static int GET_Y_LPARAM(IntPtr lParam);
    public static int HIWORD(int i);
    public static int LOWORD(int i);
    public static bool IsFlagSet(int value, int mask);
    public static bool IsFlagSet(UInt32 value, UInt32 mask);
    public static bool IsFlagSet(long value, long mask);
    public static bool IsFlagSet(ulong value, ulong mask);
    public static bool get_IsOSVistaOrNewer();
    public static bool get_IsOSWindows7OrNewer();
    public static bool get_IsPresentationFrameworkVersionLessThan4();
    public static BitmapFrame GetBestMatch(IList`1<BitmapFrame> frames, int width, int height);
    private static int _MatchImage(BitmapFrame frame, int bitDepth, int width, int height, int bpp);
    private static int _WeightedAbs(int valueHave, int valueWant, bool fPunish);
    private static BitmapFrame _GetBestMatch(IList`1<BitmapFrame> frames, int bitDepth, int width, int height);
    private static int _GetBitDepth();
    public static void SafeDeleteObject(IntPtr& gdiObject);
    public static void SafeDestroyWindow(IntPtr& hwnd);
    public static void SafeRelease(T& comObject);
    public static void AddDependencyPropertyChangeListener(object component, DependencyProperty property, EventHandler listener);
    public static void RemoveDependencyPropertyChangeListener(object component, DependencyProperty property, EventHandler listener);
    public static bool IsThicknessNonNegative(Thickness thickness);
    public static bool IsCornerRadiusValid(CornerRadius cornerRadius);
    public static bool IsDoubleFiniteAndNonNegative(double d);
}
internal static class Standard.Verify : object {
    [DebuggerStepThroughAttribute]
public static void IsApartmentState(ApartmentState requiredState, string message);
    [DebuggerStepThroughAttribute]
public static void IsNeitherNullNorEmpty(string value, string name);
    [DebuggerStepThroughAttribute]
public static void IsNeitherNullNorWhitespace(string value, string name);
    [DebuggerStepThroughAttribute]
public static void IsNotDefault(T obj, string name);
    [DebuggerStepThroughAttribute]
public static void IsNotNull(T obj, string name);
    [DebuggerStepThroughAttribute]
public static void IsNull(T obj, string name);
    [DebuggerStepThroughAttribute]
public static void PropertyIsNotNull(T obj, string name);
    [DebuggerStepThroughAttribute]
public static void PropertyIsNull(T obj, string name);
    [DebuggerStepThroughAttribute]
public static void IsTrue(bool statement, string name);
    [DebuggerStepThroughAttribute]
public static void IsTrue(bool statement, string name, string message);
    [DebuggerStepThroughAttribute]
public static void AreEqual(T expected, T actual, string parameterName, string message);
    [DebuggerStepThroughAttribute]
public static void AreNotEqual(T notExpected, T actual, string parameterName, string message);
    [DebuggerStepThroughAttribute]
public static void UriIsAbsolute(Uri uri, string parameterName);
    [DebuggerStepThroughAttribute]
public static void BoundedInteger(int lowerBoundInclusive, int value, int upperBoundExclusive, string parameterName);
    [DebuggerStepThroughAttribute]
public static void BoundedDoubleInc(double lowerBoundInclusive, double value, double upperBoundInclusive, string message, string parameter);
    [DebuggerStepThroughAttribute]
public static void TypeSupportsInterface(Type type, Type interfaceType, string parameterName);
    [DebuggerStepThroughAttribute]
public static void FileExists(string filePath, string parameterName);
    [DebuggerStepThroughAttribute]
internal static void ImplementsInterface(object parameter, Type interfaceType, string parameterName);
}
[BestFitMappingAttribute("False")]
internal class Standard.WIN32_FIND_DATAW : object {
    public FileAttributes dwFileAttributes;
    public FILETIME ftCreationTime;
    public FILETIME ftLastAccessTime;
    public FILETIME ftLastWriteTime;
    public int nFileSizeHigh;
    public int nFileSizeLow;
    public int dwReserved0;
    public int dwReserved1;
    public string cFileName;
    public string cAlternateFileName;
}
internal class Standard.Win32Error : ValueType {
    private int _value;
    public static Win32Error ERROR_SUCCESS;
    public static Win32Error ERROR_INVALID_FUNCTION;
    public static Win32Error ERROR_FILE_NOT_FOUND;
    public static Win32Error ERROR_PATH_NOT_FOUND;
    public static Win32Error ERROR_TOO_MANY_OPEN_FILES;
    public static Win32Error ERROR_ACCESS_DENIED;
    public static Win32Error ERROR_INVALID_HANDLE;
    public static Win32Error ERROR_OUTOFMEMORY;
    public static Win32Error ERROR_NO_MORE_FILES;
    public static Win32Error ERROR_SHARING_VIOLATION;
    public static Win32Error ERROR_INVALID_PARAMETER;
    public static Win32Error ERROR_INSUFFICIENT_BUFFER;
    public static Win32Error ERROR_NESTING_NOT_ALLOWED;
    public static Win32Error ERROR_KEY_DELETED;
    public static Win32Error ERROR_NOT_FOUND;
    public static Win32Error ERROR_NO_MATCH;
    public static Win32Error ERROR_BAD_DEVICE;
    public static Win32Error ERROR_CANCELLED;
    public static Win32Error ERROR_CLASS_ALREADY_EXISTS;
    public static Win32Error ERROR_INVALID_DATATYPE;
    public Win32Error(int i);
    private static Win32Error();
    public static HRESULT op_Explicit(Win32Error error);
    public HRESULT ToHRESULT();
    public static Win32Error GetLastError();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(Win32Error errLeft, Win32Error errRight);
    public static bool op_Inequality(Win32Error errLeft, Win32Error errRight);
}
internal static class Standard.Win32Value : object {
    public static UInt32 MAX_PATH;
    public static UInt32 INFOTIPSIZE;
    public static UInt32 TRUE;
    public static UInt32 FALSE;
    public static UInt32 sizeof_WCHAR;
    public static UInt32 sizeof_CHAR;
    public static UInt32 sizeof_BOOL;
}
internal class Standard.WINDOWPLACEMENT : object {
    public int length;
    public int flags;
    public SW showCmd;
    public POINT ptMinPosition;
    public POINT ptMaxPosition;
    public RECT rcNormalPosition;
}
internal class Standard.WINDOWPOS : ValueType {
    public IntPtr hwnd;
    public IntPtr hwndInsertAfter;
    public int x;
    public int y;
    public int cx;
    public int cy;
    public int flags;
}
internal enum Standard.WINDOWTHEMEATTRIBUTETYPE : Enum {
    public UInt32 value__;
    public static WINDOWTHEMEATTRIBUTETYPE WTA_NONCLIENT;
}
internal enum Standard.WM : Enum {
    public int value__;
    public static WM NULL;
    public static WM CREATE;
    public static WM DESTROY;
    public static WM MOVE;
    public static WM SIZE;
    public static WM ACTIVATE;
    public static WM SETFOCUS;
    public static WM KILLFOCUS;
    public static WM ENABLE;
    public static WM SETREDRAW;
    public static WM SETTEXT;
    public static WM GETTEXT;
    public static WM GETTEXTLENGTH;
    public static WM PAINT;
    public static WM CLOSE;
    public static WM QUERYENDSESSION;
    public static WM QUIT;
    public static WM QUERYOPEN;
    public static WM ERASEBKGND;
    public static WM SYSCOLORCHANGE;
    public static WM SHOWWINDOW;
    public static WM CTLCOLOR;
    public static WM WININICHANGE;
    public static WM SETTINGCHANGE;
    public static WM ACTIVATEAPP;
    public static WM SETCURSOR;
    public static WM MOUSEACTIVATE;
    public static WM CHILDACTIVATE;
    public static WM QUEUESYNC;
    public static WM GETMINMAXINFO;
    public static WM WINDOWPOSCHANGING;
    public static WM WINDOWPOSCHANGED;
    public static WM CONTEXTMENU;
    public static WM STYLECHANGING;
    public static WM STYLECHANGED;
    public static WM DISPLAYCHANGE;
    public static WM GETICON;
    public static WM SETICON;
    public static WM NCCREATE;
    public static WM NCDESTROY;
    public static WM NCCALCSIZE;
    public static WM NCHITTEST;
    public static WM NCPAINT;
    public static WM NCACTIVATE;
    public static WM GETDLGCODE;
    public static WM SYNCPAINT;
    public static WM NCMOUSEMOVE;
    public static WM NCLBUTTONDOWN;
    public static WM NCLBUTTONUP;
    public static WM NCLBUTTONDBLCLK;
    public static WM NCRBUTTONDOWN;
    public static WM NCRBUTTONUP;
    public static WM NCRBUTTONDBLCLK;
    public static WM NCMBUTTONDOWN;
    public static WM NCMBUTTONUP;
    public static WM NCMBUTTONDBLCLK;
    public static WM SYSKEYDOWN;
    public static WM SYSKEYUP;
    public static WM SYSCHAR;
    public static WM SYSDEADCHAR;
    public static WM COMMAND;
    public static WM SYSCOMMAND;
    public static WM MOUSEMOVE;
    public static WM LBUTTONDOWN;
    public static WM LBUTTONUP;
    public static WM LBUTTONDBLCLK;
    public static WM RBUTTONDOWN;
    public static WM RBUTTONUP;
    public static WM RBUTTONDBLCLK;
    public static WM MBUTTONDOWN;
    public static WM MBUTTONUP;
    public static WM MBUTTONDBLCLK;
    public static WM MOUSEWHEEL;
    public static WM XBUTTONDOWN;
    public static WM XBUTTONUP;
    public static WM XBUTTONDBLCLK;
    public static WM MOUSEHWHEEL;
    public static WM PARENTNOTIFY;
    public static WM CAPTURECHANGED;
    public static WM POWERBROADCAST;
    public static WM DEVICECHANGE;
    public static WM ENTERSIZEMOVE;
    public static WM EXITSIZEMOVE;
    public static WM IME_SETCONTEXT;
    public static WM IME_NOTIFY;
    public static WM IME_CONTROL;
    public static WM IME_COMPOSITIONFULL;
    public static WM IME_SELECT;
    public static WM IME_CHAR;
    public static WM IME_REQUEST;
    public static WM IME_KEYDOWN;
    public static WM IME_KEYUP;
    public static WM NCMOUSELEAVE;
    public static WM TABLET_DEFBASE;
    public static WM TABLET_ADDED;
    public static WM TABLET_DELETED;
    public static WM TABLET_FLICK;
    public static WM TABLET_QUERYSYSTEMGESTURESTATUS;
    public static WM CUT;
    public static WM COPY;
    public static WM PASTE;
    public static WM CLEAR;
    public static WM UNDO;
    public static WM RENDERFORMAT;
    public static WM RENDERALLFORMATS;
    public static WM DESTROYCLIPBOARD;
    public static WM DRAWCLIPBOARD;
    public static WM PAINTCLIPBOARD;
    public static WM VSCROLLCLIPBOARD;
    public static WM SIZECLIPBOARD;
    public static WM ASKCBFORMATNAME;
    public static WM CHANGECBCHAIN;
    public static WM HSCROLLCLIPBOARD;
    public static WM QUERYNEWPALETTE;
    public static WM PALETTEISCHANGING;
    public static WM PALETTECHANGED;
    public static WM HOTKEY;
    public static WM PRINT;
    public static WM PRINTCLIENT;
    public static WM APPCOMMAND;
    public static WM THEMECHANGED;
    public static WM DWMCOMPOSITIONCHANGED;
    public static WM DWMNCRENDERINGCHANGED;
    public static WM DWMCOLORIZATIONCOLORCHANGED;
    public static WM DWMWINDOWMAXIMIZEDCHANGE;
    public static WM GETTITLEBARINFOEX;
    public static WM DWMSENDICONICTHUMBNAIL;
    public static WM DWMSENDICONICLIVEPREVIEWBITMAP;
    public static WM USER;
    public static WM TRAYMOUSEMESSAGE;
    public static WM APP;
}
internal class Standard.WNDCLASSEX : ValueType {
    public int cbSize;
    public CS style;
    public WndProc lpfnWndProc;
    public int cbClsExtra;
    public int cbWndExtra;
    public IntPtr hInstance;
    public IntPtr hIcon;
    public IntPtr hCursor;
    public IntPtr hbrBackground;
    public string lpszMenuName;
    public string lpszClassName;
    public IntPtr hIconSm;
}
internal class Standard.WndProc : MulticastDelegate {
    public WndProc(object object, IntPtr method);
    public virtual IntPtr Invoke(IntPtr hwnd, WM uMsg, IntPtr wParam, IntPtr lParam);
    public virtual IAsyncResult BeginInvoke(IntPtr hwnd, WM uMsg, IntPtr wParam, IntPtr lParam, AsyncCallback callback, object object);
    public virtual IntPtr EndInvoke(IAsyncResult result);
}
internal class Standard.WndProcHook : MulticastDelegate {
    public WndProcHook(object object, IntPtr method);
    public virtual IntPtr Invoke(IntPtr hwnd, WM uMsg, IntPtr wParam, IntPtr lParam, Boolean& handled);
    public virtual IAsyncResult BeginInvoke(IntPtr hwnd, WM uMsg, IntPtr wParam, IntPtr lParam, Boolean& handled, AsyncCallback callback, object object);
    public virtual IntPtr EndInvoke(Boolean& handled, IAsyncResult result);
}
[FlagsAttribute]
internal enum Standard.WS : Enum {
    public UInt32 value__;
    public static WS OVERLAPPED;
    public static WS POPUP;
    public static WS CHILD;
    public static WS MINIMIZE;
    public static WS VISIBLE;
    public static WS DISABLED;
    public static WS CLIPSIBLINGS;
    public static WS CLIPCHILDREN;
    public static WS MAXIMIZE;
    public static WS BORDER;
    public static WS DLGFRAME;
    public static WS VSCROLL;
    public static WS HSCROLL;
    public static WS SYSMENU;
    public static WS THICKFRAME;
    public static WS GROUP;
    public static WS TABSTOP;
    public static WS MINIMIZEBOX;
    public static WS MAXIMIZEBOX;
    public static WS CAPTION;
    public static WS TILED;
    public static WS ICONIC;
    public static WS SIZEBOX;
    public static WS TILEDWINDOW;
    public static WS OVERLAPPEDWINDOW;
    public static WS POPUPWINDOW;
    public static WS CHILDWINDOW;
}
[FlagsAttribute]
internal enum Standard.WS_EX : Enum {
    public UInt32 value__;
    public static WS_EX None;
    public static WS_EX DLGMODALFRAME;
    public static WS_EX NOPARENTNOTIFY;
    public static WS_EX TOPMOST;
    public static WS_EX ACCEPTFILES;
    public static WS_EX TRANSPARENT;
    public static WS_EX MDICHILD;
    public static WS_EX TOOLWINDOW;
    public static WS_EX WINDOWEDGE;
    public static WS_EX CLIENTEDGE;
    public static WS_EX CONTEXTHELP;
    public static WS_EX RIGHT;
    public static WS_EX LEFT;
    public static WS_EX RTLREADING;
    public static WS_EX LTRREADING;
    public static WS_EX LEFTSCROLLBAR;
    public static WS_EX RIGHTSCROLLBAR;
    public static WS_EX CONTROLPARENT;
    public static WS_EX STATICEDGE;
    public static WS_EX APPWINDOW;
    public static WS_EX LAYERED;
    public static WS_EX NOINHERITLAYOUT;
    public static WS_EX LAYOUTRTL;
    public static WS_EX COMPOSITED;
    public static WS_EX NOACTIVATE;
    public static WS_EX OVERLAPPEDWINDOW;
    public static WS_EX PALETTEWINDOW;
}
internal class Standard.WTA_OPTIONS : ValueType {
    public static UInt32 Size;
    public WTNCA dwFlags;
    public WTNCA dwMask;
}
[FlagsAttribute]
internal enum Standard.WTNCA : Enum {
    public UInt32 value__;
    public static WTNCA NODRAWCAPTION;
    public static WTNCA NODRAWICON;
    public static WTNCA NOSYSMENU;
    public static WTNCA NOMIRRORHELP;
    public static WTNCA VALIDBITS;
}
internal enum Standard.WVR : Enum {
    public int value__;
    public static WVR ALIGNTOP;
    public static WVR ALIGNLEFT;
    public static WVR ALIGNBOTTOM;
    public static WVR ALIGNRIGHT;
    public static WVR HREDRAW;
    public static WVR VREDRAW;
    public static WVR VALIDRECTS;
    public static WVR REDRAW;
}
internal static class System.AppContextDefaultValues : object {
    public static void PopulateDefaultValues();
    private static void ParseTargetFrameworkName(String& identifier, String& profile, Int32& version);
    private static string GetTargetFrameworkMoniker();
    private static bool TryParseFrameworkName(string frameworkName, String& identifier, Int32& version, String& profile);
    private static void PopulateDefaultValuesPartial(string platformIdentifier, string profile, int version);
    private static void InitializeNetFxSwitchDefaultsForNetCoreRuntime();
}
public static class System.ComponentModel.DesignerProperties : object {
    public static DependencyProperty IsInDesignModeProperty;
    private static DesignerProperties();
    [DesignerSerializationVisibilityAttribute("0")]
public static bool GetIsInDesignMode(DependencyObject element);
    public static void SetIsInDesignMode(DependencyObject element, bool value);
}
internal class System.LocalAppContext : object {
    private static TryGetSwitchDelegate TryGetSwitchFromCentralAppContext;
    private static bool s_canForwardCalls;
    private static Dictionary`2<string, bool> s_switchMap;
    private static object s_syncLock;
    [CompilerGeneratedAttribute]
private static bool <DisableCaching>k__BackingField;
    private static bool DisableCaching { get; private set; }
    private static LocalAppContext();
    [CompilerGeneratedAttribute]
private static bool get_DisableCaching();
    [CompilerGeneratedAttribute]
private static void set_DisableCaching(bool value);
    public static bool IsSwitchEnabled(string switchName);
    private static bool IsSwitchEnabledLocal(string switchName);
    private static bool SetupDelegate();
    internal static bool GetCachedSwitchValue(string switchName, Int32& switchValue);
    private static bool GetCachedSwitchValueInternal(string switchName, Int32& switchValue);
    internal static void DefineSwitchDefault(string switchName, bool initialValue);
}
internal static class System.Runtime.InteropServices.MarshalLocal : object {
    public static bool IsTypeVisibleFromCom(Type type);
}
[XmlRootAttribute]
public class System.Windows.Annotations.Annotation : object {
    [CompilerGeneratedAttribute]
private AnnotationAuthorChangedEventHandler AuthorChanged;
    [CompilerGeneratedAttribute]
private AnnotationResourceChangedEventHandler AnchorChanged;
    [CompilerGeneratedAttribute]
private AnnotationResourceChangedEventHandler CargoChanged;
    private Guid _id;
    private XmlQualifiedName _typeName;
    private DateTime _created;
    private DateTime _modified;
    private ObservableCollection`1<string> _authors;
    private AnnotationResourceCollection _cargos;
    private AnnotationResourceCollection _anchors;
    private static Serializer _ResourceSerializer;
    private static Char[] _Colon;
    public Guid Id { get; }
    public XmlQualifiedName AnnotationType { get; }
    public DateTime CreationTime { get; }
    public DateTime LastModificationTime { get; }
    public Collection`1<string> Authors { get; }
    public Collection`1<AnnotationResource> Anchors { get; }
    public Collection`1<AnnotationResource> Cargos { get; }
    private static Serializer ResourceSerializer { get; }
    public Annotation(XmlQualifiedName annotationType);
    public Annotation(XmlQualifiedName annotationType, Guid id, DateTime creationTime, DateTime lastModificationTime);
    private static Annotation();
    public sealed virtual XmlSchema GetSchema();
    public sealed virtual void WriteXml(XmlWriter writer);
    public sealed virtual void ReadXml(XmlReader reader);
    [CompilerGeneratedAttribute]
public void add_AuthorChanged(AnnotationAuthorChangedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_AuthorChanged(AnnotationAuthorChangedEventHandler value);
    [CompilerGeneratedAttribute]
public void add_AnchorChanged(AnnotationResourceChangedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_AnchorChanged(AnnotationResourceChangedEventHandler value);
    [CompilerGeneratedAttribute]
public void add_CargoChanged(AnnotationResourceChangedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_CargoChanged(AnnotationResourceChangedEventHandler value);
    public Guid get_Id();
    public XmlQualifiedName get_AnnotationType();
    public DateTime get_CreationTime();
    public DateTime get_LastModificationTime();
    public Collection`1<string> get_Authors();
    public Collection`1<AnnotationResource> get_Anchors();
    public Collection`1<AnnotationResource> get_Cargos();
    internal static bool IsNamespaceDeclaration(XmlReader reader);
    internal static void CheckForNonNamespaceAttribute(XmlReader reader, string elementName);
    private static Serializer get_ResourceSerializer();
    private void ReadAttributes(XmlReader reader);
    private void OnCargoChanged(object sender, PropertyChangedEventArgs e);
    private void OnCargosChanged(object sender, NotifyCollectionChangedEventArgs e);
    private void OnAnchorChanged(object sender, PropertyChangedEventArgs e);
    private void OnAnchorsChanged(object sender, NotifyCollectionChangedEventArgs e);
    private void OnAuthorsChanged(object sender, NotifyCollectionChangedEventArgs e);
    private void FireAuthorEvent(object author, AnnotationAction action);
    private void FireResourceEvent(AnnotationResource resource, AnnotationAction action, AnnotationResourceChangedEventHandler handlers);
    private void Init();
}
public enum System.Windows.Annotations.AnnotationAction : Enum {
    public int value__;
    public static AnnotationAction Added;
    public static AnnotationAction Removed;
    public static AnnotationAction Modified;
}
public class System.Windows.Annotations.AnnotationAuthorChangedEventArgs : EventArgs {
    private Annotation _annotation;
    private object _author;
    private AnnotationAction _action;
    public Annotation Annotation { get; }
    public object Author { get; }
    public AnnotationAction Action { get; }
    public AnnotationAuthorChangedEventArgs(Annotation annotation, AnnotationAction action, object author);
    public Annotation get_Annotation();
    public object get_Author();
    public AnnotationAction get_Action();
}
public class System.Windows.Annotations.AnnotationAuthorChangedEventHandler : MulticastDelegate {
    public AnnotationAuthorChangedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, AnnotationAuthorChangedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, AnnotationAuthorChangedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class System.Windows.Annotations.AnnotationComponentChooser : object {
    public IAnnotationComponent ChooseAnnotationComponent(IAttachedAnnotation attachedAnnotation);
}
public class System.Windows.Annotations.AnnotationDocumentPaginator : DocumentPaginator {
    private AnnotationStore _annotationStore;
    private DocumentPaginator _originalPaginator;
    private LocatorManager _locatorManager;
    private bool _isFixedContent;
    private FlowDirection _flowDirection;
    public bool IsPageCountValid { get; }
    public int PageCount { get; }
    public Size PageSize { get; public set; }
    public IDocumentPaginatorSource Source { get; }
    public AnnotationDocumentPaginator(DocumentPaginator originalPaginator, Stream annotationStore);
    public AnnotationDocumentPaginator(DocumentPaginator originalPaginator, Stream annotationStore, FlowDirection flowDirection);
    public AnnotationDocumentPaginator(DocumentPaginator originalPaginator, AnnotationStore annotationStore);
    public AnnotationDocumentPaginator(DocumentPaginator originalPaginator, AnnotationStore annotationStore, FlowDirection flowDirection);
    public virtual bool get_IsPageCountValid();
    public virtual int get_PageCount();
    public virtual Size get_PageSize();
    public virtual void set_PageSize(Size value);
    public virtual IDocumentPaginatorSource get_Source();
    public virtual DocumentPage GetPage(int pageNumber);
    public virtual void GetPageAsync(int pageNumber, object userState);
    public virtual void ComputePageCount();
    public virtual void ComputePageCountAsync(object userState);
    public virtual void CancelAsync(object userState);
    private void HandleGetPageCompleted(object sender, GetPageCompletedEventArgs e);
    private void HandleComputePageCountCompleted(object sender, AsyncCompletedEventArgs e);
    private void HandlePagesChanged(object sender, PagesChangedEventArgs e);
    private DocumentPage ComposePageWithAnnotationVisuals(int pageNumber, DocumentPage page);
    private IList`1<IAttachedAnnotation> ProcessAnnotations(DocumentPageView dpv);
}
public static class System.Windows.Annotations.AnnotationHelper : object {
    public static Annotation CreateHighlightForSelection(AnnotationService service, string author, Brush highlightBrush);
    public static Annotation CreateTextStickyNoteForSelection(AnnotationService service, string author);
    public static Annotation CreateInkStickyNoteForSelection(AnnotationService service, string author);
    public static void ClearHighlightsForSelection(AnnotationService service);
    public static void DeleteTextStickyNotesForSelection(AnnotationService service);
    public static void DeleteInkStickyNotesForSelection(AnnotationService service);
    public static IAnchorInfo GetAnchorInfo(AnnotationService service, Annotation annotation);
    internal static void OnCreateHighlightCommand(object sender, ExecutedRoutedEventArgs e);
    internal static void OnCreateTextStickyNoteCommand(object sender, ExecutedRoutedEventArgs e);
    internal static void OnCreateInkStickyNoteCommand(object sender, ExecutedRoutedEventArgs e);
    internal static void OnClearHighlightsCommand(object sender, ExecutedRoutedEventArgs e);
    internal static void OnDeleteStickyNotesCommand(object sender, ExecutedRoutedEventArgs e);
    internal static void OnDeleteAnnotationsCommand(object sender, ExecutedRoutedEventArgs e);
    internal static void OnQueryCreateHighlightCommand(object sender, CanExecuteRoutedEventArgs e);
    internal static void OnQueryCreateTextStickyNoteCommand(object sender, CanExecuteRoutedEventArgs e);
    internal static void OnQueryCreateInkStickyNoteCommand(object sender, CanExecuteRoutedEventArgs e);
    internal static void OnQueryClearHighlightsCommand(object sender, CanExecuteRoutedEventArgs e);
    internal static void OnQueryDeleteStickyNotesCommand(object sender, CanExecuteRoutedEventArgs e);
    internal static void OnQueryDeleteAnnotationsCommand(object sender, CanExecuteRoutedEventArgs e);
    internal static DocumentPageView FindView(DocumentViewerBase viewer, int pageNb);
    private static Annotation CreateStickyNoteForSelection(AnnotationService service, XmlQualifiedName noteType, string author);
    private static bool AreAllPagesVisible(DocumentViewerBase viewer, int startPage, int endPage);
    private static IList`1<IAttachedAnnotation> GetSpannedAnnotations(AnnotationService service);
    internal static object GetFdrHost(FlowDocumentReader fdr);
    private static IList`1<IAttachedAnnotation> GetSpannedAnnotationsForFlow(AnnotationService service, ITextSelection selection);
    private static IList`1<IAttachedAnnotation> GetSpannedAnnotationsForFixed(AnnotationService service, int startPage, int endPage);
    private static void AddRange(List`1<Annotation> annotations, IList`1<Annotation> newAnnotations);
    private static List`1<IAttachedAnnotation> ResolveAnnotations(AnnotationService service, IList`1<Annotation> annotations);
    private static void DeleteSpannedAnnotations(AnnotationService service, XmlQualifiedName annotationType);
    private static bool CheckCaret(ITextSelection selection, TextAnchor anchor, XmlQualifiedName type);
    private static Annotation CreateAnnotationForSelection(AnnotationService service, ITextRange textSelection, XmlQualifiedName annotationType, string author);
    private static Annotation Highlight(AnnotationService service, string author, Brush highlightBrush, bool create);
    private static Annotation ProcessHighlights(AnnotationService service, ITextRange textRange, string author, Nullable`1<Color> color, bool create);
    private static Annotation CreateHighlight(AnnotationService service, ITextRange textRange, string author, Nullable`1<Color> color);
    private static ITextSelection GetTextSelection(FrameworkElement viewer);
    private static void SetAnchor(AnnotationService service, Annotation annot, object selection);
    private static void CheckInputs(AnnotationService service);
    private static bool IsCommandEnabled(object sender, bool checkForEmpty);
}
[XmlRootAttribute]
public class System.Windows.Annotations.AnnotationResource : object {
    private Guid _id;
    private string _name;
    private AnnotationObservableCollection`1<ContentLocatorBase> _locators;
    private XmlElementCollection _contents;
    private static Serializer s_ListSerializer;
    private static Serializer s_LocatorGroupSerializer;
    private bool _owned;
    private PropertyChangedEventHandler _propertyChanged;
    public Guid Id { get; }
    public string Name { get; public set; }
    public Collection`1<ContentLocatorBase> ContentLocators { get; }
    public Collection`1<XmlElement> Contents { get; }
    private bool MS.Internal.Annotations.IOwnedObject.Owned { get; private set; }
    internal static Serializer ListSerializer { get; }
    private AnnotationObservableCollection`1<ContentLocatorBase> InternalLocators { get; }
    private XmlElementCollection InternalContents { get; }
    private static Serializer LocatorGroupSerializer { get; }
    public AnnotationResource(string name);
    public AnnotationResource(Guid id);
    public sealed virtual XmlSchema GetSchema();
    public sealed virtual void WriteXml(XmlWriter writer);
    public sealed virtual void ReadXml(XmlReader reader);
    private sealed virtual override void System.ComponentModel.INotifyPropertyChanged.add_PropertyChanged(PropertyChangedEventHandler value);
    private sealed virtual override void System.ComponentModel.INotifyPropertyChanged.remove_PropertyChanged(PropertyChangedEventHandler value);
    public Guid get_Id();
    public string get_Name();
    public void set_Name(string value);
    public Collection`1<ContentLocatorBase> get_ContentLocators();
    public Collection`1<XmlElement> get_Contents();
    private sealed virtual override bool MS.Internal.Annotations.IOwnedObject.get_Owned();
    private sealed virtual override void MS.Internal.Annotations.IOwnedObject.set_Owned(bool value);
    internal static Serializer get_ListSerializer();
    private AnnotationObservableCollection`1<ContentLocatorBase> get_InternalLocators();
    private XmlElementCollection get_InternalContents();
    private static Serializer get_LocatorGroupSerializer();
    private void ReadAttributes(XmlReader reader);
    private void OnLocatorsChanged(object sender, NotifyCollectionChangedEventArgs e);
    private void OnContentsChanged(object sender, NotifyCollectionChangedEventArgs e);
    private void FireResourceChanged(string name);
}
public class System.Windows.Annotations.AnnotationResourceChangedEventArgs : EventArgs {
    private Annotation _annotation;
    private AnnotationResource _resource;
    private AnnotationAction _action;
    public Annotation Annotation { get; }
    public AnnotationResource Resource { get; }
    public AnnotationAction Action { get; }
    public AnnotationResourceChangedEventArgs(Annotation annotation, AnnotationAction action, AnnotationResource resource);
    public Annotation get_Annotation();
    public AnnotationResource get_Resource();
    public AnnotationAction get_Action();
}
public class System.Windows.Annotations.AnnotationResourceChangedEventHandler : MulticastDelegate {
    public AnnotationResourceChangedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, AnnotationResourceChangedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, AnnotationResourceChangedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Windows.Annotations.AnnotationService : DispatcherObject {
    public static RoutedUICommand CreateHighlightCommand;
    public static RoutedUICommand CreateTextStickyNoteCommand;
    public static RoutedUICommand CreateInkStickyNoteCommand;
    public static RoutedUICommand ClearHighlightsCommand;
    public static RoutedUICommand DeleteStickyNotesCommand;
    public static RoutedUICommand DeleteAnnotationsCommand;
    internal static DependencyProperty ChooserProperty;
    internal static DependencyProperty SubTreeProcessorIdProperty;
    internal static DependencyProperty DataIdProperty;
    [CompilerGeneratedAttribute]
private AttachedAnnotationChangedEventHandler AttachedAnnotationChanged;
    internal static DependencyProperty ServiceProperty;
    private static DependencyProperty AttachedAnnotationsProperty;
    private DependencyObject _root;
    private AnnotationMap _annotationMap;
    private AnnotationComponentManager _annotationComponentManager;
    private LocatorManager _locatorManager;
    private bool _isEnabled;
    private AnnotationStore _store;
    private Collection`1<DocumentPageView> _views;
    private DispatcherOperation _asyncLoadOperation;
    private DispatcherOperation _asyncLoadFromListOperation;
    private static int _maxAnnotationsBatch;
    public bool IsEnabled { get; }
    public AnnotationStore Store { get; }
    internal LocatorManager LocatorManager { get; }
    internal DependencyObject Root { get; }
    private static AnnotationService();
    public AnnotationService(DocumentViewerBase viewer);
    public AnnotationService(FlowDocumentScrollViewer viewer);
    public AnnotationService(FlowDocumentReader viewer);
    internal AnnotationService(DependencyObject root);
    public void Enable(AnnotationStore annotationStore);
    public void Disable();
    public static AnnotationService GetService(DocumentViewerBase viewer);
    public static AnnotationService GetService(FlowDocumentReader reader);
    public static AnnotationService GetService(FlowDocumentScrollViewer viewer);
    internal void LoadAnnotations(DependencyObject element);
    internal void UnloadAnnotations(DependencyObject element);
    private void UnloadAnnotations();
    internal IList`1<IAttachedAnnotation> GetAttachedAnnotations();
    public bool get_IsEnabled();
    public AnnotationStore get_Store();
    internal static AnnotationService GetService(DependencyObject d);
    internal static AnnotationComponentChooser GetChooser(DependencyObject d);
    internal static void SetSubTreeProcessorId(DependencyObject d, string id);
    internal static string GetSubTreeProcessorId(DependencyObject d);
    internal static void SetDataId(DependencyObject d, string id);
    internal static string GetDataId(DependencyObject d);
    [CompilerGeneratedAttribute]
internal void add_AttachedAnnotationChanged(AttachedAnnotationChangedEventHandler value);
    [CompilerGeneratedAttribute]
internal void remove_AttachedAnnotationChanged(AttachedAnnotationChangedEventHandler value);
    internal LocatorManager get_LocatorManager();
    internal DependencyObject get_Root();
    private void Initialize(DependencyObject root);
    private object LoadAnnotationsAsync(object obj);
    private object LoadAnnotationsFromListAsync(object obj);
    private bool AttachedAnchorsEqual(IAttachedAnnotation firstAttachedAnnotation, IAttachedAnnotation secondAttachedAnnotation);
    private void LoadAnnotationsFromList(IList`1<IAttachedAnnotation> attachedAnnotations);
    private void UnloadAnnotationsFromList(IList attachedAnnotations);
    private void OnLayoutUpdated(object sender, EventArgs args);
    private void UpdateAnnotations();
    private static void InvalidateAdorners(UIElement element);
    private static void VerifyServiceConfiguration(DependencyObject root);
    private static void GetViewerAndDocument(DependencyObject root, DocumentViewerBase& documentViewerBase, IDocumentPaginatorSource& document);
    private static ITextView GetTextView(IDocumentPaginatorSource document);
    private static bool VerifyNoServiceOnNode(DependencyObject node, object data, bool visitedViaVisualTree);
    private IAttachedAnnotation FindAnnotationInList(IAttachedAnnotation attachedAnnotation, IList`1<IAttachedAnnotation> list);
    private IList GetAllAttachedAnnotationsFor(DependencyObject element);
    private bool GetAttachedAnnotationsFor(DependencyObject node, List`1<IAttachedAnnotation> result, bool visitedViaVisualTree);
    private void OnStoreContentChanged(object node, StoreContentChangedEventArgs args);
    private void OnAnchorChanged(object sender, AnnotationResourceChangedEventArgs args);
    private void AnnotationAdded(Annotation annotation);
    private void AnnotationDeleted(Guid annotationId);
    private AttachedAnnotationChangedEventArgs AnchorAdded(Annotation annotation, AnnotationResource anchor);
    private AttachedAnnotationChangedEventArgs AnchorRemoved(Annotation annotation, AnnotationResource anchor);
    private AttachedAnnotationChangedEventArgs AnchorModified(Annotation annotation, AnnotationResource anchor);
    private void DoAddAttachedAnnotation(IAttachedAnnotation attachedAnnotation);
    private void DoRemoveAttachedAnnotation(IAttachedAnnotation attachedAnnotation);
    private void FullyResolveAnchor(IAttachedAnnotation attachedAnnotation);
    private object FindAttachedAnchor(AnnotationResource anchor, AttachmentLevel& attachmentLevel);
    private void FireEvents(List`1<AttachedAnnotationChangedEventArgs> eventsToFire);
    private void RegisterOnDocumentViewer(DocumentViewerBase viewer);
    private void UnregisterOnDocumentViewer(DocumentViewerBase viewer);
    private void OnPageViewsChanged(object sender, EventArgs e);
    private void OnContentChanged(object sender, EventArgs e);
}
[XmlRootAttribute]
public class System.Windows.Annotations.ContentLocator : ContentLocatorBase {
    private AnnotationObservableCollection`1<ContentLocatorPart> _parts;
    public Collection`1<ContentLocatorPart> Parts { get; }
    public bool StartsWith(ContentLocator locator);
    public virtual object Clone();
    public sealed virtual XmlSchema GetSchema();
    public sealed virtual void WriteXml(XmlWriter writer);
    public sealed virtual void ReadXml(XmlReader reader);
    public Collection`1<ContentLocatorPart> get_Parts();
    internal IList`1<ContentLocatorBase> DotProduct(IList`1<ContentLocatorPart> additionalLocatorParts);
    internal virtual ContentLocatorBase Merge(ContentLocatorBase other);
    internal void Append(ContentLocator other);
    private void OnCollectionChanged(object sender, NotifyCollectionChangedEventArgs e);
}
public abstract class System.Windows.Annotations.ContentLocatorBase : object {
    private bool _owned;
    [CompilerGeneratedAttribute]
private PropertyChangedEventHandler _propertyChanged;
    private bool MS.Internal.Annotations.IOwnedObject.Owned { get; private set; }
    public abstract virtual object Clone();
    private sealed virtual override void System.ComponentModel.INotifyPropertyChanged.add_PropertyChanged(PropertyChangedEventHandler value);
    private sealed virtual override void System.ComponentModel.INotifyPropertyChanged.remove_PropertyChanged(PropertyChangedEventHandler value);
    internal void FireLocatorChanged(string name);
    private sealed virtual override bool MS.Internal.Annotations.IOwnedObject.get_Owned();
    private sealed virtual override void MS.Internal.Annotations.IOwnedObject.set_Owned(bool value);
    internal abstract virtual ContentLocatorBase Merge(ContentLocatorBase other);
    [CompilerGeneratedAttribute]
private void add__propertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
private void remove__propertyChanged(PropertyChangedEventHandler value);
}
[XmlRootAttribute]
public class System.Windows.Annotations.ContentLocatorGroup : ContentLocatorBase {
    private AnnotationObservableCollection`1<ContentLocator> _locators;
    public Collection`1<ContentLocator> Locators { get; }
    public virtual object Clone();
    public sealed virtual XmlSchema GetSchema();
    public sealed virtual void WriteXml(XmlWriter writer);
    public sealed virtual void ReadXml(XmlReader reader);
    public Collection`1<ContentLocator> get_Locators();
    internal virtual ContentLocatorBase Merge(ContentLocatorBase other);
    private void OnCollectionChanged(object sender, NotifyCollectionChangedEventArgs e);
}
public class System.Windows.Annotations.ContentLocatorPart : object {
    private bool _owned;
    private XmlQualifiedName _type;
    private ObservableDictionary _nameValues;
    [CompilerGeneratedAttribute]
private PropertyChangedEventHandler _propertyChanged;
    public IDictionary`2<string, string> NameValuePairs { get; }
    public XmlQualifiedName PartType { get; }
    private bool MS.Internal.Annotations.IOwnedObject.Owned { get; private set; }
    public ContentLocatorPart(XmlQualifiedName partType);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public object Clone();
    public IDictionary`2<string, string> get_NameValuePairs();
    public XmlQualifiedName get_PartType();
    private sealed virtual override void System.ComponentModel.INotifyPropertyChanged.add_PropertyChanged(PropertyChangedEventHandler value);
    private sealed virtual override void System.ComponentModel.INotifyPropertyChanged.remove_PropertyChanged(PropertyChangedEventHandler value);
    internal bool Matches(ContentLocatorPart part);
    internal string GetQueryFragment(XmlNamespaceManager namespaceManager);
    private sealed virtual override bool MS.Internal.Annotations.IOwnedObject.get_Owned();
    private sealed virtual override void MS.Internal.Annotations.IOwnedObject.set_Owned(bool value);
    private void OnPropertyChanged(object sender, PropertyChangedEventArgs e);
    private string GetOverlapQueryFragment(XmlNamespaceManager namespaceManager);
    private string GetExactQueryFragment(XmlNamespaceManager namespaceManager);
    [CompilerGeneratedAttribute]
private void add__propertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
private void remove__propertyChanged(PropertyChangedEventHandler value);
}
public interface System.Windows.Annotations.IAnchorInfo {
    public Annotation Annotation { get; }
    public AnnotationResource Anchor { get; }
    public object ResolvedAnchor { get; }
    public abstract virtual Annotation get_Annotation();
    public abstract virtual AnnotationResource get_Anchor();
    public abstract virtual object get_ResolvedAnchor();
}
public abstract class System.Windows.Annotations.Storage.AnnotationStore : object {
    [CompilerGeneratedAttribute]
private StoreContentChangedEventHandler StoreContentChanged;
    [CompilerGeneratedAttribute]
private AnnotationAuthorChangedEventHandler AuthorChanged;
    [CompilerGeneratedAttribute]
private AnnotationResourceChangedEventHandler AnchorChanged;
    [CompilerGeneratedAttribute]
private AnnotationResourceChangedEventHandler CargoChanged;
    private bool _disposed;
    private object lockObject;
    public bool AutoFlush { get; public set; }
    protected object SyncRoot { get; }
    protected bool IsDisposed { get; }
    protected virtual override void Finalize();
    public abstract virtual void AddAnnotation(Annotation newAnnotation);
    public abstract virtual Annotation DeleteAnnotation(Guid annotationId);
    public abstract virtual IList`1<Annotation> GetAnnotations(ContentLocator anchorLocator);
    public abstract virtual IList`1<Annotation> GetAnnotations();
    public abstract virtual Annotation GetAnnotation(Guid annotationId);
    public abstract virtual void Flush();
    public sealed virtual void Dispose();
    public abstract virtual bool get_AutoFlush();
    public abstract virtual void set_AutoFlush(bool value);
    [CompilerGeneratedAttribute]
public void add_StoreContentChanged(StoreContentChangedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_StoreContentChanged(StoreContentChangedEventHandler value);
    [CompilerGeneratedAttribute]
public void add_AuthorChanged(AnnotationAuthorChangedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_AuthorChanged(AnnotationAuthorChangedEventHandler value);
    [CompilerGeneratedAttribute]
public void add_AnchorChanged(AnnotationResourceChangedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_AnchorChanged(AnnotationResourceChangedEventHandler value);
    [CompilerGeneratedAttribute]
public void add_CargoChanged(AnnotationResourceChangedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_CargoChanged(AnnotationResourceChangedEventHandler value);
    protected virtual void Dispose(bool disposing);
    protected virtual void OnAuthorChanged(AnnotationAuthorChangedEventArgs args);
    protected virtual void OnAnchorChanged(AnnotationResourceChangedEventArgs args);
    protected virtual void OnCargoChanged(AnnotationResourceChangedEventArgs args);
    protected virtual void OnStoreContentChanged(StoreContentChangedEventArgs e);
    protected object get_SyncRoot();
    protected bool get_IsDisposed();
}
public enum System.Windows.Annotations.Storage.StoreContentAction : Enum {
    public int value__;
    public static StoreContentAction Added;
    public static StoreContentAction Deleted;
}
public class System.Windows.Annotations.Storage.StoreContentChangedEventArgs : EventArgs {
    private StoreContentAction _action;
    private Annotation _annotation;
    public Annotation Annotation { get; }
    public StoreContentAction Action { get; }
    public StoreContentChangedEventArgs(StoreContentAction action, Annotation annotation);
    public Annotation get_Annotation();
    public StoreContentAction get_Action();
}
public class System.Windows.Annotations.Storage.StoreContentChangedEventHandler : MulticastDelegate {
    public StoreContentChangedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, StoreContentChangedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, StoreContentChangedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Windows.Annotations.Storage.XmlStreamStore : AnnotationStore {
    private bool _dirty;
    private bool _autoFlush;
    private XmlDocument _document;
    private XmlNamespaceManager _namespaceManager;
    private Stream _stream;
    private XPathNavigator _rootNavigator;
    private StoreAnnotationsMap _storeAnnotationsMap;
    private List`1<Uri> _ignoredNamespaces;
    private XmlCompatibilityReader _xmlCompatibilityReader;
    private static Dictionary`2<Uri, IList`1<Uri>> _predefinedNamespaces;
    private static Serializer _serializer;
    public bool AutoFlush { get; public set; }
    public IList`1<Uri> IgnoredNamespaces { get; }
    public static IList`1<Uri> WellKnownNamespaces { get; }
    private static XmlStreamStore();
    public XmlStreamStore(Stream stream);
    public XmlStreamStore(Stream stream, IDictionary`2<Uri, IList`1<Uri>> knownNamespaces);
    public virtual void AddAnnotation(Annotation newAnnotation);
    public virtual Annotation DeleteAnnotation(Guid annotationId);
    public virtual IList`1<Annotation> GetAnnotations(ContentLocator anchorLocator);
    public virtual IList`1<Annotation> GetAnnotations();
    public virtual Annotation GetAnnotation(Guid annotationId);
    public virtual void Flush();
    public static IList`1<Uri> GetWellKnownCompatibleNamespaces(Uri name);
    public virtual bool get_AutoFlush();
    public virtual void set_AutoFlush(bool value);
    public IList`1<Uri> get_IgnoredNamespaces();
    public static IList`1<Uri> get_WellKnownNamespaces();
    protected virtual void Dispose(bool disposing);
    protected virtual void OnStoreContentChanged(StoreContentChangedEventArgs e);
    private List`1<Guid> FindAnnotationIds(string queryExpression);
    private void HandleAuthorChanged(object sender, AnnotationAuthorChangedEventArgs e);
    private void HandleAnchorChanged(object sender, AnnotationResourceChangedEventArgs e);
    private void HandleCargoChanged(object sender, AnnotationResourceChangedEventArgs e);
    private IList`1<Annotation> MergeAndCacheAnnotations(Dictionary`2<Guid, Annotation> mapAnnotations, List`1<Guid> storeAnnotationsId);
    private IList`1<Annotation> InternalGetAnnotations(string query, ContentLocator anchorLocator);
    private void LoadStream(IDictionary`2<Uri, IList`1<Uri>> knownNamespaces);
    private void CheckKnownNamespaces(IDictionary`2<Uri, IList`1<Uri>> knownNamespaces);
    private XmlCompatibilityReader SetupReader(IDictionary`2<Uri, IList`1<Uri>> knownNamespaces);
    private bool IsXmlNamespaceSupported(string xmlNamespace, String& newXmlNamespace);
    private XPathNavigator GetAnnotationNodeForId(Guid id);
    private void CheckStatus();
    private void SerializeAnnotations();
    private void Cleanup();
    private void SetStream(Stream stream, IDictionary`2<Uri, IList`1<Uri>> knownNamespaces);
}
public class System.Windows.Annotations.TextAnchor : object {
    private List`1<TextSegment> _segments;
    public ContentPosition BoundingStart { get; }
    public ContentPosition BoundingEnd { get; }
    internal ITextPointer Start { get; }
    internal ITextPointer End { get; }
    internal bool IsEmpty { get; }
    internal string Text { get; }
    internal ReadOnlyCollection`1<TextSegment> TextSegments { get; }
    internal TextAnchor(TextAnchor anchor);
    internal bool Contains(ITextPointer textPointer);
    internal void AddTextSegment(ITextPointer start, ITextPointer end);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    internal bool IsOverlapping(ICollection`1<TextSegment> textSegments);
    internal static TextAnchor ExclusiveUnion(TextAnchor anchor, TextAnchor otherAnchor);
    internal static TextAnchor TrimToRelativeComplement(TextAnchor anchor, ICollection`1<TextSegment> textSegments);
    internal static TextAnchor TrimToIntersectionWith(TextAnchor anchor, ICollection`1<TextSegment> textSegments);
    public ContentPosition get_BoundingStart();
    public ContentPosition get_BoundingEnd();
    internal ITextPointer get_Start();
    internal ITextPointer get_End();
    internal bool get_IsEmpty();
    internal string get_Text();
    internal ReadOnlyCollection`1<TextSegment> get_TextSegments();
    private static ICollection`1<TextSegment> SortTextSegments(ICollection`1<TextSegment> textSegments, bool excludeZeroLength);
    private void InsertSegment(TextSegment newSegment);
    private static TextSegment CreateNormalizedSegment(ITextPointer start, ITextPointer end);
}
public class System.Windows.Application : DispatcherObject {
    [CompilerGeneratedAttribute]
private EventHandler Activated;
    [CompilerGeneratedAttribute]
private EventHandler Deactivated;
    [CompilerGeneratedAttribute]
private NavigatingCancelEventHandler Navigating;
    [CompilerGeneratedAttribute]
private NavigatedEventHandler Navigated;
    [CompilerGeneratedAttribute]
private NavigationProgressEventHandler NavigationProgress;
    [CompilerGeneratedAttribute]
private NavigationFailedEventHandler NavigationFailed;
    [CompilerGeneratedAttribute]
private LoadCompletedEventHandler LoadCompleted;
    [CompilerGeneratedAttribute]
private NavigationStoppedEventHandler NavigationStopped;
    [CompilerGeneratedAttribute]
private FragmentNavigationEventHandler FragmentNavigation;
    private static object _globalLock;
    private static bool _isShuttingDown;
    private static bool _appCreatedInThisAppDomain;
    private static Application _appInstance;
    private static Assembly _resourceAssembly;
    [ThreadStaticAttribute]
private static Stack`1<NestedBamlLoadInfo> s_NestedBamlLoadInfo;
    private Uri _startupUri;
    private Uri _applicationMarkupBaseUri;
    private HybridDictionary _htProps;
    private WindowCollection _appWindowList;
    private WindowCollection _nonAppWindowList;
    private Window _mainWindow;
    private ResourceDictionary _resources;
    private bool _ownDispatcherStarted;
    private NavigationService _navService;
    private SecurityCriticalDataForSet`1<MimeType> _appMimeType;
    private IServiceProvider _serviceProvider;
    private bool _appIsShutdown;
    private int _exitCode;
    private ShutdownMode _shutdownMode;
    private HwndWrapper _parkingHwnd;
    private HwndWrapperHook _appFilterHook;
    private EventHandlerList _events;
    private bool _hasImplicitStylesInResources;
    private static object EVENT_STARTUP;
    private static object EVENT_EXIT;
    private static object EVENT_SESSIONENDING;
    private static PlaySoundFlags PLAYSOUND_FLAGS;
    private static string SYSTEM_SOUNDS_REGISTRY_LOCATION;
    private static string SYSTEM_SOUNDS_REGISTRY_BASE;
    private static string SOUND_NAVIGATING;
    private static string SOUND_COMPLETE_NAVIGATION;
    public static Application Current { get; }
    public WindowCollection Windows { get; }
    public Window MainWindow { get; public set; }
    public ShutdownMode ShutdownMode { get; public set; }
    [AmbientAttribute]
public ResourceDictionary Resources { get; public set; }
    private ResourceDictionary System.Windows.Markup.IHaveResources.Resources { get; private set; }
    internal bool HasImplicitStylesInResources { get; internal set; }
    public Uri StartupUri { get; public set; }
    public IDictionary Properties { get; }
    public static Assembly ResourceAssembly { get; public set; }
    internal WindowCollection WindowsInternal { get; private set; }
    internal WindowCollection NonAppWindowsInternal { get; private set; }
    internal MimeType MimeType { get; internal set; }
    private IServiceProvider ServiceProvider { get; internal set; }
    internal NavigationService NavService { get; internal set; }
    internal static bool IsShuttingDown { get; internal set; }
    internal static bool IsApplicationObjectShuttingDown { get; }
    internal IntPtr ParkingHwnd { get; }
    internal Uri ApplicationMarkupBaseUri { get; internal set; }
    private EventHandlerList Events { get; }
    private static Application();
    public int Run();
    public int Run(Window window);
    internal object GetService(Type serviceType);
    public void Shutdown();
    public void Shutdown(int exitCode);
    internal void CriticalShutdown(int exitCode);
    public object FindResource(object resourceKey);
    public object TryFindResource(object resourceKey);
    internal object FindResourceInternal(object resourceKey);
    internal object FindResourceInternal(object resourceKey, bool allowDeferredResourceReference, bool mustReturnDeferredResourceReference);
    public static void LoadComponent(object component, Uri resourceLocator);
    public static object LoadComponent(Uri resourceLocator);
    internal static object LoadComponent(Uri resourceLocator, bool bSkipJournaledProperties);
    internal static object LoadBamlStreamWithSyncInfo(Stream stream, ParserContext pc);
    public static StreamResourceInfo GetResourceStream(Uri uriResource);
    public static StreamResourceInfo GetContentStream(Uri uriContent);
    public static StreamResourceInfo GetRemoteStream(Uri uriRemote);
    public static string GetCookie(Uri uri);
    public static void SetCookie(Uri uri, string value);
    public static Application get_Current();
    public WindowCollection get_Windows();
    public Window get_MainWindow();
    public void set_MainWindow(Window value);
    public ShutdownMode get_ShutdownMode();
    public void set_ShutdownMode(ShutdownMode value);
    public ResourceDictionary get_Resources();
    public void set_Resources(ResourceDictionary value);
    private sealed virtual override ResourceDictionary System.Windows.Markup.IHaveResources.get_Resources();
    private sealed virtual override void System.Windows.Markup.IHaveResources.set_Resources(ResourceDictionary value);
    private sealed virtual override bool System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(string propertyName);
    internal bool get_HasImplicitStylesInResources();
    internal void set_HasImplicitStylesInResources(bool value);
    public Uri get_StartupUri();
    public void set_StartupUri(Uri value);
    public IDictionary get_Properties();
    public static Assembly get_ResourceAssembly();
    public static void set_ResourceAssembly(Assembly value);
    public void add_Startup(StartupEventHandler value);
    public void remove_Startup(StartupEventHandler value);
    public void add_Exit(ExitEventHandler value);
    public void remove_Exit(ExitEventHandler value);
    [CompilerGeneratedAttribute]
public void add_Activated(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_Activated(EventHandler value);
    [CompilerGeneratedAttribute]
public void add_Deactivated(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_Deactivated(EventHandler value);
    public void add_SessionEnding(SessionEndingCancelEventHandler value);
    public void remove_SessionEnding(SessionEndingCancelEventHandler value);
    public void add_DispatcherUnhandledException(DispatcherUnhandledExceptionEventHandler value);
    public void remove_DispatcherUnhandledException(DispatcherUnhandledExceptionEventHandler value);
    [CompilerGeneratedAttribute]
public void add_Navigating(NavigatingCancelEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_Navigating(NavigatingCancelEventHandler value);
    [CompilerGeneratedAttribute]
public void add_Navigated(NavigatedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_Navigated(NavigatedEventHandler value);
    [CompilerGeneratedAttribute]
public void add_NavigationProgress(NavigationProgressEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_NavigationProgress(NavigationProgressEventHandler value);
    [CompilerGeneratedAttribute]
public void add_NavigationFailed(NavigationFailedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_NavigationFailed(NavigationFailedEventHandler value);
    [CompilerGeneratedAttribute]
public void add_LoadCompleted(LoadCompletedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_LoadCompleted(LoadCompletedEventHandler value);
    [CompilerGeneratedAttribute]
public void add_NavigationStopped(NavigationStoppedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_NavigationStopped(NavigationStoppedEventHandler value);
    [CompilerGeneratedAttribute]
public void add_FragmentNavigation(FragmentNavigationEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_FragmentNavigation(FragmentNavigationEventHandler value);
    protected virtual void OnStartup(StartupEventArgs e);
    protected virtual void OnExit(ExitEventArgs e);
    protected virtual void OnActivated(EventArgs e);
    protected virtual void OnDeactivated(EventArgs e);
    protected virtual void OnSessionEnding(SessionEndingCancelEventArgs e);
    protected virtual void OnNavigating(NavigatingCancelEventArgs e);
    protected virtual void OnNavigated(NavigationEventArgs e);
    protected virtual void OnNavigationProgress(NavigationProgressEventArgs e);
    protected virtual void OnNavigationFailed(NavigationFailedEventArgs e);
    protected virtual void OnLoadCompleted(NavigationEventArgs e);
    protected virtual void OnNavigationStopped(NavigationEventArgs e);
    protected virtual void OnFragmentNavigation(FragmentNavigationEventArgs e);
    internal virtual void PerformNavigationStateChangeTasks(bool isNavigationInitiator, bool playNavigatingSound, NavigationStateChange state);
    internal void DoStartup();
    internal virtual void DoShutdown();
    internal int RunInternal(Window window);
    internal void InvalidateResourceReferences(ResourcesChangeInfo info);
    internal NavigationWindow GetAppWindow();
    internal void FireNavigating(NavigatingCancelEventArgs e, bool isInitialNavigation);
    internal void FireNavigated(NavigationEventArgs e);
    internal void FireNavigationProgress(NavigationProgressEventArgs e);
    internal void FireNavigationFailed(NavigationFailedEventArgs e);
    internal void FireLoadCompleted(NavigationEventArgs e);
    internal void FireNavigationStopped(NavigationEventArgs e);
    internal void FireFragmentNavigation(FragmentNavigationEventArgs e);
    internal WindowCollection get_WindowsInternal();
    private void set_WindowsInternal(WindowCollection value);
    internal WindowCollection get_NonAppWindowsInternal();
    private void set_NonAppWindowsInternal(WindowCollection value);
    internal MimeType get_MimeType();
    internal void set_MimeType(MimeType value);
    private IServiceProvider get_ServiceProvider();
    internal void set_ServiceProvider(IServiceProvider value);
    internal NavigationService get_NavService();
    internal void set_NavService(NavigationService value);
    internal static bool get_IsShuttingDown();
    internal static void set_IsShuttingDown(bool value);
    internal static bool get_IsApplicationObjectShuttingDown();
    internal IntPtr get_ParkingHwnd();
    internal Uri get_ApplicationMarkupBaseUri();
    internal void set_ApplicationMarkupBaseUri(Uri value);
    private static void ApplicationInit();
    private static PackagePart GetResourceOrContentPart(Uri uri);
    private static Package GetResourcePackage(Uri packageUri);
    private void EnsureHwndSource();
    private IntPtr AppFilterMessage(IntPtr hwnd, int msg, IntPtr wParam, IntPtr lParam, Boolean& handled);
    private bool WmActivateApp(int wParam);
    private bool WmQueryEndSession(IntPtr lParam, IntPtr& refInt);
    private void InvalidateResourceReferenceOnWindowCollection(WindowCollection wc, ResourcesChangeInfo info);
    private void SetExitCode(int exitCode);
    private object ShutdownCallback(object arg);
    private void ShutdownImpl();
    private static bool IsValidShutdownMode(ShutdownMode value);
    private void OnPreBPReady(object sender, BPReadyEventArgs e);
    private void ConfigAppWindowAndRootElement(object root, Uri uri);
    private void PlaySound(string soundName);
    private string GetSystemSound(string soundName);
    private EventHandlerList get_Events();
    private static bool IsComponentBeingLoadedFromOuterLoadBaml(Uri curComponentUri);
    private object RunDispatcher(object ignore);
    [CompilerGeneratedAttribute]
private object <.ctor>b__1_0(object unused);
}
[AttributeUsageAttribute("64")]
public class System.Windows.AttachedPropertyBrowsableForChildrenAttribute : AttachedPropertyBrowsableAttribute {
    private bool _includeDescendants;
    public bool IncludeDescendants { get; public set; }
    public bool get_IncludeDescendants();
    public void set_IncludeDescendants(bool value);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    internal virtual bool IsBrowsable(DependencyObject d, DependencyProperty dp);
}
public class System.Windows.Automation.Peers.ButtonAutomationPeer : ButtonBaseAutomationPeer {
    public ButtonAutomationPeer(Button owner);
    protected virtual string GetClassNameCore();
    protected virtual AutomationControlType GetAutomationControlTypeCore();
    public virtual object GetPattern(PatternInterface patternInterface);
    private sealed virtual override void System.Windows.Automation.Provider.IInvokeProvider.Invoke();
    [CompilerGeneratedAttribute]
private object <System.Windows.Automation.Provider.IInvokeProvider.Invoke>b__4_0(object param);
}
public abstract class System.Windows.Automation.Peers.ButtonBaseAutomationPeer : FrameworkElementAutomationPeer {
    protected ButtonBaseAutomationPeer(ButtonBase owner);
    protected virtual string GetAcceleratorKeyCore();
    protected virtual string GetAutomationIdCore();
    protected virtual string GetNameCore();
}
public class System.Windows.Automation.Peers.CalendarAutomationPeer : FrameworkElementAutomationPeer {
    private Dictionary`2<DateTimeCalendarModePair, DateTimeAutomationPeer> _dataChildren;
    private Dictionary`2<DateTimeCalendarModePair, WeakReference> _weakRefElementProxyStorage;
    private Calendar OwningCalendar { get; }
    private Grid OwningGrid { get; }
    private int System.Windows.Automation.Provider.IGridProvider.ColumnCount { get; }
    private int System.Windows.Automation.Provider.IGridProvider.RowCount { get; }
    private int System.Windows.Automation.Provider.IMultipleViewProvider.CurrentView { get; }
    private bool System.Windows.Automation.Provider.ISelectionProvider.CanSelectMultiple { get; }
    private bool System.Windows.Automation.Provider.ISelectionProvider.IsSelectionRequired { get; }
    private RowOrColumnMajor System.Windows.Automation.Provider.ITableProvider.RowOrColumnMajor { get; }
    private Dictionary`2<DateTimeCalendarModePair, DateTimeAutomationPeer> DateTimePeers { get; private set; }
    private Dictionary`2<DateTimeCalendarModePair, WeakReference> WeakRefElementProxyStorage { get; }
    public CalendarAutomationPeer(Calendar owner);
    private Calendar get_OwningCalendar();
    private Grid get_OwningGrid();
    public virtual object GetPattern(PatternInterface patternInterface);
    protected virtual AutomationControlType GetAutomationControlTypeCore();
    protected virtual List`1<AutomationPeer> GetChildrenCore();
    protected virtual string GetClassNameCore();
    protected virtual void SetFocusCore();
    private DateTimeAutomationPeer GetOrCreateDateTimeAutomationPeer(DateTime date, CalendarMode buttonMode);
    private DateTimeAutomationPeer GetOrCreateDateTimeAutomationPeer(DateTime date, CalendarMode buttonMode, bool addParentInfo);
    private DateTimeAutomationPeer GetPeerFromWeakRefStorage(DateTimeCalendarModePair dateTimeCalendarModePairKey);
    internal void AddProxyToWeakRefStorage(WeakReference wr, DateTimeAutomationPeer dateTimePeer);
    internal void RaiseSelectionEvents(SelectionChangedEventArgs e);
    private sealed virtual override int System.Windows.Automation.Provider.IGridProvider.get_ColumnCount();
    private sealed virtual override int System.Windows.Automation.Provider.IGridProvider.get_RowCount();
    private sealed virtual override IRawElementProviderSimple System.Windows.Automation.Provider.IGridProvider.GetItem(int row, int column);
    private sealed virtual override int System.Windows.Automation.Provider.IMultipleViewProvider.get_CurrentView();
    private sealed virtual override Int32[] System.Windows.Automation.Provider.IMultipleViewProvider.GetSupportedViews();
    private sealed virtual override string System.Windows.Automation.Provider.IMultipleViewProvider.GetViewName(int viewId);
    private sealed virtual override void System.Windows.Automation.Provider.IMultipleViewProvider.SetCurrentView(int viewId);
    private sealed virtual override bool System.Windows.Automation.Provider.ISelectionProvider.get_CanSelectMultiple();
    private sealed virtual override bool System.Windows.Automation.Provider.ISelectionProvider.get_IsSelectionRequired();
    private sealed virtual override IRawElementProviderSimple[] System.Windows.Automation.Provider.ISelectionProvider.GetSelection();
    private sealed virtual override IRawElementProviderSimple System.Windows.Automation.Provider.IItemContainerProvider.FindItemByProperty(IRawElementProviderSimple startAfterProvider, int propertyId, object value);
    private Nullable`1<DateTime> GetNextDate(DateTimeAutomationPeer currentDatePeer, CalendarMode currentMode);
    private Nullable`1<DateTime> GetNextSelectedDate(DateTimeAutomationPeer currentDatePeer, bool isSelected);
    private sealed virtual override RowOrColumnMajor System.Windows.Automation.Provider.ITableProvider.get_RowOrColumnMajor();
    private sealed virtual override IRawElementProviderSimple[] System.Windows.Automation.Provider.ITableProvider.GetColumnHeaders();
    private sealed virtual override IRawElementProviderSimple[] System.Windows.Automation.Provider.ITableProvider.GetRowHeaders();
    private Dictionary`2<DateTimeCalendarModePair, DateTimeAutomationPeer> get_DateTimePeers();
    private void set_DateTimePeers(Dictionary`2<DateTimeCalendarModePair, DateTimeAutomationPeer> value);
    private Dictionary`2<DateTimeCalendarModePair, WeakReference> get_WeakRefElementProxyStorage();
}
public class System.Windows.Automation.Peers.CalendarButtonAutomationPeer : FrameworkElementAutomationPeer {
    private bool IsDayButton { get; }
    public CalendarButtonAutomationPeer(Button owner);
    private bool get_IsDayButton();
    protected virtual AutomationControlType GetAutomationControlTypeCore();
    protected virtual string GetClassNameCore();
    protected virtual string GetLocalizedControlTypeCore();
}
public class System.Windows.Automation.Peers.CheckBoxAutomationPeer : ToggleButtonAutomationPeer {
    public CheckBoxAutomationPeer(CheckBox owner);
    protected virtual string GetClassNameCore();
    protected virtual AutomationControlType GetAutomationControlTypeCore();
}
public class System.Windows.Automation.Peers.ComboBoxAutomationPeer : SelectorAutomationPeer {
    private string System.Windows.Automation.Provider.IValueProvider.Value { get; }
    private bool System.Windows.Automation.Provider.IValueProvider.IsReadOnly { get; }
    private ExpandCollapseState System.Windows.Automation.Provider.IExpandCollapseProvider.ExpandCollapseState { get; }
    public ComboBoxAutomationPeer(ComboBox owner);
    protected virtual ItemAutomationPeer CreateItemAutomationPeer(object item);
    protected virtual AutomationControlType GetAutomationControlTypeCore();
    protected virtual string GetClassNameCore();
    public virtual object GetPattern(PatternInterface pattern);
    protected virtual List`1<AutomationPeer> GetChildrenCore();
    protected virtual void SetFocusCore();
    internal void ScrollItemIntoView(object item);
    private sealed virtual override void System.Windows.Automation.Provider.IValueProvider.SetValue(string val);
    private sealed virtual override string System.Windows.Automation.Provider.IValueProvider.get_Value();
    private sealed virtual override bool System.Windows.Automation.Provider.IValueProvider.get_IsReadOnly();
    internal void RaiseValuePropertyChangedEvent(string oldValue, string newValue);
    private sealed virtual override void System.Windows.Automation.Provider.IExpandCollapseProvider.Expand();
    private sealed virtual override void System.Windows.Automation.Provider.IExpandCollapseProvider.Collapse();
    private sealed virtual override ExpandCollapseState System.Windows.Automation.Provider.IExpandCollapseProvider.get_ExpandCollapseState();
    internal void RaiseExpandCollapseAutomationEvent(bool oldValue, bool newValue);
}
public abstract class System.Windows.Automation.Peers.ContentTextAutomationPeer : FrameworkContentElementAutomationPeer {
    protected ContentTextAutomationPeer(FrameworkContentElement owner);
    internal IRawElementProviderSimple ProviderFromPeer(AutomationPeer peer);
    internal DependencyObject ElementFromProvider(IRawElementProviderSimple provider);
    internal abstract virtual List`1<AutomationPeer> GetAutomationPeersFromRange(ITextPointer start, ITextPointer end);
}
public class System.Windows.Automation.Peers.ContextMenuAutomationPeer : FrameworkElementAutomationPeer {
    public ContextMenuAutomationPeer(ContextMenu owner);
    protected virtual string GetClassNameCore();
    protected virtual AutomationControlType GetAutomationControlTypeCore();
    protected virtual bool IsContentElementCore();
}
public class System.Windows.Automation.Peers.DataGridAutomationPeer : ItemsControlAutomationPeer {
    private int System.Windows.Automation.Provider.IGridProvider.ColumnCount { get; }
    private int System.Windows.Automation.Provider.IGridProvider.RowCount { get; }
    private bool System.Windows.Automation.Provider.ISelectionProvider.CanSelectMultiple { get; }
    private bool System.Windows.Automation.Provider.ISelectionProvider.IsSelectionRequired { get; }
    private RowOrColumnMajor System.Windows.Automation.Provider.ITableProvider.RowOrColumnMajor { get; }
    private DataGrid OwningDataGrid { get; }
    public DataGridAutomationPeer(DataGrid owner);
    protected virtual AutomationControlType GetAutomationControlTypeCore();
    protected virtual List`1<AutomationPeer> GetChildrenCore();
    protected virtual string GetClassNameCore();
    public virtual object GetPattern(PatternInterface patternInterface);
    protected virtual ItemAutomationPeer CreateItemAutomationPeer(object item);
    internal virtual bool IsPropertySupportedByControlForFindItem(int id);
    internal virtual object GetSupportedPropertyValue(ItemAutomationPeer itemPeer, int propertyId);
    private sealed virtual override int System.Windows.Automation.Provider.IGridProvider.get_ColumnCount();
    private sealed virtual override int System.Windows.Automation.Provider.IGridProvider.get_RowCount();
    private sealed virtual override IRawElementProviderSimple System.Windows.Automation.Provider.IGridProvider.GetItem(int row, int column);
    private sealed virtual override IRawElementProviderSimple[] System.Windows.Automation.Provider.ISelectionProvider.GetSelection();
    private sealed virtual override bool System.Windows.Automation.Provider.ISelectionProvider.get_CanSelectMultiple();
    private sealed virtual override bool System.Windows.Automation.Provider.ISelectionProvider.get_IsSelectionRequired();
    private sealed virtual override RowOrColumnMajor System.Windows.Automation.Provider.ITableProvider.get_RowOrColumnMajor();
    private sealed virtual override IRawElementProviderSimple[] System.Windows.Automation.Provider.ITableProvider.GetColumnHeaders();
    private sealed virtual override IRawElementProviderSimple[] System.Windows.Automation.Provider.ITableProvider.GetRowHeaders();
    private DataGrid get_OwningDataGrid();
    private DataGridCellItemAutomationPeer GetCellItemPeer(DataGridCellInfo cellInfo);
    internal void RaiseAutomationCellSelectedEvent(SelectedCellsChangedEventArgs e);
    internal void RaiseAutomationRowInvokeEvents(DataGridRow row);
    internal void RaiseAutomationCellInvokeEvents(DataGridColumn column, DataGridRow row);
    internal void RaiseAutomationSelectionEvents(SelectionChangedEventArgs e);
    private void AddSelectedCells(List`1<IRawElementProviderSimple> cellProviders);
    private void AddSelectedRows(List`1<IRawElementProviderSimple> itemProviders);
}
public class System.Windows.Automation.Peers.DataGridCellAutomationPeer : FrameworkElementAutomationPeer {
    public DataGridCellAutomationPeer(DataGridCell owner);
    protected virtual AutomationControlType GetAutomationControlTypeCore();
    protected virtual string GetClassNameCore();
}
public class System.Windows.Automation.Peers.DataGridCellItemAutomationPeer : AutomationPeer {
    private WeakReference _item;
    private DataGridColumn _column;
    private int System.Windows.Automation.Provider.IGridItemProvider.Column { get; }
    private int System.Windows.Automation.Provider.IGridItemProvider.ColumnSpan { get; }
    private IRawElementProviderSimple System.Windows.Automation.Provider.IGridItemProvider.ContainingGrid { get; }
    private int System.Windows.Automation.Provider.IGridItemProvider.Row { get; }
    private int System.Windows.Automation.Provider.IGridItemProvider.RowSpan { get; }
    private bool System.Windows.Automation.Provider.ISelectionItemProvider.IsSelected { get; }
    private IRawElementProviderSimple System.Windows.Automation.Provider.ISelectionItemProvider.SelectionContainer { get; }
    private bool System.Windows.Automation.Provider.IValueProvider.IsReadOnly { get; }
    private string System.Windows.Automation.Provider.IValueProvider.Value { get; }
    private bool IsCellSelectionUnit { get; }
    private bool IsNewItemPlaceholder { get; }
    private DataGrid OwningDataGrid { get; }
    private DataGridCell OwningCell { get; }
    internal DataGridCellAutomationPeer OwningCellPeer { get; }
    private IRawElementProviderSimple ContainingGrid { get; }
    internal DataGridColumn Column { get; }
    internal object Item { get; }
    private DataGridItemAutomationPeer OwningItemPeer { get; }
    internal bool AncestorsInvalid { get; internal set; }
    public DataGridCellItemAutomationPeer(object item, DataGridColumn dataGridColumn);
    protected virtual string GetAcceleratorKeyCore();
    protected virtual string GetAccessKeyCore();
    protected virtual AutomationControlType GetAutomationControlTypeCore();
    protected virtual string GetAutomationIdCore();
    protected virtual Rect GetBoundingRectangleCore();
    protected virtual List`1<AutomationPeer> GetChildrenCore();
    protected virtual string GetClassNameCore();
    protected virtual Point GetClickablePointCore();
    protected virtual string GetHelpTextCore();
    protected virtual string GetItemStatusCore();
    protected virtual string GetItemTypeCore();
    protected virtual AutomationPeer GetLabeledByCore();
    protected virtual string GetLocalizedControlTypeCore();
    protected virtual AutomationLiveSetting GetLiveSettingCore();
    protected virtual string GetNameCore();
    protected virtual AutomationOrientation GetOrientationCore();
    public virtual object GetPattern(PatternInterface patternInterface);
    protected virtual int GetPositionInSetCore();
    protected virtual int GetSizeOfSetCore();
    internal virtual Rect GetVisibleBoundingRectCore();
    protected virtual bool HasKeyboardFocusCore();
    protected virtual bool IsContentElementCore();
    protected virtual bool IsControlElementCore();
    protected virtual bool IsEnabledCore();
    protected virtual bool IsKeyboardFocusableCore();
    protected virtual bool IsOffscreenCore();
    protected virtual bool IsPasswordCore();
    protected virtual bool IsRequiredForFormCore();
    protected virtual void SetFocusCore();
    internal virtual bool IsDataItemAutomationPeer();
    internal virtual void AddToParentProxyWeakRefCache();
    private sealed virtual override int System.Windows.Automation.Provider.IGridItemProvider.get_Column();
    private sealed virtual override int System.Windows.Automation.Provider.IGridItemProvider.get_ColumnSpan();
    private sealed virtual override IRawElementProviderSimple System.Windows.Automation.Provider.IGridItemProvider.get_ContainingGrid();
    private sealed virtual override int System.Windows.Automation.Provider.IGridItemProvider.get_Row();
    private sealed virtual override int System.Windows.Automation.Provider.IGridItemProvider.get_RowSpan();
    private sealed virtual override IRawElementProviderSimple[] System.Windows.Automation.Provider.ITableItemProvider.GetColumnHeaderItems();
    private sealed virtual override IRawElementProviderSimple[] System.Windows.Automation.Provider.ITableItemProvider.GetRowHeaderItems();
    private sealed virtual override void System.Windows.Automation.Provider.IInvokeProvider.Invoke();
    private sealed virtual override void System.Windows.Automation.Provider.IScrollItemProvider.ScrollIntoView();
    private sealed virtual override bool System.Windows.Automation.Provider.ISelectionItemProvider.get_IsSelected();
    private sealed virtual override IRawElementProviderSimple System.Windows.Automation.Provider.ISelectionItemProvider.get_SelectionContainer();
    private sealed virtual override void System.Windows.Automation.Provider.ISelectionItemProvider.AddToSelection();
    private sealed virtual override void System.Windows.Automation.Provider.ISelectionItemProvider.RemoveFromSelection();
    private sealed virtual override void System.Windows.Automation.Provider.ISelectionItemProvider.Select();
    private sealed virtual override bool System.Windows.Automation.Provider.IValueProvider.get_IsReadOnly();
    private sealed virtual override void System.Windows.Automation.Provider.IValueProvider.SetValue(string value);
    private sealed virtual override string System.Windows.Automation.Provider.IValueProvider.get_Value();
    private sealed virtual override void System.Windows.Automation.Provider.IVirtualizedItemProvider.Realize();
    private void EnsureEnabled();
    private void ThrowElementNotAvailableException();
    private bool IsItemInAutomationTree();
    private bool get_IsCellSelectionUnit();
    private bool get_IsNewItemPlaceholder();
    private DataGrid get_OwningDataGrid();
    private DataGridCell get_OwningCell();
    internal DataGridCellAutomationPeer get_OwningCellPeer();
    private IRawElementProviderSimple get_ContainingGrid();
    internal DataGridColumn get_Column();
    internal object get_Item();
    private DataGridItemAutomationPeer get_OwningItemPeer();
    internal virtual bool get_AncestorsInvalid();
    internal virtual void set_AncestorsInvalid(bool value);
}
public class System.Windows.Automation.Peers.DataGridColumnHeaderAutomationPeer : ButtonBaseAutomationPeer {
    public DataGridColumnHeaderAutomationPeer(DataGridColumnHeader owner);
    protected virtual AutomationControlType GetAutomationControlTypeCore();
    protected virtual string GetClassNameCore();
    protected virtual bool IsContentElementCore();
}
public class System.Windows.Automation.Peers.DataGridColumnHeaderItemAutomationPeer : ItemAutomationPeer {
    private DataGridColumn _column;
    private bool System.Windows.Automation.Provider.ITransformProvider.CanMove { get; }
    private bool System.Windows.Automation.Provider.ITransformProvider.CanResize { get; }
    private bool System.Windows.Automation.Provider.ITransformProvider.CanRotate { get; }
    internal bool AncestorsInvalid { get; internal set; }
    internal DataGridColumnHeader OwningHeader { get; }
    internal DataGrid OwningDataGrid { get; }
    internal DataGridColumn Column { get; }
    internal DataGridColumnHeaderAutomationPeer OwningColumnHeaderPeer { get; }
    public DataGridColumnHeaderItemAutomationPeer(object item, DataGridColumn column, DataGridColumnHeadersPresenterAutomationPeer peer);
    protected virtual AutomationControlType GetAutomationControlTypeCore();
    protected virtual string GetClassNameCore();
    public virtual object GetPattern(PatternInterface patternInterface);
    protected virtual bool IsContentElementCore();
    private sealed virtual override void System.Windows.Automation.Provider.IInvokeProvider.Invoke();
    private sealed virtual override void System.Windows.Automation.Provider.IScrollItemProvider.ScrollIntoView();
    private sealed virtual override bool System.Windows.Automation.Provider.ITransformProvider.get_CanMove();
    private sealed virtual override bool System.Windows.Automation.Provider.ITransformProvider.get_CanResize();
    private sealed virtual override bool System.Windows.Automation.Provider.ITransformProvider.get_CanRotate();
    private sealed virtual override void System.Windows.Automation.Provider.ITransformProvider.Move(double x, double y);
    private sealed virtual override void System.Windows.Automation.Provider.ITransformProvider.Resize(double width, double height);
    private sealed virtual override void System.Windows.Automation.Provider.ITransformProvider.Rotate(double degrees);
    private sealed virtual override void System.Windows.Automation.Provider.IVirtualizedItemProvider.Realize();
    internal virtual bool get_AncestorsInvalid();
    internal virtual void set_AncestorsInvalid(bool value);
    internal DataGridColumnHeader get_OwningHeader();
    internal DataGrid get_OwningDataGrid();
    internal DataGridColumn get_Column();
    internal DataGridColumnHeaderAutomationPeer get_OwningColumnHeaderPeer();
}
public class System.Windows.Automation.Peers.DataGridColumnHeadersPresenterAutomationPeer : ItemsControlAutomationPeer {
    private DataGrid OwningDataGrid { get; }
    public DataGridColumnHeadersPresenterAutomationPeer(DataGridColumnHeadersPresenter owner);
    protected virtual AutomationControlType GetAutomationControlTypeCore();
    protected virtual string GetClassNameCore();
    protected virtual List`1<AutomationPeer> GetChildrenCore();
    private sealed virtual override IRawElementProviderSimple System.Windows.Automation.Provider.IItemContainerProvider.FindItemByProperty(IRawElementProviderSimple startAfter, int propertyId, object value);
    protected virtual bool IsContentElementCore();
    protected virtual ItemAutomationPeer CreateItemAutomationPeer(object column);
    private DataGrid get_OwningDataGrid();
}
public class System.Windows.Automation.Peers.DataGridDetailsPresenterAutomationPeer : FrameworkElementAutomationPeer {
    public DataGridDetailsPresenterAutomationPeer(DataGridDetailsPresenter owner);
    protected virtual string GetClassNameCore();
}
public class System.Windows.Automation.Peers.DataGridItemAutomationPeer : ItemAutomationPeer {
    private AutomationPeer _dataGridAutomationPeer;
    private ItemPeersStorage`1<DataGridCellItemAutomationPeer> _dataChildren;
    private ItemPeersStorage`1<WeakReference> _weakRefElementProxyStorage;
    private bool System.Windows.Automation.Provider.ISelectionItemProvider.IsSelected { get; }
    private IRawElementProviderSimple System.Windows.Automation.Provider.ISelectionItemProvider.SelectionContainer { get; }
    private bool System.Windows.Automation.Provider.ISelectionProvider.CanSelectMultiple { get; }
    private bool System.Windows.Automation.Provider.ISelectionProvider.IsSelectionRequired { get; }
    private bool IsRowSelectionUnit { get; }
    private bool IsNewItemPlaceholder { get; }
    internal AutomationPeer RowHeaderAutomationPeer { get; }
    private DataGrid OwningDataGrid { get; }
    private ItemPeersStorage`1<DataGridCellItemAutomationPeer> CellItemPeers { get; private set; }
    private ItemPeersStorage`1<WeakReference> WeakRefElementProxyStorage { get; }
    public DataGridItemAutomationPeer(object item, DataGridAutomationPeer dataGridPeer);
    protected virtual AutomationControlType GetAutomationControlTypeCore();
    protected virtual List`1<AutomationPeer> GetChildrenCore();
    protected virtual string GetClassNameCore();
    public virtual object GetPattern(PatternInterface patternInterface);
    protected virtual AutomationPeer GetPeerFromPointCore(Point point);
    private sealed virtual override IRawElementProviderSimple System.Windows.Automation.Provider.IItemContainerProvider.FindItemByProperty(IRawElementProviderSimple startAfter, int propertyId, object value);
    private sealed virtual override void System.Windows.Automation.Provider.IInvokeProvider.Invoke();
    private sealed virtual override void System.Windows.Automation.Provider.IScrollItemProvider.ScrollIntoView();
    private sealed virtual override bool System.Windows.Automation.Provider.ISelectionItemProvider.get_IsSelected();
    private sealed virtual override IRawElementProviderSimple System.Windows.Automation.Provider.ISelectionItemProvider.get_SelectionContainer();
    private sealed virtual override void System.Windows.Automation.Provider.ISelectionItemProvider.AddToSelection();
    private sealed virtual override void System.Windows.Automation.Provider.ISelectionItemProvider.RemoveFromSelection();
    private sealed virtual override void System.Windows.Automation.Provider.ISelectionItemProvider.Select();
    private sealed virtual override bool System.Windows.Automation.Provider.ISelectionProvider.get_CanSelectMultiple();
    private sealed virtual override bool System.Windows.Automation.Provider.ISelectionProvider.get_IsSelectionRequired();
    private sealed virtual override IRawElementProviderSimple[] System.Windows.Automation.Provider.ISelectionProvider.GetSelection();
    internal List`1<AutomationPeer> GetCellItemPeers();
    internal DataGridCellItemAutomationPeer GetOrCreateCellItemPeer(DataGridColumn column);
    private DataGridCellItemAutomationPeer GetOrCreateCellItemPeer(DataGridColumn column, bool addParentInfo);
    private DataGridCellItemAutomationPeer GetPeerFromWeakRefStorage(object column);
    internal void AddProxyToWeakRefStorage(WeakReference wr, DataGridCellItemAutomationPeer cellItemPeer);
    private void EnsureEnabled();
    private bool get_IsRowSelectionUnit();
    private bool get_IsNewItemPlaceholder();
    internal AutomationPeer get_RowHeaderAutomationPeer();
    private DataGrid get_OwningDataGrid();
    private ItemPeersStorage`1<DataGridCellItemAutomationPeer> get_CellItemPeers();
    private void set_CellItemPeers(ItemPeersStorage`1<DataGridCellItemAutomationPeer> value);
    private ItemPeersStorage`1<WeakReference> get_WeakRefElementProxyStorage();
}
public class System.Windows.Automation.Peers.DataGridRowAutomationPeer : FrameworkElementAutomationPeer {
    internal AutomationPeer RowHeaderAutomationPeer { get; }
    private AutomationPeer DetailsPresenterAutomationPeer { get; }
    private DataGridRow OwningDataGridRow { get; }
    public DataGridRowAutomationPeer(DataGridRow owner);
    protected virtual AutomationControlType GetAutomationControlTypeCore();
    protected virtual string GetClassNameCore();
    protected virtual List`1<AutomationPeer> GetChildrenCore();
    internal AutomationPeer get_RowHeaderAutomationPeer();
    private AutomationPeer get_DetailsPresenterAutomationPeer();
    private DataGridRow get_OwningDataGridRow();
}
public class System.Windows.Automation.Peers.DataGridRowHeaderAutomationPeer : ButtonBaseAutomationPeer {
    public DataGridRowHeaderAutomationPeer(DataGridRowHeader owner);
    protected virtual AutomationControlType GetAutomationControlTypeCore();
    protected virtual string GetClassNameCore();
    protected virtual bool IsContentElementCore();
}
public class System.Windows.Automation.Peers.DatePickerAutomationPeer : FrameworkElementAutomationPeer {
    private DatePicker OwningDatePicker { get; }
    private ExpandCollapseState System.Windows.Automation.Provider.IExpandCollapseProvider.ExpandCollapseState { get; }
    private bool System.Windows.Automation.Provider.IValueProvider.IsReadOnly { get; }
    private string System.Windows.Automation.Provider.IValueProvider.Value { get; }
    public DatePickerAutomationPeer(DatePicker owner);
    private DatePicker get_OwningDatePicker();
    public virtual object GetPattern(PatternInterface patternInterface);
    protected virtual void SetFocusCore();
    protected virtual AutomationControlType GetAutomationControlTypeCore();
    protected virtual List`1<AutomationPeer> GetChildrenCore();
    protected virtual string GetClassNameCore();
    protected virtual string GetLocalizedControlTypeCore();
    private sealed virtual override ExpandCollapseState System.Windows.Automation.Provider.IExpandCollapseProvider.get_ExpandCollapseState();
    private sealed virtual override void System.Windows.Automation.Provider.IExpandCollapseProvider.Collapse();
    private sealed virtual override void System.Windows.Automation.Provider.IExpandCollapseProvider.Expand();
    private sealed virtual override bool System.Windows.Automation.Provider.IValueProvider.get_IsReadOnly();
    private sealed virtual override string System.Windows.Automation.Provider.IValueProvider.get_Value();
    private sealed virtual override void System.Windows.Automation.Provider.IValueProvider.SetValue(string value);
    internal void RaiseValuePropertyChangedEvent(string oldValue, string newValue);
}
public class System.Windows.Automation.Peers.DateTimeAutomationPeer : AutomationPeer {
    [CompilerGeneratedAttribute]
private Calendar <OwningCalendar>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <Date>k__BackingField;
    [CompilerGeneratedAttribute]
private CalendarMode <ButtonMode>k__BackingField;
    internal bool AncestorsInvalid { get; internal set; }
    private Calendar OwningCalendar { get; private set; }
    internal DateTime Date { get; private set; }
    internal CalendarMode ButtonMode { get; private set; }
    internal bool IsDayButton { get; }
    private IRawElementProviderSimple OwningCalendarProvider { get; }
    internal Button OwningButton { get; }
    internal FrameworkElementAutomationPeer WrapperPeer { get; }
    private int System.Windows.Automation.Provider.IGridItemProvider.Column { get; }
    private int System.Windows.Automation.Provider.IGridItemProvider.ColumnSpan { get; }
    private IRawElementProviderSimple System.Windows.Automation.Provider.IGridItemProvider.ContainingGrid { get; }
    private int System.Windows.Automation.Provider.IGridItemProvider.Row { get; }
    private int System.Windows.Automation.Provider.IGridItemProvider.RowSpan { get; }
    private bool System.Windows.Automation.Provider.ISelectionItemProvider.IsSelected { get; }
    private IRawElementProviderSimple System.Windows.Automation.Provider.ISelectionItemProvider.SelectionContainer { get; }
    internal DateTimeAutomationPeer(DateTime date, Calendar owningCalendar, CalendarMode buttonMode);
    internal virtual bool get_AncestorsInvalid();
    internal virtual void set_AncestorsInvalid(bool value);
    [CompilerGeneratedAttribute]
private Calendar get_OwningCalendar();
    [CompilerGeneratedAttribute]
private void set_OwningCalendar(Calendar value);
    [CompilerGeneratedAttribute]
internal DateTime get_Date();
    [CompilerGeneratedAttribute]
private void set_Date(DateTime value);
    [CompilerGeneratedAttribute]
internal CalendarMode get_ButtonMode();
    [CompilerGeneratedAttribute]
private void set_ButtonMode(CalendarMode value);
    internal bool get_IsDayButton();
    private IRawElementProviderSimple get_OwningCalendarProvider();
    internal Button get_OwningButton();
    internal FrameworkElementAutomationPeer get_WrapperPeer();
    protected virtual string GetAcceleratorKeyCore();
    protected virtual string GetAccessKeyCore();
    protected virtual AutomationControlType GetAutomationControlTypeCore();
    protected virtual string GetAutomationIdCore();
    protected virtual Rect GetBoundingRectangleCore();
    protected virtual List`1<AutomationPeer> GetChildrenCore();
    protected virtual string GetClassNameCore();
    protected virtual Point GetClickablePointCore();
    protected virtual string GetHelpTextCore();
    protected virtual string GetItemStatusCore();
    protected virtual string GetItemTypeCore();
    protected virtual AutomationPeer GetLabeledByCore();
    protected virtual AutomationLiveSetting GetLiveSettingCore();
    protected virtual string GetLocalizedControlTypeCore();
    protected virtual string GetNameCore();
    protected virtual AutomationOrientation GetOrientationCore();
    public virtual object GetPattern(PatternInterface patternInterface);
    protected virtual int GetPositionInSetCore();
    protected virtual int GetSizeOfSetCore();
    internal virtual Rect GetVisibleBoundingRectCore();
    protected virtual bool HasKeyboardFocusCore();
    protected virtual bool IsContentElementCore();
    protected virtual bool IsControlElementCore();
    protected virtual bool IsEnabledCore();
    protected virtual bool IsKeyboardFocusableCore();
    protected virtual bool IsOffscreenCore();
    protected virtual bool IsPasswordCore();
    protected virtual bool IsRequiredForFormCore();
    protected virtual void SetFocusCore();
    private sealed virtual override int System.Windows.Automation.Provider.IGridItemProvider.get_Column();
    private sealed virtual override int System.Windows.Automation.Provider.IGridItemProvider.get_ColumnSpan();
    private sealed virtual override IRawElementProviderSimple System.Windows.Automation.Provider.IGridItemProvider.get_ContainingGrid();
    private sealed virtual override int System.Windows.Automation.Provider.IGridItemProvider.get_Row();
    private sealed virtual override int System.Windows.Automation.Provider.IGridItemProvider.get_RowSpan();
    private sealed virtual override bool System.Windows.Automation.Provider.ISelectionItemProvider.get_IsSelected();
    private sealed virtual override IRawElementProviderSimple System.Windows.Automation.Provider.ISelectionItemProvider.get_SelectionContainer();
    private sealed virtual override void System.Windows.Automation.Provider.ISelectionItemProvider.AddToSelection();
    private sealed virtual override void System.Windows.Automation.Provider.ISelectionItemProvider.RemoveFromSelection();
    private sealed virtual override void System.Windows.Automation.Provider.ISelectionItemProvider.Select();
    private sealed virtual override IRawElementProviderSimple[] System.Windows.Automation.Provider.ITableItemProvider.GetColumnHeaderItems();
    private sealed virtual override IRawElementProviderSimple[] System.Windows.Automation.Provider.ITableItemProvider.GetRowHeaderItems();
    private sealed virtual override void System.Windows.Automation.Provider.IInvokeProvider.Invoke();
    private sealed virtual override void System.Windows.Automation.Provider.IVirtualizedItemProvider.Realize();
    internal virtual bool IsDataItemAutomationPeer();
    internal virtual void AddToParentProxyWeakRefCache();
    private bool EnsureSelection();
    private bool IsItemInAutomationTree();
    private void ThrowElementNotAvailableException();
}
internal class System.Windows.Automation.Peers.DateTimeCalendarModePair : ValueType {
    private CalendarMode ButtonMode;
    private DateTime Date;
    internal DateTimeCalendarModePair(DateTime date, CalendarMode mode);
}
public class System.Windows.Automation.Peers.DocumentAutomationPeer : ContentTextAutomationPeer {
    private ITextPointer _childrenStart;
    private ITextPointer _childrenEnd;
    private TextAdaptor _textPattern;
    private ITextContainer _textContainer;
    public DocumentAutomationPeer(FrameworkContentElement owner);
    internal void OnDisconnected();
    protected virtual List`1<AutomationPeer> GetChildrenCore();
    public virtual object GetPattern(PatternInterface patternInterface);
    protected virtual AutomationControlType GetAutomationControlTypeCore();
    protected virtual string GetClassNameCore();
    protected virtual bool IsControlElementCore();
    protected virtual Rect GetBoundingRectangleCore();
    protected virtual Point GetClickablePointCore();
    protected virtual bool IsOffscreenCore();
    internal virtual List`1<AutomationPeer> GetAutomationPeersFromRange(ITextPointer start, ITextPointer end);
    private Rect CalculateBoundingRect(bool clipToVisible, UIElement& uiScope);
}
public class System.Windows.Automation.Peers.DocumentPageViewAutomationPeer : FrameworkElementAutomationPeer {
    public DocumentPageViewAutomationPeer(DocumentPageView owner);
    protected virtual List`1<AutomationPeer> GetChildrenCore();
    protected virtual string GetAutomationIdCore();
}
public class System.Windows.Automation.Peers.DocumentViewerAutomationPeer : DocumentViewerBaseAutomationPeer {
    public DocumentViewerAutomationPeer(DocumentViewer owner);
    protected virtual string GetClassNameCore();
    public virtual object GetPattern(PatternInterface patternInterface);
}
public class System.Windows.Automation.Peers.DocumentViewerBaseAutomationPeer : FrameworkElementAutomationPeer {
    private DocumentAutomationPeer _documentPeer;
    public DocumentViewerBaseAutomationPeer(DocumentViewerBase owner);
    public virtual object GetPattern(PatternInterface patternInterface);
    protected virtual List`1<AutomationPeer> GetChildrenCore();
    protected virtual AutomationControlType GetAutomationControlTypeCore();
    protected virtual string GetClassNameCore();
    private AutomationPeer GetDocumentAutomationPeer();
}
public class System.Windows.Automation.Peers.ExpanderAutomationPeer : FrameworkElementAutomationPeer {
    private ExpandCollapseState System.Windows.Automation.Provider.IExpandCollapseProvider.ExpandCollapseState { get; }
    public ExpanderAutomationPeer(Expander owner);
    protected virtual string GetClassNameCore();
    protected virtual AutomationControlType GetAutomationControlTypeCore();
    protected virtual List`1<AutomationPeer> GetChildrenCore();
    protected virtual bool HasKeyboardFocusCore();
    public virtual object GetPattern(PatternInterface pattern);
    private sealed virtual override void System.Windows.Automation.Provider.IExpandCollapseProvider.Expand();
    private sealed virtual override void System.Windows.Automation.Provider.IExpandCollapseProvider.Collapse();
    private sealed virtual override ExpandCollapseState System.Windows.Automation.Provider.IExpandCollapseProvider.get_ExpandCollapseState();
    internal void RaiseExpandCollapseAutomationEvent(bool oldValue, bool newValue);
}
public class System.Windows.Automation.Peers.FixedPageAutomationPeer : FrameworkElementAutomationPeer {
    public FixedPageAutomationPeer(FixedPage owner);
    protected virtual string GetClassNameCore();
    protected virtual AutomationControlType GetAutomationControlTypeCore();
}
public class System.Windows.Automation.Peers.FlowDocumentPageViewerAutomationPeer : DocumentViewerBaseAutomationPeer {
    public FlowDocumentPageViewerAutomationPeer(FlowDocumentPageViewer owner);
    protected virtual List`1<AutomationPeer> GetChildrenCore();
    protected virtual string GetClassNameCore();
}
public class System.Windows.Automation.Peers.FlowDocumentReaderAutomationPeer : FrameworkElementAutomationPeer {
    private DocumentAutomationPeer _documentPeer;
    private FlowDocumentReader FlowDocumentReader { get; }
    private int System.Windows.Automation.Provider.IMultipleViewProvider.CurrentView { get; }
    public FlowDocumentReaderAutomationPeer(FlowDocumentReader owner);
    public virtual object GetPattern(PatternInterface patternInterface);
    protected virtual List`1<AutomationPeer> GetChildrenCore();
    protected virtual string GetClassNameCore();
    internal void RaiseCurrentViewChangedEvent(FlowDocumentReaderViewingMode newMode, FlowDocumentReaderViewingMode oldMode);
    internal void RaiseSupportedViewsChangedEvent(DependencyPropertyChangedEventArgs e);
    private Int32[] GetSupportedViews(bool single, bool facing, bool scroll);
    private int ConvertModeToViewId(FlowDocumentReaderViewingMode mode);
    private FlowDocumentReaderViewingMode ConvertViewIdToMode(int viewId);
    private FlowDocumentReader get_FlowDocumentReader();
    private sealed virtual override string System.Windows.Automation.Provider.IMultipleViewProvider.GetViewName(int viewId);
    private sealed virtual override void System.Windows.Automation.Provider.IMultipleViewProvider.SetCurrentView(int viewId);
    private sealed virtual override int System.Windows.Automation.Provider.IMultipleViewProvider.get_CurrentView();
    private sealed virtual override Int32[] System.Windows.Automation.Provider.IMultipleViewProvider.GetSupportedViews();
}
public class System.Windows.Automation.Peers.FlowDocumentScrollViewerAutomationPeer : FrameworkElementAutomationPeer {
    private DocumentAutomationPeer _documentPeer;
    public FlowDocumentScrollViewerAutomationPeer(FlowDocumentScrollViewer owner);
    public virtual object GetPattern(PatternInterface patternInterface);
    protected virtual List`1<AutomationPeer> GetChildrenCore();
    protected virtual AutomationControlType GetAutomationControlTypeCore();
    protected virtual string GetClassNameCore();
}
public class System.Windows.Automation.Peers.FrameAutomationPeer : FrameworkElementAutomationPeer {
    public FrameAutomationPeer(Frame owner);
    protected virtual string GetClassNameCore();
    protected virtual AutomationControlType GetAutomationControlTypeCore();
}
public class System.Windows.Automation.Peers.FrameworkContentElementAutomationPeer : ContentElementAutomationPeer {
    public FrameworkContentElementAutomationPeer(FrameworkContentElement owner);
    protected virtual string GetAutomationIdCore();
    protected virtual string GetHelpTextCore();
    protected virtual AutomationPeer GetLabeledByCore();
}
public class System.Windows.Automation.Peers.FrameworkElementAutomationPeer : UIElementAutomationPeer {
    public FrameworkElementAutomationPeer(FrameworkElement owner);
    protected virtual string GetAutomationIdCore();
    protected virtual string GetNameCore();
    protected virtual string GetHelpTextCore();
    internal virtual bool IgnoreUpdatePeer();
}
public class System.Windows.Automation.Peers.GridSplitterAutomationPeer : ThumbAutomationPeer {
    private bool System.Windows.Automation.Provider.ITransformProvider.CanMove { get; }
    private bool System.Windows.Automation.Provider.ITransformProvider.CanResize { get; }
    private bool System.Windows.Automation.Provider.ITransformProvider.CanRotate { get; }
    public GridSplitterAutomationPeer(GridSplitter owner);
    protected virtual string GetClassNameCore();
    public virtual object GetPattern(PatternInterface patternInterface);
    private sealed virtual override bool System.Windows.Automation.Provider.ITransformProvider.get_CanMove();
    private sealed virtual override bool System.Windows.Automation.Provider.ITransformProvider.get_CanResize();
    private sealed virtual override bool System.Windows.Automation.Provider.ITransformProvider.get_CanRotate();
    private sealed virtual override void System.Windows.Automation.Provider.ITransformProvider.Move(double x, double y);
    private sealed virtual override void System.Windows.Automation.Provider.ITransformProvider.Resize(double width, double height);
    private sealed virtual override void System.Windows.Automation.Provider.ITransformProvider.Rotate(double degrees);
}
public class System.Windows.Automation.Peers.GridViewAutomationPeer : object {
    private GridView _owner;
    private ListView _listview;
    private int _oldItemsCount;
    private int _oldColumnsCount;
    private RowOrColumnMajor System.Windows.Automation.Provider.ITableProvider.RowOrColumnMajor { get; }
    private int System.Windows.Automation.Provider.IGridProvider.ColumnCount { get; }
    private int System.Windows.Automation.Provider.IGridProvider.RowCount { get; }
    public GridViewAutomationPeer(GridView owner, ListView listview);
    private sealed virtual override AutomationControlType System.Windows.Automation.Peers.IViewAutomationPeer.GetAutomationControlType();
    private sealed virtual override object System.Windows.Automation.Peers.IViewAutomationPeer.GetPattern(PatternInterface patternInterface);
    private sealed virtual override List`1<AutomationPeer> System.Windows.Automation.Peers.IViewAutomationPeer.GetChildren(List`1<AutomationPeer> children);
    private sealed virtual override ItemAutomationPeer System.Windows.Automation.Peers.IViewAutomationPeer.CreateItemAutomationPeer(object item);
    private sealed virtual override void System.Windows.Automation.Peers.IViewAutomationPeer.ItemsChanged(NotifyCollectionChangedEventArgs e);
    private sealed virtual override void System.Windows.Automation.Peers.IViewAutomationPeer.ViewDetached();
    private sealed virtual override RowOrColumnMajor System.Windows.Automation.Provider.ITableProvider.get_RowOrColumnMajor();
    private sealed virtual override IRawElementProviderSimple[] System.Windows.Automation.Provider.ITableProvider.GetColumnHeaders();
    private sealed virtual override IRawElementProviderSimple[] System.Windows.Automation.Provider.ITableProvider.GetRowHeaders();
    private sealed virtual override int System.Windows.Automation.Provider.IGridProvider.get_ColumnCount();
    private sealed virtual override int System.Windows.Automation.Provider.IGridProvider.get_RowCount();
    private sealed virtual override IRawElementProviderSimple System.Windows.Automation.Provider.IGridProvider.GetItem(int row, int column);
    private void OnColumnCollectionChanged(object sender, NotifyCollectionChangedEventArgs e);
    internal static Visual FindVisualByType(Visual parent, Type type);
}
public class System.Windows.Automation.Peers.GridViewCellAutomationPeer : FrameworkElementAutomationPeer {
    private ListViewAutomationPeer _listviewAP;
    private int _column;
    private int _row;
    internal int Column { get; internal set; }
    internal int Row { get; internal set; }
    private int System.Windows.Automation.Provider.IGridItemProvider.Row { get; }
    private int System.Windows.Automation.Provider.IGridItemProvider.Column { get; }
    private int System.Windows.Automation.Provider.IGridItemProvider.RowSpan { get; }
    private int System.Windows.Automation.Provider.IGridItemProvider.ColumnSpan { get; }
    private IRawElementProviderSimple System.Windows.Automation.Provider.IGridItemProvider.ContainingGrid { get; }
    internal GridViewCellAutomationPeer(ContentPresenter owner, ListViewAutomationPeer parent);
    internal GridViewCellAutomationPeer(TextBlock owner, ListViewAutomationPeer parent);
    protected virtual string GetClassNameCore();
    protected virtual AutomationControlType GetAutomationControlTypeCore();
    public virtual object GetPattern(PatternInterface patternInterface);
    protected virtual bool IsControlElementCore();
    internal int get_Column();
    internal void set_Column(int value);
    internal int get_Row();
    internal void set_Row(int value);
    private sealed virtual override IRawElementProviderSimple[] System.Windows.Automation.Provider.ITableItemProvider.GetRowHeaderItems();
    private sealed virtual override IRawElementProviderSimple[] System.Windows.Automation.Provider.ITableItemProvider.GetColumnHeaderItems();
    private sealed virtual override int System.Windows.Automation.Provider.IGridItemProvider.get_Row();
    private sealed virtual override int System.Windows.Automation.Provider.IGridItemProvider.get_Column();
    private sealed virtual override int System.Windows.Automation.Provider.IGridItemProvider.get_RowSpan();
    private sealed virtual override int System.Windows.Automation.Provider.IGridItemProvider.get_ColumnSpan();
    private sealed virtual override IRawElementProviderSimple System.Windows.Automation.Provider.IGridItemProvider.get_ContainingGrid();
    private List`1<AutomationPeer> GetChildrenAutomationPeer(Visual parent, bool includeInvisibleItems);
    private static bool iterate(Visual parent, bool includeInvisibleItems, IteratorCallback callback);
}
public class System.Windows.Automation.Peers.GridViewColumnHeaderAutomationPeer : FrameworkElementAutomationPeer {
    private bool System.Windows.Automation.Provider.ITransformProvider.CanMove { get; }
    private bool System.Windows.Automation.Provider.ITransformProvider.CanResize { get; }
    private bool System.Windows.Automation.Provider.ITransformProvider.CanRotate { get; }
    public GridViewColumnHeaderAutomationPeer(GridViewColumnHeader owner);
    protected virtual AutomationControlType GetAutomationControlTypeCore();
    protected virtual bool IsContentElementCore();
    protected virtual string GetClassNameCore();
    public virtual object GetPattern(PatternInterface patternInterface);
    private sealed virtual override void System.Windows.Automation.Provider.IInvokeProvider.Invoke();
    private sealed virtual override bool System.Windows.Automation.Provider.ITransformProvider.get_CanMove();
    private sealed virtual override bool System.Windows.Automation.Provider.ITransformProvider.get_CanResize();
    private sealed virtual override bool System.Windows.Automation.Provider.ITransformProvider.get_CanRotate();
    private sealed virtual override void System.Windows.Automation.Provider.ITransformProvider.Move(double x, double y);
    private sealed virtual override void System.Windows.Automation.Provider.ITransformProvider.Resize(double width, double height);
    private sealed virtual override void System.Windows.Automation.Provider.ITransformProvider.Rotate(double degrees);
}
public class System.Windows.Automation.Peers.GridViewHeaderRowPresenterAutomationPeer : FrameworkElementAutomationPeer {
    public GridViewHeaderRowPresenterAutomationPeer(GridViewHeaderRowPresenter owner);
    protected virtual string GetClassNameCore();
    protected virtual AutomationControlType GetAutomationControlTypeCore();
    protected virtual bool IsContentElementCore();
    protected virtual List`1<AutomationPeer> GetChildrenCore();
}
public class System.Windows.Automation.Peers.GridViewItemAutomationPeer : ListBoxItemAutomationPeer {
    private ListViewAutomationPeer _listviewAP;
    private Hashtable _dataChildren;
    public GridViewItemAutomationPeer(object owner, ListViewAutomationPeer listviewAP);
    protected virtual string GetClassNameCore();
    protected virtual AutomationControlType GetAutomationControlTypeCore();
    protected virtual List`1<AutomationPeer> GetChildrenCore();
}
public class System.Windows.Automation.Peers.GroupBoxAutomationPeer : FrameworkElementAutomationPeer {
    public GroupBoxAutomationPeer(GroupBox owner);
    protected virtual string GetClassNameCore();
    protected virtual AutomationControlType GetAutomationControlTypeCore();
    protected virtual string GetNameCore();
}
public class System.Windows.Automation.Peers.GroupItemAutomationPeer : FrameworkElementAutomationPeer {
    private AutomationPeer _expanderPeer;
    public GroupItemAutomationPeer(GroupItem owner);
    protected virtual string GetClassNameCore();
    protected virtual int GetPositionInSetCore();
    protected virtual int GetSizeOfSetCore();
    protected virtual AutomationControlType GetAutomationControlTypeCore();
    public virtual object GetPattern(PatternInterface patternInterface);
    protected virtual List`1<AutomationPeer> GetChildrenCore();
    internal void InvalidateGroupItemPeersContainingRecentlyRealizedPeers(List`1<ItemAutomationPeer> recentlyRealizedPeers);
    protected virtual void SetFocusCore();
    protected virtual bool IsKeyboardFocusableCore();
    protected virtual bool HasKeyboardFocusCore();
}
internal class System.Windows.Automation.Peers.HwndHostAutomationPeer : FrameworkElementAutomationPeer {
    private InteropAutomationProvider _interopProvider;
    public HwndHostAutomationPeer(HwndHost owner);
    protected virtual string GetClassNameCore();
    protected virtual AutomationControlType GetAutomationControlTypeCore();
    internal virtual InteropAutomationProvider GetInteropChild();
}
public class System.Windows.Automation.Peers.HyperlinkAutomationPeer : TextElementAutomationPeer {
    public HyperlinkAutomationPeer(Hyperlink owner);
    public virtual object GetPattern(PatternInterface patternInterface);
    protected virtual AutomationControlType GetAutomationControlTypeCore();
    protected virtual string GetNameCore();
    protected virtual string GetClassNameCore();
    protected virtual bool IsControlElementCore();
    private sealed virtual override void System.Windows.Automation.Provider.IInvokeProvider.Invoke();
}
public class System.Windows.Automation.Peers.ImageAutomationPeer : FrameworkElementAutomationPeer {
    public ImageAutomationPeer(Image owner);
    protected virtual string GetClassNameCore();
    protected virtual AutomationControlType GetAutomationControlTypeCore();
}
public class System.Windows.Automation.Peers.InkCanvasAutomationPeer : FrameworkElementAutomationPeer {
    public InkCanvasAutomationPeer(InkCanvas owner);
    protected virtual string GetClassNameCore();
    protected virtual AutomationControlType GetAutomationControlTypeCore();
}
public class System.Windows.Automation.Peers.InkPresenterAutomationPeer : FrameworkElementAutomationPeer {
    public InkPresenterAutomationPeer(InkPresenter owner);
    protected virtual string GetClassNameCore();
    protected virtual AutomationControlType GetAutomationControlTypeCore();
}
public abstract class System.Windows.Automation.Peers.ItemAutomationPeer : AutomationPeer {
    private object _item;
    private ItemsControlAutomationPeer _itemsControlAutomationPeer;
    internal bool AncestorsInvalid { get; internal set; }
    public object Item { get; private set; }
    private object RawItem { get; }
    public ItemsControlAutomationPeer ItemsControlAutomationPeer { get; internal set; }
    protected ItemAutomationPeer(object item, ItemsControlAutomationPeer itemsControlAutomationPeer);
    internal virtual bool get_AncestorsInvalid();
    internal virtual void set_AncestorsInvalid(bool value);
    public virtual object GetPattern(PatternInterface patternInterface);
    internal UIElement GetWrapper();
    internal virtual AutomationPeer GetWrapperPeer();
    internal void ThrowElementNotAvailableException();
    private bool IsItemInAutomationTree();
    internal virtual bool IgnoreUpdatePeer();
    internal virtual bool IsDataItemAutomationPeer();
    internal virtual void AddToParentProxyWeakRefCache();
    internal virtual Rect GetVisibleBoundingRectCore();
    protected virtual string GetItemTypeCore();
    protected virtual List`1<AutomationPeer> GetChildrenCore();
    protected virtual Rect GetBoundingRectangleCore();
    protected virtual bool IsOffscreenCore();
    protected virtual AutomationOrientation GetOrientationCore();
    protected virtual int GetPositionInSetCore();
    protected virtual int GetSizeOfSetCore();
    internal static int GetPositionInSetFromItemsControl(ItemsControl itemsControl, object item);
    internal static int GetSizeOfSetFromItemsControl(ItemsControl itemsControl, object item);
    private static int FindPositionInGroup(ReadOnlyObservableCollection`1<object> collection, int position, Int32& sizeOfGroup);
    protected virtual string GetItemStatusCore();
    protected virtual bool IsRequiredForFormCore();
    protected virtual bool IsKeyboardFocusableCore();
    protected virtual bool HasKeyboardFocusCore();
    protected virtual bool IsEnabledCore();
    protected virtual bool IsPasswordCore();
    protected virtual string GetAutomationIdCore();
    protected virtual string GetNameCore();
    protected virtual bool IsContentElementCore();
    protected virtual bool IsControlElementCore();
    protected virtual AutomationPeer GetLabeledByCore();
    protected virtual AutomationLiveSetting GetLiveSettingCore();
    protected virtual string GetHelpTextCore();
    protected virtual string GetAcceleratorKeyCore();
    protected virtual string GetAccessKeyCore();
    protected virtual Point GetClickablePointCore();
    protected virtual void SetFocusCore();
    internal virtual ItemsControlAutomationPeer GetItemsControlAutomationPeer();
    public object get_Item();
    private void set_Item(object value);
    private object get_RawItem();
    internal void ReuseForItem(object item);
    public ItemsControlAutomationPeer get_ItemsControlAutomationPeer();
    internal void set_ItemsControlAutomationPeer(ItemsControlAutomationPeer value);
    private sealed virtual override void System.Windows.Automation.Provider.IVirtualizedItemProvider.Realize();
    internal virtual void RealizeCore();
}
[DefaultMemberAttribute("Item")]
internal class System.Windows.Automation.Peers.ItemPeersStorage`1 : object {
    private WeakDictionary`2<object, T> _hashtable;
    private List`1<KeyValuePair`2<object, T>> _list;
    private int _count;
    private bool _usesHashCode;
    public T Item { get; public set; }
    public int Count { get; }
    public void Clear();
    public T get_Item(object item);
    public void set_Item(object item, T value);
    public void Remove(object item);
    public void PurgeWeakRefCollection();
    public int get_Count();
}
public abstract class System.Windows.Automation.Peers.ItemsControlAutomationPeer : FrameworkElementAutomationPeer {
    private ItemPeersStorage`1<ItemAutomationPeer> _dataChildren;
    private ItemPeersStorage`1<ItemAutomationPeer> _reusablePeers;
    private ItemPeersStorage`1<WeakReference> _WeakRefElementProxyStorage;
    private List`1<ItemAutomationPeer> _recentlyRealizedPeers;
    private RecyclableWrapper _recyclableWrapperCache;
    protected bool IsVirtualized { get; }
    internal ItemPeersStorage`1<ItemAutomationPeer> ItemPeers { get; internal set; }
    internal ItemPeersStorage`1<WeakReference> WeakRefElementProxyStorage { get; internal set; }
    internal List`1<ItemAutomationPeer> RecentlyRealizedPeers { get; }
    protected ItemsControlAutomationPeer(ItemsControl owner);
    public virtual object GetPattern(PatternInterface patternInterface);
    protected virtual List`1<AutomationPeer> GetChildrenCore();
    internal ItemAutomationPeer ReusePeerForItem(ItemAutomationPeer peer, object item);
    internal void AddProxyToWeakRefStorage(WeakReference wr, ItemAutomationPeer itemPeer);
    private sealed virtual override IRawElementProviderSimple System.Windows.Automation.Provider.IItemContainerProvider.FindItemByProperty(IRawElementProviderSimple startAfter, int propertyId, object value);
    internal virtual bool IsPropertySupportedByControlForFindItem(int id);
    internal static bool IsPropertySupportedByControlForFindItemInternal(int id);
    internal virtual object GetSupportedPropertyValue(ItemAutomationPeer itemPeer, int propertyId);
    internal static object GetSupportedPropertyValueInternal(AutomationPeer itemPeer, int propertyId);
    protected internal virtual ItemAutomationPeer FindOrCreateItemAutomationPeer(object item);
    internal ItemAutomationPeer CreateItemAutomationPeerInternal(object item);
    protected abstract virtual ItemAutomationPeer CreateItemAutomationPeer(object item);
    internal RecyclableWrapper GetRecyclableWrapperPeer(object item);
    internal virtual IDisposable UpdateChildren();
    internal ItemAutomationPeer GetPeerFromWeakRefStorage(object item);
    internal AutomationPeer GetExistingPeerByItem(object item, bool checkInWeakRefStorage);
    internal ItemAutomationPeer ReusablePeerFor(object item);
    private void ClearReusablePeers(ItemPeersStorage`1<ItemAutomationPeer> oldChildren);
    protected virtual bool get_IsVirtualized();
    internal ItemPeersStorage`1<ItemAutomationPeer> get_ItemPeers();
    internal void set_ItemPeers(ItemPeersStorage`1<ItemAutomationPeer> value);
    internal ItemPeersStorage`1<WeakReference> get_WeakRefElementProxyStorage();
    internal void set_WeakRefElementProxyStorage(ItemPeersStorage`1<WeakReference> value);
    internal List`1<ItemAutomationPeer> get_RecentlyRealizedPeers();
}
internal class System.Windows.Automation.Peers.ItemsControlItemAutomationPeer : ItemAutomationPeer {
    public ItemsControlItemAutomationPeer(object item, ItemsControlWrapperAutomationPeer parent);
    protected virtual AutomationControlType GetAutomationControlTypeCore();
    protected virtual string GetClassNameCore();
}
internal class System.Windows.Automation.Peers.ItemsControlWrapperAutomationPeer : ItemsControlAutomationPeer {
    public ItemsControlWrapperAutomationPeer(ItemsControl owner);
    protected virtual ItemAutomationPeer CreateItemAutomationPeer(object item);
    protected virtual string GetClassNameCore();
    protected virtual AutomationControlType GetAutomationControlTypeCore();
}
public interface System.Windows.Automation.Peers.IViewAutomationPeer {
    public abstract virtual AutomationControlType GetAutomationControlType();
    public abstract virtual object GetPattern(PatternInterface patternInterface);
    public abstract virtual List`1<AutomationPeer> GetChildren(List`1<AutomationPeer> children);
    public abstract virtual ItemAutomationPeer CreateItemAutomationPeer(object item);
    public abstract virtual void ItemsChanged(NotifyCollectionChangedEventArgs e);
    public abstract virtual void ViewDetached();
}
public class System.Windows.Automation.Peers.LabelAutomationPeer : FrameworkElementAutomationPeer {
    public LabelAutomationPeer(Label owner);
    protected virtual string GetClassNameCore();
    protected virtual AutomationControlType GetAutomationControlTypeCore();
    protected virtual string GetNameCore();
}
public class System.Windows.Automation.Peers.ListBoxAutomationPeer : SelectorAutomationPeer {
    public ListBoxAutomationPeer(ListBox owner);
    protected virtual ItemAutomationPeer CreateItemAutomationPeer(object item);
    protected virtual string GetClassNameCore();
}
public class System.Windows.Automation.Peers.ListBoxItemAutomationPeer : SelectorItemAutomationPeer {
    public ListBoxItemAutomationPeer(object owner, SelectorAutomationPeer selectorAutomationPeer);
    protected virtual string GetClassNameCore();
    protected virtual AutomationControlType GetAutomationControlTypeCore();
    public virtual object GetPattern(PatternInterface patternInterface);
    internal virtual void RealizeCore();
    private sealed virtual override void System.Windows.Automation.Provider.IScrollItemProvider.ScrollIntoView();
}
public class System.Windows.Automation.Peers.ListBoxItemWrapperAutomationPeer : FrameworkElementAutomationPeer {
    public ListBoxItemWrapperAutomationPeer(ListBoxItem owner);
    protected virtual string GetClassNameCore();
    protected virtual AutomationControlType GetAutomationControlTypeCore();
}
public class System.Windows.Automation.Peers.ListViewAutomationPeer : ListBoxAutomationPeer {
    private bool _refreshItemPeers;
    private IViewAutomationPeer _viewAutomationPeer;
    protected internal IViewAutomationPeer ViewAutomationPeer { get; protected internal set; }
    public ListViewAutomationPeer(ListView owner);
    protected virtual AutomationControlType GetAutomationControlTypeCore();
    protected virtual string GetClassNameCore();
    public virtual object GetPattern(PatternInterface patternInterface);
    protected virtual List`1<AutomationPeer> GetChildrenCore();
    protected virtual ItemAutomationPeer CreateItemAutomationPeer(object item);
    protected internal IViewAutomationPeer get_ViewAutomationPeer();
    protected internal void set_ViewAutomationPeer(IViewAutomationPeer value);
}
public class System.Windows.Automation.Peers.MediaElementAutomationPeer : FrameworkElementAutomationPeer {
    public MediaElementAutomationPeer(MediaElement owner);
    protected virtual string GetClassNameCore();
    protected virtual AutomationControlType GetAutomationControlTypeCore();
}
public class System.Windows.Automation.Peers.MenuAutomationPeer : FrameworkElementAutomationPeer {
    public MenuAutomationPeer(Menu owner);
    protected virtual string GetClassNameCore();
    protected virtual AutomationControlType GetAutomationControlTypeCore();
    protected virtual bool IsContentElementCore();
}
public class System.Windows.Automation.Peers.MenuItemAutomationPeer : FrameworkElementAutomationPeer {
    private ExpandCollapseState System.Windows.Automation.Provider.IExpandCollapseProvider.ExpandCollapseState { get; }
    private ToggleState System.Windows.Automation.Provider.IToggleProvider.ToggleState { get; }
    public MenuItemAutomationPeer(MenuItem owner);
    protected virtual string GetClassNameCore();
    protected virtual AutomationControlType GetAutomationControlTypeCore();
    public virtual object GetPattern(PatternInterface patternInterface);
    protected virtual int GetSizeOfSetCore();
    protected virtual int GetPositionInSetCore();
    protected virtual string GetAccessKeyCore();
    protected virtual List`1<AutomationPeer> GetChildrenCore();
    private sealed virtual override void System.Windows.Automation.Provider.IExpandCollapseProvider.Expand();
    private sealed virtual override void System.Windows.Automation.Provider.IExpandCollapseProvider.Collapse();
    private sealed virtual override ExpandCollapseState System.Windows.Automation.Provider.IExpandCollapseProvider.get_ExpandCollapseState();
    private sealed virtual override void System.Windows.Automation.Provider.IInvokeProvider.Invoke();
    private sealed virtual override void System.Windows.Automation.Provider.IToggleProvider.Toggle();
    private sealed virtual override ToggleState System.Windows.Automation.Provider.IToggleProvider.get_ToggleState();
    internal void RaiseExpandCollapseAutomationEvent(bool oldValue, bool newValue);
    protected virtual string GetNameCore();
}
public class System.Windows.Automation.Peers.NavigationWindowAutomationPeer : WindowAutomationPeer {
    public NavigationWindowAutomationPeer(NavigationWindow owner);
    protected virtual string GetClassNameCore();
    internal static void RaiseAsyncContentLoadedEvent(AutomationPeer peer, long bytesRead, long maxBytes);
}
public class System.Windows.Automation.Peers.PasswordBoxAutomationPeer : TextAutomationPeer {
    private TextAdaptor _textPattern;
    private bool System.Windows.Automation.Provider.IValueProvider.IsReadOnly { get; }
    private string System.Windows.Automation.Provider.IValueProvider.Value { get; }
    public PasswordBoxAutomationPeer(PasswordBox owner);
    protected virtual string GetClassNameCore();
    protected virtual AutomationControlType GetAutomationControlTypeCore();
    public virtual object GetPattern(PatternInterface patternInterface);
    protected virtual bool IsPasswordCore();
    private sealed virtual override bool System.Windows.Automation.Provider.IValueProvider.get_IsReadOnly();
    private sealed virtual override string System.Windows.Automation.Provider.IValueProvider.get_Value();
    private sealed virtual override void System.Windows.Automation.Provider.IValueProvider.SetValue(string value);
    internal void RaiseValuePropertyChangedEvent(string oldValue, string newValue);
    internal void RaiseIsReadOnlyPropertyChangedEvent(bool oldValue, bool newValue);
    internal virtual List`1<AutomationPeer> GetAutomationPeersFromRange(ITextPointer start, ITextPointer end);
}
internal class System.Windows.Automation.Peers.PopupRootAutomationPeer : FrameworkElementAutomationPeer {
    public PopupRootAutomationPeer(PopupRoot owner);
    protected virtual string GetClassNameCore();
    protected virtual AutomationControlType GetAutomationControlTypeCore();
}
public class System.Windows.Automation.Peers.ProgressBarAutomationPeer : RangeBaseAutomationPeer {
    private bool System.Windows.Automation.Provider.IRangeValueProvider.IsReadOnly { get; }
    private double System.Windows.Automation.Provider.IRangeValueProvider.LargeChange { get; }
    private double System.Windows.Automation.Provider.IRangeValueProvider.SmallChange { get; }
    public ProgressBarAutomationPeer(ProgressBar owner);
    protected virtual string GetClassNameCore();
    protected virtual AutomationControlType GetAutomationControlTypeCore();
    public virtual object GetPattern(PatternInterface patternInterface);
    private sealed virtual override void System.Windows.Automation.Provider.IRangeValueProvider.SetValue(double val);
    private sealed virtual override bool System.Windows.Automation.Provider.IRangeValueProvider.get_IsReadOnly();
    private sealed virtual override double System.Windows.Automation.Provider.IRangeValueProvider.get_LargeChange();
    private sealed virtual override double System.Windows.Automation.Provider.IRangeValueProvider.get_SmallChange();
}
public class System.Windows.Automation.Peers.RadioButtonAutomationPeer : ToggleButtonAutomationPeer {
    private bool System.Windows.Automation.Provider.ISelectionItemProvider.IsSelected { get; }
    private IRawElementProviderSimple System.Windows.Automation.Provider.ISelectionItemProvider.SelectionContainer { get; }
    public RadioButtonAutomationPeer(RadioButton owner);
    protected virtual string GetClassNameCore();
    protected virtual AutomationControlType GetAutomationControlTypeCore();
    public virtual object GetPattern(PatternInterface patternInterface);
    private sealed virtual override void System.Windows.Automation.Provider.ISelectionItemProvider.Select();
    private sealed virtual override void System.Windows.Automation.Provider.ISelectionItemProvider.AddToSelection();
    private sealed virtual override void System.Windows.Automation.Provider.ISelectionItemProvider.RemoveFromSelection();
    private sealed virtual override bool System.Windows.Automation.Provider.ISelectionItemProvider.get_IsSelected();
    private sealed virtual override IRawElementProviderSimple System.Windows.Automation.Provider.ISelectionItemProvider.get_SelectionContainer();
    internal virtual void RaiseToggleStatePropertyChangedEvent(Nullable`1<bool> oldValue, Nullable`1<bool> newValue);
}
public class System.Windows.Automation.Peers.RangeBaseAutomationPeer : FrameworkElementAutomationPeer {
    private double System.Windows.Automation.Provider.IRangeValueProvider.Value { get; }
    private bool System.Windows.Automation.Provider.IRangeValueProvider.IsReadOnly { get; }
    private double System.Windows.Automation.Provider.IRangeValueProvider.Maximum { get; }
    private double System.Windows.Automation.Provider.IRangeValueProvider.Minimum { get; }
    private double System.Windows.Automation.Provider.IRangeValueProvider.LargeChange { get; }
    private double System.Windows.Automation.Provider.IRangeValueProvider.SmallChange { get; }
    public RangeBaseAutomationPeer(RangeBase owner);
    public virtual object GetPattern(PatternInterface patternInterface);
    internal void RaiseMinimumPropertyChangedEvent(double oldValue, double newValue);
    internal void RaiseMaximumPropertyChangedEvent(double oldValue, double newValue);
    internal void RaiseValuePropertyChangedEvent(double oldValue, double newValue);
    internal virtual void SetValueCore(double val);
    private sealed virtual override void System.Windows.Automation.Provider.IRangeValueProvider.SetValue(double val);
    private sealed virtual override double System.Windows.Automation.Provider.IRangeValueProvider.get_Value();
    private sealed virtual override bool System.Windows.Automation.Provider.IRangeValueProvider.get_IsReadOnly();
    private sealed virtual override double System.Windows.Automation.Provider.IRangeValueProvider.get_Maximum();
    private sealed virtual override double System.Windows.Automation.Provider.IRangeValueProvider.get_Minimum();
    private sealed virtual override double System.Windows.Automation.Provider.IRangeValueProvider.get_LargeChange();
    private sealed virtual override double System.Windows.Automation.Provider.IRangeValueProvider.get_SmallChange();
}
internal class System.Windows.Automation.Peers.RecyclableWrapper : object {
    private ItemsControl _itemsControl;
    private DependencyObject _container;
    private object _item;
    public AutomationPeer Peer { get; }
    public RecyclableWrapper(ItemsControl itemsControl, object item);
    public void LinkItem(object item);
    private void UnlinkItem();
    private sealed virtual override void System.IDisposable.Dispose();
    public AutomationPeer get_Peer();
}
public class System.Windows.Automation.Peers.RepeatButtonAutomationPeer : ButtonBaseAutomationPeer {
    public RepeatButtonAutomationPeer(RepeatButton owner);
    protected virtual string GetClassNameCore();
    protected virtual AutomationControlType GetAutomationControlTypeCore();
    public virtual object GetPattern(PatternInterface patternInterface);
    private sealed virtual override void System.Windows.Automation.Provider.IInvokeProvider.Invoke();
}
public class System.Windows.Automation.Peers.RichTextBoxAutomationPeer : TextAutomationPeer {
    private TextAdaptor _textPattern;
    public RichTextBoxAutomationPeer(RichTextBox owner);
    protected virtual string GetClassNameCore();
    protected virtual AutomationControlType GetAutomationControlTypeCore();
    public virtual object GetPattern(PatternInterface patternInterface);
    protected virtual List`1<AutomationPeer> GetChildrenCore();
    internal virtual List`1<AutomationPeer> GetAutomationPeersFromRange(ITextPointer start, ITextPointer end);
}
public class System.Windows.Automation.Peers.ScrollBarAutomationPeer : RangeBaseAutomationPeer {
    public ScrollBarAutomationPeer(ScrollBar owner);
    protected virtual string GetClassNameCore();
    protected virtual AutomationControlType GetAutomationControlTypeCore();
    protected virtual bool IsContentElementCore();
    protected virtual Point GetClickablePointCore();
    protected virtual AutomationOrientation GetOrientationCore();
    internal virtual void SetValueCore(double val);
}
public class System.Windows.Automation.Peers.ScrollViewerAutomationPeer : FrameworkElementAutomationPeer {
    private double System.Windows.Automation.Provider.IScrollProvider.HorizontalScrollPercent { get; }
    private double System.Windows.Automation.Provider.IScrollProvider.VerticalScrollPercent { get; }
    private double System.Windows.Automation.Provider.IScrollProvider.HorizontalViewSize { get; }
    private double System.Windows.Automation.Provider.IScrollProvider.VerticalViewSize { get; }
    private bool System.Windows.Automation.Provider.IScrollProvider.HorizontallyScrollable { get; }
    private bool System.Windows.Automation.Provider.IScrollProvider.VerticallyScrollable { get; }
    private bool HorizontallyScrollable { get; }
    private bool VerticallyScrollable { get; }
    public ScrollViewerAutomationPeer(ScrollViewer owner);
    protected virtual string GetClassNameCore();
    protected virtual AutomationControlType GetAutomationControlTypeCore();
    protected virtual bool IsControlElementCore();
    public virtual object GetPattern(PatternInterface patternInterface);
    private sealed virtual override void System.Windows.Automation.Provider.IScrollProvider.Scroll(ScrollAmount horizontalAmount, ScrollAmount verticalAmount);
    private sealed virtual override void System.Windows.Automation.Provider.IScrollProvider.SetScrollPercent(double horizontalPercent, double verticalPercent);
    private sealed virtual override double System.Windows.Automation.Provider.IScrollProvider.get_HorizontalScrollPercent();
    private sealed virtual override double System.Windows.Automation.Provider.IScrollProvider.get_VerticalScrollPercent();
    private sealed virtual override double System.Windows.Automation.Provider.IScrollProvider.get_HorizontalViewSize();
    private sealed virtual override double System.Windows.Automation.Provider.IScrollProvider.get_VerticalViewSize();
    private sealed virtual override bool System.Windows.Automation.Provider.IScrollProvider.get_HorizontallyScrollable();
    private sealed virtual override bool System.Windows.Automation.Provider.IScrollProvider.get_VerticallyScrollable();
    private static bool AutomationIsScrollable(double extent, double viewport);
    private static double AutomationGetScrollPercent(double extent, double viewport, double actualOffset);
    private static double AutomationGetViewSize(double extent, double viewport);
    private bool get_HorizontallyScrollable();
    private bool get_VerticallyScrollable();
    internal void RaiseAutomationEvents(double extentX, double extentY, double viewportX, double viewportY, double offsetX, double offsetY);
}
public abstract class System.Windows.Automation.Peers.SelectorAutomationPeer : ItemsControlAutomationPeer {
    private bool System.Windows.Automation.Provider.ISelectionProvider.CanSelectMultiple { get; }
    private bool System.Windows.Automation.Provider.ISelectionProvider.IsSelectionRequired { get; }
    protected SelectorAutomationPeer(Selector owner);
    protected virtual AutomationControlType GetAutomationControlTypeCore();
    public virtual object GetPattern(PatternInterface patternInterface);
    internal virtual bool IsPropertySupportedByControlForFindItem(int id);
    internal static bool IsPropertySupportedByControlForFindItemInternal(int id);
    internal virtual object GetSupportedPropertyValue(ItemAutomationPeer itemPeer, int propertyId);
    internal static object GetSupportedPropertyValueInternal(AutomationPeer itemPeer, int propertyId);
    private sealed virtual override IRawElementProviderSimple[] System.Windows.Automation.Provider.ISelectionProvider.GetSelection();
    private sealed virtual override bool System.Windows.Automation.Provider.ISelectionProvider.get_CanSelectMultiple();
    private sealed virtual override bool System.Windows.Automation.Provider.ISelectionProvider.get_IsSelectionRequired();
    internal void RaiseSelectionEvents(SelectionChangedEventArgs e);
}
public abstract class System.Windows.Automation.Peers.SelectorItemAutomationPeer : ItemAutomationPeer {
    private bool System.Windows.Automation.Provider.ISelectionItemProvider.IsSelected { get; }
    private IRawElementProviderSimple System.Windows.Automation.Provider.ISelectionItemProvider.SelectionContainer { get; }
    protected SelectorItemAutomationPeer(object owner, SelectorAutomationPeer selectorAutomationPeer);
    public virtual object GetPattern(PatternInterface patternInterface);
    private sealed virtual override void System.Windows.Automation.Provider.ISelectionItemProvider.Select();
    private sealed virtual override void System.Windows.Automation.Provider.ISelectionItemProvider.AddToSelection();
    private sealed virtual override void System.Windows.Automation.Provider.ISelectionItemProvider.RemoveFromSelection();
    private sealed virtual override bool System.Windows.Automation.Provider.ISelectionItemProvider.get_IsSelected();
    private sealed virtual override IRawElementProviderSimple System.Windows.Automation.Provider.ISelectionItemProvider.get_SelectionContainer();
    internal void RaiseAutomationIsSelectedChanged(bool isSelected);
}
public class System.Windows.Automation.Peers.SeparatorAutomationPeer : FrameworkElementAutomationPeer {
    public SeparatorAutomationPeer(Separator owner);
    protected virtual string GetClassNameCore();
    protected virtual AutomationControlType GetAutomationControlTypeCore();
    protected virtual bool IsContentElementCore();
}
public class System.Windows.Automation.Peers.SliderAutomationPeer : RangeBaseAutomationPeer {
    public SliderAutomationPeer(Slider owner);
    protected virtual string GetClassNameCore();
    protected virtual AutomationControlType GetAutomationControlTypeCore();
    protected virtual Point GetClickablePointCore();
}
public class System.Windows.Automation.Peers.StatusBarAutomationPeer : FrameworkElementAutomationPeer {
    public StatusBarAutomationPeer(StatusBar owner);
    protected virtual string GetClassNameCore();
    protected virtual AutomationControlType GetAutomationControlTypeCore();
    protected virtual List`1<AutomationPeer> GetChildrenCore();
    private List`1<AutomationPeer> GetChildrenAutomationPeer(Visual parent);
    private static bool iterate(Visual parent, IteratorCallback callback);
}
public class System.Windows.Automation.Peers.StatusBarItemAutomationPeer : FrameworkElementAutomationPeer {
    public StatusBarItemAutomationPeer(StatusBarItem owner);
    protected virtual string GetClassNameCore();
    protected virtual AutomationControlType GetAutomationControlTypeCore();
}
public class System.Windows.Automation.Peers.TabControlAutomationPeer : SelectorAutomationPeer {
    private bool System.Windows.Automation.Provider.ISelectionProvider.IsSelectionRequired { get; }
    public TabControlAutomationPeer(TabControl owner);
    protected virtual ItemAutomationPeer CreateItemAutomationPeer(object item);
    protected virtual AutomationControlType GetAutomationControlTypeCore();
    protected virtual string GetClassNameCore();
    protected virtual Point GetClickablePointCore();
    private sealed virtual override bool System.Windows.Automation.Provider.ISelectionProvider.get_IsSelectionRequired();
}
public class System.Windows.Automation.Peers.TabItemAutomationPeer : SelectorItemAutomationPeer {
    public TabItemAutomationPeer(object owner, TabControlAutomationPeer tabControlAutomationPeer);
    protected virtual string GetClassNameCore();
    protected virtual AutomationControlType GetAutomationControlTypeCore();
    protected virtual string GetNameCore();
    protected virtual List`1<AutomationPeer> GetChildrenCore();
    private sealed virtual override void System.Windows.Automation.Provider.ISelectionItemProvider.RemoveFromSelection();
    internal virtual void RealizeCore();
}
public class System.Windows.Automation.Peers.TabItemWrapperAutomationPeer : FrameworkElementAutomationPeer {
    public TabItemWrapperAutomationPeer(TabItem owner);
}
public class System.Windows.Automation.Peers.TableAutomationPeer : TextElementAutomationPeer {
    private int _rowCount;
    private int _columnCount;
    private int System.Windows.Automation.Provider.IGridProvider.RowCount { get; }
    private int System.Windows.Automation.Provider.IGridProvider.ColumnCount { get; }
    public TableAutomationPeer(Table owner);
    public virtual object GetPattern(PatternInterface patternInterface);
    protected virtual AutomationControlType GetAutomationControlTypeCore();
    protected virtual string GetClassNameCore();
    protected virtual bool IsControlElementCore();
    internal void OnStructureInvalidated();
    private int GetRowCount();
    private int GetColumnCount();
    private sealed virtual override IRawElementProviderSimple System.Windows.Automation.Provider.IGridProvider.GetItem(int row, int column);
    private sealed virtual override int System.Windows.Automation.Provider.IGridProvider.get_RowCount();
    private sealed virtual override int System.Windows.Automation.Provider.IGridProvider.get_ColumnCount();
}
public class System.Windows.Automation.Peers.TableCellAutomationPeer : TextElementAutomationPeer {
    private int System.Windows.Automation.Provider.IGridItemProvider.Row { get; }
    private int System.Windows.Automation.Provider.IGridItemProvider.Column { get; }
    private int System.Windows.Automation.Provider.IGridItemProvider.RowSpan { get; }
    private int System.Windows.Automation.Provider.IGridItemProvider.ColumnSpan { get; }
    private IRawElementProviderSimple System.Windows.Automation.Provider.IGridItemProvider.ContainingGrid { get; }
    public TableCellAutomationPeer(TableCell owner);
    public virtual object GetPattern(PatternInterface patternInterface);
    protected virtual AutomationControlType GetAutomationControlTypeCore();
    protected virtual string GetLocalizedControlTypeCore();
    protected virtual string GetClassNameCore();
    protected virtual bool IsControlElementCore();
    internal void OnColumnSpanChanged(int oldValue, int newValue);
    internal void OnRowSpanChanged(int oldValue, int newValue);
    private sealed virtual override int System.Windows.Automation.Provider.IGridItemProvider.get_Row();
    private sealed virtual override int System.Windows.Automation.Provider.IGridItemProvider.get_Column();
    private sealed virtual override int System.Windows.Automation.Provider.IGridItemProvider.get_RowSpan();
    private sealed virtual override int System.Windows.Automation.Provider.IGridItemProvider.get_ColumnSpan();
    private sealed virtual override IRawElementProviderSimple System.Windows.Automation.Provider.IGridItemProvider.get_ContainingGrid();
}
public abstract class System.Windows.Automation.Peers.TextAutomationPeer : FrameworkElementAutomationPeer {
    protected TextAutomationPeer(FrameworkElement owner);
    protected virtual string GetNameCore();
    internal IRawElementProviderSimple ProviderFromPeer(AutomationPeer peer);
    internal DependencyObject ElementFromProvider(IRawElementProviderSimple provider);
    internal abstract virtual List`1<AutomationPeer> GetAutomationPeersFromRange(ITextPointer start, ITextPointer end);
}
public class System.Windows.Automation.Peers.TextBlockAutomationPeer : FrameworkElementAutomationPeer {
    public TextBlockAutomationPeer(TextBlock owner);
    protected virtual List`1<AutomationPeer> GetChildrenCore();
    protected virtual AutomationControlType GetAutomationControlTypeCore();
    protected virtual string GetClassNameCore();
    protected virtual bool IsControlElementCore();
}
public class System.Windows.Automation.Peers.TextBoxAutomationPeer : TextAutomationPeer {
    private TextAdaptor _textPattern;
    private bool System.Windows.Automation.Provider.IValueProvider.IsReadOnly { get; }
    private string System.Windows.Automation.Provider.IValueProvider.Value { get; }
    public TextBoxAutomationPeer(TextBox owner);
    protected virtual string GetClassNameCore();
    protected virtual AutomationControlType GetAutomationControlTypeCore();
    public virtual object GetPattern(PatternInterface patternInterface);
    private sealed virtual override bool System.Windows.Automation.Provider.IValueProvider.get_IsReadOnly();
    private sealed virtual override string System.Windows.Automation.Provider.IValueProvider.get_Value();
    private sealed virtual override void System.Windows.Automation.Provider.IValueProvider.SetValue(string value);
    internal void RaiseValuePropertyChangedEvent(string oldValue, string newValue);
    internal void RaiseIsReadOnlyPropertyChangedEvent(bool oldValue, bool newValue);
    internal virtual List`1<AutomationPeer> GetAutomationPeersFromRange(ITextPointer start, ITextPointer end);
}
public class System.Windows.Automation.Peers.TextElementAutomationPeer : ContentTextAutomationPeer {
    internal Nullable`1<bool> IsTextViewVisible { get; }
    public TextElementAutomationPeer(TextElement owner);
    protected virtual List`1<AutomationPeer> GetChildrenCore();
    protected virtual Rect GetBoundingRectangleCore();
    protected virtual Point GetClickablePointCore();
    protected virtual bool IsOffscreenCore();
    private Rect CalculateVisibleRect(ITextView textView, TextElement textElement, TextPointer startPointer, TextPointer endPointer);
    internal virtual List`1<AutomationPeer> GetAutomationPeersFromRange(ITextPointer start, ITextPointer end);
    internal Nullable`1<bool> get_IsTextViewVisible();
}
public class System.Windows.Automation.Peers.ThumbAutomationPeer : FrameworkElementAutomationPeer {
    public ThumbAutomationPeer(Thumb owner);
    protected virtual string GetClassNameCore();
    protected virtual AutomationControlType GetAutomationControlTypeCore();
    protected virtual bool IsContentElementCore();
}
public class System.Windows.Automation.Peers.ToggleButtonAutomationPeer : ButtonBaseAutomationPeer {
    private ToggleState System.Windows.Automation.Provider.IToggleProvider.ToggleState { get; }
    public ToggleButtonAutomationPeer(ToggleButton owner);
    protected virtual string GetClassNameCore();
    protected virtual AutomationControlType GetAutomationControlTypeCore();
    public virtual object GetPattern(PatternInterface patternInterface);
    private sealed virtual override void System.Windows.Automation.Provider.IToggleProvider.Toggle();
    private sealed virtual override ToggleState System.Windows.Automation.Provider.IToggleProvider.get_ToggleState();
    internal virtual void RaiseToggleStatePropertyChangedEvent(Nullable`1<bool> oldValue, Nullable`1<bool> newValue);
    private static ToggleState ConvertToToggleState(Nullable`1<bool> value);
}
public class System.Windows.Automation.Peers.ToolBarAutomationPeer : FrameworkElementAutomationPeer {
    public ToolBarAutomationPeer(ToolBar owner);
    protected virtual string GetClassNameCore();
    protected virtual AutomationControlType GetAutomationControlTypeCore();
}
public class System.Windows.Automation.Peers.ToolTipAutomationPeer : FrameworkElementAutomationPeer {
    public ToolTipAutomationPeer(ToolTip owner);
    protected virtual string GetClassNameCore();
    protected virtual AutomationControlType GetAutomationControlTypeCore();
}
public class System.Windows.Automation.Peers.TreeViewAutomationPeer : ItemsControlAutomationPeer {
    private bool System.Windows.Automation.Provider.ISelectionProvider.CanSelectMultiple { get; }
    private bool System.Windows.Automation.Provider.ISelectionProvider.IsSelectionRequired { get; }
    public TreeViewAutomationPeer(TreeView owner);
    protected virtual AutomationControlType GetAutomationControlTypeCore();
    protected virtual string GetClassNameCore();
    public virtual object GetPattern(PatternInterface patternInterface);
    protected virtual List`1<AutomationPeer> GetChildrenCore();
    protected virtual ItemAutomationPeer CreateItemAutomationPeer(object item);
    internal virtual bool IsPropertySupportedByControlForFindItem(int id);
    internal virtual object GetSupportedPropertyValue(ItemAutomationPeer itemPeer, int propertyId);
    private sealed virtual override IRawElementProviderSimple[] System.Windows.Automation.Provider.ISelectionProvider.GetSelection();
    private sealed virtual override bool System.Windows.Automation.Provider.ISelectionProvider.get_CanSelectMultiple();
    private sealed virtual override bool System.Windows.Automation.Provider.ISelectionProvider.get_IsSelectionRequired();
}
public class System.Windows.Automation.Peers.TreeViewDataItemAutomationPeer : ItemAutomationPeer {
    private TreeViewDataItemAutomationPeer _parentDataItemAutomationPeer;
    private ItemPeersStorage`1<WeakReference> _WeakRefElementProxyStorageCache;
    public TreeViewDataItemAutomationPeer ParentDataItemAutomationPeer { get; }
    private ExpandCollapseState System.Windows.Automation.Provider.IExpandCollapseProvider.ExpandCollapseState { get; }
    private bool System.Windows.Automation.Provider.ISelectionItemProvider.IsSelected { get; }
    private IRawElementProviderSimple System.Windows.Automation.Provider.ISelectionItemProvider.SelectionContainer { get; }
    internal ItemPeersStorage`1<WeakReference> WeakRefElementProxyStorageCache { get; internal set; }
    public TreeViewDataItemAutomationPeer(object item, ItemsControlAutomationPeer itemsControlAutomationPeer, TreeViewDataItemAutomationPeer parentDataItemAutomationPeer);
    public virtual object GetPattern(PatternInterface patternInterface);
    internal virtual AutomationPeer GetWrapperPeer();
    protected virtual string GetClassNameCore();
    protected virtual AutomationControlType GetAutomationControlTypeCore();
    public TreeViewDataItemAutomationPeer get_ParentDataItemAutomationPeer();
    internal virtual ItemsControlAutomationPeer GetItemsControlAutomationPeer();
    internal virtual void RealizeCore();
    private sealed virtual override void System.Windows.Automation.Provider.IExpandCollapseProvider.Expand();
    private sealed virtual override void System.Windows.Automation.Provider.IExpandCollapseProvider.Collapse();
    private sealed virtual override ExpandCollapseState System.Windows.Automation.Provider.IExpandCollapseProvider.get_ExpandCollapseState();
    internal void RaiseExpandCollapseAutomationEvent(bool oldValue, bool newValue);
    private sealed virtual override void System.Windows.Automation.Provider.ISelectionItemProvider.Select();
    private sealed virtual override void System.Windows.Automation.Provider.ISelectionItemProvider.AddToSelection();
    private sealed virtual override void System.Windows.Automation.Provider.ISelectionItemProvider.RemoveFromSelection();
    private sealed virtual override bool System.Windows.Automation.Provider.ISelectionItemProvider.get_IsSelected();
    private sealed virtual override IRawElementProviderSimple System.Windows.Automation.Provider.ISelectionItemProvider.get_SelectionContainer();
    private sealed virtual override void System.Windows.Automation.Provider.IScrollItemProvider.ScrollIntoView();
    internal void RaiseAutomationIsSelectedChanged(bool isSelected);
    private void RecursiveScrollIntoView();
    internal ItemPeersStorage`1<WeakReference> get_WeakRefElementProxyStorageCache();
    internal void set_WeakRefElementProxyStorageCache(ItemPeersStorage`1<WeakReference> value);
}
public class System.Windows.Automation.Peers.TreeViewItemAutomationPeer : ItemsControlAutomationPeer {
    private ExpandCollapseState System.Windows.Automation.Provider.IExpandCollapseProvider.ExpandCollapseState { get; }
    private bool System.Windows.Automation.Provider.ISelectionItemProvider.IsSelected { get; }
    private IRawElementProviderSimple System.Windows.Automation.Provider.ISelectionItemProvider.SelectionContainer { get; }
    public TreeViewItemAutomationPeer(TreeViewItem owner);
    protected virtual string GetClassNameCore();
    protected virtual AutomationControlType GetAutomationControlTypeCore();
    public virtual object GetPattern(PatternInterface patternInterface);
    protected virtual List`1<AutomationPeer> GetChildrenCore();
    private static bool iterate(TreeViewItemAutomationPeer logicalParentAp, DependencyObject parent, IteratorCallback callback, ItemPeersStorage`1<ItemAutomationPeer> dataChildren, ItemPeersStorage`1<ItemAutomationPeer> oldChildren);
    protected internal virtual ItemAutomationPeer FindOrCreateItemAutomationPeer(object item);
    internal virtual bool IsPropertySupportedByControlForFindItem(int id);
    internal virtual object GetSupportedPropertyValue(ItemAutomationPeer itemPeer, int propertyId);
    protected virtual ItemAutomationPeer CreateItemAutomationPeer(object item);
    internal virtual IDisposable UpdateChildren();
    internal void AddDataPeerInfo(TreeViewDataItemAutomationPeer dataPeer);
    internal void UpdateWeakRefStorageFromDataPeer();
    private sealed virtual override void System.Windows.Automation.Provider.IExpandCollapseProvider.Expand();
    private sealed virtual override void System.Windows.Automation.Provider.IExpandCollapseProvider.Collapse();
    private sealed virtual override ExpandCollapseState System.Windows.Automation.Provider.IExpandCollapseProvider.get_ExpandCollapseState();
    internal void RaiseExpandCollapseAutomationEvent(bool oldValue, bool newValue);
    private sealed virtual override void System.Windows.Automation.Provider.ISelectionItemProvider.Select();
    private sealed virtual override void System.Windows.Automation.Provider.ISelectionItemProvider.AddToSelection();
    private sealed virtual override void System.Windows.Automation.Provider.ISelectionItemProvider.RemoveFromSelection();
    private sealed virtual override bool System.Windows.Automation.Provider.ISelectionItemProvider.get_IsSelected();
    private sealed virtual override IRawElementProviderSimple System.Windows.Automation.Provider.ISelectionItemProvider.get_SelectionContainer();
    private sealed virtual override void System.Windows.Automation.Provider.IScrollItemProvider.ScrollIntoView();
    internal void RaiseAutomationIsSelectedChanged(bool isSelected);
    internal void RaiseAutomationSelectionEvent(AutomationEvents eventId);
}
public class System.Windows.Automation.Peers.UserControlAutomationPeer : FrameworkElementAutomationPeer {
    public UserControlAutomationPeer(UserControl owner);
    protected virtual string GetClassNameCore();
    protected virtual AutomationControlType GetAutomationControlTypeCore();
}
public class System.Windows.Automation.Peers.Viewport3DAutomationPeer : FrameworkElementAutomationPeer {
    public Viewport3DAutomationPeer(Viewport3D owner);
    protected virtual string GetClassNameCore();
    protected virtual AutomationControlType GetAutomationControlTypeCore();
}
public class System.Windows.Automation.Peers.WindowAutomationPeer : FrameworkElementAutomationPeer {
    public WindowAutomationPeer(Window owner);
    protected virtual string GetClassNameCore();
    protected virtual string GetNameCore();
    protected virtual AutomationControlType GetAutomationControlTypeCore();
    protected virtual Rect GetBoundingRectangleCore();
}
public class System.Windows.Baml2006.Baml2006Reader : XamlReader {
    private Baml2006ReaderSettings _settings;
    private bool _isBinaryProvider;
    private bool _isEof;
    private int _lookingForAKeyOnAMarkupExtensionInADictionaryDepth;
    private XamlNodeList _lookingForAKeyOnAMarkupExtensionInADictionaryNodeList;
    private BamlBinaryReader _binaryReader;
    private Baml2006ReaderContext _context;
    private XamlNodeQueue _xamlMainNodeQueue;
    private XamlNodeList _xamlTemplateNodeList;
    private XamlReader _xamlNodesReader;
    private XamlWriter _xamlNodesWriter;
    private Stack`1<XamlWriter> _xamlWriterStack;
    private Dictionary`2<int, TypeConverter> _typeConverterMap;
    private Dictionary`2<Type, TypeConverter> _enumTypeConverterMap;
    private Dictionary`2<string, Freezable> _freezeCache;
    private static short ExtensionIdMask;
    private static short TypeExtensionValueMask;
    private static short StaticExtensionValueMask;
    private static sbyte ReaderFlags_AddedToTree;
    private object _root;
    public XamlNodeType NodeType { get; }
    public bool IsEof { get; }
    public NamespaceDeclaration Namespace { get; }
    public XamlSchemaContext SchemaContext { get; }
    public XamlType Type { get; }
    public object Value { get; }
    public XamlMember Member { get; }
    private bool System.Xaml.IXamlLineInfo.HasLineInfo { get; }
    private int System.Xaml.IXamlLineInfo.LineNumber { get; }
    private int System.Xaml.IXamlLineInfo.LinePosition { get; }
    internal bool FreezeFreezables { get; internal set; }
    private bool System.Windows.Media.IFreezeFreezables.FreezeFreezables { get; }
    private Baml2006SchemaContext BamlSchemaContext { get; }
    public Baml2006Reader(string fileName);
    public Baml2006Reader(Stream stream);
    public Baml2006Reader(Stream stream, XamlReaderSettings xamlReaderSettings);
    internal Baml2006Reader(Stream stream, Baml2006SchemaContext schemaContext, Baml2006ReaderSettings settings);
    internal Baml2006Reader(Stream stream, Baml2006SchemaContext baml2006SchemaContext, Baml2006ReaderSettings baml2006ReaderSettings, object root);
    private void Initialize(Stream stream, Baml2006SchemaContext schemaContext, Baml2006ReaderSettings settings);
    public virtual bool Read();
    public virtual XamlNodeType get_NodeType();
    public virtual bool get_IsEof();
    public virtual NamespaceDeclaration get_Namespace();
    public virtual XamlSchemaContext get_SchemaContext();
    public virtual XamlType get_Type();
    public virtual object get_Value();
    public virtual XamlMember get_Member();
    protected virtual void Dispose(bool disposing);
    private sealed virtual override bool System.Xaml.IXamlLineInfo.get_HasLineInfo();
    private sealed virtual override int System.Xaml.IXamlLineInfo.get_LineNumber();
    private sealed virtual override int System.Xaml.IXamlLineInfo.get_LinePosition();
    internal List`1<KeyRecord> ReadKeys();
    internal XamlReader ReadObject(KeyRecord record);
    internal Type GetTypeOfFirstStartObject(KeyRecord record);
    private bool Process_BamlRecords();
    private bool Process_OneBamlRecord();
    private void Process_ProcessingInstruction();
    private void Process_DefTag();
    private void Process_EndAttributes();
    private void Process_XmlAttribute();
    private void Process_PresentationOptionsAttribute();
    private void Process_Comment();
    private void Process_LiteralContent();
    private void Process_TextWithConverter();
    private void Process_StaticResourceEnd();
    private void Process_StaticResourceStart();
    private void Process_StaticResourceId();
    private void Process_ClrEvent();
    private void Process_RoutedEvent();
    private void Process_PropertyStringReference();
    private void Process_OptimizedStaticResource();
    private void Process_DeferableContentStart();
    private void Process_DefAttribute();
    private void Process_DefAttributeKeyString();
    private void Process_DefAttributeKeyType();
    private bool IsStringOnlyWhiteSpace(string value);
    private void Process_Text();
    private void Process_TextWithId();
    private void Process_Text_Helper(string stringValue);
    private void Process_ConstructorParametersEnd();
    private void Process_ConstructorParametersStart();
    private void Process_ConstructorParameterType();
    private void Process_Header();
    private void Process_ElementStart();
    private void Process_ElementEnd();
    private void Process_KeyElementStart();
    private void Process_KeyElementEnd();
    private void Process_Property();
    private void Common_Process_Property();
    private Int32Collection GetInt32Collection();
    private XamlMember GetProperty(short propertyId, XamlType parentType);
    private XamlMember GetProperty(short propertyId, bool isAttached);
    private void Process_PropertyCustom();
    private bool WriteTypeConvertedInstance(short converterId, int dataByteSize);
    private void Process_PropertyWithConverter();
    internal virtual object CreateTypeConverterMarkupExtension(XamlMember property, TypeConverter converter, object propertyValue, Baml2006ReaderSettings settings);
    private void Process_PropertyWithExtension();
    private void Process_PropertyTypeReference();
    private void Process_PropertyWithStaticResourceId();
    private void Process_PropertyComplexStart();
    private void Process_PropertyArrayStart();
    private void Process_PropertyIDictionaryStart();
    private void Process_PropertyEnd();
    private void Process_PropertyIDictionaryEnd();
    private string Logic_GetFullyQualifiedNameForMember(short propertyId);
    private string Logic_GetFullyQualifiedNameForType(XamlType type);
    private string Logic_GetFullXmlns(string uriInput);
    internal virtual string GetAssemblyNameForNamespace(Assembly assembly);
    private void Process_XmlnsProperty();
    private void Process_LinePosition();
    private void Process_LineNumberAndPosition();
    private void Process_PIMapping();
    private void Process_AssemblyInfo();
    private void Process_TypeInfo();
    private void Process_TypeSerializerInfo();
    private void Process_AttributeInfo();
    private void Process_StringInfo();
    private void Process_ContentProperty();
    private void Process_ConnectionId();
    private Baml2006RecordType Read_RecordType();
    private int Read_RecordSize();
    private void SkipBytes(long offset);
    private void RemoveImplicitFrame();
    private void InjectPropertyAndFrameIfNeeded(XamlType elementType, sbyte flags);
    private void StartSavingFirstItemInDictionary();
    private void RestoreSavedFirstItemInDictionary();
    private void EmitGoItemsPreamble(XamlType parentPropertyType);
    private StaticResource GetLastStaticResource();
    private string GetTextFromBinary(Byte[] bytes, short serializerId, XamlMember property, XamlType type);
    private string GetStaticExtensionValue(short valueId, Type& memberType, Object& providedValue);
    private bool NodeListHasAKeySetOnTheRoot(XamlReader reader);
    internal bool get_FreezeFreezables();
    internal void set_FreezeFreezables(bool value);
    private sealed virtual override bool System.Windows.Media.IFreezeFreezables.get_FreezeFreezables();
    private sealed virtual override bool System.Windows.Media.IFreezeFreezables.TryFreeze(string value, Freezable freezable);
    private sealed virtual override Freezable System.Windows.Media.IFreezeFreezables.TryGetFreezable(string value);
    private Baml2006SchemaContext get_BamlSchemaContext();
}
internal class System.Windows.Baml2006.Baml2006ReaderContext : object {
    [CompilerGeneratedAttribute]
private List`1<KeyRecord> <KeyList>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CurrentKey>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <InsideKeyRecord>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <InsideStaticResource>k__BackingField;
    [CompilerGeneratedAttribute]
private int <TemplateStartDepth>k__BackingField;
    [CompilerGeneratedAttribute]
private int <LineNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private int <LineOffset>k__BackingField;
    private Baml2006SchemaContext _schemaContext;
    private XamlContextStack`1<Baml2006ReaderFrame> _stack;
    public Baml2006SchemaContext SchemaContext { get; }
    public Baml2006ReaderFrame CurrentFrame { get; }
    public Baml2006ReaderFrame PreviousFrame { get; }
    public List`1<KeyRecord> KeyList { get; public set; }
    public int CurrentKey { get; public set; }
    public KeyRecord LastKey { get; }
    public bool InsideKeyRecord { get; public set; }
    public bool InsideStaticResource { get; public set; }
    public int TemplateStartDepth { get; public set; }
    public int LineNumber { get; public set; }
    public int LineOffset { get; public set; }
    public Baml2006ReaderContext(Baml2006SchemaContext schemaContext);
    public Baml2006SchemaContext get_SchemaContext();
    public void PushScope();
    public void PopScope();
    public Baml2006ReaderFrame get_CurrentFrame();
    public Baml2006ReaderFrame get_PreviousFrame();
    [CompilerGeneratedAttribute]
public List`1<KeyRecord> get_KeyList();
    [CompilerGeneratedAttribute]
public void set_KeyList(List`1<KeyRecord> value);
    [CompilerGeneratedAttribute]
public int get_CurrentKey();
    [CompilerGeneratedAttribute]
public void set_CurrentKey(int value);
    public KeyRecord get_LastKey();
    [CompilerGeneratedAttribute]
public bool get_InsideKeyRecord();
    [CompilerGeneratedAttribute]
public void set_InsideKeyRecord(bool value);
    [CompilerGeneratedAttribute]
public bool get_InsideStaticResource();
    [CompilerGeneratedAttribute]
public void set_InsideStaticResource(bool value);
    [CompilerGeneratedAttribute]
public int get_TemplateStartDepth();
    [CompilerGeneratedAttribute]
public void set_TemplateStartDepth(int value);
    [CompilerGeneratedAttribute]
public int get_LineNumber();
    [CompilerGeneratedAttribute]
public void set_LineNumber(int value);
    [CompilerGeneratedAttribute]
public int get_LineOffset();
    [CompilerGeneratedAttribute]
public void set_LineOffset(int value);
}
internal class System.Windows.Baml2006.Baml2006ReaderFrame : XamlFrame {
    protected Dictionary`2<string, string> _namespaces;
    [CompilerGeneratedAttribute]
private XamlType <XamlType>k__BackingField;
    [CompilerGeneratedAttribute]
private XamlMember <Member>k__BackingField;
    [CompilerGeneratedAttribute]
private KeyRecord <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private int <DelayedConnectionId>k__BackingField;
    [CompilerGeneratedAttribute]
private XamlMember <ContentProperty>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <FreezeFreezables>k__BackingField;
    [CompilerGeneratedAttribute]
private Baml2006ReaderFrameFlags <Flags>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsDeferredContent>k__BackingField;
    public XamlType XamlType { get; public set; }
    public XamlMember Member { get; public set; }
    public KeyRecord Key { get; public set; }
    public int DelayedConnectionId { get; public set; }
    public XamlMember ContentProperty { get; public set; }
    public bool FreezeFreezables { get; public set; }
    public Baml2006ReaderFrameFlags Flags { get; public set; }
    public bool IsDeferredContent { get; public set; }
    public Baml2006ReaderFrame(Baml2006ReaderFrame source);
    public virtual XamlFrame Clone();
    [CompilerGeneratedAttribute]
public XamlType get_XamlType();
    [CompilerGeneratedAttribute]
public void set_XamlType(XamlType value);
    [CompilerGeneratedAttribute]
public XamlMember get_Member();
    [CompilerGeneratedAttribute]
public void set_Member(XamlMember value);
    [CompilerGeneratedAttribute]
public KeyRecord get_Key();
    [CompilerGeneratedAttribute]
public void set_Key(KeyRecord value);
    [CompilerGeneratedAttribute]
public int get_DelayedConnectionId();
    [CompilerGeneratedAttribute]
public void set_DelayedConnectionId(int value);
    [CompilerGeneratedAttribute]
public XamlMember get_ContentProperty();
    [CompilerGeneratedAttribute]
public void set_ContentProperty(XamlMember value);
    [CompilerGeneratedAttribute]
public bool get_FreezeFreezables();
    [CompilerGeneratedAttribute]
public void set_FreezeFreezables(bool value);
    public void AddNamespace(string prefix, string xamlNs);
    public void SetNamespaces(Dictionary`2<string, string> namespaces);
    public bool TryGetNamespaceByPrefix(string prefix, String& xamlNs);
    public bool TryGetPrefixByNamespace(string xamlNs, String& prefix);
    public virtual void Reset();
    [CompilerGeneratedAttribute]
public Baml2006ReaderFrameFlags get_Flags();
    [CompilerGeneratedAttribute]
public void set_Flags(Baml2006ReaderFrameFlags value);
    [CompilerGeneratedAttribute]
public bool get_IsDeferredContent();
    [CompilerGeneratedAttribute]
public void set_IsDeferredContent(bool value);
}
internal enum System.Windows.Baml2006.Baml2006ReaderFrameFlags : Enum {
    public byte value__;
    public static Baml2006ReaderFrameFlags None;
    public static Baml2006ReaderFrameFlags IsImplict;
    public static Baml2006ReaderFrameFlags HasImplicitProperty;
}
internal class System.Windows.Baml2006.Baml2006ReaderInternal : Baml2006Reader {
    internal Baml2006ReaderInternal(Stream stream, Baml2006SchemaContext schemaContext, Baml2006ReaderSettings settings);
    internal Baml2006ReaderInternal(Stream stream, Baml2006SchemaContext baml2006SchemaContext, Baml2006ReaderSettings baml2006ReaderSettings, object root);
    internal virtual string GetAssemblyNameForNamespace(Assembly asm);
    internal virtual object CreateTypeConverterMarkupExtension(XamlMember property, TypeConverter converter, object propertyValue, Baml2006ReaderSettings settings);
}
internal class System.Windows.Baml2006.Baml2006ReaderSettings : XamlReaderSettings {
    [CompilerGeneratedAttribute]
private bool <OwnsStream>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsBamlFragment>k__BackingField;
    internal bool OwnsStream { get; internal set; }
    internal bool IsBamlFragment { get; internal set; }
    public Baml2006ReaderSettings(Baml2006ReaderSettings settings);
    public Baml2006ReaderSettings(XamlReaderSettings settings);
    [CompilerGeneratedAttribute]
internal bool get_OwnsStream();
    [CompilerGeneratedAttribute]
internal void set_OwnsStream(bool value);
    [CompilerGeneratedAttribute]
internal bool get_IsBamlFragment();
    [CompilerGeneratedAttribute]
internal void set_IsBamlFragment(bool value);
}
internal enum System.Windows.Baml2006.Baml2006RecordType : Enum {
    public byte value__;
    public static Baml2006RecordType Unknown;
    public static Baml2006RecordType DocumentStart;
    public static Baml2006RecordType DocumentEnd;
    public static Baml2006RecordType ElementStart;
    public static Baml2006RecordType ElementEnd;
    public static Baml2006RecordType Property;
    public static Baml2006RecordType PropertyCustom;
    public static Baml2006RecordType PropertyComplexStart;
    public static Baml2006RecordType PropertyComplexEnd;
    public static Baml2006RecordType PropertyArrayStart;
    public static Baml2006RecordType PropertyArrayEnd;
    public static Baml2006RecordType PropertyIListStart;
    public static Baml2006RecordType PropertyIListEnd;
    public static Baml2006RecordType PropertyIDictionaryStart;
    public static Baml2006RecordType PropertyIDictionaryEnd;
    public static Baml2006RecordType LiteralContent;
    public static Baml2006RecordType Text;
    public static Baml2006RecordType TextWithConverter;
    public static Baml2006RecordType RoutedEvent;
    public static Baml2006RecordType ClrEvent;
    public static Baml2006RecordType XmlnsProperty;
    public static Baml2006RecordType XmlAttribute;
    public static Baml2006RecordType ProcessingInstruction;
    public static Baml2006RecordType Comment;
    public static Baml2006RecordType DefTag;
    public static Baml2006RecordType DefAttribute;
    public static Baml2006RecordType EndAttributes;
    public static Baml2006RecordType PIMapping;
    public static Baml2006RecordType AssemblyInfo;
    public static Baml2006RecordType TypeInfo;
    public static Baml2006RecordType TypeSerializerInfo;
    public static Baml2006RecordType AttributeInfo;
    public static Baml2006RecordType StringInfo;
    public static Baml2006RecordType PropertyStringReference;
    public static Baml2006RecordType PropertyTypeReference;
    public static Baml2006RecordType PropertyWithExtension;
    public static Baml2006RecordType PropertyWithConverter;
    public static Baml2006RecordType DeferableContentStart;
    public static Baml2006RecordType DefAttributeKeyString;
    public static Baml2006RecordType DefAttributeKeyType;
    public static Baml2006RecordType KeyElementStart;
    public static Baml2006RecordType KeyElementEnd;
    public static Baml2006RecordType ConstructorParametersStart;
    public static Baml2006RecordType ConstructorParametersEnd;
    public static Baml2006RecordType ConstructorParameterType;
    public static Baml2006RecordType ConnectionId;
    public static Baml2006RecordType ContentProperty;
    public static Baml2006RecordType NamedElementStart;
    public static Baml2006RecordType StaticResourceStart;
    public static Baml2006RecordType StaticResourceEnd;
    public static Baml2006RecordType StaticResourceId;
    public static Baml2006RecordType TextWithId;
    public static Baml2006RecordType PresentationOptionsAttribute;
    public static Baml2006RecordType LineNumberAndPosition;
    public static Baml2006RecordType LinePosition;
    public static Baml2006RecordType OptimizedStaticResource;
    public static Baml2006RecordType PropertyWithStaticResourceId;
    public static Baml2006RecordType LastRecordType;
}
internal class System.Windows.Baml2006.Baml2006SchemaContext : XamlSchemaContext {
    [CompilerGeneratedAttribute]
private Baml2006ReaderSettings <Settings>k__BackingField;
    internal static short StaticExtensionTypeId;
    internal static short StaticResourceTypeId;
    internal static short DynamicResourceTypeId;
    internal static short TemplateBindingTypeId;
    internal static short TypeExtensionTypeId;
    internal static string WpfNamespace;
    private List`1<BamlAssembly> _bamlAssembly;
    private List`1<object> _bamlType;
    private List`1<object> _bamlProperty;
    private List`1<string> _bamlString;
    private Dictionary`2<string, Int16[]> _bamlXmlnsMappings;
    private static Lazy`1<XamlMember> _xStaticMemberProperty;
    private static Lazy`1<XamlMember> _xTypeTypeProperty;
    private static Lazy`1<XamlMember> _resourceDictionaryDefContentProperty;
    private static Lazy`1<XamlType> _resourceDictionaryType;
    private static Lazy`1<XamlType> _eventSetterType;
    private static Lazy`1<XamlMember> _eventSetterEventProperty;
    private static Lazy`1<XamlMember> _eventSetterHandlerProperty;
    private static Lazy`1<XamlMember> _frameworkTemplateTemplateProperty;
    private static Lazy`1<XamlType> _staticResourceExtensionType;
    private object _syncObject;
    private Assembly _localAssembly;
    private XamlSchemaContext _parentSchemaContext;
    internal XamlMember StaticExtensionMemberTypeProperty { get; }
    internal XamlMember TypeExtensionTypeProperty { get; }
    internal XamlMember ResourceDictionaryDeferredContentProperty { get; }
    internal XamlType ResourceDictionaryType { get; }
    internal XamlType EventSetterType { get; }
    internal XamlMember EventSetterEventProperty { get; }
    internal XamlMember EventSetterHandlerProperty { get; }
    internal XamlMember FrameworkTemplateTemplateProperty { get; }
    internal XamlType StaticResourceExtensionType { get; }
    internal Assembly LocalAssembly { get; }
    internal Baml2006ReaderSettings Settings { get; internal set; }
    public Baml2006SchemaContext(Assembly localAssembly);
    internal Baml2006SchemaContext(Assembly localAssembly, XamlSchemaContext parentSchemaContext);
    private static Baml2006SchemaContext();
    public virtual bool TryGetCompatibleXamlNamespace(string xamlNamespace, String& compatibleNamespace);
    public virtual XamlDirective GetXamlDirective(string xamlNamespace, string name);
    public virtual IEnumerable`1<string> GetAllXamlNamespaces();
    public virtual ICollection`1<XamlType> GetAllXamlTypes(string xamlNamespace);
    public virtual string GetPreferredPrefix(string xmlns);
    public virtual XamlType GetXamlType(Type type);
    protected virtual XamlType GetXamlType(string xamlNamespace, string name, XamlType[] typeArguments);
    internal XamlMember get_StaticExtensionMemberTypeProperty();
    internal XamlMember get_TypeExtensionTypeProperty();
    internal XamlMember get_ResourceDictionaryDeferredContentProperty();
    internal XamlType get_ResourceDictionaryType();
    internal XamlType get_EventSetterType();
    internal XamlMember get_EventSetterEventProperty();
    internal XamlMember get_EventSetterHandlerProperty();
    internal XamlMember get_FrameworkTemplateTemplateProperty();
    internal XamlType get_StaticResourceExtensionType();
    internal Assembly get_LocalAssembly();
    [CompilerGeneratedAttribute]
internal Baml2006ReaderSettings get_Settings();
    [CompilerGeneratedAttribute]
internal void set_Settings(Baml2006ReaderSettings value);
    internal void Reset();
    internal Assembly GetAssembly(short assemblyId);
    internal string GetAssemblyName(short assemblyId);
    internal Type GetClrType(short typeId);
    internal XamlType GetXamlType(short typeId);
    internal DependencyProperty GetDependencyProperty(short propertyId);
    internal XamlMember GetProperty(short propertyId, XamlType parentType);
    internal XamlMember GetProperty(short propertyId, bool isAttached);
    internal XamlType GetPropertyDeclaringType(short propertyId);
    internal string GetPropertyName(short propertyId, bool fullName);
    internal string GetString(short stringId);
    internal void AddAssembly(short assemblyId, string assemblyName);
    internal void AddXamlType(short typeId, short assemblyId, string typeName, TypeInfoFlags flags);
    internal void AddProperty(short propertyId, short declaringTypeId, string propertyName);
    internal void AddString(short stringId, string value);
    internal void AddXmlnsMapping(string xmlns, Int16[] assemblies);
    private void EnsureXmlnsAssembliesLoaded(string xamlNamespace);
    private Assembly ResolveAssembly(BamlAssembly bamlAssembly);
    private bool MatchesLocalAssembly(string shortName, Byte[] publicKeyToken);
    private Type ResolveBamlTypeToType(BamlType bamlType);
    private XamlType ResolveBamlType(BamlType bamlType, short typeId);
    private bool TryGetBamlAssembly(short assemblyId, BamlAssembly& bamlAssembly);
    private bool TryGetBamlType(short typeId, BamlType& bamlType, XamlType& xamlType);
    private bool TryGetBamlProperty(short propertyId, BamlProperty& bamlProperty, XamlMember& xamlMember);
}
internal class System.Windows.Baml2006.Baml6Assembly : object {
    public string Name;
    private Assembly _assembly;
    public Assembly Assembly { get; }
    public Baml6Assembly(string name);
    public Baml6Assembly(Assembly assembly);
    public Assembly get_Assembly();
}
internal class System.Windows.Baml2006.Baml6ConstructorInfo : ValueType {
    private List`1<Type> _types;
    private Func`2<Object[], object> _constructor;
    public List`1<Type> Types { get; }
    public Func`2<Object[], object> Constructor { get; }
    public Baml6ConstructorInfo(List`1<Type> types, Func`2<Object[], object> ctor);
    public List`1<Type> get_Types();
    public Func`2<Object[], object> get_Constructor();
}
internal static class System.Windows.Baml2006.Baml6KnownTypes : object {
    public static short BooleanConverter;
    public static short DependencyPropertyConverter;
    public static short EnumConverter;
    public static short XamlBrushSerializer;
    public static short XamlInt32CollectionSerializer;
    public static short XamlPathDataSerializer;
    public static short XamlPoint3DCollectionSerializer;
    public static short XamlPointCollectionSerializer;
    public static short XamlVector3DCollectionSerializer;
}
internal class System.Windows.Baml2006.BamlBinaryReader : BinaryReader {
    public BamlBinaryReader(Stream stream);
    public int Read7BitEncodedInt();
}
internal class System.Windows.Baml2006.DeferredBinaryDeserializerExtension : MarkupExtension {
    private IFreezeFreezables _freezer;
    private bool _canFreeze;
    private BinaryReader _reader;
    private Stream _stream;
    private int _converterId;
    public DeferredBinaryDeserializerExtension(IFreezeFreezables freezer, BinaryReader reader, int converterId, int dataByteSize);
    public virtual object ProvideValue(IServiceProvider serviceProvider);
}
[DebuggerDisplayAttribute("{DebuggerString}")]
internal class System.Windows.Baml2006.KeyRecord : object {
    [CompilerGeneratedAttribute]
private long <ValuePosition>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ValueSize>k__BackingField;
    [CompilerGeneratedAttribute]
private byte <Flags>k__BackingField;
    private List`1<object> _resources;
    private object _data;
    private bool _shared;
    private bool _sharedSet;
    public bool Shared { get; }
    public bool SharedSet { get; }
    public long ValuePosition { get; public set; }
    public int ValueSize { get; public set; }
    public byte Flags { get; public set; }
    public List`1<object> StaticResources { get; }
    public bool HasStaticResources { get; }
    public StaticResource LastStaticResource { get; }
    public string KeyString { get; }
    public Type KeyType { get; }
    public XamlNodeList KeyNodeList { get; }
    public KeyRecord(bool shared, bool sharedSet, int valuePosition, Type keyType);
    public KeyRecord(bool shared, bool sharedSet, int valuePosition, string keyString);
    public KeyRecord(bool shared, bool sharedSet, int valuePosition, XamlSchemaContext context);
    private KeyRecord(bool shared, bool sharedSet, int valuePosition);
    public bool get_Shared();
    public bool get_SharedSet();
    [CompilerGeneratedAttribute]
public long get_ValuePosition();
    [CompilerGeneratedAttribute]
public void set_ValuePosition(long value);
    [CompilerGeneratedAttribute]
public int get_ValueSize();
    [CompilerGeneratedAttribute]
public void set_ValueSize(int value);
    [CompilerGeneratedAttribute]
public byte get_Flags();
    [CompilerGeneratedAttribute]
public void set_Flags(byte value);
    public List`1<object> get_StaticResources();
    public bool get_HasStaticResources();
    public StaticResource get_LastStaticResource();
    public string get_KeyString();
    public Type get_KeyType();
    public XamlNodeList get_KeyNodeList();
}
internal class System.Windows.Baml2006.OptimizedStaticResource : object {
    [CompilerGeneratedAttribute]
private short <KeyId>k__BackingField;
    [CompilerGeneratedAttribute]
private object <KeyValue>k__BackingField;
    private bool _isStatic;
    private bool _isType;
    private static byte TypeExtensionValueMask;
    private static byte StaticExtensionValueMask;
    public short KeyId { get; public set; }
    public object KeyValue { get; public set; }
    public bool IsKeyStaticExtension { get; }
    public bool IsKeyTypeExtension { get; }
    public OptimizedStaticResource(byte flags, short keyId);
    private static OptimizedStaticResource();
    [CompilerGeneratedAttribute]
public short get_KeyId();
    [CompilerGeneratedAttribute]
public void set_KeyId(short value);
    [CompilerGeneratedAttribute]
public object get_KeyValue();
    [CompilerGeneratedAttribute]
public void set_KeyValue(object value);
    public bool get_IsKeyStaticExtension();
    public bool get_IsKeyTypeExtension();
}
internal class System.Windows.Baml2006.SharedStream : Stream {
    private Stream _baseStream;
    private long _offset;
    private long _length;
    private long _position;
    private RefCount _refCount;
    public int SharedCount { get; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public bool IsDisposed { get; }
    public Stream BaseStream { get; }
    public SharedStream(Stream baseStream);
    public SharedStream(Stream baseStream, long offset, long length);
    private void Initialize(Stream baseStream, long offset, long length);
    public virtual int get_SharedCount();
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual void Flush();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual bool get_IsDisposed();
    public virtual int ReadByte();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    protected virtual void Dispose(bool disposing);
    public Stream get_BaseStream();
    private void CheckDisposed();
    private bool Sync();
}
internal class System.Windows.Baml2006.SourceUriTypeConverterMarkupExtension : TypeConverterMarkupExtension {
    private Assembly _assemblyInfo;
    public SourceUriTypeConverterMarkupExtension(TypeConverter converter, object value, Assembly assemblyInfo);
    public virtual object ProvideValue(IServiceProvider serviceProvider);
}
internal class System.Windows.Baml2006.StaticResource : object {
    [CompilerGeneratedAttribute]
private XamlNodeList <ResourceNodeList>k__BackingField;
    public XamlNodeList ResourceNodeList { get; private set; }
    public StaticResource(XamlType type, XamlSchemaContext schemaContext);
    [CompilerGeneratedAttribute]
public XamlNodeList get_ResourceNodeList();
    [CompilerGeneratedAttribute]
private void set_ResourceNodeList(XamlNodeList value);
}
internal abstract class System.Windows.Baml2006.ThemeKnownTypeHelper : object {
    public abstract virtual XamlType GetKnownXamlType(string name);
}
internal class System.Windows.Baml2006.TypeConverterMarkupExtension : MarkupExtension {
    private TypeConverter _converter;
    private object _value;
    public TypeConverterMarkupExtension(TypeConverter converter, object value);
    public virtual object ProvideValue(IServiceProvider serviceProvider);
}
internal class System.Windows.Baml2006.WpfKnownMember : WpfXamlMember {
    private Action`2<object, object> _setDelegate;
    private Func`2<object, object> _getDelegate;
    private Type _deferringLoader;
    private Type _typeConverterType;
    private Type _type;
    private byte _bitField;
    private bool Frozen { get; private set; }
    private bool ReadOnly { get; private set; }
    public bool HasSpecialTypeConverter { get; public set; }
    public bool Ambient { get; public set; }
    public bool IsReadPrivate { get; public set; }
    public bool IsWritePrivate { get; public set; }
    public Action`2<object, object> SetDelegate { get; public set; }
    public Func`2<object, object> GetDelegate { get; public set; }
    public Type TypeConverterType { get; public set; }
    public Type DeferringLoaderType { get; public set; }
    public WpfKnownMember(XamlSchemaContext schema, XamlType declaringType, string name, DependencyProperty dProperty, bool isReadOnly, bool isAttachable);
    public WpfKnownMember(XamlSchemaContext schema, XamlType declaringType, string name, Type type, bool isReadOnly, bool isAttachable);
    private bool get_Frozen();
    private void set_Frozen(bool value);
    private bool get_ReadOnly();
    private void set_ReadOnly(bool value);
    public bool get_HasSpecialTypeConverter();
    public void set_HasSpecialTypeConverter(bool value);
    public bool get_Ambient();
    public void set_Ambient(bool value);
    public bool get_IsReadPrivate();
    public void set_IsReadPrivate(bool value);
    public bool get_IsWritePrivate();
    public void set_IsWritePrivate(bool value);
    protected virtual bool LookupIsUnknown();
    public void Freeze();
    private void CheckFrozen();
    protected virtual XamlMemberInvoker LookupInvoker();
    public Action`2<object, object> get_SetDelegate();
    public void set_SetDelegate(Action`2<object, object> value);
    public Func`2<object, object> get_GetDelegate();
    public void set_GetDelegate(Func`2<object, object> value);
    public Type get_TypeConverterType();
    public void set_TypeConverterType(Type value);
    protected virtual XamlValueConverter`1<TypeConverter> LookupTypeConverter();
    public Type get_DeferringLoaderType();
    public void set_DeferringLoaderType(Type value);
    protected virtual XamlValueConverter`1<XamlDeferringLoader> LookupDeferringLoader();
    protected virtual bool LookupIsReadOnly();
    protected virtual XamlType LookupType();
    protected virtual MemberInfo LookupUnderlyingMember();
    protected virtual bool LookupIsAmbient();
    protected virtual bool LookupIsWritePublic();
    protected virtual bool LookupIsReadPublic();
    protected virtual WpfXamlMember GetAsContentProperty();
}
internal class System.Windows.Baml2006.WpfKnownMemberInvoker : XamlMemberInvoker {
    private WpfKnownMember _member;
    private bool _hasShouldSerializeMethodBeenLookedup;
    private MethodInfo _shouldSerializeMethod;
    public WpfKnownMemberInvoker(WpfKnownMember member);
    public virtual object GetValue(object instance);
    public virtual void SetValue(object instance, object value);
    public virtual ShouldSerializeResult ShouldSerializeValue(object instance);
}
internal class System.Windows.Baml2006.WpfKnownType : WpfXamlType {
    private static Attribute[] s_EmptyAttributes;
    private short _bamlNumber;
    private string _name;
    private Type _underlyingType;
    private string _contentPropertyName;
    private string _runtimeNamePropertyName;
    private string _dictionaryKeyPropertyName;
    private string _xmlLangPropertyName;
    private string _uidPropertyName;
    private Func`1<object> _defaultConstructor;
    private Type _deferringLoader;
    private Type _typeConverterType;
    private XamlCollectionKind _collectionKind;
    private Dictionary`2<int, Baml6ConstructorInfo> _constructors;
    private bool Frozen { get; private set; }
    public bool WhitespaceSignificantCollection { get; public set; }
    public bool IsUsableDuringInit { get; public set; }
    public bool HasSpecialValueConverter { get; public set; }
    public short BamlNumber { get; }
    public string ContentPropertyName { get; public set; }
    public string RuntimeNamePropertyName { get; public set; }
    public string XmlLangPropertyName { get; public set; }
    public string UidPropertyName { get; public set; }
    public string DictionaryKeyPropertyName { get; public set; }
    public XamlCollectionKind CollectionKind { get; public set; }
    public Func`1<object> DefaultConstructor { get; public set; }
    public Type TypeConverterType { get; public set; }
    public Type DeferringLoaderType { get; public set; }
    public Dictionary`2<int, Baml6ConstructorInfo> Constructors { get; }
    public WpfKnownType(XamlSchemaContext schema, int bamlNumber, string name, Type underlyingType);
    public WpfKnownType(XamlSchemaContext schema, int bamlNumber, string name, Type underlyingType, bool isBamlType, bool useV3Rules);
    private bool get_Frozen();
    private void set_Frozen(bool value);
    public bool get_WhitespaceSignificantCollection();
    public void set_WhitespaceSignificantCollection(bool value);
    public bool get_IsUsableDuringInit();
    public void set_IsUsableDuringInit(bool value);
    public bool get_HasSpecialValueConverter();
    public void set_HasSpecialValueConverter(bool value);
    public void Freeze();
    private void CheckFrozen();
    public short get_BamlNumber();
    protected virtual XamlMember LookupContentProperty();
    public string get_ContentPropertyName();
    public void set_ContentPropertyName(string value);
    protected virtual XamlMember LookupAliasedProperty(XamlDirective directive);
    public string get_RuntimeNamePropertyName();
    public void set_RuntimeNamePropertyName(string value);
    public string get_XmlLangPropertyName();
    public void set_XmlLangPropertyName(string value);
    public string get_UidPropertyName();
    public void set_UidPropertyName(string value);
    public string get_DictionaryKeyPropertyName();
    public void set_DictionaryKeyPropertyName(string value);
    protected virtual XamlCollectionKind LookupCollectionKind();
    public XamlCollectionKind get_CollectionKind();
    public void set_CollectionKind(XamlCollectionKind value);
    protected virtual bool LookupIsWhitespaceSignificantCollection();
    public Func`1<object> get_DefaultConstructor();
    public void set_DefaultConstructor(Func`1<object> value);
    protected virtual XamlValueConverter`1<TypeConverter> LookupTypeConverter();
    public Type get_TypeConverterType();
    public void set_TypeConverterType(Type value);
    public Type get_DeferringLoaderType();
    public void set_DeferringLoaderType(Type value);
    protected virtual XamlValueConverter`1<XamlDeferringLoader> LookupDeferringLoader();
    protected virtual EventHandler`1<XamlSetMarkupExtensionEventArgs> LookupSetMarkupExtensionHandler();
    protected virtual EventHandler`1<XamlSetTypeConverterEventArgs> LookupSetTypeConverterHandler();
    protected virtual bool LookupUsableDuringInitialization();
    protected virtual XamlTypeInvoker LookupInvoker();
    private XamlMember CallGetMember(string name);
    public Dictionary`2<int, Baml6ConstructorInfo> get_Constructors();
    protected virtual IList`1<XamlType> LookupPositionalParameters(int paramCount);
    protected virtual ICustomAttributeProvider LookupCustomAttributeProvider();
    private sealed virtual override Object[] System.Reflection.ICustomAttributeProvider.GetCustomAttributes(bool inherit);
    private sealed virtual override Object[] System.Reflection.ICustomAttributeProvider.GetCustomAttributes(Type attributeType, bool inherit);
    private bool TryGetCustomAttribute(Type attributeType, Attribute& result);
    private sealed virtual override bool System.Reflection.ICustomAttributeProvider.IsDefined(Type attributeType, bool inherit);
}
internal class System.Windows.Baml2006.WpfKnownTypeInvoker : XamlTypeInvoker {
    private WpfKnownType _type;
    public WpfKnownTypeInvoker(WpfKnownType type);
    public virtual object CreateInstance(Object[] arguments);
}
internal class System.Windows.Baml2006.WpfMemberInvoker : XamlMemberInvoker {
    private WpfXamlMember _member;
    private bool _hasShouldSerializeMethodBeenLookedup;
    private MethodInfo _shouldSerializeMethod;
    public WpfMemberInvoker(WpfXamlMember member);
    public virtual void SetValue(object instance, object value);
    public virtual object GetValue(object instance);
    public virtual ShouldSerializeResult ShouldSerializeValue(object instance);
}
internal class System.Windows.Baml2006.WpfSharedBamlSchemaContext : XamlSchemaContext {
    private static int KnownPropertyCount;
    private static int KnownTypeCount;
    private object _syncObject;
    private Baml6Assembly[] _knownBamlAssemblies;
    private WpfKnownType[] _knownBamlTypes;
    private WpfKnownMember[] _knownBamlMembers;
    private Dictionary`2<Type, XamlType> _masterTypeTable;
    private XmlnsDictionary _wpfDefaultNamespace;
    private List`1<ThemeKnownTypeHelper> _themeHelpers;
    [CompilerGeneratedAttribute]
private Baml2006ReaderSettings <Settings>k__BackingField;
    private static Lazy`1<XamlMember> _xStaticMemberProperty;
    private static Lazy`1<XamlMember> _xTypeTypeProperty;
    private static Lazy`1<XamlMember> _resourceDictionaryDefContentProperty;
    private static Lazy`1<XamlType> _resourceDictionaryType;
    private static Lazy`1<XamlType> _eventSetterType;
    private static Lazy`1<XamlMember> _eventSetterEventProperty;
    private static Lazy`1<XamlMember> _eventSetterHandlerProperty;
    private static Lazy`1<XamlMember> _frameworkTemplateTemplateProperty;
    private static Lazy`1<XamlType> _staticResourceExtensionType;
    internal XamlMember StaticExtensionMemberTypeProperty { get; }
    internal XamlMember TypeExtensionTypeProperty { get; }
    internal XamlMember ResourceDictionaryDeferredContentProperty { get; }
    internal XamlType ResourceDictionaryType { get; }
    internal XamlType EventSetterType { get; }
    internal XamlMember EventSetterEventProperty { get; }
    internal XamlMember EventSetterHandlerProperty { get; }
    internal XamlMember FrameworkTemplateTemplateProperty { get; }
    internal XamlType StaticResourceExtensionType { get; }
    internal Baml2006ReaderSettings Settings { get; internal set; }
    internal List`1<ThemeKnownTypeHelper> ThemeKnownTypeHelpers { get; }
    public WpfSharedBamlSchemaContext(XamlSchemaContextSettings settings);
    private static WpfSharedBamlSchemaContext();
    private WpfKnownMember CreateKnownMember(short bamlNumber);
    private UInt32 GetTypeNameHashForPropeties(string typeName);
    internal WpfKnownMember CreateKnownMember(string type, string property);
    internal WpfKnownMember CreateKnownAttachableMember(string type, string property);
    private WpfKnownMember Create_BamlProperty_AccessText_Text();
    private WpfKnownMember Create_BamlProperty_BeginStoryboard_Storyboard();
    private WpfKnownMember Create_BamlProperty_BitmapEffectGroup_Children();
    private WpfKnownMember Create_BamlProperty_Border_Background();
    private WpfKnownMember Create_BamlProperty_Border_BorderBrush();
    private WpfKnownMember Create_BamlProperty_Border_BorderThickness();
    private WpfKnownMember Create_BamlProperty_ButtonBase_Command();
    private WpfKnownMember Create_BamlProperty_ButtonBase_CommandParameter();
    private WpfKnownMember Create_BamlProperty_ButtonBase_CommandTarget();
    private WpfKnownMember Create_BamlProperty_ButtonBase_IsPressed();
    private WpfKnownMember Create_BamlProperty_ColumnDefinition_MaxWidth();
    private WpfKnownMember Create_BamlProperty_ColumnDefinition_MinWidth();
    private WpfKnownMember Create_BamlProperty_ColumnDefinition_Width();
    private WpfKnownMember Create_BamlProperty_ContentControl_Content();
    private WpfKnownMember Create_BamlProperty_ContentControl_ContentTemplate();
    private WpfKnownMember Create_BamlProperty_ContentControl_ContentTemplateSelector();
    private WpfKnownMember Create_BamlProperty_ContentControl_HasContent();
    private WpfKnownMember Create_BamlProperty_ContentElement_Focusable();
    private WpfKnownMember Create_BamlProperty_ContentPresenter_Content();
    private WpfKnownMember Create_BamlProperty_ContentPresenter_ContentSource();
    private WpfKnownMember Create_BamlProperty_ContentPresenter_ContentTemplate();
    private WpfKnownMember Create_BamlProperty_ContentPresenter_ContentTemplateSelector();
    private WpfKnownMember Create_BamlProperty_ContentPresenter_RecognizesAccessKey();
    private WpfKnownMember Create_BamlProperty_Control_Background();
    private WpfKnownMember Create_BamlProperty_Control_BorderBrush();
    private WpfKnownMember Create_BamlProperty_Control_BorderThickness();
    private WpfKnownMember Create_BamlProperty_Control_FontFamily();
    private WpfKnownMember Create_BamlProperty_Control_FontSize();
    private WpfKnownMember Create_BamlProperty_Control_FontStretch();
    private WpfKnownMember Create_BamlProperty_Control_FontStyle();
    private WpfKnownMember Create_BamlProperty_Control_FontWeight();
    private WpfKnownMember Create_BamlProperty_Control_Foreground();
    private WpfKnownMember Create_BamlProperty_Control_HorizontalContentAlignment();
    private WpfKnownMember Create_BamlProperty_Control_IsTabStop();
    private WpfKnownMember Create_BamlProperty_Control_Padding();
    private WpfKnownMember Create_BamlProperty_Control_TabIndex();
    private WpfKnownMember Create_BamlProperty_Control_Template();
    private WpfKnownMember Create_BamlProperty_Control_VerticalContentAlignment();
    private WpfKnownMember Create_BamlProperty_DockPanel_Dock();
    private WpfKnownMember Create_BamlProperty_DockPanel_LastChildFill();
    private WpfKnownMember Create_BamlProperty_DocumentViewerBase_Document();
    private WpfKnownMember Create_BamlProperty_DrawingGroup_Children();
    private WpfKnownMember Create_BamlProperty_FlowDocumentReader_Document();
    private WpfKnownMember Create_BamlProperty_FlowDocumentScrollViewer_Document();
    private WpfKnownMember Create_BamlProperty_FrameworkContentElement_Style();
    private WpfKnownMember Create_BamlProperty_FrameworkElement_FlowDirection();
    private WpfKnownMember Create_BamlProperty_FrameworkElement_Height();
    private WpfKnownMember Create_BamlProperty_FrameworkElement_HorizontalAlignment();
    private WpfKnownMember Create_BamlProperty_FrameworkElement_Margin();
    private WpfKnownMember Create_BamlProperty_FrameworkElement_MaxHeight();
    private WpfKnownMember Create_BamlProperty_FrameworkElement_MaxWidth();
    private WpfKnownMember Create_BamlProperty_FrameworkElement_MinHeight();
    private WpfKnownMember Create_BamlProperty_FrameworkElement_MinWidth();
    private WpfKnownMember Create_BamlProperty_FrameworkElement_Name();
    private WpfKnownMember Create_BamlProperty_FrameworkElement_Style();
    private WpfKnownMember Create_BamlProperty_FrameworkElement_VerticalAlignment();
    private WpfKnownMember Create_BamlProperty_FrameworkElement_Width();
    private WpfKnownMember Create_BamlProperty_GeneralTransformGroup_Children();
    private WpfKnownMember Create_BamlProperty_GeometryGroup_Children();
    private WpfKnownMember Create_BamlProperty_GradientBrush_GradientStops();
    private WpfKnownMember Create_BamlProperty_Grid_Column();
    private WpfKnownMember Create_BamlProperty_Grid_ColumnSpan();
    private WpfKnownMember Create_BamlProperty_Grid_Row();
    private WpfKnownMember Create_BamlProperty_Grid_RowSpan();
    private WpfKnownMember Create_BamlProperty_GridViewColumn_Header();
    private WpfKnownMember Create_BamlProperty_HeaderedContentControl_HasHeader();
    private WpfKnownMember Create_BamlProperty_HeaderedContentControl_Header();
    private WpfKnownMember Create_BamlProperty_HeaderedContentControl_HeaderTemplate();
    private WpfKnownMember Create_BamlProperty_HeaderedContentControl_HeaderTemplateSelector();
    private WpfKnownMember Create_BamlProperty_HeaderedItemsControl_HasHeader();
    private WpfKnownMember Create_BamlProperty_HeaderedItemsControl_Header();
    private WpfKnownMember Create_BamlProperty_HeaderedItemsControl_HeaderTemplate();
    private WpfKnownMember Create_BamlProperty_HeaderedItemsControl_HeaderTemplateSelector();
    private WpfKnownMember Create_BamlProperty_Hyperlink_NavigateUri();
    private WpfKnownMember Create_BamlProperty_Image_Source();
    private WpfKnownMember Create_BamlProperty_Image_Stretch();
    private WpfKnownMember Create_BamlProperty_ItemsControl_ItemContainerStyle();
    private WpfKnownMember Create_BamlProperty_ItemsControl_ItemContainerStyleSelector();
    private WpfKnownMember Create_BamlProperty_ItemsControl_ItemTemplate();
    private WpfKnownMember Create_BamlProperty_ItemsControl_ItemTemplateSelector();
    private WpfKnownMember Create_BamlProperty_ItemsControl_ItemsPanel();
    private WpfKnownMember Create_BamlProperty_ItemsControl_ItemsSource();
    private WpfKnownMember Create_BamlProperty_MaterialGroup_Children();
    private WpfKnownMember Create_BamlProperty_Model3DGroup_Children();
    private WpfKnownMember Create_BamlProperty_Page_Content();
    private WpfKnownMember Create_BamlProperty_Panel_Background();
    private WpfKnownMember Create_BamlProperty_Path_Data();
    private WpfKnownMember Create_BamlProperty_PathFigure_Segments();
    private WpfKnownMember Create_BamlProperty_PathGeometry_Figures();
    private WpfKnownMember Create_BamlProperty_Popup_Child();
    private WpfKnownMember Create_BamlProperty_Popup_IsOpen();
    private WpfKnownMember Create_BamlProperty_Popup_Placement();
    private WpfKnownMember Create_BamlProperty_Popup_PopupAnimation();
    private WpfKnownMember Create_BamlProperty_RowDefinition_Height();
    private WpfKnownMember Create_BamlProperty_RowDefinition_MaxHeight();
    private WpfKnownMember Create_BamlProperty_RowDefinition_MinHeight();
    private WpfKnownMember Create_BamlProperty_ScrollViewer_CanContentScroll();
    private WpfKnownMember Create_BamlProperty_ScrollViewer_HorizontalScrollBarVisibility();
    private WpfKnownMember Create_BamlProperty_ScrollViewer_VerticalScrollBarVisibility();
    private WpfKnownMember Create_BamlProperty_Shape_Fill();
    private WpfKnownMember Create_BamlProperty_Shape_Stroke();
    private WpfKnownMember Create_BamlProperty_Shape_StrokeThickness();
    private WpfKnownMember Create_BamlProperty_TextBlock_Background();
    private WpfKnownMember Create_BamlProperty_TextBlock_FontFamily();
    private WpfKnownMember Create_BamlProperty_TextBlock_FontSize();
    private WpfKnownMember Create_BamlProperty_TextBlock_FontStretch();
    private WpfKnownMember Create_BamlProperty_TextBlock_FontStyle();
    private WpfKnownMember Create_BamlProperty_TextBlock_FontWeight();
    private WpfKnownMember Create_BamlProperty_TextBlock_Foreground();
    private WpfKnownMember Create_BamlProperty_TextBlock_Text();
    private WpfKnownMember Create_BamlProperty_TextBlock_TextDecorations();
    private WpfKnownMember Create_BamlProperty_TextBlock_TextTrimming();
    private WpfKnownMember Create_BamlProperty_TextBlock_TextWrapping();
    private WpfKnownMember Create_BamlProperty_TextBox_Text();
    private WpfKnownMember Create_BamlProperty_TextElement_Background();
    private WpfKnownMember Create_BamlProperty_TextElement_FontFamily();
    private WpfKnownMember Create_BamlProperty_TextElement_FontSize();
    private WpfKnownMember Create_BamlProperty_TextElement_FontStretch();
    private WpfKnownMember Create_BamlProperty_TextElement_FontStyle();
    private WpfKnownMember Create_BamlProperty_TextElement_FontWeight();
    private WpfKnownMember Create_BamlProperty_TextElement_Foreground();
    private WpfKnownMember Create_BamlProperty_TimelineGroup_Children();
    private WpfKnownMember Create_BamlProperty_Track_IsDirectionReversed();
    private WpfKnownMember Create_BamlProperty_Track_Maximum();
    private WpfKnownMember Create_BamlProperty_Track_Minimum();
    private WpfKnownMember Create_BamlProperty_Track_Orientation();
    private WpfKnownMember Create_BamlProperty_Track_Value();
    private WpfKnownMember Create_BamlProperty_Track_ViewportSize();
    private WpfKnownMember Create_BamlProperty_Transform3DGroup_Children();
    private WpfKnownMember Create_BamlProperty_TransformGroup_Children();
    private WpfKnownMember Create_BamlProperty_UIElement_ClipToBounds();
    private WpfKnownMember Create_BamlProperty_UIElement_Focusable();
    private WpfKnownMember Create_BamlProperty_UIElement_IsEnabled();
    private WpfKnownMember Create_BamlProperty_UIElement_RenderTransform();
    private WpfKnownMember Create_BamlProperty_UIElement_Visibility();
    private WpfKnownMember Create_BamlProperty_Viewport3D_Children();
    private WpfKnownMember Create_BamlProperty_AdornedElementPlaceholder_Child();
    private WpfKnownMember Create_BamlProperty_AdornerDecorator_Child();
    private WpfKnownMember Create_BamlProperty_AnchoredBlock_Blocks();
    private WpfKnownMember Create_BamlProperty_ArrayExtension_Items();
    private WpfKnownMember Create_BamlProperty_BlockUIContainer_Child();
    private WpfKnownMember Create_BamlProperty_Bold_Inlines();
    private WpfKnownMember Create_BamlProperty_BooleanAnimationUsingKeyFrames_KeyFrames();
    private WpfKnownMember Create_BamlProperty_Border_Child();
    private WpfKnownMember Create_BamlProperty_BulletDecorator_Child();
    private WpfKnownMember Create_BamlProperty_Button_Content();
    private WpfKnownMember Create_BamlProperty_ButtonBase_Content();
    private WpfKnownMember Create_BamlProperty_ByteAnimationUsingKeyFrames_KeyFrames();
    private WpfKnownMember Create_BamlProperty_Canvas_Children();
    private WpfKnownMember Create_BamlProperty_CharAnimationUsingKeyFrames_KeyFrames();
    private WpfKnownMember Create_BamlProperty_CheckBox_Content();
    private WpfKnownMember Create_BamlProperty_ColorAnimationUsingKeyFrames_KeyFrames();
    private WpfKnownMember Create_BamlProperty_ComboBox_Items();
    private WpfKnownMember Create_BamlProperty_ComboBoxItem_Content();
    private WpfKnownMember Create_BamlProperty_ContextMenu_Items();
    private WpfKnownMember Create_BamlProperty_ControlTemplate_VisualTree();
    private WpfKnownMember Create_BamlProperty_DataTemplate_VisualTree();
    private WpfKnownMember Create_BamlProperty_DataTrigger_Setters();
    private WpfKnownMember Create_BamlProperty_DecimalAnimationUsingKeyFrames_KeyFrames();
    private WpfKnownMember Create_BamlProperty_Decorator_Child();
    private WpfKnownMember Create_BamlProperty_DockPanel_Children();
    private WpfKnownMember Create_BamlProperty_DocumentViewer_Document();
    private WpfKnownMember Create_BamlProperty_DoubleAnimationUsingKeyFrames_KeyFrames();
    private WpfKnownMember Create_BamlProperty_EventTrigger_Actions();
    private WpfKnownMember Create_BamlProperty_Expander_Content();
    private WpfKnownMember Create_BamlProperty_Figure_Blocks();
    private WpfKnownMember Create_BamlProperty_FixedDocument_Pages();
    private WpfKnownMember Create_BamlProperty_FixedDocumentSequence_References();
    private WpfKnownMember Create_BamlProperty_FixedPage_Children();
    private WpfKnownMember Create_BamlProperty_Floater_Blocks();
    private WpfKnownMember Create_BamlProperty_FlowDocument_Blocks();
    private WpfKnownMember Create_BamlProperty_FlowDocumentPageViewer_Document();
    private WpfKnownMember Create_BamlProperty_FrameworkTemplate_VisualTree();
    private WpfKnownMember Create_BamlProperty_Grid_Children();
    private WpfKnownMember Create_BamlProperty_GridView_Columns();
    private WpfKnownMember Create_BamlProperty_GridViewColumnHeader_Content();
    private WpfKnownMember Create_BamlProperty_GroupBox_Content();
    private WpfKnownMember Create_BamlProperty_GroupItem_Content();
    private WpfKnownMember Create_BamlProperty_HeaderedContentControl_Content();
    private WpfKnownMember Create_BamlProperty_HeaderedItemsControl_Items();
    private WpfKnownMember Create_BamlProperty_HierarchicalDataTemplate_VisualTree();
    private WpfKnownMember Create_BamlProperty_Hyperlink_Inlines();
    private WpfKnownMember Create_BamlProperty_InkCanvas_Children();
    private WpfKnownMember Create_BamlProperty_InkPresenter_Child();
    private WpfKnownMember Create_BamlProperty_InlineUIContainer_Child();
    private WpfKnownMember Create_BamlProperty_InputScopeName_NameValue();
    private WpfKnownMember Create_BamlProperty_Int16AnimationUsingKeyFrames_KeyFrames();
    private WpfKnownMember Create_BamlProperty_Int32AnimationUsingKeyFrames_KeyFrames();
    private WpfKnownMember Create_BamlProperty_Int64AnimationUsingKeyFrames_KeyFrames();
    private WpfKnownMember Create_BamlProperty_Italic_Inlines();
    private WpfKnownMember Create_BamlProperty_ItemsControl_Items();
    private WpfKnownMember Create_BamlProperty_ItemsPanelTemplate_VisualTree();
    private WpfKnownMember Create_BamlProperty_Label_Content();
    private WpfKnownMember Create_BamlProperty_LinearGradientBrush_GradientStops();
    private WpfKnownMember Create_BamlProperty_List_ListItems();
    private WpfKnownMember Create_BamlProperty_ListBox_Items();
    private WpfKnownMember Create_BamlProperty_ListBoxItem_Content();
    private WpfKnownMember Create_BamlProperty_ListItem_Blocks();
    private WpfKnownMember Create_BamlProperty_ListView_Items();
    private WpfKnownMember Create_BamlProperty_ListViewItem_Content();
    private WpfKnownMember Create_BamlProperty_MatrixAnimationUsingKeyFrames_KeyFrames();
    private WpfKnownMember Create_BamlProperty_Menu_Items();
    private WpfKnownMember Create_BamlProperty_MenuBase_Items();
    private WpfKnownMember Create_BamlProperty_MenuItem_Items();
    private WpfKnownMember Create_BamlProperty_ModelVisual3D_Children();
    private WpfKnownMember Create_BamlProperty_MultiBinding_Bindings();
    private WpfKnownMember Create_BamlProperty_MultiDataTrigger_Setters();
    private WpfKnownMember Create_BamlProperty_MultiTrigger_Setters();
    private WpfKnownMember Create_BamlProperty_ObjectAnimationUsingKeyFrames_KeyFrames();
    private WpfKnownMember Create_BamlProperty_PageContent_Child();
    private WpfKnownMember Create_BamlProperty_PageFunctionBase_Content();
    private WpfKnownMember Create_BamlProperty_Panel_Children();
    private WpfKnownMember Create_BamlProperty_Paragraph_Inlines();
    private WpfKnownMember Create_BamlProperty_ParallelTimeline_Children();
    private WpfKnownMember Create_BamlProperty_Point3DAnimationUsingKeyFrames_KeyFrames();
    private WpfKnownMember Create_BamlProperty_PointAnimationUsingKeyFrames_KeyFrames();
    private WpfKnownMember Create_BamlProperty_PriorityBinding_Bindings();
    private WpfKnownMember Create_BamlProperty_QuaternionAnimationUsingKeyFrames_KeyFrames();
    private WpfKnownMember Create_BamlProperty_RadialGradientBrush_GradientStops();
    private WpfKnownMember Create_BamlProperty_RadioButton_Content();
    private WpfKnownMember Create_BamlProperty_RectAnimationUsingKeyFrames_KeyFrames();
    private WpfKnownMember Create_BamlProperty_RepeatButton_Content();
    private WpfKnownMember Create_BamlProperty_RichTextBox_Document();
    private WpfKnownMember Create_BamlProperty_Rotation3DAnimationUsingKeyFrames_KeyFrames();
    private WpfKnownMember Create_BamlProperty_Run_Text();
    private WpfKnownMember Create_BamlProperty_ScrollViewer_Content();
    private WpfKnownMember Create_BamlProperty_Section_Blocks();
    private WpfKnownMember Create_BamlProperty_Selector_Items();
    private WpfKnownMember Create_BamlProperty_SingleAnimationUsingKeyFrames_KeyFrames();
    private WpfKnownMember Create_BamlProperty_SizeAnimationUsingKeyFrames_KeyFrames();
    private WpfKnownMember Create_BamlProperty_Span_Inlines();
    private WpfKnownMember Create_BamlProperty_StackPanel_Children();
    private WpfKnownMember Create_BamlProperty_StatusBar_Items();
    private WpfKnownMember Create_BamlProperty_StatusBarItem_Content();
    private WpfKnownMember Create_BamlProperty_Storyboard_Children();
    private WpfKnownMember Create_BamlProperty_StringAnimationUsingKeyFrames_KeyFrames();
    private WpfKnownMember Create_BamlProperty_Style_Setters();
    private WpfKnownMember Create_BamlProperty_TabControl_Items();
    private WpfKnownMember Create_BamlProperty_TabItem_Content();
    private WpfKnownMember Create_BamlProperty_TabPanel_Children();
    private WpfKnownMember Create_BamlProperty_Table_RowGroups();
    private WpfKnownMember Create_BamlProperty_TableCell_Blocks();
    private WpfKnownMember Create_BamlProperty_TableRow_Cells();
    private WpfKnownMember Create_BamlProperty_TableRowGroup_Rows();
    private WpfKnownMember Create_BamlProperty_TextBlock_Inlines();
    private WpfKnownMember Create_BamlProperty_ThicknessAnimationUsingKeyFrames_KeyFrames();
    private WpfKnownMember Create_BamlProperty_ToggleButton_Content();
    private WpfKnownMember Create_BamlProperty_ToolBar_Items();
    private WpfKnownMember Create_BamlProperty_ToolBarOverflowPanel_Children();
    private WpfKnownMember Create_BamlProperty_ToolBarPanel_Children();
    private WpfKnownMember Create_BamlProperty_ToolBarTray_ToolBars();
    private WpfKnownMember Create_BamlProperty_ToolTip_Content();
    private WpfKnownMember Create_BamlProperty_TreeView_Items();
    private WpfKnownMember Create_BamlProperty_TreeViewItem_Items();
    private WpfKnownMember Create_BamlProperty_Trigger_Setters();
    private WpfKnownMember Create_BamlProperty_Underline_Inlines();
    private WpfKnownMember Create_BamlProperty_UniformGrid_Children();
    private WpfKnownMember Create_BamlProperty_UserControl_Content();
    private WpfKnownMember Create_BamlProperty_Vector3DAnimationUsingKeyFrames_KeyFrames();
    private WpfKnownMember Create_BamlProperty_VectorAnimationUsingKeyFrames_KeyFrames();
    private WpfKnownMember Create_BamlProperty_Viewbox_Child();
    private WpfKnownMember Create_BamlProperty_Viewport3DVisual_Children();
    private WpfKnownMember Create_BamlProperty_VirtualizingPanel_Children();
    private WpfKnownMember Create_BamlProperty_VirtualizingStackPanel_Children();
    private WpfKnownMember Create_BamlProperty_Window_Content();
    private WpfKnownMember Create_BamlProperty_WrapPanel_Children();
    private WpfKnownMember Create_BamlProperty_XmlDataProvider_XmlSerializer();
    private WpfKnownMember Create_BamlProperty_ControlTemplate_Triggers();
    private WpfKnownMember Create_BamlProperty_DataTemplate_Triggers();
    private WpfKnownMember Create_BamlProperty_DataTemplate_DataTemplateKey();
    private WpfKnownMember Create_BamlProperty_ControlTemplate_TargetType();
    private WpfKnownMember Create_BamlProperty_FrameworkElement_Resources();
    private WpfKnownMember Create_BamlProperty_FrameworkTemplate_Template();
    private WpfKnownMember Create_BamlProperty_Grid_ColumnDefinitions();
    private WpfKnownMember Create_BamlProperty_Grid_RowDefinitions();
    private WpfKnownMember Create_BamlProperty_MultiTrigger_Conditions();
    private WpfKnownMember Create_BamlProperty_NameScope_NameScope();
    private WpfKnownMember Create_BamlProperty_Style_TargetType();
    private WpfKnownMember Create_BamlProperty_Style_Triggers();
    private WpfKnownMember Create_BamlProperty_Setter_Value();
    private WpfKnownMember Create_BamlProperty_Setter_TargetName();
    private WpfKnownMember Create_BamlProperty_Binding_Path();
    private WpfKnownMember Create_BamlProperty_ComponentResourceKey_ResourceId();
    private WpfKnownMember Create_BamlProperty_ComponentResourceKey_TypeInTargetAssembly();
    private WpfKnownMember Create_BamlProperty_Binding_Converter();
    private WpfKnownMember Create_BamlProperty_Binding_Source();
    private WpfKnownMember Create_BamlProperty_Binding_RelativeSource();
    private WpfKnownMember Create_BamlProperty_Binding_Mode();
    private WpfKnownMember Create_BamlProperty_Timeline_BeginTime();
    private WpfKnownMember Create_BamlProperty_Style_BasedOn();
    private WpfKnownMember Create_BamlProperty_Binding_ElementName();
    private WpfKnownMember Create_BamlProperty_Binding_UpdateSourceTrigger();
    private WpfKnownMember Create_BamlProperty_ResourceDictionary_DeferrableContent();
    private WpfKnownMember Create_BamlProperty_Trigger_Value();
    private WpfKnownMember Create_BamlProperty_Trigger_SourceName();
    private WpfKnownMember Create_BamlProperty_RelativeSource_AncestorType();
    private WpfKnownMember Create_BamlProperty_UIElement_Uid();
    private WpfKnownMember Create_BamlProperty_FrameworkContentElement_Name();
    private WpfKnownMember Create_BamlProperty_FrameworkContentElement_Resources();
    private WpfKnownMember Create_BamlProperty_Style_Resources();
    private WpfKnownMember Create_BamlProperty_FrameworkTemplate_Resources();
    private WpfKnownMember Create_BamlProperty_Application_Resources();
    private WpfKnownMember Create_BamlProperty_MultiBinding_Converter();
    private WpfKnownMember Create_BamlProperty_MultiBinding_ConverterParameter();
    private WpfKnownMember Create_BamlProperty_LinearGradientBrush_StartPoint();
    private WpfKnownMember Create_BamlProperty_LinearGradientBrush_EndPoint();
    private WpfKnownMember Create_BamlProperty_CommandBinding_Command();
    private WpfKnownMember Create_BamlProperty_Condition_Property();
    private WpfKnownMember Create_BamlProperty_Condition_Value();
    private WpfKnownMember Create_BamlProperty_Condition_Binding();
    private WpfKnownMember Create_BamlProperty_BindingBase_FallbackValue();
    private WpfKnownMember Create_BamlProperty_Window_ResizeMode();
    private WpfKnownMember Create_BamlProperty_Window_WindowState();
    private WpfKnownMember Create_BamlProperty_Window_Title();
    private WpfKnownMember Create_BamlProperty_Shape_StrokeLineJoin();
    private WpfKnownMember Create_BamlProperty_Shape_StrokeStartLineCap();
    private WpfKnownMember Create_BamlProperty_Shape_StrokeEndLineCap();
    private WpfKnownMember Create_BamlProperty_TileBrush_TileMode();
    private WpfKnownMember Create_BamlProperty_TileBrush_ViewboxUnits();
    private WpfKnownMember Create_BamlProperty_TileBrush_ViewportUnits();
    private WpfKnownMember Create_BamlProperty_GeometryDrawing_Pen();
    private WpfKnownMember Create_BamlProperty_TextBox_TextWrapping();
    private WpfKnownMember Create_BamlProperty_StackPanel_Orientation();
    private WpfKnownMember Create_BamlProperty_Track_Thumb();
    private WpfKnownMember Create_BamlProperty_Track_IncreaseRepeatButton();
    private WpfKnownMember Create_BamlProperty_Track_DecreaseRepeatButton();
    private WpfKnownMember Create_BamlProperty_EventTrigger_RoutedEvent();
    private WpfKnownMember Create_BamlProperty_InputBinding_Command();
    private WpfKnownMember Create_BamlProperty_KeyBinding_Gesture();
    private WpfKnownMember Create_BamlProperty_TextBox_TextAlignment();
    private WpfKnownMember Create_BamlProperty_TextBlock_TextAlignment();
    private WpfKnownMember Create_BamlProperty_JournalEntryUnifiedViewConverter_JournalEntryPosition();
    private WpfKnownMember Create_BamlProperty_GradientBrush_MappingMode();
    private WpfKnownMember Create_BamlProperty_MenuItem_Role();
    private WpfKnownMember Create_BamlProperty_DataTrigger_Value();
    private WpfKnownMember Create_BamlProperty_DataTrigger_Binding();
    private WpfKnownMember Create_BamlProperty_Setter_Property();
    private WpfKnownMember Create_BamlProperty_ResourceDictionary_Source();
    private WpfKnownMember Create_BamlProperty_BeginStoryboard_Name();
    private WpfKnownMember Create_BamlProperty_ResourceDictionary_MergedDictionaries();
    private WpfKnownMember Create_BamlProperty_KeyboardNavigation_DirectionalNavigation();
    private WpfKnownMember Create_BamlProperty_KeyboardNavigation_TabNavigation();
    private WpfKnownMember Create_BamlProperty_ScrollBar_Orientation();
    private WpfKnownMember Create_BamlProperty_Trigger_Property();
    private WpfKnownMember Create_BamlProperty_EventTrigger_SourceName();
    private WpfKnownMember Create_BamlProperty_DefinitionBase_SharedSizeGroup();
    private WpfKnownMember Create_BamlProperty_ToolTipService_ToolTip();
    private WpfKnownMember Create_BamlProperty_PathFigure_IsClosed();
    private WpfKnownMember Create_BamlProperty_PathFigure_IsFilled();
    private WpfKnownMember Create_BamlProperty_ButtonBase_ClickMode();
    private WpfKnownMember Create_BamlProperty_Block_TextAlignment();
    private WpfKnownMember Create_BamlProperty_UIElement_RenderTransformOrigin();
    private WpfKnownMember Create_BamlProperty_Pen_LineJoin();
    private WpfKnownMember Create_BamlProperty_BulletDecorator_Bullet();
    private WpfKnownMember Create_BamlProperty_UIElement_SnapsToDevicePixels();
    private WpfKnownMember Create_BamlProperty_UIElement_CommandBindings();
    private WpfKnownMember Create_BamlProperty_UIElement_InputBindings();
    private WpfKnownMember Create_BamlProperty_SolidColorBrush_Color();
    private WpfKnownMember Create_BamlProperty_Brush_Opacity();
    private WpfKnownMember Create_BamlProperty_TextBoxBase_AcceptsTab();
    private WpfKnownMember Create_BamlProperty_PathSegment_IsStroked();
    private WpfKnownMember Create_BamlProperty_VirtualizingPanel_IsVirtualizing();
    private WpfKnownMember Create_BamlProperty_Shape_Stretch();
    private WpfKnownMember Create_BamlProperty_Frame_JournalOwnership();
    private WpfKnownMember Create_BamlProperty_Frame_NavigationUIVisibility();
    private WpfKnownMember Create_BamlProperty_Storyboard_TargetName();
    private WpfKnownMember Create_BamlProperty_XmlDataProvider_XPath();
    private WpfKnownMember Create_BamlProperty_Selector_IsSelected();
    private WpfKnownMember Create_BamlProperty_DataTemplate_DataType();
    private WpfKnownMember Create_BamlProperty_Shape_StrokeMiterLimit();
    private WpfKnownMember Create_BamlProperty_UIElement_AllowDrop();
    private WpfKnownMember Create_BamlProperty_MenuItem_IsChecked();
    private WpfKnownMember Create_BamlProperty_Panel_IsItemsHost();
    private WpfKnownMember Create_BamlProperty_Binding_XPath();
    private WpfKnownMember Create_BamlProperty_Window_AllowsTransparency();
    private WpfKnownMember Create_BamlProperty_ObjectDataProvider_ObjectType();
    private WpfKnownMember Create_BamlProperty_ToolBar_Orientation();
    private WpfKnownMember Create_BamlProperty_TextBoxBase_VerticalScrollBarVisibility();
    private WpfKnownMember Create_BamlProperty_TextBoxBase_HorizontalScrollBarVisibility();
    private WpfKnownMember Create_BamlProperty_FrameworkElement_Triggers();
    private WpfKnownMember Create_BamlProperty_MultiDataTrigger_Conditions();
    private WpfKnownMember Create_BamlProperty_KeyBinding_Key();
    private WpfKnownMember Create_BamlProperty_Binding_ConverterParameter();
    private WpfKnownMember Create_BamlProperty_Canvas_Top();
    private WpfKnownMember Create_BamlProperty_Canvas_Left();
    private WpfKnownMember Create_BamlProperty_Canvas_Bottom();
    private WpfKnownMember Create_BamlProperty_Canvas_Right();
    private WpfKnownMember Create_BamlProperty_Storyboard_TargetProperty();
    private WpfKnownType CreateKnownBamlType(short bamlNumber, bool isBamlType, bool useV3Rules);
    private UInt32 GetTypeNameHash(string typeName);
    protected WpfKnownType CreateKnownBamlType(string typeName, bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_AccessText(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_AdornedElementPlaceholder(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_Adorner(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_AdornerDecorator(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_AdornerLayer(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_AffineTransform3D(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_AmbientLight(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_AnchoredBlock(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_Animatable(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_AnimationClock(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_AnimationTimeline(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_Application(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_ArcSegment(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_ArrayExtension(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_AxisAngleRotation3D(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_BaseIListConverter(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_BeginStoryboard(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_BevelBitmapEffect(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_BezierSegment(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_Binding(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_BindingBase(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_BindingExpression(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_BindingExpressionBase(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_BindingListCollectionView(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_BitmapDecoder(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_BitmapEffect(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_BitmapEffectCollection(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_BitmapEffectGroup(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_BitmapEffectInput(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_BitmapEncoder(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_BitmapFrame(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_BitmapImage(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_BitmapMetadata(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_BitmapPalette(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_BitmapSource(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_Block(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_BlockUIContainer(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_BlurBitmapEffect(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_BmpBitmapDecoder(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_BmpBitmapEncoder(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_Bold(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_BoolIListConverter(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_Boolean(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_BooleanAnimationBase(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_BooleanAnimationUsingKeyFrames(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_BooleanConverter(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_BooleanKeyFrame(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_BooleanKeyFrameCollection(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_BooleanToVisibilityConverter(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_Border(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_BorderGapMaskConverter(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_Brush(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_BrushConverter(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_BulletDecorator(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_Button(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_ButtonBase(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_Byte(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_ByteAnimation(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_ByteAnimationBase(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_ByteAnimationUsingKeyFrames(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_ByteConverter(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_ByteKeyFrame(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_ByteKeyFrameCollection(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_CachedBitmap(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_Camera(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_Canvas(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_Char(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_CharAnimationBase(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_CharAnimationUsingKeyFrames(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_CharConverter(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_CharIListConverter(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_CharKeyFrame(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_CharKeyFrameCollection(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_CheckBox(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_Clock(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_ClockController(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_ClockGroup(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_CollectionContainer(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_CollectionView(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_CollectionViewSource(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_Color(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_ColorAnimation(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_ColorAnimationBase(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_ColorAnimationUsingKeyFrames(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_ColorConvertedBitmap(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_ColorConvertedBitmapExtension(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_ColorConverter(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_ColorKeyFrame(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_ColorKeyFrameCollection(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_ColumnDefinition(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_CombinedGeometry(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_ComboBox(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_ComboBoxItem(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_CommandConverter(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_ComponentResourceKey(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_ComponentResourceKeyConverter(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_CompositionTarget(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_Condition(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_ContainerVisual(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_ContentControl(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_ContentElement(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_ContentPresenter(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_ContentPropertyAttribute(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_ContentWrapperAttribute(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_ContextMenu(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_ContextMenuService(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_Control(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_ControlTemplate(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_ControllableStoryboardAction(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_CornerRadius(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_CornerRadiusConverter(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_CroppedBitmap(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_CultureInfo(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_CultureInfoConverter(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_CultureInfoIetfLanguageTagConverter(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_Cursor(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_CursorConverter(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_DashStyle(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_DataChangedEventManager(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_DataTemplate(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_DataTemplateKey(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_DataTrigger(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_DateTime(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_DateTimeConverter(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_DateTimeConverter2(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_Decimal(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_DecimalAnimation(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_DecimalAnimationBase(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_DecimalAnimationUsingKeyFrames(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_DecimalConverter(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_DecimalKeyFrame(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_DecimalKeyFrameCollection(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_Decorator(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_DefinitionBase(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_DependencyObject(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_DependencyProperty(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_DependencyPropertyConverter(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_DialogResultConverter(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_DiffuseMaterial(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_DirectionalLight(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_DiscreteBooleanKeyFrame(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_DiscreteByteKeyFrame(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_DiscreteCharKeyFrame(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_DiscreteColorKeyFrame(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_DiscreteDecimalKeyFrame(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_DiscreteDoubleKeyFrame(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_DiscreteInt16KeyFrame(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_DiscreteInt32KeyFrame(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_DiscreteInt64KeyFrame(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_DiscreteMatrixKeyFrame(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_DiscreteObjectKeyFrame(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_DiscretePoint3DKeyFrame(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_DiscretePointKeyFrame(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_DiscreteQuaternionKeyFrame(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_DiscreteRectKeyFrame(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_DiscreteRotation3DKeyFrame(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_DiscreteSingleKeyFrame(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_DiscreteSizeKeyFrame(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_DiscreteStringKeyFrame(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_DiscreteThicknessKeyFrame(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_DiscreteVector3DKeyFrame(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_DiscreteVectorKeyFrame(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_DockPanel(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_DocumentPageView(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_DocumentReference(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_DocumentViewer(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_DocumentViewerBase(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_Double(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_DoubleAnimation(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_DoubleAnimationBase(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_DoubleAnimationUsingKeyFrames(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_DoubleAnimationUsingPath(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_DoubleCollection(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_DoubleCollectionConverter(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_DoubleConverter(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_DoubleIListConverter(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_DoubleKeyFrame(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_DoubleKeyFrameCollection(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_Drawing(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_DrawingBrush(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_DrawingCollection(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_DrawingContext(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_DrawingGroup(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_DrawingImage(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_DrawingVisual(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_DropShadowBitmapEffect(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_Duration(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_DurationConverter(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_DynamicResourceExtension(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_DynamicResourceExtensionConverter(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_Ellipse(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_EllipseGeometry(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_EmbossBitmapEffect(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_EmissiveMaterial(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_EnumConverter(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_EventManager(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_EventSetter(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_EventTrigger(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_Expander(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_Expression(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_ExpressionConverter(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_Figure(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_FigureLength(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_FigureLengthConverter(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_FixedDocument(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_FixedDocumentSequence(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_FixedPage(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_Floater(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_FlowDocument(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_FlowDocumentPageViewer(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_FlowDocumentReader(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_FlowDocumentScrollViewer(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_FocusManager(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_FontFamily(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_FontFamilyConverter(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_FontSizeConverter(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_FontStretch(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_FontStretchConverter(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_FontStyle(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_FontStyleConverter(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_FontWeight(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_FontWeightConverter(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_FormatConvertedBitmap(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_Frame(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_FrameworkContentElement(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_FrameworkElement(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_FrameworkElementFactory(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_FrameworkPropertyMetadata(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_FrameworkPropertyMetadataOptions(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_FrameworkRichTextComposition(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_FrameworkTemplate(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_FrameworkTextComposition(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_Freezable(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_GeneralTransform(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_GeneralTransformCollection(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_GeneralTransformGroup(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_Geometry(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_Geometry3D(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_GeometryCollection(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_GeometryConverter(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_GeometryDrawing(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_GeometryGroup(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_GeometryModel3D(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_GestureRecognizer(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_GifBitmapDecoder(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_GifBitmapEncoder(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_GlyphRun(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_GlyphRunDrawing(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_GlyphTypeface(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_Glyphs(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_GradientBrush(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_GradientStop(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_GradientStopCollection(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_Grid(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_GridLength(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_GridLengthConverter(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_GridSplitter(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_GridView(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_GridViewColumn(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_GridViewColumnHeader(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_GridViewHeaderRowPresenter(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_GridViewRowPresenter(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_GridViewRowPresenterBase(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_GroupBox(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_GroupItem(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_Guid(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_GuidConverter(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_GuidelineSet(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_HeaderedContentControl(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_HeaderedItemsControl(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_HierarchicalDataTemplate(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_HostVisual(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_Hyperlink(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_IAddChild(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_IAddChildInternal(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_ICommand(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_IComponentConnector(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_INameScope(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_IStyleConnector(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_IconBitmapDecoder(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_Image(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_ImageBrush(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_ImageDrawing(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_ImageMetadata(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_ImageSource(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_ImageSourceConverter(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_InPlaceBitmapMetadataWriter(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_InkCanvas(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_InkPresenter(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_Inline(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_InlineCollection(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_InlineUIContainer(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_InputBinding(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_InputDevice(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_InputLanguageManager(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_InputManager(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_InputMethod(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_InputScope(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_InputScopeConverter(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_InputScopeName(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_InputScopeNameConverter(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_Int16(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_Int16Animation(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_Int16AnimationBase(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_Int16AnimationUsingKeyFrames(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_Int16Converter(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_Int16KeyFrame(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_Int16KeyFrameCollection(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_Int32(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_Int32Animation(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_Int32AnimationBase(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_Int32AnimationUsingKeyFrames(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_Int32Collection(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_Int32CollectionConverter(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_Int32Converter(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_Int32KeyFrame(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_Int32KeyFrameCollection(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_Int32Rect(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_Int32RectConverter(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_Int64(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_Int64Animation(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_Int64AnimationBase(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_Int64AnimationUsingKeyFrames(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_Int64Converter(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_Int64KeyFrame(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_Int64KeyFrameCollection(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_Italic(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_ItemCollection(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_ItemsControl(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_ItemsPanelTemplate(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_ItemsPresenter(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_JournalEntry(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_JournalEntryListConverter(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_JournalEntryUnifiedViewConverter(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_JpegBitmapDecoder(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_JpegBitmapEncoder(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_KeyBinding(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_KeyConverter(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_KeyGesture(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_KeyGestureConverter(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_KeySpline(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_KeySplineConverter(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_KeyTime(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_KeyTimeConverter(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_KeyboardDevice(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_Label(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_LateBoundBitmapDecoder(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_LengthConverter(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_Light(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_Line(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_LineBreak(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_LineGeometry(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_LineSegment(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_LinearByteKeyFrame(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_LinearColorKeyFrame(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_LinearDecimalKeyFrame(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_LinearDoubleKeyFrame(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_LinearGradientBrush(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_LinearInt16KeyFrame(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_LinearInt32KeyFrame(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_LinearInt64KeyFrame(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_LinearPoint3DKeyFrame(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_LinearPointKeyFrame(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_LinearQuaternionKeyFrame(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_LinearRectKeyFrame(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_LinearRotation3DKeyFrame(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_LinearSingleKeyFrame(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_LinearSizeKeyFrame(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_LinearThicknessKeyFrame(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_LinearVector3DKeyFrame(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_LinearVectorKeyFrame(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_List(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_ListBox(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_ListBoxItem(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_ListCollectionView(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_ListItem(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_ListView(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_ListViewItem(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_Localization(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_LostFocusEventManager(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_MarkupExtension(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_Material(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_MaterialCollection(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_MaterialGroup(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_Matrix(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_Matrix3D(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_Matrix3DConverter(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_MatrixAnimationBase(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_MatrixAnimationUsingKeyFrames(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_MatrixAnimationUsingPath(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_MatrixCamera(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_MatrixConverter(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_MatrixKeyFrame(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_MatrixKeyFrameCollection(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_MatrixTransform(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_MatrixTransform3D(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_MediaClock(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_MediaElement(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_MediaPlayer(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_MediaTimeline(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_Menu(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_MenuBase(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_MenuItem(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_MenuScrollingVisibilityConverter(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_MeshGeometry3D(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_Model3D(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_Model3DCollection(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_Model3DGroup(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_ModelVisual3D(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_ModifierKeysConverter(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_MouseActionConverter(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_MouseBinding(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_MouseDevice(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_MouseGesture(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_MouseGestureConverter(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_MultiBinding(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_MultiBindingExpression(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_MultiDataTrigger(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_MultiTrigger(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_NameScope(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_NavigationWindow(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_NullExtension(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_NullableBoolConverter(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_NullableConverter(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_NumberSubstitution(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_Object(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_ObjectAnimationBase(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_ObjectAnimationUsingKeyFrames(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_ObjectDataProvider(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_ObjectKeyFrame(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_ObjectKeyFrameCollection(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_OrthographicCamera(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_OuterGlowBitmapEffect(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_Page(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_PageContent(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_PageFunctionBase(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_Panel(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_Paragraph(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_ParallelTimeline(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_ParserContext(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_PasswordBox(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_Path(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_PathFigure(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_PathFigureCollection(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_PathFigureCollectionConverter(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_PathGeometry(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_PathSegment(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_PathSegmentCollection(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_PauseStoryboard(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_Pen(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_PerspectiveCamera(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_PixelFormat(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_PixelFormatConverter(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_PngBitmapDecoder(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_PngBitmapEncoder(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_Point(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_Point3D(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_Point3DAnimation(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_Point3DAnimationBase(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_Point3DAnimationUsingKeyFrames(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_Point3DCollection(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_Point3DCollectionConverter(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_Point3DConverter(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_Point3DKeyFrame(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_Point3DKeyFrameCollection(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_Point4D(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_Point4DConverter(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_PointAnimation(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_PointAnimationBase(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_PointAnimationUsingKeyFrames(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_PointAnimationUsingPath(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_PointCollection(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_PointCollectionConverter(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_PointConverter(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_PointIListConverter(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_PointKeyFrame(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_PointKeyFrameCollection(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_PointLight(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_PointLightBase(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_PolyBezierSegment(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_PolyLineSegment(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_PolyQuadraticBezierSegment(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_Polygon(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_Polyline(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_Popup(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_PresentationSource(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_PriorityBinding(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_PriorityBindingExpression(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_ProgressBar(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_ProjectionCamera(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_PropertyPath(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_PropertyPathConverter(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_QuadraticBezierSegment(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_Quaternion(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_QuaternionAnimation(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_QuaternionAnimationBase(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_QuaternionAnimationUsingKeyFrames(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_QuaternionConverter(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_QuaternionKeyFrame(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_QuaternionKeyFrameCollection(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_QuaternionRotation3D(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_RadialGradientBrush(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_RadioButton(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_RangeBase(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_Rect(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_Rect3D(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_Rect3DConverter(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_RectAnimation(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_RectAnimationBase(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_RectAnimationUsingKeyFrames(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_RectConverter(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_RectKeyFrame(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_RectKeyFrameCollection(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_Rectangle(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_RectangleGeometry(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_RelativeSource(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_RemoveStoryboard(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_RenderOptions(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_RenderTargetBitmap(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_RepeatBehavior(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_RepeatBehaviorConverter(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_RepeatButton(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_ResizeGrip(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_ResourceDictionary(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_ResourceKey(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_ResumeStoryboard(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_RichTextBox(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_RotateTransform(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_RotateTransform3D(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_Rotation3D(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_Rotation3DAnimation(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_Rotation3DAnimationBase(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_Rotation3DAnimationUsingKeyFrames(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_Rotation3DKeyFrame(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_Rotation3DKeyFrameCollection(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_RoutedCommand(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_RoutedEvent(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_RoutedEventConverter(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_RoutedUICommand(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_RoutingStrategy(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_RowDefinition(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_Run(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_RuntimeNamePropertyAttribute(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_SByte(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_SByteConverter(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_ScaleTransform(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_ScaleTransform3D(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_ScrollBar(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_ScrollContentPresenter(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_ScrollViewer(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_Section(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_SeekStoryboard(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_Selector(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_Separator(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_SetStoryboardSpeedRatio(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_Setter(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_SetterBase(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_Shape(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_Single(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_SingleAnimation(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_SingleAnimationBase(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_SingleAnimationUsingKeyFrames(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_SingleConverter(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_SingleKeyFrame(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_SingleKeyFrameCollection(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_Size(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_Size3D(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_Size3DConverter(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_SizeAnimation(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_SizeAnimationBase(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_SizeAnimationUsingKeyFrames(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_SizeConverter(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_SizeKeyFrame(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_SizeKeyFrameCollection(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_SkewTransform(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_SkipStoryboardToFill(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_Slider(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_SolidColorBrush(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_SoundPlayerAction(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_Span(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_SpecularMaterial(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_SpellCheck(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_SplineByteKeyFrame(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_SplineColorKeyFrame(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_SplineDecimalKeyFrame(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_SplineDoubleKeyFrame(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_SplineInt16KeyFrame(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_SplineInt32KeyFrame(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_SplineInt64KeyFrame(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_SplinePoint3DKeyFrame(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_SplinePointKeyFrame(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_SplineQuaternionKeyFrame(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_SplineRectKeyFrame(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_SplineRotation3DKeyFrame(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_SplineSingleKeyFrame(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_SplineSizeKeyFrame(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_SplineThicknessKeyFrame(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_SplineVector3DKeyFrame(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_SplineVectorKeyFrame(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_SpotLight(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_StackPanel(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_StaticExtension(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_StaticResourceExtension(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_StatusBar(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_StatusBarItem(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_StickyNoteControl(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_StopStoryboard(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_Storyboard(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_StreamGeometry(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_StreamGeometryContext(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_StreamResourceInfo(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_String(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_StringAnimationBase(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_StringAnimationUsingKeyFrames(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_StringConverter(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_StringKeyFrame(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_StringKeyFrameCollection(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_StrokeCollection(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_StrokeCollectionConverter(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_Style(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_Stylus(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_StylusDevice(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_TabControl(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_TabItem(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_TabPanel(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_Table(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_TableCell(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_TableColumn(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_TableRow(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_TableRowGroup(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_TabletDevice(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_TemplateBindingExpression(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_TemplateBindingExpressionConverter(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_TemplateBindingExtension(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_TemplateBindingExtensionConverter(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_TemplateKey(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_TemplateKeyConverter(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_TextBlock(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_TextBox(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_TextBoxBase(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_TextComposition(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_TextCompositionManager(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_TextDecoration(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_TextDecorationCollection(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_TextDecorationCollectionConverter(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_TextEffect(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_TextEffectCollection(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_TextElement(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_TextSearch(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_ThemeDictionaryExtension(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_Thickness(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_ThicknessAnimation(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_ThicknessAnimationBase(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_ThicknessAnimationUsingKeyFrames(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_ThicknessConverter(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_ThicknessKeyFrame(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_ThicknessKeyFrameCollection(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_Thumb(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_TickBar(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_TiffBitmapDecoder(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_TiffBitmapEncoder(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_TileBrush(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_TimeSpan(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_TimeSpanConverter(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_Timeline(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_TimelineCollection(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_TimelineGroup(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_ToggleButton(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_ToolBar(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_ToolBarOverflowPanel(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_ToolBarPanel(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_ToolBarTray(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_ToolTip(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_ToolTipService(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_Track(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_Transform(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_Transform3D(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_Transform3DCollection(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_Transform3DGroup(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_TransformCollection(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_TransformConverter(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_TransformGroup(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_TransformedBitmap(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_TranslateTransform(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_TranslateTransform3D(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_TreeView(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_TreeViewItem(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_Trigger(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_TriggerAction(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_TriggerBase(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_TypeExtension(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_TypeTypeConverter(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_Typography(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_UIElement(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_UInt16(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_UInt16Converter(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_UInt32(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_UInt32Converter(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_UInt64(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_UInt64Converter(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_UShortIListConverter(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_Underline(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_UniformGrid(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_Uri(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_UriTypeConverter(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_UserControl(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_Validation(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_Vector(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_Vector3D(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_Vector3DAnimation(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_Vector3DAnimationBase(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_Vector3DAnimationUsingKeyFrames(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_Vector3DCollection(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_Vector3DCollectionConverter(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_Vector3DConverter(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_Vector3DKeyFrame(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_Vector3DKeyFrameCollection(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_VectorAnimation(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_VectorAnimationBase(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_VectorAnimationUsingKeyFrames(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_VectorCollection(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_VectorCollectionConverter(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_VectorConverter(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_VectorKeyFrame(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_VectorKeyFrameCollection(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_VideoDrawing(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_ViewBase(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_Viewbox(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_Viewport3D(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_Viewport3DVisual(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_VirtualizingPanel(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_VirtualizingStackPanel(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_Visual(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_Visual3D(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_VisualBrush(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_VisualTarget(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_WeakEventManager(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_WhitespaceSignificantCollectionAttribute(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_Window(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_WmpBitmapDecoder(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_WmpBitmapEncoder(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_WrapPanel(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_WriteableBitmap(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_XamlBrushSerializer(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_XamlInt32CollectionSerializer(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_XamlPathDataSerializer(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_XamlPoint3DCollectionSerializer(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_XamlPointCollectionSerializer(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_XamlReader(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_XamlStyleSerializer(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_XamlTemplateSerializer(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_XamlVector3DCollectionSerializer(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_XamlWriter(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_XmlDataProvider(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_XmlLangPropertyAttribute(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_XmlLanguage(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_XmlLanguageConverter(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_XmlNamespaceMapping(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_ZoomPercentageConverter(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_CommandBinding(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_XmlNamespaceMappingCollection(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_PageContentCollection(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_DocumentReferenceCollection(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_KeyboardNavigationMode(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_Enum(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_RelativeSourceMode(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_PenLineJoin(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_PenLineCap(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_InputBindingCollection(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_CommandBindingCollection(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_Stretch(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_Orientation(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_TextAlignment(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_NavigationUIVisibility(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_JournalOwnership(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_ScrollBarVisibility(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_TriggerCollection(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_UIElementCollection(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_SetterBaseCollection(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_ColumnDefinitionCollection(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_RowDefinitionCollection(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_ItemContainerTemplate(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_ItemContainerTemplateKey(bool isBamlType, bool useV3Rules);
    private WpfKnownType Create_BamlType_KeyboardNavigation(bool isBamlType, bool useV3Rules);
    private void Initialize();
    internal string GetKnownBamlString(short stringId);
    internal Baml6Assembly GetKnownBamlAssembly(short assemblyId);
    internal Baml6Assembly CreateKnownBamlAssembly(short assemblyId);
    internal WpfKnownType GetKnownBamlType(short typeId);
    internal WpfKnownMember GetKnownBamlMember(short memberId);
    public virtual XamlType GetXamlType(Type type);
    private XamlType GetUnknownXamlType(Type type);
    internal XamlType GetKnownXamlType(Type type);
    internal XamlValueConverter`1<XamlDeferringLoader> GetDeferringLoader(Type loaderType);
    internal XamlValueConverter`1<TypeConverter> GetTypeConverter(Type converterType);
    protected virtual XamlType GetXamlType(string xamlNamespace, string name, XamlType[] typeArguments);
    public XamlType GetXamlTypeExposed(string xamlNamespace, string name, XamlType[] typeArguments);
    internal Type ResolvePrefixedNameWithAdditionalWpfSemantics(string prefixedName, DependencyObject element);
    internal XamlMember get_StaticExtensionMemberTypeProperty();
    internal XamlMember get_TypeExtensionTypeProperty();
    internal XamlMember get_ResourceDictionaryDeferredContentProperty();
    internal XamlType get_ResourceDictionaryType();
    internal XamlType get_EventSetterType();
    internal XamlMember get_EventSetterEventProperty();
    internal XamlMember get_EventSetterHandlerProperty();
    internal XamlMember get_FrameworkTemplateTemplateProperty();
    internal XamlType get_StaticResourceExtensionType();
    [CompilerGeneratedAttribute]
internal Baml2006ReaderSettings get_Settings();
    [CompilerGeneratedAttribute]
internal void set_Settings(Baml2006ReaderSettings value);
    internal List`1<ThemeKnownTypeHelper> get_ThemeKnownTypeHelpers();
}
internal class System.Windows.Baml2006.WpfSharedXamlSchemaContext : WpfSharedBamlSchemaContext {
    private Dictionary`2<Type, XamlType> _masterTypeTable;
    private object _syncObject;
    private bool _useV3Rules;
    public WpfSharedXamlSchemaContext(XamlSchemaContextSettings settings, bool useV3Rules);
    public virtual XamlType GetXamlType(Type type);
    internal static void RequireRuntimeType(Type type);
    internal XamlType GetXamlTypeInternal(string xamlNamespace, string name, XamlType[] typeArguments);
}
internal class System.Windows.Baml2006.WpfXamlMember : XamlMember {
    [CompilerGeneratedAttribute]
private DependencyProperty <DependencyProperty>k__BackingField;
    [CompilerGeneratedAttribute]
private RoutedEvent <RoutedEvent>k__BackingField;
    private byte _bitField;
    private XamlMember _baseUnderlyingMember;
    private WpfXamlMember _asContentProperty;
    public DependencyProperty DependencyProperty { get; public set; }
    public RoutedEvent RoutedEvent { get; public set; }
    internal bool ApplyGetterFallback { get; private set; }
    internal WpfXamlMember AsContentProperty { get; }
    private bool _useV3Rules { get; private set; }
    private bool _isBamlMember { get; private set; }
    private bool _underlyingMemberIsKnown { get; private set; }
    private object System.Windows.Markup.IProvideValueTarget.TargetObject { get; }
    private object System.Windows.Markup.IProvideValueTarget.TargetProperty { get; }
    private XamlMember BaseUnderlyingMember { get; }
    public WpfXamlMember(DependencyProperty dp, bool isAttachable);
    public WpfXamlMember(RoutedEvent re, bool isAttachable);
    public WpfXamlMember(DependencyProperty dp, MethodInfo getter, MethodInfo setter, XamlSchemaContext schemaContext, bool useV3Rules);
    public WpfXamlMember(DependencyProperty dp, PropertyInfo property, XamlSchemaContext schemaContext, bool useV3Rules);
    public WpfXamlMember(RoutedEvent re, MethodInfo setter, XamlSchemaContext schemaContext, bool useV3Rules);
    public WpfXamlMember(RoutedEvent re, EventInfo eventInfo, XamlSchemaContext schemaContext, bool useV3Rules);
    protected WpfXamlMember(string name, XamlType declaringType, bool isAttachable);
    [CompilerGeneratedAttribute]
public DependencyProperty get_DependencyProperty();
    [CompilerGeneratedAttribute]
public void set_DependencyProperty(DependencyProperty value);
    [CompilerGeneratedAttribute]
public RoutedEvent get_RoutedEvent();
    [CompilerGeneratedAttribute]
public void set_RoutedEvent(RoutedEvent value);
    internal bool get_ApplyGetterFallback();
    private void set_ApplyGetterFallback(bool value);
    internal WpfXamlMember get_AsContentProperty();
    protected virtual WpfXamlMember GetAsContentProperty();
    protected virtual XamlType LookupType();
    protected virtual MemberInfo LookupUnderlyingMember();
    protected virtual MethodInfo LookupUnderlyingSetter();
    protected virtual MethodInfo LookupUnderlyingGetter();
    protected virtual bool LookupIsReadOnly();
    protected virtual bool LookupIsEvent();
    protected virtual XamlMemberInvoker LookupInvoker();
    protected virtual bool LookupIsUnknown();
    protected virtual XamlValueConverter`1<XamlDeferringLoader> LookupDeferringLoader();
    private bool get__useV3Rules();
    private void set__useV3Rules(bool value);
    private bool get__isBamlMember();
    private void set__isBamlMember(bool value);
    private bool get__underlyingMemberIsKnown();
    private void set__underlyingMemberIsKnown(bool value);
    private sealed virtual override object System.Windows.Markup.IProvideValueTarget.get_TargetObject();
    private sealed virtual override object System.Windows.Markup.IProvideValueTarget.get_TargetProperty();
    private XamlMember get_BaseUnderlyingMember();
}
internal class System.Windows.Baml2006.WpfXamlType : XamlType {
    private static int ConcurrencyLevel;
    private static int Capacity;
    private ConcurrentDictionary`2<string, XamlMember> _attachableMembers;
    private ConcurrentDictionary`2<string, XamlMember> _members;
    protected byte _bitField;
    private bool IsBamlScenario { get; private set; }
    private bool UseV3Rules { get; private set; }
    protected ConcurrentDictionary`2<string, XamlMember> Members { get; }
    protected ConcurrentDictionary`2<string, XamlMember> AttachableMembers { get; }
    private bool IsXmlNamespaceMappingCollection { get; }
    public WpfXamlType(Type type, XamlSchemaContext schema, bool isBamlScenario, bool useV3Rules);
    private bool get_IsBamlScenario();
    private void set_IsBamlScenario(bool value);
    private bool get_UseV3Rules();
    private void set_UseV3Rules(bool value);
    protected ConcurrentDictionary`2<string, XamlMember> get_Members();
    protected ConcurrentDictionary`2<string, XamlMember> get_AttachableMembers();
    protected virtual XamlMember LookupContentProperty();
    protected virtual bool LookupIsNameScope();
    private XamlMember FindMember(string name, bool isAttached, bool skipReadOnlyCheck);
    protected virtual XamlMember LookupMember(string name, bool skipReadOnlyCheck);
    protected virtual XamlMember LookupAttachableMember(string name);
    protected virtual IEnumerable`1<XamlMember> LookupAllMembers();
    private XamlMember FindKnownMember(string name, bool isAttachable);
    private XamlMember FindRoutedEventBackedProperty(string name, bool isAttachable, bool skipReadOnlyCheck);
    private XamlMember FindDependencyPropertyBackedProperty(string name, bool isAttachable, bool skipReadOnlyCheck);
    private XamlMember CacheAndReturnXamlMember(XamlMember xamlMember);
    private XamlMember GetAttachedRoutedEvent(string name, RoutedEvent re);
    private XamlMember GetRoutedEvent(string name, RoutedEvent re, bool skipReadOnlyCheck);
    private XamlMember GetAttachedDependencyProperty(string name, DependencyProperty property);
    private XamlMember GetRegularDependencyProperty(string name, DependencyProperty property, bool skipReadOnlyCheck);
    private static XamlMember FindKnownMember(WpfXamlType wpfXamlType, string name, bool isAttachable);
    protected virtual XamlCollectionKind LookupCollectionKind();
    private bool get_IsXmlNamespaceMappingCollection();
    internal XamlMember FindBaseXamlMember(string name, bool isAttachable);
    internal static bool GetFlag(Byte& bitField, byte typeBit);
    internal static void SetFlag(Byte& bitField, byte typeBit, bool value);
}
public enum System.Windows.BaseValueSource : Enum {
    public int value__;
    public static BaseValueSource Unknown;
    public static BaseValueSource Default;
    public static BaseValueSource Inherited;
    public static BaseValueSource DefaultStyle;
    public static BaseValueSource DefaultStyleTrigger;
    public static BaseValueSource Style;
    public static BaseValueSource TemplateTrigger;
    public static BaseValueSource StyleTrigger;
    public static BaseValueSource ImplicitStyleReference;
    public static BaseValueSource ParentTemplate;
    public static BaseValueSource ParentTemplateTrigger;
    public static BaseValueSource Local;
}
internal class System.Windows.BindingValueCache : object {
    internal Type BindingValueType;
    internal object ValueAsBindingValueType;
    internal BindingValueCache(Type bindingValueType, object valueAsBindingValueType);
}
internal static class System.Windows.BroadcastEventHelper : object {
    private static VisitedCallback`1<BroadcastEventData> BroadcastDelegate;
    private static BroadcastEventHelper();
    internal static void AddLoadedCallback(DependencyObject d, DependencyObject logicalParent);
    internal static void RemoveLoadedCallback(DependencyObject d, Object[] loadedPending);
    internal static void AddUnloadedCallback(DependencyObject d, DependencyObject logicalParent);
    internal static void RemoveUnloadedCallback(DependencyObject d, Object[] unloadedPending);
    internal static void BroadcastLoadedOrUnloadedEvent(DependencyObject d, DependencyObject oldParent, DependencyObject newParent);
    internal static object BroadcastLoadedEvent(object root);
    internal static void BroadcastLoadedSynchronously(DependencyObject rootDO, bool isLoaded);
    internal static object BroadcastUnloadedEvent(object root);
    internal static void BroadcastUnloadedSynchronously(DependencyObject rootDO, bool isLoaded);
    private static void BroadcastEvent(DependencyObject root, RoutedEvent routedEvent);
    private static bool OnBroadcastCallback(DependencyObject d, BroadcastEventData data, bool visitedViaVisualTree);
    private static bool SubtreeHasLoadedChangeHandlerHelper(DependencyObject d);
    private static void FireLoadedOnDescendentsHelper(DependencyObject d);
    private static void FireUnloadedOnDescendentsHelper(DependencyObject d);
    private static bool IsLoadedHelper(DependencyObject d);
    internal static bool IsParentLoaded(DependencyObject d);
    internal static FrameworkElementFactory GetFEFTreeRoot(DependencyObject templatedParent);
    internal static void AddOrRemoveHasLoadedChangeHandlerFlag(DependencyObject d, DependencyObject oldParent, DependencyObject newParent);
    internal static void AddHasLoadedChangeHandlerFlagInAncestry(DependencyObject d);
    internal static void RemoveHasLoadedChangeHandlerFlagInAncestry(DependencyObject d);
    private static bool AreThereLoadedChangeHandlersInSubtree(FrameworkObject& fo);
    private static void UpdateHasLoadedChangeHandlerFlagInAncestry(DependencyObject d, bool addHandler);
    private static void UpdateIsLoadedCache(FrameworkElement fe, DependencyObject parent);
    private static void UpdateIsLoadedCache(FrameworkContentElement fce, DependencyObject parent);
}
internal class System.Windows.ChildEventDependent : ValueType {
    internal int ChildIndex;
    internal EventHandlersStore EventHandlersStore;
}
internal class System.Windows.ChildPropertyDependent : ValueType {
    public int ChildIndex;
    public DependencyProperty Property;
    public object Name;
}
internal class System.Windows.ChildRecord : ValueType {
    public ItemStructMap`1<ItemStructList`1<ChildValueLookup>> ValueLookupListFromProperty;
}
internal class System.Windows.ChildValueLookup : ValueType {
    internal ValueLookupType LookupType;
    internal TriggerCondition[] Conditions;
    internal DependencyProperty Property;
    internal object Value;
    public virtual bool Equals(object value);
    public virtual int GetHashCode();
    public static bool op_Equality(ChildValueLookup value1, ChildValueLookup value2);
    public static bool op_Inequality(ChildValueLookup value1, ChildValueLookup value2);
}
[MarkupExtensionReturnTypeAttribute("System.Windows.Media.Imaging.ColorConvertedBitmap")]
public class System.Windows.ColorConvertedBitmapExtension : MarkupExtension {
    private string _image;
    private string _sourceProfile;
    private Uri _baseUri;
    private string _destinationProfile;
    public ColorConvertedBitmapExtension(object image);
    public virtual object ProvideValue(IServiceProvider serviceProvider);
    private Uri GetResolvedUri(string uri);
}
public enum System.Windows.ColumnSpaceDistribution : Enum {
    public int value__;
    public static ColumnSpaceDistribution Left;
    public static ColumnSpaceDistribution Right;
    public static ColumnSpaceDistribution Between;
}
[TypeConverterAttribute("System.Windows.Markup.ComponentResourceKeyConverter")]
public class System.Windows.ComponentResourceKey : ResourceKey {
    private Type _typeInTargetAssembly;
    private bool _typeInTargetAssemblyInitialized;
    private object _resourceId;
    private bool _resourceIdInitialized;
    public Type TypeInTargetAssembly { get; public set; }
    public Assembly Assembly { get; }
    public object ResourceId { get; public set; }
    public ComponentResourceKey(Type typeInTargetAssembly, object resourceId);
    public Type get_TypeInTargetAssembly();
    public void set_TypeInTargetAssembly(Type value);
    public virtual Assembly get_Assembly();
    public object get_ResourceId();
    public void set_ResourceId(object value);
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
    public virtual string ToString();
}
[XamlSetTypeConverterAttribute("ReceiveTypeConverter")]
[XamlSetMarkupExtensionAttribute("ReceiveMarkupExtension")]
public class System.Windows.Condition : object {
    private bool _sealed;
    private DependencyProperty _property;
    private BindingBase _binding;
    private object _value;
    private string _sourceName;
    private object _unresolvedProperty;
    private object _unresolvedValue;
    private ITypeDescriptorContext _serviceProvider;
    private CultureInfo _cultureInfoForTypeConverter;
    [AmbientAttribute]
[DefaultValueAttribute("")]
public DependencyProperty Property { get; public set; }
    [DefaultValueAttribute("")]
public BindingBase Binding { get; public set; }
    [TypeConverterAttribute("System.Windows.Markup.SetterTriggerConditionValueConverter")]
public object Value { get; public set; }
    [DefaultValueAttribute("")]
public string SourceName { get; public set; }
    public Condition(DependencyProperty conditionProperty, object conditionValue);
    public Condition(DependencyProperty conditionProperty, object conditionValue, string sourceName);
    public Condition(BindingBase binding, object conditionValue);
    public DependencyProperty get_Property();
    public void set_Property(DependencyProperty value);
    public BindingBase get_Binding();
    public void set_Binding(BindingBase value);
    public object get_Value();
    public void set_Value(object value);
    public string get_SourceName();
    public void set_SourceName(string value);
    internal void Seal(ValueLookupType type);
    private sealed virtual override void System.ComponentModel.ISupportInitialize.BeginInit();
    private sealed virtual override void System.ComponentModel.ISupportInitialize.EndInit();
    public static void ReceiveMarkupExtension(object targetObject, XamlSetMarkupExtensionEventArgs eventArgs);
    public static void ReceiveTypeConverter(object targetObject, XamlSetTypeConverterEventArgs eventArgs);
}
public class System.Windows.ConditionCollection : Collection`1<Condition> {
    private bool _sealed;
    public bool IsSealed { get; }
    protected virtual void ClearItems();
    protected virtual void InsertItem(int index, Condition item);
    protected virtual void RemoveItem(int index);
    protected virtual void SetItem(int index, Condition item);
    public bool get_IsSealed();
    internal void Seal(ValueLookupType type);
    private void CheckSealed();
    private void ConditionValidation(object value);
}
internal class System.Windows.ContainerDependent : ValueType {
    internal DependencyProperty Property;
    internal bool FromVisualTrigger;
}
[ContentPropertyAttribute("Text")]
public class System.Windows.Controls.AccessText : FrameworkElement {
    public static DependencyProperty TextProperty;
    public static DependencyProperty FontFamilyProperty;
    public static DependencyProperty FontStyleProperty;
    public static DependencyProperty FontWeightProperty;
    public static DependencyProperty FontStretchProperty;
    public static DependencyProperty FontSizeProperty;
    public static DependencyProperty ForegroundProperty;
    public static DependencyProperty BackgroundProperty;
    public static DependencyProperty TextDecorationsProperty;
    public static DependencyProperty TextEffectsProperty;
    public static DependencyProperty LineHeightProperty;
    public static DependencyProperty LineStackingStrategyProperty;
    public static DependencyProperty TextAlignmentProperty;
    public static DependencyProperty TextTrimmingProperty;
    public static DependencyProperty TextWrappingProperty;
    public static DependencyProperty BaselineOffsetProperty;
    private TextContainer _textContainer;
    private TextBlock _textBlock;
    private Run _accessKey;
    private bool _accessKeyLocated;
    private static char _accessKeyMarker;
    private static Style _accessKeyStyle;
    private string _currentlyRegistered;
    private static UncommonField`1<bool> HasCustomSerializationStorage;
    protected internal IEnumerator LogicalChildren { get; }
    public char AccessKey { get; }
    [DefaultValueAttribute("")]
public string Text { get; public set; }
    [LocalizabilityAttribute("14")]
public FontFamily FontFamily { get; public set; }
    public FontStyle FontStyle { get; public set; }
    public FontWeight FontWeight { get; public set; }
    public FontStretch FontStretch { get; public set; }
    [TypeConverterAttribute("System.Windows.FontSizeConverter")]
[LocalizabilityAttribute("0")]
public double FontSize { get; public set; }
    public Brush Foreground { get; public set; }
    public Brush Background { get; public set; }
    public TextDecorationCollection TextDecorations { get; public set; }
    public TextEffectCollection TextEffects { get; public set; }
    [TypeConverterAttribute("System.Windows.LengthConverter")]
public double LineHeight { get; public set; }
    public LineStackingStrategy LineStackingStrategy { get; public set; }
    public TextAlignment TextAlignment { get; public set; }
    public TextTrimming TextTrimming { get; public set; }
    public TextWrapping TextWrapping { get; public set; }
    public double BaselineOffset { get; public set; }
    internal TextBlock TextBlock { get; }
    internal static char AccessKeyMarker { get; }
    private TextContainer TextContainer { get; }
    protected int VisualChildrenCount { get; }
    private static Style AccessKeyStyle { get; }
    private static AccessText();
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object value);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string text);
    protected internal virtual IEnumerator get_LogicalChildren();
    public char get_AccessKey();
    public string get_Text();
    public void set_Text(string value);
    public FontFamily get_FontFamily();
    public void set_FontFamily(FontFamily value);
    public FontStyle get_FontStyle();
    public void set_FontStyle(FontStyle value);
    public FontWeight get_FontWeight();
    public void set_FontWeight(FontWeight value);
    public FontStretch get_FontStretch();
    public void set_FontStretch(FontStretch value);
    public double get_FontSize();
    public void set_FontSize(double value);
    public Brush get_Foreground();
    public void set_Foreground(Brush value);
    public Brush get_Background();
    public void set_Background(Brush value);
    public TextDecorationCollection get_TextDecorations();
    public void set_TextDecorations(TextDecorationCollection value);
    public TextEffectCollection get_TextEffects();
    public void set_TextEffects(TextEffectCollection value);
    public double get_LineHeight();
    public void set_LineHeight(double value);
    public LineStackingStrategy get_LineStackingStrategy();
    public void set_LineStackingStrategy(LineStackingStrategy value);
    public TextAlignment get_TextAlignment();
    public void set_TextAlignment(TextAlignment value);
    public TextTrimming get_TextTrimming();
    public void set_TextTrimming(TextTrimming value);
    public TextWrapping get_TextWrapping();
    public void set_TextWrapping(TextWrapping value);
    public double get_BaselineOffset();
    public void set_BaselineOffset(double value);
    protected sealed virtual Size MeasureOverride(Size constraint);
    protected sealed virtual Size ArrangeOverride(Size arrangeSize);
    internal static bool HasCustomSerialization(object o);
    internal TextBlock get_TextBlock();
    internal static char get_AccessKeyMarker();
    private TextContainer get_TextContainer();
    private static void OnPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private void CreateTextBlock();
    protected virtual int get_VisualChildrenCount();
    protected virtual Visual GetVisualChild(int index);
    internal static void SerializeCustom(XmlWriter xmlWriter, object o);
    private static Style get_AccessKeyStyle();
    private void UpdateAccessKey();
    private static int FindAccessKeyMarker(string text);
    internal static string RemoveAccessKeyMarker(string text);
    private void RegisterAccessKey();
    private static void OnTextChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private void UpdateText(string text);
    private void InitializeTextContainerListener();
    private void UninitializeTextContainerListener();
    private void OnTextContainerChanged(object sender, TextContainerChangedEventArgs args);
}
public class System.Windows.Controls.AddingNewItemEventArgs : EventArgs {
    private object _newItem;
    public object NewItem { get; public set; }
    public object get_NewItem();
    public void set_NewItem(object value);
}
[ContentPropertyAttribute("Child")]
public class System.Windows.Controls.AdornedElementPlaceholder : FrameworkElement {
    private UIElement _child;
    private TemplatedAdorner _templatedAdorner;
    public UIElement AdornedElement { get; }
    [DefaultValueAttribute("")]
public UIElement Child { get; public set; }
    protected int VisualChildrenCount { get; }
    protected internal IEnumerator LogicalChildren { get; }
    private TemplatedAdorner TemplatedAdorner { get; }
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object value);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string text);
    public UIElement get_AdornedElement();
    public virtual UIElement get_Child();
    public virtual void set_Child(UIElement value);
    protected virtual int get_VisualChildrenCount();
    protected virtual Visual GetVisualChild(int index);
    protected internal virtual IEnumerator get_LogicalChildren();
    protected virtual void OnInitialized(EventArgs e);
    protected virtual Size MeasureOverride(Size constraint);
    protected virtual Size ArrangeOverride(Size arrangeBounds);
    private TemplatedAdorner get_TemplatedAdorner();
}
[ContentPropertyAttribute("Values")]
public class System.Windows.Controls.AlternationConverter : object {
    private List`1<object> _values;
    public IList Values { get; }
    public IList get_Values();
    public sealed virtual object Convert(object o, Type targetType, object parameter, CultureInfo culture);
    public sealed virtual object ConvertBack(object o, Type targetType, object parameter, CultureInfo culture);
}
internal class System.Windows.Controls.AVElementHelper : object {
    private MediaPlayer _mediaPlayer;
    private MediaElement _element;
    private Uri _baseUri;
    private MediaState _unloadedBehavior;
    private MediaState _loadedBehavior;
    private MediaState _currentState;
    private bool _isLoaded;
    private SettableState`1<TimeSpan> _position;
    private SettableState`1<MediaState> _mediaState;
    private SettableState`1<Uri> _source;
    private SettableState`1<MediaClock> _clock;
    private SettableState`1<double> _speedRatio;
    private SettableState`1<double> _volume;
    private SettableState`1<bool> _isMuted;
    private SettableState`1<double> _balance;
    private SettableState`1<bool> _isScrubbingEnabled;
    internal MediaPlayer Player { get; }
    internal Uri BaseUri { get; internal set; }
    internal TimeSpan Position { get; }
    internal MediaClock Clock { get; }
    internal double SpeedRatio { get; }
    internal AVElementHelper(MediaElement element);
    internal static AVElementHelper GetHelper(DependencyObject d);
    internal MediaPlayer get_Player();
    internal Uri get_BaseUri();
    internal void set_BaseUri(Uri value);
    internal void SetUnloadedBehavior(MediaState unloadedBehavior);
    internal void SetLoadedBehavior(MediaState loadedBehavior);
    internal TimeSpan get_Position();
    internal void SetPosition(TimeSpan position);
    internal MediaClock get_Clock();
    internal void SetClock(MediaClock clock);
    internal double get_SpeedRatio();
    internal void SetSpeedRatio(double speedRatio);
    internal void SetState(MediaState mediaState);
    internal void SetVolume(double volume);
    internal void SetBalance(double balance);
    internal void SetIsMuted(bool isMuted);
    internal void SetScrubbingEnabled(bool isScrubbingEnabled);
    private void HookEvents();
    private void HandleStateChange();
    private Uri UriFromSourceUri(Uri sourceUri);
    internal static void OnSourceChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private void MemberOnInvalidateSource(DependencyPropertyChangedEventArgs e);
    private void OnMediaFailed(object sender, ExceptionEventArgs args);
    private void OnMediaOpened(object sender, EventArgs args);
    private void OnBufferingStarted(object sender, EventArgs args);
    private void OnBufferingEnded(object sender, EventArgs args);
    private void OnMediaEnded(object sender, EventArgs args);
    private void OnScriptCommand(object sender, MediaScriptCommandEventArgs args);
    private void OnLoaded(object sender, RoutedEventArgs args);
    private void OnUnloaded(object sender, RoutedEventArgs args);
}
[LocalizabilityAttribute("17")]
internal class System.Windows.Controls.BooleanToSelectiveScrollingOrientationConverter : object {
    public sealed virtual object Convert(object value, Type targetType, object parameter, CultureInfo culture);
    public sealed virtual object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture);
}
[LocalizabilityAttribute("17")]
public class System.Windows.Controls.BooleanToVisibilityConverter : object {
    public sealed virtual object Convert(object value, Type targetType, object parameter, CultureInfo culture);
    public sealed virtual object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture);
}
public class System.Windows.Controls.Border : Decorator {
    [CommonDependencyPropertyAttribute]
public static DependencyProperty BorderThicknessProperty;
    public static DependencyProperty PaddingProperty;
    public static DependencyProperty CornerRadiusProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty BorderBrushProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty BackgroundProperty;
    private bool _useComplexRenderCodePath;
    private static UncommonField`1<StreamGeometry> BorderGeometryField;
    private static UncommonField`1<StreamGeometry> BackgroundGeometryField;
    private static UncommonField`1<Pen> LeftPenField;
    private static UncommonField`1<Pen> RightPenField;
    private static UncommonField`1<Pen> TopPenField;
    private static UncommonField`1<Pen> BottomPenField;
    public Thickness BorderThickness { get; public set; }
    public Thickness Padding { get; public set; }
    public CornerRadius CornerRadius { get; public set; }
    public Brush BorderBrush { get; public set; }
    public Brush Background { get; public set; }
    internal int EffectiveValuesInitialSize { get; }
    private StreamGeometry BorderGeometryCache { get; private set; }
    private StreamGeometry BackgroundGeometryCache { get; private set; }
    private Pen LeftPenCache { get; private set; }
    private Pen RightPenCache { get; private set; }
    private Pen TopPenCache { get; private set; }
    private Pen BottomPenCache { get; private set; }
    private static Border();
    public Thickness get_BorderThickness();
    public void set_BorderThickness(Thickness value);
    public Thickness get_Padding();
    public void set_Padding(Thickness value);
    public CornerRadius get_CornerRadius();
    public void set_CornerRadius(CornerRadius value);
    public Brush get_BorderBrush();
    public void set_BorderBrush(Brush value);
    public Brush get_Background();
    public void set_Background(Brush value);
    private static void OnClearPenCache(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static bool IsThicknessValid(object value);
    private static bool IsCornerRadiusValid(object value);
    protected virtual Size MeasureOverride(Size constraint);
    protected virtual Size ArrangeOverride(Size finalSize);
    protected virtual void OnRender(DrawingContext dc);
    private static Size HelperCollapseThickness(Thickness th);
    private static bool AreUniformCorners(CornerRadius borderRadii);
    private static Rect HelperDeflateRect(Rect rt, Thickness thick);
    private static void GenerateGeometry(StreamGeometryContext ctx, Rect rect, Radii radii);
    internal virtual int get_EffectiveValuesInitialSize();
    private StreamGeometry get_BorderGeometryCache();
    private void set_BorderGeometryCache(StreamGeometry value);
    private StreamGeometry get_BackgroundGeometryCache();
    private void set_BackgroundGeometryCache(StreamGeometry value);
    private Pen get_LeftPenCache();
    private void set_LeftPenCache(Pen value);
    private Pen get_RightPenCache();
    private void set_RightPenCache(Pen value);
    private Pen get_TopPenCache();
    private void set_TopPenCache(Pen value);
    private Pen get_BottomPenCache();
    private void set_BottomPenCache(Pen value);
}
public class System.Windows.Controls.BorderGapMaskConverter : object {
    public sealed virtual object Convert(Object[] values, Type targetType, object parameter, CultureInfo culture);
    public sealed virtual Object[] ConvertBack(object value, Type[] targetTypes, object parameter, CultureInfo culture);
}
public class System.Windows.Controls.Button : ButtonBase {
    public static DependencyProperty IsDefaultProperty;
    public static DependencyProperty IsCancelProperty;
    private static DependencyPropertyKey IsDefaultedPropertyKey;
    public static DependencyProperty IsDefaultedProperty;
    private static UncommonField`1<KeyboardFocusChangedEventHandler> FocusChangedEventHandlerField;
    private static DependencyObjectType _dType;
    public bool IsDefault { get; public set; }
    public bool IsCancel { get; public set; }
    public bool IsDefaulted { get; }
    internal int EffectiveValuesInitialSize { get; }
    internal DependencyObjectType DTypeThemeStyleKey { get; }
    private static Button();
    public bool get_IsDefault();
    public void set_IsDefault(bool value);
    private static void OnIsDefaultChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void OnIsEnabledChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public bool get_IsCancel();
    public void set_IsCancel(bool value);
    private static void OnIsCancelChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public bool get_IsDefaulted();
    private void OnFocusChanged(object sender, KeyboardFocusChangedEventArgs e);
    private void UpdateIsDefaulted(IInputElement focus);
    protected virtual AutomationPeer OnCreateAutomationPeer();
    protected virtual void OnClick();
    internal virtual int get_EffectiveValuesInitialSize();
    internal virtual DependencyObjectType get_DTypeThemeStyleKey();
}
[TemplatePartAttribute]
[TemplatePartAttribute]
public class System.Windows.Controls.Calendar : Control {
    private static string ElementRoot;
    private static string ElementMonth;
    private static int COLS;
    private static int ROWS;
    private static int YEAR_ROWS;
    private static int YEAR_COLS;
    private static int YEARS_PER_DECADE;
    private Nullable`1<DateTime> _hoverStart;
    private Nullable`1<DateTime> _hoverEnd;
    private bool _isShiftPressed;
    private Nullable`1<DateTime> _currentDate;
    private CalendarItem _monthControl;
    private CalendarBlackoutDatesCollection _blackoutDates;
    private SelectedDatesCollection _selectedDates;
    public static RoutedEvent SelectedDatesChangedEvent;
    [CompilerGeneratedAttribute]
private EventHandler`1<CalendarDateChangedEventArgs> DisplayDateChanged;
    [CompilerGeneratedAttribute]
private EventHandler`1<CalendarModeChangedEventArgs> DisplayModeChanged;
    [CompilerGeneratedAttribute]
private EventHandler`1<EventArgs> SelectionModeChanged;
    public static DependencyProperty CalendarButtonStyleProperty;
    public static DependencyProperty CalendarDayButtonStyleProperty;
    public static DependencyProperty CalendarItemStyleProperty;
    public static DependencyProperty DisplayDateProperty;
    public static DependencyProperty DisplayDateEndProperty;
    public static DependencyProperty DisplayDateStartProperty;
    public static DependencyProperty DisplayModeProperty;
    public static DependencyProperty FirstDayOfWeekProperty;
    public static DependencyProperty IsTodayHighlightedProperty;
    public static DependencyProperty SelectedDateProperty;
    public static DependencyProperty SelectionModeProperty;
    [CompilerGeneratedAttribute]
private MouseButtonEventHandler DayButtonMouseUp;
    [CompilerGeneratedAttribute]
private RoutedEventHandler DayOrMonthPreviewKeyDown;
    [CompilerGeneratedAttribute]
private bool <DatePickerDisplayDateFlag>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <DisplayDateInternal>k__BackingField;
    public CalendarBlackoutDatesCollection BlackoutDates { get; }
    public Style CalendarButtonStyle { get; public set; }
    public Style CalendarDayButtonStyle { get; public set; }
    public Style CalendarItemStyle { get; public set; }
    public DateTime DisplayDate { get; public set; }
    public Nullable`1<DateTime> DisplayDateEnd { get; public set; }
    public Nullable`1<DateTime> DisplayDateStart { get; public set; }
    public CalendarMode DisplayMode { get; public set; }
    public DayOfWeek FirstDayOfWeek { get; public set; }
    public bool IsTodayHighlighted { get; public set; }
    public Nullable`1<DateTime> SelectedDate { get; public set; }
    public SelectedDatesCollection SelectedDates { get; }
    public CalendarSelectionMode SelectionMode { get; public set; }
    internal bool DatePickerDisplayDateFlag { get; internal set; }
    internal DateTime DisplayDateInternal { get; private set; }
    internal DateTime DisplayDateEndInternal { get; }
    internal DateTime DisplayDateStartInternal { get; }
    internal DateTime CurrentDate { get; internal set; }
    internal Nullable`1<DateTime> HoverStart { get; internal set; }
    internal Nullable`1<DateTime> HoverEnd { get; internal set; }
    internal CalendarItem MonthControl { get; }
    internal DateTime DisplayMonth { get; }
    internal DateTime DisplayYear { get; }
    private static Calendar();
    public void add_SelectedDatesChanged(EventHandler`1<SelectionChangedEventArgs> value);
    public void remove_SelectedDatesChanged(EventHandler`1<SelectionChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_DisplayDateChanged(EventHandler`1<CalendarDateChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_DisplayDateChanged(EventHandler`1<CalendarDateChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_DisplayModeChanged(EventHandler`1<CalendarModeChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_DisplayModeChanged(EventHandler`1<CalendarModeChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_SelectionModeChanged(EventHandler`1<EventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_SelectionModeChanged(EventHandler`1<EventArgs> value);
    public CalendarBlackoutDatesCollection get_BlackoutDates();
    public Style get_CalendarButtonStyle();
    public void set_CalendarButtonStyle(Style value);
    public Style get_CalendarDayButtonStyle();
    public void set_CalendarDayButtonStyle(Style value);
    public Style get_CalendarItemStyle();
    public void set_CalendarItemStyle(Style value);
    public DateTime get_DisplayDate();
    public void set_DisplayDate(DateTime value);
    private static void OnDisplayDateChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static object CoerceDisplayDate(DependencyObject d, object value);
    public Nullable`1<DateTime> get_DisplayDateEnd();
    public void set_DisplayDateEnd(Nullable`1<DateTime> value);
    private static void OnDisplayDateEndChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static object CoerceDisplayDateEnd(DependencyObject d, object value);
    public Nullable`1<DateTime> get_DisplayDateStart();
    public void set_DisplayDateStart(Nullable`1<DateTime> value);
    private static void OnDisplayDateStartChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static object CoerceDisplayDateStart(DependencyObject d, object value);
    public CalendarMode get_DisplayMode();
    public void set_DisplayMode(CalendarMode value);
    private static void OnDisplayModePropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public DayOfWeek get_FirstDayOfWeek();
    public void set_FirstDayOfWeek(DayOfWeek value);
    private static void OnFirstDayOfWeekChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public bool get_IsTodayHighlighted();
    public void set_IsTodayHighlighted(bool value);
    private static void OnIsTodayHighlightedChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void OnLanguageChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public Nullable`1<DateTime> get_SelectedDate();
    public void set_SelectedDate(Nullable`1<DateTime> value);
    private static void OnSelectedDateChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public SelectedDatesCollection get_SelectedDates();
    public CalendarSelectionMode get_SelectionMode();
    public void set_SelectionMode(CalendarSelectionMode value);
    private static void OnSelectionModeChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    [CompilerGeneratedAttribute]
internal void add_DayButtonMouseUp(MouseButtonEventHandler value);
    [CompilerGeneratedAttribute]
internal void remove_DayButtonMouseUp(MouseButtonEventHandler value);
    [CompilerGeneratedAttribute]
internal void add_DayOrMonthPreviewKeyDown(RoutedEventHandler value);
    [CompilerGeneratedAttribute]
internal void remove_DayOrMonthPreviewKeyDown(RoutedEventHandler value);
    [CompilerGeneratedAttribute]
internal bool get_DatePickerDisplayDateFlag();
    [CompilerGeneratedAttribute]
internal void set_DatePickerDisplayDateFlag(bool value);
    [CompilerGeneratedAttribute]
internal DateTime get_DisplayDateInternal();
    [CompilerGeneratedAttribute]
private void set_DisplayDateInternal(DateTime value);
    internal DateTime get_DisplayDateEndInternal();
    internal DateTime get_DisplayDateStartInternal();
    internal DateTime get_CurrentDate();
    internal void set_CurrentDate(DateTime value);
    internal Nullable`1<DateTime> get_HoverStart();
    internal void set_HoverStart(Nullable`1<DateTime> value);
    internal Nullable`1<DateTime> get_HoverEnd();
    internal void set_HoverEnd(Nullable`1<DateTime> value);
    internal CalendarItem get_MonthControl();
    internal DateTime get_DisplayMonth();
    internal DateTime get_DisplayYear();
    public virtual void OnApplyTemplate();
    public virtual string ToString();
    protected virtual void OnSelectedDatesChanged(SelectionChangedEventArgs e);
    protected virtual void OnDisplayDateChanged(CalendarDateChangedEventArgs e);
    protected virtual void OnDisplayModeChanged(CalendarModeChangedEventArgs e);
    protected virtual void OnSelectionModeChanged(EventArgs e);
    protected virtual AutomationPeer OnCreateAutomationPeer();
    protected virtual void OnKeyDown(KeyEventArgs e);
    protected virtual void OnKeyUp(KeyEventArgs e);
    internal CalendarDayButton FindDayButtonFromDay(DateTime day);
    internal static bool IsValidDateSelection(Calendar cal, object value);
    internal void OnDayButtonMouseUp(MouseButtonEventArgs e);
    internal void OnDayOrMonthPreviewKeyDown(RoutedEventArgs e);
    internal void OnDayClick(DateTime selectedDate);
    internal void OnCalendarButtonPressed(CalendarButton b, bool switchDisplayMode);
    private Nullable`1<DateTime> GetDateOffset(DateTime date, int offset, CalendarMode displayMode);
    private void MoveDisplayTo(Nullable`1<DateTime> date);
    internal void OnNextClick();
    internal void OnPreviousClick();
    internal void OnSelectedDatesCollectionChanged(SelectionChangedEventArgs e);
    internal void UpdateCellItems();
    private void CoerceFromSelection();
    private void AddKeyboardSelection();
    private static bool IsSelectionChanged(SelectionChangedEventArgs e);
    private static bool IsValidDisplayMode(object value);
    internal static bool IsValidFirstDayOfWeek(object value);
    private static bool IsValidKeyboardSelection(Calendar cal, object value);
    private static bool IsValidSelectionMode(object value);
    private void OnSelectedMonthChanged(Nullable`1<DateTime> selectedMonth);
    private void OnSelectedYearChanged(Nullable`1<DateTime> selectedYear);
    internal void FocusDate(DateTime date);
    private static void OnGotFocus(object sender, RoutedEventArgs e);
    private bool ProcessCalendarKey(KeyEventArgs e);
    private void ProcessDownKey(bool ctrl, bool shift);
    private void ProcessEndKey(bool shift);
    private bool ProcessEnterKey();
    private void ProcessHomeKey(bool shift);
    private void ProcessLeftKey(bool shift);
    private void ProcessPageDownKey(bool shift);
    private void ProcessPageUpKey(bool shift);
    private void ProcessRightKey(bool shift);
    private void ProcessSelection(bool shift, Nullable`1<DateTime> lastSelectedDate);
    private void ProcessShiftKeyUp();
    private void ProcessUpKey(bool ctrl, bool shift);
}
public class System.Windows.Controls.CalendarBlackoutDatesCollection : ObservableCollection`1<CalendarDateRange> {
    private Thread _dispatcherThread;
    private Calendar _owner;
    public CalendarBlackoutDatesCollection(Calendar owner);
    public void AddDatesInPast();
    public bool Contains(DateTime date);
    public bool Contains(DateTime start, DateTime end);
    public bool ContainsAny(CalendarDateRange range);
    internal Nullable`1<DateTime> GetNonBlackoutDate(Nullable`1<DateTime> requestedDate, int dayInterval);
    protected virtual void ClearItems();
    protected virtual void InsertItem(int index, CalendarDateRange item);
    protected virtual void RemoveItem(int index);
    protected virtual void SetItem(int index, CalendarDateRange item);
    private void RegisterItem(CalendarDateRange item);
    private void UnRegisterItem(CalendarDateRange item);
    private void Item_Changing(object sender, CalendarDateRangeChangingEventArgs e);
    private void Item_PropertyChanged(object sender, PropertyChangedEventArgs e);
    private bool IsValid(CalendarDateRange item);
    private bool IsValid(DateTime start, DateTime end);
    private bool IsValidThread();
    private CalendarDateRange GetContainingDateRange(DateTime date);
}
public class System.Windows.Controls.CalendarDateChangedEventArgs : RoutedEventArgs {
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <AddedDate>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <RemovedDate>k__BackingField;
    public Nullable`1<DateTime> AddedDate { get; private set; }
    public Nullable`1<DateTime> RemovedDate { get; private set; }
    internal CalendarDateChangedEventArgs(Nullable`1<DateTime> removedDate, Nullable`1<DateTime> addedDate);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_AddedDate();
    [CompilerGeneratedAttribute]
private void set_AddedDate(Nullable`1<DateTime> value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_RemovedDate();
    [CompilerGeneratedAttribute]
private void set_RemovedDate(Nullable`1<DateTime> value);
}
public class System.Windows.Controls.CalendarDateRange : object {
    private DateTime _end;
    private DateTime _start;
    [CompilerGeneratedAttribute]
private PropertyChangedEventHandler PropertyChanged;
    [CompilerGeneratedAttribute]
private EventHandler`1<CalendarDateRangeChangingEventArgs> Changing;
    public DateTime End { get; public set; }
    public DateTime Start { get; public set; }
    public CalendarDateRange(DateTime day);
    public CalendarDateRange(DateTime start, DateTime end);
    [CompilerGeneratedAttribute]
public sealed virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
    public DateTime get_End();
    public void set_End(DateTime value);
    public DateTime get_Start();
    public void set_Start(DateTime value);
    [CompilerGeneratedAttribute]
internal void add_Changing(EventHandler`1<CalendarDateRangeChangingEventArgs> value);
    [CompilerGeneratedAttribute]
internal void remove_Changing(EventHandler`1<CalendarDateRangeChangingEventArgs> value);
    internal bool ContainsAny(CalendarDateRange range);
    private void OnChanging(CalendarDateRangeChangingEventArgs e);
    private void OnPropertyChanged(PropertyChangedEventArgs e);
    private static DateTime CoerceEnd(DateTime start, DateTime end);
}
internal class System.Windows.Controls.CalendarDateRangeChangingEventArgs : EventArgs {
    private DateTime _start;
    private DateTime _end;
    public DateTime Start { get; }
    public DateTime End { get; }
    public CalendarDateRangeChangingEventArgs(DateTime start, DateTime end);
    public DateTime get_Start();
    public DateTime get_End();
}
internal static class System.Windows.Controls.CalendarKeyboardHelper : object {
    public static void GetMetaKeyState(Boolean& ctrl, Boolean& shift);
}
public enum System.Windows.Controls.CalendarMode : Enum {
    public int value__;
    public static CalendarMode Month;
    public static CalendarMode Year;
    public static CalendarMode Decade;
}
public class System.Windows.Controls.CalendarModeChangedEventArgs : RoutedEventArgs {
    [CompilerGeneratedAttribute]
private CalendarMode <NewMode>k__BackingField;
    [CompilerGeneratedAttribute]
private CalendarMode <OldMode>k__BackingField;
    public CalendarMode NewMode { get; private set; }
    public CalendarMode OldMode { get; private set; }
    public CalendarModeChangedEventArgs(CalendarMode oldMode, CalendarMode newMode);
    [CompilerGeneratedAttribute]
public CalendarMode get_NewMode();
    [CompilerGeneratedAttribute]
private void set_NewMode(CalendarMode value);
    [CompilerGeneratedAttribute]
public CalendarMode get_OldMode();
    [CompilerGeneratedAttribute]
private void set_OldMode(CalendarMode value);
}
internal class System.Windows.Controls.CalendarSelectionChangedEventArgs : SelectionChangedEventArgs {
    public CalendarSelectionChangedEventArgs(RoutedEvent eventId, IList removedItems, IList addedItems);
    protected virtual void InvokeEventHandler(Delegate genericHandler, object genericTarget);
}
public enum System.Windows.Controls.CalendarSelectionMode : Enum {
    public int value__;
    public static CalendarSelectionMode SingleDate;
    public static CalendarSelectionMode SingleRange;
    public static CalendarSelectionMode MultipleRange;
    public static CalendarSelectionMode None;
}
public class System.Windows.Controls.Canvas : Panel {
    public static DependencyProperty LeftProperty;
    public static DependencyProperty TopProperty;
    public static DependencyProperty RightProperty;
    public static DependencyProperty BottomProperty;
    internal int EffectiveValuesInitialSize { get; }
    private static Canvas();
    [TypeConverterAttribute("System.Windows.LengthConverter, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")]
[AttachedPropertyBrowsableForChildrenAttribute]
public static double GetLeft(UIElement element);
    public static void SetLeft(UIElement element, double length);
    [TypeConverterAttribute("System.Windows.LengthConverter, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")]
[AttachedPropertyBrowsableForChildrenAttribute]
public static double GetTop(UIElement element);
    public static void SetTop(UIElement element, double length);
    [AttachedPropertyBrowsableForChildrenAttribute]
[TypeConverterAttribute("System.Windows.LengthConverter, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")]
public static double GetRight(UIElement element);
    public static void SetRight(UIElement element, double length);
    [TypeConverterAttribute("System.Windows.LengthConverter, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")]
[AttachedPropertyBrowsableForChildrenAttribute]
public static double GetBottom(UIElement element);
    public static void SetBottom(UIElement element, double length);
    private static void OnPositioningChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    protected virtual Size MeasureOverride(Size constraint);
    protected virtual Size ArrangeOverride(Size arrangeSize);
    protected virtual Geometry GetLayoutClip(Size layoutSlotSize);
    internal virtual int get_EffectiveValuesInitialSize();
}
public enum System.Windows.Controls.CharacterCasing : Enum {
    public int value__;
    public static CharacterCasing Normal;
    public static CharacterCasing Lower;
    public static CharacterCasing Upper;
}
[DefaultEventAttribute("CheckStateChanged")]
[LocalizabilityAttribute("5")]
public class System.Windows.Controls.CheckBox : ToggleButton {
    private static DependencyObjectType _dType;
    internal DependencyObjectType DTypeThemeStyleKey { get; }
    private static CheckBox();
    protected virtual AutomationPeer OnCreateAutomationPeer();
    protected virtual void OnKeyDown(KeyEventArgs e);
    protected virtual void OnAccessKey(AccessKeyEventArgs e);
    internal virtual DependencyObjectType get_DTypeThemeStyleKey();
}
public class System.Windows.Controls.CleanUpVirtualizedItemEventArgs : RoutedEventArgs {
    private object _value;
    private UIElement _element;
    private bool _cancel;
    public object Value { get; }
    public UIElement UIElement { get; }
    public bool Cancel { get; public set; }
    public CleanUpVirtualizedItemEventArgs(object value, UIElement element);
    public object get_Value();
    public UIElement get_UIElement();
    public bool get_Cancel();
    public void set_Cancel(bool value);
}
public class System.Windows.Controls.CleanUpVirtualizedItemEventHandler : MulticastDelegate {
    public CleanUpVirtualizedItemEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, CleanUpVirtualizedItemEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, CleanUpVirtualizedItemEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public enum System.Windows.Controls.ClickMode : Enum {
    public int value__;
    public static ClickMode Release;
    public static ClickMode Press;
    public static ClickMode Hover;
}
public class System.Windows.Controls.ColumnDefinition : DefinitionBase {
    [CommonDependencyPropertyAttribute]
public static DependencyProperty WidthProperty;
    [CommonDependencyPropertyAttribute]
[TypeConverterAttribute("System.Windows.LengthConverter, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")]
public static DependencyProperty MinWidthProperty;
    [TypeConverterAttribute("System.Windows.LengthConverter, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")]
[CommonDependencyPropertyAttribute]
public static DependencyProperty MaxWidthProperty;
    public GridLength Width { get; public set; }
    [TypeConverterAttribute("System.Windows.LengthConverter")]
public double MinWidth { get; public set; }
    [TypeConverterAttribute("System.Windows.LengthConverter")]
public double MaxWidth { get; public set; }
    public double ActualWidth { get; }
    public double Offset { get; }
    private static ColumnDefinition();
    public GridLength get_Width();
    public void set_Width(GridLength value);
    public double get_MinWidth();
    public void set_MinWidth(double value);
    public double get_MaxWidth();
    public void set_MaxWidth(double value);
    public double get_ActualWidth();
    public double get_Offset();
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Controls.ColumnDefinitionCollection : object {
    private Grid _owner;
    private DefinitionBase[] _items;
    private int _size;
    private int _version;
    private static int c_defaultCapacity;
    public int Count { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    public bool IsReadOnly { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    private object System.Collections.IList.Item { get; private set; }
    public ColumnDefinition Item { get; public set; }
    internal int InternalCount { get; }
    internal DefinitionBase[] InternalItems { get; }
    internal ColumnDefinitionCollection(Grid owner);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public sealed virtual void CopyTo(ColumnDefinition[] array, int index);
    private sealed virtual override int System.Collections.IList.Add(object value);
    public sealed virtual void Add(ColumnDefinition value);
    public sealed virtual void Clear();
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    public sealed virtual bool Contains(ColumnDefinition value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    public sealed virtual int IndexOf(ColumnDefinition value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    public sealed virtual void Insert(int index, ColumnDefinition value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    public sealed virtual bool Remove(ColumnDefinition value);
    public sealed virtual void RemoveAt(int index);
    public void RemoveRange(int index, int count);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override IEnumerator`1<ColumnDefinition> System.Collections.Generic.IEnumerable<System.Windows.Controls.ColumnDefinition>.GetEnumerator();
    public sealed virtual int get_Count();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public sealed virtual ColumnDefinition get_Item(int index);
    public sealed virtual void set_Item(int index, ColumnDefinition value);
    internal void InternalTrimToSize();
    internal int get_InternalCount();
    internal DefinitionBase[] get_InternalItems();
    private void PrivateVerifyWriteAccess();
    private void PrivateValidateValueForAddition(object value);
    private bool PrivateValidateValueForRemoval(object value);
    private void PrivateConnectChild(int index, DefinitionBase value);
    private void PrivateDisconnectChild(DefinitionBase value);
    private void PrivateInsert(int index, DefinitionBase value);
    private void PrivateRemove(DefinitionBase value);
    private void PrivateOnModified();
    private void PrivateSetCapacity(int value);
}
internal enum System.Windows.Controls.ColumnMeasureState : Enum {
    public int value__;
    public static ColumnMeasureState Init;
    public static ColumnMeasureState Headered;
    public static ColumnMeasureState Data;
    public static ColumnMeasureState SpecificWidth;
}
[TemplatePartAttribute]
[LocalizabilityAttribute("6")]
[TemplatePartAttribute]
[StyleTypedPropertyAttribute]
public class System.Windows.Controls.ComboBox : Selector {
    public static DependencyProperty MaxDropDownHeightProperty;
    public static DependencyProperty IsDropDownOpenProperty;
    public static DependencyProperty ShouldPreserveUserEnteredPrefixProperty;
    public static DependencyProperty IsEditableProperty;
    public static DependencyProperty TextProperty;
    public static DependencyProperty IsReadOnlyProperty;
    private static DependencyPropertyKey SelectionBoxItemPropertyKey;
    public static DependencyProperty SelectionBoxItemProperty;
    private static DependencyPropertyKey SelectionBoxItemTemplatePropertyKey;
    public static DependencyProperty SelectionBoxItemTemplateProperty;
    private static DependencyPropertyKey SelectionBoxItemStringFormatPropertyKey;
    public static DependencyProperty SelectionBoxItemStringFormatProperty;
    public static DependencyProperty StaysOpenOnEditProperty;
    private static DependencyPropertyKey IsSelectionBoxHighlightedPropertyKey;
    private static DependencyProperty IsSelectionBoxHighlightedProperty;
    private static EventPrivateKey DropDownOpenedKey;
    private static EventPrivateKey DropDownClosedKey;
    private static string EditableTextBoxTemplateName;
    private static string PopupTemplateName;
    private TextBox _editableTextBoxSite;
    private Popup _dropDownPopup;
    private int _textBoxSelectionStart;
    private BitVector32 _cacheValid;
    private ItemInfo _highlightedInfo;
    private DispatcherTimer _autoScrollTimer;
    private UIElement _clonedElement;
    private DispatcherOperation _updateTextBoxOperation;
    private static DependencyObjectType _dType;
    [TypeConverterAttribute("System.Windows.LengthConverter")]
[CategoryAttribute("Layout")]
[BindableAttribute("True")]
public double MaxDropDownHeight { get; public set; }
    [BindableAttribute("True")]
[BrowsableAttribute("False")]
[CategoryAttribute("Appearance")]
public bool IsDropDownOpen { get; public set; }
    public bool ShouldPreserveUserEnteredPrefix { get; public set; }
    public bool IsEditable { get; public set; }
    public string Text { get; public set; }
    public bool IsReadOnly { get; public set; }
    public object SelectionBoxItem { get; private set; }
    public DataTemplate SelectionBoxItemTemplate { get; private set; }
    public string SelectionBoxItemStringFormat { get; private set; }
    public bool StaysOpenOnEdit { get; public set; }
    public bool IsSelectionBoxHighlighted { get; }
    protected internal bool HandlesScrolling { get; }
    protected internal bool HasEffectiveKeyboardFocus { get; }
    internal TextBox EditableTextBoxSite { get; internal set; }
    private bool HasCapture { get; }
    private bool IsItemsHostVisible { get; }
    private ItemInfo HighlightedInfo { get; private set; }
    private ComboBoxItem HighlightedElement { get; }
    private bool IsMouseOverItemsHost { get; private set; }
    private bool HasMouseEnteredItemsHost { get; private set; }
    private bool IsContextMenuOpen { get; private set; }
    private bool UpdatingText { get; private set; }
    private bool UpdatingSelectedItem { get; private set; }
    private bool IsWaitingForTextComposition { get; private set; }
    internal DependencyObjectType DTypeThemeStyleKey { get; }
    private static ComboBox();
    public double get_MaxDropDownHeight();
    public void set_MaxDropDownHeight(double value);
    public bool get_IsDropDownOpen();
    public void set_IsDropDownOpen(bool value);
    public bool get_ShouldPreserveUserEnteredPrefix();
    public void set_ShouldPreserveUserEnteredPrefix(bool value);
    private static object CoerceIsDropDownOpen(DependencyObject d, object value);
    private static object CoerceToolTipIsEnabled(DependencyObject d, object value);
    private void RegisterToOpenOnLoad();
    private void OpenOnLoad(object sender, RoutedEventArgs e);
    protected virtual void OnDropDownOpened(EventArgs e);
    protected virtual void OnDropDownClosed(EventArgs e);
    private static void OnIsDropDownOpenChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private void OnPopupClosed(object source, EventArgs e);
    public bool get_IsEditable();
    public void set_IsEditable(bool value);
    private static void OnIsEditableChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public string get_Text();
    public void set_Text(string value);
    public bool get_IsReadOnly();
    public void set_IsReadOnly(bool value);
    public object get_SelectionBoxItem();
    private void set_SelectionBoxItem(object value);
    public DataTemplate get_SelectionBoxItemTemplate();
    private void set_SelectionBoxItemTemplate(DataTemplate value);
    public string get_SelectionBoxItemStringFormat();
    private void set_SelectionBoxItemStringFormat(string value);
    public bool get_StaysOpenOnEdit();
    public void set_StaysOpenOnEdit(bool value);
    public bool get_IsSelectionBoxHighlighted();
    private static object CoerceIsSelectionBoxHighlighted(object o, object value);
    public void add_DropDownOpened(EventHandler value);
    public void remove_DropDownOpened(EventHandler value);
    public void add_DropDownClosed(EventHandler value);
    public void remove_DropDownClosed(EventHandler value);
    protected virtual void OnSelectionChanged(SelectionChangedEventArgs e);
    internal void SelectedItemUpdated();
    private static void OnTextChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private void OnEditableTextBoxTextChanged(object sender, TextChangedEventArgs e);
    private void OnEditableTextBoxSelectionChanged(object sender, RoutedEventArgs e);
    private void OnEditableTextBoxPreviewTextInput(object sender, TextCompositionEventArgs e);
    private void TextUpdated(string newText, bool textBoxUpdated);
    private object UpdateTextBoxCallback(object arg);
    private void UpdateTextBox(string matchedText, MatchedTextInfo matchedTextInfo);
    private void Update();
    private void UpdateEditableTextBox();
    private void UpdateSelectionBoxItem();
    private void CloneLayoutUpdated(object sender, EventArgs e);
    internal virtual void ChangeVisualState(bool useTransitions);
    protected internal virtual bool get_HandlesScrolling();
    protected virtual void PrepareContainerForItemOverride(DependencyObject element, object item);
    internal virtual void AdjustItemInfoOverride(NotifyCollectionChangedEventArgs e);
    private static void OnGotFocus(object sender, RoutedEventArgs e);
    internal virtual bool FocusItem(ItemInfo info, ItemNavigateArgs itemNavigateArgs);
    protected virtual void OnIsKeyboardFocusWithinChanged(DependencyPropertyChangedEventArgs e);
    private static void OnMouseWheel(object sender, MouseWheelEventArgs e);
    private static void OnContextMenuOpen(object sender, ContextMenuEventArgs e);
    private static void OnContextMenuClose(object sender, ContextMenuEventArgs e);
    protected virtual void OnIsMouseCapturedChanged(DependencyPropertyChangedEventArgs e);
    protected internal virtual bool get_HasEffectiveKeyboardFocus();
    internal void NotifyComboBoxItemMouseDown(ComboBoxItem comboBoxItem);
    internal void NotifyComboBoxItemMouseUp(ComboBoxItem comboBoxItem);
    internal void NotifyComboBoxItemEnter(ComboBoxItem item);
    protected virtual bool IsItemItsOwnContainerOverride(object item);
    protected virtual DependencyObject GetContainerForItemOverride();
    private void Initialize();
    protected virtual void OnPreviewKeyDown(KeyEventArgs e);
    protected virtual void OnKeyDown(KeyEventArgs e);
    private void KeyDownHandler(KeyEventArgs e);
    private void SelectPrev();
    private void SelectNext();
    private void SelectFirst();
    private void SelectLast();
    private void SelectItemHelper(int startIndex, int increment, int stopIndex);
    private bool IsSelectableHelper(object o);
    private static string ExtractString(DependencyObject d);
    public virtual void OnApplyTemplate();
    internal virtual void OnTemplateChangedInternal(FrameworkTemplate oldTemplate, FrameworkTemplate newTemplate);
    private static void OnLostMouseCapture(object sender, MouseEventArgs e);
    private static void OnMouseButtonDown(object sender, MouseButtonEventArgs e);
    private static void OnPreviewMouseButtonDown(object sender, MouseButtonEventArgs e);
    protected virtual void OnMouseLeftButtonUp(MouseButtonEventArgs e);
    private static void OnMouseMove(object sender, MouseEventArgs e);
    private void KeyboardToggleDropDown(bool commitSelection);
    private void KeyboardCloseDropDown(bool commitSelection);
    private void KeyboardToggleDropDown(bool openDropDown, bool commitSelection);
    private void CommitSelection();
    private void OnAutoScrollTimeout(object sender, EventArgs e);
    private void Close();
    protected virtual AutomationPeer OnCreateAutomationPeer();
    internal TextBox get_EditableTextBoxSite();
    internal void set_EditableTextBoxSite(TextBox value);
    private bool get_HasCapture();
    private bool get_IsItemsHostVisible();
    private ItemInfo get_HighlightedInfo();
    private void set_HighlightedInfo(ItemInfo value);
    private ComboBoxItem get_HighlightedElement();
    private bool get_IsMouseOverItemsHost();
    private void set_IsMouseOverItemsHost(bool value);
    private bool get_HasMouseEnteredItemsHost();
    private void set_HasMouseEnteredItemsHost(bool value);
    private bool get_IsContextMenuOpen();
    private void set_IsContextMenuOpen(bool value);
    private bool get_UpdatingText();
    private void set_UpdatingText(bool value);
    private bool get_UpdatingSelectedItem();
    private void set_UpdatingSelectedItem(bool value);
    private bool get_IsWaitingForTextComposition();
    private void set_IsWaitingForTextComposition(bool value);
    internal virtual DependencyObjectType get_DTypeThemeStyleKey();
    [CompilerGeneratedAttribute]
private object <OpenOnLoad>b__17_0(object param);
}
[LocalizabilityAttribute("6")]
public class System.Windows.Controls.ComboBoxItem : ListBoxItem {
    private static DependencyPropertyKey IsHighlightedPropertyKey;
    public static DependencyProperty IsHighlightedProperty;
    private static DependencyObjectType _dType;
    public bool IsHighlighted { get; protected set; }
    private ComboBox ParentComboBox { get; }
    internal DependencyObjectType DTypeThemeStyleKey { get; }
    private static ComboBoxItem();
    public bool get_IsHighlighted();
    protected void set_IsHighlighted(bool value);
    protected virtual void OnMouseLeftButtonDown(MouseButtonEventArgs e);
    protected virtual void OnMouseLeftButtonUp(MouseButtonEventArgs e);
    protected virtual void OnMouseEnter(MouseEventArgs e);
    protected virtual void OnContentChanged(object oldContent, object newContent);
    protected virtual void OnGotKeyboardFocus(KeyboardFocusChangedEventArgs e);
    private ComboBox get_ParentComboBox();
    internal void SetIsHighlighted(bool isHighlighted);
    internal virtual DependencyObjectType get_DTypeThemeStyleKey();
}
internal class System.Windows.Controls.ContainerTracking`1 : object {
    private T _container;
    private ContainerTracking`1<T> _next;
    private ContainerTracking`1<T> _previous;
    internal T Container { get; }
    internal ContainerTracking`1<T> Next { get; }
    internal ContainerTracking`1<T> Previous { get; }
    internal ContainerTracking`1(T container);
    internal T get_Container();
    internal ContainerTracking`1<T> get_Next();
    internal ContainerTracking`1<T> get_Previous();
    internal void StartTracking(ContainerTracking`1& root);
    internal void StopTracking(ContainerTracking`1& root);
    [ConditionalAttribute("DEBUG")]
internal void Debug_AssertIsInList(ContainerTracking`1<T> root);
    [ConditionalAttribute("DEBUG")]
internal void Debug_AssertNotInList(ContainerTracking`1<T> root);
}
[DefaultPropertyAttribute("Content")]
[ContentPropertyAttribute("Content")]
[LocalizabilityAttribute("0")]
public class System.Windows.Controls.ContentControl : Control {
    [CommonDependencyPropertyAttribute]
public static DependencyProperty ContentProperty;
    private static DependencyPropertyKey HasContentPropertyKey;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty HasContentProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty ContentTemplateProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty ContentTemplateSelectorProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty ContentStringFormatProperty;
    private static DependencyObjectType _dType;
    protected internal IEnumerator LogicalChildren { get; }
    [BindableAttribute("True")]
[CustomCategoryAttribute("Content")]
public object Content { get; public set; }
    [ReadOnlyAttribute("True")]
[BrowsableAttribute("False")]
public bool HasContent { get; }
    [BindableAttribute("True")]
[CustomCategoryAttribute("Content")]
public DataTemplate ContentTemplate { get; public set; }
    [DesignerSerializationVisibilityAttribute("0")]
[CustomCategoryAttribute("Content")]
[BindableAttribute("True")]
public DataTemplateSelector ContentTemplateSelector { get; public set; }
    [BindableAttribute("True")]
[CustomCategoryAttribute("Content")]
public string ContentStringFormat { get; public set; }
    internal bool ContentIsNotLogical { get; internal set; }
    internal bool ContentIsItem { get; internal set; }
    internal int EffectiveValuesInitialSize { get; }
    internal DependencyObjectType DTypeThemeStyleKey { get; }
    private static ContentControl();
    protected internal virtual IEnumerator get_LogicalChildren();
    internal virtual string GetPlainText();
    internal static string ContentObjectToString(object content);
    internal void PrepareContentControl(object item, DataTemplate itemTemplate, DataTemplateSelector itemTemplateSelector, string itemStringFormat);
    internal void ClearContentControl(object item);
    [EditorBrowsableAttribute("1")]
public virtual bool ShouldSerializeContent();
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object value);
    protected virtual void AddChild(object value);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string text);
    protected virtual void AddText(string text);
    public sealed virtual object get_Content();
    public sealed virtual void set_Content(object value);
    private static void OnContentChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    protected virtual void OnContentChanged(object oldContent, object newContent);
    public bool get_HasContent();
    public DataTemplate get_ContentTemplate();
    public void set_ContentTemplate(DataTemplate value);
    private static void OnContentTemplateChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    protected virtual void OnContentTemplateChanged(DataTemplate oldContentTemplate, DataTemplate newContentTemplate);
    public DataTemplateSelector get_ContentTemplateSelector();
    public void set_ContentTemplateSelector(DataTemplateSelector value);
    private static void OnContentTemplateSelectorChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    protected virtual void OnContentTemplateSelectorChanged(DataTemplateSelector oldContentTemplateSelector, DataTemplateSelector newContentTemplateSelector);
    public string get_ContentStringFormat();
    public void set_ContentStringFormat(string value);
    private static void OnContentStringFormatChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    protected virtual void OnContentStringFormatChanged(string oldContentStringFormat, string newContentStringFormat);
    internal bool get_ContentIsNotLogical();
    internal void set_ContentIsNotLogical(bool value);
    internal bool get_ContentIsItem();
    internal void set_ContentIsItem(bool value);
    internal virtual int get_EffectiveValuesInitialSize();
    internal virtual DependencyObjectType get_DTypeThemeStyleKey();
}
[LocalizabilityAttribute("0")]
public class System.Windows.Controls.ContentPresenter : FrameworkElement {
    [CommonDependencyPropertyAttribute]
public static DependencyProperty RecognizesAccessKeyProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty ContentProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty ContentTemplateProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty ContentTemplateSelectorProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty ContentStringFormatProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty ContentSourceProperty;
    internal static DependencyProperty TemplateProperty;
    private DataTemplate _templateCache;
    private bool _templateIsCurrent;
    private bool _contentIsItem;
    private XmlLanguage _language;
    private static DataTemplate s_AccessTextTemplate;
    private static DataTemplate s_StringTemplate;
    private static DataTemplate s_XmlNodeTemplate;
    private static DataTemplate s_UIElementTemplate;
    private static DataTemplate s_DefaultTemplate;
    private static DefaultSelector s_DefaultTemplateSelector;
    private static UncommonField`1<DataTemplate> XMLFormattingTemplateField;
    private static UncommonField`1<DataTemplate> StringFormattingTemplateField;
    private static UncommonField`1<DataTemplate> AccessTextFormattingTemplateField;
    public bool RecognizesAccessKey { get; public set; }
    public object Content { get; public set; }
    public DataTemplate ContentTemplate { get; public set; }
    public DataTemplateSelector ContentTemplateSelector { get; public set; }
    [BindableAttribute("True")]
[CustomCategoryAttribute("Content")]
public string ContentStringFormat { get; public set; }
    public string ContentSource { get; public set; }
    internal static DataTemplate AccessTextContentTemplate { get; }
    internal static DataTemplate StringContentTemplate { get; }
    internal FrameworkTemplate TemplateInternal { get; }
    internal FrameworkTemplate TemplateCache { get; internal set; }
    internal bool TemplateIsCurrent { get; }
    private static DataTemplate XmlNodeContentTemplate { get; }
    private static DataTemplate UIElementContentTemplate { get; }
    private static DataTemplate DefaultContentTemplate { get; }
    private static DefaultSelector DefaultTemplateSelector { get; }
    private DataTemplate FormattingAccessTextContentTemplate { get; }
    private DataTemplate FormattingStringContentTemplate { get; }
    private DataTemplate FormattingXmlNodeContentTemplate { get; }
    private DataTemplate Template { get; private set; }
    private bool IsUsingDefaultStringTemplate { get; }
    internal int EffectiveValuesInitialSize { get; }
    private static ContentPresenter();
    private void Initialize();
    public bool get_RecognizesAccessKey();
    public void set_RecognizesAccessKey(bool value);
    public object get_Content();
    public void set_Content(object value);
    private static void OnContentChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public DataTemplate get_ContentTemplate();
    public void set_ContentTemplate(DataTemplate value);
    private static void OnContentTemplateChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    protected virtual void OnContentTemplateChanged(DataTemplate oldContentTemplate, DataTemplate newContentTemplate);
    public DataTemplateSelector get_ContentTemplateSelector();
    public void set_ContentTemplateSelector(DataTemplateSelector value);
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeContentTemplateSelector();
    private static void OnContentTemplateSelectorChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    protected virtual void OnContentTemplateSelectorChanged(DataTemplateSelector oldContentTemplateSelector, DataTemplateSelector newContentTemplateSelector);
    public string get_ContentStringFormat();
    public void set_ContentStringFormat(string value);
    private static void OnContentStringFormatChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    protected virtual void OnContentStringFormatChanged(string oldContentStringFormat, string newContentStringFormat);
    public string get_ContentSource();
    public void set_ContentSource(string value);
    internal virtual void OnPreApplyTemplate();
    protected virtual Size MeasureOverride(Size constraint);
    protected virtual Size ArrangeOverride(Size arrangeSize);
    protected virtual DataTemplate ChooseTemplate();
    internal static DataTemplate get_AccessTextContentTemplate();
    internal static DataTemplate get_StringContentTemplate();
    internal virtual FrameworkTemplate get_TemplateInternal();
    internal virtual FrameworkTemplate get_TemplateCache();
    internal virtual void set_TemplateCache(FrameworkTemplate value);
    internal bool get_TemplateIsCurrent();
    internal void PrepareContentPresenter(object item, DataTemplate itemTemplate, DataTemplateSelector itemTemplateSelector, string stringFormat);
    internal void ClearContentPresenter(object item);
    internal static object DataTypeForItem(object item, DependencyObject target, Type& type);
    internal void ReevaluateTemplate();
    private static DataTemplate get_XmlNodeContentTemplate();
    private static DataTemplate get_UIElementContentTemplate();
    private static DataTemplate get_DefaultContentTemplate();
    private static DefaultSelector get_DefaultTemplateSelector();
    private DataTemplate get_FormattingAccessTextContentTemplate();
    private DataTemplate get_FormattingStringContentTemplate();
    private DataTemplate get_FormattingXmlNodeContentTemplate();
    private DataTemplate get_Template();
    private void set_Template(DataTemplate value);
    internal virtual void OnTemplateChangedInternal(FrameworkTemplate oldTemplate, FrameworkTemplate newTemplate);
    private static void OnTemplateChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    protected virtual void OnTemplateChanged(DataTemplate oldTemplate, DataTemplate newTemplate);
    private void EnsureTemplate();
    private DataTemplate SelectTemplateForString(string s);
    private bool get_IsUsingDefaultStringTemplate();
    private DataTemplate SelectTemplateForXML();
    internal static FrameworkElementFactory CreateAccessTextFactory();
    internal static FrameworkElementFactory CreateTextBlockFactory();
    private static TextBlock CreateTextBlock(ContentPresenter container);
    private void CacheLanguage(XmlLanguage language);
    internal virtual int get_EffectiveValuesInitialSize();
}
[DefaultEventAttribute("Opened")]
public class System.Windows.Controls.ContextMenu : MenuBase {
    public static DependencyProperty HorizontalOffsetProperty;
    public static DependencyProperty VerticalOffsetProperty;
    public static DependencyProperty IsOpenProperty;
    public static DependencyProperty PlacementTargetProperty;
    public static DependencyProperty PlacementRectangleProperty;
    public static DependencyProperty PlacementProperty;
    public static DependencyProperty HasDropShadowProperty;
    public static DependencyProperty CustomPopupPlacementCallbackProperty;
    public static DependencyProperty StaysOpenProperty;
    public static RoutedEvent OpenedEvent;
    public static RoutedEvent ClosedEvent;
    private static DependencyProperty InsideContextMenuProperty;
    private Popup _parentPopup;
    private WeakReference`1<IInputElement> _weakRefToPreviousFocus;
    private static DependencyObjectType _dType;
    [BindableAttribute("True")]
[TypeConverterAttribute("System.Windows.LengthConverter")]
[CategoryAttribute("Layout")]
public double HorizontalOffset { get; public set; }
    [CategoryAttribute("Layout")]
[BindableAttribute("True")]
[TypeConverterAttribute("System.Windows.LengthConverter")]
public double VerticalOffset { get; public set; }
    [BindableAttribute("True")]
[BrowsableAttribute("False")]
[CategoryAttribute("Appearance")]
[DesignerSerializationVisibilityAttribute("0")]
public bool IsOpen { get; public set; }
    [BindableAttribute("True")]
[CategoryAttribute("Layout")]
[DesignerSerializationVisibilityAttribute("0")]
public UIElement PlacementTarget { get; public set; }
    [BindableAttribute("True")]
[CategoryAttribute("Layout")]
public Rect PlacementRectangle { get; public set; }
    [BindableAttribute("True")]
[CategoryAttribute("Layout")]
public PlacementMode Placement { get; public set; }
    public bool HasDropShadow { get; public set; }
    [BindableAttribute("False")]
[CategoryAttribute("Layout")]
public CustomPopupPlacementCallback CustomPopupPlacementCallback { get; public set; }
    [BindableAttribute("True")]
[CategoryAttribute("Behavior")]
public bool StaysOpen { get; public set; }
    protected internal bool HandlesScrolling { get; }
    internal DependencyObjectType DTypeThemeStyleKey { get; }
    private static ContextMenu();
    private static object CoerceHorizontalOffset(DependencyObject d, object value);
    public double get_HorizontalOffset();
    public void set_HorizontalOffset(double value);
    private static object CoerceVerticalOffset(DependencyObject d, object value);
    public double get_VerticalOffset();
    public void set_VerticalOffset(double value);
    public bool get_IsOpen();
    public void set_IsOpen(bool value);
    private static void OnIsOpenChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static object CoercePlacementTarget(DependencyObject d, object value);
    public UIElement get_PlacementTarget();
    public void set_PlacementTarget(UIElement value);
    private static object CoercePlacementRectangle(DependencyObject d, object value);
    public Rect get_PlacementRectangle();
    public void set_PlacementRectangle(Rect value);
    private static object CoercePlacement(DependencyObject d, object value);
    public PlacementMode get_Placement();
    public void set_Placement(PlacementMode value);
    private static object CoerceHasDropShadow(DependencyObject d, object value);
    public bool get_HasDropShadow();
    public void set_HasDropShadow(bool value);
    public CustomPopupPlacementCallback get_CustomPopupPlacementCallback();
    public void set_CustomPopupPlacementCallback(CustomPopupPlacementCallback value);
    public bool get_StaysOpen();
    public void set_StaysOpen(bool value);
    public void add_Opened(RoutedEventHandler value);
    public void remove_Opened(RoutedEventHandler value);
    protected virtual void OnOpened(RoutedEventArgs e);
    public void add_Closed(RoutedEventHandler value);
    public void remove_Closed(RoutedEventHandler value);
    protected virtual void OnClosed(RoutedEventArgs e);
    protected virtual AutomationPeer OnCreateAutomationPeer();
    protected virtual void PrepareContainerForItemOverride(DependencyObject element, object item);
    protected internal virtual bool get_HandlesScrolling();
    protected virtual void OnKeyDown(KeyEventArgs e);
    protected virtual void OnKeyUp(KeyEventArgs e);
    private void Initialize();
    private void HookupParentPopup();
    private void OnPopupCouldClose(object sender, EventArgs e);
    private void OnPopupOpened(object source, EventArgs e);
    private void OnPopupClosed(object source, EventArgs e);
    private void ClosingMenu();
    private void OnPopupUnloaded(object sender, RoutedEventArgs e);
    private void OnIsMenuModeChanged(object sender, EventArgs e);
    protected virtual void OnIsKeyboardFocusWithinChanged(DependencyPropertyChangedEventArgs e);
    internal virtual bool IgnoreModelParentBuildRoute(RoutedEventArgs e);
    private static void OnAccessKeyPressed(object sender, AccessKeyPressedEventArgs e);
    protected internal virtual void OnVisualParentChanged(DependencyObject oldParent);
    internal virtual void OnAncestorChanged();
    internal virtual DependencyObjectType get_DTypeThemeStyleKey();
}
public class System.Windows.Controls.ContextMenuEventArgs : RoutedEventArgs {
    private double _left;
    private double _top;
    private DependencyObject _targetElement;
    public double CursorLeft { get; }
    public double CursorTop { get; }
    internal DependencyObject TargetElement { get; internal set; }
    internal ContextMenuEventArgs(object source, bool opening);
    internal ContextMenuEventArgs(object source, bool opening, double left, double top);
    public double get_CursorLeft();
    public double get_CursorTop();
    internal DependencyObject get_TargetElement();
    internal void set_TargetElement(DependencyObject value);
    protected virtual void InvokeEventHandler(Delegate genericHandler, object genericTarget);
}
public class System.Windows.Controls.ContextMenuEventHandler : MulticastDelegate {
    public ContextMenuEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, ContextMenuEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, ContextMenuEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public static class System.Windows.Controls.ContextMenuService : object {
    public static DependencyProperty ContextMenuProperty;
    public static DependencyProperty HorizontalOffsetProperty;
    public static DependencyProperty VerticalOffsetProperty;
    public static DependencyProperty HasDropShadowProperty;
    public static DependencyProperty PlacementTargetProperty;
    public static DependencyProperty PlacementRectangleProperty;
    public static DependencyProperty PlacementProperty;
    public static DependencyProperty ShowOnDisabledProperty;
    public static DependencyProperty IsEnabledProperty;
    public static RoutedEvent ContextMenuOpeningEvent;
    public static RoutedEvent ContextMenuClosingEvent;
    private static ContextMenuService();
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static ContextMenu GetContextMenu(DependencyObject element);
    public static void SetContextMenu(DependencyObject element, ContextMenu value);
    [TypeConverterAttribute("System.Windows.LengthConverter")]
[AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static double GetHorizontalOffset(DependencyObject element);
    public static void SetHorizontalOffset(DependencyObject element, double value);
    [TypeConverterAttribute("System.Windows.LengthConverter")]
[AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static double GetVerticalOffset(DependencyObject element);
    public static void SetVerticalOffset(DependencyObject element, double value);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static bool GetHasDropShadow(DependencyObject element);
    public static void SetHasDropShadow(DependencyObject element, bool value);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static UIElement GetPlacementTarget(DependencyObject element);
    public static void SetPlacementTarget(DependencyObject element, UIElement value);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static Rect GetPlacementRectangle(DependencyObject element);
    public static void SetPlacementRectangle(DependencyObject element, Rect value);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static PlacementMode GetPlacement(DependencyObject element);
    public static void SetPlacement(DependencyObject element, PlacementMode value);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static bool GetShowOnDisabled(DependencyObject element);
    public static void SetShowOnDisabled(DependencyObject element, bool value);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static bool GetIsEnabled(DependencyObject element);
    public static void SetIsEnabled(DependencyObject element, bool value);
    public static void AddContextMenuOpeningHandler(DependencyObject element, ContextMenuEventHandler handler);
    public static void RemoveContextMenuOpeningHandler(DependencyObject element, ContextMenuEventHandler handler);
    public static void AddContextMenuClosingHandler(DependencyObject element, ContextMenuEventHandler handler);
    public static void RemoveContextMenuClosingHandler(DependencyObject element, ContextMenuEventHandler handler);
    private static void OnContextMenuOpening(object sender, ContextMenuEventArgs e);
    internal static bool ContextMenuIsEnabled(DependencyObject o);
}
public class System.Windows.Controls.Control : FrameworkElement {
    [CommonDependencyPropertyAttribute]
public static DependencyProperty BorderBrushProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty BorderThicknessProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty BackgroundProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty ForegroundProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty FontFamilyProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty FontSizeProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty FontStretchProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty FontStyleProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty FontWeightProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty HorizontalContentAlignmentProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty VerticalContentAlignmentProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty TabIndexProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty IsTabStopProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty PaddingProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty TemplateProperty;
    public static RoutedEvent PreviewMouseDoubleClickEvent;
    public static RoutedEvent MouseDoubleClickEvent;
    private ControlTemplate _templateCache;
    internal ControlBoolFlags _controlBoolField;
    [BindableAttribute("True")]
[CategoryAttribute("Appearance")]
public Brush BorderBrush { get; public set; }
    [BindableAttribute("True")]
[CategoryAttribute("Appearance")]
public Thickness BorderThickness { get; public set; }
    [BindableAttribute("True")]
[CategoryAttribute("Appearance")]
public Brush Background { get; public set; }
    [CategoryAttribute("Appearance")]
[BindableAttribute("True")]
public Brush Foreground { get; public set; }
    [BindableAttribute("True")]
[CategoryAttribute("Appearance")]
[LocalizabilityAttribute("14")]
public FontFamily FontFamily { get; public set; }
    [TypeConverterAttribute("System.Windows.FontSizeConverter")]
[BindableAttribute("True")]
[CategoryAttribute("Appearance")]
[LocalizabilityAttribute("0")]
public double FontSize { get; public set; }
    [BindableAttribute("True")]
[CategoryAttribute("Appearance")]
public FontStretch FontStretch { get; public set; }
    [BindableAttribute("True")]
[CategoryAttribute("Appearance")]
public FontStyle FontStyle { get; public set; }
    [CategoryAttribute("Appearance")]
[BindableAttribute("True")]
public FontWeight FontWeight { get; public set; }
    [CategoryAttribute("Layout")]
[BindableAttribute("True")]
public HorizontalAlignment HorizontalContentAlignment { get; public set; }
    [BindableAttribute("True")]
[CategoryAttribute("Layout")]
public VerticalAlignment VerticalContentAlignment { get; public set; }
    [CategoryAttribute("Behavior")]
[BindableAttribute("True")]
public int TabIndex { get; public set; }
    [BindableAttribute("True")]
[CategoryAttribute("Behavior")]
public bool IsTabStop { get; public set; }
    [BindableAttribute("True")]
[CategoryAttribute("Layout")]
public Thickness Padding { get; public set; }
    public ControlTemplate Template { get; public set; }
    internal FrameworkTemplate TemplateInternal { get; }
    internal FrameworkTemplate TemplateCache { get; internal set; }
    protected internal bool HandlesScrolling { get; }
    internal bool VisualStateChangeSuspended { get; internal set; }
    private static Control();
    public Brush get_BorderBrush();
    public void set_BorderBrush(Brush value);
    public Thickness get_BorderThickness();
    public void set_BorderThickness(Thickness value);
    public Brush get_Background();
    public void set_Background(Brush value);
    public Brush get_Foreground();
    public void set_Foreground(Brush value);
    public FontFamily get_FontFamily();
    public void set_FontFamily(FontFamily value);
    public double get_FontSize();
    public void set_FontSize(double value);
    public FontStretch get_FontStretch();
    public void set_FontStretch(FontStretch value);
    public FontStyle get_FontStyle();
    public void set_FontStyle(FontStyle value);
    public FontWeight get_FontWeight();
    public void set_FontWeight(FontWeight value);
    public HorizontalAlignment get_HorizontalContentAlignment();
    public void set_HorizontalContentAlignment(HorizontalAlignment value);
    public VerticalAlignment get_VerticalContentAlignment();
    public void set_VerticalContentAlignment(VerticalAlignment value);
    public int get_TabIndex();
    public void set_TabIndex(int value);
    public bool get_IsTabStop();
    public void set_IsTabStop(bool value);
    private static bool IsMarginValid(object value);
    public Thickness get_Padding();
    public void set_Padding(Thickness value);
    public ControlTemplate get_Template();
    public void set_Template(ControlTemplate value);
    internal virtual FrameworkTemplate get_TemplateInternal();
    internal virtual FrameworkTemplate get_TemplateCache();
    internal virtual void set_TemplateCache(FrameworkTemplate value);
    internal virtual void OnTemplateChangedInternal(FrameworkTemplate oldTemplate, FrameworkTemplate newTemplate);
    private static void OnTemplateChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    protected virtual void OnTemplateChanged(ControlTemplate oldTemplate, ControlTemplate newTemplate);
    protected internal virtual bool get_HandlesScrolling();
    internal bool get_VisualStateChangeSuspended();
    internal void set_VisualStateChangeSuspended(bool value);
    public virtual string ToString();
    public void add_PreviewMouseDoubleClick(MouseButtonEventHandler value);
    public void remove_PreviewMouseDoubleClick(MouseButtonEventHandler value);
    protected virtual void OnPreviewMouseDoubleClick(MouseButtonEventArgs e);
    public void add_MouseDoubleClick(MouseButtonEventHandler value);
    public void remove_MouseDoubleClick(MouseButtonEventHandler value);
    protected virtual void OnMouseDoubleClick(MouseButtonEventArgs e);
    private static void HandleDoubleClick(object sender, MouseButtonEventArgs e);
    internal virtual void OnPreApplyTemplate();
    internal virtual void OnPostApplyTemplate();
    internal void UpdateVisualState();
    internal void UpdateVisualState(bool useTransitions);
    internal virtual void ChangeVisualState(bool useTransitions);
    internal void ChangeValidationVisualState(bool useTransitions);
    internal static void OnVisualStatePropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    protected virtual Size MeasureOverride(Size constraint);
    protected virtual Size ArrangeOverride(Size arrangeBounds);
    internal bool ReadControlFlag(ControlBoolFlags reqFlag);
    internal void WriteControlFlag(ControlBoolFlags reqFlag, bool set);
    [CompilerGeneratedAttribute]
private object <ToString>b__76_0(object o);
}
[LocalizabilityAttribute("0")]
[DictionaryKeyPropertyAttribute("TargetType")]
public class System.Windows.Controls.ControlTemplate : FrameworkTemplate {
    private Type _targetType;
    private TriggerCollection _triggers;
    internal static Type DefaultTargetType;
    [AmbientAttribute]
[DefaultValueAttribute("")]
public Type TargetType { get; public set; }
    [DesignerSerializationVisibilityAttribute("2")]
[DependsOnAttribute("VisualTree")]
[DependsOnAttribute("Template")]
public TriggerCollection Triggers { get; }
    internal Type TargetTypeInternal { get; }
    internal TriggerCollection TriggersInternal { get; }
    public ControlTemplate(Type targetType);
    private static ControlTemplate();
    protected virtual void ValidateTemplatedParent(FrameworkElement templatedParent);
    public Type get_TargetType();
    public void set_TargetType(Type value);
    public TriggerCollection get_Triggers();
    private void ValidateTargetType(Type targetType, string argName);
    internal virtual Type get_TargetTypeInternal();
    internal virtual void SetTargetTypeInternal(Type targetType);
    internal virtual TriggerCollection get_TriggersInternal();
}
internal class System.Windows.Controls.ConversionValidationRule : ValidationRule {
    internal static ConversionValidationRule Instance;
    private static ConversionValidationRule();
    public virtual ValidationResult Validate(object value, CultureInfo cultureInfo);
}
internal class System.Windows.Controls.CustomDictionarySources : object {
    private List`1<Uri> _uriList;
    private TextBoxBase _owner;
    private Uri System.Collections.Generic.IList<System.Uri>.Item { get; private set; }
    private int System.Collections.Generic.ICollection<System.Uri>.Count { get; }
    private bool System.Collections.Generic.ICollection<System.Uri>.IsReadOnly { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private object System.Collections.IList.Item { get; private set; }
    private int System.Collections.ICollection.Count { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private Speller Speller { get; }
    internal CustomDictionarySources(TextBoxBase owner);
    public sealed virtual IEnumerator`1<Uri> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override int System.Collections.Generic.IList<System.Uri>.IndexOf(Uri item);
    private sealed virtual override void System.Collections.Generic.IList<System.Uri>.Insert(int index, Uri item);
    private sealed virtual override void System.Collections.Generic.IList<System.Uri>.RemoveAt(int index);
    private sealed virtual override Uri System.Collections.Generic.IList<System.Uri>.get_Item(int index);
    private sealed virtual override void System.Collections.Generic.IList<System.Uri>.set_Item(int index, Uri value);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Uri>.Add(Uri item);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Uri>.Clear();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Uri>.Contains(Uri item);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Uri>.CopyTo(Uri[] array, int arrayIndex);
    private sealed virtual override int System.Collections.Generic.ICollection<System.Uri>.get_Count();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Uri>.get_IsReadOnly();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Uri>.Remove(Uri item);
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override void System.Collections.IList.Clear();
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.IList.RemoveAt(int index);
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override int System.Collections.ICollection.get_Count();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private Speller get_Speller();
    private static void ValidateUri(Uri item);
}
public class System.Windows.Controls.DataErrorValidationRule : ValidationRule {
    internal static DataErrorValidationRule Instance;
    private static DataErrorValidationRule();
    public virtual ValidationResult Validate(object value, CultureInfo cultureInfo);
}
public class System.Windows.Controls.DataGrid : MultiSelector {
    public static DependencyProperty CanUserResizeColumnsProperty;
    public static DependencyProperty ColumnWidthProperty;
    public static DependencyProperty MinColumnWidthProperty;
    public static DependencyProperty MaxColumnWidthProperty;
    private static UncommonField`1<int> BringColumnIntoViewRetryCountField;
    private static int MaxBringColumnIntoViewRetries;
    [CompilerGeneratedAttribute]
private EventHandler`1<DataGridColumnEventArgs> ColumnDisplayIndexChanged;
    public static DependencyProperty GridLinesVisibilityProperty;
    public static DependencyProperty HorizontalGridLinesBrushProperty;
    public static DependencyProperty VerticalGridLinesBrushProperty;
    public static DependencyProperty RowStyleProperty;
    public static DependencyProperty RowValidationErrorTemplateProperty;
    public static DependencyProperty RowStyleSelectorProperty;
    public static DependencyProperty RowBackgroundProperty;
    public static DependencyProperty AlternatingRowBackgroundProperty;
    public static DependencyProperty RowHeightProperty;
    public static DependencyProperty MinRowHeightProperty;
    [CompilerGeneratedAttribute]
private EventHandler`1<DataGridRowEventArgs> LoadingRow;
    [CompilerGeneratedAttribute]
private EventHandler`1<DataGridRowEventArgs> UnloadingRow;
    public static DependencyProperty RowHeaderWidthProperty;
    private static DependencyPropertyKey RowHeaderActualWidthPropertyKey;
    public static DependencyProperty RowHeaderActualWidthProperty;
    public static DependencyProperty ColumnHeaderHeightProperty;
    public static DependencyProperty HeadersVisibilityProperty;
    public static DependencyProperty CellStyleProperty;
    public static DependencyProperty ColumnHeaderStyleProperty;
    public static DependencyProperty RowHeaderStyleProperty;
    public static DependencyProperty RowHeaderTemplateProperty;
    public static DependencyProperty RowHeaderTemplateSelectorProperty;
    public static DependencyProperty HorizontalScrollBarVisibilityProperty;
    public static DependencyProperty VerticalScrollBarVisibilityProperty;
    internal static DependencyProperty HorizontalScrollOffsetProperty;
    public static RoutedCommand BeginEditCommand;
    public static RoutedCommand CommitEditCommand;
    public static RoutedCommand CancelEditCommand;
    [CompilerGeneratedAttribute]
private EventHandler`1<DataGridRowEditEndingEventArgs> RowEditEnding;
    [CompilerGeneratedAttribute]
private EventHandler`1<DataGridCellEditEndingEventArgs> CellEditEnding;
    public static DependencyProperty IsReadOnlyProperty;
    public static DependencyProperty CurrentItemProperty;
    public static DependencyProperty CurrentColumnProperty;
    public static DependencyProperty CurrentCellProperty;
    [CompilerGeneratedAttribute]
private EventHandler`1<EventArgs> CurrentCellChanged;
    [CompilerGeneratedAttribute]
private EventHandler`1<DataGridBeginningEditEventArgs> BeginningEdit;
    [CompilerGeneratedAttribute]
private EventHandler`1<DataGridPreparingCellForEditEventArgs> PreparingCellForEdit;
    public static DependencyProperty CanUserAddRowsProperty;
    public static DependencyProperty CanUserDeleteRowsProperty;
    [CompilerGeneratedAttribute]
private EventHandler`1<AddingNewItemEventArgs> AddingNewItem;
    [CompilerGeneratedAttribute]
private InitializingNewItemEventHandler InitializingNewItem;
    public static DependencyProperty RowDetailsVisibilityModeProperty;
    public static DependencyProperty AreRowDetailsFrozenProperty;
    public static DependencyProperty RowDetailsTemplateProperty;
    public static DependencyProperty RowDetailsTemplateSelectorProperty;
    [CompilerGeneratedAttribute]
private EventHandler`1<DataGridRowDetailsEventArgs> LoadingRowDetails;
    [CompilerGeneratedAttribute]
private EventHandler`1<DataGridRowDetailsEventArgs> UnloadingRowDetails;
    [CompilerGeneratedAttribute]
private EventHandler`1<DataGridRowDetailsEventArgs> RowDetailsVisibilityChanged;
    public static DependencyProperty CanUserResizeRowsProperty;
    private static DependencyPropertyKey NewItemMarginPropertyKey;
    public static DependencyProperty NewItemMarginProperty;
    [CompilerGeneratedAttribute]
private SelectedCellsChangedEventHandler SelectedCellsChanged;
    public static DependencyProperty SelectionModeProperty;
    public static DependencyProperty SelectionUnitProperty;
    public static DependencyProperty CanUserSortColumnsProperty;
    [CompilerGeneratedAttribute]
private DataGridSortingEventHandler Sorting;
    [CompilerGeneratedAttribute]
private EventHandler AutoGeneratedColumns;
    [CompilerGeneratedAttribute]
private EventHandler`1<DataGridAutoGeneratingColumnEventArgs> AutoGeneratingColumn;
    public static DependencyProperty AutoGenerateColumnsProperty;
    [CompilerGeneratedAttribute]
private bool <DeferAutoGeneration>k__BackingField;
    public static DependencyProperty FrozenColumnCountProperty;
    private static DependencyPropertyKey NonFrozenColumnsViewportHorizontalOffsetPropertyKey;
    public static DependencyProperty NonFrozenColumnsViewportHorizontalOffsetProperty;
    public static DependencyProperty EnableRowVirtualizationProperty;
    public static DependencyProperty EnableColumnVirtualizationProperty;
    public static DependencyProperty CanUserReorderColumnsProperty;
    public static DependencyProperty DragIndicatorStyleProperty;
    public static DependencyProperty DropLocationIndicatorStyleProperty;
    [CompilerGeneratedAttribute]
private EventHandler`1<DataGridColumnReorderingEventArgs> ColumnReordering;
    [CompilerGeneratedAttribute]
private EventHandler`1<DragStartedEventArgs> ColumnHeaderDragStarted;
    [CompilerGeneratedAttribute]
private EventHandler`1<DragDeltaEventArgs> ColumnHeaderDragDelta;
    [CompilerGeneratedAttribute]
private EventHandler`1<DragCompletedEventArgs> ColumnHeaderDragCompleted;
    [CompilerGeneratedAttribute]
private EventHandler`1<DataGridColumnEventArgs> ColumnReordered;
    public static DependencyProperty ClipboardCopyModeProperty;
    [CompilerGeneratedAttribute]
private EventHandler`1<DataGridRowClipboardEventArgs> CopyingRowClipboardContent;
    internal static DependencyProperty CellsPanelActualWidthProperty;
    private static DependencyPropertyKey CellsPanelHorizontalOffsetPropertyKey;
    public static DependencyProperty CellsPanelHorizontalOffsetProperty;
    [CompilerGeneratedAttribute]
private bool <CellsPanelHorizontalOffsetComputationPending>k__BackingField;
    private static IValueConverter _headersVisibilityConverter;
    private static IValueConverter _rowDetailsScrollingConverter;
    private static object _newItemPlaceholder;
    private DataGridColumnCollection _columns;
    private ContainerTracking`1<DataGridRow> _rowTrackingRoot;
    private DataGridColumnHeadersPresenter _columnHeadersPresenter;
    private DataGridCell _currentCellContainer;
    private DataGridCell _pendingCurrentCellContainer;
    private SelectedCellsCollection _selectedCells;
    private List`1<ItemInfo> _pendingInfos;
    private Nullable`1<DataGridCellInfo> _selectionAnchor;
    private bool _isDraggingSelection;
    private bool _isRowDragging;
    private Panel _internalItemsHost;
    private ScrollViewer _internalScrollHost;
    private ScrollContentPresenter _internalScrollContentPresenter;
    private DispatcherTimer _autoScrollTimer;
    private bool _hasAutoScrolled;
    private VirtualizedCellInfoCollection _pendingSelectedCells;
    private VirtualizedCellInfoCollection _pendingUnselectedCells;
    private bool _measureNeverInvoked;
    private bool _updatingSelectedCells;
    private Visibility _placeholderVisibility;
    private Point _dragPoint;
    private List`1<int> _groupingSortDescriptionIndices;
    private bool _ignoreSortDescriptionsChange;
    private bool _sortingStarted;
    private ObservableCollection`1<ValidationRule> _rowValidationRules;
    private BindingGroup _defaultBindingGroup;
    private ItemInfo _editingRowInfo;
    private bool _hasCellValidationError;
    private bool _hasRowValidationError;
    private IEnumerable _cachedItemsSource;
    private DataGridItemAttachedStorage _itemAttachedStorage;
    private bool _viewportWidthChangeNotificationPending;
    private double _originalViewportWidth;
    private double _finalViewportWidth;
    private Dictionary`2<DataGridColumn, CellAutomationValueHolder> _editingCellAutomationValueHolders;
    private DataGridCell _focusedCell;
    private bool _newItemMarginComputationPending;
    private static string ItemsPanelPartName;
    public ObservableCollection`1<DataGridColumn> Columns { get; }
    internal DataGridColumnCollection InternalColumns { get; }
    public bool CanUserResizeColumns { get; public set; }
    public DataGridLength ColumnWidth { get; public set; }
    public double MinColumnWidth { get; public set; }
    public double MaxColumnWidth { get; public set; }
    internal List`1<int> DisplayIndexMap { get; }
    internal DataGridColumnHeadersPresenter ColumnHeadersPresenter { get; internal set; }
    public DataGridGridLinesVisibility GridLinesVisibility { get; public set; }
    public Brush HorizontalGridLinesBrush { get; public set; }
    public Brush VerticalGridLinesBrush { get; public set; }
    internal double HorizontalGridLineThickness { get; }
    internal double VerticalGridLineThickness { get; }
    public Style RowStyle { get; public set; }
    public ControlTemplate RowValidationErrorTemplate { get; public set; }
    public ObservableCollection`1<ValidationRule> RowValidationRules { get; }
    public StyleSelector RowStyleSelector { get; public set; }
    public Brush RowBackground { get; public set; }
    public Brush AlternatingRowBackground { get; public set; }
    public double RowHeight { get; public set; }
    public double MinRowHeight { get; public set; }
    internal Visibility PlaceholderVisibility { get; }
    public double RowHeaderWidth { get; public set; }
    public double RowHeaderActualWidth { get; internal set; }
    public double ColumnHeaderHeight { get; public set; }
    public DataGridHeadersVisibility HeadersVisibility { get; public set; }
    internal DataGridItemAttachedStorage ItemAttachedStorage { get; }
    private bool ShouldSelectRowHeader { get; }
    public Style CellStyle { get; public set; }
    public Style ColumnHeaderStyle { get; public set; }
    public Style RowHeaderStyle { get; public set; }
    public DataTemplate RowHeaderTemplate { get; public set; }
    public DataTemplateSelector RowHeaderTemplateSelector { get; public set; }
    public static ComponentResourceKey FocusBorderBrushKey { get; }
    public static IValueConverter HeadersVisibilityConverter { get; }
    public static IValueConverter RowDetailsScrollingConverter { get; }
    public ScrollBarVisibility HorizontalScrollBarVisibility { get; public set; }
    public ScrollBarVisibility VerticalScrollBarVisibility { get; public set; }
    protected internal bool HandlesScrolling { get; }
    internal Panel InternalItemsHost { get; internal set; }
    internal ScrollViewer InternalScrollHost { get; }
    internal ScrollContentPresenter InternalScrollContentPresenter { get; }
    internal double HorizontalScrollOffset { get; }
    public static RoutedUICommand DeleteCommand { get; }
    public bool IsReadOnly { get; public set; }
    public object CurrentItem { get; public set; }
    public DataGridColumn CurrentColumn { get; public set; }
    public DataGridCellInfo CurrentCell { get; public set; }
    internal DataGridCell CurrentCellContainer { get; internal set; }
    private bool IsEditingCurrentCell { get; }
    private bool IsCurrentCellReadOnly { get; }
    internal ItemInfo CurrentInfo { get; }
    private bool HasCellValidationError { get; private set; }
    private bool HasRowValidationError { get; private set; }
    internal DataGridCell FocusedCell { get; internal set; }
    public bool CanUserAddRows { get; public set; }
    public bool CanUserDeleteRows { get; public set; }
    private IEditableCollectionView EditableItems { get; }
    private bool IsAddingNewItem { get; }
    private bool IsEditingRowItem { get; }
    private int DataItemsCount { get; }
    private int DataItemsSelected { get; }
    private bool HasNewItemPlaceholder { get; }
    public DataGridRowDetailsVisibilityMode RowDetailsVisibilityMode { get; public set; }
    public bool AreRowDetailsFrozen { get; public set; }
    public DataTemplate RowDetailsTemplate { get; public set; }
    public DataTemplateSelector RowDetailsTemplateSelector { get; public set; }
    public bool CanUserResizeRows { get; public set; }
    public Thickness NewItemMargin { get; private set; }
    internal SelectedItemCollection SelectedItemCollection { get; }
    public IList`1<DataGridCellInfo> SelectedCells { get; }
    internal SelectedCellsCollection SelectedCellsInternal { get; }
    public static RoutedUICommand SelectAllCommand { get; }
    public DataGridSelectionMode SelectionMode { get; public set; }
    public DataGridSelectionUnit SelectionUnit { get; public set; }
    private bool IsUpdatingSelectedCells { get; }
    private bool ShouldExtendSelection { get; }
    private static bool ShouldMinimallyModifySelection { get; }
    private bool CanSelectRows { get; }
    private DataGridRow MouseOverRow { get; }
    private DataGridCell MouseOverCell { get; }
    private RelativeMousePositions RelativeMousePosition { get; }
    public bool CanUserSortColumns { get; public set; }
    private List`1<int> GroupingSortDescriptionIndices { get; private set; }
    public bool AutoGenerateColumns { get; public set; }
    private bool DeferAutoGeneration { get; private set; }
    public int FrozenColumnCount { get; public set; }
    public double NonFrozenColumnsViewportHorizontalOffset { get; internal set; }
    public bool EnableRowVirtualization { get; public set; }
    public bool EnableColumnVirtualization { get; public set; }
    public bool CanUserReorderColumns { get; public set; }
    public Style DragIndicatorStyle { get; public set; }
    public Style DropLocationIndicatorStyle { get; public set; }
    public DataGridClipboardCopyMode ClipboardCopyMode { get; public set; }
    internal double CellsPanelActualWidth { get; internal set; }
    public double CellsPanelHorizontalOffset { get; private set; }
    private bool CellsPanelHorizontalOffsetComputationPending { get; private set; }
    internal static object NewItemPlaceholder { get; }
    private static DataGrid();
    public ObservableCollection`1<DataGridColumn> get_Columns();
    internal DataGridColumnCollection get_InternalColumns();
    public bool get_CanUserResizeColumns();
    public void set_CanUserResizeColumns(bool value);
    public DataGridLength get_ColumnWidth();
    public void set_ColumnWidth(DataGridLength value);
    public double get_MinColumnWidth();
    public void set_MinColumnWidth(double value);
    public double get_MaxColumnWidth();
    public void set_MaxColumnWidth(double value);
    private static void OnColumnSizeConstraintChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static bool ValidateMinColumnWidth(object v);
    private static bool ValidateMaxColumnWidth(object v);
    private void OnColumnsChanged(object sender, NotifyCollectionChangedEventArgs e);
    internal void UpdateDataGridReference(IList list, bool clear);
    private static void UpdateColumnSizeConstraints(IList list);
    private static bool HasVisibleColumns(IList columns);
    internal bool RetryBringColumnIntoView(bool retryRequested);
    public DataGridColumn ColumnFromDisplayIndex(int displayIndex);
    [CompilerGeneratedAttribute]
public void add_ColumnDisplayIndexChanged(EventHandler`1<DataGridColumnEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_ColumnDisplayIndexChanged(EventHandler`1<DataGridColumnEventArgs> value);
    protected internal virtual void OnColumnDisplayIndexChanged(DataGridColumnEventArgs e);
    internal List`1<int> get_DisplayIndexMap();
    internal void ValidateDisplayIndex(DataGridColumn column, int displayIndex);
    internal int ColumnIndexFromDisplayIndex(int displayIndex);
    internal DataGridColumnHeader ColumnHeaderFromDisplayIndex(int displayIndex);
    private static void OnNotifyCellsPresenterPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void OnNotifyColumnAndCellPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void OnNotifyColumnPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void OnNotifyColumnAndColumnHeaderPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void OnNotifyColumnHeaderPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void OnNotifyHeaderPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void OnNotifyDataGridAndRowPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void OnNotifyGridLinePropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void OnNotifyRowPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void OnNotifyRowHeaderPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void OnNotifyRowAndRowHeaderPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void OnNotifyRowAndDetailsPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void OnNotifyHorizontalOffsetPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    internal void NotifyPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e, DataGridNotificationTarget target);
    internal void NotifyPropertyChanged(DependencyObject d, string propertyName, DependencyPropertyChangedEventArgs e, DataGridNotificationTarget target);
    internal void UpdateColumnsOnVirtualizedCellInfoCollections(NotifyCollectionChangedAction action, int oldDisplayIndex, DataGridColumn oldColumn, int newDisplayIndex);
    internal DataGridColumnHeadersPresenter get_ColumnHeadersPresenter();
    internal void set_ColumnHeadersPresenter(DataGridColumnHeadersPresenter value);
    protected virtual void OnTemplateChanged(ControlTemplate oldTemplate, ControlTemplate newTemplate);
    public DataGridGridLinesVisibility get_GridLinesVisibility();
    public void set_GridLinesVisibility(DataGridGridLinesVisibility value);
    public Brush get_HorizontalGridLinesBrush();
    public void set_HorizontalGridLinesBrush(Brush value);
    public Brush get_VerticalGridLinesBrush();
    public void set_VerticalGridLinesBrush(Brush value);
    internal double get_HorizontalGridLineThickness();
    internal double get_VerticalGridLineThickness();
    protected virtual bool IsItemItsOwnContainerOverride(object item);
    protected virtual DependencyObject GetContainerForItemOverride();
    protected virtual void PrepareContainerForItemOverride(DependencyObject element, object item);
    protected virtual void ClearContainerForItemOverride(DependencyObject element, object item);
    private void UpdateColumnsOnRows(NotifyCollectionChangedEventArgs e);
    public Style get_RowStyle();
    public void set_RowStyle(Style value);
    private static void OnRowStyleChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static object OnCoerceItemContainerStyle(DependencyObject d, object baseValue);
    public ControlTemplate get_RowValidationErrorTemplate();
    public void set_RowValidationErrorTemplate(ControlTemplate value);
    public ObservableCollection`1<ValidationRule> get_RowValidationRules();
    private void OnRowValidationRulesChanged(object sender, NotifyCollectionChangedEventArgs e);
    public StyleSelector get_RowStyleSelector();
    public void set_RowStyleSelector(StyleSelector value);
    private static void OnRowStyleSelectorChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static object OnCoerceItemContainerStyleSelector(DependencyObject d, object baseValue);
    private static object OnCoerceIsSynchronizedWithCurrentItem(DependencyObject d, object baseValue);
    public Brush get_RowBackground();
    public void set_RowBackground(Brush value);
    public Brush get_AlternatingRowBackground();
    public void set_AlternatingRowBackground(Brush value);
    private static object OnCoerceAlternationCount(DependencyObject d, object baseValue);
    public double get_RowHeight();
    public void set_RowHeight(double value);
    public double get_MinRowHeight();
    public void set_MinRowHeight(double value);
    internal Visibility get_PlaceholderVisibility();
    [CompilerGeneratedAttribute]
public void add_LoadingRow(EventHandler`1<DataGridRowEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_LoadingRow(EventHandler`1<DataGridRowEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_UnloadingRow(EventHandler`1<DataGridRowEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_UnloadingRow(EventHandler`1<DataGridRowEventArgs> value);
    protected virtual void OnLoadingRow(DataGridRowEventArgs e);
    internal static object DelayedOnLoadingRowDetails(object arg);
    protected virtual void OnUnloadingRow(DataGridRowEventArgs e);
    public double get_RowHeaderWidth();
    public void set_RowHeaderWidth(double value);
    public double get_RowHeaderActualWidth();
    internal void set_RowHeaderActualWidth(double value);
    public double get_ColumnHeaderHeight();
    public void set_ColumnHeaderHeight(double value);
    public DataGridHeadersVisibility get_HeadersVisibility();
    public void set_HeadersVisibility(DataGridHeadersVisibility value);
    private static void OnNotifyRowHeaderWidthPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private void ResetRowHeaderActualWidth();
    public void SetDetailsVisibilityForItem(object item, Visibility detailsVisibility);
    public Visibility GetDetailsVisibilityForItem(object item);
    public void ClearDetailsVisibilityForItem(object item);
    internal DataGridItemAttachedStorage get_ItemAttachedStorage();
    private bool get_ShouldSelectRowHeader();
    public Style get_CellStyle();
    public void set_CellStyle(Style value);
    public Style get_ColumnHeaderStyle();
    public void set_ColumnHeaderStyle(Style value);
    public Style get_RowHeaderStyle();
    public void set_RowHeaderStyle(Style value);
    public DataTemplate get_RowHeaderTemplate();
    public void set_RowHeaderTemplate(DataTemplate value);
    public DataTemplateSelector get_RowHeaderTemplateSelector();
    public void set_RowHeaderTemplateSelector(DataTemplateSelector value);
    public static ComponentResourceKey get_FocusBorderBrushKey();
    public static IValueConverter get_HeadersVisibilityConverter();
    public static IValueConverter get_RowDetailsScrollingConverter();
    public ScrollBarVisibility get_HorizontalScrollBarVisibility();
    public void set_HorizontalScrollBarVisibility(ScrollBarVisibility value);
    public ScrollBarVisibility get_VerticalScrollBarVisibility();
    public void set_VerticalScrollBarVisibility(ScrollBarVisibility value);
    public void ScrollIntoView(object item);
    internal void ScrollIntoView(ItemInfo info);
    public void ScrollIntoView(object item, DataGridColumn column);
    private void ScrollIntoView(ItemInfo info, DataGridColumn column);
    private object OnScrollIntoView(object arg);
    private void ScrollColumnIntoView(DataGridColumn column);
    private void ScrollCellIntoView(ItemInfo info, DataGridColumn column);
    protected virtual void OnIsMouseCapturedChanged(DependencyPropertyChangedEventArgs e);
    private void StartAutoScroll();
    private void StopAutoScroll();
    private void OnAutoScrollTimeout(object sender, EventArgs e);
    private bool DoAutoScroll();
    protected internal virtual bool get_HandlesScrolling();
    internal Panel get_InternalItemsHost();
    internal void set_InternalItemsHost(Panel value);
    internal ScrollViewer get_InternalScrollHost();
    internal ScrollContentPresenter get_InternalScrollContentPresenter();
    private void DetermineItemsHostStarBehavior();
    private void EnsureInternalScrollControls();
    private void CleanUpInternalScrollControls();
    private void OnInternalScrollContentPresenterSizeChanged(object sender, SizeChangedEventArgs e);
    internal void OnViewportSizeChanged(Size oldSize, Size newSize);
    private object OnDelayedViewportWidthChanged(object args);
    internal void OnHasVisibleStarColumnsChanged();
    internal double get_HorizontalScrollOffset();
    public static RoutedUICommand get_DeleteCommand();
    private static void OnCanExecuteBeginEdit(object sender, CanExecuteRoutedEventArgs e);
    private static void OnExecutedBeginEdit(object sender, ExecutedRoutedEventArgs e);
    protected virtual void OnCanExecuteBeginEdit(CanExecuteRoutedEventArgs e);
    protected virtual void OnExecutedBeginEdit(ExecutedRoutedEventArgs e);
    private static void OnCanExecuteCommitEdit(object sender, CanExecuteRoutedEventArgs e);
    private static void OnExecutedCommitEdit(object sender, ExecutedRoutedEventArgs e);
    private DataGridCell GetEventCellOrCurrentCell(RoutedEventArgs e);
    private bool CanEndEdit(CanExecuteRoutedEventArgs e, bool commit);
    protected virtual void OnCanExecuteCommitEdit(CanExecuteRoutedEventArgs e);
    protected virtual void OnExecutedCommitEdit(ExecutedRoutedEventArgs e);
    private static object DoNothing(object arg);
    private DataGridEditingUnit GetEditingUnit(object parameter);
    [CompilerGeneratedAttribute]
public void add_RowEditEnding(EventHandler`1<DataGridRowEditEndingEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_RowEditEnding(EventHandler`1<DataGridRowEditEndingEventArgs> value);
    protected virtual void OnRowEditEnding(DataGridRowEditEndingEventArgs e);
    [CompilerGeneratedAttribute]
public void add_CellEditEnding(EventHandler`1<DataGridCellEditEndingEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_CellEditEnding(EventHandler`1<DataGridCellEditEndingEventArgs> value);
    protected virtual void OnCellEditEnding(DataGridCellEditEndingEventArgs e);
    private static void OnCanExecuteCancelEdit(object sender, CanExecuteRoutedEventArgs e);
    private static void OnExecutedCancelEdit(object sender, ExecutedRoutedEventArgs e);
    protected virtual void OnCanExecuteCancelEdit(CanExecuteRoutedEventArgs e);
    protected virtual void OnExecutedCancelEdit(ExecutedRoutedEventArgs e);
    private static void OnCanExecuteDelete(object sender, CanExecuteRoutedEventArgs e);
    private static void OnExecutedDelete(object sender, ExecutedRoutedEventArgs e);
    protected virtual void OnCanExecuteDelete(CanExecuteRoutedEventArgs e);
    protected virtual void OnExecutedDelete(ExecutedRoutedEventArgs e);
    private void SetCurrentCellToNewItem(object newItem);
    public bool get_IsReadOnly();
    public void set_IsReadOnly(bool value);
    private static void OnIsReadOnlyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public object get_CurrentItem();
    public void set_CurrentItem(object value);
    private static void OnCurrentItemChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private void SetCurrentItem(object item);
    public DataGridColumn get_CurrentColumn();
    public void set_CurrentColumn(DataGridColumn value);
    private static void OnCurrentColumnChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public DataGridCellInfo get_CurrentCell();
    public void set_CurrentCell(DataGridCellInfo value);
    private static void OnCurrentCellChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    [CompilerGeneratedAttribute]
public void add_CurrentCellChanged(EventHandler`1<EventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_CurrentCellChanged(EventHandler`1<EventArgs> value);
    protected virtual void OnCurrentCellChanged(EventArgs e);
    private void UpdateCurrentCell(DataGridCell cell, bool isFocusWithinCell);
    internal DataGridCell get_CurrentCellContainer();
    internal void set_CurrentCellContainer(DataGridCell value);
    private bool get_IsEditingCurrentCell();
    private bool get_IsCurrentCellReadOnly();
    internal ItemInfo get_CurrentInfo();
    internal bool IsCurrent(DataGridRow row, DataGridColumn column);
    [CompilerGeneratedAttribute]
public void add_BeginningEdit(EventHandler`1<DataGridBeginningEditEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_BeginningEdit(EventHandler`1<DataGridBeginningEditEventArgs> value);
    protected virtual void OnBeginningEdit(DataGridBeginningEditEventArgs e);
    [CompilerGeneratedAttribute]
public void add_PreparingCellForEdit(EventHandler`1<DataGridPreparingCellForEditEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_PreparingCellForEdit(EventHandler`1<DataGridPreparingCellForEditEventArgs> value);
    protected internal virtual void OnPreparingCellForEdit(DataGridPreparingCellForEditEventArgs e);
    public bool BeginEdit();
    public bool BeginEdit(RoutedEventArgs editingEventArgs);
    public bool CancelEdit();
    internal bool CancelEdit(DataGridCell cell);
    public bool CancelEdit(DataGridEditingUnit editingUnit);
    private void CancelAnyEdit();
    public bool CommitEdit();
    public bool CommitEdit(DataGridEditingUnit editingUnit, bool exitEditingMode);
    private bool CommitAnyEdit();
    private bool EndEdit(RoutedCommand command, DataGridCell cellContainer, DataGridEditingUnit editingUnit, bool exitEditMode);
    private bool get_HasCellValidationError();
    private void set_HasCellValidationError(bool value);
    private bool get_HasRowValidationError();
    private void set_HasRowValidationError(bool value);
    internal DataGridCell get_FocusedCell();
    internal void set_FocusedCell(DataGridCell value);
    public bool get_CanUserAddRows();
    public void set_CanUserAddRows(bool value);
    private static void OnCanUserAddRowsChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static object OnCoerceCanUserAddRows(DependencyObject d, object baseValue);
    private static bool OnCoerceCanUserAddOrDeleteRows(DataGrid dataGrid, bool baseValue, bool canUserAddRowsProperty);
    public bool get_CanUserDeleteRows();
    public void set_CanUserDeleteRows(bool value);
    private static void OnCanUserDeleteRowsChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static object OnCoerceCanUserDeleteRows(DependencyObject d, object baseValue);
    [CompilerGeneratedAttribute]
public void add_AddingNewItem(EventHandler`1<AddingNewItemEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_AddingNewItem(EventHandler`1<AddingNewItemEventArgs> value);
    protected virtual void OnAddingNewItem(AddingNewItemEventArgs e);
    [CompilerGeneratedAttribute]
public void add_InitializingNewItem(InitializingNewItemEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_InitializingNewItem(InitializingNewItemEventHandler value);
    protected virtual void OnInitializingNewItem(InitializingNewItemEventArgs e);
    private object AddNewItem();
    private void EditRowItem(object rowItem);
    private void CommitRowItem();
    private void CancelRowItem();
    private void UpdateRowEditing(DataGridCell cell);
    private IEditableCollectionView get_EditableItems();
    private bool get_IsAddingNewItem();
    private bool get_IsEditingRowItem();
    private bool IsAddingOrEditingRowItem(object item);
    private bool IsAddingOrEditingRowItem(DataGridEditingUnit editingUnit, object item);
    private bool IsEditingItem(object item);
    private void UpdateNewItemPlaceholder(bool isAddingNewItem);
    private void SetCurrentItemToPlaceholder();
    private int get_DataItemsCount();
    private int get_DataItemsSelected();
    private bool get_HasNewItemPlaceholder();
    private bool IsNewItemPlaceholder(object item);
    public DataGridRowDetailsVisibilityMode get_RowDetailsVisibilityMode();
    public void set_RowDetailsVisibilityMode(DataGridRowDetailsVisibilityMode value);
    public bool get_AreRowDetailsFrozen();
    public void set_AreRowDetailsFrozen(bool value);
    public DataTemplate get_RowDetailsTemplate();
    public void set_RowDetailsTemplate(DataTemplate value);
    public DataTemplateSelector get_RowDetailsTemplateSelector();
    public void set_RowDetailsTemplateSelector(DataTemplateSelector value);
    [CompilerGeneratedAttribute]
public void add_LoadingRowDetails(EventHandler`1<DataGridRowDetailsEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_LoadingRowDetails(EventHandler`1<DataGridRowDetailsEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_UnloadingRowDetails(EventHandler`1<DataGridRowDetailsEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_UnloadingRowDetails(EventHandler`1<DataGridRowDetailsEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_RowDetailsVisibilityChanged(EventHandler`1<DataGridRowDetailsEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_RowDetailsVisibilityChanged(EventHandler`1<DataGridRowDetailsEventArgs> value);
    internal void OnLoadingRowDetailsWrapper(DataGridRow row);
    internal void OnUnloadingRowDetailsWrapper(DataGridRow row);
    protected virtual void OnLoadingRowDetails(DataGridRowDetailsEventArgs e);
    protected virtual void OnUnloadingRowDetails(DataGridRowDetailsEventArgs e);
    protected internal virtual void OnRowDetailsVisibilityChanged(DataGridRowDetailsEventArgs e);
    public bool get_CanUserResizeRows();
    public void set_CanUserResizeRows(bool value);
    public Thickness get_NewItemMargin();
    private void set_NewItemMargin(Thickness value);
    private void EnqueueNewItemMarginComputation();
    internal virtual void OnIsGroupingChanged(DependencyPropertyChangedEventArgs e);
    internal SelectedItemCollection get_SelectedItemCollection();
    public IList`1<DataGridCellInfo> get_SelectedCells();
    internal SelectedCellsCollection get_SelectedCellsInternal();
    [CompilerGeneratedAttribute]
public void add_SelectedCellsChanged(SelectedCellsChangedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_SelectedCellsChanged(SelectedCellsChangedEventHandler value);
    internal void OnSelectedCellsChanged(NotifyCollectionChangedAction action, VirtualizedCellInfoCollection oldItems, VirtualizedCellInfoCollection newItems);
    private void NotifySelectedCellsChanged();
    protected virtual void OnSelectedCellsChanged(SelectedCellsChangedEventArgs e);
    public static RoutedUICommand get_SelectAllCommand();
    private static void OnCanExecuteSelectAll(object sender, CanExecuteRoutedEventArgs e);
    private static void OnExecutedSelectAll(object sender, ExecutedRoutedEventArgs e);
    internal virtual void SelectAllImpl();
    internal void SelectOnlyThisCell(DataGridCellInfo currentCellInfo);
    public void SelectAllCells();
    public void UnselectAllCells();
    public DataGridSelectionMode get_SelectionMode();
    public void set_SelectionMode(DataGridSelectionMode value);
    private static void OnSelectionModeChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public DataGridSelectionUnit get_SelectionUnit();
    public void set_SelectionUnit(DataGridSelectionUnit value);
    private static void OnSelectionUnitChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    protected virtual void OnSelectionChanged(SelectionChangedEventArgs e);
    private void UpdateIsSelected();
    private void UpdateIsSelected(VirtualizedCellInfoCollection cells, bool isSelected);
    private void UpdateSelectionOfCellsInRow(ItemInfo rowInfo, bool isSelected);
    private void EnsurePendingInfos();
    internal void CellIsSelectedChanged(DataGridCell cell, bool isSelected);
    internal void HandleSelectionForCellInput(DataGridCell cell, bool startDragging, bool allowsExtendSelect, bool allowsMinimalSelect);
    internal void HandleSelectionForRowHeaderAndDetailsInput(DataGridRow row, bool startDragging);
    private void BeginRowDragging();
    private void BeginDragging();
    private void EndDragging();
    private void MakeFullRowSelection(ItemInfo info, bool allowsExtendSelect, bool allowsMinimalSelect);
    private void MakeCellSelection(DataGridCellInfo cellInfo, bool allowsExtendSelect, bool allowsMinimalSelect);
    private void SelectItem(ItemInfo info);
    private void SelectItem(ItemInfo info, bool selectCells);
    private void UnselectItem(ItemInfo info);
    private void UpdateSelectedItems(ItemInfo info, bool add);
    private IDisposable UpdateSelectedCells();
    private void BeginUpdateSelectedCells();
    private void EndUpdateSelectedCells();
    private bool get_IsUpdatingSelectedCells();
    private bool get_ShouldExtendSelection();
    private static bool get_ShouldMinimallyModifySelection();
    private bool get_CanSelectRows();
    private void OnItemsCollectionChanged(object sender, NotifyCollectionChangedEventArgs e);
    private static void OnIsEnabledChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void OnIsKeyboardFocusWithinChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    protected virtual void OnTextInput(TextCompositionEventArgs e);
    internal virtual bool FocusItem(ItemInfo info, ItemNavigateArgs itemNavigateArgs);
    protected virtual void OnKeyDown(KeyEventArgs e);
    private static FocusNavigationDirection KeyToTraversalDirection(Key key);
    private void OnArrowKeyDown(KeyEventArgs e);
    private bool TryDefaultNavigation(KeyEventArgs e, ItemInfo currentInfo);
    private void OnTabKeyDown(KeyEventArgs e);
    private void OnEnterKeyDown(KeyEventArgs e);
    private DataGridCell GetCellForSelectAndEditOnFocusMove();
    private void SelectAndEditOnFocusMove(KeyEventArgs e, DataGridCell oldCell, bool wasEditing, bool allowsExtendSelect, bool ignoreControlKey);
    private void OnHomeOrEndKeyDown(KeyEventArgs e);
    private void OnPageUpOrDownKeyDown(KeyEventArgs e);
    protected virtual void OnMouseMove(MouseEventArgs e);
    private static void OnAnyMouseUpThunk(object sender, MouseButtonEventArgs e);
    private void OnAnyMouseUp(MouseButtonEventArgs e);
    protected virtual void OnContextMenuOpening(ContextMenuEventArgs e);
    private DataGridRow GetRowNearMouse();
    private DataGridCell GetCellNearMouse();
    private static bool CalculateCellDistance(FrameworkElement cell, DataGridRow rowOwner, Panel itemsHost, Rect itemsHostBounds, bool isMouseInCorner, Double& distance);
    private DataGridRow get_MouseOverRow();
    private DataGridCell get_MouseOverCell();
    private RelativeMousePositions get_RelativeMousePosition();
    private static bool IsMouseToLeft(RelativeMousePositions position);
    private static bool IsMouseToRight(RelativeMousePositions position);
    private static bool IsMouseAbove(RelativeMousePositions position);
    private static bool IsMouseBelow(RelativeMousePositions position);
    private static bool IsMouseToLeftOrRightOnly(RelativeMousePositions position);
    private static bool IsMouseInCorner(RelativeMousePositions position);
    protected virtual AutomationPeer OnCreateAutomationPeer();
    private CellAutomationValueHolder GetCellAutomationValueHolder(object item, DataGridColumn column);
    internal string GetCellAutomationValue(object item, DataGridColumn column);
    internal object GetCellClipboardValue(object item, DataGridColumn column);
    internal void SetCellAutomationValue(object item, DataGridColumn column, string value);
    internal void SetCellClipboardValue(object item, DataGridColumn column, object value);
    private void SetCellValue(object item, DataGridColumn column, object value, bool clipboard);
    private void EnsureCellAutomationValueHolder(DataGridCell cell);
    private void UpdateCellAutomationValueHolder(DataGridCell cell);
    private void ReleaseCellAutomationValueHolders();
    internal DataGridCell TryFindCell(DataGridCellInfo info);
    internal DataGridCell TryFindCell(ItemInfo info, DataGridColumn column);
    internal DataGridCell TryFindCell(object item, DataGridColumn column);
    public bool get_CanUserSortColumns();
    public void set_CanUserSortColumns(bool value);
    private static object OnCoerceCanUserSortColumns(DependencyObject d, object baseValue);
    private static void OnCanUserSortColumnsPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    [CompilerGeneratedAttribute]
public void add_Sorting(DataGridSortingEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_Sorting(DataGridSortingEventHandler value);
    protected virtual void OnSorting(DataGridSortingEventArgs eventArgs);
    internal void PerformSort(DataGridColumn sortColumn);
    private void PrepareForSort(DataGridColumn sortColumn);
    private void DefaultSort(DataGridColumn column, bool clearExistingSortDescriptions);
    private List`1<int> get_GroupingSortDescriptionIndices();
    private void set_GroupingSortDescriptionIndices(List`1<int> value);
    private void OnItemsSortDescriptionsChanged(object sender, NotifyCollectionChangedEventArgs e);
    private void RemoveGroupingSortDescriptions();
    private static bool CanConvertToSortDescription(PropertyGroupDescription propertyGroupDescription);
    private void AddGroupingSortDescriptions();
    private void RegenerateGroupingSortDescriptions();
    private void OnItemsGroupDescriptionsChanged(object sender, NotifyCollectionChangedEventArgs e);
    [CompilerGeneratedAttribute]
public void add_AutoGeneratedColumns(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_AutoGeneratedColumns(EventHandler value);
    [CompilerGeneratedAttribute]
public void add_AutoGeneratingColumn(EventHandler`1<DataGridAutoGeneratingColumnEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_AutoGeneratingColumn(EventHandler`1<DataGridAutoGeneratingColumnEventArgs> value);
    public bool get_AutoGenerateColumns();
    public void set_AutoGenerateColumns(bool value);
    protected virtual void OnAutoGeneratedColumns(EventArgs e);
    protected virtual void OnAutoGeneratingColumn(DataGridAutoGeneratingColumnEventArgs e);
    protected virtual Size MeasureOverride(Size availableSize);
    private void EnsureItemBindingGroup();
    private void ClearSortDescriptionsOnItemsSourceChange();
    private static object OnCoerceItemsSourceProperty(DependencyObject d, object baseValue);
    protected virtual void OnItemsSourceChanged(IEnumerable oldValue, IEnumerable newValue);
    [CompilerGeneratedAttribute]
private bool get_DeferAutoGeneration();
    [CompilerGeneratedAttribute]
private void set_DeferAutoGeneration(bool value);
    protected virtual void OnItemsChanged(NotifyCollectionChangedEventArgs e);
    internal virtual void AdjustItemInfoOverride(NotifyCollectionChangedEventArgs e);
    internal virtual void AdjustItemInfosAfterGeneratorChangeOverride();
    private static bool CellInfoNeedsAdjusting(DataGridCellInfo cellInfo);
    private void AdjustPendingInfos();
    private void AddAutoColumns();
    private void DeleteAutoColumns();
    private void RegenerateAutoColumns();
    public static Collection`1<DataGridColumn> GenerateColumns(IItemProperties itemProperties);
    private static void GenerateColumns(ReadOnlyCollection`1<ItemPropertyInfo> itemProperties, DataGrid dataGrid, Collection`1<DataGridColumn> columnCollection);
    private static void OnAutoGenerateColumnsPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public int get_FrozenColumnCount();
    public void set_FrozenColumnCount(int value);
    private static object OnCoerceFrozenColumnCount(DependencyObject d, object baseValue);
    private static void OnFrozenColumnCountPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static bool ValidateFrozenColumnCount(object value);
    public double get_NonFrozenColumnsViewportHorizontalOffset();
    internal void set_NonFrozenColumnsViewportHorizontalOffset(double value);
    public virtual void OnApplyTemplate();
    public bool get_EnableRowVirtualization();
    public void set_EnableRowVirtualization(bool value);
    private static void OnEnableRowVirtualizationChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static object OnCoerceIsVirtualizingProperty(DependencyObject d, object baseValue);
    public bool get_EnableColumnVirtualization();
    public void set_EnableColumnVirtualization(bool value);
    private static void OnEnableColumnVirtualizationChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public bool get_CanUserReorderColumns();
    public void set_CanUserReorderColumns(bool value);
    public Style get_DragIndicatorStyle();
    public void set_DragIndicatorStyle(Style value);
    public Style get_DropLocationIndicatorStyle();
    public void set_DropLocationIndicatorStyle(Style value);
    [CompilerGeneratedAttribute]
public void add_ColumnReordering(EventHandler`1<DataGridColumnReorderingEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_ColumnReordering(EventHandler`1<DataGridColumnReorderingEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_ColumnHeaderDragStarted(EventHandler`1<DragStartedEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_ColumnHeaderDragStarted(EventHandler`1<DragStartedEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_ColumnHeaderDragDelta(EventHandler`1<DragDeltaEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_ColumnHeaderDragDelta(EventHandler`1<DragDeltaEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_ColumnHeaderDragCompleted(EventHandler`1<DragCompletedEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_ColumnHeaderDragCompleted(EventHandler`1<DragCompletedEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_ColumnReordered(EventHandler`1<DataGridColumnEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_ColumnReordered(EventHandler`1<DataGridColumnEventArgs> value);
    protected internal virtual void OnColumnHeaderDragStarted(DragStartedEventArgs e);
    protected internal virtual void OnColumnReordering(DataGridColumnReorderingEventArgs e);
    protected internal virtual void OnColumnHeaderDragDelta(DragDeltaEventArgs e);
    protected internal virtual void OnColumnHeaderDragCompleted(DragCompletedEventArgs e);
    protected internal virtual void OnColumnReordered(DataGridColumnEventArgs e);
    private static void OnClipboardCopyModeChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public DataGridClipboardCopyMode get_ClipboardCopyMode();
    public void set_ClipboardCopyMode(DataGridClipboardCopyMode value);
    private static void OnCanExecuteCopy(object target, CanExecuteRoutedEventArgs args);
    protected virtual void OnCanExecuteCopy(CanExecuteRoutedEventArgs args);
    private static void OnExecutedCopy(object target, ExecutedRoutedEventArgs args);
    protected virtual void OnExecutedCopy(ExecutedRoutedEventArgs args);
    protected virtual void OnCopyingRowClipboardContent(DataGridRowClipboardEventArgs args);
    [CompilerGeneratedAttribute]
public void add_CopyingRowClipboardContent(EventHandler`1<DataGridRowClipboardEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_CopyingRowClipboardContent(EventHandler`1<DataGridRowClipboardEventArgs> value);
    internal double get_CellsPanelActualWidth();
    internal void set_CellsPanelActualWidth(double value);
    private static void CellsPanelActualWidthChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public double get_CellsPanelHorizontalOffset();
    private void set_CellsPanelHorizontalOffset(double value);
    [CompilerGeneratedAttribute]
private bool get_CellsPanelHorizontalOffsetComputationPending();
    [CompilerGeneratedAttribute]
private void set_CellsPanelHorizontalOffsetComputationPending(bool value);
    internal void QueueInvalidateCellsPanelHorizontalOffset();
    private object InvalidateCellsPanelHorizontalOffset(object args);
    internal IProvideDataGridColumn GetAnyCellOrColumnHeader();
    internal double GetViewportWidthForColumns();
    internal virtual void ChangeVisualState(bool useTransitions);
    internal static object get_NewItemPlaceholder();
    [CompilerGeneratedAttribute]
private void <EnqueueNewItemMarginComputation>b__402_0();
}
public class System.Windows.Controls.DataGridAutoGeneratingColumnEventArgs : EventArgs {
    private DataGridColumn _column;
    private string _propertyName;
    private Type _propertyType;
    private object _propertyDescriptor;
    private bool _cancel;
    public DataGridColumn Column { get; public set; }
    public string PropertyName { get; }
    public Type PropertyType { get; }
    public object PropertyDescriptor { get; private set; }
    public bool Cancel { get; public set; }
    public DataGridAutoGeneratingColumnEventArgs(string propertyName, Type propertyType, DataGridColumn column);
    internal DataGridAutoGeneratingColumnEventArgs(DataGridColumn column, ItemPropertyInfo itemPropertyInfo);
    internal DataGridAutoGeneratingColumnEventArgs(DataGridColumn column, string propertyName, Type propertyType, object propertyDescriptor);
    public DataGridColumn get_Column();
    public void set_Column(DataGridColumn value);
    public string get_PropertyName();
    public Type get_PropertyType();
    public object get_PropertyDescriptor();
    private void set_PropertyDescriptor(object value);
    public bool get_Cancel();
    public void set_Cancel(bool value);
}
public class System.Windows.Controls.DataGridBeginningEditEventArgs : EventArgs {
    private bool _cancel;
    private DataGridColumn _dataGridColumn;
    private DataGridRow _dataGridRow;
    private RoutedEventArgs _editingEventArgs;
    public bool Cancel { get; public set; }
    public DataGridColumn Column { get; }
    public DataGridRow Row { get; }
    public RoutedEventArgs EditingEventArgs { get; }
    public DataGridBeginningEditEventArgs(DataGridColumn column, DataGridRow row, RoutedEventArgs editingEventArgs);
    public bool get_Cancel();
    public void set_Cancel(bool value);
    public DataGridColumn get_Column();
    public DataGridRow get_Row();
    public RoutedEventArgs get_EditingEventArgs();
}
public abstract class System.Windows.Controls.DataGridBoundColumn : DataGridColumn {
    public static DependencyProperty ElementStyleProperty;
    public static DependencyProperty EditingElementStyleProperty;
    private BindingBase _binding;
    public BindingBase Binding { get; public set; }
    public Style ElementStyle { get; public set; }
    public Style EditingElementStyle { get; public set; }
    public BindingBase ClipboardContentBinding { get; public set; }
    private static DataGridBoundColumn();
    private static object OnCoerceSortMemberPath(DependencyObject d, object baseValue);
    public virtual BindingBase get_Binding();
    public virtual void set_Binding(BindingBase value);
    protected virtual bool OnCoerceIsReadOnly(bool baseValue);
    protected virtual void OnBindingChanged(BindingBase oldBinding, BindingBase newBinding);
    internal void ApplyBinding(DependencyObject target, DependencyProperty property);
    public Style get_ElementStyle();
    public void set_ElementStyle(Style value);
    public Style get_EditingElementStyle();
    public void set_EditingElementStyle(Style value);
    internal void ApplyStyle(bool isEditing, bool defaultToElementStyle, FrameworkElement element);
    private Style PickStyle(bool isEditing, bool defaultToElementStyle);
    public virtual BindingBase get_ClipboardContentBinding();
    public virtual void set_ClipboardContentBinding(BindingBase value);
    protected internal virtual void RefreshCellContent(FrameworkElement element, string propertyName);
}
public class System.Windows.Controls.DataGridCell : ContentControl {
    private static DependencyPropertyKey ColumnPropertyKey;
    public static DependencyProperty ColumnProperty;
    public static DependencyProperty IsEditingProperty;
    private static DependencyPropertyKey IsReadOnlyPropertyKey;
    public static DependencyProperty IsReadOnlyProperty;
    public static DependencyProperty IsSelectedProperty;
    public static RoutedEvent SelectedEvent;
    public static RoutedEvent UnselectedEvent;
    private DataGridRow _owner;
    private ContainerTracking`1<DataGridCell> _tracker;
    private bool _syncingIsSelected;
    internal ContainerTracking`1<DataGridCell> Tracker { get; }
    public DataGridColumn Column { get; internal set; }
    public bool IsEditing { get; public set; }
    private bool IsCurrent { get; }
    public bool IsReadOnly { get; }
    internal FrameworkElement EditingElement { get; }
    public bool IsSelected { get; public set; }
    internal DataGrid DataGridOwner { get; }
    private Panel ParentPanel { get; }
    internal DataGridRow RowOwner { get; }
    internal object RowDataItem { get; }
    private DataGridCellsPresenter CellsPresenter { get; }
    private bool NeedsVisualTree { get; }
    private static DataGridCell();
    protected virtual AutomationPeer OnCreateAutomationPeer();
    internal void PrepareCell(object item, ItemsControl cellsPresenter, DataGridRow ownerRow);
    internal void PrepareCell(object item, DataGridRow ownerRow, int index);
    internal void ClearCell(DataGridRow ownerRow);
    internal ContainerTracking`1<DataGridCell> get_Tracker();
    public sealed virtual DataGridColumn get_Column();
    internal void set_Column(DataGridColumn value);
    private static void OnColumnChanged(object sender, DependencyPropertyChangedEventArgs e);
    protected virtual void OnColumnChanged(DataGridColumn oldColumn, DataGridColumn newColumn);
    private static void OnNotifyPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void OnNotifyIsReadOnlyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    internal void NotifyPropertyChanged(DependencyObject d, string propertyName, DependencyPropertyChangedEventArgs e, DataGridNotificationTarget target);
    private static object OnCoerceStyle(DependencyObject d, object baseValue);
    internal virtual void ChangeVisualState(bool useTransitions);
    internal void BuildVisualTree();
    private void RemoveBindingExpressions(BindingGroup bindingGroup, DependencyObject element);
    public bool get_IsEditing();
    public void set_IsEditing(bool value);
    private static void OnIsEditingChanged(object sender, DependencyPropertyChangedEventArgs e);
    protected virtual void OnIsEditingChanged(bool isEditing);
    internal void NotifyCurrentCellContainerChanged();
    private bool get_IsCurrent();
    public bool get_IsReadOnly();
    private static object OnCoerceIsReadOnly(DependencyObject d, object baseValue);
    private static void OnAnyLostFocus(object sender, RoutedEventArgs e);
    private static void OnAnyGotFocus(object sender, RoutedEventArgs e);
    internal void BeginEdit(RoutedEventArgs e);
    internal void CancelEdit();
    internal bool CommitEdit();
    private void RaisePreparingCellForEdit(RoutedEventArgs editingEventArgs);
    internal FrameworkElement get_EditingElement();
    public bool get_IsSelected();
    public void set_IsSelected(bool value);
    private static void OnIsSelectedChanged(object sender, DependencyPropertyChangedEventArgs e);
    internal void SyncIsSelected(bool isSelected);
    private void RaiseSelectionChangedEvent(bool isSelected);
    public void add_Selected(RoutedEventHandler value);
    public void remove_Selected(RoutedEventHandler value);
    protected virtual void OnSelected(RoutedEventArgs e);
    public void add_Unselected(RoutedEventHandler value);
    public void remove_Unselected(RoutedEventHandler value);
    protected virtual void OnUnselected(RoutedEventArgs e);
    protected virtual Size MeasureOverride(Size constraint);
    protected virtual Size ArrangeOverride(Size arrangeSize);
    protected virtual void OnRender(DrawingContext drawingContext);
    private static void OnAnyMouseLeftButtonDownThunk(object sender, MouseButtonEventArgs e);
    private void OnAnyMouseLeftButtonDown(MouseButtonEventArgs e);
    protected virtual void OnTextInput(TextCompositionEventArgs e);
    protected virtual void OnPreviewKeyDown(KeyEventArgs e);
    protected virtual void OnKeyDown(KeyEventArgs e);
    private void SendInputToColumn(InputEventArgs e);
    private static object OnCoerceClip(DependencyObject d, object baseValue);
    internal DataGrid get_DataGridOwner();
    private Panel get_ParentPanel();
    internal DataGridRow get_RowOwner();
    internal object get_RowDataItem();
    private DataGridCellsPresenter get_CellsPresenter();
    private bool get_NeedsVisualTree();
}
public class System.Windows.Controls.DataGridCellClipboardEventArgs : EventArgs {
    private object _content;
    private object _item;
    private DataGridColumn _column;
    public object Content { get; public set; }
    public object Item { get; }
    public DataGridColumn Column { get; }
    public DataGridCellClipboardEventArgs(object item, DataGridColumn column, object content);
    public object get_Content();
    public void set_Content(object value);
    public object get_Item();
    public DataGridColumn get_Column();
}
public class System.Windows.Controls.DataGridCellEditEndingEventArgs : EventArgs {
    private bool _cancel;
    private DataGridColumn _dataGridColumn;
    private DataGridRow _dataGridRow;
    private FrameworkElement _editingElement;
    private DataGridEditAction _editAction;
    public bool Cancel { get; public set; }
    public DataGridColumn Column { get; }
    public DataGridRow Row { get; }
    public FrameworkElement EditingElement { get; }
    public DataGridEditAction EditAction { get; }
    public DataGridCellEditEndingEventArgs(DataGridColumn column, DataGridRow row, FrameworkElement editingElement, DataGridEditAction editAction);
    public bool get_Cancel();
    public void set_Cancel(bool value);
    public DataGridColumn get_Column();
    public DataGridRow get_Row();
    public FrameworkElement get_EditingElement();
    public DataGridEditAction get_EditAction();
}
public class System.Windows.Controls.DataGridCellInfo : ValueType {
    private ItemInfo _info;
    private DataGridColumn _column;
    private WeakReference _owner;
    public object Item { get; }
    public DataGridColumn Column { get; }
    public bool IsValid { get; }
    internal bool IsSet { get; }
    internal ItemInfo ItemInfo { get; }
    private bool ArePropertyValuesValid { get; }
    internal static DataGridCellInfo Unset { get; }
    private DataGrid Owner { get; }
    public DataGridCellInfo(object item, DataGridColumn column);
    public DataGridCellInfo(DataGridCell cell);
    internal DataGridCellInfo(object item, DataGridColumn column, DataGrid owner);
    internal DataGridCellInfo(ItemInfo info, DataGridColumn column, DataGrid owner);
    internal DataGridCellInfo(object item);
    internal DataGridCellInfo(DataGridCellInfo info);
    private DataGridCellInfo(DataGrid owner, DataGridColumn column, object item);
    internal static DataGridCellInfo CreatePossiblyPartialCellInfo(object item, DataGridColumn column, DataGrid owner);
    public object get_Item();
    public DataGridColumn get_Column();
    public virtual bool Equals(object obj);
    public static bool op_Equality(DataGridCellInfo cell1, DataGridCellInfo cell2);
    public static bool op_Inequality(DataGridCellInfo cell1, DataGridCellInfo cell2);
    internal bool EqualsImpl(DataGridCellInfo cell);
    public virtual int GetHashCode();
    public bool get_IsValid();
    internal bool get_IsSet();
    internal ItemInfo get_ItemInfo();
    internal bool IsValidForDataGrid(DataGrid dataGrid);
    private bool get_ArePropertyValuesValid();
    internal static DataGridCellInfo get_Unset();
    private DataGrid get_Owner();
}
public class System.Windows.Controls.DataGridCellsPanel : VirtualizingPanel {
    [CompilerGeneratedAttribute]
private bool <IsVirtualizing>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <InRecyclingMode>k__BackingField;
    private DataGrid _parentDataGrid;
    private UIElement _clippedChildForFrozenBehaviour;
    private RectangleGeometry _childClipForFrozenBehavior;
    private List`1<UIElement> _realizedChildren;
    internal bool HasCorrectRealizedColumns { get; }
    private bool RebuildRealizedColumnsBlockList { get; private set; }
    private List`1<RealizedColumnsBlock> RealizedColumnsBlockList { get; private set; }
    private List`1<RealizedColumnsBlock> RealizedColumnsDisplayIndexBlockList { get; private set; }
    private DataGridRowsPresenter ParentRowsPresenter { get; }
    private bool IsVirtualizing { get; private set; }
    private bool InRecyclingMode { get; private set; }
    private IList RealizedChildren { get; }
    private ObservableCollection`1<DataGridColumn> Columns { get; }
    private DataGrid ParentDataGrid { get; }
    private ItemsControl ParentPresenter { get; }
    private static DataGridCellsPanel();
    protected virtual Size MeasureOverride(Size constraint);
    private static void MeasureChild(UIElement child, Size constraint);
    private Size GenerateAndMeasureChildrenForRealizedColumns(Size constraint);
    private Size DetermineRealizedColumnsBlockList(Size constraint);
    private void UpdateRealizedBlockLists(List`1<int> realizedColumnIndices, List`1<int> realizedColumnDisplayIndices, bool redeterminationNeeded);
    private static List`1<RealizedColumnsBlock> BuildRealizedColumnsBlockList(List`1<int> indexList);
    private static GeneratorPosition IndexToGeneratorPositionForStart(IItemContainerGenerator generator, int index, Int32& childIndex);
    private UIElement GenerateChild(IItemContainerGenerator generator, Size constraint, DataGridColumn column, IDisposable& generatorState, Int32& childIndex, Size& childSize);
    private UIElement GenerateChild(IItemContainerGenerator generator, Size constraint, DataGridColumn column, Int32& childIndex, Size& childSize);
    private Size GenerateChildren(IItemContainerGenerator generator, int startIndex, int endIndex, Size constraint);
    private void AddContainerFromGenerator(int childIndex, UIElement child, bool newlyRealized);
    private void InsertRecycledContainer(int childIndex, UIElement container);
    private void InsertNewContainer(int childIndex, UIElement container);
    private void InsertContainer(int childIndex, UIElement container, bool isRecycled);
    private int ChildIndexFromRealizedIndex(int realizedChildIndex);
    private static bool InBlockOrNextBlock(List`1<RealizedColumnsBlock> blockList, int index, Int32& blockIndex, RealizedColumnsBlock& block, Boolean& pastLastBlock);
    private Size EnsureAtleastOneHeader(IItemContainerGenerator generator, Size constraint, List`1<int> realizedColumnIndices, List`1<int> realizedColumnDisplayIndices);
    private void EnsureFocusTrail(List`1<int> realizedColumnIndices, List`1<int> realizedColumnDisplayIndices, int firstVisibleNonFrozenDisplayIndex, int lastVisibleNonFrozenDisplayIndex, Size constraint);
    private bool GenerateChildForFocusTrail(ItemContainerGenerator generator, List`1<int> realizedColumnIndices, List`1<int> realizedColumnDisplayIndices, Size constraint, int displayIndex, Int32& displayIndexListIterator);
    private static void AddToIndicesListIfNeeded(List`1<int> realizedColumnIndices, List`1<int> realizedColumnDisplayIndices, int columnIndex, int displayIndex, Int32& displayIndexListIterator);
    private void VirtualizeChildren(List`1<RealizedColumnsBlock> blockList, IItemContainerGenerator generator);
    private void CleanupRange(IList children, IItemContainerGenerator generator, int startIndex, int count);
    private void DisconnectRecycledContainers();
    private void InitializeArrangeState(ArrangeState arrangeState);
    private void FinishArrange(ArrangeState arrangeState);
    private void SetDataGridCellPanelWidth(IList children, double newWidth);
    [ConditionalAttribute("DEBUG")]
private static void Debug_VerifyRealizedIndexCountVsDisplayIndexCount(List`1<RealizedColumnsBlock> blockList, List`1<RealizedColumnsBlock> displayIndexBlockList);
    protected virtual Size ArrangeOverride(Size arrangeSize);
    private void ArrangeChild(UIElement child, int displayIndex, ArrangeState arrangeState);
    private static RealizedColumnsBlock GetRealizedBlockForColumn(List`1<RealizedColumnsBlock> blockList, int columnIndex);
    private List`1<int> GetRealizedChildrenNotInBlockList(List`1<RealizedColumnsBlock> blockList, IList children);
    internal bool get_HasCorrectRealizedColumns();
    private bool get_RebuildRealizedColumnsBlockList();
    private void set_RebuildRealizedColumnsBlockList(bool value);
    private List`1<RealizedColumnsBlock> get_RealizedColumnsBlockList();
    private void set_RealizedColumnsBlockList(List`1<RealizedColumnsBlock> value);
    private List`1<RealizedColumnsBlock> get_RealizedColumnsDisplayIndexBlockList();
    private void set_RealizedColumnsDisplayIndexBlockList(List`1<RealizedColumnsBlock> value);
    protected virtual void OnIsItemsHostChanged(bool oldIsItemsHost, bool newIsItemsHost);
    private DataGridRowsPresenter get_ParentRowsPresenter();
    private void DetermineVirtualizationState();
    [CompilerGeneratedAttribute]
private bool get_IsVirtualizing();
    [CompilerGeneratedAttribute]
private void set_IsVirtualizing(bool value);
    [CompilerGeneratedAttribute]
private bool get_InRecyclingMode();
    [CompilerGeneratedAttribute]
private void set_InRecyclingMode(bool value);
    private static double GetColumnEstimatedMeasureWidth(DataGridColumn column, double averageColumnWidth);
    private double GetColumnEstimatedMeasureWidthSum(int startIndex, int endIndex, double averageColumnWidth);
    private IList get_RealizedChildren();
    private void EnsureRealizedChildren();
    internal double ComputeCellsPanelHorizontalOffset();
    private double GetViewportWidth();
    protected virtual void OnItemsChanged(object sender, ItemsChangedEventArgs args);
    private void OnItemsRemove(ItemsChangedEventArgs args);
    private void OnItemsReplace(ItemsChangedEventArgs args);
    private void OnItemsMove(ItemsChangedEventArgs args);
    private void RemoveChildRange(GeneratorPosition position, int itemCount, int itemUICount);
    protected virtual void OnClearChildren();
    internal void InternalBringIndexIntoView(int index);
    protected internal virtual void BringIndexIntoView(int index);
    private void RetryBringIndexIntoView(int index);
    private bool IsChildInView(int index, Double& newHorizontalOffset);
    internal Geometry GetFrozenClipForChild(UIElement child);
    private ObservableCollection`1<DataGridColumn> get_Columns();
    private DataGrid get_ParentDataGrid();
    private ItemsControl get_ParentPresenter();
}
public class System.Windows.Controls.DataGridCheckBoxColumn : DataGridBoundColumn {
    public static DependencyProperty IsThreeStateProperty;
    private static Style _defaultElementStyle;
    private static Style _defaultEditingElementStyle;
    public static Style DefaultElementStyle { get; }
    public static Style DefaultEditingElementStyle { get; }
    public bool IsThreeState { get; public set; }
    private static DataGridCheckBoxColumn();
    public static Style get_DefaultElementStyle();
    public static Style get_DefaultEditingElementStyle();
    protected virtual FrameworkElement GenerateElement(DataGridCell cell, object dataItem);
    protected virtual FrameworkElement GenerateEditingElement(DataGridCell cell, object dataItem);
    private CheckBox GenerateCheckBox(bool isEditing, DataGridCell cell);
    protected internal virtual void RefreshCellContent(FrameworkElement element, string propertyName);
    public bool get_IsThreeState();
    public void set_IsThreeState(bool value);
    protected virtual object PrepareCellForEdit(FrameworkElement editingElement, RoutedEventArgs editingEventArgs);
    internal virtual void OnInput(InputEventArgs e);
    private static bool IsMouseLeftButtonDown(RoutedEventArgs e);
    private static bool IsMouseOver(CheckBox checkBox, RoutedEventArgs e);
    private static bool IsSpaceKeyDown(RoutedEventArgs e);
}
public class System.Windows.Controls.DataGridClipboardCellContent : ValueType {
    private object _item;
    private DataGridColumn _column;
    private object _content;
    public object Item { get; }
    public DataGridColumn Column { get; }
    public object Content { get; }
    public DataGridClipboardCellContent(object item, DataGridColumn column, object content);
    public object get_Item();
    public DataGridColumn get_Column();
    public object get_Content();
    public virtual bool Equals(object data);
    public virtual int GetHashCode();
    public static bool op_Equality(DataGridClipboardCellContent clipboardCellContent1, DataGridClipboardCellContent clipboardCellContent2);
    public static bool op_Inequality(DataGridClipboardCellContent clipboardCellContent1, DataGridClipboardCellContent clipboardCellContent2);
}
public enum System.Windows.Controls.DataGridClipboardCopyMode : Enum {
    public int value__;
    public static DataGridClipboardCopyMode None;
    public static DataGridClipboardCopyMode ExcludeHeader;
    public static DataGridClipboardCopyMode IncludeHeader;
}
internal static class System.Windows.Controls.DataGridClipboardHelper : object {
    private static string DATAGRIDVIEW_htmlPrefix;
    private static string DATAGRIDVIEW_htmlStartFragment;
    private static string DATAGRIDVIEW_htmlEndFragment;
    internal static void FormatCell(object cellValue, bool firstCell, bool lastCell, StringBuilder sb, string format);
    internal static void GetClipboardContentForHtml(StringBuilder content);
    private static void FormatPlainText(string s, bool csv, TextWriter output, Boolean& escapeApplied);
    private static void FormatPlainTextAsHtml(string s, TextWriter output);
}
public abstract class System.Windows.Controls.DataGridColumn : DependencyObject {
    public static DependencyProperty HeaderProperty;
    public static DependencyProperty HeaderStyleProperty;
    public static DependencyProperty HeaderStringFormatProperty;
    public static DependencyProperty HeaderTemplateProperty;
    public static DependencyProperty HeaderTemplateSelectorProperty;
    public static DependencyProperty CellStyleProperty;
    public static DependencyProperty IsReadOnlyProperty;
    public static DependencyProperty WidthProperty;
    public static DependencyProperty MinWidthProperty;
    public static DependencyProperty MaxWidthProperty;
    private static DependencyPropertyKey ActualWidthPropertyKey;
    public static DependencyProperty ActualWidthProperty;
    private static DependencyProperty OriginalValueProperty;
    public static DependencyProperty DisplayIndexProperty;
    public static DependencyProperty SortMemberPathProperty;
    public static DependencyProperty CanUserSortProperty;
    public static DependencyProperty SortDirectionProperty;
    private static DependencyPropertyKey IsAutoGeneratedPropertyKey;
    public static DependencyProperty IsAutoGeneratedProperty;
    private static DependencyPropertyKey IsFrozenPropertyKey;
    public static DependencyProperty IsFrozenProperty;
    public static DependencyProperty CanUserReorderProperty;
    public static DependencyProperty DragIndicatorStyleProperty;
    [CompilerGeneratedAttribute]
private EventHandler`1<DataGridCellClipboardEventArgs> CopyingCellClipboardContent;
    [CompilerGeneratedAttribute]
private EventHandler`1<DataGridCellClipboardEventArgs> PastingCellClipboardContent;
    public static DependencyProperty CanUserResizeProperty;
    public static DependencyProperty VisibilityProperty;
    private DataGrid _dataGridOwner;
    private BindingBase _clipboardContentBinding;
    private bool _ignoreRedistributionOnWidthChange;
    private bool _processingWidthChange;
    private static double _starMaxWidth;
    public object Header { get; public set; }
    public Style HeaderStyle { get; public set; }
    public string HeaderStringFormat { get; public set; }
    public DataTemplate HeaderTemplate { get; public set; }
    public DataTemplateSelector HeaderTemplateSelector { get; public set; }
    public Style CellStyle { get; public set; }
    public bool IsReadOnly { get; public set; }
    public DataGridLength Width { get; public set; }
    public double MinWidth { get; public set; }
    public double MaxWidth { get; public set; }
    public double ActualWidth { get; private set; }
    protected internal DataGrid DataGridOwner { get; internal set; }
    public int DisplayIndex { get; public set; }
    public string SortMemberPath { get; public set; }
    public bool CanUserSort { get; public set; }
    public Nullable`1<ListSortDirection> SortDirection { get; public set; }
    public bool IsAutoGenerated { get; internal set; }
    public bool IsFrozen { get; internal set; }
    public bool CanUserReorder { get; public set; }
    public Style DragIndicatorStyle { get; public set; }
    public BindingBase ClipboardContentBinding { get; public set; }
    public bool CanUserResize { get; public set; }
    public Visibility Visibility { get; public set; }
    internal bool IsVisible { get; }
    private static DataGridColumn();
    public object get_Header();
    public void set_Header(object value);
    public Style get_HeaderStyle();
    public void set_HeaderStyle(Style value);
    private static object OnCoerceHeaderStyle(DependencyObject d, object baseValue);
    public string get_HeaderStringFormat();
    public void set_HeaderStringFormat(string value);
    public DataTemplate get_HeaderTemplate();
    public void set_HeaderTemplate(DataTemplate value);
    public DataTemplateSelector get_HeaderTemplateSelector();
    public void set_HeaderTemplateSelector(DataTemplateSelector value);
    public Style get_CellStyle();
    public void set_CellStyle(Style value);
    private static object OnCoerceCellStyle(DependencyObject d, object baseValue);
    public bool get_IsReadOnly();
    public void set_IsReadOnly(bool value);
    private static object OnCoerceIsReadOnly(DependencyObject d, object baseValue);
    protected virtual bool OnCoerceIsReadOnly(bool baseValue);
    public DataGridLength get_Width();
    public void set_Width(DataGridLength value);
    internal void SetWidthInternal(DataGridLength width);
    private static void OnWidthPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public double get_MinWidth();
    public void set_MinWidth(double value);
    private static void OnMinWidthPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public double get_MaxWidth();
    public void set_MaxWidth(double value);
    private static void OnMaxWidthPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static double CoerceDesiredOrDisplayWidthValue(double widthValue, double memberValue, DataGridLengthUnitType type);
    private static object OnCoerceWidth(DependencyObject d, object baseValue);
    private static object OnCoerceMinWidth(DependencyObject d, object baseValue);
    private static object OnCoerceMaxWidth(DependencyObject d, object baseValue);
    private static bool ValidateMinWidth(object v);
    private static bool ValidateMaxWidth(object v);
    public double get_ActualWidth();
    private void set_ActualWidth(double value);
    private static object OnCoerceActualWidth(DependencyObject d, object baseValue);
    internal double GetConstraintWidth(bool isHeader);
    internal void UpdateDesiredWidthForAutoColumn(bool isHeader, double pixelWidth);
    internal void UpdateWidthForStarColumn(double displayWidth, double desiredWidth, double starValue);
    public FrameworkElement GetCellContent(object dataItem);
    public FrameworkElement GetCellContent(DataGridRow dataGridRow);
    internal FrameworkElement BuildVisualTree(bool isEditing, object dataItem, DataGridCell cell);
    protected abstract virtual FrameworkElement GenerateElement(DataGridCell cell, object dataItem);
    protected abstract virtual FrameworkElement GenerateEditingElement(DataGridCell cell, object dataItem);
    protected virtual object PrepareCellForEdit(FrameworkElement editingElement, RoutedEventArgs editingEventArgs);
    protected virtual void CancelCellEdit(FrameworkElement editingElement, object uneditedValue);
    protected virtual bool CommitCellEdit(FrameworkElement editingElement);
    internal void BeginEdit(FrameworkElement editingElement, RoutedEventArgs e);
    internal void CancelEdit(FrameworkElement editingElement);
    internal bool CommitEdit(FrameworkElement editingElement);
    private static object GetOriginalValue(DependencyObject obj);
    private static void SetOriginalValue(DependencyObject obj, object value);
    private static void ClearOriginalValue(DependencyObject obj);
    internal static void OnNotifyCellPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void OnNotifyColumnHeaderPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void OnNotifyColumnPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    internal void NotifyPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e, DataGridNotificationTarget target);
    protected void NotifyPropertyChanged(string propertyName);
    internal static void NotifyPropertyChangeForRefreshContent(DependencyObject d, DependencyPropertyChangedEventArgs e);
    protected internal virtual void RefreshCellContent(FrameworkElement element, string propertyName);
    internal void SyncProperties();
    protected internal DataGrid get_DataGridOwner();
    internal void set_DataGridOwner(DataGrid value);
    public int get_DisplayIndex();
    public void set_DisplayIndex(int value);
    private static object OnCoerceDisplayIndex(DependencyObject d, object baseValue);
    private static void DisplayIndexChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public string get_SortMemberPath();
    public void set_SortMemberPath(string value);
    public bool get_CanUserSort();
    public void set_CanUserSort(bool value);
    internal static object OnCoerceCanUserSort(DependencyObject d, object baseValue);
    private static void OnCanUserSortPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public Nullable`1<ListSortDirection> get_SortDirection();
    public void set_SortDirection(Nullable`1<ListSortDirection> value);
    private static void OnNotifySortPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public bool get_IsAutoGenerated();
    internal void set_IsAutoGenerated(bool value);
    internal static DataGridColumn CreateDefaultColumn(ItemPropertyInfo itemProperty);
    public bool get_IsFrozen();
    internal void set_IsFrozen(bool value);
    private static void OnNotifyFrozenPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static object OnCoerceIsFrozen(DependencyObject d, object baseValue);
    public bool get_CanUserReorder();
    public void set_CanUserReorder(bool value);
    private static object OnCoerceCanUserReorder(DependencyObject d, object baseValue);
    public Style get_DragIndicatorStyle();
    public void set_DragIndicatorStyle(Style value);
    private static object OnCoerceDragIndicatorStyle(DependencyObject d, object baseValue);
    public virtual BindingBase get_ClipboardContentBinding();
    public virtual void set_ClipboardContentBinding(BindingBase value);
    public virtual object OnCopyingCellClipboardContent(object item);
    public virtual void OnPastingCellClipboardContent(object item, object cellContent);
    [CompilerGeneratedAttribute]
public void add_CopyingCellClipboardContent(EventHandler`1<DataGridCellClipboardEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_CopyingCellClipboardContent(EventHandler`1<DataGridCellClipboardEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_PastingCellClipboardContent(EventHandler`1<DataGridCellClipboardEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_PastingCellClipboardContent(EventHandler`1<DataGridCellClipboardEventArgs> value);
    internal virtual void OnInput(InputEventArgs e);
    internal void BeginEdit(InputEventArgs e, bool handled);
    public bool get_CanUserResize();
    public void set_CanUserResize(bool value);
    private static object OnCoerceCanUserResize(DependencyObject d, object baseValue);
    public Visibility get_Visibility();
    public void set_Visibility(Visibility value);
    private static void OnVisibilityPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs eventArgs);
    internal bool get_IsVisible();
}
internal class System.Windows.Controls.DataGridColumnCollection : ObservableCollection`1<DataGridColumn> {
    [CompilerGeneratedAttribute]
private bool <RebuildRealizedColumnsBlockListForNonVirtualizedRows>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<RealizedColumnsBlock> <RealizedColumnsDisplayIndexBlockListForNonVirtualizedRows>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RebuildRealizedColumnsBlockListForVirtualizedRows>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<RealizedColumnsBlock> <RealizedColumnsDisplayIndexBlockListForVirtualizedRows>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RefreshAutoWidthColumns>k__BackingField;
    private DataGrid _dataGridOwner;
    private bool _isUpdatingDisplayIndex;
    private List`1<int> _displayIndexMap;
    private bool _displayIndexMapInitialized;
    private bool _isClearingDisplayIndex;
    private bool _columnWidthsComputationPending;
    private Dictionary`2<DataGridColumn, DataGridLength> _originalWidthsForResize;
    private Nullable`1<double> _averageColumnWidth;
    private List`1<RealizedColumnsBlock> _realizedColumnsBlockListForNonVirtualizedRows;
    private List`1<RealizedColumnsBlock> _realizedColumnsBlockListForVirtualizedRows;
    private bool _hasVisibleStarColumns;
    internal List`1<int> DisplayIndexMap { get; private set; }
    private bool IsUpdatingDisplayIndex { get; private set; }
    private DataGrid DataGridOwner { get; }
    internal bool DisplayIndexMapInitialized { get; }
    internal bool HasVisibleStarColumns { get; private set; }
    internal double AverageColumnWidth { get; }
    internal bool ColumnWidthsComputationPending { get; }
    internal bool RebuildRealizedColumnsBlockListForNonVirtualizedRows { get; internal set; }
    internal List`1<RealizedColumnsBlock> RealizedColumnsBlockListForNonVirtualizedRows { get; internal set; }
    internal List`1<RealizedColumnsBlock> RealizedColumnsDisplayIndexBlockListForNonVirtualizedRows { get; internal set; }
    internal bool RebuildRealizedColumnsBlockListForVirtualizedRows { get; internal set; }
    internal List`1<RealizedColumnsBlock> RealizedColumnsBlockListForVirtualizedRows { get; internal set; }
    internal List`1<RealizedColumnsBlock> RealizedColumnsDisplayIndexBlockListForVirtualizedRows { get; internal set; }
    internal int FirstVisibleDisplayIndex { get; }
    internal int LastVisibleDisplayIndex { get; }
    internal bool RefreshAutoWidthColumns { get; internal set; }
    internal DataGridColumnCollection(DataGrid dataGridOwner);
    protected virtual void InsertItem(int index, DataGridColumn item);
    protected virtual void SetItem(int index, DataGridColumn item);
    protected virtual void OnCollectionChanged(NotifyCollectionChangedEventArgs e);
    protected virtual void ClearItems();
    internal void NotifyPropertyChanged(DependencyObject d, string propertyName, DependencyPropertyChangedEventArgs e, DataGridNotificationTarget target);
    internal DataGridColumn ColumnFromDisplayIndex(int displayIndex);
    internal List`1<int> get_DisplayIndexMap();
    private void set_DisplayIndexMap(List`1<int> value);
    private bool get_IsUpdatingDisplayIndex();
    private void set_IsUpdatingDisplayIndex(bool value);
    private int CoerceDefaultDisplayIndex(DataGridColumn column);
    private int CoerceDefaultDisplayIndex(DataGridColumn column, int newDisplayIndex);
    private void OnColumnDisplayIndexChanged(DataGridColumn column, int oldDisplayIndex, int newDisplayIndex);
    private void UpdateDisplayIndexForChangedColumn(int oldDisplayIndex, int newDisplayIndex);
    private void UpdateDisplayIndexForMovedColumn(int oldColumnIndex, int newColumnIndex);
    private void UpdateDisplayIndexForNewColumns(IList newColumns, int startingIndex);
    internal void InitializeDisplayIndexMap();
    private void InitializeDisplayIndexMap(DataGridColumn changingColumn, int oldDisplayIndex, Int32& resultDisplayIndex);
    private void UpdateDisplayIndexForRemovedColumns(IList oldColumns, int startingIndex);
    private void UpdateDisplayIndexForReplacedColumn(IList oldColumns, IList newColumns);
    private void ClearDisplayIndex(IList oldColumns, IList newColumns);
    private bool IsDisplayIndexValid(DataGridColumn column, int displayIndex, bool isAdding);
    private void InsertInDisplayIndexMap(int newDisplayIndex, int columnIndex);
    private int RemoveFromDisplayIndexMap(int columnIndex);
    internal void ValidateDisplayIndex(DataGridColumn column, int displayIndex);
    internal void ValidateDisplayIndex(DataGridColumn column, int displayIndex, bool isAdding);
    [ConditionalAttribute("DEBUG")]
private void Debug_VerifyDisplayIndexMap();
    private void OnDataGridFrozenColumnCountChanged(int oldFrozenCount, int newFrozenCount);
    private DataGrid get_DataGridOwner();
    internal bool get_DisplayIndexMapInitialized();
    private bool HasVisibleStarColumnsInternal(DataGridColumn ignoredColumn, Double& perStarWidth);
    private bool HasVisibleStarColumnsInternal(Double& perStarWidth);
    private bool HasVisibleStarColumnsInternal(DataGridColumn ignoredColumn);
    internal bool get_HasVisibleStarColumns();
    private void set_HasVisibleStarColumns(bool value);
    internal void InvalidateHasVisibleStarColumns();
    private void RecomputeStarColumnWidths();
    private double ComputeStarColumnWidths(double availableStarSpace);
    private void OnCellsPanelHorizontalOffsetChanged(DependencyPropertyChangedEventArgs e);
    internal void InvalidateAverageColumnWidth();
    internal double get_AverageColumnWidth();
    private double ComputeAverageColumnWidth();
    internal bool get_ColumnWidthsComputationPending();
    internal void InvalidateColumnWidthsComputation();
    private object ComputeColumnWidths(object arg);
    private void ComputeColumnWidths();
    private void InitializeColumnDisplayValues();
    internal void RedistributeColumnWidthsOnMinWidthChangeOfColumn(DataGridColumn changedColumn, double oldMinWidth);
    internal void RedistributeColumnWidthsOnMaxWidthChangeOfColumn(DataGridColumn changedColumn, double oldMaxWidth);
    internal void RedistributeColumnWidthsOnWidthChangeOfColumn(DataGridColumn changedColumn, DataGridLength oldWidth);
    internal void RedistributeColumnWidthsOnAvailableSpaceChange(double availableSpaceChange, double newTotalAvailableSpace);
    private void ExpandAllColumnWidthsToDesiredValue();
    private void RedistributeColumnWidthsOnNonStarWidthChange(DataGridColumn changedColumn, DataGridLength oldWidth);
    private void DistributeSpaceAmongColumns(double availableSpace);
    private double DistributeSpaceAmongNonStarColumns(double availableSpace);
    internal void OnColumnResizeStarted();
    internal void OnColumnResizeCompleted(bool cancel);
    internal void RecomputeColumnWidthsOnColumnResize(DataGridColumn resizingColumn, double horizontalChange, bool retainAuto);
    private void RecomputeColumnWidthsOnColumnPositiveResize(double horizontalChange, int resizingColumnIndex, bool retainAuto);
    private double RecomputeStarColumnWidthsOnColumnPositiveResize(double horizontalChange, int resizingColumnIndex, double perStarWidth, bool retainAuto);
    private static bool CanColumnParticipateInResize(DataGridColumn column);
    private double GetStarFactorsForPositiveResize(int startIndex, Double& minPerStarExcessRatio);
    private double ReallocateStarValuesForPositiveResize(int startIndex, double horizontalChange, double perStarExcessRatio, double totalStarFactors, double perStarWidth, bool retainAuto);
    private double RecomputeNonStarColumnWidthsOnColumnPositiveResize(double horizontalChange, int resizingColumnIndex, bool retainAuto, bool onlyShrinkToDesiredWidth);
    private void RecomputeColumnWidthsOnColumnNegativeResize(double horizontalChange, int resizingColumnIndex, bool retainAuto);
    private double RecomputeNonStarColumnWidthsOnColumnNegativeResize(double horizontalChange, int resizingColumnIndex, bool retainAuto, bool expandBeyondDesiredWidth);
    private double RecomputeStarColumnWidthsOnColumnNegativeResize(double horizontalChange, int resizingColumnIndex, double perStarWidth, bool retainAuto);
    private double GetStarFactorsForNegativeResize(int startIndex, Double& minPerStarLagRatio);
    private double ReallocateStarValuesForNegativeResize(int startIndex, double horizontalChange, double perStarLagRatio, double totalStarFactors, double perStarWidth, bool retainAuto);
    private static void SetResizedColumnWidth(DataGridColumn column, double widthDelta, bool retainAuto);
    private double GiveAwayWidthToColumns(DataGridColumn ignoredColumn, double giveAwayWidth);
    private double GiveAwayWidthToColumns(DataGridColumn ignoredColumn, double giveAwayWidth, bool recomputeStars);
    private double GiveAwayWidthToNonStarColumns(DataGridColumn ignoredColumn, double giveAwayWidth);
    private double FindMinimumLaggingWidthOfNonStarColumns(DataGridColumn ignoredColumn, Int32& countOfParticipatingColumns);
    private void GiveAwayWidthToEveryNonStarColumn(DataGridColumn ignoredColumn, double perColumnGiveAwayWidth);
    private double GiveAwayWidthToScrollViewerExcess(double giveAwayWidth, bool includedInColumnsWidth);
    private double TakeAwayUnusedSpaceOnColumnPositiveResize(double horizontalChange, int resizingColumnIndex, bool retainAuto);
    private double TakeAwayWidthFromUnusedSpace(bool spaceAlreadyUtilized, double takeAwayWidth, double totalAvailableWidth);
    private double TakeAwayWidthFromUnusedSpace(bool spaceAlreadyUtilized, double takeAwayWidth);
    private double TakeAwayWidthFromColumns(DataGridColumn ignoredColumn, double takeAwayWidth, bool widthAlreadyUtilized);
    private double TakeAwayWidthFromColumns(DataGridColumn ignoredColumn, double takeAwayWidth, bool widthAlreadyUtilized, double totalAvailableWidth);
    private double TakeAwayWidthFromStarColumns(DataGridColumn ignoredColumn, double takeAwayWidth);
    private double TakeAwayWidthFromNonStarColumns(DataGridColumn ignoredColumn, double takeAwayWidth);
    private double FindMinimumExcessWidthOfNonStarColumns(DataGridColumn ignoredColumn, Int32& countOfParticipatingColumns);
    private void TakeAwayWidthFromEveryNonStarColumn(DataGridColumn ignoredColumn, double perColumnTakeAwayWidth);
    [CompilerGeneratedAttribute]
internal bool get_RebuildRealizedColumnsBlockListForNonVirtualizedRows();
    [CompilerGeneratedAttribute]
internal void set_RebuildRealizedColumnsBlockListForNonVirtualizedRows(bool value);
    internal List`1<RealizedColumnsBlock> get_RealizedColumnsBlockListForNonVirtualizedRows();
    internal void set_RealizedColumnsBlockListForNonVirtualizedRows(List`1<RealizedColumnsBlock> value);
    [CompilerGeneratedAttribute]
internal List`1<RealizedColumnsBlock> get_RealizedColumnsDisplayIndexBlockListForNonVirtualizedRows();
    [CompilerGeneratedAttribute]
internal void set_RealizedColumnsDisplayIndexBlockListForNonVirtualizedRows(List`1<RealizedColumnsBlock> value);
    [CompilerGeneratedAttribute]
internal bool get_RebuildRealizedColumnsBlockListForVirtualizedRows();
    [CompilerGeneratedAttribute]
internal void set_RebuildRealizedColumnsBlockListForVirtualizedRows(bool value);
    internal List`1<RealizedColumnsBlock> get_RealizedColumnsBlockListForVirtualizedRows();
    internal void set_RealizedColumnsBlockListForVirtualizedRows(List`1<RealizedColumnsBlock> value);
    [CompilerGeneratedAttribute]
internal List`1<RealizedColumnsBlock> get_RealizedColumnsDisplayIndexBlockListForVirtualizedRows();
    [CompilerGeneratedAttribute]
internal void set_RealizedColumnsDisplayIndexBlockListForVirtualizedRows(List`1<RealizedColumnsBlock> value);
    internal void InvalidateColumnRealization(bool invalidateForNonVirtualizedRows);
    internal int get_FirstVisibleDisplayIndex();
    internal int get_LastVisibleDisplayIndex();
    [CompilerGeneratedAttribute]
internal bool get_RefreshAutoWidthColumns();
    [CompilerGeneratedAttribute]
internal void set_RefreshAutoWidthColumns(bool value);
}
internal class System.Windows.Controls.DataGridColumnDropSeparator : Separator {
    private DataGridColumnHeader _referenceHeader;
    internal DataGridColumnHeader ReferenceHeader { get; internal set; }
    private static DataGridColumnDropSeparator();
    private static object OnCoerceWidth(DependencyObject d, object baseValue);
    private static object OnCoerceHeight(DependencyObject d, object baseValue);
    internal DataGridColumnHeader get_ReferenceHeader();
    internal void set_ReferenceHeader(DataGridColumnHeader value);
}
public class System.Windows.Controls.DataGridColumnEventArgs : EventArgs {
    private DataGridColumn _column;
    public DataGridColumn Column { get; }
    public DataGridColumnEventArgs(DataGridColumn column);
    public DataGridColumn get_Column();
}
[TemplatePartAttribute]
internal class System.Windows.Controls.DataGridColumnFloatingHeader : Control {
    private DataGridColumnHeader _referenceHeader;
    private static string VisualBrushCanvasTemplateName;
    private Canvas _visualBrushCanvas;
    internal DataGridColumnHeader ReferenceHeader { get; internal set; }
    private static DataGridColumnFloatingHeader();
    private static void OnWidthChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static object OnCoerceWidth(DependencyObject d, object baseValue);
    private static void OnHeightChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static object OnCoerceHeight(DependencyObject d, object baseValue);
    public virtual void OnApplyTemplate();
    internal DataGridColumnHeader get_ReferenceHeader();
    internal void set_ReferenceHeader(DataGridColumnHeader value);
    private void UpdateVisualBrush();
    internal void ClearHeader();
    private double GetVisualCanvasMarginX();
    private double GetVisualCanvasMarginY();
}
internal class System.Windows.Controls.DataGridColumnHeaderCollection : object {
    [CompilerGeneratedAttribute]
private NotifyCollectionChangedEventHandler CollectionChanged;
    private ObservableCollection`1<DataGridColumn> _columns;
    public DataGridColumnHeaderCollection(ObservableCollection`1<DataGridColumn> columns);
    public DataGridColumn ColumnFromIndex(int index);
    internal void NotifyHeaderPropertyChanged(DataGridColumn column, DependencyPropertyChangedEventArgs e);
    public sealed virtual void Dispose();
    public sealed virtual IEnumerator GetEnumerator();
    [CompilerGeneratedAttribute]
public sealed virtual void add_CollectionChanged(NotifyCollectionChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_CollectionChanged(NotifyCollectionChangedEventHandler value);
    private void OnColumnsChanged(object sender, NotifyCollectionChangedEventArgs e);
    private void FireCollectionChanged(NotifyCollectionChangedEventArgs args);
    private static Object[] HeadersFromColumns(IList columns);
}
public class System.Windows.Controls.DataGridColumnReorderingEventArgs : DataGridColumnEventArgs {
    private bool _cancel;
    private Control _dropLocationIndicator;
    private Control _dragIndicator;
    public bool Cancel { get; public set; }
    public Control DropLocationIndicator { get; public set; }
    public Control DragIndicator { get; public set; }
    public DataGridColumnReorderingEventArgs(DataGridColumn dataGridColumn);
    public bool get_Cancel();
    public void set_Cancel(bool value);
    public Control get_DropLocationIndicator();
    public void set_DropLocationIndicator(Control value);
    public Control get_DragIndicator();
    public void set_DragIndicator(Control value);
}
public class System.Windows.Controls.DataGridComboBoxColumn : DataGridColumn {
    public static DependencyProperty ElementStyleProperty;
    public static DependencyProperty EditingElementStyleProperty;
    public static DependencyProperty ItemsSourceProperty;
    public static DependencyProperty DisplayMemberPathProperty;
    public static DependencyProperty SelectedValuePathProperty;
    private static Style _defaultElementStyle;
    private BindingBase _selectedValueBinding;
    private BindingBase _selectedItemBinding;
    private BindingBase _textBinding;
    public static ComponentResourceKey TextBlockComboBoxStyleKey { get; }
    private BindingBase EffectiveBinding { get; }
    public BindingBase SelectedValueBinding { get; public set; }
    public BindingBase SelectedItemBinding { get; public set; }
    public BindingBase TextBinding { get; public set; }
    public static Style DefaultElementStyle { get; }
    public static Style DefaultEditingElementStyle { get; }
    public Style ElementStyle { get; public set; }
    public Style EditingElementStyle { get; public set; }
    public BindingBase ClipboardContentBinding { get; public set; }
    public IEnumerable ItemsSource { get; public set; }
    public string DisplayMemberPath { get; public set; }
    public string SelectedValuePath { get; public set; }
    private static DataGridComboBoxColumn();
    public static ComponentResourceKey get_TextBlockComboBoxStyleKey();
    private static object OnCoerceSortMemberPath(DependencyObject d, object baseValue);
    private BindingBase get_EffectiveBinding();
    public virtual BindingBase get_SelectedValueBinding();
    public virtual void set_SelectedValueBinding(BindingBase value);
    protected virtual bool OnCoerceIsReadOnly(bool baseValue);
    public virtual BindingBase get_SelectedItemBinding();
    public virtual void set_SelectedItemBinding(BindingBase value);
    public virtual BindingBase get_TextBinding();
    public virtual void set_TextBinding(BindingBase value);
    protected virtual void OnSelectedValueBindingChanged(BindingBase oldBinding, BindingBase newBinding);
    protected virtual void OnSelectedItemBindingChanged(BindingBase oldBinding, BindingBase newBinding);
    protected virtual void OnTextBindingChanged(BindingBase oldBinding, BindingBase newBinding);
    public static Style get_DefaultElementStyle();
    public static Style get_DefaultEditingElementStyle();
    public Style get_ElementStyle();
    public void set_ElementStyle(Style value);
    public Style get_EditingElementStyle();
    public void set_EditingElementStyle(Style value);
    private void ApplyStyle(bool isEditing, bool defaultToElementStyle, FrameworkElement element);
    internal void ApplyStyle(bool isEditing, bool defaultToElementStyle, FrameworkContentElement element);
    private Style PickStyle(bool isEditing, bool defaultToElementStyle);
    private static void ApplyBinding(BindingBase binding, DependencyObject target, DependencyProperty property);
    public virtual BindingBase get_ClipboardContentBinding();
    public virtual void set_ClipboardContentBinding(BindingBase value);
    public IEnumerable get_ItemsSource();
    public void set_ItemsSource(IEnumerable value);
    public string get_DisplayMemberPath();
    public void set_DisplayMemberPath(string value);
    public string get_SelectedValuePath();
    public void set_SelectedValuePath(string value);
    protected internal virtual void RefreshCellContent(FrameworkElement element, string propertyName);
    private object GetComboBoxSelectionValue(ComboBox comboBox);
    protected virtual FrameworkElement GenerateElement(DataGridCell cell, object dataItem);
    protected virtual FrameworkElement GenerateEditingElement(DataGridCell cell, object dataItem);
    private void ApplyColumnProperties(ComboBox comboBox);
    protected virtual object PrepareCellForEdit(FrameworkElement editingElement, RoutedEventArgs editingEventArgs);
    protected virtual void CancelCellEdit(FrameworkElement editingElement, object uneditedValue);
    protected virtual bool CommitCellEdit(FrameworkElement editingElement);
    internal virtual void OnInput(InputEventArgs e);
    private static bool IsComboBoxOpeningInputEvent(RoutedEventArgs e);
}
public enum System.Windows.Controls.DataGridEditAction : Enum {
    public int value__;
    public static DataGridEditAction Cancel;
    public static DataGridEditAction Commit;
}
public enum System.Windows.Controls.DataGridEditingUnit : Enum {
    public int value__;
    public static DataGridEditingUnit Cell;
    public static DataGridEditingUnit Row;
}
public enum System.Windows.Controls.DataGridGridLinesVisibility : Enum {
    public int value__;
    public static DataGridGridLinesVisibility All;
    public static DataGridGridLinesVisibility Horizontal;
    public static DataGridGridLinesVisibility None;
    public static DataGridGridLinesVisibility Vertical;
}
[FlagsAttribute]
public enum System.Windows.Controls.DataGridHeadersVisibility : Enum {
    public int value__;
    public static DataGridHeadersVisibility All;
    public static DataGridHeadersVisibility Column;
    public static DataGridHeadersVisibility Row;
    public static DataGridHeadersVisibility None;
}
[LocalizabilityAttribute("17")]
internal class System.Windows.Controls.DataGridHeadersVisibilityToVisibilityConverter : object {
    public sealed virtual object Convert(object value, Type targetType, object parameter, CultureInfo culture);
    public sealed virtual object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture);
}
internal static class System.Windows.Controls.DataGridHelper : object {
    private static ConditionalWeakTable`2<DependencyObject, Dictionary`2<DependencyProperty, bool>> _propertyTransferEnabledMap;
    private static DependencyProperty FlowDirectionCacheProperty;
    private static char _escapeChar;
    private static DataGridHelper();
    public static Size SubtractFromSize(Size size, double thickness, bool height);
    public static bool IsGridLineVisible(DataGrid dataGrid, bool isHorizontal);
    public static bool ShouldNotifyCells(DataGridNotificationTarget target);
    public static bool ShouldNotifyCellsPresenter(DataGridNotificationTarget target);
    public static bool ShouldNotifyColumns(DataGridNotificationTarget target);
    public static bool ShouldNotifyColumnHeaders(DataGridNotificationTarget target);
    public static bool ShouldNotifyColumnHeadersPresenter(DataGridNotificationTarget target);
    public static bool ShouldNotifyColumnCollection(DataGridNotificationTarget target);
    public static bool ShouldNotifyDataGrid(DataGridNotificationTarget target);
    public static bool ShouldNotifyDetailsPresenter(DataGridNotificationTarget target);
    public static bool ShouldRefreshCellContent(DataGridNotificationTarget target);
    public static bool ShouldNotifyRowHeaders(DataGridNotificationTarget target);
    public static bool ShouldNotifyRows(DataGridNotificationTarget target);
    public static bool ShouldNotifyRowSubtree(DataGridNotificationTarget target);
    private static bool TestTarget(DataGridNotificationTarget target, DataGridNotificationTarget value);
    public static T FindParent(FrameworkElement element);
    public static T FindVisualParent(UIElement element);
    public static bool TreeHasFocusAndTabStop(DependencyObject element);
    public static void OnColumnWidthChanged(IProvideDataGridColumn cell, DependencyPropertyChangedEventArgs e);
    public static Geometry GetFrozenClipForCell(IProvideDataGridColumn cell);
    public static DataGridCellsPanel GetParentPanelForCell(IProvideDataGridColumn cell);
    public static double GetParentCellsPanelHorizontalOffset(IProvideDataGridColumn cell);
    public static bool IsDefaultValue(DependencyObject d, DependencyProperty dp);
    public static object GetCoercedTransferPropertyValue(DependencyObject baseObject, object baseValue, DependencyProperty baseProperty, DependencyObject parentObject, DependencyProperty parentProperty);
    public static object GetCoercedTransferPropertyValue(DependencyObject baseObject, object baseValue, DependencyProperty baseProperty, DependencyObject parentObject, DependencyProperty parentProperty, DependencyObject grandParentObject, DependencyProperty grandParentProperty);
    public static void TransferProperty(DependencyObject d, DependencyProperty p);
    private static Dictionary`2<DependencyProperty, bool> GetPropertyTransferEnabledMapForObject(DependencyObject d);
    internal static bool IsPropertyTransferEnabled(DependencyObject d, DependencyProperty p);
    internal static bool IsOneWay(BindingBase bindingBase);
    internal static BindingExpression GetBindingExpression(FrameworkElement element, DependencyProperty dp);
    internal static bool ValidateWithoutUpdate(FrameworkElement element);
    internal static bool BindingExpressionBelongsToElement(BindingExpressionBase beb, T element);
    private static DependencyObject FindContextElement(BindingExpressionBase beb);
    internal static void CacheFlowDirection(FrameworkElement element, DataGridCell cell);
    internal static void RestoreFlowDirection(FrameworkElement element, DataGridCell cell);
    internal static void UpdateTarget(FrameworkElement element);
    internal static void SyncColumnProperty(DependencyObject column, DependencyObject content, DependencyProperty contentProperty, DependencyProperty columnProperty);
    internal static string GetPathFromBinding(Binding binding);
    public static bool AreRowHeadersVisible(DataGridHeadersVisibility headersVisibility);
    public static double CoerceToMinMax(double value, double minValue, double maxValue);
    public static bool HasNonEscapeCharacters(TextCompositionEventArgs textArgs);
    public static bool IsImeProcessed(KeyEventArgs keyArgs);
}
public class System.Windows.Controls.DataGridHyperlinkColumn : DataGridBoundColumn {
    public static DependencyProperty TargetNameProperty;
    private BindingBase _contentBinding;
    public string TargetName { get; public set; }
    public BindingBase ContentBinding { get; public set; }
    public static Style DefaultElementStyle { get; }
    public static Style DefaultEditingElementStyle { get; }
    private static DataGridHyperlinkColumn();
    public string get_TargetName();
    public void set_TargetName(string value);
    public BindingBase get_ContentBinding();
    public void set_ContentBinding(BindingBase value);
    protected virtual void OnContentBindingChanged(BindingBase oldBinding, BindingBase newBinding);
    private void ApplyContentBinding(DependencyObject target, DependencyProperty property);
    protected internal virtual void RefreshCellContent(FrameworkElement element, string propertyName);
    public static Style get_DefaultElementStyle();
    public static Style get_DefaultEditingElementStyle();
    protected virtual FrameworkElement GenerateElement(DataGridCell cell, object dataItem);
    protected virtual FrameworkElement GenerateEditingElement(DataGridCell cell, object dataItem);
    protected virtual object PrepareCellForEdit(FrameworkElement editingElement, RoutedEventArgs editingEventArgs);
    protected virtual void CancelCellEdit(FrameworkElement editingElement, object uneditedValue);
    protected virtual bool CommitCellEdit(FrameworkElement editingElement);
    internal virtual void OnInput(InputEventArgs e);
}
internal class System.Windows.Controls.DataGridItemAttachedStorage : object {
    private Dictionary`2<object, Dictionary`2<DependencyProperty, object>> _itemStorageMap;
    public void SetValue(object item, DependencyProperty property, object value);
    public bool TryGetValue(object item, DependencyProperty property, Object& value);
    public void ClearValue(object item, DependencyProperty property);
    public void ClearItem(object item);
    public void Clear();
    private void EnsureItemStorageMap();
    private Dictionary`2<DependencyProperty, object> EnsureItem(object item);
}
[TypeConverterAttribute("System.Windows.Controls.DataGridLengthConverter")]
public class System.Windows.Controls.DataGridLength : ValueType {
    private double _unitValue;
    private DataGridLengthUnitType _unitType;
    private double _desiredValue;
    private double _displayValue;
    private static double AutoValue;
    private static DataGridLength _auto;
    private static DataGridLength _sizeToCells;
    private static DataGridLength _sizeToHeader;
    public bool IsAbsolute { get; }
    public bool IsAuto { get; }
    public bool IsStar { get; }
    public bool IsSizeToCells { get; }
    public bool IsSizeToHeader { get; }
    public double Value { get; }
    public DataGridLengthUnitType UnitType { get; }
    public double DesiredValue { get; }
    public double DisplayValue { get; }
    public static DataGridLength Auto { get; }
    public static DataGridLength SizeToCells { get; }
    public static DataGridLength SizeToHeader { get; }
    public DataGridLength(double pixels);
    public DataGridLength(double value, DataGridLengthUnitType type);
    public DataGridLength(double value, DataGridLengthUnitType type, double desiredValue, double displayValue);
    private static DataGridLength();
    public static bool op_Equality(DataGridLength gl1, DataGridLength gl2);
    public static bool op_Inequality(DataGridLength gl1, DataGridLength gl2);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(DataGridLength other);
    public virtual int GetHashCode();
    public bool get_IsAbsolute();
    public bool get_IsAuto();
    public bool get_IsStar();
    public bool get_IsSizeToCells();
    public bool get_IsSizeToHeader();
    public double get_Value();
    public DataGridLengthUnitType get_UnitType();
    public double get_DesiredValue();
    public double get_DisplayValue();
    public virtual string ToString();
    public static DataGridLength get_Auto();
    public static DataGridLength get_SizeToCells();
    public static DataGridLength get_SizeToHeader();
    public static DataGridLength op_Implicit(double value);
}
public class System.Windows.Controls.DataGridLengthConverter : TypeConverter {
    private static String[] _unitStrings;
    private static int NumDescriptiveUnits;
    private static String[] _nonStandardUnitStrings;
    private static Double[] _pixelUnitFactors;
    private static DataGridLengthConverter();
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
    internal static string ConvertToString(DataGridLength length, CultureInfo cultureInfo);
    private static DataGridLength ConvertFromString(string s, CultureInfo cultureInfo);
}
public enum System.Windows.Controls.DataGridLengthUnitType : Enum {
    public int value__;
    public static DataGridLengthUnitType Auto;
    public static DataGridLengthUnitType Pixel;
    public static DataGridLengthUnitType SizeToCells;
    public static DataGridLengthUnitType SizeToHeader;
    public static DataGridLengthUnitType Star;
}
[FlagsAttribute]
internal enum System.Windows.Controls.DataGridNotificationTarget : Enum {
    public int value__;
    public static DataGridNotificationTarget None;
    public static DataGridNotificationTarget Cells;
    public static DataGridNotificationTarget CellsPresenter;
    public static DataGridNotificationTarget Columns;
    public static DataGridNotificationTarget ColumnCollection;
    public static DataGridNotificationTarget ColumnHeaders;
    public static DataGridNotificationTarget ColumnHeadersPresenter;
    public static DataGridNotificationTarget DataGrid;
    public static DataGridNotificationTarget DetailsPresenter;
    public static DataGridNotificationTarget RefreshCellContent;
    public static DataGridNotificationTarget RowHeaders;
    public static DataGridNotificationTarget Rows;
    public static DataGridNotificationTarget All;
}
public class System.Windows.Controls.DataGridPreparingCellForEditEventArgs : EventArgs {
    private DataGridColumn _dataGridColumn;
    private DataGridRow _dataGridRow;
    private RoutedEventArgs _editingEventArgs;
    private FrameworkElement _editingElement;
    public DataGridColumn Column { get; }
    public DataGridRow Row { get; }
    public RoutedEventArgs EditingEventArgs { get; }
    public FrameworkElement EditingElement { get; }
    public DataGridPreparingCellForEditEventArgs(DataGridColumn column, DataGridRow row, RoutedEventArgs editingEventArgs, FrameworkElement editingElement);
    public DataGridColumn get_Column();
    public DataGridRow get_Row();
    public RoutedEventArgs get_EditingEventArgs();
    public FrameworkElement get_EditingElement();
}
public class System.Windows.Controls.DataGridRow : Control {
    private static byte DATAGRIDROW_stateMouseOverCode;
    private static byte DATAGRIDROW_stateMouseOverEditingCode;
    private static byte DATAGRIDROW_stateMouseOverEditingFocusedCode;
    private static byte DATAGRIDROW_stateMouseOverSelectedCode;
    private static byte DATAGRIDROW_stateMouseOverSelectedFocusedCode;
    private static byte DATAGRIDROW_stateNormalCode;
    private static byte DATAGRIDROW_stateNormalEditingCode;
    private static byte DATAGRIDROW_stateNormalEditingFocusedCode;
    private static byte DATAGRIDROW_stateSelectedCode;
    private static byte DATAGRIDROW_stateSelectedFocusedCode;
    private static byte DATAGRIDROW_stateNullCode;
    private static Byte[] _idealStateMapping;
    private static Byte[] _fallbackStateMapping;
    private static String[] _stateNames;
    public static DependencyProperty ItemProperty;
    public static DependencyProperty ItemsPanelProperty;
    public static DependencyProperty HeaderProperty;
    public static DependencyProperty HeaderStyleProperty;
    public static DependencyProperty HeaderTemplateProperty;
    public static DependencyProperty HeaderTemplateSelectorProperty;
    public static DependencyProperty ValidationErrorTemplateProperty;
    public static DependencyProperty DetailsTemplateProperty;
    public static DependencyProperty DetailsTemplateSelectorProperty;
    public static DependencyProperty DetailsVisibilityProperty;
    public static DependencyProperty AlternationIndexProperty;
    public static DependencyProperty IsSelectedProperty;
    public static RoutedEvent SelectedEvent;
    public static RoutedEvent UnselectedEvent;
    private static DependencyPropertyKey IsEditingPropertyKey;
    public static DependencyProperty IsEditingProperty;
    internal static DependencyPropertyKey IsNewItemPropertyKey;
    public static DependencyProperty IsNewItemProperty;
    internal bool _detailsLoaded;
    private DataGrid _owner;
    private DataGridCellsPresenter _cellsPresenter;
    private DataGridDetailsPresenter _detailsPresenter;
    private DataGridRowHeader _rowHeader;
    private ContainerTracking`1<DataGridRow> _tracker;
    private double _cellsPresenterResizeHeight;
    public object Item { get; public set; }
    public ItemsPanelTemplate ItemsPanel { get; public set; }
    private bool IsDataGridKeyboardFocusWithin { get; }
    public object Header { get; public set; }
    public Style HeaderStyle { get; public set; }
    public DataTemplate HeaderTemplate { get; public set; }
    public DataTemplateSelector HeaderTemplateSelector { get; public set; }
    public ControlTemplate ValidationErrorTemplate { get; public set; }
    public DataTemplate DetailsTemplate { get; public set; }
    public DataTemplateSelector DetailsTemplateSelector { get; public set; }
    public Visibility DetailsVisibility { get; public set; }
    internal bool DetailsLoaded { get; internal set; }
    internal ContainerTracking`1<DataGridRow> Tracker { get; }
    internal DataGridCellsPresenter CellsPresenter { get; internal set; }
    internal DataGridDetailsPresenter DetailsPresenter { get; internal set; }
    internal DataGridRowHeader RowHeader { get; internal set; }
    public int AlternationIndex { get; }
    [BindableAttribute("True")]
[CategoryAttribute("Appearance")]
public bool IsSelected { get; public set; }
    private bool IsSelectable { get; }
    public bool IsEditing { get; internal set; }
    public bool IsNewItem { get; internal set; }
    internal DataGrid DataGridOwner { get; }
    internal bool DetailsPresenterDrawsGridLines { get; }
    private static DataGridRow();
    public object get_Item();
    public void set_Item(object value);
    protected virtual void OnItemChanged(object oldItem, object newItem);
    public ItemsPanelTemplate get_ItemsPanel();
    public void set_ItemsPanel(ItemsPanelTemplate value);
    protected virtual void OnTemplateChanged(ControlTemplate oldTemplate, ControlTemplate newTemplate);
    private bool get_IsDataGridKeyboardFocusWithin();
    internal virtual void ChangeVisualState(bool useTransitions);
    public object get_Header();
    public void set_Header(object value);
    protected virtual void OnHeaderChanged(object oldHeader, object newHeader);
    public Style get_HeaderStyle();
    public void set_HeaderStyle(Style value);
    public DataTemplate get_HeaderTemplate();
    public void set_HeaderTemplate(DataTemplate value);
    public DataTemplateSelector get_HeaderTemplateSelector();
    public void set_HeaderTemplateSelector(DataTemplateSelector value);
    public ControlTemplate get_ValidationErrorTemplate();
    public void set_ValidationErrorTemplate(ControlTemplate value);
    public DataTemplate get_DetailsTemplate();
    public void set_DetailsTemplate(DataTemplate value);
    public DataTemplateSelector get_DetailsTemplateSelector();
    public void set_DetailsTemplateSelector(DataTemplateSelector value);
    public Visibility get_DetailsVisibility();
    public void set_DetailsVisibility(Visibility value);
    internal bool get_DetailsLoaded();
    internal void set_DetailsLoaded(bool value);
    protected virtual void OnPropertyChanged(DependencyPropertyChangedEventArgs e);
    internal void PrepareRow(object item, DataGrid owningDataGrid);
    internal void ClearRow(DataGrid owningDataGrid);
    private void PersistAttachedItemValue(DependencyObject objectWithProperty, DependencyProperty property);
    private void RestoreAttachedItemValue(DependencyObject objectWithProperty, DependencyProperty property);
    internal ContainerTracking`1<DataGridRow> get_Tracker();
    internal void OnRowResizeStarted();
    internal void OnRowResize(double changeAmount);
    internal void OnRowResizeCompleted(bool canceled);
    internal void OnRowResizeReset();
    protected internal virtual void OnColumnsChanged(ObservableCollection`1<DataGridColumn> columns, NotifyCollectionChangedEventArgs e);
    private static object OnCoerceHeaderStyle(DependencyObject d, object baseValue);
    private static object OnCoerceHeaderTemplate(DependencyObject d, object baseValue);
    private static object OnCoerceHeaderTemplateSelector(DependencyObject d, object baseValue);
    private static object OnCoerceBackground(DependencyObject d, object baseValue);
    private static object OnCoerceValidationErrorTemplate(DependencyObject d, object baseValue);
    private static object OnCoerceDetailsTemplate(DependencyObject d, object baseValue);
    private static object OnCoerceDetailsTemplateSelector(DependencyObject d, object baseValue);
    private static object OnCoerceDetailsVisibility(DependencyObject d, object baseValue);
    private static object OnCoerceVisibility(DependencyObject d, object baseValue);
    private static object OnCoerceShouldCacheContainerSize(DependencyObject d, object baseValue);
    private static void OnNotifyRowPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void OnNotifyRowAndRowHeaderPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void OnNotifyDetailsTemplatePropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void OnNotifyDetailsVisibilityChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static object DelayedRowDetailsVisibilityChanged(object arg);
    internal DataGridCellsPresenter get_CellsPresenter();
    internal void set_CellsPresenter(DataGridCellsPresenter value);
    internal DataGridDetailsPresenter get_DetailsPresenter();
    internal void set_DetailsPresenter(DataGridDetailsPresenter value);
    internal DataGridRowHeader get_RowHeader();
    internal void set_RowHeader(DataGridRowHeader value);
    internal void NotifyPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e, DataGridNotificationTarget target);
    internal void NotifyPropertyChanged(DependencyObject d, string propertyName, DependencyPropertyChangedEventArgs e, DataGridNotificationTarget target);
    private object DelayedValidateWithoutUpdate(object arg);
    private void SyncProperties(bool forcePrepareCells);
    public int get_AlternationIndex();
    public bool get_IsSelected();
    public void set_IsSelected(bool value);
    private static void OnIsSelectedChanged(object sender, DependencyPropertyChangedEventArgs e);
    private void RaiseSelectionChangedEvent(bool isSelected);
    public void add_Selected(RoutedEventHandler value);
    public void remove_Selected(RoutedEventHandler value);
    protected virtual void OnSelected(RoutedEventArgs e);
    public void add_Unselected(RoutedEventHandler value);
    public void remove_Unselected(RoutedEventHandler value);
    protected virtual void OnUnselected(RoutedEventArgs e);
    private bool get_IsSelectable();
    public bool get_IsEditing();
    internal void set_IsEditing(bool value);
    protected virtual AutomationPeer OnCreateAutomationPeer();
    internal void ScrollCellIntoView(int index);
    protected virtual Size ArrangeOverride(Size arrangeBounds);
    public bool get_IsNewItem();
    internal void set_IsNewItem(bool value);
    public int GetIndex();
    public static DataGridRow GetRowContainingElement(FrameworkElement element);
    internal DataGrid get_DataGridOwner();
    internal bool get_DetailsPresenterDrawsGridLines();
    internal DataGridCell TryGetCell(int index);
}
public class System.Windows.Controls.DataGridRowClipboardEventArgs : EventArgs {
    private int _startColumnDisplayIndex;
    private int _endColumnDisplayIndex;
    private object _item;
    private bool _isColumnHeadersRow;
    private List`1<DataGridClipboardCellContent> _clipboardRowContent;
    private int _rowIndexHint;
    public object Item { get; }
    public List`1<DataGridClipboardCellContent> ClipboardRowContent { get; }
    public int StartColumnDisplayIndex { get; }
    public int EndColumnDisplayIndex { get; }
    public bool IsColumnHeadersRow { get; }
    internal int RowIndexHint { get; }
    public DataGridRowClipboardEventArgs(object item, int startColumnDisplayIndex, int endColumnDisplayIndex, bool isColumnHeadersRow);
    internal DataGridRowClipboardEventArgs(object item, int startColumnDisplayIndex, int endColumnDisplayIndex, bool isColumnHeadersRow, int rowIndexHint);
    public object get_Item();
    public List`1<DataGridClipboardCellContent> get_ClipboardRowContent();
    public string FormatClipboardCellValues(string format);
    public int get_StartColumnDisplayIndex();
    public int get_EndColumnDisplayIndex();
    public bool get_IsColumnHeadersRow();
    internal int get_RowIndexHint();
}
public class System.Windows.Controls.DataGridRowDetailsEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private FrameworkElement <DetailsElement>k__BackingField;
    [CompilerGeneratedAttribute]
private DataGridRow <Row>k__BackingField;
    public FrameworkElement DetailsElement { get; private set; }
    public DataGridRow Row { get; private set; }
    public DataGridRowDetailsEventArgs(DataGridRow row, FrameworkElement detailsElement);
    [CompilerGeneratedAttribute]
public FrameworkElement get_DetailsElement();
    [CompilerGeneratedAttribute]
private void set_DetailsElement(FrameworkElement value);
    [CompilerGeneratedAttribute]
public DataGridRow get_Row();
    [CompilerGeneratedAttribute]
private void set_Row(DataGridRow value);
}
public enum System.Windows.Controls.DataGridRowDetailsVisibilityMode : Enum {
    public int value__;
    public static DataGridRowDetailsVisibilityMode Collapsed;
    public static DataGridRowDetailsVisibilityMode Visible;
    public static DataGridRowDetailsVisibilityMode VisibleWhenSelected;
}
public class System.Windows.Controls.DataGridRowEditEndingEventArgs : EventArgs {
    private bool _cancel;
    private DataGridRow _dataGridRow;
    private DataGridEditAction _editAction;
    public bool Cancel { get; public set; }
    public DataGridRow Row { get; }
    public DataGridEditAction EditAction { get; }
    public DataGridRowEditEndingEventArgs(DataGridRow row, DataGridEditAction editAction);
    public bool get_Cancel();
    public void set_Cancel(bool value);
    public DataGridRow get_Row();
    public DataGridEditAction get_EditAction();
}
public class System.Windows.Controls.DataGridRowEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private DataGridRow <Row>k__BackingField;
    public DataGridRow Row { get; private set; }
    public DataGridRowEventArgs(DataGridRow row);
    [CompilerGeneratedAttribute]
public DataGridRow get_Row();
    [CompilerGeneratedAttribute]
private void set_Row(DataGridRow value);
}
public enum System.Windows.Controls.DataGridSelectionMode : Enum {
    public int value__;
    public static DataGridSelectionMode Single;
    public static DataGridSelectionMode Extended;
}
public enum System.Windows.Controls.DataGridSelectionUnit : Enum {
    public int value__;
    public static DataGridSelectionUnit Cell;
    public static DataGridSelectionUnit FullRow;
    public static DataGridSelectionUnit CellOrRowHeader;
}
public class System.Windows.Controls.DataGridSortingEventArgs : DataGridColumnEventArgs {
    private bool _handled;
    public bool Handled { get; public set; }
    public DataGridSortingEventArgs(DataGridColumn column);
    public bool get_Handled();
    public void set_Handled(bool value);
}
public class System.Windows.Controls.DataGridSortingEventHandler : MulticastDelegate {
    public DataGridSortingEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, DataGridSortingEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, DataGridSortingEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Windows.Controls.DataGridTemplateColumn : DataGridColumn {
    public static DependencyProperty CellTemplateProperty;
    public static DependencyProperty CellTemplateSelectorProperty;
    public static DependencyProperty CellEditingTemplateProperty;
    public static DependencyProperty CellEditingTemplateSelectorProperty;
    public DataTemplate CellTemplate { get; public set; }
    public DataTemplateSelector CellTemplateSelector { get; public set; }
    public DataTemplate CellEditingTemplate { get; public set; }
    public DataTemplateSelector CellEditingTemplateSelector { get; public set; }
    private static DataGridTemplateColumn();
    private static void OnTemplateColumnSortMemberPathChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static object OnCoerceTemplateColumnCanUserSort(DependencyObject d, object baseValue);
    public DataTemplate get_CellTemplate();
    public void set_CellTemplate(DataTemplate value);
    public DataTemplateSelector get_CellTemplateSelector();
    public void set_CellTemplateSelector(DataTemplateSelector value);
    public DataTemplate get_CellEditingTemplate();
    public void set_CellEditingTemplate(DataTemplate value);
    public DataTemplateSelector get_CellEditingTemplateSelector();
    public void set_CellEditingTemplateSelector(DataTemplateSelector value);
    private void ChooseCellTemplateAndSelector(bool isEditing, DataTemplate& template, DataTemplateSelector& templateSelector);
    private FrameworkElement LoadTemplateContent(bool isEditing, object dataItem, DataGridCell cell);
    protected virtual FrameworkElement GenerateElement(DataGridCell cell, object dataItem);
    protected virtual FrameworkElement GenerateEditingElement(DataGridCell cell, object dataItem);
    protected internal virtual void RefreshCellContent(FrameworkElement element, string propertyName);
}
public class System.Windows.Controls.DataGridTextColumn : DataGridBoundColumn {
    public static DependencyProperty FontFamilyProperty;
    public static DependencyProperty FontSizeProperty;
    public static DependencyProperty FontStyleProperty;
    public static DependencyProperty FontWeightProperty;
    public static DependencyProperty ForegroundProperty;
    private static Style _defaultElementStyle;
    private static Style _defaultEditingElementStyle;
    public static Style DefaultElementStyle { get; }
    public static Style DefaultEditingElementStyle { get; }
    public FontFamily FontFamily { get; public set; }
    [TypeConverterAttribute("System.Windows.FontSizeConverter")]
[LocalizabilityAttribute("0")]
public double FontSize { get; public set; }
    public FontStyle FontStyle { get; public set; }
    public FontWeight FontWeight { get; public set; }
    public Brush Foreground { get; public set; }
    private static DataGridTextColumn();
    public static Style get_DefaultElementStyle();
    public static Style get_DefaultEditingElementStyle();
    protected virtual FrameworkElement GenerateElement(DataGridCell cell, object dataItem);
    protected virtual FrameworkElement GenerateEditingElement(DataGridCell cell, object dataItem);
    private void SyncProperties(FrameworkElement e);
    protected internal virtual void RefreshCellContent(FrameworkElement element, string propertyName);
    protected virtual object PrepareCellForEdit(FrameworkElement editingElement, RoutedEventArgs editingEventArgs);
    private string ConvertTextForEdit(string s);
    protected virtual void CancelCellEdit(FrameworkElement editingElement, object uneditedValue);
    protected virtual bool CommitCellEdit(FrameworkElement editingElement);
    private static bool PlaceCaretOnTextBox(TextBox textBox, Point position);
    internal virtual void OnInput(InputEventArgs e);
    public FontFamily get_FontFamily();
    public void set_FontFamily(FontFamily value);
    public double get_FontSize();
    public void set_FontSize(double value);
    public FontStyle get_FontStyle();
    public void set_FontStyle(FontStyle value);
    public FontWeight get_FontWeight();
    public void set_FontWeight(FontWeight value);
    public Brush get_Foreground();
    public void set_Foreground(Brush value);
}
public class System.Windows.Controls.DataTemplateSelector : object {
    public virtual DataTemplate SelectTemplate(object item, DependencyObject container);
}
[TemplatePartAttribute]
[TemplatePartAttribute]
[TemplatePartAttribute]
[TemplatePartAttribute]
public class System.Windows.Controls.DatePicker : Control {
    private static string ElementRoot;
    private static string ElementTextBox;
    private static string ElementButton;
    private static string ElementPopup;
    private Calendar _calendar;
    private string _defaultText;
    private ButtonBase _dropDownButton;
    private Popup _popUp;
    private bool _disablePopupReopen;
    private DatePickerTextBox _textBox;
    private IDictionary`2<DependencyProperty, bool> _isHandlerSuspended;
    private Nullable`1<DateTime> _originalSelectedDate;
    public static RoutedEvent SelectedDateChangedEvent;
    [CompilerGeneratedAttribute]
private RoutedEventHandler CalendarClosed;
    [CompilerGeneratedAttribute]
private RoutedEventHandler CalendarOpened;
    [CompilerGeneratedAttribute]
private EventHandler`1<DatePickerDateValidationErrorEventArgs> DateValidationError;
    public static DependencyProperty CalendarStyleProperty;
    public static DependencyProperty DisplayDateProperty;
    public static DependencyProperty DisplayDateEndProperty;
    public static DependencyProperty DisplayDateStartProperty;
    public static DependencyProperty FirstDayOfWeekProperty;
    public static DependencyProperty IsDropDownOpenProperty;
    public static DependencyProperty IsTodayHighlightedProperty;
    public static DependencyProperty SelectedDateProperty;
    public static DependencyProperty SelectedDateFormatProperty;
    public static DependencyProperty TextProperty;
    public CalendarBlackoutDatesCollection BlackoutDates { get; }
    public Style CalendarStyle { get; public set; }
    public DateTime DisplayDate { get; public set; }
    public Nullable`1<DateTime> DisplayDateEnd { get; public set; }
    public Nullable`1<DateTime> DisplayDateStart { get; public set; }
    public DayOfWeek FirstDayOfWeek { get; public set; }
    public bool IsDropDownOpen { get; public set; }
    public bool IsTodayHighlighted { get; public set; }
    public Nullable`1<DateTime> SelectedDate { get; public set; }
    public DatePickerFormat SelectedDateFormat { get; public set; }
    public string Text { get; public set; }
    internal Calendar Calendar { get; }
    internal TextBox TextBox { get; }
    protected internal bool HasEffectiveKeyboardFocus { get; }
    private static DatePicker();
    [CompilerGeneratedAttribute]
public void add_CalendarClosed(RoutedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_CalendarClosed(RoutedEventHandler value);
    [CompilerGeneratedAttribute]
public void add_CalendarOpened(RoutedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_CalendarOpened(RoutedEventHandler value);
    [CompilerGeneratedAttribute]
public void add_DateValidationError(EventHandler`1<DatePickerDateValidationErrorEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_DateValidationError(EventHandler`1<DatePickerDateValidationErrorEventArgs> value);
    public void add_SelectedDateChanged(EventHandler`1<SelectionChangedEventArgs> value);
    public void remove_SelectedDateChanged(EventHandler`1<SelectionChangedEventArgs> value);
    public CalendarBlackoutDatesCollection get_BlackoutDates();
    public Style get_CalendarStyle();
    public void set_CalendarStyle(Style value);
    public DateTime get_DisplayDate();
    public void set_DisplayDate(DateTime value);
    private static object CoerceDisplayDate(DependencyObject d, object value);
    public Nullable`1<DateTime> get_DisplayDateEnd();
    public void set_DisplayDateEnd(Nullable`1<DateTime> value);
    private static void OnDisplayDateEndChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static object CoerceDisplayDateEnd(DependencyObject d, object value);
    public Nullable`1<DateTime> get_DisplayDateStart();
    public void set_DisplayDateStart(Nullable`1<DateTime> value);
    private static void OnDisplayDateStartChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static object CoerceDisplayDateStart(DependencyObject d, object value);
    public DayOfWeek get_FirstDayOfWeek();
    public void set_FirstDayOfWeek(DayOfWeek value);
    public bool get_IsDropDownOpen();
    public void set_IsDropDownOpen(bool value);
    private static object OnCoerceIsDropDownOpen(DependencyObject d, object baseValue);
    private static void OnIsDropDownOpenChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void OnIsEnabledChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public bool get_IsTodayHighlighted();
    public void set_IsTodayHighlighted(bool value);
    public Nullable`1<DateTime> get_SelectedDate();
    public void set_SelectedDate(Nullable`1<DateTime> value);
    private static void OnSelectedDateChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static object CoerceSelectedDate(DependencyObject d, object value);
    public DatePickerFormat get_SelectedDateFormat();
    public void set_SelectedDateFormat(DatePickerFormat value);
    private static void OnSelectedDateFormatChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public string get_Text();
    public void set_Text(string value);
    private static void OnTextChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private void SetTextInternal(string value);
    internal Calendar get_Calendar();
    internal TextBox get_TextBox();
    public virtual void OnApplyTemplate();
    public virtual string ToString();
    internal virtual void ChangeVisualState(bool useTransitions);
    protected virtual AutomationPeer OnCreateAutomationPeer();
    protected virtual void OnCalendarClosed(RoutedEventArgs e);
    protected virtual void OnCalendarOpened(RoutedEventArgs e);
    protected virtual void OnSelectedDateChanged(SelectionChangedEventArgs e);
    protected virtual void OnDateValidationError(DatePickerDateValidationErrorEventArgs e);
    protected internal virtual bool get_HasEffectiveKeyboardFocus();
    private static void OnGotFocus(object sender, RoutedEventArgs e);
    private void SetValueNoCallback(DependencyProperty property, object value);
    private bool IsHandlerSuspended(DependencyProperty property);
    private void SetIsHandlerSuspended(DependencyProperty property, bool value);
    private void PopUp_PreviewMouseLeftButtonDown(object sender, MouseButtonEventArgs e);
    private void PopUp_Opened(object sender, EventArgs e);
    private void PopUp_Closed(object sender, EventArgs e);
    private void Calendar_DayButtonMouseUp(object sender, MouseButtonEventArgs e);
    private void CalendarDayOrMonthButton_PreviewKeyDown(object sender, RoutedEventArgs e);
    private void Calendar_DisplayDateChanged(object sender, CalendarDateChangedEventArgs e);
    private void Calendar_SelectedDatesChanged(object sender, SelectionChangedEventArgs e);
    private string DateTimeToString(DateTime d);
    private static DateTime DiscardDayTime(DateTime d);
    private static Nullable`1<DateTime> DiscardTime(Nullable`1<DateTime> d);
    private void DropDownButton_Click(object sender, RoutedEventArgs e);
    private void DropDownButton_MouseLeave(object sender, MouseEventArgs e);
    private void TogglePopUp();
    private void InitializeCalendar();
    private BindingBase GetDatePickerBinding(DependencyProperty property);
    private static bool IsValidSelectedDateFormat(object value);
    private Nullable`1<DateTime> ParseText(string text);
    private bool ProcessDatePickerKey(KeyEventArgs e);
    private void SetSelectedDate();
    private void SafeSetText(string s);
    private Nullable`1<DateTime> SetTextBoxValue(string s);
    private void SetWaterMarkText();
    private void TextBox_LostFocus(object sender, RoutedEventArgs e);
    private void TextBox_KeyDown(object sender, KeyEventArgs e);
    private void TextBox_TextChanged(object sender, TextChangedEventArgs e);
}
public class System.Windows.Controls.DatePickerDateValidationErrorEventArgs : EventArgs {
    private bool _throwException;
    [CompilerGeneratedAttribute]
private Exception <Exception>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Text>k__BackingField;
    public Exception Exception { get; private set; }
    public string Text { get; private set; }
    public bool ThrowException { get; public set; }
    public DatePickerDateValidationErrorEventArgs(Exception exception, string text);
    [CompilerGeneratedAttribute]
public Exception get_Exception();
    [CompilerGeneratedAttribute]
private void set_Exception(Exception value);
    [CompilerGeneratedAttribute]
public string get_Text();
    [CompilerGeneratedAttribute]
private void set_Text(string value);
    public bool get_ThrowException();
    public void set_ThrowException(bool value);
}
public enum System.Windows.Controls.DatePickerFormat : Enum {
    public int value__;
    public static DatePickerFormat Long;
    public static DatePickerFormat Short;
}
internal static class System.Windows.Controls.DateTimeHelper : object {
    private static Calendar cal;
    private static DateTimeHelper();
    public static Nullable`1<DateTime> AddDays(DateTime time, int days);
    public static Nullable`1<DateTime> AddMonths(DateTime time, int months);
    public static Nullable`1<DateTime> AddYears(DateTime time, int years);
    public static Nullable`1<DateTime> SetYear(DateTime date, int year);
    public static Nullable`1<DateTime> SetYearMonth(DateTime date, DateTime yearMonth);
    public static int CompareDays(DateTime dt1, DateTime dt2);
    public static int CompareYearMonth(DateTime dt1, DateTime dt2);
    public static int DecadeOfDate(DateTime date);
    public static DateTime DiscardDayTime(DateTime d);
    public static Nullable`1<DateTime> DiscardTime(Nullable`1<DateTime> d);
    public static int EndOfDecade(DateTime date);
    public static DateTimeFormatInfo GetCurrentDateFormat();
    internal static CultureInfo GetCulture(FrameworkElement element);
    internal static DateTimeFormatInfo GetDateFormat(CultureInfo culture);
    public static bool InRange(DateTime date, CalendarDateRange range);
    public static bool InRange(DateTime date, DateTime start, DateTime end);
    public static string ToDayString(Nullable`1<DateTime> date, CultureInfo culture);
    public static string ToDecadeRangeString(int decade, FrameworkElement fe);
    public static string ToYearMonthPatternString(Nullable`1<DateTime> date, CultureInfo culture);
    public static string ToYearString(Nullable`1<DateTime> date, CultureInfo culture);
    public static string ToAbbreviatedMonthString(Nullable`1<DateTime> date, CultureInfo culture);
    public static string ToLongDateString(Nullable`1<DateTime> date, CultureInfo culture);
}
[LocalizabilityAttribute("16")]
[ContentPropertyAttribute("Child")]
public class System.Windows.Controls.Decorator : FrameworkElement {
    private UIElement _child;
    [DefaultValueAttribute("")]
public UIElement Child { get; public set; }
    protected internal IEnumerator LogicalChildren { get; }
    protected int VisualChildrenCount { get; }
    internal UIElement IntChild { get; internal set; }
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object value);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string text);
    public virtual UIElement get_Child();
    public virtual void set_Child(UIElement value);
    protected internal virtual IEnumerator get_LogicalChildren();
    protected virtual int get_VisualChildrenCount();
    protected virtual Visual GetVisualChild(int index);
    protected virtual Size MeasureOverride(Size constraint);
    protected virtual Size ArrangeOverride(Size arrangeSize);
    internal UIElement get_IntChild();
    internal void set_IntChild(UIElement value);
}
internal class System.Windows.Controls.DefaultItemContainerTemplateSelector : ItemContainerTemplateSelector {
    public virtual DataTemplate SelectTemplate(object item, ItemsControl parentItemsControl);
}
internal class System.Windows.Controls.DeferredRunTextReference : DeferredReference {
    private Run _run;
    internal DeferredRunTextReference(Run run);
    internal virtual object GetValue(BaseValueSourceInternal valueSource);
    internal virtual Type GetValueType();
}
internal class System.Windows.Controls.DeferredSelectedIndexReference : DeferredReference {
    private Selector _selector;
    internal DeferredSelectedIndexReference(Selector selector);
    internal virtual object GetValue(BaseValueSourceInternal valueSource);
    internal virtual Type GetValueType();
}
internal class System.Windows.Controls.DeferredTextReference : DeferredReference {
    private ITextContainer _textContainer;
    internal DeferredTextReference(ITextContainer textContainer);
    internal virtual object GetValue(BaseValueSourceInternal valueSource);
    internal virtual Type GetValueType();
}
[LocalizabilityAttribute("16")]
public abstract class System.Windows.Controls.DefinitionBase : FrameworkContentElement {
    private bool _isColumnDefinition;
    private Flags _flags;
    private int _parentIndex;
    private LayoutTimeSizeType _sizeType;
    private double _minSize;
    private double _measureSize;
    private double _sizeCache;
    private double _offset;
    private SharedSizeState _sharedState;
    internal static bool ThisIsColumnDefinition;
    internal static bool ThisIsRowDefinition;
    internal static DependencyProperty PrivateSharedSizeScopeProperty;
    public static DependencyProperty SharedSizeGroupProperty;
    public string SharedSizeGroup { get; public set; }
    internal bool IsShared { get; }
    internal GridLength UserSize { get; }
    internal double UserMinSize { get; }
    internal double UserMaxSize { get; }
    internal int Index { get; internal set; }
    internal LayoutTimeSizeType SizeType { get; internal set; }
    internal double MeasureSize { get; internal set; }
    internal double PreferredSize { get; }
    internal double SizeCache { get; internal set; }
    internal double MinSize { get; }
    internal double MinSizeForArrange { get; }
    internal double RawMinSize { get; }
    internal double FinalOffset { get; internal set; }
    internal GridLength UserSizeValueCache { get; }
    internal double UserMinSizeValueCache { get; }
    internal double UserMaxSizeValueCache { get; }
    internal bool InParentLogicalTree { get; }
    private SharedSizeScope PrivateSharedSizeScope { get; }
    private bool UseSharedMinimum { get; private set; }
    private bool LayoutWasUpdated { get; private set; }
    internal DefinitionBase(bool isColumnDefinition);
    private static DefinitionBase();
    public string get_SharedSizeGroup();
    public void set_SharedSizeGroup(string value);
    internal void OnEnterParentTree();
    internal void OnExitParentTree();
    internal void OnBeforeLayout(Grid grid);
    internal void UpdateMinSize(double minSize);
    internal void SetMinSize(double minSize);
    internal static void OnUserSizePropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    internal static bool IsUserSizePropertyValueValid(object value);
    internal static void OnUserMinSizePropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    internal static bool IsUserMinSizePropertyValueValid(object value);
    internal static void OnUserMaxSizePropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    internal static bool IsUserMaxSizePropertyValueValid(object value);
    internal static void OnIsSharedSizeScopePropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    internal bool get_IsShared();
    internal GridLength get_UserSize();
    internal double get_UserMinSize();
    internal double get_UserMaxSize();
    internal int get_Index();
    internal void set_Index(int value);
    internal LayoutTimeSizeType get_SizeType();
    internal void set_SizeType(LayoutTimeSizeType value);
    internal double get_MeasureSize();
    internal void set_MeasureSize(double value);
    internal double get_PreferredSize();
    internal double get_SizeCache();
    internal void set_SizeCache(double value);
    internal double get_MinSize();
    internal double get_MinSizeForArrange();
    internal double get_RawMinSize();
    internal double get_FinalOffset();
    internal void set_FinalOffset(double value);
    internal GridLength get_UserSizeValueCache();
    internal double get_UserMinSizeValueCache();
    internal double get_UserMaxSizeValueCache();
    internal bool get_InParentLogicalTree();
    private void SetFlags(bool value, Flags flags);
    private bool CheckFlagsAnd(Flags flags);
    private static void OnSharedSizeGroupPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static bool SharedSizeGroupPropertyValueValid(object value);
    private static void OnPrivateSharedSizeScopePropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private SharedSizeScope get_PrivateSharedSizeScope();
    private bool get_UseSharedMinimum();
    private void set_UseSharedMinimum(bool value);
    private bool get_LayoutWasUpdated();
    private void set_LayoutWasUpdated(bool value);
}
public enum System.Windows.Controls.Dock : Enum {
    public int value__;
    public static Dock Left;
    public static Dock Top;
    public static Dock Right;
    public static Dock Bottom;
}
public class System.Windows.Controls.DockPanel : Panel {
    [CommonDependencyPropertyAttribute]
public static DependencyProperty LastChildFillProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty DockProperty;
    public bool LastChildFill { get; public set; }
    internal int EffectiveValuesInitialSize { get; }
    private static DockPanel();
    [AttachedPropertyBrowsableForChildrenAttribute]
public static Dock GetDock(UIElement element);
    public static void SetDock(UIElement element, Dock dock);
    private static void OnDockChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public bool get_LastChildFill();
    public void set_LastChildFill(bool value);
    protected virtual Size MeasureOverride(Size constraint);
    protected virtual Size ArrangeOverride(Size arrangeSize);
    internal static bool IsValidDock(object o);
    internal virtual int get_EffectiveValuesInitialSize();
}
[TemplatePartAttribute]
[TemplatePartAttribute]
public class System.Windows.Controls.DocumentViewer : DocumentViewerBase {
    public static DependencyProperty HorizontalOffsetProperty;
    public static DependencyProperty VerticalOffsetProperty;
    private static DependencyPropertyKey ExtentWidthPropertyKey;
    public static DependencyProperty ExtentWidthProperty;
    private static DependencyPropertyKey ExtentHeightPropertyKey;
    public static DependencyProperty ExtentHeightProperty;
    private static DependencyPropertyKey ViewportWidthPropertyKey;
    public static DependencyProperty ViewportWidthProperty;
    private static DependencyPropertyKey ViewportHeightPropertyKey;
    public static DependencyProperty ViewportHeightProperty;
    public static DependencyProperty ShowPageBordersProperty;
    public static DependencyProperty ZoomProperty;
    public static DependencyProperty MaxPagesAcrossProperty;
    public static DependencyProperty VerticalPageSpacingProperty;
    public static DependencyProperty HorizontalPageSpacingProperty;
    private static DependencyPropertyKey CanMoveUpPropertyKey;
    public static DependencyProperty CanMoveUpProperty;
    private static DependencyPropertyKey CanMoveDownPropertyKey;
    public static DependencyProperty CanMoveDownProperty;
    private static DependencyPropertyKey CanMoveLeftPropertyKey;
    public static DependencyProperty CanMoveLeftProperty;
    private static DependencyPropertyKey CanMoveRightPropertyKey;
    public static DependencyProperty CanMoveRightProperty;
    private static DependencyPropertyKey CanIncreaseZoomPropertyKey;
    public static DependencyProperty CanIncreaseZoomProperty;
    private static DependencyPropertyKey CanDecreaseZoomPropertyKey;
    public static DependencyProperty CanDecreaseZoomProperty;
    private IDocumentScrollInfo _documentScrollInfo;
    private ScrollViewer _scrollViewer;
    private ZoomPercentageConverter _zoomPercentageConverter;
    private FindToolBar _findToolbar;
    private static double _horizontalOffsetDefault;
    private static double _verticalOffsetDefault;
    private static double _extentWidthDefault;
    private static double _extentHeightDefault;
    private static double _viewportWidthDefault;
    private static double _viewportHeightDefault;
    private static bool _showPageBordersDefault;
    private static double _zoomPercentageDefault;
    private static int _maxPagesAcrossDefault;
    private static double _verticalPageSpacingDefault;
    private static double _horizontalPageSpacingDefault;
    private static bool _canMoveUpDefault;
    private static bool _canMoveDownDefault;
    private static bool _canMoveLeftDefault;
    private static bool _canMoveRightDefault;
    private static bool _canIncreaseZoomDefault;
    private static bool _canDecreaseZoomDefault;
    private static RoutedUICommand _viewThumbnailsCommand;
    private static RoutedUICommand _fitToWidthCommand;
    private static RoutedUICommand _fitToHeightCommand;
    private static RoutedUICommand _fitToMaxPagesAcrossCommand;
    private static Double[] _zoomLevelCollection;
    private int _zoomLevelIndex;
    private bool _zoomLevelIndexValid;
    private bool _updatingInternalZoomLevel;
    private bool _internalIDSIChange;
    private bool _pageViewCollectionChanged;
    private bool _firstDocumentAssignment;
    private static string _findToolBarHostName;
    private static string _contentHostName;
    private static DependencyObjectType _dType;
    public static RoutedUICommand ViewThumbnailsCommand { get; }
    public static RoutedUICommand FitToWidthCommand { get; }
    public static RoutedUICommand FitToHeightCommand { get; }
    public static RoutedUICommand FitToMaxPagesAcrossCommand { get; }
    public double HorizontalOffset { get; public set; }
    public double VerticalOffset { get; public set; }
    public double ExtentWidth { get; }
    public double ExtentHeight { get; }
    public double ViewportWidth { get; }
    public double ViewportHeight { get; }
    public bool ShowPageBorders { get; public set; }
    public double Zoom { get; public set; }
    public int MaxPagesAcross { get; public set; }
    public double VerticalPageSpacing { get; public set; }
    public double HorizontalPageSpacing { get; public set; }
    public bool CanMoveUp { get; }
    public bool CanMoveDown { get; }
    public bool CanMoveLeft { get; }
    public bool CanMoveRight { get; }
    public bool CanIncreaseZoom { get; }
    public bool CanDecreaseZoom { get; }
    internal ITextSelection TextSelection { get; }
    internal IDocumentScrollInfo DocumentScrollInfo { get; }
    internal ScrollViewer ScrollViewer { get; }
    internal DependencyObjectType DTypeThemeStyleKey { get; }
    private static DocumentViewer();
    public void ViewThumbnails();
    public void FitToWidth();
    public void FitToHeight();
    public void FitToMaxPagesAcross();
    public void FitToMaxPagesAcross(int pagesAcross);
    public void Find();
    public void ScrollPageUp();
    public void ScrollPageDown();
    public void ScrollPageLeft();
    public void ScrollPageRight();
    public void MoveUp();
    public void MoveDown();
    public void MoveLeft();
    public void MoveRight();
    public void IncreaseZoom();
    public void DecreaseZoom();
    public virtual void OnApplyTemplate();
    public static RoutedUICommand get_ViewThumbnailsCommand();
    public static RoutedUICommand get_FitToWidthCommand();
    public static RoutedUICommand get_FitToHeightCommand();
    public static RoutedUICommand get_FitToMaxPagesAcrossCommand();
    public double get_HorizontalOffset();
    public void set_HorizontalOffset(double value);
    public double get_VerticalOffset();
    public void set_VerticalOffset(double value);
    public double get_ExtentWidth();
    public double get_ExtentHeight();
    public double get_ViewportWidth();
    public double get_ViewportHeight();
    public bool get_ShowPageBorders();
    public void set_ShowPageBorders(bool value);
    public double get_Zoom();
    public void set_Zoom(double value);
    public int get_MaxPagesAcross();
    public void set_MaxPagesAcross(int value);
    public double get_VerticalPageSpacing();
    public void set_VerticalPageSpacing(double value);
    public double get_HorizontalPageSpacing();
    public void set_HorizontalPageSpacing(double value);
    public bool get_CanMoveUp();
    public bool get_CanMoveDown();
    public bool get_CanMoveLeft();
    public bool get_CanMoveRight();
    public bool get_CanIncreaseZoom();
    public bool get_CanDecreaseZoom();
    protected virtual AutomationPeer OnCreateAutomationPeer();
    protected virtual void OnDocumentChanged();
    protected virtual void OnBringIntoView(DependencyObject element, Rect rect, int pageNumber);
    protected virtual void OnPreviousPageCommand();
    protected virtual void OnNextPageCommand();
    protected virtual void OnFirstPageCommand();
    protected virtual void OnLastPageCommand();
    protected virtual void OnGoToPageCommand(int pageNumber);
    protected virtual void OnViewThumbnailsCommand();
    protected virtual void OnFitToWidthCommand();
    protected virtual void OnFitToHeightCommand();
    protected virtual void OnFitToMaxPagesAcrossCommand();
    protected virtual void OnFitToMaxPagesAcrossCommand(int pagesAcross);
    protected virtual void OnFindCommand();
    protected virtual void OnKeyDown(KeyEventArgs e);
    protected virtual void OnScrollPageUpCommand();
    protected virtual void OnScrollPageDownCommand();
    protected virtual void OnScrollPageLeftCommand();
    protected virtual void OnScrollPageRightCommand();
    protected virtual void OnMoveUpCommand();
    protected virtual void OnMoveDownCommand();
    protected virtual void OnMoveLeftCommand();
    protected virtual void OnMoveRightCommand();
    protected virtual void OnIncreaseZoomCommand();
    protected virtual void OnDecreaseZoomCommand();
    protected virtual ReadOnlyCollection`1<DocumentPageView> GetPageViewsCollection(Boolean& changed);
    protected virtual void OnMouseLeftButtonDown(MouseButtonEventArgs e);
    protected virtual void OnPreviewMouseWheel(MouseWheelEventArgs e);
    internal void InvalidateDocumentScrollInfo();
    internal void InvalidatePageViewsInternal();
    internal bool BringPointIntoView(Point point);
    internal ITextSelection get_TextSelection();
    internal IDocumentScrollInfo get_DocumentScrollInfo();
    internal ScrollViewer get_ScrollViewer();
    private static void CreateCommandBindings();
    private static void QueryEnabledHandler(object target, CanExecuteRoutedEventArgs args);
    private static void ExecutedRoutedEventHandler(object target, ExecutedRoutedEventArgs args);
    private static void DoFitToMaxPagesAcross(DocumentViewer dv, object data);
    private static void DoZoom(DocumentViewer dv, object data);
    private static void RegisterMetadata();
    private void SetUp();
    private void CreateIDocumentScrollInfo();
    private void AttachContent();
    private void FindContentHost();
    private void InstantiateFindToolBar();
    private void OnFindInvoked(object sender, EventArgs e);
    private void GoToFind();
    private KeyEventArgs ProcessFindKeys(KeyEventArgs e);
    private void FindZoomLevelIndex();
    private static bool DoubleValue_Validate(object value);
    private static double ScaleToZoom(double scale);
    private static double ZoomToScale(double zoom);
    private static bool ValidateOffset(object value);
    private static void OnHorizontalOffsetChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void OnVerticalOffsetChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void OnExtentWidthChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void OnExtentHeightChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void OnViewportWidthChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void OnViewportHeightChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void OnShowPageBordersChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static object CoerceZoom(DependencyObject d, object value);
    private static void OnZoomChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static bool ValidateMaxPagesAcross(object value);
    private static void OnMaxPagesAcrossChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static bool ValidatePageSpacing(object value);
    private static void OnVerticalPageSpacingChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void OnHorizontalPageSpacingChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    internal virtual DependencyObjectType get_DTypeThemeStyleKey();
}
internal static class System.Windows.Controls.EditingModeHelper : object {
    internal static bool IsDefined(InkCanvasEditingMode InkCanvasEditingMode);
}
internal enum System.Windows.Controls.ElementViewportPosition : Enum {
    public int value__;
    public static ElementViewportPosition None;
    public static ElementViewportPosition BeforeViewport;
    public static ElementViewportPosition PartiallyInViewport;
    public static ElementViewportPosition CompletelyInViewport;
    public static ElementViewportPosition AfterViewport;
}
public class System.Windows.Controls.ExceptionValidationRule : ValidationRule {
    internal static ExceptionValidationRule Instance;
    private static ExceptionValidationRule();
    public virtual ValidationResult Validate(object value, CultureInfo cultureInfo);
}
public enum System.Windows.Controls.ExpandDirection : Enum {
    public int value__;
    public static ExpandDirection Down;
    public static ExpandDirection Up;
    public static ExpandDirection Left;
    public static ExpandDirection Right;
}
[LocalizabilityAttribute("0")]
public class System.Windows.Controls.Expander : HeaderedContentControl {
    public static DependencyProperty ExpandDirectionProperty;
    public static DependencyProperty IsExpandedProperty;
    public static RoutedEvent ExpandedEvent;
    public static RoutedEvent CollapsedEvent;
    private static string ExpanderToggleButtonTemplateName;
    private ToggleButton _expanderToggleButton;
    private static DependencyObjectType _dType;
    [BindableAttribute("True")]
[CategoryAttribute("Behavior")]
public ExpandDirection ExpandDirection { get; public set; }
    [BindableAttribute("True")]
[CategoryAttribute("Appearance")]
public bool IsExpanded { get; public set; }
    internal bool IsExpanderToggleButtonFocused { get; }
    internal ToggleButton ExpanderToggleButton { get; }
    internal DependencyObjectType DTypeThemeStyleKey { get; }
    private static Expander();
    public ExpandDirection get_ExpandDirection();
    public void set_ExpandDirection(ExpandDirection value);
    private static bool IsValidExpandDirection(object o);
    private static void OnIsExpandedChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public bool get_IsExpanded();
    public void set_IsExpanded(bool value);
    public void add_Expanded(RoutedEventHandler value);
    public void remove_Expanded(RoutedEventHandler value);
    public void add_Collapsed(RoutedEventHandler value);
    public void remove_Collapsed(RoutedEventHandler value);
    internal virtual void ChangeVisualState(bool useTransitions);
    protected virtual void OnExpanded();
    protected virtual void OnCollapsed();
    protected virtual AutomationPeer OnCreateAutomationPeer();
    public virtual void OnApplyTemplate();
    internal bool get_IsExpanderToggleButtonFocused();
    internal ToggleButton get_ExpanderToggleButton();
    internal virtual DependencyObjectType get_DTypeThemeStyleKey();
}
internal class System.Windows.Controls.FindToolTipEventArgs : RoutedEventArgs {
    private DependencyObject _targetElement;
    private bool _keepCurrentActive;
    private ToolTipTrigger _triggerAction;
    internal DependencyObject TargetElement { get; internal set; }
    internal bool KeepCurrentActive { get; internal set; }
    internal ToolTipTrigger TriggerAction { get; }
    internal FindToolTipEventArgs(ToolTipTrigger triggerAction);
    internal DependencyObject get_TargetElement();
    internal void set_TargetElement(DependencyObject value);
    internal bool get_KeepCurrentActive();
    internal void set_KeepCurrentActive(bool value);
    internal ToolTipTrigger get_TriggerAction();
    protected virtual void InvokeEventHandler(Delegate genericHandler, object genericTarget);
}
internal class System.Windows.Controls.FindToolTipEventHandler : MulticastDelegate {
    public FindToolTipEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, FindToolTipEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, FindToolTipEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[TemplatePartAttribute]
public class System.Windows.Controls.FlowDocumentPageViewer : DocumentViewerBase {
    public static DependencyProperty ZoomProperty;
    public static DependencyProperty MaxZoomProperty;
    public static DependencyProperty MinZoomProperty;
    public static DependencyProperty ZoomIncrementProperty;
    protected static DependencyPropertyKey CanIncreaseZoomPropertyKey;
    public static DependencyProperty CanIncreaseZoomProperty;
    protected static DependencyPropertyKey CanDecreaseZoomPropertyKey;
    public static DependencyProperty CanDecreaseZoomProperty;
    public static DependencyProperty SelectionBrushProperty;
    public static DependencyProperty SelectionOpacityProperty;
    public static DependencyProperty IsSelectionActiveProperty;
    public static DependencyProperty IsInactiveSelectionHighlightEnabledProperty;
    private Decorator _findToolBarHost;
    private ContentPosition _contentPosition;
    private FlowDocumentPrintingState _printingState;
    private IDocumentPaginatorSource _oldDocument;
    private object _bringContentPositionIntoViewToken;
    private static string _findToolBarHostTemplateName;
    private static DependencyObjectType _dType;
    public TextSelection Selection { get; }
    public double Zoom { get; public set; }
    public double MaxZoom { get; public set; }
    public double MinZoom { get; public set; }
    public double ZoomIncrement { get; public set; }
    public bool CanIncreaseZoom { get; }
    public bool CanDecreaseZoom { get; }
    public Brush SelectionBrush { get; public set; }
    public double SelectionOpacity { get; public set; }
    public bool IsSelectionActive { get; }
    public bool IsInactiveSelectionHighlightEnabled { get; public set; }
    internal ContentPosition ContentPosition { get; }
    internal bool CanShowFindToolBar { get; }
    internal bool IsPrinting { get; }
    private FindToolBar FindToolBar { get; }
    internal DependencyObjectType DTypeThemeStyleKey { get; }
    private static FlowDocumentPageViewer();
    public virtual void OnApplyTemplate();
    public void IncreaseZoom();
    public void DecreaseZoom();
    public void Find();
    public TextSelection get_Selection();
    public double get_Zoom();
    public void set_Zoom(double value);
    public double get_MaxZoom();
    public void set_MaxZoom(double value);
    public double get_MinZoom();
    public void set_MinZoom(double value);
    public double get_ZoomIncrement();
    public void set_ZoomIncrement(double value);
    public virtual bool get_CanIncreaseZoom();
    public virtual bool get_CanDecreaseZoom();
    public Brush get_SelectionBrush();
    public void set_SelectionBrush(Brush value);
    public double get_SelectionOpacity();
    public void set_SelectionOpacity(double value);
    public bool get_IsSelectionActive();
    public bool get_IsInactiveSelectionHighlightEnabled();
    public void set_IsInactiveSelectionHighlightEnabled(bool value);
    protected virtual AutomationPeer OnCreateAutomationPeer();
    protected virtual void OnKeyDown(KeyEventArgs e);
    protected virtual void OnMouseWheel(MouseWheelEventArgs e);
    protected virtual void OnContextMenuOpening(ContextMenuEventArgs e);
    protected virtual void OnPageViewsChanged();
    protected virtual void OnDocumentChanged();
    protected virtual void OnPrintCompleted();
    protected virtual void OnPreviousPageCommand();
    protected virtual void OnNextPageCommand();
    protected virtual void OnFirstPageCommand();
    protected virtual void OnLastPageCommand();
    protected virtual void OnGoToPageCommand(int pageNumber);
    protected virtual void OnFindCommand();
    protected virtual void OnPrintCommand();
    protected virtual void OnCancelPrintCommand();
    protected virtual void OnIncreaseZoomCommand();
    protected virtual void OnDecreaseZoomCommand();
    internal virtual bool BuildRouteCore(EventRoute route, RoutedEventArgs args);
    internal virtual bool InvalidateAutomationAncestorsCore(Stack`1<DependencyObject> branchNodeStack, Boolean& continuePastCoreTree);
    internal bool BringPointIntoView(Point point);
    internal object BringContentPositionIntoView(object arg);
    internal ContentPosition get_ContentPosition();
    internal bool get_CanShowFindToolBar();
    internal bool get_IsPrinting();
    private void HandleLayoutUpdated(object sender, EventArgs e);
    private void HandleGetPageNumberCompleted(object sender, GetPageNumberCompletedEventArgs e);
    private void HandleAllBreakRecordsInvalidated(object sender, EventArgs e);
    private bool IsValidContentPositionForDocument(IDocumentPaginatorSource document, ContentPosition contentPosition);
    private void PrivateBringContentPositionIntoView(object arg, bool isAsyncRequest);
    private void HandlePrintCompleted(object sender, WritingCompletedEventArgs e);
    private void HandlePrintCancelled(object sender, WritingCancelledEventArgs e);
    private void ClearPrintingState();
    private void ApplyZoom();
    private void ToggleFindToolBar(bool enable);
    private void OnFindInvoked(object sender, EventArgs e);
    private void ZoomChanged(double oldValue, double newValue);
    private void UpdateCanIncreaseZoom();
    private void UpdateCanDecreaseZoom();
    private void MaxZoomChanged(double oldValue, double newValue);
    private void MinZoomChanged(double oldValue, double newValue);
    private static void CreateCommandBindings();
    private static void CanExecuteRoutedEventHandler(object target, CanExecuteRoutedEventArgs args);
    private static void ExecutedRoutedEventHandler(object target, ExecutedRoutedEventArgs args);
    private void PreviewCanExecuteRoutedEventHandler(object target, CanExecuteRoutedEventArgs args);
    private static void KeyDownHandler(object sender, KeyEventArgs e);
    private static object CoerceZoom(DependencyObject d, object value);
    private static object CoerceMaxZoom(DependencyObject d, object value);
    private static void ZoomChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void MaxZoomChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void MinZoomChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static bool ZoomValidateValue(object o);
    private static void UpdateCaretElement(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private FindToolBar get_FindToolBar();
    private sealed virtual override CustomJournalStateInternal MS.Internal.AppModel.IJournalState.GetJournalState(JournalReason journalReason);
    private sealed virtual override void MS.Internal.AppModel.IJournalState.RestoreJournalState(CustomJournalStateInternal state);
    internal virtual DependencyObjectType get_DTypeThemeStyleKey();
}
[ContentPropertyAttribute("Document")]
[TemplatePartAttribute]
[TemplatePartAttribute]
public class System.Windows.Controls.FlowDocumentReader : Control {
    public static DependencyProperty ViewingModeProperty;
    public static DependencyProperty IsPageViewEnabledProperty;
    public static DependencyProperty IsTwoPageViewEnabledProperty;
    public static DependencyProperty IsScrollViewEnabledProperty;
    private static DependencyPropertyKey PageCountPropertyKey;
    public static DependencyProperty PageCountProperty;
    private static DependencyPropertyKey PageNumberPropertyKey;
    public static DependencyProperty PageNumberProperty;
    private static DependencyPropertyKey CanGoToPreviousPagePropertyKey;
    public static DependencyProperty CanGoToPreviousPageProperty;
    private static DependencyPropertyKey CanGoToNextPagePropertyKey;
    public static DependencyProperty CanGoToNextPageProperty;
    public static DependencyProperty IsFindEnabledProperty;
    public static DependencyProperty IsPrintEnabledProperty;
    public static DependencyProperty DocumentProperty;
    public static DependencyProperty ZoomProperty;
    public static DependencyProperty MaxZoomProperty;
    public static DependencyProperty MinZoomProperty;
    public static DependencyProperty ZoomIncrementProperty;
    private static DependencyPropertyKey CanIncreaseZoomPropertyKey;
    public static DependencyProperty CanIncreaseZoomProperty;
    private static DependencyPropertyKey CanDecreaseZoomPropertyKey;
    public static DependencyProperty CanDecreaseZoomProperty;
    public static DependencyProperty SelectionBrushProperty;
    public static DependencyProperty SelectionOpacityProperty;
    public static DependencyProperty IsSelectionActiveProperty;
    public static DependencyProperty IsInactiveSelectionHighlightEnabledProperty;
    public static RoutedUICommand SwitchViewingModeCommand;
    private Decorator _contentHost;
    private Decorator _findToolBarHost;
    private ToggleButton _findButton;
    private ReaderPageViewer _pageViewer;
    private ReaderTwoPageViewer _twoPageViewer;
    private ReaderScrollViewer _scrollViewer;
    private bool _documentAsLogicalChild;
    private bool _printInProgress;
    private static string _contentHostTemplateName;
    private static string _findToolBarHostTemplateName;
    private static string _findButtonTemplateName;
    private static string KeySwitchViewingMode;
    private static string Switch_ViewingMode;
    private static DependencyObjectType _dType;
    private static ComponentResourceKey _pageViewStyleKey;
    private static ComponentResourceKey _twoPageViewStyleKey;
    private static ComponentResourceKey _scrollViewStyleKey;
    public FlowDocumentReaderViewingMode ViewingMode { get; public set; }
    public TextSelection Selection { get; }
    public bool IsPageViewEnabled { get; public set; }
    public bool IsTwoPageViewEnabled { get; public set; }
    public bool IsScrollViewEnabled { get; public set; }
    public int PageCount { get; }
    public int PageNumber { get; }
    public bool CanGoToPreviousPage { get; }
    public bool CanGoToNextPage { get; }
    public bool IsFindEnabled { get; public set; }
    public bool IsPrintEnabled { get; public set; }
    public FlowDocument Document { get; public set; }
    public double Zoom { get; public set; }
    public double MaxZoom { get; public set; }
    public double MinZoom { get; public set; }
    public double ZoomIncrement { get; public set; }
    public bool CanIncreaseZoom { get; }
    public bool CanDecreaseZoom { get; }
    public Brush SelectionBrush { get; public set; }
    public double SelectionOpacity { get; public set; }
    public bool IsSelectionActive { get; }
    public bool IsInactiveSelectionHighlightEnabled { get; public set; }
    protected internal IEnumerator LogicalChildren { get; }
    private bool CanShowFindToolBar { get; }
    private TextEditor TextEditor { get; }
    private FindToolBar FindToolBar { get; }
    private IFlowDocumentViewer CurrentViewer { get; }
    internal DependencyObjectType DTypeThemeStyleKey { get; }
    private static ResourceKey PageViewStyleKey { get; }
    private static ResourceKey TwoPageViewStyleKey { get; }
    private static ResourceKey ScrollViewStyleKey { get; }
    private static FlowDocumentReader();
    public virtual void OnApplyTemplate();
    public bool CanGoToPage(int pageNumber);
    public void Find();
    public void Print();
    public void CancelPrint();
    public void IncreaseZoom();
    public void DecreaseZoom();
    public void SwitchViewingMode(FlowDocumentReaderViewingMode viewingMode);
    public FlowDocumentReaderViewingMode get_ViewingMode();
    public void set_ViewingMode(FlowDocumentReaderViewingMode value);
    public TextSelection get_Selection();
    public bool get_IsPageViewEnabled();
    public void set_IsPageViewEnabled(bool value);
    public bool get_IsTwoPageViewEnabled();
    public void set_IsTwoPageViewEnabled(bool value);
    public bool get_IsScrollViewEnabled();
    public void set_IsScrollViewEnabled(bool value);
    public int get_PageCount();
    public int get_PageNumber();
    public bool get_CanGoToPreviousPage();
    public bool get_CanGoToNextPage();
    public bool get_IsFindEnabled();
    public void set_IsFindEnabled(bool value);
    public bool get_IsPrintEnabled();
    public void set_IsPrintEnabled(bool value);
    public FlowDocument get_Document();
    public void set_Document(FlowDocument value);
    public double get_Zoom();
    public void set_Zoom(double value);
    public double get_MaxZoom();
    public void set_MaxZoom(double value);
    public double get_MinZoom();
    public void set_MinZoom(double value);
    public double get_ZoomIncrement();
    public void set_ZoomIncrement(double value);
    public bool get_CanIncreaseZoom();
    public bool get_CanDecreaseZoom();
    public Brush get_SelectionBrush();
    public void set_SelectionBrush(Brush value);
    public double get_SelectionOpacity();
    public void set_SelectionOpacity(double value);
    public bool get_IsSelectionActive();
    public bool get_IsInactiveSelectionHighlightEnabled();
    public void set_IsInactiveSelectionHighlightEnabled(bool value);
    protected virtual void OnPrintCompleted();
    protected virtual void OnFindCommand();
    protected virtual void OnPrintCommand();
    protected virtual void OnCancelPrintCommand();
    protected virtual void OnIncreaseZoomCommand();
    protected virtual void OnDecreaseZoomCommand();
    protected virtual void OnSwitchViewingModeCommand(FlowDocumentReaderViewingMode viewingMode);
    protected virtual void OnInitialized(EventArgs e);
    protected virtual void OnDpiChanged(DpiScale oldDpiScaleInfo, DpiScale newDpiScaleInfo);
    protected virtual AutomationPeer OnCreateAutomationPeer();
    protected virtual void OnIsKeyboardFocusWithinChanged(DependencyPropertyChangedEventArgs e);
    protected virtual void OnKeyDown(KeyEventArgs e);
    protected internal virtual IEnumerator get_LogicalChildren();
    internal virtual bool BuildRouteCore(EventRoute route, RoutedEventArgs args);
    internal virtual bool InvalidateAutomationAncestorsCore(Stack`1<DependencyObject> branchNodeStack, Boolean& continuePastCoreTree);
    protected virtual void SwitchViewingModeCore(FlowDocumentReaderViewingMode viewingMode);
    private bool IsFocusWithinDocument();
    private void DocumentChanged(FlowDocument oldDocument, FlowDocument newDocument);
    private void DetachViewer(IFlowDocumentViewer viewer);
    private void AttachViewer(IFlowDocumentViewer viewer);
    private void CreateTwoWayBinding(FrameworkElement fe, DependencyProperty dp, string propertyPath);
    private bool CanSwitchToViewingMode(FlowDocumentReaderViewingMode mode);
    private IFlowDocumentViewer GetViewerFromMode(FlowDocumentReaderViewingMode mode);
    private void UpdateReadOnlyProperties(bool pageCountChanged, bool pageNumberChanged);
    private void OnPageCountChanged(object sender, EventArgs e);
    private void OnPageNumberChanged(object sender, EventArgs e);
    private void OnViewerPrintStarted(object sender, EventArgs e);
    private void OnViewerPrintCompleted(object sender, EventArgs e);
    private bool ConvertToViewingMode(object value, FlowDocumentReaderViewingMode& mode);
    private void ToggleFindToolBar(bool enable);
    private static void CreateCommandBindings();
    private static void CanExecuteRoutedEventHandler(object target, CanExecuteRoutedEventArgs args);
    private static void ExecutedRoutedEventHandler(object target, ExecutedRoutedEventArgs args);
    private void TrySwitchViewingMode(object parameter);
    private void OnPreviousPageCommand();
    private void OnNextPageCommand();
    private void OnFirstPageCommand();
    private void OnLastPageCommand();
    private void OnFindInvoked(object sender, EventArgs e);
    private void PreviewCanExecuteRoutedEventHandler(object target, CanExecuteRoutedEventArgs args);
    private static void KeyDownHandler(object sender, KeyEventArgs e);
    private static void ViewingModeChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static bool IsValidViewingMode(object o);
    private static void ViewingModeEnabledChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void IsFindEnabledChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void IsPrintEnabledChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void DocumentChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void ZoomChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static object CoerceZoom(DependencyObject d, object value);
    private static void MaxZoomChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static object CoerceMaxZoom(DependencyObject d, object value);
    private static void MinZoomChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static bool ZoomValidateValue(object o);
    private static void UpdateCaretElement(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private bool get_CanShowFindToolBar();
    private TextEditor get_TextEditor();
    private FindToolBar get_FindToolBar();
    private IFlowDocumentViewer get_CurrentViewer();
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object value);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string text);
    private sealed virtual override CustomJournalStateInternal MS.Internal.AppModel.IJournalState.GetJournalState(JournalReason journalReason);
    private sealed virtual override void MS.Internal.AppModel.IJournalState.RestoreJournalState(CustomJournalStateInternal state);
    internal virtual DependencyObjectType get_DTypeThemeStyleKey();
    private static ResourceKey get_PageViewStyleKey();
    private static ResourceKey get_TwoPageViewStyleKey();
    private static ResourceKey get_ScrollViewStyleKey();
}
public enum System.Windows.Controls.FlowDocumentReaderViewingMode : Enum {
    public int value__;
    public static FlowDocumentReaderViewingMode Page;
    public static FlowDocumentReaderViewingMode TwoPage;
    public static FlowDocumentReaderViewingMode Scroll;
}
[TemplatePartAttribute]
[TemplatePartAttribute]
[TemplatePartAttribute]
[ContentPropertyAttribute("Document")]
public class System.Windows.Controls.FlowDocumentScrollViewer : Control {
    public static DependencyProperty DocumentProperty;
    public static DependencyProperty ZoomProperty;
    public static DependencyProperty MaxZoomProperty;
    public static DependencyProperty MinZoomProperty;
    public static DependencyProperty ZoomIncrementProperty;
    private static DependencyPropertyKey CanIncreaseZoomPropertyKey;
    public static DependencyProperty CanIncreaseZoomProperty;
    private static DependencyPropertyKey CanDecreaseZoomPropertyKey;
    public static DependencyProperty CanDecreaseZoomProperty;
    public static DependencyProperty IsSelectionEnabledProperty;
    public static DependencyProperty IsToolBarVisibleProperty;
    public static DependencyProperty HorizontalScrollBarVisibilityProperty;
    public static DependencyProperty VerticalScrollBarVisibilityProperty;
    public static DependencyProperty SelectionBrushProperty;
    public static DependencyProperty SelectionOpacityProperty;
    public static DependencyProperty IsSelectionActiveProperty;
    public static DependencyProperty IsInactiveSelectionHighlightEnabledProperty;
    private TextEditor _textEditor;
    private Decorator _findToolBarHost;
    private Decorator _toolBarHost;
    private ScrollViewer _contentHost;
    private bool _documentAsLogicalChild;
    private FlowDocumentPrintingState _printingState;
    private static string _contentHostTemplateName;
    private static string _findToolBarHostTemplateName;
    private static string _toolBarHostTemplateName;
    private static bool IsEditingEnabled;
    private static RoutedUICommand _commandLineDown;
    private static RoutedUICommand _commandLineUp;
    private static RoutedUICommand _commandLineLeft;
    private static RoutedUICommand _commandLineRight;
    private static DependencyObjectType _dType;
    public FlowDocument Document { get; public set; }
    public TextSelection Selection { get; }
    public double Zoom { get; public set; }
    public double MaxZoom { get; public set; }
    public double MinZoom { get; public set; }
    public double ZoomIncrement { get; public set; }
    public bool CanIncreaseZoom { get; }
    public bool CanDecreaseZoom { get; }
    public bool IsSelectionEnabled { get; public set; }
    public bool IsToolBarVisible { get; public set; }
    public ScrollBarVisibility HorizontalScrollBarVisibility { get; public set; }
    public ScrollBarVisibility VerticalScrollBarVisibility { get; public set; }
    public Brush SelectionBrush { get; public set; }
    public double SelectionOpacity { get; public set; }
    public bool IsSelectionActive { get; }
    public bool IsInactiveSelectionHighlightEnabled { get; public set; }
    protected internal IEnumerator LogicalChildren { get; }
    internal ScrollViewer ScrollViewer { get; }
    internal bool CanShowFindToolBar { get; }
    internal bool IsPrinting { get; }
    internal TextPointer ContentPosition { get; }
    private FindToolBar FindToolBar { get; }
    private FlowDocumentView RenderScope { get; }
    internal DependencyObjectType DTypeThemeStyleKey { get; }
    private static FlowDocumentScrollViewer();
    public virtual void OnApplyTemplate();
    public void Find();
    public void Print();
    public void CancelPrint();
    public void IncreaseZoom();
    public void DecreaseZoom();
    public FlowDocument get_Document();
    public void set_Document(FlowDocument value);
    public TextSelection get_Selection();
    public double get_Zoom();
    public void set_Zoom(double value);
    public double get_MaxZoom();
    public void set_MaxZoom(double value);
    public double get_MinZoom();
    public void set_MinZoom(double value);
    public double get_ZoomIncrement();
    public void set_ZoomIncrement(double value);
    public bool get_CanIncreaseZoom();
    public bool get_CanDecreaseZoom();
    public bool get_IsSelectionEnabled();
    public void set_IsSelectionEnabled(bool value);
    public bool get_IsToolBarVisible();
    public void set_IsToolBarVisible(bool value);
    public ScrollBarVisibility get_HorizontalScrollBarVisibility();
    public void set_HorizontalScrollBarVisibility(ScrollBarVisibility value);
    public ScrollBarVisibility get_VerticalScrollBarVisibility();
    public void set_VerticalScrollBarVisibility(ScrollBarVisibility value);
    public Brush get_SelectionBrush();
    public void set_SelectionBrush(Brush value);
    public double get_SelectionOpacity();
    public void set_SelectionOpacity(double value);
    public bool get_IsSelectionActive();
    public bool get_IsInactiveSelectionHighlightEnabled();
    public void set_IsInactiveSelectionHighlightEnabled(bool value);
    protected virtual void OnPrintCompleted();
    protected virtual void OnFindCommand();
    protected virtual void OnPrintCommand();
    protected virtual void OnCancelPrintCommand();
    protected virtual void OnIncreaseZoomCommand();
    protected virtual void OnDecreaseZoomCommand();
    protected virtual void OnKeyDown(KeyEventArgs e);
    protected virtual void OnMouseWheel(MouseWheelEventArgs e);
    protected virtual void OnContextMenuOpening(ContextMenuEventArgs e);
    protected virtual AutomationPeer OnCreateAutomationPeer();
    protected internal virtual IEnumerator get_LogicalChildren();
    internal virtual bool BuildRouteCore(EventRoute route, RoutedEventArgs args);
    internal virtual bool InvalidateAutomationAncestorsCore(Stack`1<DependencyObject> branchNodeStack, Boolean& continuePastCoreTree);
    internal object BringContentPositionIntoView(object arg);
    internal ScrollViewer get_ScrollViewer();
    internal bool get_CanShowFindToolBar();
    internal bool get_IsPrinting();
    internal TextPointer get_ContentPosition();
    private void ToggleFindToolBar(bool enable);
    private void ApplyZoom();
    private void AttachTextEditor();
    private void OnScrollChanged(object sender, ScrollChangedEventArgs e);
    private void HandlePrintCompleted(object sender, WritingCompletedEventArgs e);
    private void HandlePrintCancelled(object sender, WritingCancelledEventArgs e);
    private void ClearPrintingState();
    private void HandleRequestBringIntoView(RequestBringIntoViewEventArgs args);
    private void DocumentChanged(FlowDocument oldDocument, FlowDocument newDocument);
    private ITextView GetTextView();
    private IContentHost GetIContentHost();
    private void CreateTwoWayBinding(FrameworkElement fe, DependencyProperty dp, string propertyPath);
    private static void CreateCommandBindings();
    private static void CanExecuteRoutedEventHandler(object target, CanExecuteRoutedEventArgs args);
    private static void ExecutedRoutedEventHandler(object target, ExecutedRoutedEventArgs args);
    private void OnFindInvoked(object sender, EventArgs e);
    private void PreviewCanExecuteRoutedEventHandler(object target, CanExecuteRoutedEventArgs args);
    private static void KeyDownHandler(object sender, KeyEventArgs e);
    private static Rect MakeVisible(IScrollInfo scrollInfo, Visual visual, Rect rectangle);
    private static void DocumentChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void ZoomChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static object CoerceZoom(DependencyObject d, object value);
    private static void MaxZoomChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static object CoerceMaxZoom(DependencyObject d, object value);
    private static void MinZoomChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static bool ZoomValidateValue(object o);
    private static void HandleRequestBringIntoView(object sender, RequestBringIntoViewEventArgs args);
    private static void IsSelectionEnabledChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void IsToolBarVisibleChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void UpdateCaretElement(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private FindToolBar get_FindToolBar();
    private FlowDocumentView get_RenderScope();
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object value);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string text);
    private sealed virtual override object System.IServiceProvider.GetService(Type serviceType);
    private sealed virtual override CustomJournalStateInternal MS.Internal.AppModel.IJournalState.GetJournalState(JournalReason journalReason);
    private sealed virtual override void MS.Internal.AppModel.IJournalState.RestoreJournalState(CustomJournalStateInternal state);
    internal virtual DependencyObjectType get_DTypeThemeStyleKey();
}
[DefaultPropertyAttribute("Source")]
[DefaultEventAttribute("Navigated")]
[LocalizabilityAttribute("16")]
[ContentPropertyAttribute]
[TemplatePartAttribute]
public class System.Windows.Controls.Frame : ContentControl {
    [CompilerGeneratedAttribute]
private EventHandler ContentRendered;
    public static DependencyProperty SourceProperty;
    public static DependencyProperty CanGoBackProperty;
    public static DependencyProperty CanGoForwardProperty;
    public static DependencyProperty BackStackProperty;
    public static DependencyProperty ForwardStackProperty;
    public static DependencyProperty NavigationUIVisibilityProperty;
    public static DependencyProperty SandboxExternalContentProperty;
    public static DependencyProperty JournalOwnershipProperty;
    private bool _postContentRenderedFromLoadedHandler;
    private DispatcherOperation _contentRenderedCallback;
    private NavigationService _navigationService;
    private bool _sourceUpdatedFromNavService;
    private JournalOwnership _journalOwnership;
    private JournalNavigationScope _ownJournalScope;
    private List`1<CommandBinding> _commandBindings;
    private static DependencyObjectType _dType;
    private Uri System.Windows.Markup.IUriContext.BaseUri { get; private set; }
    protected Uri BaseUri { get; protected set; }
    private NavigationService MS.Internal.AppModel.IDownloader.Downloader { get; }
    [BindableAttribute("True")]
[CustomCategoryAttribute("Navigation")]
public Uri Source { get; public set; }
    public NavigationUIVisibility NavigationUIVisibility { get; public set; }
    public bool SandboxExternalContent { get; public set; }
    public JournalOwnership JournalOwnership { get; public set; }
    public NavigationService NavigationService { get; }
    public bool CanGoForward { get; }
    public bool CanGoBack { get; }
    public Uri CurrentSource { get; }
    public IEnumerable BackStack { get; }
    public IEnumerable ForwardStack { get; }
    internal DependencyObjectType DTypeThemeStyleKey { get; }
    private static Frame();
    private static object CoerceContent(DependencyObject d, object value);
    private void Init();
    private sealed virtual override Uri System.Windows.Markup.IUriContext.get_BaseUri();
    private sealed virtual override void System.Windows.Markup.IUriContext.set_BaseUri(Uri value);
    protected virtual Uri get_BaseUri();
    protected virtual void set_BaseUri(Uri value);
    private sealed virtual override NavigationService MS.Internal.AppModel.IDownloader.get_Downloader();
    [CompilerGeneratedAttribute]
public sealed virtual void add_ContentRendered(EventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_ContentRendered(EventHandler value);
    protected virtual void OnContentRendered(EventArgs args);
    private static object CoerceSource(DependencyObject d, object value);
    private static void OnSourcePropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private sealed virtual override void MS.Internal.AppModel.INavigatorImpl.OnSourceUpdatedFromNavService(bool journalOrCancel);
    public sealed virtual Uri get_Source();
    public sealed virtual void set_Source(Uri value);
    public NavigationUIVisibility get_NavigationUIVisibility();
    public void set_NavigationUIVisibility(NavigationUIVisibility value);
    public bool get_SandboxExternalContent();
    public void set_SandboxExternalContent(bool value);
    private static void OnSandboxExternalContentPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static object CoerceSandBoxExternalContentValue(DependencyObject d, object value);
    private static bool ValidateJournalOwnershipValue(object value);
    private static void OnJournalOwnershipPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private void OnJournalOwnershipPropertyChanged(JournalOwnership newValue);
    private static object CoerceJournalOwnership(DependencyObject d, object newValue);
    public JournalOwnership get_JournalOwnership();
    public void set_JournalOwnership(JournalOwnership value);
    public sealed virtual NavigationService get_NavigationService();
    protected virtual AutomationPeer OnCreateAutomationPeer();
    protected virtual void AddChild(object value);
    protected virtual void AddText(string text);
    private void _OnBPReady(object o, BPReadyEventArgs e);
    private void LoadedHandler(object sender, RoutedEventArgs args);
    private void PostContentRendered();
    private void OnQueryGoBack(object sender, CanExecuteRoutedEventArgs e);
    private void OnGoBack(object sender, ExecutedRoutedEventArgs e);
    private void OnQueryGoForward(object sender, CanExecuteRoutedEventArgs e);
    private void OnGoForward(object sender, ExecutedRoutedEventArgs e);
    private void OnNavigateJournal(object sender, ExecutedRoutedEventArgs e);
    private void OnQueryRefresh(object sender, CanExecuteRoutedEventArgs e);
    private void OnRefresh(object sender, ExecutedRoutedEventArgs e);
    private void OnBrowseStop(object sender, ExecutedRoutedEventArgs e);
    internal virtual object AdjustEventSource(RoutedEventArgs e);
    internal virtual string GetPlainText();
    [EditorBrowsableAttribute("1")]
public virtual bool ShouldSerializeContent();
    private static void OnParentNavigationServiceChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public virtual void OnApplyTemplate();
    private sealed virtual override Visual MS.Internal.AppModel.INavigatorImpl.FindRootViewer();
    private sealed virtual override JournalNavigationScope MS.Internal.AppModel.INavigator.GetJournal(bool create);
    private JournalNavigationScope GetJournal(bool create);
    public sealed virtual bool get_CanGoForward();
    public sealed virtual bool get_CanGoBack();
    public sealed virtual void AddBackEntry(CustomContentState state);
    public sealed virtual JournalEntry RemoveBackEntry();
    public sealed virtual bool Navigate(Uri source);
    public sealed virtual bool Navigate(Uri source, object extraData);
    public sealed virtual bool Navigate(object content);
    public sealed virtual bool Navigate(object content, object extraData);
    public sealed virtual void GoForward();
    public sealed virtual void GoBack();
    public sealed virtual void StopLoading();
    public sealed virtual void Refresh();
    public sealed virtual Uri get_CurrentSource();
    public sealed virtual IEnumerable get_BackStack();
    public sealed virtual IEnumerable get_ForwardStack();
    public sealed virtual void add_Navigating(NavigatingCancelEventHandler value);
    public sealed virtual void remove_Navigating(NavigatingCancelEventHandler value);
    public sealed virtual void add_NavigationProgress(NavigationProgressEventHandler value);
    public sealed virtual void remove_NavigationProgress(NavigationProgressEventHandler value);
    public sealed virtual void add_NavigationFailed(NavigationFailedEventHandler value);
    public sealed virtual void remove_NavigationFailed(NavigationFailedEventHandler value);
    public sealed virtual void add_Navigated(NavigatedEventHandler value);
    public sealed virtual void remove_Navigated(NavigatedEventHandler value);
    public sealed virtual void add_LoadCompleted(LoadCompletedEventHandler value);
    public sealed virtual void remove_LoadCompleted(LoadCompletedEventHandler value);
    public sealed virtual void add_NavigationStopped(NavigationStoppedEventHandler value);
    public sealed virtual void remove_NavigationStopped(NavigationStoppedEventHandler value);
    public sealed virtual void add_FragmentNavigation(FragmentNavigationEventHandler value);
    public sealed virtual void remove_FragmentNavigation(FragmentNavigationEventHandler value);
    private sealed virtual override void MS.Internal.AppModel.IJournalNavigationScopeHost.VerifyContextAndObjectState();
    private sealed virtual override void MS.Internal.AppModel.IJournalNavigationScopeHost.OnJournalAvailable();
    private sealed virtual override bool MS.Internal.AppModel.IJournalNavigationScopeHost.GoBackOverride();
    private sealed virtual override bool MS.Internal.AppModel.IJournalNavigationScopeHost.GoForwardOverride();
    private sealed virtual override CustomJournalStateInternal MS.Internal.AppModel.IJournalState.GetJournalState(JournalReason journalReason);
    private sealed virtual override void MS.Internal.AppModel.IJournalState.RestoreJournalState(CustomJournalStateInternal cjs);
    internal virtual void OnPreApplyTemplate();
    internal virtual void OnThemeChanged();
    private JournalNavigationScope GetParentJournal(bool create);
    private void SwitchToOwnJournal();
    private void SwitchToParentJournal();
    private void AddCommandBinding(CommandBinding b);
    internal virtual DependencyObjectType get_DTypeThemeStyleKey();
    [CompilerGeneratedAttribute]
private object <PostContentRendered>b__52_0(object unused);
}
public class System.Windows.Controls.Grid : Panel {
    private ExtendedData _data;
    private Flags _flags;
    private GridLinesRenderer _gridLinesRenderer;
    private Int32[] _definitionIndices;
    private Double[] _roundingErrors;
    private static double c_epsilon;
    private static double c_starClip;
    private static int c_layoutLoopMaxCount;
    private static LocalDataStoreSlot s_tempDefinitionsDataSlot;
    private static IComparer s_spanPreferredDistributionOrderComparer;
    private static IComparer s_spanMaxDistributionOrderComparer;
    private static IComparer s_starDistributionOrderComparer;
    private static IComparer s_distributionOrderComparer;
    private static IComparer s_minRatioComparer;
    private static IComparer s_maxRatioComparer;
    private static IComparer s_starWeightComparer;
    public static DependencyProperty ShowGridLinesProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty ColumnProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty RowProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty ColumnSpanProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty RowSpanProperty;
    public static DependencyProperty IsSharedSizeScopeProperty;
    protected internal IEnumerator LogicalChildren { get; }
    public bool ShowGridLines { get; public set; }
    [DesignerSerializationVisibilityAttribute("2")]
public ColumnDefinitionCollection ColumnDefinitions { get; }
    [DesignerSerializationVisibilityAttribute("2")]
public RowDefinitionCollection RowDefinitions { get; }
    protected int VisualChildrenCount { get; }
    internal bool MeasureOverrideInProgress { get; internal set; }
    internal bool ArrangeOverrideInProgress { get; internal set; }
    internal bool ColumnDefinitionCollectionDirty { get; internal set; }
    internal bool RowDefinitionCollectionDirty { get; internal set; }
    private DefinitionBase[] DefinitionsU { get; }
    private DefinitionBase[] DefinitionsV { get; }
    private DefinitionBase[] TempDefinitions { get; }
    private Int32[] DefinitionIndices { get; }
    private Double[] RoundingErrors { get; }
    private CellCache[] PrivateCells { get; }
    private bool CellsStructureDirty { get; private set; }
    private bool ListenToNotifications { get; private set; }
    private bool SizeToContentU { get; private set; }
    private bool SizeToContentV { get; private set; }
    private bool HasStarCellsU { get; private set; }
    private bool HasStarCellsV { get; private set; }
    private bool HasGroup3CellsInAutoRows { get; private set; }
    private ExtendedData ExtData { get; }
    internal int EffectiveValuesInitialSize { get; }
    private static Grid();
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object value);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string text);
    protected internal virtual IEnumerator get_LogicalChildren();
    public static void SetColumn(UIElement element, int value);
    [AttachedPropertyBrowsableForChildrenAttribute]
public static int GetColumn(UIElement element);
    public static void SetRow(UIElement element, int value);
    [AttachedPropertyBrowsableForChildrenAttribute]
public static int GetRow(UIElement element);
    public static void SetColumnSpan(UIElement element, int value);
    [AttachedPropertyBrowsableForChildrenAttribute]
public static int GetColumnSpan(UIElement element);
    public static void SetRowSpan(UIElement element, int value);
    [AttachedPropertyBrowsableForChildrenAttribute]
public static int GetRowSpan(UIElement element);
    public static void SetIsSharedSizeScope(UIElement element, bool value);
    public static bool GetIsSharedSizeScope(UIElement element);
    public bool get_ShowGridLines();
    public void set_ShowGridLines(bool value);
    public ColumnDefinitionCollection get_ColumnDefinitions();
    public RowDefinitionCollection get_RowDefinitions();
    protected virtual Visual GetVisualChild(int index);
    protected virtual int get_VisualChildrenCount();
    protected virtual Size MeasureOverride(Size constraint);
    protected virtual Size ArrangeOverride(Size arrangeSize);
    protected internal virtual void OnVisualChildrenChanged(DependencyObject visualAdded, DependencyObject visualRemoved);
    internal void Invalidate();
    internal double GetFinalColumnDefinitionWidth(int columnIndex);
    internal double GetFinalRowDefinitionHeight(int rowIndex);
    internal bool get_MeasureOverrideInProgress();
    internal void set_MeasureOverrideInProgress(bool value);
    internal bool get_ArrangeOverrideInProgress();
    internal void set_ArrangeOverrideInProgress(bool value);
    internal bool get_ColumnDefinitionCollectionDirty();
    internal void set_ColumnDefinitionCollectionDirty(bool value);
    internal bool get_RowDefinitionCollectionDirty();
    internal void set_RowDefinitionCollectionDirty(bool value);
    private void ValidateCells();
    private void ValidateCellsCore();
    private void ValidateDefinitionsUStructure();
    private void ValidateDefinitionsVStructure();
    private void ValidateDefinitionsLayout(DefinitionBase[] definitions, bool treatStarAsAuto);
    private Double[] CacheMinSizes(int cellsHead, bool isRows);
    private void ApplyCachedMinSizes(Double[] minSizes, bool isRows);
    private void MeasureCellsGroup(int cellsHead, Size referenceSize, bool ignoreDesiredSizeU, bool forceInfinityV);
    private void MeasureCellsGroup(int cellsHead, Size referenceSize, bool ignoreDesiredSizeU, bool forceInfinityV, Boolean& hasDesiredSizeUChanged);
    private static void RegisterSpan(Hashtable& store, int start, int count, bool u, double value);
    private void MeasureCell(int cell, bool forceInfinityV);
    private double GetMeasureSizeForRange(DefinitionBase[] definitions, int start, int count);
    private LayoutTimeSizeType GetLengthTypeForRange(DefinitionBase[] definitions, int start, int count);
    private void EnsureMinSizeInDefinitionRange(DefinitionBase[] definitions, int start, int count, double requestedSize, double percentReferenceSize);
    private void ResolveStar(DefinitionBase[] definitions, double availableSize);
    private void ResolveStarLegacy(DefinitionBase[] definitions, double availableSize);
    private void ResolveStarMaxDiscrepancy(DefinitionBase[] definitions, double availableSize);
    private double CalculateDesiredSize(DefinitionBase[] definitions);
    private void SetFinalSize(DefinitionBase[] definitions, double finalSize, bool columns);
    private void SetFinalSizeLegacy(DefinitionBase[] definitions, double finalSize, bool columns);
    private void SetFinalSizeMaxDiscrepancy(DefinitionBase[] definitions, double finalSize, bool columns);
    private static Nullable`1<bool> Choose(double minRatio, double maxRatio, double proportion);
    private static int CompareRoundingErrors(KeyValuePair`2<int, double> x, KeyValuePair`2<int, double> y);
    private double GetFinalSizeForRange(DefinitionBase[] definitions, int start, int count);
    private void SetValid();
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeColumnDefinitions();
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeRowDefinitions();
    private GridLinesRenderer EnsureGridLinesRenderer();
    private void SetFlags(bool value, Flags flags);
    private bool CheckFlagsAnd(Flags flags);
    private bool CheckFlagsOr(Flags flags);
    private static void OnShowGridLinesPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void OnCellAttachedPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static bool IsIntValueNotNegative(object value);
    private static bool IsIntValueGreaterThanZero(object value);
    private static bool CompareNullRefs(object x, object y, Int32& result);
    private DefinitionBase[] get_DefinitionsU();
    private DefinitionBase[] get_DefinitionsV();
    private DefinitionBase[] get_TempDefinitions();
    private Int32[] get_DefinitionIndices();
    private Double[] get_RoundingErrors();
    private CellCache[] get_PrivateCells();
    private bool get_CellsStructureDirty();
    private void set_CellsStructureDirty(bool value);
    private bool get_ListenToNotifications();
    private void set_ListenToNotifications(bool value);
    private bool get_SizeToContentU();
    private void set_SizeToContentU(bool value);
    private bool get_SizeToContentV();
    private void set_SizeToContentV(bool value);
    private bool get_HasStarCellsU();
    private void set_HasStarCellsU(bool value);
    private bool get_HasStarCellsV();
    private void set_HasStarCellsV(bool value);
    private bool get_HasGroup3CellsInAutoRows();
    private void set_HasGroup3CellsInAutoRows(bool value);
    private static bool _IsZero(double d);
    private static bool _AreClose(double d1, double d2);
    private ExtendedData get_ExtData();
    private static double StarWeight(DefinitionBase def, double scale);
    internal virtual int get_EffectiveValuesInitialSize();
    [ConditionalAttribute("GRIDPARANOIA")]
internal void EnterCounterScope(Counters scopeCounter);
    [ConditionalAttribute("GRIDPARANOIA")]
internal void ExitCounterScope(Counters scopeCounter);
    [ConditionalAttribute("GRIDPARANOIA")]
internal void EnterCounter(Counters counter);
    [ConditionalAttribute("GRIDPARANOIA")]
internal void ExitCounter(Counters counter);
}
public enum System.Windows.Controls.GridResizeBehavior : Enum {
    public int value__;
    public static GridResizeBehavior BasedOnAlignment;
    public static GridResizeBehavior CurrentAndNext;
    public static GridResizeBehavior PreviousAndCurrent;
    public static GridResizeBehavior PreviousAndNext;
}
public enum System.Windows.Controls.GridResizeDirection : Enum {
    public int value__;
    public static GridResizeDirection Auto;
    public static GridResizeDirection Columns;
    public static GridResizeDirection Rows;
}
[StyleTypedPropertyAttribute]
public class System.Windows.Controls.GridSplitter : Thumb {
    public static DependencyProperty ResizeDirectionProperty;
    public static DependencyProperty ResizeBehaviorProperty;
    public static DependencyProperty ShowsPreviewProperty;
    public static DependencyProperty PreviewStyleProperty;
    public static DependencyProperty KeyboardIncrementProperty;
    public static DependencyProperty DragIncrementProperty;
    private ResizeData _resizeData;
    private static DependencyObjectType _dType;
    public GridResizeDirection ResizeDirection { get; public set; }
    public GridResizeBehavior ResizeBehavior { get; public set; }
    public bool ShowsPreview { get; public set; }
    public Style PreviewStyle { get; public set; }
    public double KeyboardIncrement { get; public set; }
    public double DragIncrement { get; public set; }
    internal DependencyObjectType DTypeThemeStyleKey { get; }
    private static GridSplitter();
    private static void UpdateCursor(DependencyObject o, DependencyPropertyChangedEventArgs e);
    private static object CoerceCursor(DependencyObject o, object value);
    public GridResizeDirection get_ResizeDirection();
    public void set_ResizeDirection(GridResizeDirection value);
    private static bool IsValidResizeDirection(object o);
    public GridResizeBehavior get_ResizeBehavior();
    public void set_ResizeBehavior(GridResizeBehavior value);
    private static bool IsValidResizeBehavior(object o);
    public bool get_ShowsPreview();
    public void set_ShowsPreview(bool value);
    public Style get_PreviewStyle();
    public void set_PreviewStyle(Style value);
    public double get_KeyboardIncrement();
    public void set_KeyboardIncrement(double value);
    private static bool IsValidDelta(object o);
    public double get_DragIncrement();
    public void set_DragIncrement(double value);
    protected virtual AutomationPeer OnCreateAutomationPeer();
    private GridResizeDirection GetEffectiveResizeDirection();
    private GridResizeBehavior GetEffectiveResizeBehavior(GridResizeDirection direction);
    protected internal virtual void OnRenderSizeChanged(SizeChangedInfo sizeInfo);
    private void RemovePreviewAdorner();
    private void InitializeData(bool ShowsPreview);
    private bool SetupDefinitionsToResize();
    private void SetupPreview();
    protected virtual void OnLostKeyboardFocus(KeyboardFocusChangedEventArgs e);
    private static void OnDragStarted(object sender, DragStartedEventArgs e);
    private void OnDragStarted(DragStartedEventArgs e);
    private static void OnDragDelta(object sender, DragDeltaEventArgs e);
    private void OnDragDelta(DragDeltaEventArgs e);
    private static void OnDragCompleted(object sender, DragCompletedEventArgs e);
    private void OnDragCompleted(DragCompletedEventArgs e);
    protected virtual void OnKeyDown(KeyEventArgs e);
    private void CancelResize();
    private static bool IsStar(DefinitionBase definition);
    private static DefinitionBase GetGridDefinition(Grid grid, int index, GridResizeDirection direction);
    private double GetActualLength(DefinitionBase definition);
    private static void SetDefinitionLength(DefinitionBase definition, GridLength length);
    private void GetDeltaConstraints(Double& minDelta, Double& maxDelta);
    private void SetLengths(double definition1Pixels, double definition2Pixels);
    private void MoveSplitter(double horizontalChange, double verticalChange);
    internal bool KeyboardMoveSplitter(double horizontalChange, double verticalChange);
    internal virtual DependencyObjectType get_DTypeThemeStyleKey();
}
[StyleTypedPropertyAttribute]
[ContentPropertyAttribute("Columns")]
public class System.Windows.Controls.GridView : ViewBase {
    public static DependencyProperty ColumnCollectionProperty;
    public static DependencyProperty ColumnHeaderContainerStyleProperty;
    public static DependencyProperty ColumnHeaderTemplateProperty;
    public static DependencyProperty ColumnHeaderTemplateSelectorProperty;
    public static DependencyProperty ColumnHeaderStringFormatProperty;
    public static DependencyProperty AllowsColumnReorderProperty;
    public static DependencyProperty ColumnHeaderContextMenuProperty;
    public static DependencyProperty ColumnHeaderToolTipProperty;
    private GridViewColumnCollection _columns;
    private GridViewHeaderRowPresenter _gvheaderRP;
    public static ResourceKey GridViewScrollViewerStyleKey { get; }
    public static ResourceKey GridViewStyleKey { get; }
    public static ResourceKey GridViewItemContainerStyleKey { get; }
    [DesignerSerializationVisibilityAttribute("2")]
public GridViewColumnCollection Columns { get; }
    public Style ColumnHeaderContainerStyle { get; public set; }
    public DataTemplate ColumnHeaderTemplate { get; public set; }
    [DesignerSerializationVisibilityAttribute("0")]
public DataTemplateSelector ColumnHeaderTemplateSelector { get; public set; }
    public string ColumnHeaderStringFormat { get; public set; }
    public bool AllowsColumnReorder { get; public set; }
    public ContextMenu ColumnHeaderContextMenu { get; public set; }
    public object ColumnHeaderToolTip { get; public set; }
    protected internal object DefaultStyleKey { get; }
    protected internal object ItemContainerDefaultStyleKey { get; }
    internal GridViewHeaderRowPresenter HeaderRowPresenter { get; internal set; }
    private static GridView();
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object column);
    protected virtual void AddChild(object column);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string text);
    protected virtual void AddText(string text);
    public virtual string ToString();
    protected internal virtual IViewAutomationPeer GetAutomationPeer(ListView parent);
    public static ResourceKey get_GridViewScrollViewerStyleKey();
    public static ResourceKey get_GridViewStyleKey();
    public static ResourceKey get_GridViewItemContainerStyleKey();
    public static GridViewColumnCollection GetColumnCollection(DependencyObject element);
    public static void SetColumnCollection(DependencyObject element, GridViewColumnCollection collection);
    [EditorBrowsableAttribute("1")]
public static bool ShouldSerializeColumnCollection(DependencyObject obj);
    public GridViewColumnCollection get_Columns();
    public Style get_ColumnHeaderContainerStyle();
    public void set_ColumnHeaderContainerStyle(Style value);
    public DataTemplate get_ColumnHeaderTemplate();
    public void set_ColumnHeaderTemplate(DataTemplate value);
    private static void OnColumnHeaderTemplateChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public DataTemplateSelector get_ColumnHeaderTemplateSelector();
    public void set_ColumnHeaderTemplateSelector(DataTemplateSelector value);
    private static void OnColumnHeaderTemplateSelectorChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public string get_ColumnHeaderStringFormat();
    public void set_ColumnHeaderStringFormat(string value);
    public bool get_AllowsColumnReorder();
    public void set_AllowsColumnReorder(bool value);
    public ContextMenu get_ColumnHeaderContextMenu();
    public void set_ColumnHeaderContextMenu(ContextMenu value);
    public object get_ColumnHeaderToolTip();
    public void set_ColumnHeaderToolTip(object value);
    protected internal virtual void PrepareItem(ListViewItem item);
    protected internal virtual void ClearItem(ListViewItem item);
    protected internal virtual object get_DefaultStyleKey();
    protected internal virtual object get_ItemContainerDefaultStyleKey();
    internal virtual void OnInheritanceContextChangedCore(EventArgs args);
    internal virtual void OnThemeChanged();
    internal GridViewHeaderRowPresenter get_HeaderRowPresenter();
    internal void set_HeaderRowPresenter(GridViewHeaderRowPresenter value);
}
[ContentPropertyAttribute("Header")]
[StyleTypedPropertyAttribute]
[LocalizabilityAttribute("0")]
public class System.Windows.Controls.GridViewColumn : DependencyObject {
    public static DependencyProperty HeaderProperty;
    public static DependencyProperty HeaderContainerStyleProperty;
    public static DependencyProperty HeaderTemplateProperty;
    public static DependencyProperty HeaderTemplateSelectorProperty;
    public static DependencyProperty HeaderStringFormatProperty;
    private BindingBase _displayMemberBinding;
    internal static string c_DisplayMemberBindingName;
    public static DependencyProperty CellTemplateProperty;
    public static DependencyProperty CellTemplateSelectorProperty;
    public static DependencyProperty WidthProperty;
    [CompilerGeneratedAttribute]
private PropertyChangedEventHandler _propertyChanged;
    internal static string c_ActualWidthName;
    private DependencyObject _inheritanceContext;
    private double _desiredWidth;
    private int _actualIndex;
    private double _actualWidth;
    private ColumnMeasureState _state;
    public object Header { get; public set; }
    public Style HeaderContainerStyle { get; public set; }
    public DataTemplate HeaderTemplate { get; public set; }
    [DesignerSerializationVisibilityAttribute("0")]
public DataTemplateSelector HeaderTemplateSelector { get; public set; }
    public string HeaderStringFormat { get; public set; }
    public BindingBase DisplayMemberBinding { get; public set; }
    public DataTemplate CellTemplate { get; public set; }
    [DesignerSerializationVisibilityAttribute("0")]
public DataTemplateSelector CellTemplateSelector { get; public set; }
    [TypeConverterAttribute("System.Windows.LengthConverter")]
public double Width { get; public set; }
    public double ActualWidth { get; private set; }
    internal ColumnMeasureState State { get; internal set; }
    internal int ActualIndex { get; internal set; }
    internal double DesiredWidth { get; private set; }
    internal DependencyObject InheritanceContext { get; }
    private static GridViewColumn();
    public virtual string ToString();
    public object get_Header();
    public void set_Header(object value);
    private static void OnHeaderChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public Style get_HeaderContainerStyle();
    public void set_HeaderContainerStyle(Style value);
    private static void OnHeaderContainerStyleChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public DataTemplate get_HeaderTemplate();
    public void set_HeaderTemplate(DataTemplate value);
    private static void OnHeaderTemplateChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public DataTemplateSelector get_HeaderTemplateSelector();
    public void set_HeaderTemplateSelector(DataTemplateSelector value);
    private static void OnHeaderTemplateSelectorChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public string get_HeaderStringFormat();
    public void set_HeaderStringFormat(string value);
    private static void OnHeaderStringFormatChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    protected virtual void OnHeaderStringFormatChanged(string oldHeaderStringFormat, string newHeaderStringFormat);
    public BindingBase get_DisplayMemberBinding();
    public void set_DisplayMemberBinding(BindingBase value);
    private void OnDisplayMemberBindingChanged();
    public DataTemplate get_CellTemplate();
    public void set_CellTemplate(DataTemplate value);
    private static void OnCellTemplateChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public DataTemplateSelector get_CellTemplateSelector();
    public void set_CellTemplateSelector(DataTemplateSelector value);
    private static void OnCellTemplateSelectorChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public double get_Width();
    public void set_Width(double value);
    private static void OnWidthChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public double get_ActualWidth();
    private void set_ActualWidth(double value);
    private sealed virtual override void System.ComponentModel.INotifyPropertyChanged.add_PropertyChanged(PropertyChangedEventHandler value);
    private sealed virtual override void System.ComponentModel.INotifyPropertyChanged.remove_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
private void add__propertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
private void remove__propertyChanged(PropertyChangedEventHandler value);
    protected virtual void OnPropertyChanged(PropertyChangedEventArgs e);
    internal void OnThemeChanged();
    internal double EnsureWidth(double width);
    internal void ResetPrivateData();
    internal ColumnMeasureState get_State();
    internal void set_State(ColumnMeasureState value);
    internal int get_ActualIndex();
    internal void set_ActualIndex(int value);
    internal double get_DesiredWidth();
    private void set_DesiredWidth(double value);
    internal virtual DependencyObject get_InheritanceContext();
    internal virtual void AddInheritanceContext(DependencyObject context, DependencyProperty property);
    internal virtual void RemoveInheritanceContext(DependencyObject context, DependencyProperty property);
    private void OnPropertyChanged(string propertyName);
    private void UpdateActualWidth();
}
public class System.Windows.Controls.GridViewColumnCollection : ObservableCollection`1<GridViewColumn> {
    private DependencyObject _owner;
    private bool _inViewMode;
    private List`1<GridViewColumn> _columns;
    private List`1<int> _actualIndices;
    private bool _isImmutable;
    [CompilerGeneratedAttribute]
private NotifyCollectionChangedEventHandler _internalCollectionChanged;
    private GridViewColumnCollectionChangedEventArgs _internalEventArg;
    internal List`1<GridViewColumn> ColumnCollection { get; }
    internal List`1<int> IndexList { get; }
    internal DependencyObject Owner { get; internal set; }
    internal bool InViewMode { get; internal set; }
    private bool IsImmutable { get; private set; }
    protected virtual void ClearItems();
    protected virtual void RemoveItem(int index);
    protected virtual void InsertItem(int index, GridViewColumn column);
    protected virtual void SetItem(int index, GridViewColumn column);
    protected virtual void MoveItem(int oldIndex, int newIndex);
    protected virtual void OnCollectionChanged(NotifyCollectionChangedEventArgs e);
    internal void add_InternalCollectionChanged(NotifyCollectionChangedEventHandler value);
    internal void remove_InternalCollectionChanged(NotifyCollectionChangedEventHandler value);
    internal void BlockWrite();
    internal void UnblockWrite();
    internal List`1<GridViewColumn> get_ColumnCollection();
    internal List`1<int> get_IndexList();
    internal DependencyObject get_Owner();
    internal void set_Owner(DependencyObject value);
    internal bool get_InViewMode();
    internal void set_InViewMode(bool value);
    private void OnInternalCollectionChanged();
    private void ColumnPropertyChanged(object sender, PropertyChangedEventArgs e);
    private GridViewColumnCollectionChangedEventArgs MovePreprocess(int oldIndex, int newIndex);
    private GridViewColumnCollectionChangedEventArgs ClearPreprocess();
    private GridViewColumnCollectionChangedEventArgs RemoveAtPreprocess(int index);
    private void UpdateIndexList(int actualIndex, int index);
    private void UpdateActualIndexInColumn(int iStart);
    private GridViewColumnCollectionChangedEventArgs InsertPreprocess(int index, GridViewColumn column);
    private GridViewColumnCollectionChangedEventArgs SetPreprocess(int index, GridViewColumn newColumn);
    private void VerifyIndexInRange(int index, string indexName);
    private void ValidateColumnForInsert(GridViewColumn column);
    private void VerifyAccess();
    private bool get_IsImmutable();
    private void set_IsImmutable(bool value);
    [CompilerGeneratedAttribute]
private void add__internalCollectionChanged(NotifyCollectionChangedEventHandler value);
    [CompilerGeneratedAttribute]
private void remove__internalCollectionChanged(NotifyCollectionChangedEventHandler value);
}
internal class System.Windows.Controls.GridViewColumnCollectionChangedEventArgs : NotifyCollectionChangedEventArgs {
    private int _actualIndex;
    private ReadOnlyCollection`1<GridViewColumn> _clearedColumns;
    private GridViewColumn _column;
    private string _propertyName;
    internal int ActualIndex { get; }
    internal ReadOnlyCollection`1<GridViewColumn> ClearedColumns { get; }
    internal GridViewColumn Column { get; }
    internal string PropertyName { get; }
    internal GridViewColumnCollectionChangedEventArgs(GridViewColumn column, string propertyName);
    internal GridViewColumnCollectionChangedEventArgs(NotifyCollectionChangedAction action, GridViewColumn[] clearedColumns);
    internal GridViewColumnCollectionChangedEventArgs(NotifyCollectionChangedAction action, GridViewColumn changedItem, int index, int actualIndex);
    internal GridViewColumnCollectionChangedEventArgs(NotifyCollectionChangedAction action, GridViewColumn newItem, GridViewColumn oldItem, int index, int actualIndex);
    internal GridViewColumnCollectionChangedEventArgs(NotifyCollectionChangedAction action, GridViewColumn changedItem, int index, int oldIndex, int actualIndex);
    internal int get_ActualIndex();
    internal ReadOnlyCollection`1<GridViewColumn> get_ClearedColumns();
    internal GridViewColumn get_Column();
    internal string get_PropertyName();
}
[TemplatePartAttribute]
[TemplatePartAttribute]
public class System.Windows.Controls.GridViewColumnHeader : ButtonBase {
    internal static DependencyPropertyKey ColumnPropertyKey;
    public static DependencyProperty ColumnProperty;
    internal static DependencyPropertyKey RolePropertyKey;
    public static DependencyProperty RoleProperty;
    private static DependencyObjectType _dType;
    private GridViewColumnHeader _previousHeader;
    private static Cursor _splitCursorCache;
    private static Cursor _splitOpenCursorCache;
    private Flags _flags;
    private Thumb _headerGripper;
    private double _originalWidth;
    private Canvas _floatingHeaderCanvas;
    private GridViewColumnHeader _srcHeader;
    private static int c_SPLIT;
    private static int c_SPLITOPEN;
    private static string HeaderGripperTemplateName;
    private static string FloatingHeaderCanvasTemplateName;
    public GridViewColumn Column { get; }
    [CategoryAttribute("Behavior")]
public GridViewColumnHeaderRole Role { get; }
    internal DependencyObjectType DTypeThemeStyleKey { get; }
    internal GridViewColumnHeader PreviousVisualHeader { get; internal set; }
    internal bool SuppressClickEvent { get; internal set; }
    internal GridViewColumnHeader FloatSourceHeader { get; internal set; }
    internal bool IsInternalGenerated { get; internal set; }
    private Cursor SplitCursor { get; }
    private Cursor SplitOpenCursor { get; }
    private bool IsAccessKeyOrAutomation { get; private set; }
    private double ColumnActualWidth { get; }
    private static GridViewColumnHeader();
    public virtual void OnApplyTemplate();
    public GridViewColumn get_Column();
    public GridViewColumnHeaderRole get_Role();
    protected virtual void OnMouseLeftButtonUp(MouseButtonEventArgs e);
    protected virtual void OnMouseLeftButtonDown(MouseButtonEventArgs e);
    protected virtual void OnMouseMove(MouseEventArgs e);
    protected internal virtual void OnRenderSizeChanged(SizeChangedInfo sizeInfo);
    protected virtual void OnClick();
    protected virtual void OnAccessKey(AccessKeyEventArgs e);
    protected internal virtual bool ShouldSerializeProperty(DependencyProperty dp);
    protected virtual void OnMouseEnter(MouseEventArgs e);
    protected virtual void OnMouseLeave(MouseEventArgs e);
    protected virtual void OnLostKeyboardFocus(KeyboardFocusChangedEventArgs e);
    internal void AutomationClick();
    internal void OnColumnHeaderKeyDown(object sender, KeyEventArgs e);
    internal void CheckWidthForPreviousHeaderGripper();
    internal void ResetFloatingHeaderCanvasBackground();
    internal void UpdateProperty(DependencyProperty dp, object value);
    internal virtual DependencyObjectType get_DTypeThemeStyleKey();
    internal GridViewColumnHeader get_PreviousVisualHeader();
    internal void set_PreviousVisualHeader(GridViewColumnHeader value);
    internal bool get_SuppressClickEvent();
    internal void set_SuppressClickEvent(bool value);
    internal GridViewColumnHeader get_FloatSourceHeader();
    internal void set_FloatSourceHeader(GridViewColumnHeader value);
    internal bool get_IsInternalGenerated();
    internal void set_IsInternalGenerated(bool value);
    protected virtual AutomationPeer OnCreateAutomationPeer();
    private static void PropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void PropertyToFlags(DependencyProperty dp, Flags& flag, Flags& ignoreFlag);
    private void HideGripperRightHalf(bool hide);
    private void OnColumnHeaderGripperDragStarted(object sender, DragStartedEventArgs e);
    private void MakeParentGotFocus();
    private void OnColumnHeaderResize(object sender, DragDeltaEventArgs e);
    private void OnColumnHeaderGripperDragCompleted(object sender, DragCompletedEventArgs e);
    private void HookupGripperEvents();
    private void OnGripperDoubleClicked(object sender, MouseButtonEventArgs e);
    private void UnhookGripperEvents();
    private Cursor GetCursor(int cursorID);
    private void UpdateGripperCursor();
    private void UpdateColumnHeaderWidth(double width);
    private bool IsMouseOutside();
    private void ClickImplement();
    private bool GetFlag(Flags flag);
    private void SetFlag(Flags flag, bool set);
    private void UpdateFloatingHeaderCanvas();
    private bool HandleIsMouseOverChanged();
    private void OnGripperMouseEnterLeave(object sender, MouseEventArgs e);
    private Cursor get_SplitCursor();
    private Cursor get_SplitOpenCursor();
    private bool get_IsAccessKeyOrAutomation();
    private void set_IsAccessKeyOrAutomation(bool value);
    private double get_ColumnActualWidth();
}
public enum System.Windows.Controls.GridViewColumnHeaderRole : Enum {
    public int value__;
    public static GridViewColumnHeaderRole Normal;
    public static GridViewColumnHeaderRole Floating;
    public static GridViewColumnHeaderRole Padding;
}
[StyleTypedPropertyAttribute]
public class System.Windows.Controls.GridViewHeaderRowPresenter : GridViewRowPresenterBase {
    public static DependencyProperty ColumnHeaderContainerStyleProperty;
    public static DependencyProperty ColumnHeaderTemplateProperty;
    public static DependencyProperty ColumnHeaderTemplateSelectorProperty;
    public static DependencyProperty ColumnHeaderStringFormatProperty;
    public static DependencyProperty AllowsColumnReorderProperty;
    public static DependencyProperty ColumnHeaderContextMenuProperty;
    public static DependencyProperty ColumnHeaderToolTipProperty;
    private bool _gvHeadersValid;
    private List`1<GridViewColumnHeader> _gvHeaders;
    private List`1<Rect> _headersPositionList;
    private ScrollViewer _mainSV;
    private ScrollViewer _headerSV;
    private GridViewColumnHeader _paddingHeader;
    private GridViewColumnHeader _floatingHeader;
    private Separator _indicator;
    private ItemsControl _itemsControl;
    private GridViewColumnHeader _draggingSrcHeader;
    private Point _startPos;
    private Point _relativeStartPos;
    private Point _currentPos;
    private int _startColumnIndex;
    private int _desColumnIndex;
    private bool _isHeaderDragging;
    private bool _isColumnChangedOrCreated;
    private bool _prepareDragging;
    private static double c_thresholdX;
    private static DependencyProperty[][] s_DPList;
    public Style ColumnHeaderContainerStyle { get; public set; }
    public DataTemplate ColumnHeaderTemplate { get; public set; }
    [DesignerSerializationVisibilityAttribute("0")]
public DataTemplateSelector ColumnHeaderTemplateSelector { get; public set; }
    [DesignerSerializationVisibilityAttribute("0")]
public string ColumnHeaderStringFormat { get; public set; }
    public bool AllowsColumnReorder { get; public set; }
    public ContextMenu ColumnHeaderContextMenu { get; public set; }
    public object ColumnHeaderToolTip { get; public set; }
    internal List`1<GridViewColumnHeader> ActualColumnHeaders { get; }
    private List`1<Rect> HeadersPositionList { get; }
    private static GridViewHeaderRowPresenter();
    public Style get_ColumnHeaderContainerStyle();
    public void set_ColumnHeaderContainerStyle(Style value);
    public DataTemplate get_ColumnHeaderTemplate();
    public void set_ColumnHeaderTemplate(DataTemplate value);
    public DataTemplateSelector get_ColumnHeaderTemplateSelector();
    public void set_ColumnHeaderTemplateSelector(DataTemplateSelector value);
    public string get_ColumnHeaderStringFormat();
    public void set_ColumnHeaderStringFormat(string value);
    public bool get_AllowsColumnReorder();
    public void set_AllowsColumnReorder(bool value);
    public ContextMenu get_ColumnHeaderContextMenu();
    public void set_ColumnHeaderContextMenu(ContextMenu value);
    public object get_ColumnHeaderToolTip();
    public void set_ColumnHeaderToolTip(object value);
    private static void PropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    protected virtual Size MeasureOverride(Size constraint);
    protected virtual Size ArrangeOverride(Size arrangeSize);
    protected virtual void OnMouseLeftButtonDown(MouseButtonEventArgs e);
    protected virtual void OnMouseLeftButtonUp(MouseButtonEventArgs e);
    protected virtual void OnMouseMove(MouseEventArgs e);
    protected virtual void OnLostMouseCapture(MouseEventArgs e);
    internal virtual void OnPreApplyTemplate();
    internal virtual void OnColumnPropertyChanged(GridViewColumn column, string propertyName);
    internal virtual void OnColumnCollectionChanged(GridViewColumnCollectionChangedEventArgs e);
    internal void MakeParentItemsControlGotFocus();
    internal void UpdateHeaderProperty(GridViewColumnHeader header, DependencyProperty property);
    protected virtual AutomationPeer OnCreateAutomationPeer();
    private void OnLayoutUpdated(object sender, EventArgs e);
    private int GetVisualIndex(int columnIndex);
    private void BuildHeaderLinks();
    private GridViewColumnHeader CreateAndInsertHeader(GridViewColumn column, int index);
    private void RemoveHeader(GridViewColumnHeader header, int index);
    private void RenewEvents();
    private void UnhookItemsControlKeyboardEvent(GridViewColumnHeader header);
    private void HookupItemsControlKeyboardEvent(GridViewColumnHeader header);
    private void OnMasterScrollChanged(object sender, ScrollChangedEventArgs e);
    private void OnHeaderScrollChanged(object sender, ScrollChangedEventArgs e);
    private void AddPaddingColumnHeader();
    private void AddIndicator();
    private void AddFloatingHeader(GridViewColumnHeader srcHeader);
    private void UpdateFloatingHeader(GridViewColumnHeader srcHeader);
    private bool CheckStartHeaderDrag(Point currentPos, Point originalPos);
    private static ItemsControl FindItemsControlThroughTemplatedParent(GridViewHeaderRowPresenter presenter);
    private void OnColumnHeadersPresenterKeyDown(object sender, KeyEventArgs e);
    private GridViewColumnHeader FindHeaderByColumn(GridViewColumn column);
    private int FindIndexByPosition(Point startPos, bool findNearestColumn);
    private Point FindPositionByIndex(int index);
    private void UpdateHeader(GridViewColumnHeader header);
    private void UpdateHeaderContent(GridViewColumnHeader header);
    private void UpdatePaddingHeader(GridViewColumnHeader header);
    private void UpdateAllHeaders(DependencyProperty dp);
    private void GetIndexRange(DependencyProperty dp, Int32& iStart, Int32& iEnd);
    private void UpdateHeaderProperty(GridViewColumnHeader header, DependencyProperty targetDP, DependencyProperty columnDP, DependencyProperty gvDP);
    private void PrepareHeaderDrag(GridViewColumnHeader header, Point pos, Point relativePos, bool cancelInvoke);
    private void StartHeaderDrag();
    private void FinishHeaderDrag(bool isCancel);
    private static bool IsMousePositionValid(FrameworkElement floatingHeader, Point currentPos, double arrange);
    internal List`1<GridViewColumnHeader> get_ActualColumnHeaders();
    private List`1<Rect> get_HeadersPositionList();
    private static DependencyProperty GetColumnDPFromName(string dpName);
    private static void GetMatchingDPs(DependencyProperty indexDP, DependencyProperty& gvDP, DependencyProperty& columnDP, DependencyProperty& headerDP);
}
public class System.Windows.Controls.GridViewRowPresenter : GridViewRowPresenterBase {
    public static DependencyProperty ContentProperty;
    private FrameworkElement _viewPort;
    private FrameworkElement _viewItem;
    private Type _oldContentType;
    private bool _viewPortValid;
    private bool _isOnCurrentPage;
    private bool _isOnCurrentPageValid;
    private static Thickness _defalutCellMargin;
    public object Content { get; public set; }
    internal List`1<UIElement> ActualCells { get; }
    private bool IsOnCurrentPage { get; }
    private static GridViewRowPresenter();
    public virtual string ToString();
    public object get_Content();
    public void set_Content(object value);
    private static void OnContentChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    protected virtual Size MeasureOverride(Size constraint);
    protected virtual Size ArrangeOverride(Size arrangeSize);
    internal virtual void OnPreApplyTemplate();
    internal virtual void OnColumnPropertyChanged(GridViewColumn column, string propertyName);
    internal virtual void OnColumnCollectionChanged(GridViewColumnCollectionChangedEventArgs e);
    internal List`1<UIElement> get_ActualCells();
    private void FindViewPort();
    private bool CheckVisibleOnCurrentPage();
    private bool CheckContains(Rect container, Rect element);
    private bool CheckIsPointBetween(Rect rect, double pointY);
    private void OnLayoutUpdated(object sender, EventArgs e);
    private FrameworkElement CreateCell(GridViewColumn column);
    private void RenewCell(int index, GridViewColumn column);
    private void UpdateCells();
    private bool get_IsOnCurrentPage();
}
[LocalizabilityAttribute("0")]
public class System.Windows.Controls.GroupBox : HeaderedContentControl {
    private static GroupBox();
    protected virtual AutomationPeer OnCreateAutomationPeer();
    protected virtual void OnAccessKey(AccessKeyEventArgs e);
    private static void OnAccessKeyPressed(object sender, AccessKeyPressedEventArgs e);
}
public class System.Windows.Controls.GroupItem : ContentControl {
    private ItemContainerGenerator _generator;
    private Panel _itemsHost;
    private FrameworkElement _header;
    private Expander _expander;
    internal static UncommonField`1<bool> MustDisableVirtualizationField;
    internal static UncommonField`1<bool> InBackgroundLayoutField;
    internal static UncommonField`1<Thickness> DesiredPixelItemsSizeCorrectionFactorField;
    internal static UncommonField`1<HierarchicalVirtualizationConstraints> HierarchicalVirtualizationConstraintsField;
    internal static UncommonField`1<HierarchicalVirtualizationHeaderDesiredSizes> HierarchicalVirtualizationHeaderDesiredSizesField;
    internal static UncommonField`1<HierarchicalVirtualizationItemDesiredSizes> HierarchicalVirtualizationItemDesiredSizesField;
    private static DependencyObjectType _dType;
    private static string ExpanderHeaderPartName;
    internal ItemContainerGenerator Generator { get; internal set; }
    private HierarchicalVirtualizationConstraints System.Windows.Controls.Primitives.IHierarchicalVirtualizationAndScrollInfo.Constraints { get; private set; }
    private HierarchicalVirtualizationHeaderDesiredSizes System.Windows.Controls.Primitives.IHierarchicalVirtualizationAndScrollInfo.HeaderDesiredSizes { get; }
    private HierarchicalVirtualizationItemDesiredSizes System.Windows.Controls.Primitives.IHierarchicalVirtualizationAndScrollInfo.ItemDesiredSizes { get; private set; }
    private Panel System.Windows.Controls.Primitives.IHierarchicalVirtualizationAndScrollInfo.ItemsHost { get; }
    private bool System.Windows.Controls.Primitives.IHierarchicalVirtualizationAndScrollInfo.MustDisableVirtualization { get; private set; }
    private bool System.Windows.Controls.Primitives.IHierarchicalVirtualizationAndScrollInfo.InBackgroundLayout { get; private set; }
    private ItemsControl ParentItemsControl { get; }
    internal IContainItemStorage ParentItemStorageProvider { get; }
    internal Panel ItemsHost { get; internal set; }
    private ItemsPresenter ItemsHostPresenter { get; }
    internal Expander Expander { get; }
    private FrameworkElement ExpanderHeader { get; }
    private FrameworkElement HeaderElement { get; }
    internal DependencyObjectType DTypeThemeStyleKey { get; }
    private static GroupItem();
    protected virtual AutomationPeer OnCreateAutomationPeer();
    public virtual void OnApplyTemplate();
    private static void OnExpanded(object sender, RoutedEventArgs e);
    internal virtual void OnTemplateChangedInternal(FrameworkTemplate oldTemplate, FrameworkTemplate newTemplate);
    protected virtual Size ArrangeOverride(Size arrangeSize);
    internal virtual string GetPlainText();
    internal ItemContainerGenerator get_Generator();
    internal void set_Generator(ItemContainerGenerator value);
    internal void PrepareItemContainer(object item, ItemsControl parentItemsControl);
    internal void ClearItemContainer(object item, ItemsControl parentItemsControl);
    private sealed virtual override HierarchicalVirtualizationConstraints System.Windows.Controls.Primitives.IHierarchicalVirtualizationAndScrollInfo.get_Constraints();
    private sealed virtual override void System.Windows.Controls.Primitives.IHierarchicalVirtualizationAndScrollInfo.set_Constraints(HierarchicalVirtualizationConstraints value);
    private sealed virtual override HierarchicalVirtualizationHeaderDesiredSizes System.Windows.Controls.Primitives.IHierarchicalVirtualizationAndScrollInfo.get_HeaderDesiredSizes();
    private sealed virtual override HierarchicalVirtualizationItemDesiredSizes System.Windows.Controls.Primitives.IHierarchicalVirtualizationAndScrollInfo.get_ItemDesiredSizes();
    private sealed virtual override void System.Windows.Controls.Primitives.IHierarchicalVirtualizationAndScrollInfo.set_ItemDesiredSizes(HierarchicalVirtualizationItemDesiredSizes value);
    private sealed virtual override Panel System.Windows.Controls.Primitives.IHierarchicalVirtualizationAndScrollInfo.get_ItemsHost();
    private sealed virtual override bool System.Windows.Controls.Primitives.IHierarchicalVirtualizationAndScrollInfo.get_MustDisableVirtualization();
    private sealed virtual override void System.Windows.Controls.Primitives.IHierarchicalVirtualizationAndScrollInfo.set_MustDisableVirtualization(bool value);
    private sealed virtual override bool System.Windows.Controls.Primitives.IHierarchicalVirtualizationAndScrollInfo.get_InBackgroundLayout();
    private sealed virtual override void System.Windows.Controls.Primitives.IHierarchicalVirtualizationAndScrollInfo.set_InBackgroundLayout(bool value);
    private sealed virtual override object System.Windows.Controls.Primitives.IContainItemStorage.ReadItemValue(object item, DependencyProperty dp);
    private sealed virtual override void System.Windows.Controls.Primitives.IContainItemStorage.StoreItemValue(object item, DependencyProperty dp, object value);
    private sealed virtual override void System.Windows.Controls.Primitives.IContainItemStorage.ClearItemValue(object item, DependencyProperty dp);
    private sealed virtual override void System.Windows.Controls.Primitives.IContainItemStorage.ClearValue(DependencyProperty dp);
    private sealed virtual override void System.Windows.Controls.Primitives.IContainItemStorage.Clear();
    private ItemsControl get_ParentItemsControl();
    internal IContainItemStorage get_ParentItemStorageProvider();
    internal Panel get_ItemsHost();
    internal void set_ItemsHost(Panel value);
    private ItemsPresenter get_ItemsHostPresenter();
    internal Expander get_Expander();
    private FrameworkElement get_ExpanderHeader();
    private FrameworkElement get_HeaderElement();
    internal virtual DependencyObjectType get_DTypeThemeStyleKey();
}
[LocalizabilityAttribute("0")]
public class System.Windows.Controls.GroupStyle : object {
    [CompilerGeneratedAttribute]
private PropertyChangedEventHandler PropertyChanged;
    public static ItemsPanelTemplate DefaultGroupPanel;
    private ItemsPanelTemplate _panel;
    private Style _containerStyle;
    private StyleSelector _containerStyleSelector;
    private DataTemplate _headerTemplate;
    private DataTemplateSelector _headerTemplateSelector;
    private string _headerStringFormat;
    private bool _hidesIfEmpty;
    private bool _isAlternationCountSet;
    private int _alternationCount;
    private static GroupStyle s_DefaultGroupStyle;
    internal static ItemsPanelTemplate DefaultStackPanel;
    internal static ItemsPanelTemplate DefaultVirtualizingStackPanel;
    public ItemsPanelTemplate Panel { get; public set; }
    [DefaultValueAttribute("")]
public Style ContainerStyle { get; public set; }
    [DefaultValueAttribute("")]
public StyleSelector ContainerStyleSelector { get; public set; }
    [DefaultValueAttribute("")]
public DataTemplate HeaderTemplate { get; public set; }
    [DefaultValueAttribute("")]
public DataTemplateSelector HeaderTemplateSelector { get; public set; }
    [DefaultValueAttribute("")]
public string HeaderStringFormat { get; public set; }
    [DefaultValueAttribute("False")]
public bool HidesIfEmpty { get; public set; }
    [DefaultValueAttribute("0")]
public int AlternationCount { get; public set; }
    public static GroupStyle Default { get; }
    internal bool IsAlternationCountSet { get; }
    private static GroupStyle();
    private sealed virtual override void System.ComponentModel.INotifyPropertyChanged.add_PropertyChanged(PropertyChangedEventHandler value);
    private sealed virtual override void System.ComponentModel.INotifyPropertyChanged.remove_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
protected virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
protected virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
    protected virtual void OnPropertyChanged(PropertyChangedEventArgs e);
    public ItemsPanelTemplate get_Panel();
    public void set_Panel(ItemsPanelTemplate value);
    public Style get_ContainerStyle();
    public void set_ContainerStyle(Style value);
    public StyleSelector get_ContainerStyleSelector();
    public void set_ContainerStyleSelector(StyleSelector value);
    public DataTemplate get_HeaderTemplate();
    public void set_HeaderTemplate(DataTemplate value);
    public DataTemplateSelector get_HeaderTemplateSelector();
    public void set_HeaderTemplateSelector(DataTemplateSelector value);
    public string get_HeaderStringFormat();
    public void set_HeaderStringFormat(string value);
    public bool get_HidesIfEmpty();
    public void set_HidesIfEmpty(bool value);
    public int get_AlternationCount();
    public void set_AlternationCount(int value);
    public static GroupStyle get_Default();
    private void OnPropertyChanged(string propertyName);
    internal bool get_IsAlternationCountSet();
}
public class System.Windows.Controls.GroupStyleSelector : MulticastDelegate {
    public GroupStyleSelector(object object, IntPtr method);
    public virtual GroupStyle Invoke(CollectionViewGroup group, int level);
    public virtual IAsyncResult BeginInvoke(CollectionViewGroup group, int level, AsyncCallback callback, object object);
    public virtual GroupStyle EndInvoke(IAsyncResult result);
}
[LocalizabilityAttribute("1")]
public class System.Windows.Controls.HeaderedContentControl : ContentControl {
    [CommonDependencyPropertyAttribute]
public static DependencyProperty HeaderProperty;
    internal static DependencyPropertyKey HasHeaderPropertyKey;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty HasHeaderProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty HeaderTemplateProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty HeaderTemplateSelectorProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty HeaderStringFormatProperty;
    private static DependencyObjectType _dType;
    [BindableAttribute("True")]
[CategoryAttribute("Content")]
[LocalizabilityAttribute("3")]
public object Header { get; public set; }
    [BrowsableAttribute("False")]
[BindableAttribute("False")]
public bool HasHeader { get; }
    [CategoryAttribute("Content")]
[BindableAttribute("True")]
public DataTemplate HeaderTemplate { get; public set; }
    [BindableAttribute("True")]
[CategoryAttribute("Content")]
public DataTemplateSelector HeaderTemplateSelector { get; public set; }
    [CustomCategoryAttribute("Content")]
[BindableAttribute("True")]
public string HeaderStringFormat { get; public set; }
    protected internal IEnumerator LogicalChildren { get; }
    internal bool HeaderIsNotLogical { get; internal set; }
    internal bool HeaderIsItem { get; internal set; }
    internal DependencyObjectType DTypeThemeStyleKey { get; }
    private static HeaderedContentControl();
    public object get_Header();
    public void set_Header(object value);
    private static void OnHeaderChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    protected virtual void OnHeaderChanged(object oldHeader, object newHeader);
    public bool get_HasHeader();
    public DataTemplate get_HeaderTemplate();
    public void set_HeaderTemplate(DataTemplate value);
    private static void OnHeaderTemplateChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    protected virtual void OnHeaderTemplateChanged(DataTemplate oldHeaderTemplate, DataTemplate newHeaderTemplate);
    public DataTemplateSelector get_HeaderTemplateSelector();
    public void set_HeaderTemplateSelector(DataTemplateSelector value);
    private static void OnHeaderTemplateSelectorChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    protected virtual void OnHeaderTemplateSelectorChanged(DataTemplateSelector oldHeaderTemplateSelector, DataTemplateSelector newHeaderTemplateSelector);
    public string get_HeaderStringFormat();
    public void set_HeaderStringFormat(string value);
    private static void OnHeaderStringFormatChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    protected virtual void OnHeaderStringFormatChanged(string oldHeaderStringFormat, string newHeaderStringFormat);
    protected internal virtual IEnumerator get_LogicalChildren();
    internal virtual string GetPlainText();
    internal bool get_HeaderIsNotLogical();
    internal void set_HeaderIsNotLogical(bool value);
    internal bool get_HeaderIsItem();
    internal void set_HeaderIsItem(bool value);
    internal void PrepareHeaderedContentControl(object item, DataTemplate itemTemplate, DataTemplateSelector itemTemplateSelector, string stringFormat);
    internal void ClearHeaderedContentControl(object item);
    public virtual string ToString();
    internal virtual DependencyObjectType get_DTypeThemeStyleKey();
}
[DefaultPropertyAttribute("Header")]
[LocalizabilityAttribute("8")]
public class System.Windows.Controls.HeaderedItemsControl : ItemsControl {
    [CommonDependencyPropertyAttribute]
public static DependencyProperty HeaderProperty;
    private static DependencyPropertyKey HasHeaderPropertyKey;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty HasHeaderProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty HeaderTemplateProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty HeaderTemplateSelectorProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty HeaderStringFormatProperty;
    [BindableAttribute("True")]
[CustomCategoryAttribute("Content")]
public object Header { get; public set; }
    [BindableAttribute("False")]
[BrowsableAttribute("False")]
public bool HasHeader { get; }
    [BindableAttribute("True")]
[CustomCategoryAttribute("Content")]
public DataTemplate HeaderTemplate { get; public set; }
    [CustomCategoryAttribute("Content")]
[BindableAttribute("True")]
public DataTemplateSelector HeaderTemplateSelector { get; public set; }
    [BindableAttribute("True")]
[CustomCategoryAttribute("Content")]
public string HeaderStringFormat { get; public set; }
    protected internal IEnumerator LogicalChildren { get; }
    private bool HeaderIsItem { get; private set; }
    private static HeaderedItemsControl();
    public object get_Header();
    public void set_Header(object value);
    private static void OnHeaderChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    protected virtual void OnHeaderChanged(object oldHeader, object newHeader);
    public bool get_HasHeader();
    public DataTemplate get_HeaderTemplate();
    public void set_HeaderTemplate(DataTemplate value);
    private static void OnHeaderTemplateChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    protected virtual void OnHeaderTemplateChanged(DataTemplate oldHeaderTemplate, DataTemplate newHeaderTemplate);
    public DataTemplateSelector get_HeaderTemplateSelector();
    public void set_HeaderTemplateSelector(DataTemplateSelector value);
    private static void OnHeaderTemplateSelectorChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    protected virtual void OnHeaderTemplateSelectorChanged(DataTemplateSelector oldHeaderTemplateSelector, DataTemplateSelector newHeaderTemplateSelector);
    public string get_HeaderStringFormat();
    public void set_HeaderStringFormat(string value);
    private static void OnHeaderStringFormatChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    protected virtual void OnHeaderStringFormatChanged(string oldHeaderStringFormat, string newHeaderStringFormat);
    internal void PrepareHeaderedItemsControl(object item, ItemsControl parentItemsControl);
    internal void ClearHeaderedItemsControl(object item);
    internal virtual string GetPlainText();
    public virtual string ToString();
    protected internal virtual IEnumerator get_LogicalChildren();
    private void PrepareHierarchy(object item, ItemsControl parentItemsControl);
    private bool IsBound(DependencyProperty dp, Binding binding);
    private bool IsHeaderLogical();
    private bool get_HeaderIsItem();
    private void set_HeaderIsItem(bool value);
}
public class System.Windows.Controls.HierarchicalVirtualizationConstraints : ValueType {
    private VirtualizationCacheLength _cacheLength;
    private VirtualizationCacheLengthUnit _cacheLengthUnit;
    private Rect _viewport;
    private long _scrollGeneration;
    public VirtualizationCacheLength CacheLength { get; }
    public VirtualizationCacheLengthUnit CacheLengthUnit { get; }
    public Rect Viewport { get; }
    internal long ScrollGeneration { get; internal set; }
    public HierarchicalVirtualizationConstraints(VirtualizationCacheLength cacheLength, VirtualizationCacheLengthUnit cacheLengthUnit, Rect viewport);
    public VirtualizationCacheLength get_CacheLength();
    public VirtualizationCacheLengthUnit get_CacheLengthUnit();
    public Rect get_Viewport();
    public static bool op_Equality(HierarchicalVirtualizationConstraints constraints1, HierarchicalVirtualizationConstraints constraints2);
    public static bool op_Inequality(HierarchicalVirtualizationConstraints constraints1, HierarchicalVirtualizationConstraints constraints2);
    public virtual bool Equals(object oCompare);
    public bool Equals(HierarchicalVirtualizationConstraints comparisonConstraints);
    public virtual int GetHashCode();
    internal long get_ScrollGeneration();
    internal void set_ScrollGeneration(long value);
}
public class System.Windows.Controls.HierarchicalVirtualizationHeaderDesiredSizes : ValueType {
    private Size _logicalSize;
    private Size _pixelSize;
    public Size LogicalSize { get; }
    public Size PixelSize { get; }
    public HierarchicalVirtualizationHeaderDesiredSizes(Size logicalSize, Size pixelSize);
    public Size get_LogicalSize();
    public Size get_PixelSize();
    public static bool op_Equality(HierarchicalVirtualizationHeaderDesiredSizes headerDesiredSizes1, HierarchicalVirtualizationHeaderDesiredSizes headerDesiredSizes2);
    public static bool op_Inequality(HierarchicalVirtualizationHeaderDesiredSizes headerDesiredSizes1, HierarchicalVirtualizationHeaderDesiredSizes headerDesiredSizes2);
    public virtual bool Equals(object oCompare);
    public bool Equals(HierarchicalVirtualizationHeaderDesiredSizes comparisonHeaderSizes);
    public virtual int GetHashCode();
}
public class System.Windows.Controls.HierarchicalVirtualizationItemDesiredSizes : ValueType {
    private Size _logicalSize;
    private Size _logicalSizeInViewport;
    private Size _logicalSizeBeforeViewport;
    private Size _logicalSizeAfterViewport;
    private Size _pixelSize;
    private Size _pixelSizeInViewport;
    private Size _pixelSizeBeforeViewport;
    private Size _pixelSizeAfterViewport;
    public Size LogicalSize { get; }
    public Size LogicalSizeInViewport { get; }
    public Size LogicalSizeBeforeViewport { get; }
    public Size LogicalSizeAfterViewport { get; }
    public Size PixelSize { get; }
    public Size PixelSizeInViewport { get; }
    public Size PixelSizeBeforeViewport { get; }
    public Size PixelSizeAfterViewport { get; }
    public HierarchicalVirtualizationItemDesiredSizes(Size logicalSize, Size logicalSizeInViewport, Size logicalSizeBeforeViewport, Size logicalSizeAfterViewport, Size pixelSize, Size pixelSizeInViewport, Size pixelSizeBeforeViewport, Size pixelSizeAfterViewport);
    public Size get_LogicalSize();
    public Size get_LogicalSizeInViewport();
    public Size get_LogicalSizeBeforeViewport();
    public Size get_LogicalSizeAfterViewport();
    public Size get_PixelSize();
    public Size get_PixelSizeInViewport();
    public Size get_PixelSizeBeforeViewport();
    public Size get_PixelSizeAfterViewport();
    public static bool op_Equality(HierarchicalVirtualizationItemDesiredSizes itemDesiredSizes1, HierarchicalVirtualizationItemDesiredSizes itemDesiredSizes2);
    public static bool op_Inequality(HierarchicalVirtualizationItemDesiredSizes itemDesiredSizes1, HierarchicalVirtualizationItemDesiredSizes itemDesiredSizes2);
    public virtual bool Equals(object oCompare);
    public bool Equals(HierarchicalVirtualizationItemDesiredSizes comparisonItemSizes);
    public virtual int GetHashCode();
}
[LocalizabilityAttribute("0")]
public class System.Windows.Controls.Image : FrameworkElement {
    [CommonDependencyPropertyAttribute]
public static DependencyProperty SourceProperty;
    public static RoutedEvent DpiChangedEvent;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty StretchProperty;
    public static DependencyProperty StretchDirectionProperty;
    public static RoutedEvent ImageFailedEvent;
    private BitmapSource _bitmapSource;
    private bool _hasDpiChangedEverFired;
    public ImageSource Source { get; public set; }
    public Stretch Stretch { get; public set; }
    public StretchDirection StretchDirection { get; public set; }
    private Uri System.Windows.Markup.IUriContext.BaseUri { get; private set; }
    protected Uri BaseUri { get; protected set; }
    internal int EffectiveValuesInitialSize { get; }
    private static Image();
    public ImageSource get_Source();
    public void set_Source(ImageSource value);
    public Stretch get_Stretch();
    public void set_Stretch(Stretch value);
    public StretchDirection get_StretchDirection();
    public void set_StretchDirection(StretchDirection value);
    public void add_ImageFailed(EventHandler`1<ExceptionRoutedEventArgs> value);
    public void remove_ImageFailed(EventHandler`1<ExceptionRoutedEventArgs> value);
    public void add_DpiChanged(DpiChangedEventHandler value);
    public void remove_DpiChanged(DpiChangedEventHandler value);
    protected virtual AutomationPeer OnCreateAutomationPeer();
    protected virtual void OnDpiChanged(DpiScale oldDpi, DpiScale newDpi);
    protected virtual Size MeasureOverride(Size constraint);
    protected virtual Size ArrangeOverride(Size arrangeSize);
    protected virtual void OnRender(DrawingContext dc);
    private sealed virtual override Uri System.Windows.Markup.IUriContext.get_BaseUri();
    private sealed virtual override void System.Windows.Markup.IUriContext.set_BaseUri(Uri value);
    protected virtual Uri get_BaseUri();
    protected virtual void set_BaseUri(Uri value);
    private Size MeasureArrangeHelper(Size inputSize);
    internal virtual int get_EffectiveValuesInitialSize();
    private static Style CreateDefaultStyles();
    private void OnSourceDownloaded(object sender, EventArgs e);
    private void OnSourceFailed(object sender, ExceptionEventArgs e);
    private void AttachBitmapSourceEvents(BitmapSource bitmapSource);
    private void DetachBitmapSourceEvents();
    private static void OnSourceChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void UpdateBaseUri(DependencyObject d, ImageSource source);
    private sealed virtual override bool System.Windows.Markup.IProvidePropertyFallback.CanProvidePropertyFallback(string property);
    private sealed virtual override object System.Windows.Markup.IProvidePropertyFallback.ProvidePropertyFallback(string property, Exception cause);
}
public class System.Windows.Controls.InitializingNewItemEventArgs : EventArgs {
    private object _newItem;
    public object NewItem { get; }
    public InitializingNewItemEventArgs(object newItem);
    public object get_NewItem();
}
public class System.Windows.Controls.InitializingNewItemEventHandler : MulticastDelegate {
    public InitializingNewItemEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, InitializingNewItemEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, InitializingNewItemEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[ContentPropertyAttribute("Children")]
public class System.Windows.Controls.InkCanvas : FrameworkElement {
    public static DependencyProperty BackgroundProperty;
    public static DependencyProperty TopProperty;
    public static DependencyProperty BottomProperty;
    public static DependencyProperty LeftProperty;
    public static DependencyProperty RightProperty;
    public static DependencyProperty StrokesProperty;
    public static DependencyProperty DefaultDrawingAttributesProperty;
    internal static DependencyPropertyKey ActiveEditingModePropertyKey;
    public static DependencyProperty ActiveEditingModeProperty;
    public static DependencyProperty EditingModeProperty;
    public static DependencyProperty EditingModeInvertedProperty;
    public static RoutedEvent StrokeCollectedEvent;
    public static RoutedEvent GestureEvent;
    [CompilerGeneratedAttribute]
private InkCanvasStrokesReplacedEventHandler StrokesReplaced;
    [CompilerGeneratedAttribute]
private DrawingAttributesReplacedEventHandler DefaultDrawingAttributesReplaced;
    public static RoutedEvent ActiveEditingModeChangedEvent;
    public static RoutedEvent EditingModeChangedEvent;
    public static RoutedEvent EditingModeInvertedChangedEvent;
    [CompilerGeneratedAttribute]
private InkCanvasSelectionEditingEventHandler SelectionMoving;
    [CompilerGeneratedAttribute]
private EventHandler SelectionMoved;
    [CompilerGeneratedAttribute]
private InkCanvasStrokeErasingEventHandler StrokeErasing;
    public static RoutedEvent StrokeErasedEvent;
    [CompilerGeneratedAttribute]
private InkCanvasSelectionEditingEventHandler SelectionResizing;
    [CompilerGeneratedAttribute]
private EventHandler SelectionResized;
    [CompilerGeneratedAttribute]
private InkCanvasSelectionChangingEventHandler SelectionChanging;
    [CompilerGeneratedAttribute]
private EventHandler SelectionChanged;
    internal static RoutedCommand DeselectCommand;
    private InkCanvasSelection _selection;
    private InkCanvasSelectionAdorner _selectionAdorner;
    private InkCanvasFeedbackAdorner _feedbackAdorner;
    private InkCanvasInnerCanvas _innerCanvas;
    private AdornerDecorator _localAdornerDecorator;
    private StrokeCollection _dynamicallySelectedStrokes;
    private EditingCoordinator _editingCoordinator;
    private StylusPointDescription _defaultStylusPointDescription;
    private StylusShape _eraserShape;
    private bool _useCustomCursor;
    private InkPresenter _inkPresenter;
    private DynamicRenderer _dynamicRenderer;
    private ClipboardProcessor _clipboardProcessor;
    private GestureRecognizer _gestureRecognizer;
    private RTIHighContrastCallback _rtiHighContrastCallback;
    private static double c_pasteDefaultLocation;
    private static string InkCanvasDeselectKey;
    private static string KeyCtrlInsert;
    private static string KeyShiftInsert;
    private static string KeyShiftDelete;
    protected int VisualChildrenCount { get; }
    [CategoryAttribute("Appearance")]
[BindableAttribute("True")]
public Brush Background { get; public set; }
    public StrokeCollection Strokes { get; public set; }
    internal InkCanvasSelectionAdorner SelectionAdorner { get; }
    internal InkCanvasFeedbackAdorner FeedbackAdorner { get; }
    [DesignerSerializationVisibilityAttribute("0")]
public bool IsGestureRecognizerAvailable { get; }
    [DesignerSerializationVisibilityAttribute("2")]
public UIElementCollection Children { get; }
    public DrawingAttributes DefaultDrawingAttributes { get; public set; }
    [DesignerSerializationVisibilityAttribute("0")]
public StylusShape EraserShape { get; public set; }
    public InkCanvasEditingMode ActiveEditingMode { get; }
    public InkCanvasEditingMode EditingMode { get; public set; }
    public InkCanvasEditingMode EditingModeInverted { get; public set; }
    [DesignerSerializationVisibilityAttribute("0")]
public bool UseCustomCursor { get; public set; }
    public bool MoveEnabled { get; public set; }
    public bool ResizeEnabled { get; public set; }
    [DesignerSerializationVisibilityAttribute("0")]
public StylusPointDescription DefaultStylusPointDescription { get; public set; }
    [DesignerSerializationVisibilityAttribute("0")]
public IEnumerable`1<InkCanvasClipboardFormat> PreferredPasteFormats { get; public set; }
    protected internal IEnumerator LogicalChildren { get; }
    protected DynamicRenderer DynamicRenderer { get; protected set; }
    protected InkPresenter InkPresenter { get; }
    internal EditingCoordinator EditingCoordinator { get; }
    internal DynamicRenderer InternalDynamicRenderer { get; }
    internal InkCanvasInnerCanvas InnerCanvas { get; }
    internal InkCanvasSelection InkCanvasSelection { get; }
    private ClipboardProcessor ClipboardProcessor { get; }
    private GestureRecognizer GestureRecognizer { get; }
    private static InkCanvas();
    private void Initialize();
    private void InitializeInkObject();
    protected virtual Size MeasureOverride(Size availableSize);
    protected virtual Size ArrangeOverride(Size arrangeSize);
    protected virtual HitTestResult HitTestCore(PointHitTestParameters hitTestParams);
    protected virtual void OnPropertyChanged(DependencyPropertyChangedEventArgs e);
    internal virtual void OnPreApplyTemplate();
    protected virtual int get_VisualChildrenCount();
    protected virtual Visual GetVisualChild(int index);
    protected virtual AutomationPeer OnCreateAutomationPeer();
    public Brush get_Background();
    public void set_Background(Brush value);
    [TypeConverterAttribute("System.Windows.LengthConverter, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")]
[AttachedPropertyBrowsableForChildrenAttribute]
public static double GetTop(UIElement element);
    public static void SetTop(UIElement element, double length);
    [TypeConverterAttribute("System.Windows.LengthConverter, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")]
[AttachedPropertyBrowsableForChildrenAttribute]
public static double GetBottom(UIElement element);
    public static void SetBottom(UIElement element, double length);
    [AttachedPropertyBrowsableForChildrenAttribute]
[TypeConverterAttribute("System.Windows.LengthConverter, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")]
public static double GetLeft(UIElement element);
    public static void SetLeft(UIElement element, double length);
    [TypeConverterAttribute("System.Windows.LengthConverter, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")]
[AttachedPropertyBrowsableForChildrenAttribute]
public static double GetRight(UIElement element);
    public static void SetRight(UIElement element, double length);
    private static void OnPositioningChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public StrokeCollection get_Strokes();
    public void set_Strokes(StrokeCollection value);
    private static void OnStrokesChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    internal InkCanvasSelectionAdorner get_SelectionAdorner();
    internal InkCanvasFeedbackAdorner get_FeedbackAdorner();
    public bool get_IsGestureRecognizerAvailable();
    public UIElementCollection get_Children();
    public DrawingAttributes get_DefaultDrawingAttributes();
    public void set_DefaultDrawingAttributes(DrawingAttributes value);
    private static void OnDefaultDrawingAttributesChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public StylusShape get_EraserShape();
    public void set_EraserShape(StylusShape value);
    public InkCanvasEditingMode get_ActiveEditingMode();
    public InkCanvasEditingMode get_EditingMode();
    public void set_EditingMode(InkCanvasEditingMode value);
    private static void OnEditingModeChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public InkCanvasEditingMode get_EditingModeInverted();
    public void set_EditingModeInverted(InkCanvasEditingMode value);
    private static void OnEditingModeInvertedChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static bool ValidateEditingMode(object value);
    public bool get_UseCustomCursor();
    public void set_UseCustomCursor(bool value);
    public bool get_MoveEnabled();
    public void set_MoveEnabled(bool value);
    public bool get_ResizeEnabled();
    public void set_ResizeEnabled(bool value);
    public StylusPointDescription get_DefaultStylusPointDescription();
    public void set_DefaultStylusPointDescription(StylusPointDescription value);
    public IEnumerable`1<InkCanvasClipboardFormat> get_PreferredPasteFormats();
    public void set_PreferredPasteFormats(IEnumerable`1<InkCanvasClipboardFormat> value);
    public void add_StrokeCollected(InkCanvasStrokeCollectedEventHandler value);
    public void remove_StrokeCollected(InkCanvasStrokeCollectedEventHandler value);
    protected virtual void OnStrokeCollected(InkCanvasStrokeCollectedEventArgs e);
    internal void RaiseGestureOrStrokeCollected(InkCanvasStrokeCollectedEventArgs e, bool userInitiated);
    public void add_Gesture(InkCanvasGestureEventHandler value);
    public void remove_Gesture(InkCanvasGestureEventHandler value);
    protected virtual void OnGesture(InkCanvasGestureEventArgs e);
    [CompilerGeneratedAttribute]
public void add_StrokesReplaced(InkCanvasStrokesReplacedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_StrokesReplaced(InkCanvasStrokesReplacedEventHandler value);
    protected virtual void OnStrokesReplaced(InkCanvasStrokesReplacedEventArgs e);
    [CompilerGeneratedAttribute]
public void add_DefaultDrawingAttributesReplaced(DrawingAttributesReplacedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_DefaultDrawingAttributesReplaced(DrawingAttributesReplacedEventHandler value);
    protected virtual void OnDefaultDrawingAttributesReplaced(DrawingAttributesReplacedEventArgs e);
    private void RaiseDefaultDrawingAttributeReplaced(DrawingAttributesReplacedEventArgs e);
    public void add_ActiveEditingModeChanged(RoutedEventHandler value);
    public void remove_ActiveEditingModeChanged(RoutedEventHandler value);
    protected virtual void OnActiveEditingModeChanged(RoutedEventArgs e);
    internal void RaiseActiveEditingModeChanged(RoutedEventArgs e);
    public void add_EditingModeChanged(RoutedEventHandler value);
    public void remove_EditingModeChanged(RoutedEventHandler value);
    protected virtual void OnEditingModeChanged(RoutedEventArgs e);
    private void RaiseEditingModeChanged(RoutedEventArgs e);
    public void add_EditingModeInvertedChanged(RoutedEventHandler value);
    public void remove_EditingModeInvertedChanged(RoutedEventHandler value);
    protected virtual void OnEditingModeInvertedChanged(RoutedEventArgs e);
    private void RaiseEditingModeInvertedChanged(RoutedEventArgs e);
    [CompilerGeneratedAttribute]
public void add_SelectionMoving(InkCanvasSelectionEditingEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_SelectionMoving(InkCanvasSelectionEditingEventHandler value);
    protected virtual void OnSelectionMoving(InkCanvasSelectionEditingEventArgs e);
    internal void RaiseSelectionMoving(InkCanvasSelectionEditingEventArgs e);
    [CompilerGeneratedAttribute]
public void add_SelectionMoved(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_SelectionMoved(EventHandler value);
    protected virtual void OnSelectionMoved(EventArgs e);
    internal void RaiseSelectionMoved(EventArgs e);
    [CompilerGeneratedAttribute]
public void add_StrokeErasing(InkCanvasStrokeErasingEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_StrokeErasing(InkCanvasStrokeErasingEventHandler value);
    protected virtual void OnStrokeErasing(InkCanvasStrokeErasingEventArgs e);
    internal void RaiseStrokeErasing(InkCanvasStrokeErasingEventArgs e);
    public void add_StrokeErased(RoutedEventHandler value);
    public void remove_StrokeErased(RoutedEventHandler value);
    protected virtual void OnStrokeErased(RoutedEventArgs e);
    internal void RaiseInkErased();
    [CompilerGeneratedAttribute]
public void add_SelectionResizing(InkCanvasSelectionEditingEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_SelectionResizing(InkCanvasSelectionEditingEventHandler value);
    protected virtual void OnSelectionResizing(InkCanvasSelectionEditingEventArgs e);
    internal void RaiseSelectionResizing(InkCanvasSelectionEditingEventArgs e);
    [CompilerGeneratedAttribute]
public void add_SelectionResized(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_SelectionResized(EventHandler value);
    protected virtual void OnSelectionResized(EventArgs e);
    internal void RaiseSelectionResized(EventArgs e);
    [CompilerGeneratedAttribute]
public void add_SelectionChanging(InkCanvasSelectionChangingEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_SelectionChanging(InkCanvasSelectionChangingEventHandler value);
    protected virtual void OnSelectionChanging(InkCanvasSelectionChangingEventArgs e);
    private void RaiseSelectionChanging(InkCanvasSelectionChangingEventArgs e);
    [CompilerGeneratedAttribute]
public void add_SelectionChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_SelectionChanged(EventHandler value);
    protected virtual void OnSelectionChanged(EventArgs e);
    internal void RaiseSelectionChanged(EventArgs e);
    internal void RaiseOnVisualChildrenChanged(DependencyObject visualAdded, DependencyObject visualRemoved);
    public ReadOnlyCollection`1<ApplicationGesture> GetEnabledGestures();
    public void SetEnabledGestures(IEnumerable`1<ApplicationGesture> applicationGestures);
    public Rect GetSelectionBounds();
    public ReadOnlyCollection`1<UIElement> GetSelectedElements();
    public StrokeCollection GetSelectedStrokes();
    public void Select(StrokeCollection selectedStrokes);
    public void Select(IEnumerable`1<UIElement> selectedElements);
    public void Select(StrokeCollection selectedStrokes, IEnumerable`1<UIElement> selectedElements);
    public InkCanvasSelectionHitResult HitTestSelection(Point point);
    public void CopySelection();
    public void CutSelection();
    public void Paste();
    public void Paste(Point point);
    public bool CanPaste();
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object value);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string textData);
    protected internal virtual IEnumerator get_LogicalChildren();
    protected DynamicRenderer get_DynamicRenderer();
    protected void set_DynamicRenderer(DynamicRenderer value);
    protected InkPresenter get_InkPresenter();
    private bool UserInitiatedCanPaste();
    private bool PrivateCanPaste();
    internal void PasteFromDataObject(IDataObject dataObj, Point point);
    private InkCanvasClipboardDataFormats CopyToDataObject();
    internal EditingCoordinator get_EditingCoordinator();
    internal DynamicRenderer get_InternalDynamicRenderer();
    internal InkCanvasInnerCanvas get_InnerCanvas();
    internal InkCanvasSelection get_InkCanvasSelection();
    internal void BeginDynamicSelection(Visual visual);
    internal void UpdateDynamicSelection(StrokeCollection strokesToDynamicallySelect, StrokeCollection strokesToDynamicallyUnselect);
    internal StrokeCollection EndDynamicSelection(Visual visual);
    internal bool ClearSelectionRaiseSelectionChanging();
    internal void ClearSelection(bool raiseSelectionChangedEvent);
    internal void ChangeInkCanvasSelection(StrokeCollection strokes, UIElement[] elements);
    private void CoreChangeSelection(StrokeCollection validStrokes, IList`1<UIElement> validElements, bool raiseSelectionChanged);
    internal static StrokeCollection GetValidStrokes(StrokeCollection subset, StrokeCollection superset);
    private static void _RegisterClipboardHandlers();
    private StrokeCollection ValidateSelectedStrokes(StrokeCollection strokes);
    private UIElement[] ValidateSelectedElements(IEnumerable`1<UIElement> selectedElements);
    private bool InkCanvasIsAncestorOf(UIElement element);
    private void DefaultDrawingAttributes_Changed(object sender, PropertyDataChangedEventArgs args);
    internal void UpdateDynamicRenderer();
    private void UpdateDynamicRenderer(DrawingAttributes newDrawingAttributes);
    private bool EnsureActiveEditingMode(InkCanvasEditingMode newEditingMode);
    private ClipboardProcessor get_ClipboardProcessor();
    private GestureRecognizer get_GestureRecognizer();
    private void DeleteCurrentSelection(bool removeSelectedStrokes, bool removeSelectedElements);
    private static void _OnCommandExecuted(object sender, ExecutedRoutedEventArgs args);
    private static void _OnQueryCommandEnabled(object sender, CanExecuteRoutedEventArgs args);
    private InkCanvasClipboardDataFormats PrivateCopySelection();
    private static void _OnDeviceDown(object sender, TEventArgs e);
    private static void _OnDeviceUp(object sender, TEventArgs e);
    private static void _OnQueryCursor(object sender, QueryCursorEventArgs e);
    internal void UpdateCursor();
}
public enum System.Windows.Controls.InkCanvasClipboardFormat : Enum {
    public int value__;
    public static InkCanvasClipboardFormat InkSerializedFormat;
    public static InkCanvasClipboardFormat Text;
    public static InkCanvasClipboardFormat Xaml;
}
public enum System.Windows.Controls.InkCanvasEditingMode : Enum {
    public int value__;
    public static InkCanvasEditingMode None;
    public static InkCanvasEditingMode Ink;
    public static InkCanvasEditingMode GestureOnly;
    public static InkCanvasEditingMode InkAndGesture;
    public static InkCanvasEditingMode Select;
    public static InkCanvasEditingMode EraseByPoint;
    public static InkCanvasEditingMode EraseByStroke;
}
public class System.Windows.Controls.InkCanvasGestureEventArgs : RoutedEventArgs {
    private StrokeCollection _strokes;
    private List`1<GestureRecognitionResult> _gestureRecognitionResults;
    private bool _cancel;
    public StrokeCollection Strokes { get; }
    public bool Cancel { get; public set; }
    public InkCanvasGestureEventArgs(StrokeCollection strokes, IEnumerable`1<GestureRecognitionResult> gestureRecognitionResults);
    public StrokeCollection get_Strokes();
    public ReadOnlyCollection`1<GestureRecognitionResult> GetGestureRecognitionResults();
    public bool get_Cancel();
    public void set_Cancel(bool value);
    protected virtual void InvokeEventHandler(Delegate genericHandler, object genericTarget);
}
public class System.Windows.Controls.InkCanvasGestureEventHandler : MulticastDelegate {
    public InkCanvasGestureEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, InkCanvasGestureEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, InkCanvasGestureEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Windows.Controls.InkCanvasSelectionChangingEventArgs : CancelEventArgs {
    private StrokeCollection _strokes;
    private List`1<UIElement> _elements;
    private bool _strokesChanged;
    private bool _elementsChanged;
    internal bool StrokesChanged { get; }
    internal bool ElementsChanged { get; }
    internal InkCanvasSelectionChangingEventArgs(StrokeCollection selectedStrokes, IEnumerable`1<UIElement> selectedElements);
    internal bool get_StrokesChanged();
    internal bool get_ElementsChanged();
    public void SetSelectedElements(IEnumerable`1<UIElement> selectedElements);
    public ReadOnlyCollection`1<UIElement> GetSelectedElements();
    public void SetSelectedStrokes(StrokeCollection selectedStrokes);
    public StrokeCollection GetSelectedStrokes();
}
public class System.Windows.Controls.InkCanvasSelectionChangingEventHandler : MulticastDelegate {
    public InkCanvasSelectionChangingEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, InkCanvasSelectionChangingEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, InkCanvasSelectionChangingEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Windows.Controls.InkCanvasSelectionEditingEventArgs : CancelEventArgs {
    private Rect _oldRectangle;
    private Rect _newRectangle;
    public Rect OldRectangle { get; }
    public Rect NewRectangle { get; public set; }
    internal InkCanvasSelectionEditingEventArgs(Rect oldRectangle, Rect newRectangle);
    public Rect get_OldRectangle();
    public Rect get_NewRectangle();
    public void set_NewRectangle(Rect value);
}
public class System.Windows.Controls.InkCanvasSelectionEditingEventHandler : MulticastDelegate {
    public InkCanvasSelectionEditingEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, InkCanvasSelectionEditingEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, InkCanvasSelectionEditingEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public enum System.Windows.Controls.InkCanvasSelectionHitResult : Enum {
    public int value__;
    public static InkCanvasSelectionHitResult None;
    public static InkCanvasSelectionHitResult TopLeft;
    public static InkCanvasSelectionHitResult Top;
    public static InkCanvasSelectionHitResult TopRight;
    public static InkCanvasSelectionHitResult Right;
    public static InkCanvasSelectionHitResult BottomRight;
    public static InkCanvasSelectionHitResult Bottom;
    public static InkCanvasSelectionHitResult BottomLeft;
    public static InkCanvasSelectionHitResult Left;
    public static InkCanvasSelectionHitResult Selection;
}
public class System.Windows.Controls.InkCanvasStrokeCollectedEventArgs : RoutedEventArgs {
    private Stroke _stroke;
    public Stroke Stroke { get; }
    public InkCanvasStrokeCollectedEventArgs(Stroke stroke);
    public Stroke get_Stroke();
    protected virtual void InvokeEventHandler(Delegate genericHandler, object genericTarget);
}
public class System.Windows.Controls.InkCanvasStrokeCollectedEventHandler : MulticastDelegate {
    public InkCanvasStrokeCollectedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, InkCanvasStrokeCollectedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, InkCanvasStrokeCollectedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Windows.Controls.InkCanvasStrokeErasingEventArgs : CancelEventArgs {
    private Stroke _stroke;
    public Stroke Stroke { get; }
    internal InkCanvasStrokeErasingEventArgs(Stroke stroke);
    public Stroke get_Stroke();
}
public class System.Windows.Controls.InkCanvasStrokeErasingEventHandler : MulticastDelegate {
    public InkCanvasStrokeErasingEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, InkCanvasStrokeErasingEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, InkCanvasStrokeErasingEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Windows.Controls.InkCanvasStrokesReplacedEventArgs : EventArgs {
    private StrokeCollection _newStrokes;
    private StrokeCollection _previousStrokes;
    public StrokeCollection NewStrokes { get; }
    public StrokeCollection PreviousStrokes { get; }
    internal InkCanvasStrokesReplacedEventArgs(StrokeCollection newStrokes, StrokeCollection previousStrokes);
    public StrokeCollection get_NewStrokes();
    public StrokeCollection get_PreviousStrokes();
}
public class System.Windows.Controls.InkCanvasStrokesReplacedEventHandler : MulticastDelegate {
    public InkCanvasStrokesReplacedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, InkCanvasStrokesReplacedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, InkCanvasStrokesReplacedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Windows.Controls.InkPresenter : Decorator {
    public static DependencyProperty StrokesProperty;
    private Renderer _renderer;
    private Nullable`1<Rect> _cachedBounds;
    private bool _hasAddedRoot;
    private InkPresenterHighContrastCallback _contrastCallback;
    private Size _constraintSize;
    public StrokeCollection Strokes { get; public set; }
    protected int VisualChildrenCount { get; }
    private Rect StrokesBounds { get; }
    private static InkPresenter();
    public void AttachVisuals(Visual visual, DrawingAttributes drawingAttributes);
    public void DetachVisuals(Visual visual);
    public StrokeCollection get_Strokes();
    public void set_Strokes(StrokeCollection value);
    private static void OnStrokesChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    protected virtual Size MeasureOverride(Size constraint);
    protected virtual Size ArrangeOverride(Size arrangeSize);
    protected virtual Geometry GetLayoutClip(Size layoutSlotSize);
    protected virtual Visual GetVisualChild(int index);
    protected virtual int get_VisualChildrenCount();
    protected virtual AutomationPeer OnCreateAutomationPeer();
    internal bool ContainsAttachedVisual(Visual visual);
    internal bool AttachedVisualIsPositionedCorrectly(Visual visual, DrawingAttributes drawingAttributes);
    private void SetStrokesChangedHandlers(StrokeCollection newStrokes, StrokeCollection oldStrokes);
    private void OnStrokesChanged(object sender, StrokeCollectionChangedEventArgs eventArgs);
    private void SetStrokeChangedHandlers(StrokeCollection addedStrokes, StrokeCollection removedStrokes);
    private void OnStrokeChanged(object sender, EventArgs e);
    private void OnStrokeChanged();
    private void StartListeningOnStrokeEvents(Stroke stroke);
    private void StopListeningOnStrokeEvents(Stroke stroke);
    private void EnsureRootVisual();
    private Rect get_StrokesBounds();
}
internal interface System.Windows.Controls.IProvideDataGridColumn {
    public DataGridColumn Column { get; }
    public abstract virtual DataGridColumn get_Column();
}
internal interface System.Windows.Controls.IStackMeasure {
    public bool IsScrolling { get; }
    public UIElementCollection InternalChildren { get; }
    public Orientation Orientation { get; }
    public bool CanVerticallyScroll { get; }
    public bool CanHorizontallyScroll { get; }
    public abstract virtual bool get_IsScrolling();
    public abstract virtual UIElementCollection get_InternalChildren();
    public abstract virtual Orientation get_Orientation();
    public abstract virtual bool get_CanVerticallyScroll();
    public abstract virtual bool get_CanHorizontallyScroll();
    public abstract virtual void OnScrollChange();
}
internal interface System.Windows.Controls.IStackMeasureScrollData {
    public Vector Offset { get; public set; }
    public Size Viewport { get; public set; }
    public Size Extent { get; public set; }
    public Vector ComputedOffset { get; public set; }
    public abstract virtual Vector get_Offset();
    public abstract virtual void set_Offset(Vector value);
    public abstract virtual Size get_Viewport();
    public abstract virtual void set_Viewport(Size value);
    public abstract virtual Size get_Extent();
    public abstract virtual void set_Extent(Size value);
    public abstract virtual Vector get_ComputedOffset();
    public abstract virtual void set_ComputedOffset(Vector value);
    public abstract virtual void SetPhysicalViewport(double value);
}
[DefaultMemberAttribute("Item")]
[LocalizabilityAttribute("16")]
public class System.Windows.Controls.ItemCollection : CollectionView {
    private InnerItemCollectionView _internalView;
    private IEnumerable _itemsSource;
    private CollectionView _collectionView;
    private int _defaultCapacity;
    private bool _isUsingItemsSource;
    private bool _isInitializing;
    private int _deferLevel;
    private IDisposable _deferInnerRefresh;
    private ShapingStorage _shapingStorage;
    private WeakReference _modelParent;
    public int Count { get; }
    public bool IsEmpty { get; }
    public object Item { get; public set; }
    public IEnumerable SourceCollection { get; }
    public bool NeedsRefresh { get; }
    public SortDescriptionCollection SortDescriptions { get; }
    public bool CanSort { get; }
    public Predicate`1<object> Filter { get; public set; }
    public bool CanFilter { get; }
    public bool CanGroup { get; }
    public ObservableCollection`1<GroupDescription> GroupDescriptions { get; }
    public ReadOnlyObservableCollection`1<object> Groups { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    public int CurrentPosition { get; }
    public object CurrentItem { get; }
    public bool IsCurrentAfterLast { get; }
    public bool IsCurrentBeforeFirst { get; }
    private NewItemPlaceholderPosition System.ComponentModel.IEditableCollectionView.NewItemPlaceholderPosition { get; private set; }
    private bool System.ComponentModel.IEditableCollectionView.CanAddNew { get; }
    private bool System.ComponentModel.IEditableCollectionView.IsAddingNew { get; }
    private object System.ComponentModel.IEditableCollectionView.CurrentAddItem { get; }
    private bool System.ComponentModel.IEditableCollectionView.CanRemove { get; }
    private bool System.ComponentModel.IEditableCollectionView.CanCancelEdit { get; }
    private bool System.ComponentModel.IEditableCollectionView.IsEditingItem { get; }
    private object System.ComponentModel.IEditableCollectionView.CurrentEditItem { get; }
    private bool System.ComponentModel.IEditableCollectionViewAddNewItem.CanAddNewItem { get; }
    public bool CanChangeLiveSorting { get; }
    public bool CanChangeLiveFiltering { get; }
    public bool CanChangeLiveGrouping { get; }
    public Nullable`1<bool> IsLiveSorting { get; public set; }
    public Nullable`1<bool> IsLiveFiltering { get; public set; }
    public Nullable`1<bool> IsLiveGrouping { get; public set; }
    public ObservableCollection`1<string> LiveSortingProperties { get; }
    public ObservableCollection`1<string> LiveFilteringProperties { get; }
    public ObservableCollection`1<string> LiveGroupingProperties { get; }
    private ReadOnlyCollection`1<ItemPropertyInfo> System.ComponentModel.IItemProperties.ItemProperties { get; }
    internal DependencyObject ModelParent { get; }
    internal FrameworkElement ModelParentFE { get; }
    internal IEnumerable ItemsSource { get; }
    internal bool IsUsingItemsSource { get; }
    internal CollectionView CollectionView { get; }
    internal IEnumerator LogicalChildren { get; }
    private bool IsRefreshDeferred { get; }
    private bool IsShapingActive { get; }
    private SortDescriptionCollection MySortDescriptions { get; private set; }
    private bool IsSortingSet { get; private set; }
    private MonitorWrapper SortDescriptionsMonitor { get; }
    private Predicate`1<object> MyFilter { get; private set; }
    private ObservableCollection`1<GroupDescription> MyGroupDescriptions { get; private set; }
    private bool IsGroupingSet { get; private set; }
    private MonitorWrapper GroupDescriptionsMonitor { get; }
    private Nullable`1<bool> MyIsLiveSorting { get; private set; }
    private ObservableCollection`1<string> MyLiveSortingProperties { get; private set; }
    private bool IsLiveSortingSet { get; private set; }
    private MonitorWrapper LiveSortingMonitor { get; }
    private Nullable`1<bool> MyIsLiveFiltering { get; private set; }
    private ObservableCollection`1<string> MyLiveFilteringProperties { get; private set; }
    private bool IsLiveFilteringSet { get; private set; }
    private MonitorWrapper LiveFilteringMonitor { get; }
    private Nullable`1<bool> MyIsLiveGrouping { get; private set; }
    private ObservableCollection`1<string> MyLiveGroupingProperties { get; private set; }
    private bool IsLiveGroupingSet { get; private set; }
    private MonitorWrapper LiveGroupingMonitor { get; }
    internal ItemCollection(DependencyObject modelParent);
    internal ItemCollection(FrameworkElement modelParent, int capacity);
    public virtual bool MoveCurrentToFirst();
    public virtual bool MoveCurrentToNext();
    public virtual bool MoveCurrentToPrevious();
    public virtual bool MoveCurrentToLast();
    public virtual bool MoveCurrentTo(object item);
    public virtual bool MoveCurrentToPosition(int position);
    protected virtual IEnumerator GetEnumerator();
    public sealed virtual int Add(object newItem);
    public sealed virtual void Clear();
    public virtual bool Contains(object containItem);
    public sealed virtual void CopyTo(Array array, int index);
    public virtual int IndexOf(object item);
    public virtual object GetItemAt(int index);
    public sealed virtual void Insert(int insertIndex, object insertItem);
    public sealed virtual void Remove(object removeItem);
    public sealed virtual void RemoveAt(int removeIndex);
    public virtual bool PassesFilter(object item);
    protected virtual void RefreshOverride();
    public virtual int get_Count();
    public virtual bool get_IsEmpty();
    public sealed virtual object get_Item(int index);
    public sealed virtual void set_Item(int index, object value);
    public virtual IEnumerable get_SourceCollection();
    public virtual bool get_NeedsRefresh();
    public virtual SortDescriptionCollection get_SortDescriptions();
    public virtual bool get_CanSort();
    public virtual Predicate`1<object> get_Filter();
    public virtual void set_Filter(Predicate`1<object> value);
    public virtual bool get_CanFilter();
    public virtual bool get_CanGroup();
    public virtual ObservableCollection`1<GroupDescription> get_GroupDescriptions();
    public virtual ReadOnlyObservableCollection`1<object> get_Groups();
    public virtual IDisposable DeferRefresh();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    public virtual int get_CurrentPosition();
    public virtual object get_CurrentItem();
    public virtual bool get_IsCurrentAfterLast();
    public virtual bool get_IsCurrentBeforeFirst();
    private sealed virtual override NewItemPlaceholderPosition System.ComponentModel.IEditableCollectionView.get_NewItemPlaceholderPosition();
    private sealed virtual override void System.ComponentModel.IEditableCollectionView.set_NewItemPlaceholderPosition(NewItemPlaceholderPosition value);
    private sealed virtual override bool System.ComponentModel.IEditableCollectionView.get_CanAddNew();
    private sealed virtual override object System.ComponentModel.IEditableCollectionView.AddNew();
    private sealed virtual override void System.ComponentModel.IEditableCollectionView.CommitNew();
    private sealed virtual override void System.ComponentModel.IEditableCollectionView.CancelNew();
    private sealed virtual override bool System.ComponentModel.IEditableCollectionView.get_IsAddingNew();
    private sealed virtual override object System.ComponentModel.IEditableCollectionView.get_CurrentAddItem();
    private sealed virtual override bool System.ComponentModel.IEditableCollectionView.get_CanRemove();
    private sealed virtual override void System.ComponentModel.IEditableCollectionView.RemoveAt(int index);
    private sealed virtual override void System.ComponentModel.IEditableCollectionView.Remove(object item);
    private sealed virtual override void System.ComponentModel.IEditableCollectionView.EditItem(object item);
    private sealed virtual override void System.ComponentModel.IEditableCollectionView.CommitEdit();
    private sealed virtual override void System.ComponentModel.IEditableCollectionView.CancelEdit();
    private sealed virtual override bool System.ComponentModel.IEditableCollectionView.get_CanCancelEdit();
    private sealed virtual override bool System.ComponentModel.IEditableCollectionView.get_IsEditingItem();
    private sealed virtual override object System.ComponentModel.IEditableCollectionView.get_CurrentEditItem();
    private sealed virtual override bool System.ComponentModel.IEditableCollectionViewAddNewItem.get_CanAddNewItem();
    private sealed virtual override object System.ComponentModel.IEditableCollectionViewAddNewItem.AddNewItem(object newItem);
    public sealed virtual bool get_CanChangeLiveSorting();
    public sealed virtual bool get_CanChangeLiveFiltering();
    public sealed virtual bool get_CanChangeLiveGrouping();
    public sealed virtual Nullable`1<bool> get_IsLiveSorting();
    public sealed virtual void set_IsLiveSorting(Nullable`1<bool> value);
    public sealed virtual Nullable`1<bool> get_IsLiveFiltering();
    public sealed virtual void set_IsLiveFiltering(Nullable`1<bool> value);
    public sealed virtual Nullable`1<bool> get_IsLiveGrouping();
    public sealed virtual void set_IsLiveGrouping(Nullable`1<bool> value);
    public sealed virtual ObservableCollection`1<string> get_LiveSortingProperties();
    public sealed virtual ObservableCollection`1<string> get_LiveFilteringProperties();
    public sealed virtual ObservableCollection`1<string> get_LiveGroupingProperties();
    private sealed virtual override ReadOnlyCollection`1<ItemPropertyInfo> System.ComponentModel.IItemProperties.get_ItemProperties();
    internal DependencyObject get_ModelParent();
    internal FrameworkElement get_ModelParentFE();
    internal void SetItemsSource(IEnumerable value, Func`2<object, object> GetSourceItem);
    internal void ClearItemsSource();
    internal IEnumerable get_ItemsSource();
    internal bool get_IsUsingItemsSource();
    internal CollectionView get_CollectionView();
    internal void BeginInit();
    internal void EndInit();
    internal IEnumerator get_LogicalChildren();
    internal virtual void GetCollectionChangedSources(int level, Action`4<int, object, Nullable`1<bool>, List`1<string>> format, List`1<string> sources);
    private bool get_IsRefreshDeferred();
    private bool EnsureCollectionView();
    private void EnsureInternalView();
    private void SetCollectionView(CollectionView view);
    private void ApplySortFilterAndGroup();
    private void HookCollectionView(CollectionView view);
    private void UnhookCollectionView(CollectionView view);
    private void OnViewCollectionChanged(object sender, NotifyCollectionChangedEventArgs e);
    private void OnCurrentChanged(object sender, EventArgs e);
    private void OnCurrentChanging(object sender, CurrentChangingEventArgs e);
    private void OnViewPropertyChanged(object sender, PropertyChangedEventArgs e);
    private sealed virtual override bool System.Windows.IWeakEventListener.ReceiveWeakEvent(Type managerType, object sender, EventArgs e);
    private void CheckIsUsingInnerView();
    private void EndDefer();
    private void VerifyRefreshNotDeferred();
    private void SortDescriptionsChanged(object sender, NotifyCollectionChangedEventArgs e);
    private void OnInnerSortDescriptionsChanged(object sender, NotifyCollectionChangedEventArgs e);
    private void GroupDescriptionsChanged(object sender, NotifyCollectionChangedEventArgs e);
    private void OnInnerGroupDescriptionsChanged(object sender, NotifyCollectionChangedEventArgs e);
    private void LiveSortingChanged(object sender, NotifyCollectionChangedEventArgs e);
    private void OnInnerLiveSortingChanged(object sender, NotifyCollectionChangedEventArgs e);
    private void LiveFilteringChanged(object sender, NotifyCollectionChangedEventArgs e);
    private void OnInnerLiveFilteringChanged(object sender, NotifyCollectionChangedEventArgs e);
    private void LiveGroupingChanged(object sender, NotifyCollectionChangedEventArgs e);
    private void OnInnerLiveGroupingChanged(object sender, NotifyCollectionChangedEventArgs e);
    private void SynchronizeCollections(NotifyCollectionChangedEventArgs e, Collection`1<T> origin, Collection`1<T> clone);
    private void CloneList(IList clone, IList master);
    private bool get_IsShapingActive();
    private void EnsureShapingStorage();
    private SortDescriptionCollection get_MySortDescriptions();
    private void set_MySortDescriptions(SortDescriptionCollection value);
    private bool get_IsSortingSet();
    private void set_IsSortingSet(bool value);
    private MonitorWrapper get_SortDescriptionsMonitor();
    private Predicate`1<object> get_MyFilter();
    private void set_MyFilter(Predicate`1<object> value);
    private ObservableCollection`1<GroupDescription> get_MyGroupDescriptions();
    private void set_MyGroupDescriptions(ObservableCollection`1<GroupDescription> value);
    private bool get_IsGroupingSet();
    private void set_IsGroupingSet(bool value);
    private MonitorWrapper get_GroupDescriptionsMonitor();
    private Nullable`1<bool> get_MyIsLiveSorting();
    private void set_MyIsLiveSorting(Nullable`1<bool> value);
    private ObservableCollection`1<string> get_MyLiveSortingProperties();
    private void set_MyLiveSortingProperties(ObservableCollection`1<string> value);
    private bool get_IsLiveSortingSet();
    private void set_IsLiveSortingSet(bool value);
    private MonitorWrapper get_LiveSortingMonitor();
    private Nullable`1<bool> get_MyIsLiveFiltering();
    private void set_MyIsLiveFiltering(Nullable`1<bool> value);
    private ObservableCollection`1<string> get_MyLiveFilteringProperties();
    private void set_MyLiveFilteringProperties(ObservableCollection`1<string> value);
    private bool get_IsLiveFilteringSet();
    private void set_IsLiveFilteringSet(bool value);
    private MonitorWrapper get_LiveFilteringMonitor();
    private Nullable`1<bool> get_MyIsLiveGrouping();
    private void set_MyIsLiveGrouping(Nullable`1<bool> value);
    private ObservableCollection`1<string> get_MyLiveGroupingProperties();
    private void set_MyLiveGroupingProperties(ObservableCollection`1<string> value);
    private bool get_IsLiveGroupingSet();
    private void set_IsLiveGroupingSet(bool value);
    private MonitorWrapper get_LiveGroupingMonitor();
}
public class System.Windows.Controls.ItemContainerGenerator : object {
    [CompilerGeneratedAttribute]
private ItemsChangedEventHandler ItemsChanged;
    [CompilerGeneratedAttribute]
private EventHandler StatusChanged;
    internal static DependencyProperty ItemForItemContainerProperty;
    [CompilerGeneratedAttribute]
private EventHandler PanelChanged;
    private Generator _generator;
    private IGeneratorHost _host;
    private ItemBlock _itemMap;
    private GeneratorStatus _status;
    private int _itemsGenerated;
    private int _startIndexForUIFromItem;
    private DependencyObject _peer;
    private int _level;
    private IList _items;
    private ReadOnlyCollection`1<object> _itemsReadOnly;
    private GroupStyle _groupStyle;
    private ItemContainerGenerator _parent;
    private ArrayList _emptyGroupItems;
    private int _alternationCount;
    private Type _containerType;
    private Queue`1<DependencyObject> _recyclableContainers;
    private bool _generatesGroupItems;
    private bool _isGeneratingBatches;
    [CompilerGeneratedAttribute]
private MapChangedHandler MapChanged;
    public GeneratorStatus Status { get; }
    public ReadOnlyCollection`1<object> Items { get; }
    internal IEnumerable RecyclableContainers { get; }
    internal ItemContainerGenerator Parent { get; }
    internal int Level { get; }
    internal GroupStyle GroupStyle { get; internal set; }
    internal IList ItemsInternal { get; internal set; }
    private IGeneratorHost Host { get; }
    private DependencyObject Peer { get; }
    private bool IsGrouping { get; }
    internal ItemContainerGenerator(IGeneratorHost host);
    private ItemContainerGenerator(ItemContainerGenerator parent, GroupItem groupItem);
    private ItemContainerGenerator(ItemContainerGenerator parent, IGeneratorHost host, DependencyObject peer, int level);
    private static ItemContainerGenerator();
    public GeneratorStatus get_Status();
    private void SetStatus(GeneratorStatus value);
    public ReadOnlyCollection`1<object> get_Items();
    private sealed virtual override ItemContainerGenerator System.Windows.Controls.Primitives.IItemContainerGenerator.GetItemContainerGeneratorForPanel(Panel panel);
    private sealed virtual override IDisposable System.Windows.Controls.Primitives.IItemContainerGenerator.StartAt(GeneratorPosition position, GeneratorDirection direction);
    private sealed virtual override IDisposable System.Windows.Controls.Primitives.IItemContainerGenerator.StartAt(GeneratorPosition position, GeneratorDirection direction, bool allowStartAtRealizedItem);
    public IDisposable GenerateBatches();
    private sealed virtual override DependencyObject System.Windows.Controls.Primitives.IItemContainerGenerator.GenerateNext();
    private sealed virtual override DependencyObject System.Windows.Controls.Primitives.IItemContainerGenerator.GenerateNext(Boolean& isNewlyRealized);
    private sealed virtual override void System.Windows.Controls.Primitives.IItemContainerGenerator.PrepareItemContainer(DependencyObject container);
    private sealed virtual override void System.Windows.Controls.Primitives.IItemContainerGenerator.Remove(GeneratorPosition position, int count);
    private void Remove(GeneratorPosition position, int count, bool isRecycling);
    private sealed virtual override void System.Windows.Controls.Primitives.IItemContainerGenerator.RemoveAll();
    internal void RemoveAllInternal(bool saveRecycleQueue);
    private void ResetRecyclableContainers();
    private sealed virtual override void System.Windows.Controls.Primitives.IRecyclingItemContainerGenerator.Recycle(GeneratorPosition position, int count);
    private sealed virtual override GeneratorPosition System.Windows.Controls.Primitives.IItemContainerGenerator.GeneratorPositionFromIndex(int itemIndex);
    private sealed virtual override int System.Windows.Controls.Primitives.IItemContainerGenerator.IndexFromGeneratorPosition(GeneratorPosition position);
    public object ItemFromContainer(DependencyObject container);
    public DependencyObject ContainerFromItem(object item);
    public int IndexFromContainer(DependencyObject container);
    public int IndexFromContainer(DependencyObject container, bool returnLocalIndex);
    internal bool FindItem(Func`3<object, DependencyObject, bool> match, DependencyObject& container, Int32& itemIndex);
    private bool DoLinearSearch(Func`3<object, DependencyObject, bool> match, Object& item, DependencyObject& container, Int32& itemIndex, bool returnLocalIndex);
    private int GetCount();
    private int GetCount(ItemBlock stop);
    private int GetCount(ItemBlock stop, bool returnLocalIndex);
    private int GetRealizedItemBlockCount(RealizedItemBlock rib, int end, bool returnLocalIndex);
    public DependencyObject ContainerFromIndex(int index);
    [CompilerGeneratedAttribute]
public void add_ItemsChanged(ItemsChangedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_ItemsChanged(ItemsChangedEventHandler value);
    [CompilerGeneratedAttribute]
public void add_StatusChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_StatusChanged(EventHandler value);
    internal IEnumerable get_RecyclableContainers();
    internal void Refresh();
    internal void Release();
    internal void Verify();
    private void FormatCollectionChangedSource(int level, object source, Nullable`1<bool> isLikely, List`1<string> sources);
    private void GetCollectionChangedSources(int level, Action`4<int, object, Nullable`1<bool>, List`1<string>> format, List`1<string> sources);
    internal void ChangeAlternationCount();
    private void ChangeAlternationCount(int newAlternationCount);
    internal ItemContainerGenerator get_Parent();
    internal int get_Level();
    internal GroupStyle get_GroupStyle();
    internal void set_GroupStyle(GroupStyle value);
    internal IList get_ItemsInternal();
    internal void set_ItemsInternal(IList value);
    [CompilerGeneratedAttribute]
internal void add_PanelChanged(EventHandler value);
    [CompilerGeneratedAttribute]
internal void remove_PanelChanged(EventHandler value);
    internal void OnPanelChanged();
    private IGeneratorHost get_Host();
    private DependencyObject get_Peer();
    private bool get_IsGrouping();
    private void MoveToPosition(GeneratorPosition position, GeneratorDirection direction, bool allowStartAtRealizedItem, GeneratorState& state);
    private void Realize(UnrealizedItemBlock block, int offset, object item, DependencyObject container);
    private void RemoveAndCoalesceBlocksIfNeeded(ItemBlock block);
    private void MoveItems(ItemBlock block, int offset, int count, ItemBlock newBlock, int newOffset, int deltaCount);
    private void SetAlternationIndex(ItemBlock block, int offset, GeneratorDirection direction);
    private DependencyObject ContainerForGroup(CollectionViewGroup group);
    private void PrepareGrouping();
    private void SetAlternationCount();
    private bool ShouldHide(CollectionViewGroup group);
    private void AddEmptyGroupItem(CollectionViewGroup group);
    private void OnSubgroupBecameNonEmpty(EmptyGroupItem groupItem, CollectionViewGroup group);
    private void OnSubgroupBecameEmpty(CollectionViewGroup group);
    private GeneratorPosition PositionFromIndex(int itemIndex);
    private void GetBlockAndPosition(object item, int itemIndex, bool deletedFromItems, GeneratorPosition& position, ItemBlock& block, Int32& offsetFromBlockStart, Int32& correctIndex);
    private void GetBlockAndPosition(int itemIndex, GeneratorPosition& position, ItemBlock& block, Int32& offsetFromBlockStart);
    private void GetBlockAndPosition(object item, bool deletedFromItems, GeneratorPosition& position, ItemBlock& block, Int32& offsetFromBlockStart, Int32& correctIndex);
    internal static void LinkContainerToItem(DependencyObject container, object item);
    private void UnlinkContainerFromItem(DependencyObject container, object item);
    internal static void UnlinkContainerFromItem(DependencyObject container, object item, IGeneratorHost host);
    private sealed virtual override bool System.Windows.IWeakEventListener.ReceiveWeakEvent(Type managerType, object sender, EventArgs e);
    private void OnGroupStylePropertyChanged(object sender, PropertyChangedEventArgs e);
    private void ValidateAndCorrectIndex(object item, Int32& index);
    private void OnCollectionChanged(object sender, NotifyCollectionChangedEventArgs args);
    private void OnItemAdded(object item, int index);
    private void OnItemRemoved(object item, int itemIndex);
    private void OnItemReplaced(object oldItem, object newItem, int index);
    private void OnItemMoved(object item, int oldIndex, int newIndex);
    private void OnRefresh();
    [CompilerGeneratedAttribute]
private void add_MapChanged(MapChangedHandler value);
    [CompilerGeneratedAttribute]
private void remove_MapChanged(MapChangedHandler value);
}
[DictionaryKeyPropertyAttribute("ItemContainerTemplateKey")]
public class System.Windows.Controls.ItemContainerTemplate : DataTemplate {
    public object ItemContainerTemplateKey { get; }
    public object get_ItemContainerTemplateKey();
}
public class System.Windows.Controls.ItemContainerTemplateKey : TemplateKey {
    public ItemContainerTemplateKey(object dataType);
}
public abstract class System.Windows.Controls.ItemContainerTemplateSelector : object {
    public virtual DataTemplate SelectTemplate(object item, ItemsControl parentItemsControl);
}
[DefaultEventAttribute("OnItemsChanged")]
[DefaultPropertyAttribute("Items")]
[ContentPropertyAttribute("Items")]
[StyleTypedPropertyAttribute]
[LocalizabilityAttribute("0")]
public class System.Windows.Controls.ItemsControl : Control {
    [CommonDependencyPropertyAttribute]
public static DependencyProperty ItemsSourceProperty;
    internal static DependencyPropertyKey HasItemsPropertyKey;
    public static DependencyProperty HasItemsProperty;
    public static DependencyProperty DisplayMemberPathProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty ItemTemplateProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty ItemTemplateSelectorProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty ItemStringFormatProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty ItemBindingGroupProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty ItemContainerStyleProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty ItemContainerStyleSelectorProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty ItemsPanelProperty;
    private static DependencyPropertyKey IsGroupingPropertyKey;
    public static DependencyProperty IsGroupingProperty;
    public static DependencyProperty GroupStyleSelectorProperty;
    public static DependencyProperty AlternationCountProperty;
    private static DependencyPropertyKey AlternationIndexPropertyKey;
    public static DependencyProperty AlternationIndexProperty;
    public static DependencyProperty IsTextSearchEnabledProperty;
    public static DependencyProperty IsTextSearchCaseSensitiveProperty;
    private ItemInfo _focusedInfo;
    private ItemCollection _items;
    private ItemContainerGenerator _itemContainerGenerator;
    private Panel _itemsHost;
    private ScrollViewer _scrollHost;
    private ObservableCollection`1<GroupStyle> _groupStyle;
    private static UncommonField`1<bool> ShouldCoerceScrollUnitField;
    private static UncommonField`1<bool> ShouldCoerceCacheSizeField;
    private static DependencyObjectType _dType;
    [DesignerSerializationVisibilityAttribute("2")]
[BindableAttribute("True")]
[CustomCategoryAttribute("Content")]
public ItemCollection Items { get; }
    [BindableAttribute("True")]
[CustomCategoryAttribute("Content")]
[DesignerSerializationVisibilityAttribute("0")]
public IEnumerable ItemsSource { get; public set; }
    [BindableAttribute("False")]
[BrowsableAttribute("False")]
[EditorBrowsableAttribute("2")]
public ItemContainerGenerator ItemContainerGenerator { get; }
    protected internal IEnumerator LogicalChildren { get; }
    [BindableAttribute("False")]
[BrowsableAttribute("False")]
public bool HasItems { get; }
    [BindableAttribute("True")]
[CustomCategoryAttribute("Content")]
public string DisplayMemberPath { get; public set; }
    [BindableAttribute("True")]
[CustomCategoryAttribute("Content")]
public DataTemplate ItemTemplate { get; public set; }
    [CustomCategoryAttribute("Content")]
[BindableAttribute("True")]
[DesignerSerializationVisibilityAttribute("0")]
public DataTemplateSelector ItemTemplateSelector { get; public set; }
    [BindableAttribute("True")]
[CustomCategoryAttribute("Content")]
public string ItemStringFormat { get; public set; }
    [BindableAttribute("True")]
[CustomCategoryAttribute("Content")]
public BindingGroup ItemBindingGroup { get; public set; }
    [BindableAttribute("True")]
[CategoryAttribute("Content")]
public Style ItemContainerStyle { get; public set; }
    [BindableAttribute("True")]
[CategoryAttribute("Content")]
[DesignerSerializationVisibilityAttribute("0")]
public StyleSelector ItemContainerStyleSelector { get; public set; }
    [BindableAttribute("False")]
public ItemsPanelTemplate ItemsPanel { get; public set; }
    [DesignerSerializationVisibilityAttribute("0")]
[BindableAttribute("False")]
public bool IsGrouping { get; }
    [DesignerSerializationVisibilityAttribute("2")]
public ObservableCollection`1<GroupStyle> GroupStyle { get; }
    [DesignerSerializationVisibilityAttribute("0")]
[BindableAttribute("True")]
[CustomCategoryAttribute("Content")]
public GroupStyleSelector GroupStyleSelector { get; public set; }
    [CustomCategoryAttribute("Content")]
[BindableAttribute("True")]
public int AlternationCount { get; public set; }
    public bool IsTextSearchEnabled { get; public set; }
    public bool IsTextSearchCaseSensitive { get; public set; }
    private ItemCollection MS.Internal.Controls.IGeneratorHost.View { get; }
    private int MS.Internal.Controls.IGeneratorHost.AlternationCount { get; }
    private bool IsInitPending { get; }
    internal Panel ItemsHost { get; internal set; }
    internal ItemInfo FocusedInfo { get; }
    internal bool IsLogicalVertical { get; }
    internal bool IsLogicalHorizontal { get; }
    internal ScrollViewer ScrollHost { get; }
    internal static TimeSpan AutoScrollTimeout { get; }
    internal DependencyObjectType DTypeThemeStyleKey { get; }
    private static ItemsControl();
    private static void OnScrollingModeChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static object CoerceScrollingMode(DependencyObject d, object baseValue);
    private static void OnCacheSizeChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static object CoerceVirtualizationCacheLengthUnit(DependencyObject d, object baseValue);
    private void CreateItemCollectionAndGenerator();
    public ItemCollection get_Items();
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeItems();
    private static void OnItemsSourceChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    protected virtual void OnItemsSourceChanged(IEnumerable oldValue, IEnumerable newValue);
    public IEnumerable get_ItemsSource();
    public void set_ItemsSource(IEnumerable value);
    public ItemContainerGenerator get_ItemContainerGenerator();
    protected internal virtual IEnumerator get_LogicalChildren();
    private void OnItemCollectionChanged1(object sender, NotifyCollectionChangedEventArgs e);
    private void OnItemCollectionChanged2(object sender, NotifyCollectionChangedEventArgs e);
    protected virtual void OnItemsChanged(NotifyCollectionChangedEventArgs e);
    internal virtual void AdjustItemInfoOverride(NotifyCollectionChangedEventArgs e);
    public bool get_HasItems();
    public string get_DisplayMemberPath();
    public void set_DisplayMemberPath(string value);
    private static void OnDisplayMemberPathChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private void UpdateDisplayMemberTemplateSelector();
    protected virtual void OnDisplayMemberPathChanged(string oldDisplayMemberPath, string newDisplayMemberPath);
    public DataTemplate get_ItemTemplate();
    public void set_ItemTemplate(DataTemplate value);
    private static void OnItemTemplateChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    protected virtual void OnItemTemplateChanged(DataTemplate oldItemTemplate, DataTemplate newItemTemplate);
    public DataTemplateSelector get_ItemTemplateSelector();
    public void set_ItemTemplateSelector(DataTemplateSelector value);
    private static void OnItemTemplateSelectorChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    protected virtual void OnItemTemplateSelectorChanged(DataTemplateSelector oldItemTemplateSelector, DataTemplateSelector newItemTemplateSelector);
    public string get_ItemStringFormat();
    public void set_ItemStringFormat(string value);
    private static void OnItemStringFormatChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    protected virtual void OnItemStringFormatChanged(string oldItemStringFormat, string newItemStringFormat);
    public BindingGroup get_ItemBindingGroup();
    public void set_ItemBindingGroup(BindingGroup value);
    private static void OnItemBindingGroupChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    protected virtual void OnItemBindingGroupChanged(BindingGroup oldItemBindingGroup, BindingGroup newItemBindingGroup);
    private void CheckTemplateSource();
    public Style get_ItemContainerStyle();
    public void set_ItemContainerStyle(Style value);
    private static void OnItemContainerStyleChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    protected virtual void OnItemContainerStyleChanged(Style oldItemContainerStyle, Style newItemContainerStyle);
    public StyleSelector get_ItemContainerStyleSelector();
    public void set_ItemContainerStyleSelector(StyleSelector value);
    private static void OnItemContainerStyleSelectorChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    protected virtual void OnItemContainerStyleSelectorChanged(StyleSelector oldItemContainerStyleSelector, StyleSelector newItemContainerStyleSelector);
    public static ItemsControl GetItemsOwner(DependencyObject element);
    internal static DependencyObject GetItemsOwnerInternal(DependencyObject element);
    internal static DependencyObject GetItemsOwnerInternal(DependencyObject element, ItemsControl& itemsControl);
    private static ItemsPanelTemplate GetDefaultItemsPanelTemplate();
    public ItemsPanelTemplate get_ItemsPanel();
    public void set_ItemsPanel(ItemsPanelTemplate value);
    private static void OnItemsPanelChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    protected virtual void OnItemsPanelChanged(ItemsPanelTemplate oldItemsPanel, ItemsPanelTemplate newItemsPanel);
    public bool get_IsGrouping();
    private static void OnIsGroupingChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    internal virtual void OnIsGroupingChanged(DependencyPropertyChangedEventArgs e);
    public ObservableCollection`1<GroupStyle> get_GroupStyle();
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeGroupStyle();
    private void OnGroupStyleChanged(object sender, NotifyCollectionChangedEventArgs e);
    public GroupStyleSelector get_GroupStyleSelector();
    public void set_GroupStyleSelector(GroupStyleSelector value);
    private static void OnGroupStyleSelectorChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    protected virtual void OnGroupStyleSelectorChanged(GroupStyleSelector oldGroupStyleSelector, GroupStyleSelector newGroupStyleSelector);
    public int get_AlternationCount();
    public void set_AlternationCount(int value);
    private static void OnAlternationCountChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    protected virtual void OnAlternationCountChanged(int oldAlternationCount, int newAlternationCount);
    public static int GetAlternationIndex(DependencyObject element);
    internal static void SetAlternationIndex(DependencyObject d, int value);
    internal static void ClearAlternationIndex(DependencyObject d);
    public bool get_IsTextSearchEnabled();
    public void set_IsTextSearchEnabled(bool value);
    public bool get_IsTextSearchCaseSensitive();
    public void set_IsTextSearchCaseSensitive(bool value);
    public static ItemsControl ItemsControlFromItemContainer(DependencyObject container);
    public static DependencyObject ContainerFromElement(ItemsControl itemsControl, DependencyObject element);
    public DependencyObject ContainerFromElement(DependencyObject element);
    private static bool IsContainerForItemsControl(DependencyObject element, ItemsControl itemsControl);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object value);
    protected virtual void AddChild(object value);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string text);
    protected virtual void AddText(string text);
    private sealed virtual override ItemCollection MS.Internal.Controls.IGeneratorHost.get_View();
    private sealed virtual override bool MS.Internal.Controls.IGeneratorHost.IsItemItsOwnContainer(object item);
    private sealed virtual override DependencyObject MS.Internal.Controls.IGeneratorHost.GetContainerForItem(object item);
    private sealed virtual override void MS.Internal.Controls.IGeneratorHost.PrepareItemContainer(DependencyObject container, object item);
    private sealed virtual override void MS.Internal.Controls.IGeneratorHost.ClearContainerForItem(DependencyObject container, object item);
    private sealed virtual override bool MS.Internal.Controls.IGeneratorHost.IsHostForItemContainer(DependencyObject container);
    private sealed virtual override GroupStyle MS.Internal.Controls.IGeneratorHost.GetGroupStyle(CollectionViewGroup group, int level);
    private sealed virtual override void MS.Internal.Controls.IGeneratorHost.SetIsGrouping(bool isGrouping);
    private sealed virtual override int MS.Internal.Controls.IGeneratorHost.get_AlternationCount();
    public virtual void BeginInit();
    public virtual void EndInit();
    private bool get_IsInitPending();
    public bool IsItemItsOwnContainer(object item);
    protected virtual bool IsItemItsOwnContainerOverride(object item);
    protected virtual DependencyObject GetContainerForItemOverride();
    protected virtual void PrepareContainerForItemOverride(DependencyObject element, object item);
    protected virtual void ClearContainerForItemOverride(DependencyObject element, object item);
    protected virtual void OnTextInput(TextCompositionEventArgs e);
    protected virtual void OnKeyDown(KeyEventArgs e);
    internal virtual void OnTemplateChangedInternal(FrameworkTemplate oldTemplate, FrameworkTemplate newTemplate);
    protected virtual bool ShouldApplyItemContainerStyle(DependencyObject container, object item);
    internal void PrepareItemsControl(object item, ItemsControl parentItemsControl);
    internal void ClearItemsControl(object item);
    internal object OnBringItemIntoView(object arg);
    internal object OnBringItemIntoView(ItemInfo info);
    internal Panel get_ItemsHost();
    internal void set_ItemsHost(Panel value);
    internal bool NavigateByLine(FocusNavigationDirection direction, ItemNavigateArgs itemNavigateArgs);
    internal void PrepareNavigateByLine(ItemInfo startingInfo, FrameworkElement startingElement, FocusNavigationDirection direction, ItemNavigateArgs itemNavigateArgs, FrameworkElement& container);
    internal bool NavigateByLine(ItemInfo startingInfo, FocusNavigationDirection direction, ItemNavigateArgs itemNavigateArgs);
    internal bool NavigateByLine(ItemInfo startingInfo, FrameworkElement startingElement, FocusNavigationDirection direction, ItemNavigateArgs itemNavigateArgs);
    private bool NavigateByLineInternal(object startingItem, FocusNavigationDirection direction, FrameworkElement startingElement, ItemNavigateArgs itemNavigateArgs, bool shouldFocus, FrameworkElement& container);
    internal void PrepareToNavigateByPage(ItemInfo startingInfo, FrameworkElement startingElement, FocusNavigationDirection direction, ItemNavigateArgs itemNavigateArgs, FrameworkElement& container);
    internal bool NavigateByPage(FocusNavigationDirection direction, ItemNavigateArgs itemNavigateArgs);
    internal bool NavigateByPage(ItemInfo startingInfo, FocusNavigationDirection direction, ItemNavigateArgs itemNavigateArgs);
    internal bool NavigateByPage(ItemInfo startingInfo, FrameworkElement startingElement, FocusNavigationDirection direction, ItemNavigateArgs itemNavigateArgs);
    private bool NavigateByPageInternal(object startingItem, FocusNavigationDirection direction, FrameworkElement startingElement, ItemNavigateArgs itemNavigateArgs, bool shouldFocus, FrameworkElement& container);
    internal void NavigateToStart(ItemNavigateArgs itemNavigateArgs);
    internal bool NavigateToStartInternal(ItemNavigateArgs itemNavigateArgs, bool shouldFocus, FrameworkElement& container);
    internal void NavigateToEnd(ItemNavigateArgs itemNavigateArgs);
    internal bool NavigateToEndInternal(ItemNavigateArgs itemNavigateArgs, bool shouldFocus, FrameworkElement& container);
    private FrameworkElement FindEndFocusableLeafContainer(Panel itemsHost, bool last);
    internal void NavigateToItem(ItemInfo info, ItemNavigateArgs itemNavigateArgs, bool alwaysAtTopOfViewport);
    internal void NavigateToItem(object item, ItemNavigateArgs itemNavigateArgs);
    internal void NavigateToItem(object item, int itemIndex, ItemNavigateArgs itemNavigateArgs);
    internal void NavigateToItem(object item, ItemNavigateArgs itemNavigateArgs, bool alwaysAtTopOfViewport);
    private void NavigateToItem(object item, int elementIndex, ItemNavigateArgs itemNavigateArgs, bool alwaysAtTopOfViewport);
    private object FindFocusable(int startIndex, int direction, Int32& foundIndex, FrameworkElement& foundContainer);
    private void AdjustOffsetToAlignWithEdge(FrameworkElement element, FocusNavigationDirection direction);
    private void MakeVisible(int index, FocusNavigationDirection direction, bool alwaysAtTopOfViewport, FrameworkElement& container);
    private void MakeVisible(ItemInfo info, FocusNavigationDirection direction, FrameworkElement& container);
    internal void MakeVisible(FrameworkElement container, FocusNavigationDirection direction, bool alwaysAtTopOfViewport);
    private bool NavigateToFirstItemOnCurrentPage(object startingItem, FocusNavigationDirection direction, ItemNavigateArgs itemNavigateArgs, bool shouldFocus, FrameworkElement& container);
    private object GetFirstItemOnCurrentPage(FrameworkElement startingElement, FocusNavigationDirection direction, FrameworkElement& firstElement);
    internal FrameworkElement GetViewportElement();
    private bool IsOnCurrentPage(object item, FocusNavigationDirection axis);
    private bool IsOnCurrentPage(FrameworkElement element, FocusNavigationDirection axis);
    private bool IsOnCurrentPage(FrameworkElement viewPort, FrameworkElement element, FocusNavigationDirection axis, bool fullyVisible);
    internal static ElementViewportPosition GetElementViewportPosition(FrameworkElement viewPort, UIElement element, FocusNavigationDirection axis, bool fullyVisible);
    internal static ElementViewportPosition GetElementViewportPosition(FrameworkElement viewPort, UIElement element, FocusNavigationDirection axis, bool fullyVisible, Rect& elementRect);
    internal static ElementViewportPosition GetElementViewportPosition(FrameworkElement viewPort, UIElement element, FocusNavigationDirection axis, bool fullyVisible, bool ignorePerpendicularAxis, Rect& elementRect);
    internal static ElementViewportPosition GetElementViewportPosition(FrameworkElement viewPort, UIElement element, FocusNavigationDirection axis, bool fullyVisible, bool ignorePerpendicularAxis, Rect& elementRect, Rect& layoutRect);
    private static GeneralTransform CorrectCatastrophicCancellation(GeneralTransform transform);
    private static bool ElementIntersectsViewport(Rect viewportRect, Rect elementRect);
    private bool IsInDirectionForLineNavigation(Rect fromRect, Rect toRect, FocusNavigationDirection direction, bool isHorizontal);
    private static void OnGotFocus(object sender, KeyboardFocusChangedEventArgs e);
    internal ItemInfo get_FocusedInfo();
    internal virtual bool FocusItem(ItemInfo info, ItemNavigateArgs itemNavigateArgs);
    internal bool get_IsLogicalVertical();
    internal bool get_IsLogicalHorizontal();
    internal ScrollViewer get_ScrollHost();
    internal static TimeSpan get_AutoScrollTimeout();
    internal void DoAutoScroll();
    internal void DoAutoScroll(ItemInfo startingInfo);
    private bool IsRTL(FrameworkElement element);
    private static ItemsControl GetEncapsulatingItemsControl(FrameworkElement element);
    private static object GetEncapsulatingItem(FrameworkElement element, FrameworkElement& container);
    private static object GetEncapsulatingItem(FrameworkElement element, FrameworkElement& container, ItemsControl& itemsControl);
    internal static DependencyObject TryGetTreeViewItemHeader(DependencyObject element);
    private void ApplyItemContainerStyle(DependencyObject container, object item);
    private void RemoveItemContainerStyle(DependencyObject container);
    internal object GetItemOrContainerFromContainer(DependencyObject container);
    internal static bool EqualsEx(object o1, object o2);
    internal ItemInfo NewItemInfo(object item, DependencyObject container, int index);
    internal ItemInfo ItemInfoFromContainer(DependencyObject container);
    internal ItemInfo ItemInfoFromIndex(int index);
    internal ItemInfo NewUnresolvedItemInfo(object item);
    internal DependencyObject ContainerFromItemInfo(ItemInfo info);
    internal void AdjustItemInfoAfterGeneratorChange(ItemInfo info);
    internal void AdjustItemInfosAfterGeneratorChange(IEnumerable`1<ItemInfo> list, bool claimUniqueContainer);
    internal void AdjustItemInfo(NotifyCollectionChangedEventArgs e, ItemInfo info);
    internal void AdjustItemInfos(NotifyCollectionChangedEventArgs e, IEnumerable`1<ItemInfo> list);
    internal ItemInfo LeaseItemInfo(ItemInfo info, bool ensureIndex);
    internal void RefreshItemInfo(ItemInfo info);
    private sealed virtual override object System.Windows.Controls.Primitives.IContainItemStorage.ReadItemValue(object item, DependencyProperty dp);
    private sealed virtual override void System.Windows.Controls.Primitives.IContainItemStorage.StoreItemValue(object item, DependencyProperty dp, object value);
    private sealed virtual override void System.Windows.Controls.Primitives.IContainItemStorage.ClearItemValue(object item, DependencyProperty dp);
    private sealed virtual override void System.Windows.Controls.Primitives.IContainItemStorage.ClearValue(DependencyProperty dp);
    private sealed virtual override void System.Windows.Controls.Primitives.IContainItemStorage.Clear();
    public virtual string ToString();
    internal virtual AutomationPeer OnCreateAutomationPeerInternal();
    internal virtual DependencyObjectType get_DTypeThemeStyleKey();
}
public class System.Windows.Controls.ItemsPanelTemplate : FrameworkTemplate {
    internal Type TargetTypeInternal { get; }
    internal static Type DefaultTargetType { get; }
    public ItemsPanelTemplate(FrameworkElementFactory root);
    internal virtual Type get_TargetTypeInternal();
    internal virtual void SetTargetTypeInternal(Type targetType);
    internal static Type get_DefaultTargetType();
    internal virtual void ProcessTemplateBeforeSeal();
    protected virtual void ValidateTemplatedParent(FrameworkElement templatedParent);
}
[LocalizabilityAttribute("17")]
public class System.Windows.Controls.ItemsPresenter : FrameworkElement {
    internal static DependencyProperty TemplateProperty;
    private ItemsControl _owner;
    private ItemContainerGenerator _generator;
    private ItemsPanelTemplate _templateCache;
    internal ItemsControl Owner { get; }
    internal ItemContainerGenerator Generator { get; }
    internal FrameworkTemplate TemplateInternal { get; }
    internal FrameworkTemplate TemplateCache { get; internal set; }
    private ItemsPanelTemplate Template { get; private set; }
    private static ItemsPresenter();
    internal virtual void OnPreApplyTemplate();
    public virtual void OnApplyTemplate();
    protected virtual Size MeasureOverride(Size constraint);
    protected virtual Size ArrangeOverride(Size arrangeSize);
    internal ItemsControl get_Owner();
    internal ItemContainerGenerator get_Generator();
    internal virtual FrameworkTemplate get_TemplateInternal();
    internal virtual FrameworkTemplate get_TemplateCache();
    internal virtual void set_TemplateCache(FrameworkTemplate value);
    private ItemsPanelTemplate get_Template();
    private void set_Template(ItemsPanelTemplate value);
    internal virtual void OnTemplateChangedInternal(FrameworkTemplate oldTemplate, FrameworkTemplate newTemplate);
    private static void OnTemplateChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    protected virtual void OnTemplateChanged(ItemsPanelTemplate oldTemplate, ItemsPanelTemplate newTemplate);
    internal static ItemsPresenter FromPanel(Panel panel);
    internal static ItemsPresenter FromGroupItem(GroupItem groupItem);
    internal virtual void OnAncestorChanged();
    private void AttachToOwner();
    private void UseGenerator(ItemContainerGenerator generator);
    private void OnPanelChanged(object sender, EventArgs e);
    private void ClearPanel();
}
internal interface System.Windows.Controls.ITextBoxViewHost {
    public ITextContainer TextContainer { get; }
    public bool IsTypographyDefaultValue { get; }
    public abstract virtual ITextContainer get_TextContainer();
    public abstract virtual bool get_IsTypographyDefaultValue();
}
[LocalizabilityAttribute("3")]
public class System.Windows.Controls.Label : ContentControl {
    public static DependencyProperty TargetProperty;
    private static DependencyProperty LabeledByProperty;
    private static DependencyObjectType _dType;
    [TypeConverterAttribute("System.Windows.Markup.NameReferenceConverter")]
public UIElement Target { get; public set; }
    internal DependencyObjectType DTypeThemeStyleKey { get; }
    private static Label();
    public UIElement get_Target();
    public void set_Target(UIElement value);
    private static void OnTargetChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    internal static Label GetLabeledBy(DependencyObject o);
    protected virtual AutomationPeer OnCreateAutomationPeer();
    private static void OnAccessKeyPressed(object sender, AccessKeyPressedEventArgs e);
    internal virtual DependencyObjectType get_DTypeThemeStyleKey();
}
[LocalizabilityAttribute("7")]
[StyleTypedPropertyAttribute]
public class System.Windows.Controls.ListBox : Selector {
    internal static string ListBoxSelectAllKey;
    public static DependencyProperty SelectionModeProperty;
    public static DependencyProperty SelectedItemsProperty;
    private ItemInfo _anchorItem;
    private WeakReference _lastActionItem;
    private DispatcherTimer _autoScrollTimer;
    private static RoutedUICommand SelectAllCommand;
    private static DependencyObjectType _dType;
    public SelectionMode SelectionMode { get; public set; }
    [CategoryAttribute("Appearance")]
[BindableAttribute("True")]
[DesignerSerializationVisibilityAttribute("0")]
public IList SelectedItems { get; }
    protected internal bool HandlesScrolling { get; }
    protected object AnchorItem { get; protected set; }
    internal ItemInfo AnchorItemInternal { get; internal set; }
    internal ListBoxItem LastActionItem { get; internal set; }
    internal DependencyObjectType DTypeThemeStyleKey { get; }
    private static ListBox();
    private void Initialize();
    public void SelectAll();
    public void UnselectAll();
    public void ScrollIntoView(object item);
    public SelectionMode get_SelectionMode();
    public void set_SelectionMode(SelectionMode value);
    private static void OnSelectionModeChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static object OnGetSelectionMode(DependencyObject d);
    private static bool IsValidSelectionMode(object o);
    private void ValidateSelectionMode(SelectionMode mode);
    public IList get_SelectedItems();
    protected virtual AutomationPeer OnCreateAutomationPeer();
    protected bool SetSelectedItems(IEnumerable selectedItems);
    protected virtual void PrepareContainerForItemOverride(DependencyObject element, object item);
    internal virtual void AdjustItemInfoOverride(NotifyCollectionChangedEventArgs e);
    internal virtual void AdjustItemInfosAfterGeneratorChangeOverride();
    protected virtual void OnSelectionChanged(SelectionChangedEventArgs e);
    protected virtual void OnKeyDown(KeyEventArgs e);
    protected virtual void OnMouseMove(MouseEventArgs e);
    private static void OnMouseButtonUp(object sender, MouseButtonEventArgs e);
    private static void OnGotKeyboardFocus(object sender, KeyboardFocusChangedEventArgs e);
    protected virtual void OnIsMouseCapturedChanged(DependencyPropertyChangedEventArgs e);
    protected virtual bool IsItemItsOwnContainerOverride(object item);
    protected virtual DependencyObject GetContainerForItemOverride();
    protected internal virtual bool get_HandlesScrolling();
    private static void OnQueryStatusSelectAll(object target, CanExecuteRoutedEventArgs args);
    private static void OnSelectAll(object target, ExecutedRoutedEventArgs args);
    internal void NotifyListItemClicked(ListBoxItem item, MouseButton mouseButton);
    internal void NotifyListItemMouseDragged(ListBoxItem listItem);
    private void UpdateAnchorAndActionItem(ItemInfo info);
    private void MakeSingleSelection(ListBoxItem listItem);
    private void MakeToggleSelection(ListBoxItem item);
    private void MakeAnchorSelection(ListBoxItem actionItem, bool clearCurrent);
    private void MakeKeyboardSelection(ListBoxItem item);
    private int ElementIndex(ListBoxItem listItem);
    private ListBoxItem ElementAt(int index);
    private object GetWeakReferenceTarget(WeakReference& weakReference);
    private void OnAutoScrollTimeout(object sender, EventArgs e);
    internal virtual bool FocusItem(ItemInfo info, ItemNavigateArgs itemNavigateArgs);
    protected object get_AnchorItem();
    protected void set_AnchorItem(object value);
    internal ItemInfo get_AnchorItemInternal();
    internal void set_AnchorItemInternal(ItemInfo value);
    internal ListBoxItem get_LastActionItem();
    internal void set_LastActionItem(ListBoxItem value);
    internal virtual DependencyObjectType get_DTypeThemeStyleKey();
}
[DefaultEventAttribute("Selected")]
public class System.Windows.Controls.ListBoxItem : ContentControl {
    public static DependencyProperty IsSelectedProperty;
    public static RoutedEvent SelectedEvent;
    public static RoutedEvent UnselectedEvent;
    private DispatcherOperation parentNotifyDraggedOperation;
    private static DependencyObjectType _dType;
    [BindableAttribute("True")]
[CategoryAttribute("Appearance")]
public bool IsSelected { get; public set; }
    private ListBox ParentListBox { get; }
    internal Selector ParentSelector { get; }
    internal DependencyObjectType DTypeThemeStyleKey { get; }
    private static ListBoxItem();
    public bool get_IsSelected();
    public void set_IsSelected(bool value);
    private static void OnIsSelectedChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    protected virtual void OnSelected(RoutedEventArgs e);
    protected virtual void OnUnselected(RoutedEventArgs e);
    private void HandleIsSelectedChanged(bool newValue, RoutedEventArgs e);
    public void add_Selected(RoutedEventHandler value);
    public void remove_Selected(RoutedEventHandler value);
    public void add_Unselected(RoutedEventHandler value);
    public void remove_Unselected(RoutedEventHandler value);
    internal virtual void ChangeVisualState(bool useTransitions);
    protected virtual AutomationPeer OnCreateAutomationPeer();
    protected virtual void OnMouseLeftButtonDown(MouseButtonEventArgs e);
    protected virtual void OnMouseRightButtonDown(MouseButtonEventArgs e);
    private void HandleMouseButtonDown(MouseButton mouseButton);
    protected virtual void OnMouseEnter(MouseEventArgs e);
    protected virtual void OnMouseLeave(MouseEventArgs e);
    protected internal virtual void OnVisualParentChanged(DependencyObject oldParent);
    private ListBox get_ParentListBox();
    internal Selector get_ParentSelector();
    internal virtual DependencyObjectType get_DTypeThemeStyleKey();
}
[StyleTypedPropertyAttribute]
public class System.Windows.Controls.ListView : ListBox {
    public static DependencyProperty ViewProperty;
    private ViewBase _previousView;
    public ViewBase View { get; public set; }
    private static ListView();
    public ViewBase get_View();
    public void set_View(ViewBase value);
    private static void OnViewChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    protected virtual void PrepareContainerForItemOverride(DependencyObject element, object item);
    protected virtual void ClearContainerForItemOverride(DependencyObject element, object item);
    protected virtual bool IsItemItsOwnContainerOverride(object item);
    protected virtual DependencyObject GetContainerForItemOverride();
    protected virtual void OnItemsChanged(NotifyCollectionChangedEventArgs e);
    protected virtual AutomationPeer OnCreateAutomationPeer();
    private void ApplyNewView();
    internal virtual void OnThemeChanged();
}
public class System.Windows.Controls.ListViewItem : ListBoxItem {
    internal void SetDefaultStyleKey(object key);
    internal void ClearDefaultStyleKey();
}
internal class System.Windows.Controls.MatchedTextInfo : object {
    private string _matchedText;
    private int _matchedItemIndex;
    private int _matchedPrefixLength;
    private int _textExcludingPrefixLength;
    private static MatchedTextInfo s_NoMatch;
    internal static MatchedTextInfo NoMatch { get; }
    internal string MatchedText { get; }
    internal int MatchedItemIndex { get; }
    internal int MatchedPrefixLength { get; }
    internal int TextExcludingPrefixLength { get; }
    private static MatchedTextInfo();
    internal MatchedTextInfo(int matchedItemIndex, string matchedText, int matchedPrefixLength, int textExcludingPrefixLength);
    internal static MatchedTextInfo get_NoMatch();
    internal string get_MatchedText();
    internal int get_MatchedItemIndex();
    internal int get_MatchedPrefixLength();
    internal int get_TextExcludingPrefixLength();
}
[LocalizabilityAttribute("17")]
public class System.Windows.Controls.MediaElement : FrameworkElement {
    public static DependencyProperty SourceProperty;
    public static DependencyProperty VolumeProperty;
    public static DependencyProperty BalanceProperty;
    public static DependencyProperty IsMutedProperty;
    public static DependencyProperty ScrubbingEnabledProperty;
    public static DependencyProperty UnloadedBehaviorProperty;
    public static DependencyProperty LoadedBehaviorProperty;
    public static DependencyProperty StretchProperty;
    public static DependencyProperty StretchDirectionProperty;
    public static RoutedEvent MediaFailedEvent;
    public static RoutedEvent MediaOpenedEvent;
    public static RoutedEvent BufferingStartedEvent;
    public static RoutedEvent BufferingEndedEvent;
    public static RoutedEvent ScriptCommandEvent;
    public static RoutedEvent MediaEndedEvent;
    private AVElementHelper _helper;
    public Uri Source { get; public set; }
    [DesignerSerializationVisibilityAttribute("0")]
public MediaClock Clock { get; public set; }
    public Stretch Stretch { get; public set; }
    public StretchDirection StretchDirection { get; public set; }
    public double Volume { get; public set; }
    public double Balance { get; public set; }
    public bool IsMuted { get; public set; }
    public bool ScrubbingEnabled { get; public set; }
    public MediaState UnloadedBehavior { get; public set; }
    public MediaState LoadedBehavior { get; public set; }
    public bool CanPause { get; }
    public bool IsBuffering { get; }
    public double DownloadProgress { get; }
    public double BufferingProgress { get; }
    public int NaturalVideoHeight { get; }
    public int NaturalVideoWidth { get; }
    public bool HasAudio { get; }
    public bool HasVideo { get; }
    public Duration NaturalDuration { get; }
    public TimeSpan Position { get; public set; }
    public double SpeedRatio { get; public set; }
    private Uri System.Windows.Markup.IUriContext.BaseUri { get; private set; }
    internal AVElementHelper Helper { get; }
    private static MediaElement();
    private static Style CreateDefaultStyles();
    public Uri get_Source();
    public void set_Source(Uri value);
    public MediaClock get_Clock();
    public void set_Clock(MediaClock value);
    public void Play();
    public void Pause();
    public void Stop();
    public void Close();
    public Stretch get_Stretch();
    public void set_Stretch(Stretch value);
    public StretchDirection get_StretchDirection();
    public void set_StretchDirection(StretchDirection value);
    public double get_Volume();
    public void set_Volume(double value);
    public double get_Balance();
    public void set_Balance(double value);
    public bool get_IsMuted();
    public void set_IsMuted(bool value);
    public bool get_ScrubbingEnabled();
    public void set_ScrubbingEnabled(bool value);
    public MediaState get_UnloadedBehavior();
    public void set_UnloadedBehavior(MediaState value);
    public MediaState get_LoadedBehavior();
    public void set_LoadedBehavior(MediaState value);
    public bool get_CanPause();
    public bool get_IsBuffering();
    public double get_DownloadProgress();
    public double get_BufferingProgress();
    public int get_NaturalVideoHeight();
    public int get_NaturalVideoWidth();
    public bool get_HasAudio();
    public bool get_HasVideo();
    public Duration get_NaturalDuration();
    public TimeSpan get_Position();
    public void set_Position(TimeSpan value);
    public double get_SpeedRatio();
    public void set_SpeedRatio(double value);
    public void add_MediaFailed(EventHandler`1<ExceptionRoutedEventArgs> value);
    public void remove_MediaFailed(EventHandler`1<ExceptionRoutedEventArgs> value);
    public void add_MediaOpened(RoutedEventHandler value);
    public void remove_MediaOpened(RoutedEventHandler value);
    public void add_BufferingStarted(RoutedEventHandler value);
    public void remove_BufferingStarted(RoutedEventHandler value);
    public void add_BufferingEnded(RoutedEventHandler value);
    public void remove_BufferingEnded(RoutedEventHandler value);
    public void add_ScriptCommand(EventHandler`1<MediaScriptCommandRoutedEventArgs> value);
    public void remove_ScriptCommand(EventHandler`1<MediaScriptCommandRoutedEventArgs> value);
    public void add_MediaEnded(RoutedEventHandler value);
    public void remove_MediaEnded(RoutedEventHandler value);
    private sealed virtual override Uri System.Windows.Markup.IUriContext.get_BaseUri();
    private sealed virtual override void System.Windows.Markup.IUriContext.set_BaseUri(Uri value);
    protected virtual AutomationPeer OnCreateAutomationPeer();
    protected virtual Size MeasureOverride(Size availableSize);
    protected virtual Size ArrangeOverride(Size finalSize);
    protected virtual void OnRender(DrawingContext drawingContext);
    internal AVElementHelper get_Helper();
    private void Initialize();
    private Size MeasureArrangeHelper(Size inputSize);
    private static void VolumePropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void BalancePropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void IsMutedPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void ScrubbingEnabledPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void UnloadedBehaviorPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void LoadedBehaviorPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    internal void OnMediaFailed(object sender, ExceptionEventArgs args);
    internal void OnMediaOpened(object sender, EventArgs args);
    internal void OnBufferingStarted(object sender, EventArgs args);
    internal void OnBufferingEnded(object sender, EventArgs args);
    internal void OnMediaEnded(object sender, EventArgs args);
    internal void OnScriptCommand(object sender, MediaScriptCommandEventArgs args);
}
public enum System.Windows.Controls.MediaState : Enum {
    public int value__;
    public static MediaState Manual;
    public static MediaState Play;
    public static MediaState Close;
    public static MediaState Pause;
    public static MediaState Stop;
}
public class System.Windows.Controls.Menu : MenuBase {
    public static DependencyProperty IsMainMenuProperty;
    private EnterMenuModeEventHandler _enterMenuModeHandler;
    private static DependencyObjectType _dType;
    public bool IsMainMenu { get; public set; }
    internal int EffectiveValuesInitialSize { get; }
    internal DependencyObjectType DTypeThemeStyleKey { get; }
    private static Menu();
    private static ItemsPanelTemplate GetDefaultPanel();
    public bool get_IsMainMenu();
    public void set_IsMainMenu(bool value);
    private static void OnIsMainMenuChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    protected virtual AutomationPeer OnCreateAutomationPeer();
    protected virtual void OnInitialized(EventArgs e);
    private void SetupMainMenu();
    private void CleanupMainMenu();
    private static object OnGetIsMainMenu(DependencyObject d);
    protected virtual void PrepareContainerForItemOverride(DependencyObject element, object item);
    protected virtual void OnKeyDown(KeyEventArgs e);
    protected virtual void OnTextInput(TextCompositionEventArgs e);
    protected virtual void HandleMouseButton(MouseButtonEventArgs e);
    internal virtual bool FocusItem(ItemInfo info, ItemNavigateArgs itemNavigateArgs);
    private static void OnAccessKeyPressed(object sender, AccessKeyPressedEventArgs e);
    private bool OnEnterMenuMode(object sender, EventArgs e);
    internal virtual int get_EffectiveValuesInitialSize();
    internal virtual DependencyObjectType get_DTypeThemeStyleKey();
}
[DefaultEventAttribute("Click")]
[LocalizabilityAttribute("8")]
[TemplatePartAttribute]
[StyleTypedPropertyAttribute]
public class System.Windows.Controls.MenuItem : HeaderedItemsControl {
    private static ComponentResourceKey _topLevelItemTemplateKey;
    private static ComponentResourceKey _topLevelHeaderTemplateKey;
    private static ComponentResourceKey _submenuItemTemplateKey;
    private static ComponentResourceKey _submenuHeaderTemplateKey;
    public static RoutedEvent ClickEvent;
    internal static RoutedEvent PreviewClickEvent;
    public static RoutedEvent CheckedEvent;
    public static RoutedEvent UncheckedEvent;
    public static RoutedEvent SubmenuOpenedEvent;
    public static RoutedEvent SubmenuClosedEvent;
    public static DependencyProperty CommandProperty;
    public static DependencyProperty CommandParameterProperty;
    public static DependencyProperty CommandTargetProperty;
    public static DependencyProperty IsSubmenuOpenProperty;
    private static DependencyPropertyKey RolePropertyKey;
    public static DependencyProperty RoleProperty;
    public static DependencyProperty IsCheckableProperty;
    private static DependencyPropertyKey IsPressedPropertyKey;
    public static DependencyProperty IsPressedProperty;
    private static DependencyPropertyKey IsHighlightedPropertyKey;
    public static DependencyProperty IsHighlightedProperty;
    public static DependencyProperty IsCheckedProperty;
    public static DependencyProperty StaysOpenOnClickProperty;
    internal static DependencyProperty IsSelectedProperty;
    public static DependencyProperty InputGestureTextProperty;
    public static DependencyProperty IconProperty;
    private static DependencyPropertyKey IsSuspendingPopupAnimationPropertyKey;
    public static DependencyProperty IsSuspendingPopupAnimationProperty;
    public static DependencyProperty ItemContainerTemplateSelectorProperty;
    public static DependencyProperty UsesItemContainerTemplateProperty;
    private object _currentItem;
    internal static DependencyProperty InsideContextMenuProperty;
    private static DependencyProperty BooleanFieldStoreProperty;
    private static string PopupTemplateName;
    private MenuItem _currentSelection;
    private Popup _submenuPopup;
    private DispatcherTimer _openHierarchyTimer;
    private DispatcherTimer _closeHierarchyTimer;
    private bool _userInitiatedPress;
    private static DependencyObjectType _dType;
    public static ResourceKey TopLevelItemTemplateKey { get; }
    public static ResourceKey TopLevelHeaderTemplateKey { get; }
    public static ResourceKey SubmenuItemTemplateKey { get; }
    public static ResourceKey SubmenuHeaderTemplateKey { get; }
    [BindableAttribute("True")]
[CategoryAttribute("Action")]
[LocalizabilityAttribute("17")]
public ICommand Command { get; public set; }
    protected bool IsEnabledCore { get; }
    [BindableAttribute("True")]
[CategoryAttribute("Action")]
[LocalizabilityAttribute("17")]
public object CommandParameter { get; public set; }
    [CategoryAttribute("Action")]
[BindableAttribute("True")]
public IInputElement CommandTarget { get; public set; }
    [CategoryAttribute("Appearance")]
[BrowsableAttribute("False")]
[BindableAttribute("True")]
[DesignerSerializationVisibilityAttribute("0")]
public bool IsSubmenuOpen { get; public set; }
    [CategoryAttribute("Behavior")]
public MenuItemRole Role { get; }
    [BindableAttribute("True")]
[CategoryAttribute("Behavior")]
public bool IsCheckable { get; public set; }
    [BrowsableAttribute("False")]
[CategoryAttribute("Appearance")]
public bool IsPressed { get; protected set; }
    [CategoryAttribute("Appearance")]
[BrowsableAttribute("False")]
public bool IsHighlighted { get; protected set; }
    [BindableAttribute("True")]
[CategoryAttribute("Appearance")]
public bool IsChecked { get; public set; }
    [CategoryAttribute("Behavior")]
[BindableAttribute("True")]
public bool StaysOpenOnClick { get; public set; }
    internal bool IsSelected { get; internal set; }
    [CustomCategoryAttribute("Content")]
[BindableAttribute("True")]
public string InputGestureText { get; public set; }
    [CustomCategoryAttribute("Content")]
[BindableAttribute("True")]
public object Icon { get; public set; }
    [DesignerSerializationVisibilityAttribute("0")]
public bool IsSuspendingPopupAnimation { get; internal set; }
    public ItemContainerTemplateSelector ItemContainerTemplateSelector { get; public set; }
    public bool UsesItemContainerTemplate { get; public set; }
    protected internal bool HandlesScrolling { get; }
    private bool IsInMenuMode { get; }
    private bool OpenOnMouseEnter { get; }
    [DesignerSerializationVisibilityAttribute("0")]
private bool InsideContextMenu { get; }
    internal object LogicalParent { get; }
    private MenuItem CurrentSibling { get; }
    private bool IsMouseOverSibling { get; }
    private MenuItem CurrentSelection { get; private set; }
    internal int EffectiveValuesInitialSize { get; }
    private bool CanExecute { get; private set; }
    internal DependencyObjectType DTypeThemeStyleKey { get; }
    public static ResourceKey SeparatorStyleKey { get; }
    private static MenuItem();
    public static ResourceKey get_TopLevelItemTemplateKey();
    public static ResourceKey get_TopLevelHeaderTemplateKey();
    public static ResourceKey get_SubmenuItemTemplateKey();
    public static ResourceKey get_SubmenuHeaderTemplateKey();
    public void add_Click(RoutedEventHandler value);
    public void remove_Click(RoutedEventHandler value);
    public void add_Checked(RoutedEventHandler value);
    public void remove_Checked(RoutedEventHandler value);
    public void add_Unchecked(RoutedEventHandler value);
    public void remove_Unchecked(RoutedEventHandler value);
    public void add_SubmenuOpened(RoutedEventHandler value);
    public void remove_SubmenuOpened(RoutedEventHandler value);
    public void add_SubmenuClosed(RoutedEventHandler value);
    public void remove_SubmenuClosed(RoutedEventHandler value);
    private static object CoerceHeader(DependencyObject d, object value);
    public sealed virtual ICommand get_Command();
    public void set_Command(ICommand value);
    private static void OnCommandChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private void OnCommandChanged(ICommand oldCommand, ICommand newCommand);
    private void UnhookCommand(ICommand command);
    private void HookCommand(ICommand command);
    private void OnCanExecuteChanged(object sender, EventArgs e);
    private void UpdateCanExecute();
    protected virtual bool get_IsEnabledCore();
    public sealed virtual object get_CommandParameter();
    public void set_CommandParameter(object value);
    public sealed virtual IInputElement get_CommandTarget();
    public void set_CommandTarget(IInputElement value);
    public bool get_IsSubmenuOpen();
    public void set_IsSubmenuOpen(bool value);
    private static object CoerceIsSubmenuOpen(DependencyObject d, object value);
    private static object CoerceToolTipIsEnabled(DependencyObject d, object value);
    private void RegisterToOpenOnLoad();
    private void OpenOnLoad(object sender, RoutedEventArgs e);
    private static void OnIsSubmenuOpenChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private void OnPopupClosed(object source, EventArgs e);
    protected virtual void OnSubmenuOpened(RoutedEventArgs e);
    protected virtual void OnSubmenuClosed(RoutedEventArgs e);
    public MenuItemRole get_Role();
    private void UpdateRole();
    public bool get_IsCheckable();
    public void set_IsCheckable(bool value);
    private static void OnIsCheckableChanged(DependencyObject target, DependencyPropertyChangedEventArgs e);
    public bool get_IsPressed();
    protected void set_IsPressed(bool value);
    private void UpdateIsPressed();
    public bool get_IsHighlighted();
    protected void set_IsHighlighted(bool value);
    public bool get_IsChecked();
    public void set_IsChecked(bool value);
    protected virtual void OnChecked(RoutedEventArgs e);
    protected virtual void OnUnchecked(RoutedEventArgs e);
    private static void OnIsCheckedChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public bool get_StaysOpenOnClick();
    public void set_StaysOpenOnClick(bool value);
    internal bool get_IsSelected();
    internal void set_IsSelected(bool value);
    private static void OnIsSelectedChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void OnIsSelectedChanged(object sender, RoutedPropertyChangedEventArgs`1<bool> e);
    public string get_InputGestureText();
    public void set_InputGestureText(string value);
    private static void OnInputGestureTextChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static object CoerceInputGestureText(DependencyObject d, object value);
    public object get_Icon();
    public void set_Icon(object value);
    public bool get_IsSuspendingPopupAnimation();
    internal void set_IsSuspendingPopupAnimation(bool value);
    private void NotifySiblingsToSuspendAnimation();
    private void NotifyChildrenToResumeAnimation();
    public ItemContainerTemplateSelector get_ItemContainerTemplateSelector();
    public void set_ItemContainerTemplateSelector(ItemContainerTemplateSelector value);
    public bool get_UsesItemContainerTemplate();
    public void set_UsesItemContainerTemplate(bool value);
    protected virtual AutomationPeer OnCreateAutomationPeer();
    protected virtual void OnInitialized(EventArgs e);
    protected virtual void PrepareContainerForItemOverride(DependencyObject element, object item);
    internal static void PrepareMenuItem(DependencyObject element, object item);
    protected virtual void OnClick();
    internal virtual void OnClickCore(bool userInitiated);
    internal void OnClickImpl(bool userInitiated);
    private object InvokeClickAfterRender(object arg);
    protected virtual void OnMouseLeftButtonDown(MouseButtonEventArgs e);
    protected virtual void OnMouseRightButtonDown(MouseButtonEventArgs e);
    protected virtual void OnMouseLeftButtonUp(MouseButtonEventArgs e);
    protected virtual void OnMouseRightButtonUp(MouseButtonEventArgs e);
    private void HandleMouseDown(MouseButtonEventArgs e);
    private void HandleMouseUp(MouseButtonEventArgs e);
    private static void OnAccessKeyPressed(object sender, AccessKeyPressedEventArgs e);
    protected virtual void OnMouseLeave(MouseEventArgs e);
    protected virtual void OnMouseMove(MouseEventArgs e);
    protected virtual void OnMouseEnter(MouseEventArgs e);
    private void MouseEnterHelper();
    private void MouseEnterInMenuMode(MenuItemRole role);
    private void MouseLeaveInMenuMode(MenuItemRole role);
    protected virtual void OnGotKeyboardFocus(KeyboardFocusChangedEventArgs e);
    protected virtual void OnIsKeyboardFocusWithinChanged(DependencyPropertyChangedEventArgs e);
    protected internal virtual bool get_HandlesScrolling();
    protected virtual void OnKeyDown(KeyEventArgs e);
    protected virtual void OnAccessKey(AccessKeyEventArgs e);
    protected virtual void OnItemsChanged(NotifyCollectionChangedEventArgs e);
    protected virtual bool IsItemItsOwnContainerOverride(object item);
    protected virtual bool ShouldApplyItemContainerStyle(DependencyObject container, object item);
    protected virtual DependencyObject GetContainerForItemOverride();
    protected internal virtual void OnVisualParentChanged(DependencyObject oldParent);
    public virtual void OnApplyTemplate();
    private void SetMenuMode(bool menuMode);
    private bool get_IsInMenuMode();
    private bool get_OpenOnMouseEnter();
    private bool get_InsideContextMenu();
    internal static void SetInsideContextMenuProperty(UIElement element, bool value);
    internal void ClickItem();
    private void ClickItem(bool userInitiated);
    internal void ClickHeader();
    internal bool OpenMenu();
    internal void OpenSubmenuWithKeyboard();
    private bool MenuItemNavigate(Key key, ModifierKeys modifiers);
    internal object get_LogicalParent();
    private MenuItem get_CurrentSibling();
    private bool get_IsMouseOverSibling();
    private static bool IsMouseReallyOver(FrameworkElement elem);
    private void OpenHierarchy(MenuItemRole role);
    private void FocusOrSelect();
    private void SetTimerToOpenHierarchy();
    private void SetTimerToCloseHierarchy();
    private void StopTimer(DispatcherTimer& timer);
    private void StartTimer(DispatcherTimer timer);
    private static object OnCoerceAcceleratorKey(DependencyObject d, object value);
    private MenuItem get_CurrentSelection();
    private void set_CurrentSelection(MenuItem value);
    private static bool GetBoolField(UIElement element, BoolField field);
    private static void SetBoolField(UIElement element, BoolField field, bool value);
    internal virtual int get_EffectiveValuesInitialSize();
    private bool get_CanExecute();
    private void set_CanExecute(bool value);
    internal virtual DependencyObjectType get_DTypeThemeStyleKey();
    public static ResourceKey get_SeparatorStyleKey();
    [CompilerGeneratedAttribute]
private object <OpenOnLoad>b__63_0(object param);
    [CompilerGeneratedAttribute]
private void <SetTimerToOpenHierarchy>b__189_0(object sender, EventArgs e);
    [CompilerGeneratedAttribute]
private void <SetTimerToCloseHierarchy>b__190_0(object sender, EventArgs e);
}
public enum System.Windows.Controls.MenuItemRole : Enum {
    public int value__;
    public static MenuItemRole TopLevelItem;
    public static MenuItemRole TopLevelHeader;
    public static MenuItemRole SubmenuItem;
    public static MenuItemRole SubmenuHeader;
}
public class System.Windows.Controls.MenuScrollingVisibilityConverter : object {
    public sealed virtual object Convert(Object[] values, Type targetType, object parameter, CultureInfo culture);
    public sealed virtual Object[] ConvertBack(object value, Type[] targetTypes, object parameter, CultureInfo culture);
}
[DefaultMemberAttribute("Item")]
internal class System.Windows.Controls.MultipleCopiesCollection : object {
    [CompilerGeneratedAttribute]
private NotifyCollectionChangedEventHandler CollectionChanged;
    [CompilerGeneratedAttribute]
private PropertyChangedEventHandler PropertyChanged;
    private object _item;
    private int _count;
    private static string CountName;
    private static string IndexerName;
    internal object CopiedItem { get; internal set; }
    private int RepeatCount { get; private set; }
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    public object Item { get; public set; }
    public int Count { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    internal MultipleCopiesCollection(object item, int count);
    internal void MirrorCollectionChange(NotifyCollectionChangedEventArgs e);
    internal void SyncToCount(int newCount);
    internal object get_CopiedItem();
    internal void set_CopiedItem(object value);
    private int get_RepeatCount();
    private void set_RepeatCount(int value);
    private void Insert(int index);
    private void InsertRange(int index, int count);
    private void Move(int oldIndex, int newIndex);
    private void RemoveAt(int index);
    private void RemoveRange(int index, int count);
    private void OnReplace(object oldItem, object newItem, int index);
    private void Reset();
    public sealed virtual int Add(object value);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(object value);
    public sealed virtual int IndexOf(object value);
    public sealed virtual void Insert(int index, object value);
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual void Remove(object value);
    private sealed virtual override void System.Collections.IList.RemoveAt(int index);
    public sealed virtual object get_Item(int index);
    public sealed virtual void set_Item(int index, object value);
    public sealed virtual void CopyTo(Array array, int index);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    public sealed virtual IEnumerator GetEnumerator();
    [CompilerGeneratedAttribute]
public sealed virtual void add_CollectionChanged(NotifyCollectionChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_CollectionChanged(NotifyCollectionChangedEventHandler value);
    private void OnCollectionChanged(NotifyCollectionChangedAction action, object item, int index);
    private void OnCollectionReset();
    private void OnCollectionChanged(NotifyCollectionChangedEventArgs e);
    [CompilerGeneratedAttribute]
public sealed virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
    private void OnPropertyChanged(string propertyName);
    private void OnPropertyChanged(PropertyChangedEventArgs e);
}
public class System.Windows.Controls.NotifyDataErrorValidationRule : ValidationRule {
    internal static NotifyDataErrorValidationRule Instance;
    private static NotifyDataErrorValidationRule();
    public virtual ValidationResult Validate(object value, CultureInfo cultureInfo);
}
[LocalizabilityAttribute("0")]
public enum System.Windows.Controls.Orientation : Enum {
    public int value__;
    public static Orientation Horizontal;
    public static Orientation Vertical;
}
public enum System.Windows.Controls.OverflowMode : Enum {
    public int value__;
    public static OverflowMode AsNeeded;
    public static OverflowMode Always;
    public static OverflowMode Never;
}
[ContentPropertyAttribute("Content")]
public class System.Windows.Controls.Page : FrameworkElement {
    public static DependencyProperty ContentProperty;
    public static DependencyProperty BackgroundProperty;
    public static DependencyProperty TitleProperty;
    public static DependencyProperty KeepAliveProperty;
    public static DependencyProperty ForegroundProperty;
    public static DependencyProperty FontFamilyProperty;
    public static DependencyProperty FontSizeProperty;
    public static DependencyProperty TemplateProperty;
    private IWindowService _currentIws;
    private PageHelperObject _pho;
    private SetPropertyFlags _setPropertyFlags;
    private bool _isTopLevel;
    private ControlTemplate _templateCache;
    private static DependencyObjectType _dType;
    protected internal IEnumerator LogicalChildren { get; }
    public object Content { get; public set; }
    private string System.Windows.IWindowService.Title { get; private set; }
    [LocalizabilityAttribute("2")]
public string WindowTitle { get; public set; }
    private double System.Windows.IWindowService.Height { get; private set; }
    public double WindowHeight { get; public set; }
    private double System.Windows.IWindowService.Width { get; private set; }
    public double WindowWidth { get; public set; }
    [CategoryAttribute("Appearance")]
public Brush Background { get; public set; }
    public string Title { get; public set; }
    public bool ShowsNavigationUI { get; public set; }
    public bool KeepAlive { get; public set; }
    public NavigationService NavigationService { get; }
    [CategoryAttribute("Appearance")]
[BindableAttribute("True")]
public Brush Foreground { get; public set; }
    [BindableAttribute("True")]
[CategoryAttribute("Appearance")]
[LocalizabilityAttribute("14")]
public FontFamily FontFamily { get; public set; }
    [TypeConverterAttribute("System.Windows.FontSizeConverter")]
[BindableAttribute("True")]
[CategoryAttribute("Appearance")]
[LocalizabilityAttribute("0")]
public double FontSize { get; public set; }
    public ControlTemplate Template { get; public set; }
    internal FrameworkTemplate TemplateInternal { get; }
    internal FrameworkTemplate TemplateCache { get; internal set; }
    private bool System.Windows.IWindowService.UserResized { get; }
    private IWindowService WindowService { get; }
    private PageHelperObject PageHelperObject { get; }
    internal int EffectiveValuesInitialSize { get; }
    internal DependencyObjectType DTypeThemeStyleKey { get; }
    private static Page();
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object obj);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string str);
    protected internal virtual IEnumerator get_LogicalChildren();
    public object get_Content();
    public void set_Content(object value);
    private sealed virtual override string System.Windows.IWindowService.get_Title();
    private sealed virtual override void System.Windows.IWindowService.set_Title(string value);
    public string get_WindowTitle();
    public void set_WindowTitle(string value);
    internal bool ShouldJournalWindowTitle();
    private sealed virtual override double System.Windows.IWindowService.get_Height();
    private sealed virtual override void System.Windows.IWindowService.set_Height(double value);
    public double get_WindowHeight();
    public void set_WindowHeight(double value);
    private sealed virtual override double System.Windows.IWindowService.get_Width();
    private sealed virtual override void System.Windows.IWindowService.set_Width(double value);
    public double get_WindowWidth();
    public void set_WindowWidth(double value);
    public Brush get_Background();
    public void set_Background(Brush value);
    public string get_Title();
    public void set_Title(string value);
    private static void OnTitleChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public bool get_ShowsNavigationUI();
    public void set_ShowsNavigationUI(bool value);
    public bool get_KeepAlive();
    public void set_KeepAlive(bool value);
    public NavigationService get_NavigationService();
    public Brush get_Foreground();
    public void set_Foreground(Brush value);
    public FontFamily get_FontFamily();
    public void set_FontFamily(FontFamily value);
    public double get_FontSize();
    public void set_FontSize(double value);
    public ControlTemplate get_Template();
    public void set_Template(ControlTemplate value);
    internal virtual FrameworkTemplate get_TemplateInternal();
    internal virtual FrameworkTemplate get_TemplateCache();
    internal virtual void set_TemplateCache(FrameworkTemplate value);
    internal virtual void OnTemplateChangedInternal(FrameworkTemplate oldTemplate, FrameworkTemplate newTemplate);
    private static void OnTemplateChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    protected virtual void OnTemplateChanged(ControlTemplate oldTemplate, ControlTemplate newTemplate);
    protected virtual Size MeasureOverride(Size constraint);
    protected virtual Size ArrangeOverride(Size arrangeBounds);
    protected internal sealed virtual void OnVisualParentChanged(DependencyObject oldParent);
    private static void OnContentChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private void OnContentChanged(object oldContent, object newContent);
    private static void _OnWindowServiceChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private void OnWindowServiceChanged(IWindowService iws);
    private void DetermineTopLevel();
    private void PropagateProperties();
    private sealed virtual override bool System.Windows.IWindowService.get_UserResized();
    private void SetShowsNavigationUI(bool showsNavigationUI);
    private bool IsPropertySet(SetPropertyFlags property);
    private void PropertyIsSet(SetPropertyFlags property);
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeWindowTitle();
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeWindowHeight();
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeWindowWidth();
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeTitle();
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeShowsNavigationUI();
    private IWindowService get_WindowService();
    private PageHelperObject get_PageHelperObject();
    internal virtual int get_EffectiveValuesInitialSize();
    internal virtual DependencyObjectType get_DTypeThemeStyleKey();
}
internal class System.Windows.Controls.PageHelperObject : object {
    internal string _text;
    internal string _windowTitle;
    internal double _windowHeight;
    internal double _windowWidth;
    internal bool _showsNavigationUI;
}
public class System.Windows.Controls.PageRange : ValueType {
    private int _pageFrom;
    private int _pageTo;
    public int PageFrom { get; public set; }
    public int PageTo { get; public set; }
    public PageRange(int page);
    public PageRange(int pageFrom, int pageTo);
    public int get_PageFrom();
    public void set_PageFrom(int value);
    public int get_PageTo();
    public void set_PageTo(int value);
    public virtual string ToString();
    public virtual bool Equals(object obj);
    public bool Equals(PageRange pageRange);
    public virtual int GetHashCode();
    public static bool op_Equality(PageRange pr1, PageRange pr2);
    public static bool op_Inequality(PageRange pr1, PageRange pr2);
}
public enum System.Windows.Controls.PageRangeSelection : Enum {
    public int value__;
    public static PageRangeSelection AllPages;
    public static PageRangeSelection UserPages;
    public static PageRangeSelection CurrentPage;
    public static PageRangeSelection SelectedPages;
}
[LocalizabilityAttribute("16")]
[ContentPropertyAttribute("Children")]
public abstract class System.Windows.Controls.Panel : FrameworkElement {
    [CommonDependencyPropertyAttribute]
public static DependencyProperty BackgroundProperty;
    public static DependencyProperty IsItemsHostProperty;
    private UIElementCollection _uiElementCollection;
    private ItemContainerGenerator _itemContainerGenerator;
    private BoolField _boolFieldStore;
    private static int c_zDefaultValue;
    private int _zConsonant;
    private Int32[] _zLut;
    public static DependencyProperty ZIndexProperty;
    public Brush Background { get; public set; }
    protected internal IEnumerator LogicalChildren { get; }
    [DesignerSerializationVisibilityAttribute("2")]
public UIElementCollection Children { get; }
    [BindableAttribute("False")]
[CategoryAttribute("Behavior")]
public bool IsItemsHost { get; public set; }
    public Orientation LogicalOrientationPublic { get; }
    protected internal Orientation LogicalOrientation { get; }
    public bool HasLogicalOrientationPublic { get; }
    protected internal bool HasLogicalOrientation { get; }
    protected internal UIElementCollection InternalChildren { get; }
    protected int VisualChildrenCount { get; }
    internal IItemContainerGenerator Generator { get; }
    internal bool VSP_IsVirtualizing { get; internal set; }
    internal bool VSP_HasMeasured { get; internal set; }
    internal bool VSP_MustDisableVirtualization { get; internal set; }
    internal bool VSP_IsPixelBased { get; internal set; }
    internal bool VSP_InRecyclingMode { get; internal set; }
    internal bool VSP_MeasureCaches { get; internal set; }
    internal bool IsDataBound { get; }
    internal int EffectiveValuesInitialSize { get; }
    private bool IsZStateDirty { get; private set; }
    private bool IsZStateDiverse { get; private set; }
    private static Panel();
    protected virtual void OnRender(DrawingContext dc);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object value);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string text);
    public Brush get_Background();
    public void set_Background(Brush value);
    protected internal virtual IEnumerator get_LogicalChildren();
    public UIElementCollection get_Children();
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeChildren();
    public bool get_IsItemsHost();
    public void set_IsItemsHost(bool value);
    private static void OnIsItemsHostChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    protected virtual void OnIsItemsHostChanged(bool oldIsItemsHost, bool newIsItemsHost);
    public Orientation get_LogicalOrientationPublic();
    protected internal virtual Orientation get_LogicalOrientation();
    public bool get_HasLogicalOrientationPublic();
    protected internal virtual bool get_HasLogicalOrientation();
    protected internal UIElementCollection get_InternalChildren();
    protected virtual int get_VisualChildrenCount();
    protected virtual Visual GetVisualChild(int index);
    protected virtual UIElementCollection CreateUIElementCollection(FrameworkElement logicalParent);
    internal IItemContainerGenerator get_Generator();
    internal bool get_VSP_IsVirtualizing();
    internal void set_VSP_IsVirtualizing(bool value);
    internal bool get_VSP_HasMeasured();
    internal void set_VSP_HasMeasured(bool value);
    internal bool get_VSP_MustDisableVirtualization();
    internal void set_VSP_MustDisableVirtualization(bool value);
    internal bool get_VSP_IsPixelBased();
    internal void set_VSP_IsPixelBased(bool value);
    internal bool get_VSP_InRecyclingMode();
    internal void set_VSP_InRecyclingMode(bool value);
    internal bool get_VSP_MeasureCaches();
    internal void set_VSP_MeasureCaches(bool value);
    private bool VerifyBoundState();
    internal bool get_IsDataBound();
    internal static bool IsAboutToGenerateContent(Panel panel);
    private void ConnectToGenerator();
    private void DisconnectFromGenerator();
    private void EnsureEmptyChildren(FrameworkElement logicalParent);
    internal void EnsureGenerator();
    private void ClearChildren();
    internal virtual void OnClearChildrenInternal();
    internal virtual void GenerateChildren();
    private void OnItemsChanged(object sender, ItemsChangedEventArgs args);
    internal virtual bool OnItemsChangedInternal(object sender, ItemsChangedEventArgs args);
    private void AddChildren(GeneratorPosition pos, int itemCount);
    private void RemoveChildren(GeneratorPosition pos, int containerCount);
    private void ReplaceChildren(GeneratorPosition pos, int itemCount, int containerCount);
    private void MoveChildren(GeneratorPosition fromPos, GeneratorPosition toPos, int containerCount);
    private void ResetChildren();
    private bool GetBoolField(BoolField field);
    private void SetBoolField(BoolField field, bool value);
    internal virtual int get_EffectiveValuesInitialSize();
    protected internal virtual void OnVisualChildrenChanged(DependencyObject visualAdded, DependencyObject visualRemoved);
    public static void SetZIndex(UIElement element, int value);
    public static int GetZIndex(UIElement element);
    private static void OnZIndexPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    internal void InvalidateZState();
    private bool get_IsZStateDirty();
    private void set_IsZStateDirty(bool value);
    private bool get_IsZStateDiverse();
    private void set_IsZStateDiverse(bool value);
    private void RecomputeZState();
}
public enum System.Windows.Controls.PanningMode : Enum {
    public int value__;
    public static PanningMode None;
    public static PanningMode HorizontalOnly;
    public static PanningMode VerticalOnly;
    public static PanningMode Both;
    public static PanningMode HorizontalFirst;
    public static PanningMode VerticalFirst;
}
[TemplatePartAttribute]
public class System.Windows.Controls.PasswordBox : Control {
    public static DependencyProperty PasswordCharProperty;
    public static DependencyProperty MaxLengthProperty;
    public static DependencyProperty SelectionBrushProperty;
    public static DependencyProperty SelectionTextBrushProperty;
    public static DependencyProperty SelectionOpacityProperty;
    public static DependencyProperty CaretBrushProperty;
    public static DependencyProperty IsSelectionActiveProperty;
    public static DependencyProperty IsInactiveSelectionHighlightEnabledProperty;
    public static RoutedEvent PasswordChangedEvent;
    private TextEditor _textEditor;
    private PasswordTextContainer _textContainer;
    private TextBoxView _renderScope;
    private ScrollViewer _scrollViewer;
    private Border _border;
    private FrameworkElement _passwordBoxContentHost;
    private static int _defaultWidth;
    private static int _defaultHeight;
    private static string ContentHostTemplateName;
    private static DependencyObjectType _dType;
    private NavigationService _navigationService;
    [DefaultValueAttribute("")]
[DesignerSerializationVisibilityAttribute("0")]
public string Password { get; public set; }
    [DesignerSerializationVisibilityAttribute("0")]
public SecureString SecurePassword { get; }
    public char PasswordChar { get; public set; }
    [DefaultValueAttribute("0")]
public int MaxLength { get; public set; }
    public Brush SelectionBrush { get; public set; }
    public Brush SelectionTextBrush { get; public set; }
    public double SelectionOpacity { get; public set; }
    public Brush CaretBrush { get; public set; }
    public bool IsSelectionActive { get; }
    public bool IsInactiveSelectionHighlightEnabled { get; public set; }
    internal PasswordTextContainer TextContainer { get; }
    internal FrameworkElement RenderScope { get; }
    internal ScrollViewer ScrollViewer { get; }
    private ITextContainer System.Windows.Controls.ITextBoxViewHost.TextContainer { get; }
    private bool System.Windows.Controls.ITextBoxViewHost.IsTypographyDefaultValue { get; }
    private ITextSelection Selection { get; }
    internal DependencyObjectType DTypeThemeStyleKey { get; }
    private static PasswordBox();
    public void Paste();
    public void SelectAll();
    public void Clear();
    public string get_Password();
    public void set_Password(string value);
    public SecureString get_SecurePassword();
    public char get_PasswordChar();
    public void set_PasswordChar(char value);
    public int get_MaxLength();
    public void set_MaxLength(int value);
    public Brush get_SelectionBrush();
    public void set_SelectionBrush(Brush value);
    public Brush get_SelectionTextBrush();
    public void set_SelectionTextBrush(Brush value);
    public double get_SelectionOpacity();
    public void set_SelectionOpacity(double value);
    public Brush get_CaretBrush();
    public void set_CaretBrush(Brush value);
    public bool get_IsSelectionActive();
    public bool get_IsInactiveSelectionHighlightEnabled();
    public void set_IsInactiveSelectionHighlightEnabled(bool value);
    public void add_PasswordChanged(RoutedEventHandler value);
    public void remove_PasswordChanged(RoutedEventHandler value);
    internal virtual void ChangeVisualState(bool useTransitions);
    protected virtual AutomationPeer OnCreateAutomationPeer();
    public virtual void OnApplyTemplate();
    protected virtual void OnTemplateChanged(ControlTemplate oldTemplate, ControlTemplate newTemplate);
    protected virtual void OnPropertyChanged(DependencyPropertyChangedEventArgs e);
    protected virtual void OnKeyDown(KeyEventArgs e);
    protected virtual void OnKeyUp(KeyEventArgs e);
    protected virtual void OnTextInput(TextCompositionEventArgs e);
    protected virtual void OnMouseDown(MouseButtonEventArgs e);
    protected virtual void OnMouseMove(MouseEventArgs e);
    protected virtual void OnMouseUp(MouseButtonEventArgs e);
    protected virtual void OnQueryCursor(QueryCursorEventArgs e);
    protected virtual void OnQueryContinueDrag(QueryContinueDragEventArgs e);
    protected virtual void OnGiveFeedback(GiveFeedbackEventArgs e);
    protected virtual void OnDragEnter(DragEventArgs e);
    protected virtual void OnDragOver(DragEventArgs e);
    protected virtual void OnDragLeave(DragEventArgs e);
    protected virtual void OnDrop(DragEventArgs e);
    protected virtual void OnContextMenuOpening(ContextMenuEventArgs e);
    protected virtual void OnGotKeyboardFocus(KeyboardFocusChangedEventArgs e);
    protected virtual void OnLostKeyboardFocus(KeyboardFocusChangedEventArgs e);
    protected virtual void OnLostFocus(RoutedEventArgs e);
    internal PasswordTextContainer get_TextContainer();
    internal FrameworkElement get_RenderScope();
    internal ScrollViewer get_ScrollViewer();
    private sealed virtual override ITextContainer System.Windows.Controls.ITextBoxViewHost.get_TextContainer();
    private sealed virtual override bool System.Windows.Controls.ITextBoxViewHost.get_IsTypographyDefaultValue();
    private void Initialize();
    private void InitializeTextContainer(PasswordTextContainer textContainer);
    private static object ForceToFalse(DependencyObject d, object value);
    private static void OnPasswordCharChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private void OnTextContainerChanged(object sender, TextContainerChangedEventArgs e);
    private void SetRenderScopeToContentHost(TextBoxView renderScope);
    private void ClearContentHost();
    private void InitializeRenderScope();
    private void UninitializeRenderScope();
    private void ResetSelection();
    private void Select(int start, int length);
    private static void OnPaddingChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void OnParentNavigationServiceChanged(DependencyObject o, DependencyPropertyChangedEventArgs e);
    private void OnNavigating(object sender, NavigatingCancelEventArgs e);
    private void AttachToVisualTree();
    private void DetachFromVisualTree();
    private void SetSecurePassword(SecureString value);
    private static void UpdateCaretElement(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private ITextSelection get_Selection();
    internal virtual DependencyObjectType get_DTypeThemeStyleKey();
}
internal class System.Windows.Controls.PasswordTextContainer : object {
    private PasswordBox _passwordBox;
    private SecureString _password;
    private ArrayList _positionList;
    private Highlights _highlights;
    private int _changeBlockLevel;
    private TextContainerChangedEventArgs _changes;
    private ITextView _textview;
    private bool _isReadOnly;
    private EventHandler Changing;
    private TextContainerChangeEventHandler Change;
    private TextContainerChangedEventHandler Changed;
    private ITextSelection _textSelection;
    private bool System.Windows.Documents.ITextContainer.IsReadOnly { get; }
    private ITextPointer System.Windows.Documents.ITextContainer.Start { get; }
    private ITextPointer System.Windows.Documents.ITextContainer.End { get; }
    private UInt32 System.Windows.Documents.ITextContainer.Generation { get; }
    private Highlights System.Windows.Documents.ITextContainer.Highlights { get; }
    private DependencyObject System.Windows.Documents.ITextContainer.Parent { get; }
    private ITextSelection System.Windows.Documents.ITextContainer.TextSelection { get; private set; }
    private UndoManager System.Windows.Documents.ITextContainer.UndoManager { get; }
    private ITextView System.Windows.Documents.ITextContainer.TextView { get; private set; }
    internal ITextView TextView { get; internal set; }
    private int System.Windows.Documents.ITextContainer.SymbolCount { get; }
    private int System.Windows.Documents.ITextContainer.IMECharCount { get; }
    internal ITextPointer Start { get; }
    internal ITextPointer End { get; }
    internal int SymbolCount { get; }
    internal char PasswordChar { get; }
    internal PasswordBox PasswordBox { get; }
    internal PasswordTextContainer(PasswordBox passwordBox);
    internal void InsertText(ITextPointer position, string textData);
    internal void DeleteContent(ITextPointer startPosition, ITextPointer endPosition);
    internal void BeginChange();
    internal void EndChange();
    internal void EndChange(bool skipEvents);
    private sealed virtual override void System.Windows.Documents.ITextContainer.BeginChange();
    private sealed virtual override void System.Windows.Documents.ITextContainer.BeginChangeNoUndo();
    private sealed virtual override void System.Windows.Documents.ITextContainer.EndChange();
    private sealed virtual override void System.Windows.Documents.ITextContainer.EndChange(bool skipEvents);
    private sealed virtual override ITextPointer System.Windows.Documents.ITextContainer.CreatePointerAtOffset(int offset, LogicalDirection direction);
    private sealed virtual override ITextPointer System.Windows.Documents.ITextContainer.CreatePointerAtCharOffset(int charOffset, LogicalDirection direction);
    private sealed virtual override ITextPointer System.Windows.Documents.ITextContainer.CreateDynamicTextPointer(StaticTextPointer position, LogicalDirection direction);
    private sealed virtual override StaticTextPointer System.Windows.Documents.ITextContainer.CreateStaticPointerAtOffset(int offset);
    private sealed virtual override TextPointerContext System.Windows.Documents.ITextContainer.GetPointerContext(StaticTextPointer pointer, LogicalDirection direction);
    private sealed virtual override int System.Windows.Documents.ITextContainer.GetOffsetToPosition(StaticTextPointer position1, StaticTextPointer position2);
    private sealed virtual override int System.Windows.Documents.ITextContainer.GetTextInRun(StaticTextPointer position, LogicalDirection direction, Char[] textBuffer, int startIndex, int count);
    private sealed virtual override object System.Windows.Documents.ITextContainer.GetAdjacentElement(StaticTextPointer position, LogicalDirection direction);
    private sealed virtual override DependencyObject System.Windows.Documents.ITextContainer.GetParent(StaticTextPointer position);
    private sealed virtual override StaticTextPointer System.Windows.Documents.ITextContainer.CreatePointer(StaticTextPointer position, int offset);
    private sealed virtual override StaticTextPointer System.Windows.Documents.ITextContainer.GetNextContextPosition(StaticTextPointer position, LogicalDirection direction);
    private sealed virtual override int System.Windows.Documents.ITextContainer.CompareTo(StaticTextPointer position1, StaticTextPointer position2);
    private sealed virtual override int System.Windows.Documents.ITextContainer.CompareTo(StaticTextPointer position1, ITextPointer position2);
    private sealed virtual override object System.Windows.Documents.ITextContainer.GetValue(StaticTextPointer position, DependencyProperty formattingProperty);
    internal void AddPosition(PasswordTextPointer position);
    internal void RemovePosition(PasswordTextPointer searchPosition);
    private sealed virtual override bool System.Windows.Documents.ITextContainer.get_IsReadOnly();
    private sealed virtual override ITextPointer System.Windows.Documents.ITextContainer.get_Start();
    private sealed virtual override ITextPointer System.Windows.Documents.ITextContainer.get_End();
    private sealed virtual override UInt32 System.Windows.Documents.ITextContainer.get_Generation();
    private sealed virtual override Highlights System.Windows.Documents.ITextContainer.get_Highlights();
    private sealed virtual override DependencyObject System.Windows.Documents.ITextContainer.get_Parent();
    private sealed virtual override ITextSelection System.Windows.Documents.ITextContainer.get_TextSelection();
    private sealed virtual override void System.Windows.Documents.ITextContainer.set_TextSelection(ITextSelection value);
    private sealed virtual override UndoManager System.Windows.Documents.ITextContainer.get_UndoManager();
    private sealed virtual override ITextView System.Windows.Documents.ITextContainer.get_TextView();
    private sealed virtual override void System.Windows.Documents.ITextContainer.set_TextView(ITextView value);
    internal ITextView get_TextView();
    internal void set_TextView(ITextView value);
    private sealed virtual override int System.Windows.Documents.ITextContainer.get_SymbolCount();
    private sealed virtual override int System.Windows.Documents.ITextContainer.get_IMECharCount();
    internal ITextPointer get_Start();
    internal ITextPointer get_End();
    internal SecureString GetPasswordCopy();
    internal void SetPassword(SecureString value);
    internal int get_SymbolCount();
    internal char get_PasswordChar();
    internal PasswordBox get_PasswordBox();
    private sealed virtual override void System.Windows.Documents.ITextContainer.add_Changing(EventHandler value);
    private sealed virtual override void System.Windows.Documents.ITextContainer.remove_Changing(EventHandler value);
    private sealed virtual override void System.Windows.Documents.ITextContainer.add_Change(TextContainerChangeEventHandler value);
    private sealed virtual override void System.Windows.Documents.ITextContainer.remove_Change(TextContainerChangeEventHandler value);
    private sealed virtual override void System.Windows.Documents.ITextContainer.add_Changed(TextContainerChangedEventHandler value);
    private sealed virtual override void System.Windows.Documents.ITextContainer.remove_Changed(TextContainerChangedEventHandler value);
    private void AddChange(ITextPointer startPosition, int symbolCount, PrecursorTextChangeType precursorTextChange);
    private void OnPasswordChange(int offset, int delta);
    private void UpdatePositionList(int offset, int delta);
    private void RemoveUnreferencedPositions();
    private int FindIndex(int offset, LogicalDirection gravity);
    private void DebugAssertPositionList();
    private PasswordTextPointer GetPointerAtIndex(int index);
}
internal class System.Windows.Controls.PasswordTextPointer : object {
    private PasswordTextContainer _container;
    private LogicalDirection _gravity;
    private int _offset;
    private bool _isFrozen;
    private Type System.Windows.Documents.ITextPointer.ParentType { get; }
    private ITextContainer System.Windows.Documents.ITextPointer.TextContainer { get; }
    private bool System.Windows.Documents.ITextPointer.HasValidLayout { get; }
    private bool System.Windows.Documents.ITextPointer.IsAtCaretUnitBoundary { get; }
    private LogicalDirection System.Windows.Documents.ITextPointer.LogicalDirection { get; }
    private bool System.Windows.Documents.ITextPointer.IsAtInsertionPosition { get; }
    private bool System.Windows.Documents.ITextPointer.IsFrozen { get; }
    private int System.Windows.Documents.ITextPointer.Offset { get; }
    private int System.Windows.Documents.ITextPointer.CharOffset { get; }
    internal PasswordTextContainer Container { get; }
    internal LogicalDirection LogicalDirection { get; }
    internal int Offset { get; internal set; }
    internal PasswordTextPointer(PasswordTextContainer container, LogicalDirection gravity, int offset);
    private sealed virtual override void System.Windows.Documents.ITextPointer.SetLogicalDirection(LogicalDirection direction);
    private sealed virtual override int System.Windows.Documents.ITextPointer.CompareTo(ITextPointer position);
    private sealed virtual override int System.Windows.Documents.ITextPointer.CompareTo(StaticTextPointer position);
    private sealed virtual override int System.Windows.Documents.ITextPointer.GetOffsetToPosition(ITextPointer position);
    private sealed virtual override TextPointerContext System.Windows.Documents.ITextPointer.GetPointerContext(LogicalDirection direction);
    private sealed virtual override int System.Windows.Documents.ITextPointer.GetTextRunLength(LogicalDirection direction);
    private sealed virtual override string System.Windows.Documents.ITextPointer.GetTextInRun(LogicalDirection direction);
    private sealed virtual override int System.Windows.Documents.ITextPointer.GetTextInRun(LogicalDirection direction, Char[] textBuffer, int startIndex, int count);
    private sealed virtual override object System.Windows.Documents.ITextPointer.GetAdjacentElement(LogicalDirection direction);
    private sealed virtual override Type System.Windows.Documents.ITextPointer.GetElementType(LogicalDirection direction);
    private sealed virtual override bool System.Windows.Documents.ITextPointer.HasEqualScope(ITextPointer position);
    private sealed virtual override object System.Windows.Documents.ITextPointer.GetValue(DependencyProperty formattingProperty);
    private sealed virtual override object System.Windows.Documents.ITextPointer.ReadLocalValue(DependencyProperty formattingProperty);
    private sealed virtual override LocalValueEnumerator System.Windows.Documents.ITextPointer.GetLocalValueEnumerator();
    private sealed virtual override ITextPointer System.Windows.Documents.ITextPointer.CreatePointer();
    private sealed virtual override StaticTextPointer System.Windows.Documents.ITextPointer.CreateStaticPointer();
    private sealed virtual override ITextPointer System.Windows.Documents.ITextPointer.CreatePointer(int distance);
    private sealed virtual override ITextPointer System.Windows.Documents.ITextPointer.CreatePointer(LogicalDirection gravity);
    private sealed virtual override ITextPointer System.Windows.Documents.ITextPointer.CreatePointer(int distance, LogicalDirection gravity);
    private sealed virtual override void System.Windows.Documents.ITextPointer.Freeze();
    private sealed virtual override ITextPointer System.Windows.Documents.ITextPointer.GetFrozenPointer(LogicalDirection logicalDirection);
    private sealed virtual override void System.Windows.Documents.ITextPointer.InsertTextInRun(string textData);
    private sealed virtual override void System.Windows.Documents.ITextPointer.DeleteContentToPosition(ITextPointer limit);
    private sealed virtual override bool System.Windows.Documents.ITextPointer.MoveToNextContextPosition(LogicalDirection direction);
    private sealed virtual override int System.Windows.Documents.ITextPointer.MoveByOffset(int distance);
    private sealed virtual override void System.Windows.Documents.ITextPointer.MoveToPosition(ITextPointer position);
    private sealed virtual override void System.Windows.Documents.ITextPointer.MoveToElementEdge(ElementEdge edge);
    private sealed virtual override int System.Windows.Documents.ITextPointer.MoveToLineBoundary(int count);
    private sealed virtual override Rect System.Windows.Documents.ITextPointer.GetCharacterRect(LogicalDirection direction);
    private sealed virtual override bool System.Windows.Documents.ITextPointer.MoveToInsertionPosition(LogicalDirection direction);
    private sealed virtual override bool System.Windows.Documents.ITextPointer.MoveToNextInsertionPosition(LogicalDirection direction);
    private sealed virtual override ITextPointer System.Windows.Documents.ITextPointer.GetNextContextPosition(LogicalDirection direction);
    private sealed virtual override ITextPointer System.Windows.Documents.ITextPointer.GetInsertionPosition(LogicalDirection direction);
    private sealed virtual override ITextPointer System.Windows.Documents.ITextPointer.GetNextInsertionPosition(LogicalDirection direction);
    private sealed virtual override ITextPointer System.Windows.Documents.ITextPointer.GetFormatNormalizedPosition(LogicalDirection direction);
    private sealed virtual override bool System.Windows.Documents.ITextPointer.ValidateLayout();
    private sealed virtual override Type System.Windows.Documents.ITextPointer.get_ParentType();
    private sealed virtual override ITextContainer System.Windows.Documents.ITextPointer.get_TextContainer();
    private sealed virtual override bool System.Windows.Documents.ITextPointer.get_HasValidLayout();
    private sealed virtual override bool System.Windows.Documents.ITextPointer.get_IsAtCaretUnitBoundary();
    private sealed virtual override LogicalDirection System.Windows.Documents.ITextPointer.get_LogicalDirection();
    private sealed virtual override bool System.Windows.Documents.ITextPointer.get_IsAtInsertionPosition();
    private sealed virtual override bool System.Windows.Documents.ITextPointer.get_IsFrozen();
    private sealed virtual override int System.Windows.Documents.ITextPointer.get_Offset();
    private sealed virtual override int System.Windows.Documents.ITextPointer.get_CharOffset();
    internal PasswordTextContainer get_Container();
    internal LogicalDirection get_LogicalDirection();
    internal int get_Offset();
    internal void set_Offset(int value);
}
internal class System.Windows.Controls.PopupControlService : object {
    internal static RoutedEvent ContextMenuOpenedEvent;
    internal static RoutedEvent ContextMenuClosedEvent;
    internal static DependencyProperty ServiceOwnedProperty;
    internal static DependencyProperty OwnerProperty;
    private DispatcherTimer _toolTipTimer;
    private bool _quickShow;
    private WeakReference _lastMouseDirectlyOver;
    private WeakReference _lastMouseOverWithToolTip;
    private WeakReference _lastObjectWithToolTip;
    private WeakReference _lastChecked;
    private bool _lastToolTipOpen;
    private ToolTip _currentToolTip;
    private DispatcherTimer _forceCloseTimer;
    private bool _ownToolTip;
    private KeyboardFocusChangedEventHandler _focusChangedEventHandler;
    private IInputElement LastMouseDirectlyOver { get; private set; }
    private DependencyObject LastMouseOverWithToolTip { get; private set; }
    private DependencyObject LastObjectWithToolTip { get; private set; }
    private DependencyObject LastChecked { get; private set; }
    internal static PopupControlService Current { get; }
    internal ToolTip CurrentToolTip { get; }
    private DispatcherTimer ToolTipTimer { get; private set; }
    internal KeyboardFocusChangedEventHandler FocusChangedEventHandler { get; }
    private static PopupControlService();
    private void OnPostProcessInput(object sender, ProcessInputEventArgs e);
    private void OnMouseMove(IInputElement directlyOver, Point pt);
    private void OnFocusChanged(object sender, KeyboardFocusChangedEventArgs e);
    private void ProcessMouseUp(object sender, MouseButtonEventArgs e);
    private void ProcessKeyDown(object sender, KeyEventArgs e);
    public bool OpenOrCloseToolTipViaShortcut();
    private void ProcessKeyUp(object sender, KeyEventArgs e);
    private bool InspectElementForToolTip(DependencyObject o, ToolTipTrigger triggerAction);
    private bool LocateNearestToolTip(DependencyObject& o, ToolTipTrigger triggerAction, Boolean& showToolTip);
    internal bool StopLookingForToolTip(DependencyObject o);
    private bool WithinCurrentToolTip(DependencyObject o);
    private void ResetToolTipTimer();
    internal void OnRaiseToolTipOpeningEvent(object sender, EventArgs e);
    private void RaiseToolTipOpeningEvent(bool fromKeyboard);
    internal void OnRaiseToolTipClosingEvent(object sender, EventArgs e);
    private void RaiseToolTipClosingEvent(bool reset);
    private void OnToolTipOpened(object sender, EventArgs e);
    private void OnToolTipClosed(object sender, EventArgs e);
    private void OnForceClose(object sender, EventArgs e);
    private void OnBetweenShowDelay(object source, EventArgs e);
    private IInputElement get_LastMouseDirectlyOver();
    private void set_LastMouseDirectlyOver(IInputElement value);
    private DependencyObject get_LastMouseOverWithToolTip();
    private void set_LastMouseOverWithToolTip(DependencyObject value);
    private DependencyObject get_LastObjectWithToolTip();
    private void set_LastObjectWithToolTip(DependencyObject value);
    private DependencyObject get_LastChecked();
    private void set_LastChecked(DependencyObject value);
    private void RaiseContextMenuOpeningEvent(KeyEventArgs e);
    private bool RaiseContextMenuOpeningEvent(IInputElement source, double x, double y, bool userInitiated);
    private void OnContextMenuClosed(object source, RoutedEventArgs e);
    private static bool IsPresentationSourceNull(DependencyObject uie);
    internal static DependencyObject FindParent(DependencyObject o);
    internal static DependencyObject FindContentElementParent(ContentElement ce);
    internal static bool IsElementEnabled(DependencyObject o);
    internal static PopupControlService get_Current();
    internal ToolTip get_CurrentToolTip();
    private DispatcherTimer get_ToolTipTimer();
    private void set_ToolTipTimer(DispatcherTimer value);
    private static UIElement GetTarget(DependencyObject o);
    private static void OnOwnerChanged(DependencyObject o, DependencyPropertyChangedEventArgs e);
    internal static object CoerceProperty(DependencyObject o, object value, DependencyProperty dp);
    internal KeyboardFocusChangedEventHandler get_FocusChangedEventHandler();
}
public enum System.Windows.Controls.Primitives.AutoToolTipPlacement : Enum {
    public int value__;
    public static AutoToolTipPlacement None;
    public static AutoToolTipPlacement TopLeft;
    public static AutoToolTipPlacement BottomRight;
}
public class System.Windows.Controls.Primitives.BulletDecorator : Decorator {
    public static DependencyProperty BackgroundProperty;
    private UIElement _bullet;
    public Brush Background { get; public set; }
    public UIElement Bullet { get; public set; }
    protected internal IEnumerator LogicalChildren { get; }
    protected int VisualChildrenCount { get; }
    private static BulletDecorator();
    public Brush get_Background();
    public void set_Background(Brush value);
    public UIElement get_Bullet();
    public void set_Bullet(UIElement value);
    protected internal virtual IEnumerator get_LogicalChildren();
    protected virtual void OnRender(DrawingContext dc);
    protected virtual int get_VisualChildrenCount();
    protected virtual Visual GetVisualChild(int index);
    protected virtual Size MeasureOverride(Size constraint);
    protected virtual Size ArrangeOverride(Size arrangeSize);
    private double GetFirstLineHeight(UIElement element);
    private TextBlock FindText(Visual root);
    private FlowDocumentScrollViewer FindFlowDocumentScrollViewer(Visual root);
}
[DefaultEventAttribute("Click")]
[LocalizabilityAttribute("4")]
public abstract class System.Windows.Controls.Primitives.ButtonBase : ContentControl {
    public static RoutedEvent ClickEvent;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty CommandProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty CommandParameterProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty CommandTargetProperty;
    internal static DependencyPropertyKey IsPressedPropertyKey;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty IsPressedProperty;
    public static DependencyProperty ClickModeProperty;
    private bool IsInMainFocusScope { get; }
    [BrowsableAttribute("False")]
[CategoryAttribute("Appearance")]
[ReadOnlyAttribute("True")]
public bool IsPressed { get; protected set; }
    [CategoryAttribute("Action")]
[BindableAttribute("True")]
[LocalizabilityAttribute("17")]
public ICommand Command { get; public set; }
    protected bool IsEnabledCore { get; }
    [LocalizabilityAttribute("17")]
[CategoryAttribute("Action")]
[BindableAttribute("True")]
public object CommandParameter { get; public set; }
    [CategoryAttribute("Action")]
[BindableAttribute("True")]
public IInputElement CommandTarget { get; public set; }
    [BindableAttribute("True")]
[CategoryAttribute("Behavior")]
public ClickMode ClickMode { get; public set; }
    private bool IsSpaceKeyDown { get; private set; }
    private bool CanExecute { get; private set; }
    private static ButtonBase();
    protected virtual void OnClick();
    protected virtual void OnIsPressedChanged(DependencyPropertyChangedEventArgs e);
    private bool get_IsInMainFocusScope();
    internal void AutomationButtonBaseClick();
    private static bool IsValidClickMode(object o);
    protected internal virtual void OnRenderSizeChanged(SizeChangedInfo sizeInfo);
    private static void OnIsPressedChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void OnAccessKeyPressed(object sender, AccessKeyPressedEventArgs e);
    private void UpdateIsPressed();
    public void add_Click(RoutedEventHandler value);
    public void remove_Click(RoutedEventHandler value);
    public bool get_IsPressed();
    protected void set_IsPressed(bool value);
    private void SetIsPressed(bool pressed);
    public sealed virtual ICommand get_Command();
    public void set_Command(ICommand value);
    private static void OnCommandChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private void OnCommandChanged(ICommand oldCommand, ICommand newCommand);
    private void UnhookCommand(ICommand command);
    private void HookCommand(ICommand command);
    private void OnCanExecuteChanged(object sender, EventArgs e);
    private void UpdateCanExecute();
    protected virtual bool get_IsEnabledCore();
    public sealed virtual object get_CommandParameter();
    public void set_CommandParameter(object value);
    public sealed virtual IInputElement get_CommandTarget();
    public void set_CommandTarget(IInputElement value);
    public ClickMode get_ClickMode();
    public void set_ClickMode(ClickMode value);
    protected virtual void OnMouseLeftButtonDown(MouseButtonEventArgs e);
    protected virtual void OnMouseLeftButtonUp(MouseButtonEventArgs e);
    protected virtual void OnMouseMove(MouseEventArgs e);
    protected virtual void OnLostMouseCapture(MouseEventArgs e);
    protected virtual void OnMouseEnter(MouseEventArgs e);
    protected virtual void OnMouseLeave(MouseEventArgs e);
    private bool HandleIsMouseOverChanged();
    protected virtual void OnKeyDown(KeyEventArgs e);
    protected virtual void OnKeyUp(KeyEventArgs e);
    protected virtual void OnLostKeyboardFocus(KeyboardFocusChangedEventArgs e);
    protected virtual void OnAccessKey(AccessKeyEventArgs e);
    private bool GetMouseLeftButtonReleased();
    private bool get_IsSpaceKeyDown();
    private void set_IsSpaceKeyDown(bool value);
    private bool get_CanExecute();
    private void set_CanExecute(bool value);
    internal virtual void ChangeVisualState(bool useTransitions);
}
public class System.Windows.Controls.Primitives.CalendarButton : Button {
    internal static DependencyPropertyKey HasSelectedDaysPropertyKey;
    public static DependencyProperty HasSelectedDaysProperty;
    internal static DependencyPropertyKey IsInactivePropertyKey;
    public static DependencyProperty IsInactiveProperty;
    [CompilerGeneratedAttribute]
private Calendar <Owner>k__BackingField;
    public bool HasSelectedDays { get; internal set; }
    public bool IsInactive { get; internal set; }
    internal Calendar Owner { get; internal set; }
    private static CalendarButton();
    public bool get_HasSelectedDays();
    internal void set_HasSelectedDays(bool value);
    public bool get_IsInactive();
    internal void set_IsInactive(bool value);
    [CompilerGeneratedAttribute]
internal Calendar get_Owner();
    [CompilerGeneratedAttribute]
internal void set_Owner(Calendar value);
    internal virtual void ChangeVisualState(bool useTransitions);
    protected virtual AutomationPeer OnCreateAutomationPeer();
    internal void SetContentInternal(string value);
}
public class System.Windows.Controls.Primitives.CalendarDayButton : Button {
    private static int DEFAULTCONTENT;
    internal static DependencyPropertyKey IsTodayPropertyKey;
    public static DependencyProperty IsTodayProperty;
    internal static DependencyPropertyKey IsSelectedPropertyKey;
    public static DependencyProperty IsSelectedProperty;
    internal static DependencyPropertyKey IsInactivePropertyKey;
    public static DependencyProperty IsInactiveProperty;
    internal static DependencyPropertyKey IsBlackedOutPropertyKey;
    public static DependencyProperty IsBlackedOutProperty;
    internal static DependencyPropertyKey IsHighlightedPropertyKey;
    public static DependencyProperty IsHighlightedProperty;
    [CompilerGeneratedAttribute]
private Calendar <Owner>k__BackingField;
    public bool IsToday { get; }
    public bool IsSelected { get; }
    public bool IsInactive { get; }
    public bool IsBlackedOut { get; }
    public bool IsHighlighted { get; }
    internal Calendar Owner { get; internal set; }
    private static CalendarDayButton();
    public bool get_IsToday();
    public bool get_IsSelected();
    public bool get_IsInactive();
    public bool get_IsBlackedOut();
    public bool get_IsHighlighted();
    [CompilerGeneratedAttribute]
internal Calendar get_Owner();
    [CompilerGeneratedAttribute]
internal void set_Owner(Calendar value);
    protected virtual AutomationPeer OnCreateAutomationPeer();
    internal virtual void ChangeVisualState(bool useTransitions);
    internal void NotifyNeedsVisualStateUpdate();
    internal void SetContentInternal(string value);
}
[TemplatePartAttribute]
[TemplatePartAttribute]
[TemplatePartAttribute]
[TemplatePartAttribute]
[TemplatePartAttribute]
[TemplatePartAttribute]
[TemplatePartAttribute]
[TemplatePartAttribute]
public class System.Windows.Controls.Primitives.CalendarItem : Control {
    private static string ElementRoot;
    private static string ElementHeaderButton;
    private static string ElementPreviousButton;
    private static string ElementNextButton;
    private static string ElementDayTitleTemplate;
    private static string ElementMonthView;
    private static string ElementYearView;
    private static string ElementDisabledVisual;
    private static int COLS;
    private static int ROWS;
    private static int YEAR_COLS;
    private static int YEAR_ROWS;
    private static int NUMBER_OF_DAYS_IN_WEEK;
    private static ComponentResourceKey _dayTitleTemplateResourceKey;
    private Calendar _calendar;
    private DataTemplate _dayTitleTemplate;
    private FrameworkElement _disabledVisual;
    private Button _headerButton;
    private Grid _monthView;
    private Button _nextButton;
    private Button _previousButton;
    private Grid _yearView;
    private bool _isMonthPressed;
    private bool _isDayPressed;
    [CompilerGeneratedAttribute]
private Calendar <Owner>k__BackingField;
    internal Grid MonthView { get; }
    internal Calendar Owner { get; internal set; }
    internal Grid YearView { get; }
    private CalendarMode DisplayMode { get; }
    internal Button HeaderButton { get; }
    internal Button NextButton { get; }
    internal Button PreviousButton { get; }
    private DateTime DisplayDate { get; }
    public static ComponentResourceKey DayTitleTemplateResourceKey { get; }
    private static CalendarItem();
    internal Grid get_MonthView();
    [CompilerGeneratedAttribute]
internal Calendar get_Owner();
    [CompilerGeneratedAttribute]
internal void set_Owner(Calendar value);
    internal Grid get_YearView();
    private CalendarMode get_DisplayMode();
    internal Button get_HeaderButton();
    internal Button get_NextButton();
    internal Button get_PreviousButton();
    private DateTime get_DisplayDate();
    public virtual void OnApplyTemplate();
    internal virtual void ChangeVisualState(bool useTransitions);
    protected virtual void OnMouseUp(MouseButtonEventArgs e);
    protected virtual void OnLostMouseCapture(MouseEventArgs e);
    internal void UpdateDecadeMode();
    internal void UpdateMonthMode();
    internal void UpdateYearMode();
    [IteratorStateMachineAttribute("System.Windows.Controls.Primitives.CalendarItem/<GetCalendarDayButtons>d__51")]
internal IEnumerable`1<CalendarDayButton> GetCalendarDayButtons();
    internal CalendarDayButton GetFocusedCalendarDayButton();
    internal CalendarDayButton GetCalendarDayButton(DateTime date);
    internal CalendarButton GetCalendarButton(DateTime date, CalendarMode mode);
    internal CalendarButton GetFocusedCalendarButton();
    [IteratorStateMachineAttribute("System.Windows.Controls.Primitives.CalendarItem/<GetCalendarButtons>d__56")]
private IEnumerable`1<CalendarButton> GetCalendarButtons();
    internal void FocusDate(DateTime date);
    private int GetDecadeForDecadeMode(DateTime selectedYear);
    private void EndDrag(bool ctrl, DateTime selectedDate);
    private void CellOrMonth_PreviewKeyDown(object sender, RoutedEventArgs e);
    private void Cell_Clicked(object sender, RoutedEventArgs e);
    private void Cell_MouseLeftButtonDown(object sender, MouseButtonEventArgs e);
    private void Cell_MouseEnter(object sender, MouseEventArgs e);
    private void Cell_MouseLeftButtonUp(object sender, MouseButtonEventArgs e);
    private void FinishSelection(DateTime selectedDate);
    private void Month_MouseLeftButtonDown(object sender, MouseButtonEventArgs e);
    private void Month_MouseLeftButtonUp(object sender, MouseButtonEventArgs e);
    private void Month_MouseEnter(object sender, MouseEventArgs e);
    private void Month_Clicked(object sender, RoutedEventArgs e);
    private void HeaderButton_Click(object sender, RoutedEventArgs e);
    private void PreviousButton_Click(object sender, RoutedEventArgs e);
    private void NextButton_Click(object sender, RoutedEventArgs e);
    private void PopulateGrids();
    private void SetMonthModeDayTitles();
    private void SetMonthModeCalendarDayButtons();
    private void SetMonthModeDayButtonState(CalendarDayButton childButton, Nullable`1<DateTime> dateToAdd);
    private void AddMonthModeHighlight();
    private void SetMonthModeHeaderButton();
    private void SetMonthModeNextButton();
    private void SetMonthModePreviousButton();
    private void SetYearButtons(int decade, int decadeEnd);
    private void SetYearModeMonthButtons();
    private void SetYearModeHeaderButton();
    private void SetYearModeNextButton();
    private void SetYearModePreviousButton();
    private void SetDecadeModeHeaderButton(int decade);
    private void SetDecadeModeNextButton(int decadeEnd);
    private void SetDecadeModePreviousButton(int decade);
    private int GetNumberOfDisplayedDaysFromPreviousMonth(DateTime firstOfMonth);
    private BindingBase GetOwnerBinding(string propertyName);
    public static ComponentResourceKey get_DayTitleTemplateResourceKey();
}
public class System.Windows.Controls.Primitives.CustomPopupPlacement : ValueType {
    private Point _point;
    private PopupPrimaryAxis _primaryAxis;
    public Point Point { get; public set; }
    public PopupPrimaryAxis PrimaryAxis { get; public set; }
    public CustomPopupPlacement(Point point, PopupPrimaryAxis primaryAxis);
    public Point get_Point();
    public void set_Point(Point value);
    public PopupPrimaryAxis get_PrimaryAxis();
    public void set_PrimaryAxis(PopupPrimaryAxis value);
    public static bool op_Equality(CustomPopupPlacement placement1, CustomPopupPlacement placement2);
    public static bool op_Inequality(CustomPopupPlacement placement1, CustomPopupPlacement placement2);
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
}
public class System.Windows.Controls.Primitives.CustomPopupPlacementCallback : MulticastDelegate {
    public CustomPopupPlacementCallback(object object, IntPtr method);
    public virtual CustomPopupPlacement[] Invoke(Size popupSize, Size targetSize, Point offset);
    public virtual IAsyncResult BeginInvoke(Size popupSize, Size targetSize, Point offset, AsyncCallback callback, object object);
    public virtual CustomPopupPlacement[] EndInvoke(IAsyncResult result);
}
public class System.Windows.Controls.Primitives.DataGridCellsPresenter : ItemsControl {
    private object _item;
    private ContainerTracking`1<DataGridCell> _cellTrackingRoot;
    private Panel _internalItemsHost;
    public object Item { get; internal set; }
    internal Panel InternalItemsHost { get; internal set; }
    internal DataGrid DataGridOwner { get; }
    internal DataGridRow DataGridRowOwner { get; }
    private ObservableCollection`1<DataGridColumn> Columns { get; }
    internal ContainerTracking`1<DataGridCell> CellTrackingRoot { get; }
    private static DataGridCellsPresenter();
    public virtual void OnApplyTemplate();
    internal void SyncProperties(bool forcePrepareCells);
    private static object OnCoerceHeight(DependencyObject d, object baseValue);
    private static object OnCoerceMinHeight(DependencyObject d, object baseValue);
    public object get_Item();
    internal void set_Item(object value);
    protected virtual void OnItemChanged(object oldItem, object newItem);
    protected virtual bool IsItemItsOwnContainerOverride(object item);
    internal bool IsItemItsOwnContainerInternal(object item);
    protected virtual DependencyObject GetContainerForItemOverride();
    protected virtual void PrepareContainerForItemOverride(DependencyObject element, object item);
    protected virtual void ClearContainerForItemOverride(DependencyObject element, object item);
    protected internal virtual void OnColumnsChanged(ObservableCollection`1<DataGridColumn> columns, NotifyCollectionChangedEventArgs e);
    private static void OnNotifyHeightPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    internal void NotifyPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e, DataGridNotificationTarget target);
    internal void NotifyPropertyChanged(DependencyObject d, string propertyName, DependencyPropertyChangedEventArgs e, DataGridNotificationTarget target);
    protected virtual Size MeasureOverride(Size availableSize);
    protected virtual Size ArrangeOverride(Size finalSize);
    protected virtual void OnRender(DrawingContext drawingContext);
    private static void OnIsVirtualizingPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static object OnCoerceIsVirtualizingProperty(DependencyObject d, object baseValue);
    internal void InvalidateDataGridCellsPanelMeasureAndArrange();
    private void InvalidateDataGridCellsPanelMeasureAndArrangeImpl(bool invalidateMeasureUptoRowsPresenter);
    private void InvalidateDataGridCellsPanelMeasureAndArrange(bool withColumnVirtualization);
    internal Panel get_InternalItemsHost();
    internal void set_InternalItemsHost(Panel value);
    internal void ScrollCellIntoView(int index);
    internal DataGrid get_DataGridOwner();
    internal DataGridRow get_DataGridRowOwner();
    private ObservableCollection`1<DataGridColumn> get_Columns();
    internal ContainerTracking`1<DataGridCell> get_CellTrackingRoot();
}
[TemplatePartAttribute]
[TemplatePartAttribute]
public class System.Windows.Controls.Primitives.DataGridColumnHeader : ButtonBase {
    public static DependencyProperty SeparatorBrushProperty;
    public static DependencyProperty SeparatorVisibilityProperty;
    private static DependencyPropertyKey DisplayIndexPropertyKey;
    public static DependencyProperty DisplayIndexProperty;
    private static DependencyPropertyKey CanUserSortPropertyKey;
    public static DependencyProperty CanUserSortProperty;
    private static DependencyPropertyKey SortDirectionPropertyKey;
    public static DependencyProperty SortDirectionProperty;
    private static DependencyPropertyKey IsFrozenPropertyKey;
    public static DependencyProperty IsFrozenProperty;
    private DataGridColumn _column;
    private ContainerTracking`1<DataGridColumnHeader> _tracker;
    private DataGridColumnHeadersPresenter _parentPresenter;
    private Thumb _leftGripper;
    private Thumb _rightGripper;
    private bool _suppressClickEvent;
    private static string LeftHeaderGripperTemplateName;
    private static string RightHeaderGripperTemplateName;
    public DataGridColumn Column { get; }
    public Brush SeparatorBrush { get; public set; }
    public Visibility SeparatorVisibility { get; public set; }
    internal ContainerTracking`1<DataGridColumnHeader> Tracker { get; }
    public int DisplayIndex { get; }
    private DataGridLength ColumnWidth { get; }
    private double ColumnActualWidth { get; }
    public bool CanUserSort { get; }
    public Nullable`1<ListSortDirection> SortDirection { get; }
    public bool IsFrozen { get; }
    internal DataGridColumnHeadersPresenter ParentPresenter { get; }
    internal bool SuppressClickEvent { get; internal set; }
    public static ComponentResourceKey ColumnHeaderDropSeparatorStyleKey { get; }
    public static ComponentResourceKey ColumnFloatingHeaderStyleKey { get; }
    private DataGridColumn System.Windows.Controls.IProvideDataGridColumn.Column { get; }
    private Panel ParentPanel { get; }
    private DataGridColumnHeader PreviousVisibleHeader { get; }
    private static DataGridColumnHeader();
    public DataGridColumn get_Column();
    public Brush get_SeparatorBrush();
    public void set_SeparatorBrush(Brush value);
    public Visibility get_SeparatorVisibility();
    public void set_SeparatorVisibility(Visibility value);
    internal void PrepareColumnHeader(object item, DataGridColumn column);
    internal void ClearHeader();
    internal ContainerTracking`1<DataGridColumnHeader> get_Tracker();
    public int get_DisplayIndex();
    private static object OnCoerceDisplayIndex(DependencyObject d, object baseValue);
    private static void OnDisplayIndexChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public virtual void OnApplyTemplate();
    private void HookupGripperEvents();
    private void UnhookGripperEvents();
    private DataGridColumnHeader HeaderToResize(object gripper);
    private void OnColumnHeaderGripperDragStarted(object sender, DragStartedEventArgs e);
    private void OnColumnHeaderResize(object sender, DragDeltaEventArgs e);
    private static void RecomputeColumnWidthsOnColumnResize(DataGridColumnHeader header, double horizontalChange);
    private void OnColumnHeaderGripperDragCompleted(object sender, DragCompletedEventArgs e);
    private void OnGripperDoubleClicked(object sender, MouseButtonEventArgs e);
    private DataGridLength get_ColumnWidth();
    private double get_ColumnActualWidth();
    private static void OnNotifyPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    internal void NotifyPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private void OnCanUserResizeColumnsChanged();
    private void OnCanUserResizeChanged();
    private void SetLeftGripperVisibility();
    private void SetLeftGripperVisibility(bool canPreviousColumnResize);
    private void SetRightGripperVisibility();
    private void SetNextHeaderLeftGripperVisibility(bool canUserResize);
    private void OnColumnVisibilityChanged(DependencyPropertyChangedEventArgs e);
    private static object OnCoerceContent(DependencyObject d, object baseValue);
    private static object OnCoerceContentTemplate(DependencyObject d, object baseValue);
    private static object OnCoerceContentTemplateSelector(DependencyObject d, object baseValue);
    private static object OnCoerceStringFormat(DependencyObject d, object baseValue);
    private static object OnCoerceStyle(DependencyObject d, object baseValue);
    public bool get_CanUserSort();
    public Nullable`1<ListSortDirection> get_SortDirection();
    protected virtual void OnClick();
    private static object OnCoerceHeight(DependencyObject d, object baseValue);
    private static object OnCoerceCanUserSort(DependencyObject d, object baseValue);
    private static object OnCoerceSortDirection(DependencyObject d, object baseValue);
    protected virtual AutomationPeer OnCreateAutomationPeer();
    internal void Invoke();
    public bool get_IsFrozen();
    private static object OnCoerceIsFrozen(DependencyObject d, object baseValue);
    private static object OnCoerceClip(DependencyObject d, object baseValue);
    internal DataGridColumnHeadersPresenter get_ParentPresenter();
    internal bool get_SuppressClickEvent();
    internal void set_SuppressClickEvent(bool value);
    protected virtual void OnMouseLeftButtonDown(MouseButtonEventArgs e);
    protected virtual void OnMouseMove(MouseEventArgs e);
    protected virtual void OnMouseLeftButtonUp(MouseButtonEventArgs e);
    protected virtual void OnLostMouseCapture(MouseEventArgs e);
    public static ComponentResourceKey get_ColumnHeaderDropSeparatorStyleKey();
    public static ComponentResourceKey get_ColumnFloatingHeaderStyleKey();
    internal virtual void ChangeVisualState(bool useTransitions);
    private sealed virtual override DataGridColumn System.Windows.Controls.IProvideDataGridColumn.get_Column();
    private Panel get_ParentPanel();
    private DataGridColumnHeader get_PreviousVisibleHeader();
}
[TemplatePartAttribute]
public class System.Windows.Controls.Primitives.DataGridColumnHeadersPresenter : ItemsControl {
    private static string ElementFillerColumnHeader;
    private ContainerTracking`1<DataGridColumnHeader> _headerTrackingRoot;
    private DataGrid _parentDataGrid;
    private bool _prepareColumnHeaderDragging;
    private bool _isColumnHeaderDragging;
    private DataGridColumnHeader _draggingSrcColumnHeader;
    private Point _columnHeaderDragStartPosition;
    private Point _columnHeaderDragStartRelativePosition;
    private Point _columnHeaderDragCurrentPosition;
    private Control _columnHeaderDropLocationIndicator;
    private Control _columnHeaderDragIndicator;
    private Panel _internalItemsHost;
    internal Panel InternalItemsHost { get; internal set; }
    protected int VisualChildrenCount { get; }
    private DataGridColumnHeaderCollection HeaderCollection { get; }
    internal DataGrid ParentDataGrid { get; }
    internal ContainerTracking`1<DataGridColumnHeader> HeaderTrackingRoot { get; }
    private static DataGridColumnHeadersPresenter();
    public virtual void OnApplyTemplate();
    protected virtual AutomationPeer OnCreateAutomationPeer();
    protected virtual Size MeasureOverride(Size availableSize);
    protected virtual Size ArrangeOverride(Size finalSize);
    protected virtual Geometry GetLayoutClip(Size layoutSlotSize);
    protected virtual DependencyObject GetContainerForItemOverride();
    protected virtual bool IsItemItsOwnContainerOverride(object item);
    internal bool IsItemItsOwnContainerInternal(object item);
    protected virtual void PrepareContainerForItemOverride(DependencyObject element, object item);
    protected virtual void ClearContainerForItemOverride(DependencyObject element, object item);
    private DataGridColumn ColumnFromContainer(DataGridColumnHeader container);
    internal void NotifyPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e, DataGridNotificationTarget target);
    internal void NotifyPropertyChanged(DependencyObject d, string propertyName, DependencyPropertyChangedEventArgs e, DataGridNotificationTarget target);
    private static void OnIsVirtualizingPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static object OnCoerceIsVirtualizingProperty(DependencyObject d, object baseValue);
    private void InvalidateDataGridCellsPanelMeasureAndArrange();
    private void InvalidateDataGridCellsPanelMeasureAndArrange(bool withColumnVirtualization);
    internal Panel get_InternalItemsHost();
    internal void set_InternalItemsHost(Panel value);
    protected virtual int get_VisualChildrenCount();
    protected virtual Visual GetVisualChild(int index);
    internal void OnHeaderMouseLeftButtonDown(MouseButtonEventArgs e);
    internal void OnHeaderMouseMove(MouseEventArgs e);
    internal void OnHeaderMouseLeftButtonUp(MouseButtonEventArgs e);
    internal void OnHeaderLostMouseCapture(MouseEventArgs e);
    private void ClearColumnHeaderDragInfo();
    private void PrepareColumnHeaderDrag(DataGridColumnHeader header, Point pos, Point relativePos);
    private static bool CheckStartColumnHeaderDrag(Point currentPos, Point originalPos);
    private bool IsMousePositionValidForColumnDrag(double dragFactor);
    private bool IsMousePositionValidForColumnDrag(double dragFactor, Int32& nearestDisplayIndex);
    private void StartColumnHeaderDrag();
    private Control CreateColumnHeaderDragIndicator();
    private void SetDefaultsOnDragIndicator();
    private Control CreateColumnHeaderDropIndicator();
    private void SetDefaultsOnDropIndicator();
    private void FinishColumnHeaderDrag(bool isCancel);
    private int FindDisplayIndexByPosition(Point startPos, bool findNearestColumn);
    private DataGridColumnHeader FindColumnHeaderByPosition(Point startPos);
    private Point FindColumnHeaderPositionByCurrentPosition(Point startPos, bool findNearestColumn);
    private static double GetColumnEstimatedWidth(DataGridColumn column, double averageColumnWidth);
    private void FindDisplayIndexAndHeaderPosition(Point startPos, bool findNearestColumn, Int32& displayIndex, Point& headerPos, DataGridColumnHeader& header);
    private DataGridColumnHeaderCollection get_HeaderCollection();
    internal DataGrid get_ParentDataGrid();
    internal ContainerTracking`1<DataGridColumnHeader> get_HeaderTrackingRoot();
}
public class System.Windows.Controls.Primitives.DataGridDetailsPresenter : ContentPresenter {
    internal FrameworkElement DetailsElement { get; }
    private DataGrid DataGridOwner { get; }
    internal DataGridRow DataGridRowOwner { get; }
    private static DataGridDetailsPresenter();
    protected virtual AutomationPeer OnCreateAutomationPeer();
    private static object OnCoerceContentTemplate(DependencyObject d, object baseValue);
    private static object OnCoerceContentTemplateSelector(DependencyObject d, object baseValue);
    protected internal virtual void OnVisualParentChanged(DependencyObject oldParent);
    private static void OnAnyMouseLeftButtonDownThunk(object sender, MouseButtonEventArgs e);
    private void OnAnyMouseLeftButtonDown(MouseButtonEventArgs e);
    internal FrameworkElement get_DetailsElement();
    internal void SyncProperties();
    private static void OnNotifyPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    internal void NotifyPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    protected virtual Size MeasureOverride(Size availableSize);
    protected virtual Size ArrangeOverride(Size finalSize);
    protected virtual void OnRender(DrawingContext drawingContext);
    private DataGrid get_DataGridOwner();
    internal DataGridRow get_DataGridRowOwner();
}
[TemplatePartAttribute]
[TemplatePartAttribute]
public class System.Windows.Controls.Primitives.DataGridRowHeader : ButtonBase {
    private static byte DATAGRIDROWHEADER_stateMouseOverCode;
    private static byte DATAGRIDROWHEADER_stateMouseOverCurrentRowCode;
    private static byte DATAGRIDROWHEADER_stateMouseOverEditingRowCode;
    private static byte DATAGRIDROWHEADER_stateMouseOverEditingRowFocusedCode;
    private static byte DATAGRIDROWHEADER_stateMouseOverSelectedCode;
    private static byte DATAGRIDROWHEADER_stateMouseOverSelectedCurrentRowCode;
    private static byte DATAGRIDROWHEADER_stateMouseOverSelectedCurrentRowFocusedCode;
    private static byte DATAGRIDROWHEADER_stateMouseOverSelectedFocusedCode;
    private static byte DATAGRIDROWHEADER_stateNormalCode;
    private static byte DATAGRIDROWHEADER_stateNormalCurrentRowCode;
    private static byte DATAGRIDROWHEADER_stateNormalEditingRowCode;
    private static byte DATAGRIDROWHEADER_stateNormalEditingRowFocusedCode;
    private static byte DATAGRIDROWHEADER_stateSelectedCode;
    private static byte DATAGRIDROWHEADER_stateSelectedCurrentRowCode;
    private static byte DATAGRIDROWHEADER_stateSelectedCurrentRowFocusedCode;
    private static byte DATAGRIDROWHEADER_stateSelectedFocusedCode;
    private static byte DATAGRIDROWHEADER_stateNullCode;
    private static Byte[] _fallbackStateMapping;
    private static Byte[] _idealStateMapping;
    private static String[] _stateNames;
    public static DependencyProperty SeparatorBrushProperty;
    public static DependencyProperty SeparatorVisibilityProperty;
    private static DependencyPropertyKey IsRowSelectedPropertyKey;
    public static DependencyProperty IsRowSelectedProperty;
    private Thumb _topGripper;
    private Thumb _bottomGripper;
    private static string TopHeaderGripperTemplateName;
    private static string BottomHeaderGripperTemplateName;
    public Brush SeparatorBrush { get; public set; }
    public Visibility SeparatorVisibility { get; public set; }
    private bool IsRowCurrent { get; }
    private bool IsRowEditing { get; }
    private bool IsRowMouseOver { get; }
    private bool IsDataGridKeyboardFocusWithin { get; }
    [BindableAttribute("True")]
[CategoryAttribute("Appearance")]
public bool IsRowSelected { get; }
    private DataGridRow PreviousRow { get; }
    internal DataGridRow ParentRow { get; }
    private DataGrid DataGridOwner { get; }
    private static DataGridRowHeader();
    protected virtual AutomationPeer OnCreateAutomationPeer();
    public Brush get_SeparatorBrush();
    public void set_SeparatorBrush(Brush value);
    public Visibility get_SeparatorVisibility();
    public void set_SeparatorVisibility(Visibility value);
    protected virtual Size MeasureOverride(Size availableSize);
    public virtual void OnApplyTemplate();
    internal void SyncProperties();
    private static void OnNotifyPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    internal void NotifyPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static object OnCoerceContent(DependencyObject d, object baseValue);
    private static object OnCoerceContentTemplate(DependencyObject d, object baseValue);
    private static object OnCoerceContentTemplateSelector(DependencyObject d, object baseValue);
    private static object OnCoerceStyle(DependencyObject d, object baseValue);
    private static object OnCoerceWidth(DependencyObject d, object baseValue);
    private bool get_IsRowCurrent();
    private bool get_IsRowEditing();
    private bool get_IsRowMouseOver();
    private bool get_IsDataGridKeyboardFocusWithin();
    internal virtual void ChangeVisualState(bool useTransitions);
    public bool get_IsRowSelected();
    private static object OnCoerceIsRowSelected(DependencyObject d, object baseValue);
    protected virtual void OnClick();
    private void HookupGripperEvents();
    private void UnhookGripperEvents();
    private void SetTopGripperVisibility();
    private void SetBottomGripperVisibility();
    private DataGridRow get_PreviousRow();
    private DataGridRow RowToResize(object gripper);
    private void OnRowHeaderGripperDragStarted(object sender, DragStartedEventArgs e);
    private void OnRowHeaderResize(object sender, DragDeltaEventArgs e);
    private void OnRowHeaderGripperDragCompleted(object sender, DragCompletedEventArgs e);
    private void OnGripperDoubleClicked(object sender, MouseButtonEventArgs e);
    private void OnCanUserResizeRowsChanged();
    internal DataGridRow get_ParentRow();
    private DataGrid get_DataGridOwner();
}
public class System.Windows.Controls.Primitives.DataGridRowsPresenter : VirtualizingStackPanel {
    private DataGrid _owner;
    private Size _availableSize;
    internal Size AvailableSize { get; }
    internal DataGrid Owner { get; }
    internal void InternalBringIndexIntoView(int index);
    protected virtual void OnIsItemsHostChanged(bool oldIsItemsHost, bool newIsItemsHost);
    protected virtual void OnViewportSizeChanged(Size oldViewportSize, Size newViewportSize);
    protected virtual Size MeasureOverride(Size constraint);
    internal Size get_AvailableSize();
    protected virtual void OnCleanUpVirtualizedItem(CleanUpVirtualizedItemEventArgs e);
    internal DataGrid get_Owner();
}
[TemplatePartAttribute]
public class System.Windows.Controls.Primitives.DatePickerTextBox : TextBox {
    private static string ElementContentName;
    private ContentControl elementContent;
    internal static DependencyProperty WatermarkProperty;
    internal object Watermark { get; internal set; }
    private static DatePickerTextBox();
    internal object get_Watermark();
    internal void set_Watermark(object value);
    public virtual void OnApplyTemplate();
    protected virtual void OnGotFocus(RoutedEventArgs e);
    private void OnLoaded(object sender, RoutedEventArgs e);
    internal virtual void ChangeVisualState(bool useTransitions);
    private T ExtractTemplatePart(string partName);
    private static T ExtractTemplatePart(string partName, DependencyObject obj);
    private void OnDatePickerTextBoxIsEnabledChanged(object sender, DependencyPropertyChangedEventArgs e);
    private void OnWatermarkChanged();
    private static void OnWatermarkPropertyChanged(DependencyObject sender, DependencyPropertyChangedEventArgs args);
}
public class System.Windows.Controls.Primitives.DocumentPageView : FrameworkElement {
    public static DependencyProperty PageNumberProperty;
    public static DependencyProperty StretchProperty;
    public static DependencyProperty StretchDirectionProperty;
    [CompilerGeneratedAttribute]
private EventHandler PageConnected;
    [CompilerGeneratedAttribute]
private EventHandler PageDisconnected;
    private DocumentPaginator _documentPaginator;
    private double _pageZoom;
    private DocumentPage _documentPage;
    private DocumentPage _documentPageAsync;
    private DocumentPageTextView _textView;
    private DocumentPageHost _pageHost;
    private Visual _pageVisualClone;
    private Size _visualCloneSize;
    private bool _useAsynchronous;
    private bool _suspendLayout;
    private bool _disposed;
    private bool _newPageConnected;
    public DocumentPaginator DocumentPaginator { get; public set; }
    public DocumentPage DocumentPage { get; }
    public int PageNumber { get; public set; }
    public Stretch Stretch { get; public set; }
    public StretchDirection StretchDirection { get; public set; }
    protected bool IsDisposed { get; }
    protected int VisualChildrenCount { get; }
    internal bool UseAsynchronousGetPage { get; internal set; }
    internal DocumentPage DocumentPageInternal { get; }
    private static DocumentPageView();
    public DocumentPaginator get_DocumentPaginator();
    public void set_DocumentPaginator(DocumentPaginator value);
    public DocumentPage get_DocumentPage();
    public int get_PageNumber();
    public void set_PageNumber(int value);
    public Stretch get_Stretch();
    public void set_Stretch(Stretch value);
    public StretchDirection get_StretchDirection();
    public void set_StretchDirection(StretchDirection value);
    [CompilerGeneratedAttribute]
public void add_PageConnected(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_PageConnected(EventHandler value);
    [CompilerGeneratedAttribute]
public void add_PageDisconnected(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_PageDisconnected(EventHandler value);
    protected virtual void OnDpiChanged(DpiScale oldDpiScaleInfo, DpiScale newDpiScaleInfo);
    protected sealed virtual Size MeasureOverride(Size availableSize);
    protected sealed virtual Size ArrangeOverride(Size finalSize);
    protected virtual Visual GetVisualChild(int index);
    protected void Dispose();
    protected object GetService(Type serviceType);
    protected virtual AutomationPeer OnCreateAutomationPeer();
    protected bool get_IsDisposed();
    protected virtual int get_VisualChildrenCount();
    internal void SetPageZoom(double pageZoom);
    internal void SuspendLayout();
    internal void ResumeLayout();
    internal void DuplicateVisual();
    internal void RemoveDuplicateVisual();
    internal bool get_UseAsynchronousGetPage();
    internal void set_UseAsynchronousGetPage(bool value);
    internal DocumentPage get_DocumentPageInternal();
    private void HandlePageDestroyed(object sender, EventArgs e);
    private void HandleAsyncPageDestroyed(object sender, EventArgs e);
    private void HandleGetPageCompleted(object sender, GetPageCompletedEventArgs e);
    private void HandlePagesChanged(object sender, PagesChangedEventArgs e);
    private void OnTransformChangedAsync();
    private object OnTransformChanged(object arg);
    private void OnPageConnected();
    private void OnPageDisconnected();
    private void OnPageContentChanged();
    private void DisposeCurrentPage();
    private void DisposeAsyncPage();
    private void CheckDisposed();
    private bool ShouldReflowContent();
    private DocumentViewerBase GetHostViewer();
    private static void OnPageNumberChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private DrawingVisual DuplicatePageVisual();
    private sealed virtual override object System.IServiceProvider.GetService(Type serviceType);
    private sealed virtual override void System.IDisposable.Dispose();
}
[ContentPropertyAttribute("Document")]
public abstract class System.Windows.Controls.Primitives.DocumentViewerBase : Control {
    public static DependencyProperty DocumentProperty;
    protected static DependencyPropertyKey PageCountPropertyKey;
    public static DependencyProperty PageCountProperty;
    protected static DependencyPropertyKey MasterPageNumberPropertyKey;
    public static DependencyProperty MasterPageNumberProperty;
    protected static DependencyPropertyKey CanGoToPreviousPagePropertyKey;
    public static DependencyProperty CanGoToPreviousPageProperty;
    protected static DependencyPropertyKey CanGoToNextPagePropertyKey;
    public static DependencyProperty CanGoToNextPageProperty;
    public static DependencyProperty IsMasterPageProperty;
    [CompilerGeneratedAttribute]
private EventHandler PageViewsChanged;
    private ReadOnlyCollection`1<DocumentPageView> _pageViews;
    private FrameworkElement _textEditorRenderScope;
    private MultiPageTextView _textView;
    private TextEditor _textEditor;
    private IDocumentPaginatorSource _document;
    private Flags _flags;
    private XpsDocumentWriter _documentWriter;
    private static bool IsEditingEnabled;
    public IDocumentPaginatorSource Document { get; public set; }
    public int PageCount { get; }
    public int MasterPageNumber { get; }
    public bool CanGoToPreviousPage { get; }
    public bool CanGoToNextPage { get; }
    [CLSCompliantAttribute("False")]
public ReadOnlyCollection`1<DocumentPageView> PageViews { get; }
    protected internal IEnumerator LogicalChildren { get; }
    internal bool IsSelectionEnabled { get; internal set; }
    internal TextEditor TextEditor { get; }
    internal FrameworkElement TextEditorRenderScope { get; internal set; }
    private ITextContainer TextContainer { get; }
    private static DocumentViewerBase();
    public virtual void OnApplyTemplate();
    public void PreviousPage();
    public void NextPage();
    public void FirstPage();
    public void LastPage();
    public void GoToPage(int pageNumber);
    public void Print();
    public void CancelPrint();
    public virtual bool CanGoToPage(int pageNumber);
    public IDocumentPaginatorSource get_Document();
    public void set_Document(IDocumentPaginatorSource value);
    public int get_PageCount();
    public virtual int get_MasterPageNumber();
    public virtual bool get_CanGoToPreviousPage();
    public virtual bool get_CanGoToNextPage();
    public ReadOnlyCollection`1<DocumentPageView> get_PageViews();
    public static bool GetIsMasterPage(DependencyObject element);
    public static void SetIsMasterPage(DependencyObject element, bool value);
    [CompilerGeneratedAttribute]
public void add_PageViewsChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_PageViewsChanged(EventHandler value);
    protected virtual AutomationPeer OnCreateAutomationPeer();
    protected virtual void OnDpiChanged(DpiScale oldDpiScaleInfo, DpiScale newDpiScaleInfo);
    protected void InvalidatePageViews();
    protected DocumentPageView GetMasterPageView();
    protected virtual ReadOnlyCollection`1<DocumentPageView> GetPageViewsCollection(Boolean& changed);
    protected virtual void OnPageViewsChanged();
    protected virtual void OnMasterPageNumberChanged();
    protected virtual void OnBringIntoView(DependencyObject element, Rect rect, int pageNumber);
    protected virtual void OnPreviousPageCommand();
    protected virtual void OnNextPageCommand();
    protected virtual void OnFirstPageCommand();
    protected virtual void OnLastPageCommand();
    protected virtual void OnGoToPageCommand(int pageNumber);
    protected virtual void OnPrintCommand();
    protected virtual void OnCancelPrintCommand();
    protected virtual void OnDocumentChanged();
    protected internal virtual IEnumerator get_LogicalChildren();
    internal bool IsMasterPageView(DocumentPageView pageView);
    internal ITextRange Find(FindToolBar findToolBar);
    internal bool get_IsSelectionEnabled();
    internal void set_IsSelectionEnabled(bool value);
    internal TextEditor get_TextEditor();
    internal FrameworkElement get_TextEditorRenderScope();
    internal void set_TextEditorRenderScope(FrameworkElement value);
    private ITextPointer GetMasterPageTextPointer(bool startOfPage);
    private void UpdatePageViews();
    private void VerifyDocumentPageViews(ReadOnlyCollection`1<DocumentPageView> pageViews);
    private void FindDocumentPageViews(Visual root, List`1<DocumentPageView> pageViews);
    private AdornerDecorator FindAdornerDecorator(Visual root);
    private void AttachTextEditor();
    private void HandlePrintCompleted(object sender, WritingCompletedEventArgs e);
    private void HandlePrintCancelled(object sender, WritingCancelledEventArgs e);
    private void HandlePaginationCompleted(object sender, EventArgs e);
    private void HandlePaginationProgress(object sender, EventArgs e);
    private void HandleGetPageNumberCompleted(object sender, GetPageNumberCompletedEventArgs e);
    private void HandleRequestBringIntoView(RequestBringIntoViewEventArgs args);
    private void UpdateReadOnlyProperties(bool pageCountChanged, bool masterPageChanged);
    private void ShiftPagesByOffset(int offset);
    private void SetFlags(bool value, Flags flags);
    private bool CheckFlags(Flags flags);
    private void DocumentChanged(IDocumentPaginatorSource oldDocument, IDocumentPaginatorSource newDocument);
    private void CleanUpPrintOperation();
    private static void CreateCommandBindings();
    private static void CanExecuteRoutedEventHandler(object target, CanExecuteRoutedEventArgs args);
    private static void ExecutedRoutedEventHandler(object target, ExecutedRoutedEventArgs args);
    private static void HandleRequestBringIntoView(object sender, RequestBringIntoViewEventArgs args);
    private static void DocumentChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private ITextContainer get_TextContainer();
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object value);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string text);
    private sealed virtual override object System.IServiceProvider.GetService(Type serviceType);
}
public class System.Windows.Controls.Primitives.DragCompletedEventArgs : RoutedEventArgs {
    private double _horizontalChange;
    private double _verticalChange;
    private bool _wasCanceled;
    public double HorizontalChange { get; }
    public double VerticalChange { get; }
    public bool Canceled { get; }
    public DragCompletedEventArgs(double horizontalChange, double verticalChange, bool canceled);
    public double get_HorizontalChange();
    public double get_VerticalChange();
    public bool get_Canceled();
    protected virtual void InvokeEventHandler(Delegate genericHandler, object genericTarget);
}
public class System.Windows.Controls.Primitives.DragCompletedEventHandler : MulticastDelegate {
    public DragCompletedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, DragCompletedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, DragCompletedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Windows.Controls.Primitives.DragDeltaEventArgs : RoutedEventArgs {
    private double _horizontalChange;
    private double _verticalChange;
    public double HorizontalChange { get; }
    public double VerticalChange { get; }
    public DragDeltaEventArgs(double horizontalChange, double verticalChange);
    public double get_HorizontalChange();
    public double get_VerticalChange();
    protected virtual void InvokeEventHandler(Delegate genericHandler, object genericTarget);
}
public class System.Windows.Controls.Primitives.DragDeltaEventHandler : MulticastDelegate {
    public DragDeltaEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, DragDeltaEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, DragDeltaEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Windows.Controls.Primitives.DragStartedEventArgs : RoutedEventArgs {
    private double _horizontalOffset;
    private double _verticalOffset;
    public double HorizontalOffset { get; }
    public double VerticalOffset { get; }
    public DragStartedEventArgs(double horizontalOffset, double verticalOffset);
    public double get_HorizontalOffset();
    public double get_VerticalOffset();
    protected virtual void InvokeEventHandler(Delegate genericHandler, object genericTarget);
}
public class System.Windows.Controls.Primitives.DragStartedEventHandler : MulticastDelegate {
    public DragStartedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, DragStartedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, DragStartedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public enum System.Windows.Controls.Primitives.GeneratorDirection : Enum {
    public int value__;
    public static GeneratorDirection Forward;
    public static GeneratorDirection Backward;
}
public class System.Windows.Controls.Primitives.GeneratorPosition : ValueType {
    private int _index;
    private int _offset;
    public int Index { get; public set; }
    public int Offset { get; public set; }
    public GeneratorPosition(int index, int offset);
    public int get_Index();
    public void set_Index(int value);
    public int get_Offset();
    public void set_Offset(int value);
    public virtual int GetHashCode();
    public virtual string ToString();
    public virtual bool Equals(object o);
    public static bool op_Equality(GeneratorPosition gp1, GeneratorPosition gp2);
    public static bool op_Inequality(GeneratorPosition gp1, GeneratorPosition gp2);
}
public enum System.Windows.Controls.Primitives.GeneratorStatus : Enum {
    public int value__;
    public static GeneratorStatus NotStarted;
    public static GeneratorStatus GeneratingContainers;
    public static GeneratorStatus ContainersGenerated;
    public static GeneratorStatus Error;
}
public abstract class System.Windows.Controls.Primitives.GridViewRowPresenterBase : FrameworkElement {
    public static DependencyProperty ColumnsProperty;
    internal static double c_PaddingHeaderMinWidth;
    private UIElementCollection _uiElementCollection;
    private bool _needUpdateVisualTree;
    private List`1<double> _desiredWidthList;
    public GridViewColumnCollection Columns { get; public set; }
    protected internal IEnumerator LogicalChildren { get; }
    protected int VisualChildrenCount { get; }
    internal List`1<double> DesiredWidthList { get; private set; }
    internal bool NeedUpdateVisualTree { get; internal set; }
    internal UIElementCollection InternalChildren { get; }
    private bool IsPresenterVisualReady { get; }
    private static GridViewRowPresenterBase();
    public virtual string ToString();
    public GridViewColumnCollection get_Columns();
    public void set_Columns(GridViewColumnCollection value);
    protected internal virtual IEnumerator get_LogicalChildren();
    protected virtual int get_VisualChildrenCount();
    protected virtual Visual GetVisualChild(int index);
    internal virtual void OnColumnCollectionChanged(GridViewColumnCollectionChangedEventArgs e);
    internal abstract virtual void OnColumnPropertyChanged(GridViewColumn column, string propertyName);
    internal void EnsureDesiredWidthList();
    internal List`1<double> get_DesiredWidthList();
    private void set_DesiredWidthList(List`1<double> value);
    internal bool get_NeedUpdateVisualTree();
    internal void set_NeedUpdateVisualTree(bool value);
    internal UIElementCollection get_InternalChildren();
    private static void ColumnsPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private FrameworkElement GetStableAncester();
    private bool get_IsPresenterVisualReady();
    private sealed virtual override bool System.Windows.IWeakEventListener.ReceiveWeakEvent(Type managerType, object sender, EventArgs args);
    private void ColumnCollectionChanged(object sender, NotifyCollectionChangedEventArgs arg);
}
public interface System.Windows.Controls.Primitives.IContainItemStorage {
    public abstract virtual void StoreItemValue(object item, DependencyProperty dp, object value);
    public abstract virtual object ReadItemValue(object item, DependencyProperty dp);
    public abstract virtual void ClearItemValue(object item, DependencyProperty dp);
    public abstract virtual void ClearValue(DependencyProperty dp);
    public abstract virtual void Clear();
}
public interface System.Windows.Controls.Primitives.IHierarchicalVirtualizationAndScrollInfo {
    public HierarchicalVirtualizationConstraints Constraints { get; public set; }
    public HierarchicalVirtualizationHeaderDesiredSizes HeaderDesiredSizes { get; }
    public HierarchicalVirtualizationItemDesiredSizes ItemDesiredSizes { get; public set; }
    public Panel ItemsHost { get; }
    public bool MustDisableVirtualization { get; public set; }
    public bool InBackgroundLayout { get; public set; }
    public abstract virtual HierarchicalVirtualizationConstraints get_Constraints();
    public abstract virtual void set_Constraints(HierarchicalVirtualizationConstraints value);
    public abstract virtual HierarchicalVirtualizationHeaderDesiredSizes get_HeaderDesiredSizes();
    public abstract virtual HierarchicalVirtualizationItemDesiredSizes get_ItemDesiredSizes();
    public abstract virtual void set_ItemDesiredSizes(HierarchicalVirtualizationItemDesiredSizes value);
    public abstract virtual Panel get_ItemsHost();
    public abstract virtual bool get_MustDisableVirtualization();
    public abstract virtual void set_MustDisableVirtualization(bool value);
    public abstract virtual bool get_InBackgroundLayout();
    public abstract virtual void set_InBackgroundLayout(bool value);
}
public interface System.Windows.Controls.Primitives.IItemContainerGenerator {
    public abstract virtual ItemContainerGenerator GetItemContainerGeneratorForPanel(Panel panel);
    public abstract virtual IDisposable StartAt(GeneratorPosition position, GeneratorDirection direction);
    public abstract virtual IDisposable StartAt(GeneratorPosition position, GeneratorDirection direction, bool allowStartAtRealizedItem);
    public abstract virtual DependencyObject GenerateNext();
    public abstract virtual DependencyObject GenerateNext(Boolean& isNewlyRealized);
    public abstract virtual void PrepareItemContainer(DependencyObject container);
    public abstract virtual void RemoveAll();
    public abstract virtual void Remove(GeneratorPosition position, int count);
    public abstract virtual GeneratorPosition GeneratorPositionFromIndex(int itemIndex);
    public abstract virtual int IndexFromGeneratorPosition(GeneratorPosition position);
}
internal class System.Windows.Controls.Primitives.InternalCollectionChangedEventManager : WeakEventManager {
    private static InternalCollectionChangedEventManager CurrentManager { get; }
    public static void AddListener(GridViewColumnCollection source, IWeakEventListener listener);
    public static void RemoveListener(GridViewColumnCollection source, IWeakEventListener listener);
    public static void AddHandler(GridViewColumnCollection source, EventHandler`1<NotifyCollectionChangedEventArgs> handler);
    public static void RemoveHandler(GridViewColumnCollection source, EventHandler`1<NotifyCollectionChangedEventArgs> handler);
    protected virtual ListenerList NewListenerList();
    protected virtual void StartListening(object source);
    protected virtual void StopListening(object source);
    private static InternalCollectionChangedEventManager get_CurrentManager();
    private void OnCollectionChanged(object sender, NotifyCollectionChangedEventArgs args);
}
public interface System.Windows.Controls.Primitives.IRecyclingItemContainerGenerator {
    public abstract virtual void Recycle(GeneratorPosition position, int count);
}
public interface System.Windows.Controls.Primitives.IScrollInfo {
    public bool CanVerticallyScroll { get; public set; }
    public bool CanHorizontallyScroll { get; public set; }
    public double ExtentWidth { get; }
    public double ExtentHeight { get; }
    public double ViewportWidth { get; }
    public double ViewportHeight { get; }
    public double HorizontalOffset { get; }
    public double VerticalOffset { get; }
    public ScrollViewer ScrollOwner { get; public set; }
    public abstract virtual void LineUp();
    public abstract virtual void LineDown();
    public abstract virtual void LineLeft();
    public abstract virtual void LineRight();
    public abstract virtual void PageUp();
    public abstract virtual void PageDown();
    public abstract virtual void PageLeft();
    public abstract virtual void PageRight();
    public abstract virtual void MouseWheelUp();
    public abstract virtual void MouseWheelDown();
    public abstract virtual void MouseWheelLeft();
    public abstract virtual void MouseWheelRight();
    public abstract virtual void SetHorizontalOffset(double offset);
    public abstract virtual void SetVerticalOffset(double offset);
    public abstract virtual Rect MakeVisible(Visual visual, Rect rectangle);
    public abstract virtual bool get_CanVerticallyScroll();
    public abstract virtual void set_CanVerticallyScroll(bool value);
    public abstract virtual bool get_CanHorizontallyScroll();
    public abstract virtual void set_CanHorizontallyScroll(bool value);
    public abstract virtual double get_ExtentWidth();
    public abstract virtual double get_ExtentHeight();
    public abstract virtual double get_ViewportWidth();
    public abstract virtual double get_ViewportHeight();
    public abstract virtual double get_HorizontalOffset();
    public abstract virtual double get_VerticalOffset();
    public abstract virtual ScrollViewer get_ScrollOwner();
    public abstract virtual void set_ScrollOwner(ScrollViewer value);
}
public class System.Windows.Controls.Primitives.ItemsChangedEventArgs : EventArgs {
    private NotifyCollectionChangedAction _action;
    private GeneratorPosition _position;
    private GeneratorPosition _oldPosition;
    private int _itemCount;
    private int _itemUICount;
    public NotifyCollectionChangedAction Action { get; }
    public GeneratorPosition Position { get; }
    public GeneratorPosition OldPosition { get; }
    public int ItemCount { get; }
    public int ItemUICount { get; }
    internal ItemsChangedEventArgs(NotifyCollectionChangedAction action, GeneratorPosition position, GeneratorPosition oldPosition, int itemCount, int itemUICount);
    internal ItemsChangedEventArgs(NotifyCollectionChangedAction action, GeneratorPosition position, int itemCount, int itemUICount);
    public NotifyCollectionChangedAction get_Action();
    public GeneratorPosition get_Position();
    public GeneratorPosition get_OldPosition();
    public int get_ItemCount();
    public int get_ItemUICount();
}
public class System.Windows.Controls.Primitives.ItemsChangedEventHandler : MulticastDelegate {
    public ItemsChangedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, ItemsChangedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, ItemsChangedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public static class System.Windows.Controls.Primitives.LayoutInformation : object {
    private static void CheckArgument(FrameworkElement element);
    public static Rect GetLayoutSlot(FrameworkElement element);
    public static Geometry GetLayoutClip(FrameworkElement element);
    public static UIElement GetLayoutExceptionElement(Dispatcher dispatcher);
}
[LocalizabilityAttribute("8")]
[StyleTypedPropertyAttribute]
public abstract class System.Windows.Controls.Primitives.MenuBase : ItemsControl {
    public static DependencyProperty ItemContainerTemplateSelectorProperty;
    public static DependencyProperty UsesItemContainerTemplateProperty;
    internal static RoutedEvent IsSelectedChangedEvent;
    private object _currentItem;
    private static EventPrivateKey InternalMenuModeChangedKey;
    private PresentationSource _pushedMenuMode;
    private MenuItem _currentSelection;
    private BitVector32 _bitFlags;
    public ItemContainerTemplateSelector ItemContainerTemplateSelector { get; public set; }
    public bool UsesItemContainerTemplate { get; public set; }
    internal MenuItem CurrentSelection { get; internal set; }
    internal bool HasCapture { get; }
    internal bool IgnoreNextLeftRelease { get; internal set; }
    internal bool IgnoreNextRightRelease { get; internal set; }
    internal bool IsMenuMode { get; internal set; }
    internal bool OpenOnMouseEnter { get; internal set; }
    private bool HasPushedMenuMode { get; }
    private bool IsAcquireFocusMenuMode { get; private set; }
    private static MenuBase();
    public ItemContainerTemplateSelector get_ItemContainerTemplateSelector();
    public void set_ItemContainerTemplateSelector(ItemContainerTemplateSelector value);
    public bool get_UsesItemContainerTemplate();
    public void set_UsesItemContainerTemplate(bool value);
    private static void OnMouseButtonDown(object sender, MouseButtonEventArgs e);
    private static void OnMouseButtonUp(object sender, MouseButtonEventArgs e);
    protected virtual void HandleMouseButton(MouseButtonEventArgs e);
    private static void OnClickThroughThunk(object sender, MouseButtonEventArgs e);
    private void OnClickThrough(MouseButtonEventArgs e);
    private static void OnPromotedMouseButton(object sender, MouseButtonEventArgs e);
    protected virtual void OnMouseLeave(MouseEventArgs e);
    private static void OnPreviewKeyboardInputProviderAcquireFocus(object sender, KeyboardInputProviderAcquireFocusEventArgs e);
    private static void OnKeyboardInputProviderAcquireFocus(object sender, KeyboardInputProviderAcquireFocusEventArgs e);
    protected virtual void OnIsKeyboardFocusWithinChanged(DependencyPropertyChangedEventArgs e);
    private void InvokeMenuOpenedClosedAutomationEvent(bool open);
    private static void OnIsSelectedChanged(object sender, RoutedPropertyChangedEventArgs`1<bool> e);
    private bool IsDescendant(DependencyObject node);
    internal static bool IsDescendant(DependencyObject reference, DependencyObject node);
    protected virtual void OnKeyDown(KeyEventArgs e);
    protected virtual bool IsItemItsOwnContainerOverride(object item);
    protected virtual DependencyObject GetContainerForItemOverride();
    private static void OnLostMouseCapture(object sender, MouseEventArgs e);
    private static void OnMenuItemPreviewClick(object sender, RoutedEventArgs e);
    internal void add_InternalMenuModeChanged(EventHandler value);
    internal void remove_InternalMenuModeChanged(EventHandler value);
    private void RestorePreviousFocus();
    internal static void SetSuspendingPopupAnimation(ItemsControl menu, MenuItem ignore, bool suspend);
    internal void KeyboardLeaveMenuMode();
    internal MenuItem get_CurrentSelection();
    internal void set_CurrentSelection(MenuItem value);
    internal bool get_HasCapture();
    internal bool get_IgnoreNextLeftRelease();
    internal void set_IgnoreNextLeftRelease(bool value);
    internal bool get_IgnoreNextRightRelease();
    internal void set_IgnoreNextRightRelease(bool value);
    internal bool get_IsMenuMode();
    internal void set_IsMenuMode(bool value);
    internal bool get_OpenOnMouseEnter();
    internal void set_OpenOnMouseEnter(bool value);
    private void PushMenuMode(bool isAcquireFocusMenuMode);
    private void PopMenuMode();
    private bool get_HasPushedMenuMode();
    private bool get_IsAcquireFocusMenuMode();
    private void set_IsAcquireFocusMenuMode(bool value);
}
public abstract class System.Windows.Controls.Primitives.MultiSelector : Selector {
    protected bool CanSelectMultipleItems { get; protected set; }
    [BindableAttribute("True")]
[CategoryAttribute("Appearance")]
[DesignerSerializationVisibilityAttribute("0")]
public IList SelectedItems { get; }
    protected bool IsUpdatingSelectedItems { get; }
    protected bool get_CanSelectMultipleItems();
    protected void set_CanSelectMultipleItems(bool value);
    public IList get_SelectedItems();
    protected void BeginUpdateSelectedItems();
    protected void EndUpdateSelectedItems();
    protected bool get_IsUpdatingSelectedItems();
    public void SelectAll();
    public void UnselectAll();
}
[LocalizabilityAttribute("0")]
public enum System.Windows.Controls.Primitives.PlacementMode : Enum {
    public int value__;
    public static PlacementMode Absolute;
    public static PlacementMode Relative;
    public static PlacementMode Bottom;
    public static PlacementMode Center;
    public static PlacementMode Right;
    public static PlacementMode AbsolutePoint;
    public static PlacementMode RelativePoint;
    public static PlacementMode Mouse;
    public static PlacementMode MousePoint;
    public static PlacementMode Left;
    public static PlacementMode Top;
    public static PlacementMode Custom;
}
[DefaultEventAttribute("Opened")]
[DefaultPropertyAttribute("Child")]
[LocalizabilityAttribute("0")]
[ContentPropertyAttribute("Child")]
public class System.Windows.Controls.Primitives.Popup : FrameworkElement {
    internal static DependencyProperty TreatMousePlacementAsBottomProperty;
    public static DependencyProperty ChildProperty;
    internal static UncommonField`1<List`1<Popup>> RegisteredPopupsField;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty IsOpenProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty PlacementProperty;
    public static DependencyProperty CustomPopupPlacementCallbackProperty;
    public static DependencyProperty StaysOpenProperty;
    public static DependencyProperty HorizontalOffsetProperty;
    public static DependencyProperty VerticalOffsetProperty;
    public static DependencyProperty PlacementTargetProperty;
    public static DependencyProperty PlacementRectangleProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty PopupAnimationProperty;
    public static DependencyProperty AllowsTransparencyProperty;
    private static DependencyPropertyKey HasDropShadowPropertyKey;
    public static DependencyProperty HasDropShadowProperty;
    private static EventPrivateKey OpenedKey;
    private static EventPrivateKey ClosedKey;
    [CompilerGeneratedAttribute]
private EventHandler PopupCouldClose;
    private static UncommonField`1<Exception> SavedExceptionField;
    internal static double Tolerance;
    private static int AnimationDelay;
    internal static TimeSpan AnimationDelayTime;
    internal static RoutedEventHandler CloseOnUnloadedHandler;
    private static UncommonField`1<PopupRoot> ParentPopupRootField;
    private PositionInfo _positionInfo;
    private SecurityCriticalDataForSet`1<PopupRoot> _popupRoot;
    private DispatcherOperation _asyncCreate;
    private DispatcherTimer _asyncDestroy;
    private PopupSecurityHelper _secHelper;
    private BitVector32 _cacheValid;
    private static double RestrictPercentage;
    internal bool TreatMousePlacementAsBottom { get; internal set; }
    [CustomCategoryAttribute("Content")]
[BindableAttribute("True")]
public UIElement Child { get; public set; }
    [BindableAttribute("True")]
[CategoryAttribute("Appearance")]
public bool IsOpen { get; public set; }
    [BindableAttribute("True")]
[CategoryAttribute("Layout")]
public PlacementMode Placement { get; public set; }
    internal PlacementMode PlacementInternal { get; }
    [BindableAttribute("False")]
[CategoryAttribute("Layout")]
public CustomPopupPlacementCallback CustomPopupPlacementCallback { get; public set; }
    [CategoryAttribute("Behavior")]
[BindableAttribute("True")]
public bool StaysOpen { get; public set; }
    [BindableAttribute("True")]
[CategoryAttribute("Layout")]
[TypeConverterAttribute("System.Windows.LengthConverter")]
public double HorizontalOffset { get; public set; }
    [TypeConverterAttribute("System.Windows.LengthConverter")]
[CategoryAttribute("Layout")]
[BindableAttribute("True")]
public double VerticalOffset { get; public set; }
    [DesignerSerializationVisibilityAttribute("0")]
[CategoryAttribute("Layout")]
[BindableAttribute("True")]
public UIElement PlacementTarget { get; public set; }
    [BindableAttribute("True")]
[CategoryAttribute("Layout")]
public Rect PlacementRectangle { get; public set; }
    internal bool DropOpposite { get; internal set; }
    [BindableAttribute("True")]
[CategoryAttribute("Appearance")]
public PopupAnimation PopupAnimation { get; public set; }
    public bool AllowsTransparency { get; public set; }
    public bool HasDropShadow { get; }
    protected internal IEnumerator LogicalChildren { get; }
    internal Exception SavedException { get; internal set; }
    private bool IsTransparent { get; private set; }
    private bool AnimateFromRight { get; private set; }
    private bool AnimateFromBottom { get; private set; }
    internal bool HitTestable { get; internal set; }
    private bool IsDragDropActive { get; private set; }
    internal int EffectiveValuesInitialSize { get; }
    private static Popup();
    private static object CoerceVisibility(DependencyObject d, object value);
    internal bool get_TreatMousePlacementAsBottom();
    internal void set_TreatMousePlacementAsBottom(bool value);
    public UIElement get_Child();
    public void set_Child(UIElement value);
    private static void OnChildChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    internal virtual void pushTextRenderingMode();
    private static void RegisterPopupWithPlacementTarget(Popup popup, UIElement placementTarget);
    private static void UnregisterPopupFromPlacementTarget(Popup popup, UIElement placementTarget);
    private void UpdatePlacementTargetRegistration(UIElement oldValue, UIElement newValue);
    public bool get_IsOpen();
    public void set_IsOpen(bool value);
    private static object CoerceIsOpen(DependencyObject d, object value);
    private void RegisterToOpenOnLoad();
    private void OpenOnLoad(object sender, RoutedEventArgs e);
    private static void OnIsOpenChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    protected virtual void OnOpened(EventArgs e);
    protected virtual void OnClosed(EventArgs e);
    private static void CloseOnUnloaded(object sender, RoutedEventArgs e);
    public PlacementMode get_Placement();
    public void set_Placement(PlacementMode value);
    internal PlacementMode get_PlacementInternal();
    private static void OnPlacementChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static bool IsValidPlacementMode(object o);
    public CustomPopupPlacementCallback get_CustomPopupPlacementCallback();
    public void set_CustomPopupPlacementCallback(CustomPopupPlacementCallback value);
    public bool get_StaysOpen();
    public void set_StaysOpen(bool value);
    private static void OnStaysOpenChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public double get_HorizontalOffset();
    public void set_HorizontalOffset(double value);
    private static void OnOffsetChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public double get_VerticalOffset();
    public void set_VerticalOffset(double value);
    public UIElement get_PlacementTarget();
    public void set_PlacementTarget(UIElement value);
    private static void OnPlacementTargetChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public Rect get_PlacementRectangle();
    public void set_PlacementRectangle(Rect value);
    internal bool get_DropOpposite();
    internal void set_DropOpposite(bool value);
    private void ClearDropOpposite();
    public PopupAnimation get_PopupAnimation();
    public void set_PopupAnimation(PopupAnimation value);
    private static object CoercePopupAnimation(DependencyObject o, object value);
    private static bool IsValidPopupAnimation(object o);
    public bool get_AllowsTransparency();
    public void set_AllowsTransparency(bool value);
    private static void OnAllowsTransparencyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static object CoerceAllowsTransparency(DependencyObject d, object value);
    public bool get_HasDropShadow();
    private static object CoerceHasDropShadow(DependencyObject d, object value);
    public static void CreateRootPopup(Popup popup, UIElement child);
    internal static void CreateRootPopupInternal(Popup popup, UIElement child, bool bindTreatMousePlacementAsBottomProperty);
    internal static bool IsRootedInPopup(Popup parentPopup, UIElement element);
    public void add_Opened(EventHandler value);
    public void remove_Opened(EventHandler value);
    public void add_Closed(EventHandler value);
    public void remove_Closed(EventHandler value);
    private void FirePopupCouldClose();
    [CompilerGeneratedAttribute]
internal void add_PopupCouldClose(EventHandler value);
    [CompilerGeneratedAttribute]
internal void remove_PopupCouldClose(EventHandler value);
    protected virtual Size MeasureOverride(Size availableSize);
    protected virtual void OnPreviewMouseLeftButtonDown(MouseButtonEventArgs e);
    protected virtual void OnPreviewMouseRightButtonDown(MouseButtonEventArgs e);
    protected virtual void OnPreviewMouseLeftButtonUp(MouseButtonEventArgs e);
    protected virtual void OnPreviewMouseRightButtonUp(MouseButtonEventArgs e);
    private void OnPreviewMouseButton(MouseButtonEventArgs e);
    private void EstablishPopupCapture(bool isRestoringCapture);
    private void ReleasePopupCapture();
    private static void OnLostMouseCapture(object sender, MouseEventArgs e);
    private static void OnDragDropStarted(object sender, RoutedEventArgs e);
    private static void OnDragDropCompleted(object sender, RoutedEventArgs e);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object value);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string text);
    internal virtual void OnThemeChanged();
    internal virtual bool BlockReverseInheritance();
    protected internal virtual DependencyObject GetUIParentCore();
    internal virtual bool IgnoreModelParentBuildRoute(RoutedEventArgs e);
    protected internal virtual IEnumerator get_LogicalChildren();
    private static Visual GetRootVisual(Visual child);
    private Visual GetTarget();
    private void SetHitTestable(bool hitTestable);
    private static object AsyncCreateWindow(object arg);
    private void CreateNewPopupRoot();
    private void CreateWindow(bool asyncCall);
    private void SetRootVisualToPopupRoot();
    private void BuildWindow(Visual targetVisual);
    private bool DestroyWindowImpl();
    private void DestroyWindow();
    private void ShowWindow();
    private void HideWindow();
    private bool SetupAnimations(bool visible);
    private void CancelAsyncCreate();
    private void CancelAsyncDestroy();
    internal void ForceClose();
    private IntPtr PopupFilterMessage(IntPtr hwnd, int msg, IntPtr wParam, IntPtr lParam, Boolean& handled);
    private object HandleDeactivateApp(object arg);
    private void UpdateTransform();
    private void OnWindowResize(object sender, AutoResizedEventArgs e);
    private void OnDpiChanged(object sender, HwndDpiChangedEventArgs e);
    internal Exception get_SavedException();
    internal void set_SavedException(Exception value);
    internal void Reposition();
    private static bool IsAbsolutePlacementMode(PlacementMode placement);
    private void UpdatePosition();
    private void GetPopupRootLimits(Rect& targetBounds, Rect& screenBounds, Size& limitSize);
    private Point[] GetPlacementTargetInterestPoints(PlacementMode placement);
    private static void SwapPoints(Point& p1, Point& p2);
    private Point[] GetChildInterestPoints(PlacementMode placement);
    private static Point[] InterestPointsFromRect(Rect rect);
    private static GeneralTransform TransformToClient(Visual visual, Visual rootVisual);
    private Rect GetBounds(Point[] interestPoints);
    private static int GetNumberOfCombinations(PlacementMode placement);
    private PointCombination GetPointCombination(PlacementMode placement, int i, PopupPrimaryAxis& axis);
    private static PopupPrimaryAxis GetPrimaryAxis(PlacementMode placement);
    internal Size RestrictSize(Size desiredSize);
    private Rect GetScreenBounds(Rect boundingBox, Point p);
    private Rect GetMouseRect(PlacementMode placement);
    private static void GetMouseCursorSize(Int32& width, Int32& height, Int32& hotX, Int32& hotY);
    private bool get_IsTransparent();
    private void set_IsTransparent(bool value);
    private bool get_AnimateFromRight();
    private void set_AnimateFromRight(bool value);
    private bool get_AnimateFromBottom();
    private void set_AnimateFromBottom(bool value);
    internal bool get_HitTestable();
    internal void set_HitTestable(bool value);
    private bool get_IsDragDropActive();
    private void set_IsDragDropActive(bool value);
    internal virtual int get_EffectiveValuesInitialSize();
    [CompilerGeneratedAttribute]
private object <OpenOnLoad>b__23_0(object param);
    [CompilerGeneratedAttribute]
private void <HideWindow>b__130_0(object sender, EventArgs args);
    [CompilerGeneratedAttribute]
private object <Reposition>b__144_0(object param);
}
public enum System.Windows.Controls.Primitives.PopupAnimation : Enum {
    public int value__;
    public static PopupAnimation None;
    public static PopupAnimation Fade;
    public static PopupAnimation Slide;
    public static PopupAnimation Scroll;
}
public enum System.Windows.Controls.Primitives.PopupPrimaryAxis : Enum {
    public int value__;
    public static PopupPrimaryAxis None;
    public static PopupPrimaryAxis Horizontal;
    public static PopupPrimaryAxis Vertical;
}
internal class System.Windows.Controls.Primitives.PopupRoot : FrameworkElement {
    private Decorator _transformDecorator;
    private AdornerDecorator _adornerDecorator;
    protected int VisualChildrenCount { get; }
    internal UIElement Child { get; internal set; }
    internal Vector AnimationOffset { get; }
    unknown Transform Transform {internal set; }
    private static PopupRoot();
    private void Initialize();
    protected virtual int get_VisualChildrenCount();
    protected virtual Visual GetVisualChild(int index);
    protected virtual AutomationPeer OnCreateAutomationPeer();
    internal UIElement get_Child();
    internal void set_Child(UIElement value);
    internal Vector get_AnimationOffset();
    internal void set_Transform(Transform value);
    protected virtual Size MeasureOverride(Size constraint);
    private Size GetPopupSizeRestrictions(Popup popup, Size desiredSize, Boolean& restrictWidth, Boolean& restrictHeight);
    private Size Get2DRestrictedDesiredSize(Size restrictedSize);
    protected virtual Size ArrangeOverride(Size arrangeSize);
    internal void SetupLayoutBindings(Popup popup);
    internal void SetupFadeAnimation(Duration duration, bool visible);
    internal void SetupTranslateAnimations(PopupAnimation animationType, Duration duration, bool animateFromRight, bool animateFromBottom);
    internal void StopAnimations();
    internal virtual bool IgnoreModelParentBuildRoute(RoutedEventArgs e);
}
[DefaultEventAttribute("ValueChanged")]
[DefaultPropertyAttribute("Value")]
public abstract class System.Windows.Controls.Primitives.RangeBase : Control {
    public static RoutedEvent ValueChangedEvent;
    public static DependencyProperty MinimumProperty;
    public static DependencyProperty MaximumProperty;
    public static DependencyProperty ValueProperty;
    public static DependencyProperty LargeChangeProperty;
    public static DependencyProperty SmallChangeProperty;
    [BindableAttribute("True")]
[CategoryAttribute("Behavior")]
public double Minimum { get; public set; }
    [BindableAttribute("True")]
[CategoryAttribute("Behavior")]
public double Maximum { get; public set; }
    [BindableAttribute("True")]
[CategoryAttribute("Behavior")]
public double Value { get; public set; }
    [CategoryAttribute("Behavior")]
[BindableAttribute("True")]
public double LargeChange { get; public set; }
    [BindableAttribute("True")]
[CategoryAttribute("Behavior")]
public double SmallChange { get; public set; }
    private static RangeBase();
    public void add_ValueChanged(RoutedPropertyChangedEventHandler`1<double> value);
    public void remove_ValueChanged(RoutedPropertyChangedEventHandler`1<double> value);
    public double get_Minimum();
    public void set_Minimum(double value);
    private static void OnMinimumChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    protected virtual void OnMinimumChanged(double oldMinimum, double newMinimum);
    private static object CoerceMaximum(DependencyObject d, object value);
    public double get_Maximum();
    public void set_Maximum(double value);
    private static void OnMaximumChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    protected virtual void OnMaximumChanged(double oldMaximum, double newMaximum);
    internal static object ConstrainToRange(DependencyObject d, object value);
    public double get_Value();
    public void set_Value(double value);
    private static void OnValueChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    protected virtual void OnValueChanged(double oldValue, double newValue);
    private static bool IsValidDoubleValue(object value);
    private static bool IsValidChange(object value);
    public double get_LargeChange();
    public void set_LargeChange(double value);
    public double get_SmallChange();
    public void set_SmallChange(double value);
    internal virtual void ChangeVisualState(bool useTransitions);
    public virtual string ToString();
}
internal enum System.Windows.Controls.Primitives.RelativeHeaderPosition : Enum {
    public int value__;
    public static RelativeHeaderPosition Top;
    public static RelativeHeaderPosition Bottom;
    public static RelativeHeaderPosition Left;
    public static RelativeHeaderPosition Right;
}
public class System.Windows.Controls.Primitives.RepeatButton : ButtonBase {
    public static DependencyProperty DelayProperty;
    public static DependencyProperty IntervalProperty;
    private DispatcherTimer _timer;
    private static DependencyObjectType _dType;
    [BindableAttribute("True")]
[CategoryAttribute("Behavior")]
public int Delay { get; public set; }
    [BindableAttribute("True")]
[CategoryAttribute("Behavior")]
public int Interval { get; public set; }
    internal int EffectiveValuesInitialSize { get; }
    internal DependencyObjectType DTypeThemeStyleKey { get; }
    private static RepeatButton();
    public int get_Delay();
    public void set_Delay(int value);
    public int get_Interval();
    public void set_Interval(int value);
    private static bool IsDelayValid(object value);
    private static bool IsIntervalValid(object value);
    private void StartTimer();
    private void StopTimer();
    private void OnTimeout(object sender, EventArgs e);
    internal static int GetKeyboardDelay();
    internal static int GetKeyboardSpeed();
    protected virtual AutomationPeer OnCreateAutomationPeer();
    protected virtual void OnClick();
    protected virtual void OnMouseLeftButtonDown(MouseButtonEventArgs e);
    protected virtual void OnMouseLeftButtonUp(MouseButtonEventArgs e);
    protected virtual void OnLostMouseCapture(MouseEventArgs e);
    protected virtual void OnMouseEnter(MouseEventArgs e);
    protected virtual void OnMouseLeave(MouseEventArgs e);
    private bool HandleIsMouseOverChanged();
    protected virtual void OnKeyDown(KeyEventArgs e);
    protected virtual void OnKeyUp(KeyEventArgs e);
    internal virtual int get_EffectiveValuesInitialSize();
    internal virtual DependencyObjectType get_DTypeThemeStyleKey();
}
public class System.Windows.Controls.Primitives.ResizeGrip : Control {
    private static DependencyObjectType _dType;
    internal DependencyObjectType DTypeThemeStyleKey { get; }
    internal int EffectiveValuesInitialSize { get; }
    private static ResizeGrip();
    private static void _OnWindowServiceChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private void OnWindowServiceChanged(Window oldWindow, Window newWindow);
    internal virtual DependencyObjectType get_DTypeThemeStyleKey();
    internal virtual int get_EffectiveValuesInitialSize();
}
[LocalizabilityAttribute("17")]
[TemplatePartAttribute]
public class System.Windows.Controls.Primitives.ScrollBar : RangeBase {
    public static RoutedEvent ScrollEvent;
    public static DependencyProperty OrientationProperty;
    public static DependencyProperty ViewportSizeProperty;
    public static RoutedCommand LineUpCommand;
    public static RoutedCommand LineDownCommand;
    public static RoutedCommand LineLeftCommand;
    public static RoutedCommand LineRightCommand;
    public static RoutedCommand PageUpCommand;
    public static RoutedCommand PageDownCommand;
    public static RoutedCommand PageLeftCommand;
    public static RoutedCommand PageRightCommand;
    public static RoutedCommand ScrollToEndCommand;
    public static RoutedCommand ScrollToHomeCommand;
    public static RoutedCommand ScrollToRightEndCommand;
    public static RoutedCommand ScrollToLeftEndCommand;
    public static RoutedCommand ScrollToTopCommand;
    public static RoutedCommand ScrollToBottomCommand;
    public static RoutedCommand ScrollToHorizontalOffsetCommand;
    public static RoutedCommand ScrollToVerticalOffsetCommand;
    public static RoutedCommand DeferScrollToHorizontalOffsetCommand;
    public static RoutedCommand DeferScrollToVerticalOffsetCommand;
    public static RoutedCommand ScrollHereCommand;
    private static double MaxPerpendicularDelta;
    private static string TrackName;
    private Track _track;
    private Point _latestRightButtonClickPoint;
    private bool _canScroll;
    private bool _hasScrolled;
    private bool _isStandalone;
    private bool _openingContextMenu;
    private double _previousValue;
    private Vector _thumbOffset;
    private static DependencyObjectType _dType;
    public Orientation Orientation { get; public set; }
    [DesignerSerializationVisibilityAttribute("0")]
public double ViewportSize { get; public set; }
    public Track Track { get; }
    protected bool IsEnabledCore { get; }
    private IInputElement CommandTarget { get; }
    internal bool IsStandalone { get; internal set; }
    internal DependencyObjectType DTypeThemeStyleKey { get; }
    private static ContextMenu VerticalContextMenu { get; }
    private static ContextMenu HorizontalContextMenuLTR { get; }
    private static ContextMenu HorizontalContextMenuRTL { get; }
    internal int EffectiveValuesInitialSize { get; }
    private static ScrollBar();
    public void add_Scroll(ScrollEventHandler value);
    public void remove_Scroll(ScrollEventHandler value);
    public Orientation get_Orientation();
    public void set_Orientation(Orientation value);
    public double get_ViewportSize();
    public void set_ViewportSize(double value);
    public Track get_Track();
    protected virtual AutomationPeer OnCreateAutomationPeer();
    protected virtual void OnPreviewMouseLeftButtonDown(MouseButtonEventArgs e);
    protected virtual void OnPreviewMouseRightButtonUp(MouseButtonEventArgs e);
    protected virtual bool get_IsEnabledCore();
    public virtual void OnApplyTemplate();
    private static void OnThumbDragStarted(object sender, DragStartedEventArgs e);
    private static void OnThumbDragDelta(object sender, DragDeltaEventArgs e);
    private void UpdateValue(double horizontalDragDelta, double verticalDragDelta);
    private static void OnThumbDragCompleted(object sender, DragCompletedEventArgs e);
    private void OnThumbDragCompleted(DragCompletedEventArgs e);
    private IInputElement get_CommandTarget();
    private void FinishDrag();
    private void ChangeValue(double newValue, bool defer);
    internal void ScrollToLastMousePoint();
    internal void RaiseScrollEvent(ScrollEventType scrollEventType);
    private static void OnScrollCommand(object target, ExecutedRoutedEventArgs args);
    private void SmallDecrement();
    private void SmallIncrement();
    private void LargeDecrement();
    private void LargeIncrement();
    private void ToMinimum();
    private void ToMaximum();
    private void LineUp();
    private void LineDown();
    private void PageUp();
    private void PageDown();
    private void ScrollToTop();
    private void ScrollToBottom();
    private void LineLeft();
    private void LineRight();
    private void PageLeft();
    private void PageRight();
    private void ScrollToLeftEnd();
    private void ScrollToRightEnd();
    private static void OnQueryScrollHereCommand(object target, CanExecuteRoutedEventArgs args);
    private static void OnQueryScrollCommand(object target, CanExecuteRoutedEventArgs args);
    private static void ViewChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    internal static bool IsValidOrientation(object o);
    internal bool get_IsStandalone();
    internal void set_IsStandalone(bool value);
    internal virtual DependencyObjectType get_DTypeThemeStyleKey();
    private static object CoerceContextMenu(DependencyObject o, object value);
    protected virtual void OnContextMenuOpening(ContextMenuEventArgs e);
    protected virtual void OnContextMenuClosing(ContextMenuEventArgs e);
    private static ContextMenu get_VerticalContextMenu();
    private static ContextMenu get_HorizontalContextMenuLTR();
    private static ContextMenu get_HorizontalContextMenuRTL();
    private static MenuItem CreateMenuItem(string name, string automationId, RoutedCommand command);
    internal virtual int get_EffectiveValuesInitialSize();
}
public class System.Windows.Controls.Primitives.ScrollEventArgs : RoutedEventArgs {
    private ScrollEventType _scrollEventType;
    private double _newValue;
    public ScrollEventType ScrollEventType { get; }
    public double NewValue { get; }
    public ScrollEventArgs(ScrollEventType scrollEventType, double newValue);
    public ScrollEventType get_ScrollEventType();
    public double get_NewValue();
    protected virtual void InvokeEventHandler(Delegate genericHandler, object genericTarget);
}
public class System.Windows.Controls.Primitives.ScrollEventHandler : MulticastDelegate {
    public ScrollEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, ScrollEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, ScrollEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public enum System.Windows.Controls.Primitives.ScrollEventType : Enum {
    public int value__;
    public static ScrollEventType EndScroll;
    public static ScrollEventType First;
    public static ScrollEventType LargeDecrement;
    public static ScrollEventType LargeIncrement;
    public static ScrollEventType Last;
    public static ScrollEventType SmallDecrement;
    public static ScrollEventType SmallIncrement;
    public static ScrollEventType ThumbPosition;
    public static ScrollEventType ThumbTrack;
}
public class System.Windows.Controls.Primitives.SelectiveScrollingGrid : Grid {
    public static DependencyProperty SelectiveScrollingOrientationProperty;
    private static SelectiveScrollingGrid();
    public static SelectiveScrollingOrientation GetSelectiveScrollingOrientation(DependencyObject obj);
    public static void SetSelectiveScrollingOrientation(DependencyObject obj, SelectiveScrollingOrientation value);
    private static void OnSelectiveScrollingOrientationChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
}
[DefaultEventAttribute("SelectionChanged")]
[DefaultPropertyAttribute("SelectedIndex")]
[LocalizabilityAttribute("0")]
public abstract class System.Windows.Controls.Primitives.Selector : ItemsControl {
    public static RoutedEvent SelectionChangedEvent;
    public static RoutedEvent SelectedEvent;
    public static RoutedEvent UnselectedEvent;
    internal static DependencyPropertyKey IsSelectionActivePropertyKey;
    public static DependencyProperty IsSelectionActiveProperty;
    public static DependencyProperty IsSelectedProperty;
    public static DependencyProperty IsSynchronizedWithCurrentItemProperty;
    public static DependencyProperty SelectedIndexProperty;
    public static DependencyProperty SelectedItemProperty;
    public static DependencyProperty SelectedValueProperty;
    public static DependencyProperty SelectedValuePathProperty;
    private static DependencyPropertyKey SelectedItemsPropertyKey;
    internal static DependencyProperty SelectedItemsImplProperty;
    private static BindingExpressionUncommonField ItemValueBindingExpression;
    internal InternalSelectedItemsStorage _selectedItems;
    private Point _lastMousePosition;
    private SelectionChanger _selectionChangeInstance;
    private BitVector32 _cacheValid;
    private EventHandler _focusEnterMainFocusScopeEventHandler;
    private DependencyObject _clearingContainer;
    private static UncommonField`1<ItemInfo> PendingSelectionByValueField;
    private static ItemInfoEqualityComparer MatchExplicitEqualityComparer;
    private static ItemInfoEqualityComparer MatchUnresolvedEqualityComparer;
    private static UncommonField`1<ChangeInfo> ChangeInfoField;
    [LocalizabilityAttribute("17")]
[CategoryAttribute("Behavior")]
[TypeConverterAttribute("System.Windows.NullableBoolConverter, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")]
[BindableAttribute("True")]
public Nullable`1<bool> IsSynchronizedWithCurrentItem { get; public set; }
    [DesignerSerializationVisibilityAttribute("0")]
[CategoryAttribute("Appearance")]
[BindableAttribute("True")]
[LocalizabilityAttribute("17")]
public int SelectedIndex { get; public set; }
    [BindableAttribute("True")]
[CategoryAttribute("Appearance")]
[DesignerSerializationVisibilityAttribute("0")]
public object SelectedItem { get; public set; }
    [LocalizabilityAttribute("17")]
[CategoryAttribute("Appearance")]
[DesignerSerializationVisibilityAttribute("0")]
[BindableAttribute("True")]
public object SelectedValue { get; public set; }
    [BindableAttribute("True")]
[CategoryAttribute("Appearance")]
[LocalizabilityAttribute("17")]
public string SelectedValuePath { get; public set; }
    internal IList SelectedItemsImpl { get; }
    internal bool CanSelectMultiple { get; internal set; }
    private bool IsSynchronizedWithCurrentItemPrivate { get; private set; }
    private bool SkipCoerceSelectedItemCheck { get; private set; }
    internal SelectionChanger SelectionChange { get; }
    internal object InternalSelectedItem { get; }
    internal ItemInfo InternalSelectedInfo { get; }
    internal int InternalSelectedIndex { get; }
    private object InternalSelectedValue { get; }
    private static Selector();
    public void add_SelectionChanged(SelectionChangedEventHandler value);
    public void remove_SelectionChanged(SelectionChangedEventHandler value);
    public static void AddSelectedHandler(DependencyObject element, RoutedEventHandler handler);
    public static void RemoveSelectedHandler(DependencyObject element, RoutedEventHandler handler);
    public static void AddUnselectedHandler(DependencyObject element, RoutedEventHandler handler);
    public static void RemoveUnselectedHandler(DependencyObject element, RoutedEventHandler handler);
    public static bool GetIsSelectionActive(DependencyObject element);
    [AttachedPropertyBrowsableForChildrenAttribute]
public static bool GetIsSelected(DependencyObject element);
    public static void SetIsSelected(DependencyObject element, bool isSelected);
    public Nullable`1<bool> get_IsSynchronizedWithCurrentItem();
    public void set_IsSynchronizedWithCurrentItem(Nullable`1<bool> value);
    private static void OnIsSynchronizedWithCurrentItemChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private void SetSynchronizationWithCurrentItem();
    public int get_SelectedIndex();
    public void set_SelectedIndex(int value);
    private static void OnSelectedIndexChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static bool ValidateSelectedIndex(object o);
    private static object CoerceSelectedIndex(DependencyObject d, object value);
    public object get_SelectedItem();
    public void set_SelectedItem(object value);
    private static void OnSelectedItemChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static object CoerceSelectedItem(DependencyObject d, object value);
    public object get_SelectedValue();
    public void set_SelectedValue(object value);
    private static void OnSelectedValueChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private object SelectItemWithValue(object value, bool selectNow);
    private object FindItemWithValue(object value, Int32& index);
    private bool VerifyEqual(object knownValue, Type knownType, object itemValue, DynamicValueConverter converter);
    private static object CoerceSelectedValue(DependencyObject d, object value);
    public string get_SelectedValuePath();
    public void set_SelectedValuePath(string value);
    private static void OnSelectedValuePathChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private BindingExpression PrepareItemValueBinding(object item);
    internal IList get_SelectedItemsImpl();
    internal bool SetSelectedItemsImpl(IEnumerable selectedItems);
    private void OnSelectedItemsCollectionChanged(object sender, NotifyCollectionChangedEventArgs e);
    internal bool get_CanSelectMultiple();
    internal void set_CanSelectMultiple(bool value);
    protected virtual void ClearContainerForItemOverride(DependencyObject element, object item);
    internal void RaiseIsSelectedChangedAutomationEvent(DependencyObject container, bool isSelected);
    internal void SetInitialMousePosition();
    internal bool DidMouseMove();
    internal void ResetLastMousePosition();
    internal virtual void SelectAllImpl();
    internal virtual void UnselectAllImpl();
    protected virtual void OnItemsChanged(NotifyCollectionChangedEventArgs e);
    internal virtual void AdjustItemInfoOverride(NotifyCollectionChangedEventArgs e);
    private void RemoveFromSelection(NotifyCollectionChangedEventArgs e);
    protected virtual void OnSelectionChanged(SelectionChangedEventArgs e);
    protected virtual void OnIsKeyboardFocusWithinChanged(DependencyPropertyChangedEventArgs e);
    private void OnFocusEnterMainFocusScope(object sender, EventArgs e);
    protected virtual void OnItemsSourceChanged(IEnumerable oldValue, IEnumerable newValue);
    protected virtual void PrepareContainerForItemOverride(DependencyObject element, object item);
    protected virtual void OnInitialized(EventArgs e);
    private bool get_IsSynchronizedWithCurrentItemPrivate();
    private void set_IsSynchronizedWithCurrentItemPrivate(bool value);
    private bool get_SkipCoerceSelectedItemCheck();
    private void set_SkipCoerceSelectedItemCheck(bool value);
    private void SetSelectedHelper(object item, FrameworkElement UI, bool selected);
    private void OnCurrentChanged(object sender, EventArgs e);
    private void OnNewContainer();
    private void OnLayoutUpdated(object sender, EventArgs e);
    private void OnGeneratorStatusChanged(object sender, EventArgs e);
    private void AdjustNewContainers();
    internal virtual void AdjustItemInfosAfterGeneratorChangeOverride();
    private void SetSelectedToCurrent();
    private void SetCurrentToSelected();
    private void UpdateSelectedItems();
    internal void FinishSelectedItemsChange();
    private void UpdateSelectedItems(InternalSelectedItemsStorage toAdd, InternalSelectedItemsStorage toRemove);
    internal void UpdatePublicSelectionProperties();
    private void InvokeSelectionChanged(List`1<ItemInfo> unselectedInfos, List`1<ItemInfo> selectedInfos);
    private bool InfoGetIsSelected(ItemInfo info);
    private void ItemSetIsSelected(ItemInfo info, bool value);
    internal static bool ItemGetIsSelectable(object item);
    internal static bool UiGetIsSelectable(DependencyObject o);
    private static void OnSelected(object sender, RoutedEventArgs e);
    private static void OnUnselected(object sender, RoutedEventArgs e);
    internal void NotifyIsSelectedChanged(FrameworkElement container, bool selected, RoutedEventArgs e);
    internal SelectionChanger get_SelectionChange();
    private void ResetSelectedItemsAlgorithm();
    internal void LocateSelectedItems(List`1<Tuple`2<int, int>> ranges, bool deselectMissingItems);
    internal object get_InternalSelectedItem();
    internal ItemInfo get_InternalSelectedInfo();
    internal int get_InternalSelectedIndex();
    private object get_InternalSelectedValue();
}
[StyleTypedPropertyAttribute]
public class System.Windows.Controls.Primitives.StatusBar : ItemsControl {
    public static DependencyProperty ItemContainerTemplateSelectorProperty;
    public static DependencyProperty UsesItemContainerTemplateProperty;
    private object _currentItem;
    private static DependencyObjectType _dType;
    public ItemContainerTemplateSelector ItemContainerTemplateSelector { get; public set; }
    public bool UsesItemContainerTemplate { get; public set; }
    internal DependencyObjectType DTypeThemeStyleKey { get; }
    public static ResourceKey SeparatorStyleKey { get; }
    private static StatusBar();
    public ItemContainerTemplateSelector get_ItemContainerTemplateSelector();
    public void set_ItemContainerTemplateSelector(ItemContainerTemplateSelector value);
    public bool get_UsesItemContainerTemplate();
    public void set_UsesItemContainerTemplate(bool value);
    protected virtual bool IsItemItsOwnContainerOverride(object item);
    protected virtual DependencyObject GetContainerForItemOverride();
    protected virtual void PrepareContainerForItemOverride(DependencyObject element, object item);
    protected virtual bool ShouldApplyItemContainerStyle(DependencyObject container, object item);
    protected virtual AutomationPeer OnCreateAutomationPeer();
    internal virtual DependencyObjectType get_DTypeThemeStyleKey();
    public static ResourceKey get_SeparatorStyleKey();
}
[LocalizabilityAttribute("15")]
public class System.Windows.Controls.Primitives.StatusBarItem : ContentControl {
    private static DependencyObjectType _dType;
    internal DependencyObjectType DTypeThemeStyleKey { get; }
    private static StatusBarItem();
    protected virtual AutomationPeer OnCreateAutomationPeer();
    internal virtual DependencyObjectType get_DTypeThemeStyleKey();
}
public class System.Windows.Controls.Primitives.TabPanel : Panel {
    private int _numRows;
    private int _numHeaders;
    private double _rowHeight;
    private Dock TabStripPlacement { get; }
    private static TabPanel();
    protected virtual Size MeasureOverride(Size constraint);
    protected virtual Size ArrangeOverride(Size arrangeSize);
    protected virtual Geometry GetLayoutClip(Size layoutSlotSize);
    private Size GetDesiredSizeWithoutMargin(UIElement element);
    private Double[] GetHeadersSize();
    private void ArrangeHorizontal(Size arrangeSize);
    private void ArrangeVertical(Size arrangeSize);
    private int GetActiveRow(Int32[] solution);
    private Int32[] CalculateHeaderDistribution(double rowWidthLimit, Double[] headerWidth);
    private Dock get_TabStripPlacement();
}
[LocalizabilityAttribute("1")]
[TemplatePartAttribute]
public abstract class System.Windows.Controls.Primitives.TextBoxBase : Control {
    public static DependencyProperty IsReadOnlyProperty;
    public static DependencyProperty IsReadOnlyCaretVisibleProperty;
    public static DependencyProperty AcceptsReturnProperty;
    public static DependencyProperty AcceptsTabProperty;
    public static DependencyProperty HorizontalScrollBarVisibilityProperty;
    public static DependencyProperty VerticalScrollBarVisibilityProperty;
    public static DependencyProperty IsUndoEnabledProperty;
    public static DependencyProperty UndoLimitProperty;
    public static DependencyProperty AutoWordSelectionProperty;
    public static DependencyProperty SelectionBrushProperty;
    public static DependencyProperty SelectionTextBrushProperty;
    internal static double AdornerSelectionOpacityDefaultValue;
    internal static double NonAdornerSelectionOpacityDefaultValue;
    private static double SelectionOpacityDefaultValue;
    public static DependencyProperty SelectionOpacityProperty;
    public static DependencyProperty CaretBrushProperty;
    internal static DependencyPropertyKey IsSelectionActivePropertyKey;
    public static DependencyProperty IsSelectionActiveProperty;
    public static DependencyProperty IsInactiveSelectionHighlightEnabledProperty;
    public static RoutedEvent TextChangedEvent;
    public static RoutedEvent SelectionChangedEvent;
    private static DependencyObjectType _dType;
    private TextContainer _textContainer;
    private TextEditor _textEditor;
    private FrameworkElement _textBoxContentHost;
    private FrameworkElement _renderScope;
    private ScrollViewer _scrollViewer;
    private UndoAction _pendingUndoAction;
    internal static string ContentHostTemplateName;
    public bool IsReadOnly { get; public set; }
    public bool IsReadOnlyCaretVisible { get; public set; }
    public bool AcceptsReturn { get; public set; }
    public bool AcceptsTab { get; public set; }
    public SpellCheck SpellCheck { get; }
    public ScrollBarVisibility HorizontalScrollBarVisibility { get; public set; }
    public ScrollBarVisibility VerticalScrollBarVisibility { get; public set; }
    public double ExtentWidth { get; }
    public double ExtentHeight { get; }
    public double ViewportWidth { get; }
    public double ViewportHeight { get; }
    public double HorizontalOffset { get; }
    public double VerticalOffset { get; }
    public bool CanUndo { get; }
    public bool CanRedo { get; }
    public bool IsUndoEnabled { get; public set; }
    public int UndoLimit { get; public set; }
    public bool AutoWordSelection { get; public set; }
    public Brush SelectionBrush { get; public set; }
    public Brush SelectionTextBrush { get; public set; }
    public double SelectionOpacity { get; public set; }
    public Brush CaretBrush { get; public set; }
    public bool IsSelectionActive { get; }
    public bool IsInactiveSelectionHighlightEnabled { get; public set; }
    internal ScrollViewer ScrollViewer { get; }
    internal TextSelection TextSelectionInternal { get; }
    internal TextContainer TextContainer { get; }
    internal FrameworkElement RenderScope { get; }
    internal UndoAction PendingUndoAction { get; internal set; }
    internal TextEditor TextEditor { get; }
    internal bool IsContentHostAvailable { get; }
    internal DependencyObjectType DTypeThemeStyleKey { get; }
    private static TextBoxBase();
    public void AppendText(string textData);
    public virtual void OnApplyTemplate();
    public void Copy();
    public void Cut();
    public void Paste();
    public void SelectAll();
    public void LineLeft();
    public void LineRight();
    public void PageLeft();
    public void PageRight();
    public void LineUp();
    public void LineDown();
    public void PageUp();
    public void PageDown();
    public void ScrollToHome();
    public void ScrollToEnd();
    public void ScrollToHorizontalOffset(double offset);
    public void ScrollToVerticalOffset(double offset);
    public bool Undo();
    public bool Redo();
    public void LockCurrentUndoUnit();
    public void BeginChange();
    public void EndChange();
    public IDisposable DeclareChangeBlock();
    public bool get_IsReadOnly();
    public void set_IsReadOnly(bool value);
    public bool get_IsReadOnlyCaretVisible();
    public void set_IsReadOnlyCaretVisible(bool value);
    public bool get_AcceptsReturn();
    public void set_AcceptsReturn(bool value);
    public bool get_AcceptsTab();
    public void set_AcceptsTab(bool value);
    public SpellCheck get_SpellCheck();
    public ScrollBarVisibility get_HorizontalScrollBarVisibility();
    public void set_HorizontalScrollBarVisibility(ScrollBarVisibility value);
    public ScrollBarVisibility get_VerticalScrollBarVisibility();
    public void set_VerticalScrollBarVisibility(ScrollBarVisibility value);
    public double get_ExtentWidth();
    public double get_ExtentHeight();
    public double get_ViewportWidth();
    public double get_ViewportHeight();
    public double get_HorizontalOffset();
    public double get_VerticalOffset();
    public bool get_CanUndo();
    public bool get_CanRedo();
    public bool get_IsUndoEnabled();
    public void set_IsUndoEnabled(bool value);
    public int get_UndoLimit();
    public void set_UndoLimit(int value);
    public bool get_AutoWordSelection();
    public void set_AutoWordSelection(bool value);
    public Brush get_SelectionBrush();
    public void set_SelectionBrush(Brush value);
    public Brush get_SelectionTextBrush();
    public void set_SelectionTextBrush(Brush value);
    public double get_SelectionOpacity();
    public void set_SelectionOpacity(double value);
    public Brush get_CaretBrush();
    public void set_CaretBrush(Brush value);
    public bool get_IsSelectionActive();
    public bool get_IsInactiveSelectionHighlightEnabled();
    public void set_IsInactiveSelectionHighlightEnabled(bool value);
    public void add_TextChanged(TextChangedEventHandler value);
    public void remove_TextChanged(TextChangedEventHandler value);
    public void add_SelectionChanged(RoutedEventHandler value);
    public void remove_SelectionChanged(RoutedEventHandler value);
    internal virtual void ChangeVisualState(bool useTransitions);
    protected virtual void OnTextChanged(TextChangedEventArgs e);
    protected virtual void OnSelectionChanged(RoutedEventArgs e);
    protected virtual void OnTemplateChanged(ControlTemplate oldTemplate, ControlTemplate newTemplate);
    protected virtual void OnMouseWheel(MouseWheelEventArgs e);
    protected virtual void OnPreviewKeyDown(KeyEventArgs e);
    protected virtual void OnKeyDown(KeyEventArgs e);
    protected virtual void OnKeyUp(KeyEventArgs e);
    protected virtual void OnTextInput(TextCompositionEventArgs e);
    protected virtual void OnMouseDown(MouseButtonEventArgs e);
    protected virtual void OnMouseMove(MouseEventArgs e);
    protected virtual void OnMouseUp(MouseButtonEventArgs e);
    protected virtual void OnQueryCursor(QueryCursorEventArgs e);
    protected virtual void OnQueryContinueDrag(QueryContinueDragEventArgs e);
    protected virtual void OnGiveFeedback(GiveFeedbackEventArgs e);
    protected virtual void OnDragEnter(DragEventArgs e);
    protected virtual void OnDragOver(DragEventArgs e);
    protected virtual void OnDragLeave(DragEventArgs e);
    protected virtual void OnDrop(DragEventArgs e);
    protected virtual void OnContextMenuOpening(ContextMenuEventArgs e);
    protected virtual void OnGotKeyboardFocus(KeyboardFocusChangedEventArgs e);
    protected virtual void OnLostKeyboardFocus(KeyboardFocusChangedEventArgs e);
    protected virtual void OnLostFocus(RoutedEventArgs e);
    internal abstract virtual FrameworkElement CreateRenderScope();
    internal virtual void OnTextContainerChanged(object sender, TextContainerChangedEventArgs e);
    internal void InitializeTextContainer(TextContainer textContainer);
    internal TextPointer GetTextPositionFromPointInternal(Point point, bool snapToText);
    internal bool GetRectangleFromTextPosition(TextPointer position, Rect& rect);
    internal virtual void AttachToVisualTree();
    internal virtual void DoLineUp();
    internal virtual void DoLineDown();
    internal virtual void AddToEventRouteCore(EventRoute route, RoutedEventArgs args);
    internal void ChangeUndoEnabled(bool value);
    internal void ChangeUndoLimit(object value);
    internal ScrollViewer get_ScrollViewer();
    internal TextSelection get_TextSelectionInternal();
    internal TextContainer get_TextContainer();
    internal FrameworkElement get_RenderScope();
    internal UndoAction get_PendingUndoAction();
    internal void set_PendingUndoAction(UndoAction value);
    internal TextEditor get_TextEditor();
    internal bool get_IsContentHostAvailable();
    private void DetachFromVisualTree();
    private void InitializeRenderScope();
    private void UninitializeRenderScope();
    private static Brush GetDefaultSelectionBrush();
    private static Brush GetDefaultSelectionTextBrush();
    private static object OnPageHeightGetValue(DependencyObject d);
    private void SetRenderScopeToContentHost();
    private void ClearContentHost();
    private static void OnIsReadOnlyCaretVisiblePropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    internal virtual void OnScrollChanged(object sender, ScrollChangedEventArgs e);
    private void OnSelectionChangedInternal(object sender, EventArgs e);
    internal virtual DependencyObjectType get_DTypeThemeStyleKey();
    internal static void OnScrollViewerPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void OnIsUndoEnabledChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static bool UndoLimitValidateValue(object value);
    private static void OnUndoLimitChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void OnInputMethodEnabledPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void UpdateCaretElement(DependencyObject d, DependencyPropertyChangedEventArgs e);
}
[DefaultEventAttribute("DragDelta")]
[LocalizabilityAttribute("17")]
public class System.Windows.Controls.Primitives.Thumb : Control {
    public static RoutedEvent DragStartedEvent;
    public static RoutedEvent DragDeltaEvent;
    public static RoutedEvent DragCompletedEvent;
    private static DependencyPropertyKey IsDraggingPropertyKey;
    public static DependencyProperty IsDraggingProperty;
    private Point _originThumbPoint;
    private Point _originScreenCoordPosition;
    private Point _previousScreenCoordPosition;
    private static DependencyObjectType _dType;
    [BindableAttribute("True")]
[BrowsableAttribute("False")]
[CategoryAttribute("Appearance")]
public bool IsDragging { get; protected set; }
    internal int EffectiveValuesInitialSize { get; }
    internal DependencyObjectType DTypeThemeStyleKey { get; }
    private static Thumb();
    public void add_DragStarted(DragStartedEventHandler value);
    public void remove_DragStarted(DragStartedEventHandler value);
    public void add_DragDelta(DragDeltaEventHandler value);
    public void remove_DragDelta(DragDeltaEventHandler value);
    public void add_DragCompleted(DragCompletedEventHandler value);
    public void remove_DragCompleted(DragCompletedEventHandler value);
    public bool get_IsDragging();
    protected void set_IsDragging(bool value);
    private static void OnIsDraggingPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public void CancelDrag();
    protected virtual void OnDraggingChanged(DependencyPropertyChangedEventArgs e);
    internal virtual void ChangeVisualState(bool useTransitions);
    protected virtual AutomationPeer OnCreateAutomationPeer();
    protected virtual void OnMouseLeftButtonDown(MouseButtonEventArgs e);
    protected virtual void OnMouseLeftButtonUp(MouseButtonEventArgs e);
    private static void OnLostMouseCapture(object sender, MouseEventArgs e);
    protected virtual void OnMouseMove(MouseEventArgs e);
    internal virtual int get_EffectiveValuesInitialSize();
    internal virtual DependencyObjectType get_DTypeThemeStyleKey();
}
[LocalizabilityAttribute("0")]
public class System.Windows.Controls.Primitives.TickBar : FrameworkElement {
    public static DependencyProperty FillProperty;
    public static DependencyProperty MinimumProperty;
    public static DependencyProperty MaximumProperty;
    public static DependencyProperty SelectionStartProperty;
    public static DependencyProperty SelectionEndProperty;
    public static DependencyProperty IsSelectionRangeEnabledProperty;
    public static DependencyProperty TickFrequencyProperty;
    public static DependencyProperty TicksProperty;
    public static DependencyProperty IsDirectionReversedProperty;
    public static DependencyProperty PlacementProperty;
    public static DependencyProperty ReservedSpaceProperty;
    public Brush Fill { get; public set; }
    [CategoryAttribute("Appearance")]
[BindableAttribute("True")]
public double Minimum { get; public set; }
    [CategoryAttribute("Appearance")]
[BindableAttribute("True")]
public double Maximum { get; public set; }
    [BindableAttribute("True")]
[CategoryAttribute("Appearance")]
public double SelectionStart { get; public set; }
    [BindableAttribute("True")]
[CategoryAttribute("Appearance")]
public double SelectionEnd { get; public set; }
    [CategoryAttribute("Appearance")]
[BindableAttribute("True")]
public bool IsSelectionRangeEnabled { get; public set; }
    [BindableAttribute("True")]
[CategoryAttribute("Appearance")]
public double TickFrequency { get; public set; }
    [CategoryAttribute("Appearance")]
[BindableAttribute("True")]
public DoubleCollection Ticks { get; public set; }
    [BindableAttribute("True")]
[CategoryAttribute("Appearance")]
public bool IsDirectionReversed { get; public set; }
    [BindableAttribute("True")]
[CategoryAttribute("Appearance")]
public TickBarPlacement Placement { get; public set; }
    [BindableAttribute("True")]
[CategoryAttribute("Appearance")]
public double ReservedSpace { get; public set; }
    private static TickBar();
    public Brush get_Fill();
    public void set_Fill(Brush value);
    public double get_Minimum();
    public void set_Minimum(double value);
    public double get_Maximum();
    public void set_Maximum(double value);
    public double get_SelectionStart();
    public void set_SelectionStart(double value);
    public double get_SelectionEnd();
    public void set_SelectionEnd(double value);
    public bool get_IsSelectionRangeEnabled();
    public void set_IsSelectionRangeEnabled(bool value);
    public double get_TickFrequency();
    public void set_TickFrequency(double value);
    public DoubleCollection get_Ticks();
    public void set_Ticks(DoubleCollection value);
    public bool get_IsDirectionReversed();
    public void set_IsDirectionReversed(bool value);
    public TickBarPlacement get_Placement();
    public void set_Placement(TickBarPlacement value);
    private static bool IsValidTickBarPlacement(object o);
    public double get_ReservedSpace();
    public void set_ReservedSpace(double value);
    protected virtual void OnRender(DrawingContext dc);
    private void BindToTemplatedParent(DependencyProperty target, DependencyProperty source);
    internal virtual void OnPreApplyTemplate();
}
public enum System.Windows.Controls.Primitives.TickBarPlacement : Enum {
    public int value__;
    public static TickBarPlacement Left;
    public static TickBarPlacement Top;
    public static TickBarPlacement Right;
    public static TickBarPlacement Bottom;
}
public enum System.Windows.Controls.Primitives.TickPlacement : Enum {
    public int value__;
    public static TickPlacement None;
    public static TickPlacement TopLeft;
    public static TickPlacement BottomRight;
    public static TickPlacement Both;
}
[DefaultEventAttribute("Checked")]
public class System.Windows.Controls.Primitives.ToggleButton : ButtonBase {
    public static RoutedEvent CheckedEvent;
    public static RoutedEvent UncheckedEvent;
    public static RoutedEvent IndeterminateEvent;
    public static DependencyProperty IsCheckedProperty;
    public static DependencyProperty IsThreeStateProperty;
    private static DependencyObjectType _dType;
    [TypeConverterAttribute("System.Windows.NullableBoolConverter")]
[CategoryAttribute("Appearance")]
[LocalizabilityAttribute("0")]
public Nullable`1<bool> IsChecked { get; public set; }
    [CategoryAttribute("Behavior")]
[BindableAttribute("True")]
public bool IsThreeState { get; public set; }
    internal DependencyObjectType DTypeThemeStyleKey { get; }
    private static ToggleButton();
    public void add_Checked(RoutedEventHandler value);
    public void remove_Checked(RoutedEventHandler value);
    public void add_Unchecked(RoutedEventHandler value);
    public void remove_Unchecked(RoutedEventHandler value);
    public void add_Indeterminate(RoutedEventHandler value);
    public void remove_Indeterminate(RoutedEventHandler value);
    public Nullable`1<bool> get_IsChecked();
    public void set_IsChecked(Nullable`1<bool> value);
    private static object OnGetIsChecked(DependencyObject d);
    private static void OnIsCheckedChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    protected virtual void OnChecked(RoutedEventArgs e);
    protected virtual void OnUnchecked(RoutedEventArgs e);
    protected virtual void OnIndeterminate(RoutedEventArgs e);
    public bool get_IsThreeState();
    public void set_IsThreeState(bool value);
    protected virtual AutomationPeer OnCreateAutomationPeer();
    protected virtual void OnClick();
    internal virtual void ChangeVisualState(bool useTransitions);
    public virtual string ToString();
    protected internal virtual void OnToggle();
    internal virtual DependencyObjectType get_DTypeThemeStyleKey();
}
public class System.Windows.Controls.Primitives.ToolBarOverflowPanel : Panel {
    public static DependencyProperty WrapWidthProperty;
    private double _wrapWidth;
    private Size _panelSize;
    public double WrapWidth { get; public set; }
    private ToolBar ToolBar { get; }
    private ToolBarPanel ToolBarPanel { get; }
    private static ToolBarOverflowPanel();
    public double get_WrapWidth();
    public void set_WrapWidth(double value);
    private static bool IsWrapWidthValid(object value);
    protected virtual Size MeasureOverride(Size constraint);
    protected virtual Size ArrangeOverride(Size arrangeBounds);
    protected virtual UIElementCollection CreateUIElementCollection(FrameworkElement logicalParent);
    private void arrangeLine(double y, double lineHeight, int start, int end);
    private ToolBar get_ToolBar();
    private ToolBarPanel get_ToolBarPanel();
}
public class System.Windows.Controls.Primitives.ToolBarPanel : StackPanel {
    [CompilerGeneratedAttribute]
private double <MinLength>k__BackingField;
    [CompilerGeneratedAttribute]
private double <MaxLength>k__BackingField;
    private List`1<UIElement> _generatedItemsCollection;
    internal double MinLength { get; private set; }
    internal double MaxLength { get; private set; }
    private ToolBar ToolBar { get; }
    private ToolBarOverflowPanel ToolBarOverflowPanel { get; }
    internal List`1<UIElement> GeneratedItemsCollection { get; }
    private static ToolBarPanel();
    [CompilerGeneratedAttribute]
internal double get_MinLength();
    [CompilerGeneratedAttribute]
private void set_MinLength(double value);
    [CompilerGeneratedAttribute]
internal double get_MaxLength();
    [CompilerGeneratedAttribute]
private void set_MaxLength(double value);
    private bool MeasureGeneratedItems(bool asNeededPass, Size constraint, bool horizontal, double maxExtent, Size& panelDesiredSize, Double& overflowExtent);
    protected virtual Size MeasureOverride(Size constraint);
    protected virtual Size ArrangeOverride(Size arrangeSize);
    internal virtual void OnPreApplyTemplate();
    internal virtual void GenerateChildren();
    internal virtual bool OnItemsChangedInternal(object sender, ItemsChangedEventArgs args);
    private void AddChildren(GeneratorPosition pos, int itemCount);
    private void RemoveChild(UIElement child);
    private void RemoveChildren(GeneratorPosition pos, int containerCount);
    private void ReplaceChildren(GeneratorPosition pos, int itemCount, int containerCount);
    private void MoveChildren(GeneratorPosition fromPos, GeneratorPosition toPos, int containerCount);
    private ToolBar get_ToolBar();
    private ToolBarOverflowPanel get_ToolBarOverflowPanel();
    internal List`1<UIElement> get_GeneratedItemsCollection();
}
[LocalizabilityAttribute("0")]
public class System.Windows.Controls.Primitives.Track : FrameworkElement {
    [CommonDependencyPropertyAttribute]
public static DependencyProperty OrientationProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty MinimumProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty MaximumProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty ValueProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty ViewportSizeProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty IsDirectionReversedProperty;
    private RepeatButton _increaseButton;
    private RepeatButton _decreaseButton;
    private Thumb _thumb;
    private Visual[] _visualChildren;
    private double _density;
    private double _thumbCenterOffset;
    public RepeatButton DecreaseRepeatButton { get; public set; }
    public Thumb Thumb { get; public set; }
    public RepeatButton IncreaseRepeatButton { get; public set; }
    public Orientation Orientation { get; public set; }
    public double Minimum { get; public set; }
    public double Maximum { get; public set; }
    public double Value { get; public set; }
    public double ViewportSize { get; public set; }
    public bool IsDirectionReversed { get; public set; }
    protected int VisualChildrenCount { get; }
    private double ThumbCenterOffset { get; private set; }
    private double Density { get; private set; }
    internal int EffectiveValuesInitialSize { get; }
    private static Track();
    public virtual double ValueFromPoint(Point pt);
    public virtual double ValueFromDistance(double horizontal, double vertical);
    private void UpdateComponent(Control oldValue, Control newValue);
    public RepeatButton get_DecreaseRepeatButton();
    public void set_DecreaseRepeatButton(RepeatButton value);
    public Thumb get_Thumb();
    public void set_Thumb(Thumb value);
    public RepeatButton get_IncreaseRepeatButton();
    public void set_IncreaseRepeatButton(RepeatButton value);
    public Orientation get_Orientation();
    public void set_Orientation(Orientation value);
    public double get_Minimum();
    public void set_Minimum(double value);
    public double get_Maximum();
    public void set_Maximum(double value);
    public double get_Value();
    public void set_Value(double value);
    public double get_ViewportSize();
    public void set_ViewportSize(double value);
    private static bool IsValidViewport(object o);
    public bool get_IsDirectionReversed();
    public void set_IsDirectionReversed(bool value);
    protected virtual Visual GetVisualChild(int index);
    protected virtual int get_VisualChildrenCount();
    protected virtual Size MeasureOverride(Size availableSize);
    private static void CoerceLength(Double& componentLength, double trackLength);
    protected virtual Size ArrangeOverride(Size arrangeSize);
    private void ComputeSliderLengths(Size arrangeSize, bool isVertical, Double& decreaseButtonLength, Double& thumbLength, Double& increaseButtonLength);
    private bool ComputeScrollBarLengths(Size arrangeSize, double viewportSize, bool isVertical, Double& decreaseButtonLength, Double& thumbLength, Double& increaseButtonLength);
    private void BindToTemplatedParent(DependencyProperty target, DependencyProperty source);
    private void BindChildToTemplatedParent(FrameworkElement element, DependencyProperty target, DependencyProperty source);
    internal virtual void OnPreApplyTemplate();
    private static void OnIsEnabledChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private double get_ThumbCenterOffset();
    private void set_ThumbCenterOffset(double value);
    private double get_Density();
    private void set_Density(double value);
    internal virtual int get_EffectiveValuesInitialSize();
}
public class System.Windows.Controls.Primitives.UniformGrid : Panel {
    public static DependencyProperty FirstColumnProperty;
    public static DependencyProperty ColumnsProperty;
    public static DependencyProperty RowsProperty;
    private int _rows;
    private int _columns;
    public int FirstColumn { get; public set; }
    public int Columns { get; public set; }
    public int Rows { get; public set; }
    private static UniformGrid();
    public int get_FirstColumn();
    public void set_FirstColumn(int value);
    private static bool ValidateFirstColumn(object o);
    public int get_Columns();
    public void set_Columns(int value);
    private static bool ValidateColumns(object o);
    public int get_Rows();
    public void set_Rows(int value);
    private static bool ValidateRows(object o);
    protected virtual Size MeasureOverride(Size constraint);
    protected virtual Size ArrangeOverride(Size arrangeSize);
    private void UpdateComputedValues();
}
public class System.Windows.Controls.PrintDialog : object {
    private PrintTicket _printTicket;
    private PrintQueue _printQueue;
    private PageRangeSelection _pageRangeSelection;
    private PageRange _pageRange;
    private bool _userPageRangeEnabled;
    private bool _selectedPagesEnabled;
    private bool _currentPageEnabled;
    private UInt32 _minPage;
    private UInt32 _maxPage;
    private double _printableAreaWidth;
    private double _printableAreaHeight;
    private bool _isPrintableAreaWidthUpdated;
    private bool _isPrintableAreaHeightUpdated;
    public PageRangeSelection PageRangeSelection { get; public set; }
    public PageRange PageRange { get; public set; }
    public bool UserPageRangeEnabled { get; public set; }
    public bool SelectedPagesEnabled { get; public set; }
    public bool CurrentPageEnabled { get; public set; }
    public UInt32 MinPage { get; public set; }
    public UInt32 MaxPage { get; public set; }
    public PrintQueue PrintQueue { get; public set; }
    public PrintTicket PrintTicket { get; public set; }
    public double PrintableAreaWidth { get; }
    public double PrintableAreaHeight { get; }
    public PageRangeSelection get_PageRangeSelection();
    public void set_PageRangeSelection(PageRangeSelection value);
    public PageRange get_PageRange();
    public void set_PageRange(PageRange value);
    public bool get_UserPageRangeEnabled();
    public void set_UserPageRangeEnabled(bool value);
    public bool get_SelectedPagesEnabled();
    public void set_SelectedPagesEnabled(bool value);
    public bool get_CurrentPageEnabled();
    public void set_CurrentPageEnabled(bool value);
    public UInt32 get_MinPage();
    public void set_MinPage(UInt32 value);
    public UInt32 get_MaxPage();
    public void set_MaxPage(UInt32 value);
    public PrintQueue get_PrintQueue();
    public void set_PrintQueue(PrintQueue value);
    public PrintTicket get_PrintTicket();
    public void set_PrintTicket(PrintTicket value);
    public double get_PrintableAreaWidth();
    public double get_PrintableAreaHeight();
    public Nullable`1<bool> ShowDialog();
    public void PrintVisual(Visual visual, string description);
    public void PrintDocument(DocumentPaginator documentPaginator, string description);
    private PrintQueue AcquireDefaultPrintQueue();
    private PrintTicket AcquireDefaultPrintTicket(PrintQueue printQueue);
    private void UpdatePrintableAreaSize();
    private XpsDocumentWriter CreateWriter(string description);
    private void PickCorrectPrintingEnvironment(PrintQueue& printQueue, PrintTicket& printTicket);
}
public class System.Windows.Controls.PrintDialogException : Exception {
    public PrintDialogException(string message);
    public PrintDialogException(string message, Exception innerException);
    protected PrintDialogException(SerializationInfo info, StreamingContext context);
}
[TemplatePartAttribute]
[TemplatePartAttribute]
[TemplatePartAttribute]
public class System.Windows.Controls.ProgressBar : RangeBase {
    public static DependencyProperty IsIndeterminateProperty;
    public static DependencyProperty OrientationProperty;
    private static string TrackTemplateName;
    private static string IndicatorTemplateName;
    private static string GlowingRectTemplateName;
    private FrameworkElement _track;
    private FrameworkElement _indicator;
    private FrameworkElement _glow;
    private static DependencyObjectType _dType;
    public bool IsIndeterminate { get; public set; }
    public Orientation Orientation { get; public set; }
    internal DependencyObjectType DTypeThemeStyleKey { get; }
    private static ProgressBar();
    public bool get_IsIndeterminate();
    public void set_IsIndeterminate(bool value);
    private static void OnIsIndeterminateChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void OnForegroundChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public Orientation get_Orientation();
    public void set_Orientation(Orientation value);
    internal static bool IsValidOrientation(object o);
    private static void OnOrientationChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private void SetProgressBarIndicatorLength();
    private void SetProgressBarGlowElementBrush();
    private void UpdateAnimation();
    internal virtual void ChangeVisualState(bool useTransitions);
    protected virtual AutomationPeer OnCreateAutomationPeer();
    protected virtual void OnMinimumChanged(double oldMinimum, double newMinimum);
    protected virtual void OnMaximumChanged(double oldMaximum, double newMaximum);
    protected virtual void OnValueChanged(double oldValue, double newValue);
    public virtual void OnApplyTemplate();
    private void OnTrackSizeChanged(object sender, SizeChangedEventArgs e);
    internal virtual DependencyObjectType get_DTypeThemeStyleKey();
    [CompilerGeneratedAttribute]
private void <.ctor>b__1_0(object s, DependencyPropertyChangedEventArgs e);
}
[LocalizabilityAttribute("9")]
public class System.Windows.Controls.RadioButton : ToggleButton {
    public static DependencyProperty GroupNameProperty;
    private static DependencyObjectType _dType;
    [ThreadStaticAttribute]
private static Hashtable _groupNameToElements;
    private static UncommonField`1<string> _currentlyRegisteredGroupName;
    [DefaultValueAttribute("")]
[LocalizabilityAttribute("17")]
public string GroupName { get; public set; }
    internal DependencyObjectType DTypeThemeStyleKey { get; }
    private static RadioButton();
    private static void OnGroupNameChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void Register(string groupName, RadioButton radioButton);
    private static void Unregister(string groupName, RadioButton radioButton);
    private static void PurgeDead(ArrayList elements, object elementToRemove);
    private void UpdateRadioButtonGroup();
    private void UncheckRadioButton();
    public string get_GroupName();
    public void set_GroupName(string value);
    protected virtual AutomationPeer OnCreateAutomationPeer();
    protected virtual void OnChecked(RoutedEventArgs e);
    protected internal virtual void OnToggle();
    protected virtual void OnAccessKey(AccessKeyEventArgs e);
    internal virtual DependencyObjectType get_DTypeThemeStyleKey();
}
internal class System.Windows.Controls.RealizedColumnsBlock : ValueType {
    [CompilerGeneratedAttribute]
private int <StartIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private int <EndIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private int <StartIndexOffset>k__BackingField;
    public int StartIndex { get; private set; }
    public int EndIndex { get; private set; }
    public int StartIndexOffset { get; private set; }
    public RealizedColumnsBlock(int startIndex, int endIndex, int startIndexOffset);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_StartIndex();
    [CompilerGeneratedAttribute]
private void set_StartIndex(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_EndIndex();
    [CompilerGeneratedAttribute]
private void set_EndIndex(int value);
    [CompilerGeneratedAttribute]
[IsReadOnlyAttribute]
public int get_StartIndexOffset();
    [CompilerGeneratedAttribute]
private void set_StartIndexOffset(int value);
}
[ContentPropertyAttribute("Document")]
[LocalizabilityAttribute("15")]
public class System.Windows.Controls.RichTextBox : TextBoxBase {
    public static DependencyProperty IsDocumentEnabledProperty;
    private FlowDocument _document;
    private bool _implicitDocument;
    private static DependencyObjectType _dType;
    public FlowDocument Document { get; public set; }
    public bool IsDocumentEnabled { get; public set; }
    protected internal IEnumerator LogicalChildren { get; }
    public TextSelection Selection { get; }
    [DesignerSerializationVisibilityAttribute("0")]
public TextPointer CaretPosition { get; public set; }
    internal DependencyObjectType DTypeThemeStyleKey { get; }
    private static RichTextBox();
    public RichTextBox(FlowDocument document);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object value);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string text);
    public TextPointer GetPositionFromPoint(Point point, bool snapToText);
    public SpellingError GetSpellingError(TextPointer position);
    public TextRange GetSpellingErrorRange(TextPointer position);
    public TextPointer GetNextSpellingErrorPosition(TextPointer position, LogicalDirection direction);
    protected virtual AutomationPeer OnCreateAutomationPeer();
    protected virtual void OnDpiChanged(DpiScale oldDpiScaleInfo, DpiScale newDpiScaleInfo);
    protected virtual Size MeasureOverride(Size constraint);
    internal virtual FrameworkElement CreateRenderScope();
    public FlowDocument get_Document();
    public void set_Document(FlowDocument value);
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeDocument();
    public bool get_IsDocumentEnabled();
    public void set_IsDocumentEnabled(bool value);
    protected internal virtual IEnumerator get_LogicalChildren();
    public TextSelection get_Selection();
    public TextPointer get_CaretPosition();
    public void set_CaretPosition(TextPointer value);
    internal virtual DependencyObjectType get_DTypeThemeStyleKey();
    private static void HookupInheritablePropertyListeners();
    private void TransferInheritedPropertiesToFlowDocument();
    private static void OnFormattingPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private void TransferFormattingProperty(DependencyProperty property, object inheritedValue);
    private static void OnBehavioralPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private void TransferBehavioralProperty(DependencyProperty property, object inheritedValue);
    private void OnPageSizeChangedHandler(object sender, EventArgs e);
    private static void OnIsDocumentEnabledChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
}
public class System.Windows.Controls.RowDefinition : DefinitionBase {
    [CommonDependencyPropertyAttribute]
public static DependencyProperty HeightProperty;
    [CommonDependencyPropertyAttribute]
[TypeConverterAttribute("System.Windows.LengthConverter, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")]
public static DependencyProperty MinHeightProperty;
    [CommonDependencyPropertyAttribute]
[TypeConverterAttribute("System.Windows.LengthConverter, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")]
public static DependencyProperty MaxHeightProperty;
    public GridLength Height { get; public set; }
    [TypeConverterAttribute("System.Windows.LengthConverter")]
public double MinHeight { get; public set; }
    [TypeConverterAttribute("System.Windows.LengthConverter")]
public double MaxHeight { get; public set; }
    public double ActualHeight { get; }
    public double Offset { get; }
    private static RowDefinition();
    public GridLength get_Height();
    public void set_Height(GridLength value);
    public double get_MinHeight();
    public void set_MinHeight(double value);
    public double get_MaxHeight();
    public void set_MaxHeight(double value);
    public double get_ActualHeight();
    public double get_Offset();
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Controls.RowDefinitionCollection : object {
    private Grid _owner;
    private DefinitionBase[] _items;
    private int _size;
    private int _version;
    private static int c_defaultCapacity;
    public int Count { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    public bool IsReadOnly { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    private object System.Collections.IList.Item { get; private set; }
    public RowDefinition Item { get; public set; }
    internal int InternalCount { get; }
    internal DefinitionBase[] InternalItems { get; }
    internal RowDefinitionCollection(Grid owner);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public sealed virtual void CopyTo(RowDefinition[] array, int index);
    private sealed virtual override int System.Collections.IList.Add(object value);
    public sealed virtual void Add(RowDefinition value);
    public sealed virtual void Clear();
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    public sealed virtual bool Contains(RowDefinition value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    public sealed virtual int IndexOf(RowDefinition value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    public sealed virtual void Insert(int index, RowDefinition value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    public sealed virtual bool Remove(RowDefinition value);
    public sealed virtual void RemoveAt(int index);
    public void RemoveRange(int index, int count);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override IEnumerator`1<RowDefinition> System.Collections.Generic.IEnumerable<System.Windows.Controls.RowDefinition>.GetEnumerator();
    public sealed virtual int get_Count();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public sealed virtual RowDefinition get_Item(int index);
    public sealed virtual void set_Item(int index, RowDefinition value);
    internal void InternalTrimToSize();
    internal int get_InternalCount();
    internal DefinitionBase[] get_InternalItems();
    private void PrivateVerifyWriteAccess();
    private void PrivateValidateValueForAddition(object value);
    private bool PrivateValidateValueForRemoval(object value);
    private void PrivateConnectChild(int index, DefinitionBase value);
    private void PrivateDisconnectChild(DefinitionBase value);
    private void PrivateInsert(int index, DefinitionBase value);
    private void PrivateRemove(DefinitionBase value);
    private void PrivateOnModified();
    private void PrivateSetCapacity(int value);
}
public enum System.Windows.Controls.ScrollBarVisibility : Enum {
    public int value__;
    public static ScrollBarVisibility Disabled;
    public static ScrollBarVisibility Auto;
    public static ScrollBarVisibility Hidden;
    public static ScrollBarVisibility Visible;
}
public class System.Windows.Controls.ScrollChangedEventArgs : RoutedEventArgs {
    private Vector _offset;
    private Vector _offsetChange;
    private Size _extent;
    private Vector _extentChange;
    private Size _viewport;
    private Vector _viewportChange;
    public double HorizontalOffset { get; }
    public double VerticalOffset { get; }
    public double HorizontalChange { get; }
    public double VerticalChange { get; }
    public double ViewportWidth { get; }
    public double ViewportHeight { get; }
    public double ViewportWidthChange { get; }
    public double ViewportHeightChange { get; }
    public double ExtentWidth { get; }
    public double ExtentHeight { get; }
    public double ExtentWidthChange { get; }
    public double ExtentHeightChange { get; }
    internal ScrollChangedEventArgs(Vector offset, Vector offsetChange, Size extent, Vector extentChange, Size viewport, Vector viewportChange);
    public double get_HorizontalOffset();
    public double get_VerticalOffset();
    public double get_HorizontalChange();
    public double get_VerticalChange();
    public double get_ViewportWidth();
    public double get_ViewportHeight();
    public double get_ViewportWidthChange();
    public double get_ViewportHeightChange();
    public double get_ExtentWidth();
    public double get_ExtentHeight();
    public double get_ExtentWidthChange();
    public double get_ExtentHeightChange();
    protected virtual void InvokeEventHandler(Delegate genericHandler, object genericTarget);
}
public class System.Windows.Controls.ScrollChangedEventHandler : MulticastDelegate {
    public ScrollChangedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, ScrollChangedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, ScrollChangedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Windows.Controls.ScrollContentPresenter : ContentPresenter {
    public static DependencyProperty CanContentScrollProperty;
    private IScrollInfo _scrollInfo;
    private ScrollData _scrollData;
    private AdornerLayer _adornerLayer;
    public AdornerLayer AdornerLayer { get; }
    public bool CanContentScroll { get; public set; }
    public bool CanHorizontallyScroll { get; public set; }
    public bool CanVerticallyScroll { get; public set; }
    public double ExtentWidth { get; }
    public double ExtentHeight { get; }
    public double ViewportWidth { get; }
    public double ViewportHeight { get; }
    [DesignerSerializationVisibilityAttribute("0")]
public double HorizontalOffset { get; }
    [DesignerSerializationVisibilityAttribute("0")]
public double VerticalOffset { get; }
    [DesignerSerializationVisibilityAttribute("0")]
public ScrollViewer ScrollOwner { get; public set; }
    protected int VisualChildrenCount { get; }
    internal UIElement TemplateChild { get; internal set; }
    private bool IsScrollClient { get; }
    internal int EffectiveValuesInitialSize { get; }
    private static ScrollContentPresenter();
    public sealed virtual void LineUp();
    public sealed virtual void LineDown();
    public sealed virtual void LineLeft();
    public sealed virtual void LineRight();
    public sealed virtual void PageUp();
    public sealed virtual void PageDown();
    public sealed virtual void PageLeft();
    public sealed virtual void PageRight();
    public sealed virtual void MouseWheelUp();
    public sealed virtual void MouseWheelDown();
    public sealed virtual void MouseWheelLeft();
    public sealed virtual void MouseWheelRight();
    public sealed virtual void SetHorizontalOffset(double offset);
    public sealed virtual void SetVerticalOffset(double offset);
    public sealed virtual Rect MakeVisible(Visual visual, Rect rectangle);
    public AdornerLayer get_AdornerLayer();
    public bool get_CanContentScroll();
    public void set_CanContentScroll(bool value);
    public sealed virtual bool get_CanHorizontallyScroll();
    public sealed virtual void set_CanHorizontallyScroll(bool value);
    public sealed virtual bool get_CanVerticallyScroll();
    public sealed virtual void set_CanVerticallyScroll(bool value);
    public sealed virtual double get_ExtentWidth();
    public sealed virtual double get_ExtentHeight();
    public sealed virtual double get_ViewportWidth();
    public sealed virtual double get_ViewportHeight();
    public sealed virtual double get_HorizontalOffset();
    public sealed virtual double get_VerticalOffset();
    public sealed virtual ScrollViewer get_ScrollOwner();
    public sealed virtual void set_ScrollOwner(ScrollViewer value);
    protected virtual int get_VisualChildrenCount();
    protected virtual Visual GetVisualChild(int index);
    internal virtual UIElement get_TemplateChild();
    internal virtual void set_TemplateChild(UIElement value);
    protected virtual Size MeasureOverride(Size constraint);
    protected virtual Size ArrangeOverride(Size arrangeSize);
    protected virtual Geometry GetLayoutClip(Size layoutSlotSize);
    public virtual void OnApplyTemplate();
    internal Rect MakeVisible(Visual visual, Rect rectangle, bool throwOnError);
    internal static double ComputeScrollOffsetWithMinimalScroll(double topView, double bottomView, double topChild, double bottomChild);
    internal static double ComputeScrollOffsetWithMinimalScroll(double topView, double bottomView, double topChild, double bottomChild, Boolean& alignTop, Boolean& alignBottom);
    internal static double ValidateInputOffset(double offset, string parameterName);
    private ScrollData EnsureScrollData();
    internal void HookupScrollingComponents();
    private void VerifyScrollData(Size viewport, Size extent);
    internal static double CoerceOffset(double offset, double extent, double viewport);
    private bool CoerceOffsets();
    private static void OnCanContentScrollChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private bool get_IsScrollClient();
    internal virtual int get_EffectiveValuesInitialSize();
}
public enum System.Windows.Controls.ScrollUnit : Enum {
    public int value__;
    public static ScrollUnit Pixel;
    public static ScrollUnit Item;
}
[TemplatePartAttribute]
[LocalizabilityAttribute("16")]
[DefaultEventAttribute("ScrollChangedEvent")]
[TemplatePartAttribute]
[TemplatePartAttribute]
public class System.Windows.Controls.ScrollViewer : ContentControl {
    [CommonDependencyPropertyAttribute]
public static DependencyProperty CanContentScrollProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty HorizontalScrollBarVisibilityProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty VerticalScrollBarVisibilityProperty;
    private static DependencyPropertyKey ComputedHorizontalScrollBarVisibilityPropertyKey;
    public static DependencyProperty ComputedHorizontalScrollBarVisibilityProperty;
    private static DependencyPropertyKey ComputedVerticalScrollBarVisibilityPropertyKey;
    public static DependencyProperty ComputedVerticalScrollBarVisibilityProperty;
    private static DependencyPropertyKey VerticalOffsetPropertyKey;
    public static DependencyProperty VerticalOffsetProperty;
    private static DependencyPropertyKey HorizontalOffsetPropertyKey;
    public static DependencyProperty HorizontalOffsetProperty;
    private static DependencyPropertyKey ContentVerticalOffsetPropertyKey;
    public static DependencyProperty ContentVerticalOffsetProperty;
    private static DependencyPropertyKey ContentHorizontalOffsetPropertyKey;
    public static DependencyProperty ContentHorizontalOffsetProperty;
    private static DependencyPropertyKey ExtentWidthPropertyKey;
    public static DependencyProperty ExtentWidthProperty;
    private static DependencyPropertyKey ExtentHeightPropertyKey;
    public static DependencyProperty ExtentHeightProperty;
    private static DependencyPropertyKey ScrollableWidthPropertyKey;
    public static DependencyProperty ScrollableWidthProperty;
    private static DependencyPropertyKey ScrollableHeightPropertyKey;
    public static DependencyProperty ScrollableHeightProperty;
    private static DependencyPropertyKey ViewportWidthPropertyKey;
    public static DependencyProperty ViewportWidthProperty;
    internal static DependencyPropertyKey ViewportHeightPropertyKey;
    public static DependencyProperty ViewportHeightProperty;
    public static DependencyProperty IsDeferredScrollingEnabledProperty;
    public static RoutedEvent ScrollChangedEvent;
    public static DependencyProperty PanningModeProperty;
    public static DependencyProperty PanningDecelerationProperty;
    public static DependencyProperty PanningRatioProperty;
    private bool _seenTapGesture;
    internal static double _scrollLineDelta;
    internal static double _mouseWheelDelta;
    private static string HorizontalScrollBarTemplateName;
    private static string VerticalScrollBarTemplateName;
    internal static string ScrollContentPresenterTemplateName;
    private Visibility _scrollVisibilityX;
    private Visibility _scrollVisibilityY;
    private double _xPositionISI;
    private double _yPositionISI;
    private double _xExtent;
    private double _yExtent;
    private double _xSize;
    private double _ySize;
    private EventHandler _layoutUpdatedHandler;
    private IScrollInfo _scrollInfo;
    private CommandQueue _queue;
    private PanningInfo _panningInfo;
    private Flags _flags;
    private static DependencyObjectType _dType;
    public bool CanContentScroll { get; public set; }
    [BindableAttribute("True")]
[CategoryAttribute("Appearance")]
public ScrollBarVisibility HorizontalScrollBarVisibility { get; public set; }
    [CategoryAttribute("Appearance")]
[BindableAttribute("True")]
public ScrollBarVisibility VerticalScrollBarVisibility { get; public set; }
    public Visibility ComputedHorizontalScrollBarVisibility { get; }
    public Visibility ComputedVerticalScrollBarVisibility { get; }
    public double HorizontalOffset { get; private set; }
    public double VerticalOffset { get; private set; }
    [CategoryAttribute("Layout")]
public double ExtentWidth { get; }
    [CategoryAttribute("Layout")]
public double ExtentHeight { get; }
    public double ScrollableWidth { get; }
    public double ScrollableHeight { get; }
    [CategoryAttribute("Layout")]
public double ViewportWidth { get; }
    [CategoryAttribute("Layout")]
public double ViewportHeight { get; }
    public double ContentVerticalOffset { get; private set; }
    public double ContentHorizontalOffset { get; private set; }
    public bool IsDeferredScrollingEnabled { get; public set; }
    protected internal bool HandlesScrolling { get; }
    protected internal IScrollInfo ScrollInfo { get; protected internal set; }
    public PanningMode PanningMode { get; public set; }
    public double PanningDeceleration { get; public set; }
    public double PanningRatio { get; public set; }
    internal bool HandlesMouseWheelScrolling { get; internal set; }
    internal bool InChildInvalidateMeasure { get; internal set; }
    private bool InvalidatedMeasureFromArrange { get; private set; }
    private bool ForceNextManipulationComplete { get; private set; }
    private bool ManipulationBindingsInitialized { get; private set; }
    private bool CompleteScrollManipulation { get; private set; }
    internal bool InChildMeasurePass1 { get; internal set; }
    internal bool InChildMeasurePass2 { get; internal set; }
    internal bool InChildMeasurePass3 { get; internal set; }
    internal int EffectiveValuesInitialSize { get; }
    internal DependencyObjectType DTypeThemeStyleKey { get; }
    private static ScrollViewer();
    public void LineUp();
    public void LineDown();
    public void LineLeft();
    public void LineRight();
    public void PageUp();
    public void PageDown();
    public void PageLeft();
    public void PageRight();
    public void ScrollToLeftEnd();
    public void ScrollToRightEnd();
    public void ScrollToHome();
    public void ScrollToEnd();
    public void ScrollToTop();
    public void ScrollToBottom();
    public void ScrollToHorizontalOffset(double offset);
    public void ScrollToVerticalOffset(double offset);
    private void DeferScrollToHorizontalOffset(double offset);
    private void DeferScrollToVerticalOffset(double offset);
    internal void MakeVisible(Visual child, Rect rect);
    private void EnsureLayoutUpdatedHandler();
    private void ClearLayoutUpdatedHandler();
    public void InvalidateScrollInfo();
    public bool get_CanContentScroll();
    public void set_CanContentScroll(bool value);
    public ScrollBarVisibility get_HorizontalScrollBarVisibility();
    public void set_HorizontalScrollBarVisibility(ScrollBarVisibility value);
    public ScrollBarVisibility get_VerticalScrollBarVisibility();
    public void set_VerticalScrollBarVisibility(ScrollBarVisibility value);
    public Visibility get_ComputedHorizontalScrollBarVisibility();
    public Visibility get_ComputedVerticalScrollBarVisibility();
    public double get_HorizontalOffset();
    private void set_HorizontalOffset(double value);
    public double get_VerticalOffset();
    private void set_VerticalOffset(double value);
    public double get_ExtentWidth();
    public double get_ExtentHeight();
    public double get_ScrollableWidth();
    public double get_ScrollableHeight();
    public double get_ViewportWidth();
    public double get_ViewportHeight();
    public static void SetCanContentScroll(DependencyObject element, bool canContentScroll);
    public static bool GetCanContentScroll(DependencyObject element);
    public static void SetHorizontalScrollBarVisibility(DependencyObject element, ScrollBarVisibility horizontalScrollBarVisibility);
    public static ScrollBarVisibility GetHorizontalScrollBarVisibility(DependencyObject element);
    public static void SetVerticalScrollBarVisibility(DependencyObject element, ScrollBarVisibility verticalScrollBarVisibility);
    public static ScrollBarVisibility GetVerticalScrollBarVisibility(DependencyObject element);
    public double get_ContentVerticalOffset();
    private void set_ContentVerticalOffset(double value);
    public double get_ContentHorizontalOffset();
    private void set_ContentHorizontalOffset(double value);
    public static bool GetIsDeferredScrollingEnabled(DependencyObject element);
    public static void SetIsDeferredScrollingEnabled(DependencyObject element, bool value);
    public bool get_IsDeferredScrollingEnabled();
    public void set_IsDeferredScrollingEnabled(bool value);
    public void add_ScrollChanged(ScrollChangedEventHandler value);
    public void remove_ScrollChanged(ScrollChangedEventHandler value);
    protected virtual void OnStylusSystemGesture(StylusSystemGestureEventArgs e);
    protected virtual void OnScrollChanged(ScrollChangedEventArgs e);
    protected virtual HitTestResult HitTestCore(PointHitTestParameters hitTestParameters);
    protected internal virtual bool get_HandlesScrolling();
    protected virtual void OnKeyDown(KeyEventArgs e);
    private bool IsInViewport(ScrollContentPresenter scp, DependencyObject element);
    internal void ScrollInDirection(KeyEventArgs e);
    protected virtual void OnMouseWheel(MouseWheelEventArgs e);
    protected virtual void OnMouseLeftButtonDown(MouseButtonEventArgs e);
    protected virtual Size MeasureOverride(Size constraint);
    protected virtual Size ArrangeOverride(Size arrangeSize);
    private void BindToTemplatedParent(DependencyProperty property);
    internal virtual void OnPreApplyTemplate();
    public virtual void OnApplyTemplate();
    protected internal IScrollInfo get_ScrollInfo();
    protected internal void set_ScrollInfo(IScrollInfo value);
    public PanningMode get_PanningMode();
    public void set_PanningMode(PanningMode value);
    public static void SetPanningMode(DependencyObject element, PanningMode panningMode);
    public static PanningMode GetPanningMode(DependencyObject element);
    private static void OnPanningModeChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private void OnPanningModeChanged();
    public double get_PanningDeceleration();
    public void set_PanningDeceleration(double value);
    public static void SetPanningDeceleration(DependencyObject element, double value);
    public static double GetPanningDeceleration(DependencyObject element);
    public double get_PanningRatio();
    public void set_PanningRatio(double value);
    public static void SetPanningRatio(DependencyObject element, double value);
    public static double GetPanningRatio(DependencyObject element);
    private static bool CheckFiniteNonNegative(object value);
    protected virtual void OnManipulationStarting(ManipulationStartingEventArgs e);
    private bool ShouldManipulateScroll(ManipulationStartingEventArgs e, ScrollContentPresenter viewport);
    protected virtual void OnManipulationDelta(ManipulationDeltaEventArgs e);
    private void ManipulateScroll(ManipulationDeltaEventArgs e);
    private void ManipulateScroll(double delta, double cumulativeTranslation, bool isHorizontal);
    private bool IsPastInertialLimit();
    private bool CanStartScrollManipulation(Vector translation, Boolean& cancelManipulation);
    protected virtual void OnManipulationInertiaStarting(ManipulationInertiaStartingEventArgs e);
    protected virtual void OnManipulationCompleted(ManipulationCompletedEventArgs e);
    internal bool get_HandlesMouseWheelScrolling();
    internal void set_HandlesMouseWheelScrolling(bool value);
    internal bool get_InChildInvalidateMeasure();
    internal void set_InChildInvalidateMeasure(bool value);
    private bool ExecuteNextCommand();
    private void EnqueueCommand(Commands code, double param, MakeVisibleParams mvp);
    private void EnsureQueueProcessing();
    private void OnLayoutUpdated(object sender, EventArgs e);
    protected virtual AutomationPeer OnCreateAutomationPeer();
    private static void OnRequestBringIntoView(object sender, RequestBringIntoViewEventArgs e);
    private static void OnScrollCommand(object target, ExecutedRoutedEventArgs args);
    private static void OnQueryScrollCommand(object target, CanExecuteRoutedEventArgs args);
    private static void InitializeCommands();
    private static ControlTemplate CreateDefaultControlTemplate();
    private void SetFlagValue(Flags flag, bool value);
    private bool get_InvalidatedMeasureFromArrange();
    private void set_InvalidatedMeasureFromArrange(bool value);
    private bool get_ForceNextManipulationComplete();
    private void set_ForceNextManipulationComplete(bool value);
    private bool get_ManipulationBindingsInitialized();
    private void set_ManipulationBindingsInitialized(bool value);
    private bool get_CompleteScrollManipulation();
    private void set_CompleteScrollManipulation(bool value);
    internal bool get_InChildMeasurePass1();
    internal void set_InChildMeasurePass1(bool value);
    internal bool get_InChildMeasurePass2();
    internal void set_InChildMeasurePass2(bool value);
    internal bool get_InChildMeasurePass3();
    internal void set_InChildMeasurePass3(bool value);
    private static bool IsValidScrollBarVisibility(object o);
    internal virtual int get_EffectiveValuesInitialSize();
    internal virtual DependencyObjectType get_DTypeThemeStyleKey();
}
public class System.Windows.Controls.SelectedCellsChangedEventArgs : EventArgs {
    private IList`1<DataGridCellInfo> _addedCells;
    private IList`1<DataGridCellInfo> _removedCells;
    public IList`1<DataGridCellInfo> AddedCells { get; }
    public IList`1<DataGridCellInfo> RemovedCells { get; }
    public SelectedCellsChangedEventArgs(List`1<DataGridCellInfo> addedCells, List`1<DataGridCellInfo> removedCells);
    public SelectedCellsChangedEventArgs(ReadOnlyCollection`1<DataGridCellInfo> addedCells, ReadOnlyCollection`1<DataGridCellInfo> removedCells);
    internal SelectedCellsChangedEventArgs(DataGrid owner, VirtualizedCellInfoCollection addedCells, VirtualizedCellInfoCollection removedCells);
    public IList`1<DataGridCellInfo> get_AddedCells();
    public IList`1<DataGridCellInfo> get_RemovedCells();
}
public class System.Windows.Controls.SelectedCellsChangedEventHandler : MulticastDelegate {
    public SelectedCellsChangedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, SelectedCellsChangedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, SelectedCellsChangedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class System.Windows.Controls.SelectedCellsCollection : VirtualizedCellInfoCollection {
    internal SelectedCellsCollection(DataGrid owner);
    internal bool GetSelectionRange(Int32& minColumnDisplayIndex, Int32& maxColumnDisplayIndex, Int32& minRowIndex, Int32& maxRowIndex);
    protected virtual void OnCollectionChanged(NotifyCollectionChangedAction action, VirtualizedCellInfoCollection oldItems, VirtualizedCellInfoCollection newItems);
}
public class System.Windows.Controls.SelectedDatesCollection : ObservableCollection`1<DateTime> {
    private Collection`1<DateTime> _addedItems;
    private Collection`1<DateTime> _removedItems;
    private Thread _dispatcherThread;
    private bool _isAddingRange;
    private Calendar _owner;
    private Nullable`1<DateTime> _maximumDate;
    private Nullable`1<DateTime> _minimumDate;
    internal Nullable`1<DateTime> MinimumDate { get; }
    internal Nullable`1<DateTime> MaximumDate { get; }
    public SelectedDatesCollection(Calendar owner);
    internal Nullable`1<DateTime> get_MinimumDate();
    internal Nullable`1<DateTime> get_MaximumDate();
    public void AddRange(DateTime start, DateTime end);
    protected virtual void ClearItems();
    protected virtual void InsertItem(int index, DateTime item);
    protected virtual void RemoveItem(int index);
    protected virtual void SetItem(int index, DateTime item);
    internal void AddRangeInternal(DateTime start, DateTime end);
    internal void ClearInternal();
    internal void ClearInternal(bool fireChangeNotification);
    internal void Toggle(DateTime date);
    private void RaiseSelectionChanged(IList removedItems, IList addedItems);
    private void BeginAddRange();
    private void EndAddRange();
    private bool CheckSelectionMode();
    private bool IsValidThread();
    private void UpdateMinMax(DateTime date);
    private void ClearMinMax();
    [IteratorStateMachineAttribute("System.Windows.Controls.SelectedDatesCollection/<GetDaysInRange>d__28")]
private static IEnumerable`1<DateTime> GetDaysInRange(DateTime start, DateTime end);
    private static int GetDirection(DateTime start, DateTime end);
}
internal class System.Windows.Controls.SelectedItemCollection : ObservableCollection`1<object> {
    private int _changeCount;
    private Changer _changer;
    private Selector _selector;
    private bool _updatingSelectedItems;
    internal bool IsChanging { get; }
    internal bool IsUpdatingSelectedItems { get; }
    public SelectedItemCollection(Selector selector);
    protected virtual void ClearItems();
    protected virtual void RemoveItem(int index);
    protected virtual void InsertItem(int index, object item);
    protected virtual void SetItem(int index, object item);
    protected virtual void MoveItem(int oldIndex, int newIndex);
    internal bool get_IsChanging();
    private IDisposable ChangeSelectedItems();
    private void FinishChange();
    internal void BeginUpdateSelectedItems();
    internal void EndUpdateSelectedItems();
    internal bool get_IsUpdatingSelectedItems();
    internal void Add(ItemInfo info);
    internal void Remove(ItemInfo info);
}
public class System.Windows.Controls.SelectionChangedEventArgs : RoutedEventArgs {
    private Object[] _addedItems;
    private Object[] _removedItems;
    private List`1<ItemInfo> _addedInfos;
    private List`1<ItemInfo> _removedInfos;
    public IList RemovedItems { get; }
    public IList AddedItems { get; }
    internal List`1<ItemInfo> RemovedInfos { get; }
    internal List`1<ItemInfo> AddedInfos { get; }
    public SelectionChangedEventArgs(RoutedEvent id, IList removedItems, IList addedItems);
    internal SelectionChangedEventArgs(List`1<ItemInfo> unselectedInfos, List`1<ItemInfo> selectedInfos);
    public IList get_RemovedItems();
    public IList get_AddedItems();
    internal List`1<ItemInfo> get_RemovedInfos();
    internal List`1<ItemInfo> get_AddedInfos();
    protected virtual void InvokeEventHandler(Delegate genericHandler, object genericTarget);
}
public class System.Windows.Controls.SelectionChangedEventHandler : MulticastDelegate {
    public SelectionChangedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, SelectionChangedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, SelectionChangedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public enum System.Windows.Controls.SelectionMode : Enum {
    public int value__;
    public static SelectionMode Single;
    public static SelectionMode Multiple;
    public static SelectionMode Extended;
}
public enum System.Windows.Controls.SelectiveScrollingOrientation : Enum {
    public int value__;
    public static SelectiveScrollingOrientation None;
    public static SelectiveScrollingOrientation Horizontal;
    public static SelectiveScrollingOrientation Vertical;
    public static SelectiveScrollingOrientation Both;
}
[LocalizabilityAttribute("0")]
public class System.Windows.Controls.Separator : Control {
    private static DependencyObjectType _dType;
    internal DependencyObjectType DTypeThemeStyleKey { get; }
    private static Separator();
    internal static void PrepareContainer(Control container);
    protected virtual AutomationPeer OnCreateAutomationPeer();
    internal virtual DependencyObjectType get_DTypeThemeStyleKey();
}
[FlagsAttribute]
internal enum System.Windows.Controls.SetPropertyFlags : Enum {
    public byte value__;
    public static SetPropertyFlags WindowTitle;
    public static SetPropertyFlags WindowHeight;
    public static SetPropertyFlags WindowWidth;
    public static SetPropertyFlags Title;
    public static SetPropertyFlags ShowsNavigationUI;
    public static SetPropertyFlags None;
}
internal class System.Windows.Controls.SettableState`1 : ValueType {
    internal T _value;
    internal bool _isSet;
    internal bool _wasSet;
    internal SettableState`1(T value);
}
[LocalizabilityAttribute("16")]
[DefaultEventAttribute("ValueChanged")]
[DefaultPropertyAttribute("Value")]
[TemplatePartAttribute]
[TemplatePartAttribute]
public class System.Windows.Controls.Slider : RangeBase {
    private static RoutedCommand _increaseLargeCommand;
    private static RoutedCommand _increaseSmallCommand;
    private static RoutedCommand _decreaseLargeCommand;
    private static RoutedCommand _decreaseSmallCommand;
    private static RoutedCommand _minimizeValueCommand;
    private static RoutedCommand _maximizeValueCommand;
    public static DependencyProperty OrientationProperty;
    public static DependencyProperty IsDirectionReversedProperty;
    public static DependencyProperty DelayProperty;
    public static DependencyProperty IntervalProperty;
    public static DependencyProperty AutoToolTipPlacementProperty;
    public static DependencyProperty AutoToolTipPrecisionProperty;
    public static DependencyProperty IsSnapToTickEnabledProperty;
    public static DependencyProperty TickPlacementProperty;
    public static DependencyProperty TickFrequencyProperty;
    public static DependencyProperty TicksProperty;
    public static DependencyProperty IsSelectionRangeEnabledProperty;
    public static DependencyProperty SelectionStartProperty;
    public static DependencyProperty SelectionEndProperty;
    public static DependencyProperty IsMoveToPointEnabledProperty;
    private static string TrackName;
    private static string SelectionRangeElementName;
    private FrameworkElement _selectionRangeElement;
    private Track _track;
    private ToolTip _autoToolTip;
    private object _thumbOriginalToolTip;
    private static DependencyObjectType _dType;
    public static RoutedCommand IncreaseLarge { get; }
    public static RoutedCommand DecreaseLarge { get; }
    public static RoutedCommand IncreaseSmall { get; }
    public static RoutedCommand DecreaseSmall { get; }
    public static RoutedCommand MinimizeValue { get; }
    public static RoutedCommand MaximizeValue { get; }
    public Orientation Orientation { get; public set; }
    [BindableAttribute("True")]
[CategoryAttribute("Appearance")]
public bool IsDirectionReversed { get; public set; }
    [CategoryAttribute("Behavior")]
[BindableAttribute("True")]
public int Delay { get; public set; }
    [BindableAttribute("True")]
[CategoryAttribute("Behavior")]
public int Interval { get; public set; }
    [CategoryAttribute("Behavior")]
[BindableAttribute("True")]
public AutoToolTipPlacement AutoToolTipPlacement { get; public set; }
    [BindableAttribute("True")]
[CategoryAttribute("Appearance")]
public int AutoToolTipPrecision { get; public set; }
    [BindableAttribute("True")]
[CategoryAttribute("Behavior")]
public bool IsSnapToTickEnabled { get; public set; }
    [BindableAttribute("True")]
[CategoryAttribute("Appearance")]
public TickPlacement TickPlacement { get; public set; }
    [CategoryAttribute("Appearance")]
[BindableAttribute("True")]
public double TickFrequency { get; public set; }
    [BindableAttribute("True")]
[CategoryAttribute("Appearance")]
public DoubleCollection Ticks { get; public set; }
    [BindableAttribute("True")]
[CategoryAttribute("Appearance")]
public bool IsSelectionRangeEnabled { get; public set; }
    [BindableAttribute("True")]
[CategoryAttribute("Appearance")]
public double SelectionStart { get; public set; }
    [BindableAttribute("True")]
[CategoryAttribute("Appearance")]
public double SelectionEnd { get; public set; }
    [CategoryAttribute("Behavior")]
[BindableAttribute("True")]
public bool IsMoveToPointEnabled { get; public set; }
    internal Track Track { get; internal set; }
    internal FrameworkElement SelectionRangeElement { get; internal set; }
    internal DependencyObjectType DTypeThemeStyleKey { get; }
    private static Slider();
    public static RoutedCommand get_IncreaseLarge();
    public static RoutedCommand get_DecreaseLarge();
    public static RoutedCommand get_IncreaseSmall();
    public static RoutedCommand get_DecreaseSmall();
    public static RoutedCommand get_MinimizeValue();
    public static RoutedCommand get_MaximizeValue();
    private static void InitializeCommands();
    private static void OnIncreaseSmallCommand(object sender, ExecutedRoutedEventArgs e);
    private static void OnDecreaseSmallCommand(object sender, ExecutedRoutedEventArgs e);
    private static void OnMaximizeValueCommand(object sender, ExecutedRoutedEventArgs e);
    private static void OnMinimizeValueCommand(object sender, ExecutedRoutedEventArgs e);
    private static void OnIncreaseLargeCommand(object sender, ExecutedRoutedEventArgs e);
    private static void OnDecreaseLargeCommand(object sender, ExecutedRoutedEventArgs e);
    public Orientation get_Orientation();
    public void set_Orientation(Orientation value);
    public bool get_IsDirectionReversed();
    public void set_IsDirectionReversed(bool value);
    public int get_Delay();
    public void set_Delay(int value);
    public int get_Interval();
    public void set_Interval(int value);
    public AutoToolTipPlacement get_AutoToolTipPlacement();
    public void set_AutoToolTipPlacement(AutoToolTipPlacement value);
    private static bool IsValidAutoToolTipPlacement(object o);
    public int get_AutoToolTipPrecision();
    public void set_AutoToolTipPrecision(int value);
    private static bool IsValidAutoToolTipPrecision(object o);
    public bool get_IsSnapToTickEnabled();
    public void set_IsSnapToTickEnabled(bool value);
    public TickPlacement get_TickPlacement();
    public void set_TickPlacement(TickPlacement value);
    private static bool IsValidTickPlacement(object o);
    public double get_TickFrequency();
    public void set_TickFrequency(double value);
    public DoubleCollection get_Ticks();
    public void set_Ticks(DoubleCollection value);
    public bool get_IsSelectionRangeEnabled();
    public void set_IsSelectionRangeEnabled(bool value);
    public double get_SelectionStart();
    public void set_SelectionStart(double value);
    private static void OnSelectionStartChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static object CoerceSelectionStart(DependencyObject d, object value);
    public double get_SelectionEnd();
    public void set_SelectionEnd(double value);
    private static void OnSelectionEndChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static object CoerceSelectionEnd(DependencyObject d, object value);
    private static object OnGetSelectionEnd(DependencyObject d);
    protected virtual void OnMinimumChanged(double oldMinimum, double newMinimum);
    protected virtual void OnMaximumChanged(double oldMaximum, double newMaximum);
    public bool get_IsMoveToPointEnabled();
    public void set_IsMoveToPointEnabled(bool value);
    protected virtual void OnPreviewMouseLeftButtonDown(MouseButtonEventArgs e);
    private static void OnThumbDragStarted(object sender, DragStartedEventArgs e);
    private static void OnThumbDragDelta(object sender, DragDeltaEventArgs e);
    private static void OnThumbDragCompleted(object sender, DragCompletedEventArgs e);
    protected virtual void OnThumbDragStarted(DragStartedEventArgs e);
    protected virtual void OnThumbDragDelta(DragDeltaEventArgs e);
    private string GetAutoToolTipNumber();
    protected virtual void OnThumbDragCompleted(DragCompletedEventArgs e);
    private CustomPopupPlacement[] AutoToolTipCustomPlacementCallback(Size popupSize, Size targetSize, Point offset);
    private void UpdateSelectionRangeElementPositionAndSize();
    internal Track get_Track();
    internal void set_Track(Track value);
    internal FrameworkElement get_SelectionRangeElement();
    internal void set_SelectionRangeElement(FrameworkElement value);
    private double SnapToTick(double value);
    private void MoveToNextTick(double direction);
    protected virtual AutomationPeer OnCreateAutomationPeer();
    private static void _OnMouseLeftButtonDown(object sender, MouseButtonEventArgs e);
    protected virtual Size ArrangeOverride(Size finalSize);
    protected virtual void OnValueChanged(double oldValue, double newValue);
    public virtual void OnApplyTemplate();
    protected virtual void OnIncreaseLarge();
    protected virtual void OnDecreaseLarge();
    protected virtual void OnIncreaseSmall();
    protected virtual void OnDecreaseSmall();
    protected virtual void OnMaximizeValue();
    protected virtual void OnMinimizeValue();
    private void UpdateValue(double value);
    private static bool IsValidDoubleValue(object value);
    internal virtual DependencyObjectType get_DTypeThemeStyleKey();
}
public class System.Windows.Controls.SoundPlayerAction : TriggerAction {
    public static DependencyProperty SourceProperty;
    private SoundPlayer m_player;
    private Uri m_lastRequestedAbsoluteUri;
    private bool m_streamLoadInProgress;
    private bool m_playRequested;
    private bool m_uriChangedWhileLoadingStream;
    public Uri Source { get; public set; }
    private static SoundPlayerAction();
    public sealed virtual void Dispose();
    public Uri get_Source();
    public void set_Source(Uri value);
    private static void OnSourceChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private void OnSourceChangedHelper(Uri newValue);
    internal sealed virtual void Invoke(FrameworkElement el, FrameworkContentElement ctntEl, Style targetStyle, FrameworkTemplate targetTemplate, long layer);
    internal sealed virtual void Invoke(FrameworkElement el);
    private void PlayWhenLoaded();
    private void BeginLoadStream();
    private Stream LoadStreamAsync(Uri uri);
    private void LoadStreamCallback(Stream asyncResult);
    private object OnLoadStreamCompleted(object asyncResultArg);
    private void OnSoundPlayerLoadCompleted(object sender, AsyncCompletedEventArgs e);
    [CompilerGeneratedAttribute]
private void <BeginLoadStream>b__11_0();
}
public class System.Windows.Controls.SpellCheck : object {
    public static DependencyProperty IsEnabledProperty;
    public static DependencyProperty SpellingReformProperty;
    private static DependencyPropertyKey CustomDictionariesPropertyKey;
    public static DependencyProperty CustomDictionariesProperty;
    private TextBoxBase _owner;
    public bool IsEnabled { get; public set; }
    public SpellingReform SpellingReform { get; public set; }
    public IList CustomDictionaries { get; }
    internal SpellCheck(TextBoxBase owner);
    private static SpellCheck();
    public bool get_IsEnabled();
    public void set_IsEnabled(bool value);
    public static void SetIsEnabled(TextBoxBase textBoxBase, bool value);
    public static bool GetIsEnabled(TextBoxBase textBoxBase);
    public SpellingReform get_SpellingReform();
    public void set_SpellingReform(SpellingReform value);
    public static void SetSpellingReform(TextBoxBase textBoxBase, SpellingReform value);
    public IList get_CustomDictionaries();
    public static IList GetCustomDictionaries(TextBoxBase textBoxBase);
    private static void OnIsEnabledChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void OnSpellingReformChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
}
public class System.Windows.Controls.SpellingError : object {
    private Speller _speller;
    private ITextPointer _start;
    private ITextPointer _end;
    public IEnumerable`1<string> Suggestions { get; }
    internal ITextPointer Start { get; }
    internal ITextPointer End { get; }
    internal SpellingError(Speller speller, ITextPointer start, ITextPointer end);
    public void Correct(string correctedText);
    public void IgnoreAll();
    [IteratorStateMachineAttribute("System.Windows.Controls.SpellingError/<get_Suggestions>d__4")]
public IEnumerable`1<string> get_Suggestions();
    internal ITextPointer get_Start();
    internal ITextPointer get_End();
}
public enum System.Windows.Controls.SpellingReform : Enum {
    public int value__;
    public static SpellingReform PreAndPostreform;
    public static SpellingReform Prereform;
    public static SpellingReform Postreform;
}
public class System.Windows.Controls.StackPanel : Panel {
    public static DependencyProperty OrientationProperty;
    private ScrollData _scrollData;
    public Orientation Orientation { get; public set; }
    protected internal bool HasLogicalOrientation { get; }
    protected internal Orientation LogicalOrientation { get; }
    [DefaultValueAttribute("False")]
public bool CanHorizontallyScroll { get; public set; }
    [DefaultValueAttribute("False")]
public bool CanVerticallyScroll { get; public set; }
    public double ExtentWidth { get; }
    public double ExtentHeight { get; }
    public double ViewportWidth { get; }
    public double ViewportHeight { get; }
    [DesignerSerializationVisibilityAttribute("0")]
public double HorizontalOffset { get; }
    [DesignerSerializationVisibilityAttribute("0")]
public double VerticalOffset { get; }
    [DesignerSerializationVisibilityAttribute("0")]
public ScrollViewer ScrollOwner { get; public set; }
    private bool IsScrolling { get; }
    internal int EffectiveValuesInitialSize { get; }
    private bool System.Windows.Controls.IStackMeasure.IsScrolling { get; }
    private UIElementCollection System.Windows.Controls.IStackMeasure.InternalChildren { get; }
    private bool CanMouseWheelVerticallyScroll { get; }
    private static StackPanel();
    public sealed virtual void LineUp();
    public sealed virtual void LineDown();
    public sealed virtual void LineLeft();
    public sealed virtual void LineRight();
    public sealed virtual void PageUp();
    public sealed virtual void PageDown();
    public sealed virtual void PageLeft();
    public sealed virtual void PageRight();
    public sealed virtual void MouseWheelUp();
    public sealed virtual void MouseWheelDown();
    public sealed virtual void MouseWheelLeft();
    public sealed virtual void MouseWheelRight();
    public sealed virtual void SetHorizontalOffset(double offset);
    public sealed virtual void SetVerticalOffset(double offset);
    public sealed virtual Rect MakeVisible(Visual visual, Rect rectangle);
    public sealed virtual Orientation get_Orientation();
    public void set_Orientation(Orientation value);
    protected internal virtual bool get_HasLogicalOrientation();
    protected internal virtual Orientation get_LogicalOrientation();
    public sealed virtual bool get_CanHorizontallyScroll();
    public sealed virtual void set_CanHorizontallyScroll(bool value);
    public sealed virtual bool get_CanVerticallyScroll();
    public sealed virtual void set_CanVerticallyScroll(bool value);
    public sealed virtual double get_ExtentWidth();
    public sealed virtual double get_ExtentHeight();
    public sealed virtual double get_ViewportWidth();
    public sealed virtual double get_ViewportHeight();
    public sealed virtual double get_HorizontalOffset();
    public sealed virtual double get_VerticalOffset();
    public sealed virtual ScrollViewer get_ScrollOwner();
    public sealed virtual void set_ScrollOwner(ScrollViewer value);
    protected virtual Size MeasureOverride(Size constraint);
    internal static Size StackMeasureHelper(IStackMeasure measureElement, IStackMeasureScrollData scrollData, Size constraint);
    protected virtual Size ArrangeOverride(Size arrangeSize);
    internal static Size StackArrangeHelper(IStackMeasure arrangeElement, IStackMeasureScrollData scrollData, Size arrangeSize);
    private void EnsureScrollData();
    private static void ResetScrolling(StackPanel element);
    private void OnScrollChange();
    private static void VerifyScrollingData(IStackMeasure measureElement, IStackMeasureScrollData scrollData, Size viewport, Size extent, Vector offset);
    private static double ComputePhysicalFromLogicalOffset(IStackMeasure arrangeElement, double logicalOffset, bool fHorizontal);
    private int FindChildIndexThatParentsVisual(Visual child);
    private void MakeVisiblePhysicalHelper(Rect r, Vector& newOffset, Rect& newRect);
    private void MakeVisibleLogicalHelper(int childIndex, Vector& newOffset, Rect& newRect);
    private static int CoerceOffsetToInteger(double offset, int numberOfItems);
    private static void OnOrientationChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private bool get_IsScrolling();
    internal virtual int get_EffectiveValuesInitialSize();
    private sealed virtual override bool System.Windows.Controls.IStackMeasure.get_IsScrolling();
    private sealed virtual override UIElementCollection System.Windows.Controls.IStackMeasure.get_InternalChildren();
    private sealed virtual override void System.Windows.Controls.IStackMeasure.OnScrollChange();
    private bool get_CanMouseWheelVerticallyScroll();
}
[TemplatePartAttribute]
[TemplatePartAttribute]
[TemplatePartAttribute]
[TemplatePartAttribute]
[TemplatePartAttribute]
[TemplatePartAttribute]
[TemplatePartAttribute]
[TemplatePartAttribute]
[TemplatePartAttribute]
[TemplatePartAttribute]
public class System.Windows.Controls.StickyNoteControl : Control {
    public static XmlQualifiedName TextSchemaName;
    public static XmlQualifiedName InkSchemaName;
    private PresentationContext _presentationContext;
    private TranslateTransform _positionTransform;
    private IAttachedAnnotation _attachedAnnotation;
    private SNCAnnotation _sncAnnotation;
    private double _offsetX;
    private double _offsetY;
    private double _deltaX;
    private double _deltaY;
    private int _zOrder;
    private bool _selfMirroring;
    internal static DependencyPropertyKey AuthorPropertyKey;
    public static DependencyProperty AuthorProperty;
    public static DependencyProperty IsExpandedProperty;
    public static DependencyProperty IsActiveProperty;
    internal static DependencyPropertyKey IsMouseOverAnchorPropertyKey;
    public static DependencyProperty IsMouseOverAnchorProperty;
    public static DependencyProperty CaptionFontFamilyProperty;
    public static DependencyProperty CaptionFontSizeProperty;
    public static DependencyProperty CaptionFontStretchProperty;
    public static DependencyProperty CaptionFontStyleProperty;
    public static DependencyProperty CaptionFontWeightProperty;
    public static DependencyProperty PenWidthProperty;
    private static DependencyPropertyKey StickyNoteTypePropertyKey;
    public static DependencyProperty StickyNoteTypeProperty;
    public static RoutedCommand DeleteNoteCommand;
    public static RoutedCommand InkCommand;
    private static DependencyProperty InkEditingModeProperty;
    private LockHelper _lockHelper;
    private MarkedHighlightComponent _anchor;
    private bool _dirty;
    private StickyNoteType _stickyNoteType;
    private StickyNoteContentControl _contentControl;
    private StrokeChangedHandler`1<PropertyDataChangedEventArgs> _propertyDataChangedHandler;
    private StrokeChangedHandler`1<DrawingAttributesReplacedEventArgs> _strokeDrawingAttributesReplacedHandler;
    private StrokeChangedHandler`1<EventArgs> _strokePacketDataChangedHandler;
    private IList MS.Internal.Annotations.Component.IAnnotationComponent.AttachedAnnotations { get; }
    private UIElement MS.Internal.Annotations.Component.IAnnotationComponent.AnnotatedElement { get; }
    private PresentationContext MS.Internal.Annotations.Component.IAnnotationComponent.PresentationContext { get; private set; }
    private int MS.Internal.Annotations.Component.IAnnotationComponent.ZOrder { get; private set; }
    private bool MS.Internal.Annotations.Component.IAnnotationComponent.IsDirty { get; private set; }
    internal TranslateTransform PositionTransform { get; internal set; }
    internal double XOffset { get; internal set; }
    internal double YOffset { get; internal set; }
    internal bool FlipBothOrigins { get; }
    private Rect StickyNoteBounds { get; }
    private Rect PageBounds { get; }
    public string Author { get; }
    public bool IsExpanded { get; public set; }
    public bool IsActive { get; }
    public bool IsMouseOverAnchor { get; }
    public FontFamily CaptionFontFamily { get; public set; }
    public double CaptionFontSize { get; public set; }
    public FontStretch CaptionFontStretch { get; public set; }
    public FontStyle CaptionFontStyle { get; public set; }
    public FontWeight CaptionFontWeight { get; public set; }
    public double PenWidth { get; public set; }
    public StickyNoteType StickyNoteType { get; }
    public IAnchorInfo AnchorInfo { get; }
    internal StickyNoteContentControl Content { get; }
    private bool IsDirty { get; private set; }
    private LockHelper InternalLocker { get; }
    private static StickyNoteControl();
    internal StickyNoteControl(StickyNoteType type);
    private sealed virtual override void MS.Internal.Annotations.Component.IAnnotationComponent.AddAttachedAnnotation(IAttachedAnnotation attachedAnnotation);
    private sealed virtual override void MS.Internal.Annotations.Component.IAnnotationComponent.RemoveAttachedAnnotation(IAttachedAnnotation attachedAnnotation);
    private sealed virtual override void MS.Internal.Annotations.Component.IAnnotationComponent.ModifyAttachedAnnotation(IAttachedAnnotation attachedAnnotation, object previousAttachedAnchor, AttachmentLevel previousAttachmentLevel);
    private sealed virtual override IList MS.Internal.Annotations.Component.IAnnotationComponent.get_AttachedAnnotations();
    private sealed virtual override GeneralTransform MS.Internal.Annotations.Component.IAnnotationComponent.GetDesiredTransform(GeneralTransform transform);
    private sealed virtual override UIElement MS.Internal.Annotations.Component.IAnnotationComponent.get_AnnotatedElement();
    private sealed virtual override PresentationContext MS.Internal.Annotations.Component.IAnnotationComponent.get_PresentationContext();
    private sealed virtual override void MS.Internal.Annotations.Component.IAnnotationComponent.set_PresentationContext(PresentationContext value);
    private sealed virtual override int MS.Internal.Annotations.Component.IAnnotationComponent.get_ZOrder();
    private sealed virtual override void MS.Internal.Annotations.Component.IAnnotationComponent.set_ZOrder(int value);
    private sealed virtual override bool MS.Internal.Annotations.Component.IAnnotationComponent.get_IsDirty();
    private sealed virtual override void MS.Internal.Annotations.Component.IAnnotationComponent.set_IsDirty(bool value);
    internal TranslateTransform get_PositionTransform();
    internal void set_PositionTransform(TranslateTransform value);
    internal double get_XOffset();
    internal void set_XOffset(double value);
    internal double get_YOffset();
    internal void set_YOffset(double value);
    internal bool get_FlipBothOrigins();
    private void OnAuthorUpdated(object obj, AnnotationAuthorChangedEventArgs args);
    private void OnAnnotationUpdated(object obj, AnnotationResourceChangedEventArgs args);
    private void SetAnnotation(IAttachedAnnotation attachedAnnotation);
    private void ClearAnnotation();
    private void OnRequestBringIntoView(object sender, RequestBringIntoViewEventArgs e);
    private object DispatchBringIntoView(object arg);
    private void UpdateSNCWithAnnotation(XmlToken tokens);
    private void UpdateAnnotationWithSNC(XmlToken tokens);
    private void UpdateOffsets();
    private static void GetOffsets(Rect rectPage, Rect rectStickyNote, Double& offsetX, Double& offsetY);
    private Rect get_StickyNoteBounds();
    private Rect get_PageBounds();
    public virtual void OnApplyTemplate();
    public string get_Author();
    public bool get_IsExpanded();
    public void set_IsExpanded(bool value);
    public bool get_IsActive();
    public bool get_IsMouseOverAnchor();
    public FontFamily get_CaptionFontFamily();
    public void set_CaptionFontFamily(FontFamily value);
    public double get_CaptionFontSize();
    public void set_CaptionFontSize(double value);
    public FontStretch get_CaptionFontStretch();
    public void set_CaptionFontStretch(FontStretch value);
    public FontStyle get_CaptionFontStyle();
    public void set_CaptionFontStyle(FontStyle value);
    public FontWeight get_CaptionFontWeight();
    public void set_CaptionFontWeight(FontWeight value);
    public double get_PenWidth();
    public void set_PenWidth(double value);
    public StickyNoteType get_StickyNoteType();
    public IAnchorInfo get_AnchorInfo();
    protected virtual void OnTemplateChanged(ControlTemplate oldTemplate, ControlTemplate newTemplate);
    protected virtual void OnIsKeyboardFocusWithinChanged(DependencyPropertyChangedEventArgs args);
    protected virtual void OnGotKeyboardFocus(KeyboardFocusChangedEventArgs args);
    private void EnsureStickyNoteType();
    private void DisconnectContent();
    private void ConnectContent();
    internal StickyNoteContentControl get_Content();
    private Button GetCloseButton();
    private Button GetIconButton();
    private Thumb GetTitleThumb();
    private UIElement GetContentContainer();
    private Thumb GetResizeThumb();
    private bool get_IsDirty();
    private void set_IsDirty(bool value);
    private static void _OnIsExpandedChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void OnFontPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void _UpdateInkDrawingAttributes(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private void OnTextChanged(object obj, TextChangedEventArgs args);
    private static void _OnDeviceDown(object sender, TEventArgs args);
    private static void _OnContextMenuOpening(object sender, ContextMenuEventArgs args);
    private static void _OnPreviewDeviceDown(object sender, TEventArgs args);
    private void OnInkCanvasStrokesReplacedEventHandler(object sender, InkCanvasStrokesReplacedEventArgs e);
    private void OnInkCanvasSelectionMovingEventHandler(object sender, InkCanvasSelectionEditingEventArgs e);
    private void OnInkCanvasSelectionResizingEventHandler(object sender, InkCanvasSelectionEditingEventArgs e);
    private void OnInkStrokesChanged(object sender, StrokeCollectionChangedEventArgs args);
    private void InitStickyNoteControl();
    private void InitializeEventHandlers();
    private void OnButtonClick(object sender, RoutedEventArgs e);
    private void DeleteStickyNote();
    private void OnDragCompleted(object sender, DragCompletedEventArgs args);
    private void OnDragDelta(object sender, DragDeltaEventArgs args);
    private void OnTitleDragDelta(double horizontalChange, double verticalChange);
    private void OnResizeDragDelta(double horizontalChange, double verticalChange);
    private void OnPreviewDeviceDown(object dc, InputEventArgs args);
    private void OnLoadedEventHandler(object sender, RoutedEventArgs e);
    private void ClearCachedControls();
    private void OnIsExpandedChanged();
    private object AsyncTakeFocus(object notUsed);
    private void GiveUpFocus();
    private void BringToFront();
    private void SendToBack();
    private void InvalidateTransform();
    private object AsyncUpdateAnnotation(object arg);
    private void BindContentControlProperties();
    private void UnbindContentControlProperties();
    private void StartListenToContentControlEvent();
    private void StopListenToContentControlEvent();
    private void StartListenToStrokesEvent(StrokeCollection strokes);
    private void StopListenToStrokesEvent(StrokeCollection strokes);
    private void StartListenToStrokeEvent(IEnumerable`1<Stroke> strokes);
    private void StopListenToStrokeEvent(IEnumerable`1<Stroke> strokes);
    private void SetupMenu();
    private static void _OnCommandExecuted(object sender, ExecutedRoutedEventArgs args);
    private static void _OnQueryCommandEnabled(object sender, CanExecuteRoutedEventArgs args);
    private void UpdateInkDrawingAttributes();
    private MenuItem GetInkMenuItem();
    private MenuItem GetSelectMenuItem();
    private MenuItem GetEraseMenuItem();
    private MenuItem GetCopyMenuItem();
    private MenuItem GetPasteMenuItem();
    private Separator GetClipboardSeparator();
    private LockHelper get_InternalLocker();
}
public enum System.Windows.Controls.StickyNoteType : Enum {
    public int value__;
    public static StickyNoteType Text;
    public static StickyNoteType Ink;
}
public enum System.Windows.Controls.StretchDirection : Enum {
    public int value__;
    public static StretchDirection UpOnly;
    public static StretchDirection DownOnly;
    public static StretchDirection Both;
}
public class System.Windows.Controls.StyleSelector : object {
    public virtual Style SelectStyle(object item, DependencyObject container);
}
[StyleTypedPropertyAttribute]
[TemplatePartAttribute]
public class System.Windows.Controls.TabControl : Selector {
    public static DependencyProperty TabStripPlacementProperty;
    private static DependencyPropertyKey SelectedContentPropertyKey;
    public static DependencyProperty SelectedContentProperty;
    private static DependencyPropertyKey SelectedContentTemplatePropertyKey;
    public static DependencyProperty SelectedContentTemplateProperty;
    private static DependencyPropertyKey SelectedContentTemplateSelectorPropertyKey;
    public static DependencyProperty SelectedContentTemplateSelectorProperty;
    private static DependencyPropertyKey SelectedContentStringFormatPropertyKey;
    public static DependencyProperty SelectedContentStringFormatProperty;
    public static DependencyProperty ContentTemplateProperty;
    public static DependencyProperty ContentTemplateSelectorProperty;
    public static DependencyProperty ContentStringFormatProperty;
    private static string SelectedContentHostTemplateName;
    private static DependencyObjectType _dType;
    [BindableAttribute("True")]
[CategoryAttribute("Behavior")]
public Dock TabStripPlacement { get; public set; }
    [DesignerSerializationVisibilityAttribute("0")]
public object SelectedContent { get; internal set; }
    [DesignerSerializationVisibilityAttribute("0")]
public DataTemplate SelectedContentTemplate { get; internal set; }
    [DesignerSerializationVisibilityAttribute("0")]
public DataTemplateSelector SelectedContentTemplateSelector { get; internal set; }
    public string SelectedContentStringFormat { get; internal set; }
    public DataTemplate ContentTemplate { get; public set; }
    public DataTemplateSelector ContentTemplateSelector { get; public set; }
    public string ContentStringFormat { get; public set; }
    internal ContentPresenter SelectedContentPresenter { get; }
    internal DependencyObjectType DTypeThemeStyleKey { get; }
    private static TabControl();
    private static void OnTabStripPlacementPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public Dock get_TabStripPlacement();
    public void set_TabStripPlacement(Dock value);
    public object get_SelectedContent();
    internal void set_SelectedContent(object value);
    public DataTemplate get_SelectedContentTemplate();
    internal void set_SelectedContentTemplate(DataTemplate value);
    public DataTemplateSelector get_SelectedContentTemplateSelector();
    internal void set_SelectedContentTemplateSelector(DataTemplateSelector value);
    public string get_SelectedContentStringFormat();
    internal void set_SelectedContentStringFormat(string value);
    public DataTemplate get_ContentTemplate();
    public void set_ContentTemplate(DataTemplate value);
    public DataTemplateSelector get_ContentTemplateSelector();
    public void set_ContentTemplateSelector(DataTemplateSelector value);
    public string get_ContentStringFormat();
    public void set_ContentStringFormat(string value);
    internal virtual void ChangeVisualState(bool useTransitions);
    protected virtual AutomationPeer OnCreateAutomationPeer();
    protected virtual void OnInitialized(EventArgs e);
    public virtual void OnApplyTemplate();
    protected virtual void OnSelectionChanged(SelectionChangedEventArgs e);
    protected virtual void OnItemsChanged(NotifyCollectionChangedEventArgs e);
    protected virtual void OnKeyDown(KeyEventArgs e);
    private TabItem FindNextTabItem(int startIndex, int direction);
    protected virtual bool IsItemItsOwnContainerOverride(object item);
    protected virtual DependencyObject GetContainerForItemOverride();
    internal ContentPresenter get_SelectedContentPresenter();
    private void OnGeneratorStatusChanged(object sender, EventArgs e);
    private TabItem GetSelectedTabItem();
    private void UpdateSelectedContent();
    internal virtual DependencyObjectType get_DTypeThemeStyleKey();
}
[DefaultEventAttribute("IsSelectedChanged")]
public class System.Windows.Controls.TabItem : HeaderedContentControl {
    public static DependencyProperty IsSelectedProperty;
    private static DependencyPropertyKey TabStripPlacementPropertyKey;
    public static DependencyProperty TabStripPlacementProperty;
    private BoolField _tabItemBoolFieldStore;
    private static DependencyObjectType _dType;
    [BindableAttribute("True")]
[CategoryAttribute("Appearance")]
public bool IsSelected { get; public set; }
    public Dock TabStripPlacement { get; }
    private TabControl TabControlParent { get; }
    internal DependencyObjectType DTypeThemeStyleKey { get; }
    private static TabItem();
    public bool get_IsSelected();
    public void set_IsSelected(bool value);
    private static void OnIsSelectedChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    protected virtual void OnSelected(RoutedEventArgs e);
    protected virtual void OnUnselected(RoutedEventArgs e);
    private void HandleIsSelectedChanged(bool newValue, RoutedEventArgs e);
    private static object CoerceTabStripPlacement(DependencyObject d, object value);
    public Dock get_TabStripPlacement();
    internal virtual void OnAncestorChanged();
    internal virtual void ChangeVisualState(bool useTransitions);
    protected virtual AutomationPeer OnCreateAutomationPeer();
    protected virtual void OnMouseLeftButtonDown(MouseButtonEventArgs e);
    protected virtual void OnPreviewGotKeyboardFocus(KeyboardFocusChangedEventArgs e);
    protected virtual void OnAccessKey(AccessKeyEventArgs e);
    protected virtual void OnContentChanged(object oldContent, object newContent);
    protected virtual void OnContentTemplateChanged(DataTemplate oldContentTemplate, DataTemplate newContentTemplate);
    protected virtual void OnContentTemplateSelectorChanged(DataTemplateSelector oldContentTemplateSelector, DataTemplateSelector newContentTemplateSelector);
    private static void OnAccessKeyPressed(object sender, AccessKeyPressedEventArgs e);
    internal bool SetFocus();
    private TabControl get_TabControlParent();
    private bool GetBoolField(BoolField field);
    private void SetBoolField(BoolField field, bool value);
    internal virtual DependencyObjectType get_DTypeThemeStyleKey();
}
[LocalizabilityAttribute("1")]
[ContentPropertyAttribute("Inlines")]
public class System.Windows.Controls.TextBlock : FrameworkElement {
    public static DependencyProperty BaselineOffsetProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty TextProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty FontFamilyProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty FontStyleProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty FontWeightProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty FontStretchProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty FontSizeProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty ForegroundProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty BackgroundProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty TextDecorationsProperty;
    public static DependencyProperty TextEffectsProperty;
    public static DependencyProperty LineHeightProperty;
    public static DependencyProperty LineStackingStrategyProperty;
    public static DependencyProperty PaddingProperty;
    public static DependencyProperty TextAlignmentProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty TextTrimmingProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty TextWrappingProperty;
    public static DependencyProperty IsHyphenationEnabledProperty;
    private TextBlockCache _textBlockCache;
    private string _contentCache;
    private ComplexContent _complexContent;
    private TextFormatter _textFormatterIdeal;
    private TextFormatter _textFormatterDisplay;
    private Size _referenceSize;
    private Size _previousDesiredSize;
    private double _baselineOffset;
    private static UncommonField`1<NaturalLanguageHyphenator> HyphenatorField;
    private LineMetrics _firstLine;
    private List`1<LineMetrics> _subsequentLines;
    private Flags _flags;
    private IEnumerator`1<IInputElement> System.Windows.IContentHost.HostedElements { get; }
    protected internal IEnumerator LogicalChildren { get; }
    [DesignerSerializationVisibilityAttribute("2")]
public InlineCollection Inlines { get; }
    public TextPointer ContentStart { get; }
    public TextPointer ContentEnd { get; }
    internal TextRange TextRange { get; }
    public LineBreakCondition BreakBefore { get; }
    public LineBreakCondition BreakAfter { get; }
    public Typography Typography { get; }
    public double BaselineOffset { get; public set; }
    [LocalizabilityAttribute("1")]
public string Text { get; public set; }
    [LocalizabilityAttribute("14")]
public FontFamily FontFamily { get; public set; }
    public FontStyle FontStyle { get; public set; }
    public FontWeight FontWeight { get; public set; }
    public FontStretch FontStretch { get; public set; }
    [TypeConverterAttribute("System.Windows.FontSizeConverter")]
[LocalizabilityAttribute("0")]
public double FontSize { get; public set; }
    public Brush Foreground { get; public set; }
    public Brush Background { get; public set; }
    public TextDecorationCollection TextDecorations { get; public set; }
    public TextEffectCollection TextEffects { get; public set; }
    [TypeConverterAttribute("System.Windows.LengthConverter")]
public double LineHeight { get; public set; }
    public LineStackingStrategy LineStackingStrategy { get; public set; }
    public Thickness Padding { get; public set; }
    public TextAlignment TextAlignment { get; public set; }
    public TextTrimming TextTrimming { get; public set; }
    public TextWrapping TextWrapping { get; public set; }
    public bool IsHyphenationEnabled { get; public set; }
    protected int VisualChildrenCount { get; }
    protected IEnumerator`1<IInputElement> HostedElementsCore { get; }
    internal TextFormatter TextFormatter { get; }
    internal ITextContainer TextContainer { get; }
    internal ITextView TextView { get; }
    internal Highlights Highlights { get; }
    internal LineProperties ParagraphProperties { get; }
    internal bool IsLayoutDataValid { get; }
    internal bool HasComplexContent { get; }
    internal bool IsTypographyDefaultValue { get; }
    private ArrayList InlineObjects { get; private set; }
    internal bool IsContentPresenterContainer { get; internal set; }
    private int LineCount { get; }
    internal int EffectiveValuesInitialSize { get; }
    private static TextBlock();
    public TextBlock(Inline inline);
    private sealed virtual override IInputElement System.Windows.IContentHost.InputHitTest(Point point);
    private sealed virtual override ReadOnlyCollection`1<Rect> System.Windows.IContentHost.GetRectangles(ContentElement child);
    private sealed virtual override IEnumerator`1<IInputElement> System.Windows.IContentHost.get_HostedElements();
    private sealed virtual override void System.Windows.IContentHost.OnChildDesiredSizeChanged(UIElement child);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object value);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string text);
    protected internal virtual IEnumerator get_LogicalChildren();
    private sealed virtual override object System.IServiceProvider.GetService(Type serviceType);
    private void Initialize();
    public TextPointer GetPositionFromPoint(Point point, bool snapToText);
    public InlineCollection get_Inlines();
    public TextPointer get_ContentStart();
    public TextPointer get_ContentEnd();
    internal TextRange get_TextRange();
    public LineBreakCondition get_BreakBefore();
    public LineBreakCondition get_BreakAfter();
    public Typography get_Typography();
    public double get_BaselineOffset();
    public void set_BaselineOffset(double value);
    public static void SetBaselineOffset(DependencyObject element, double value);
    public static double GetBaselineOffset(DependencyObject element);
    public string get_Text();
    public void set_Text(string value);
    private static object CoerceText(DependencyObject d, object value);
    public FontFamily get_FontFamily();
    public void set_FontFamily(FontFamily value);
    public static void SetFontFamily(DependencyObject element, FontFamily value);
    public static FontFamily GetFontFamily(DependencyObject element);
    public FontStyle get_FontStyle();
    public void set_FontStyle(FontStyle value);
    public static void SetFontStyle(DependencyObject element, FontStyle value);
    public static FontStyle GetFontStyle(DependencyObject element);
    public FontWeight get_FontWeight();
    public void set_FontWeight(FontWeight value);
    public static void SetFontWeight(DependencyObject element, FontWeight value);
    public static FontWeight GetFontWeight(DependencyObject element);
    public FontStretch get_FontStretch();
    public void set_FontStretch(FontStretch value);
    public static void SetFontStretch(DependencyObject element, FontStretch value);
    public static FontStretch GetFontStretch(DependencyObject element);
    public double get_FontSize();
    public void set_FontSize(double value);
    public static void SetFontSize(DependencyObject element, double value);
    [TypeConverterAttribute("System.Windows.FontSizeConverter")]
public static double GetFontSize(DependencyObject element);
    public Brush get_Foreground();
    public void set_Foreground(Brush value);
    public static void SetForeground(DependencyObject element, Brush value);
    public static Brush GetForeground(DependencyObject element);
    public Brush get_Background();
    public void set_Background(Brush value);
    public TextDecorationCollection get_TextDecorations();
    public void set_TextDecorations(TextDecorationCollection value);
    public TextEffectCollection get_TextEffects();
    public void set_TextEffects(TextEffectCollection value);
    public double get_LineHeight();
    public void set_LineHeight(double value);
    public static void SetLineHeight(DependencyObject element, double value);
    [TypeConverterAttribute("System.Windows.LengthConverter")]
public static double GetLineHeight(DependencyObject element);
    public LineStackingStrategy get_LineStackingStrategy();
    public void set_LineStackingStrategy(LineStackingStrategy value);
    public static void SetLineStackingStrategy(DependencyObject element, LineStackingStrategy value);
    public static LineStackingStrategy GetLineStackingStrategy(DependencyObject element);
    public Thickness get_Padding();
    public void set_Padding(Thickness value);
    public TextAlignment get_TextAlignment();
    public void set_TextAlignment(TextAlignment value);
    public static void SetTextAlignment(DependencyObject element, TextAlignment value);
    public static TextAlignment GetTextAlignment(DependencyObject element);
    public TextTrimming get_TextTrimming();
    public void set_TextTrimming(TextTrimming value);
    public TextWrapping get_TextWrapping();
    public void set_TextWrapping(TextWrapping value);
    public bool get_IsHyphenationEnabled();
    public void set_IsHyphenationEnabled(bool value);
    protected virtual int get_VisualChildrenCount();
    protected virtual Visual GetVisualChild(int index);
    protected sealed virtual Size MeasureOverride(Size constraint);
    protected sealed virtual Size ArrangeOverride(Size arrangeSize);
    protected sealed virtual void OnRender(DrawingContext ctx);
    protected sealed virtual void OnPropertyChanged(DependencyPropertyChangedEventArgs e);
    protected sealed virtual HitTestResult HitTestCore(PointHitTestParameters hitTestParameters);
    protected virtual IInputElement InputHitTestCore(Point point);
    protected virtual ReadOnlyCollection`1<Rect> GetRectanglesCore(ContentElement child);
    protected virtual IEnumerator`1<IInputElement> get_HostedElementsCore();
    protected virtual void OnChildDesiredSizeChangedCore(UIElement child);
    protected virtual AutomationPeer OnCreateAutomationPeer();
    internal void RemoveChild(Visual child);
    internal void SetTextContainer(ITextContainer textContainer);
    internal Size MeasureChild(InlineObject inlineObject);
    internal virtual string GetPlainText();
    internal ReadOnlyCollection`1<LineResult> GetLineResults();
    internal void GetLineDetails(int dcp, int index, double lineVOffset, Int32& cchContent, Int32& cchEllipses);
    internal ITextPointer GetTextPositionFromDistance(int dcp, double distance, double lineVOffset, int index);
    internal Rect GetRectangleFromTextPosition(ITextPointer orientedPosition);
    internal Geometry GetTightBoundingGeometryFromTextPositions(ITextPointer startPosition, ITextPointer endPosition);
    internal bool IsAtCaretUnitBoundary(ITextPointer position, int dcp, int lineIndex);
    internal ITextPointer GetNextCaretUnitPosition(ITextPointer position, LogicalDirection direction, int dcp, int lineIndex);
    internal ITextPointer GetBackspaceCaretUnitPosition(ITextPointer position, int dcp, int lineIndex);
    internal TextFormatter get_TextFormatter();
    internal ITextContainer get_TextContainer();
    internal ITextView get_TextView();
    internal Highlights get_Highlights();
    internal LineProperties get_ParagraphProperties();
    internal bool get_IsLayoutDataValid();
    internal bool get_HasComplexContent();
    internal bool get_IsTypographyDefaultValue();
    private ArrayList get_InlineObjects();
    private void set_InlineObjects(ArrayList value);
    internal bool get_IsContentPresenterContainer();
    internal void set_IsContentPresenterContainer(bool value);
    private static void OnTypographyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private object OnValidateTextView(object arg);
    private static void InsertTextRun(ITextPointer position, string text, bool whitespacesIgnorable);
    private Line CreateLine(LineProperties lineProperties);
    private void EnsureComplexContent();
    private void EnsureComplexContent(ITextContainer textContainer);
    private void ClearComplexContent();
    private void OnHighlightChanged(object sender, HighlightChangedEventArgs args);
    private void OnTextContainerChanging(object sender, EventArgs args);
    private void OnTextContainerChange(object sender, TextContainerChangeEventArgs args);
    private void EnsureTextBlockCache();
    private LineProperties GetLineProperties();
    private TextParagraphProperties GetLineProperties(bool firstLine, LineProperties lineProperties);
    private TextParagraphProperties GetLineProperties(bool firstLine, bool showParagraphEllipsis, LineProperties lineProperties);
    private double CalcLineAdvance(double lineHeight, LineProperties lineProperties);
    private Vector CalcContentOffset(Size computedSize, double wrappingWidth);
    private bool ParagraphEllipsisShownOnLine(int lineIndex, double lineVOffset);
    private double CalcWrappingWidth(double width);
    private void Format(Line line, int length, int dcp, double wrappingWidth, TextParagraphProperties paragraphProperties, TextLineBreak textLineBreak, TextRunCache textRunCache, bool ellipsis);
    private void VerifyTreeIsUnlocked();
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeText();
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeInlines(XamlDesignerSerializationManager manager);
    private void AlignContent();
    private static void OnRequestBringIntoView(object sender, RequestBringIntoViewEventArgs args);
    private static bool ContainsContentElement(TextBlock textBlock, ContentElement element);
    private int get_LineCount();
    private LineMetrics GetLine(int index);
    private LineMetrics UpdateLine(int index, LineMetrics metrics, double start, double width);
    private void SetFlags(bool value, Flags flags);
    private bool CheckFlags(Flags flags);
    private void VerifyReentrancy();
    private int GetLineIndexFromDcp(int dcpLine);
    private TextPointer FindElementPosition(IInputElement e);
    internal void OnChildBaselineOffsetChanged(DependencyObject source);
    private static void OnBaselineOffsetChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private void InitializeTextContainerListeners();
    private void ClearLineMetrics();
    private NaturalLanguageHyphenator EnsureHyphenator();
    private static bool IsValidTextTrimming(object o);
    private static bool IsValidTextWrap(object o);
    private static object CoerceBaselineOffset(DependencyObject d, object value);
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeBaselineOffset();
    private static void OnTextChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void OnTextChanged(DependencyObject d, string newText);
    internal virtual int get_EffectiveValuesInitialSize();
}
internal class System.Windows.Controls.TextBlockCache : object {
    public LineProperties _lineProperties;
    public TextRunCache _textRunCache;
}
[LocalizabilityAttribute("1")]
[ContentPropertyAttribute("Text")]
public class System.Windows.Controls.TextBox : TextBoxBase {
    public static DependencyProperty TextWrappingProperty;
    public static DependencyProperty MinLinesProperty;
    public static DependencyProperty MaxLinesProperty;
    public static DependencyProperty TextProperty;
    public static DependencyProperty CharacterCasingProperty;
    public static DependencyProperty MaxLengthProperty;
    public static DependencyProperty TextAlignmentProperty;
    public static DependencyProperty TextDecorationsProperty;
    private static DependencyObjectType _dType;
    private bool _minmaxChanged;
    private bool _isInsideTextContentChange;
    private object _newTextValue;
    private bool _isTypographySet;
    private int _changeEventNestingCount;
    public TextWrapping TextWrapping { get; public set; }
    [DefaultValueAttribute("1")]
public int MinLines { get; public set; }
    [DefaultValueAttribute("2147483647")]
public int MaxLines { get; public set; }
    [DefaultValueAttribute("")]
[LocalizabilityAttribute("1")]
public string Text { get; public set; }
    public CharacterCasing CharacterCasing { get; public set; }
    [DefaultValueAttribute("0")]
[LocalizabilityAttribute("0")]
public int MaxLength { get; public set; }
    public TextAlignment TextAlignment { get; public set; }
    [DesignerSerializationVisibilityAttribute("0")]
public string SelectedText { get; public set; }
    [DefaultValueAttribute("0")]
[DesignerSerializationVisibilityAttribute("0")]
public int SelectionLength { get; public set; }
    [DefaultValueAttribute("0")]
[DesignerSerializationVisibilityAttribute("0")]
public int SelectionStart { get; public set; }
    [DesignerSerializationVisibilityAttribute("0")]
public int CaretIndex { get; public set; }
    [DesignerSerializationVisibilityAttribute("0")]
public int LineCount { get; }
    public TextDecorationCollection TextDecorations { get; public set; }
    public Typography Typography { get; }
    protected internal IEnumerator LogicalChildren { get; }
    internal DependencyObjectType DTypeThemeStyleKey { get; }
    internal int EffectiveValuesInitialSize { get; }
    internal TextSelection Selection { get; }
    internal TextPointer StartPosition { get; }
    internal TextPointer EndPosition { get; }
    internal bool IsTypographyDefaultValue { get; }
    private ITextContainer System.Windows.Controls.ITextBoxViewHost.TextContainer { get; }
    private bool System.Windows.Controls.ITextBoxViewHost.IsTypographyDefaultValue { get; }
    private static TextBox();
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object value);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string text);
    public void Select(int start, int length);
    public void Clear();
    public int GetCharacterIndexFromPoint(Point point, bool snapToText);
    public int GetCharacterIndexFromLineIndex(int lineIndex);
    public int GetLineIndexFromCharacterIndex(int charIndex);
    public int GetLineLength(int lineIndex);
    public int GetFirstVisibleLineIndex();
    public int GetLastVisibleLineIndex();
    public void ScrollToLine(int lineIndex);
    public string GetLineText(int lineIndex);
    public Rect GetRectFromCharacterIndex(int charIndex);
    public Rect GetRectFromCharacterIndex(int charIndex, bool trailingEdge);
    public SpellingError GetSpellingError(int charIndex);
    public int GetSpellingErrorStart(int charIndex);
    public int GetSpellingErrorLength(int charIndex);
    public int GetNextSpellingErrorCharacterIndex(int charIndex, LogicalDirection direction);
    public TextWrapping get_TextWrapping();
    public void set_TextWrapping(TextWrapping value);
    public int get_MinLines();
    public void set_MinLines(int value);
    public int get_MaxLines();
    public void set_MaxLines(int value);
    public string get_Text();
    public void set_Text(string value);
    public CharacterCasing get_CharacterCasing();
    public void set_CharacterCasing(CharacterCasing value);
    public int get_MaxLength();
    public void set_MaxLength(int value);
    public TextAlignment get_TextAlignment();
    public void set_TextAlignment(TextAlignment value);
    public string get_SelectedText();
    public void set_SelectedText(string value);
    public int get_SelectionLength();
    public void set_SelectionLength(int value);
    public int get_SelectionStart();
    public void set_SelectionStart(int value);
    public int get_CaretIndex();
    public void set_CaretIndex(int value);
    public int get_LineCount();
    public TextDecorationCollection get_TextDecorations();
    public void set_TextDecorations(TextDecorationCollection value);
    public Typography get_Typography();
    protected virtual AutomationPeer OnCreateAutomationPeer();
    protected virtual void OnPropertyChanged(DependencyPropertyChangedEventArgs e);
    protected internal virtual IEnumerator get_LogicalChildren();
    protected virtual Size MeasureOverride(Size constraint);
    internal void OnTextWrappingChanged();
    internal virtual FrameworkElement CreateRenderScope();
    internal virtual void AttachToVisualTree();
    internal virtual string GetPlainText();
    internal virtual DependencyObjectType get_DTypeThemeStyleKey();
    internal virtual void DoLineUp();
    internal virtual void DoLineDown();
    internal virtual void OnTextContainerChanged(object sender, TextContainerChangedEventArgs e);
    internal void OnDeferredTextReferenceResolved(DeferredTextReference dtr, string s);
    internal virtual void OnScrollChanged(object sender, ScrollChangedEventArgs e);
    internal void RaiseCourtesyTextChangedEvent();
    internal virtual int get_EffectiveValuesInitialSize();
    internal TextSelection get_Selection();
    internal TextPointer get_StartPosition();
    internal TextPointer get_EndPosition();
    internal bool get_IsTypographyDefaultValue();
    private sealed virtual override ITextContainer System.Windows.Controls.ITextBoxViewHost.get_TextContainer();
    private sealed virtual override bool System.Windows.Controls.ITextBoxViewHost.get_IsTypographyDefaultValue();
    private bool GetRectangleFromTextPositionInternal(TextPointer position, bool relativeToTextBox, Rect& rect);
    private TextPointer GetStartPositionOfLine(int lineIndex);
    private TextPointer GetEndPositionOfLine(int lineIndex);
    private static object CoerceHorizontalScrollBarVisibility(DependencyObject d, object value);
    private static bool MaxLengthValidateValue(object value);
    private static bool CharacterCasingValidateValue(object value);
    private static bool MinLinesValidateValue(object value);
    private static bool MaxLinesValidateValue(object value);
    private static void OnMinMaxChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void OnTextPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private void OnTextPropertyChanged(string oldText, string newText);
    private int ChooseCaretIndex(int oldIndex, string oldText, string newText);
    private static void OnTextWrappingChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private void SetScrollViewerMinMaxHeight();
    private void SetRenderScopeMinMaxHeight();
    private double GetLineHeight();
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeText(XamlDesignerSerializationManager manager);
    private static void OnQueryScrollCommand(object target, CanExecuteRoutedEventArgs args);
    private static object CoerceText(DependencyObject d, object value);
    private static void OnTypographyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
}
internal class System.Windows.Controls.TextBoxLine : TextSource {
    private TextBoxView _owner;
    private TextLine _line;
    private int _dcp;
    private LineProperties _lineProperties;
    private TextProperties _spellerErrorProperties;
    private double _paragraphWidth;
    private static int _syntheticCharacterLength;
    internal double Width { get; }
    internal double Height { get; }
    internal bool EndOfParagraph { get; }
    internal int Length { get; }
    internal int ContentLength { get; }
    internal bool HasLineBreak { get; }
    private bool IsXOffsetAdjusted { get; }
    private bool IsWidthAdjusted { get; }
    internal TextBoxLine(TextBoxView owner);
    public sealed virtual void Dispose();
    public virtual TextRun GetTextRun(int dcp);
    public virtual TextSpan`1<CultureSpecificCharacterBufferRange> GetPrecedingText(int dcp);
    public virtual int GetTextEffectCharacterIndexFromTextSourceCharacterIndex(int textSourceCharacterIndex);
    internal void Format(int dcp, double formatWidth, double paragraphWidth, LineProperties lineProperties, TextRunCache textRunCache, TextFormatter formatter);
    internal TextBoxLineDrawingVisual CreateVisual(Geometry selectionGeometry);
    internal Rect GetBoundsFromTextPosition(int characterIndex, FlowDirection& flowDirection);
    internal List`1<Rect> GetRangeBounds(int cp, int cch, double xOffset, double yOffset);
    internal CharacterHit GetTextPositionFromDistance(double distance);
    internal CharacterHit GetNextCaretCharacterHit(CharacterHit index);
    internal CharacterHit GetPreviousCaretCharacterHit(CharacterHit index);
    internal CharacterHit GetBackspaceCaretCharacterHit(CharacterHit index);
    internal bool IsAtCaretCharacterHit(CharacterHit charHit);
    internal double get_Width();
    internal double get_Height();
    internal bool get_EndOfParagraph();
    internal int get_Length();
    internal int get_ContentLength();
    internal bool get_HasLineBreak();
    private TextRun HandleText(StaticTextPointer position);
    private Rect GetBoundsFromPosition(int cp, int cch, FlowDirection& flowDirection);
    private double CalculateXOffsetShift();
    private bool get_IsXOffsetAdjusted();
    private bool get_IsWidthAdjusted();
}
internal class System.Windows.Controls.TextBoxLineDrawingVisual : DrawingVisual {
    [CompilerGeneratedAttribute]
private bool <DiscardOnArrange>k__BackingField;
    internal bool DiscardOnArrange { get; internal set; }
    [CompilerGeneratedAttribute]
internal bool get_DiscardOnArrange();
    [CompilerGeneratedAttribute]
internal void set_DiscardOnArrange(bool value);
}
internal class System.Windows.Controls.TextBoxView : FrameworkElement {
    private ITextBoxViewHost _host;
    private Size _contentSize;
    private Size _previousConstraint;
    private TextCache _cache;
    private double _lineHeight;
    private List`1<TextBoxLineDrawingVisual> _visualChildren;
    private List`1<LineRecord> _lineMetrics;
    private List`1<TextBoxLineDrawingVisual> _viewportLineVisuals;
    private int _viewportLineVisualsIndex;
    private ScrollData _scrollData;
    private DtrList _dirtyList;
    private DispatcherTimer _throttleBackgroundTimer;
    private Flags _flags;
    private EventHandler UpdatedEvent;
    private static UInt32 _maxMeasureTimeMs;
    private static int _throttleBackgroundSeconds;
    private bool System.Windows.Controls.Primitives.IScrollInfo.CanVerticallyScroll { get; private set; }
    private bool System.Windows.Controls.Primitives.IScrollInfo.CanHorizontallyScroll { get; private set; }
    private double System.Windows.Controls.Primitives.IScrollInfo.ExtentWidth { get; }
    private double System.Windows.Controls.Primitives.IScrollInfo.ExtentHeight { get; }
    private double System.Windows.Controls.Primitives.IScrollInfo.ViewportWidth { get; }
    private double System.Windows.Controls.Primitives.IScrollInfo.ViewportHeight { get; }
    private double System.Windows.Controls.Primitives.IScrollInfo.HorizontalOffset { get; }
    private double System.Windows.Controls.Primitives.IScrollInfo.VerticalOffset { get; }
    private ScrollViewer System.Windows.Controls.Primitives.IScrollInfo.ScrollOwner { get; private set; }
    protected int VisualChildrenCount { get; }
    internal ITextBoxViewHost Host { get; }
    private UIElement System.Windows.Documents.ITextView.RenderScope { get; }
    private ITextContainer System.Windows.Documents.ITextView.TextContainer { get; }
    private bool System.Windows.Documents.ITextView.IsValid { get; }
    private bool System.Windows.Documents.ITextView.RendersOwnSelection { get; }
    private ReadOnlyCollection`1<TextSegment> System.Windows.Documents.ITextView.TextSegments { get; }
    private bool IsLayoutValid { get; }
    private Rect Viewport { get; }
    private bool IsBackgroundLayoutPending { get; }
    private double VerticalAlignmentOffset { get; }
    private TextAlignment CalculatedTextAlignment { get; }
    private double VerticalPadding { get; }
    private static TextBoxView();
    internal TextBoxView(ITextBoxViewHost host);
    private sealed virtual override object System.IServiceProvider.GetService(Type serviceType);
    private sealed virtual override void System.Windows.Controls.Primitives.IScrollInfo.LineUp();
    private sealed virtual override void System.Windows.Controls.Primitives.IScrollInfo.LineDown();
    private sealed virtual override void System.Windows.Controls.Primitives.IScrollInfo.LineLeft();
    private sealed virtual override void System.Windows.Controls.Primitives.IScrollInfo.LineRight();
    private sealed virtual override void System.Windows.Controls.Primitives.IScrollInfo.PageUp();
    private sealed virtual override void System.Windows.Controls.Primitives.IScrollInfo.PageDown();
    private sealed virtual override void System.Windows.Controls.Primitives.IScrollInfo.PageLeft();
    private sealed virtual override void System.Windows.Controls.Primitives.IScrollInfo.PageRight();
    private sealed virtual override void System.Windows.Controls.Primitives.IScrollInfo.MouseWheelUp();
    private sealed virtual override void System.Windows.Controls.Primitives.IScrollInfo.MouseWheelDown();
    private sealed virtual override void System.Windows.Controls.Primitives.IScrollInfo.MouseWheelLeft();
    private sealed virtual override void System.Windows.Controls.Primitives.IScrollInfo.MouseWheelRight();
    private sealed virtual override void System.Windows.Controls.Primitives.IScrollInfo.SetHorizontalOffset(double offset);
    private sealed virtual override void System.Windows.Controls.Primitives.IScrollInfo.SetVerticalOffset(double offset);
    private sealed virtual override Rect System.Windows.Controls.Primitives.IScrollInfo.MakeVisible(Visual visual, Rect rectangle);
    private sealed virtual override bool System.Windows.Controls.Primitives.IScrollInfo.get_CanVerticallyScroll();
    private sealed virtual override void System.Windows.Controls.Primitives.IScrollInfo.set_CanVerticallyScroll(bool value);
    private sealed virtual override bool System.Windows.Controls.Primitives.IScrollInfo.get_CanHorizontallyScroll();
    private sealed virtual override void System.Windows.Controls.Primitives.IScrollInfo.set_CanHorizontallyScroll(bool value);
    private sealed virtual override double System.Windows.Controls.Primitives.IScrollInfo.get_ExtentWidth();
    private sealed virtual override double System.Windows.Controls.Primitives.IScrollInfo.get_ExtentHeight();
    private sealed virtual override double System.Windows.Controls.Primitives.IScrollInfo.get_ViewportWidth();
    private sealed virtual override double System.Windows.Controls.Primitives.IScrollInfo.get_ViewportHeight();
    private sealed virtual override double System.Windows.Controls.Primitives.IScrollInfo.get_HorizontalOffset();
    private sealed virtual override double System.Windows.Controls.Primitives.IScrollInfo.get_VerticalOffset();
    private sealed virtual override ScrollViewer System.Windows.Controls.Primitives.IScrollInfo.get_ScrollOwner();
    private sealed virtual override void System.Windows.Controls.Primitives.IScrollInfo.set_ScrollOwner(ScrollViewer value);
    protected virtual Size MeasureOverride(Size constraint);
    protected virtual Size ArrangeOverride(Size arrangeSize);
    protected virtual void OnRender(DrawingContext context);
    protected virtual Visual GetVisualChild(int index);
    protected virtual int get_VisualChildrenCount();
    private sealed virtual override ITextPointer System.Windows.Documents.ITextView.GetTextPositionFromPoint(Point point, bool snapToText);
    private sealed virtual override Rect System.Windows.Documents.ITextView.GetRectangleFromTextPosition(ITextPointer position);
    private sealed virtual override Rect System.Windows.Documents.ITextView.GetRawRectangleFromTextPosition(ITextPointer position, Transform& transform);
    private sealed virtual override Geometry System.Windows.Documents.ITextView.GetTightBoundingGeometryFromTextPositions(ITextPointer startPosition, ITextPointer endPosition);
    private sealed virtual override ITextPointer System.Windows.Documents.ITextView.GetPositionAtNextLine(ITextPointer position, double suggestedX, int count, Double& newSuggestedX, Int32& linesMoved);
    private sealed virtual override ITextPointer System.Windows.Documents.ITextView.GetPositionAtNextPage(ITextPointer position, Point suggestedOffset, int count, Point& newSuggestedOffset, Int32& pagesMoved);
    private sealed virtual override bool System.Windows.Documents.ITextView.IsAtCaretUnitBoundary(ITextPointer position);
    private sealed virtual override ITextPointer System.Windows.Documents.ITextView.GetNextCaretUnitPosition(ITextPointer position, LogicalDirection direction);
    private sealed virtual override ITextPointer System.Windows.Documents.ITextView.GetBackspaceCaretUnitPosition(ITextPointer position);
    private sealed virtual override TextSegment System.Windows.Documents.ITextView.GetLineRange(ITextPointer position);
    private sealed virtual override ReadOnlyCollection`1<GlyphRun> System.Windows.Documents.ITextView.GetGlyphRuns(ITextPointer start, ITextPointer end);
    private sealed virtual override bool System.Windows.Documents.ITextView.Contains(ITextPointer position);
    private sealed virtual override void System.Windows.Documents.ITextView.BringPositionIntoViewAsync(ITextPointer position, object userState);
    private sealed virtual override void System.Windows.Documents.ITextView.BringPointIntoViewAsync(Point point, object userState);
    private sealed virtual override void System.Windows.Documents.ITextView.BringLineIntoViewAsync(ITextPointer position, double suggestedX, int count, object userState);
    private sealed virtual override void System.Windows.Documents.ITextView.BringPageIntoViewAsync(ITextPointer position, Point suggestedOffset, int count, object userState);
    private sealed virtual override void System.Windows.Documents.ITextView.CancelAsync(object userState);
    private sealed virtual override bool System.Windows.Documents.ITextView.Validate();
    private sealed virtual override bool System.Windows.Documents.ITextView.Validate(Point point);
    private sealed virtual override bool System.Windows.Documents.ITextView.Validate(ITextPointer position);
    private sealed virtual override void System.Windows.Documents.ITextView.ThrottleBackgroundTasksForUserInput();
    internal void Remeasure();
    internal void Rerender();
    internal int GetLineIndexFromOffset(int offset);
    internal void RemoveTextContainerListeners();
    internal ITextBoxViewHost get_Host();
    private sealed virtual override UIElement System.Windows.Documents.ITextView.get_RenderScope();
    private sealed virtual override ITextContainer System.Windows.Documents.ITextView.get_TextContainer();
    private sealed virtual override bool System.Windows.Documents.ITextView.get_IsValid();
    private sealed virtual override bool System.Windows.Documents.ITextView.get_RendersOwnSelection();
    private sealed virtual override ReadOnlyCollection`1<TextSegment> System.Windows.Documents.ITextView.get_TextSegments();
    private sealed virtual override void System.Windows.Documents.ITextView.add_BringPositionIntoViewCompleted(BringPositionIntoViewCompletedEventHandler value);
    private sealed virtual override void System.Windows.Documents.ITextView.remove_BringPositionIntoViewCompleted(BringPositionIntoViewCompletedEventHandler value);
    private sealed virtual override void System.Windows.Documents.ITextView.add_BringPointIntoViewCompleted(BringPointIntoViewCompletedEventHandler value);
    private sealed virtual override void System.Windows.Documents.ITextView.remove_BringPointIntoViewCompleted(BringPointIntoViewCompletedEventHandler value);
    private sealed virtual override void System.Windows.Documents.ITextView.add_BringLineIntoViewCompleted(BringLineIntoViewCompletedEventHandler value);
    private sealed virtual override void System.Windows.Documents.ITextView.remove_BringLineIntoViewCompleted(BringLineIntoViewCompletedEventHandler value);
    private sealed virtual override void System.Windows.Documents.ITextView.add_BringPageIntoViewCompleted(BringPageIntoViewCompletedEventHandler value);
    private sealed virtual override void System.Windows.Documents.ITextView.remove_BringPageIntoViewCompleted(BringPageIntoViewCompletedEventHandler value);
    private sealed virtual override void System.Windows.Documents.ITextView.add_Updated(EventHandler value);
    private sealed virtual override void System.Windows.Documents.ITextView.remove_Updated(EventHandler value);
    private void EnsureTextContainerListeners();
    private void EnsureCache();
    private LineProperties GetLineProperties();
    private void OnTextContainerChanging(object sender, EventArgs args);
    private void OnTextContainerChange(object sender, TextContainerChangeEventArgs args);
    private void OnHighlightChanged(object sender, HighlightChangedEventArgs args);
    private void HandleTextSelectionHighlightChange(DirtyTextRange currentSelectionRange, Boolean& arrangeNeeded, Boolean& measureNeeded);
    private void SetFlags(bool value, Flags flags);
    private bool CheckFlags(Flags flags);
    private void FireTextViewUpdatedEvent();
    private int GetLineIndexFromPoint(Point point, bool snapToText);
    private int GetLineIndexFromPosition(ITextPointer position);
    private int GetLineIndexFromPosition(ITextPointer position, LogicalDirection direction);
    private int GetLineIndexFromOffset(int offset, LogicalDirection direction);
    private TextBoxLine GetFormattedLine(int lineIndex);
    private TextBoxLine GetFormattedLine(int lineIndex, LineProperties& lineProperties);
    private ITextPointer GetTextPositionFromDistance(int lineIndex, double x);
    private void ArrangeScrollData(Size arrangeSize);
    private void ArrangeVisuals(Size arrangeSize);
    private void InvalidateDirtyVisuals();
    private void DetachDiscardedVisualChildren();
    private void AttachVisualChild(TextBoxLineDrawingVisual lineVisual);
    private void ClearVisualChildren();
    private Point TransformToDocumentSpace(Point point);
    private Rect TransformToVisualSpace(Rect rect);
    private void GetTightBoundingGeometryFromLineIndex(int lineIndex, int unclippedStartOffset, int unclippedEndOffset, TextAlignment alignment, double endOfParaGlyphWidth, Geometry& geometry);
    private void GetTightBoundingGeometryFromLineIndexForSelection(TextBoxLine line, int lineIndex, int unclippedStartOffset, int unclippedEndOffset, TextAlignment alignment, double endOfParaGlyphWidth, Geometry& geometry);
    private void GetVisibleLines(Int32& firstLineIndex, Int32& lastLineIndex);
    private Size FullMeasureTick(double constraintWidth, LineProperties lineProperties);
    private object OnBackgroundMeasure(object o);
    private Size IncrementalMeasure(double constraintWidth, LineProperties lineProperties);
    private void IncrementalMeasureLinesAfterInsert(double constraintWidth, LineProperties lineProperties, DirtyTextRange range, Size& desiredSize);
    private void IncrementalMeasureLinesAfterDelete(double constraintWidth, LineProperties lineProperties, DirtyTextRange range, Size& desiredSize);
    private void FormatFirstIncrementalLine(int lineIndex, double constraintWidth, LineProperties lineProperties, TextBoxLine line, Int32& lineOffset, Boolean& endOfParagraph);
    private void SyncLineMetrics(DirtyTextRange range, double constraintWidth, LineProperties lineProperties, TextBoxLine line, bool endOfParagraph, int lineIndex, int lineOffset);
    private Size BruteForceCalculateDesiredSize();
    private void SetViewportLines(int firstLineIndex, int lastLineIndex);
    private TextBoxLineDrawingVisual GetLineVisual(int lineIndex);
    private void SetLineVisual(int lineIndex, TextBoxLineDrawingVisual lineVisual);
    private void AddLineVisualPlaceholder(int lineIndex);
    private void ClearLineVisual(int lineIndex);
    private void RemoveLineVisualRange(int lineIndex, int count);
    private void OnThrottleBackgroundTimeout(object sender, EventArgs e);
    private double GetContentOffset(double lineWidth, TextAlignment aligment);
    private TextAlignment HorizontalAlignmentToTextAlignment(HorizontalAlignment horizontalAlignment);
    private bool Contains(ITextPointer position);
    private double GetWrappingWidth(double width);
    private double GetTextAlignmentCorrection(TextAlignment textAlignment, double width);
    private Nullable`1<DirtyTextRange> GetSelectionRenderRange(DirtyTextRange selectionRange);
    private bool get_IsLayoutValid();
    private Rect get_Viewport();
    private bool get_IsBackgroundLayoutPending();
    private double get_VerticalAlignmentOffset();
    private TextAlignment get_CalculatedTextAlignment();
    private double get_VerticalPadding();
}
public class System.Windows.Controls.TextChange : object {
    private int _offset;
    private int _addedLength;
    private int _removedLength;
    public int Offset { get; internal set; }
    public int AddedLength { get; internal set; }
    public int RemovedLength { get; internal set; }
    public int get_Offset();
    internal void set_Offset(int value);
    public int get_AddedLength();
    internal void set_AddedLength(int value);
    public int get_RemovedLength();
    internal void set_RemovedLength(int value);
}
public class System.Windows.Controls.TextChangedEventArgs : RoutedEventArgs {
    private UndoAction _undoAction;
    private ICollection`1<TextChange> _changes;
    public UndoAction UndoAction { get; }
    public ICollection`1<TextChange> Changes { get; }
    public TextChangedEventArgs(RoutedEvent id, UndoAction action, ICollection`1<TextChange> changes);
    public TextChangedEventArgs(RoutedEvent id, UndoAction action);
    public UndoAction get_UndoAction();
    public ICollection`1<TextChange> get_Changes();
    protected virtual void InvokeEventHandler(Delegate genericHandler, object genericTarget);
}
public class System.Windows.Controls.TextChangedEventHandler : MulticastDelegate {
    public TextChangedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, TextChangedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, TextChangedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Windows.Controls.TextSearch : DependencyObject {
    public static DependencyProperty TextPathProperty;
    public static DependencyProperty TextProperty;
    private static DependencyProperty CurrentPrefixProperty;
    private static DependencyProperty IsActiveProperty;
    private static DependencyPropertyKey TextSearchInstancePropertyKey;
    private static DependencyProperty TextSearchInstanceProperty;
    private static BindingExpressionUncommonField TextValueBindingExpression;
    private ItemsControl _attachedTo;
    private string _prefix;
    private List`1<string> _charsEntered;
    private bool _isActive;
    private int _matchedItemIndex;
    private DispatcherTimer _timeoutTimer;
    private TimeSpan TimeOut { get; }
    private string Prefix { get; private set; }
    private bool IsActive { get; private set; }
    private int MatchedItemIndex { get; private set; }
    private TextSearch(ItemsControl itemsControl);
    private static TextSearch();
    internal static TextSearch EnsureInstance(ItemsControl itemsControl);
    public static void SetTextPath(DependencyObject element, string path);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static string GetTextPath(DependencyObject element);
    public static void SetText(DependencyObject element, string text);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static string GetText(DependencyObject element);
    internal bool DoSearch(string nextChar);
    internal bool DeleteLastCharacter();
    private static void GetMatchingPrefixAndRemainingTextLength(string matchedText, string newText, CultureInfo cultureInfo, bool ignoreCase, Int32& matchedPrefixLength, Int32& textExcludingPrefixLength);
    private static int FindMatchingPrefix(ItemsControl itemsControl, string primaryTextPath, string prefix, string newChar, int startItemIndex, bool lookForFallbackMatchToo, Boolean& wasNewCharUsed);
    internal static MatchedTextInfo FindMatchingPrefix(ItemsControl itemsControl, string prefix);
    private void ResetTimeout();
    private void AddCharToPrefix(string newChar);
    private static string GetPrimaryTextPath(ItemsControl itemsControl);
    private static string GetPrimaryText(object item, BindingExpression primaryTextBinding, DependencyObject primaryTextBindingHome);
    private static string ConvertToPlainText(object o);
    internal static string GetPrimaryTextFromItem(ItemsControl itemsControl, object item);
    private static BindingExpression CreateBindingExpression(ItemsControl itemsControl, object item, string primaryTextPath);
    private void OnTimeout(object sender, EventArgs e);
    private void ResetState();
    private TimeSpan get_TimeOut();
    private static TextSearch GetInstance(DependencyObject d);
    private void TypeAKey(string c);
    private void CauseTimeOut();
    internal string GetCurrentPrefix();
    internal static string GetPrimaryText(FrameworkElement element);
    private string get_Prefix();
    private void set_Prefix(string value);
    private bool get_IsActive();
    private void set_IsActive(bool value);
    private int get_MatchedItemIndex();
    private void set_MatchedItemIndex(int value);
    private static CultureInfo GetCulture(DependencyObject element);
}
[TemplatePartAttribute]
[TemplatePartAttribute]
public class System.Windows.Controls.ToolBar : HeaderedItemsControl {
    private static DependencyPropertyKey OrientationPropertyKey;
    public static DependencyProperty OrientationProperty;
    public static DependencyProperty BandProperty;
    public static DependencyProperty BandIndexProperty;
    public static DependencyProperty IsOverflowOpenProperty;
    internal static DependencyPropertyKey HasOverflowItemsPropertyKey;
    public static DependencyProperty HasOverflowItemsProperty;
    internal static DependencyPropertyKey IsOverflowItemPropertyKey;
    public static DependencyProperty IsOverflowItemProperty;
    public static DependencyProperty OverflowModeProperty;
    private ToolBarPanel _toolBarPanel;
    private ToolBarOverflowPanel _toolBarOverflowPanel;
    private static string ToolBarPanelTemplateName;
    private static string ToolBarOverflowPanelTemplateName;
    private double _minLength;
    private double _maxLength;
    private static DependencyObjectType _dType;
    public Orientation Orientation { get; }
    public int Band { get; public set; }
    public int BandIndex { get; public set; }
    [BindableAttribute("True")]
[BrowsableAttribute("False")]
[CategoryAttribute("Appearance")]
[DesignerSerializationVisibilityAttribute("0")]
public bool IsOverflowOpen { get; public set; }
    public bool HasOverflowItems { get; }
    internal ToolBarPanel ToolBarPanel { get; }
    internal ToolBarOverflowPanel ToolBarOverflowPanel { get; }
    private ToolBarTray ToolBarTray { get; }
    internal double MinLength { get; }
    internal double MaxLength { get; }
    internal DependencyObjectType DTypeThemeStyleKey { get; }
    public static ResourceKey ButtonStyleKey { get; }
    public static ResourceKey ToggleButtonStyleKey { get; }
    public static ResourceKey SeparatorStyleKey { get; }
    public static ResourceKey CheckBoxStyleKey { get; }
    public static ResourceKey RadioButtonStyleKey { get; }
    public static ResourceKey ComboBoxStyleKey { get; }
    public static ResourceKey TextBoxStyleKey { get; }
    public static ResourceKey MenuStyleKey { get; }
    private static ToolBar();
    private static object CoerceOrientation(DependencyObject d, object value);
    public Orientation get_Orientation();
    public int get_Band();
    public void set_Band(int value);
    public int get_BandIndex();
    public void set_BandIndex(int value);
    public bool get_IsOverflowOpen();
    public void set_IsOverflowOpen(bool value);
    private static object CoerceIsOverflowOpen(DependencyObject d, object value);
    private static object CoerceToolTipIsEnabled(DependencyObject d, object value);
    private void RegisterToOpenOnLoad();
    private void OpenOnLoad(object sender, RoutedEventArgs e);
    private static void OnOverflowOpenChanged(DependencyObject element, DependencyPropertyChangedEventArgs e);
    private void SetFocusOnToolBarOverflowPanel();
    public bool get_HasOverflowItems();
    internal static void SetIsOverflowItem(DependencyObject element, object value);
    public static bool GetIsOverflowItem(DependencyObject element);
    private static void OnOverflowModeChanged(DependencyObject element, DependencyPropertyChangedEventArgs e);
    private void InvalidateLayout();
    private static bool IsValidOverflowMode(object o);
    public static void SetOverflowMode(DependencyObject element, OverflowMode mode);
    [AttachedPropertyBrowsableForChildrenAttribute]
public static OverflowMode GetOverflowMode(DependencyObject element);
    protected virtual AutomationPeer OnCreateAutomationPeer();
    protected virtual void PrepareContainerForItemOverride(DependencyObject element, object item);
    internal virtual void OnTemplateChangedInternal(FrameworkTemplate oldTemplate, FrameworkTemplate newTemplate);
    protected virtual void OnItemsChanged(NotifyCollectionChangedEventArgs e);
    protected virtual Size MeasureOverride(Size constraint);
    protected virtual void OnLostMouseCapture(MouseEventArgs e);
    internal ToolBarPanel get_ToolBarPanel();
    private ToolBarPanel FindToolBarPanel();
    internal ToolBarOverflowPanel get_ToolBarOverflowPanel();
    private ToolBarOverflowPanel FindToolBarOverflowPanel();
    protected virtual void OnKeyDown(KeyEventArgs e);
    private static void OnMouseButtonDown(object sender, MouseButtonEventArgs e);
    private static void _OnClick(object e, RoutedEventArgs args);
    internal virtual void OnAncestorChanged();
    private void Close();
    private ToolBarTray get_ToolBarTray();
    internal double get_MinLength();
    internal double get_MaxLength();
    internal virtual DependencyObjectType get_DTypeThemeStyleKey();
    public static ResourceKey get_ButtonStyleKey();
    public static ResourceKey get_ToggleButtonStyleKey();
    public static ResourceKey get_SeparatorStyleKey();
    public static ResourceKey get_CheckBoxStyleKey();
    public static ResourceKey get_RadioButtonStyleKey();
    public static ResourceKey get_ComboBoxStyleKey();
    public static ResourceKey get_TextBoxStyleKey();
    public static ResourceKey get_MenuStyleKey();
    [CompilerGeneratedAttribute]
private object <OpenOnLoad>b__22_0(object param);
    [CompilerGeneratedAttribute]
private object <SetFocusOnToolBarOverflowPanel>b__24_0(object param);
}
[ContentPropertyAttribute("ToolBars")]
public class System.Windows.Controls.ToolBarTray : FrameworkElement {
    public static DependencyProperty BackgroundProperty;
    public static DependencyProperty OrientationProperty;
    public static DependencyProperty IsLockedProperty;
    private List`1<BandInfo> _bands;
    private bool _bandsDirty;
    private ToolBarCollection _toolBarsCollection;
    private static DependencyObjectType _dType;
    public Brush Background { get; public set; }
    public Orientation Orientation { get; public set; }
    public bool IsLocked { get; public set; }
    [DesignerSerializationVisibilityAttribute("2")]
public Collection`1<ToolBar> ToolBars { get; }
    protected internal IEnumerator LogicalChildren { get; }
    protected int VisualChildrenCount { get; }
    internal DependencyObjectType DTypeThemeStyleKey { get; }
    private static ToolBarTray();
    public Brush get_Background();
    public void set_Background(Brush value);
    private static void OnOrientationPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public Orientation get_Orientation();
    public void set_Orientation(Orientation value);
    public bool get_IsLocked();
    public void set_IsLocked(bool value);
    public static void SetIsLocked(DependencyObject element, bool value);
    public static bool GetIsLocked(DependencyObject element);
    public Collection`1<ToolBar> get_ToolBars();
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object value);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string text);
    protected internal virtual IEnumerator get_LogicalChildren();
    protected virtual void OnRender(DrawingContext dc);
    protected virtual Size MeasureOverride(Size constraint);
    protected virtual Size ArrangeOverride(Size arrangeSize);
    protected virtual int get_VisualChildrenCount();
    protected virtual Visual GetVisualChild(int index);
    private static void OnThumbDragDelta(object sender, DragDeltaEventArgs e);
    private void ProcessThumbDragDelta(DragDeltaEventArgs e);
    private Point TransformPointToToolBar(ToolBar toolBar, Point point);
    private void ShrinkToolBars(List`1<ToolBar> band, int startIndex, int endIndex, double shrinkAmount);
    private double ToolBarsTotalMinimum(List`1<ToolBar> band, int startIndex, int endIndex);
    private void ExpandToolBars(List`1<ToolBar> band, int startIndex, int endIndex, double expandAmount);
    private double ToolBarsTotalMaximum(List`1<ToolBar> band, int startIndex, int endIndex);
    private void MoveToolBar(ToolBar toolBar, int newBandNumber, double position);
    private int GetBandFromOffset(double toolBarOffset);
    private void GenerateBands();
    private bool IsBandsDirty();
    private void InsertBand(ToolBar toolBar, int toolBarIndex);
    private BandInfo CreateBand(int startIndex);
    private void InsertToolBar(ToolBar toolBar, List`1<ToolBar> band);
    internal virtual DependencyObjectType get_DTypeThemeStyleKey();
}
[DefaultEventAttribute("Opened")]
[LocalizabilityAttribute("10")]
public class System.Windows.Controls.ToolTip : ContentControl {
    internal static DependencyProperty FromKeyboardProperty;
    public static DependencyProperty HorizontalOffsetProperty;
    public static DependencyProperty VerticalOffsetProperty;
    public static DependencyProperty IsOpenProperty;
    public static DependencyProperty HasDropShadowProperty;
    public static DependencyProperty PlacementTargetProperty;
    public static DependencyProperty PlacementRectangleProperty;
    public static DependencyProperty PlacementProperty;
    public static DependencyProperty CustomPopupPlacementCallbackProperty;
    public static DependencyProperty StaysOpenProperty;
    public static RoutedEvent OpenedEvent;
    public static RoutedEvent ClosedEvent;
    private Popup _parentPopup;
    private static DependencyObjectType _dType;
    [BindableAttribute("True")]
[CategoryAttribute("Behavior")]
internal bool FromKeyboard { get; internal set; }
    internal bool ShouldShowOnKeyboardFocus { get; }
    [TypeConverterAttribute("System.Windows.LengthConverter")]
[BindableAttribute("True")]
[CategoryAttribute("Layout")]
public double HorizontalOffset { get; public set; }
    [TypeConverterAttribute("System.Windows.LengthConverter")]
[BindableAttribute("True")]
[CategoryAttribute("Layout")]
public double VerticalOffset { get; public set; }
    [BindableAttribute("True")]
[BrowsableAttribute("False")]
[CategoryAttribute("Appearance")]
[DesignerSerializationVisibilityAttribute("0")]
public bool IsOpen { get; public set; }
    public bool HasDropShadow { get; public set; }
    [BindableAttribute("True")]
[CategoryAttribute("Layout")]
[DesignerSerializationVisibilityAttribute("0")]
public UIElement PlacementTarget { get; public set; }
    [CategoryAttribute("Layout")]
[BindableAttribute("True")]
public Rect PlacementRectangle { get; public set; }
    [BindableAttribute("True")]
[CategoryAttribute("Layout")]
public PlacementMode Placement { get; public set; }
    [BindableAttribute("False")]
[CategoryAttribute("Layout")]
public CustomPopupPlacementCallback CustomPopupPlacementCallback { get; public set; }
    [BindableAttribute("True")]
[CategoryAttribute("Behavior")]
public bool StaysOpen { get; public set; }
    internal DependencyObjectType DTypeThemeStyleKey { get; }
    private static ToolTip();
    internal bool get_FromKeyboard();
    internal void set_FromKeyboard(bool value);
    internal virtual bool get_ShouldShowOnKeyboardFocus();
    private static object CoerceHorizontalOffset(DependencyObject d, object value);
    public double get_HorizontalOffset();
    public void set_HorizontalOffset(double value);
    private static object CoerceVerticalOffset(DependencyObject d, object value);
    public double get_VerticalOffset();
    public void set_VerticalOffset(double value);
    private static void OnIsOpenChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public bool get_IsOpen();
    public void set_IsOpen(bool value);
    private static object CoerceHasDropShadow(DependencyObject d, object value);
    public bool get_HasDropShadow();
    public void set_HasDropShadow(bool value);
    private static object CoercePlacementTarget(DependencyObject d, object value);
    public UIElement get_PlacementTarget();
    public void set_PlacementTarget(UIElement value);
    private static object CoercePlacementRectangle(DependencyObject d, object value);
    public Rect get_PlacementRectangle();
    public void set_PlacementRectangle(Rect value);
    private static object CoercePlacement(DependencyObject d, object value);
    public PlacementMode get_Placement();
    public void set_Placement(PlacementMode value);
    public CustomPopupPlacementCallback get_CustomPopupPlacementCallback();
    public void set_CustomPopupPlacementCallback(CustomPopupPlacementCallback value);
    public bool get_StaysOpen();
    public void set_StaysOpen(bool value);
    public void add_Opened(RoutedEventHandler value);
    public void remove_Opened(RoutedEventHandler value);
    protected virtual void OnOpened(RoutedEventArgs e);
    public void add_Closed(RoutedEventHandler value);
    public void remove_Closed(RoutedEventHandler value);
    protected virtual void OnClosed(RoutedEventArgs e);
    internal virtual void ChangeVisualState(bool useTransitions);
    protected virtual AutomationPeer OnCreateAutomationPeer();
    protected internal virtual void OnVisualParentChanged(DependencyObject oldParent);
    internal virtual void OnAncestorChanged();
    protected virtual void OnContentChanged(object oldContent, object newContent);
    private void HookupParentPopup();
    internal void ForceClose();
    private void OnPopupCouldClose(object sender, EventArgs e);
    private void OnPopupOpened(object source, EventArgs e);
    private void OnPopupClosed(object source, EventArgs e);
    internal virtual DependencyObjectType get_DTypeThemeStyleKey();
}
public class System.Windows.Controls.ToolTipEventArgs : RoutedEventArgs {
    internal ToolTipEventArgs(bool opening);
    protected virtual void InvokeEventHandler(Delegate genericHandler, object genericTarget);
}
public class System.Windows.Controls.ToolTipEventHandler : MulticastDelegate {
    public ToolTipEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, ToolTipEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, ToolTipEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public static class System.Windows.Controls.ToolTipService : object {
    public static DependencyProperty ToolTipProperty;
    public static DependencyProperty HorizontalOffsetProperty;
    public static DependencyProperty VerticalOffsetProperty;
    public static DependencyProperty HasDropShadowProperty;
    public static DependencyProperty PlacementTargetProperty;
    public static DependencyProperty PlacementRectangleProperty;
    public static DependencyProperty PlacementProperty;
    public static DependencyProperty ShowOnDisabledProperty;
    private static DependencyPropertyKey IsOpenPropertyKey;
    public static DependencyProperty IsOpenProperty;
    public static DependencyProperty IsEnabledProperty;
    public static DependencyProperty ShowDurationProperty;
    public static DependencyProperty InitialShowDelayProperty;
    public static DependencyProperty BetweenShowDelayProperty;
    public static RoutedEvent ToolTipOpeningEvent;
    public static RoutedEvent ToolTipClosingEvent;
    internal static RoutedEvent FindToolTipEvent;
    private static ToolTipService();
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static object GetToolTip(DependencyObject element);
    public static void SetToolTip(DependencyObject element, object value);
    [TypeConverterAttribute("System.Windows.LengthConverter")]
[AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static double GetHorizontalOffset(DependencyObject element);
    public static void SetHorizontalOffset(DependencyObject element, double value);
    [TypeConverterAttribute("System.Windows.LengthConverter")]
[AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static double GetVerticalOffset(DependencyObject element);
    public static void SetVerticalOffset(DependencyObject element, double value);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static bool GetHasDropShadow(DependencyObject element);
    public static void SetHasDropShadow(DependencyObject element, bool value);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static UIElement GetPlacementTarget(DependencyObject element);
    public static void SetPlacementTarget(DependencyObject element, UIElement value);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static Rect GetPlacementRectangle(DependencyObject element);
    public static void SetPlacementRectangle(DependencyObject element, Rect value);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static PlacementMode GetPlacement(DependencyObject element);
    public static void SetPlacement(DependencyObject element, PlacementMode value);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static bool GetShowOnDisabled(DependencyObject element);
    public static void SetShowOnDisabled(DependencyObject element, bool value);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static bool GetIsOpen(DependencyObject element);
    private static void SetIsOpen(DependencyObject element, bool value);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static bool GetIsEnabled(DependencyObject element);
    public static void SetIsEnabled(DependencyObject element, bool value);
    private static bool PositiveValueValidation(object o);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static int GetShowDuration(DependencyObject element);
    public static void SetShowDuration(DependencyObject element, int value);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static int GetInitialShowDelay(DependencyObject element);
    public static void SetInitialShowDelay(DependencyObject element, int value);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static int GetBetweenShowDelay(DependencyObject element);
    public static void SetBetweenShowDelay(DependencyObject element, int value);
    public static void AddToolTipOpeningHandler(DependencyObject element, ToolTipEventHandler handler);
    public static void RemoveToolTipOpeningHandler(DependencyObject element, ToolTipEventHandler handler);
    public static void AddToolTipClosingHandler(DependencyObject element, ToolTipEventHandler handler);
    public static void RemoveToolTipClosingHandler(DependencyObject element, ToolTipEventHandler handler);
    private static void OnFindToolTip(object sender, FindToolTipEventArgs e);
    private static bool ToolTipIsEnabled(DependencyObject o, ToolTipTrigger triggerAction);
}
[StyleTypedPropertyAttribute]
public class System.Windows.Controls.TreeView : ItemsControl {
    private static DependencyPropertyKey SelectedItemPropertyKey;
    public static DependencyProperty SelectedItemProperty;
    private static DependencyPropertyKey SelectedValuePropertyKey;
    public static DependencyProperty SelectedValueProperty;
    public static DependencyProperty SelectedValuePathProperty;
    public static RoutedEvent SelectedItemChangedEvent;
    private static DependencyObjectType _dType;
    private BitVector32 _bits;
    private TreeViewItem _selectedContainer;
    private static BindingExpressionUncommonField SelectedValuePathBindingExpression;
    private EventHandler _focusEnterMainFocusScopeEventHandler;
    [BindableAttribute("True")]
[CategoryAttribute("Appearance")]
[ReadOnlyAttribute("True")]
[DesignerSerializationVisibilityAttribute("0")]
public object SelectedItem { get; }
    [BindableAttribute("True")]
[CategoryAttribute("Appearance")]
[ReadOnlyAttribute("True")]
[DesignerSerializationVisibilityAttribute("0")]
public object SelectedValue { get; }
    [CategoryAttribute("Appearance")]
[BindableAttribute("True")]
public string SelectedValuePath { get; public set; }
    internal bool IsSelectionChangeActive { get; internal set; }
    internal bool IsSelectedContainerHookedUp { get; }
    internal TreeViewItem SelectedContainer { get; }
    protected internal bool HandlesScrolling { get; }
    private static bool IsControlKeyDown { get; }
    private static bool IsShiftKeyDown { get; }
    internal DependencyObjectType DTypeThemeStyleKey { get; }
    private static TreeView();
    public object get_SelectedItem();
    private void SetSelectedItem(object data);
    public object get_SelectedValue();
    private void SetSelectedValue(object data);
    public string get_SelectedValuePath();
    public void set_SelectedValuePath(string value);
    private static void OnSelectedValuePathChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public void add_SelectedItemChanged(RoutedPropertyChangedEventHandler`1<object> value);
    public void remove_SelectedItemChanged(RoutedPropertyChangedEventHandler`1<object> value);
    protected virtual void OnSelectedItemChanged(RoutedPropertyChangedEventArgs`1<object> e);
    internal void ChangeSelection(object data, TreeViewItem container, bool selected);
    internal bool get_IsSelectionChangeActive();
    internal void set_IsSelectionChangeActive(bool value);
    private void UpdateSelectedValue(object selectedItem);
    private BindingExpression PrepareSelectedValuePathBindingExpression(object item);
    internal void HandleSelectionAndCollapsed(TreeViewItem collapsed);
    internal void HandleMouseButtonDown();
    protected virtual bool IsItemItsOwnContainerOverride(object item);
    protected virtual DependencyObject GetContainerForItemOverride();
    protected virtual void OnItemsChanged(NotifyCollectionChangedEventArgs e);
    private void SelectFirstItem();
    private bool GetFirstItem(Object& item, TreeViewItem& container);
    internal bool get_IsSelectedContainerHookedUp();
    internal TreeViewItem get_SelectedContainer();
    protected internal virtual bool get_HandlesScrolling();
    protected virtual void OnKeyDown(KeyEventArgs e);
    private static bool get_IsControlKeyDown();
    private static bool get_IsShiftKeyDown();
    private bool FocusFirstItem();
    private bool FocusLastItem();
    private bool HandleScrollKeys(Key key);
    private bool HandleScrollByPage(KeyEventArgs e);
    protected virtual bool ExpandSubtree(TreeViewItem container);
    protected virtual void OnIsKeyboardFocusWithinChanged(DependencyPropertyChangedEventArgs e);
    protected virtual void OnGotFocus(RoutedEventArgs e);
    private void OnFocusEnterMainFocusScope(object sender, EventArgs e);
    private static DependencyObject FindParent(DependencyObject o);
    protected virtual AutomationPeer OnCreateAutomationPeer();
    internal virtual DependencyObjectType get_DTypeThemeStyleKey();
}
[StyleTypedPropertyAttribute]
[TemplatePartAttribute]
[TemplatePartAttribute]
public class System.Windows.Controls.TreeViewItem : HeaderedItemsControl {
    public static DependencyProperty IsExpandedProperty;
    public static DependencyProperty IsSelectedProperty;
    public static DependencyProperty IsSelectionActiveProperty;
    public static RoutedEvent ExpandedEvent;
    public static RoutedEvent CollapsedEvent;
    public static RoutedEvent SelectedEvent;
    public static RoutedEvent UnselectedEvent;
    private static DependencyObjectType _dType;
    private static string HeaderPartName;
    private static string ItemsHostPartName;
    public bool IsExpanded { get; public set; }
    private bool CanExpand { get; }
    public bool IsSelected { get; public set; }
    [BrowsableAttribute("False")]
[CategoryAttribute("Appearance")]
[ReadOnlyAttribute("True")]
public bool IsSelectionActive { get; }
    private HierarchicalVirtualizationConstraints System.Windows.Controls.Primitives.IHierarchicalVirtualizationAndScrollInfo.Constraints { get; private set; }
    private HierarchicalVirtualizationHeaderDesiredSizes System.Windows.Controls.Primitives.IHierarchicalVirtualizationAndScrollInfo.HeaderDesiredSizes { get; }
    private HierarchicalVirtualizationItemDesiredSizes System.Windows.Controls.Primitives.IHierarchicalVirtualizationAndScrollInfo.ItemDesiredSizes { get; private set; }
    private Panel System.Windows.Controls.Primitives.IHierarchicalVirtualizationAndScrollInfo.ItemsHost { get; }
    private bool System.Windows.Controls.Primitives.IHierarchicalVirtualizationAndScrollInfo.MustDisableVirtualization { get; private set; }
    private bool System.Windows.Controls.Primitives.IHierarchicalVirtualizationAndScrollInfo.InBackgroundLayout { get; private set; }
    internal TreeView ParentTreeView { get; }
    internal TreeViewItem ParentTreeViewItem { get; }
    internal ItemsControl ParentItemsControl { get; }
    private bool ContainsSelection { get; private set; }
    private static bool IsControlKeyDown { get; }
    private bool CanExpandOnInput { get; }
    internal FrameworkElement HeaderElement { get; }
    private ItemsPresenter ItemsHostPresenter { get; }
    internal DependencyObjectType DTypeThemeStyleKey { get; }
    private static TreeViewItem();
    public bool get_IsExpanded();
    public void set_IsExpanded(bool value);
    private bool get_CanExpand();
    private static void OnIsExpandedChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public bool get_IsSelected();
    public void set_IsSelected(bool value);
    private static void OnIsSelectedChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public bool get_IsSelectionActive();
    public void add_Expanded(RoutedEventHandler value);
    public void remove_Expanded(RoutedEventHandler value);
    protected virtual void OnExpanded(RoutedEventArgs e);
    public void add_Collapsed(RoutedEventHandler value);
    public void remove_Collapsed(RoutedEventHandler value);
    protected virtual void OnCollapsed(RoutedEventArgs e);
    public void add_Selected(RoutedEventHandler value);
    public void remove_Selected(RoutedEventHandler value);
    protected virtual void OnSelected(RoutedEventArgs e);
    public void add_Unselected(RoutedEventHandler value);
    public void remove_Unselected(RoutedEventHandler value);
    protected virtual void OnUnselected(RoutedEventArgs e);
    public void ExpandSubtree();
    protected virtual Size ArrangeOverride(Size arrangeSize);
    private sealed virtual override HierarchicalVirtualizationConstraints System.Windows.Controls.Primitives.IHierarchicalVirtualizationAndScrollInfo.get_Constraints();
    private sealed virtual override void System.Windows.Controls.Primitives.IHierarchicalVirtualizationAndScrollInfo.set_Constraints(HierarchicalVirtualizationConstraints value);
    private sealed virtual override HierarchicalVirtualizationHeaderDesiredSizes System.Windows.Controls.Primitives.IHierarchicalVirtualizationAndScrollInfo.get_HeaderDesiredSizes();
    private sealed virtual override HierarchicalVirtualizationItemDesiredSizes System.Windows.Controls.Primitives.IHierarchicalVirtualizationAndScrollInfo.get_ItemDesiredSizes();
    private sealed virtual override void System.Windows.Controls.Primitives.IHierarchicalVirtualizationAndScrollInfo.set_ItemDesiredSizes(HierarchicalVirtualizationItemDesiredSizes value);
    private sealed virtual override Panel System.Windows.Controls.Primitives.IHierarchicalVirtualizationAndScrollInfo.get_ItemsHost();
    private sealed virtual override bool System.Windows.Controls.Primitives.IHierarchicalVirtualizationAndScrollInfo.get_MustDisableVirtualization();
    private sealed virtual override void System.Windows.Controls.Primitives.IHierarchicalVirtualizationAndScrollInfo.set_MustDisableVirtualization(bool value);
    private sealed virtual override bool System.Windows.Controls.Primitives.IHierarchicalVirtualizationAndScrollInfo.get_InBackgroundLayout();
    private sealed virtual override void System.Windows.Controls.Primitives.IHierarchicalVirtualizationAndScrollInfo.set_InBackgroundLayout(bool value);
    internal TreeView get_ParentTreeView();
    internal TreeViewItem get_ParentTreeViewItem();
    internal ItemsControl get_ParentItemsControl();
    protected internal virtual void OnVisualParentChanged(DependencyObject oldParent);
    private void Select(bool selected);
    private bool get_ContainsSelection();
    private void set_ContainsSelection(bool value);
    internal void UpdateContainsSelection(bool selected);
    protected virtual void OnGotFocus(RoutedEventArgs e);
    protected virtual void OnMouseLeftButtonDown(MouseButtonEventArgs e);
    protected virtual void OnKeyDown(KeyEventArgs e);
    private bool LogicalLeft(Key key);
    private static bool get_IsControlKeyDown();
    private bool get_CanExpandOnInput();
    internal bool HandleUpKey(KeyEventArgs e);
    internal bool HandleDownKey(KeyEventArgs e);
    private bool HandleUpDownKey(bool up, KeyEventArgs e);
    private bool AllowHandleKeyEvent(FocusNavigationDirection direction);
    private static void OnMouseButtonDown(object sender, MouseButtonEventArgs e);
    private static void OnRequestBringIntoView(object sender, RequestBringIntoViewEventArgs e);
    private void HandleBringIntoView(RequestBringIntoViewEventArgs e);
    private object BringItemIntoView(object args);
    internal FrameworkElement get_HeaderElement();
    internal FrameworkElement TryGetHeaderElement();
    private ItemsPresenter get_ItemsHostPresenter();
    protected virtual bool IsItemItsOwnContainerOverride(object item);
    protected virtual DependencyObject GetContainerForItemOverride();
    internal void PrepareItemContainer(object item, ItemsControl parentItemsControl);
    internal void ClearItemContainer(object item, ItemsControl parentItemsControl);
    internal static void IsVirtualizingPropagationHelper(DependencyObject parent, DependencyObject element);
    internal static void SynchronizeValue(DependencyProperty dp, DependencyObject parent, DependencyObject child);
    protected virtual void OnItemsChanged(NotifyCollectionChangedEventArgs e);
    private static void ExpandRecursive(TreeViewItem item);
    protected virtual AutomationPeer OnCreateAutomationPeer();
    internal virtual DependencyObjectType get_DTypeThemeStyleKey();
    internal virtual void ChangeVisualState(bool useTransitions);
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Controls.UIElementCollection : object {
    private VisualCollection _visualChildren;
    private UIElement _visualParent;
    private FrameworkElement _logicalParent;
    public int Count { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public int Capacity { get; public set; }
    public UIElement Item { get; public set; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private object System.Collections.IList.Item { get; private set; }
    internal UIElement VisualParent { get; }
    internal FrameworkElement LogicalParent { get; }
    public UIElementCollection(UIElement visualParent, FrameworkElement logicalParent);
    public virtual int get_Count();
    public virtual bool get_IsSynchronized();
    public virtual object get_SyncRoot();
    public virtual void CopyTo(Array array, int index);
    public virtual void CopyTo(UIElement[] array, int index);
    public virtual int get_Capacity();
    public virtual void set_Capacity(int value);
    public virtual UIElement get_Item(int index);
    public virtual void set_Item(int index, UIElement value);
    internal void SetInternal(int index, UIElement item);
    public virtual int Add(UIElement element);
    internal int AddInternal(UIElement element);
    public virtual int IndexOf(UIElement element);
    public virtual void Remove(UIElement element);
    internal void RemoveInternal(UIElement element);
    internal virtual void RemoveNoVerify(UIElement element);
    public virtual bool Contains(UIElement element);
    public virtual void Clear();
    internal void ClearInternal();
    public virtual void Insert(int index, UIElement element);
    internal void InsertInternal(int index, UIElement element);
    public virtual void RemoveAt(int index);
    public virtual void RemoveRange(int index, int count);
    internal void RemoveRangeInternal(int index, int count);
    internal void MoveVisualChild(Visual visual, Visual destination);
    private UIElement Cast(object value);
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public virtual IEnumerator GetEnumerator();
    protected void SetLogicalParent(UIElement element);
    protected void ClearLogicalParent(UIElement element);
    internal UIElement get_VisualParent();
    private void ValidateElement(UIElement element);
    private void VerifyWriteAccess();
    internal FrameworkElement get_LogicalParent();
}
public enum System.Windows.Controls.UndoAction : Enum {
    public int value__;
    public static UndoAction None;
    public static UndoAction Merge;
    public static UndoAction Undo;
    public static UndoAction Redo;
    public static UndoAction Clear;
    public static UndoAction Create;
}
public class System.Windows.Controls.UserControl : ContentControl {
    private static DependencyObjectType _dType;
    internal FrameworkElement StateGroupsRoot { get; }
    internal DependencyObjectType DTypeThemeStyleKey { get; }
    private static UserControl();
    internal virtual void AdjustBranchSource(RoutedEventArgs e);
    protected virtual AutomationPeer OnCreateAutomationPeer();
    internal virtual FrameworkElement get_StateGroupsRoot();
    internal virtual DependencyObjectType get_DTypeThemeStyleKey();
}
public static class System.Windows.Controls.Validation : object {
    public static RoutedEvent ErrorEvent;
    internal static DependencyPropertyKey ErrorsPropertyKey;
    public static DependencyProperty ErrorsProperty;
    internal static DependencyProperty ValidationErrorsInternalProperty;
    internal static DependencyPropertyKey HasErrorPropertyKey;
    public static DependencyProperty HasErrorProperty;
    public static DependencyProperty ErrorTemplateProperty;
    public static DependencyProperty ValidationAdornerSiteProperty;
    public static DependencyProperty ValidationAdornerSiteForProperty;
    private static DependencyProperty ValidationAdornerProperty;
    private static Validation();
    public static void AddErrorHandler(DependencyObject element, EventHandler`1<ValidationErrorEventArgs> handler);
    public static void RemoveErrorHandler(DependencyObject element, EventHandler`1<ValidationErrorEventArgs> handler);
    public static ReadOnlyObservableCollection`1<ValidationError> GetErrors(DependencyObject element);
    private static void OnErrorsInternalChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    internal static ValidationErrorCollection GetErrorsInternal(DependencyObject target);
    private static void OnHasErrorChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public static bool GetHasError(DependencyObject element);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static ControlTemplate GetErrorTemplate(DependencyObject element);
    public static void SetErrorTemplate(DependencyObject element, ControlTemplate value);
    private static void OnErrorTemplateChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static DependencyObject GetValidationAdornerSite(DependencyObject element);
    public static void SetValidationAdornerSite(DependencyObject element, DependencyObject value);
    private static void OnValidationAdornerSiteChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static DependencyObject GetValidationAdornerSiteFor(DependencyObject element);
    public static void SetValidationAdornerSiteFor(DependencyObject element, DependencyObject value);
    private static void OnValidationAdornerSiteForChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    internal static void ShowValidationAdorner(DependencyObject targetElement, bool show);
    private static bool HasValidationGroup(FrameworkElement fe);
    private static bool HasValidationGroup(IList`1<VisualStateGroup> groups);
    private static void ShowValidationAdornerHelper(DependencyObject targetElement, DependencyObject adornerSite, bool show);
    private static object ShowValidationAdornerOperation(object arg);
    private static void ShowValidationAdornerHelper(DependencyObject targetElement, DependencyObject adornerSite, bool show, bool tryAgain);
    public static void MarkInvalid(BindingExpressionBase bindingExpression, ValidationError validationError);
    public static void ClearInvalid(BindingExpressionBase bindingExpression);
    internal static void AddValidationError(ValidationError validationError, DependencyObject targetElement, bool shouldRaiseEvent);
    internal static void RemoveValidationError(ValidationError validationError, DependencyObject targetElement, bool shouldRaiseEvent);
    private static void OnValidationError(DependencyObject source, ValidationError validationError, ValidationErrorEventAction action);
    private static ControlTemplate CreateDefaultErrorTemplate();
}
public class System.Windows.Controls.ValidationError : object {
    private ValidationRule _ruleInError;
    private object _errorContent;
    private Exception _exception;
    private object _bindingInError;
    public ValidationRule RuleInError { get; public set; }
    public object ErrorContent { get; public set; }
    public Exception Exception { get; public set; }
    public object BindingInError { get; }
    public ValidationError(ValidationRule ruleInError, object bindingInError, object errorContent, Exception exception);
    public ValidationError(ValidationRule ruleInError, object bindingInError);
    public ValidationRule get_RuleInError();
    public void set_RuleInError(ValidationRule value);
    public object get_ErrorContent();
    public void set_ErrorContent(object value);
    public Exception get_Exception();
    public void set_Exception(Exception value);
    public object get_BindingInError();
}
public enum System.Windows.Controls.ValidationErrorEventAction : Enum {
    public int value__;
    public static ValidationErrorEventAction Added;
    public static ValidationErrorEventAction Removed;
}
public class System.Windows.Controls.ValidationErrorEventArgs : RoutedEventArgs {
    private ValidationError _validationError;
    private ValidationErrorEventAction _action;
    public ValidationError Error { get; }
    public ValidationErrorEventAction Action { get; }
    internal ValidationErrorEventArgs(ValidationError validationError, ValidationErrorEventAction action);
    public ValidationError get_Error();
    public ValidationErrorEventAction get_Action();
    protected virtual void InvokeEventHandler(Delegate genericHandler, object genericTarget);
}
public class System.Windows.Controls.ValidationResult : object {
    private bool _isValid;
    private object _errorContent;
    private static ValidationResult s_valid;
    public bool IsValid { get; }
    public object ErrorContent { get; }
    public static ValidationResult ValidResult { get; }
    public ValidationResult(bool isValid, object errorContent);
    private static ValidationResult();
    public bool get_IsValid();
    public object get_ErrorContent();
    public static ValidationResult get_ValidResult();
    public static bool op_Equality(ValidationResult left, ValidationResult right);
    public static bool op_Inequality(ValidationResult left, ValidationResult right);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public abstract class System.Windows.Controls.ValidationRule : object {
    private ValidationStep _validationStep;
    private bool _validatesOnTargetUpdated;
    public ValidationStep ValidationStep { get; public set; }
    public bool ValidatesOnTargetUpdated { get; public set; }
    protected ValidationRule(ValidationStep validationStep, bool validatesOnTargetUpdated);
    public abstract virtual ValidationResult Validate(object value, CultureInfo cultureInfo);
    public virtual ValidationResult Validate(object value, CultureInfo cultureInfo, BindingExpressionBase owner);
    public virtual ValidationResult Validate(object value, CultureInfo cultureInfo, BindingGroup owner);
    public ValidationStep get_ValidationStep();
    public void set_ValidationStep(ValidationStep value);
    public bool get_ValidatesOnTargetUpdated();
    public void set_ValidatesOnTargetUpdated(bool value);
}
public enum System.Windows.Controls.ValidationStep : Enum {
    public int value__;
    public static ValidationStep RawProposedValue;
    public static ValidationStep ConvertedProposedValue;
    public static ValidationStep UpdatedValue;
    public static ValidationStep CommittedValue;
}
public abstract class System.Windows.Controls.ViewBase : DependencyObject {
    private DependencyObject _inheritanceContext;
    private bool _isUsed;
    protected internal object DefaultStyleKey { get; }
    protected internal object ItemContainerDefaultStyleKey { get; }
    internal DependencyObject InheritanceContext { get; }
    internal bool IsUsed { get; internal set; }
    protected internal virtual void PrepareItem(ListViewItem item);
    protected internal virtual void ClearItem(ListViewItem item);
    protected internal virtual object get_DefaultStyleKey();
    protected internal virtual object get_ItemContainerDefaultStyleKey();
    internal virtual void OnThemeChanged();
    internal virtual DependencyObject get_InheritanceContext();
    internal virtual void AddInheritanceContext(DependencyObject context, DependencyProperty property);
    internal virtual void RemoveInheritanceContext(DependencyObject context, DependencyProperty property);
    protected internal virtual IViewAutomationPeer GetAutomationPeer(ListView parent);
    internal bool get_IsUsed();
    internal void set_IsUsed(bool value);
}
public class System.Windows.Controls.Viewbox : Decorator {
    public static DependencyProperty StretchProperty;
    public static DependencyProperty StretchDirectionProperty;
    private ContainerVisual _internalVisual;
    private ContainerVisual InternalVisual { get; }
    private UIElement InternalChild { get; private set; }
    private Transform InternalTransform { get; private set; }
    public UIElement Child { get; public set; }
    protected int VisualChildrenCount { get; }
    protected internal IEnumerator LogicalChildren { get; }
    public Stretch Stretch { get; public set; }
    public StretchDirection StretchDirection { get; public set; }
    private static Viewbox();
    private static bool ValidateStretchValue(object value);
    private static bool ValidateStretchDirectionValue(object value);
    private ContainerVisual get_InternalVisual();
    private UIElement get_InternalChild();
    private void set_InternalChild(UIElement value);
    private Transform get_InternalTransform();
    private void set_InternalTransform(Transform value);
    public virtual UIElement get_Child();
    public virtual void set_Child(UIElement value);
    protected virtual int get_VisualChildrenCount();
    protected virtual Visual GetVisualChild(int index);
    protected internal virtual IEnumerator get_LogicalChildren();
    public Stretch get_Stretch();
    public void set_Stretch(Stretch value);
    public StretchDirection get_StretchDirection();
    public void set_StretchDirection(StretchDirection value);
    protected virtual Size MeasureOverride(Size constraint);
    protected virtual Size ArrangeOverride(Size arrangeSize);
    internal static Size ComputeScaleFactor(Size availableSize, Size contentSize, Stretch stretch, StretchDirection stretchDirection);
}
[ContentPropertyAttribute("Children")]
[LocalizabilityAttribute("17")]
public class System.Windows.Controls.Viewport3D : FrameworkElement {
    public static DependencyProperty CameraProperty;
    private static DependencyPropertyKey ChildrenPropertyKey;
    public static DependencyProperty ChildrenProperty;
    private Viewport3DVisual _viewport3DVisual;
    public Camera Camera { get; public set; }
    [DesignerSerializationVisibilityAttribute("2")]
public Visual3DCollection Children { get; }
    protected int VisualChildrenCount { get; }
    private static Viewport3D();
    private static void OnCameraChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public Camera get_Camera();
    public void set_Camera(Camera value);
    public Visual3DCollection get_Children();
    protected virtual AutomationPeer OnCreateAutomationPeer();
    protected virtual Size ArrangeOverride(Size finalSize);
    protected virtual Visual GetVisualChild(int index);
    protected virtual int get_VisualChildrenCount();
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object value);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string text);
}
[TypeConverterAttribute("System.Windows.Controls.VirtualizationCacheLengthConverter")]
public class System.Windows.Controls.VirtualizationCacheLength : ValueType {
    private double _cacheBeforeViewport;
    private double _cacheAfterViewport;
    public double CacheBeforeViewport { get; }
    public double CacheAfterViewport { get; }
    public VirtualizationCacheLength(double cacheBeforeAndAfterViewport);
    public VirtualizationCacheLength(double cacheBeforeViewport, double cacheAfterViewport);
    public static bool op_Equality(VirtualizationCacheLength cl1, VirtualizationCacheLength cl2);
    public static bool op_Inequality(VirtualizationCacheLength cl1, VirtualizationCacheLength cl2);
    public virtual bool Equals(object oCompare);
    public sealed virtual bool Equals(VirtualizationCacheLength cacheLength);
    public virtual int GetHashCode();
    public double get_CacheBeforeViewport();
    public double get_CacheAfterViewport();
    public virtual string ToString();
}
public class System.Windows.Controls.VirtualizationCacheLengthConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext typeDescriptorContext, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext typeDescriptorContext, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext typeDescriptorContext, CultureInfo cultureInfo, object source);
    public virtual object ConvertTo(ITypeDescriptorContext typeDescriptorContext, CultureInfo cultureInfo, object value, Type destinationType);
    internal static string ToString(VirtualizationCacheLength cacheLength, CultureInfo cultureInfo);
    internal static VirtualizationCacheLength FromString(string s, CultureInfo cultureInfo);
}
public enum System.Windows.Controls.VirtualizationCacheLengthUnit : Enum {
    public int value__;
    public static VirtualizationCacheLengthUnit Pixel;
    public static VirtualizationCacheLengthUnit Item;
    public static VirtualizationCacheLengthUnit Page;
}
public enum System.Windows.Controls.VirtualizationMode : Enum {
    public int value__;
    public static VirtualizationMode Standard;
    public static VirtualizationMode Recycling;
}
[DefaultMemberAttribute("Item")]
internal class System.Windows.Controls.VirtualizedCellInfoCollection : object {
    private bool _isReadOnly;
    private DataGrid _owner;
    private List`1<CellRegion> _regions;
    public DataGridCellInfo Item { get; public set; }
    public int Count { get; }
    public bool IsReadOnly { get; private set; }
    protected bool IsEmpty { get; }
    protected DataGrid Owner { get; }
    internal VirtualizedCellInfoCollection(DataGrid owner);
    private VirtualizedCellInfoCollection(DataGrid owner, List`1<CellRegion> regions);
    internal static VirtualizedCellInfoCollection MakeEmptyCollection(DataGrid owner);
    public sealed virtual void Add(DataGridCellInfo cell);
    internal void AddValidatedCell(DataGridCellInfo cell);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(DataGridCellInfo cell);
    internal bool Contains(DataGridCell cell);
    internal bool Contains(int rowIndex, int columnIndex);
    public sealed virtual void CopyTo(DataGridCellInfo[] array, int arrayIndex);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual IEnumerator`1<DataGridCellInfo> GetEnumerator();
    public sealed virtual int IndexOf(DataGridCellInfo cell);
    public sealed virtual void Insert(int index, DataGridCellInfo cell);
    public sealed virtual bool Remove(DataGridCellInfo cell);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual DataGridCellInfo get_Item(int index);
    public sealed virtual void set_Item(int index, DataGridCellInfo value);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    private void set_IsReadOnly(bool value);
    private void OnAdd(VirtualizedCellInfoCollection newItems);
    private void OnRemove(VirtualizedCellInfoCollection oldItems);
    protected virtual void OnCollectionChanged(NotifyCollectionChangedAction action, VirtualizedCellInfoCollection oldItems, VirtualizedCellInfoCollection newItems);
    private bool IsValidCell(DataGridCellInfo cell);
    private bool IsValidPublicCell(DataGridCellInfo cell);
    protected bool get_IsEmpty();
    protected void GetBoundingRegion(Int32& left, Int32& top, Int32& right, Int32& bottom);
    internal void AddRegion(int rowIndex, int columnIndex, int rowCount, int columnCount);
    private void AddRegion(int rowIndex, int columnIndex, int rowCount, int columnCount, bool notify);
    internal void RemoveRegion(int rowIndex, int columnIndex, int rowCount, int columnCount);
    private void RemoveRegion(int rowIndex, int columnIndex, int rowCount, int columnCount, List`1& removeList);
    internal void OnItemsCollectionChanged(NotifyCollectionChangedEventArgs e, List`1<Tuple`2<int, int>> ranges);
    private void OnAddRow(int rowIndex);
    private void OnRemoveRow(int rowIndex, object item);
    private void OnReplaceRow(int rowIndex, object item);
    private void OnMoveRow(int oldIndex, int newIndex);
    internal void OnColumnsChanged(NotifyCollectionChangedAction action, int oldDisplayIndex, DataGridColumn oldColumn, int newDisplayIndex, IList selectedRows);
    private void OnAddColumn(int columnIndex, IList selectedRows);
    private void FillInFullRowRegions(IList rows, int columnIndex, bool notify);
    private void OnRemoveColumn(int columnIndex, DataGridColumn oldColumn);
    private void OnReplaceColumn(int columnIndex, DataGridColumn oldColumn, IList selectedRows);
    private void OnMoveColumn(int oldIndex, int newIndex);
    internal void Union(VirtualizedCellInfoCollection collection);
    internal static void Xor(VirtualizedCellInfoCollection c1, VirtualizedCellInfoCollection c2);
    internal void ClearFullRows(IList rows);
    internal void RestoreOnlyFullRows(List`1<Tuple`2<int, int>> ranges);
    internal void RemoveAllButOne(DataGridCellInfo cellInfo);
    internal void RemoveAllButOne();
    internal void RemoveAllButOneRow(int rowIndex);
    private void RemoveAllButRegion(int rowIndex, int columnIndex, int rowCount, int columnCount);
    internal bool Intersects(int rowIndex);
    internal bool Intersects(int rowIndex, List`1& columnIndexRanges);
    protected DataGrid get_Owner();
    private void ConvertCellInfoToIndexes(DataGridCellInfo cell, Int32& rowIndex, Int32& columnIndex);
    private static void ConvertIndexToIndexes(List`1<CellRegion> regions, int index, Int32& rowIndex, Int32& columnIndex);
    private DataGridCellInfo GetCellInfoFromIndex(DataGrid owner, List`1<CellRegion> regions, int index);
    private void ValidateIsReadOnly();
    private void AddRegionToList(CellRegion region, List`1<DataGridCellInfo> list);
    protected virtual DataGridCellInfo CreateCellInfo(ItemInfo rowInfo, DataGridColumn column, DataGrid owner);
}
public abstract class System.Windows.Controls.VirtualizingPanel : Panel {
    public static DependencyProperty IsVirtualizingProperty;
    public static DependencyProperty VirtualizationModeProperty;
    public static DependencyProperty IsVirtualizingWhenGroupingProperty;
    public static DependencyProperty ScrollUnitProperty;
    public static DependencyProperty CacheLengthProperty;
    public static DependencyProperty CacheLengthUnitProperty;
    public static DependencyProperty IsContainerVirtualizableProperty;
    internal static DependencyProperty ShouldCacheContainerSizeProperty;
    public bool CanHierarchicallyScrollAndVirtualize { get; }
    protected bool CanHierarchicallyScrollAndVirtualizeCore { get; }
    public IItemContainerGenerator ItemContainerGenerator { get; }
    private static VirtualizingPanel();
    public bool get_CanHierarchicallyScrollAndVirtualize();
    protected virtual bool get_CanHierarchicallyScrollAndVirtualizeCore();
    public double GetItemOffset(UIElement child);
    protected virtual double GetItemOffsetCore(UIElement child);
    public static bool GetIsVirtualizing(DependencyObject element);
    public static void SetIsVirtualizing(DependencyObject element, bool value);
    public static VirtualizationMode GetVirtualizationMode(DependencyObject element);
    public static void SetVirtualizationMode(DependencyObject element, VirtualizationMode value);
    public static bool GetIsVirtualizingWhenGrouping(DependencyObject element);
    public static void SetIsVirtualizingWhenGrouping(DependencyObject element, bool value);
    public static ScrollUnit GetScrollUnit(DependencyObject element);
    public static void SetScrollUnit(DependencyObject element, ScrollUnit value);
    public static VirtualizationCacheLength GetCacheLength(DependencyObject element);
    public static void SetCacheLength(DependencyObject element, VirtualizationCacheLength value);
    public static VirtualizationCacheLengthUnit GetCacheLengthUnit(DependencyObject element);
    public static void SetCacheLengthUnit(DependencyObject element, VirtualizationCacheLengthUnit value);
    public static bool GetIsContainerVirtualizable(DependencyObject element);
    public static void SetIsContainerVirtualizable(DependencyObject element, bool value);
    internal static bool GetShouldCacheContainerSize(DependencyObject element);
    private static bool ValidateCacheSizeBeforeOrAfterViewport(object value);
    private static object CoerceIsVirtualizingWhenGrouping(DependencyObject d, object baseValue);
    internal static void OnVirtualizationPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void VirtualizationPropertyChangePropagationRecursive(DependencyObject parent, Panel itemsHost);
    public IItemContainerGenerator get_ItemContainerGenerator();
    internal virtual void GenerateChildren();
    protected void AddInternalChild(UIElement child);
    protected void InsertInternalChild(int index, UIElement child);
    protected void RemoveInternalChildRange(int index, int range);
    internal static void AddInternalChild(UIElementCollection children, UIElement child);
    internal static void InsertInternalChild(UIElementCollection children, int index, UIElement child);
    internal static void RemoveInternalChildRange(UIElementCollection children, int index, int range);
    protected virtual void OnItemsChanged(object sender, ItemsChangedEventArgs args);
    public bool ShouldItemsChangeAffectLayout(bool areItemChangesLocal, ItemsChangedEventArgs args);
    protected virtual bool ShouldItemsChangeAffectLayoutCore(bool areItemChangesLocal, ItemsChangedEventArgs args);
    protected virtual void OnClearChildren();
    public void BringIndexIntoViewPublic(int index);
    protected internal virtual void BringIndexIntoView(int index);
    internal virtual bool OnItemsChangedInternal(object sender, ItemsChangedEventArgs args);
    internal virtual void OnClearChildrenInternal();
}
public class System.Windows.Controls.VirtualizingStackPanel : VirtualizingPanel {
    private static DependencyProperty ContainerSizeProperty;
    private static DependencyProperty ContainerSizeDualProperty;
    private static DependencyProperty AreContainersUniformlySizedProperty;
    private static DependencyProperty UniformOrAverageContainerSizeProperty;
    private static DependencyProperty UniformOrAverageContainerSizeDualProperty;
    internal static DependencyProperty ItemsHostInsetProperty;
    public static DependencyProperty IsVirtualizingProperty;
    public static DependencyProperty VirtualizationModeProperty;
    public static DependencyProperty OrientationProperty;
    public static RoutedEvent CleanUpVirtualizedItemEvent;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <AreContainersUniformlySized>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<double> <UniformOrAverageContainerSize>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<double> <UniformOrAverageContainerPixelSize>k__BackingField;
    private BoolField _boolFieldStore;
    private ScrollData _scrollData;
    private int _firstItemInExtendedViewportChildIndex;
    private int _firstItemInExtendedViewportIndex;
    private double _firstItemInExtendedViewportOffset;
    private int _actualItemsInExtendedViewportCount;
    private Rect _viewport;
    private int _itemsInExtendedViewportCount;
    private Rect _extendedViewport;
    private Size _previousStackPixelSizeInViewport;
    private Size _previousStackLogicalSizeInViewport;
    private Size _previousStackPixelSizeInCacheBeforeViewport;
    private double _pixelDistanceToFirstContainerInExtendedViewport;
    private double _pixelDistanceToViewport;
    private List`1<UIElement> _realizedChildren;
    private DispatcherOperation _cleanupOperation;
    private DispatcherTimer _cleanupDelay;
    private static int FocusTrail;
    private DependencyObject _bringIntoViewContainer;
    private static Int32[] _indicesStoredInItemValueStorage;
    private static UncommonField`1<DispatcherOperation> MeasureCachesOperationField;
    private static UncommonField`1<DispatcherOperation> AnchorOperationField;
    private static UncommonField`1<DispatcherOperation> AnchoredInvalidateMeasureOperationField;
    private static UncommonField`1<DispatcherOperation> ClearIsScrollActiveOperationField;
    private static UncommonField`1<OffsetInformation> OffsetInformationField;
    private static UncommonField`1<EffectiveOffsetInformation> EffectiveOffsetInformationField;
    private static UncommonField`1<SnapshotData> SnapshotDataField;
    private static UncommonField`1<FirstContainerInformation> FirstContainerInformationField;
    private static UncommonField`1<ScrollTracingInfo> ScrollTracingInfoField;
    public Orientation Orientation { get; public set; }
    protected internal bool HasLogicalOrientation { get; }
    protected internal Orientation LogicalOrientation { get; }
    [DefaultValueAttribute("False")]
public bool CanHorizontallyScroll { get; public set; }
    [DefaultValueAttribute("False")]
public bool CanVerticallyScroll { get; public set; }
    public double ExtentWidth { get; }
    public double ExtentHeight { get; }
    public double ViewportWidth { get; }
    public double ViewportHeight { get; }
    [DesignerSerializationVisibilityAttribute("0")]
public double HorizontalOffset { get; }
    [DesignerSerializationVisibilityAttribute("0")]
public double VerticalOffset { get; }
    [DesignerSerializationVisibilityAttribute("0")]
public ScrollViewer ScrollOwner { get; public set; }
    protected bool CanHierarchicallyScrollAndVirtualizeCore { get; }
    private int MinDesiredGenerated { get; }
    private int MaxDesiredGenerated { get; }
    private int ItemCount { get; }
    private bool HasMeasured { get; private set; }
    private bool InRecyclingMode { get; private set; }
    internal bool IsScrolling { get; }
    internal bool IsPixelBased { get; internal set; }
    internal bool MustDisableVirtualization { get; internal set; }
    internal bool MeasureCaches { get; internal set; }
    private bool IsVirtualizing { get; private set; }
    private bool HasVirtualizingChildren { get; private set; }
    private bool AlignTopOfBringIntoViewContainer { get; private set; }
    private bool AlignBottomOfBringIntoViewContainer { get; private set; }
    private bool WasLastMeasurePassAnchored { get; private set; }
    private bool ItemsChangedDuringMeasure { get; private set; }
    private bool IsScrollActive { get; private set; }
    internal bool IgnoreMaxDesiredSize { get; internal set; }
    private bool IsMeasureCachesPending { get; private set; }
    private Nullable`1<bool> AreContainersUniformlySized { get; private set; }
    private Nullable`1<double> UniformOrAverageContainerSize { get; private set; }
    private Nullable`1<double> UniformOrAverageContainerPixelSize { get; private set; }
    private IList RealizedChildren { get; }
    internal static bool IsVSP45Compat { get; }
    private bool System.Windows.Controls.IStackMeasure.IsScrolling { get; }
    private UIElementCollection System.Windows.Controls.IStackMeasure.InternalChildren { get; }
    private DependencyObject BringIntoViewLeafContainer { get; }
    private FrameworkElement FirstContainerInViewport { get; }
    private double FirstContainerOffsetFromViewport { get; }
    private double ExpectedDistanceBetweenViewports { get; }
    private bool CanMouseWheelVerticallyScroll { get; }
    private static VirtualizingStackPanel();
    public virtual void LineUp();
    public virtual void LineDown();
    public virtual void LineLeft();
    public virtual void LineRight();
    public virtual void PageUp();
    public virtual void PageDown();
    public virtual void PageLeft();
    public virtual void PageRight();
    public virtual void MouseWheelUp();
    public virtual void MouseWheelDown();
    public virtual void MouseWheelLeft();
    public virtual void MouseWheelRight();
    private double NewItemOffset(bool isHorizontal, double delta, bool fromFirst);
    public sealed virtual void SetHorizontalOffset(double offset);
    private void SetHorizontalOffsetImpl(double offset, bool setAnchorInformation);
    public sealed virtual void SetVerticalOffset(double offset);
    private void SetVerticalOffsetImpl(double offset, bool setAnchorInformation);
    private void SetAnchorInformation(bool isHorizontalOffset);
    private void OnAnchorOperation();
    private void OnAnchorOperation(bool isAnchorOperationPending);
    private void ClearAnchorInformation(bool shouldAbort);
    private FrameworkElement ComputeFirstContainerInViewport(FrameworkElement viewportElement, FocusNavigationDirection direction, Panel itemsHost, Action`1<DependencyObject> action, bool findTopContainer, Double& firstContainerOffsetFromViewport);
    private FrameworkElement ComputeFirstContainerInViewport(FrameworkElement viewportElement, FocusNavigationDirection direction, Panel itemsHost, Action`1<DependencyObject> action, bool findTopContainer, Double& firstContainerOffsetFromViewport, Boolean& foundTopContainer);
    internal void AnchoredInvalidateMeasure();
    private void CancelPendingAnchoredInvalidateMeasure();
    public sealed virtual Rect MakeVisible(Visual visual, Rect rectangle);
    protected internal virtual void BringIndexIntoView(int index);
    private void BringContainerIntoView(ItemsControl itemsControl, int itemIndex);
    public sealed virtual Orientation get_Orientation();
    public void set_Orientation(Orientation value);
    protected internal virtual bool get_HasLogicalOrientation();
    protected internal virtual Orientation get_LogicalOrientation();
    public sealed virtual bool get_CanHorizontallyScroll();
    public sealed virtual void set_CanHorizontallyScroll(bool value);
    public sealed virtual bool get_CanVerticallyScroll();
    public sealed virtual void set_CanVerticallyScroll(bool value);
    public sealed virtual double get_ExtentWidth();
    public sealed virtual double get_ExtentHeight();
    public sealed virtual double get_ViewportWidth();
    public sealed virtual double get_ViewportHeight();
    public sealed virtual double get_HorizontalOffset();
    public sealed virtual double get_VerticalOffset();
    public sealed virtual ScrollViewer get_ScrollOwner();
    public sealed virtual void set_ScrollOwner(ScrollViewer value);
    public static void AddCleanUpVirtualizedItemHandler(DependencyObject element, CleanUpVirtualizedItemEventHandler handler);
    public static void RemoveCleanUpVirtualizedItemHandler(DependencyObject element, CleanUpVirtualizedItemEventHandler handler);
    protected virtual void OnCleanUpVirtualizedItem(CleanUpVirtualizedItemEventArgs e);
    protected virtual bool get_CanHierarchicallyScrollAndVirtualizeCore();
    protected virtual Size MeasureOverride(Size constraint);
    private Size MeasureOverrideImpl(Size constraint, Nullable`1& lastPageSafeOffset, List`1& previouslyMeasuredOffsets, Nullable`1& lastPagePixelSize, bool remeasure);
    private Size MeasureNonItemsHost(Size constraint);
    private Size ArrangeNonItemsHost(Size arrangeSize);
    protected virtual Size ArrangeOverride(Size arrangeSize);
    protected virtual void OnItemsChanged(object sender, ItemsChangedEventArgs args);
    internal void ResetMaximumDesiredSize();
    protected virtual bool ShouldItemsChangeAffectLayoutCore(bool areItemChangesLocal, ItemsChangedEventArgs args);
    private void UpdateExtent(bool areItemChangesLocal);
    private bool IsExtendedViewportFull();
    protected virtual void OnClearChildren();
    private void OnIsVisibleChanged(object sender, DependencyPropertyChangedEventArgs e);
    internal void ClearAllContainers();
    private IHierarchicalVirtualizationAndScrollInfo GetVirtualizingProvider();
    private static IHierarchicalVirtualizationAndScrollInfo GetVirtualizingProvider(DependencyObject element);
    private static IHierarchicalVirtualizationAndScrollInfo GetVirtualizingChild(DependencyObject element);
    private static IHierarchicalVirtualizationAndScrollInfo GetVirtualizingChild(DependencyObject element, Boolean& isChildHorizontal);
    private static IContainItemStorage GetItemStorageProvider(Panel itemsHost);
    private void GetOwners(bool shouldSetVirtualizationState, bool isHorizontal, ItemsControl& itemsControl, GroupItem& groupItem, IContainItemStorage& itemStorageProvider, IHierarchicalVirtualizationAndScrollInfo& virtualizationInfoProvider, Object& parentItem, IContainItemStorage& parentItemStorageProvider, Boolean& mustDisableVirtualization);
    private void SetVirtualizationState(IContainItemStorage itemStorageProvider, ItemsControl itemsControl, bool mustDisableVirtualization);
    private static void ClearItemValueStorageRecursive(IContainItemStorage itemStorageProvider, Panel itemsHost);
    private void InitializeViewport(object parentItem, IContainItemStorage parentItemStorageProvider, IHierarchicalVirtualizationAndScrollInfo virtualizationInfoProvider, bool isHorizontal, Size constraint, Rect& viewport, VirtualizationCacheLength& cacheSize, VirtualizationCacheLengthUnit& cacheUnit, Rect& extendedViewport, Int64& scrollGeneration);
    private void ClearMeasureCachesState();
    private void ClearIsScrollActive();
    private void NormalizeCacheLength(bool isHorizontal, Rect viewport, VirtualizationCacheLength& cacheLength, VirtualizationCacheLengthUnit& cacheUnit);
    private Rect ExtendViewport(IHierarchicalVirtualizationAndScrollInfo virtualizationInfoProvider, bool isHorizontal, Rect viewport, VirtualizationCacheLength cacheLength, VirtualizationCacheLengthUnit cacheUnit, Size stackPixelSizeInCacheBeforeViewport, Size stackLogicalSizeInCacheBeforeViewport, Size stackPixelSizeInCacheAfterViewport, Size stackLogicalSizeInCacheAfterViewport, Size stackPixelSize, Size stackLogicalSize, Int32& itemsInExtendedViewportCount);
    private void CoerceScrollingViewportOffset(Rect& viewport, Size extent, bool isHorizontal);
    private void AdjustNonScrollingViewportForHeader(IHierarchicalVirtualizationAndScrollInfo virtualizationInfoProvider, Rect& viewport, VirtualizationCacheLength& cacheLength, VirtualizationCacheLengthUnit& cacheLengthUnit);
    private void AdjustNonScrollingViewportForItems(IHierarchicalVirtualizationAndScrollInfo virtualizationInfoProvider, Rect& viewport, VirtualizationCacheLength& cacheLength, VirtualizationCacheLengthUnit& cacheLengthUnit);
    private void AdjustNonScrollingViewport(IHierarchicalVirtualizationAndScrollInfo virtualizationInfoProvider, Rect& viewport, VirtualizationCacheLength& cacheLength, VirtualizationCacheLengthUnit& cacheUnit, bool forHeader);
    private void AdjustNonScrollingViewportForInset(bool isHorizontal, object parentItem, IContainItemStorage parentItemStorageProvider, IHierarchicalVirtualizationAndScrollInfo virtualizationInfoProvider, Rect& viewport, VirtualizationCacheLength& cacheLength, VirtualizationCacheLengthUnit& cacheUnit);
    private void ComputeFirstItemInViewportIndexAndOffset(IList items, int itemCount, IContainItemStorage itemStorageProvider, Rect viewport, VirtualizationCacheLength cacheSize, bool isHorizontal, bool areContainersUniformlySized, double uniformOrAverageContainerSize, Double& firstItemInViewportOffset, Double& firstItemInViewportContainerSpan, Int32& firstItemInViewportIndex, Boolean& foundFirstItemInViewport);
    private double ComputeEffectiveOffset(Rect& viewport, DependencyObject firstContainer, int itemIndex, double firstItemOffset, IList items, IContainItemStorage itemStorageProvider, IHierarchicalVirtualizationAndScrollInfo virtualizationInfoProvider, bool isHorizontal, bool areContainersUniformlySized, double uniformOrAverageContainerSize, long scrollGeneration);
    private void IncrementScrollGeneration();
    private void ExtendPixelAndLogicalSizes(IList children, IList items, int itemCount, IContainItemStorage itemStorageProvider, bool areContainersUniformlySized, double uniformOrAverageContainerSize, double uniformOrAverageContainerPixelSize, Size& stackPixelSize, Size& stackLogicalSize, bool isHorizontal, int pivotIndex, int pivotChildIndex, int firstContainerInViewportIndex, bool before);
    private void ComputeDistance(IList items, IContainItemStorage itemStorageProvider, bool isHorizontal, bool areContainersUniformlySized, double uniformOrAverageContainerSize, int startIndex, int itemCount, Double& distance);
    private void ComputeDistance(IList items, IContainItemStorage itemStorageProvider, bool isHorizontal, bool areContainersUniformlySized, double uniformOrAverageContainerSize, double uniformOrAverageContainerPixelSize, int startIndex, int itemCount, Double& distance, Double& pixelDistance);
    private void GetContainerSizeForItem(IContainItemStorage itemStorageProvider, object item, bool isHorizontal, bool areContainersUniformlySized, double uniformOrAverageContainerSize, Size& containerSize);
    private void GetContainerSizeForItem(IContainItemStorage itemStorageProvider, object item, bool isHorizontal, bool areContainersUniformlySized, double uniformOrAverageContainerSize, double uniformOrAverageContainerPixelSize, Size& containerSize, Size& containerPixelSize);
    private void SetContainerSizeForItem(IContainItemStorage itemStorageProvider, IContainItemStorage parentItemStorageProvider, object parentItem, object item, Size containerSize, bool isHorizontal, Boolean& hasUniformOrAverageContainerSizeBeenSet, Double& uniformOrAverageContainerSize, Boolean& areContainersUniformlySized);
    private void SetContainerSizeForItem(IContainItemStorage itemStorageProvider, IContainItemStorage parentItemStorageProvider, object parentItem, object item, Size containerSize, Size containerPixelSize, bool isHorizontal, bool hasVirtualizingChildren, Boolean& hasUniformOrAverageContainerSizeBeenSet, Double& uniformOrAverageContainerSize, Double& uniformOrAverageContainerPixelSize, Boolean& areContainersUniformlySized, Boolean& hasAnyContainerSpanChanged);
    private Thickness GetItemsHostInsetForChild(IHierarchicalVirtualizationAndScrollInfo virtualizationInfoProvider, IContainItemStorage parentItemStorageProvider, object parentItem);
    private void SetItemsHostInsetForChild(int index, UIElement child, IContainItemStorage itemStorageProvider, bool isHorizontal);
    private static bool AreInsetsClose(double value1, double value2);
    private ItemsControl GetScrollingItemsControl(UIElement container);
    private object GetItemFromContainer(DependencyObject container);
    private bool IsHeaderBeforeItems(bool isHorizontal, FrameworkElement container, Thickness& inset);
    private bool IsEndOfCache(bool isHorizontal, double cacheSize, VirtualizationCacheLengthUnit cacheUnit, Size stackPixelSizeInCache, Size stackLogicalSizeInCache);
    private bool IsEndOfViewport(bool isHorizontal, Rect viewport, Size stackPixelSizeInViewport);
    private bool IsViewportEmpty(bool isHorizontal, Rect viewport);
    private void SetViewportForChild(bool isHorizontal, IContainItemStorage itemStorageProvider, bool areContainersUniformlySized, double uniformOrAverageContainerSize, bool mustDisableVirtualization, UIElement child, IHierarchicalVirtualizationAndScrollInfo virtualizingChild, object item, bool isBeforeFirstItem, bool isAfterFirstItem, double firstItemInViewportOffset, Rect parentViewport, VirtualizationCacheLength parentCacheSize, VirtualizationCacheLengthUnit parentCacheUnit, long scrollGeneration, Size stackPixelSize, Size stackPixelSizeInViewport, Size stackPixelSizeInCacheBeforeViewport, Size stackPixelSizeInCacheAfterViewport, Size stackLogicalSize, Size stackLogicalSizeInViewport, Size stackLogicalSizeInCacheBeforeViewport, Size stackLogicalSizeInCacheAfterViewport, Rect& childViewport, VirtualizationCacheLength& childCacheSize, VirtualizationCacheLengthUnit& childCacheUnit);
    private void InvalidateMeasureOnItemsHost(IHierarchicalVirtualizationAndScrollInfo virtualizingChild);
    private void GetSizesForChild(bool isHorizontal, bool isChildHorizontal, bool isBeforeFirstItem, bool isAfterLastItem, IHierarchicalVirtualizationAndScrollInfo virtualizingChild, Size childDesiredSize, Rect childViewport, VirtualizationCacheLength childCacheSize, VirtualizationCacheLengthUnit childCacheUnit, Size& childPixelSize, Size& childPixelSizeInViewport, Size& childPixelSizeInCacheBeforeViewport, Size& childPixelSizeInCacheAfterViewport, Size& childLogicalSize, Size& childLogicalSizeInViewport, Size& childLogicalSizeInCacheBeforeViewport, Size& childLogicalSizeInCacheAfterViewport);
    private void GetSizesForChildWithInset(bool isHorizontal, bool isChildHorizontal, bool isBeforeFirstItem, bool isAfterLastItem, IHierarchicalVirtualizationAndScrollInfo virtualizingChild, Size childDesiredSize, Rect childViewport, VirtualizationCacheLength childCacheSize, VirtualizationCacheLengthUnit childCacheUnit, Size& childPixelSize, Size& childPixelSizeInViewport, Size& childPixelSizeInCacheBeforeViewport, Size& childPixelSizeInCacheAfterViewport, Size& childLogicalSize, Size& childLogicalSizeInViewport, Size& childLogicalSizeInCacheBeforeViewport, Size& childLogicalSizeInCacheAfterViewport);
    private void GetSizesForChildIntersectingTheViewport(bool isHorizontal, bool childIsHorizontal, Size childPixelSize, Size childLogicalSize, Rect childViewport, Size& childPixelSizeInViewport, Size& childLogicalSizeInViewport, Size& childPixelSizeInCacheBeforeViewport, Size& childLogicalSizeInCacheBeforeViewport, Size& childPixelSizeInCacheAfterViewport, Size& childLogicalSizeInCacheAfterViewport);
    private void UpdateStackSizes(bool isHorizontal, bool foundFirstItemInViewport, Size childPixelSize, Size childPixelSizeInViewport, Size childPixelSizeInCacheBeforeViewport, Size childPixelSizeInCacheAfterViewport, Size childLogicalSize, Size childLogicalSizeInViewport, Size childLogicalSizeInCacheBeforeViewport, Size childLogicalSizeInCacheAfterViewport, Size& stackPixelSize, Size& stackPixelSizeInViewport, Size& stackPixelSizeInCacheBeforeViewport, Size& stackPixelSizeInCacheAfterViewport, Size& stackLogicalSize, Size& stackLogicalSizeInViewport, Size& stackLogicalSizeInCacheBeforeViewport, Size& stackLogicalSizeInCacheAfterViewport);
    private static void StackSizes(bool isHorizontal, Size& sz1, Size sz2);
    private void SyncUniformSizeFlags(object parentItem, IContainItemStorage parentItemStorageProvider, IList children, IList items, IContainItemStorage itemStorageProvider, int itemCount, bool computedAreContainersUniformlySized, double computedUniformOrAverageContainerSize, Boolean& areContainersUniformlySized, Double& uniformOrAverageContainerSize, Boolean& hasAverageContainerSizeChanged, bool isHorizontal, bool evaluateAreContainersUniformlySized);
    private void SyncUniformSizeFlags(object parentItem, IContainItemStorage parentItemStorageProvider, IList children, IList items, IContainItemStorage itemStorageProvider, int itemCount, bool computedAreContainersUniformlySized, double computedUniformOrAverageContainerSize, double computedUniformOrAverageContainerPixelSize, Boolean& areContainersUniformlySized, Double& uniformOrAverageContainerSize, Double& uniformOrAverageContainerPixelSize, Boolean& hasAverageContainerSizeChanged, bool isHorizontal, bool evaluateAreContainersUniformlySized);
    private void ClearAsyncOperations();
    private bool GetAreContainersUniformlySized(IContainItemStorage itemStorageProvider, object item);
    private void SetAreContainersUniformlySized(IContainItemStorage itemStorageProvider, object item, bool value);
    private double GetUniformOrAverageContainerSize(IContainItemStorage itemStorageProvider, object item);
    private void GetUniformOrAverageContainerSize(IContainItemStorage itemStorageProvider, object item, bool isSingleValue, Double& uniformOrAverageContainerSize, Double& uniformOrAverageContainerPixelSize);
    private void GetUniformOrAverageContainerSize(IContainItemStorage itemStorageProvider, object item, bool isSingleValue, Double& uniformOrAverageContainerSize, Double& uniformOrAverageContainerPixelSize, Boolean& hasUniformOrAverageContainerSizeBeenSet);
    private bool SetUniformOrAverageContainerSize(IContainItemStorage itemStorageProvider, object item, double value, double pixelValue);
    private void MeasureExistingChildBeyondExtendedViewport(IItemContainerGenerator& generator, IContainItemStorage& itemStorageProvider, IContainItemStorage& parentItemStorageProvider, Object& parentItem, Boolean& hasUniformOrAverageContainerSizeBeenSet, Double& computedUniformOrAverageContainerSize, Double& computedUniformOrAverageContainerPixelSize, Boolean& computedAreContainersUniformlySized, Boolean& hasAnyContainerSpanChanged, IList& items, IList& children, Int32& childIndex, Boolean& visualOrderChanged, Boolean& isHorizontal, Size& childConstraint, Boolean& foundFirstItemInViewport, Double& firstItemInViewportOffset, Boolean& mustDisableVirtualization, Boolean& hasVirtualizingChildren, Boolean& hasBringIntoViewContainerBeenMeasured, Int64& scrollGeneration);
    private void MeasureChild(IItemContainerGenerator& generator, IContainItemStorage& itemStorageProvider, IContainItemStorage& parentItemStorageProvider, Object& parentItem, Boolean& hasUniformOrAverageContainerSizeBeenSet, Double& computedUniformOrAverageContainerSize, Double& computedUniformOrAverageContainerPixelSize, Boolean& computedAreContainersUniformlySized, Boolean& hasAnyContainerSpanChanged, IList& items, Object& item, IList& children, Int32& childIndex, Boolean& visualOrderChanged, Boolean& isHorizontal, Size& childConstraint, Rect& viewport, VirtualizationCacheLength& cacheSize, VirtualizationCacheLengthUnit& cacheUnit, Int64& scrollGeneration, Boolean& foundFirstItemInViewport, Double& firstItemInViewportOffset, Size& stackPixelSize, Size& stackPixelSizeInViewport, Size& stackPixelSizeInCacheBeforeViewport, Size& stackPixelSizeInCacheAfterViewport, Size& stackLogicalSize, Size& stackLogicalSizeInViewport, Size& stackLogicalSizeInCacheBeforeViewport, Size& stackLogicalSizeInCacheAfterViewport, Boolean& mustDisableVirtualization, bool isBeforeFirstItem, bool isAfterFirstItem, bool isAfterLastItem, bool skipActualMeasure, bool skipGeneration, Boolean& hasBringIntoViewContainerBeenMeasured, Boolean& hasVirtualizingChildren);
    private void ArrangeFirstItemInExtendedViewport(bool isHorizontal, UIElement child, Size childDesiredSize, double arrangeLength, Rect& rcChild, Size& previousChildSize, Point& previousChildOffset, Int32& previousChildItemIndex);
    private void ArrangeOtherItemsInExtendedViewport(bool isHorizontal, UIElement child, Size childDesiredSize, double arrangeLength, int index, Rect& rcChild, Size& previousChildSize, Point& previousChildOffset, Int32& previousChildItemIndex);
    private void ArrangeItemsBeyondTheExtendedViewport(bool isHorizontal, UIElement child, Size childDesiredSize, double arrangeLength, IList items, IItemContainerGenerator generator, IContainItemStorage itemStorageProvider, bool areContainersUniformlySized, double uniformOrAverageContainerSize, bool beforeExtendedViewport, Rect& rcChild, Size& previousChildSize, Point& previousChildOffset, Int32& previousChildItemIndex);
    private void InsertNewContainer(int childIndex, UIElement container);
    private bool InsertRecycledContainer(int childIndex, UIElement container);
    private bool InsertContainer(int childIndex, UIElement container, bool isRecycled);
    private void EnsureCleanupOperation(bool delay);
    private bool PreviousChildIsGenerated(int childIndex);
    private bool AddContainerFromGenerator(int childIndex, UIElement child, bool newlyRealized, bool isBeforeViewport);
    private void OnItemsRemove(ItemsChangedEventArgs args);
    private void OnItemsReplace(ItemsChangedEventArgs args);
    private void OnItemsMove(ItemsChangedEventArgs args);
    private void RemoveChildRange(GeneratorPosition position, int itemCount, int itemUICount);
    private void CleanupContainers(int firstItemInExtendedViewportIndex, int itemsInExtendedViewportCount, ItemsControl itemsControl);
    private bool CleanupContainers(int firstItemInExtendedViewportIndex, int itemsInExtendedViewportCount, ItemsControl itemsControl, bool timeBound, int startTickCount);
    private void EnsureRealizedChildren();
    [ConditionalAttribute("DEBUG")]
private void debug_VerifyRealizedChildren();
    [ConditionalAttribute("DEBUG")]
private void debug_AssertRealizedChildrenEqualVisualChildren();
    private int ChildIndexFromRealizedIndex(int realizedChildIndex);
    private void DisconnectRecycledContainers();
    private GeneratorPosition IndexToGeneratorPositionForStart(int index, Int32& childIndex);
    private void OnDelayCleanup(object sender, EventArgs e);
    private object OnCleanUp(object args);
    private bool CleanUp();
    private bool NotifyCleanupItem(int childIndex, UIElementCollection children, ItemsControl itemsControl);
    private bool NotifyCleanupItem(UIElement child, ItemsControl itemsControl);
    private void CleanupRange(IList children, IItemContainerGenerator generator, int startIndex, int count);
    private void AdjustFirstVisibleChildIndex(int startIndex, int count);
    private int get_MinDesiredGenerated();
    private int get_MaxDesiredGenerated();
    private int get_ItemCount();
    private void EnsureScrollData();
    private static void ResetScrolling(VirtualizingStackPanel element);
    private void OnScrollChange();
    private void SetAndVerifyScrollingData(bool isHorizontal, Rect viewport, Size constraint, UIElement firstContainerInViewport, double firstContainerOffsetFromViewport, bool hasAverageContainerSizeChanged, double newOffset, Size& stackPixelSize, Size& stackLogicalSize, Size& stackPixelSizeInViewport, Size& stackLogicalSizeInViewport, Size& stackPixelSizeInCacheBeforeViewport, Size& stackLogicalSizeInCacheBeforeViewport, Boolean& remeasure, Nullable`1& lastPageSafeOffset, Nullable`1& lastPagePixelSize, List`1& previouslyMeasuredOffsets);
    private void SetAndVerifyScrollingData(bool isHorizontal, Rect viewport, Size constraint, Size& stackPixelSize, Size& stackLogicalSize, Size& stackPixelSizeInViewport, Size& stackLogicalSizeInViewport, Size& stackPixelSizeInCacheBeforeViewport, Size& stackLogicalSizeInCacheBeforeViewport, Boolean& remeasure, Nullable`1& lastPageSafeOffset, List`1& previouslyMeasuredOffsets);
    private void StorePreviouslyMeasuredOffset(List`1& previouslyMeasuredOffsets, double offset);
    private bool WasOffsetPreviouslyMeasured(List`1<double> previouslyMeasuredOffsets, double offset);
    protected virtual void OnViewportSizeChanged(Size oldViewportSize, Size newViewportSize);
    protected virtual void OnViewportOffsetChanged(Vector oldViewportOffset, Vector newViewportOffset);
    protected virtual double GetItemOffsetCore(UIElement child);
    private double FindScrollOffset(Visual v);
    private DependencyObject FindDirectDescendentOfItemsHost(Panel itemsHost, DependencyObject child);
    private void MakeVisiblePhysicalHelper(Rect r, Vector& newOffset, Rect& newRect, bool isHorizontal, Boolean& alignTop, Boolean& alignBottom);
    private void MakeVisibleLogicalHelper(int childIndex, Rect r, Vector& newOffset, Rect& newRect, Boolean& alignTop, Boolean& alignBottom);
    private int GetGeneratedIndex(int childIndex);
    private double GetMaxChildArrangeLength(IList children, bool isHorizontal);
    private static void OnOrientationChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private bool get_HasMeasured();
    private void set_HasMeasured(bool value);
    private bool get_InRecyclingMode();
    private void set_InRecyclingMode(bool value);
    internal bool get_IsScrolling();
    internal bool get_IsPixelBased();
    internal void set_IsPixelBased(bool value);
    internal bool get_MustDisableVirtualization();
    internal void set_MustDisableVirtualization(bool value);
    internal bool get_MeasureCaches();
    internal void set_MeasureCaches(bool value);
    private bool get_IsVirtualizing();
    private void set_IsVirtualizing(bool value);
    private bool get_HasVirtualizingChildren();
    private void set_HasVirtualizingChildren(bool value);
    private bool get_AlignTopOfBringIntoViewContainer();
    private void set_AlignTopOfBringIntoViewContainer(bool value);
    private bool get_AlignBottomOfBringIntoViewContainer();
    private void set_AlignBottomOfBringIntoViewContainer(bool value);
    private bool get_WasLastMeasurePassAnchored();
    private void set_WasLastMeasurePassAnchored(bool value);
    private bool get_ItemsChangedDuringMeasure();
    private void set_ItemsChangedDuringMeasure(bool value);
    private bool get_IsScrollActive();
    private void set_IsScrollActive(bool value);
    internal bool get_IgnoreMaxDesiredSize();
    internal void set_IgnoreMaxDesiredSize(bool value);
    private bool get_IsMeasureCachesPending();
    private void set_IsMeasureCachesPending(bool value);
    [CompilerGeneratedAttribute]
private Nullable`1<bool> get_AreContainersUniformlySized();
    [CompilerGeneratedAttribute]
private void set_AreContainersUniformlySized(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
private Nullable`1<double> get_UniformOrAverageContainerSize();
    [CompilerGeneratedAttribute]
private void set_UniformOrAverageContainerSize(Nullable`1<double> value);
    [CompilerGeneratedAttribute]
private Nullable`1<double> get_UniformOrAverageContainerPixelSize();
    [CompilerGeneratedAttribute]
private void set_UniformOrAverageContainerPixelSize(Nullable`1<double> value);
    private IList get_RealizedChildren();
    internal static bool get_IsVSP45Compat();
    private sealed virtual override bool System.Windows.Controls.IStackMeasure.get_IsScrolling();
    private sealed virtual override UIElementCollection System.Windows.Controls.IStackMeasure.get_InternalChildren();
    private sealed virtual override void System.Windows.Controls.IStackMeasure.OnScrollChange();
    private DependencyObject get_BringIntoViewLeafContainer();
    private FrameworkElement get_FirstContainerInViewport();
    private double get_FirstContainerOffsetFromViewport();
    private double get_ExpectedDistanceBetweenViewports();
    private bool get_CanMouseWheelVerticallyScroll();
    private bool GetBoolField(BoolField field);
    private void SetBoolField(BoolField field, bool value);
    private Snapshot TakeSnapshot();
    private string ContainerPath(DependencyObject container);
    [CompilerGeneratedAttribute]
private void <AnchoredInvalidateMeasure>b__31_0();
    [CompilerGeneratedAttribute]
private void <BringContainerIntoView>b__35_0();
}
internal static class System.Windows.Controls.VisualStates : object {
    internal static string StateToday;
    internal static string StateRegularDay;
    internal static string GroupDay;
    internal static string StateBlackoutDay;
    internal static string StateNormalDay;
    internal static string GroupBlackout;
    public static string StateCalendarButtonUnfocused;
    public static string StateCalendarButtonFocused;
    public static string GroupCalendarButtonFocus;
    public static string StateNormal;
    public static string StateMouseOver;
    public static string StatePressed;
    public static string StateDisabled;
    public static string StateReadOnly;
    internal static string StateDeterminate;
    public static string GroupCommon;
    public static string StateUnfocused;
    public static string StateFocused;
    public static string StateFocusedDropDown;
    public static string GroupFocus;
    public static string StateExpanded;
    public static string StateCollapsed;
    public static string GroupExpansion;
    public static string StateOpen;
    public static string StateClosed;
    public static string GroupOpen;
    public static string StateHasItems;
    public static string StateNoItems;
    public static string GroupHasItems;
    public static string StateExpandDown;
    public static string StateExpandUp;
    public static string StateExpandLeft;
    public static string StateExpandRight;
    public static string GroupExpandDirection;
    public static string StateSelected;
    public static string StateSelectedUnfocused;
    public static string StateSelectedInactive;
    public static string StateUnselected;
    public static string GroupSelection;
    public static string StateEditable;
    public static string StateUneditable;
    public static string GroupEdit;
    public static string StateActive;
    public static string StateInactive;
    public static string GroupActive;
    public static string StateValid;
    public static string StateInvalidFocused;
    public static string StateInvalidUnfocused;
    public static string GroupValidation;
    public static string StateUnwatermarked;
    public static string StateWatermarked;
    public static string GroupWatermark;
    public static string StateChecked;
    public static string StateUnchecked;
    public static string StateIndeterminate;
    public static string GroupCheck;
    public static string StateRegular;
    public static string StateCurrent;
    public static string GroupCurrent;
    public static string StateDisplay;
    public static string StateEditing;
    public static string GroupInteraction;
    public static string StateUnsorted;
    public static string StateSortAscending;
    public static string StateSortDescending;
    public static string GroupSort;
    public static string DATAGRIDROW_stateAlternate;
    public static string DATAGRIDROW_stateMouseOver;
    public static string DATAGRIDROW_stateMouseOverEditing;
    public static string DATAGRIDROW_stateMouseOverEditingFocused;
    public static string DATAGRIDROW_stateMouseOverSelected;
    public static string DATAGRIDROW_stateMouseOverSelectedFocused;
    public static string DATAGRIDROW_stateNormal;
    public static string DATAGRIDROW_stateNormalEditing;
    public static string DATAGRIDROW_stateNormalEditingFocused;
    public static string DATAGRIDROW_stateSelected;
    public static string DATAGRIDROW_stateSelectedFocused;
    public static string DATAGRIDROWHEADER_stateMouseOver;
    public static string DATAGRIDROWHEADER_stateMouseOverCurrentRow;
    public static string DATAGRIDROWHEADER_stateMouseOverEditingRow;
    public static string DATAGRIDROWHEADER_stateMouseOverEditingRowFocused;
    public static string DATAGRIDROWHEADER_stateMouseOverSelected;
    public static string DATAGRIDROWHEADER_stateMouseOverSelectedCurrentRow;
    public static string DATAGRIDROWHEADER_stateMouseOverSelectedCurrentRowFocused;
    public static string DATAGRIDROWHEADER_stateMouseOverSelectedFocused;
    public static string DATAGRIDROWHEADER_stateNormal;
    public static string DATAGRIDROWHEADER_stateNormalCurrentRow;
    public static string DATAGRIDROWHEADER_stateNormalEditingRow;
    public static string DATAGRIDROWHEADER_stateNormalEditingRowFocused;
    public static string DATAGRIDROWHEADER_stateSelected;
    public static string DATAGRIDROWHEADER_stateSelectedCurrentRow;
    public static string DATAGRIDROWHEADER_stateSelectedCurrentRowFocused;
    public static string DATAGRIDROWHEADER_stateSelectedFocused;
    public static void GoToState(Control control, bool useTransitions, String[] stateNames);
}
public class System.Windows.Controls.WebBrowser : ActiveXHost {
    [CompilerGeneratedAttribute]
private NavigatingCancelEventHandler Navigating;
    [CompilerGeneratedAttribute]
private NavigatedEventHandler Navigated;
    [CompilerGeneratedAttribute]
private LoadCompletedEventHandler LoadCompleted;
    internal bool _canGoBack;
    internal bool _canGoForward;
    internal static string AboutBlankUriString;
    private IWebBrowser2 _axIWebBrowser2;
    private WebOCHostingAdaptor _hostingAdaptor;
    private ConnectionPointCookie _cookie;
    private object _objectForScripting;
    private Stream _documentStream;
    private SecurityCriticalDataForSet`1<bool> _navigatingToAboutBlank;
    private SecurityCriticalDataForSet`1<Guid> _lastNavigation;
    public Uri Source { get; public set; }
    public bool CanGoBack { get; }
    public bool CanGoForward { get; }
    public object ObjectForScripting { get; public set; }
    public object Document { get; }
    internal IHTMLDocument2 NativeHTMLDocument { get; }
    [DebuggerBrowsableAttribute("0")]
internal IWebBrowser2 AxIWebBrowser2 { get; }
    internal WebOCHostingAdaptor HostingAdaptor { get; }
    internal Stream DocumentStream { get; internal set; }
    internal bool NavigatingToAboutBlank { get; internal set; }
    internal Guid LastNavigation { get; internal set; }
    private static WebBrowser();
    public void Navigate(Uri source);
    public void Navigate(string source);
    public void Navigate(Uri source, string targetFrameName, Byte[] postData, string additionalHeaders);
    public void Navigate(string source, string targetFrameName, Byte[] postData, string additionalHeaders);
    public void NavigateToStream(Stream stream);
    public void NavigateToString(string text);
    public void GoBack();
    public void GoForward();
    public void Refresh();
    public void Refresh(bool noCache);
    public object InvokeScript(string scriptName);
    public object InvokeScript(string scriptName, Object[] args);
    public void set_Source(Uri value);
    public Uri get_Source();
    public bool get_CanGoBack();
    public bool get_CanGoForward();
    public object get_ObjectForScripting();
    public void set_ObjectForScripting(object value);
    public object get_Document();
    [CompilerGeneratedAttribute]
public void add_Navigating(NavigatingCancelEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_Navigating(NavigatingCancelEventHandler value);
    [CompilerGeneratedAttribute]
public void add_Navigated(NavigatedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_Navigated(NavigatedEventHandler value);
    [CompilerGeneratedAttribute]
public void add_LoadCompleted(LoadCompletedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_LoadCompleted(LoadCompletedEventHandler value);
    internal void OnNavigating(NavigatingCancelEventArgs e);
    internal void OnNavigated(NavigationEventArgs e);
    internal void OnLoadCompleted(NavigationEventArgs e);
    internal virtual object CreateActiveXObject(Guid clsid);
    internal virtual void AttachInterfaces(object nativeActiveXObject);
    internal virtual void DetachInterfaces();
    internal virtual void CreateSink();
    internal virtual void DetachSink();
    internal virtual ActiveXSite CreateActiveXSite();
    internal virtual DrawingGroup GetDrawing();
    internal void CleanInternalState();
    internal IHTMLDocument2 get_NativeHTMLDocument();
    internal IWebBrowser2 get_AxIWebBrowser2();
    internal WebOCHostingAdaptor get_HostingAdaptor();
    internal Stream get_DocumentStream();
    internal void set_DocumentStream(Stream value);
    internal bool get_NavigatingToAboutBlank();
    internal void set_NavigatingToAboutBlank(bool value);
    internal Guid get_LastNavigation();
    internal void set_LastNavigation(Guid value);
    private void LoadedHandler(object sender, RoutedEventArgs args);
    private static void TurnOnFeatureControlKeys();
    private void DoNavigate(Uri source, Object& targetFrameName, Object& postData, Object& headers, bool ignoreEscaping);
    private void SyncUIActiveState();
    protected virtual bool TranslateAcceleratorCore(MSG& msg, ModifierKeys modifiers);
    protected virtual bool TabIntoCore(TraversalRequest request);
}
public class System.Windows.Controls.WrapPanel : Panel {
    public static DependencyProperty ItemWidthProperty;
    public static DependencyProperty ItemHeightProperty;
    public static DependencyProperty OrientationProperty;
    private Orientation _orientation;
    [TypeConverterAttribute("System.Windows.LengthConverter")]
public double ItemWidth { get; public set; }
    [TypeConverterAttribute("System.Windows.LengthConverter")]
public double ItemHeight { get; public set; }
    public Orientation Orientation { get; public set; }
    private static WrapPanel();
    private static bool IsWidthHeightValid(object value);
    public double get_ItemWidth();
    public void set_ItemWidth(double value);
    public double get_ItemHeight();
    public void set_ItemHeight(double value);
    public Orientation get_Orientation();
    public void set_Orientation(Orientation value);
    private static void OnOrientationChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    protected virtual Size MeasureOverride(Size constraint);
    protected virtual Size ArrangeOverride(Size finalSize);
    private void arrangeLine(double v, double lineV, int start, int end, bool useItemU, double itemU);
}
[TypeConverterAttribute("System.Windows.CornerRadiusConverter")]
public class System.Windows.CornerRadius : ValueType {
    private double _topLeft;
    private double _topRight;
    private double _bottomLeft;
    private double _bottomRight;
    public double TopLeft { get; public set; }
    public double TopRight { get; public set; }
    public double BottomRight { get; public set; }
    public double BottomLeft { get; public set; }
    internal bool IsZero { get; }
    public CornerRadius(double uniformRadius);
    public CornerRadius(double topLeft, double topRight, double bottomRight, double bottomLeft);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(CornerRadius cornerRadius);
    public virtual int GetHashCode();
    public virtual string ToString();
    public static bool op_Equality(CornerRadius cr1, CornerRadius cr2);
    public static bool op_Inequality(CornerRadius cr1, CornerRadius cr2);
    public double get_TopLeft();
    public void set_TopLeft(double value);
    public double get_TopRight();
    public void set_TopRight(double value);
    public double get_BottomRight();
    public void set_BottomRight(double value);
    public double get_BottomLeft();
    public void set_BottomLeft(double value);
    internal bool IsValid(bool allowNegative, bool allowNaN, bool allowPositiveInfinity, bool allowNegativeInfinity);
    internal bool get_IsZero();
}
public class System.Windows.CornerRadiusConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext typeDescriptorContext, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext typeDescriptorContext, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext typeDescriptorContext, CultureInfo cultureInfo, object source);
    public virtual object ConvertTo(ITypeDescriptorContext typeDescriptorContext, CultureInfo cultureInfo, object value, Type destinationType);
    internal static string ToString(CornerRadius cr, CultureInfo cultureInfo);
    internal static CornerRadius FromString(string s, CultureInfo cultureInfo);
}
[AttributeUsageAttribute("448")]
internal class System.Windows.CustomCategoryAttribute : CategoryAttribute {
    internal CustomCategoryAttribute(string name);
    protected virtual string GetLocalizedString(string value);
}
public class System.Windows.Data.Binding : BindingBase {
    public static RoutedEvent SourceUpdatedEvent;
    public static RoutedEvent TargetUpdatedEvent;
    public static DependencyProperty XmlNamespaceManagerProperty;
    public static object DoNothing;
    public static string IndexerName;
    private SourceProperties _sourceInUse;
    private PropertyPath _ppath;
    private ObjectRef _source;
    private bool _isAsync;
    private bool _bindsDirectlyToSource;
    private bool _doesNotTransferDefaultValue;
    private int _attachedPropertiesInPath;
    private static ObjectRef UnsetSource;
    private static ObjectRef StaticSourceRef;
    public Collection`1<ValidationRule> ValidationRules { get; }
    [DefaultValueAttribute("False")]
public bool ValidatesOnExceptions { get; public set; }
    [DefaultValueAttribute("False")]
public bool ValidatesOnDataErrors { get; public set; }
    [DefaultValueAttribute("True")]
public bool ValidatesOnNotifyDataErrors { get; public set; }
    public PropertyPath Path { get; public set; }
    [DefaultValueAttribute("")]
public string XPath { get; public set; }
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
public BindingMode Mode { get; public set; }
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
public UpdateSourceTrigger UpdateSourceTrigger { get; public set; }
    [DefaultValueAttribute("False")]
public bool NotifyOnSourceUpdated { get; public set; }
    [DefaultValueAttribute("False")]
public bool NotifyOnTargetUpdated { get; public set; }
    [DefaultValueAttribute("False")]
public bool NotifyOnValidationError { get; public set; }
    [DefaultValueAttribute("")]
public IValueConverter Converter { get; public set; }
    [DefaultValueAttribute("")]
public object ConverterParameter { get; public set; }
    [DefaultValueAttribute("")]
[TypeConverterAttribute("System.Windows.CultureInfoIetfLanguageTagConverter")]
public CultureInfo ConverterCulture { get; public set; }
    public object Source { get; public set; }
    [DefaultValueAttribute("")]
public RelativeSource RelativeSource { get; public set; }
    [DefaultValueAttribute("")]
public string ElementName { get; public set; }
    [DefaultValueAttribute("False")]
public bool IsAsync { get; public set; }
    [DefaultValueAttribute("")]
public object AsyncState { get; public set; }
    [DefaultValueAttribute("False")]
public bool BindsDirectlyToSource { get; public set; }
    [DesignerSerializationVisibilityAttribute("0")]
public UpdateSourceExceptionFilterCallback UpdateSourceExceptionFilter { get; public set; }
    internal CultureInfo ConverterCultureInternal { get; }
    internal ObjectRef SourceReference { get; internal set; }
    internal bool TreeContextIsRequired { get; }
    internal Collection`1<ValidationRule> ValidationRulesInternal { get; }
    internal bool TransfersDefaultValue { get; internal set; }
    internal bool ValidatesOnNotifyDataErrorsInternal { get; }
    public Binding(string path);
    private static Binding();
    public static void AddSourceUpdatedHandler(DependencyObject element, EventHandler`1<DataTransferEventArgs> handler);
    public static void RemoveSourceUpdatedHandler(DependencyObject element, EventHandler`1<DataTransferEventArgs> handler);
    public static void AddTargetUpdatedHandler(DependencyObject element, EventHandler`1<DataTransferEventArgs> handler);
    public static void RemoveTargetUpdatedHandler(DependencyObject element, EventHandler`1<DataTransferEventArgs> handler);
    public static XmlNamespaceManager GetXmlNamespaceManager(DependencyObject target);
    public static void SetXmlNamespaceManager(DependencyObject target, XmlNamespaceManager value);
    private static bool IsValidXmlNamespaceManager(object value);
    public Collection`1<ValidationRule> get_ValidationRules();
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeValidationRules();
    public bool get_ValidatesOnExceptions();
    public void set_ValidatesOnExceptions(bool value);
    public bool get_ValidatesOnDataErrors();
    public void set_ValidatesOnDataErrors(bool value);
    public bool get_ValidatesOnNotifyDataErrors();
    public void set_ValidatesOnNotifyDataErrors(bool value);
    public PropertyPath get_Path();
    public void set_Path(PropertyPath value);
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializePath();
    public string get_XPath();
    public void set_XPath(string value);
    public BindingMode get_Mode();
    public void set_Mode(BindingMode value);
    public UpdateSourceTrigger get_UpdateSourceTrigger();
    public void set_UpdateSourceTrigger(UpdateSourceTrigger value);
    public bool get_NotifyOnSourceUpdated();
    public void set_NotifyOnSourceUpdated(bool value);
    public bool get_NotifyOnTargetUpdated();
    public void set_NotifyOnTargetUpdated(bool value);
    public bool get_NotifyOnValidationError();
    public void set_NotifyOnValidationError(bool value);
    public IValueConverter get_Converter();
    public void set_Converter(IValueConverter value);
    public object get_ConverterParameter();
    public void set_ConverterParameter(object value);
    public CultureInfo get_ConverterCulture();
    public void set_ConverterCulture(CultureInfo value);
    public object get_Source();
    public void set_Source(object value);
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeSource();
    public RelativeSource get_RelativeSource();
    public void set_RelativeSource(RelativeSource value);
    public string get_ElementName();
    public void set_ElementName(string value);
    public bool get_IsAsync();
    public void set_IsAsync(bool value);
    public object get_AsyncState();
    public void set_AsyncState(object value);
    public bool get_BindsDirectlyToSource();
    public void set_BindsDirectlyToSource(bool value);
    public UpdateSourceExceptionFilterCallback get_UpdateSourceExceptionFilter();
    public void set_UpdateSourceExceptionFilter(UpdateSourceExceptionFilterCallback value);
    internal virtual BindingExpressionBase CreateBindingExpressionOverride(DependencyObject target, DependencyProperty dp, BindingExpressionBase owner);
    internal virtual ValidationRule LookupValidationRule(Type type);
    internal object DoFilterException(object bindExpr, Exception exception);
    internal void UsePath(PropertyPath path);
    internal virtual BindingBase CreateClone();
    internal virtual void InitializeClone(BindingBase baseClone, BindingMode mode);
    internal virtual CultureInfo get_ConverterCultureInternal();
    internal ObjectRef get_SourceReference();
    internal void set_SourceReference(ObjectRef value);
    internal bool get_TreeContextIsRequired();
    internal virtual Collection`1<ValidationRule> get_ValidationRulesInternal();
    internal bool get_TransfersDefaultValue();
    internal void set_TransfersDefaultValue(bool value);
    internal virtual bool get_ValidatesOnNotifyDataErrorsInternal();
    private void DetermineSource();
}
[MarkupExtensionReturnTypeAttribute("System.Object")]
[LocalizabilityAttribute("0")]
public abstract class System.Windows.Data.BindingBase : MarkupExtension {
    private BindingFlags _flags;
    private bool _isSealed;
    private UncommonValueTable _values;
    public object FallbackValue { get; public set; }
    [DefaultValueAttribute("")]
public string StringFormat { get; public set; }
    public object TargetNullValue { get; public set; }
    [DefaultValueAttribute("")]
public string BindingGroupName { get; public set; }
    [DefaultValueAttribute("0")]
public int Delay { get; public set; }
    internal BindingFlags Flags { get; }
    internal CultureInfo ConverterCultureInternal { get; }
    internal Collection`1<ValidationRule> ValidationRulesInternal { get; }
    internal bool ValidatesOnNotifyDataErrorsInternal { get; }
    private static BindingBase();
    public object get_FallbackValue();
    public void set_FallbackValue(object value);
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeFallbackValue();
    public string get_StringFormat();
    public void set_StringFormat(string value);
    public object get_TargetNullValue();
    public void set_TargetNullValue(object value);
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeTargetNullValue();
    public string get_BindingGroupName();
    public void set_BindingGroupName(string value);
    public int get_Delay();
    public void set_Delay(int value);
    public sealed virtual object ProvideValue(IServiceProvider serviceProvider);
    internal abstract virtual BindingExpressionBase CreateBindingExpressionOverride(DependencyObject targetObject, DependencyProperty targetProperty, BindingExpressionBase owner);
    internal bool TestFlag(BindingFlags flag);
    internal void SetFlag(BindingFlags flag);
    internal void ClearFlag(BindingFlags flag);
    internal void ChangeFlag(BindingFlags flag, bool value);
    internal BindingFlags GetFlagsWithinMask(BindingFlags mask);
    internal void ChangeFlagsWithinMask(BindingFlags mask, BindingFlags flags);
    internal static BindingFlags FlagsFrom(BindingMode bindingMode);
    internal static BindingFlags FlagsFrom(UpdateSourceTrigger updateSourceTrigger);
    internal BindingFlags get_Flags();
    internal virtual CultureInfo get_ConverterCultureInternal();
    internal virtual Collection`1<ValidationRule> get_ValidationRulesInternal();
    internal virtual bool get_ValidatesOnNotifyDataErrorsInternal();
    internal BindingExpressionBase CreateBindingExpression(DependencyObject targetObject, DependencyProperty targetProperty);
    internal BindingExpressionBase CreateBindingExpression(DependencyObject targetObject, DependencyProperty targetProperty, BindingExpressionBase owner);
    internal void CheckSealed();
    internal ValidationRule GetValidationRule(Type type);
    internal virtual ValidationRule LookupValidationRule(Type type);
    internal static ValidationRule LookupValidationRule(Type type, Collection`1<ValidationRule> collection);
    internal BindingBase Clone(BindingMode mode);
    internal virtual void InitializeClone(BindingBase clone, BindingMode mode);
    internal abstract virtual BindingBase CreateClone();
    internal bool HasValue(Feature id);
    internal object GetValue(Feature id, object defaultValue);
    internal void SetValue(Feature id, object value);
    internal void SetValue(Feature id, object value, object defaultValue);
    internal void ClearValue(Feature id);
    internal void CopyValue(Feature id, BindingBase clone);
}
public class System.Windows.Data.BindingExpression : BindingExpressionBase {
    private WeakReference _ctxElement;
    private object _dataItem;
    private BindingWorker _worker;
    private Type _sourceType;
    internal static object NullDataItem;
    internal static object IgnoreDefaultValue;
    internal static object StaticSource;
    private DependencyObject MS.Internal.Data.IDataBindEngineClient.TargetElement { get; }
    public Binding ParentBinding { get; }
    public object DataItem { get; }
    public object ResolvedSource { get; }
    public string ResolvedSourcePropertyName { get; }
    internal object DataSource { get; }
    internal DependencyObject ContextElement { get; }
    internal CollectionViewSource CollectionViewSource { get; internal set; }
    internal bool IgnoreSourcePropertyChange { get; }
    internal PropertyPath Path { get; }
    internal IValueConverter Converter { get; internal set; }
    internal Type ConverterSourceType { get; }
    internal object SourceItem { get; }
    internal string SourcePropertyName { get; }
    internal object SourceValue { get; }
    internal bool IsParentBindingUpdateTriggerDefault { get; }
    internal bool IsDisconnected { get; }
    private bool CanActivate { get; }
    private BindingWorker Worker { get; }
    private DynamicValueConverter DynamicConverter { get; }
    private DataSourceProvider DataProvider { get; private set; }
    private BindingExpression(Binding binding, BindingExpressionBase owner);
    private static BindingExpression();
    private sealed virtual override void MS.Internal.Data.IDataBindEngineClient.TransferValue();
    private sealed virtual override void MS.Internal.Data.IDataBindEngineClient.UpdateValue();
    private sealed virtual override bool MS.Internal.Data.IDataBindEngineClient.AttachToContext(bool lastChance);
    private sealed virtual override void MS.Internal.Data.IDataBindEngineClient.VerifySourceReference(bool lastChance);
    private sealed virtual override void MS.Internal.Data.IDataBindEngineClient.OnTargetUpdated();
    private sealed virtual override DependencyObject MS.Internal.Data.IDataBindEngineClient.get_TargetElement();
    public Binding get_ParentBinding();
    public object get_DataItem();
    public object get_ResolvedSource();
    public string get_ResolvedSourcePropertyName();
    internal object get_DataSource();
    public virtual void UpdateSource();
    public virtual void UpdateTarget();
    internal virtual void OnPropertyInvalidation(DependencyObject d, DependencyPropertyChangedEventArgs args);
    internal virtual void InvalidateChild(BindingExpressionBase bindingExpression);
    internal virtual void ChangeSourcesForChild(BindingExpressionBase bindingExpression, WeakDependencySource[] newSources);
    internal virtual void ReplaceChild(BindingExpressionBase bindingExpression);
    internal virtual void UpdateBindingGroup(BindingGroup bg);
    internal DependencyObject get_ContextElement();
    internal CollectionViewSource get_CollectionViewSource();
    internal void set_CollectionViewSource(CollectionViewSource value);
    internal bool get_IgnoreSourcePropertyChange();
    internal PropertyPath get_Path();
    internal IValueConverter get_Converter();
    internal void set_Converter(IValueConverter value);
    internal Type get_ConverterSourceType();
    internal object get_SourceItem();
    internal string get_SourcePropertyName();
    internal object get_SourceValue();
    internal virtual bool get_IsParentBindingUpdateTriggerDefault();
    internal virtual bool get_IsDisconnected();
    internal static BindingExpression CreateBindingExpression(DependencyObject d, DependencyProperty dp, Binding binding, BindingExpressionBase parent);
    internal void SetupDefaultValueConverter(Type type);
    internal static bool HasLocalDataContext(DependencyObject d);
    private bool get_CanActivate();
    private BindingWorker get_Worker();
    private DynamicValueConverter get_DynamicConverter();
    private DataSourceProvider get_DataProvider();
    private void set_DataProvider(DataSourceProvider value);
    internal virtual bool AttachOverride(DependencyObject target, DependencyProperty dp);
    internal virtual void DetachOverride();
    private void AttachToContext(AttachAttempt attempt);
    private void DetachFromContext();
    internal virtual void Activate();
    internal void Activate(object item);
    private object GetInitialValue(DependencyObject target, ValidationError& error);
    internal virtual void Deactivate();
    internal virtual void Disconnect();
    private object DereferenceDataProvider(object item);
    internal virtual object GetSourceItem(object newValue);
    private void CreateWorker();
    internal void ChangeWorkerSources(WeakDependencySource[] newWorkerSources, int n);
    private void TransferValue();
    internal void TransferValue(object newValue, bool isASubPropertyChange);
    private void ValidateOnTargetUpdated();
    private ValidationError RunValidationRule(ValidationRule validationRule, object value, CultureInfo culture);
    private object ConvertHelper(IValueConverter converter, object value, Type targetType, object parameter, CultureInfo culture);
    private object ConvertBackHelper(IValueConverter converter, object value, Type sourceType, object parameter, CultureInfo culture);
    internal void ScheduleTransfer(bool isASubPropertyChange);
    private void OnTargetUpdated();
    private void OnSourceUpdated();
    internal virtual bool ShouldReactToDirtyOverride();
    internal virtual bool UpdateOverride();
    internal virtual object ConvertProposedValue(object value);
    internal virtual bool ObtainConvertedProposedValue(BindingGroup bindingGroup);
    internal virtual object UpdateSource(object value);
    internal virtual bool UpdateSource(BindingGroup bindingGroup);
    internal virtual void StoreValueInBindingGroup(object value, BindingGroup bindingGroup);
    internal virtual bool Validate(object value, ValidationStep validationStep);
    internal virtual bool CheckValidationRules(BindingGroup bindingGroup, ValidationStep validationStep);
    internal virtual bool ValidateAndConvertProposedValue(Collection`1& values);
    private bool IsValidValueForUpdate(object value, Type sourceType);
    private void ProcessException(Exception ex, bool validate);
    private bool ShouldIgnoreUpdate();
    internal void UpdateNotifyDataErrors(INotifyDataErrorInfo indei, string propertyName, object value);
    private void UpdateNotifyDataErrors(object value);
    internal static List`1<object> GetDataErrors(INotifyDataErrorInfo indei, string propertyName);
    private List`1<object> MergeErrors(List`1<object> list1, List`1<object> list2);
    private void OnDataContextChanged(DependencyObject contextElement);
    internal void OnCurrentChanged(object sender, EventArgs e);
    internal void OnCurrentChanging(object sender, CurrentChangingEventArgs e);
    private void OnDataChanged(object sender, EventArgs e);
    private void OnInheritanceContextChanged(object sender, EventArgs e);
    internal virtual void OnLostFocus(object sender, RoutedEventArgs e);
    private void OnErrorsChanged(object sender, DataErrorsChangedEventArgs e);
    private sealed virtual override bool System.Windows.IWeakEventListener.ReceiveWeakEvent(Type managerType, object sender, EventArgs e);
    private object CallDoFilterException(Exception ex);
    private bool ExceptionFilterExists();
    internal IDisposable ChangingValue();
    internal void CancelPendingTasks();
    private void Replace();
    internal static void OnTargetUpdated(DependencyObject d, DependencyProperty dp);
    internal static void OnSourceUpdated(DependencyObject d, DependencyProperty dp);
    internal virtual void HandlePropertyInvalidation(DependencyObject d, DependencyPropertyChangedEventArgs args);
    private void SetDataItem(object newItem);
    private object GetDataSourceForDataContext(DependencyObject d);
    [CompilerGeneratedAttribute]
private object <OnErrorsChanged>b__108_0(object arg);
}
public abstract class System.Windows.Data.BindingExpressionBase : Expression {
    [CompilerGeneratedAttribute]
private EventHandler`1<BindingValueChangedEventArgs> ValueChanged;
    internal static DependencyProperty NoTargetProperty;
    private BindingBase _binding;
    private WeakReference _targetElement;
    private DependencyProperty _targetProperty;
    private DataBindEngine _engine;
    private PrivateFlags _flags;
    private object _value;
    private BindingStatusInternal _status;
    private WeakDependencySource[] _sources;
    private object _culture;
    internal static object DefaultValueObject;
    internal static object DisconnectedItem;
    private static WeakReference`1<BindingGroup> NullBindingGroupReference;
    private UncommonValueTable _values;
    public DependencyObject Target { get; }
    public DependencyProperty TargetProperty { get; }
    public BindingBase ParentBindingBase { get; }
    public BindingGroup BindingGroup { get; }
    public BindingStatus Status { get; }
    internal BindingStatusInternal StatusInternal { get; }
    public ValidationError ValidationError { get; }
    internal ValidationError BaseValidationError { get; }
    internal List`1<ValidationError> NotifyDataErrors { get; }
    public bool HasError { get; }
    public bool HasValidationError { get; }
    public bool IsDirty { get; }
    public ReadOnlyCollection`1<ValidationError> ValidationErrors { get; }
    internal bool IsAttaching { get; internal set; }
    internal bool IsDetaching { get; internal set; }
    internal bool IsDetached { get; }
    private bool IsAttached { get; }
    internal bool IsDynamic { get; }
    internal bool IsReflective { get; internal set; }
    internal bool UseDefaultValueConverter { get; internal set; }
    internal bool IsOneWayToSource { get; }
    internal bool IsUpdateOnPropertyChanged { get; }
    internal bool IsUpdateOnLostFocus { get; }
    internal bool IsTransferPending { get; internal set; }
    internal bool TransferIsDeferred { get; internal set; }
    internal bool IsInTransfer { get; internal set; }
    internal bool IsInUpdate { get; internal set; }
    internal bool UsingFallbackValue { get; internal set; }
    internal bool UsingMentor { get; internal set; }
    internal bool ResolveNamesInTemplate { get; internal set; }
    internal bool NeedsDataTransfer { get; internal set; }
    internal bool NeedsUpdate { get; internal set; }
    internal bool NeedsValidation { get; internal set; }
    internal bool NotifyOnTargetUpdated { get; internal set; }
    internal bool NotifyOnSourceUpdated { get; internal set; }
    internal bool NotifyOnValidationError { get; internal set; }
    internal bool IsInPriorityBindingExpression { get; }
    internal bool IsInMultiBindingExpression { get; }
    internal bool IsInBindingExpressionCollection { get; }
    internal bool ValidatesOnExceptions { get; }
    internal bool ValidatesOnDataErrors { get; }
    internal bool TargetWantsCrossThreadNotifications { get; internal set; }
    internal bool IsDataErrorsChangedPending { get; internal set; }
    internal bool IsUpdateDeferredForComposition { get; internal set; }
    internal bool ValidatesOnNotifyDataErrors { get; }
    internal MultiBindingExpression ParentMultiBindingExpression { get; }
    internal PriorityBindingExpression ParentPriorityBindingExpression { get; }
    internal BindingExpressionBase ParentBindingExpressionBase { get; }
    internal object FallbackValue { get; }
    internal object DefaultValue { get; }
    internal string EffectiveStringFormat { get; }
    internal object EffectiveTargetNullValue { get; }
    internal BindingExpressionBase RootBindingExpression { get; }
    internal bool IsParentBindingUpdateTriggerDefault { get; }
    internal bool UsesLanguage { get; }
    internal bool IsEligibleForCommit { get; }
    internal DependencyObject TargetElement { get; }
    internal WeakReference TargetElementReference { get; }
    internal DataBindEngine Engine { get; }
    internal Dispatcher Dispatcher { get; }
    internal object Value { get; internal set; }
    internal WeakDependencySource[] WeakSources { get; }
    internal bool IsDisconnected { get; }
    internal TraceEventType TraceLevel { get; }
    private static BindingExpressionBase();
    internal BindingExpressionBase(BindingBase binding, BindingExpressionBase parent);
    public DependencyObject get_Target();
    public DependencyProperty get_TargetProperty();
    public BindingBase get_ParentBindingBase();
    public BindingGroup get_BindingGroup();
    public BindingStatus get_Status();
    internal BindingStatusInternal get_StatusInternal();
    public virtual ValidationError get_ValidationError();
    internal ValidationError get_BaseValidationError();
    internal List`1<ValidationError> get_NotifyDataErrors();
    public virtual bool get_HasError();
    public virtual bool get_HasValidationError();
    public bool get_IsDirty();
    public virtual ReadOnlyCollection`1<ValidationError> get_ValidationErrors();
    public virtual void UpdateTarget();
    public virtual void UpdateSource();
    public bool ValidateWithoutUpdate();
    internal sealed virtual void OnAttach(DependencyObject d, DependencyProperty dp);
    internal sealed virtual void OnDetach(DependencyObject d, DependencyProperty dp);
    internal virtual object GetValue(DependencyObject d, DependencyProperty dp);
    internal virtual bool SetValue(DependencyObject d, DependencyProperty dp, object value);
    internal virtual void OnPropertyInvalidation(DependencyObject d, DependencyPropertyChangedEventArgs args);
    internal virtual DependencySource[] GetSources();
    internal virtual Expression Copy(DependencyObject targetObject, DependencyProperty targetDP);
    private sealed virtual override bool System.Windows.IWeakEventListener.ReceiveWeakEvent(Type managerType, object sender, EventArgs e);
    internal static BindingExpressionBase CreateUntargetedBindingExpression(DependencyObject d, BindingBase binding);
    internal void Attach(DependencyObject d);
    [CompilerGeneratedAttribute]
internal void add_ValueChanged(EventHandler`1<BindingValueChangedEventArgs> value);
    [CompilerGeneratedAttribute]
internal void remove_ValueChanged(EventHandler`1<BindingValueChangedEventArgs> value);
    internal bool get_IsAttaching();
    internal void set_IsAttaching(bool value);
    internal bool get_IsDetaching();
    internal void set_IsDetaching(bool value);
    internal bool get_IsDetached();
    private bool get_IsAttached();
    internal bool get_IsDynamic();
    internal bool get_IsReflective();
    internal void set_IsReflective(bool value);
    internal bool get_UseDefaultValueConverter();
    internal void set_UseDefaultValueConverter(bool value);
    internal bool get_IsOneWayToSource();
    internal bool get_IsUpdateOnPropertyChanged();
    internal bool get_IsUpdateOnLostFocus();
    internal bool get_IsTransferPending();
    internal void set_IsTransferPending(bool value);
    internal bool get_TransferIsDeferred();
    internal void set_TransferIsDeferred(bool value);
    internal bool get_IsInTransfer();
    internal void set_IsInTransfer(bool value);
    internal bool get_IsInUpdate();
    internal void set_IsInUpdate(bool value);
    internal bool get_UsingFallbackValue();
    internal void set_UsingFallbackValue(bool value);
    internal bool get_UsingMentor();
    internal void set_UsingMentor(bool value);
    internal bool get_ResolveNamesInTemplate();
    internal void set_ResolveNamesInTemplate(bool value);
    internal bool get_NeedsDataTransfer();
    internal void set_NeedsDataTransfer(bool value);
    internal bool get_NeedsUpdate();
    internal void set_NeedsUpdate(bool value);
    internal bool get_NeedsValidation();
    internal void set_NeedsValidation(bool value);
    internal bool get_NotifyOnTargetUpdated();
    internal void set_NotifyOnTargetUpdated(bool value);
    internal bool get_NotifyOnSourceUpdated();
    internal void set_NotifyOnSourceUpdated(bool value);
    internal bool get_NotifyOnValidationError();
    internal void set_NotifyOnValidationError(bool value);
    internal bool get_IsInPriorityBindingExpression();
    internal bool get_IsInMultiBindingExpression();
    internal bool get_IsInBindingExpressionCollection();
    internal bool get_ValidatesOnExceptions();
    internal bool get_ValidatesOnDataErrors();
    internal bool get_TargetWantsCrossThreadNotifications();
    internal void set_TargetWantsCrossThreadNotifications(bool value);
    internal bool get_IsDataErrorsChangedPending();
    internal void set_IsDataErrorsChangedPending(bool value);
    internal bool get_IsUpdateDeferredForComposition();
    internal void set_IsUpdateDeferredForComposition(bool value);
    internal bool get_ValidatesOnNotifyDataErrors();
    internal MultiBindingExpression get_ParentMultiBindingExpression();
    internal PriorityBindingExpression get_ParentPriorityBindingExpression();
    internal BindingExpressionBase get_ParentBindingExpressionBase();
    internal object get_FallbackValue();
    internal object get_DefaultValue();
    internal string get_EffectiveStringFormat();
    internal object get_EffectiveTargetNullValue();
    internal BindingExpressionBase get_RootBindingExpression();
    internal virtual bool get_IsParentBindingUpdateTriggerDefault();
    internal bool get_UsesLanguage();
    internal bool get_IsEligibleForCommit();
    internal virtual bool AttachOverride(DependencyObject target, DependencyProperty dp);
    internal virtual void DetachOverride();
    internal abstract virtual void InvalidateChild(BindingExpressionBase bindingExpression);
    internal abstract virtual void ChangeSourcesForChild(BindingExpressionBase bindingExpression, WeakDependencySource[] newSources);
    internal abstract virtual void ReplaceChild(BindingExpressionBase bindingExpression);
    internal abstract virtual void HandlePropertyInvalidation(DependencyObject d, DependencyPropertyChangedEventArgs args);
    private object HandlePropertyInvalidationOperation(object o);
    internal void OnBindingGroupChanged(bool joining);
    private object RestoreUpdateTriggerOperation(object arg);
    internal abstract virtual void UpdateBindingGroup(BindingGroup bg);
    internal bool UpdateValue();
    internal virtual object GetRawProposedValue();
    internal abstract virtual object ConvertProposedValue(object rawValue);
    internal abstract virtual bool ObtainConvertedProposedValue(BindingGroup bindingGroup);
    internal abstract virtual object UpdateSource(object convertedValue);
    internal abstract virtual bool UpdateSource(BindingGroup bindingGroup);
    internal virtual object CommitSource(object value);
    internal abstract virtual void StoreValueInBindingGroup(object value, BindingGroup bindingGroup);
    internal virtual bool Validate(object value, ValidationStep validationStep);
    internal abstract virtual bool CheckValidationRules(BindingGroup bindingGroup, ValidationStep validationStep);
    internal abstract virtual bool ValidateAndConvertProposedValue(Collection`1& values);
    internal CultureInfo GetCulture();
    internal void InvalidateCulture();
    internal void BeginSourceUpdate();
    internal void EndSourceUpdate();
    private object UpdateTargetCallback(object unused);
    internal bool ShouldUpdateWithCurrentValue(DependencyObject target, Object& currentValue);
    internal void ChangeValue(object newValue, bool notify);
    internal void Clean();
    internal void Dirty();
    private bool ShouldReactToDirty();
    internal virtual bool ShouldReactToDirtyOverride();
    private void ProcessDirty();
    private void OnTimerTick(object sender, EventArgs e);
    private void OnPreviewTextInput(object sender, TextCompositionEventArgs e);
    internal void Invalidate(bool isASubPropertyChange);
    internal object UseFallbackValue();
    internal static bool IsNullValue(object value);
    internal object NullValueForType(Type type);
    internal ValidationRule LookupValidationRule(Type type);
    internal void JoinBindingGroup(bool isReflective, DependencyObject contextElement);
    internal void LeaveBindingGroup();
    internal void RejoinBindingGroup(bool isReflective, DependencyObject contextElement);
    internal BindingGroup FindBindingGroup(bool isReflective, DependencyObject contextElement);
    internal void JoinBindingGroup(BindingGroup bg, bool explicitJoin);
    private void MarkAsNonGrouped();
    internal void NotifyCommitManager();
    internal virtual void UpdateCommitState();
    internal void AdoptProperties(BindingExpressionBase bb);
    internal virtual bool ReceiveWeakEvent(Type managerType, object sender, EventArgs e);
    internal virtual void OnLostFocus(object sender, RoutedEventArgs e);
    internal abstract virtual object GetSourceItem(object newValue);
    private bool TestFlag(PrivateFlags flag);
    private void ChangeFlag(PrivateFlags flag, bool value);
    internal DependencyObject get_TargetElement();
    internal WeakReference get_TargetElementReference();
    internal DataBindEngine get_Engine();
    internal Dispatcher get_Dispatcher();
    internal object get_Value();
    internal void set_Value(object value);
    internal WeakDependencySource[] get_WeakSources();
    internal virtual bool get_IsDisconnected();
    internal void Attach(DependencyObject target, DependencyProperty dp);
    internal void Detach();
    internal virtual void Disconnect();
    internal void SetStatus(BindingStatusInternal status);
    internal static object ConvertFallbackValue(object value, DependencyProperty dp, object sender);
    internal static object ConvertTargetNullValue(object value, DependencyProperty dp, object sender);
    private static object ConvertValue(object value, DependencyProperty dp, Exception& e);
    internal TraceEventType get_TraceLevel();
    internal virtual void Activate();
    internal virtual void Deactivate();
    internal bool Update();
    internal virtual bool UpdateOverride();
    internal void UpdateValidationError(ValidationError validationError, bool skipBindingGroup);
    internal void UpdateNotifyDataErrorValidationErrors(List`1<object> errors);
    internal static void GetValidationDelta(List`1<ValidationError> previousErrors, List`1<object> errors, List`1& toAdd, List`1& toRemove);
    internal void AddValidationError(ValidationError validationError, bool skipBindingGroup);
    internal void RemoveValidationError(ValidationError validationError, bool skipBindingGroup);
    internal ValidationError GetValidationErrors(ValidationStep validationStep);
    internal void ChangeSources(WeakDependencySource[] newSources);
    internal static WeakDependencySource[] CombineSources(int index, Collection`1<BindingExpressionBase> bindingExpressions, int count, WeakDependencySource[] newSources, WeakDependencySource[] commonSources);
    internal void ResolvePropertyDefaultSettings(BindingMode mode, UpdateSourceTrigger updateTrigger, FrameworkPropertyMetadata fwMetaData);
    internal UpdateSourceTrigger GetDefaultUpdateSourceTrigger(FrameworkPropertyMetadata fwMetaData);
    internal void SetUpdateSourceTrigger(UpdateSourceTrigger ust);
    internal Type GetEffectiveTargetType();
    internal void DetermineEffectiveStringFormat();
    internal void DetermineEffectiveTargetNullValue();
    private void DetermineEffectiveUpdateBehavior();
    internal void DetermineEffectiveValidatesOnNotifyDataErrors();
    internal static object CreateReference(object item);
    internal static object CreateReference(WeakReference item);
    internal static object ReplaceReference(object oldReference, object item);
    internal static object GetReference(object reference);
    internal static void InitializeTracing(BindingExpressionBase expr, DependencyObject d, DependencyProperty dp);
    private void ChangeSources(DependencyObject target, DependencyProperty dp, WeakDependencySource[] newSources);
    internal bool HasValue(Feature id);
    internal object GetValue(Feature id, object defaultValue);
    internal void SetValue(Feature id, object value);
    internal void SetValue(Feature id, object value, object defaultValue);
    internal void ClearValue(Feature id);
}
public class System.Windows.Data.BindingGroup : DependencyObject {
    [CompilerGeneratedAttribute]
private bool <IsEditing>k__BackingField;
    private ValidationRuleCollection _validationRules;
    private string _name;
    private bool _notifyOnValidationError;
    private bool _sharesProposedValues;
    private bool _validatesOnNotifyDataError;
    private DataBindEngine _engine;
    private BindingExpressionCollection _bindingExpressions;
    private bool _isItemsValid;
    private ValidationStep _validationStep;
    private GetValueTable _getValueTable;
    private ProposedValueTable _proposedValueTable;
    private BindingExpression[] _proposedValueBindingExpressions;
    private Collection`1<WeakReference> _itemsRW;
    private WeakReadOnlyCollection`1<object> _items;
    private CultureInfo _culture;
    private Dictionary`2<WeakReference, List`1<ValidationError>> _notifyDataErrors;
    internal static object DeferredTargetValue;
    internal static object DeferredSourceValue;
    private static WeakReference`1<DependencyObject> NullInheritanceContext;
    private WeakReference`1<DependencyObject> _inheritanceContext;
    private bool _hasMultipleInheritanceContexts;
    public DependencyObject Owner { get; }
    public Collection`1<ValidationRule> ValidationRules { get; }
    public Collection`1<BindingExpressionBase> BindingExpressions { get; }
    public string Name { get; public set; }
    public bool NotifyOnValidationError { get; public set; }
    public bool ValidatesOnNotifyDataError { get; public set; }
    public bool SharesProposedValues { get; public set; }
    public bool CanRestoreValues { get; }
    public IList Items { get; }
    public bool IsDirty { get; }
    public bool HasValidationError { get; }
    public ReadOnlyCollection`1<ValidationError> ValidationErrors { get; }
    private DataBindEngine Engine { get; }
    internal DependencyObject InheritanceContext { get; }
    internal bool HasMultipleInheritanceContexts { get; }
    private bool IsEditing { get; private set; }
    private bool IsItemsValid { get; private set; }
    private bool ValidatesOnDataTransfer { get; }
    internal BindingGroup(BindingGroup master);
    private static BindingGroup();
    private void Initialize();
    public DependencyObject get_Owner();
    public Collection`1<ValidationRule> get_ValidationRules();
    public Collection`1<BindingExpressionBase> get_BindingExpressions();
    public string get_Name();
    public void set_Name(string value);
    public bool get_NotifyOnValidationError();
    public void set_NotifyOnValidationError(bool value);
    public bool get_ValidatesOnNotifyDataError();
    public void set_ValidatesOnNotifyDataError(bool value);
    public bool get_SharesProposedValues();
    public void set_SharesProposedValues(bool value);
    public bool get_CanRestoreValues();
    public IList get_Items();
    public bool get_IsDirty();
    public bool get_HasValidationError();
    public ReadOnlyCollection`1<ValidationError> get_ValidationErrors();
    private bool GetValidationErrors(ValidationErrorCollection& superset, Boolean& isPure);
    private bool Belongs(ValidationError error);
    private DataBindEngine get_Engine();
    public void BeginEdit();
    public bool CommitEdit();
    public void CancelEdit();
    public bool ValidateWithoutUpdate();
    public bool UpdateSources();
    public object GetValue(object item, string propertyName);
    public bool TryGetValue(object item, string propertyName, Object& value);
    private bool TryGetValueImpl(object item, string propertyName, Object& value);
    internal virtual DependencyObject get_InheritanceContext();
    internal virtual void AddInheritanceContext(DependencyObject context, DependencyProperty property);
    internal virtual void RemoveInheritanceContext(DependencyObject context, DependencyProperty property);
    internal virtual bool get_HasMultipleInheritanceContexts();
    private void CheckDetach(DependencyObject newOwner);
    [CompilerGeneratedAttribute]
private bool get_IsEditing();
    [CompilerGeneratedAttribute]
private void set_IsEditing(bool value);
    private bool get_IsItemsValid();
    private void set_IsItemsValid(bool value);
    internal void UpdateTable(BindingExpression bindingExpression);
    internal void AddToValueTable(BindingExpressionBase bindingExpressionBase);
    internal object GetValue(BindingExpressionBase bindingExpressionBase);
    internal void SetValue(BindingExpressionBase bindingExpressionBase, object value);
    internal void UseSourceValue(BindingExpressionBase bindingExpressionBase);
    internal ProposedValueEntry GetProposedValueEntry(object item, string propertyName);
    internal void RemoveProposedValueEntry(ProposedValueEntry entry);
    internal void AddBindingForProposedValue(BindingExpressionBase dependent, object item, string propertyName);
    internal void AddValidationError(ValidationError validationError);
    internal void RemoveValidationError(ValidationError validationError);
    private void ClearValidationErrors(ValidationStep validationStep);
    private void ClearValidationErrors();
    private void ClearValidationErrorsImpl(ValidationStep validationStep, bool allSteps);
    private void EnsureItems();
    private bool get_ValidatesOnDataTransfer();
    private void OnLayoutUpdated(object sender, EventArgs e);
    private void OnDataContextChanged(object sender, DependencyPropertyChangedEventArgs e);
    private void ValidateOnDataTransfer();
    private bool UpdateAndValidate(ValidationStep validationStep);
    private void UpdateNotifyDataErrors(INotifyDataErrorInfo indei, WeakReference itemWR);
    private void UpdateNotifyDataErrorValidationErrors(WeakReference itemWR, List`1<object> errors);
    private bool ObtainConvertedProposedValues();
    private bool UpdateValues();
    private bool CheckValidationRules();
    private bool CommitValues();
    private static int FindIndexOf(WeakReference wr, IList`1<WeakReference> list);
    private static int FindIndexOf(object item, IList`1<WeakReference> list);
    private CultureInfo GetCulture();
    private void OnBindingsChanged(object sender, NotifyCollectionChangedEventArgs e);
    private void RemoveBindingExpression(BindingExpressionBase exprBase);
    private void RemoveAllBindingExpressions();
    private void PreserveProposedValues(Collection`1<ProposedValue> proposedValues);
    private void PrepareProposedValuesForUpdate(DependencyObject mentor, bool isUpdating);
    private void ResetProposedValuesAfterUpdate(DependencyObject mentor, bool isFullUpdate);
    private void NotifyCommitManager();
    private void OnErrorsChanged(object sender, DataErrorsChangedEventArgs e);
    [CompilerGeneratedAttribute]
private object <OnErrorsChanged>b__93_0(object arg);
}
public class System.Windows.Data.BindingListCollectionView : CollectionView {
    private IBindingList _internalList;
    private CollectionViewGroupRoot _group;
    private bool _isGrouping;
    private IBindingListView _blv;
    private BindingListSortDescriptionCollection _sort;
    private IList _shadowList;
    private bool _isSorted;
    private IComparer _comparer;
    private string _customFilter;
    private bool _isFiltered;
    private bool _ignoreInnerRefresh;
    private Nullable`1<bool> _itemsRaisePropertyChanged;
    private bool _isDataView;
    private object _newItem;
    private object _editItem;
    private int _newItemIndex;
    private NewItemPlaceholderPosition _newItemPlaceholderPosition;
    private List`1<Action> _deferredActions;
    private bool _isRemoving;
    private Nullable`1<bool> _isLiveGrouping;
    private bool _isLiveShapingDirty;
    private ObservableCollection`1<string> _liveSortingProperties;
    private ObservableCollection`1<string> _liveFilteringProperties;
    private ObservableCollection`1<string> _liveGroupingProperties;
    private IList _cachedList;
    public SortDescriptionCollection SortDescriptions { get; }
    public bool CanSort { get; }
    private IComparer ActiveComparer { get; private set; }
    public bool CanFilter { get; }
    public string CustomFilter { get; public set; }
    public bool CanCustomFilter { get; }
    public bool CanGroup { get; }
    public ObservableCollection`1<GroupDescription> GroupDescriptions { get; }
    public ReadOnlyObservableCollection`1<object> Groups { get; }
    [DefaultValueAttribute("")]
public GroupDescriptionSelectorCallback GroupBySelector { get; public set; }
    public int Count { get; }
    public bool IsEmpty { get; }
    public bool IsDataInGroupOrder { get; public set; }
    public NewItemPlaceholderPosition NewItemPlaceholderPosition { get; public set; }
    public bool CanAddNew { get; }
    public bool IsAddingNew { get; }
    public object CurrentAddItem { get; }
    public bool CanRemove { get; }
    public bool CanCancelEdit { get; }
    public bool IsEditingItem { get; }
    public object CurrentEditItem { get; }
    public bool CanChangeLiveSorting { get; }
    public bool CanChangeLiveFiltering { get; }
    public bool CanChangeLiveGrouping { get; }
    public Nullable`1<bool> IsLiveSorting { get; public set; }
    public Nullable`1<bool> IsLiveFiltering { get; public set; }
    public Nullable`1<bool> IsLiveGrouping { get; public set; }
    public ObservableCollection`1<string> LiveSortingProperties { get; }
    public ObservableCollection`1<string> LiveFilteringProperties { get; }
    public ObservableCollection`1<string> LiveGroupingProperties { get; }
    public ReadOnlyCollection`1<ItemPropertyInfo> ItemProperties { get; }
    private int InternalCount { get; }
    private bool IsDataView { get; }
    private bool IsCurrentInView { get; }
    private IList CollectionProxy { get; }
    private IBindingList InternalList { get; private set; }
    private bool IsCustomFilterSet { get; }
    private bool CanGroupNamesChange { get; }
    internal bool IsLiveShapingDirty { get; internal set; }
    public BindingListCollectionView(IBindingList list);
    public virtual bool PassesFilter(object item);
    public virtual bool Contains(object item);
    public virtual bool MoveCurrentToPosition(int position);
    private sealed virtual override int System.Collections.IComparer.Compare(object o1, object o2);
    public virtual int IndexOf(object item);
    public virtual object GetItemAt(int index);
    protected virtual IEnumerator GetEnumerator();
    public virtual void DetachFromSourceCollection();
    public virtual SortDescriptionCollection get_SortDescriptions();
    public virtual bool get_CanSort();
    private IComparer get_ActiveComparer();
    private void set_ActiveComparer(IComparer value);
    public virtual bool get_CanFilter();
    public string get_CustomFilter();
    public void set_CustomFilter(string value);
    public bool get_CanCustomFilter();
    public virtual bool get_CanGroup();
    public virtual ObservableCollection`1<GroupDescription> get_GroupDescriptions();
    public virtual ReadOnlyObservableCollection`1<object> get_Groups();
    public GroupDescriptionSelectorCallback get_GroupBySelector();
    public void set_GroupBySelector(GroupDescriptionSelectorCallback value);
    public virtual int get_Count();
    public virtual bool get_IsEmpty();
    public bool get_IsDataInGroupOrder();
    public void set_IsDataInGroupOrder(bool value);
    public sealed virtual NewItemPlaceholderPosition get_NewItemPlaceholderPosition();
    public sealed virtual void set_NewItemPlaceholderPosition(NewItemPlaceholderPosition value);
    public sealed virtual bool get_CanAddNew();
    public sealed virtual object AddNew();
    private void BeginAddNew(object newItem, int index);
    public sealed virtual void CommitNew();
    public sealed virtual void CancelNew();
    private object EndAddNew(bool cancel);
    private NotifyCollectionChangedEventArgs ProcessCommitNew(int fromIndex, int toIndex);
    private void CommitNewForGrouping();
    public sealed virtual bool get_IsAddingNew();
    public sealed virtual object get_CurrentAddItem();
    private void SetNewItem(object item);
    public sealed virtual bool get_CanRemove();
    public sealed virtual void RemoveAt(int index);
    public sealed virtual void Remove(object item);
    private void RemoveImpl(object item, int index);
    public sealed virtual void EditItem(object item);
    public sealed virtual void CommitEdit();
    public sealed virtual void CancelEdit();
    private void ImplicitlyCancelEdit();
    public sealed virtual bool get_CanCancelEdit();
    public sealed virtual bool get_IsEditingItem();
    public sealed virtual object get_CurrentEditItem();
    private void SetEditItem(object item);
    public sealed virtual bool get_CanChangeLiveSorting();
    public sealed virtual bool get_CanChangeLiveFiltering();
    public sealed virtual bool get_CanChangeLiveGrouping();
    public sealed virtual Nullable`1<bool> get_IsLiveSorting();
    public sealed virtual void set_IsLiveSorting(Nullable`1<bool> value);
    public sealed virtual Nullable`1<bool> get_IsLiveFiltering();
    public sealed virtual void set_IsLiveFiltering(Nullable`1<bool> value);
    public sealed virtual Nullable`1<bool> get_IsLiveGrouping();
    public sealed virtual void set_IsLiveGrouping(Nullable`1<bool> value);
    public sealed virtual ObservableCollection`1<string> get_LiveSortingProperties();
    public sealed virtual ObservableCollection`1<string> get_LiveFilteringProperties();
    public sealed virtual ObservableCollection`1<string> get_LiveGroupingProperties();
    private void OnLivePropertyListChanged(object sender, NotifyCollectionChangedEventArgs e);
    public sealed virtual ReadOnlyCollection`1<ItemPropertyInfo> get_ItemProperties();
    protected virtual void RefreshOverride();
    protected virtual void OnAllowsCrossThreadChangesChanged();
    private void PrepareCachedList();
    private void RebuildLists();
    private void RebuildListsCore();
    [ObsoleteAttribute("Replaced by OnAllowsCrossThreadChangesChanged")]
protected virtual void OnBeginChangeLogging(NotifyCollectionChangedEventArgs args);
    protected virtual void ProcessCollectionChanged(NotifyCollectionChangedEventArgs args);
    private int get_InternalCount();
    private bool get_IsDataView();
    private int InternalIndexOf(object item);
    private object InternalItemAt(int index);
    private bool InternalContains(object item);
    private IEnumerator InternalGetEnumerator();
    private void AdjustShadowCopy(NotifyCollectionChangedEventArgs e);
    private bool get_IsCurrentInView();
    private void _MoveTo(int proposed);
    private void SubscribeToChanges();
    private void OnListChanged(object sender, ListChangedEventArgs args);
    private void AdjustCurrencyForAdd(int index);
    private bool AdjustCurrencyForRemove(int index);
    private void AdjustCurrencyForMove(int oldIndex, int newIndex);
    private bool AdjustCurrencyForReplace(int index);
    private void MoveCurrencyOffDeletedElement(int oldCurrentPosition);
    private IList get_CollectionProxy();
    private IBindingList get_InternalList();
    private void set_InternalList(IBindingList value);
    private bool get_IsCustomFilterSet();
    private bool get_CanGroupNamesChange();
    private void SortDescriptionsChanged(object sender, NotifyCollectionChangedEventArgs e);
    private ListSortDescriptionCollection ConvertSortDescriptionCollection(SortDescriptionCollection sorts);
    private void InitializeGrouping();
    private void PrepareGroups();
    private void OnGroupChanged(object sender, NotifyCollectionChangedEventArgs e);
    private void OnGroupByChanged(object sender, NotifyCollectionChangedEventArgs e);
    private void OnGroupDescriptionChanged(object sender, EventArgs e);
    private void AddItemToGroups(object item);
    private void RemoveItemFromGroups(object item);
    private LiveShapingFlags GetLiveShapingFlags();
    internal void RestoreLiveShaping();
    internal bool get_IsLiveShapingDirty();
    internal void set_IsLiveShapingDirty(bool value);
    private void OnLiveShapingDirty(object sender, EventArgs e);
    private void ValidateCollectionChangedEventArgs(NotifyCollectionChangedEventArgs e);
    private void OnPropertyChanged(string propertyName);
    private void DeferAction(Action action);
    private void DoDeferredActions();
    [CompilerGeneratedAttribute]
private void <RefreshOverride>b__96_0();
    [CompilerGeneratedAttribute]
private void <RefreshOverride>b__96_1();
    [CompilerGeneratedAttribute]
private void <PrepareCachedList>b__98_0();
    [CompilerGeneratedAttribute]
private void <SubscribeToChanges>b__115_0();
}
public enum System.Windows.Data.BindingMode : Enum {
    public int value__;
    public static BindingMode TwoWay;
    public static BindingMode OneWay;
    public static BindingMode OneTime;
    public static BindingMode OneWayToSource;
    public static BindingMode Default;
}
public static class System.Windows.Data.BindingOperations : object {
    [CompilerGeneratedAttribute]
private static EventHandler`1<CollectionRegisteringEventArgs> CollectionRegistering;
    [CompilerGeneratedAttribute]
private static EventHandler`1<CollectionViewRegisteringEventArgs> CollectionViewRegistering;
    private static ExceptionLogger _exceptionLogger;
    public static object DisconnectedSource { get; }
    internal static bool IsCleanupEnabled { get; internal set; }
    internal static bool TraceAccessorTableSize { get; internal set; }
    public static object get_DisconnectedSource();
    public static BindingExpressionBase SetBinding(DependencyObject target, DependencyProperty dp, BindingBase binding);
    public static BindingBase GetBindingBase(DependencyObject target, DependencyProperty dp);
    public static Binding GetBinding(DependencyObject target, DependencyProperty dp);
    public static PriorityBinding GetPriorityBinding(DependencyObject target, DependencyProperty dp);
    public static MultiBinding GetMultiBinding(DependencyObject target, DependencyProperty dp);
    public static BindingExpressionBase GetBindingExpressionBase(DependencyObject target, DependencyProperty dp);
    public static BindingExpression GetBindingExpression(DependencyObject target, DependencyProperty dp);
    public static MultiBindingExpression GetMultiBindingExpression(DependencyObject target, DependencyProperty dp);
    public static PriorityBindingExpression GetPriorityBindingExpression(DependencyObject target, DependencyProperty dp);
    public static void ClearBinding(DependencyObject target, DependencyProperty dp);
    public static void ClearAllBindings(DependencyObject target);
    public static bool IsDataBound(DependencyObject target, DependencyProperty dp);
    public static void EnableCollectionSynchronization(IEnumerable collection, object context, CollectionSynchronizationCallback synchronizationCallback);
    public static void EnableCollectionSynchronization(IEnumerable collection, object lockObject);
    public static void DisableCollectionSynchronization(IEnumerable collection);
    public static void AccessCollection(IEnumerable collection, Action accessMethod, bool writeAccess);
    public static ReadOnlyCollection`1<BindingExpressionBase> GetSourceUpdatingBindings(DependencyObject root);
    public static ReadOnlyCollection`1<BindingGroup> GetSourceUpdatingBindingGroups(DependencyObject root);
    [CompilerGeneratedAttribute]
public static void add_CollectionRegistering(EventHandler`1<CollectionRegisteringEventArgs> value);
    [CompilerGeneratedAttribute]
public static void remove_CollectionRegistering(EventHandler`1<CollectionRegisteringEventArgs> value);
    [CompilerGeneratedAttribute]
public static void add_CollectionViewRegistering(EventHandler`1<CollectionViewRegisteringEventArgs> value);
    [CompilerGeneratedAttribute]
public static void remove_CollectionViewRegistering(EventHandler`1<CollectionViewRegisteringEventArgs> value);
    internal static bool IsValidUpdateSourceTrigger(UpdateSourceTrigger value);
    internal static bool get_IsCleanupEnabled();
    internal static void set_IsCleanupEnabled(bool value);
    internal static bool Cleanup();
    internal static void PrintStats();
    internal static bool get_TraceAccessorTableSize();
    internal static void set_TraceAccessorTableSize(bool value);
    internal static void OnCollectionRegistering(IEnumerable collection, object parent);
    internal static void OnCollectionViewRegistering(CollectionView view);
    internal static IDisposable EnableExceptionLogging();
    internal static void LogException(Exception ex);
}
public enum System.Windows.Data.BindingStatus : Enum {
    public int value__;
    public static BindingStatus Unattached;
    public static BindingStatus Inactive;
    public static BindingStatus Active;
    public static BindingStatus Detached;
    public static BindingStatus AsyncRequestPending;
    public static BindingStatus PathError;
    public static BindingStatus UpdateTargetError;
    public static BindingStatus UpdateSourceError;
}
internal enum System.Windows.Data.BindingStatusInternal : Enum {
    public byte value__;
    public static BindingStatusInternal Unattached;
    public static BindingStatusInternal Inactive;
    public static BindingStatusInternal Active;
    public static BindingStatusInternal Detached;
    public static BindingStatusInternal AsyncRequestPending;
    public static BindingStatusInternal PathError;
    public static BindingStatusInternal UpdateTargetError;
    public static BindingStatusInternal UpdateSourceError;
}
public class System.Windows.Data.CollectionContainer : DependencyObject {
    public static DependencyProperty CollectionProperty;
    [CompilerGeneratedAttribute]
private NotifyCollectionChangedEventHandler CollectionChanged;
    private TraceLog _traceLog;
    private ICollectionView _view;
    private IndexedEnumerable _viewList;
    public IEnumerable Collection { get; public set; }
    internal ICollectionView View { get; }
    internal int ViewCount { get; }
    internal bool ViewIsEmpty { get; }
    private IndexedEnumerable ViewList { get; }
    private static CollectionContainer();
    public IEnumerable get_Collection();
    public void set_Collection(IEnumerable value);
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeCollection();
    internal ICollectionView get_View();
    internal int get_ViewCount();
    internal bool get_ViewIsEmpty();
    internal object ViewItem(int index);
    internal int ViewIndexOf(object item);
    internal void GetCollectionChangedSources(int level, Action`4<int, object, Nullable`1<bool>, List`1<string>> format, List`1<string> sources);
    private sealed virtual override void System.Collections.Specialized.INotifyCollectionChanged.add_CollectionChanged(NotifyCollectionChangedEventHandler value);
    private sealed virtual override void System.Collections.Specialized.INotifyCollectionChanged.remove_CollectionChanged(NotifyCollectionChangedEventHandler value);
    [CompilerGeneratedAttribute]
protected virtual void add_CollectionChanged(NotifyCollectionChangedEventHandler value);
    [CompilerGeneratedAttribute]
protected virtual void remove_CollectionChanged(NotifyCollectionChangedEventHandler value);
    protected virtual void OnContainedCollectionChanged(NotifyCollectionChangedEventArgs args);
    private sealed virtual override bool System.Windows.IWeakEventListener.ReceiveWeakEvent(Type managerType, object sender, EventArgs e);
    protected virtual bool ReceiveWeakEvent(Type managerType, object sender, EventArgs e);
    private IndexedEnumerable get_ViewList();
    private static object OnGetCollection(DependencyObject d);
    private static void OnCollectionPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private void HookUpToCollection(IEnumerable newCollection, bool shouldRaiseChangeEvent);
    private void OnCollectionChanged(object sender, NotifyCollectionChangedEventArgs e);
    private void InitializeTraceLog();
}
public class System.Windows.Data.CollectionRegisteringEventArgs : EventArgs {
    private IEnumerable _collection;
    private object _parent;
    public IEnumerable Collection { get; }
    public object Parent { get; }
    internal CollectionRegisteringEventArgs(IEnumerable collection, object parent);
    public IEnumerable get_Collection();
    public object get_Parent();
}
public class System.Windows.Data.CollectionSynchronizationCallback : MulticastDelegate {
    public CollectionSynchronizationCallback(object object, IntPtr method);
    public virtual void Invoke(IEnumerable collection, object context, Action accessMethod, bool writeAccess);
    public virtual IAsyncResult BeginInvoke(IEnumerable collection, object context, Action accessMethod, bool writeAccess, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Windows.Data.CollectionView : DispatcherObject {
    [CompilerGeneratedAttribute]
private CurrentChangingEventHandler CurrentChanging;
    [CompilerGeneratedAttribute]
private EventHandler CurrentChanged;
    [CompilerGeneratedAttribute]
private NotifyCollectionChangedEventHandler CollectionChanged;
    [CompilerGeneratedAttribute]
private PropertyChangedEventHandler PropertyChanged;
    private ArrayList _changeLog;
    private ArrayList _tempChangeLog;
    private DataBindOperation _databindOperation;
    private object _vmData;
    private IEnumerable _sourceCollection;
    private CultureInfo _culture;
    private SimpleMonitor _currentChangedMonitor;
    private int _deferLevel;
    private IndexedEnumerable _enumerableWrapper;
    private Predicate`1<object> _filter;
    private object _currentItem;
    private int _currentPosition;
    private CollectionViewFlags _flags;
    private bool _currentElementWasRemovedOrReplaced;
    private static object _newItemPlaceholder;
    private object _syncObject;
    private DataBindEngine _engine;
    private int _timestamp;
    private static ArrayList EmptyArrayList;
    private static string IEnumerableT;
    internal static object NoNewItem;
    private static CurrentChangingEventArgs uncancelableCurrentChangingEventArgs;
    internal static string CountPropertyName;
    internal static string IsEmptyPropertyName;
    internal static string CulturePropertyName;
    internal static string CurrentPositionPropertyName;
    internal static string CurrentItemPropertyName;
    internal static string IsCurrentBeforeFirstPropertyName;
    internal static string IsCurrentAfterLastPropertyName;
    [TypeConverterAttribute("System.Windows.CultureInfoIetfLanguageTagConverter")]
public CultureInfo Culture { get; public set; }
    public IEnumerable SourceCollection { get; }
    public Predicate`1<object> Filter { get; public set; }
    public bool CanFilter { get; }
    public SortDescriptionCollection SortDescriptions { get; }
    public bool CanSort { get; }
    public bool CanGroup { get; }
    public ObservableCollection`1<GroupDescription> GroupDescriptions { get; }
    public ReadOnlyObservableCollection`1<object> Groups { get; }
    public object CurrentItem { get; }
    public int CurrentPosition { get; }
    public bool IsCurrentAfterLast { get; }
    public bool IsCurrentBeforeFirst { get; }
    public int Count { get; }
    public bool IsEmpty { get; }
    public IComparer Comparer { get; }
    public bool NeedsRefresh { get; }
    public bool IsInUse { get; }
    public static object NewItemPlaceholder { get; }
    protected bool IsDynamic { get; }
    protected bool AllowsCrossThreadChanges { get; }
    protected bool UpdatedOutsideDispatcher { get; }
    protected bool IsRefreshDeferred { get; }
    protected bool IsCurrentInSync { get; }
    internal object SyncRoot { get; }
    internal int Timestamp { get; }
    private bool IsCurrentInView { get; }
    private IndexedEnumerable EnumerableWrapper { get; }
    public CollectionView(IEnumerable collection);
    internal CollectionView(IEnumerable collection, int moveToFirst);
    internal CollectionView(IEnumerable collection, bool shouldProcessCollectionChanged);
    private static CollectionView();
    public virtual CultureInfo get_Culture();
    public virtual void set_Culture(CultureInfo value);
    public virtual bool Contains(object item);
    public virtual IEnumerable get_SourceCollection();
    public virtual Predicate`1<object> get_Filter();
    public virtual void set_Filter(Predicate`1<object> value);
    public virtual bool get_CanFilter();
    public virtual SortDescriptionCollection get_SortDescriptions();
    public virtual bool get_CanSort();
    public virtual bool get_CanGroup();
    public virtual ObservableCollection`1<GroupDescription> get_GroupDescriptions();
    public virtual ReadOnlyObservableCollection`1<object> get_Groups();
    public virtual void Refresh();
    internal void RefreshInternal();
    public virtual IDisposable DeferRefresh();
    public virtual object get_CurrentItem();
    public virtual int get_CurrentPosition();
    public virtual bool get_IsCurrentAfterLast();
    public virtual bool get_IsCurrentBeforeFirst();
    public virtual bool MoveCurrentToFirst();
    public virtual bool MoveCurrentToLast();
    public virtual bool MoveCurrentToNext();
    public virtual bool MoveCurrentToPrevious();
    public virtual bool MoveCurrentTo(object item);
    public virtual bool MoveCurrentToPosition(int position);
    [CompilerGeneratedAttribute]
public virtual void add_CurrentChanging(CurrentChangingEventHandler value);
    [CompilerGeneratedAttribute]
public virtual void remove_CurrentChanging(CurrentChangingEventHandler value);
    [CompilerGeneratedAttribute]
public virtual void add_CurrentChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public virtual void remove_CurrentChanged(EventHandler value);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public virtual bool PassesFilter(object item);
    public virtual int IndexOf(object item);
    public virtual object GetItemAt(int index);
    public virtual void DetachFromSourceCollection();
    public virtual int get_Count();
    public virtual bool get_IsEmpty();
    public virtual IComparer get_Comparer();
    public virtual bool get_NeedsRefresh();
    public virtual bool get_IsInUse();
    public static object get_NewItemPlaceholder();
    [CompilerGeneratedAttribute]
protected virtual void add_CollectionChanged(NotifyCollectionChangedEventHandler value);
    [CompilerGeneratedAttribute]
protected virtual void remove_CollectionChanged(NotifyCollectionChangedEventHandler value);
    private sealed virtual override void System.Collections.Specialized.INotifyCollectionChanged.add_CollectionChanged(NotifyCollectionChangedEventHandler value);
    private sealed virtual override void System.Collections.Specialized.INotifyCollectionChanged.remove_CollectionChanged(NotifyCollectionChangedEventHandler value);
    private sealed virtual override void System.ComponentModel.INotifyPropertyChanged.add_PropertyChanged(PropertyChangedEventHandler value);
    private sealed virtual override void System.ComponentModel.INotifyPropertyChanged.remove_PropertyChanged(PropertyChangedEventHandler value);
    protected virtual void OnPropertyChanged(PropertyChangedEventArgs e);
    [CompilerGeneratedAttribute]
protected virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
protected virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
    protected virtual void RefreshOverride();
    protected virtual IEnumerator GetEnumerator();
    protected virtual void OnCollectionChanged(NotifyCollectionChangedEventArgs args);
    protected void SetCurrent(object newItem, int newPosition);
    protected void SetCurrent(object newItem, int newPosition, int count);
    protected bool OKToChangeCurrent();
    protected void OnCurrentChanging();
    protected virtual void OnCurrentChanging(CurrentChangingEventArgs args);
    protected virtual void OnCurrentChanged();
    protected virtual void ProcessCollectionChanged(NotifyCollectionChangedEventArgs args);
    protected void OnCollectionChanged(object sender, NotifyCollectionChangedEventArgs args);
    protected virtual void OnAllowsCrossThreadChangesChanged();
    protected void ClearPendingChanges();
    protected void ProcessPendingChanges();
    [ObsoleteAttribute("Replaced by OnAllowsCrossThreadChangesChanged")]
protected virtual void OnBeginChangeLogging(NotifyCollectionChangedEventArgs args);
    [ObsoleteAttribute("Replaced by ClearPendingChanges")]
protected void ClearChangeLog();
    protected void RefreshOrDefer();
    protected bool get_IsDynamic();
    protected bool get_AllowsCrossThreadChanges();
    internal void SetAllowsCrossThreadChanges(bool value);
    protected bool get_UpdatedOutsideDispatcher();
    protected bool get_IsRefreshDeferred();
    protected bool get_IsCurrentInSync();
    internal void SetViewManagerData(object value);
    internal virtual bool HasReliableHashCodes();
    internal void VerifyRefreshNotDeferred();
    internal void InvalidateEnumerableWrapper();
    internal ReadOnlyCollection`1<ItemPropertyInfo> GetItemProperties();
    internal Type GetItemType(bool useRepresentativeItem);
    internal object GetRepresentativeItem();
    internal virtual void GetCollectionChangedSources(int level, Action`4<int, object, Nullable`1<bool>, List`1<string>> format, List`1<string> sources);
    internal object get_SyncRoot();
    internal int get_Timestamp();
    private bool get_IsCurrentInView();
    private IndexedEnumerable get_EnumerableWrapper();
    private void _MoveCurrentToPosition(int position);
    private void MoveCurrencyOffDeletedElement();
    private void EndDefer();
    private void DeferProcessing(ICollection changeLog);
    private ICollection ProcessChangeLog(ArrayList changeLog, bool processAll);
    private bool CheckFlag(CollectionViewFlags flags);
    private void SetFlag(CollectionViewFlags flags, bool value);
    private void PostChange(NotifyCollectionChangedEventArgs args);
    private object ProcessInvoke(object arg);
    private void ValidateCollectionChangedEventArgs(NotifyCollectionChangedEventArgs e);
    private void AdjustCurrencyForAdd(int index);
    private void AdjustCurrencyForRemove(int index);
    private void AdjustCurrencyForMove(int oldIndex, int newIndex);
    private void AdjustCurrencyForReplace(int index);
    private void OnPropertyChanged(string propertyName);
}
public abstract class System.Windows.Data.CollectionViewGroup : object {
    [CompilerGeneratedAttribute]
private PropertyChangedEventHandler PropertyChanged;
    private object _name;
    private ObservableCollection`1<object> _itemsRW;
    private ReadOnlyObservableCollection`1<object> _itemsRO;
    private int _itemCount;
    public object Name { get; }
    public ReadOnlyObservableCollection`1<object> Items { get; }
    public int ItemCount { get; }
    public bool IsBottomLevel { get; }
    protected ObservableCollection`1<object> ProtectedItems { get; }
    protected int ProtectedItemCount { get; protected set; }
    protected CollectionViewGroup(object name);
    public object get_Name();
    public ReadOnlyObservableCollection`1<object> get_Items();
    public int get_ItemCount();
    public abstract virtual bool get_IsBottomLevel();
    private sealed virtual override void System.ComponentModel.INotifyPropertyChanged.add_PropertyChanged(PropertyChangedEventHandler value);
    private sealed virtual override void System.ComponentModel.INotifyPropertyChanged.remove_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
protected virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
protected virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
    protected virtual void OnPropertyChanged(PropertyChangedEventArgs e);
    protected ObservableCollection`1<object> get_ProtectedItems();
    protected int get_ProtectedItemCount();
    protected void set_ProtectedItemCount(int value);
}
public class System.Windows.Data.CollectionViewRegisteringEventArgs : EventArgs {
    private CollectionView _view;
    public CollectionView CollectionView { get; }
    internal CollectionViewRegisteringEventArgs(CollectionView view);
    public CollectionView get_CollectionView();
}
public class System.Windows.Data.CollectionViewSource : DependencyObject {
    private static DependencyPropertyKey ViewPropertyKey;
    public static DependencyProperty ViewProperty;
    public static DependencyProperty SourceProperty;
    public static DependencyProperty CollectionViewTypeProperty;
    private static DependencyPropertyKey CanChangeLiveSortingPropertyKey;
    public static DependencyProperty CanChangeLiveSortingProperty;
    public static DependencyProperty IsLiveSortingRequestedProperty;
    private static DependencyPropertyKey IsLiveSortingPropertyKey;
    public static DependencyProperty IsLiveSortingProperty;
    private static DependencyPropertyKey CanChangeLiveFilteringPropertyKey;
    public static DependencyProperty CanChangeLiveFilteringProperty;
    public static DependencyProperty IsLiveFilteringRequestedProperty;
    private static DependencyPropertyKey IsLiveFilteringPropertyKey;
    public static DependencyProperty IsLiveFilteringProperty;
    private static DependencyPropertyKey CanChangeLiveGroupingPropertyKey;
    public static DependencyProperty CanChangeLiveGroupingProperty;
    public static DependencyProperty IsLiveGroupingRequestedProperty;
    private static DependencyPropertyKey IsLiveGroupingPropertyKey;
    public static DependencyProperty IsLiveGroupingProperty;
    private CultureInfo _culture;
    private SortDescriptionCollection _sort;
    private ObservableCollection`1<GroupDescription> _groupBy;
    private ObservableCollection`1<string> _liveSortingProperties;
    private ObservableCollection`1<string> _liveFilteringProperties;
    private ObservableCollection`1<string> _liveGroupingProperties;
    private bool _isInitializing;
    private bool _isViewInitialized;
    private int _version;
    private int _deferLevel;
    private DataSourceProvider _dataProvider;
    private FilterStub _filterStub;
    private DependencyObject _inheritanceContext;
    private bool _hasMultipleInheritanceContexts;
    private DependencyProperty _propertyForInheritanceContext;
    internal static CollectionViewSource DefaultSource;
    private static UncommonField`1<FilterEventHandler> FilterHandlersField;
    [ReadOnlyAttribute("True")]
public ICollectionView View { get; }
    public object Source { get; public set; }
    public Type CollectionViewType { get; public set; }
    [TypeConverterAttribute("System.Windows.CultureInfoIetfLanguageTagConverter")]
public CultureInfo Culture { get; public set; }
    public SortDescriptionCollection SortDescriptions { get; }
    public ObservableCollection`1<GroupDescription> GroupDescriptions { get; }
    [ReadOnlyAttribute("True")]
public bool CanChangeLiveSorting { get; private set; }
    public bool IsLiveSortingRequested { get; public set; }
    [ReadOnlyAttribute("True")]
public Nullable`1<bool> IsLiveSorting { get; private set; }
    public ObservableCollection`1<string> LiveSortingProperties { get; }
    [ReadOnlyAttribute("True")]
public bool CanChangeLiveFiltering { get; private set; }
    public bool IsLiveFilteringRequested { get; public set; }
    [ReadOnlyAttribute("True")]
public Nullable`1<bool> IsLiveFiltering { get; private set; }
    public ObservableCollection`1<string> LiveFilteringProperties { get; }
    [ReadOnlyAttribute("True")]
public bool CanChangeLiveGrouping { get; private set; }
    public bool IsLiveGroupingRequested { get; public set; }
    [ReadOnlyAttribute("True")]
public Nullable`1<bool> IsLiveGrouping { get; private set; }
    public ObservableCollection`1<string> LiveGroupingProperties { get; }
    internal CollectionView CollectionView { get; }
    internal DependencyProperty PropertyForInheritanceContext { get; }
    internal DependencyObject InheritanceContext { get; }
    internal bool HasMultipleInheritanceContexts { get; }
    private Predicate`1<object> FilterWrapper { get; }
    internal int EffectiveValuesInitialSize { get; }
    private static CollectionViewSource();
    public ICollectionView get_View();
    public object get_Source();
    public void set_Source(object value);
    private static void OnSourceChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    protected virtual void OnSourceChanged(object oldSource, object newSource);
    private static bool IsSourceValid(object o);
    private static bool IsValidSourceForView(object o);
    public Type get_CollectionViewType();
    public void set_CollectionViewType(Type value);
    private static void OnCollectionViewTypeChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    protected virtual void OnCollectionViewTypeChanged(Type oldCollectionViewType, Type newCollectionViewType);
    private static bool IsCollectionViewTypeValid(object o);
    public CultureInfo get_Culture();
    public void set_Culture(CultureInfo value);
    public SortDescriptionCollection get_SortDescriptions();
    public ObservableCollection`1<GroupDescription> get_GroupDescriptions();
    public bool get_CanChangeLiveSorting();
    private void set_CanChangeLiveSorting(bool value);
    public bool get_IsLiveSortingRequested();
    public void set_IsLiveSortingRequested(bool value);
    private static void OnIsLiveSortingRequestedChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public Nullable`1<bool> get_IsLiveSorting();
    private void set_IsLiveSorting(Nullable`1<bool> value);
    public ObservableCollection`1<string> get_LiveSortingProperties();
    public bool get_CanChangeLiveFiltering();
    private void set_CanChangeLiveFiltering(bool value);
    public bool get_IsLiveFilteringRequested();
    public void set_IsLiveFilteringRequested(bool value);
    private static void OnIsLiveFilteringRequestedChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public Nullable`1<bool> get_IsLiveFiltering();
    private void set_IsLiveFiltering(Nullable`1<bool> value);
    public ObservableCollection`1<string> get_LiveFilteringProperties();
    public bool get_CanChangeLiveGrouping();
    private void set_CanChangeLiveGrouping(bool value);
    public bool get_IsLiveGroupingRequested();
    public void set_IsLiveGroupingRequested(bool value);
    private static void OnIsLiveGroupingRequestedChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public Nullable`1<bool> get_IsLiveGrouping();
    private void set_IsLiveGrouping(Nullable`1<bool> value);
    public ObservableCollection`1<string> get_LiveGroupingProperties();
    public void add_Filter(FilterEventHandler value);
    public void remove_Filter(FilterEventHandler value);
    public static ICollectionView GetDefaultView(object source);
    private static ICollectionView LazyGetDefaultView(object source);
    public static bool IsDefaultView(ICollectionView view);
    public IDisposable DeferRefresh();
    private sealed virtual override void System.ComponentModel.ISupportInitialize.BeginInit();
    private sealed virtual override void System.ComponentModel.ISupportInitialize.EndInit();
    private sealed virtual override bool System.Windows.IWeakEventListener.ReceiveWeakEvent(Type managerType, object sender, EventArgs e);
    protected virtual bool ReceiveWeakEvent(Type managerType, object sender, EventArgs e);
    internal CollectionView get_CollectionView();
    internal DependencyProperty get_PropertyForInheritanceContext();
    internal static CollectionView GetDefaultCollectionView(object source, bool createView, Func`2<object, object> GetSourceItem);
    internal static CollectionView GetDefaultCollectionView(object source, DependencyObject d, Func`2<object, object> GetSourceItem);
    internal virtual DependencyObject get_InheritanceContext();
    internal virtual void AddInheritanceContext(DependencyObject context, DependencyProperty property);
    internal virtual void RemoveInheritanceContext(DependencyObject context, DependencyProperty property);
    internal virtual bool get_HasMultipleInheritanceContexts();
    internal bool IsShareableInTemplate();
    private void EnsureView();
    private void EnsureView(object source, Type collectionViewType);
    private void ApplyPropertiesToView(ICollectionView view);
    private static ICollectionView GetOriginalView(ICollectionView view);
    private Predicate`1<object> get_FilterWrapper();
    private bool WrapFilter(object item);
    private void OnDataChanged(object sender, EventArgs e);
    private void OnForwardedCollectionChanged(object sender, NotifyCollectionChangedEventArgs e);
    private void OnForwardedPropertyChanged();
    private void BeginDefer();
    private void EndDefer();
    internal virtual int get_EffectiveValuesInitialSize();
    [CompilerGeneratedAttribute]
private object <EnsureView>b__103_0(object x);
}
[DefaultMemberAttribute("Item")]
[LocalizabilityAttribute("16")]
public class System.Windows.Data.CompositeCollection : object {
    [CompilerGeneratedAttribute]
private NotifyCollectionChangedEventHandler CollectionChanged;
    [CompilerGeneratedAttribute]
private NotifyCollectionChangedEventHandler ContainedCollectionChanged;
    private ArrayList _internalList;
    public int Count { get; }
    public object Item { get; public set; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private ArrayList InternalList { get; }
    public CompositeCollection(int capacity);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void CopyTo(Array array, int index);
    public sealed virtual int Add(object newItem);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(object containItem);
    public sealed virtual int IndexOf(object indexItem);
    public sealed virtual void Insert(int insertIndex, object insertItem);
    public sealed virtual void Remove(object removeItem);
    public sealed virtual void RemoveAt(int removeIndex);
    private sealed virtual override ICollectionView System.ComponentModel.ICollectionViewFactory.CreateView();
    public sealed virtual int get_Count();
    public sealed virtual object get_Item(int itemIndex);
    public sealed virtual void set_Item(int itemIndex, object value);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override void System.Collections.Specialized.INotifyCollectionChanged.add_CollectionChanged(NotifyCollectionChangedEventHandler value);
    private sealed virtual override void System.Collections.Specialized.INotifyCollectionChanged.remove_CollectionChanged(NotifyCollectionChangedEventHandler value);
    [CompilerGeneratedAttribute]
protected void add_CollectionChanged(NotifyCollectionChangedEventHandler value);
    [CompilerGeneratedAttribute]
protected void remove_CollectionChanged(NotifyCollectionChangedEventHandler value);
    private sealed virtual override bool System.Windows.IWeakEventListener.ReceiveWeakEvent(Type managerType, object sender, EventArgs e);
    protected virtual bool ReceiveWeakEvent(Type managerType, object sender, EventArgs e);
    [CompilerGeneratedAttribute]
internal void add_ContainedCollectionChanged(NotifyCollectionChangedEventHandler value);
    [CompilerGeneratedAttribute]
internal void remove_ContainedCollectionChanged(NotifyCollectionChangedEventHandler value);
    private void OnContainedCollectionChanged(object sender, NotifyCollectionChangedEventArgs e);
    private void Initialize(ArrayList internalList);
    private ArrayList get_InternalList();
    private void AddCollectionContainer(CollectionContainer cc);
    private void RemoveCollectionContainer(CollectionContainer cc);
    private void OnCollectionChanged(NotifyCollectionChangedAction action);
    private void OnCollectionChanged(NotifyCollectionChangedAction action, object item, int index);
    private void OnCollectionChanged(NotifyCollectionChangedAction action, object oldItem, object newItem, int index);
    internal void GetCollectionChangedSources(int level, Action`4<int, object, Nullable`1<bool>, List`1<string>> format, List`1<string> sources);
}
public class System.Windows.Data.DataChangedEventManager : WeakEventManager {
    private static DataChangedEventManager CurrentManager { get; }
    public static void AddListener(DataSourceProvider source, IWeakEventListener listener);
    public static void RemoveListener(DataSourceProvider source, IWeakEventListener listener);
    public static void AddHandler(DataSourceProvider source, EventHandler`1<EventArgs> handler);
    public static void RemoveHandler(DataSourceProvider source, EventHandler`1<EventArgs> handler);
    protected virtual ListenerList NewListenerList();
    protected virtual void StartListening(object source);
    protected virtual void StopListening(object source);
    private static DataChangedEventManager get_CurrentManager();
    private void OnDataChanged(object sender, EventArgs args);
}
public class System.Windows.Data.DataTransferEventArgs : RoutedEventArgs {
    private DependencyObject _targetObject;
    private DependencyProperty _dp;
    public DependencyObject TargetObject { get; }
    public DependencyProperty Property { get; }
    internal DataTransferEventArgs(DependencyObject targetObject, DependencyProperty dp);
    public DependencyObject get_TargetObject();
    public DependencyProperty get_Property();
    protected virtual void InvokeEventHandler(Delegate genericHandler, object genericTarget);
}
public class System.Windows.Data.FilterEventArgs : EventArgs {
    private object _item;
    private bool _accepted;
    public object Item { get; }
    public bool Accepted { get; public set; }
    internal FilterEventArgs(object item);
    public object get_Item();
    public bool get_Accepted();
    public void set_Accepted(bool value);
}
public class System.Windows.Data.FilterEventHandler : MulticastDelegate {
    public FilterEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, FilterEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, FilterEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Windows.Data.GroupDescriptionSelectorCallback : MulticastDelegate {
    public GroupDescriptionSelectorCallback(object object, IntPtr method);
    public virtual GroupDescription Invoke(CollectionViewGroup group, int level);
    public virtual IAsyncResult BeginInvoke(CollectionViewGroup group, int level, AsyncCallback callback, object object);
    public virtual GroupDescription EndInvoke(IAsyncResult result);
}
public interface System.Windows.Data.IMultiValueConverter {
    public abstract virtual object Convert(Object[] values, Type targetType, object parameter, CultureInfo culture);
    public abstract virtual Object[] ConvertBack(object value, Type[] targetTypes, object parameter, CultureInfo culture);
}
public interface System.Windows.Data.IValueConverter {
    public abstract virtual object Convert(object value, Type targetType, object parameter, CultureInfo culture);
    public abstract virtual object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture);
}
public class System.Windows.Data.ListCollectionView : CollectionView {
    private static double LiveSortingDensityThreshold;
    private IList _internalList;
    private CollectionViewGroupRoot _group;
    private bool _isGrouping;
    private IComparer _activeComparer;
    private Predicate`1<object> _activeFilter;
    private SortDescriptionCollection _sort;
    private IComparer _customSort;
    private ArrayList _shadowCollection;
    private bool _currentElementWasRemoved;
    private object _newItem;
    private object _editItem;
    private int _newItemIndex;
    private NewItemPlaceholderPosition _newItemPlaceholderPosition;
    private bool _isItemConstructorValid;
    private ConstructorInfo _itemConstructor;
    private List`1<Action> _deferredActions;
    private ObservableCollection`1<string> _liveSortingProperties;
    private ObservableCollection`1<string> _liveFilteringProperties;
    private ObservableCollection`1<string> _liveGroupingProperties;
    private Nullable`1<bool> _isLiveSorting;
    private Nullable`1<bool> _isLiveFiltering;
    private Nullable`1<bool> _isLiveGrouping;
    private bool _isLiveShapingDirty;
    private bool _isRemoving;
    private static int _unknownIndex;
    public bool CanGroup { get; }
    public ObservableCollection`1<GroupDescription> GroupDescriptions { get; }
    public ReadOnlyObservableCollection`1<object> Groups { get; }
    public SortDescriptionCollection SortDescriptions { get; }
    public bool CanSort { get; }
    public bool CanFilter { get; }
    public Predicate`1<object> Filter { get; public set; }
    public IComparer CustomSort { get; public set; }
    [DefaultValueAttribute("")]
public GroupDescriptionSelectorCallback GroupBySelector { get; public set; }
    public int Count { get; }
    public bool IsEmpty { get; }
    public bool IsDataInGroupOrder { get; public set; }
    public NewItemPlaceholderPosition NewItemPlaceholderPosition { get; public set; }
    public bool CanAddNew { get; }
    public bool CanAddNewItem { get; }
    private bool CanConstructItem { get; }
    public bool IsAddingNew { get; }
    public object CurrentAddItem { get; }
    public bool CanRemove { get; }
    public bool CanCancelEdit { get; }
    public bool IsEditingItem { get; }
    public object CurrentEditItem { get; }
    public bool CanChangeLiveSorting { get; }
    public bool CanChangeLiveFiltering { get; }
    public bool CanChangeLiveGrouping { get; }
    public Nullable`1<bool> IsLiveSorting { get; public set; }
    public Nullable`1<bool> IsLiveFiltering { get; public set; }
    public Nullable`1<bool> IsLiveGrouping { get; public set; }
    private bool IsLiveShaping { get; }
    public ObservableCollection`1<string> LiveSortingProperties { get; }
    public ObservableCollection`1<string> LiveFilteringProperties { get; }
    public ObservableCollection`1<string> LiveGroupingProperties { get; }
    public ReadOnlyCollection`1<ItemPropertyInfo> ItemProperties { get; }
    protected bool UsesLocalArray { get; }
    protected IList InternalList { get; }
    protected IComparer ActiveComparer { get; protected set; }
    protected Predicate`1<object> ActiveFilter { get; protected set; }
    protected bool IsGrouping { get; }
    protected int InternalCount { get; }
    internal ArrayList ShadowCollection { get; internal set; }
    internal bool HasSortDescriptions { get; }
    private bool IsCurrentInView { get; }
    private bool CanGroupNamesChange { get; }
    private IList SourceList { get; }
    internal bool IsLiveShapingDirty { get; internal set; }
    public ListCollectionView(IList list);
    protected virtual void RefreshOverride();
    public virtual bool Contains(object item);
    public virtual bool MoveCurrentToPosition(int position);
    public virtual bool get_CanGroup();
    public virtual ObservableCollection`1<GroupDescription> get_GroupDescriptions();
    public virtual ReadOnlyObservableCollection`1<object> get_Groups();
    public virtual bool PassesFilter(object item);
    public virtual int IndexOf(object item);
    public virtual object GetItemAt(int index);
    private sealed virtual override int System.Collections.IComparer.Compare(object o1, object o2);
    protected virtual int Compare(object o1, object o2);
    protected virtual IEnumerator GetEnumerator();
    public virtual SortDescriptionCollection get_SortDescriptions();
    public virtual bool get_CanSort();
    public virtual bool get_CanFilter();
    public virtual Predicate`1<object> get_Filter();
    public virtual void set_Filter(Predicate`1<object> value);
    public IComparer get_CustomSort();
    public void set_CustomSort(IComparer value);
    public virtual GroupDescriptionSelectorCallback get_GroupBySelector();
    public virtual void set_GroupBySelector(GroupDescriptionSelectorCallback value);
    public virtual int get_Count();
    public virtual bool get_IsEmpty();
    public bool get_IsDataInGroupOrder();
    public void set_IsDataInGroupOrder(bool value);
    public sealed virtual NewItemPlaceholderPosition get_NewItemPlaceholderPosition();
    public sealed virtual void set_NewItemPlaceholderPosition(NewItemPlaceholderPosition value);
    public sealed virtual bool get_CanAddNew();
    public sealed virtual bool get_CanAddNewItem();
    private bool get_CanConstructItem();
    private void EnsureItemConstructor();
    public sealed virtual object AddNew();
    public sealed virtual object AddNewItem(object newItem);
    private object AddNewCommon(object newItem);
    private void BeginAddNew(object newItem, int index);
    public sealed virtual void CommitNew();
    private void CommitNewForGrouping();
    public sealed virtual void CancelNew();
    private object EndAddNew(bool cancel);
    public sealed virtual bool get_IsAddingNew();
    public sealed virtual object get_CurrentAddItem();
    private void SetNewItem(object item);
    public sealed virtual bool get_CanRemove();
    public sealed virtual void RemoveAt(int index);
    public sealed virtual void Remove(object item);
    private void RemoveImpl(object item, int index);
    public sealed virtual void EditItem(object item);
    public sealed virtual void CommitEdit();
    public sealed virtual void CancelEdit();
    private void ImplicitlyCancelEdit();
    public sealed virtual bool get_CanCancelEdit();
    public sealed virtual bool get_IsEditingItem();
    public sealed virtual object get_CurrentEditItem();
    private void SetEditItem(object item);
    public sealed virtual bool get_CanChangeLiveSorting();
    public sealed virtual bool get_CanChangeLiveFiltering();
    public sealed virtual bool get_CanChangeLiveGrouping();
    public sealed virtual Nullable`1<bool> get_IsLiveSorting();
    public sealed virtual void set_IsLiveSorting(Nullable`1<bool> value);
    public sealed virtual Nullable`1<bool> get_IsLiveFiltering();
    public sealed virtual void set_IsLiveFiltering(Nullable`1<bool> value);
    public sealed virtual Nullable`1<bool> get_IsLiveGrouping();
    public sealed virtual void set_IsLiveGrouping(Nullable`1<bool> value);
    private bool get_IsLiveShaping();
    public sealed virtual ObservableCollection`1<string> get_LiveSortingProperties();
    public sealed virtual ObservableCollection`1<string> get_LiveFilteringProperties();
    public sealed virtual ObservableCollection`1<string> get_LiveGroupingProperties();
    private void OnLivePropertyListChanged(object sender, NotifyCollectionChangedEventArgs e);
    public sealed virtual ReadOnlyCollection`1<ItemPropertyInfo> get_ItemProperties();
    protected virtual void OnAllowsCrossThreadChangesChanged();
    [ObsoleteAttribute("Replaced by OnAllowsCrossThreadChangesChanged")]
protected virtual void OnBeginChangeLogging(NotifyCollectionChangedEventArgs args);
    protected virtual void ProcessCollectionChanged(NotifyCollectionChangedEventArgs args);
    private void ProcessCollectionChangedWithAdjustedIndex(NotifyCollectionChangedEventArgs args, int adjustedOldIndex, int adjustedNewIndex);
    protected int InternalIndexOf(object item);
    protected object InternalItemAt(int index);
    protected bool InternalContains(object item);
    protected IEnumerator InternalGetEnumerator();
    protected bool get_UsesLocalArray();
    protected IList get_InternalList();
    protected IComparer get_ActiveComparer();
    protected void set_ActiveComparer(IComparer value);
    protected Predicate`1<object> get_ActiveFilter();
    protected void set_ActiveFilter(Predicate`1<object> value);
    protected bool get_IsGrouping();
    protected int get_InternalCount();
    internal ArrayList get_ShadowCollection();
    internal void set_ShadowCollection(ArrayList value);
    internal void AdjustShadowCopy(NotifyCollectionChangedEventArgs e);
    internal bool get_HasSortDescriptions();
    internal static IComparer PrepareComparer(IComparer customSort, SortDescriptionCollection sort, Func`1<CollectionView> lazyGetCollectionView);
    private bool get_IsCurrentInView();
    private bool get_CanGroupNamesChange();
    private IList get_SourceList();
    private void ValidateCollectionChangedEventArgs(NotifyCollectionChangedEventArgs e);
    private void PrepareLocalArray();
    private void OnLiveShapingDirty(object sender, EventArgs e);
    private void RebuildLocalArray();
    private void MoveCurrencyOffDeletedElement(int oldCurrentPosition);
    private int AdjustBefore(NotifyCollectionChangedAction action, object item, int index);
    private int MatchingSearch(object item, int index, IList ilFull, IList ilPartial);
    private void AdjustCurrencyForAdd(int index);
    private void AdjustCurrencyForRemove(int index);
    private void AdjustCurrencyForMove(int oldIndex, int newIndex);
    private void AdjustCurrencyForReplace(int index);
    private void PrepareShaping();
    private void SetSortDescriptions(SortDescriptionCollection descriptions);
    private void SortDescriptionsChanged(object sender, NotifyCollectionChangedEventArgs e);
    private void PrepareGroups();
    private void OnGroupChanged(object sender, NotifyCollectionChangedEventArgs e);
    private void OnGroupByChanged(object sender, NotifyCollectionChangedEventArgs e);
    private void OnGroupDescriptionChanged(object sender, EventArgs e);
    private void AddItemToGroups(object item, LiveShapingItem lsi);
    private void RemoveItemFromGroups(object item);
    private void MoveItemWithinGroups(object item, LiveShapingItem lsi, int oldIndex, int newIndex);
    private LiveShapingFlags GetLiveShapingFlags();
    internal void RestoreLiveShaping();
    private void ProcessLiveShapingCollectionChange(NotifyCollectionChangedEventArgs args, int oldIndex, int newIndex);
    internal bool get_IsLiveShapingDirty();
    internal void set_IsLiveShapingDirty(bool value);
    private object ItemFrom(object o);
    private void OnPropertyChanged(string propertyName);
    private void DeferAction(Action action);
    private void DoDeferredActions();
    [CompilerGeneratedAttribute]
private void <.ctor>b__0_0();
    [CompilerGeneratedAttribute]
private void <RefreshOverride>b__1_0();
    [CompilerGeneratedAttribute]
private void <CancelNew>b__54_0();
    [CompilerGeneratedAttribute]
private void <OnAllowsCrossThreadChangesChanged>b__103_0();
    [CompilerGeneratedAttribute]
private CollectionView <PrepareShaping>b__149_0();
}
[ContentPropertyAttribute("Bindings")]
public class System.Windows.Data.MultiBinding : BindingBase {
    private BindingCollection _bindingCollection;
    [DesignerSerializationVisibilityAttribute("2")]
public Collection`1<BindingBase> Bindings { get; }
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
public BindingMode Mode { get; public set; }
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
public UpdateSourceTrigger UpdateSourceTrigger { get; public set; }
    [DefaultValueAttribute("False")]
public bool NotifyOnSourceUpdated { get; public set; }
    [DefaultValueAttribute("False")]
public bool NotifyOnTargetUpdated { get; public set; }
    [DefaultValueAttribute("False")]
public bool NotifyOnValidationError { get; public set; }
    [DefaultValueAttribute("")]
public IMultiValueConverter Converter { get; public set; }
    [DefaultValueAttribute("")]
public object ConverterParameter { get; public set; }
    [TypeConverterAttribute("System.Windows.CultureInfoIetfLanguageTagConverter")]
[DefaultValueAttribute("")]
public CultureInfo ConverterCulture { get; public set; }
    public Collection`1<ValidationRule> ValidationRules { get; }
    [DesignerSerializationVisibilityAttribute("0")]
public UpdateSourceExceptionFilterCallback UpdateSourceExceptionFilter { get; public set; }
    [DefaultValueAttribute("False")]
public bool ValidatesOnExceptions { get; public set; }
    [DefaultValueAttribute("False")]
public bool ValidatesOnDataErrors { get; public set; }
    [DefaultValueAttribute("True")]
public bool ValidatesOnNotifyDataErrors { get; public set; }
    internal Collection`1<ValidationRule> ValidationRulesInternal { get; }
    internal CultureInfo ConverterCultureInternal { get; }
    internal bool ValidatesOnNotifyDataErrorsInternal { get; }
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object value);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string text);
    public Collection`1<BindingBase> get_Bindings();
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeBindings();
    public BindingMode get_Mode();
    public void set_Mode(BindingMode value);
    public UpdateSourceTrigger get_UpdateSourceTrigger();
    public void set_UpdateSourceTrigger(UpdateSourceTrigger value);
    public bool get_NotifyOnSourceUpdated();
    public void set_NotifyOnSourceUpdated(bool value);
    public bool get_NotifyOnTargetUpdated();
    public void set_NotifyOnTargetUpdated(bool value);
    public bool get_NotifyOnValidationError();
    public void set_NotifyOnValidationError(bool value);
    public IMultiValueConverter get_Converter();
    public void set_Converter(IMultiValueConverter value);
    public object get_ConverterParameter();
    public void set_ConverterParameter(object value);
    public CultureInfo get_ConverterCulture();
    public void set_ConverterCulture(CultureInfo value);
    public Collection`1<ValidationRule> get_ValidationRules();
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeValidationRules();
    public UpdateSourceExceptionFilterCallback get_UpdateSourceExceptionFilter();
    public void set_UpdateSourceExceptionFilter(UpdateSourceExceptionFilterCallback value);
    public bool get_ValidatesOnExceptions();
    public void set_ValidatesOnExceptions(bool value);
    public bool get_ValidatesOnDataErrors();
    public void set_ValidatesOnDataErrors(bool value);
    public bool get_ValidatesOnNotifyDataErrors();
    public void set_ValidatesOnNotifyDataErrors(bool value);
    internal virtual BindingExpressionBase CreateBindingExpressionOverride(DependencyObject target, DependencyProperty dp, BindingExpressionBase owner);
    internal virtual ValidationRule LookupValidationRule(Type type);
    internal object DoFilterException(object bindExpr, Exception exception);
    internal static void CheckTrigger(BindingBase bb);
    internal virtual BindingBase CreateClone();
    internal virtual void InitializeClone(BindingBase baseClone, BindingMode mode);
    internal virtual Collection`1<ValidationRule> get_ValidationRulesInternal();
    internal virtual CultureInfo get_ConverterCultureInternal();
    internal virtual bool get_ValidatesOnNotifyDataErrorsInternal();
    private void OnBindingCollectionChanged();
}
public class System.Windows.Data.MultiBindingExpression : BindingExpressionBase {
    private Collection`1<BindingExpressionBase> _list;
    private IMultiValueConverter _converter;
    private Object[] _tempValues;
    private Type[] _tempTypes;
    private DependencyObject MS.Internal.Data.IDataBindEngineClient.TargetElement { get; }
    public MultiBinding ParentMultiBinding { get; }
    public ReadOnlyCollection`1<BindingExpressionBase> BindingExpressions { get; }
    internal bool IsParentBindingUpdateTriggerDefault { get; }
    public ValidationError ValidationError { get; }
    public bool HasError { get; }
    public bool HasValidationError { get; }
    private Collection`1<BindingExpressionBase> MutableBindingExpressions { get; }
    private IMultiValueConverter Converter { get; private set; }
    private MultiBindingExpression(MultiBinding binding, BindingExpressionBase owner);
    private sealed virtual override void MS.Internal.Data.IDataBindEngineClient.TransferValue();
    private sealed virtual override void MS.Internal.Data.IDataBindEngineClient.UpdateValue();
    private sealed virtual override bool MS.Internal.Data.IDataBindEngineClient.AttachToContext(bool lastChance);
    private sealed virtual override void MS.Internal.Data.IDataBindEngineClient.VerifySourceReference(bool lastChance);
    private sealed virtual override void MS.Internal.Data.IDataBindEngineClient.OnTargetUpdated();
    private sealed virtual override DependencyObject MS.Internal.Data.IDataBindEngineClient.get_TargetElement();
    public MultiBinding get_ParentMultiBinding();
    public ReadOnlyCollection`1<BindingExpressionBase> get_BindingExpressions();
    public virtual void UpdateSource();
    public virtual void UpdateTarget();
    internal virtual bool get_IsParentBindingUpdateTriggerDefault();
    internal static MultiBindingExpression CreateBindingExpression(DependencyObject d, DependencyProperty dp, MultiBinding binding, BindingExpressionBase owner);
    private void AttachToContext(bool lastChance);
    public virtual ValidationError get_ValidationError();
    public virtual bool get_HasError();
    public virtual bool get_HasValidationError();
    internal virtual bool AttachOverride(DependencyObject d, DependencyProperty dp);
    internal virtual void DetachOverride();
    internal virtual void InvalidateChild(BindingExpressionBase bindingExpression);
    internal virtual void ChangeSourcesForChild(BindingExpressionBase bindingExpression, WeakDependencySource[] newSources);
    internal virtual void ReplaceChild(BindingExpressionBase bindingExpression);
    internal virtual void UpdateBindingGroup(BindingGroup bg);
    internal virtual object ConvertProposedValue(object value);
    private bool ConvertProposedValueImpl(object value, Object& result);
    private object GetValuesForChildBindings(object rawValue);
    internal virtual bool ObtainConvertedProposedValue(BindingGroup bindingGroup);
    internal virtual object UpdateSource(object convertedValue);
    internal virtual bool UpdateSource(BindingGroup bindingGroup);
    internal virtual void StoreValueInBindingGroup(object value, BindingGroup bindingGroup);
    internal virtual bool Validate(object value, ValidationStep validationStep);
    internal virtual bool CheckValidationRules(BindingGroup bindingGroup, ValidationStep validationStep);
    internal virtual bool ValidateAndConvertProposedValue(Collection`1& values);
    internal virtual object GetSourceItem(object newValue);
    private Collection`1<BindingExpressionBase> get_MutableBindingExpressions();
    private IMultiValueConverter get_Converter();
    private void set_Converter(IMultiValueConverter value);
    private BindingExpressionBase AttachBindingExpression(int i, bool replaceExisting);
    internal virtual void HandlePropertyInvalidation(DependencyObject d, DependencyPropertyChangedEventArgs args);
    internal virtual bool ReceiveWeakEvent(Type managerType, object sender, EventArgs e);
    internal virtual void OnLostFocus(object sender, RoutedEventArgs e);
    private void UpdateTarget(bool includeInnerBindings);
    private void Transfer();
    private void TransferValue();
    private void OnTargetUpdated();
    private void OnSourceUpdated();
    internal virtual bool ShouldReactToDirtyOverride();
    internal virtual bool UpdateOverride();
}
[LocalizabilityAttribute("17")]
public class System.Windows.Data.ObjectDataProvider : DataSourceProvider {
    private Type _objectType;
    private object _objectInstance;
    private string _methodName;
    private DataSourceProvider _instanceProvider;
    private ParameterCollection _constructorParameters;
    private ParameterCollection _methodParameters;
    private bool _isAsynchronous;
    private SourceMode _mode;
    private bool _needNewInstance;
    private EventHandler _sourceDataChangedHandler;
    private static string s_instance;
    private static string s_type;
    private static string s_method;
    private static string s_async;
    private static BindingFlags s_invokeMethodFlags;
    public Type ObjectType { get; public set; }
    public object ObjectInstance { get; public set; }
    [DefaultValueAttribute("")]
public string MethodName { get; public set; }
    public IList ConstructorParameters { get; }
    public IList MethodParameters { get; }
    [DefaultValueAttribute("False")]
public bool IsAsynchronous { get; public set; }
    public Type get_ObjectType();
    public void set_ObjectType(Type value);
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeObjectType();
    public object get_ObjectInstance();
    public void set_ObjectInstance(object value);
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeObjectInstance();
    public string get_MethodName();
    public void set_MethodName(string value);
    public IList get_ConstructorParameters();
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeConstructorParameters();
    public IList get_MethodParameters();
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeMethodParameters();
    public bool get_IsAsynchronous();
    public void set_IsAsynchronous(bool value);
    protected virtual void BeginQuery();
    private object TryInstanceProvider(object value);
    private bool SetObjectInstance(object value);
    private bool SetObjectType(Type newType);
    private void QueryWorker(object obj);
    private object CreateObjectInstance(Exception& e);
    private object InvokeMethodOnInstance(Exception& e);
    private void OnParametersChanged(ParameterCollection sender);
    private void OnSourceDataChanged(object sender, EventArgs args);
    private void OnPropertyChanged(string propertyName);
}
[ContentPropertyAttribute("Bindings")]
public class System.Windows.Data.PriorityBinding : BindingBase {
    private BindingCollection _bindingCollection;
    [DesignerSerializationVisibilityAttribute("2")]
public Collection`1<BindingBase> Bindings { get; }
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object value);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string text);
    public Collection`1<BindingBase> get_Bindings();
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeBindings();
    internal virtual BindingExpressionBase CreateBindingExpressionOverride(DependencyObject target, DependencyProperty dp, BindingExpressionBase owner);
    internal virtual BindingBase CreateClone();
    internal virtual void InitializeClone(BindingBase baseClone, BindingMode mode);
    private void OnBindingCollectionChanged();
}
public class System.Windows.Data.PriorityBindingExpression : BindingExpressionBase {
    private static int NoActiveBindingExpressions;
    private static int UnknownActiveBindingExpression;
    private Collection`1<BindingExpressionBase> _list;
    private int _activeIndex;
    private bool _isInInvalidateBinding;
    public PriorityBinding ParentPriorityBinding { get; }
    public ReadOnlyCollection`1<BindingExpressionBase> BindingExpressions { get; }
    public BindingExpressionBase ActiveBindingExpression { get; }
    public bool HasValidationError { get; }
    internal int AttentiveBindingExpressions { get; }
    private Collection`1<BindingExpressionBase> MutableBindingExpressions { get; }
    private PriorityBindingExpression(PriorityBinding binding, BindingExpressionBase owner);
    public PriorityBinding get_ParentPriorityBinding();
    public ReadOnlyCollection`1<BindingExpressionBase> get_BindingExpressions();
    public BindingExpressionBase get_ActiveBindingExpression();
    public virtual bool get_HasValidationError();
    public virtual void UpdateTarget();
    public virtual void UpdateSource();
    internal virtual bool SetValue(DependencyObject d, DependencyProperty dp, object value);
    internal static PriorityBindingExpression CreateBindingExpression(DependencyObject d, DependencyProperty dp, PriorityBinding binding, BindingExpressionBase owner);
    internal int get_AttentiveBindingExpressions();
    internal virtual bool AttachOverride(DependencyObject d, DependencyProperty dp);
    internal virtual void DetachOverride();
    internal virtual void InvalidateChild(BindingExpressionBase bindingExpression);
    internal virtual void ChangeSourcesForChild(BindingExpressionBase bindingExpression, WeakDependencySource[] newSources);
    internal virtual void ReplaceChild(BindingExpressionBase bindingExpression);
    internal virtual void UpdateBindingGroup(BindingGroup bg);
    internal virtual bool ShouldReactToDirtyOverride();
    internal virtual object GetRawProposedValue();
    internal virtual object ConvertProposedValue(object rawValue);
    internal virtual bool ObtainConvertedProposedValue(BindingGroup bindingGroup);
    internal virtual object UpdateSource(object convertedValue);
    internal virtual bool UpdateSource(BindingGroup bindingGroup);
    internal virtual void StoreValueInBindingGroup(object value, BindingGroup bindingGroup);
    internal virtual bool Validate(object value, ValidationStep validationStep);
    internal virtual bool CheckValidationRules(BindingGroup bindingGroup, ValidationStep validationStep);
    internal virtual bool ValidateAndConvertProposedValue(Collection`1& values);
    internal virtual object GetSourceItem(object newValue);
    internal virtual void UpdateCommitState();
    private Collection`1<BindingExpressionBase> get_MutableBindingExpressions();
    private BindingExpressionBase AttachBindingExpression(int i, bool replaceExisting);
    private void ChooseActiveBindingExpression(DependencyObject target);
    private void ChangeValue();
    internal virtual void HandlePropertyInvalidation(DependencyObject d, DependencyPropertyChangedEventArgs args);
}
public class System.Windows.Data.PropertyGroupDescription : GroupDescription {
    private string _propertyName;
    private PropertyPath _propertyPath;
    private IValueConverter _converter;
    private StringComparison _stringComparison;
    private static IComparer _compareNameAscending;
    private static IComparer _compareNameDescending;
    [DefaultValueAttribute("")]
public string PropertyName { get; public set; }
    [DefaultValueAttribute("")]
public IValueConverter Converter { get; public set; }
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
public StringComparison StringComparison { get; public set; }
    public static IComparer CompareNameAscending { get; }
    public static IComparer CompareNameDescending { get; }
    public PropertyGroupDescription(string propertyName);
    public PropertyGroupDescription(string propertyName, IValueConverter converter);
    public PropertyGroupDescription(string propertyName, IValueConverter converter, StringComparison stringComparison);
    private static PropertyGroupDescription();
    public string get_PropertyName();
    public void set_PropertyName(string value);
    public IValueConverter get_Converter();
    public void set_Converter(IValueConverter value);
    public StringComparison get_StringComparison();
    public void set_StringComparison(StringComparison value);
    public static IComparer get_CompareNameAscending();
    public static IComparer get_CompareNameDescending();
    public virtual object GroupNameFromItem(object item, int level, CultureInfo culture);
    public virtual bool NamesMatch(object groupName, object itemName);
    private void UpdatePropertyName(string propertyName);
    private void OnPropertyChanged(string propertyName);
}
[MarkupExtensionReturnTypeAttribute("System.Windows.Data.RelativeSource")]
public class System.Windows.Data.RelativeSource : MarkupExtension {
    private RelativeSourceMode _mode;
    private Type _ancestorType;
    private int _ancestorLevel;
    private static RelativeSource s_previousData;
    private static RelativeSource s_templatedParent;
    private static RelativeSource s_self;
    public static RelativeSource PreviousData { get; }
    public static RelativeSource TemplatedParent { get; }
    public static RelativeSource Self { get; }
    [ConstructorArgumentAttribute("mode")]
public RelativeSourceMode Mode { get; public set; }
    public Type AncestorType { get; public set; }
    public int AncestorLevel { get; public set; }
    private bool IsUninitialized { get; }
    public RelativeSource(RelativeSourceMode mode);
    public RelativeSource(RelativeSourceMode mode, Type ancestorType, int ancestorLevel);
    private sealed virtual override void System.ComponentModel.ISupportInitialize.BeginInit();
    private sealed virtual override void System.ComponentModel.ISupportInitialize.EndInit();
    public static RelativeSource get_PreviousData();
    public static RelativeSource get_TemplatedParent();
    public static RelativeSource get_Self();
    public RelativeSourceMode get_Mode();
    public void set_Mode(RelativeSourceMode value);
    public Type get_AncestorType();
    public void set_AncestorType(Type value);
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeAncestorType();
    public int get_AncestorLevel();
    public void set_AncestorLevel(int value);
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeAncestorLevel();
    public virtual object ProvideValue(IServiceProvider serviceProvider);
    private bool get_IsUninitialized();
    private void InitializeMode(RelativeSourceMode mode);
}
public enum System.Windows.Data.RelativeSourceMode : Enum {
    public int value__;
    public static RelativeSourceMode PreviousData;
    public static RelativeSourceMode TemplatedParent;
    public static RelativeSourceMode Self;
    public static RelativeSourceMode FindAncestor;
}
public class System.Windows.Data.UpdateSourceExceptionFilterCallback : MulticastDelegate {
    public UpdateSourceExceptionFilterCallback(object object, IntPtr method);
    public virtual object Invoke(object bindExpression, Exception exception);
    public virtual IAsyncResult BeginInvoke(object bindExpression, Exception exception, AsyncCallback callback, object object);
    public virtual object EndInvoke(IAsyncResult result);
}
public enum System.Windows.Data.UpdateSourceTrigger : Enum {
    public int value__;
    public static UpdateSourceTrigger Default;
    public static UpdateSourceTrigger PropertyChanged;
    public static UpdateSourceTrigger LostFocus;
    public static UpdateSourceTrigger Explicit;
}
[AttributeUsageAttribute("4")]
public class System.Windows.Data.ValueConversionAttribute : Attribute {
    private Type _sourceType;
    private Type _targetType;
    private Type _parameterType;
    public Type SourceType { get; }
    public Type TargetType { get; }
    public Type ParameterType { get; public set; }
    public object TypeId { get; }
    public ValueConversionAttribute(Type sourceType, Type targetType);
    public Type get_SourceType();
    public Type get_TargetType();
    public Type get_ParameterType();
    public void set_ParameterType(Type value);
    public virtual object get_TypeId();
    public virtual int GetHashCode();
}
public class System.Windows.Data.ValueUnavailableException : SystemException {
    public ValueUnavailableException(string message);
    public ValueUnavailableException(string message, Exception innerException);
    protected ValueUnavailableException(SerializationInfo info, StreamingContext context);
}
[LocalizabilityAttribute("0")]
[ContentPropertyAttribute("XmlSerializer")]
public class System.Windows.Data.XmlDataProvider : DataSourceProvider {
    private XmlDocument _document;
    private XmlDocument _domSetDocument;
    private XmlDocument _savedDocument;
    private ManualResetEvent _waitForInlineDoc;
    private XmlNamespaceManager _nsMgr;
    private Uri _source;
    private Uri _baseUri;
    private string _xPath;
    private bool _tryInlineDoc;
    private bool _isListening;
    private XmlIslandSerializer _xmlSerializer;
    private bool _isAsynchronous;
    private bool _inEndInit;
    private DispatcherOperationCallback _onCompletedCallback;
    private XmlNodeChangedEventHandler _nodeChangedHandler;
    public Uri Source { get; public set; }
    [DesignerSerializationVisibilityAttribute("0")]
public XmlDocument Document { get; public set; }
    [DesignerSerializationOptionsAttribute("1")]
public string XPath { get; public set; }
    [DefaultValueAttribute("")]
public XmlNamespaceManager XmlNamespaceManager { get; public set; }
    [DefaultValueAttribute("True")]
public bool IsAsynchronous { get; public set; }
    [DesignerSerializationVisibilityAttribute("2")]
[EditorBrowsableAttribute("1")]
public IXmlSerializable XmlSerializer { get; }
    private Uri System.Windows.Markup.IUriContext.BaseUri { get; private set; }
    protected Uri BaseUri { get; protected set; }
    private XmlDocument DocumentForSerialization { get; }
    private XmlDataCollection XmlDataCollection { get; }
    private DispatcherOperationCallback CompletedCallback { get; }
    private XmlNodeChangedEventHandler NodeChangeHandler { get; }
    public Uri get_Source();
    public void set_Source(Uri value);
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeSource();
    public XmlDocument get_Document();
    public void set_Document(XmlDocument value);
    public string get_XPath();
    public void set_XPath(string value);
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeXPath();
    public XmlNamespaceManager get_XmlNamespaceManager();
    public void set_XmlNamespaceManager(XmlNamespaceManager value);
    public bool get_IsAsynchronous();
    public void set_IsAsynchronous(bool value);
    public IXmlSerializable get_XmlSerializer();
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeXmlSerializer();
    private sealed virtual override Uri System.Windows.Markup.IUriContext.get_BaseUri();
    private sealed virtual override void System.Windows.Markup.IUriContext.set_BaseUri(Uri value);
    protected virtual Uri get_BaseUri();
    protected virtual void set_BaseUri(Uri value);
    protected virtual void BeginQuery();
    protected virtual void EndInit();
    private void LoadFromSource();
    private void ParseInline(XmlReader xmlReader);
    private XmlDocument get_DocumentForSerialization();
    private void CreateDocFromInlineXmlAsync(object arg);
    private void CreateDocFromInlineXml(XmlReader xmlReader);
    private void CreateDocFromExternalSourceAsynch(object arg);
    private void CreateDocFromExternalSource(WebRequest request);
    private void BuildNodeCollectionAsynch(object arg);
    private void BuildNodeCollection(XmlDocument doc);
    private object OnCompletedCallback(object arg);
    private void ChangeDocument(XmlDocument doc);
    private void DiscardInline();
    private void Hook();
    private void UnHook();
    private void OnNodeChanged(object sender, XmlNodeChangedEventArgs e);
    private XmlNodeList GetResultNodeList(XmlDocument doc);
    private XmlDataCollection get_XmlDataCollection();
    private DispatcherOperationCallback get_CompletedCallback();
    private XmlNodeChangedEventHandler get_NodeChangeHandler();
}
public class System.Windows.Data.XmlNamespaceMapping : object {
    private string _prefix;
    private Uri _uri;
    private bool _initializing;
    public string Prefix { get; public set; }
    public Uri Uri { get; public set; }
    public XmlNamespaceMapping(string prefix, Uri uri);
    public string get_Prefix();
    public void set_Prefix(string value);
    public Uri get_Uri();
    public void set_Uri(Uri value);
    public virtual bool Equals(object obj);
    public static bool op_Equality(XmlNamespaceMapping mappingA, XmlNamespaceMapping mappingB);
    public static bool op_Inequality(XmlNamespaceMapping mappingA, XmlNamespaceMapping mappingB);
    public virtual int GetHashCode();
    private sealed virtual override void System.ComponentModel.ISupportInitialize.BeginInit();
    private sealed virtual override void System.ComponentModel.ISupportInitialize.EndInit();
}
[LocalizabilityAttribute("17")]
public class System.Windows.Data.XmlNamespaceMappingCollection : XmlNamespaceManager {
    public int Count { get; }
    public bool IsReadOnly { get; }
    private IEnumerator BaseEnumerator { get; }
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object value);
    protected virtual void AddChild(object value);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string text);
    protected virtual void AddText(string text);
    public sealed virtual void Add(XmlNamespaceMapping mapping);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(XmlNamespaceMapping mapping);
    public sealed virtual void CopyTo(XmlNamespaceMapping[] array, int arrayIndex);
    public sealed virtual bool Remove(XmlNamespaceMapping mapping);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public virtual IEnumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<XmlNamespaceMapping> System.Collections.Generic.IEnumerable<System.Windows.Data.XmlNamespaceMapping>.GetEnumerator();
    [IteratorStateMachineAttribute("System.Windows.Data.XmlNamespaceMappingCollection/<ProtectedGetEnumerator>d__16")]
protected IEnumerator`1<XmlNamespaceMapping> ProtectedGetEnumerator();
    private IEnumerator get_BaseEnumerator();
}
[DictionaryKeyPropertyAttribute("DataTemplateKey")]
public class System.Windows.DataTemplate : FrameworkTemplate {
    private object _dataType;
    private TriggerCollection _triggers;
    [DefaultValueAttribute("")]
[AmbientAttribute]
public object DataType { get; public set; }
    [DesignerSerializationVisibilityAttribute("2")]
[DependsOnAttribute("VisualTree")]
[DependsOnAttribute("Template")]
public TriggerCollection Triggers { get; }
    public object DataTemplateKey { get; }
    internal Type TargetTypeInternal { get; }
    internal object DataTypeInternal { get; }
    internal TriggerCollection TriggersInternal { get; }
    internal static Type DefaultTargetType { get; }
    public DataTemplate(object dataType);
    public object get_DataType();
    public void set_DataType(object value);
    public TriggerCollection get_Triggers();
    public object get_DataTemplateKey();
    internal virtual Type get_TargetTypeInternal();
    internal virtual void SetTargetTypeInternal(Type targetType);
    internal virtual object get_DataTypeInternal();
    internal virtual TriggerCollection get_TriggersInternal();
    internal static Type get_DefaultTargetType();
    protected virtual void ValidateTemplatedParent(FrameworkElement templatedParent);
}
public class System.Windows.DataTemplateKey : TemplateKey {
    public DataTemplateKey(object dataType);
}
[XamlSetMarkupExtensionAttribute("ReceiveMarkupExtension")]
[ContentPropertyAttribute("Setters")]
public class System.Windows.DataTrigger : TriggerBase {
    private BindingBase _binding;
    private object _value;
    private SetterBaseCollection _setters;
    [LocalizabilityAttribute("0")]
public BindingBase Binding { get; public set; }
    [DependsOnAttribute("Binding")]
[LocalizabilityAttribute("0")]
public object Value { get; public set; }
    [DesignerSerializationVisibilityAttribute("2")]
public SetterBaseCollection Setters { get; }
    public BindingBase get_Binding();
    public void set_Binding(BindingBase value);
    public object get_Value();
    public void set_Value(object value);
    public SetterBaseCollection get_Setters();
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object value);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string text);
    internal sealed virtual void Seal();
    internal virtual bool GetCurrentState(DependencyObject container, UncommonField`1<HybridDictionary[]> dataField);
    public static void ReceiveMarkupExtension(object targetObject, XamlSetMarkupExtensionEventArgs eventArgs);
}
internal class System.Windows.DataTriggerRecord : object {
    public FrugalStructList`1<ChildPropertyDependent> Dependents;
}
[TypeConverterAttribute("System.Windows.DeferrableContentConverter")]
public class System.Windows.DeferrableContent : object {
    [CompilerGeneratedAttribute]
private Stream <Stream>k__BackingField;
    [CompilerGeneratedAttribute]
private Baml2006SchemaContext <SchemaContext>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlObjectWriterFactory <ObjectWriterFactory>k__BackingField;
    [CompilerGeneratedAttribute]
private XamlObjectWriterSettings <ObjectWriterParentSettings>k__BackingField;
    [CompilerGeneratedAttribute]
private object <RootObject>k__BackingField;
    [CompilerGeneratedAttribute]
private IServiceProvider <ServiceProvider>k__BackingField;
    internal Stream Stream { get; private set; }
    internal Baml2006SchemaContext SchemaContext { get; private set; }
    internal IXamlObjectWriterFactory ObjectWriterFactory { get; private set; }
    internal XamlObjectWriterSettings ObjectWriterParentSettings { get; private set; }
    internal object RootObject { get; private set; }
    internal IServiceProvider ServiceProvider { get; private set; }
    internal DeferrableContent(Stream stream, Baml2006SchemaContext schemaContext, IXamlObjectWriterFactory objectWriterFactory, IServiceProvider serviceProvider, object rootObject);
    [CompilerGeneratedAttribute]
internal Stream get_Stream();
    [CompilerGeneratedAttribute]
private void set_Stream(Stream value);
    [CompilerGeneratedAttribute]
internal Baml2006SchemaContext get_SchemaContext();
    [CompilerGeneratedAttribute]
private void set_SchemaContext(Baml2006SchemaContext value);
    [CompilerGeneratedAttribute]
internal IXamlObjectWriterFactory get_ObjectWriterFactory();
    [CompilerGeneratedAttribute]
private void set_ObjectWriterFactory(IXamlObjectWriterFactory value);
    [CompilerGeneratedAttribute]
internal XamlObjectWriterSettings get_ObjectWriterParentSettings();
    [CompilerGeneratedAttribute]
private void set_ObjectWriterParentSettings(XamlObjectWriterSettings value);
    [CompilerGeneratedAttribute]
internal object get_RootObject();
    [CompilerGeneratedAttribute]
private void set_RootObject(object value);
    [CompilerGeneratedAttribute]
internal IServiceProvider get_ServiceProvider();
    [CompilerGeneratedAttribute]
private void set_ServiceProvider(IServiceProvider value);
}
public class System.Windows.DeferrableContentConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    private static T RequireService(IServiceProvider provider);
}
internal class System.Windows.DeferredAction : ValueType {
    internal TriggerBase TriggerBase;
    internal TriggerActionCollection TriggerActionCollection;
}
internal class System.Windows.DeferredAppResourceReference : DeferredResourceReference {
    internal DeferredAppResourceReference(ResourceDictionary dictionary, object resourceKey);
    internal virtual object GetValue(BaseValueSourceInternal valueSource);
    internal virtual Type GetValueType();
}
internal class System.Windows.DeferredResourceReference : DeferredReference {
    private ResourceDictionary _dictionary;
    protected object _keyOrValue;
    private WeakReferenceList _inflatedList;
    internal object Key { get; }
    internal ResourceDictionary Dictionary { get; internal set; }
    internal object Value { get; internal set; }
    internal bool IsUnset { get; }
    internal bool IsInflated { get; }
    internal DeferredResourceReference(ResourceDictionary dictionary, object key);
    internal virtual object GetValue(BaseValueSourceInternal valueSource);
    private void OnInflated();
    internal virtual Type GetValueType();
    internal virtual void RemoveFromDictionary();
    internal virtual void AddInflatedListener(ResourceReferenceExpression listener);
    internal virtual void RemoveInflatedListener(ResourceReferenceExpression listener);
    internal virtual object get_Key();
    internal ResourceDictionary get_Dictionary();
    internal void set_Dictionary(ResourceDictionary value);
    internal virtual object get_Value();
    internal virtual void set_Value(object value);
    internal virtual bool get_IsUnset();
    internal bool get_IsInflated();
}
internal class System.Windows.DeferredResourceReferenceHolder : DeferredResourceReference {
    internal object Key { get; }
    internal object Value { get; internal set; }
    internal bool IsUnset { get; }
    internal DeferredResourceReferenceHolder(object resourceKey, object value);
    internal virtual object GetValue(BaseValueSourceInternal valueSource);
    internal virtual Type GetValueType();
    internal virtual object get_Key();
    internal virtual object get_Value();
    internal virtual void set_Value(object value);
    internal virtual bool get_IsUnset();
}
internal class System.Windows.DeferredThemeResourceReference : DeferredResourceReference {
    private bool _canCacheAsThemeResource;
    internal DeferredThemeResourceReference(ResourceDictionary dictionary, object resourceKey, bool canCacheAsThemeResource);
    internal virtual object GetValue(BaseValueSourceInternal valueSource);
    internal virtual Type GetValueType();
    internal virtual void RemoveFromDictionary();
}
public static class System.Windows.DependencyPropertyHelper : object {
    public static ValueSource GetValueSource(DependencyObject dependencyObject, DependencyProperty dependencyProperty);
    public static bool IsTemplatedValueDynamic(DependencyObject elementInTemplate, DependencyProperty dependencyProperty);
}
internal class System.Windows.DescendentsWalker`1 : DescendentsWalkerBase {
    private VisitedCallback`1<T> _callback;
    private T _data;
    protected T Data { get; }
    public DescendentsWalker`1(TreeWalkPriority priority, VisitedCallback`1<T> callback);
    public DescendentsWalker`1(TreeWalkPriority priority, VisitedCallback`1<T> callback, T data);
    public void StartWalk(DependencyObject startNode);
    public virtual void StartWalk(DependencyObject startNode, bool skipStartNode);
    private void IterateChildren(DependencyObject d);
    private void WalkVisualChildren(Visual v);
    private void WalkVisualChildren(Visual3D v);
    private void WalkLogicalChildren(FrameworkElement feParent, FrameworkContentElement fceParent, IEnumerator logicalChildren);
    private void WalkFrameworkElementVisualThenLogicalChildren(FrameworkElement feParent, bool hasLogicalChildren);
    private void WalkFrameworkElementLogicalThenVisualChildren(FrameworkElement feParent, bool hasLogicalChildren);
    private void VisitNode(FrameworkElement fe, bool visitedViaVisualTree);
    private void VisitNode(DependencyObject d, bool visitedViaVisualTree);
    protected virtual void _VisitNode(DependencyObject d, bool visitedViaVisualTree);
    protected T get_Data();
}
internal class System.Windows.DescendentsWalkerBase : object {
    internal DependencyObject _startNode;
    internal TreeWalkPriority _priority;
    internal FrugalStructList`1<DependencyObject> _nodes;
    internal int _recursionDepth;
    protected DescendentsWalkerBase(TreeWalkPriority priority);
    internal bool WasVisited(DependencyObject d);
}
public static class System.Windows.Diagnostics.ResourceDictionaryDiagnostics : object {
    private static Dictionary`2<Uri, List`1<WeakReference`1<ResourceDictionary>>> _dictionariesFromUri;
    private static object _dictionariesFromUriLock;
    private static ReadOnlyCollection`1<ResourceDictionary> EmptyResourceDictionaries;
    private static ReadOnlyCollection`1<FrameworkElement> EmptyFrameworkElementList;
    private static ReadOnlyCollection`1<FrameworkContentElement> EmptyFrameworkContentElementList;
    private static ReadOnlyCollection`1<Application> EmptyApplicationList;
    [CompilerGeneratedAttribute]
private static EventHandler`1<StaticResourceResolvedEventArgs> StaticResourceResolved;
    private static List`1<object> IgnorableProperties;
    [ThreadStaticAttribute]
private static Stack`1<LookupResult> _lookupResultStack;
    [ThreadStaticAttribute]
private static Dictionary`2<WeakReferenceKey`1<StaticResourceExtension>, WeakReference`1<ResourceDictionary>> _resultCache;
    [ThreadStaticAttribute]
private static DispatcherOperation _cleanupOperation;
    [CompilerGeneratedAttribute]
private static bool <IsEnabled>k__BackingField;
    private static ReadOnlyCollection`1<ResourceDictionaryInfo> EmptyResourceDictionaryInfos;
    public static IEnumerable`1<ResourceDictionaryInfo> ThemedResourceDictionaries { get; }
    public static IEnumerable`1<ResourceDictionaryInfo> GenericResourceDictionaries { get; }
    internal static bool HasStaticResourceResolvedListeners { get; }
    internal static bool IsEnabled { get; private set; }
    private static ResourceDictionaryDiagnostics();
    public static IEnumerable`1<ResourceDictionaryInfo> get_ThemedResourceDictionaries();
    public static IEnumerable`1<ResourceDictionaryInfo> get_GenericResourceDictionaries();
    public static void add_ThemedResourceDictionaryLoaded(EventHandler`1<ResourceDictionaryLoadedEventArgs> value);
    public static void remove_ThemedResourceDictionaryLoaded(EventHandler`1<ResourceDictionaryLoadedEventArgs> value);
    public static void add_ThemedResourceDictionaryUnloaded(EventHandler`1<ResourceDictionaryUnloadedEventArgs> value);
    public static void remove_ThemedResourceDictionaryUnloaded(EventHandler`1<ResourceDictionaryUnloadedEventArgs> value);
    public static void add_GenericResourceDictionaryLoaded(EventHandler`1<ResourceDictionaryLoadedEventArgs> value);
    public static void remove_GenericResourceDictionaryLoaded(EventHandler`1<ResourceDictionaryLoadedEventArgs> value);
    public static IEnumerable`1<ResourceDictionary> GetResourceDictionariesForSource(Uri uri);
    internal static void AddResourceDictionaryForUri(Uri uri, ResourceDictionary rd);
    private static void AddResourceDictionaryForUriImpl(Uri uri, ResourceDictionary rd);
    internal static void RemoveResourceDictionaryForUri(Uri uri, ResourceDictionary rd);
    private static void RemoveResourceDictionaryForUriImpl(Uri uri, ResourceDictionary rd);
    private static void RemoveEntries(Uri uri, List`1<WeakReference`1<ResourceDictionary>> list, List`1<WeakReference`1<ResourceDictionary>> toRemove);
    public static IEnumerable`1<FrameworkElement> GetFrameworkElementOwners(ResourceDictionary dictionary);
    public static IEnumerable`1<FrameworkContentElement> GetFrameworkContentElementOwners(ResourceDictionary dictionary);
    public static IEnumerable`1<Application> GetApplicationOwners(ResourceDictionary dictionary);
    private static IEnumerable`1<T> GetOwners(WeakReferenceList list, IEnumerable`1<T> emptyList);
    [CompilerGeneratedAttribute]
public static void add_StaticResourceResolved(EventHandler`1<StaticResourceResolvedEventArgs> value);
    [CompilerGeneratedAttribute]
public static void remove_StaticResourceResolved(EventHandler`1<StaticResourceResolvedEventArgs> value);
    internal static bool get_HasStaticResourceResolvedListeners();
    internal static bool ShouldIgnoreProperty(object targetProperty);
    internal static LookupResult RequestLookupResult(StaticResourceExtension requester);
    internal static void RecordLookupResult(object key, ResourceDictionary rd);
    private static void RecordLookupResultImpl(object key, ResourceDictionary rd);
    internal static void RevertRequest(StaticResourceExtension requester, bool success);
    internal static void OnStaticResourceResolved(object targetObject, object targetProperty, LookupResult result);
    private static void RequestCacheCleanup(object targetObject);
    private static void DoCleanup();
    [CompilerGeneratedAttribute]
internal static bool get_IsEnabled();
    [CompilerGeneratedAttribute]
private static void set_IsEnabled(bool value);
}
[DebuggerDisplayAttribute("Assembly = {Assembly?.GetName()?.Name}, ResourceDictionary SourceUri = {SourceUri?.AbsoluteUri}")]
public class System.Windows.Diagnostics.ResourceDictionaryInfo : object {
    [CompilerGeneratedAttribute]
private Assembly <Assembly>k__BackingField;
    [CompilerGeneratedAttribute]
private Assembly <ResourceDictionaryAssembly>k__BackingField;
    [CompilerGeneratedAttribute]
private ResourceDictionary <ResourceDictionary>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <SourceUri>k__BackingField;
    public Assembly Assembly { get; private set; }
    public Assembly ResourceDictionaryAssembly { get; private set; }
    public ResourceDictionary ResourceDictionary { get; private set; }
    public Uri SourceUri { get; private set; }
    internal ResourceDictionaryInfo(Assembly assembly, Assembly resourceDictionaryAssembly, ResourceDictionary resourceDictionary, Uri sourceUri);
    [CompilerGeneratedAttribute]
public Assembly get_Assembly();
    [CompilerGeneratedAttribute]
private void set_Assembly(Assembly value);
    [CompilerGeneratedAttribute]
public Assembly get_ResourceDictionaryAssembly();
    [CompilerGeneratedAttribute]
private void set_ResourceDictionaryAssembly(Assembly value);
    [CompilerGeneratedAttribute]
public ResourceDictionary get_ResourceDictionary();
    [CompilerGeneratedAttribute]
private void set_ResourceDictionary(ResourceDictionary value);
    [CompilerGeneratedAttribute]
public Uri get_SourceUri();
    [CompilerGeneratedAttribute]
private void set_SourceUri(Uri value);
}
public class System.Windows.Diagnostics.ResourceDictionaryLoadedEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private ResourceDictionaryInfo <ResourceDictionaryInfo>k__BackingField;
    public ResourceDictionaryInfo ResourceDictionaryInfo { get; private set; }
    internal ResourceDictionaryLoadedEventArgs(ResourceDictionaryInfo resourceDictionaryInfo);
    [CompilerGeneratedAttribute]
public ResourceDictionaryInfo get_ResourceDictionaryInfo();
    [CompilerGeneratedAttribute]
private void set_ResourceDictionaryInfo(ResourceDictionaryInfo value);
}
public class System.Windows.Diagnostics.ResourceDictionaryUnloadedEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private ResourceDictionaryInfo <ResourceDictionaryInfo>k__BackingField;
    public ResourceDictionaryInfo ResourceDictionaryInfo { get; private set; }
    internal ResourceDictionaryUnloadedEventArgs(ResourceDictionaryInfo resourceDictionaryInfo);
    [CompilerGeneratedAttribute]
public ResourceDictionaryInfo get_ResourceDictionaryInfo();
    [CompilerGeneratedAttribute]
private void set_ResourceDictionaryInfo(ResourceDictionaryInfo value);
}
public class System.Windows.Diagnostics.StaticResourceResolvedEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private object <TargetObject>k__BackingField;
    [CompilerGeneratedAttribute]
private object <TargetProperty>k__BackingField;
    [CompilerGeneratedAttribute]
private ResourceDictionary <ResourceDictionary>k__BackingField;
    [CompilerGeneratedAttribute]
private object <ResourceKey>k__BackingField;
    public object TargetObject { get; private set; }
    public object TargetProperty { get; private set; }
    public ResourceDictionary ResourceDictionary { get; private set; }
    public object ResourceKey { get; private set; }
    internal StaticResourceResolvedEventArgs(object targetObject, object targetProperty, ResourceDictionary rd, object key);
    [CompilerGeneratedAttribute]
public object get_TargetObject();
    [CompilerGeneratedAttribute]
private void set_TargetObject(object value);
    [CompilerGeneratedAttribute]
public object get_TargetProperty();
    [CompilerGeneratedAttribute]
private void set_TargetProperty(object value);
    [CompilerGeneratedAttribute]
public ResourceDictionary get_ResourceDictionary();
    [CompilerGeneratedAttribute]
private void set_ResourceDictionary(ResourceDictionary value);
    [CompilerGeneratedAttribute]
public object get_ResourceKey();
    [CompilerGeneratedAttribute]
private void set_ResourceKey(object value);
}
public class System.Windows.DialogResultConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext typeDescriptorContext, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext typeDescriptorContext, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext typeDescriptorContext, CultureInfo cultureInfo, object source);
    public virtual object ConvertTo(ITypeDescriptorContext typeDescriptorContext, CultureInfo cultureInfo, object value, Type destinationType);
}
public abstract class System.Windows.Documents.Adorner : FrameworkElement {
    private UIElement _adornedElement;
    private bool _isClipEnabled;
    internal Geometry AdornerClip { get; internal set; }
    internal Transform AdornerTransform { get; internal set; }
    public UIElement AdornedElement { get; }
    public bool IsClipEnabled { get; public set; }
    protected Adorner(UIElement adornedElement);
    protected virtual Size MeasureOverride(Size constraint);
    protected virtual Geometry GetLayoutClip(Size layoutSlotSize);
    public virtual GeneralTransform GetDesiredTransform(GeneralTransform transform);
    internal Geometry get_AdornerClip();
    internal void set_AdornerClip(Geometry value);
    internal Transform get_AdornerTransform();
    internal void set_AdornerTransform(Transform value);
    public UIElement get_AdornedElement();
    public bool get_IsClipEnabled();
    public void set_IsClipEnabled(bool value);
    private static object CreateFlowDirectionBinding(object o);
    internal virtual bool NeedsUpdate(Size oldSize);
}
public class System.Windows.Documents.AdornerDecorator : Decorator {
    private AdornerLayer _adornerLayer;
    public AdornerLayer AdornerLayer { get; }
    public UIElement Child { get; public set; }
    protected int VisualChildrenCount { get; }
    internal int EffectiveValuesInitialSize { get; }
    public AdornerLayer get_AdornerLayer();
    protected virtual Size MeasureOverride(Size constraint);
    protected virtual Size ArrangeOverride(Size finalSize);
    public virtual UIElement get_Child();
    public virtual void set_Child(UIElement value);
    protected virtual int get_VisualChildrenCount();
    protected virtual Visual GetVisualChild(int index);
    internal virtual int get_EffectiveValuesInitialSize();
}
public class System.Windows.Documents.AdornerLayer : FrameworkElement {
    private HybridDictionary _elementMap;
    private SortedList _zOrderMap;
    private static int DefaultZOrder;
    private VisualCollection _children;
    protected int VisualChildrenCount { get; }
    protected internal IEnumerator LogicalChildren { get; }
    internal HybridDictionary ElementMap { get; }
    internal int EffectiveValuesInitialSize { get; }
    internal AdornerLayer(Dispatcher context);
    public void Add(Adorner adorner);
    public void Remove(Adorner adorner);
    public void Update();
    public void Update(UIElement element);
    public Adorner[] GetAdorners(UIElement element);
    public AdornerHitTestResult AdornerHitTest(Point point);
    public static AdornerLayer GetAdornerLayer(Visual visual);
    protected virtual int get_VisualChildrenCount();
    protected virtual Visual GetVisualChild(int index);
    protected internal virtual IEnumerator get_LogicalChildren();
    protected virtual Size MeasureOverride(Size constraint);
    protected virtual Size ArrangeOverride(Size finalSize);
    internal void Add(Adorner adorner, int zOrder);
    internal void InvalidateAdorner(AdornerInfo adornerInfo);
    internal void OnLayoutUpdated(object sender, EventArgs args);
    internal void SetAdornerZOrder(Adorner adorner, int zOrder);
    internal int GetAdornerZOrder(Adorner adorner);
    internal HybridDictionary get_ElementMap();
    private void AddAdornerToVisualTree(AdornerInfo adornerInfo, int zOrder);
    private void Clear(UIElement element);
    private void UpdateElementAdorners(UIElement element);
    private void UpdateAdorner(UIElement element);
    private CombinedGeometry GetClipGeometry(Visual element, Adorner adorner);
    private bool RemoveAdornerInfo(IDictionary infoMap, Adorner adorner, object key);
    private AdornerInfo GetAdornerInfo(ArrayList adornerInfos, Adorner adorner);
    private void AddAdornerInfo(IDictionary infoMap, AdornerInfo adornerInfo, object key);
    internal virtual int get_EffectiveValuesInitialSize();
    private GeneralTransform GetProposedTransform(Adorner adorner, GeneralTransform sourceTransform);
}
[ContentPropertyAttribute("Blocks")]
public abstract class System.Windows.Documents.AnchoredBlock : Inline {
    public static DependencyProperty MarginProperty;
    public static DependencyProperty PaddingProperty;
    public static DependencyProperty BorderThicknessProperty;
    public static DependencyProperty BorderBrushProperty;
    public static DependencyProperty TextAlignmentProperty;
    public static DependencyProperty LineHeightProperty;
    public static DependencyProperty LineStackingStrategyProperty;
    [DesignerSerializationVisibilityAttribute("2")]
public BlockCollection Blocks { get; }
    public Thickness Margin { get; public set; }
    public Thickness Padding { get; public set; }
    public Thickness BorderThickness { get; public set; }
    public Brush BorderBrush { get; public set; }
    public TextAlignment TextAlignment { get; public set; }
    [TypeConverterAttribute("System.Windows.LengthConverter")]
public double LineHeight { get; public set; }
    public LineStackingStrategy LineStackingStrategy { get; public set; }
    internal bool IsIMEStructuralElement { get; }
    protected AnchoredBlock(Block block, TextPointer insertionPosition);
    private static AnchoredBlock();
    public BlockCollection get_Blocks();
    public Thickness get_Margin();
    public void set_Margin(Thickness value);
    public Thickness get_Padding();
    public void set_Padding(Thickness value);
    public Thickness get_BorderThickness();
    public void set_BorderThickness(Thickness value);
    public Brush get_BorderBrush();
    public void set_BorderBrush(Brush value);
    public TextAlignment get_TextAlignment();
    public void set_TextAlignment(TextAlignment value);
    public double get_LineHeight();
    public void set_LineHeight(double value);
    public LineStackingStrategy get_LineStackingStrategy();
    public void set_LineStackingStrategy(LineStackingStrategy value);
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeBlocks(XamlDesignerSerializationManager manager);
    internal virtual bool get_IsIMEStructuralElement();
}
public abstract class System.Windows.Documents.Block : TextElement {
    public static DependencyProperty IsHyphenationEnabledProperty;
    public static DependencyProperty MarginProperty;
    public static DependencyProperty PaddingProperty;
    public static DependencyProperty BorderThicknessProperty;
    public static DependencyProperty BorderBrushProperty;
    public static DependencyProperty TextAlignmentProperty;
    public static DependencyProperty FlowDirectionProperty;
    public static DependencyProperty LineHeightProperty;
    public static DependencyProperty LineStackingStrategyProperty;
    public static DependencyProperty BreakPageBeforeProperty;
    public static DependencyProperty BreakColumnBeforeProperty;
    public static DependencyProperty ClearFloatersProperty;
    public BlockCollection SiblingBlocks { get; }
    public Block NextBlock { get; }
    public Block PreviousBlock { get; }
    public bool IsHyphenationEnabled { get; public set; }
    public Thickness Margin { get; public set; }
    public Thickness Padding { get; public set; }
    public Thickness BorderThickness { get; public set; }
    public Brush BorderBrush { get; public set; }
    public TextAlignment TextAlignment { get; public set; }
    public FlowDirection FlowDirection { get; public set; }
    [TypeConverterAttribute("System.Windows.LengthConverter")]
public double LineHeight { get; public set; }
    public LineStackingStrategy LineStackingStrategy { get; public set; }
    public bool BreakPageBefore { get; public set; }
    public bool BreakColumnBefore { get; public set; }
    public WrapDirection ClearFloaters { get; public set; }
    internal bool IsIMEStructuralElement { get; }
    private static Block();
    public BlockCollection get_SiblingBlocks();
    public Block get_NextBlock();
    public Block get_PreviousBlock();
    public bool get_IsHyphenationEnabled();
    public void set_IsHyphenationEnabled(bool value);
    public static void SetIsHyphenationEnabled(DependencyObject element, bool value);
    public static bool GetIsHyphenationEnabled(DependencyObject element);
    public Thickness get_Margin();
    public void set_Margin(Thickness value);
    public Thickness get_Padding();
    public void set_Padding(Thickness value);
    public Thickness get_BorderThickness();
    public void set_BorderThickness(Thickness value);
    public Brush get_BorderBrush();
    public void set_BorderBrush(Brush value);
    public TextAlignment get_TextAlignment();
    public void set_TextAlignment(TextAlignment value);
    public static void SetTextAlignment(DependencyObject element, TextAlignment value);
    public static TextAlignment GetTextAlignment(DependencyObject element);
    public FlowDirection get_FlowDirection();
    public void set_FlowDirection(FlowDirection value);
    public double get_LineHeight();
    public void set_LineHeight(double value);
    public static void SetLineHeight(DependencyObject element, double value);
    [TypeConverterAttribute("System.Windows.LengthConverter")]
public static double GetLineHeight(DependencyObject element);
    public LineStackingStrategy get_LineStackingStrategy();
    public void set_LineStackingStrategy(LineStackingStrategy value);
    public static void SetLineStackingStrategy(DependencyObject element, LineStackingStrategy value);
    public static LineStackingStrategy GetLineStackingStrategy(DependencyObject element);
    public bool get_BreakPageBefore();
    public void set_BreakPageBefore(bool value);
    public bool get_BreakColumnBefore();
    public void set_BreakColumnBefore(bool value);
    public WrapDirection get_ClearFloaters();
    public void set_ClearFloaters(WrapDirection value);
    internal static bool IsValidMargin(object o);
    internal static bool IsValidPadding(object o);
    internal static bool IsValidBorderThickness(object o);
    internal virtual bool get_IsIMEStructuralElement();
    private static bool IsValidLineHeight(object o);
    private static bool IsValidLineStackingStrategy(object o);
    private static bool IsValidTextAlignment(object o);
    private static bool IsValidWrapDirection(object o);
    internal static bool IsValidThickness(Thickness t, bool allowNaN);
}
public class System.Windows.Documents.BlockCollection : TextElementCollection`1<Block> {
    public Block FirstBlock { get; }
    public Block LastBlock { get; }
    internal BlockCollection(DependencyObject owner, bool isOwnerParent);
    public Block get_FirstBlock();
    public Block get_LastBlock();
}
[ContentPropertyAttribute("Child")]
public class System.Windows.Documents.BlockUIContainer : Block {
    public UIElement Child { get; public set; }
    public BlockUIContainer(UIElement uiElement);
    public UIElement get_Child();
    public void set_Child(UIElement value);
}
public class System.Windows.Documents.Bold : Span {
    private static Bold();
    public Bold(Inline childInline);
    public Bold(Inline childInline, TextPointer insertionPosition);
    public Bold(TextPointer start, TextPointer end);
}
internal class System.Windows.Documents.BorderFormat : object {
    private long _cf;
    private long _width;
    private BorderType _type;
    private static BorderFormat _emptyBorderFormat;
    internal long CF { get; internal set; }
    internal long Width { get; internal set; }
    internal long EffectiveWidth { get; }
    internal BorderType Type { get; internal set; }
    internal bool IsNone { get; }
    internal string RTFEncoding { get; }
    internal static BorderFormat EmptyBorderFormat { get; }
    internal BorderFormat(BorderFormat cb);
    internal long get_CF();
    internal void set_CF(long value);
    internal long get_Width();
    internal void set_Width(long value);
    internal long get_EffectiveWidth();
    internal BorderType get_Type();
    internal void set_Type(BorderType value);
    internal bool get_IsNone();
    internal string get_RTFEncoding();
    internal static BorderFormat get_EmptyBorderFormat();
    internal void SetDefaults();
}
internal enum System.Windows.Documents.BorderType : Enum {
    public int value__;
    public static BorderType BorderNone;
    public static BorderType BorderSingle;
    public static BorderType BorderDouble;
}
internal class System.Windows.Documents.BringLineIntoViewCompletedEventArgs : AsyncCompletedEventArgs {
    private ITextPointer _position;
    private int _count;
    private ITextPointer _newPosition;
    private double _newSuggestedX;
    public ITextPointer Position { get; }
    public int Count { get; }
    public ITextPointer NewPosition { get; }
    public double NewSuggestedX { get; }
    public BringLineIntoViewCompletedEventArgs(ITextPointer position, double suggestedX, int count, ITextPointer newPosition, double newSuggestedX, int linesMoved, bool succeeded, Exception error, bool cancelled, object userState);
    public ITextPointer get_Position();
    public int get_Count();
    public ITextPointer get_NewPosition();
    public double get_NewSuggestedX();
}
internal class System.Windows.Documents.BringLineIntoViewCompletedEventHandler : MulticastDelegate {
    public BringLineIntoViewCompletedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, BringLineIntoViewCompletedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, BringLineIntoViewCompletedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class System.Windows.Documents.BringPageIntoViewCompletedEventArgs : AsyncCompletedEventArgs {
    private ITextPointer _position;
    private int _count;
    private ITextPointer _newPosition;
    private Point _newSuggestedOffset;
    public ITextPointer Position { get; }
    public int Count { get; }
    public ITextPointer NewPosition { get; }
    public Point NewSuggestedOffset { get; }
    public BringPageIntoViewCompletedEventArgs(ITextPointer position, Point suggestedOffset, int count, ITextPointer newPosition, Point newSuggestedOffset, int pagesMoved, bool succeeded, Exception error, bool cancelled, object userState);
    public ITextPointer get_Position();
    public int get_Count();
    public ITextPointer get_NewPosition();
    public Point get_NewSuggestedOffset();
}
internal class System.Windows.Documents.BringPageIntoViewCompletedEventHandler : MulticastDelegate {
    public BringPageIntoViewCompletedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, BringPageIntoViewCompletedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, BringPageIntoViewCompletedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class System.Windows.Documents.BringPointIntoViewCompletedEventArgs : AsyncCompletedEventArgs {
    private Point _point;
    private ITextPointer _position;
    public Point Point { get; }
    public ITextPointer Position { get; }
    public BringPointIntoViewCompletedEventArgs(Point point, ITextPointer position, bool succeeded, Exception error, bool cancelled, object userState);
    public Point get_Point();
    public ITextPointer get_Position();
}
internal class System.Windows.Documents.BringPointIntoViewCompletedEventHandler : MulticastDelegate {
    public BringPointIntoViewCompletedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, BringPointIntoViewCompletedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, BringPointIntoViewCompletedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class System.Windows.Documents.BringPositionIntoViewCompletedEventArgs : AsyncCompletedEventArgs {
    public BringPositionIntoViewCompletedEventArgs(ITextPointer position, bool succeeded, Exception error, bool cancelled, object userState);
}
internal class System.Windows.Documents.BringPositionIntoViewCompletedEventHandler : MulticastDelegate {
    public BringPositionIntoViewCompletedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, BringPositionIntoViewCompletedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, BringPositionIntoViewCompletedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class System.Windows.Documents.CaretElement : Adorner {
    internal static double BidiCaretIndicatorWidth;
    internal static double CaretPaddingWidth;
    private TextEditor _textEditor;
    private bool _showCaret;
    private bool _isSelectionActive;
    private AnimationClock _blinkAnimationClock;
    private double _left;
    private double _top;
    private double _systemCaretWidth;
    private double _interimWidth;
    private double _height;
    private double _win32Height;
    private bool _isBlinkEnabled;
    private Brush _caretBrush;
    private double _opacity;
    private AdornerLayer _adornerLayer;
    private bool _italic;
    private bool _win32Caret;
    private static double CaretOpacity;
    private static double BidiIndicatorHeightRatio;
    private static double DefaultNarrowCaretWidth;
    private Geometry _selectionGeometry;
    internal static double c_geometryCombineTolerance;
    internal static double c_endOfParaMagicMultiplier;
    internal static int ZOrderValue;
    private CaretSubElement _caretElement;
    private bool _pendingGeometryUpdate;
    private bool _scrolledToCurrentPositionYet;
    protected int VisualChildrenCount { get; }
    private static CaretElement Debug_CaretElement { get; }
    private static FrameworkElement Debug_RenderScope { get; }
    internal Geometry SelectionGeometry { get; }
    internal bool IsSelectionActive { get; internal set; }
    private bool IsInInterimState { get; }
    internal CaretElement(TextEditor textEditor, bool isBlinkEnabled);
    protected virtual int get_VisualChildrenCount();
    protected virtual Visual GetVisualChild(int index);
    protected virtual HitTestResult HitTestCore(PointHitTestParameters hitTestParameters);
    protected virtual void OnRender(DrawingContext drawingContext);
    protected virtual Size MeasureOverride(Size availableSize);
    protected virtual Size ArrangeOverride(Size availableSize);
    internal void Update(bool visible, Rect caretRectangle, Brush caretBrush, double opacity, bool italic, CaretScrollMethod scrollMethod, double scrollToOriginPosition);
    private void DoSimpleScrollToView(double scrollToOriginPosition, Rect scrollRectangle);
    private void DoNavigationalScrollToView(double scrollToOriginPosition, Rect targetRect);
    internal void UpdateSelection();
    internal static void AddGeometry(Geometry& geometry, Geometry addedGeometry);
    internal static void ClipGeometryByViewport(Geometry& geometry, Rect viewport);
    internal static void AddTransformToGeometry(Geometry targetGeometry, Transform transformToAdd);
    internal void Hide();
    internal void RefreshCaret(bool italic);
    internal void DetachFromView();
    internal void SetBlinking(bool isBlinkEnabled);
    internal void UpdateCaretBrush(Brush caretBrush);
    internal void OnRenderCaretSubElement(DrawingContext context);
    internal void OnTextViewUpdated();
    private static CaretElement get_Debug_CaretElement();
    private static FrameworkElement get_Debug_RenderScope();
    internal Geometry get_SelectionGeometry();
    internal bool get_IsSelectionActive();
    internal void set_IsSelectionActive(bool value);
    private FrameworkElement GetOwnerElement();
    internal static FrameworkElement GetOwnerElement(FrameworkElement uiScope);
    private void EnsureAttachedToView();
    private void SetBlinkAnimation(bool visible, bool positionChanged);
    private void Win32CreateCaret();
    private void Win32DestroyCaret();
    private void Win32SetCaretPos();
    private int ConvertToInt32(double value);
    private int Win32GetCaretBlinkTime();
    private bool get_IsInInterimState();
}
internal enum System.Windows.Documents.CaretScrollMethod : Enum {
    public int value__;
    public static CaretScrollMethod Unset;
    public static CaretScrollMethod Simple;
    public static CaretScrollMethod Navigation;
    public static CaretScrollMethod None;
}
internal class System.Windows.Documents.CellFormat : object {
    private long _cb;
    private long _cf;
    private long _nShading;
    private long _padT;
    private long _padB;
    private long _padR;
    private long _padL;
    private long _spaceT;
    private long _spaceB;
    private long _spaceR;
    private long _spaceL;
    private long _nCellX;
    private CellWidth _width;
    private VAlign _valign;
    private BorderFormat _brdL;
    private BorderFormat _brdR;
    private BorderFormat _brdT;
    private BorderFormat _brdB;
    private bool _fPending;
    private bool _fHMerge;
    private bool _fHMergeFirst;
    private bool _fVMerge;
    private bool _fVMergeFirst;
    private bool _fCellXSet;
    internal long CB { get; internal set; }
    internal long CF { get; internal set; }
    internal long Shading { get; internal set; }
    internal long PaddingLeft { get; internal set; }
    internal long PaddingRight { get; internal set; }
    internal long PaddingTop { get; internal set; }
    internal long PaddingBottom { get; internal set; }
    internal BorderFormat BorderTop { get; internal set; }
    internal BorderFormat BorderBottom { get; internal set; }
    internal BorderFormat BorderLeft { get; internal set; }
    internal BorderFormat BorderRight { get; internal set; }
    internal CellWidth Width { get; internal set; }
    internal long CellX { get; internal set; }
    internal bool IsCellXSet { get; internal set; }
    unknown VAlign VAlign {internal set; }
    internal long SpacingTop { get; internal set; }
    internal long SpacingLeft { get; internal set; }
    internal long SpacingBottom { get; internal set; }
    internal long SpacingRight { get; internal set; }
    internal bool IsPending { get; internal set; }
    internal bool IsHMerge { get; internal set; }
    internal bool IsHMergeFirst { get; internal set; }
    internal bool IsVMerge { get; internal set; }
    internal bool IsVMergeFirst { get; internal set; }
    internal bool HasBorder { get; }
    internal string RTFEncodingForWidth { get; }
    internal CellFormat(CellFormat cf);
    internal long get_CB();
    internal void set_CB(long value);
    internal long get_CF();
    internal void set_CF(long value);
    internal long get_Shading();
    internal void set_Shading(long value);
    internal long get_PaddingLeft();
    internal void set_PaddingLeft(long value);
    internal long get_PaddingRight();
    internal void set_PaddingRight(long value);
    internal long get_PaddingTop();
    internal void set_PaddingTop(long value);
    internal long get_PaddingBottom();
    internal void set_PaddingBottom(long value);
    internal BorderFormat get_BorderTop();
    internal void set_BorderTop(BorderFormat value);
    internal BorderFormat get_BorderBottom();
    internal void set_BorderBottom(BorderFormat value);
    internal BorderFormat get_BorderLeft();
    internal void set_BorderLeft(BorderFormat value);
    internal BorderFormat get_BorderRight();
    internal void set_BorderRight(BorderFormat value);
    internal CellWidth get_Width();
    internal void set_Width(CellWidth value);
    internal long get_CellX();
    internal void set_CellX(long value);
    internal bool get_IsCellXSet();
    internal void set_IsCellXSet(bool value);
    internal void set_VAlign(VAlign value);
    internal long get_SpacingTop();
    internal void set_SpacingTop(long value);
    internal long get_SpacingLeft();
    internal void set_SpacingLeft(long value);
    internal long get_SpacingBottom();
    internal void set_SpacingBottom(long value);
    internal long get_SpacingRight();
    internal void set_SpacingRight(long value);
    internal bool get_IsPending();
    internal void set_IsPending(bool value);
    internal bool get_IsHMerge();
    internal void set_IsHMerge(bool value);
    internal bool get_IsHMergeFirst();
    internal void set_IsHMergeFirst(bool value);
    internal bool get_IsVMerge();
    internal void set_IsVMerge(bool value);
    internal bool get_IsVMergeFirst();
    internal void set_IsVMergeFirst(bool value);
    internal bool get_HasBorder();
    internal string get_RTFEncodingForWidth();
    internal void SetDefaults();
    internal string GetBorderAttributeString(ConverterState converterState);
    internal string GetPaddingAttributeString();
}
internal class System.Windows.Documents.CellWidth : object {
    private WidthType _type;
    private long _value;
    internal WidthType Type { get; internal set; }
    internal long Value { get; internal set; }
    internal CellWidth(CellWidth cw);
    internal WidthType get_Type();
    internal void set_Type(WidthType value);
    internal long get_Value();
    internal void set_Value(long value);
    internal void SetDefaults();
}
internal class System.Windows.Documents.ChangeBlockUndoRecord : object {
    private UndoManager _undoManager;
    private IParentUndoUnit _parentUndoUnit;
    internal ChangeBlockUndoRecord(ITextContainer textContainer, string actionDescription);
    internal void OnEndChange();
}
internal class System.Windows.Documents.ChildDocumentBlock : object {
    private DocumentSequenceTextContainer _aggregatedContainer;
    private DocumentReference _docRef;
    private ITextContainer _container;
    private DocumentSequenceHighlightLayer _highlightLayer;
    private BlockStatus _status;
    private ChildDocumentBlock _previousBlock;
    private ChildDocumentBlock _nextBlock;
    internal DocumentSequenceTextContainer AggregatedContainer { get; }
    internal ITextContainer ChildContainer { get; }
    internal DocumentSequenceHighlightLayer ChildHighlightLayer { get; }
    internal DocumentReference DocRef { get; }
    internal ITextPointer End { get; }
    internal bool IsHead { get; }
    internal bool IsTail { get; }
    internal ChildDocumentBlock PreviousBlock { get; }
    internal ChildDocumentBlock NextBlock { get; }
    internal ChildDocumentBlock(DocumentSequenceTextContainer aggregatedContainer, ITextContainer childContainer);
    internal ChildDocumentBlock(DocumentSequenceTextContainer aggregatedContainer, DocumentReference docRef);
    internal ChildDocumentBlock InsertNextBlock(ChildDocumentBlock newBlock);
    internal DocumentSequenceTextContainer get_AggregatedContainer();
    internal ITextContainer get_ChildContainer();
    internal DocumentSequenceHighlightLayer get_ChildHighlightLayer();
    internal DocumentReference get_DocRef();
    internal ITextPointer get_End();
    internal bool get_IsHead();
    internal bool get_IsTail();
    internal ChildDocumentBlock get_PreviousBlock();
    internal ChildDocumentBlock get_NextBlock();
    private void _EnsureBlockLoaded();
    private bool _HasStatus(BlockStatus flags);
    private void _SetStatus(BlockStatus flags);
    private void _ClearStatus(BlockStatus flags);
}
internal class System.Windows.Documents.ColorTable : ArrayList {
    private bool _inProgress;
    unknown byte NewRed {internal set; }
    unknown byte NewGreen {internal set; }
    unknown byte NewBlue {internal set; }
    internal Color ColorAt(int index);
    internal void FinishColor();
    internal int AddColor(Color color);
    internal ColorTableEntry EntryAt(int index);
    internal void set_NewRed(byte value);
    internal void set_NewGreen(byte value);
    internal void set_NewBlue(byte value);
    private ColorTableEntry GetInProgressEntry();
}
internal class System.Windows.Documents.ColorTableEntry : object {
    private Color _color;
    private bool _bAuto;
    internal Color Color { get; internal set; }
    internal bool IsAuto { get; internal set; }
    unknown byte Red {internal set; }
    unknown byte Green {internal set; }
    unknown byte Blue {internal set; }
    internal Color get_Color();
    internal void set_Color(Color value);
    internal bool get_IsAuto();
    internal void set_IsAuto(bool value);
    internal void set_Red(byte value);
    internal void set_Green(byte value);
    internal void set_Blue(byte value);
}
internal class System.Windows.Documents.ColumnResizeUndoUnit : ParentUndoUnit {
    private TextContainer _textContainer;
    private Double[] _columnWidths;
    private int _cpTable;
    private int _columnIndex;
    private double _resizeAmount;
    internal ColumnResizeUndoUnit(TextPointer textPointerTable, int columnIndex, Double[] columnWidths, double resizeAmount);
    public virtual void Do();
}
internal class System.Windows.Documents.ColumnState : object {
    private long _nCellX;
    private DocumentNode _row;
    private bool _fFilled;
    internal long CellX { get; internal set; }
    internal DocumentNode Row { get; internal set; }
    internal bool IsFilled { get; internal set; }
    internal long get_CellX();
    internal void set_CellX(long value);
    internal DocumentNode get_Row();
    internal void set_Row(DocumentNode value);
    internal bool get_IsFilled();
    internal void set_IsFilled(bool value);
}
internal class System.Windows.Documents.ColumnStateArray : ArrayList {
    internal ColumnState EntryAt(int i);
    internal int GetMinUnfilledRowIndex();
}
internal class System.Windows.Documents.CompositionAdorner : Adorner {
    private AdornerLayer _adornerLayer;
    private ITextView _textView;
    private ArrayList _attributeRanges;
    private static double DotLength;
    private static double NormalLineHeightRatio;
    private static double BoldLineHeightRatio;
    private static double NormalDotLineHeightRatio;
    private static double BoldDotLineHeightRatio;
    private static double NormalDashRatio;
    private static double BoldDashRatio;
    private static double ClauseGapRatio;
    private static double NormalDashGapRatio;
    private static double BoldDashGapRatio;
    private static string chinesePinyin;
    private static CompositionAdorner();
    internal CompositionAdorner(ITextView textView);
    internal CompositionAdorner(ITextView textView, ArrayList attributeRanges);
    public virtual GeneralTransform GetDesiredTransform(GeneralTransform transform);
    protected virtual void OnRender(DrawingContext drawingContext);
    internal void AddAttributeRange(ITextPointer start, ITextPointer end, TextServicesDisplayAttribute textServiceDisplayAttribute);
    internal void InvalidateAdorner();
    internal void Initialize(ITextView textView);
    internal void Uninitialize();
}
internal static class System.Windows.Documents.Converters : object {
    internal static double HalfPointToPositivePx(double halfPoint);
    internal static double TwipToPx(double twip);
    internal static double TwipToPositivePx(double twip);
    internal static double TwipToPositiveVisiblePx(double twip);
    internal static string TwipToPxString(double twip);
    internal static string TwipToPositivePxString(double twip);
    internal static string TwipToPositiveVisiblePxString(double twip);
    internal static double PxToPt(double px);
    internal static long PxToTwipRounded(double px);
    internal static long PxToHalfPointRounded(double px);
    internal static bool StringToDouble(string s, Double& d);
    internal static bool StringToInt(string s, Int32& i);
    internal static string StringToXMLAttribute(string s);
    internal static bool HexStringToInt(string s, Int32& i);
    internal static string MarkerStyleToString(MarkerStyle ms);
    internal static string MarkerStyleToOldRTFString(MarkerStyle ms);
    internal static bool ColorToUse(ConverterState converterState, long cb, long cf, long shade, Color& c);
    internal static string AlignmentToString(HAlign a, DirState ds);
    internal static string MarkerCountToString(MarkerStyle ms, long nCount);
    private static string MarkerRomanCountToString(StringBuilder sb, MarkerStyle ms, long nCount);
    private static string MarkerAlphaCountToString(StringBuilder sb, MarkerStyle ms, long nCount);
    internal static void ByteToHex(byte byteData, Byte& firstHexByte, Byte& secondHexByte);
}
internal class System.Windows.Documents.ConverterState : object {
    private RtfFormatStack _rtfFormatStack;
    private DocumentNodeArray _documentNodeArray;
    private FontTable _fontTable;
    private ColorTable _colorTable;
    private ListTable _listTable;
    private ListOverrideTable _listOverrideTable;
    private long _defaultFont;
    private long _defaultLang;
    private long _defaultLangFE;
    private int _codePage;
    private bool _bMarkerWhiteSpace;
    private bool _bMarkerPresent;
    private BorderFormat _border;
    internal RtfFormatStack RtfFormatStack { get; }
    internal FontTable FontTable { get; }
    internal ColorTable ColorTable { get; }
    internal ListTable ListTable { get; }
    internal ListOverrideTable ListOverrideTable { get; }
    internal DocumentNodeArray DocumentNodeArray { get; }
    internal FormatState TopFormatState { get; }
    internal int CodePage { get; internal set; }
    internal long DefaultFont { get; internal set; }
    internal long DefaultLang { get; internal set; }
    internal long DefaultLangFE { get; internal set; }
    internal bool IsMarkerWhiteSpace { get; internal set; }
    internal bool IsMarkerPresent { get; internal set; }
    internal BorderFormat CurrentBorder { get; internal set; }
    internal FormatState PreviousTopFormatState(int fromTop);
    internal RtfFormatStack get_RtfFormatStack();
    internal FontTable get_FontTable();
    internal ColorTable get_ColorTable();
    internal ListTable get_ListTable();
    internal ListOverrideTable get_ListOverrideTable();
    internal DocumentNodeArray get_DocumentNodeArray();
    internal FormatState get_TopFormatState();
    internal int get_CodePage();
    internal void set_CodePage(int value);
    internal long get_DefaultFont();
    internal void set_DefaultFont(long value);
    internal long get_DefaultLang();
    internal void set_DefaultLang(long value);
    internal long get_DefaultLangFE();
    internal void set_DefaultLangFE(long value);
    internal bool get_IsMarkerWhiteSpace();
    internal void set_IsMarkerWhiteSpace(bool value);
    internal bool get_IsMarkerPresent();
    internal void set_IsMarkerPresent(bool value);
    internal BorderFormat get_CurrentBorder();
    internal void set_CurrentBorder(BorderFormat value);
}
internal enum System.Windows.Documents.DirState : Enum {
    public int value__;
    public static DirState DirDefault;
    public static DirState DirLTR;
    public static DirState DirRTL;
}
internal class System.Windows.Documents.DocumentNode : object {
    internal static String[] HtmlNames;
    internal static Int32[] HtmlLengths;
    internal static String[] XamlNames;
    private bool _bPending;
    private bool _bTerminated;
    private DocumentNodeType _type;
    private FormatState _formatState;
    private string _xaml;
    private StringBuilder _contentBuilder;
    private int _childCount;
    private int _index;
    private DocumentNode _parent;
    private DocumentNodeArray _dna;
    private ColumnStateArray _csa;
    private int _nRowSpan;
    private int _nColSpan;
    private string _sCustom;
    private long _nVirtualListLevel;
    private bool _bHasMarkerContent;
    private bool _bMatched;
    internal bool IsInline { get; }
    internal bool IsBlock { get; }
    internal bool IsEmptyNode { get; }
    internal bool IsHidden { get; }
    internal bool IsWhiteSpace { get; }
    internal bool IsPending { get; internal set; }
    internal bool IsTerminated { get; internal set; }
    internal bool IsMatched { get; internal set; }
    internal bool IsTrackedAsOpen { get; }
    internal bool HasMarkerContent { get; internal set; }
    internal bool IsNonEmpty { get; }
    internal string ListLabel { get; internal set; }
    internal long VirtualListLevel { get; internal set; }
    internal string NavigateUri { get; internal set; }
    internal DocumentNodeType Type { get; }
    internal FormatState FormatState { get; internal set; }
    internal FormatState ParentFormatStateForFont { get; }
    internal int ChildCount { get; internal set; }
    internal int Index { get; internal set; }
    internal DocumentNodeArray DNA { get; internal set; }
    internal int LastChildIndex { get; }
    internal DocumentNode ClosedParent { get; }
    internal DocumentNode Parent { get; internal set; }
    internal string Xaml { get; internal set; }
    internal StringBuilder Content { get; }
    internal int RowSpan { get; internal set; }
    internal int ColSpan { get; internal set; }
    internal ColumnStateArray ColumnStateArray { get; internal set; }
    internal DirState XamlDir { get; }
    internal DirState ParentXamlDir { get; }
    internal bool RequiresXamlDir { get; }
    internal long NearMargin { get; internal set; }
    internal long FarMargin { get; }
    internal DocumentNode(DocumentNodeType documentNodeType);
    private static DocumentNode();
    internal void InheritFormatState(FormatState formatState);
    internal string GetTagName();
    internal DocumentNode GetParentOfType(DocumentNodeType parentType);
    internal int GetTableDepth();
    internal int GetListDepth();
    internal void Terminate(ConverterState converterState);
    internal void ConstrainFontPropagation(FormatState fsOrig);
    internal bool RequiresXamlFontProperties();
    internal void AppendXamlFontProperties(ConverterState converterState, StringBuilder sb);
    internal string StripInvalidChars(string text);
    internal void AppendXamlEncoded(string text);
    internal void AppendXamlPrefix(ConverterState converterState);
    private void AppendXamlPrefixTableProperties(StringBuilder xamlStringBuilder);
    private void AppendXamlPrefixCellProperties(StringBuilder xamlStringBuilder, DocumentNodeArray dna, ConverterState converterState);
    private void AppendXamlDir(StringBuilder xamlStringBuilder);
    private void AppendXamlPrefixParagraphProperties(StringBuilder xamlStringBuilder, ConverterState converterState);
    private void AppendXamlPrefixListItemProperties(StringBuilder xamlStringBuilder);
    private void AppendXamlPrefixListProperties(StringBuilder xamlStringBuilder);
    private void AppendXamlPrefixHyperlinkProperties(StringBuilder xamlStringBuilder);
    private void AppendXamlTableColumnsAfterStartTag(StringBuilder xamlStringBuilder);
    internal void AppendXamlPostfix(ConverterState converterState);
    internal void AppendInlineXamlPrefix(ConverterState converterState);
    internal void AppendInlineXamlPostfix(ConverterState converterState);
    internal void AppendImageXamlPrefix();
    internal void AppendImageXamlPostfix();
    internal bool IsAncestorOf(DocumentNode documentNode);
    internal bool IsLastParagraphInCell();
    internal DocumentNodeArray GetTableRows();
    internal DocumentNodeArray GetRowsCells();
    internal int GetCellColumn();
    internal ColumnStateArray ComputeColumns();
    internal bool get_IsInline();
    internal bool get_IsBlock();
    internal bool get_IsEmptyNode();
    internal bool get_IsHidden();
    internal bool get_IsWhiteSpace();
    internal bool get_IsPending();
    internal void set_IsPending(bool value);
    internal bool get_IsTerminated();
    internal void set_IsTerminated(bool value);
    internal bool get_IsMatched();
    internal void set_IsMatched(bool value);
    internal bool get_IsTrackedAsOpen();
    internal bool get_HasMarkerContent();
    internal void set_HasMarkerContent(bool value);
    internal bool get_IsNonEmpty();
    internal string get_ListLabel();
    internal void set_ListLabel(string value);
    internal long get_VirtualListLevel();
    internal void set_VirtualListLevel(long value);
    internal string get_NavigateUri();
    internal void set_NavigateUri(string value);
    internal DocumentNodeType get_Type();
    internal FormatState get_FormatState();
    internal void set_FormatState(FormatState value);
    internal FormatState get_ParentFormatStateForFont();
    internal int get_ChildCount();
    internal void set_ChildCount(int value);
    internal int get_Index();
    internal void set_Index(int value);
    internal DocumentNodeArray get_DNA();
    internal void set_DNA(DocumentNodeArray value);
    internal int get_LastChildIndex();
    internal DocumentNode get_ClosedParent();
    internal DocumentNode get_Parent();
    internal void set_Parent(DocumentNode value);
    internal string get_Xaml();
    internal void set_Xaml(string value);
    internal StringBuilder get_Content();
    internal int get_RowSpan();
    internal void set_RowSpan(int value);
    internal int get_ColSpan();
    internal void set_ColSpan(int value);
    internal ColumnStateArray get_ColumnStateArray();
    internal void set_ColumnStateArray(ColumnStateArray value);
    internal DirState get_XamlDir();
    internal DirState get_ParentXamlDir();
    internal bool get_RequiresXamlDir();
    internal long get_NearMargin();
    internal void set_NearMargin(long value);
    internal long get_FarMargin();
}
internal class System.Windows.Documents.DocumentNodeArray : ArrayList {
    private bool _fMain;
    private DocumentNodeArray _dnaOpen;
    internal DocumentNode Top { get; }
    unknown bool IsMain {internal set; }
    internal DocumentNode EntryAt(int nAt);
    internal void Push(DocumentNode documentNode);
    internal DocumentNode Pop();
    internal DocumentNode TopPending();
    internal bool TestTop(DocumentNodeType documentNodeType);
    internal void PreCoalesceChildren(ConverterState converterState, int nStart, bool bChild);
    internal void CoalesceChildren(ConverterState converterState, int nStart);
    internal void CoalesceOnlyChildren(ConverterState converterState, int nStart);
    internal void CoalesceAll(ConverterState converterState);
    internal void CloseAtHelper(int index, int nChildCount);
    internal void CloseAt(int index);
    internal void AssertTreeInvariants();
    internal void AssertTreeSemanticInvariants();
    internal void CloseAll();
    internal int CountOpenNodes(DocumentNodeType documentNodeType);
    internal int CountOpenCells();
    internal DocumentNode GetOpenParentWhileParsing(DocumentNode dn);
    internal DocumentNodeType GetTableScope();
    internal MarkerList GetOpenMarkerStyles();
    internal MarkerList GetLastMarkerStyles(MarkerList mlHave, MarkerList mlWant);
    internal void OpenLastList();
    internal void OpenLastCell();
    internal int FindPendingFrom(DocumentNodeType documentNodeType, int nStart, int nLow);
    internal int FindPending(DocumentNodeType documentNodeType, int nLow);
    internal int FindPending(DocumentNodeType documentNodeType);
    internal int FindUnmatched(DocumentNodeType dnType);
    internal void EstablishTreeRelationships();
    internal void CullOpen();
    internal void InsertOpenNode(DocumentNode dn);
    internal void InsertNode(int nAt, DocumentNode dn);
    internal void InsertChildAt(DocumentNode dnParent, DocumentNode dnNew, int nInsertAt, int nChild);
    internal void Excise(int nAt, int nExcise);
    internal DocumentNode get_Top();
    internal void set_IsMain(bool value);
    private void PreCoalesceListItem(DocumentNode dn);
    private void PreCoalesceList(DocumentNode dn);
    private int PreCoalesceTable(DocumentNode dn);
    private void PreCoalesceRow(DocumentNode dn, Boolean& fVMerged);
    private void ProcessTableRowSpan(DocumentNodeArray dnaTables);
}
internal enum System.Windows.Documents.DocumentNodeType : Enum {
    public int value__;
    public static DocumentNodeType dnUnknown;
    public static DocumentNodeType dnText;
    public static DocumentNodeType dnInline;
    public static DocumentNodeType dnLineBreak;
    public static DocumentNodeType dnHyperlink;
    public static DocumentNodeType dnParagraph;
    public static DocumentNodeType dnInlineUIContainer;
    public static DocumentNodeType dnBlockUIContainer;
    public static DocumentNodeType dnImage;
    public static DocumentNodeType dnList;
    public static DocumentNodeType dnListItem;
    public static DocumentNodeType dnTable;
    public static DocumentNodeType dnTableBody;
    public static DocumentNodeType dnRow;
    public static DocumentNodeType dnCell;
    public static DocumentNodeType dnSection;
    public static DocumentNodeType dnFigure;
    public static DocumentNodeType dnFloater;
    public static DocumentNodeType dnFieldBegin;
    public static DocumentNodeType dnFieldEnd;
    public static DocumentNodeType dnShape;
    public static DocumentNodeType dnListText;
}
[UsableDuringInitializationAttribute("False")]
public class System.Windows.Documents.DocumentReference : FrameworkElement {
    public static DependencyProperty SourceProperty;
    private FixedDocument _doc;
    private FixedDocument _docIdentity;
    public Uri Source { get; public set; }
    private Uri System.Windows.Markup.IUriContext.BaseUri { get; private set; }
    internal FixedDocument CurrentlyLoadedDoc { get; }
    private static DocumentReference();
    public FixedDocument GetDocument(bool forceReload);
    public void SetDocument(FixedDocument doc);
    private static void OnSourceChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public Uri get_Source();
    public void set_Source(Uri value);
    private sealed virtual override Uri System.Windows.Markup.IUriContext.get_BaseUri();
    private sealed virtual override void System.Windows.Markup.IUriContext.set_BaseUri(Uri value);
    internal FixedDocument get_CurrentlyLoadedDoc();
    private void _Init();
    private Uri _ResolveUri();
    private FixedDocument _LoadDocument();
}
[DefaultMemberAttribute("Item")]
[CLSCompliantAttribute("False")]
public class System.Windows.Documents.DocumentReferenceCollection : object {
    [CompilerGeneratedAttribute]
private NotifyCollectionChangedEventHandler CollectionChanged;
    private List`1<DocumentReference> _internalList;
    public int Count { get; }
    public DocumentReference Item { get; }
    private IList`1<DocumentReference> _InternalList { get; }
    public sealed virtual IEnumerator`1<DocumentReference> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public void Add(DocumentReference item);
    public void CopyTo(DocumentReference[] array, int arrayIndex);
    public int get_Count();
    public DocumentReference get_Item(int index);
    [CompilerGeneratedAttribute]
public sealed virtual void add_CollectionChanged(NotifyCollectionChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_CollectionChanged(NotifyCollectionChangedEventHandler value);
    private IList`1<DocumentReference> get__InternalList();
    private void OnCollectionChanged(NotifyCollectionChangedAction action, object item, int index);
}
internal class System.Windows.Documents.DocumentSequenceHighlightLayer : HighlightLayer {
    [CompilerGeneratedAttribute]
private HighlightChangedEventHandler Changed;
    private DocumentSequenceTextContainer _docSeqContainer;
    internal Type OwnerType { get; }
    internal DocumentSequenceHighlightLayer(DocumentSequenceTextContainer docSeqContainer);
    internal virtual object GetHighlightValue(StaticTextPointer staticTextPointer, LogicalDirection direction);
    internal virtual bool IsContentHighlighted(StaticTextPointer staticTextPointer, LogicalDirection direction);
    internal virtual StaticTextPointer GetNextChangePosition(StaticTextPointer staticTextPointer, LogicalDirection direction);
    internal void RaiseHighlightChangedEvent(IList ranges);
    internal virtual Type get_OwnerType();
    [CompilerGeneratedAttribute]
internal virtual void add_Changed(HighlightChangedEventHandler value);
    [CompilerGeneratedAttribute]
internal virtual void remove_Changed(HighlightChangedEventHandler value);
}
internal class System.Windows.Documents.DocumentSequenceTextContainer : object {
    [CompilerGeneratedAttribute]
private EventHandler Changing;
    [CompilerGeneratedAttribute]
private TextContainerChangeEventHandler Change;
    [CompilerGeneratedAttribute]
private TextContainerChangedEventHandler Changed;
    private FixedDocumentSequence _parent;
    private DocumentSequenceTextPointer _start;
    private DocumentSequenceTextPointer _end;
    private ChildDocumentBlock _doclistHead;
    private ChildDocumentBlock _doclistTail;
    private ITextSelection _textSelection;
    private Highlights _highlights;
    private int _changeBlockLevel;
    private TextContainerChangedEventArgs _changes;
    private ITextView _textview;
    private bool _isReadOnly;
    private bool System.Windows.Documents.ITextContainer.IsReadOnly { get; }
    private ITextPointer System.Windows.Documents.ITextContainer.Start { get; }
    private ITextPointer System.Windows.Documents.ITextContainer.End { get; }
    private UInt32 System.Windows.Documents.ITextContainer.Generation { get; }
    private Highlights System.Windows.Documents.ITextContainer.Highlights { get; }
    private DependencyObject System.Windows.Documents.ITextContainer.Parent { get; }
    private ITextSelection System.Windows.Documents.ITextContainer.TextSelection { get; private set; }
    private UndoManager System.Windows.Documents.ITextContainer.UndoManager { get; }
    private ITextView System.Windows.Documents.ITextContainer.TextView { get; private set; }
    private int System.Windows.Documents.ITextContainer.SymbolCount { get; }
    private int System.Windows.Documents.ITextContainer.IMECharCount { get; }
    internal Highlights Highlights { get; }
    internal ITextSelection TextSelection { get; }
    internal DocumentSequenceTextContainer(DependencyObject parent);
    private sealed virtual override void System.Windows.Documents.ITextContainer.BeginChange();
    private sealed virtual override void System.Windows.Documents.ITextContainer.BeginChangeNoUndo();
    private sealed virtual override void System.Windows.Documents.ITextContainer.EndChange();
    private sealed virtual override void System.Windows.Documents.ITextContainer.EndChange(bool skipEvents);
    private sealed virtual override ITextPointer System.Windows.Documents.ITextContainer.CreatePointerAtOffset(int offset, LogicalDirection direction);
    private sealed virtual override ITextPointer System.Windows.Documents.ITextContainer.CreatePointerAtCharOffset(int charOffset, LogicalDirection direction);
    private sealed virtual override ITextPointer System.Windows.Documents.ITextContainer.CreateDynamicTextPointer(StaticTextPointer position, LogicalDirection direction);
    private sealed virtual override StaticTextPointer System.Windows.Documents.ITextContainer.CreateStaticPointerAtOffset(int offset);
    private sealed virtual override TextPointerContext System.Windows.Documents.ITextContainer.GetPointerContext(StaticTextPointer pointer, LogicalDirection direction);
    private sealed virtual override int System.Windows.Documents.ITextContainer.GetOffsetToPosition(StaticTextPointer position1, StaticTextPointer position2);
    private sealed virtual override int System.Windows.Documents.ITextContainer.GetTextInRun(StaticTextPointer position, LogicalDirection direction, Char[] textBuffer, int startIndex, int count);
    private sealed virtual override object System.Windows.Documents.ITextContainer.GetAdjacentElement(StaticTextPointer position, LogicalDirection direction);
    private sealed virtual override DependencyObject System.Windows.Documents.ITextContainer.GetParent(StaticTextPointer position);
    private sealed virtual override StaticTextPointer System.Windows.Documents.ITextContainer.CreatePointer(StaticTextPointer position, int offset);
    private sealed virtual override StaticTextPointer System.Windows.Documents.ITextContainer.GetNextContextPosition(StaticTextPointer position, LogicalDirection direction);
    private sealed virtual override int System.Windows.Documents.ITextContainer.CompareTo(StaticTextPointer position1, StaticTextPointer position2);
    private sealed virtual override int System.Windows.Documents.ITextContainer.CompareTo(StaticTextPointer position1, ITextPointer position2);
    private sealed virtual override object System.Windows.Documents.ITextContainer.GetValue(StaticTextPointer position, DependencyProperty formattingProperty);
    private sealed virtual override bool System.Windows.Documents.ITextContainer.get_IsReadOnly();
    private sealed virtual override ITextPointer System.Windows.Documents.ITextContainer.get_Start();
    private sealed virtual override ITextPointer System.Windows.Documents.ITextContainer.get_End();
    private sealed virtual override UInt32 System.Windows.Documents.ITextContainer.get_Generation();
    private sealed virtual override Highlights System.Windows.Documents.ITextContainer.get_Highlights();
    private sealed virtual override DependencyObject System.Windows.Documents.ITextContainer.get_Parent();
    private sealed virtual override ITextSelection System.Windows.Documents.ITextContainer.get_TextSelection();
    private sealed virtual override void System.Windows.Documents.ITextContainer.set_TextSelection(ITextSelection value);
    private sealed virtual override UndoManager System.Windows.Documents.ITextContainer.get_UndoManager();
    private sealed virtual override ITextView System.Windows.Documents.ITextContainer.get_TextView();
    private sealed virtual override void System.Windows.Documents.ITextContainer.set_TextView(ITextView value);
    private sealed virtual override int System.Windows.Documents.ITextContainer.get_SymbolCount();
    private sealed virtual override int System.Windows.Documents.ITextContainer.get_IMECharCount();
    [CompilerGeneratedAttribute]
public sealed virtual void add_Changing(EventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_Changing(EventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_Change(TextContainerChangeEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_Change(TextContainerChangeEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_Changed(TextContainerChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_Changed(TextContainerChangedEventHandler value);
    internal DocumentSequenceTextPointer VerifyPosition(ITextPointer position);
    internal DocumentSequenceTextPointer MapChildPositionToParent(ITextPointer tp);
    internal ChildDocumentBlock FindChildBlock(DocumentReference docRef);
    internal int GetChildBlockDistance(ChildDocumentBlock block1, ChildDocumentBlock block2);
    internal Highlights get_Highlights();
    internal ITextSelection get_TextSelection();
    private void _Initialize();
    private void AddChange(ITextPointer startPosition, int symbolCount, PrecursorTextChangeType precursorTextChange);
    private void _OnContentChanged(object sender, NotifyCollectionChangedEventArgs args);
    private void _OnHighlightChanged(object sender, HighlightChangedEventArgs args);
}
internal class System.Windows.Documents.DocumentSequenceTextPointer : ContentPosition {
    private ChildDocumentBlock _childBlock;
    private ITextPointer _childTp;
    private bool _isFrozen;
    private Type System.Windows.Documents.ITextPointer.ParentType { get; }
    private ITextContainer System.Windows.Documents.ITextPointer.TextContainer { get; }
    private bool System.Windows.Documents.ITextPointer.HasValidLayout { get; }
    private bool System.Windows.Documents.ITextPointer.IsAtCaretUnitBoundary { get; }
    private LogicalDirection System.Windows.Documents.ITextPointer.LogicalDirection { get; }
    private bool System.Windows.Documents.ITextPointer.IsAtInsertionPosition { get; }
    private bool System.Windows.Documents.ITextPointer.IsFrozen { get; }
    private int System.Windows.Documents.ITextPointer.Offset { get; }
    private int System.Windows.Documents.ITextPointer.CharOffset { get; }
    internal DocumentSequenceTextContainer AggregatedContainer { get; }
    internal ChildDocumentBlock ChildBlock { get; internal set; }
    internal ITextPointer ChildPointer { get; internal set; }
    internal DocumentSequenceTextPointer(ChildDocumentBlock childBlock, ITextPointer childPosition);
    private sealed virtual override void System.Windows.Documents.ITextPointer.SetLogicalDirection(LogicalDirection direction);
    private sealed virtual override int System.Windows.Documents.ITextPointer.CompareTo(ITextPointer position);
    private sealed virtual override int System.Windows.Documents.ITextPointer.CompareTo(StaticTextPointer position);
    private sealed virtual override int System.Windows.Documents.ITextPointer.GetOffsetToPosition(ITextPointer position);
    private sealed virtual override TextPointerContext System.Windows.Documents.ITextPointer.GetPointerContext(LogicalDirection direction);
    private sealed virtual override int System.Windows.Documents.ITextPointer.GetTextRunLength(LogicalDirection direction);
    private sealed virtual override string System.Windows.Documents.ITextPointer.GetTextInRun(LogicalDirection direction);
    private sealed virtual override int System.Windows.Documents.ITextPointer.GetTextInRun(LogicalDirection direction, Char[] textBuffer, int startIndex, int count);
    private sealed virtual override object System.Windows.Documents.ITextPointer.GetAdjacentElement(LogicalDirection direction);
    private sealed virtual override Type System.Windows.Documents.ITextPointer.GetElementType(LogicalDirection direction);
    private sealed virtual override bool System.Windows.Documents.ITextPointer.HasEqualScope(ITextPointer position);
    private sealed virtual override object System.Windows.Documents.ITextPointer.GetValue(DependencyProperty property);
    private sealed virtual override object System.Windows.Documents.ITextPointer.ReadLocalValue(DependencyProperty property);
    private sealed virtual override LocalValueEnumerator System.Windows.Documents.ITextPointer.GetLocalValueEnumerator();
    private sealed virtual override ITextPointer System.Windows.Documents.ITextPointer.CreatePointer();
    private sealed virtual override StaticTextPointer System.Windows.Documents.ITextPointer.CreateStaticPointer();
    private sealed virtual override ITextPointer System.Windows.Documents.ITextPointer.CreatePointer(int distance);
    private sealed virtual override ITextPointer System.Windows.Documents.ITextPointer.CreatePointer(LogicalDirection gravity);
    private sealed virtual override ITextPointer System.Windows.Documents.ITextPointer.CreatePointer(int distance, LogicalDirection gravity);
    private sealed virtual override void System.Windows.Documents.ITextPointer.Freeze();
    private sealed virtual override ITextPointer System.Windows.Documents.ITextPointer.GetFrozenPointer(LogicalDirection logicalDirection);
    private sealed virtual override void System.Windows.Documents.ITextPointer.InsertTextInRun(string textData);
    private sealed virtual override void System.Windows.Documents.ITextPointer.DeleteContentToPosition(ITextPointer limit);
    private sealed virtual override ITextPointer System.Windows.Documents.ITextPointer.GetNextContextPosition(LogicalDirection direction);
    private sealed virtual override ITextPointer System.Windows.Documents.ITextPointer.GetInsertionPosition(LogicalDirection direction);
    private sealed virtual override ITextPointer System.Windows.Documents.ITextPointer.GetFormatNormalizedPosition(LogicalDirection direction);
    private sealed virtual override ITextPointer System.Windows.Documents.ITextPointer.GetNextInsertionPosition(LogicalDirection direction);
    private sealed virtual override bool System.Windows.Documents.ITextPointer.ValidateLayout();
    private sealed virtual override Type System.Windows.Documents.ITextPointer.get_ParentType();
    private sealed virtual override ITextContainer System.Windows.Documents.ITextPointer.get_TextContainer();
    private sealed virtual override bool System.Windows.Documents.ITextPointer.get_HasValidLayout();
    private sealed virtual override bool System.Windows.Documents.ITextPointer.get_IsAtCaretUnitBoundary();
    private sealed virtual override LogicalDirection System.Windows.Documents.ITextPointer.get_LogicalDirection();
    private sealed virtual override bool System.Windows.Documents.ITextPointer.get_IsAtInsertionPosition();
    private sealed virtual override bool System.Windows.Documents.ITextPointer.get_IsFrozen();
    private sealed virtual override int System.Windows.Documents.ITextPointer.get_Offset();
    private sealed virtual override int System.Windows.Documents.ITextPointer.get_CharOffset();
    private sealed virtual override bool System.Windows.Documents.ITextPointer.MoveToNextContextPosition(LogicalDirection direction);
    private sealed virtual override int System.Windows.Documents.ITextPointer.MoveByOffset(int offset);
    private sealed virtual override void System.Windows.Documents.ITextPointer.MoveToPosition(ITextPointer position);
    private sealed virtual override void System.Windows.Documents.ITextPointer.MoveToElementEdge(ElementEdge edge);
    private sealed virtual override int System.Windows.Documents.ITextPointer.MoveToLineBoundary(int count);
    private sealed virtual override Rect System.Windows.Documents.ITextPointer.GetCharacterRect(LogicalDirection direction);
    private sealed virtual override bool System.Windows.Documents.ITextPointer.MoveToInsertionPosition(LogicalDirection direction);
    private sealed virtual override bool System.Windows.Documents.ITextPointer.MoveToNextInsertionPosition(LogicalDirection direction);
    internal DocumentSequenceTextContainer get_AggregatedContainer();
    internal ChildDocumentBlock get_ChildBlock();
    internal void set_ChildBlock(ChildDocumentBlock value);
    internal ITextPointer get_ChildPointer();
    internal void set_ChildPointer(ITextPointer value);
    public static int CompareTo(DocumentSequenceTextPointer thisTp, ITextPointer position);
    public static int GetOffsetToPosition(DocumentSequenceTextPointer thisTp, ITextPointer position);
    public static TextPointerContext GetPointerContext(DocumentSequenceTextPointer thisTp, LogicalDirection direction);
    public static int GetTextRunLength(DocumentSequenceTextPointer thisTp, LogicalDirection direction);
    public static int GetTextInRun(DocumentSequenceTextPointer thisTp, LogicalDirection direction, Char[] textBuffer, int startIndex, int count);
    public static object GetAdjacentElement(DocumentSequenceTextPointer thisTp, LogicalDirection direction);
    public static Type GetElementType(DocumentSequenceTextPointer thisTp, LogicalDirection direction);
    public static Type GetElementType(DocumentSequenceTextPointer thisTp);
    public static bool HasEqualScope(DocumentSequenceTextPointer thisTp, ITextPointer position);
    public static object GetValue(DocumentSequenceTextPointer thisTp, DependencyProperty property);
    public static object ReadLocalValue(DocumentSequenceTextPointer thisTp, DependencyProperty property);
    public static LocalValueEnumerator GetLocalValueEnumerator(DocumentSequenceTextPointer thisTp);
    public static ITextPointer CreatePointer(DocumentSequenceTextPointer thisTp);
    public static ITextPointer CreatePointer(DocumentSequenceTextPointer thisTp, int distance);
    public static ITextPointer CreatePointer(DocumentSequenceTextPointer thisTp, LogicalDirection gravity);
    public static ITextPointer CreatePointer(DocumentSequenceTextPointer thisTp, int distance, LogicalDirection gravity);
    internal static bool iScan(DocumentSequenceTextPointer thisTp, LogicalDirection direction);
    internal static bool iScan(DocumentSequenceTextPointer thisTp, int distance);
    private static DocumentSequenceTextPointer xGetClingDSTP(DocumentSequenceTextPointer thisTp, LogicalDirection direction);
    private static TextPointerContext xGapAwareGetSymbolType(DocumentSequenceTextPointer thisTp, LogicalDirection direction);
    private static object xGapAwareGetEmbeddedElement(DocumentSequenceTextPointer thisTp, LogicalDirection direction);
    private static int xGapAwareCompareTo(DocumentSequenceTextPointer thisTp, DocumentSequenceTextPointer tp);
    private static bool xUnseparated(DocumentSequenceTextPointer tp1, DocumentSequenceTextPointer tp2);
    private static int xGapAwareGetDistance(DocumentSequenceTextPointer tp1, DocumentSequenceTextPointer tp2);
    private static bool xGapAwareScan(DocumentSequenceTextPointer thisTp, int distance);
}
internal class System.Windows.Documents.DocumentSequenceTextView : TextViewBase {
    private FixedDocumentSequenceDocumentPage _docPage;
    private ITextView _childTextView;
    private ReadOnlyCollection`1<TextSegment> _textSegments;
    private ChildDocumentBlock _childBlock;
    internal UIElement RenderScope { get; }
    internal ITextContainer TextContainer { get; }
    internal bool IsValid { get; }
    internal bool RendersOwnSelection { get; }
    internal ReadOnlyCollection`1<TextSegment> TextSegments { get; }
    private ITextView ChildTextView { get; }
    private ChildDocumentBlock ChildBlock { get; }
    private DocumentSequenceTextContainer DocumentSequenceTextContainer { get; }
    internal DocumentSequenceTextView(FixedDocumentSequenceDocumentPage docPage);
    internal virtual ITextPointer GetTextPositionFromPoint(Point point, bool snapToText);
    internal virtual Rect GetRawRectangleFromTextPosition(ITextPointer position, Transform& transform);
    internal virtual Geometry GetTightBoundingGeometryFromTextPositions(ITextPointer startPosition, ITextPointer endPosition);
    internal virtual ITextPointer GetPositionAtNextLine(ITextPointer position, double suggestedX, int count, Double& newSuggestedX, Int32& linesMoved);
    internal virtual bool IsAtCaretUnitBoundary(ITextPointer position);
    internal virtual ITextPointer GetNextCaretUnitPosition(ITextPointer position, LogicalDirection direction);
    internal virtual ITextPointer GetBackspaceCaretUnitPosition(ITextPointer position);
    internal virtual TextSegment GetLineRange(ITextPointer position);
    internal virtual ReadOnlyCollection`1<GlyphRun> GetGlyphRuns(ITextPointer start, ITextPointer end);
    internal virtual bool Contains(ITextPointer position);
    internal virtual bool Validate();
    internal virtual bool Validate(Point point);
    internal virtual UIElement get_RenderScope();
    internal virtual ITextContainer get_TextContainer();
    internal virtual bool get_IsValid();
    internal virtual bool get_RendersOwnSelection();
    internal virtual ReadOnlyCollection`1<TextSegment> get_TextSegments();
    private ITextView get_ChildTextView();
    private ChildDocumentBlock get_ChildBlock();
    private DocumentSequenceTextContainer get_DocumentSequenceTextContainer();
}
public class System.Windows.Documents.DocumentStructures.BlockElement : object {
    internal ElementType _elementType;
    internal ElementType ElementType { get; }
    internal ElementType get_ElementType();
}
public class System.Windows.Documents.DocumentStructures.FigureStructure : SemanticBasicElement {
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object value);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string text);
    public void Add(NamedElement element);
    private sealed virtual override IEnumerator`1<NamedElement> System.Collections.Generic.IEnumerable<System.Windows.Documents.DocumentStructures.NamedElement>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class System.Windows.Documents.DocumentStructures.ListItemStructure : SemanticBasicElement {
    private string _markerName;
    public string Marker { get; public set; }
    public void Add(BlockElement element);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object value);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string text);
    private sealed virtual override IEnumerator`1<BlockElement> System.Collections.Generic.IEnumerable<System.Windows.Documents.DocumentStructures.BlockElement>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public string get_Marker();
    public void set_Marker(string value);
}
public class System.Windows.Documents.DocumentStructures.ListStructure : SemanticBasicElement {
    public void Add(ListItemStructure listItem);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object value);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string text);
    private sealed virtual override IEnumerator`1<ListItemStructure> System.Collections.Generic.IEnumerable<System.Windows.Documents.DocumentStructures.ListItemStructure>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class System.Windows.Documents.DocumentStructures.NamedElement : BlockElement {
    private string _reference;
    public string NameReference { get; public set; }
    public string get_NameReference();
    public void set_NameReference(string value);
}
public class System.Windows.Documents.DocumentStructures.ParagraphStructure : SemanticBasicElement {
    public void Add(NamedElement element);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object value);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string text);
    private sealed virtual override IEnumerator`1<NamedElement> System.Collections.Generic.IEnumerable<System.Windows.Documents.DocumentStructures.NamedElement>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class System.Windows.Documents.DocumentStructures.SectionStructure : SemanticBasicElement {
    public void Add(BlockElement element);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object value);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string text);
    private sealed virtual override IEnumerator`1<BlockElement> System.Collections.Generic.IEnumerable<System.Windows.Documents.DocumentStructures.BlockElement>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class System.Windows.Documents.DocumentStructures.SemanticBasicElement : BlockElement {
    internal List`1<BlockElement> _elementList;
    internal List`1<BlockElement> BlockElementList { get; }
    internal List`1<BlockElement> get_BlockElementList();
}
public class System.Windows.Documents.DocumentStructures.StoryBreak : BlockElement {
}
[ContentPropertyAttribute("BlockElementList")]
public class System.Windows.Documents.DocumentStructures.StoryFragment : object {
    private List`1<BlockElement> _elementList;
    private string _storyName;
    private string _fragmentName;
    private string _fragmentType;
    public string StoryName { get; public set; }
    public string FragmentName { get; public set; }
    public string FragmentType { get; public set; }
    internal List`1<BlockElement> BlockElementList { get; }
    public void Add(BlockElement element);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object value);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string text);
    private sealed virtual override IEnumerator`1<BlockElement> System.Collections.Generic.IEnumerable<System.Windows.Documents.DocumentStructures.BlockElement>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public string get_StoryName();
    public void set_StoryName(string value);
    public string get_FragmentName();
    public void set_FragmentName(string value);
    public string get_FragmentType();
    public void set_FragmentType(string value);
    internal List`1<BlockElement> get_BlockElementList();
}
[ContentPropertyAttribute("StoryFragmentList")]
public class System.Windows.Documents.DocumentStructures.StoryFragments : object {
    private List`1<StoryFragment> _elementList;
    internal List`1<StoryFragment> StoryFragmentList { get; }
    public void Add(StoryFragment storyFragment);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object value);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string text);
    private sealed virtual override IEnumerator`1<StoryFragment> System.Collections.Generic.IEnumerable<System.Windows.Documents.DocumentStructures.StoryFragment>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    internal List`1<StoryFragment> get_StoryFragmentList();
}
public class System.Windows.Documents.DocumentStructures.TableCellStructure : SemanticBasicElement {
    private int _rowSpan;
    private int _columnSpan;
    public int RowSpan { get; public set; }
    public int ColumnSpan { get; public set; }
    public void Add(BlockElement element);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object value);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string text);
    private sealed virtual override IEnumerator`1<BlockElement> System.Collections.Generic.IEnumerable<System.Windows.Documents.DocumentStructures.BlockElement>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public int get_RowSpan();
    public void set_RowSpan(int value);
    public int get_ColumnSpan();
    public void set_ColumnSpan(int value);
}
public class System.Windows.Documents.DocumentStructures.TableRowGroupStructure : SemanticBasicElement {
    public void Add(TableRowStructure tableRow);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object value);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string text);
    private sealed virtual override IEnumerator`1<TableRowStructure> System.Collections.Generic.IEnumerable<System.Windows.Documents.DocumentStructures.TableRowStructure>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class System.Windows.Documents.DocumentStructures.TableRowStructure : SemanticBasicElement {
    public void Add(TableCellStructure tableCell);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object value);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string text);
    private sealed virtual override IEnumerator`1<TableCellStructure> System.Collections.Generic.IEnumerable<System.Windows.Documents.DocumentStructures.TableCellStructure>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class System.Windows.Documents.DocumentStructures.TableStructure : SemanticBasicElement {
    public void Add(TableRowGroupStructure tableRowGroup);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object value);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string text);
    private sealed virtual override IEnumerator`1<TableRowGroupStructure> System.Collections.Generic.IEnumerable<System.Windows.Documents.DocumentStructures.TableRowGroupStructure>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal class System.Windows.Documents.DPTypeDescriptorContext : object {
    private DependencyProperty _property;
    private object _propertyValue;
    private IContainer System.ComponentModel.ITypeDescriptorContext.Container { get; }
    private object System.ComponentModel.ITypeDescriptorContext.Instance { get; }
    private PropertyDescriptor System.ComponentModel.ITypeDescriptorContext.PropertyDescriptor { get; }
    private DPTypeDescriptorContext(DependencyProperty property, object propertyValue);
    internal static string GetStringValue(DependencyProperty property, object propertyValue);
    private static string TextDecorationsFixup(TextDecorationCollection textDecorations);
    private static string CultureInfoFixup(DependencyProperty property, CultureInfo cultureInfo);
    private sealed virtual override IContainer System.ComponentModel.ITypeDescriptorContext.get_Container();
    private sealed virtual override object System.ComponentModel.ITypeDescriptorContext.get_Instance();
    private sealed virtual override void System.ComponentModel.ITypeDescriptorContext.OnComponentChanged();
    private sealed virtual override bool System.ComponentModel.ITypeDescriptorContext.OnComponentChanging();
    private sealed virtual override PropertyDescriptor System.ComponentModel.ITypeDescriptorContext.get_PropertyDescriptor();
    private sealed virtual override object System.IServiceProvider.GetService(Type serviceType);
}
public static class System.Windows.Documents.EditingCommands : object {
    private static object _synchronize;
    private static RoutedUICommand _ToggleInsert;
    private static RoutedUICommand _Delete;
    private static RoutedUICommand _Backspace;
    private static RoutedUICommand _DeleteNextWord;
    private static RoutedUICommand _DeletePreviousWord;
    private static RoutedUICommand _EnterParagraphBreak;
    private static RoutedUICommand _EnterLineBreak;
    private static RoutedUICommand _TabForward;
    private static RoutedUICommand _TabBackward;
    private static RoutedUICommand _Space;
    private static RoutedUICommand _ShiftSpace;
    private static RoutedUICommand _MoveRightByCharacter;
    private static RoutedUICommand _MoveLeftByCharacter;
    private static RoutedUICommand _MoveRightByWord;
    private static RoutedUICommand _MoveLeftByWord;
    private static RoutedUICommand _MoveDownByLine;
    private static RoutedUICommand _MoveUpByLine;
    private static RoutedUICommand _MoveDownByParagraph;
    private static RoutedUICommand _MoveUpByParagraph;
    private static RoutedUICommand _MoveDownByPage;
    private static RoutedUICommand _MoveUpByPage;
    private static RoutedUICommand _MoveToLineStart;
    private static RoutedUICommand _MoveToLineEnd;
    private static RoutedUICommand _MoveToColumnStart;
    private static RoutedUICommand _MoveToColumnEnd;
    private static RoutedUICommand _MoveToWindowTop;
    private static RoutedUICommand _MoveToWindowBottom;
    private static RoutedUICommand _MoveToDocumentStart;
    private static RoutedUICommand _MoveToDocumentEnd;
    private static RoutedUICommand _SelectRightByCharacter;
    private static RoutedUICommand _SelectLeftByCharacter;
    private static RoutedUICommand _SelectRightByWord;
    private static RoutedUICommand _SelectLeftByWord;
    private static RoutedUICommand _SelectDownByLine;
    private static RoutedUICommand _SelectUpByLine;
    private static RoutedUICommand _SelectDownByParagraph;
    private static RoutedUICommand _SelectUpByParagraph;
    private static RoutedUICommand _SelectDownByPage;
    private static RoutedUICommand _SelectUpByPage;
    private static RoutedUICommand _SelectToLineStart;
    private static RoutedUICommand _SelectToLineEnd;
    private static RoutedUICommand _SelectToColumnStart;
    private static RoutedUICommand _SelectToColumnEnd;
    private static RoutedUICommand _SelectToWindowTop;
    private static RoutedUICommand _SelectToWindowBottom;
    private static RoutedUICommand _SelectToDocumentStart;
    private static RoutedUICommand _SelectToDocumentEnd;
    private static RoutedUICommand _CopyFormat;
    private static RoutedUICommand _PasteFormat;
    private static RoutedUICommand _ResetFormat;
    private static RoutedUICommand _ToggleBold;
    private static RoutedUICommand _ToggleItalic;
    private static RoutedUICommand _ToggleUnderline;
    private static RoutedUICommand _ToggleSubscript;
    private static RoutedUICommand _ToggleSuperscript;
    private static RoutedUICommand _IncreaseFontSize;
    private static RoutedUICommand _DecreaseFontSize;
    private static RoutedUICommand _ApplyFontSize;
    private static RoutedUICommand _ApplyFontFamily;
    private static RoutedUICommand _ApplyForeground;
    private static RoutedUICommand _ApplyBackground;
    private static RoutedUICommand _ToggleSpellCheck;
    private static RoutedUICommand _ApplyInlineFlowDirectionRTL;
    private static RoutedUICommand _ApplyInlineFlowDirectionLTR;
    private static RoutedUICommand _AlignLeft;
    private static RoutedUICommand _AlignCenter;
    private static RoutedUICommand _AlignRight;
    private static RoutedUICommand _AlignJustify;
    private static RoutedUICommand _ApplySingleSpace;
    private static RoutedUICommand _ApplyOneAndAHalfSpace;
    private static RoutedUICommand _ApplyDoubleSpace;
    private static RoutedUICommand _IncreaseIndentation;
    private static RoutedUICommand _DecreaseIndentation;
    private static RoutedUICommand _ApplyParagraphFlowDirectionRTL;
    private static RoutedUICommand _ApplyParagraphFlowDirectionLTR;
    private static RoutedUICommand _RemoveListMarkers;
    private static RoutedUICommand _ToggleBullets;
    private static RoutedUICommand _ToggleNumbering;
    private static RoutedUICommand _InsertTable;
    private static RoutedUICommand _InsertRows;
    private static RoutedUICommand _InsertColumns;
    private static RoutedUICommand _DeleteRows;
    private static RoutedUICommand _DeleteColumns;
    private static RoutedUICommand _MergeCells;
    private static RoutedUICommand _SplitCell;
    private static RoutedUICommand _CorrectSpellingError;
    private static RoutedUICommand _IgnoreSpellingError;
    public static RoutedUICommand ToggleInsert { get; }
    public static RoutedUICommand Delete { get; }
    public static RoutedUICommand Backspace { get; }
    public static RoutedUICommand DeleteNextWord { get; }
    public static RoutedUICommand DeletePreviousWord { get; }
    public static RoutedUICommand EnterParagraphBreak { get; }
    public static RoutedUICommand EnterLineBreak { get; }
    public static RoutedUICommand TabForward { get; }
    public static RoutedUICommand TabBackward { get; }
    public static RoutedUICommand MoveRightByCharacter { get; }
    public static RoutedUICommand MoveLeftByCharacter { get; }
    public static RoutedUICommand MoveRightByWord { get; }
    public static RoutedUICommand MoveLeftByWord { get; }
    public static RoutedUICommand MoveDownByLine { get; }
    public static RoutedUICommand MoveUpByLine { get; }
    public static RoutedUICommand MoveDownByParagraph { get; }
    public static RoutedUICommand MoveUpByParagraph { get; }
    public static RoutedUICommand MoveDownByPage { get; }
    public static RoutedUICommand MoveUpByPage { get; }
    public static RoutedUICommand MoveToLineStart { get; }
    public static RoutedUICommand MoveToLineEnd { get; }
    public static RoutedUICommand MoveToDocumentStart { get; }
    public static RoutedUICommand MoveToDocumentEnd { get; }
    public static RoutedUICommand SelectRightByCharacter { get; }
    public static RoutedUICommand SelectLeftByCharacter { get; }
    public static RoutedUICommand SelectRightByWord { get; }
    public static RoutedUICommand SelectLeftByWord { get; }
    public static RoutedUICommand SelectDownByLine { get; }
    public static RoutedUICommand SelectUpByLine { get; }
    public static RoutedUICommand SelectDownByParagraph { get; }
    public static RoutedUICommand SelectUpByParagraph { get; }
    public static RoutedUICommand SelectDownByPage { get; }
    public static RoutedUICommand SelectUpByPage { get; }
    public static RoutedUICommand SelectToLineStart { get; }
    public static RoutedUICommand SelectToLineEnd { get; }
    public static RoutedUICommand SelectToDocumentStart { get; }
    public static RoutedUICommand SelectToDocumentEnd { get; }
    public static RoutedUICommand ToggleBold { get; }
    public static RoutedUICommand ToggleItalic { get; }
    public static RoutedUICommand ToggleUnderline { get; }
    public static RoutedUICommand ToggleSubscript { get; }
    public static RoutedUICommand ToggleSuperscript { get; }
    public static RoutedUICommand IncreaseFontSize { get; }
    public static RoutedUICommand DecreaseFontSize { get; }
    public static RoutedUICommand AlignLeft { get; }
    public static RoutedUICommand AlignCenter { get; }
    public static RoutedUICommand AlignRight { get; }
    public static RoutedUICommand AlignJustify { get; }
    public static RoutedUICommand ToggleBullets { get; }
    public static RoutedUICommand ToggleNumbering { get; }
    public static RoutedUICommand IncreaseIndentation { get; }
    public static RoutedUICommand DecreaseIndentation { get; }
    public static RoutedUICommand CorrectSpellingError { get; }
    public static RoutedUICommand IgnoreSpellingError { get; }
    internal static RoutedUICommand Space { get; }
    internal static RoutedUICommand ShiftSpace { get; }
    internal static RoutedUICommand MoveToColumnStart { get; }
    internal static RoutedUICommand MoveToColumnEnd { get; }
    internal static RoutedUICommand MoveToWindowTop { get; }
    internal static RoutedUICommand MoveToWindowBottom { get; }
    internal static RoutedUICommand SelectToColumnStart { get; }
    internal static RoutedUICommand SelectToColumnEnd { get; }
    internal static RoutedUICommand SelectToWindowTop { get; }
    internal static RoutedUICommand SelectToWindowBottom { get; }
    internal static RoutedUICommand ResetFormat { get; }
    internal static RoutedUICommand ToggleSpellCheck { get; }
    internal static RoutedUICommand ApplyFontSize { get; }
    internal static RoutedUICommand ApplyFontFamily { get; }
    internal static RoutedUICommand ApplyForeground { get; }
    internal static RoutedUICommand ApplyBackground { get; }
    internal static RoutedUICommand ApplyInlineFlowDirectionRTL { get; }
    internal static RoutedUICommand ApplyInlineFlowDirectionLTR { get; }
    internal static RoutedUICommand ApplySingleSpace { get; }
    internal static RoutedUICommand ApplyOneAndAHalfSpace { get; }
    internal static RoutedUICommand ApplyDoubleSpace { get; }
    internal static RoutedUICommand ApplyParagraphFlowDirectionRTL { get; }
    internal static RoutedUICommand ApplyParagraphFlowDirectionLTR { get; }
    internal static RoutedUICommand CopyFormat { get; }
    internal static RoutedUICommand PasteFormat { get; }
    internal static RoutedUICommand RemoveListMarkers { get; }
    internal static RoutedUICommand InsertTable { get; }
    internal static RoutedUICommand InsertRows { get; }
    internal static RoutedUICommand InsertColumns { get; }
    internal static RoutedUICommand DeleteRows { get; }
    internal static RoutedUICommand DeleteColumns { get; }
    internal static RoutedUICommand MergeCells { get; }
    internal static RoutedUICommand SplitCell { get; }
    private static EditingCommands();
    public static RoutedUICommand get_ToggleInsert();
    public static RoutedUICommand get_Delete();
    public static RoutedUICommand get_Backspace();
    public static RoutedUICommand get_DeleteNextWord();
    public static RoutedUICommand get_DeletePreviousWord();
    public static RoutedUICommand get_EnterParagraphBreak();
    public static RoutedUICommand get_EnterLineBreak();
    public static RoutedUICommand get_TabForward();
    public static RoutedUICommand get_TabBackward();
    public static RoutedUICommand get_MoveRightByCharacter();
    public static RoutedUICommand get_MoveLeftByCharacter();
    public static RoutedUICommand get_MoveRightByWord();
    public static RoutedUICommand get_MoveLeftByWord();
    public static RoutedUICommand get_MoveDownByLine();
    public static RoutedUICommand get_MoveUpByLine();
    public static RoutedUICommand get_MoveDownByParagraph();
    public static RoutedUICommand get_MoveUpByParagraph();
    public static RoutedUICommand get_MoveDownByPage();
    public static RoutedUICommand get_MoveUpByPage();
    public static RoutedUICommand get_MoveToLineStart();
    public static RoutedUICommand get_MoveToLineEnd();
    public static RoutedUICommand get_MoveToDocumentStart();
    public static RoutedUICommand get_MoveToDocumentEnd();
    public static RoutedUICommand get_SelectRightByCharacter();
    public static RoutedUICommand get_SelectLeftByCharacter();
    public static RoutedUICommand get_SelectRightByWord();
    public static RoutedUICommand get_SelectLeftByWord();
    public static RoutedUICommand get_SelectDownByLine();
    public static RoutedUICommand get_SelectUpByLine();
    public static RoutedUICommand get_SelectDownByParagraph();
    public static RoutedUICommand get_SelectUpByParagraph();
    public static RoutedUICommand get_SelectDownByPage();
    public static RoutedUICommand get_SelectUpByPage();
    public static RoutedUICommand get_SelectToLineStart();
    public static RoutedUICommand get_SelectToLineEnd();
    public static RoutedUICommand get_SelectToDocumentStart();
    public static RoutedUICommand get_SelectToDocumentEnd();
    public static RoutedUICommand get_ToggleBold();
    public static RoutedUICommand get_ToggleItalic();
    public static RoutedUICommand get_ToggleUnderline();
    public static RoutedUICommand get_ToggleSubscript();
    public static RoutedUICommand get_ToggleSuperscript();
    public static RoutedUICommand get_IncreaseFontSize();
    public static RoutedUICommand get_DecreaseFontSize();
    public static RoutedUICommand get_AlignLeft();
    public static RoutedUICommand get_AlignCenter();
    public static RoutedUICommand get_AlignRight();
    public static RoutedUICommand get_AlignJustify();
    public static RoutedUICommand get_ToggleBullets();
    public static RoutedUICommand get_ToggleNumbering();
    public static RoutedUICommand get_IncreaseIndentation();
    public static RoutedUICommand get_DecreaseIndentation();
    public static RoutedUICommand get_CorrectSpellingError();
    public static RoutedUICommand get_IgnoreSpellingError();
    internal static RoutedUICommand get_Space();
    internal static RoutedUICommand get_ShiftSpace();
    internal static RoutedUICommand get_MoveToColumnStart();
    internal static RoutedUICommand get_MoveToColumnEnd();
    internal static RoutedUICommand get_MoveToWindowTop();
    internal static RoutedUICommand get_MoveToWindowBottom();
    internal static RoutedUICommand get_SelectToColumnStart();
    internal static RoutedUICommand get_SelectToColumnEnd();
    internal static RoutedUICommand get_SelectToWindowTop();
    internal static RoutedUICommand get_SelectToWindowBottom();
    internal static RoutedUICommand get_ResetFormat();
    internal static RoutedUICommand get_ToggleSpellCheck();
    internal static RoutedUICommand get_ApplyFontSize();
    internal static RoutedUICommand get_ApplyFontFamily();
    internal static RoutedUICommand get_ApplyForeground();
    internal static RoutedUICommand get_ApplyBackground();
    internal static RoutedUICommand get_ApplyInlineFlowDirectionRTL();
    internal static RoutedUICommand get_ApplyInlineFlowDirectionLTR();
    internal static RoutedUICommand get_ApplySingleSpace();
    internal static RoutedUICommand get_ApplyOneAndAHalfSpace();
    internal static RoutedUICommand get_ApplyDoubleSpace();
    internal static RoutedUICommand get_ApplyParagraphFlowDirectionRTL();
    internal static RoutedUICommand get_ApplyParagraphFlowDirectionLTR();
    internal static RoutedUICommand get_CopyFormat();
    internal static RoutedUICommand get_PasteFormat();
    internal static RoutedUICommand get_RemoveListMarkers();
    internal static RoutedUICommand get_InsertTable();
    internal static RoutedUICommand get_InsertRows();
    internal static RoutedUICommand get_InsertColumns();
    internal static RoutedUICommand get_DeleteRows();
    internal static RoutedUICommand get_DeleteColumns();
    internal static RoutedUICommand get_MergeCells();
    internal static RoutedUICommand get_SplitCell();
    private static RoutedUICommand EnsureCommand(RoutedUICommand& command, string commandPropertyName);
}
[FlagsAttribute]
internal enum System.Windows.Documents.ElementEdge : Enum {
    public byte value__;
    public static ElementEdge BeforeStart;
    public static ElementEdge AfterStart;
    public static ElementEdge BeforeEnd;
    public static ElementEdge AfterEnd;
}
public class System.Windows.Documents.Figure : AnchoredBlock {
    public static DependencyProperty HorizontalAnchorProperty;
    public static DependencyProperty VerticalAnchorProperty;
    public static DependencyProperty HorizontalOffsetProperty;
    public static DependencyProperty VerticalOffsetProperty;
    public static DependencyProperty CanDelayPlacementProperty;
    public static DependencyProperty WrapDirectionProperty;
    public static DependencyProperty WidthProperty;
    public static DependencyProperty HeightProperty;
    public FigureHorizontalAnchor HorizontalAnchor { get; public set; }
    public FigureVerticalAnchor VerticalAnchor { get; public set; }
    [TypeConverterAttribute("System.Windows.LengthConverter")]
public double HorizontalOffset { get; public set; }
    [TypeConverterAttribute("System.Windows.LengthConverter")]
public double VerticalOffset { get; public set; }
    public bool CanDelayPlacement { get; public set; }
    public WrapDirection WrapDirection { get; public set; }
    public FigureLength Width { get; public set; }
    public FigureLength Height { get; public set; }
    public Figure(Block childBlock);
    public Figure(Block childBlock, TextPointer insertionPosition);
    private static Figure();
    public FigureHorizontalAnchor get_HorizontalAnchor();
    public void set_HorizontalAnchor(FigureHorizontalAnchor value);
    public FigureVerticalAnchor get_VerticalAnchor();
    public void set_VerticalAnchor(FigureVerticalAnchor value);
    public double get_HorizontalOffset();
    public void set_HorizontalOffset(double value);
    public double get_VerticalOffset();
    public void set_VerticalOffset(double value);
    public bool get_CanDelayPlacement();
    public void set_CanDelayPlacement(bool value);
    public WrapDirection get_WrapDirection();
    public void set_WrapDirection(WrapDirection value);
    public FigureLength get_Width();
    public void set_Width(FigureLength value);
    public FigureLength get_Height();
    public void set_Height(FigureLength value);
    private static bool IsValidHorizontalAnchor(object o);
    private static bool IsValidVerticalAnchor(object o);
    private static bool IsValidWrapDirection(object o);
    private static bool IsValidOffset(object o);
}
[FlagsAttribute]
internal enum System.Windows.Documents.FindFlags : Enum {
    public int value__;
    public static FindFlags None;
    public static FindFlags MatchCase;
    public static FindFlags FindInReverse;
    public static FindFlags FindWholeWordsOnly;
    public static FindFlags MatchDiacritics;
    public static FindFlags MatchKashida;
    public static FindFlags MatchAlefHamza;
}
[ContentPropertyAttribute("Pages")]
public class System.Windows.Documents.FixedDocument : FrameworkContentElement {
    public static DependencyProperty PrintTicketProperty;
    private IDictionary`2<object, GetPageAsyncRequest> _asyncOps;
    private IList`1<PageContent> _pendingPages;
    private PageContentCollection _pages;
    private PageContent _partialPage;
    private Dictionary`2<FixedPage, ArrayList> _highlights;
    private double _pageWidth;
    private double _pageHeight;
    private FixedTextContainer _fixedTextContainer;
    private RubberbandSelector _rubberbandSelector;
    private bool _navigateAfterPagination;
    private string _navigateFragment;
    private FixedDocumentPaginator _paginator;
    private DocumentReference _documentReference;
    private bool _hasExplicitStructure;
    private static string _structureRelationshipName;
    private static string _storyFragmentsRelationshipName;
    private static ContentType _storyFragmentsContentType;
    private static ContentType _documentStructureContentType;
    private static DependencyObjectType UIElementType;
    private Uri System.Windows.Markup.IUriContext.BaseUri { get; private set; }
    internal NavigationService NavigationService { get; internal set; }
    protected internal IEnumerator LogicalChildren { get; }
    public DocumentPaginator DocumentPaginator { get; }
    internal bool IsPageCountValid { get; }
    internal int PageCount { get; }
    internal Size PageSize { get; internal set; }
    internal bool HasExplicitStructure { get; }
    [DesignerSerializationVisibilityAttribute("2")]
public PageContentCollection Pages { get; }
    public object PrintTicket { get; public set; }
    internal FixedTextContainer FixedContainer { get; }
    internal Dictionary`2<FixedPage, ArrayList> Highlights { get; }
    internal DocumentReference DocumentReference { get; internal set; }
    private static FixedDocument();
    private sealed virtual override object System.IServiceProvider.GetService(Type serviceType);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object value);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string text);
    private sealed virtual override Uri System.Windows.Markup.IUriContext.get_BaseUri();
    private sealed virtual override void System.Windows.Markup.IUriContext.set_BaseUri(Uri value);
    private sealed virtual override void System.Windows.Documents.IFixedNavigate.NavigateAsync(string elementID);
    private sealed virtual override UIElement System.Windows.Documents.IFixedNavigate.FindElementByID(string elementID, FixedPage& rootFixedPage);
    internal NavigationService get_NavigationService();
    internal void set_NavigationService(NavigationService value);
    protected internal virtual IEnumerator get_LogicalChildren();
    public sealed virtual DocumentPaginator get_DocumentPaginator();
    internal DocumentPage GetPage(int pageNumber);
    internal void GetPageAsync(int pageNumber, object userState);
    internal int GetPageNumber(ContentPosition contentPosition);
    internal void CancelAsync(object userState);
    internal ContentPosition GetObjectPosition(object o);
    internal ContentPosition GetPagePosition(DocumentPage page);
    internal bool get_IsPageCountValid();
    internal int get_PageCount();
    internal Size get_PageSize();
    internal void set_PageSize(Size value);
    internal bool get_HasExplicitStructure();
    public PageContentCollection get_Pages();
    public object get_PrintTicket();
    public void set_PrintTicket(object value);
    protected virtual AutomationPeer OnCreateAutomationPeer();
    internal int GetIndexOfPage(FixedPage p);
    internal bool IsValidPageIndex(int index);
    internal FixedPage SyncGetPageWithCheck(int index);
    internal FixedPage SyncGetPage(int index, bool forceReload);
    internal void OnPageContentAppended(int index);
    internal void EnsurePageSize(FixedPage fp);
    internal bool GetPageSize(Size& pageSize, int pageNumber);
    internal Size ComputePageSize(FixedPage fp);
    internal FixedTextContainer get_FixedContainer();
    internal Dictionary`2<FixedPage, ArrayList> get_Highlights();
    internal DocumentReference get_DocumentReference();
    internal void set_DocumentReference(DocumentReference value);
    private void _Init();
    private void OnInitialized(object sender, EventArgs e);
    internal void ValidateDocStructure();
    internal static StoryFragments GetStoryFragments(FixedPage fixedPage);
    private static object ValidateAndLoadPartFromAbsoluteUri(Uri AbsoluteUriDoc, bool validateOnly, string rootElement, ContentType& mimeType);
    private static Uri GetStructureUriFromRelationship(Uri contentUri, string relationshipName);
    private void OnPageLoaded(object sender, EventArgs e);
    internal FixedPage GetFixedPage(int pageNumber);
    private void OnHighlightChanged(object sender, HighlightChangedEventArgs args);
    private object GetPageAsyncDelegate(object arg);
    private void OnGetPageRootCompleted(object sender, GetPageRootCompletedEventArgs args);
    private void _NotifyGetPageAsyncCompleted(DocumentPage page, int pageNumber, Exception error, bool cancelled, object userState);
}
internal class System.Windows.Documents.FixedDocumentPage : DocumentPage {
    private FixedDocument _panel;
    private FixedPage _page;
    private int _index;
    private bool _layedOut;
    private FixedTextView _textView;
    public Visual Visual { get; }
    internal ContentPosition ContentPosition { get; }
    internal FixedPage FixedPage { get; }
    internal int PageIndex { get; }
    internal FixedTextView TextView { get; }
    internal FixedDocument Owner { get; }
    internal FixedTextContainer TextContainer { get; }
    internal FixedDocumentPage(FixedDocument panel, FixedPage page, Size fixedSize, int index);
    private sealed virtual override object System.IServiceProvider.GetService(Type serviceType);
    public virtual Visual get_Visual();
    internal ContentPosition get_ContentPosition();
    internal FixedPage get_FixedPage();
    internal int get_PageIndex();
    internal FixedTextView get_TextView();
    internal FixedDocument get_Owner();
    internal FixedTextContainer get_TextContainer();
}
[ContentPropertyAttribute("References")]
public class System.Windows.Documents.FixedDocumentSequence : FrameworkContentElement {
    public static DependencyProperty PrintTicketProperty;
    private DocumentReferenceCollection _references;
    private DocumentReference _partialRef;
    private FixedDocumentSequencePaginator _paginator;
    private IDictionary`2<object, GetPageAsyncRequest> _asyncOps;
    private IList`1<RequestedPage> _pendingPages;
    private Size _pageSize;
    private bool _navigateAfterPagination;
    private string _navigateFragment;
    private DocumentSequenceTextContainer _textContainer;
    private RubberbandSelector _rubberbandSelector;
    protected internal IEnumerator LogicalChildren { get; }
    public DocumentPaginator DocumentPaginator { get; }
    internal bool IsPageCountValid { get; }
    internal int PageCount { get; }
    internal Size PageSize { get; internal set; }
    private Uri System.Windows.Markup.IUriContext.BaseUri { get; private set; }
    [CLSCompliantAttribute("False")]
[DesignerSerializationVisibilityAttribute("2")]
public DocumentReferenceCollection References { get; }
    public object PrintTicket { get; public set; }
    internal DocumentSequenceTextContainer TextContainer { get; }
    private static FixedDocumentSequence();
    private sealed virtual override object System.IServiceProvider.GetService(Type serviceType);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object value);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string text);
    private sealed virtual override void System.Windows.Documents.IFixedNavigate.NavigateAsync(string elementID);
    private sealed virtual override UIElement System.Windows.Documents.IFixedNavigate.FindElementByID(string elementID, FixedPage& rootFixedPage);
    protected internal virtual IEnumerator get_LogicalChildren();
    public sealed virtual DocumentPaginator get_DocumentPaginator();
    internal DocumentPage GetPage(int pageNumber);
    internal DocumentPage GetPage(FixedDocument document, int fixedDocPageNumber);
    internal void GetPageAsync(int pageNumber, object userState);
    internal int GetPageNumber(ContentPosition contentPosition);
    internal void CancelAsync(object userState);
    internal ContentPosition GetObjectPosition(object o);
    internal ContentPosition GetPagePosition(DocumentPage page);
    internal bool get_IsPageCountValid();
    internal int get_PageCount();
    internal Size get_PageSize();
    internal void set_PageSize(Size value);
    private sealed virtual override Uri System.Windows.Markup.IUriContext.get_BaseUri();
    private sealed virtual override void System.Windows.Markup.IUriContext.set_BaseUri(Uri value);
    public DocumentReferenceCollection get_References();
    public object get_PrintTicket();
    public void set_PrintTicket(object value);
    protected virtual AutomationPeer OnCreateAutomationPeer();
    internal DynamicDocumentPaginator GetPaginator(DocumentReference docRef);
    internal bool TranslatePageNumber(int pageNumber, DynamicDocumentPaginator& childPaginator, Int32& childPageNumber);
    internal DocumentSequenceTextContainer get_TextContainer();
    private void _Init();
    private void OnInitialized(object sender, EventArgs e);
    private void _OnDocumentReferenceInitialized(object sender, EventArgs e);
    private void _OnCollectionChanged(object sender, NotifyCollectionChangedEventArgs args);
    private bool _SynthesizeGlobalPageNumber(DynamicDocumentPaginator childPaginator, int childPageNumber, Int32& pageNumber);
    private void _OnChildPaginationCompleted(object sender, EventArgs args);
    private void _OnChildPaginationProgress(object sender, PaginationProgressEventArgs args);
    private void _OnChildPagesChanged(object sender, PagesChangedEventArgs args);
    private object _GetPageAsyncDelegate(object arg);
    private void _OnGetPageCompleted(object sender, GetPageCompletedEventArgs args);
    private void _NotifyGetPageAsyncCompleted(DocumentPage page, int pageNumber, Exception error, bool cancelled, object userState);
}
internal class System.Windows.Documents.FixedDocumentSequenceDocumentPage : DocumentPage {
    private FixedDocumentSequence _fixedDocumentSequence;
    private DynamicDocumentPaginator _documentPaginator;
    private DocumentPage _documentPage;
    private bool _layedOut;
    private DocumentSequenceTextView _textView;
    public Visual Visual { get; }
    internal ContentPosition ContentPosition { get; }
    internal DocumentReference ChildDocumentReference { get; }
    internal DocumentPage ChildDocumentPage { get; }
    internal FixedDocumentSequence FixedDocumentSequence { get; }
    internal FixedDocumentSequenceDocumentPage(FixedDocumentSequence documentSequence, DynamicDocumentPaginator documentPaginator, DocumentPage documentPage);
    private sealed virtual override object System.IServiceProvider.GetService(Type serviceType);
    public virtual Visual get_Visual();
    internal ContentPosition get_ContentPosition();
    internal DocumentReference get_ChildDocumentReference();
    internal DocumentPage get_ChildDocumentPage();
    internal FixedDocumentSequence get_FixedDocumentSequence();
}
internal class System.Windows.Documents.FixedDSBuilder : object {
    private StoryFragments _storyFragments;
    private FixedPage _fixedPage;
    private List`1<FixedNode> _fixedNodes;
    private BitArray _visitedArray;
    private Dictionary`2<string, NameHashFixedNode> _nameHashTable;
    private FlowModelBuilder _flowBuilder;
    public StoryFragments StoryFragments { get; }
    public FixedDSBuilder(FixedPage fp, StoryFragments sf);
    public void BuildNameHashTable(string Name, UIElement e, int indexToFixedNodes);
    public StoryFragments get_StoryFragments();
    public void ConstructFlowNodes(FlowModelBuilder flowBuilder, List`1<FixedNode> fixedNodes);
    private void AddFixedNodeInFlow(int index, UIElement e);
    private void _CreateFlowNodes(BlockElement be);
    private void AddChildofFixedNodeinFlow(Int32[] childIndex, NamedElement ne);
    private void SpecialProcessing(SemanticBasicElement sbe);
    private void ConstructSomElement(NamedElement ne);
}
internal class System.Windows.Documents.FixedElement : DependencyObject {
    public static DependencyProperty LanguageProperty;
    public static DependencyProperty FontFamilyProperty;
    public static DependencyProperty FontStyleProperty;
    public static DependencyProperty FontWeightProperty;
    public static DependencyProperty FontStretchProperty;
    public static DependencyProperty FontSizeProperty;
    public static DependencyProperty ForegroundProperty;
    public static DependencyProperty FlowDirectionProperty;
    public static DependencyProperty CellSpacingProperty;
    public static DependencyProperty BorderThicknessProperty;
    public static DependencyProperty BorderBrushProperty;
    public static DependencyProperty ColumnSpanProperty;
    public static DependencyProperty NavigateUriProperty;
    public static DependencyProperty NameProperty;
    public static DependencyProperty HelpTextProperty;
    private ElementType _type;
    private FixedTextPointer _start;
    private FixedTextPointer _end;
    private object _object;
    private int _pageIndex;
    internal bool IsTextElement { get; }
    internal Type Type { get; }
    internal FixedTextPointer Start { get; }
    internal FixedTextPointer End { get; }
    internal int PageIndex { get; }
    unknown object Object {internal set; }
    internal FixedElement(ElementType type, FixedTextPointer start, FixedTextPointer end, int pageIndex);
    private static FixedElement();
    internal void Append(FixedElement e);
    internal object GetObject();
    internal object BuildObjectTree();
    private Image GetImage();
    private void ClickHyperlink(object sender, RequestNavigateEventArgs args);
    internal bool get_IsTextElement();
    internal Type get_Type();
    internal FixedTextPointer get_Start();
    internal FixedTextPointer get_End();
    internal int get_PageIndex();
    internal void set_Object(object value);
}
internal class System.Windows.Documents.FixedFindEngine : object {
    private static String[] _predefinedNamespaces;
    private static FixedFindEngine();
    internal static TextRange Find(ITextPointer start, ITextPointer end, string findPattern, CultureInfo cultureInfo, bool matchCase, bool matchWholeWord, bool matchLast, bool matchDiacritics, bool matchKashida, bool matchAlefHamza);
    private static bool _FoundOnPage(string pageString, string findPattern, CultureInfo cultureInfo, CompareOptions compareOptions);
    private static CompareOptions _InitializeSearch(CultureInfo cultureInfo, bool matchCase, bool matchAlefHamza, bool matchDiacritics, String& findPattern, Boolean& replaceAlefWithAlefHamza);
    private static void _GetFirstPageSearchPointers(ITextPointer start, ITextPointer end, int pageNumber, bool matchLast, ITextPointer& firstSearchPageStart, ITextPointer& firstSearchPageEnd);
    private static string _GetPageString(FixedDocument doc, int translatedPageNo, bool replaceAlefWithAlefHamza);
    private static string _ConstructPageString(Stream pageStream, bool reverseRTL);
}
[DefaultMemberAttribute("Item")]
internal class System.Windows.Documents.FixedFlowMap : object {
    internal static int FixedOrderStartPage;
    internal static int FixedOrderEndPage;
    internal static int FixedOrderStartVisual;
    internal static int FixedOrderEndVisual;
    internal static int FlowOrderBoundaryScopeId;
    internal static int FlowOrderVirtualScopeId;
    internal static int FlowOrderScopeIdStart;
    private List`1<FlowNode> _flowOrder;
    private FlowNode _flowStart;
    private FlowNode _flowEnd;
    private static FixedNode s_FixedStart;
    private static FixedNode s_FixedEnd;
    private Hashtable _mapping;
    private FixedNode _cachedFixedNode;
    private List`1<FixedSOMElement> _cachedEntry;
    internal FlowNode Item { get; }
    internal FixedNode FixedStartEdge { get; }
    internal FlowNode FlowStartEdge { get; }
    internal FlowNode FlowEndEdge { get; }
    internal int FlowCount { get; }
    private static FixedFlowMap();
    internal FlowNode get_Item(int fp);
    internal void MappingReplace(FlowNode flowOld, List`1<FlowNode> flowNew);
    internal FixedSOMElement MappingGetFixedSOMElement(FixedNode fixedp, int offset);
    internal FlowNode FlowOrderInsertBefore(FlowNode nextFlow, FlowNode newFlow);
    internal void AddFixedElement(FixedSOMElement element);
    internal FixedNode get_FixedStartEdge();
    internal FlowNode get_FlowStartEdge();
    internal FlowNode get_FlowEndEdge();
    internal int get_FlowCount();
    private void _Init();
    internal void _FlowOrderInsertBefore(FlowNode nextFlow, FlowNode newFlow);
    private List`1<FixedSOMElement> _GetEntry(FixedNode node);
    private void _AddEntry(FixedSOMElement element);
}
internal class System.Windows.Documents.FixedHighlight : object {
    private UIElement _element;
    private int _gBeginOffset;
    private int _gEndOffset;
    private FixedHighlightType _type;
    private Brush _backgroundBrush;
    private Brush _foregroundBrush;
    internal FixedHighlightType HighlightType { get; }
    internal Glyphs Glyphs { get; }
    internal UIElement Element { get; }
    internal Brush ForegroundBrush { get; }
    internal Brush BackgroundBrush { get; }
    internal FixedHighlight(UIElement element, int beginOffset, int endOffset, FixedHighlightType t, Brush foreground, Brush background);
    public virtual bool Equals(object oCompare);
    public virtual int GetHashCode();
    internal Rect ComputeDesignRect();
    internal FixedHighlightType get_HighlightType();
    internal Glyphs get_Glyphs();
    internal UIElement get_Element();
    internal Brush get_ForegroundBrush();
    internal Brush get_BackgroundBrush();
}
internal enum System.Windows.Documents.FixedHighlightType : Enum {
    public int value__;
    public static FixedHighlightType None;
    public static FixedHighlightType TextSelection;
    public static FixedHighlightType AnnotationHighlight;
}
internal static class System.Windows.Documents.FixedHyperLink : object {
    public static void OnNavigationServiceChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    internal static void FragmentHandler(object sender, FragmentNavigationEventArgs e);
    internal static void NavigateToElement(object ElementHost, string elementID);
}
internal class System.Windows.Documents.FixedLineResult : object {
    private FixedNode[] _nodes;
    private Rect _layoutBox;
    internal FixedNode Start { get; }
    internal FixedNode End { get; }
    internal FixedNode[] Nodes { get; }
    internal double BaseLine { get; }
    internal Rect LayoutBox { get; }
    internal FixedLineResult(FixedNode[] nodes, Rect layoutBox);
    public sealed virtual int CompareTo(object o);
    internal FixedNode get_Start();
    internal FixedNode get_End();
    internal FixedNode[] get_Nodes();
    internal double get_BaseLine();
    internal Rect get_LayoutBox();
}
[DefaultMemberAttribute("Item")]
internal class System.Windows.Documents.FixedNode : ValueType {
    private Int32[] _path;
    internal int Page { get; }
    internal int Item { get; }
    internal int ChildLevels { get; }
    private FixedNode(int page, int level1Index);
    private FixedNode(int page, int level1Index, int level2Index);
    private FixedNode(Int32[] path);
    internal static FixedNode Create(int pageIndex, int childLevels, int level1Index, int level2Index, Int32[] childPath);
    internal static FixedNode Create(int pageIndex, Int32[] childPath);
    public sealed virtual int CompareTo(object o);
    public int CompareTo(FixedNode fixedNode);
    internal int ComparetoIndex(Int32[] childPath);
    public static bool op_LessThan(FixedNode fp1, FixedNode fp2);
    public static bool op_LessThanOrEqual(FixedNode fp1, FixedNode fp2);
    public static bool op_GreaterThan(FixedNode fp1, FixedNode fp2);
    public static bool op_GreaterThanOrEqual(FixedNode fp1, FixedNode fp2);
    public virtual bool Equals(object o);
    public bool Equals(FixedNode fixedp);
    public static bool op_Equality(FixedNode fp1, FixedNode fp2);
    public static bool op_Inequality(FixedNode fp1, FixedNode fp2);
    public virtual int GetHashCode();
    internal int get_Page();
    internal int get_Item(int level);
    internal int get_ChildLevels();
}
[ContentPropertyAttribute("Children")]
public class System.Windows.Documents.FixedPage : FrameworkElement {
    public static DependencyProperty PrintTicketProperty;
    public static DependencyProperty BackgroundProperty;
    public static DependencyProperty LeftProperty;
    public static DependencyProperty TopProperty;
    public static DependencyProperty RightProperty;
    public static DependencyProperty BottomProperty;
    public static DependencyProperty ContentBoxProperty;
    public static DependencyProperty BleedBoxProperty;
    public static DependencyProperty NavigateUriProperty;
    private string _startPartUriString;
    private UIElementCollection _uiElementCollection;
    private Uri System.Windows.Markup.IUriContext.BaseUri { get; private set; }
    protected internal IEnumerator LogicalChildren { get; }
    [DesignerSerializationVisibilityAttribute("2")]
public UIElementCollection Children { get; }
    public object PrintTicket { get; public set; }
    public Brush Background { get; public set; }
    public Rect ContentBox { get; public set; }
    public Rect BleedBox { get; public set; }
    protected int VisualChildrenCount { get; }
    internal string StartPartUriString { get; internal set; }
    private static FixedPage();
    protected virtual AutomationPeer OnCreateAutomationPeer();
    protected virtual void OnPreviewMouseWheel(MouseWheelEventArgs e);
    protected virtual void OnRender(DrawingContext dc);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object value);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string text);
    [TypeConverterAttribute("System.Windows.LengthConverter, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")]
[AttachedPropertyBrowsableForChildrenAttribute]
public static double GetLeft(UIElement element);
    public static void SetLeft(UIElement element, double length);
    [AttachedPropertyBrowsableForChildrenAttribute]
[TypeConverterAttribute("System.Windows.LengthConverter, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")]
public static double GetTop(UIElement element);
    public static void SetTop(UIElement element, double length);
    [TypeConverterAttribute("System.Windows.LengthConverter, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")]
[AttachedPropertyBrowsableForChildrenAttribute]
public static double GetRight(UIElement element);
    public static void SetRight(UIElement element, double length);
    [TypeConverterAttribute("System.Windows.LengthConverter, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")]
[AttachedPropertyBrowsableForChildrenAttribute]
public static double GetBottom(UIElement element);
    public static void SetBottom(UIElement element, double length);
    [AttachedPropertyBrowsableForChildrenAttribute]
public static Uri GetNavigateUri(UIElement element);
    public static void SetNavigateUri(UIElement element, Uri uri);
    private sealed virtual override Uri System.Windows.Markup.IUriContext.get_BaseUri();
    private sealed virtual override void System.Windows.Markup.IUriContext.set_BaseUri(Uri value);
    protected internal virtual IEnumerator get_LogicalChildren();
    public UIElementCollection get_Children();
    public object get_PrintTicket();
    public void set_PrintTicket(object value);
    public Brush get_Background();
    public void set_Background(Brush value);
    public Rect get_ContentBox();
    public void set_ContentBox(Rect value);
    public Rect get_BleedBox();
    public void set_BleedBox(Rect value);
    protected internal virtual void OnVisualParentChanged(DependencyObject oldParent);
    private static object CoerceFlowDirection(DependencyObject page, object flowDirection);
    internal static Uri GetLinkUri(IInputElement element, Uri inputUri);
    protected virtual int get_VisualChildrenCount();
    protected virtual Visual GetVisualChild(int index);
    private UIElementCollection CreateUIElementCollection(FrameworkElement logicalParent);
    protected virtual Size MeasureOverride(Size constraint);
    protected virtual Size ArrangeOverride(Size arrangeSize);
    private sealed virtual override void System.Windows.Documents.IFixedNavigate.NavigateAsync(string elementID);
    private sealed virtual override UIElement System.Windows.Documents.IFixedNavigate.FindElementByID(string elementID, FixedPage& rootFixedPage);
    internal FixedNode CreateFixedNode(int pageIndex, UIElement e);
    internal Glyphs GetGlyphsElement(FixedNode node);
    internal DependencyObject GetElement(FixedNode node);
    internal string get_StartPartUriString();
    internal void set_StartPartUriString(string value);
    private void Init();
    internal StoryFragments GetPageStructure();
    internal Int32[] _CreateChildIndex(DependencyObject e);
    private FixedNode _CreateFixedNode(int pageIndex, UIElement e);
    private static string GetStartPartUriString(DependencyObject current);
}
internal class System.Windows.Documents.FixedPageStructure : object {
    private int _pageIndex;
    private FlowNode _flowStart;
    private FlowNode _flowEnd;
    private FixedNode _fixedStart;
    private FixedNode _fixedEnd;
    private FixedSOMPageConstructor _fixedSOMPageConstructor;
    private FixedSOMPage _fixedSOMPage;
    private FixedDSBuilder _fixedDSBuilder;
    private FixedLineResult[] _lineResults;
    internal FixedNode[] LastLine { get; }
    internal FixedNode[] FirstLine { get; }
    internal int PageIndex { get; }
    internal bool Loaded { get; }
    internal FlowNode FlowStart { get; }
    internal FlowNode FlowEnd { get; }
    internal FixedSOMPage FixedSOMPage { get; internal set; }
    internal FixedDSBuilder FixedDSBuilder { get; internal set; }
    internal FixedSOMPageConstructor PageConstructor { get; internal set; }
    internal FixedPageStructure(int pageIndex);
    internal void SetupLineResults(FixedLineResult[] lineResults);
    internal FixedNode[] GetNextLine(int line, bool forward, Int32& count);
    internal FixedNode[] FindSnapToLine(Point pt);
    internal void SetFlowBoundary(FlowNode flowStart, FlowNode flowEnd);
    public void ConstructFixedSOMPage(List`1<FixedNode> fixedNodes);
    internal FixedNode[] get_LastLine();
    internal FixedNode[] get_FirstLine();
    internal int get_PageIndex();
    internal bool get_Loaded();
    internal FlowNode get_FlowStart();
    internal FlowNode get_FlowEnd();
    internal FixedSOMPage get_FixedSOMPage();
    internal void set_FixedSOMPage(FixedSOMPage value);
    internal FixedDSBuilder get_FixedDSBuilder();
    internal void set_FixedDSBuilder(FixedDSBuilder value);
    internal FixedSOMPageConstructor get_PageConstructor();
    internal void set_PageConstructor(FixedSOMPageConstructor value);
}
internal class System.Windows.Documents.FixedPosition : ValueType {
    private FixedNode _fixedNode;
    private int _offset;
    internal int Page { get; }
    internal FixedNode Node { get; }
    internal int Offset { get; }
    internal FixedPosition(FixedNode fixedNode, int offset);
    internal int get_Page();
    internal FixedNode get_Node();
    internal int get_Offset();
}
internal abstract class System.Windows.Documents.FixedSOMContainer : FixedSOMSemanticBox {
    protected List`1<FixedSOMSemanticBox> _semanticBoxes;
    protected List`1<FixedNode> _fixedNodes;
    internal ElementType[] ElementTypes { get; }
    public List`1<FixedSOMSemanticBox> SemanticBoxes { get; public set; }
    public List`1<FixedNode> FixedNodes { get; }
    private sealed virtual override int System.IComparable.CompareTo(object comparedObj);
    protected void AddSorted(FixedSOMSemanticBox box);
    protected void Add(FixedSOMSemanticBox box);
    internal virtual ElementType[] get_ElementTypes();
    public List`1<FixedSOMSemanticBox> get_SemanticBoxes();
    public void set_SemanticBoxes(List`1<FixedSOMSemanticBox> value);
    public List`1<FixedNode> get_FixedNodes();
    private void _ConstructFixedNodes();
    private void _UpdateBoundingRect(Rect rect);
}
internal abstract class System.Windows.Documents.FixedSOMElement : FixedSOMSemanticBox {
    protected FixedNode _fixedNode;
    protected int _startIndex;
    protected int _endIndex;
    protected Matrix _mat;
    private FlowNode _flowNode;
    private int _offsetInFlowNode;
    public FixedNode FixedNode { get; }
    public int StartIndex { get; }
    public int EndIndex { get; }
    internal FlowNode FlowNode { get; internal set; }
    internal int OffsetInFlowNode { get; internal set; }
    internal Matrix Matrix { get; }
    protected FixedSOMElement(FixedNode fixedNode, int startIndex, int endIndex, GeneralTransform transform);
    protected FixedSOMElement(FixedNode fixedNode, GeneralTransform transform);
    public static FixedSOMElement CreateFixedSOMElement(FixedPage page, UIElement uiElement, FixedNode fixedNode, int startIndex, int endIndex);
    public FixedNode get_FixedNode();
    public int get_StartIndex();
    public int get_EndIndex();
    internal FlowNode get_FlowNode();
    internal void set_FlowNode(FlowNode value);
    internal int get_OffsetInFlowNode();
    internal void set_OffsetInFlowNode(int value);
    internal Matrix get_Matrix();
}
internal class System.Windows.Documents.FixedSOMFixedBlock : FixedSOMPageElement {
    private int _RTLCount;
    private int _LTRCount;
    private Matrix _matrix;
    public double LineHeight { get; }
    public bool IsFloatingImage { get; }
    internal ElementType[] ElementTypes { get; }
    public bool IsWhiteSpace { get; }
    public bool IsRTL { get; }
    public Matrix Matrix { get; }
    private FixedSOMTextRun LastTextRun { get; }
    public FixedSOMFixedBlock(FixedSOMPage page);
    public double get_LineHeight();
    public bool get_IsFloatingImage();
    internal virtual ElementType[] get_ElementTypes();
    public bool get_IsWhiteSpace();
    public virtual bool get_IsRTL();
    public Matrix get_Matrix();
    private FixedSOMTextRun get_LastTextRun();
    public void CombineWith(FixedSOMFixedBlock block);
    public void AddTextRun(FixedSOMTextRun textRun);
    public void AddImage(FixedSOMImage image);
    public virtual void SetRTFProperties(FixedElement element);
    private void _AddElement(FixedSOMElement element);
}
internal class System.Windows.Documents.FixedSOMGroup : FixedSOMPageElement {
    private int _RTLCount;
    private int _LTRCount;
    public bool IsRTL { get; }
    public FixedSOMGroup(FixedSOMPage page);
    private sealed virtual override int System.IComparable.CompareTo(object comparedObj);
    public void AddContainer(FixedSOMPageElement pageElement);
    public virtual bool get_IsRTL();
}
internal class System.Windows.Documents.FixedSOMImage : FixedSOMElement {
    private Uri _source;
    private string _name;
    private string _helpText;
    internal Uri Source { get; }
    internal string Name { get; }
    internal string HelpText { get; }
    private FixedSOMImage(Rect imageRect, GeneralTransform trans, Uri sourceUri, FixedNode node, DependencyObject o);
    public static FixedSOMImage Create(FixedPage page, Image image, FixedNode fixedNode);
    public static FixedSOMImage Create(FixedPage page, Path path, FixedNode fixedNode);
    internal Uri get_Source();
    internal string get_Name();
    internal string get_HelpText();
}
internal class System.Windows.Documents.FixedSOMLineCollection : object {
    private List`1<FixedSOMLineRanges> _horizontals;
    private List`1<FixedSOMLineRanges> _verticals;
    private static double _fudgeFactor;
    public List`1<FixedSOMLineRanges> HorizontalLines { get; }
    public List`1<FixedSOMLineRanges> VerticalLines { get; }
    public bool IsVerticallySeparated(double left, double top, double right, double bottom);
    public bool IsHorizontallySeparated(double left, double top, double right, double bottom);
    public void AddVertical(Point point1, Point point2);
    public void AddHorizontal(Point point1, Point point2);
    private void _AddLineToRanges(List`1<FixedSOMLineRanges> ranges, double line, double start, double end);
    private bool _IsSeparated(List`1<FixedSOMLineRanges> lines, double parallelLowEnd, double perpLowEnd, double parallelHighEnd, double perpHighEnd);
    public List`1<FixedSOMLineRanges> get_HorizontalLines();
    public List`1<FixedSOMLineRanges> get_VerticalLines();
}
internal class System.Windows.Documents.FixedSOMLineRanges : object {
    private double _line;
    private List`1<double> _start;
    private List`1<double> _end;
    private static double _minLineSeparation;
    public double Line { get; public set; }
    public List`1<double> Start { get; }
    public List`1<double> End { get; }
    public int Count { get; }
    public static double MinLineSeparation { get; }
    public void AddRange(double start, double end);
    public int GetLineAt(double line);
    public void set_Line(double value);
    public double get_Line();
    public List`1<double> get_Start();
    public List`1<double> get_End();
    public int get_Count();
    public static double get_MinLineSeparation();
}
internal class System.Windows.Documents.FixedSOMPage : FixedSOMContainer {
    private List`1<FixedNode> _markupOrder;
    private CultureInfo _cultureInfo;
    internal ElementType[] ElementTypes { get; }
    internal List`1<FixedNode> MarkupOrder { get; internal set; }
    unknown CultureInfo CultureInfo {internal set; }
    public void AddFixedBlock(FixedSOMFixedBlock fixedBlock);
    public void AddTable(FixedSOMTable table);
    public virtual void SetRTFProperties(FixedElement element);
    internal virtual ElementType[] get_ElementTypes();
    internal List`1<FixedNode> get_MarkupOrder();
    internal void set_MarkupOrder(List`1<FixedNode> value);
    internal void set_CultureInfo(CultureInfo value);
}
internal class System.Windows.Documents.FixedSOMPageConstructor : object {
    private FixedSOMFixedBlock _currentFixedBlock;
    private int _pageIndex;
    private FixedPage _fixedPage;
    private FixedSOMPage _fixedSOMPage;
    private List`1<FixedNode> _fixedNodes;
    private FixedSOMLineCollection _lines;
    private GeometryWalker _geometryWalker;
    public FixedSOMPage FixedSOMPage { get; }
    public FixedSOMPageConstructor(FixedPage fixedPage, int pageIndex);
    public FixedSOMPage ConstructPageStructure(List`1<FixedNode> fixedNodes);
    public void ProcessPath(Path path, Matrix transform);
    public FixedSOMPage get_FixedSOMPage();
    private void _ProcessImage(DependencyObject obj, FixedNode fixedNode);
    private void _ProcessGlyphsElement(Glyphs glyphs, FixedNode node);
    private void _CreateTextRun(Rect boundingRect, GeneralTransform trans, Glyphs glyphs, FixedNode node, int startIndex, int endIndex);
    private FixedSOMFixedBlock _GetContainingFixedBlock(FixedSOMTextRun textRun);
    private bool _IsCombinable(FixedSOMFixedBlock fixedBlock, FixedSOMTextRun textRun);
    private bool _IsSpatiallyCombinable(FixedSOMSemanticBox box1, FixedSOMSemanticBox box2, double inflateH, double inflateV);
    private bool _IsSpatiallyCombinable(Rect rect1, Rect rect2, double inflateH, double inflateV);
    private void _DetectTables();
    public void _AddLine(Point startP, Point endP, Matrix transform);
    private void _CombinePass();
    internal bool _ProcessFilledRect(Matrix transform, Rect bounds);
    private void _ProcessSolidPath(Matrix transform, PathGeometry pathGeom);
    private void _ProcessOutlinePath(Matrix transform, PathGeometry pathGeom);
    private void _FillTables(List`1<FixedSOMTableRow> tableRows);
    private void _CreateGroups(FixedSOMContainer container);
}
internal abstract class System.Windows.Documents.FixedSOMPageElement : FixedSOMContainer {
    protected FixedSOMPage _page;
    public FixedSOMPage FixedSOMPage { get; }
    public bool IsRTL { get; }
    public FixedSOMPageElement(FixedSOMPage page);
    public FixedSOMPage get_FixedSOMPage();
    public abstract virtual bool get_IsRTL();
}
internal abstract class System.Windows.Documents.FixedSOMSemanticBox : object {
    protected Rect _boundingRect;
    public Rect BoundingRect { get; public set; }
    public FixedSOMSemanticBox(Rect boundingRect);
    public Rect get_BoundingRect();
    public void set_BoundingRect(Rect value);
    public virtual void SetRTFProperties(FixedElement element);
    public int CompareTo(object o);
    private sealed virtual override int System.IComparable.CompareTo(object o);
    protected SpatialComparison _CompareHorizontal(FixedSOMSemanticBox otherBox, bool RTL);
    protected SpatialComparison _CompareVertical(FixedSOMSemanticBox otherBox);
    protected int _SpatialToAbsoluteComparison(SpatialComparison comparison);
    protected SpatialComparison _InvertSpatialComparison(SpatialComparison comparison);
}
internal class System.Windows.Documents.FixedSOMTable : FixedSOMPageElement {
    private static double _minColumnWidth;
    private static double _minRowHeight;
    private int _RTLCount;
    private int _LTRCount;
    private int _numCols;
    public bool IsRTL { get; }
    internal ElementType[] ElementTypes { get; }
    internal bool IsEmpty { get; }
    internal bool IsSingleCelled { get; }
    public FixedSOMTable(FixedSOMPage page);
    public void AddRow(FixedSOMTableRow row);
    public bool AddContainer(FixedSOMContainer container);
    public virtual void SetRTFProperties(FixedElement element);
    public virtual bool get_IsRTL();
    internal virtual ElementType[] get_ElementTypes();
    internal bool get_IsEmpty();
    internal bool get_IsSingleCelled();
    internal void DeleteEmptyRows();
    internal void DeleteEmptyColumns();
}
internal class System.Windows.Documents.FixedSOMTableCell : FixedSOMContainer {
    private bool _containsTable;
    private int _columnSpan;
    internal ElementType[] ElementTypes { get; }
    internal bool IsEmpty { get; }
    internal int ColumnSpan { get; internal set; }
    public FixedSOMTableCell(double left, double top, double right, double bottom);
    public void AddContainer(FixedSOMContainer container);
    public virtual void SetRTFProperties(FixedElement element);
    private bool _AddToInnerTable(FixedSOMContainer container);
    internal virtual ElementType[] get_ElementTypes();
    internal bool get_IsEmpty();
    internal int get_ColumnSpan();
    internal void set_ColumnSpan(int value);
}
internal class System.Windows.Documents.FixedSOMTableRow : FixedSOMContainer {
    internal ElementType[] ElementTypes { get; }
    internal bool IsEmpty { get; }
    public void AddCell(FixedSOMTableCell cell);
    internal virtual ElementType[] get_ElementTypes();
    internal bool get_IsEmpty();
}
internal class System.Windows.Documents.FixedSOMTextRun : FixedSOMElement {
    private double _defaultCharWidth;
    private Uri _fontUri;
    private CultureInfo _cultureInfo;
    private bool _isSideways;
    private int _bidiLevel;
    private bool _isWhiteSpace;
    private bool _isReversed;
    private FixedSOMFixedBlock _fixedBlock;
    private int _lineIndex;
    private string _text;
    private Brush _foreground;
    private double _fontSize;
    private string _fontFamily;
    private FontStyle _fontStyle;
    private FontWeight _fontWeight;
    private FontStretch _fontStretch;
    public double DefaultCharWidth { get; }
    public bool IsSideways { get; }
    public bool IsWhiteSpace { get; }
    public CultureInfo CultureInfo { get; }
    public bool IsLTR { get; }
    public bool IsRTL { get; }
    public string Text { get; public set; }
    public FixedSOMFixedBlock FixedBlock { get; public set; }
    public string FontFamily { get; }
    public FontStyle FontStyle { get; }
    public FontWeight FontWeight { get; }
    public FontStretch FontStretch { get; }
    public double FontRenderingEmSize { get; }
    public Brush Foreground { get; }
    public bool IsReversed { get; }
    internal int LineIndex { get; internal set; }
    private FixedSOMTextRun(Rect boundingRect, GeneralTransform trans, FixedNode fixedNode, int startIndex, int endIndex);
    private sealed virtual override int System.IComparable.CompareTo(object comparedObj);
    public static FixedSOMTextRun Create(Rect boundingRect, GeneralTransform transform, Glyphs glyphs, FixedNode fixedNode, int startIndex, int endIndex, bool allowReverseGlyphs);
    public bool HasSameRichProperties(FixedSOMTextRun run);
    public virtual void SetRTFProperties(FixedElement element);
    public double get_DefaultCharWidth();
    public bool get_IsSideways();
    public bool get_IsWhiteSpace();
    public CultureInfo get_CultureInfo();
    public bool get_IsLTR();
    public bool get_IsRTL();
    public string get_Text();
    public void set_Text(string value);
    public FixedSOMFixedBlock get_FixedBlock();
    public void set_FixedBlock(FixedSOMFixedBlock value);
    public string get_FontFamily();
    public FontStyle get_FontStyle();
    public FontWeight get_FontWeight();
    public FontStretch get_FontStretch();
    public double get_FontRenderingEmSize();
    public Brush get_Foreground();
    public bool get_IsReversed();
    internal int get_LineIndex();
    internal void set_LineIndex(int value);
}
internal class System.Windows.Documents.FixedTextBuilder : object {
    internal static char FLOWORDER_SEPARATOR;
    internal static CultureInfo[] AdjacentLanguage;
    internal static Char[] HyphenSet;
    private FixedTextContainer _container;
    private List`1<FixedPageStructure> _pageStructures;
    private int _nextScopeId;
    private FixedFlowMap _fixedFlowMap;
    private static Boolean[] _cTable;
    internal FixedFlowMap FixedFlowMap { get; }
    internal FixedTextBuilder(FixedTextContainer container);
    private static FixedTextBuilder();
    internal static bool AlwaysAdjacent(CultureInfo ci);
    internal static bool IsHyphen(char target);
    internal static bool IsSpace(char target);
    internal void AddVirtualPage();
    internal bool EnsureTextOMForPage(int pageIndex);
    internal FixedPage GetFixedPage(FixedNode node);
    internal Glyphs GetGlyphsElement(FixedNode node);
    internal FixedNode[] GetNextLine(FixedNode currentNode, bool forward, Int32& count);
    internal FixedNode[] GetLine(int pageIndex, Point pt);
    internal FixedNode[] GetFirstLine(int pageIndex);
    internal FlowPosition CreateFlowPosition(FixedPosition fixedPosition);
    internal FlowPosition GetPageStartFlowPosition(int pageIndex);
    internal FlowPosition GetPageEndFlowPosition(int pageIndex);
    internal bool GetFixedPosition(FlowPosition position, LogicalDirection textdir, FixedPosition& fixedp);
    internal bool GetFixedNodesForFlowRange(FlowPosition pStart, FlowPosition pEnd, FixedSOMElement[]& somElements, Int32& firstElementStart, Int32& lastElementEnd);
    internal string GetFlowText(FlowNode flowNode);
    internal static bool MostlyRTL(string s);
    internal static bool IsSameLine(double verticalDistance, double fontSize1, double fontSize2);
    internal static bool IsNonContiguous(CultureInfo ciPrev, CultureInfo ciCurrent, bool isSidewaysPrev, bool isSidewaysCurrent, string strPrev, string strCurrent, GlyphComparison comparison);
    internal FixedFlowMap get_FixedFlowMap();
    private void _Init();
    private FixedNode _NewFixedNode(int pageIndex, int nestingLevel, int level1Index, Int32[] pathPrefix, int childIndex);
    private bool _IsImage(object o);
    private bool _IsNonContiguous(FixedSOMTextRun prevRun, FixedSOMTextRun currentRun, GlyphComparison comparison);
    private GlyphComparison _CompareGlyphs(Glyphs glyph1, Glyphs glyph2);
    private void _CreateFixedMappingAndElementForPage(FixedPageStructure pageStructure, FixedPage page, bool constructSOM);
    private void _GetFixedNodes(FixedPageStructure pageStructure, IEnumerable oneLevel, int nestingLevel, int level1Index, Int32[] pathPrefix, bool constructLines, List`1<FixedNode> fixedNodes, Matrix transform);
    private void _CreateFlowNodes(FixedSOMPage somPage, FlowModelBuilder flowBuilder);
    private void _CreateFlowNodes(FixedSOMContainer node, FlowModelBuilder flowBuilder);
    private bool _IsStartVisual(int visualIndex);
    private bool _IsEndVisual(int visualIndex);
    private bool _IsBoundaryPage(int pageIndex);
    private int _NewScopeId();
    private static bool _IsRTL(char c);
}
internal class System.Windows.Documents.FixedTextContainer : object {
    private FixedDocument _fixedPanel;
    private FixedTextBuilder _fixedTextBuilder;
    private DependencyObject _parent;
    private FixedElement _containerElement;
    private FixedTextPointer _start;
    private FixedTextPointer _end;
    private Highlights _highlights;
    private ITextSelection _textSelection;
    private ITextView _textview;
    private bool System.Windows.Documents.ITextContainer.IsReadOnly { get; }
    private ITextPointer System.Windows.Documents.ITextContainer.Start { get; }
    private ITextPointer System.Windows.Documents.ITextContainer.End { get; }
    private UInt32 System.Windows.Documents.ITextContainer.Generation { get; }
    private Highlights System.Windows.Documents.ITextContainer.Highlights { get; }
    private DependencyObject System.Windows.Documents.ITextContainer.Parent { get; }
    private ITextSelection System.Windows.Documents.ITextContainer.TextSelection { get; private set; }
    private UndoManager System.Windows.Documents.ITextContainer.UndoManager { get; }
    private ITextView System.Windows.Documents.ITextContainer.TextView { get; private set; }
    private int System.Windows.Documents.ITextContainer.SymbolCount { get; }
    private int System.Windows.Documents.ITextContainer.IMECharCount { get; }
    internal FixedDocument FixedDocument { get; }
    internal FixedTextBuilder FixedTextBuilder { get; }
    internal FixedElement ContainerElement { get; }
    internal Highlights Highlights { get; }
    internal ITextSelection TextSelection { get; }
    internal FixedTextContainer(DependencyObject parent);
    private sealed virtual override void System.Windows.Documents.ITextContainer.BeginChange();
    private sealed virtual override void System.Windows.Documents.ITextContainer.BeginChangeNoUndo();
    private sealed virtual override void System.Windows.Documents.ITextContainer.EndChange();
    private sealed virtual override void System.Windows.Documents.ITextContainer.EndChange(bool skipEvents);
    private sealed virtual override ITextPointer System.Windows.Documents.ITextContainer.CreatePointerAtOffset(int offset, LogicalDirection direction);
    private sealed virtual override ITextPointer System.Windows.Documents.ITextContainer.CreatePointerAtCharOffset(int charOffset, LogicalDirection direction);
    private sealed virtual override ITextPointer System.Windows.Documents.ITextContainer.CreateDynamicTextPointer(StaticTextPointer position, LogicalDirection direction);
    private sealed virtual override StaticTextPointer System.Windows.Documents.ITextContainer.CreateStaticPointerAtOffset(int offset);
    private sealed virtual override TextPointerContext System.Windows.Documents.ITextContainer.GetPointerContext(StaticTextPointer pointer, LogicalDirection direction);
    private sealed virtual override int System.Windows.Documents.ITextContainer.GetOffsetToPosition(StaticTextPointer position1, StaticTextPointer position2);
    private sealed virtual override int System.Windows.Documents.ITextContainer.GetTextInRun(StaticTextPointer position, LogicalDirection direction, Char[] textBuffer, int startIndex, int count);
    private sealed virtual override object System.Windows.Documents.ITextContainer.GetAdjacentElement(StaticTextPointer position, LogicalDirection direction);
    private sealed virtual override DependencyObject System.Windows.Documents.ITextContainer.GetParent(StaticTextPointer position);
    private sealed virtual override StaticTextPointer System.Windows.Documents.ITextContainer.CreatePointer(StaticTextPointer position, int offset);
    private sealed virtual override StaticTextPointer System.Windows.Documents.ITextContainer.GetNextContextPosition(StaticTextPointer position, LogicalDirection direction);
    private sealed virtual override int System.Windows.Documents.ITextContainer.CompareTo(StaticTextPointer position1, StaticTextPointer position2);
    private sealed virtual override int System.Windows.Documents.ITextContainer.CompareTo(StaticTextPointer position1, ITextPointer position2);
    private sealed virtual override object System.Windows.Documents.ITextContainer.GetValue(StaticTextPointer position, DependencyProperty formattingProperty);
    private sealed virtual override bool System.Windows.Documents.ITextContainer.get_IsReadOnly();
    private sealed virtual override ITextPointer System.Windows.Documents.ITextContainer.get_Start();
    private sealed virtual override ITextPointer System.Windows.Documents.ITextContainer.get_End();
    private sealed virtual override UInt32 System.Windows.Documents.ITextContainer.get_Generation();
    private sealed virtual override Highlights System.Windows.Documents.ITextContainer.get_Highlights();
    private sealed virtual override DependencyObject System.Windows.Documents.ITextContainer.get_Parent();
    private sealed virtual override ITextSelection System.Windows.Documents.ITextContainer.get_TextSelection();
    private sealed virtual override void System.Windows.Documents.ITextContainer.set_TextSelection(ITextSelection value);
    private sealed virtual override UndoManager System.Windows.Documents.ITextContainer.get_UndoManager();
    private sealed virtual override ITextView System.Windows.Documents.ITextContainer.get_TextView();
    private sealed virtual override void System.Windows.Documents.ITextContainer.set_TextView(ITextView value);
    private sealed virtual override int System.Windows.Documents.ITextContainer.get_SymbolCount();
    private sealed virtual override int System.Windows.Documents.ITextContainer.get_IMECharCount();
    public sealed virtual void add_Changing(EventHandler value);
    public sealed virtual void remove_Changing(EventHandler value);
    public sealed virtual void add_Change(TextContainerChangeEventHandler value);
    public sealed virtual void remove_Change(TextContainerChangeEventHandler value);
    public sealed virtual void add_Changed(TextContainerChangedEventHandler value);
    public sealed virtual void remove_Changed(TextContainerChangedEventHandler value);
    internal FixedTextPointer VerifyPosition(ITextPointer position);
    internal int GetPageNumber(ITextPointer textPointer);
    internal void GetMultiHighlights(FixedTextPointer start, FixedTextPointer end, Dictionary`2<FixedPage, ArrayList> highlights, FixedHighlightType t, Brush foregroundBrush, Brush backgroundBrush);
    internal FixedDocument get_FixedDocument();
    internal FixedTextBuilder get_FixedTextBuilder();
    internal FixedElement get_ContainerElement();
    internal Highlights get_Highlights();
    internal ITextSelection get_TextSelection();
    private void _CreateEmptyContainer();
    internal void OnNewFlowElement(FixedElement parentElement, ElementType elementType, FlowPosition pStart, FlowPosition pEnd, object source, int pageIndex);
    private bool _GetFixedNodesForFlowRange(ITextPointer start, ITextPointer end, FixedSOMElement[]& elements, Int32& startIndex, Int32& endIndex);
}
internal class System.Windows.Documents.FixedTextPointer : ContentPosition {
    private LogicalDirection _gravity;
    private FlowPosition _flowPosition;
    private bool _isFrozen;
    private Type System.Windows.Documents.ITextPointer.ParentType { get; }
    private ITextContainer System.Windows.Documents.ITextPointer.TextContainer { get; }
    private bool System.Windows.Documents.ITextPointer.HasValidLayout { get; }
    private bool System.Windows.Documents.ITextPointer.IsAtCaretUnitBoundary { get; }
    private LogicalDirection System.Windows.Documents.ITextPointer.LogicalDirection { get; }
    private bool System.Windows.Documents.ITextPointer.IsAtInsertionPosition { get; }
    private bool System.Windows.Documents.ITextPointer.IsFrozen { get; }
    private int System.Windows.Documents.ITextPointer.Offset { get; }
    private int System.Windows.Documents.ITextPointer.CharOffset { get; }
    internal FlowPosition FlowPosition { get; }
    internal FixedTextContainer FixedTextContainer { get; }
    internal LogicalDirection LogicalDirection { get; internal set; }
    internal FixedTextPointer(bool mutable, LogicalDirection gravity, FlowPosition flow);
    internal int CompareTo(ITextPointer position);
    private sealed virtual override int System.Windows.Documents.ITextPointer.CompareTo(StaticTextPointer position);
    private sealed virtual override int System.Windows.Documents.ITextPointer.CompareTo(ITextPointer position);
    private sealed virtual override int System.Windows.Documents.ITextPointer.GetOffsetToPosition(ITextPointer position);
    private sealed virtual override TextPointerContext System.Windows.Documents.ITextPointer.GetPointerContext(LogicalDirection direction);
    private sealed virtual override int System.Windows.Documents.ITextPointer.GetTextRunLength(LogicalDirection direction);
    private sealed virtual override string System.Windows.Documents.ITextPointer.GetTextInRun(LogicalDirection direction);
    private sealed virtual override int System.Windows.Documents.ITextPointer.GetTextInRun(LogicalDirection direction, Char[] textBuffer, int startIndex, int count);
    private sealed virtual override object System.Windows.Documents.ITextPointer.GetAdjacentElement(LogicalDirection direction);
    private sealed virtual override Type System.Windows.Documents.ITextPointer.GetElementType(LogicalDirection direction);
    private sealed virtual override bool System.Windows.Documents.ITextPointer.HasEqualScope(ITextPointer position);
    private sealed virtual override object System.Windows.Documents.ITextPointer.GetValue(DependencyProperty property);
    private sealed virtual override object System.Windows.Documents.ITextPointer.ReadLocalValue(DependencyProperty property);
    private sealed virtual override LocalValueEnumerator System.Windows.Documents.ITextPointer.GetLocalValueEnumerator();
    private sealed virtual override ITextPointer System.Windows.Documents.ITextPointer.CreatePointer();
    private sealed virtual override StaticTextPointer System.Windows.Documents.ITextPointer.CreateStaticPointer();
    private sealed virtual override ITextPointer System.Windows.Documents.ITextPointer.CreatePointer(int distance);
    private sealed virtual override ITextPointer System.Windows.Documents.ITextPointer.CreatePointer(LogicalDirection gravity);
    private sealed virtual override ITextPointer System.Windows.Documents.ITextPointer.CreatePointer(int distance, LogicalDirection gravity);
    private sealed virtual override void System.Windows.Documents.ITextPointer.Freeze();
    private sealed virtual override ITextPointer System.Windows.Documents.ITextPointer.GetFrozenPointer(LogicalDirection logicalDirection);
    private sealed virtual override ITextPointer System.Windows.Documents.ITextPointer.GetNextContextPosition(LogicalDirection direction);
    private sealed virtual override ITextPointer System.Windows.Documents.ITextPointer.GetInsertionPosition(LogicalDirection direction);
    private sealed virtual override ITextPointer System.Windows.Documents.ITextPointer.GetFormatNormalizedPosition(LogicalDirection direction);
    private sealed virtual override ITextPointer System.Windows.Documents.ITextPointer.GetNextInsertionPosition(LogicalDirection direction);
    private sealed virtual override void System.Windows.Documents.ITextPointer.SetLogicalDirection(LogicalDirection direction);
    private sealed virtual override bool System.Windows.Documents.ITextPointer.MoveToNextContextPosition(LogicalDirection direction);
    private sealed virtual override int System.Windows.Documents.ITextPointer.MoveByOffset(int offset);
    private sealed virtual override void System.Windows.Documents.ITextPointer.MoveToPosition(ITextPointer position);
    private sealed virtual override void System.Windows.Documents.ITextPointer.MoveToElementEdge(ElementEdge edge);
    private sealed virtual override int System.Windows.Documents.ITextPointer.MoveToLineBoundary(int count);
    private sealed virtual override Rect System.Windows.Documents.ITextPointer.GetCharacterRect(LogicalDirection direction);
    private sealed virtual override bool System.Windows.Documents.ITextPointer.MoveToInsertionPosition(LogicalDirection direction);
    private sealed virtual override bool System.Windows.Documents.ITextPointer.MoveToNextInsertionPosition(LogicalDirection direction);
    private sealed virtual override void System.Windows.Documents.ITextPointer.InsertTextInRun(string textData);
    private sealed virtual override void System.Windows.Documents.ITextPointer.DeleteContentToPosition(ITextPointer limit);
    private sealed virtual override bool System.Windows.Documents.ITextPointer.ValidateLayout();
    private sealed virtual override Type System.Windows.Documents.ITextPointer.get_ParentType();
    private sealed virtual override ITextContainer System.Windows.Documents.ITextPointer.get_TextContainer();
    private sealed virtual override bool System.Windows.Documents.ITextPointer.get_HasValidLayout();
    private sealed virtual override bool System.Windows.Documents.ITextPointer.get_IsAtCaretUnitBoundary();
    private sealed virtual override LogicalDirection System.Windows.Documents.ITextPointer.get_LogicalDirection();
    private sealed virtual override bool System.Windows.Documents.ITextPointer.get_IsAtInsertionPosition();
    private sealed virtual override bool System.Windows.Documents.ITextPointer.get_IsFrozen();
    private sealed virtual override int System.Windows.Documents.ITextPointer.get_Offset();
    private sealed virtual override int System.Windows.Documents.ITextPointer.get_CharOffset();
    internal FlowPosition get_FlowPosition();
    internal FixedTextContainer get_FixedTextContainer();
    internal LogicalDirection get_LogicalDirection();
    internal void set_LogicalDirection(LogicalDirection value);
}
internal class System.Windows.Documents.FixedTextView : TextViewBase {
    private FixedDocumentPage _docPage;
    private FixedTextPointer _start;
    private FixedTextPointer _end;
    private ReadOnlyCollection`1<TextSegment> _textSegments;
    private static DependencyObjectType UIElementType;
    internal UIElement RenderScope { get; }
    internal ITextContainer TextContainer { get; }
    internal bool IsValid { get; }
    internal bool RendersOwnSelection { get; }
    internal ReadOnlyCollection`1<TextSegment> TextSegments { get; }
    internal FixedTextPointer Start { get; }
    internal FixedTextPointer End { get; }
    private FixedTextContainer Container { get; }
    private Visual VisualRoot { get; }
    private FixedPage FixedPage { get; }
    private int PageIndex { get; }
    private bool IsContainerStart { get; }
    private bool IsContainerEnd { get; }
    internal FixedTextView(FixedDocumentPage docPage);
    private static FixedTextView();
    internal virtual ITextPointer GetTextPositionFromPoint(Point point, bool snapToText);
    internal virtual Rect GetRawRectangleFromTextPosition(ITextPointer position, Transform& transform);
    internal virtual Geometry GetTightBoundingGeometryFromTextPositions(ITextPointer startPosition, ITextPointer endPosition);
    internal virtual ITextPointer GetPositionAtNextLine(ITextPointer position, double suggestedX, int count, Double& newSuggestedX, Int32& linesMoved);
    internal virtual bool IsAtCaretUnitBoundary(ITextPointer position);
    internal virtual ITextPointer GetNextCaretUnitPosition(ITextPointer position, LogicalDirection direction);
    internal virtual ITextPointer GetBackspaceCaretUnitPosition(ITextPointer position);
    internal virtual TextSegment GetLineRange(ITextPointer position);
    internal virtual bool Contains(ITextPointer position);
    internal virtual bool Validate();
    internal virtual UIElement get_RenderScope();
    internal virtual ITextContainer get_TextContainer();
    internal virtual bool get_IsValid();
    internal virtual bool get_RendersOwnSelection();
    internal virtual ReadOnlyCollection`1<TextSegment> get_TextSegments();
    internal FixedTextPointer get_Start();
    internal FixedTextPointer get_End();
    private bool _HitTest(Point pt, UIElement& e);
    private void _GlyphRunHitTest(Glyphs g, double xoffset, Int32& charIndex, LogicalDirection& edge);
    private ITextPointer _SnapToText(Point point);
    private bool _GetNextLineGlyphs(FixedPosition& fixedp, LogicalDirection& edge, double suggestedX, LogicalDirection scanDir);
    private static double _GetDistanceToCharacter(GlyphRun run, int charOffset);
    internal static Rect _GetGlyphRunDesignRect(Glyphs g, int charStart, int charEnd);
    private Rect _GetTransformedCaretRect(GeneralTransform transform, Point origin, double height);
    private bool _GetFixedPosition(FixedTextPointer ftp, FixedPosition& fixedp);
    private bool _GetFirstFixedPosition(FixedTextPointer ftp, FixedPosition& fixedP);
    private ITextPointer _CreateTextPointer(FixedPosition fixedPosition, LogicalDirection edge);
    private ITextPointer _CreateTextPointerFromGlyphs(Glyphs g, Point point);
    private void _SkipFormattingTags(ITextPointer textPointer);
    private FixedTextContainer get_Container();
    private Visual get_VisualRoot();
    private FixedPage get_FixedPage();
    private int get_PageIndex();
    private bool get_IsContainerStart();
    private bool get_IsContainerEnd();
}
public class System.Windows.Documents.Floater : AnchoredBlock {
    public static DependencyProperty HorizontalAlignmentProperty;
    public static DependencyProperty WidthProperty;
    public HorizontalAlignment HorizontalAlignment { get; public set; }
    [TypeConverterAttribute("System.Windows.LengthConverter")]
public double Width { get; public set; }
    private static Floater();
    public Floater(Block childBlock);
    public Floater(Block childBlock, TextPointer insertionPosition);
    public HorizontalAlignment get_HorizontalAlignment();
    public void set_HorizontalAlignment(HorizontalAlignment value);
    public double get_Width();
    public void set_Width(double value);
    private static bool IsValidWidth(object o);
}
[LocalizabilityAttribute("15")]
[ContentPropertyAttribute("Blocks")]
public class System.Windows.Documents.FlowDocument : FrameworkContentElement {
    private static Type _typeofThis;
    public static DependencyProperty FontFamilyProperty;
    public static DependencyProperty FontStyleProperty;
    public static DependencyProperty FontWeightProperty;
    public static DependencyProperty FontStretchProperty;
    public static DependencyProperty FontSizeProperty;
    public static DependencyProperty ForegroundProperty;
    public static DependencyProperty BackgroundProperty;
    public static DependencyProperty TextEffectsProperty;
    public static DependencyProperty TextAlignmentProperty;
    public static DependencyProperty FlowDirectionProperty;
    public static DependencyProperty LineHeightProperty;
    public static DependencyProperty LineStackingStrategyProperty;
    public static DependencyProperty ColumnWidthProperty;
    public static DependencyProperty ColumnGapProperty;
    public static DependencyProperty IsColumnWidthFlexibleProperty;
    public static DependencyProperty ColumnRuleWidthProperty;
    public static DependencyProperty ColumnRuleBrushProperty;
    public static DependencyProperty IsOptimalParagraphEnabledProperty;
    public static DependencyProperty PageWidthProperty;
    public static DependencyProperty MinPageWidthProperty;
    public static DependencyProperty MaxPageWidthProperty;
    public static DependencyProperty PageHeightProperty;
    public static DependencyProperty MinPageHeightProperty;
    public static DependencyProperty MaxPageHeightProperty;
    public static DependencyProperty PagePaddingProperty;
    public static DependencyProperty IsHyphenationEnabledProperty;
    [CompilerGeneratedAttribute]
private EventHandler PageSizeChanged;
    private StructuralCache _structuralCache;
    private TypographyProperties _typographyPropertiesGroup;
    private IFlowDocumentFormatter _formatter;
    private TextWrapping _textWrapping;
    private double _pixelsPerDip;
    [DesignerSerializationVisibilityAttribute("2")]
public BlockCollection Blocks { get; }
    internal TextRange TextRange { get; }
    public TextPointer ContentStart { get; }
    public TextPointer ContentEnd { get; }
    [LocalizabilityAttribute("14")]
public FontFamily FontFamily { get; public set; }
    public FontStyle FontStyle { get; public set; }
    public FontWeight FontWeight { get; public set; }
    public FontStretch FontStretch { get; public set; }
    [LocalizabilityAttribute("0")]
[TypeConverterAttribute("System.Windows.FontSizeConverter")]
public double FontSize { get; public set; }
    public Brush Foreground { get; public set; }
    public Brush Background { get; public set; }
    public TextEffectCollection TextEffects { get; public set; }
    public TextAlignment TextAlignment { get; public set; }
    public FlowDirection FlowDirection { get; public set; }
    [TypeConverterAttribute("System.Windows.LengthConverter")]
public double LineHeight { get; public set; }
    public LineStackingStrategy LineStackingStrategy { get; public set; }
    [TypeConverterAttribute("System.Windows.LengthConverter")]
[LocalizabilityAttribute("0")]
public double ColumnWidth { get; public set; }
    [LocalizabilityAttribute("0")]
[TypeConverterAttribute("System.Windows.LengthConverter")]
public double ColumnGap { get; public set; }
    public bool IsColumnWidthFlexible { get; public set; }
    [LocalizabilityAttribute("0")]
[TypeConverterAttribute("System.Windows.LengthConverter")]
public double ColumnRuleWidth { get; public set; }
    public Brush ColumnRuleBrush { get; public set; }
    public bool IsOptimalParagraphEnabled { get; public set; }
    [TypeConverterAttribute("System.Windows.LengthConverter")]
public double PageWidth { get; public set; }
    [TypeConverterAttribute("System.Windows.LengthConverter")]
public double MinPageWidth { get; public set; }
    [TypeConverterAttribute("System.Windows.LengthConverter")]
public double MaxPageWidth { get; public set; }
    [TypeConverterAttribute("System.Windows.LengthConverter")]
public double PageHeight { get; public set; }
    [TypeConverterAttribute("System.Windows.LengthConverter")]
public double MinPageHeight { get; public set; }
    [TypeConverterAttribute("System.Windows.LengthConverter")]
public double MaxPageHeight { get; public set; }
    public Thickness PagePadding { get; public set; }
    public Typography Typography { get; }
    public bool IsHyphenationEnabled { get; public set; }
    protected internal IEnumerator LogicalChildren { get; }
    protected bool IsEnabledCore { get; }
    internal FlowDocumentFormatter BottomlessFormatter { get; }
    internal StructuralCache StructuralCache { get; }
    internal TypographyProperties TypographyPropertiesGroup { get; }
    internal TextWrapping TextWrapping { get; internal set; }
    internal IFlowDocumentFormatter Formatter { get; }
    internal bool IsLayoutDataValid { get; }
    internal TextContainer TextContainer { get; }
    internal double PixelsPerDip { get; internal set; }
    private DocumentPaginator System.Windows.Documents.IDocumentPaginatorSource.DocumentPaginator { get; }
    private static FlowDocument();
    public FlowDocument(Block block);
    internal FlowDocument(TextContainer textContainer);
    public BlockCollection get_Blocks();
    internal TextRange get_TextRange();
    public TextPointer get_ContentStart();
    public TextPointer get_ContentEnd();
    public FontFamily get_FontFamily();
    public void set_FontFamily(FontFamily value);
    public FontStyle get_FontStyle();
    public void set_FontStyle(FontStyle value);
    public FontWeight get_FontWeight();
    public void set_FontWeight(FontWeight value);
    public FontStretch get_FontStretch();
    public void set_FontStretch(FontStretch value);
    public double get_FontSize();
    public void set_FontSize(double value);
    public Brush get_Foreground();
    public void set_Foreground(Brush value);
    public Brush get_Background();
    public void set_Background(Brush value);
    public TextEffectCollection get_TextEffects();
    public void set_TextEffects(TextEffectCollection value);
    public TextAlignment get_TextAlignment();
    public void set_TextAlignment(TextAlignment value);
    public FlowDirection get_FlowDirection();
    public void set_FlowDirection(FlowDirection value);
    public double get_LineHeight();
    public void set_LineHeight(double value);
    public LineStackingStrategy get_LineStackingStrategy();
    public void set_LineStackingStrategy(LineStackingStrategy value);
    public double get_ColumnWidth();
    public void set_ColumnWidth(double value);
    public double get_ColumnGap();
    public void set_ColumnGap(double value);
    public bool get_IsColumnWidthFlexible();
    public void set_IsColumnWidthFlexible(bool value);
    public double get_ColumnRuleWidth();
    public void set_ColumnRuleWidth(double value);
    public Brush get_ColumnRuleBrush();
    public void set_ColumnRuleBrush(Brush value);
    public bool get_IsOptimalParagraphEnabled();
    public void set_IsOptimalParagraphEnabled(bool value);
    public double get_PageWidth();
    public void set_PageWidth(double value);
    public double get_MinPageWidth();
    public void set_MinPageWidth(double value);
    public double get_MaxPageWidth();
    public void set_MaxPageWidth(double value);
    public double get_PageHeight();
    public void set_PageHeight(double value);
    public double get_MinPageHeight();
    public void set_MinPageHeight(double value);
    public double get_MaxPageHeight();
    public void set_MaxPageHeight(double value);
    public Thickness get_PagePadding();
    public void set_PagePadding(Thickness value);
    public Typography get_Typography();
    public bool get_IsHyphenationEnabled();
    public void set_IsHyphenationEnabled(bool value);
    public void SetDpi(DpiScale dpiInfo);
    protected sealed virtual void OnPropertyChanged(DependencyPropertyChangedEventArgs e);
    protected virtual AutomationPeer OnCreateAutomationPeer();
    protected internal virtual IEnumerator get_LogicalChildren();
    protected virtual bool get_IsEnabledCore();
    internal ContentPosition GetObjectPosition(object element);
    internal void OnChildDesiredSizeChanged(UIElement child);
    internal void InitializeForFirstFormatting();
    internal void Uninitialize();
    internal Thickness ComputePageMargin();
    internal virtual void OnNewParent(DependencyObject newParent);
    internal FlowDocumentFormatter get_BottomlessFormatter();
    internal StructuralCache get_StructuralCache();
    internal TypographyProperties get_TypographyPropertiesGroup();
    internal TextWrapping get_TextWrapping();
    internal void set_TextWrapping(TextWrapping value);
    internal IFlowDocumentFormatter get_Formatter();
    internal bool get_IsLayoutDataValid();
    internal TextContainer get_TextContainer();
    internal double get_PixelsPerDip();
    internal void set_PixelsPerDip(double value);
    [CompilerGeneratedAttribute]
internal void add_PageSizeChanged(EventHandler value);
    [CompilerGeneratedAttribute]
internal void remove_PageSizeChanged(EventHandler value);
    private static void OnTypographyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private object OnChildDesiredSizeChangedAsync(object arg);
    private void Initialize(TextContainer textContainer);
    private static void OnPageMetricsChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void OnMinPageWidthChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void OnMinPageHeightChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void OnMaxPageWidthChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void OnMaxPageHeightChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static object CoerceMaxPageWidth(DependencyObject d, object value);
    private static object CoerceMaxPageHeight(DependencyObject d, object value);
    private static object CoercePageWidth(DependencyObject d, object value);
    private static object CoercePageHeight(DependencyObject d, object value);
    private void OnHighlightChanged(object sender, HighlightChangedEventArgs args);
    private void OnTextContainerChanging(object sender, EventArgs args);
    private void OnTextContainerChange(object sender, TextContainerChangeEventArgs args);
    private static bool IsValidPageSize(object o);
    private static bool IsValidMinPageSize(object o);
    private static bool IsValidMaxPageSize(object o);
    private static bool IsValidPagePadding(object o);
    private static bool IsValidColumnRuleWidth(object o);
    private static bool IsValidColumnGap(object o);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object value);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string text);
    private sealed virtual override object System.IServiceProvider.GetService(Type serviceType);
    private sealed virtual override DocumentPaginator System.Windows.Documents.IDocumentPaginatorSource.get_DocumentPaginator();
}
internal class System.Windows.Documents.FlowNode : object {
    private int _scopeId;
    private FlowNodeType _type;
    private int _fp;
    private object _cookie;
    private FixedSOMElement[] _elements;
    internal int Fp { get; }
    internal int ScopeId { get; }
    internal FlowNodeType Type { get; }
    internal object Cookie { get; }
    internal FixedSOMElement[] FixedSOMElements { get; internal set; }
    internal FlowNode(int scopeId, FlowNodeType type, object cookie);
    public static bool IsNull(FlowNode flow);
    public virtual int GetHashCode();
    public virtual bool Equals(object o);
    public sealed virtual int CompareTo(object o);
    internal void SetFp(int fp);
    internal void IncreaseFp();
    internal void DecreaseFp();
    internal int get_Fp();
    internal int get_ScopeId();
    internal FlowNodeType get_Type();
    internal object get_Cookie();
    internal FixedSOMElement[] get_FixedSOMElements();
    internal void set_FixedSOMElements(FixedSOMElement[] value);
    internal void AttachElement(FixedElement fixedElement);
}
internal enum System.Windows.Documents.FlowNodeType : Enum {
    public byte value__;
    public static FlowNodeType Boundary;
    public static FlowNodeType Start;
    public static FlowNodeType Run;
    public static FlowNodeType End;
    public static FlowNodeType Object;
    public static FlowNodeType Virtual;
    public static FlowNodeType Noop;
}
internal class System.Windows.Documents.FlowPosition : object {
    private FixedTextContainer _container;
    private FlowNode _flowNode;
    private int _offset;
    internal FixedTextContainer TextContainer { get; }
    internal bool IsBoundary { get; }
    internal bool IsStart { get; }
    internal bool IsEnd { get; }
    internal bool IsSymbol { get; }
    internal bool IsRun { get; }
    internal bool IsObject { get; }
    internal FlowNode FlowNode { get; }
    private int _NodeLength { get; }
    private FixedTextBuilder _FixedTextBuilder { get; }
    private FixedFlowMap _FixedFlowMap { get; }
    internal FlowPosition(FixedTextContainer container, FlowNode node, int offset);
    public object Clone();
    public sealed virtual int CompareTo(object o);
    public virtual int GetHashCode();
    internal int GetDistance(FlowPosition flow);
    internal TextPointerContext GetPointerContext(LogicalDirection dir);
    internal int GetTextRunLength(LogicalDirection dir);
    internal int GetTextInRun(LogicalDirection dir, int maxLength, Char[] chars, int startIndex);
    internal object GetAdjacentElement(LogicalDirection dir);
    internal FixedElement GetElement(LogicalDirection dir);
    internal FixedElement GetScopingElement();
    internal bool Move(int distance);
    internal bool Move(LogicalDirection dir);
    internal void MoveTo(FlowPosition flow);
    internal void AttachElement(FixedElement e);
    internal void GetFlowNode(LogicalDirection direction, FlowNode& flowNode, Int32& offsetStart);
    internal void GetFlowNodes(FlowPosition pEnd, FlowNode[]& flowNodes, Int32& offsetStart, Int32& offsetEnd);
    internal FlowPosition GetClingPosition(LogicalDirection dir);
    internal bool IsVirtual(FlowNode flowNode);
    internal FixedTextContainer get_TextContainer();
    internal bool get_IsBoundary();
    internal bool get_IsStart();
    internal bool get_IsEnd();
    internal bool get_IsSymbol();
    internal bool get_IsRun();
    internal bool get_IsObject();
    internal FlowNode get_FlowNode();
    private int _vScan(LogicalDirection dir, int limit);
    private TextPointerContext _vGetSymbolType(LogicalDirection dir);
    private FlowNode _xGetPreviousFlowNode();
    private FlowNode _xGetNextFlowNode();
    private bool _IsSamePosition(FlowPosition flow);
    private int _OverlapAwareCompare(FlowPosition flow);
    private TextPointerContext _FlowNodeTypeToTextSymbol(FlowNodeType t);
    private int get__NodeLength();
    private FixedTextBuilder get__FixedTextBuilder();
    private FixedFlowMap get__FixedFlowMap();
}
internal enum System.Windows.Documents.FontSlot : Enum {
    public int value__;
    public static FontSlot LOCH;
    public static FontSlot DBCH;
    public static FontSlot HICH;
}
internal class System.Windows.Documents.FontTable : ArrayList {
    private Hashtable _fontMappings;
    internal FontTableEntry CurrentEntry { get; }
    internal Hashtable FontMappings { get; }
    internal FontTableEntry DefineEntry(int index);
    internal FontTableEntry FindEntryByIndex(int index);
    internal FontTableEntry FindEntryByName(string name);
    internal FontTableEntry EntryAt(int index);
    internal int DefineEntryByName(string name);
    internal void MapFonts();
    internal FontTableEntry get_CurrentEntry();
    internal Hashtable get_FontMappings();
}
internal class System.Windows.Documents.FontTableEntry : object {
    private string _name;
    private int _index;
    private int _codePage;
    private int _charSet;
    private bool _bNameSealed;
    private bool _bPending;
    internal int Index { get; internal set; }
    internal string Name { get; internal set; }
    internal bool IsNameSealed { get; internal set; }
    internal bool IsPending { get; internal set; }
    internal int CodePage { get; internal set; }
    unknown int CodePageFromCharSet {internal set; }
    internal int CharSet { get; internal set; }
    internal int get_Index();
    internal void set_Index(int value);
    internal string get_Name();
    internal void set_Name(string value);
    internal bool get_IsNameSealed();
    internal void set_IsNameSealed(bool value);
    internal bool get_IsPending();
    internal void set_IsPending(bool value);
    internal int get_CodePage();
    internal void set_CodePage(int value);
    internal void set_CodePageFromCharSet(int value);
    internal int get_CharSet();
    internal void set_CharSet(int value);
    internal static int CharSetToCodePage(int cs);
    internal void ComputePreferredCodePage();
    private static int CodePageToCharSet(int cp);
    private static bool IsSymbolFont(string typefaceName);
}
internal class System.Windows.Documents.FormatState : object {
    private RtfDestination _dest;
    private bool _fBold;
    private bool _fItalic;
    private bool _fSuper;
    private bool _fSub;
    private bool _fOutline;
    private bool _fEngrave;
    private bool _fShadow;
    private bool _fScaps;
    private long _fs;
    private long _font;
    private int _codePage;
    private long _superOffset;
    private long _cf;
    private long _cb;
    private DirState _dirChar;
    private ULState _ul;
    private StrikeState _strike;
    private long _expand;
    private long _lang;
    private long _langFE;
    private long _langCur;
    private FontSlot _fontSlot;
    private long _sa;
    private long _sb;
    private long _li;
    private long _ri;
    private long _fi;
    private HAlign _align;
    private long _ils;
    private long _ilvl;
    private long _pnlvl;
    private long _itap;
    private DirState _dirPara;
    private long _cfPara;
    private long _cbPara;
    private long _nParaShading;
    private MarkerStyle _marker;
    private bool _fContinue;
    private long _nStartIndex;
    private long _nStartIndexDefault;
    private long _sl;
    private bool _slMult;
    private ParaBorder _pb;
    private bool _fInTable;
    private bool _fHidden;
    private int _stateSkip;
    private RowFormat _rowFormat;
    private static FormatState _fsEmptyState;
    private RtfImageFormat _imageFormat;
    private string _imageSource;
    private double _imageWidth;
    private double _imageHeight;
    private double _imageBaselineOffset;
    private bool _isIncludeImageBaselineOffset;
    private double _imageScaleWidth;
    private double _imageScaleHeight;
    private bool _isImageDataBinary;
    private string _imageStretch;
    private string _imageStretchDirection;
    private static int MAX_LIST_DEPTH;
    private static int MAX_TABLE_DEPTH;
    internal static FormatState EmptyFormatState { get; }
    internal RtfDestination RtfDestination { get; internal set; }
    internal bool IsHidden { get; internal set; }
    internal bool IsContentDestination { get; }
    internal bool Bold { get; internal set; }
    internal bool Italic { get; internal set; }
    internal bool Engrave { get; internal set; }
    internal bool Shadow { get; internal set; }
    internal bool SCaps { get; internal set; }
    internal bool Outline { get; internal set; }
    internal bool Sub { get; internal set; }
    internal bool Super { get; internal set; }
    internal long SuperOffset { get; internal set; }
    internal long FontSize { get; internal set; }
    internal long Font { get; internal set; }
    internal int CodePage { get; internal set; }
    internal long CF { get; internal set; }
    internal long CB { get; internal set; }
    internal DirState DirChar { get; internal set; }
    internal ULState UL { get; internal set; }
    internal StrikeState Strike { get; internal set; }
    internal long Expand { get; internal set; }
    internal long Lang { get; internal set; }
    internal long LangFE { get; internal set; }
    internal long LangCur { get; internal set; }
    internal FontSlot FontSlot { get; internal set; }
    internal long SB { get; internal set; }
    internal long SA { get; internal set; }
    internal long FI { get; internal set; }
    internal long RI { get; internal set; }
    internal long LI { get; internal set; }
    internal HAlign HAlign { get; internal set; }
    internal long ILVL { get; internal set; }
    internal long PNLVL { get; internal set; }
    internal long ITAP { get; internal set; }
    internal long ILS { get; internal set; }
    internal DirState DirPara { get; internal set; }
    internal long CFPara { get; internal set; }
    internal long CBPara { get; internal set; }
    internal long ParaShading { get; internal set; }
    internal MarkerStyle Marker { get; internal set; }
    internal bool IsContinue { get; internal set; }
    internal long StartIndex { get; internal set; }
    internal long StartIndexDefault { get; internal set; }
    internal long SL { get; internal set; }
    internal bool SLMult { get; internal set; }
    internal bool IsInTable { get; internal set; }
    internal long TableLevel { get; }
    internal long ListLevel { get; }
    internal int UnicodeSkip { get; internal set; }
    internal RowFormat RowFormat { get; internal set; }
    internal bool HasRowFormat { get; }
    internal ParaBorder ParaBorder { get; }
    internal bool HasParaBorder { get; }
    internal RtfImageFormat ImageFormat { get; internal set; }
    internal string ImageSource { get; internal set; }
    internal double ImageWidth { get; internal set; }
    internal double ImageHeight { get; internal set; }
    internal double ImageBaselineOffset { get; internal set; }
    internal bool IncludeImageBaselineOffset { get; internal set; }
    internal double ImageScaleWidth { get; internal set; }
    internal double ImageScaleHeight { get; internal set; }
    internal bool IsImageDataBinary { get; internal set; }
    internal string ImageStretch { get; internal set; }
    internal string ImageStretchDirection { get; internal set; }
    internal FormatState(FormatState formatState);
    internal void SetCharDefaults();
    internal void SetParaDefaults();
    internal void SetRowDefaults();
    internal bool IsEqual(FormatState formatState);
    internal static FormatState get_EmptyFormatState();
    internal string GetBorderAttributeString(ConverterState converterState);
    internal RtfDestination get_RtfDestination();
    internal void set_RtfDestination(RtfDestination value);
    internal bool get_IsHidden();
    internal void set_IsHidden(bool value);
    internal bool get_IsContentDestination();
    internal bool get_Bold();
    internal void set_Bold(bool value);
    internal bool get_Italic();
    internal void set_Italic(bool value);
    internal bool get_Engrave();
    internal void set_Engrave(bool value);
    internal bool get_Shadow();
    internal void set_Shadow(bool value);
    internal bool get_SCaps();
    internal void set_SCaps(bool value);
    internal bool get_Outline();
    internal void set_Outline(bool value);
    internal bool get_Sub();
    internal void set_Sub(bool value);
    internal bool get_Super();
    internal void set_Super(bool value);
    internal long get_SuperOffset();
    internal void set_SuperOffset(long value);
    internal long get_FontSize();
    internal void set_FontSize(long value);
    internal long get_Font();
    internal void set_Font(long value);
    internal int get_CodePage();
    internal void set_CodePage(int value);
    internal long get_CF();
    internal void set_CF(long value);
    internal long get_CB();
    internal void set_CB(long value);
    internal DirState get_DirChar();
    internal void set_DirChar(DirState value);
    internal ULState get_UL();
    internal void set_UL(ULState value);
    internal StrikeState get_Strike();
    internal void set_Strike(StrikeState value);
    internal long get_Expand();
    internal void set_Expand(long value);
    internal long get_Lang();
    internal void set_Lang(long value);
    internal long get_LangFE();
    internal void set_LangFE(long value);
    internal long get_LangCur();
    internal void set_LangCur(long value);
    internal FontSlot get_FontSlot();
    internal void set_FontSlot(FontSlot value);
    internal long get_SB();
    internal void set_SB(long value);
    internal long get_SA();
    internal void set_SA(long value);
    internal long get_FI();
    internal void set_FI(long value);
    internal long get_RI();
    internal void set_RI(long value);
    internal long get_LI();
    internal void set_LI(long value);
    internal HAlign get_HAlign();
    internal void set_HAlign(HAlign value);
    internal long get_ILVL();
    internal void set_ILVL(long value);
    internal long get_PNLVL();
    internal void set_PNLVL(long value);
    internal long get_ITAP();
    internal void set_ITAP(long value);
    internal long get_ILS();
    internal void set_ILS(long value);
    internal DirState get_DirPara();
    internal void set_DirPara(DirState value);
    internal long get_CFPara();
    internal void set_CFPara(long value);
    internal long get_CBPara();
    internal void set_CBPara(long value);
    internal long get_ParaShading();
    internal void set_ParaShading(long value);
    internal MarkerStyle get_Marker();
    internal void set_Marker(MarkerStyle value);
    internal bool get_IsContinue();
    internal void set_IsContinue(bool value);
    internal long get_StartIndex();
    internal void set_StartIndex(long value);
    internal long get_StartIndexDefault();
    internal void set_StartIndexDefault(long value);
    internal long get_SL();
    internal void set_SL(long value);
    internal bool get_SLMult();
    internal void set_SLMult(bool value);
    internal bool get_IsInTable();
    internal void set_IsInTable(bool value);
    internal long get_TableLevel();
    internal long get_ListLevel();
    internal int get_UnicodeSkip();
    internal void set_UnicodeSkip(int value);
    internal RowFormat get_RowFormat();
    internal void set_RowFormat(RowFormat value);
    internal bool get_HasRowFormat();
    internal ParaBorder get_ParaBorder();
    internal bool get_HasParaBorder();
    internal RtfImageFormat get_ImageFormat();
    internal void set_ImageFormat(RtfImageFormat value);
    internal string get_ImageSource();
    internal void set_ImageSource(string value);
    internal double get_ImageWidth();
    internal void set_ImageWidth(double value);
    internal double get_ImageHeight();
    internal void set_ImageHeight(double value);
    internal double get_ImageBaselineOffset();
    internal void set_ImageBaselineOffset(double value);
    internal bool get_IncludeImageBaselineOffset();
    internal void set_IncludeImageBaselineOffset(bool value);
    internal double get_ImageScaleWidth();
    internal void set_ImageScaleWidth(double value);
    internal double get_ImageScaleHeight();
    internal void set_ImageScaleHeight(double value);
    internal bool get_IsImageDataBinary();
    internal void set_IsImageDataBinary(bool value);
    internal string get_ImageStretch();
    internal void set_ImageStretch(string value);
    internal string get_ImageStretchDirection();
    internal void set_ImageStretchDirection(string value);
}
public class System.Windows.Documents.FrameworkRichTextComposition : FrameworkTextComposition {
    public TextPointer ResultStart { get; }
    public TextPointer ResultEnd { get; }
    public TextPointer CompositionStart { get; }
    public TextPointer CompositionEnd { get; }
    internal FrameworkRichTextComposition(InputManager inputManager, IInputElement source, object owner);
    public TextPointer get_ResultStart();
    public TextPointer get_ResultEnd();
    public TextPointer get_CompositionStart();
    public TextPointer get_CompositionEnd();
}
public class System.Windows.Documents.FrameworkTextComposition : TextComposition {
    private ITextPointer _resultStart;
    private ITextPointer _resultEnd;
    private ITextPointer _compositionStart;
    private ITextPointer _compositionEnd;
    private int _offset;
    private int _length;
    private object _owner;
    private bool _pendingComplete;
    public int ResultOffset { get; }
    public int ResultLength { get; }
    public int CompositionOffset { get; }
    public int CompositionLength { get; }
    internal ITextPointer _ResultStart { get; }
    internal ITextPointer _ResultEnd { get; }
    internal ITextPointer _CompositionStart { get; }
    internal ITextPointer _CompositionEnd { get; }
    internal bool PendingComplete { get; }
    internal object Owner { get; }
    internal FrameworkTextComposition(InputManager inputManager, IInputElement source, object owner);
    public virtual void Complete();
    public int get_ResultOffset();
    public int get_ResultLength();
    public int get_CompositionOffset();
    public int get_CompositionLength();
    internal static void CompleteCurrentComposition(ITfDocumentMgr documentMgr);
    internal static ITfCompositionView GetCurrentCompositionView(ITfDocumentMgr documentMgr);
    internal void SetResultPositions(ITextPointer start, ITextPointer end, string text);
    internal void SetCompositionPositions(ITextPointer start, ITextPointer end, string text);
    internal ITextPointer get__ResultStart();
    internal ITextPointer get__ResultEnd();
    internal ITextPointer get__CompositionStart();
    internal ITextPointer get__CompositionEnd();
    internal bool get_PendingComplete();
    internal object get_Owner();
    private static ITfCompositionView GetComposition(ITfContext context);
}
internal class System.Windows.Documents.GeometryWalker : CapacityStreamGeometryContext {
    private FixedSOMPageConstructor _pageConstructor;
    private Matrix _transform;
    private bool _stroke;
    private bool _fill;
    private Point _startPoint;
    private Point _lastPoint;
    private bool _isClosed;
    private bool _isFilled;
    private double _xMin;
    private double _xMax;
    private double _yMin;
    private double _yMax;
    private bool _needClose;
    public GeometryWalker(FixedSOMPageConstructor pageConstructor);
    public void FindLines(StreamGeometry geometry, bool stroke, bool fill, Matrix trans);
    private void CheckCloseFigure();
    private void GatherBounds(Point p);
    public virtual void BeginFigure(Point startPoint, bool isFilled, bool isClosed);
    public virtual void LineTo(Point point, bool isStroked, bool isSmoothJoin);
    public virtual void QuadraticBezierTo(Point point1, Point point2, bool isStroked, bool isSmoothJoin);
    public virtual void BezierTo(Point point1, Point point2, Point point3, bool isStroked, bool isSmoothJoin);
    public virtual void PolyLineTo(IList`1<Point> points, bool isStroked, bool isSmoothJoin);
    public virtual void PolyQuadraticBezierTo(IList`1<Point> points, bool isStroked, bool isSmoothJoin);
    public virtual void PolyBezierTo(IList`1<Point> points, bool isStroked, bool isSmoothJoin);
    public virtual void ArcTo(Point point, Size size, double rotationAngle, bool isLargeArc, SweepDirection sweepDirection, bool isStroked, bool isSmoothJoin);
    internal virtual void SetClosedState(bool closed);
    internal virtual void SetFigureCount(int figureCount);
    internal virtual void SetSegmentCount(int segmentCount);
}
public class System.Windows.Documents.GetPageRootCompletedEventArgs : AsyncCompletedEventArgs {
    private FixedPage _page;
    public FixedPage Result { get; }
    internal GetPageRootCompletedEventArgs(FixedPage page, Exception error, bool cancelled, object userToken);
    public FixedPage get_Result();
}
public class System.Windows.Documents.GetPageRootCompletedEventHandler : MulticastDelegate {
    public GetPageRootCompletedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, GetPageRootCompletedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, GetPageRootCompletedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Windows.Documents.Glyphs : FrameworkElement {
    public static DependencyProperty FillProperty;
    public static DependencyProperty IndicesProperty;
    public static DependencyProperty UnicodeStringProperty;
    public static DependencyProperty CaretStopsProperty;
    public static DependencyProperty FontRenderingEmSizeProperty;
    public static DependencyProperty OriginXProperty;
    public static DependencyProperty OriginYProperty;
    public static DependencyProperty FontUriProperty;
    public static DependencyProperty StyleSimulationsProperty;
    public static DependencyProperty IsSidewaysProperty;
    public static DependencyProperty BidiLevelProperty;
    public static DependencyProperty DeviceFontNameProperty;
    private LayoutDependentGlyphRunProperties _glyphRunProperties;
    private GlyphRun _measurementGlyphRun;
    private Point _glyphRunOrigin;
    private static double EmMultiplier;
    private Uri System.Windows.Markup.IUriContext.BaseUri { get; private set; }
    public Brush Fill { get; public set; }
    public string Indices { get; public set; }
    public string UnicodeString { get; public set; }
    public string CaretStops { get; public set; }
    [TypeConverterAttribute("System.Windows.FontSizeConverter, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")]
public double FontRenderingEmSize { get; public set; }
    [TypeConverterAttribute("System.Windows.LengthConverter, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")]
public double OriginX { get; public set; }
    [TypeConverterAttribute("System.Windows.LengthConverter, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")]
public double OriginY { get; public set; }
    public Uri FontUri { get; public set; }
    public StyleSimulations StyleSimulations { get; public set; }
    public bool IsSideways { get; public set; }
    public int BidiLevel { get; public set; }
    public string DeviceFontName { get; public set; }
    internal GlyphRun MeasurementGlyphRun { get; }
    private static Glyphs();
    public GlyphRun ToGlyphRun();
    private sealed virtual override Uri System.Windows.Markup.IUriContext.get_BaseUri();
    private sealed virtual override void System.Windows.Markup.IUriContext.set_BaseUri(Uri value);
    protected virtual Size ArrangeOverride(Size finalSize);
    protected virtual void OnRender(DrawingContext context);
    protected virtual Size MeasureOverride(Size constraint);
    private void ComputeMeasurementGlyphRunAndOrigin();
    private void ParseCaretStops(LayoutDependentGlyphRunProperties glyphRunProperties);
    private void ParseGlyphRunProperties();
    private static bool IsEmpty(string s);
    private bool ReadGlyphIndex(string valueSpec, Boolean& inCluster, Int32& glyphClusterSize, Int32& characterClusterSize, UInt16& glyphIndex);
    private static double GetAdvanceWidth(GlyphTypeface glyphTypeface, ushort glyphIndex, bool sideways);
    private ushort GetGlyphFromCharacter(GlyphTypeface glyphTypeface, char character);
    private static void SetClusterMapEntry(UInt16[] clusterMap, int index, ushort value);
    private int ParseGlyphsProperty(GlyphTypeface fontFace, string unicodeString, bool sideways, List`1& parsedGlyphs, UInt16[]& clusterMap);
    private static void FillChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void GlyphRunPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void OriginPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public Brush get_Fill();
    public void set_Fill(Brush value);
    public string get_Indices();
    public void set_Indices(string value);
    public string get_UnicodeString();
    public void set_UnicodeString(string value);
    public string get_CaretStops();
    public void set_CaretStops(string value);
    public double get_FontRenderingEmSize();
    public void set_FontRenderingEmSize(double value);
    public double get_OriginX();
    public void set_OriginX(double value);
    public double get_OriginY();
    public void set_OriginY(double value);
    public Uri get_FontUri();
    public void set_FontUri(Uri value);
    public StyleSimulations get_StyleSimulations();
    public void set_StyleSimulations(StyleSimulations value);
    public bool get_IsSideways();
    public void set_IsSideways(bool value);
    public int get_BidiLevel();
    public void set_BidiLevel(int value);
    public string get_DeviceFontName();
    public void set_DeviceFontName(string value);
    internal GlyphRun get_MeasurementGlyphRun();
}
internal enum System.Windows.Documents.HAlign : Enum {
    public int value__;
    public static HAlign AlignLeft;
    public static HAlign AlignRight;
    public static HAlign AlignCenter;
    public static HAlign AlignJustify;
    public static HAlign AlignDefault;
}
internal abstract class System.Windows.Documents.HighlightChangedEventArgs : object {
    internal IList Ranges { get; }
    internal Type OwnerType { get; }
    internal abstract virtual IList get_Ranges();
    internal abstract virtual Type get_OwnerType();
}
internal class System.Windows.Documents.HighlightChangedEventHandler : MulticastDelegate {
    public HighlightChangedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, HighlightChangedEventArgs args);
    public virtual IAsyncResult BeginInvoke(object sender, HighlightChangedEventArgs args, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal abstract class System.Windows.Documents.HighlightLayer : object {
    internal Type OwnerType { get; }
    internal abstract virtual object GetHighlightValue(StaticTextPointer textPosition, LogicalDirection direction);
    internal abstract virtual bool IsContentHighlighted(StaticTextPointer textPosition, LogicalDirection direction);
    internal abstract virtual StaticTextPointer GetNextChangePosition(StaticTextPointer textPosition, LogicalDirection direction);
    internal abstract virtual Type get_OwnerType();
    [CompilerGeneratedAttribute]
internal abstract virtual void add_Changed(HighlightChangedEventHandler value);
    [CompilerGeneratedAttribute]
internal abstract virtual void remove_Changed(HighlightChangedEventHandler value);
}
internal class System.Windows.Documents.Highlights : object {
    [CompilerGeneratedAttribute]
private HighlightChangedEventHandler Changed;
    private ITextContainer _textContainer;
    private ArrayList _layers;
    protected ITextContainer TextContainer { get; }
    private int LayerCount { get; }
    internal Highlights(ITextContainer textContainer);
    internal virtual object GetHighlightValue(StaticTextPointer textPosition, LogicalDirection direction, Type highlightLayerOwnerType);
    internal virtual bool IsContentHighlighted(StaticTextPointer textPosition, LogicalDirection direction);
    internal virtual StaticTextPointer GetNextHighlightChangePosition(StaticTextPointer textPosition, LogicalDirection direction);
    internal virtual StaticTextPointer GetNextPropertyChangePosition(StaticTextPointer textPosition, LogicalDirection direction);
    internal void AddLayer(HighlightLayer highlightLayer);
    internal void RemoveLayer(HighlightLayer highlightLayer);
    internal HighlightLayer GetLayer(Type highlightLayerType);
    protected ITextContainer get_TextContainer();
    [CompilerGeneratedAttribute]
internal void add_Changed(HighlightChangedEventHandler value);
    [CompilerGeneratedAttribute]
internal void remove_Changed(HighlightChangedEventHandler value);
    private HighlightLayer GetLayer(int index);
    private void OnLayerChanged(object sender, HighlightChangedEventArgs args);
    private void RaiseChangedEventForLayerContent(HighlightLayer highlightLayer);
    private int get_LayerCount();
}
internal class System.Windows.Documents.HighlightVisual : Adorner {
    private FixedDocument _panel;
    private RubberbandSelector _rubberbandSelector;
    private FixedPage _page;
    internal HighlightVisual(FixedDocument panel, FixedPage page);
    protected virtual GeometryHitTestResult HitTestCore(GeometryHitTestParameters hitTestParameters);
    protected virtual HitTestResult HitTestCore(PointHitTestParameters hitTestParameters);
    protected virtual void OnRender(DrawingContext dc);
    internal void InvalidateHighlights();
    internal void UpdateRubberbandSelection(RubberbandSelector selector);
    internal static HighlightVisual GetHighlightVisual(FixedPage page);
    private void _UpdateHighlightBackground(DrawingContext dc, ArrayList highlights);
    private void _UpdateHighlightForeground(DrawingContext dc, ArrayList highlights);
}
internal class System.Windows.Documents.HostedElements : object {
    private ReadOnlyCollection`1<TextSegment> _textSegments;
    private TextPointer _currentPosition;
    private int _currentTextSegment;
    private object System.Collections.IEnumerator.Current { get; }
    public IInputElement Current { get; }
    internal HostedElements(ReadOnlyCollection`1<TextSegment> textSegments);
    private sealed virtual override void System.IDisposable.Dispose();
    public sealed virtual bool MoveNext();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    private sealed virtual override void System.Collections.IEnumerator.Reset();
    public sealed virtual IInputElement get_Current();
}
[TextElementEditingBehaviorAttribute]
public class System.Windows.Documents.Hyperlink : Span {
    public static DependencyProperty CommandProperty;
    public static DependencyProperty CommandParameterProperty;
    public static DependencyProperty CommandTargetProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty NavigateUriProperty;
    public static DependencyProperty TargetNameProperty;
    public static RoutedEvent RequestNavigateEvent;
    public static RoutedEvent ClickEvent;
    internal static RoutedEvent RequestSetStatusBarEvent;
    [ThreadStaticAttribute]
private static SecurityCriticalDataForSet`1<Uri> s_cachedNavigateUri;
    [ThreadStaticAttribute]
private static SecurityCriticalDataForSet`1<Nullable`1<int>> s_criticalNavigateUriProtectee;
    private static SecurityCriticalDataForSet`1<Nullable`1<bool>> s_shouldPreventUriSpoofing;
    private bool _canExecute;
    private static DependencyProperty IsHyperlinkPressedProperty;
    private static DependencyObjectType _dType;
    [BindableAttribute("True")]
[CategoryAttribute("Action")]
[LocalizabilityAttribute("17")]
public ICommand Command { get; public set; }
    private bool CanExecute { get; private set; }
    private bool IsEditable { get; }
    protected bool IsEnabledCore { get; }
    [BindableAttribute("True")]
[CategoryAttribute("Action")]
[LocalizabilityAttribute("17")]
public object CommandParameter { get; public set; }
    [BindableAttribute("True")]
[CategoryAttribute("Action")]
public IInputElement CommandTarget { get; public set; }
    [BindableAttribute("True")]
[CustomCategoryAttribute("Navigation")]
[LocalizabilityAttribute("11")]
public Uri NavigateUri { get; public set; }
    [LocalizabilityAttribute("0")]
[CustomCategoryAttribute("Navigation")]
[BindableAttribute("True")]
public string TargetName { get; public set; }
    internal int EffectiveValuesInitialSize { get; }
    private Uri System.Windows.Markup.IUriContext.BaseUri { get; private set; }
    protected Uri BaseUri { get; protected set; }
    [DesignerSerializationVisibilityAttribute("0")]
internal string Text { get; }
    private static bool ShouldPreventUriSpoofing { get; }
    internal DependencyObjectType DTypeThemeStyleKey { get; }
    private static Hyperlink();
    public Hyperlink(Inline childInline);
    public Hyperlink(Inline childInline, TextPointer insertionPosition);
    public Hyperlink(TextPointer start, TextPointer end);
    public void DoClick();
    public sealed virtual ICommand get_Command();
    public void set_Command(ICommand value);
    private static void OnCommandChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private void OnCommandChanged(ICommand oldCommand, ICommand newCommand);
    private void UnhookCommand(ICommand command);
    private void HookCommand(ICommand command);
    private void OnCanExecuteChanged(object sender, EventArgs e);
    private void UpdateCanExecute();
    private bool get_CanExecute();
    private void set_CanExecute(bool value);
    private bool get_IsEditable();
    protected virtual bool get_IsEnabledCore();
    public sealed virtual object get_CommandParameter();
    public void set_CommandParameter(object value);
    public sealed virtual IInputElement get_CommandTarget();
    public void set_CommandTarget(IInputElement value);
    internal static object CoerceNavigateUri(DependencyObject d, object value);
    public Uri get_NavigateUri();
    public void set_NavigateUri(Uri value);
    public string get_TargetName();
    public void set_TargetName(string value);
    public void add_RequestNavigate(RequestNavigateEventHandler value);
    public void remove_RequestNavigate(RequestNavigateEventHandler value);
    public void add_Click(RoutedEventHandler value);
    public void remove_Click(RoutedEventHandler value);
    protected internal virtual void OnMouseLeftButtonDown(MouseButtonEventArgs e);
    protected internal virtual void OnMouseLeftButtonUp(MouseButtonEventArgs e);
    private static void CacheNavigateUri(DependencyObject d, Uri targetUri);
    private static void NavigateToUri(IInputElement sourceElement, Uri targetUri, string targetWindow);
    private static void UpdateStatusBar(object sender);
    private static DependencyProperty GetNavigateUriProperty(object element);
    private static void ClearStatusBarAndCachedUri(object sender);
    protected virtual void OnClick();
    protected internal virtual void OnKeyDown(KeyEventArgs e);
    internal virtual int get_EffectiveValuesInitialSize();
    protected virtual AutomationPeer OnCreateAutomationPeer();
    private sealed virtual override Uri System.Windows.Markup.IUriContext.get_BaseUri();
    private sealed virtual override void System.Windows.Markup.IUriContext.set_BaseUri(Uri value);
    protected virtual Uri get_BaseUri();
    protected virtual void set_BaseUri(Uri value);
    internal string get_Text();
    private static void OnQueryCursor(object sender, QueryCursorEventArgs e);
    private static bool get_ShouldPreventUriSpoofing();
    internal static void OnNavigateUriChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void SetUpNavigationEventHandlers(IInputElement element);
    private static void SetUpEventHandler(IInputElement element, RoutedEvent routedEvent, Delegate handler);
    private static void OnKeyDown(object sender, KeyEventArgs e);
    private static void OnMouseLeftButtonDown(object sender, MouseButtonEventArgs e);
    private static void OnMouseLeftButtonUp(object sender, MouseButtonEventArgs e);
    private static void OnMouseEnter(object sender, MouseEventArgs e);
    private static void OnMouseLeave(object sender, MouseEventArgs e);
    private static void DoUserInitiatedNavigation(object sender);
    private static void DoNonUserInitiatedNavigation(object sender);
    private static void DispatchNavigation(object sender);
    private static void DoNavigation(object sender);
    internal static void RaiseNavigate(IInputElement element, Uri targetUri, string targetWindow);
    internal virtual DependencyObjectType get_DTypeThemeStyleKey();
}
internal interface System.Windows.Documents.IFixedNavigate {
    public abstract virtual UIElement FindElementByID(string elementID, FixedPage& rootFixedPage);
    public abstract virtual void NavigateAsync(string elementID);
}
internal class System.Windows.Documents.ImmComposition : object {
    private HwndSource _source;
    private TextEditor _editor;
    private ITextPointer _startComposition;
    private ITextPointer _endComposition;
    private int _caretOffset;
    private CompositionAdorner _compositionAdorner;
    private static Hashtable _list;
    private static double _dashLength;
    private static int _maxSrounding;
    private RECONVERTSTRING _reconv;
    private bool _isReconvReady;
    private static WindowMessage s_MsImeMouseMessage;
    private TextParentUndoUnit _compositionUndoUnit;
    private bool _handlingImeMessage;
    private bool _updateCompWndPosAtNextLayoutUpdate;
    private bool _compositionModifiedByEventListener;
    private bool _handledByEditorListener;
    private bool _losingFocus;
    internal bool IsComposition { get; }
    private UIElement RenderScope { get; }
    private FrameworkElement UiScope { get; }
    private bool IsReadOnly { get; }
    private bool IsInKeyboardFocus { get; }
    private static ImmComposition();
    internal ImmComposition(HwndSource source);
    internal static ImmComposition GetImmComposition(FrameworkElement scope);
    internal void OnDetach(TextEditor editor);
    internal void OnGotFocus(TextEditor editor);
    internal void OnLostFocus();
    internal void OnLayoutUpdated();
    internal void CompleteComposition();
    internal void OnSelectionChange();
    internal void OnSelectionChanged();
    internal bool get_IsComposition();
    private void OnSourceChanged(object sender, SourceChangedEventArgs e);
    private void UpdateSource(HwndSource oldSource, HwndSource newSource);
    private IntPtr ImmCompositionFilterMessage(IntPtr hwnd, int msg, IntPtr wParam, IntPtr lParam, Boolean& handled);
    private void OnWmImeComposition(IntPtr hwnd, IntPtr lParam, Boolean& handled);
    private void OnWmImeChar(IntPtr wParam, Boolean& handled);
    private void OnWmImeNotify(IntPtr hwnd, IntPtr wParam);
    private void UpdateNearCaretCompositionWindow();
    private void OnHwndDisposed(object sender, EventArgs args);
    private void UpdateCompositionString(Char[] resultChars, Char[] compositionChars, int caretOffset, int deltaStart, Byte[] attributes);
    private string BuildCompositionString(Char[] resultChars, Char[] compositionChars, Int32& resultLength);
    private void RecordCaretOffset(int caretOffset, Byte[] attributes, int compositionLength);
    private bool RaiseTextInputStartEvent(FrameworkTextComposition composition, int resultLength, string compositionString);
    private bool RaiseTextInputUpdateEvent(FrameworkTextComposition composition, int resultLength, string compositionString);
    private bool RaiseTextInputEvent(FrameworkTextComposition composition, string compositionString);
    internal void UpdateCompositionText(FrameworkTextComposition composition);
    internal void UpdateCompositionText(FrameworkTextComposition composition, int resultLength, bool includeResultText, ITextPointer& start, ITextPointer& end);
    private void SetCompositionAdorner(Byte[] attributes);
    private void RegisterMouseListeners();
    private void UnregisterMouseListeners();
    private IntPtr OnWmImeRequest(IntPtr wParam, IntPtr lParam, Boolean& handled);
    private IntPtr OnWmImeRequest_ReconvertString(IntPtr lParam, Boolean& handled, bool fDocFeed);
    private static void StoreSurroundingText(IntPtr reconv, string surrounding);
    private static string GetSurroundingText(ITextRange range, Int32& offsetStart);
    private IntPtr OnWmImeRequest_ConfirmReconvertString(IntPtr lParam, Boolean& handled);
    private static ITextPointer MoveToNextCharPos(ITextPointer position, int offset);
    private bool IsReadingWindowIme();
    private void OnMouseButtonEvent(object sender, MouseButtonEventArgs e);
    private void OnMouseEvent(object sender, MouseEventArgs e);
    private bool InternalMouseEventHandler();
    private void OpenCompositionUndoUnit();
    private void CloseCompositionUndoUnit(UndoCloseAction undoCloseAction, ITextPointer compositionEnd);
    private int ConvertToInt32(double value);
    private void OnTextContainerChange(object sender, TextContainerChangeEventArgs args);
    private UIElement get_RenderScope();
    private FrameworkElement get_UiScope();
    private bool get_IsReadOnly();
    private bool get_IsInKeyboardFocus();
}
[TextElementEditingBehaviorAttribute]
public abstract class System.Windows.Documents.Inline : TextElement {
    public static DependencyProperty BaselineAlignmentProperty;
    public static DependencyProperty TextDecorationsProperty;
    public static DependencyProperty FlowDirectionProperty;
    public InlineCollection SiblingInlines { get; }
    public Inline NextInline { get; }
    public Inline PreviousInline { get; }
    public BaselineAlignment BaselineAlignment { get; public set; }
    public TextDecorationCollection TextDecorations { get; public set; }
    public FlowDirection FlowDirection { get; public set; }
    private static Inline();
    public InlineCollection get_SiblingInlines();
    public Inline get_NextInline();
    public Inline get_PreviousInline();
    public BaselineAlignment get_BaselineAlignment();
    public void set_BaselineAlignment(BaselineAlignment value);
    public TextDecorationCollection get_TextDecorations();
    public void set_TextDecorations(TextDecorationCollection value);
    public FlowDirection get_FlowDirection();
    public void set_FlowDirection(FlowDirection value);
    internal static Run CreateImplicitRun(DependencyObject parent);
    internal static InlineUIContainer CreateImplicitInlineUIContainer(DependencyObject parent);
    private static bool IsValidBaselineAlignment(object o);
}
[ContentWrapperAttribute("System.Windows.Documents.Run")]
[ContentWrapperAttribute("System.Windows.Documents.InlineUIContainer")]
[WhitespaceSignificantCollectionAttribute]
public class System.Windows.Documents.InlineCollection : TextElementCollection`1<Inline> {
    public Inline FirstInline { get; }
    public Inline LastInline { get; }
    internal InlineCollection(DependencyObject owner, bool isOwnerParent);
    internal virtual int OnAdd(object value);
    public void Add(string text);
    public void Add(UIElement uiElement);
    public Inline get_FirstInline();
    public Inline get_LastInline();
    internal virtual void ValidateChild(Inline child);
    private int AddText(string text, bool returnIndex);
    private int AddUIElement(UIElement uiElement, bool returnIndex);
}
[ContentPropertyAttribute("Child")]
[TextElementEditingBehaviorAttribute]
public class System.Windows.Documents.InlineUIContainer : Inline {
    private UIElementIsland _uiElementIsland;
    public UIElement Child { get; public set; }
    internal UIElementIsland UIElementIsland { get; }
    public InlineUIContainer(UIElement childUIElement);
    public InlineUIContainer(UIElement childUIElement, TextPointer insertionPosition);
    public UIElement get_Child();
    public void set_Child(UIElement value);
    internal UIElementIsland get_UIElementIsland();
    private void UpdateUIElementIsland();
}
internal class System.Windows.Documents.InputScopeAttribute : object {
    private InputScope _inputScope;
    internal InputScopeAttribute(InputScope inputscope);
    public sealed virtual void GetInputScopes(IntPtr& ppinputscopes, Int32& count);
    public sealed virtual int GetPhrase(IntPtr& ppbstrPhrases, Int32& count);
    public sealed virtual int GetRegularExpression(String& desc);
    public sealed virtual int GetSRGC(String& desc);
    public sealed virtual int GetXML(String& desc);
}
internal class System.Windows.Documents.Internal.ColumnResizeAdorner : Adorner {
    private double _x;
    private double _top;
    private double _height;
    private Pen _pen;
    private AdornerLayer _adornerLayer;
    internal ColumnResizeAdorner(UIElement scope);
    public virtual GeneralTransform GetDesiredTransform(GeneralTransform transform);
    protected virtual void OnRender(DrawingContext drawingContext);
    internal void Update(double newX);
    internal void Initialize(UIElement renderScope, double xPos, double yPos, double height);
    internal void Uninitialize();
}
public class System.Windows.Documents.Italic : Span {
    private static Italic();
    public Italic(Inline childInline);
    public Italic(Inline childInline, TextPointer insertionPosition);
    public Italic(TextPointer start, TextPointer end);
}
internal interface System.Windows.Documents.ITextContainer {
    public bool IsReadOnly { get; }
    public ITextPointer Start { get; }
    public ITextPointer End { get; }
    public DependencyObject Parent { get; }
    public Highlights Highlights { get; }
    public ITextSelection TextSelection { get; public set; }
    public UndoManager UndoManager { get; }
    public ITextView TextView { get; public set; }
    public int SymbolCount { get; }
    public int IMECharCount { get; }
    public UInt32 Generation { get; }
    public abstract virtual void BeginChange();
    public abstract virtual void BeginChangeNoUndo();
    public abstract virtual void EndChange();
    public abstract virtual void EndChange(bool skipEvents);
    public abstract virtual ITextPointer CreatePointerAtOffset(int offset, LogicalDirection direction);
    public abstract virtual ITextPointer CreatePointerAtCharOffset(int charOffset, LogicalDirection direction);
    public abstract virtual ITextPointer CreateDynamicTextPointer(StaticTextPointer position, LogicalDirection direction);
    public abstract virtual StaticTextPointer CreateStaticPointerAtOffset(int offset);
    public abstract virtual TextPointerContext GetPointerContext(StaticTextPointer pointer, LogicalDirection direction);
    public abstract virtual int GetOffsetToPosition(StaticTextPointer position1, StaticTextPointer position2);
    public abstract virtual int GetTextInRun(StaticTextPointer position, LogicalDirection direction, Char[] textBuffer, int startIndex, int count);
    public abstract virtual object GetAdjacentElement(StaticTextPointer position, LogicalDirection direction);
    public abstract virtual DependencyObject GetParent(StaticTextPointer position);
    public abstract virtual StaticTextPointer CreatePointer(StaticTextPointer position, int offset);
    public abstract virtual StaticTextPointer GetNextContextPosition(StaticTextPointer position, LogicalDirection direction);
    public abstract virtual int CompareTo(StaticTextPointer position1, StaticTextPointer position2);
    public abstract virtual int CompareTo(StaticTextPointer position1, ITextPointer position2);
    public abstract virtual object GetValue(StaticTextPointer position, DependencyProperty formattingProperty);
    public abstract virtual bool get_IsReadOnly();
    public abstract virtual ITextPointer get_Start();
    public abstract virtual ITextPointer get_End();
    public abstract virtual DependencyObject get_Parent();
    public abstract virtual Highlights get_Highlights();
    public abstract virtual ITextSelection get_TextSelection();
    public abstract virtual void set_TextSelection(ITextSelection value);
    public abstract virtual UndoManager get_UndoManager();
    public abstract virtual ITextView get_TextView();
    public abstract virtual void set_TextView(ITextView value);
    public abstract virtual int get_SymbolCount();
    public abstract virtual int get_IMECharCount();
    public abstract virtual UInt32 get_Generation();
    [CompilerGeneratedAttribute]
public abstract virtual void add_Changing(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Changing(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_Change(TextContainerChangeEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Change(TextContainerChangeEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_Changed(TextContainerChangedEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Changed(TextContainerChangedEventHandler value);
}
internal interface System.Windows.Documents.ITextPointer {
    public ITextContainer TextContainer { get; }
    public bool HasValidLayout { get; }
    public bool IsAtCaretUnitBoundary { get; }
    public LogicalDirection LogicalDirection { get; }
    public Type ParentType { get; }
    public bool IsAtInsertionPosition { get; }
    public bool IsFrozen { get; }
    public int Offset { get; }
    public int CharOffset { get; }
    public abstract virtual ITextPointer CreatePointer();
    public abstract virtual StaticTextPointer CreateStaticPointer();
    public abstract virtual ITextPointer CreatePointer(int offset);
    public abstract virtual ITextPointer CreatePointer(LogicalDirection gravity);
    public abstract virtual ITextPointer CreatePointer(int offset, LogicalDirection gravity);
    public abstract virtual void SetLogicalDirection(LogicalDirection direction);
    public abstract virtual int CompareTo(ITextPointer position);
    public abstract virtual int CompareTo(StaticTextPointer position);
    public abstract virtual bool HasEqualScope(ITextPointer position);
    public abstract virtual TextPointerContext GetPointerContext(LogicalDirection direction);
    public abstract virtual int GetOffsetToPosition(ITextPointer position);
    public abstract virtual int GetTextRunLength(LogicalDirection direction);
    public abstract virtual string GetTextInRun(LogicalDirection direction);
    public abstract virtual int GetTextInRun(LogicalDirection direction, Char[] textBuffer, int startIndex, int count);
    public abstract virtual object GetAdjacentElement(LogicalDirection direction);
    public abstract virtual void MoveToPosition(ITextPointer position);
    public abstract virtual int MoveByOffset(int offset);
    public abstract virtual bool MoveToNextContextPosition(LogicalDirection direction);
    public abstract virtual ITextPointer GetNextContextPosition(LogicalDirection direction);
    public abstract virtual bool MoveToInsertionPosition(LogicalDirection direction);
    public abstract virtual ITextPointer GetInsertionPosition(LogicalDirection direction);
    public abstract virtual ITextPointer GetFormatNormalizedPosition(LogicalDirection direction);
    public abstract virtual bool MoveToNextInsertionPosition(LogicalDirection direction);
    public abstract virtual ITextPointer GetNextInsertionPosition(LogicalDirection direction);
    public abstract virtual void MoveToElementEdge(ElementEdge edge);
    public abstract virtual int MoveToLineBoundary(int count);
    public abstract virtual Rect GetCharacterRect(LogicalDirection direction);
    public abstract virtual void Freeze();
    public abstract virtual ITextPointer GetFrozenPointer(LogicalDirection logicalDirection);
    public abstract virtual void InsertTextInRun(string textData);
    public abstract virtual void DeleteContentToPosition(ITextPointer limit);
    public abstract virtual Type GetElementType(LogicalDirection direction);
    public abstract virtual object GetValue(DependencyProperty formattingProperty);
    public abstract virtual object ReadLocalValue(DependencyProperty formattingProperty);
    public abstract virtual LocalValueEnumerator GetLocalValueEnumerator();
    public abstract virtual bool ValidateLayout();
    public abstract virtual ITextContainer get_TextContainer();
    public abstract virtual bool get_HasValidLayout();
    public abstract virtual bool get_IsAtCaretUnitBoundary();
    public abstract virtual LogicalDirection get_LogicalDirection();
    public abstract virtual Type get_ParentType();
    public abstract virtual bool get_IsAtInsertionPosition();
    public abstract virtual bool get_IsFrozen();
    public abstract virtual int get_Offset();
    public abstract virtual int get_CharOffset();
}
internal interface System.Windows.Documents.ITextRange {
    public bool IgnoreTextUnitBoundaries { get; }
    public ITextPointer Start { get; }
    public ITextPointer End { get; }
    public bool IsEmpty { get; }
    public List`1<TextSegment> TextSegments { get; }
    public bool HasConcreteTextContainer { get; }
    public string Text { get; public set; }
    public string Xml { get; }
    public bool IsTableCellRange { get; }
    public int ChangeBlockLevel { get; }
    public UInt32 _ContentGeneration { get; public set; }
    public bool _IsTableCellRange { get; public set; }
    public List`1<TextSegment> _TextSegments { get; public set; }
    public int _ChangeBlockLevel { get; public set; }
    public ChangeBlockUndoRecord _ChangeBlockUndoRecord { get; public set; }
    public bool _IsChanged { get; public set; }
    public abstract virtual bool Contains(ITextPointer position);
    public abstract virtual void Select(ITextPointer position1, ITextPointer position2);
    public abstract virtual void SelectWord(ITextPointer position);
    public abstract virtual void SelectParagraph(ITextPointer position);
    public abstract virtual void ApplyTypingHeuristics(bool overType);
    public abstract virtual object GetPropertyValue(DependencyProperty formattingProperty);
    public abstract virtual UIElement GetUIElementSelected();
    public abstract virtual bool CanSave(string dataFormat);
    public abstract virtual void Save(Stream stream, string dataFormat);
    public abstract virtual void Save(Stream stream, string dataFormat, bool preserveTextElements);
    public abstract virtual void BeginChange();
    public abstract virtual void BeginChangeNoUndo();
    public abstract virtual void EndChange();
    public abstract virtual void EndChange(bool disableScroll, bool skipEvents);
    public abstract virtual IDisposable DeclareChangeBlock();
    public abstract virtual IDisposable DeclareChangeBlock(bool disableScroll);
    public abstract virtual void NotifyChanged(bool disableScroll, bool skipEvents);
    public abstract virtual bool get_IgnoreTextUnitBoundaries();
    public abstract virtual ITextPointer get_Start();
    public abstract virtual ITextPointer get_End();
    public abstract virtual bool get_IsEmpty();
    public abstract virtual List`1<TextSegment> get_TextSegments();
    public abstract virtual bool get_HasConcreteTextContainer();
    public abstract virtual string get_Text();
    public abstract virtual void set_Text(string value);
    public abstract virtual string get_Xml();
    public abstract virtual bool get_IsTableCellRange();
    public abstract virtual int get_ChangeBlockLevel();
    [CompilerGeneratedAttribute]
public abstract virtual void add_Changed(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Changed(EventHandler value);
    public abstract virtual void FireChanged();
    public abstract virtual UInt32 get__ContentGeneration();
    public abstract virtual void set__ContentGeneration(UInt32 value);
    public abstract virtual bool get__IsTableCellRange();
    public abstract virtual void set__IsTableCellRange(bool value);
    public abstract virtual List`1<TextSegment> get__TextSegments();
    public abstract virtual void set__TextSegments(List`1<TextSegment> value);
    public abstract virtual int get__ChangeBlockLevel();
    public abstract virtual void set__ChangeBlockLevel(int value);
    public abstract virtual ChangeBlockUndoRecord get__ChangeBlockUndoRecord();
    public abstract virtual void set__ChangeBlockUndoRecord(ChangeBlockUndoRecord value);
    public abstract virtual bool get__IsChanged();
    public abstract virtual void set__IsChanged(bool value);
}
internal interface System.Windows.Documents.ITextSelection {
    public TextEditor TextEditor { get; }
    public ITextView TextView { get; }
    public bool IsInterimSelection { get; }
    public ITextPointer AnchorPosition { get; }
    public ITextPointer MovingPosition { get; }
    public CaretElement CaretElement { get; }
    public bool CoversEntireContent { get; }
    public abstract virtual void SetCaretToPosition(ITextPointer caretPosition, LogicalDirection direction, bool allowStopAtLineEnd, bool allowStopNearSpace);
    public abstract virtual void ExtendToPosition(ITextPointer textPosition);
    public abstract virtual bool ExtendToNextInsertionPosition(LogicalDirection direction);
    public abstract virtual bool Contains(Point point);
    public abstract virtual void OnDetach();
    public abstract virtual void UpdateCaretAndHighlight();
    public abstract virtual void OnTextViewUpdated();
    public abstract virtual void DetachFromVisualTree();
    public abstract virtual void RefreshCaret();
    public abstract virtual void OnInterimSelectionChanged(bool interimSelection);
    public abstract virtual void SetSelectionByMouse(ITextPointer cursorPosition, Point cursorMousePoint);
    public abstract virtual void ExtendSelectionByMouse(ITextPointer cursorPosition, bool forceWordSelection, bool forceParagraphSelection);
    public abstract virtual bool ExtendToNextTableRow(LogicalDirection direction);
    public abstract virtual void OnCaretNavigation();
    public abstract virtual void ValidateLayout();
    public abstract virtual TextEditor get_TextEditor();
    public abstract virtual ITextView get_TextView();
    public abstract virtual bool get_IsInterimSelection();
    public abstract virtual ITextPointer get_AnchorPosition();
    public abstract virtual ITextPointer get_MovingPosition();
    public abstract virtual CaretElement get_CaretElement();
    public abstract virtual bool get_CoversEntireContent();
}
internal interface System.Windows.Documents.ITextView {
    public UIElement RenderScope { get; }
    public ITextContainer TextContainer { get; }
    public bool IsValid { get; }
    public bool RendersOwnSelection { get; }
    public ReadOnlyCollection`1<TextSegment> TextSegments { get; }
    public abstract virtual ITextPointer GetTextPositionFromPoint(Point point, bool snapToText);
    public abstract virtual Rect GetRectangleFromTextPosition(ITextPointer position);
    public abstract virtual Rect GetRawRectangleFromTextPosition(ITextPointer position, Transform& transform);
    public abstract virtual Geometry GetTightBoundingGeometryFromTextPositions(ITextPointer startPosition, ITextPointer endPosition);
    public abstract virtual ITextPointer GetPositionAtNextLine(ITextPointer position, double suggestedX, int count, Double& newSuggestedX, Int32& linesMoved);
    public abstract virtual ITextPointer GetPositionAtNextPage(ITextPointer position, Point suggestedOffset, int count, Point& newSuggestedOffset, Int32& pagesMoved);
    public abstract virtual bool IsAtCaretUnitBoundary(ITextPointer position);
    public abstract virtual ITextPointer GetNextCaretUnitPosition(ITextPointer position, LogicalDirection direction);
    public abstract virtual ITextPointer GetBackspaceCaretUnitPosition(ITextPointer position);
    public abstract virtual TextSegment GetLineRange(ITextPointer position);
    public abstract virtual ReadOnlyCollection`1<GlyphRun> GetGlyphRuns(ITextPointer start, ITextPointer end);
    public abstract virtual bool Contains(ITextPointer position);
    public abstract virtual void BringPositionIntoViewAsync(ITextPointer position, object userState);
    public abstract virtual void BringPointIntoViewAsync(Point point, object userState);
    public abstract virtual void BringLineIntoViewAsync(ITextPointer position, double suggestedX, int count, object userState);
    public abstract virtual void BringPageIntoViewAsync(ITextPointer position, Point suggestedOffset, int count, object userState);
    public abstract virtual void CancelAsync(object userState);
    public abstract virtual bool Validate();
    public abstract virtual bool Validate(Point point);
    public abstract virtual bool Validate(ITextPointer position);
    public abstract virtual void ThrottleBackgroundTasksForUserInput();
    public abstract virtual UIElement get_RenderScope();
    public abstract virtual ITextContainer get_TextContainer();
    public abstract virtual bool get_IsValid();
    public abstract virtual bool get_RendersOwnSelection();
    public abstract virtual ReadOnlyCollection`1<TextSegment> get_TextSegments();
    [CompilerGeneratedAttribute]
public abstract virtual void add_BringPositionIntoViewCompleted(BringPositionIntoViewCompletedEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_BringPositionIntoViewCompleted(BringPositionIntoViewCompletedEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_BringPointIntoViewCompleted(BringPointIntoViewCompletedEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_BringPointIntoViewCompleted(BringPointIntoViewCompletedEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_BringLineIntoViewCompleted(BringLineIntoViewCompletedEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_BringLineIntoViewCompleted(BringLineIntoViewCompletedEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_BringPageIntoViewCompleted(BringPageIntoViewCompletedEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_BringPageIntoViewCompleted(BringPageIntoViewCompletedEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_Updated(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Updated(EventHandler value);
}
internal interface System.Windows.Documents.IXamlAttributes {
    public abstract virtual XamlToRtfError GetLength(Int32& length);
    public abstract virtual XamlToRtfError GetUri(int index, String& uri);
    public abstract virtual XamlToRtfError GetLocalName(int index, String& localName);
    public abstract virtual XamlToRtfError GetQName(int index, String& qName);
    public abstract virtual XamlToRtfError GetName(int index, String& uri, String& localName, String& qName);
    public abstract virtual XamlToRtfError GetIndexFromName(string uri, string localName, Int32& index);
    public abstract virtual XamlToRtfError GetIndexFromQName(string qName, Int32& index);
    public abstract virtual XamlToRtfError GetType(int index, String& type);
    public abstract virtual XamlToRtfError GetTypeFromName(string uri, string localName, String& type);
    public abstract virtual XamlToRtfError GetTypeFromQName(string qName, String& type);
    public abstract virtual XamlToRtfError GetValue(int index, String& value);
    public abstract virtual XamlToRtfError GetValueFromName(string uri, string localName, String& value);
    public abstract virtual XamlToRtfError GetValueFromQName(string qName, String& value);
}
internal interface System.Windows.Documents.IXamlContentHandler {
    public abstract virtual XamlToRtfError StartDocument();
    public abstract virtual XamlToRtfError EndDocument();
    public abstract virtual XamlToRtfError StartPrefixMapping(string prefix, string uri);
    public abstract virtual XamlToRtfError StartElement(string nameSpaceUri, string localName, string qName, IXamlAttributes attributes);
    public abstract virtual XamlToRtfError EndElement(string nameSpaceUri, string localName, string qName);
    public abstract virtual XamlToRtfError Characters(string characters);
    public abstract virtual XamlToRtfError IgnorableWhitespace(string characters);
    public abstract virtual XamlToRtfError ProcessingInstruction(string target, string data);
    public abstract virtual XamlToRtfError SkippedEntity(string name);
}
internal interface System.Windows.Documents.IXamlErrorHandler {
    public abstract virtual void Error(string message, XamlToRtfError xamlToRtfError);
    public abstract virtual void FatalError(string message, XamlToRtfError xamlToRtfError);
    public abstract virtual void IgnorableWarning(string message, XamlToRtfError xamlToRtfError);
}
[TrimSurroundingWhitespaceAttribute]
public class System.Windows.Documents.LineBreak : Inline {
    public LineBreak(TextPointer insertionPosition);
}
public class System.Windows.Documents.LinkTarget : object {
    private string _name;
    public string Name { get; public set; }
    public string get_Name();
    public void set_Name(string value);
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Documents.LinkTargetCollection : CollectionBase {
    public LinkTarget Item { get; public set; }
    public LinkTarget get_Item(int index);
    public void set_Item(int index, LinkTarget value);
    public int Add(LinkTarget value);
    public void Remove(LinkTarget value);
    public bool Contains(LinkTarget value);
    public void CopyTo(LinkTarget[] array, int index);
    public int IndexOf(LinkTarget value);
    public void Insert(int index, LinkTarget value);
}
[ContentPropertyAttribute("ListItems")]
public class System.Windows.Documents.List : Block {
    public static DependencyProperty MarkerStyleProperty;
    public static DependencyProperty MarkerOffsetProperty;
    public static DependencyProperty StartIndexProperty;
    [DesignerSerializationVisibilityAttribute("2")]
public ListItemCollection ListItems { get; }
    public TextMarkerStyle MarkerStyle { get; public set; }
    [TypeConverterAttribute("System.Windows.LengthConverter")]
public double MarkerOffset { get; public set; }
    public int StartIndex { get; public set; }
    private static List();
    public List(ListItem listItem);
    public ListItemCollection get_ListItems();
    public TextMarkerStyle get_MarkerStyle();
    public void set_MarkerStyle(TextMarkerStyle value);
    public double get_MarkerOffset();
    public void set_MarkerOffset(double value);
    public int get_StartIndex();
    public void set_StartIndex(int value);
    internal int GetListItemIndex(ListItem item);
    internal void Apply(Block firstBlock, Block lastBlock);
    private static bool IsValidMarkerStyle(object o);
    private static bool IsValidStartIndex(object o);
    private static bool IsValidMarkerOffset(object o);
}
[ContentPropertyAttribute("Blocks")]
public class System.Windows.Documents.ListItem : TextElement {
    public static DependencyProperty MarginProperty;
    public static DependencyProperty PaddingProperty;
    public static DependencyProperty BorderThicknessProperty;
    public static DependencyProperty BorderBrushProperty;
    public static DependencyProperty TextAlignmentProperty;
    public static DependencyProperty FlowDirectionProperty;
    public static DependencyProperty LineHeightProperty;
    public static DependencyProperty LineStackingStrategyProperty;
    public List List { get; }
    [DesignerSerializationVisibilityAttribute("2")]
public BlockCollection Blocks { get; }
    public ListItemCollection SiblingListItems { get; }
    public ListItem NextListItem { get; }
    public ListItem PreviousListItem { get; }
    public Thickness Margin { get; public set; }
    public Thickness Padding { get; public set; }
    public Thickness BorderThickness { get; public set; }
    public Brush BorderBrush { get; public set; }
    public TextAlignment TextAlignment { get; public set; }
    public FlowDirection FlowDirection { get; public set; }
    [TypeConverterAttribute("System.Windows.LengthConverter")]
public double LineHeight { get; public set; }
    public LineStackingStrategy LineStackingStrategy { get; public set; }
    internal bool IsIMEStructuralElement { get; }
    public ListItem(Paragraph paragraph);
    private static ListItem();
    public List get_List();
    public BlockCollection get_Blocks();
    public ListItemCollection get_SiblingListItems();
    public ListItem get_NextListItem();
    public ListItem get_PreviousListItem();
    public Thickness get_Margin();
    public void set_Margin(Thickness value);
    public Thickness get_Padding();
    public void set_Padding(Thickness value);
    public Thickness get_BorderThickness();
    public void set_BorderThickness(Thickness value);
    public Brush get_BorderBrush();
    public void set_BorderBrush(Brush value);
    public TextAlignment get_TextAlignment();
    public void set_TextAlignment(TextAlignment value);
    public FlowDirection get_FlowDirection();
    public void set_FlowDirection(FlowDirection value);
    public double get_LineHeight();
    public void set_LineHeight(double value);
    public LineStackingStrategy get_LineStackingStrategy();
    public void set_LineStackingStrategy(LineStackingStrategy value);
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeBlocks(XamlDesignerSerializationManager manager);
    internal virtual bool get_IsIMEStructuralElement();
}
public class System.Windows.Documents.ListItemCollection : TextElementCollection`1<ListItem> {
    public ListItem FirstListItem { get; }
    public ListItem LastListItem { get; }
    internal ListItemCollection(DependencyObject owner, bool isOwnerParent);
    public ListItem get_FirstListItem();
    public ListItem get_LastListItem();
}
internal class System.Windows.Documents.ListLevel : object {
    private long _nStartIndex;
    private MarkerStyle _numberType;
    private FormatState _formatState;
    internal long StartIndex { get; internal set; }
    internal MarkerStyle Marker { get; internal set; }
    unknown FormatState FormatState {internal set; }
    internal long get_StartIndex();
    internal void set_StartIndex(long value);
    internal MarkerStyle get_Marker();
    internal void set_Marker(MarkerStyle value);
    internal void set_FormatState(FormatState value);
}
internal class System.Windows.Documents.ListLevelTable : ArrayList {
    internal ListLevel CurrentEntry { get; }
    internal ListLevel EntryAt(int index);
    internal ListLevel AddEntry();
    internal ListLevel get_CurrentEntry();
}
internal class System.Windows.Documents.ListOverride : object {
    private long _id;
    private long _index;
    private long _nStartIndex;
    private ListLevelTable _levels;
    internal long ID { get; internal set; }
    internal long Index { get; internal set; }
    internal ListLevelTable Levels { get; internal set; }
    internal long StartIndex { get; internal set; }
    internal long get_ID();
    internal void set_ID(long value);
    internal long get_Index();
    internal void set_Index(long value);
    internal ListLevelTable get_Levels();
    internal void set_Levels(ListLevelTable value);
    internal long get_StartIndex();
    internal void set_StartIndex(long value);
}
internal class System.Windows.Documents.ListOverrideTable : ArrayList {
    internal ListOverride CurrentEntry { get; }
    internal ListOverride EntryAt(int index);
    internal ListOverride FindEntry(int index);
    internal ListOverride AddEntry();
    internal ListOverride get_CurrentEntry();
}
internal class System.Windows.Documents.ListTable : ArrayList {
    internal ListTableEntry CurrentEntry { get; }
    internal ListTableEntry EntryAt(int index);
    internal ListTableEntry FindEntry(long id);
    internal ListTableEntry AddEntry();
    internal ListTableEntry get_CurrentEntry();
}
internal class System.Windows.Documents.ListTableEntry : object {
    private long _id;
    private long _templateID;
    private bool _simple;
    private ListLevelTable _levels;
    internal long ID { get; internal set; }
    unknown long TemplateID {internal set; }
    unknown bool Simple {internal set; }
    internal ListLevelTable Levels { get; }
    internal long get_ID();
    internal void set_ID(long value);
    internal void set_TemplateID(long value);
    internal void set_Simple(bool value);
    internal ListLevelTable get_Levels();
}
public enum System.Windows.Documents.LogicalDirection : Enum {
    public int value__;
    public static LogicalDirection Backward;
    public static LogicalDirection Forward;
}
internal class System.Windows.Documents.MarkerList : ArrayList {
    internal MarkerListEntry EntryAt(int index);
    internal void AddEntry(MarkerStyle m, long nILS, long nStartIndexOverride, long nStartIndexDefault, long nLevel);
}
internal class System.Windows.Documents.MarkerListEntry : object {
    private MarkerStyle _marker;
    private long _nStartIndexOverride;
    private long _nStartIndexDefault;
    private long _nVirtualListLevel;
    private long _nILS;
    internal MarkerStyle Marker { get; internal set; }
    internal long StartIndexOverride { get; internal set; }
    internal long StartIndexDefault { get; internal set; }
    internal long VirtualListLevel { get; internal set; }
    internal long StartIndexToUse { get; }
    internal long ILS { get; internal set; }
    internal MarkerStyle get_Marker();
    internal void set_Marker(MarkerStyle value);
    internal long get_StartIndexOverride();
    internal void set_StartIndexOverride(long value);
    internal long get_StartIndexDefault();
    internal void set_StartIndexDefault(long value);
    internal long get_VirtualListLevel();
    internal void set_VirtualListLevel(long value);
    internal long get_StartIndexToUse();
    internal long get_ILS();
    internal void set_ILS(long value);
}
internal enum System.Windows.Documents.MarkerStyle : Enum {
    public int value__;
    public static MarkerStyle MarkerNone;
    public static MarkerStyle MarkerArabic;
    public static MarkerStyle MarkerUpperRoman;
    public static MarkerStyle MarkerLowerRoman;
    public static MarkerStyle MarkerUpperAlpha;
    public static MarkerStyle MarkerLowerAlpha;
    public static MarkerStyle MarkerOrdinal;
    public static MarkerStyle MarkerCardinal;
    public static MarkerStyle MarkerBullet;
    public static MarkerStyle MarkerHidden;
}
internal class System.Windows.Documents.MoveSizeWinEventHandler : WinEventHandler {
    private ArrayList _arTextStore;
    internal int TextStoreCount { get; }
    internal void RegisterTextStore(TextStore textstore);
    internal void UnregisterTextStore(TextStore textstore);
    internal virtual void WinEventProc(int eventId, IntPtr hwnd);
    internal int get_TextStoreCount();
}
internal class System.Windows.Documents.MsSpellCheckLib.ChangeNotifyWrapper`1 : object {
    [CompilerGeneratedAttribute]
private PropertyChangedEventHandler PropertyChanged;
    private T _value;
    private bool _shouldThrowInvalidCastException;
    public T Value { get; public set; }
    private object System.Windows.Documents.MsSpellCheckLib.IChangeNotifyWrapper.Value { get; private set; }
    internal ChangeNotifyWrapper`1(T value, bool shouldThrowInvalidCastException);
    public sealed virtual T get_Value();
    public sealed virtual void set_Value(T value);
    private sealed virtual override object System.Windows.Documents.MsSpellCheckLib.IChangeNotifyWrapper.get_Value();
    private sealed virtual override void System.Windows.Documents.MsSpellCheckLib.IChangeNotifyWrapper.set_Value(object value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
}
[ExtensionAttribute]
internal static class System.Windows.Documents.MsSpellCheckLib.Extensions : object {
    [ExtensionAttribute]
internal static List`1<string> ToList(IEnumString enumString, bool shouldSuppressCOMExceptions, bool shouldReleaseCOMObject);
    [ExtensionAttribute]
internal static List`1<SpellingError> ToList(IEnumSpellingError spellingErrors, SpellChecker spellChecker, string text, bool shouldSuppressCOMExceptions, bool shouldReleaseCOMObject);
    [ExtensionAttribute]
internal static bool IsClean(List`1<SpellingError> errors);
}
internal interface System.Windows.Documents.MsSpellCheckLib.IChangeNotifyWrapper {
    public object Value { get; public set; }
    public abstract virtual object get_Value();
    public abstract virtual void set_Value(object value);
}
internal interface System.Windows.Documents.MsSpellCheckLib.IChangeNotifyWrapper`1 {
    public T Value { get; public set; }
    public abstract virtual T get_Value();
    public abstract virtual void set_Value(T value);
}
internal class System.Windows.Documents.MsSpellCheckLib.RCW : object {
}
internal class System.Windows.Documents.MsSpellCheckLib.RetriesExhaustedException : Exception {
    internal RetriesExhaustedException(string message);
    internal RetriesExhaustedException(string message, Exception innerException);
}
internal static class System.Windows.Documents.MsSpellCheckLib.RetryHelper : object {
    internal static bool TryCallAction(Action action, RetryActionPreamble preamble, List`1<Type> ignoredExceptions, int retries, bool throwOnFailure);
    internal static bool TryCallAction(Action action, RetryPreamble preamble, List`1<Type> ignoredExceptions, int retries, bool throwOnFailure);
    internal static bool TryExecuteFunction(Func`1<TResult> func, TResult& result, RetryFunctionPreamble`1<TResult> preamble, List`1<Type> ignoredExceptions, int retries, bool throwOnFailure);
    internal static bool TryExecuteFunction(Func`1<TResult> func, TResult& result, RetryPreamble preamble, List`1<Type> ignoredExceptions, int retries, bool throwOnFailure);
    private static bool MatchException(Exception exception, List`1<Type> exceptions);
    private static void ValidateExceptionTypeList(List`1<Type> exceptions);
}
internal class System.Windows.Documents.MsSpellCheckLib.SpellChecker : object {
    private static Dictionary`2<bool, List`1<Type>> SuppressedExceptions;
    private ChangeNotifyWrapper`1<ISpellChecker> _speller;
    private string _languageTag;
    private SpellCheckerChangedEventHandler _spellCheckerChangedEventHandler;
    private Nullable`1<UInt32> _eventCookie;
    [CompilerGeneratedAttribute]
private EventHandler`1<SpellCheckerChangedEventArgs> _changed;
    private bool _disposed;
    public SpellChecker(string languageTag);
    private static SpellChecker();
    private bool Init(bool shouldSuppressCOMExceptions);
    public string GetLanguageTag();
    public List`1<string> SuggestImpl(string word);
    public List`1<string> SuggestImplWithRetries(string word, bool shouldSuppressCOMExceptions);
    public List`1<string> Suggest(string word, bool shouldSuppressCOMExceptions);
    private void AddImpl(string word);
    private void AddImplWithRetries(string word, bool shouldSuppressCOMExceptions);
    public void Add(string word, bool shouldSuppressCOMExceptions);
    private void IgnoreImpl(string word);
    public void IgnoreImplWithRetries(string word, bool shouldSuppressCOMExceptions);
    public void Ignore(string word, bool shouldSuppressCOMExceptions);
    private void AutoCorrectImpl(string from, string to);
    private void AutoCorrectImplWithRetries(string from, string to, bool suppressCOMExceptions);
    public void AutoCorrect(string from, string to, bool suppressCOMExceptions);
    private byte GetOptionValueImpl(string optionId);
    private byte GetOptionValueImplWithRetries(string optionId, bool suppressCOMExceptions);
    public byte GetOptionValue(string optionId, bool suppressCOMExceptions);
    private List`1<string> GetOptionIdsImpl();
    private List`1<string> GetOptionIdsImplWithRetries(bool suppressCOMExceptions);
    public List`1<string> GetOptionIds(bool suppressCOMExceptions);
    private string GetIdImpl();
    private string GetIdImplWithRetries(bool suppressCOMExceptions);
    private string GetId(bool suppressCOMExceptions);
    private string GetLocalizedNameImpl();
    private string GetLocalizedNameImplWithRetries(bool suppressCOMExceptions);
    public string GetLocalizedName(bool suppressCOMExceptions);
    private OptionDescription GetOptionDescriptionImpl(string optionId);
    private OptionDescription GetOptionDescriptionImplWithRetries(string optionId, bool suppressCOMExceptions);
    public OptionDescription GetOptionDescription(string optionId, bool suppressCOMExceptions);
    private List`1<SpellingError> CheckImpl(string text);
    private List`1<SpellingError> CheckImplWithRetries(string text, bool suppressCOMExceptions);
    public List`1<SpellingError> Check(string text, bool suppressCOMExceptions);
    public List`1<SpellingError> ComprehensiveCheckImpl(string text);
    public List`1<SpellingError> ComprehensiveCheckImplWithRetries(string text, bool shouldSuppressCOMExceptions);
    public List`1<SpellingError> ComprehensiveCheck(string text, bool shouldSuppressCOMExceptions);
    private Nullable`1<UInt32> add_SpellCheckerChangedImpl(ISpellCheckerChangedEventHandler handler);
    private Nullable`1<UInt32> addSpellCheckerChangedImplWithRetries(ISpellCheckerChangedEventHandler handler, bool suppressCOMExceptions);
    private Nullable`1<UInt32> add_SpellCheckerChanged(ISpellCheckerChangedEventHandler handler, bool suppressCOMExceptions);
    private void remove_SpellCheckerChangedImpl(UInt32 eventCookie);
    private void remove_SpellCheckerChangedImplWithRetries(UInt32 eventCookie, bool suppressCOMExceptions);
    private void remove_SpellCheckerChanged(UInt32 eventCookie, bool suppressCOMExceptions);
    private void SpellerInstanceChanged(object sender, PropertyChangedEventArgs args);
    internal virtual void OnChanged(SpellCheckerChangedEventArgs e);
    public void add_Changed(EventHandler`1<SpellCheckerChangedEventArgs> value);
    public void remove_Changed(EventHandler`1<SpellCheckerChangedEventArgs> value);
    protected virtual void Dispose(bool disposing);
    public sealed virtual void Dispose();
    protected virtual override void Finalize();
    [CompilerGeneratedAttribute]
private void add__changed(EventHandler`1<SpellCheckerChangedEventArgs> value);
    [CompilerGeneratedAttribute]
private void remove__changed(EventHandler`1<SpellCheckerChangedEventArgs> value);
}
internal class System.Windows.Documents.MsSpellCheckLib.SpellCheckerFactory : object {
    [CompilerGeneratedAttribute]
private ISpellCheckerFactory <ComFactory>k__BackingField;
    private static ReaderWriterLockSlimWrapper _factoryLock;
    [CompilerGeneratedAttribute]
private static SpellCheckerFactory <Singleton>k__BackingField;
    private static Dictionary`2<bool, List`1<Type>> SuppressedExceptions;
    internal ISpellCheckerFactory ComFactory { get; private set; }
    internal static SpellCheckerFactory Singleton { get; private set; }
    private static SpellCheckerFactory();
    [CompilerGeneratedAttribute]
internal ISpellCheckerFactory get_ComFactory();
    [CompilerGeneratedAttribute]
private void set_ComFactory(ISpellCheckerFactory value);
    [CompilerGeneratedAttribute]
internal static SpellCheckerFactory get_Singleton();
    [CompilerGeneratedAttribute]
private static void set_Singleton(SpellCheckerFactory value);
    public static SpellCheckerFactory Create(bool shouldSuppressCOMExceptions);
    private static bool Reinitalize();
    private static bool CreateLockFree(bool suppressCOMExceptions, bool suppressOtherExceptions);
    private List`1<string> SupportedLanguagesImpl();
    private List`1<string> SupportedLanguagesImplWithRetries(bool shouldSuppressCOMExceptions);
    private List`1<string> GetSupportedLanguagesPrivate(bool shouldSuppressCOMExceptions);
    internal static List`1<string> GetSupportedLanguages(bool shouldSuppressCOMExceptions);
    private bool IsSupportedImpl(string languageTag);
    private bool IsSupportedImplWithRetries(string languageTag, bool suppressCOMExceptions);
    private bool IsSupportedPrivate(string languageTag, bool suppressCOMExceptons);
    internal static bool IsSupported(string languageTag, bool suppressCOMExceptons);
    private ISpellChecker CreateSpellCheckerImpl(string languageTag);
    private ISpellChecker CreateSpellCheckerImplWithRetries(string languageTag, bool suppressCOMExceptions);
    private ISpellChecker CreateSpellCheckerPrivate(string languageTag, bool suppressCOMExceptions);
    internal static ISpellChecker CreateSpellChecker(string languageTag, bool suppressCOMExceptions);
    private void RegisterUserDicionaryImpl(string dictionaryPath, string languageTag);
    private void RegisterUserDictionaryImplWithRetries(string dictionaryPath, string languageTag, bool suppressCOMExceptions);
    private void RegisterUserDictionaryPrivate(string dictionaryPath, string languageTag, bool suppressCOMExceptions);
    internal static void RegisterUserDictionary(string dictionaryPath, string languageTag, bool suppressCOMExceptions);
    private void UnregisterUserDictionaryImpl(string dictionaryPath, string languageTag);
    private void UnregisterUserDictionaryImplWithRetries(string dictionaryPath, string languageTag, bool suppressCOMExceptions);
    private void UnregisterUserDictionaryPrivate(string dictionaryPath, string languageTag, bool suppressCOMExceptions);
    internal static void UnregisterUserDictionary(string dictionaryPath, string languageTag, bool suppressCOMExceptions);
}
internal class System.Windows.Documents.NaturalLanguageHyphenator : TextLexicalService {
    private IntPtr _hyphenatorResource;
    private bool _disposed;
    protected virtual override void Finalize();
    private sealed virtual override void System.IDisposable.Dispose();
    private void CleanupInternal(bool finalizing);
    public virtual bool IsCultureSupported(CultureInfo culture);
    public virtual TextLexicalBreaks AnalyzeText(Char[] characterSource, int length, CultureInfo textCulture);
}
internal class System.Windows.Documents.NLGSpellerInterop : SpellerInteropBase {
    private ITextChunk _textChunk;
    private bool _isDisposed;
    private SpellerMode _mode;
    private bool _multiWordMode;
    private static Guid CLSID_ITextContext;
    private static Guid IID_ITextContext;
    private static Guid CLSID_ITextChunk;
    private static Guid IID_ITextChunk;
    private static Guid CLSID_Lexicon;
    private static Guid IID_ILexicon;
    unknown SpellerMode Mode {internal set; }
    unknown bool MultiWordMode {internal set; }
    private static NLGSpellerInterop();
    protected virtual override void Finalize();
    public virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    internal virtual void SetLocale(CultureInfo culture);
    private void SetContextOption(string option, object value);
    internal virtual int EnumTextSegments(Char[] text, int count, EnumSentencesCallback sentenceCallback, EnumTextSegmentsCallback segmentCallback, object data);
    internal virtual void UnloadDictionary(object dictionary);
    internal virtual object LoadDictionary(string lexiconFilePath);
    internal virtual object LoadDictionary(Uri item, string trustedFolder);
    internal virtual void ReleaseAllLexicons();
    internal virtual void set_Mode(SpellerMode value);
    internal virtual void set_MultiWordMode(bool value);
    internal virtual void SetReformMode(CultureInfo culture, SpellingReform spellingReform);
    internal virtual bool CanSpellCheck(CultureInfo culture);
    private ILexicon AddLexicon(string lexiconFilePath);
    private static object CreateInstance(Guid clsid, Guid iid);
    private static ITextContext CreateTextContext();
    private static ITextChunk CreateTextChunk();
    private static ILexicon CreateLexicon();
    private static int EnumVariantNext(IEnumVariant variantEnumerator, VARIANT variant, Int32[] fetched);
}
internal class System.Windows.Documents.NonLogicalAdornerDecorator : AdornerDecorator {
    public UIElement Child { get; public set; }
    public virtual UIElement get_Child();
    public virtual void set_Child(UIElement value);
}
internal class System.Windows.Documents.NullTextContainer : object {
    private NullTextPointer _start;
    private NullTextPointer _end;
    private bool System.Windows.Documents.ITextContainer.IsReadOnly { get; }
    private ITextPointer System.Windows.Documents.ITextContainer.Start { get; }
    private ITextPointer System.Windows.Documents.ITextContainer.End { get; }
    private UInt32 System.Windows.Documents.ITextContainer.Generation { get; }
    private Highlights System.Windows.Documents.ITextContainer.Highlights { get; }
    private DependencyObject System.Windows.Documents.ITextContainer.Parent { get; }
    private ITextSelection System.Windows.Documents.ITextContainer.TextSelection { get; private set; }
    private UndoManager System.Windows.Documents.ITextContainer.UndoManager { get; }
    private ITextView System.Windows.Documents.ITextContainer.TextView { get; private set; }
    private int System.Windows.Documents.ITextContainer.SymbolCount { get; }
    private int System.Windows.Documents.ITextContainer.IMECharCount { get; }
    private sealed virtual override void System.Windows.Documents.ITextContainer.BeginChange();
    private sealed virtual override void System.Windows.Documents.ITextContainer.BeginChangeNoUndo();
    private sealed virtual override void System.Windows.Documents.ITextContainer.EndChange();
    private sealed virtual override void System.Windows.Documents.ITextContainer.EndChange(bool skipEvents);
    private sealed virtual override ITextPointer System.Windows.Documents.ITextContainer.CreatePointerAtOffset(int offset, LogicalDirection direction);
    private sealed virtual override ITextPointer System.Windows.Documents.ITextContainer.CreatePointerAtCharOffset(int charOffset, LogicalDirection direction);
    private sealed virtual override ITextPointer System.Windows.Documents.ITextContainer.CreateDynamicTextPointer(StaticTextPointer position, LogicalDirection direction);
    private sealed virtual override StaticTextPointer System.Windows.Documents.ITextContainer.CreateStaticPointerAtOffset(int offset);
    private sealed virtual override TextPointerContext System.Windows.Documents.ITextContainer.GetPointerContext(StaticTextPointer pointer, LogicalDirection direction);
    private sealed virtual override int System.Windows.Documents.ITextContainer.GetOffsetToPosition(StaticTextPointer position1, StaticTextPointer position2);
    private sealed virtual override int System.Windows.Documents.ITextContainer.GetTextInRun(StaticTextPointer position, LogicalDirection direction, Char[] textBuffer, int startIndex, int count);
    private sealed virtual override object System.Windows.Documents.ITextContainer.GetAdjacentElement(StaticTextPointer position, LogicalDirection direction);
    private sealed virtual override DependencyObject System.Windows.Documents.ITextContainer.GetParent(StaticTextPointer position);
    private sealed virtual override StaticTextPointer System.Windows.Documents.ITextContainer.CreatePointer(StaticTextPointer position, int offset);
    private sealed virtual override StaticTextPointer System.Windows.Documents.ITextContainer.GetNextContextPosition(StaticTextPointer position, LogicalDirection direction);
    private sealed virtual override int System.Windows.Documents.ITextContainer.CompareTo(StaticTextPointer position1, StaticTextPointer position2);
    private sealed virtual override int System.Windows.Documents.ITextContainer.CompareTo(StaticTextPointer position1, ITextPointer position2);
    private sealed virtual override object System.Windows.Documents.ITextContainer.GetValue(StaticTextPointer position, DependencyProperty formattingProperty);
    private sealed virtual override bool System.Windows.Documents.ITextContainer.get_IsReadOnly();
    private sealed virtual override ITextPointer System.Windows.Documents.ITextContainer.get_Start();
    private sealed virtual override ITextPointer System.Windows.Documents.ITextContainer.get_End();
    private sealed virtual override UInt32 System.Windows.Documents.ITextContainer.get_Generation();
    private sealed virtual override Highlights System.Windows.Documents.ITextContainer.get_Highlights();
    private sealed virtual override DependencyObject System.Windows.Documents.ITextContainer.get_Parent();
    private sealed virtual override ITextSelection System.Windows.Documents.ITextContainer.get_TextSelection();
    private sealed virtual override void System.Windows.Documents.ITextContainer.set_TextSelection(ITextSelection value);
    private sealed virtual override UndoManager System.Windows.Documents.ITextContainer.get_UndoManager();
    private sealed virtual override ITextView System.Windows.Documents.ITextContainer.get_TextView();
    private sealed virtual override void System.Windows.Documents.ITextContainer.set_TextView(ITextView value);
    private sealed virtual override int System.Windows.Documents.ITextContainer.get_SymbolCount();
    private sealed virtual override int System.Windows.Documents.ITextContainer.get_IMECharCount();
    public sealed virtual void add_Changing(EventHandler value);
    public sealed virtual void remove_Changing(EventHandler value);
    public sealed virtual void add_Change(TextContainerChangeEventHandler value);
    public sealed virtual void remove_Change(TextContainerChangeEventHandler value);
    public sealed virtual void add_Changed(TextContainerChangedEventHandler value);
    public sealed virtual void remove_Changed(TextContainerChangedEventHandler value);
}
internal class System.Windows.Documents.NullTextPointer : object {
    private LogicalDirection _gravity;
    private NullTextContainer _container;
    private bool _isFrozen;
    private Type System.Windows.Documents.ITextPointer.ParentType { get; }
    private ITextContainer System.Windows.Documents.ITextPointer.TextContainer { get; }
    private bool System.Windows.Documents.ITextPointer.HasValidLayout { get; }
    private bool System.Windows.Documents.ITextPointer.IsAtCaretUnitBoundary { get; }
    private LogicalDirection System.Windows.Documents.ITextPointer.LogicalDirection { get; }
    private bool System.Windows.Documents.ITextPointer.IsAtInsertionPosition { get; }
    private bool System.Windows.Documents.ITextPointer.IsFrozen { get; }
    private int System.Windows.Documents.ITextPointer.Offset { get; }
    private int System.Windows.Documents.ITextPointer.CharOffset { get; }
    internal NullTextPointer(NullTextContainer container, LogicalDirection gravity);
    private sealed virtual override int System.Windows.Documents.ITextPointer.CompareTo(ITextPointer position);
    private sealed virtual override int System.Windows.Documents.ITextPointer.CompareTo(StaticTextPointer position);
    private sealed virtual override int System.Windows.Documents.ITextPointer.GetOffsetToPosition(ITextPointer position);
    private sealed virtual override TextPointerContext System.Windows.Documents.ITextPointer.GetPointerContext(LogicalDirection direction);
    private sealed virtual override int System.Windows.Documents.ITextPointer.GetTextRunLength(LogicalDirection direction);
    private sealed virtual override string System.Windows.Documents.ITextPointer.GetTextInRun(LogicalDirection direction);
    private sealed virtual override int System.Windows.Documents.ITextPointer.GetTextInRun(LogicalDirection direction, Char[] textBuffer, int startIndex, int count);
    private sealed virtual override object System.Windows.Documents.ITextPointer.GetAdjacentElement(LogicalDirection direction);
    private sealed virtual override Type System.Windows.Documents.ITextPointer.GetElementType(LogicalDirection direction);
    private sealed virtual override bool System.Windows.Documents.ITextPointer.HasEqualScope(ITextPointer position);
    private sealed virtual override object System.Windows.Documents.ITextPointer.GetValue(DependencyProperty property);
    private sealed virtual override object System.Windows.Documents.ITextPointer.ReadLocalValue(DependencyProperty property);
    private sealed virtual override LocalValueEnumerator System.Windows.Documents.ITextPointer.GetLocalValueEnumerator();
    private sealed virtual override ITextPointer System.Windows.Documents.ITextPointer.CreatePointer();
    private sealed virtual override StaticTextPointer System.Windows.Documents.ITextPointer.CreateStaticPointer();
    private sealed virtual override ITextPointer System.Windows.Documents.ITextPointer.CreatePointer(int distance);
    private sealed virtual override ITextPointer System.Windows.Documents.ITextPointer.CreatePointer(LogicalDirection gravity);
    private sealed virtual override ITextPointer System.Windows.Documents.ITextPointer.CreatePointer(int distance, LogicalDirection gravity);
    private sealed virtual override void System.Windows.Documents.ITextPointer.Freeze();
    private sealed virtual override ITextPointer System.Windows.Documents.ITextPointer.GetFrozenPointer(LogicalDirection logicalDirection);
    private sealed virtual override void System.Windows.Documents.ITextPointer.SetLogicalDirection(LogicalDirection direction);
    private sealed virtual override bool System.Windows.Documents.ITextPointer.MoveToNextContextPosition(LogicalDirection direction);
    private sealed virtual override int System.Windows.Documents.ITextPointer.MoveByOffset(int distance);
    private sealed virtual override void System.Windows.Documents.ITextPointer.MoveToPosition(ITextPointer position);
    private sealed virtual override void System.Windows.Documents.ITextPointer.MoveToElementEdge(ElementEdge edge);
    private sealed virtual override int System.Windows.Documents.ITextPointer.MoveToLineBoundary(int count);
    private sealed virtual override Rect System.Windows.Documents.ITextPointer.GetCharacterRect(LogicalDirection direction);
    private sealed virtual override bool System.Windows.Documents.ITextPointer.MoveToInsertionPosition(LogicalDirection direction);
    private sealed virtual override bool System.Windows.Documents.ITextPointer.MoveToNextInsertionPosition(LogicalDirection direction);
    private sealed virtual override void System.Windows.Documents.ITextPointer.InsertTextInRun(string textData);
    private sealed virtual override void System.Windows.Documents.ITextPointer.DeleteContentToPosition(ITextPointer limit);
    private sealed virtual override ITextPointer System.Windows.Documents.ITextPointer.GetNextContextPosition(LogicalDirection direction);
    private sealed virtual override ITextPointer System.Windows.Documents.ITextPointer.GetInsertionPosition(LogicalDirection direction);
    private sealed virtual override ITextPointer System.Windows.Documents.ITextPointer.GetFormatNormalizedPosition(LogicalDirection direction);
    private sealed virtual override ITextPointer System.Windows.Documents.ITextPointer.GetNextInsertionPosition(LogicalDirection direction);
    private sealed virtual override bool System.Windows.Documents.ITextPointer.ValidateLayout();
    private sealed virtual override Type System.Windows.Documents.ITextPointer.get_ParentType();
    private sealed virtual override ITextContainer System.Windows.Documents.ITextPointer.get_TextContainer();
    private sealed virtual override bool System.Windows.Documents.ITextPointer.get_HasValidLayout();
    private sealed virtual override bool System.Windows.Documents.ITextPointer.get_IsAtCaretUnitBoundary();
    private sealed virtual override LogicalDirection System.Windows.Documents.ITextPointer.get_LogicalDirection();
    private sealed virtual override bool System.Windows.Documents.ITextPointer.get_IsAtInsertionPosition();
    private sealed virtual override bool System.Windows.Documents.ITextPointer.get_IsFrozen();
    private sealed virtual override int System.Windows.Documents.ITextPointer.get_Offset();
    private sealed virtual override int System.Windows.Documents.ITextPointer.get_CharOffset();
}
[ContentPropertyAttribute("Child")]
public class System.Windows.Documents.PageContent : FrameworkElement {
    public static DependencyProperty SourceProperty;
    [CompilerGeneratedAttribute]
private GetPageRootCompletedEventHandler GetPageRootCompleted;
    private WeakReference _pageRef;
    private FixedPage _child;
    private PageContentAsyncResult _asyncOp;
    private HybridDictionary _pendingStreams;
    private LinkTargetCollection _linkTargets;
    public Uri Source { get; public set; }
    public LinkTargetCollection LinkTargets { get; }
    [DefaultValueAttribute("")]
[DesignerSerializationVisibilityAttribute("2")]
public FixedPage Child { get; public set; }
    private Uri System.Windows.Markup.IUriContext.BaseUri { get; private set; }
    internal FixedPage PageStream { get; }
    protected internal IEnumerator LogicalChildren { get; }
    private static PageContent();
    public FixedPage GetPageRoot(bool forceReload);
    public void GetPageRootAsync(bool forceReload);
    public void GetPageRootAsyncCancel();
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object value);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string text);
    private static void OnSourceChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public Uri get_Source();
    public void set_Source(Uri value);
    public LinkTargetCollection get_LinkTargets();
    public FixedPage get_Child();
    public void set_Child(FixedPage value);
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeChild(XamlDesignerSerializationManager manager);
    private sealed virtual override Uri System.Windows.Markup.IUriContext.get_BaseUri();
    private sealed virtual override void System.Windows.Markup.IUriContext.set_BaseUri(Uri value);
    [CompilerGeneratedAttribute]
public void add_GetPageRootCompleted(GetPageRootCompletedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_GetPageRootCompleted(GetPageRootCompletedEventHandler value);
    internal bool IsOwnerOf(FixedPage pageVisual);
    internal Stream GetPageStream();
    internal FixedPage get_PageStream();
    internal bool ContainsID(string elementID);
    protected internal virtual IEnumerator get_LogicalChildren();
    private void _Init();
    private void _NotifyPageCompleted(FixedPage result, Exception error, bool cancelled, object userToken);
    private Uri _ResolveUri();
    private void _RequestPageCallback(IAsyncResult ar);
    private FixedPage _LoadPage();
    private FixedPage _GetLoadedPage();
    private void _OnPaserFinished(object sender, EventArgs args);
    internal static void _LoadPageImpl(Uri baseUri, Uri uriToLoad, FixedPage& fixedPage, Stream& pageStream);
}
internal class System.Windows.Documents.PageContentAsyncResult : object {
    private object _asyncState;
    private bool _isCompleted;
    private bool _completedSynchronously;
    private AsyncCallback _callback;
    private Exception _exception;
    private GetPageStatus _getpageStatus;
    private Uri _baseUri;
    private Uri _source;
    private FixedPage _child;
    private Dispatcher _dispatcher;
    private FixedPage _result;
    private Stream _pendingStream;
    private DispatcherOperation _dispatcherOperation;
    public object AsyncState { get; }
    public WaitHandle AsyncWaitHandle { get; }
    public bool CompletedSynchronously { get; }
    public bool IsCompleted { get; }
    internal Exception Exception { get; }
    internal bool IsCancelled { get; }
    unknown DispatcherOperation DispatcherOperation {internal set; }
    internal FixedPage Result { get; }
    internal PageContentAsyncResult(AsyncCallback callback, object state, Dispatcher dispatcher, Uri baseUri, Uri source, FixedPage child);
    public sealed virtual object get_AsyncState();
    public sealed virtual WaitHandle get_AsyncWaitHandle();
    public sealed virtual bool get_CompletedSynchronously();
    public sealed virtual bool get_IsCompleted();
    internal object Dispatch(object arg);
    internal void Cancel();
    internal void Wait();
    internal Exception get_Exception();
    internal bool get_IsCancelled();
    internal void set_DispatcherOperation(DispatcherOperation value);
    internal FixedPage get_Result();
    private void _OnPaserFinished(object sender, EventArgs args);
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Documents.PageContentCollection : object {
    private FixedDocument _logicalParent;
    private List`1<PageContent> _internalList;
    public PageContent Item { get; }
    public int Count { get; }
    private IList`1<PageContent> InternalList { get; }
    internal PageContentCollection(FixedDocument logicalParent);
    public int Add(PageContent newPageContent);
    public sealed virtual IEnumerator`1<PageContent> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public PageContent get_Item(int pageIndex);
    public int get_Count();
    internal int IndexOf(PageContent pc);
    private IList`1<PageContent> get_InternalList();
}
internal class System.Windows.Documents.ParaBorder : object {
    private BorderFormat _bfLeft;
    private BorderFormat _bfTop;
    private BorderFormat _bfRight;
    private BorderFormat _bfBottom;
    private BorderFormat _bfAll;
    private long _nSpacing;
    internal BorderFormat BorderLeft { get; internal set; }
    internal BorderFormat BorderTop { get; internal set; }
    internal BorderFormat BorderRight { get; internal set; }
    internal BorderFormat BorderBottom { get; internal set; }
    internal BorderFormat BorderAll { get; internal set; }
    internal long Spacing { get; internal set; }
    internal long CF { get; internal set; }
    internal bool IsNone { get; }
    internal string RTFEncoding { get; }
    internal ParaBorder(ParaBorder pb);
    internal BorderFormat get_BorderLeft();
    internal void set_BorderLeft(BorderFormat value);
    internal BorderFormat get_BorderTop();
    internal void set_BorderTop(BorderFormat value);
    internal BorderFormat get_BorderRight();
    internal void set_BorderRight(BorderFormat value);
    internal BorderFormat get_BorderBottom();
    internal void set_BorderBottom(BorderFormat value);
    internal BorderFormat get_BorderAll();
    internal void set_BorderAll(BorderFormat value);
    internal long get_Spacing();
    internal void set_Spacing(long value);
    internal long get_CF();
    internal void set_CF(long value);
    internal bool get_IsNone();
    internal string GetBorderAttributeString(ConverterState converterState);
    internal string get_RTFEncoding();
}
[ContentPropertyAttribute("Inlines")]
public class System.Windows.Documents.Paragraph : Block {
    public static DependencyProperty TextDecorationsProperty;
    public static DependencyProperty TextIndentProperty;
    public static DependencyProperty MinOrphanLinesProperty;
    public static DependencyProperty MinWidowLinesProperty;
    public static DependencyProperty KeepWithNextProperty;
    public static DependencyProperty KeepTogetherProperty;
    [DesignerSerializationVisibilityAttribute("2")]
public InlineCollection Inlines { get; }
    public TextDecorationCollection TextDecorations { get; public set; }
    [TypeConverterAttribute("System.Windows.LengthConverter")]
public double TextIndent { get; public set; }
    public int MinOrphanLines { get; public set; }
    public int MinWidowLines { get; public set; }
    public bool KeepWithNext { get; public set; }
    public bool KeepTogether { get; public set; }
    private static Paragraph();
    public Paragraph(Inline inline);
    public InlineCollection get_Inlines();
    public TextDecorationCollection get_TextDecorations();
    public void set_TextDecorations(TextDecorationCollection value);
    public double get_TextIndent();
    public void set_TextIndent(double value);
    public int get_MinOrphanLines();
    public void set_MinOrphanLines(int value);
    public int get_MinWidowLines();
    public void set_MinWidowLines(int value);
    public bool get_KeepWithNext();
    public void set_KeepWithNext(bool value);
    public bool get_KeepTogether();
    public void set_KeepTogether(bool value);
    internal void GetDefaultMarginValue(Thickness& margin);
    internal static bool IsMarginAuto(Thickness margin);
    internal static bool IsLineHeightAuto(double lineHeight);
    internal static bool HasNoTextContent(Paragraph paragraph);
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeInlines(XamlDesignerSerializationManager manager);
    private static bool IsValidMinOrphanLines(object o);
    private static bool IsValidMinWidowLines(object o);
    private static bool IsValidTextIndent(object o);
}
internal enum System.Windows.Documents.PrecursorTextChangeType : Enum {
    public int value__;
    public static PrecursorTextChangeType ContentAdded;
    public static PrecursorTextChangeType ContentRemoved;
    public static PrecursorTextChangeType PropertyModified;
    public static PrecursorTextChangeType ElementAdded;
    public static PrecursorTextChangeType ElementExtracted;
}
internal class System.Windows.Documents.PropertyRecord : ValueType {
    private DependencyProperty _property;
    private object _value;
    internal DependencyProperty Property { get; internal set; }
    internal object Value { get; internal set; }
    internal DependencyProperty get_Property();
    internal void set_Property(DependencyProperty value);
    internal object get_Value();
    internal void set_Value(object value);
}
internal enum System.Windows.Documents.PropertyValueAction : Enum {
    public int value__;
    public static PropertyValueAction SetValue;
    public static PropertyValueAction IncreaseByAbsoluteValue;
    public static PropertyValueAction DecreaseByAbsoluteValue;
    public static PropertyValueAction IncreaseByPercentageValue;
    public static PropertyValueAction DecreaseByPercentageValue;
}
internal class System.Windows.Documents.RangeContentEnumerator : object {
    private TextPointer _start;
    private TextPointer _end;
    private UInt32 _generation;
    private TextPointer _navigator;
    private object _currentCache;
    private Char[] _buffer;
    public object Current { get; }
    private bool IsLogicalChildrenIterationInProgress { get; }
    internal RangeContentEnumerator(TextPointer start, TextPointer end);
    public sealed virtual object get_Current();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
    private void EnsureBufferCapacity(int size);
    private bool get_IsLogicalChildrenIterationInProgress();
}
internal class System.Windows.Documents.RowFormat : object {
    private CellFormat _rowCellFormat;
    private CellWidth _widthA;
    private CellWidth _widthB;
    private CellWidth _widthRow;
    private ArrayList _cellFormats;
    private long _nTrgaph;
    private long _nTrleft;
    private DirState _dir;
    internal CellFormat RowCellFormat { get; }
    internal int CellCount { get; }
    internal CellFormat TopCellFormat { get; }
    internal CellWidth WidthA { get; }
    internal CellWidth WidthB { get; }
    internal CellWidth WidthRow { get; }
    internal long Trgaph { get; internal set; }
    internal long Trleft { get; internal set; }
    internal DirState Dir { get; internal set; }
    internal bool IsVMerge { get; }
    internal RowFormat(RowFormat ri);
    internal CellFormat get_RowCellFormat();
    internal int get_CellCount();
    internal CellFormat get_TopCellFormat();
    internal CellWidth get_WidthA();
    internal CellWidth get_WidthB();
    internal CellWidth get_WidthRow();
    internal long get_Trgaph();
    internal void set_Trgaph(long value);
    internal long get_Trleft();
    internal void set_Trleft(long value);
    internal DirState get_Dir();
    internal void set_Dir(DirState value);
    internal bool get_IsVMerge();
    internal CellFormat NthCellFormat(int n);
    internal CellFormat NextCellFormat();
    internal CellFormat CurrentCellFormat();
    internal void CanonicalizeWidthsFromRTF();
    internal void CanonicalizeWidthsFromXaml();
}
internal static class System.Windows.Documents.RtfControls : object {
    public static UInt32 RTK_TOGGLE;
    public static UInt32 RTK_FLAG;
    public static UInt32 RTK_VALUE;
    public static UInt32 RTK_DESTINATION;
    public static UInt32 RTK_SYMBOL;
    public static UInt32 RTK_PARAM;
    public static UInt32 RTK_TEXT;
    public static UInt32 RTK_ACHARPROPS;
    public static UInt32 RTK_CHARPROPS;
    public static UInt32 RTK_PARAPROPS;
    public static UInt32 RTK_OBJPROPS;
    public static UInt32 RTK_BOOKMARKPROPS;
    public static UInt32 RTK_SECTIONPROPS;
    public static UInt32 RTK_DOCPROPS;
    public static UInt32 RTK_FILEPROPS;
    public static UInt32 RTK_COMMENT;
    public static UInt32 RTK_STYLE;
    public static UInt32 RTK_FONTTABLE;
    public static UInt32 RTK_COLORTABLE;
    public static UInt32 RTK_BULLETS;
    public static UInt32 RTK_TABLEDEF;
    public static UInt32 RTK_SHAPES;
    public static UInt32 RTK_POSOBJ;
    public static UInt32 RTK_BORDER;
    public static UInt32 RTK_SHADING;
    public static UInt32 RTK_PICT;
    public static UInt32 RTK_FIELD;
    public static UInt32 RTK_FORMFIELD;
    public static UInt32 RTK_INDEX;
    public static UInt32 RTK_DRAWOBJ;
    public static UInt32 RTK_INFO;
    public static UInt32 RTK_LISTTABLE;
    public static UInt32 RTK_PICTPROPS;
    public static UInt32 RTK_CHARSET;
    public static UInt32 RTK_UNICODE;
    public static UInt32 RTK_TABS;
    public static UInt32 RTK_FOOTNOTES;
    public static UInt32 RTK_HIGHLIGHT;
    public static UInt32 RTK_FILETABLE;
    public static UInt32 RTK_HEADER;
    public static UInt32 RTK_OBJECTS;
    public static UInt32 RTK_PARATEXT;
    public static UInt32 RTK_SPECIAL;
    public static UInt32 RTK_SECTION;
    public static UInt32 RTK_TOC;
    internal static RtfControlWordInfo[] ControlTable;
    private static RtfControls();
    private static RtfControlWordInfo CreateCommonControlWord(string controlName, UInt32 flags);
    private static RtfControlWordInfo CreateCommonDocPropsControlWord(string controlName);
    private static RtfControlWordInfo CreateCommonDrawObjControlWord(string controlName);
}
internal enum System.Windows.Documents.RtfControlWord : Enum {
    public int value__;
    public static RtfControlWord Ctrl_Unknown;
    public static RtfControlWord Ctrl_AB;
    public static RtfControlWord Ctrl_ABSH;
    public static RtfControlWord Ctrl_ABSLOCK;
    public static RtfControlWord Ctrl_ABSNOOVRLP;
    public static RtfControlWord Ctrl_ABSW;
    public static RtfControlWord Ctrl_ACAPS;
    public static RtfControlWord Ctrl_ACCCOMMA;
    public static RtfControlWord Ctrl_ACCDOT;
    public static RtfControlWord Ctrl_ACCNONE;
    public static RtfControlWord Ctrl_ACF;
    public static RtfControlWord Ctrl_ADDITIVE;
    public static RtfControlWord Ctrl_ADJUSTRIGHT;
    public static RtfControlWord Ctrl_ADN;
    public static RtfControlWord Ctrl_AENDDOC;
    public static RtfControlWord Ctrl_AENDNOTES;
    public static RtfControlWord Ctrl_AEXPND;
    public static RtfControlWord Ctrl_AF;
    public static RtfControlWord Ctrl_AFFIXED;
    public static RtfControlWord Ctrl_AFS;
    public static RtfControlWord Ctrl_AFTNBJ;
    public static RtfControlWord Ctrl_AFTNCN;
    public static RtfControlWord Ctrl_AFTNNALC;
    public static RtfControlWord Ctrl_AFTNNAR;
    public static RtfControlWord Ctrl_AFTNNAUC;
    public static RtfControlWord Ctrl_AFTNNCHI;
    public static RtfControlWord Ctrl_AFTNNCHOSUNG;
    public static RtfControlWord Ctrl_AFTNNCNUM;
    public static RtfControlWord Ctrl_AFTNNDBAR;
    public static RtfControlWord Ctrl_AFTNNDBNUM;
    public static RtfControlWord Ctrl_AFTNNDBNUMD;
    public static RtfControlWord Ctrl_AFTNNDBNUMK;
    public static RtfControlWord Ctrl_AFTNNDBNUMT;
    public static RtfControlWord Ctrl_AFTNNGANADA;
    public static RtfControlWord Ctrl_AFTNNGBNUM;
    public static RtfControlWord Ctrl_AFTNNGBNUMD;
    public static RtfControlWord Ctrl_AFTNNGBNUMK;
    public static RtfControlWord Ctrl_AFTNNGBNUML;
    public static RtfControlWord Ctrl_AFTNNRLC;
    public static RtfControlWord Ctrl_AFTNNRUC;
    public static RtfControlWord Ctrl_AFTNNZODIAC;
    public static RtfControlWord Ctrl_AFTNNZODIACD;
    public static RtfControlWord Ctrl_AFTNNZODIACL;
    public static RtfControlWord Ctrl_AFTNRESTART;
    public static RtfControlWord Ctrl_AFTNRSTCONT;
    public static RtfControlWord Ctrl_AFTNSEP;
    public static RtfControlWord Ctrl_AFTNSEPC;
    public static RtfControlWord Ctrl_AFTNSTART;
    public static RtfControlWord Ctrl_AFTNTJ;
    public static RtfControlWord Ctrl_AI;
    public static RtfControlWord Ctrl_ALANG;
    public static RtfControlWord Ctrl_ALLPROT;
    public static RtfControlWord Ctrl_ALNTBLIND;
    public static RtfControlWord Ctrl_ALT;
    public static RtfControlWord Ctrl_ANIMTEXT;
    public static RtfControlWord Ctrl_ANNOTATION;
    public static RtfControlWord Ctrl_ANNOTPROT;
    public static RtfControlWord Ctrl_ANSI;
    public static RtfControlWord Ctrl_ANSICPG;
    public static RtfControlWord Ctrl_AOUTL;
    public static RtfControlWord Ctrl_ASCAPS;
    public static RtfControlWord Ctrl_ASHAD;
    public static RtfControlWord Ctrl_ASPALPHA;
    public static RtfControlWord Ctrl_ASPNUM;
    public static RtfControlWord Ctrl_ASTRIKE;
    public static RtfControlWord Ctrl_ATNAUTHOR;
    public static RtfControlWord Ctrl_ATNICN;
    public static RtfControlWord Ctrl_ATNID;
    public static RtfControlWord Ctrl_ATNREF;
    public static RtfControlWord Ctrl_ATNTIME;
    public static RtfControlWord Ctrl_ATRFEND;
    public static RtfControlWord Ctrl_ATRFSTART;
    public static RtfControlWord Ctrl_AUL;
    public static RtfControlWord Ctrl_AULD;
    public static RtfControlWord Ctrl_AULDB;
    public static RtfControlWord Ctrl_AULNONE;
    public static RtfControlWord Ctrl_AULW;
    public static RtfControlWord Ctrl_AUP;
    public static RtfControlWord Ctrl_AUTHOR;
    public static RtfControlWord Ctrl_B;
    public static RtfControlWord Ctrl_BACKGROUND;
    public static RtfControlWord Ctrl_BDBFHDR;
    public static RtfControlWord Ctrl_BDRRLSWSIX;
    public static RtfControlWord Ctrl_BGBDIAG;
    public static RtfControlWord Ctrl_BGCROSS;
    public static RtfControlWord Ctrl_BGDCROSS;
    public static RtfControlWord Ctrl_BGDKBDIAG;
    public static RtfControlWord Ctrl_BGDKCROSS;
    public static RtfControlWord Ctrl_BGDKDCROSS;
    public static RtfControlWord Ctrl_BGDKFDIAG;
    public static RtfControlWord Ctrl_BGDKHORIZ;
    public static RtfControlWord Ctrl_BGDKVERT;
    public static RtfControlWord Ctrl_BGFDIAG;
    public static RtfControlWord Ctrl_BGHORIZ;
    public static RtfControlWord Ctrl_BGVERT;
    public static RtfControlWord Ctrl_BIN;
    public static RtfControlWord Ctrl_BINFSXN;
    public static RtfControlWord Ctrl_BINSXN;
    public static RtfControlWord Ctrl_BKMKCOLF;
    public static RtfControlWord Ctrl_BKMKCOLL;
    public static RtfControlWord Ctrl_BKMKEND;
    public static RtfControlWord Ctrl_BKMKPUB;
    public static RtfControlWord Ctrl_BKMKSTART;
    public static RtfControlWord Ctrl_BLIPTAG;
    public static RtfControlWord Ctrl_BLIPUID;
    public static RtfControlWord Ctrl_BLIPUPI;
    public static RtfControlWord Ctrl_BLUE;
    public static RtfControlWord Ctrl_BOX;
    public static RtfControlWord Ctrl_BRDRART;
    public static RtfControlWord Ctrl_BRDRB;
    public static RtfControlWord Ctrl_BRDRBAR;
    public static RtfControlWord Ctrl_BRDRBTW;
    public static RtfControlWord Ctrl_BRDRCF;
    public static RtfControlWord Ctrl_BRDRDASH;
    public static RtfControlWord Ctrl_BRDRDASHD;
    public static RtfControlWord Ctrl_BRDRDASHDD;
    public static RtfControlWord Ctrl_BRDRDASHDOTSTR;
    public static RtfControlWord Ctrl_BRDRDASHSM;
    public static RtfControlWord Ctrl_BRDRDB;
    public static RtfControlWord Ctrl_BRDRDOT;
    public static RtfControlWord Ctrl_BRDREMBOSS;
    public static RtfControlWord Ctrl_BRDRENGRAVE;
    public static RtfControlWord Ctrl_BRDRFRAME;
    public static RtfControlWord Ctrl_BRDRHAIR;
    public static RtfControlWord Ctrl_BRDRINSET;
    public static RtfControlWord Ctrl_BRDRL;
    public static RtfControlWord Ctrl_BRDROUTSET;
    public static RtfControlWord Ctrl_BRDRNIL;
    public static RtfControlWord Ctrl_BRDRNONE;
    public static RtfControlWord Ctrl_BRDRTBL;
    public static RtfControlWord Ctrl_BRDRR;
    public static RtfControlWord Ctrl_BRDRS;
    public static RtfControlWord Ctrl_BRDRSH;
    public static RtfControlWord Ctrl_BRDRT;
    public static RtfControlWord Ctrl_BRDRTH;
    public static RtfControlWord Ctrl_BRDRTHTNLG;
    public static RtfControlWord Ctrl_BRDRTHTNMG;
    public static RtfControlWord Ctrl_BRDRTHTNSG;
    public static RtfControlWord Ctrl_BRDRTNTHLG;
    public static RtfControlWord Ctrl_BRDRTNTHMG;
    public static RtfControlWord Ctrl_BRDRTNTHSG;
    public static RtfControlWord Ctrl_BRDRTNTHTNLG;
    public static RtfControlWord Ctrl_BRDRTNTHTNMG;
    public static RtfControlWord Ctrl_BRDRTNTHTNSG;
    public static RtfControlWord Ctrl_BRDRTRIPLE;
    public static RtfControlWord Ctrl_BRDRW;
    public static RtfControlWord Ctrl_BRDRWAVY;
    public static RtfControlWord Ctrl_BRDRWAVYDB;
    public static RtfControlWord Ctrl_BRKFRM;
    public static RtfControlWord Ctrl_BRSP;
    public static RtfControlWord Ctrl_BULLET;
    public static RtfControlWord Ctrl_BUPTIM;
    public static RtfControlWord Ctrl_BXE;
    public static RtfControlWord Ctrl_CAPS;
    public static RtfControlWord Ctrl_CATEGORY;
    public static RtfControlWord Ctrl_CB;
    public static RtfControlWord Ctrl_CBPAT;
    public static RtfControlWord Ctrl_CCHS;
    public static RtfControlWord Ctrl_CELL;
    public static RtfControlWord Ctrl_CELLX;
    public static RtfControlWord Ctrl_CF;
    public static RtfControlWord Ctrl_CFPAT;
    public static RtfControlWord Ctrl_CGRID;
    public static RtfControlWord Ctrl_CHARSCALEX;
    public static RtfControlWord Ctrl_CHATN;
    public static RtfControlWord Ctrl_CHBGBDIAG;
    public static RtfControlWord Ctrl_CHBGCROSS;
    public static RtfControlWord Ctrl_CHBGDCROSS;
    public static RtfControlWord Ctrl_CHBGDKBDIAG;
    public static RtfControlWord Ctrl_CHBGDKCROSS;
    public static RtfControlWord Ctrl_CHBGDKDCROSS;
    public static RtfControlWord Ctrl_CHBGDKFDIAG;
    public static RtfControlWord Ctrl_CHBGDKHORIZ;
    public static RtfControlWord Ctrl_CHBGDKVERT;
    public static RtfControlWord Ctrl_CHBGFDIAG;
    public static RtfControlWord Ctrl_CHBGHORIZ;
    public static RtfControlWord Ctrl_CHBGVERT;
    public static RtfControlWord Ctrl_CHBRDR;
    public static RtfControlWord Ctrl_CHCBPAT;
    public static RtfControlWord Ctrl_CHCFPAT;
    public static RtfControlWord Ctrl_CHDATE;
    public static RtfControlWord Ctrl_CHDPA;
    public static RtfControlWord Ctrl_CHDPL;
    public static RtfControlWord Ctrl_CHFTN;
    public static RtfControlWord Ctrl_CHFTNSEP;
    public static RtfControlWord Ctrl_CHFTNSEPC;
    public static RtfControlWord Ctrl_CHPGN;
    public static RtfControlWord Ctrl_CHSHDNG;
    public static RtfControlWord Ctrl_CHTIME;
    public static RtfControlWord Ctrl_CLBGBDIAG;
    public static RtfControlWord Ctrl_CLBGCROSS;
    public static RtfControlWord Ctrl_CLBGDCROSS;
    public static RtfControlWord Ctrl_CLBGDKBDIAG;
    public static RtfControlWord Ctrl_CLBGDKCROSS;
    public static RtfControlWord Ctrl_CLBGDKDCROSS;
    public static RtfControlWord Ctrl_CLBGDKFDIAG;
    public static RtfControlWord Ctrl_CLBGDKHOR;
    public static RtfControlWord Ctrl_CLBGDKVERT;
    public static RtfControlWord Ctrl_CLBGFDIAG;
    public static RtfControlWord Ctrl_CLBGHORIZ;
    public static RtfControlWord Ctrl_CLBGVERT;
    public static RtfControlWord Ctrl_CLBRDRB;
    public static RtfControlWord Ctrl_CLBRDRL;
    public static RtfControlWord Ctrl_CLBRDRR;
    public static RtfControlWord Ctrl_CLBRDRT;
    public static RtfControlWord Ctrl_CLCBPAT;
    public static RtfControlWord Ctrl_CLCFPAT;
    public static RtfControlWord Ctrl_CLDGLL;
    public static RtfControlWord Ctrl_CLDGLU;
    public static RtfControlWord Ctrl_CLFITTEXT;
    public static RtfControlWord Ctrl_CLFTSWIDTH;
    public static RtfControlWord Ctrl_CLMGF;
    public static RtfControlWord Ctrl_CLMRG;
    public static RtfControlWord Ctrl_CLOWRAP;
    public static RtfControlWord Ctrl_CLPADB;
    public static RtfControlWord Ctrl_CLPADFB;
    public static RtfControlWord Ctrl_CLPADFL;
    public static RtfControlWord Ctrl_CLPADFR;
    public static RtfControlWord Ctrl_CLPADFT;
    public static RtfControlWord Ctrl_CLPADL;
    public static RtfControlWord Ctrl_CLPADR;
    public static RtfControlWord Ctrl_CLPADT;
    public static RtfControlWord Ctrl_CLSHDNG;
    public static RtfControlWord Ctrl_CLSHDRAWNIL;
    public static RtfControlWord Ctrl_CLTXBTLR;
    public static RtfControlWord Ctrl_CLTXLRTB;
    public static RtfControlWord Ctrl_CLTXLRTBV;
    public static RtfControlWord Ctrl_CLTXTBRL;
    public static RtfControlWord Ctrl_CLTXTBRLV;
    public static RtfControlWord Ctrl_CLVERTALB;
    public static RtfControlWord Ctrl_CLVERTALC;
    public static RtfControlWord Ctrl_CLVERTALT;
    public static RtfControlWord Ctrl_CLVMGF;
    public static RtfControlWord Ctrl_CLVMRG;
    public static RtfControlWord Ctrl_CLWWIDTH;
    public static RtfControlWord Ctrl_COLLAPSED;
    public static RtfControlWord Ctrl_COLNO;
    public static RtfControlWord Ctrl_COLORTBL;
    public static RtfControlWord Ctrl_COLS;
    public static RtfControlWord Ctrl_COLSR;
    public static RtfControlWord Ctrl_COLSX;
    public static RtfControlWord Ctrl_COLUMN;
    public static RtfControlWord Ctrl_COLW;
    public static RtfControlWord Ctrl_COMMENT;
    public static RtfControlWord Ctrl_COMPANY;
    public static RtfControlWord Ctrl_CPG;
    public static RtfControlWord Ctrl_CRAUTH;
    public static RtfControlWord Ctrl_CRDATE;
    public static RtfControlWord Ctrl_CREATIM;
    public static RtfControlWord Ctrl_CS;
    public static RtfControlWord Ctrl_CTRL;
    public static RtfControlWord Ctrl_CTS;
    public static RtfControlWord Ctrl_CUFI;
    public static RtfControlWord Ctrl_CULI;
    public static RtfControlWord Ctrl_CURI;
    public static RtfControlWord Ctrl_CVMME;
    public static RtfControlWord Ctrl_DATAFIELD;
    public static RtfControlWord Ctrl_DATE;
    public static RtfControlWord Ctrl_DBCH;
    public static RtfControlWord Ctrl_DEFF;
    public static RtfControlWord Ctrl_DEFFORMAT;
    public static RtfControlWord Ctrl_DEFLANG;
    public static RtfControlWord Ctrl_DEFLANGA;
    public static RtfControlWord Ctrl_DEFLANGFE;
    public static RtfControlWord Ctrl_DEFSHP;
    public static RtfControlWord Ctrl_DEFTAB;
    public static RtfControlWord Ctrl_DELETED;
    public static RtfControlWord Ctrl_DFRAUTH;
    public static RtfControlWord Ctrl_DFRDATE;
    public static RtfControlWord Ctrl_DFRMTXTX;
    public static RtfControlWord Ctrl_DFRMTXTY;
    public static RtfControlWord Ctrl_DFRSTART;
    public static RtfControlWord Ctrl_DFRSTOP;
    public static RtfControlWord Ctrl_DFRXST;
    public static RtfControlWord Ctrl_DGHORIGIN;
    public static RtfControlWord Ctrl_DGHSHOW;
    public static RtfControlWord Ctrl_DGHSPACE;
    public static RtfControlWord Ctrl_DGMARGIN;
    public static RtfControlWord Ctrl_DGSNAP;
    public static RtfControlWord Ctrl_DGVORIGIN;
    public static RtfControlWord Ctrl_DGVSHOW;
    public static RtfControlWord Ctrl_DGVSPACE;
    public static RtfControlWord Ctrl_DIBITMAP;
    public static RtfControlWord Ctrl_DN;
    public static RtfControlWord Ctrl_DNTBLNSBDB;
    public static RtfControlWord Ctrl_DO;
    public static RtfControlWord Ctrl_DOBXCOLUMN;
    public static RtfControlWord Ctrl_DOBXMARGIN;
    public static RtfControlWord Ctrl_DOBXPAGE;
    public static RtfControlWord Ctrl_DOBYMARGIN;
    public static RtfControlWord Ctrl_DOBYPAGE;
    public static RtfControlWord Ctrl_DOBYPARA;
    public static RtfControlWord Ctrl_DOCCOMM;
    public static RtfControlWord Ctrl_DOCTEMP;
    public static RtfControlWord Ctrl_DOCTYPE;
    public static RtfControlWord Ctrl_DOCVAR;
    public static RtfControlWord Ctrl_DODHGT;
    public static RtfControlWord Ctrl_DOLOCK;
    public static RtfControlWord Ctrl_DPAENDHOL;
    public static RtfControlWord Ctrl_DPAENDL;
    public static RtfControlWord Ctrl_DPAENDSOL;
    public static RtfControlWord Ctrl_DPAENDW;
    public static RtfControlWord Ctrl_DPARC;
    public static RtfControlWord Ctrl_DPARCFLIPX;
    public static RtfControlWord Ctrl_DPARCFLIPY;
    public static RtfControlWord Ctrl_DPASTARTHOL;
    public static RtfControlWord Ctrl_DPASTARTL;
    public static RtfControlWord Ctrl_DPASTARTSOL;
    public static RtfControlWord Ctrl_DPASTARTW;
    public static RtfControlWord Ctrl_DPCALLOUT;
    public static RtfControlWord Ctrl_DPCOA;
    public static RtfControlWord Ctrl_DPCOACCENT;
    public static RtfControlWord Ctrl_DPCOBESTFIT;
    public static RtfControlWord Ctrl_DPCOBORDER;
    public static RtfControlWord Ctrl_DPCODABS;
    public static RtfControlWord Ctrl_DPCODBOTTOM;
    public static RtfControlWord Ctrl_DPCODCENTER;
    public static RtfControlWord Ctrl_DPCODESCENT;
    public static RtfControlWord Ctrl_DPCODTOP;
    public static RtfControlWord Ctrl_DPCOLENGTH;
    public static RtfControlWord Ctrl_DPCOMINUSX;
    public static RtfControlWord Ctrl_DPCOMINUSY;
    public static RtfControlWord Ctrl_DPCOOFFSET;
    public static RtfControlWord Ctrl_DPCOSMARTA;
    public static RtfControlWord Ctrl_DPCOTDOUBLE;
    public static RtfControlWord Ctrl_DPCOTRIGHT;
    public static RtfControlWord Ctrl_DPCOTSINGLE;
    public static RtfControlWord Ctrl_DPCOTTRIPLE;
    public static RtfControlWord Ctrl_DPCOUNT;
    public static RtfControlWord Ctrl_DPELLIPSE;
    public static RtfControlWord Ctrl_DPENDGROUP;
    public static RtfControlWord Ctrl_DPFILLBGCB;
    public static RtfControlWord Ctrl_DPFILLBGCG;
    public static RtfControlWord Ctrl_DPFILLBGCR;
    public static RtfControlWord Ctrl_DPFILLBGGRAY;
    public static RtfControlWord Ctrl_DPFILLBGPAL;
    public static RtfControlWord Ctrl_DPFILLFGCB;
    public static RtfControlWord Ctrl_DPFILLFGCG;
    public static RtfControlWord Ctrl_DPFILLFGCR;
    public static RtfControlWord Ctrl_DPFILLFGGRAY;
    public static RtfControlWord Ctrl_DPFILLFGPAL;
    public static RtfControlWord Ctrl_DPFILLPAT;
    public static RtfControlWord Ctrl_DPGROUP;
    public static RtfControlWord Ctrl_DPLINE;
    public static RtfControlWord Ctrl_DPLINECOB;
    public static RtfControlWord Ctrl_DPLINECOG;
    public static RtfControlWord Ctrl_DPLINECOR;
    public static RtfControlWord Ctrl_DPLINEDADO;
    public static RtfControlWord Ctrl_DPLINEDADODO;
    public static RtfControlWord Ctrl_DPLINEDASH;
    public static RtfControlWord Ctrl_DPLINEDOT;
    public static RtfControlWord Ctrl_DPLINEGRAY;
    public static RtfControlWord Ctrl_DPLINEHOLLOW;
    public static RtfControlWord Ctrl_DPLINEPAL;
    public static RtfControlWord Ctrl_DPLINESOLID;
    public static RtfControlWord Ctrl_DPLINEW;
    public static RtfControlWord Ctrl_DPPOLYCOUNT;
    public static RtfControlWord Ctrl_DPPOLYGON;
    public static RtfControlWord Ctrl_DPPOLYLINE;
    public static RtfControlWord Ctrl_DPPTX;
    public static RtfControlWord Ctrl_DPPTY;
    public static RtfControlWord Ctrl_DPRECT;
    public static RtfControlWord Ctrl_DPROUNDR;
    public static RtfControlWord Ctrl_DPSHADOW;
    public static RtfControlWord Ctrl_DPSHADX;
    public static RtfControlWord Ctrl_DPSHADY;
    public static RtfControlWord Ctrl_DPTXBTLR;
    public static RtfControlWord Ctrl_DPTXBX;
    public static RtfControlWord Ctrl_DPTXBXMAR;
    public static RtfControlWord Ctrl_DPTXBXTEXT;
    public static RtfControlWord Ctrl_DPTXLRTB;
    public static RtfControlWord Ctrl_DPTXLRTBV;
    public static RtfControlWord Ctrl_DPTXTBRL;
    public static RtfControlWord Ctrl_DPTXTBRLV;
    public static RtfControlWord Ctrl_DPX;
    public static RtfControlWord Ctrl_DPXSIZE;
    public static RtfControlWord Ctrl_DPY;
    public static RtfControlWord Ctrl_DPYSIZE;
    public static RtfControlWord Ctrl_DROPCAPLI;
    public static RtfControlWord Ctrl_DROPCAPT;
    public static RtfControlWord Ctrl_DS;
    public static RtfControlWord Ctrl_DXFRTEXT;
    public static RtfControlWord Ctrl_DY;
    public static RtfControlWord Ctrl_EDMINS;
    public static RtfControlWord Ctrl_EMBO;
    public static RtfControlWord Ctrl_EMDASH;
    public static RtfControlWord Ctrl_EMFBLIP;
    public static RtfControlWord Ctrl_EMSPACE;
    public static RtfControlWord Ctrl_ENDASH;
    public static RtfControlWord Ctrl_ENDDOC;
    public static RtfControlWord Ctrl_ENDNHERE;
    public static RtfControlWord Ctrl_ENDNOTES;
    public static RtfControlWord Ctrl_ENSPACE;
    public static RtfControlWord Ctrl_EXPND;
    public static RtfControlWord Ctrl_EXPNDTW;
    public static RtfControlWord Ctrl_EXPSHRTN;
    public static RtfControlWord Ctrl_F;
    public static RtfControlWord Ctrl_FAAUTO;
    public static RtfControlWord Ctrl_FACENTER;
    public static RtfControlWord Ctrl_FACINGP;
    public static RtfControlWord Ctrl_FAHANG;
    public static RtfControlWord Ctrl_FALT;
    public static RtfControlWord Ctrl_FAROMAN;
    public static RtfControlWord Ctrl_FAVAR;
    public static RtfControlWord Ctrl_FBIAS;
    public static RtfControlWord Ctrl_FBIDI;
    public static RtfControlWord Ctrl_FCHARS;
    public static RtfControlWord Ctrl_FCHARSET;
    public static RtfControlWord Ctrl_FDECOR;
    public static RtfControlWord Ctrl_FET;
    public static RtfControlWord Ctrl_FETCH;
    public static RtfControlWord Ctrl_FFDEFRES;
    public static RtfControlWord Ctrl_FFDEFTEXT;
    public static RtfControlWord Ctrl_FFENTRYMCR;
    public static RtfControlWord Ctrl_FFEXITMCR;
    public static RtfControlWord Ctrl_FFFORMAT;
    public static RtfControlWord Ctrl_FFHASLISTBOX;
    public static RtfControlWord Ctrl_FFHELPTEXT;
    public static RtfControlWord Ctrl_FFHPS;
    public static RtfControlWord Ctrl_FFL;
    public static RtfControlWord Ctrl_FFMAXLEN;
    public static RtfControlWord Ctrl_FFNAME;
    public static RtfControlWord Ctrl_FFOWNHELP;
    public static RtfControlWord Ctrl_FFOWNSTAT;
    public static RtfControlWord Ctrl_FFPROT;
    public static RtfControlWord Ctrl_FFRECALC;
    public static RtfControlWord Ctrl_FFRES;
    public static RtfControlWord Ctrl_FFSIZE;
    public static RtfControlWord Ctrl_FFSTATTEXT;
    public static RtfControlWord Ctrl_FFTYPE;
    public static RtfControlWord Ctrl_FFTYPETXT;
    public static RtfControlWord Ctrl_FI;
    public static RtfControlWord Ctrl_FID;
    public static RtfControlWord Ctrl_FIELD;
    public static RtfControlWord Ctrl_FILE;
    public static RtfControlWord Ctrl_FILETBL;
    public static RtfControlWord Ctrl_FITTEXT;
    public static RtfControlWord Ctrl_FLDALT;
    public static RtfControlWord Ctrl_FLDDIRTY;
    public static RtfControlWord Ctrl_FLDEDIT;
    public static RtfControlWord Ctrl_FLDINST;
    public static RtfControlWord Ctrl_FLDLOCK;
    public static RtfControlWord Ctrl_FLDPRIV;
    public static RtfControlWord Ctrl_FLDRSLT;
    public static RtfControlWord Ctrl_FLDTYPE;
    public static RtfControlWord Ctrl_FMODERN;
    public static RtfControlWord Ctrl_FN;
    public static RtfControlWord Ctrl_FNAME;
    public static RtfControlWord Ctrl_FNETWORK;
    public static RtfControlWord Ctrl_FNIL;
    public static RtfControlWord Ctrl_FONTEMB;
    public static RtfControlWord Ctrl_FONTFILE;
    public static RtfControlWord Ctrl_FONTTBL;
    public static RtfControlWord Ctrl_FOOTER;
    public static RtfControlWord Ctrl_FOOTERF;
    public static RtfControlWord Ctrl_FOOTERL;
    public static RtfControlWord Ctrl_FOOTERR;
    public static RtfControlWord Ctrl_FOOTERY;
    public static RtfControlWord Ctrl_FOOTNOTE;
    public static RtfControlWord Ctrl_FORMDISP;
    public static RtfControlWord Ctrl_FORMFIELD;
    public static RtfControlWord Ctrl_FORMPROT;
    public static RtfControlWord Ctrl_FORMSHADE;
    public static RtfControlWord Ctrl_FOSNUM;
    public static RtfControlWord Ctrl_FPRQ;
    public static RtfControlWord Ctrl_FRACWIDTH;
    public static RtfControlWord Ctrl_FRELATIVE;
    public static RtfControlWord Ctrl_FRMTXBTLR;
    public static RtfControlWord Ctrl_FRMTXLRTB;
    public static RtfControlWord Ctrl_FRMTXLRTBV;
    public static RtfControlWord Ctrl_FRMTXTBRL;
    public static RtfControlWord Ctrl_FRMTXTBRLV;
    public static RtfControlWord Ctrl_FROMAN;
    public static RtfControlWord Ctrl_FROMHTML;
    public static RtfControlWord Ctrl_FROMTEXT;
    public static RtfControlWord Ctrl_FS;
    public static RtfControlWord Ctrl_FSCRIPT;
    public static RtfControlWord Ctrl_FSWISS;
    public static RtfControlWord Ctrl_FTNALT;
    public static RtfControlWord Ctrl_FTNBJ;
    public static RtfControlWord Ctrl_FTNCN;
    public static RtfControlWord Ctrl_FTNIL;
    public static RtfControlWord Ctrl_FTNLYTWNINE;
    public static RtfControlWord Ctrl_FTNNALC;
    public static RtfControlWord Ctrl_FTNNAR;
    public static RtfControlWord Ctrl_FTNNAUC;
    public static RtfControlWord Ctrl_FTNNCHI;
    public static RtfControlWord Ctrl_FTNNCHOSUNG;
    public static RtfControlWord Ctrl_FTNNCNUM;
    public static RtfControlWord Ctrl_FTNNDBAR;
    public static RtfControlWord Ctrl_FTNNDBNUM;
    public static RtfControlWord Ctrl_FTNNDBNUMD;
    public static RtfControlWord Ctrl_FTNNDBNUMK;
    public static RtfControlWord Ctrl_FTNNDBNUMT;
    public static RtfControlWord Ctrl_FTNNGANADA;
    public static RtfControlWord Ctrl_FTNNGBNUM;
    public static RtfControlWord Ctrl_FTNNGBNUMD;
    public static RtfControlWord Ctrl_FTNNGBNUMK;
    public static RtfControlWord Ctrl_FTNNGBNUML;
    public static RtfControlWord Ctrl_FTNNRLC;
    public static RtfControlWord Ctrl_FTNNRUC;
    public static RtfControlWord Ctrl_FTNNZODIAC;
    public static RtfControlWord Ctrl_FTNNZODIACD;
    public static RtfControlWord Ctrl_FTNNZODIACL;
    public static RtfControlWord Ctrl_FTNRESTART;
    public static RtfControlWord Ctrl_FTNRSTCONT;
    public static RtfControlWord Ctrl_FTNRSTPG;
    public static RtfControlWord Ctrl_FTNSEP;
    public static RtfControlWord Ctrl_FTNSEPC;
    public static RtfControlWord Ctrl_FTNSTART;
    public static RtfControlWord Ctrl_FTNTJ;
    public static RtfControlWord Ctrl_FTTRUETYPE;
    public static RtfControlWord Ctrl_FVALIDDOS;
    public static RtfControlWord Ctrl_FVALIDHPFS;
    public static RtfControlWord Ctrl_FVALIDMAC;
    public static RtfControlWord Ctrl_FVALIDNTFS;
    public static RtfControlWord Ctrl_G;
    public static RtfControlWord Ctrl_GCW;
    public static RtfControlWord Ctrl_GREEN;
    public static RtfControlWord Ctrl_GRIDTBL;
    public static RtfControlWord Ctrl_GUTTER;
    public static RtfControlWord Ctrl_GUTTERPRL;
    public static RtfControlWord Ctrl_GUTTERSXN;
    public static RtfControlWord Ctrl_HEADER;
    public static RtfControlWord Ctrl_HEADERF;
    public static RtfControlWord Ctrl_HEADERL;
    public static RtfControlWord Ctrl_HEADERR;
    public static RtfControlWord Ctrl_HEADERY;
    public static RtfControlWord Ctrl_HICH;
    public static RtfControlWord Ctrl_HIGHLIGHT;
    public static RtfControlWord Ctrl_HLFR;
    public static RtfControlWord Ctrl_HLINKBASE;
    public static RtfControlWord Ctrl_HLLOC;
    public static RtfControlWord Ctrl_HLSRC;
    public static RtfControlWord Ctrl_HORZDOC;
    public static RtfControlWord Ctrl_HORZSECT;
    public static RtfControlWord Ctrl_HR;
    public static RtfControlWord Ctrl_HTMAUTSP;
    public static RtfControlWord Ctrl_HTMLBASE;
    public static RtfControlWord Ctrl_HTMLRTF;
    public static RtfControlWord Ctrl_HTMLTAG;
    public static RtfControlWord Ctrl_HYPHAUTO;
    public static RtfControlWord Ctrl_HYPHCAPS;
    public static RtfControlWord Ctrl_HYPHCONSEC;
    public static RtfControlWord Ctrl_HYPHHOTZ;
    public static RtfControlWord Ctrl_HYPHPAR;
    public static RtfControlWord Ctrl_I;
    public static RtfControlWord Ctrl_ID;
    public static RtfControlWord Ctrl_ILVL;
    public static RtfControlWord Ctrl_IMPR;
    public static RtfControlWord Ctrl_INFO;
    public static RtfControlWord Ctrl_INTBL;
    public static RtfControlWord Ctrl_ITAP;
    public static RtfControlWord Ctrl_IXE;
    public static RtfControlWord Ctrl_JCOMPRESS;
    public static RtfControlWord Ctrl_JEXPAND;
    public static RtfControlWord Ctrl_JPEGBLIP;
    public static RtfControlWord Ctrl_JSKSU;
    public static RtfControlWord Ctrl_KEEP;
    public static RtfControlWord Ctrl_KEEPN;
    public static RtfControlWord Ctrl_KERNING;
    public static RtfControlWord Ctrl_KEYCODE;
    public static RtfControlWord Ctrl_KEYWORDS;
    public static RtfControlWord Ctrl_KSULANG;
    public static RtfControlWord Ctrl_LANDSCAPE;
    public static RtfControlWord Ctrl_LANG;
    public static RtfControlWord Ctrl_LANGFE;
    public static RtfControlWord Ctrl_LANGFENP;
    public static RtfControlWord Ctrl_LANGNP;
    public static RtfControlWord Ctrl_LBR;
    public static RtfControlWord Ctrl_LCHARS;
    public static RtfControlWord Ctrl_LDBLQUOTE;
    public static RtfControlWord Ctrl_LEVEL;
    public static RtfControlWord Ctrl_LEVELFOLLOW;
    public static RtfControlWord Ctrl_LEVELINDENT;
    public static RtfControlWord Ctrl_LEVELJC;
    public static RtfControlWord Ctrl_LEVELJCN;
    public static RtfControlWord Ctrl_LEVELLEGAL;
    public static RtfControlWord Ctrl_LEVELNFC;
    public static RtfControlWord Ctrl_LEVELNFCN;
    public static RtfControlWord Ctrl_LEVELNORESTART;
    public static RtfControlWord Ctrl_LEVELNUMBERS;
    public static RtfControlWord Ctrl_LEVELOLD;
    public static RtfControlWord Ctrl_LEVELPREV;
    public static RtfControlWord Ctrl_LEVELPREVSPACE;
    public static RtfControlWord Ctrl_LEVELSPACE;
    public static RtfControlWord Ctrl_LEVELSTARTAT;
    public static RtfControlWord Ctrl_LEVELTEMPLATEID;
    public static RtfControlWord Ctrl_LEVELTEXT;
    public static RtfControlWord Ctrl_LFOLEVEL;
    public static RtfControlWord Ctrl_LI;
    public static RtfControlWord Ctrl_LINE;
    public static RtfControlWord Ctrl_LINEBETCOL;
    public static RtfControlWord Ctrl_LINECONT;
    public static RtfControlWord Ctrl_LINEMOD;
    public static RtfControlWord Ctrl_LINEPPAGE;
    public static RtfControlWord Ctrl_LINERESTART;
    public static RtfControlWord Ctrl_LINESTART;
    public static RtfControlWord Ctrl_LINESTARTS;
    public static RtfControlWord Ctrl_LINEX;
    public static RtfControlWord Ctrl_LINKSELF;
    public static RtfControlWord Ctrl_LINKSTYLES;
    public static RtfControlWord Ctrl_LINKVAL;
    public static RtfControlWord Ctrl_LIN;
    public static RtfControlWord Ctrl_LISA;
    public static RtfControlWord Ctrl_LISB;
    public static RtfControlWord Ctrl_LIST;
    public static RtfControlWord Ctrl_LISTHYBRID;
    public static RtfControlWord Ctrl_LISTID;
    public static RtfControlWord Ctrl_LISTLEVEL;
    public static RtfControlWord Ctrl_LISTNAME;
    public static RtfControlWord Ctrl_LISTOVERRIDE;
    public static RtfControlWord Ctrl_LISTOVERRIDECOUNT;
    public static RtfControlWord Ctrl_LISTOVERRIDEFORMAT;
    public static RtfControlWord Ctrl_LISTOVERRIDESTART;
    public static RtfControlWord Ctrl_LISTPICTURE;
    public static RtfControlWord Ctrl_LISTRESTARTHDN;
    public static RtfControlWord Ctrl_LISTSIMPLE;
    public static RtfControlWord Ctrl_LISTTABLE;
    public static RtfControlWord Ctrl_LISTOVERRIDETABLE;
    public static RtfControlWord Ctrl_LISTTEMPLATEID;
    public static RtfControlWord Ctrl_LISTTEXT;
    public static RtfControlWord Ctrl_LNBRKRULE;
    public static RtfControlWord Ctrl_LNDSCPSXN;
    public static RtfControlWord Ctrl_LNONGRID;
    public static RtfControlWord Ctrl_LOCH;
    public static RtfControlWord Ctrl_LQUOTE;
    public static RtfControlWord Ctrl_LS;
    public static RtfControlWord Ctrl_LTRCH;
    public static RtfControlWord Ctrl_LTRDOC;
    public static RtfControlWord Ctrl_LTRMARK;
    public static RtfControlWord Ctrl_LTRPAR;
    public static RtfControlWord Ctrl_LTRROW;
    public static RtfControlWord Ctrl_LTRSECT;
    public static RtfControlWord Ctrl_LYTCALCTBLWD;
    public static RtfControlWord Ctrl_LYTEXCTTP;
    public static RtfControlWord Ctrl_LYTPRTMET;
    public static RtfControlWord Ctrl_LYTTBLRTGR;
    public static RtfControlWord Ctrl_MAC;
    public static RtfControlWord Ctrl_MACPICT;
    public static RtfControlWord Ctrl_MAKEBACKUP;
    public static RtfControlWord Ctrl_MANAGER;
    public static RtfControlWord Ctrl_MARGB;
    public static RtfControlWord Ctrl_MARGBSXN;
    public static RtfControlWord Ctrl_MARGL;
    public static RtfControlWord Ctrl_MARGLSXN;
    public static RtfControlWord Ctrl_MARGMIRROR;
    public static RtfControlWord Ctrl_MARGR;
    public static RtfControlWord Ctrl_MARGRSXN;
    public static RtfControlWord Ctrl_MARGT;
    public static RtfControlWord Ctrl_MARGTSXN;
    public static RtfControlWord Ctrl_MHTMLTAG;
    public static RtfControlWord Ctrl_MIN;
    public static RtfControlWord Ctrl_MO;
    public static RtfControlWord Ctrl_MSMCAP;
    public static RtfControlWord Ctrl_NESTCELL;
    public static RtfControlWord Ctrl_NESTROW;
    public static RtfControlWord Ctrl_NESTTABLEPROPS;
    public static RtfControlWord Ctrl_NEXTFILE;
    public static RtfControlWord Ctrl_NOCOLBAL;
    public static RtfControlWord Ctrl_NOCWRAP;
    public static RtfControlWord Ctrl_NOEXTRASPRL;
    public static RtfControlWord Ctrl_NOFCHARS;
    public static RtfControlWord Ctrl_NOFCHARSWS;
    public static RtfControlWord Ctrl_NOFPAGES;
    public static RtfControlWord Ctrl_NOFWORDS;
    public static RtfControlWord Ctrl_NOLEAD;
    public static RtfControlWord Ctrl_NOLINE;
    public static RtfControlWord Ctrl_NOLNHTADJTBL;
    public static RtfControlWord Ctrl_NONESTTABLES;
    public static RtfControlWord Ctrl_NONSHPPICT;
    public static RtfControlWord Ctrl_NOOVERFLOW;
    public static RtfControlWord Ctrl_NOPROOF;
    public static RtfControlWord Ctrl_NOSECTEXPAND;
    public static RtfControlWord Ctrl_NOSNAPLINEGRID;
    public static RtfControlWord Ctrl_NOSPACEFORUL;
    public static RtfControlWord Ctrl_NOSUPERSUB;
    public static RtfControlWord Ctrl_NOTABIND;
    public static RtfControlWord Ctrl_NOULTRLSPC;
    public static RtfControlWord Ctrl_NOWIDCTLPAR;
    public static RtfControlWord Ctrl_NOWRAP;
    public static RtfControlWord Ctrl_NOWWRAP;
    public static RtfControlWord Ctrl_NOXLATTOYEN;
    public static RtfControlWord Ctrl_OBJALIAS;
    public static RtfControlWord Ctrl_OBJALIGN;
    public static RtfControlWord Ctrl_OBJATTPH;
    public static RtfControlWord Ctrl_OBJAUTLINK;
    public static RtfControlWord Ctrl_OBJCLASS;
    public static RtfControlWord Ctrl_OBJCROPB;
    public static RtfControlWord Ctrl_OBJCROPL;
    public static RtfControlWord Ctrl_OBJCROPR;
    public static RtfControlWord Ctrl_OBJCROPT;
    public static RtfControlWord Ctrl_OBJDATA;
    public static RtfControlWord Ctrl_OBJECT;
    public static RtfControlWord Ctrl_OBJEMB;
    public static RtfControlWord Ctrl_OBJH;
    public static RtfControlWord Ctrl_OBJHTML;
    public static RtfControlWord Ctrl_OBJICEMB;
    public static RtfControlWord Ctrl_OBJLINK;
    public static RtfControlWord Ctrl_OBJLOCK;
    public static RtfControlWord Ctrl_OBJNAME;
    public static RtfControlWord Ctrl_OBJOCX;
    public static RtfControlWord Ctrl_OBJPUB;
    public static RtfControlWord Ctrl_OBJSCALEX;
    public static RtfControlWord Ctrl_OBJSCALEY;
    public static RtfControlWord Ctrl_OBJSECT;
    public static RtfControlWord Ctrl_OBJSETSIZE;
    public static RtfControlWord Ctrl_OBJSUB;
    public static RtfControlWord Ctrl_OBJTIME;
    public static RtfControlWord Ctrl_OBJTRANSY;
    public static RtfControlWord Ctrl_OBJUPDATE;
    public static RtfControlWord Ctrl_OBJW;
    public static RtfControlWord Ctrl_OLDAS;
    public static RtfControlWord Ctrl_OLDLINEWRAP;
    public static RtfControlWord Ctrl_OPERATOR;
    public static RtfControlWord Ctrl_OTBLRUL;
    public static RtfControlWord Ctrl_OUTL;
    public static RtfControlWord Ctrl_OUTLINELEVEL;
    public static RtfControlWord Ctrl_OVERLAY;
    public static RtfControlWord Ctrl_PAGE;
    public static RtfControlWord Ctrl_PAGEBB;
    public static RtfControlWord Ctrl_PANOSE;
    public static RtfControlWord Ctrl_PAPERH;
    public static RtfControlWord Ctrl_PAPERW;
    public static RtfControlWord Ctrl_PAR;
    public static RtfControlWord Ctrl_PARD;
    public static RtfControlWord Ctrl_PC;
    public static RtfControlWord Ctrl_PCA;
    public static RtfControlWord Ctrl_PGBRDRB;
    public static RtfControlWord Ctrl_PGBRDRFOOT;
    public static RtfControlWord Ctrl_PGBRDRHEAD;
    public static RtfControlWord Ctrl_PGBRDRL;
    public static RtfControlWord Ctrl_PGBRDROPT;
    public static RtfControlWord Ctrl_PGBRDRR;
    public static RtfControlWord Ctrl_PGBRDRSNAP;
    public static RtfControlWord Ctrl_PGBRDRT;
    public static RtfControlWord Ctrl_PGHSXN;
    public static RtfControlWord Ctrl_PGNBIDIA;
    public static RtfControlWord Ctrl_PGNBIDIB;
    public static RtfControlWord Ctrl_PGNCHOSUNG;
    public static RtfControlWord Ctrl_PGNCNUM;
    public static RtfControlWord Ctrl_PGNCONT;
    public static RtfControlWord Ctrl_PGNDBNUM;
    public static RtfControlWord Ctrl_PGNDBNUMD;
    public static RtfControlWord Ctrl_PGNDBNUMK;
    public static RtfControlWord Ctrl_PGNDBNUMT;
    public static RtfControlWord Ctrl_PGNDEC;
    public static RtfControlWord Ctrl_PGNDECD;
    public static RtfControlWord Ctrl_PGNGANADA;
    public static RtfControlWord Ctrl_PGNGBNUM;
    public static RtfControlWord Ctrl_PGNGBNUMD;
    public static RtfControlWord Ctrl_PGNGBNUMK;
    public static RtfControlWord Ctrl_PGNGBNUML;
    public static RtfControlWord Ctrl_PGNHN;
    public static RtfControlWord Ctrl_PGNHNSC;
    public static RtfControlWord Ctrl_PGNHNSH;
    public static RtfControlWord Ctrl_PGNHNSM;
    public static RtfControlWord Ctrl_PGNHNSN;
    public static RtfControlWord Ctrl_PGNHNSP;
    public static RtfControlWord Ctrl_PGNLCLTR;
    public static RtfControlWord Ctrl_PGNLCRM;
    public static RtfControlWord Ctrl_PGNRESTART;
    public static RtfControlWord Ctrl_PGNSTART;
    public static RtfControlWord Ctrl_PGNSTARTS;
    public static RtfControlWord Ctrl_PGNUCLTR;
    public static RtfControlWord Ctrl_PGNUCRM;
    public static RtfControlWord Ctrl_PGNX;
    public static RtfControlWord Ctrl_PGNY;
    public static RtfControlWord Ctrl_PGNZODIAC;
    public static RtfControlWord Ctrl_PGNZODIACD;
    public static RtfControlWord Ctrl_PGNZODIACL;
    public static RtfControlWord Ctrl_PGWSXN;
    public static RtfControlWord Ctrl_PHCOL;
    public static RtfControlWord Ctrl_PHMRG;
    public static RtfControlWord Ctrl_PHPG;
    public static RtfControlWord Ctrl_PICBMP;
    public static RtfControlWord Ctrl_PICBPP;
    public static RtfControlWord Ctrl_PICCROPB;
    public static RtfControlWord Ctrl_PICCROPL;
    public static RtfControlWord Ctrl_PICCROPR;
    public static RtfControlWord Ctrl_PICCROPT;
    public static RtfControlWord Ctrl_PICH;
    public static RtfControlWord Ctrl_PICHGOAL;
    public static RtfControlWord Ctrl_PICPROP;
    public static RtfControlWord Ctrl_PICSCALED;
    public static RtfControlWord Ctrl_PICSCALEX;
    public static RtfControlWord Ctrl_PICSCALEY;
    public static RtfControlWord Ctrl_PICT;
    public static RtfControlWord Ctrl_PICW;
    public static RtfControlWord Ctrl_PICWGOAL;
    public static RtfControlWord Ctrl_PLAIN;
    public static RtfControlWord Ctrl_PMMETAFILE;
    public static RtfControlWord Ctrl_PN;
    public static RtfControlWord Ctrl_PNACROSS;
    public static RtfControlWord Ctrl_PNAIU;
    public static RtfControlWord Ctrl_PNAIUD;
    public static RtfControlWord Ctrl_PNAIUEO;
    public static RtfControlWord Ctrl_PNAIUEOD;
    public static RtfControlWord Ctrl_PNB;
    public static RtfControlWord Ctrl_PNBIDIA;
    public static RtfControlWord Ctrl_PNBIDIB;
    public static RtfControlWord Ctrl_PNCAPS;
    public static RtfControlWord Ctrl_PNCARD;
    public static RtfControlWord Ctrl_PNCF;
    public static RtfControlWord Ctrl_PNCHOSUNG;
    public static RtfControlWord Ctrl_PNCNUM;
    public static RtfControlWord Ctrl_PNDBNUM;
    public static RtfControlWord Ctrl_PNDBNUMD;
    public static RtfControlWord Ctrl_PNDBNUMK;
    public static RtfControlWord Ctrl_PNDBNUML;
    public static RtfControlWord Ctrl_PNDBNUMT;
    public static RtfControlWord Ctrl_PNDEC;
    public static RtfControlWord Ctrl_PNDECD;
    public static RtfControlWord Ctrl_PNF;
    public static RtfControlWord Ctrl_PNFS;
    public static RtfControlWord Ctrl_PNGANADA;
    public static RtfControlWord Ctrl_PNGBLIP;
    public static RtfControlWord Ctrl_PNGBNUM;
    public static RtfControlWord Ctrl_PNGBNUMD;
    public static RtfControlWord Ctrl_PNGBNUMK;
    public static RtfControlWord Ctrl_PNGBNUML;
    public static RtfControlWord Ctrl_PNHANG;
    public static RtfControlWord Ctrl_PNI;
    public static RtfControlWord Ctrl_PNINDENT;
    public static RtfControlWord Ctrl_PNIROHA;
    public static RtfControlWord Ctrl_PNIROHAD;
    public static RtfControlWord Ctrl_PNLCLTR;
    public static RtfControlWord Ctrl_PNLCRM;
    public static RtfControlWord Ctrl_PNLVL;
    public static RtfControlWord Ctrl_PNLVLBLT;
    public static RtfControlWord Ctrl_PNLVLBODY;
    public static RtfControlWord Ctrl_PNLVLCONT;
    public static RtfControlWord Ctrl_PNNUMONCE;
    public static RtfControlWord Ctrl_PNORD;
    public static RtfControlWord Ctrl_PNORDT;
    public static RtfControlWord Ctrl_PNPREV;
    public static RtfControlWord Ctrl_PNQC;
    public static RtfControlWord Ctrl_PNQL;
    public static RtfControlWord Ctrl_PNQR;
    public static RtfControlWord Ctrl_PNRAUTH;
    public static RtfControlWord Ctrl_PNRDATE;
    public static RtfControlWord Ctrl_PNRESTART;
    public static RtfControlWord Ctrl_PNRNFC;
    public static RtfControlWord Ctrl_PNRNOT;
    public static RtfControlWord Ctrl_PNRPNBR;
    public static RtfControlWord Ctrl_PNRRGB;
    public static RtfControlWord Ctrl_PNRSTART;
    public static RtfControlWord Ctrl_PNRSTOP;
    public static RtfControlWord Ctrl_PNRXST;
    public static RtfControlWord Ctrl_PNSCAPS;
    public static RtfControlWord Ctrl_PNSECLVL;
    public static RtfControlWord Ctrl_PNSP;
    public static RtfControlWord Ctrl_PNSTART;
    public static RtfControlWord Ctrl_PNSTRIKE;
    public static RtfControlWord Ctrl_PNTEXT;
    public static RtfControlWord Ctrl_PNTXTA;
    public static RtfControlWord Ctrl_PNTXTB;
    public static RtfControlWord Ctrl_PNUCLTR;
    public static RtfControlWord Ctrl_PNUCRM;
    public static RtfControlWord Ctrl_PNUL;
    public static RtfControlWord Ctrl_PNULD;
    public static RtfControlWord Ctrl_PNULDASH;
    public static RtfControlWord Ctrl_PNULDASHD;
    public static RtfControlWord Ctrl_PNULDASHDD;
    public static RtfControlWord Ctrl_PNULDB;
    public static RtfControlWord Ctrl_PNULHAIR;
    public static RtfControlWord Ctrl_PNULNONE;
    public static RtfControlWord Ctrl_PNULTH;
    public static RtfControlWord Ctrl_PNULW;
    public static RtfControlWord Ctrl_PNULWAVE;
    public static RtfControlWord Ctrl_PNZODIAC;
    public static RtfControlWord Ctrl_PNZODIACD;
    public static RtfControlWord Ctrl_PNZODIACL;
    public static RtfControlWord Ctrl_POSNEGX;
    public static RtfControlWord Ctrl_POSNEGY;
    public static RtfControlWord Ctrl_POSX;
    public static RtfControlWord Ctrl_POSXC;
    public static RtfControlWord Ctrl_POSXI;
    public static RtfControlWord Ctrl_POSXL;
    public static RtfControlWord Ctrl_POSXO;
    public static RtfControlWord Ctrl_POSXR;
    public static RtfControlWord Ctrl_POSY;
    public static RtfControlWord Ctrl_POSYB;
    public static RtfControlWord Ctrl_POSYC;
    public static RtfControlWord Ctrl_POSYIL;
    public static RtfControlWord Ctrl_POSYIN;
    public static RtfControlWord Ctrl_POSYOUT;
    public static RtfControlWord Ctrl_POSYT;
    public static RtfControlWord Ctrl_PRCOLBL;
    public static RtfControlWord Ctrl_PRINTDATA;
    public static RtfControlWord Ctrl_PRINTIM;
    public static RtfControlWord Ctrl_PRIVATE;
    public static RtfControlWord Ctrl_PROPNAME;
    public static RtfControlWord Ctrl_PROPTYPE;
    public static RtfControlWord Ctrl_PSOVER;
    public static RtfControlWord Ctrl_PSZ;
    public static RtfControlWord Ctrl_PUBAUTO;
    public static RtfControlWord Ctrl_PVMRG;
    public static RtfControlWord Ctrl_PVPARA;
    public static RtfControlWord Ctrl_PVPG;
    public static RtfControlWord Ctrl_PWD;
    public static RtfControlWord Ctrl_PXE;
    public static RtfControlWord Ctrl_QC;
    public static RtfControlWord Ctrl_QD;
    public static RtfControlWord Ctrl_QJ;
    public static RtfControlWord Ctrl_QL;
    public static RtfControlWord Ctrl_QMSPACE;
    public static RtfControlWord Ctrl_QR;
    public static RtfControlWord Ctrl_RDBLQUOTE;
    public static RtfControlWord Ctrl_RED;
    public static RtfControlWord Ctrl_RESULT;
    public static RtfControlWord Ctrl_REVAUTH;
    public static RtfControlWord Ctrl_REVAUTHDEL;
    public static RtfControlWord Ctrl_REVBAR;
    public static RtfControlWord Ctrl_REVDTTM;
    public static RtfControlWord Ctrl_REVDTTMDEL;
    public static RtfControlWord Ctrl_REVISED;
    public static RtfControlWord Ctrl_REVISIONS;
    public static RtfControlWord Ctrl_REVPROP;
    public static RtfControlWord Ctrl_REVPROT;
    public static RtfControlWord Ctrl_REVTBL;
    public static RtfControlWord Ctrl_REVTIM;
    public static RtfControlWord Ctrl_RI;
    public static RtfControlWord Ctrl_RIN;
    public static RtfControlWord Ctrl_ROW;
    public static RtfControlWord Ctrl_RQUOTE;
    public static RtfControlWord Ctrl_RSLTBMP;
    public static RtfControlWord Ctrl_RSLTHTML;
    public static RtfControlWord Ctrl_RSLTMERGE;
    public static RtfControlWord Ctrl_RSLTPICT;
    public static RtfControlWord Ctrl_RSLTRTF;
    public static RtfControlWord Ctrl_RSLTTXT;
    public static RtfControlWord Ctrl_RTF;
    public static RtfControlWord Ctrl_RTLCH;
    public static RtfControlWord Ctrl_RTLDOC;
    public static RtfControlWord Ctrl_RTLGUTTER;
    public static RtfControlWord Ctrl_RTLMARK;
    public static RtfControlWord Ctrl_RTLPAR;
    public static RtfControlWord Ctrl_RTLROW;
    public static RtfControlWord Ctrl_RTLSECT;
    public static RtfControlWord Ctrl_RXE;
    public static RtfControlWord Ctrl_S;
    public static RtfControlWord Ctrl_SA;
    public static RtfControlWord Ctrl_SAAUTO;
    public static RtfControlWord Ctrl_SAUTOUPD;
    public static RtfControlWord Ctrl_SB;
    public static RtfControlWord Ctrl_SBASEDON;
    public static RtfControlWord Ctrl_SBAUTO;
    public static RtfControlWord Ctrl_SBKCOL;
    public static RtfControlWord Ctrl_SBKEVEN;
    public static RtfControlWord Ctrl_SBKNONE;
    public static RtfControlWord Ctrl_SBKODD;
    public static RtfControlWord Ctrl_SBKPAGE;
    public static RtfControlWord Ctrl_SBYS;
    public static RtfControlWord Ctrl_SCAPS;
    public static RtfControlWord Ctrl_SCOMPOSE;
    public static RtfControlWord Ctrl_SEC;
    public static RtfControlWord Ctrl_SECT;
    public static RtfControlWord Ctrl_SECTD;
    public static RtfControlWord Ctrl_SECTDEFAULTCL;
    public static RtfControlWord Ctrl_SECTEXPAND;
    public static RtfControlWord Ctrl_SECTLINEGRID;
    public static RtfControlWord Ctrl_SECTNUM;
    public static RtfControlWord Ctrl_SECTSPECIFYCL;
    public static RtfControlWord Ctrl_SECTSPECIFYGEN;
    public static RtfControlWord Ctrl_SECTSPECIFYL;
    public static RtfControlWord Ctrl_SECTUNLOCKED;
    public static RtfControlWord Ctrl_SHAD;
    public static RtfControlWord Ctrl_SHADING;
    public static RtfControlWord Ctrl_SHIDDEN;
    public static RtfControlWord Ctrl_SHIFT;
    public static RtfControlWord Ctrl_SHPBOTTOM;
    public static RtfControlWord Ctrl_SHPBXCOLUMN;
    public static RtfControlWord Ctrl_SHPBXIGNORE;
    public static RtfControlWord Ctrl_SHPBXMARGIN;
    public static RtfControlWord Ctrl_SHPBXPAGE;
    public static RtfControlWord Ctrl_SHPBYIGNORE;
    public static RtfControlWord Ctrl_SHPBYMARGIN;
    public static RtfControlWord Ctrl_SHPBYPAGE;
    public static RtfControlWord Ctrl_SHPBYPARA;
    public static RtfControlWord Ctrl_SHPFBLWTXT;
    public static RtfControlWord Ctrl_SHPFHDR;
    public static RtfControlWord Ctrl_SHPGRP;
    public static RtfControlWord Ctrl_SHPINST;
    public static RtfControlWord Ctrl_SHPLEFT;
    public static RtfControlWord Ctrl_SHPLID;
    public static RtfControlWord Ctrl_SHPLOCKANCHOR;
    public static RtfControlWord Ctrl_SHPPICT;
    public static RtfControlWord Ctrl_SHPRIGHT;
    public static RtfControlWord Ctrl_SHPRSLT;
    public static RtfControlWord Ctrl_SHPTOP;
    public static RtfControlWord Ctrl_SHPTXT;
    public static RtfControlWord Ctrl_SHPWRK;
    public static RtfControlWord Ctrl_SHPWR;
    public static RtfControlWord Ctrl_SHPZ;
    public static RtfControlWord Ctrl_SL;
    public static RtfControlWord Ctrl_SLMULT;
    public static RtfControlWord Ctrl_SNEXT;
    public static RtfControlWord Ctrl_SOFTCOL;
    public static RtfControlWord Ctrl_SOFTLHEIGHT;
    public static RtfControlWord Ctrl_SOFTLINE;
    public static RtfControlWord Ctrl_SOFTPAGE;
    public static RtfControlWord Ctrl_SPERSONAL;
    public static RtfControlWord Ctrl_SPLYTWNINE;
    public static RtfControlWord Ctrl_SPRSBSP;
    public static RtfControlWord Ctrl_SPRSLNSP;
    public static RtfControlWord Ctrl_SPRSSPBF;
    public static RtfControlWord Ctrl_SPRSTSM;
    public static RtfControlWord Ctrl_SPRSTSP;
    public static RtfControlWord Ctrl_SREPLY;
    public static RtfControlWord Ctrl_STATICVAL;
    public static RtfControlWord Ctrl_STEXTFLOW;
    public static RtfControlWord Ctrl_STRIKE;
    public static RtfControlWord Ctrl_STRIKED;
    public static RtfControlWord Ctrl_STYLESHEET;
    public static RtfControlWord Ctrl_SUB;
    public static RtfControlWord Ctrl_SUBDOCUMENT;
    public static RtfControlWord Ctrl_SUBFONTBYSIZE;
    public static RtfControlWord Ctrl_SUBJECT;
    public static RtfControlWord Ctrl_SUPER;
    public static RtfControlWord Ctrl_SWPBDR;
    public static RtfControlWord Ctrl_TAB;
    public static RtfControlWord Ctrl_TABSNOOVRLP;
    public static RtfControlWord Ctrl_TAPRTL;
    public static RtfControlWord Ctrl_TB;
    public static RtfControlWord Ctrl_TC;
    public static RtfControlWord Ctrl_TCELLD;
    public static RtfControlWord Ctrl_TCF;
    public static RtfControlWord Ctrl_TCL;
    public static RtfControlWord Ctrl_TCN;
    public static RtfControlWord Ctrl_TDFRMTXTBOTTOM;
    public static RtfControlWord Ctrl_TDFRMTXTLEFT;
    public static RtfControlWord Ctrl_TDFRMTXTRIGHT;
    public static RtfControlWord Ctrl_TDFRMTXTTOP;
    public static RtfControlWord Ctrl_TEMPLATE;
    public static RtfControlWord Ctrl_TIME;
    public static RtfControlWord Ctrl_TITLE;
    public static RtfControlWord Ctrl_TITLEPG;
    public static RtfControlWord Ctrl_TLDOT;
    public static RtfControlWord Ctrl_TLEQ;
    public static RtfControlWord Ctrl_TLHYPH;
    public static RtfControlWord Ctrl_TLMDOT;
    public static RtfControlWord Ctrl_TLTH;
    public static RtfControlWord Ctrl_TLUL;
    public static RtfControlWord Ctrl_TPHCOL;
    public static RtfControlWord Ctrl_TPHMRG;
    public static RtfControlWord Ctrl_TPHPG;
    public static RtfControlWord Ctrl_TPOSNEGX;
    public static RtfControlWord Ctrl_TPOSNEGY;
    public static RtfControlWord Ctrl_TPOSXC;
    public static RtfControlWord Ctrl_TPOSXI;
    public static RtfControlWord Ctrl_TPOSXL;
    public static RtfControlWord Ctrl_TPOSX;
    public static RtfControlWord Ctrl_TPOSXO;
    public static RtfControlWord Ctrl_TPOSXR;
    public static RtfControlWord Ctrl_TPOSY;
    public static RtfControlWord Ctrl_TPOSYB;
    public static RtfControlWord Ctrl_TPOSYC;
    public static RtfControlWord Ctrl_TPOSYIL;
    public static RtfControlWord Ctrl_TPOSYIN;
    public static RtfControlWord Ctrl_TPOSYOUTV;
    public static RtfControlWord Ctrl_TPOSYT;
    public static RtfControlWord Ctrl_TPVMRG;
    public static RtfControlWord Ctrl_TPVPARA;
    public static RtfControlWord Ctrl_TPVPG;
    public static RtfControlWord Ctrl_TQC;
    public static RtfControlWord Ctrl_TQDEC;
    public static RtfControlWord Ctrl_TQR;
    public static RtfControlWord Ctrl_TRANSMF;
    public static RtfControlWord Ctrl_TRAUTOFIT;
    public static RtfControlWord Ctrl_TRBRDRB;
    public static RtfControlWord Ctrl_TRBRDRH;
    public static RtfControlWord Ctrl_TRBRDRL;
    public static RtfControlWord Ctrl_TRBRDRR;
    public static RtfControlWord Ctrl_TRBRDRT;
    public static RtfControlWord Ctrl_TRBRDRV;
    public static RtfControlWord Ctrl_TRFTSWIDTHA;
    public static RtfControlWord Ctrl_TRFTSWIDTHB;
    public static RtfControlWord Ctrl_TRFTSWIDTH;
    public static RtfControlWord Ctrl_TRGAPH;
    public static RtfControlWord Ctrl_TRHDR;
    public static RtfControlWord Ctrl_TRKEEP;
    public static RtfControlWord Ctrl_TRLEFT;
    public static RtfControlWord Ctrl_TROWD;
    public static RtfControlWord Ctrl_TRPADDB;
    public static RtfControlWord Ctrl_TRPADDFB;
    public static RtfControlWord Ctrl_TRPADDFL;
    public static RtfControlWord Ctrl_TRPADDFR;
    public static RtfControlWord Ctrl_TRPADDFT;
    public static RtfControlWord Ctrl_TRPADDL;
    public static RtfControlWord Ctrl_TRPADDR;
    public static RtfControlWord Ctrl_TRPADDT;
    public static RtfControlWord Ctrl_TRQC;
    public static RtfControlWord Ctrl_TRQL;
    public static RtfControlWord Ctrl_TRQR;
    public static RtfControlWord Ctrl_TRRH;
    public static RtfControlWord Ctrl_TRSPDB;
    public static RtfControlWord Ctrl_TRSPDFB;
    public static RtfControlWord Ctrl_TRSPDFL;
    public static RtfControlWord Ctrl_TRSPDFR;
    public static RtfControlWord Ctrl_TRSPDFT;
    public static RtfControlWord Ctrl_TRSPDL;
    public static RtfControlWord Ctrl_TRSPDR;
    public static RtfControlWord Ctrl_TRSPDT;
    public static RtfControlWord Ctrl_TRUNCATEFONTHEIGHT;
    public static RtfControlWord Ctrl_TRWWIDTHA;
    public static RtfControlWord Ctrl_TRWWIDTHB;
    public static RtfControlWord Ctrl_TRWWIDTH;
    public static RtfControlWord Ctrl_TWOONONE;
    public static RtfControlWord Ctrl_TX;
    public static RtfControlWord Ctrl_TXE;
    public static RtfControlWord Ctrl_UC;
    public static RtfControlWord Ctrl_UD;
    public static RtfControlWord Ctrl_UL;
    public static RtfControlWord Ctrl_ULC;
    public static RtfControlWord Ctrl_ULD;
    public static RtfControlWord Ctrl_ULDASH;
    public static RtfControlWord Ctrl_ULDASHD;
    public static RtfControlWord Ctrl_ULDASHDD;
    public static RtfControlWord Ctrl_ULDB;
    public static RtfControlWord Ctrl_ULHAIR;
    public static RtfControlWord Ctrl_ULHWAVE;
    public static RtfControlWord Ctrl_ULLDASH;
    public static RtfControlWord Ctrl_ULNONE;
    public static RtfControlWord Ctrl_ULTH;
    public static RtfControlWord Ctrl_ULTHD;
    public static RtfControlWord Ctrl_ULTHDASH;
    public static RtfControlWord Ctrl_ULTHDASHD;
    public static RtfControlWord Ctrl_ULTHDASHDD;
    public static RtfControlWord Ctrl_ULTHLDASH;
    public static RtfControlWord Ctrl_ULULDBWAVE;
    public static RtfControlWord Ctrl_ULW;
    public static RtfControlWord Ctrl_ULWAVE;
    public static RtfControlWord Ctrl_U;
    public static RtfControlWord Ctrl_UP;
    public static RtfControlWord Ctrl_UPR;
    public static RtfControlWord Ctrl_URTF;
    public static RtfControlWord Ctrl_USELTBALN;
    public static RtfControlWord Ctrl_USERPROPS;
    public static RtfControlWord Ctrl_V;
    public static RtfControlWord Ctrl_VERN;
    public static RtfControlWord Ctrl_VERSION;
    public static RtfControlWord Ctrl_VERTALB;
    public static RtfControlWord Ctrl_VERTALC;
    public static RtfControlWord Ctrl_VERTALJ;
    public static RtfControlWord Ctrl_VERTALT;
    public static RtfControlWord Ctrl_VERTDOC;
    public static RtfControlWord Ctrl_VERTSECT;
    public static RtfControlWord Ctrl_VIEWKIND;
    public static RtfControlWord Ctrl_VIEWSCALE;
    public static RtfControlWord Ctrl_VIEWZK;
    public static RtfControlWord Ctrl_WBITMAP;
    public static RtfControlWord Ctrl_WBMBITSPIXEL;
    public static RtfControlWord Ctrl_WBMPLANES;
    public static RtfControlWord Ctrl_WBMWIDTHBYTES;
    public static RtfControlWord Ctrl_WEBHIDDEN;
    public static RtfControlWord Ctrl_WIDCTLPAR;
    public static RtfControlWord Ctrl_WIDOWCTRL;
    public static RtfControlWord Ctrl_WINDOWCAPTION;
    public static RtfControlWord Ctrl_WMETAFILE;
    public static RtfControlWord Ctrl_WPEQN;
    public static RtfControlWord Ctrl_WPJST;
    public static RtfControlWord Ctrl_WPSP;
    public static RtfControlWord Ctrl_WRAPTRSP;
    public static RtfControlWord Ctrl_XE;
    public static RtfControlWord Ctrl_XEF;
    public static RtfControlWord Ctrl_YR;
    public static RtfControlWord Ctrl_YXE;
    public static RtfControlWord Ctrl_ZWBO;
    public static RtfControlWord Ctrl_ZWJ;
    public static RtfControlWord Ctrl_ZWNBO;
    public static RtfControlWord Ctrl_ZWNJ;
}
internal class System.Windows.Documents.RtfControlWordInfo : object {
    private RtfControlWord _controlWord;
    private string _controlName;
    private UInt32 _flags;
    internal RtfControlWord Control { get; }
    internal string ControlName { get; }
    internal UInt32 Flags { get; }
    internal RtfControlWordInfo(RtfControlWord controlWord, string controlName, UInt32 flags);
    internal RtfControlWord get_Control();
    internal string get_ControlName();
    internal UInt32 get_Flags();
}
internal enum System.Windows.Documents.RtfDestination : Enum {
    public int value__;
    public static RtfDestination DestNormal;
    public static RtfDestination DestColorTable;
    public static RtfDestination DestFontTable;
    public static RtfDestination DestFontName;
    public static RtfDestination DestListTable;
    public static RtfDestination DestListOverrideTable;
    public static RtfDestination DestList;
    public static RtfDestination DestListLevel;
    public static RtfDestination DestListOverride;
    public static RtfDestination DestListPicture;
    public static RtfDestination DestListText;
    public static RtfDestination DestUPR;
    public static RtfDestination DestField;
    public static RtfDestination DestFieldInstruction;
    public static RtfDestination DestFieldResult;
    public static RtfDestination DestFieldPrivate;
    public static RtfDestination DestShape;
    public static RtfDestination DestShapeInstruction;
    public static RtfDestination DestShapeResult;
    public static RtfDestination DestShapePicture;
    public static RtfDestination DestNoneShapePicture;
    public static RtfDestination DestPicture;
    public static RtfDestination DestPN;
    public static RtfDestination DestUnknown;
}
internal class System.Windows.Documents.RtfFormatStack : ArrayList {
    internal void Push();
    internal void Pop();
    internal FormatState Top();
    internal FormatState PrevTop(int fromTop);
    internal FormatState EntryAt(int index);
}
internal enum System.Windows.Documents.RtfImageFormat : Enum {
    public int value__;
    public static RtfImageFormat Unknown;
    public static RtfImageFormat Bmp;
    public static RtfImageFormat Dib;
    public static RtfImageFormat Emf;
    public static RtfImageFormat Exif;
    public static RtfImageFormat Gif;
    public static RtfImageFormat Jpeg;
    public static RtfImageFormat Png;
    public static RtfImageFormat Tif;
    public static RtfImageFormat Wmf;
}
internal enum System.Windows.Documents.RtfSuperSubscript : Enum {
    public int value__;
    public static RtfSuperSubscript None;
    public static RtfSuperSubscript Normal;
    public static RtfSuperSubscript Super;
    public static RtfSuperSubscript Sub;
}
internal class System.Windows.Documents.RtfToken : object {
    internal static long INVALID_PARAMETER;
    private RtfTokenType _type;
    private RtfControlWordInfo _rtfControlWordInfo;
    private long _parameter;
    private string _text;
    internal RtfTokenType Type { get; internal set; }
    internal RtfControlWordInfo RtfControlWordInfo { get; internal set; }
    internal long Parameter { get; internal set; }
    internal string Text { get; internal set; }
    internal long ToggleValue { get; }
    internal bool FlagValue { get; }
    internal bool HasParameter { get; }
    internal void Empty();
    internal RtfTokenType get_Type();
    internal void set_Type(RtfTokenType value);
    internal RtfControlWordInfo get_RtfControlWordInfo();
    internal void set_RtfControlWordInfo(RtfControlWordInfo value);
    internal long get_Parameter();
    internal void set_Parameter(long value);
    internal string get_Text();
    internal void set_Text(string value);
    internal long get_ToggleValue();
    internal bool get_FlagValue();
    internal bool get_HasParameter();
}
internal enum System.Windows.Documents.RtfTokenType : Enum {
    public int value__;
    public static RtfTokenType TokenInvalid;
    public static RtfTokenType TokenEOF;
    public static RtfTokenType TokenText;
    public static RtfTokenType TokenTextSymbol;
    public static RtfTokenType TokenPictureData;
    public static RtfTokenType TokenNewline;
    public static RtfTokenType TokenNullChar;
    public static RtfTokenType TokenControl;
    public static RtfTokenType TokenDestination;
    public static RtfTokenType TokenHex;
    public static RtfTokenType TokenGroupStart;
    public static RtfTokenType TokenGroupEnd;
}
internal enum System.Windows.Documents.RtfToXamlError : Enum {
    public int value__;
    public static RtfToXamlError None;
    public static RtfToXamlError InvalidFormat;
    public static RtfToXamlError InvalidParameter;
    public static RtfToXamlError InsufficientMemory;
    public static RtfToXamlError OutOfRange;
}
internal class System.Windows.Documents.RtfToXamlLexer : object {
    private Byte[] _rtfBytes;
    private int _rtfIndex;
    private int _rtfLastIndex;
    private int _currentCodePage;
    private Encoding _currentEncoding;
    private static object _rtfControlTableMutex;
    private static Hashtable _rtfControlTable;
    private static int MAX_CONTROL_LENGTH;
    private static int MAX_PARAM_LENGTH;
    unknown int CodePage {internal set; }
    internal Encoding CurrentEncoding { get; }
    internal byte CurByte { get; }
    internal RtfToXamlLexer(Byte[] rtfBytes);
    private static RtfToXamlLexer();
    internal RtfToXamlError Next(RtfToken token, FormatState formatState);
    internal RtfToXamlError AdvanceForUnicode(long nSkip);
    internal void AdvanceForBinary(int skip);
    internal void AdvanceForImageData();
    internal void WriteImageData(Stream imageStream, bool isBinary);
    internal void set_CodePage(int value);
    internal Encoding get_CurrentEncoding();
    internal byte get_CurByte();
    private RtfToXamlError NextText(RtfToken token);
    private RtfToXamlError Backup();
    private void SetRtfIndex(RtfToken token, int controlStartIndex);
    private bool IsControl(byte controlChar);
    private bool IsControlCharValid(byte controlChar);
    private bool IsParameterStart(byte controlChar);
    private bool IsParameterFollow(byte controlChar);
    private bool IsHex(byte controlChar);
    private byte HexToByte(byte hexByte);
    private static RtfControlWordInfo RtfControlWordLookup(string controlName);
}
internal class System.Windows.Documents.RtfToXamlReader : object {
    private Byte[] _rtfBytes;
    private StringBuilder _outerXamlBuilder;
    private RtfToXamlLexer _lexer;
    private ConverterState _converterState;
    private bool _bForceParagraph;
    private WpfPayload _wpfPayload;
    private int _imageCount;
    private static int MAX_GROUP_DEPTH;
    internal string Output { get; }
    internal bool ForceParagraph { get; internal set; }
    internal ConverterState ConverterState { get; }
    unknown WpfPayload WpfPayload {internal set; }
    internal RtfToXamlReader(string rtfString);
    private void Initialize();
    internal RtfToXamlError Process();
    internal string get_Output();
    internal bool get_ForceParagraph();
    internal void set_ForceParagraph(bool value);
    internal ConverterState get_ConverterState();
    internal void set_WpfPayload(WpfPayload value);
    internal bool TreeContainsBlock();
    internal void AppendDocument();
    internal void ProcessField();
    private int HexToInt(char c);
    private int DecToInt(char c);
    private string GetIncludePictureUri(string instructionName);
    internal DocumentNode ProcessHyperlinkField(string instr);
    internal DocumentNode ProcessSymbolField(string instr);
    private void ProcessSymbolFieldInstruction(DocumentNode dn, string instr, Int32& i, EncodeType& encodeType);
    internal void ProcessImage(FormatState formatState);
    private void ConvertSymbolCharValueToText(DocumentNode dn, int nChar, EncodeType encodeType);
    internal void ProcessListText();
    internal void ProcessShapeResult();
    private void ProcessRtfDestination(FormatState fsCur);
    internal void ProcessGroupEnd();
    internal void SelectFont(long nFont);
    internal void HandleControl(RtfToken token, RtfControlWordInfo controlWordInfo);
    internal void ProcessText(RtfToken token);
    internal void ProcessTextSymbol(RtfToken token);
    internal void HandleBinControl(RtfToken token, FormatState formatState);
    internal void HandlePara(RtfToken token, FormatState formatState);
    internal void WrapPendingInlineInParagraph(RtfToken token, FormatState formatState);
    internal void HandlePage(RtfToken token, FormatState formatState);
    internal void HandleParagraphFromText(FormatState formatState);
    internal void WrapInlineInParagraph(int nInsertAt, int nChildren);
    internal void ProcessPendingTextAtRowEnd();
    internal void HandleTableTokens(RtfToken token, FormatState formatState);
    internal ListOverride GetControllingListOverride();
    internal ListLevelTable GetControllingLevelTable();
    internal void HandleListTokens(RtfToken token, FormatState formatState);
    internal void HandleShapeTokens(RtfToken token, FormatState formatState);
    internal void HandleOldListTokens(RtfToken token, FormatState formatState);
    internal void HandleTableProperties(RtfToken token, FormatState formatState);
    internal void HandleFieldTokens(RtfToken token, FormatState formatState);
    internal void HandleTableNesting(FormatState formatState);
    internal MarkerList GetMarkerStylesOfParagraph(MarkerList mlHave, FormatState fs, bool bMarkerPresent);
    internal void HandleListNesting(FormatState formatState);
    internal void HandleCodePageTokens(RtfToken token, FormatState formatState);
    internal void ProcessFieldText(RtfToken token);
    internal void ProcessFontTableText(RtfToken token);
    internal void HandleFontTableTokens(RtfToken token);
    internal void ProcessColorTableText(RtfToken token);
    internal void ProcessText(string text);
    internal void HandleNormalText(string text, FormatState formatState);
    internal void HandleNormalTextRaw(string text, FormatState formatState);
    internal void ProcessNormalHardLine(FormatState formatState);
    internal void ProcessHardLine(RtfToken token, FormatState formatState);
    private void SetTokenTextWithControlCharacter(RtfToken token);
    private int GetMatchedMarkList(FormatState formatState, MarkerList mlHave, MarkerList mlWant);
    private void EnsureListAndListItem(FormatState formatState, DocumentNodeArray dna, MarkerList mlHave, MarkerList mlWant, int nMatch);
}
internal class System.Windows.Documents.RubberbandSelector : object {
    private FixedDocument _panel;
    private FixedPage _page;
    private Rect _selectionRect;
    private bool _isSelecting;
    private Point _origin;
    private UIElement _scope;
    private FrameworkElement _uiScope;
    private int _pageIndex;
    internal FixedPage Page { get; }
    internal Rect SelectionRect { get; }
    internal bool HasSelection { get; }
    internal void ClearSelection();
    internal void AttachRubberbandSelector(FrameworkElement scope);
    internal void DetachRubberbandSelector();
    private void ExtendSelection(Point pt);
    private void UpdateHighlightVisual(FixedPage page);
    private void OnCopy(object sender, ExecutedRoutedEventArgs e);
    private BitmapSource GetImage();
    private Visual GetVisual(double offsetX, double offsetY);
    private void CloneVisualTree(ContainerVisual parent, Visual old);
    private string GetText();
    private ITextPointer _GetTextPosition(FixedNode node, int charIndex);
    private bool IntersectGlyphs(Glyphs g, double top, double left, double bottom, double right, Int32& begin, Int32& end, Boolean& includeEnd, Double& baseline, Double& height);
    private int GlyphRunHitTest(GlyphRun run, double xoffset, bool LTR);
    private void QueryCopy(object sender, CanExecuteRoutedEventArgs e);
    private void OnLeftMouseDown(object sender, MouseButtonEventArgs e);
    private void OnLeftMouseUp(object sender, MouseButtonEventArgs e);
    private void OnMouseMove(object sender, MouseEventArgs e);
    private void OnQueryCursor(object sender, QueryCursorEventArgs e);
    private FixedDocumentPage GetFixedPanelDocumentPage(Point pt);
    internal FixedPage get_Page();
    internal Rect get_SelectionRect();
    internal bool get_HasSelection();
}
[ContentPropertyAttribute("Text")]
public class System.Windows.Documents.Run : Inline {
    public static DependencyProperty TextProperty;
    private int _changeEventNestingCount;
    private bool _isInsideDeferredSet;
    public string Text { get; public set; }
    internal int EffectiveValuesInitialSize { get; }
    public Run(string text);
    public Run(string text, TextPointer insertionPosition);
    private static Run();
    public string get_Text();
    public void set_Text(string value);
    internal virtual void OnTextUpdated();
    internal virtual void BeforeLogicalTreeChange();
    internal virtual void AfterLogicalTreeChange();
    internal virtual int get_EffectiveValuesInitialSize();
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeText(XamlDesignerSerializationManager manager);
    private static void OnTextPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static object CoerceText(DependencyObject d, object baseValue);
}
[ContentPropertyAttribute("Blocks")]
public class System.Windows.Documents.Section : Block {
    internal static string HasTrailingParagraphBreakOnPastePropertyName;
    private bool _ignoreTrailingParagraphBreakOnPaste;
    [DesignerSerializationVisibilityAttribute("0")]
[DefaultValueAttribute("True")]
public bool HasTrailingParagraphBreakOnPaste { get; public set; }
    [DesignerSerializationVisibilityAttribute("2")]
public BlockCollection Blocks { get; }
    public Section(Block block);
    public bool get_HasTrailingParagraphBreakOnPaste();
    public void set_HasTrailingParagraphBreakOnPaste(bool value);
    public BlockCollection get_Blocks();
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeBlocks(XamlDesignerSerializationManager manager);
}
internal static class System.Windows.Documents.SelectionHighlightInfo : object {
    private static Brush _objectMaskBrush;
    internal static Brush ForegroundBrush { get; }
    internal static Brush BackgroundBrush { get; }
    internal static Brush ObjectMaskBrush { get; }
    private static SelectionHighlightInfo();
    internal static Brush get_ForegroundBrush();
    internal static Brush get_BackgroundBrush();
    internal static Brush get_ObjectMaskBrush();
}
internal static class System.Windows.Documents.SelectionWordBreaker : object {
    private static char LineFeedChar;
    private static char CarriageReturnChar;
    private static char QuotationMarkChar;
    private static char ApostropheChar;
    private static char SoftHyphenChar;
    private static char RightSingleQuotationChar;
    private static char ObjectReplacementChar;
    private static Byte[] _latinClasses;
    internal static int MinContextLength { get; }
    private static SelectionWordBreaker();
    internal static bool IsAtWordBoundary(Char[] text, int position, LogicalDirection insideWordDirection);
    internal static int get_MinContextLength();
    private static bool IsWordBoundary(char previousChar, char followingChar);
    private static bool IsMidLetter(Char[] text, int index, CharClass[] classes);
    private static bool IsIdeographicCharType(ushort charType3);
    private static bool IsSameClass(ushort preceedingType3, CharClass preceedingClass, ushort followingType3, CharClass followingClass);
    private static bool IsWhiteSpace(char ch, CharClass charClass);
    private static CharClass[] GetClasses(Char[] text);
    private static bool IsDiacriticOrKashida(char ch);
    private static bool IsInRange(UInt32 lower, char ch, UInt32 upper);
    private static bool IsKorean(char ch);
    private static bool IsThai(char ch);
    private static bool IsHebrew(char ch);
}
public interface System.Windows.Documents.Serialization.ISerializerFactory {
    public string DisplayName { get; }
    public string ManufacturerName { get; }
    public Uri ManufacturerWebsite { get; }
    public string DefaultFileExtension { get; }
    public abstract virtual SerializerWriter CreateSerializerWriter(Stream stream);
    public abstract virtual string get_DisplayName();
    public abstract virtual string get_ManufacturerName();
    public abstract virtual Uri get_ManufacturerWebsite();
    public abstract virtual string get_DefaultFileExtension();
}
public class System.Windows.Documents.Serialization.SerializerDescriptor : object {
    private string _displayName;
    private string _manufacturerName;
    private Uri _manufacturerWebsite;
    private string _defaultFileExtension;
    private string _assemblyName;
    private string _assemblyPath;
    private string _factoryInterfaceName;
    private Version _assemblyVersion;
    private Version _winFXVersion;
    private bool _isLoadable;
    public string DisplayName { get; }
    public string ManufacturerName { get; }
    public Uri ManufacturerWebsite { get; }
    public string DefaultFileExtension { get; }
    public string AssemblyName { get; }
    public string AssemblyPath { get; }
    public string FactoryInterfaceName { get; }
    public Version AssemblyVersion { get; }
    public Version WinFXVersion { get; }
    public bool IsLoadable { get; }
    private static string GetNonEmptyRegistryString(RegistryKey key, string value);
    public static SerializerDescriptor CreateFromFactoryInstance(ISerializerFactory factoryInstance);
    internal ISerializerFactory CreateSerializerFactory();
    internal void WriteToRegistryKey(RegistryKey key);
    internal static SerializerDescriptor CreateFromRegistry(RegistryKey plugIns, string keyName);
    public string get_DisplayName();
    public string get_ManufacturerName();
    public Uri get_ManufacturerWebsite();
    public string get_DefaultFileExtension();
    public string get_AssemblyName();
    public string get_AssemblyPath();
    public string get_FactoryInterfaceName();
    public Version get_AssemblyVersion();
    public Version get_WinFXVersion();
    public bool get_IsLoadable();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class System.Windows.Documents.Serialization.SerializerProvider : object {
    private static string _registryPath;
    private static RegistryKey _rootKey;
    private ReadOnlyCollection`1<SerializerDescriptor> _installedSerializers;
    public ReadOnlyCollection`1<SerializerDescriptor> InstalledSerializers { get; }
    private static SerializerProvider();
    public static void RegisterSerializer(SerializerDescriptor serializerDescriptor, bool overwrite);
    public static void UnregisterSerializer(SerializerDescriptor serializerDescriptor);
    public SerializerWriter CreateSerializerWriter(SerializerDescriptor serializerDescriptor, Stream stream);
    private SerializerDescriptor CreateSystemSerializerDescriptor();
    public ReadOnlyCollection`1<SerializerDescriptor> get_InstalledSerializers();
}
public abstract class System.Windows.Documents.Serialization.SerializerWriter : object {
    public abstract virtual void Write(Visual visual);
    public abstract virtual void Write(Visual visual, PrintTicket printTicket);
    public abstract virtual void WriteAsync(Visual visual);
    public abstract virtual void WriteAsync(Visual visual, object userState);
    public abstract virtual void WriteAsync(Visual visual, PrintTicket printTicket);
    public abstract virtual void WriteAsync(Visual visual, PrintTicket printTicket, object userState);
    public abstract virtual void Write(DocumentPaginator documentPaginator);
    public abstract virtual void Write(DocumentPaginator documentPaginator, PrintTicket printTicket);
    public abstract virtual void WriteAsync(DocumentPaginator documentPaginator);
    public abstract virtual void WriteAsync(DocumentPaginator documentPaginator, PrintTicket printTicket);
    public abstract virtual void WriteAsync(DocumentPaginator documentPaginator, object userState);
    public abstract virtual void WriteAsync(DocumentPaginator documentPaginator, PrintTicket printTicket, object userState);
    public abstract virtual void Write(FixedPage fixedPage);
    public abstract virtual void Write(FixedPage fixedPage, PrintTicket printTicket);
    public abstract virtual void WriteAsync(FixedPage fixedPage);
    public abstract virtual void WriteAsync(FixedPage fixedPage, PrintTicket printTicket);
    public abstract virtual void WriteAsync(FixedPage fixedPage, object userState);
    public abstract virtual void WriteAsync(FixedPage fixedPage, PrintTicket printTicket, object userState);
    public abstract virtual void Write(FixedDocument fixedDocument);
    public abstract virtual void Write(FixedDocument fixedDocument, PrintTicket printTicket);
    public abstract virtual void WriteAsync(FixedDocument fixedDocument);
    public abstract virtual void WriteAsync(FixedDocument fixedDocument, PrintTicket printTicket);
    public abstract virtual void WriteAsync(FixedDocument fixedDocument, object userState);
    public abstract virtual void WriteAsync(FixedDocument fixedDocument, PrintTicket printTicket, object userState);
    public abstract virtual void Write(FixedDocumentSequence fixedDocumentSequence);
    public abstract virtual void Write(FixedDocumentSequence fixedDocumentSequence, PrintTicket printTicket);
    public abstract virtual void WriteAsync(FixedDocumentSequence fixedDocumentSequence);
    public abstract virtual void WriteAsync(FixedDocumentSequence fixedDocumentSequence, PrintTicket printTicket);
    public abstract virtual void WriteAsync(FixedDocumentSequence fixedDocumentSequence, object userState);
    public abstract virtual void WriteAsync(FixedDocumentSequence fixedDocumentSequence, PrintTicket printTicket, object userState);
    public abstract virtual void CancelAsync();
    public abstract virtual SerializerWriterCollator CreateVisualsCollator();
    public abstract virtual SerializerWriterCollator CreateVisualsCollator(PrintTicket documentSequencePT, PrintTicket documentPT);
    [CompilerGeneratedAttribute]
public abstract virtual void add_WritingPrintTicketRequired(WritingPrintTicketRequiredEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_WritingPrintTicketRequired(WritingPrintTicketRequiredEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_WritingProgressChanged(WritingProgressChangedEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_WritingProgressChanged(WritingProgressChangedEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_WritingCompleted(WritingCompletedEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_WritingCompleted(WritingCompletedEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_WritingCancelled(WritingCancelledEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_WritingCancelled(WritingCancelledEventHandler value);
}
public abstract class System.Windows.Documents.Serialization.SerializerWriterCollator : object {
    public abstract virtual void BeginBatchWrite();
    public abstract virtual void EndBatchWrite();
    public abstract virtual void Write(Visual visual);
    public abstract virtual void Write(Visual visual, PrintTicket printTicket);
    public abstract virtual void WriteAsync(Visual visual);
    public abstract virtual void WriteAsync(Visual visual, object userState);
    public abstract virtual void WriteAsync(Visual visual, PrintTicket printTicket);
    public abstract virtual void WriteAsync(Visual visual, PrintTicket printTicket, object userState);
    public abstract virtual void CancelAsync();
    public abstract virtual void Cancel();
}
public class System.Windows.Documents.Serialization.WritingCancelledEventArgs : EventArgs {
    private Exception _exception;
    public Exception Error { get; }
    public WritingCancelledEventArgs(Exception exception);
    public Exception get_Error();
}
public class System.Windows.Documents.Serialization.WritingCancelledEventHandler : MulticastDelegate {
    public WritingCancelledEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, WritingCancelledEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, WritingCancelledEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Windows.Documents.Serialization.WritingCompletedEventArgs : AsyncCompletedEventArgs {
    public WritingCompletedEventArgs(bool cancelled, object state, Exception exception);
}
public class System.Windows.Documents.Serialization.WritingCompletedEventHandler : MulticastDelegate {
    public WritingCompletedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, WritingCompletedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, WritingCompletedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Windows.Documents.Serialization.WritingPrintTicketRequiredEventArgs : EventArgs {
    private PrintTicketLevel _printTicketLevel;
    private int _sequence;
    private PrintTicket _printTicket;
    public PrintTicketLevel CurrentPrintTicketLevel { get; }
    public int Sequence { get; }
    public PrintTicket CurrentPrintTicket { get; public set; }
    public WritingPrintTicketRequiredEventArgs(PrintTicketLevel printTicketLevel, int sequence);
    public PrintTicketLevel get_CurrentPrintTicketLevel();
    public int get_Sequence();
    public void set_CurrentPrintTicket(PrintTicket value);
    public PrintTicket get_CurrentPrintTicket();
}
public class System.Windows.Documents.Serialization.WritingPrintTicketRequiredEventHandler : MulticastDelegate {
    public WritingPrintTicketRequiredEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, WritingPrintTicketRequiredEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, WritingPrintTicketRequiredEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Windows.Documents.Serialization.WritingProgressChangedEventArgs : ProgressChangedEventArgs {
    private int _number;
    private WritingProgressChangeLevel _writingLevel;
    public int Number { get; }
    public WritingProgressChangeLevel WritingLevel { get; }
    public WritingProgressChangedEventArgs(WritingProgressChangeLevel writingLevel, int number, int progressPercentage, object state);
    public int get_Number();
    public WritingProgressChangeLevel get_WritingLevel();
}
public class System.Windows.Documents.Serialization.WritingProgressChangedEventHandler : MulticastDelegate {
    public WritingProgressChangedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, WritingProgressChangedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, WritingProgressChangedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public enum System.Windows.Documents.Serialization.WritingProgressChangeLevel : Enum {
    public int value__;
    public static WritingProgressChangeLevel None;
    public static WritingProgressChangeLevel FixedDocumentSequenceWritingProgress;
    public static WritingProgressChangeLevel FixedDocumentWritingProgress;
    public static WritingProgressChangeLevel FixedPageWritingProgress;
}
[ContentPropertyAttribute("Inlines")]
public class System.Windows.Documents.Span : Inline {
    [DesignerSerializationVisibilityAttribute("2")]
public InlineCollection Inlines { get; }
    public Span(Inline childInline);
    public Span(Inline childInline, TextPointer insertionPosition);
    public Span(TextPointer start, TextPointer end);
    public InlineCollection get_Inlines();
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeInlines(XamlDesignerSerializationManager manager);
    private TextPointer SplitElement(TextPointer position);
}
internal class System.Windows.Documents.Speller : object {
    private static int MaxIdleTimeSliceMs;
    private static long MaxIdleTimeSliceNs;
    private static int MaxScanBlockSize;
    private static int ContextBlockSize;
    private static int MinWordBreaksForContext;
    private TextEditor _textEditor;
    private SpellerStatusTable _statusTable;
    private SpellerHighlightLayer _highlightLayer;
    private SpellerInteropBase _spellerInterop;
    private SpellingReform _spellingReform;
    private bool _pendingIdleCallback;
    private bool _pendingCaretMovedCallback;
    private ArrayList _ignoredWordsList;
    private CultureInfo _defaultCulture;
    private bool _failedToInit;
    private Dictionary`2<Uri, DictionaryInfo> _uriMap;
    internal SpellerStatusTable StatusTable { get; }
    private Dictionary`2<Uri, DictionaryInfo> UriMap { get; }
    internal Speller(TextEditor textEditor);
    internal void Detach();
    internal SpellingError GetError(ITextPointer position, LogicalDirection direction, bool forceEvaluation);
    internal ITextPointer GetNextSpellingErrorPosition(ITextPointer position, LogicalDirection direction);
    internal IList GetSuggestionsForError(SpellingError error);
    internal void IgnoreAll(string word);
    internal void SetSpellingReform(SpellingReform spellingReform);
    internal void SetCustomDictionaries(CustomDictionarySources dictionaryLocations, bool add);
    internal void ResetErrors();
    internal static bool IsSpellerAffectingProperty(DependencyProperty property);
    internal void OnDictionaryUriAdded(Uri uri);
    internal void OnDictionaryUriRemoved(Uri uri);
    internal void OnDictionaryUriCollectionCleared();
    internal SpellerStatusTable get_StatusTable();
    private Dictionary`2<Uri, DictionaryInfo> get_UriMap();
    private bool EnsureInitialized();
    private void ScheduleIdleCallback();
    private void ScheduleCaretMovedCallback();
    private void OnTextContainerChange(object sender, TextContainerChangeEventArgs e);
    private object OnIdle(object unused);
    private void OnCaretMoved(object sender, EventArgs e);
    private void OnLostFocus(object sender, RoutedEventArgs e);
    private void OnCaretMovedWorker();
    private bool GetNextScanRange(ITextPointer searchStart, ITextPointer& start, ITextPointer& end);
    private void GetNextScanRangeRaw(ITextPointer searchStart, ITextPointer& start, ITextPointer& end);
    private void AdjustScanRangeAroundComposition(ITextPointer rawStart, ITextPointer rawEnd, ITextPointer& start, ITextPointer& end);
    private ScanStatus ScanRange(ITextPointer start, ITextPointer end, long timeLimit);
    private bool ScanErrorTextSegment(ISpellerSegment textSegment, object o);
    private bool ScanTextSegment(ISpellerSegment textSegment, object o);
    private bool ScanRangeCheckTimeLimitCallback(ISpellerSentence sentence, object o);
    private void MarkErrorRange(TextMap textMap, ITextRange sTextRange);
    private void ExpandToWordBreakAndContext(ITextPointer position, LogicalDirection direction, XmlLanguage language, ITextPointer& contentPosition, ITextPointer& contextPosition);
    private int FindPositionInSegmentList(TextMap textMap, LogicalDirection direction, ArrayList segments, Int32& leftWordBreak, Int32& rightWordBreak);
    private ITextPointer SearchForWordBreaks(ITextPointer position, LogicalDirection direction, XmlLanguage language, int minWordCount, bool stopOnError);
    private ITextPointer GetNextLanguageTransition(ITextPointer position, LogicalDirection direction, XmlLanguage language, ITextPointer haltPosition);
    private bool ExpandToWordBreakCallback(ISpellerSegment textSegment, object o);
    private bool IsIgnoredWord(Char[] word);
    private static bool CanSpellCheck(CultureInfo culture);
    private void SetCulture(CultureInfo culture);
    private void ScanPosition(ITextPointer position, LogicalDirection direction);
    private XmlLanguage GetCurrentLanguage(ITextPointer position);
    private CultureInfo GetCurrentCultureAndLanguage(ITextPointer position, XmlLanguage& language);
    private static Uri ResolvePathUri(Uri uri);
    private void LoadDictionaryFromPackUri(Uri item);
    private void CleanupDictionaryTempFile(Uri tempLocationUri);
    private static Uri LoadPackFile(Uri uri);
}
internal class System.Windows.Documents.SpellerHighlightLayer : HighlightLayer {
    [CompilerGeneratedAttribute]
private HighlightChangedEventHandler Changed;
    private Speller _speller;
    private static TextDecorationCollection _errorTextDecorations;
    internal Type OwnerType { get; }
    private static SpellerHighlightLayer();
    internal SpellerHighlightLayer(Speller speller);
    internal virtual object GetHighlightValue(StaticTextPointer textPosition, LogicalDirection direction);
    internal virtual bool IsContentHighlighted(StaticTextPointer textPosition, LogicalDirection direction);
    internal virtual StaticTextPointer GetNextChangePosition(StaticTextPointer textPosition, LogicalDirection direction);
    internal void FireChangedEvent(ITextPointer start, ITextPointer end);
    internal virtual Type get_OwnerType();
    [CompilerGeneratedAttribute]
internal virtual void add_Changed(HighlightChangedEventHandler value);
    [CompilerGeneratedAttribute]
internal virtual void remove_Changed(HighlightChangedEventHandler value);
    private static TextDecorationCollection GetErrorTextDecorations();
}
internal abstract class System.Windows.Documents.SpellerInteropBase : object {
    unknown SpellerMode Mode {internal set; }
    unknown bool MultiWordMode {internal set; }
    public abstract virtual void Dispose();
    protected abstract virtual void Dispose(bool disposing);
    public static SpellerInteropBase CreateInstance();
    internal abstract virtual void SetLocale(CultureInfo culture);
    internal abstract virtual int EnumTextSegments(Char[] text, int count, EnumSentencesCallback sentenceCallback, EnumTextSegmentsCallback segmentCallback, object data);
    internal abstract virtual void UnloadDictionary(object dictionary);
    internal abstract virtual object LoadDictionary(string lexiconFilePath);
    internal abstract virtual object LoadDictionary(Uri item, string trustedFolder);
    internal abstract virtual void ReleaseAllLexicons();
    internal abstract virtual void set_Mode(SpellerMode value);
    internal abstract virtual void set_MultiWordMode(bool value);
    internal abstract virtual void SetReformMode(CultureInfo culture, SpellingReform spellingReform);
    internal abstract virtual bool CanSpellCheck(CultureInfo culture);
}
internal class System.Windows.Documents.SpellerStatusTable : object {
    private SpellerHighlightLayer _highlightLayer;
    private ArrayList _runList;
    internal SpellerStatusTable(ITextPointer textContainerStart, SpellerHighlightLayer highlightLayer);
    internal void OnTextChange(TextContainerChangeEventArgs e);
    internal void GetFirstDirtyRange(ITextPointer searchStart, ITextPointer& start, ITextPointer& end);
    internal void MarkCleanRange(ITextPointer start, ITextPointer end);
    internal void MarkDirtyRange(ITextPointer start, ITextPointer end);
    internal void MarkErrorRange(ITextPointer start, ITextPointer end);
    internal bool IsRunType(StaticTextPointer textPosition, LogicalDirection direction, RunType runType);
    internal StaticTextPointer GetNextErrorTransition(StaticTextPointer textPosition, LogicalDirection direction);
    internal bool GetError(StaticTextPointer textPosition, LogicalDirection direction, ITextPointer& start, ITextPointer& end);
    internal bool GetRun(StaticTextPointer position, LogicalDirection direction, RunType& runType, StaticTextPointer& end);
    private int GetErrorIndex(StaticTextPointer textPosition, LogicalDirection direction);
    private int FindIndex(StaticTextPointer position, LogicalDirection direction);
    private void MarkRange(ITextPointer start, ITextPointer end, RunType runType);
    private void AddRun(int index, ITextPointer start, ITextPointer end, RunType runType);
    private void TryToMergeRunWithNeighbors(int index);
    private void OnContentAdded(TextContainerChangeEventArgs e);
    private void OnContentRemoved(ITextPointer position);
    private void NotifyHighlightLayerBeforeRunChange(int index);
    private void DebugAssertRunList();
    private Run GetRun(int index);
    private ITextPointer GetRunEndPositionDynamic(int index);
    private StaticTextPointer GetRunEndPosition(int index);
    private bool IsErrorRun(int index);
}
internal abstract class System.Windows.Documents.SplayTreeNode : object {
    internal SplayTreeNode ParentNode { get; internal set; }
    internal SplayTreeNode ContainedNode { get; internal set; }
    internal SplayTreeNode LeftChildNode { get; internal set; }
    internal SplayTreeNode RightChildNode { get; internal set; }
    internal int SymbolCount { get; internal set; }
    internal int IMECharCount { get; internal set; }
    internal int LeftSymbolCount { get; internal set; }
    internal int LeftCharCount { get; internal set; }
    internal UInt32 Generation { get; internal set; }
    internal int SymbolOffsetCache { get; internal set; }
    internal SplayTreeNodeRole Role { get; }
    internal SplayTreeNode GetSiblingAtOffset(int offset, Int32& nodeOffset);
    internal SplayTreeNode GetSiblingAtCharOffset(int charOffset, Int32& nodeCharOffset);
    internal SplayTreeNode GetFirstContainedNode();
    internal SplayTreeNode GetLastContainedNode();
    internal SplayTreeNode GetContainingNode();
    internal SplayTreeNode GetPreviousNode();
    internal SplayTreeNode GetNextNode();
    internal int GetSymbolOffset(UInt32 treeGeneration);
    internal int GetIMECharOffset();
    internal void InsertAtNode(SplayTreeNode positionNode, ElementEdge edge);
    internal void InsertAtNode(SplayTreeNode location, bool insertBefore);
    internal void Remove();
    internal static void Join(SplayTreeNode root, SplayTreeNode leftSubTree, SplayTreeNode rightSubTree);
    internal static SplayTreeNode Join(SplayTreeNode leftSubTree, SplayTreeNode rightSubTree);
    internal SplayTreeNode Split();
    internal SplayTreeNode GetMinSibling();
    internal SplayTreeNode GetMaxSibling();
    internal void Splay();
    internal bool IsChildOfNode(SplayTreeNode parentNode);
    internal abstract virtual SplayTreeNode get_ParentNode();
    internal abstract virtual void set_ParentNode(SplayTreeNode value);
    internal abstract virtual SplayTreeNode get_ContainedNode();
    internal abstract virtual void set_ContainedNode(SplayTreeNode value);
    internal abstract virtual SplayTreeNode get_LeftChildNode();
    internal abstract virtual void set_LeftChildNode(SplayTreeNode value);
    internal abstract virtual SplayTreeNode get_RightChildNode();
    internal abstract virtual void set_RightChildNode(SplayTreeNode value);
    internal abstract virtual int get_SymbolCount();
    internal abstract virtual void set_SymbolCount(int value);
    internal abstract virtual int get_IMECharCount();
    internal abstract virtual void set_IMECharCount(int value);
    internal abstract virtual int get_LeftSymbolCount();
    internal abstract virtual void set_LeftSymbolCount(int value);
    internal abstract virtual int get_LeftCharCount();
    internal abstract virtual void set_LeftCharCount(int value);
    internal abstract virtual UInt32 get_Generation();
    internal abstract virtual void set_Generation(UInt32 value);
    internal abstract virtual int get_SymbolOffsetCache();
    internal abstract virtual void set_SymbolOffsetCache(int value);
    internal SplayTreeNodeRole get_Role();
    private void RotateLeft();
    private void RotateRight();
}
internal enum System.Windows.Documents.SplayTreeNodeRole : Enum {
    public int value__;
    public static SplayTreeNodeRole LocalRoot;
    public static SplayTreeNodeRole LeftChild;
    public static SplayTreeNodeRole RightChild;
}
internal class System.Windows.Documents.StaticTextPointer : ValueType {
    internal static StaticTextPointer Null;
    private ITextContainer _textContainer;
    private UInt32 _generation;
    private object _handle0;
    private int _handle1;
    internal ITextContainer TextContainer { get; }
    internal DependencyObject Parent { get; }
    internal bool IsNull { get; }
    internal object Handle0 { get; }
    internal int Handle1 { get; }
    internal StaticTextPointer(ITextContainer textContainer, object handle0);
    internal StaticTextPointer(ITextContainer textContainer, object handle0, int handle1);
    private static StaticTextPointer();
    internal ITextPointer CreateDynamicTextPointer(LogicalDirection direction);
    internal TextPointerContext GetPointerContext(LogicalDirection direction);
    internal int GetOffsetToPosition(StaticTextPointer position);
    internal int GetTextInRun(LogicalDirection direction, Char[] textBuffer, int startIndex, int count);
    internal object GetAdjacentElement(LogicalDirection direction);
    internal StaticTextPointer CreatePointer(int offset);
    internal StaticTextPointer GetNextContextPosition(LogicalDirection direction);
    internal int CompareTo(StaticTextPointer position);
    internal int CompareTo(ITextPointer position);
    internal object GetValue(DependencyProperty formattingProperty);
    internal static StaticTextPointer Min(StaticTextPointer position1, StaticTextPointer position2);
    internal static StaticTextPointer Max(StaticTextPointer position1, StaticTextPointer position2);
    internal void AssertGeneration();
    internal ITextContainer get_TextContainer();
    internal DependencyObject get_Parent();
    internal bool get_IsNull();
    internal object get_Handle0();
    internal int get_Handle1();
}
internal enum System.Windows.Documents.StrikeState : Enum {
    public int value__;
    public static StrikeState StrikeNone;
    public static StrikeState StrikeNormal;
    public static StrikeState StrikeDouble;
}
[ContentPropertyAttribute("RowGroups")]
public class System.Windows.Documents.Table : Block {
    [CompilerGeneratedAttribute]
private EventHandler TableStructureChanged;
    private TableColumnCollection _columns;
    private TableRowGroupCollection _rowGroups;
    private int _rowGroupInsertionIndex;
    private static double c_defaultCellSpacing;
    private int _columnCount;
    private int _version;
    private bool _initializing;
    public static DependencyProperty CellSpacingProperty;
    protected internal IEnumerator LogicalChildren { get; }
    [DesignerSerializationVisibilityAttribute("2")]
public TableColumnCollection Columns { get; }
    [DesignerSerializationVisibilityAttribute("2")]
public TableRowGroupCollection RowGroups { get; }
    [TypeConverterAttribute("System.Windows.LengthConverter")]
public double CellSpacing { get; public set; }
    internal double InternalCellSpacing { get; }
    private int MS.Internal.Documents.IAcceptInsertion.InsertionIndex { get; private set; }
    internal int InsertionIndex { get; internal set; }
    internal int ColumnCount { get; }
    private static Table();
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object value);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string text);
    public virtual void BeginInit();
    public virtual void EndInit();
    protected internal virtual IEnumerator get_LogicalChildren();
    public TableColumnCollection get_Columns();
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeColumns();
    public TableRowGroupCollection get_RowGroups();
    public double get_CellSpacing();
    public void set_CellSpacing(double value);
    protected virtual AutomationPeer OnCreateAutomationPeer();
    internal double get_InternalCellSpacing();
    private sealed virtual override int MS.Internal.Documents.IAcceptInsertion.get_InsertionIndex();
    private sealed virtual override void MS.Internal.Documents.IAcceptInsertion.set_InsertionIndex(int value);
    internal int get_InsertionIndex();
    internal void set_InsertionIndex(int value);
    internal int get_ColumnCount();
    internal void EnsureColumnCount(int columnCount);
    internal void OnStructureChanged();
    internal void ValidateStructure();
    internal void InvalidateColumns();
    internal bool IsFirstNonEmptyRowGroup(int rowGroupIndex);
    internal bool IsLastNonEmptyRowGroup(int rowGroupIndex);
    [CompilerGeneratedAttribute]
internal void add_TableStructureChanged(EventHandler value);
    [CompilerGeneratedAttribute]
internal void remove_TableStructureChanged(EventHandler value);
    private void PrivateInitialize();
    private static bool IsValidCellSpacing(object o);
}
[ContentPropertyAttribute("Blocks")]
public class System.Windows.Documents.TableCell : TextElement {
    public static DependencyProperty PaddingProperty;
    public static DependencyProperty BorderThicknessProperty;
    public static DependencyProperty BorderBrushProperty;
    public static DependencyProperty TextAlignmentProperty;
    public static DependencyProperty FlowDirectionProperty;
    public static DependencyProperty LineHeightProperty;
    public static DependencyProperty LineStackingStrategyProperty;
    private int _parentIndex;
    private int _columnIndex;
    public static DependencyProperty ColumnSpanProperty;
    public static DependencyProperty RowSpanProperty;
    [DesignerSerializationVisibilityAttribute("2")]
public BlockCollection Blocks { get; }
    public int ColumnSpan { get; public set; }
    public int RowSpan { get; public set; }
    public Thickness Padding { get; public set; }
    public Thickness BorderThickness { get; public set; }
    public Brush BorderBrush { get; public set; }
    public TextAlignment TextAlignment { get; public set; }
    public FlowDirection FlowDirection { get; public set; }
    [TypeConverterAttribute("System.Windows.LengthConverter")]
public double LineHeight { get; public set; }
    public LineStackingStrategy LineStackingStrategy { get; public set; }
    private int MS.Internal.Documents.IIndexedChild<System.Windows.Documents.TableRow>.Index { get; private set; }
    internal TableRow Row { get; }
    internal Table Table { get; }
    internal int Index { get; internal set; }
    internal int RowIndex { get; }
    internal int RowGroupIndex { get; }
    internal int ColumnIndex { get; internal set; }
    internal bool IsIMEStructuralElement { get; }
    public TableCell(Block blockItem);
    private static TableCell();
    internal virtual void OnNewParent(DependencyObject newParent);
    public BlockCollection get_Blocks();
    public int get_ColumnSpan();
    public void set_ColumnSpan(int value);
    public int get_RowSpan();
    public void set_RowSpan(int value);
    protected virtual AutomationPeer OnCreateAutomationPeer();
    public Thickness get_Padding();
    public void set_Padding(Thickness value);
    public Thickness get_BorderThickness();
    public void set_BorderThickness(Thickness value);
    public Brush get_BorderBrush();
    public void set_BorderBrush(Brush value);
    public TextAlignment get_TextAlignment();
    public void set_TextAlignment(TextAlignment value);
    public FlowDirection get_FlowDirection();
    public void set_FlowDirection(FlowDirection value);
    public double get_LineHeight();
    public void set_LineHeight(double value);
    public LineStackingStrategy get_LineStackingStrategy();
    public void set_LineStackingStrategy(LineStackingStrategy value);
    private sealed virtual override void MS.Internal.Documents.IIndexedChild<System.Windows.Documents.TableRow>.OnEnterParentTree();
    private sealed virtual override void MS.Internal.Documents.IIndexedChild<System.Windows.Documents.TableRow>.OnExitParentTree();
    private sealed virtual override void MS.Internal.Documents.IIndexedChild<System.Windows.Documents.TableRow>.OnAfterExitParentTree(TableRow parent);
    private sealed virtual override int MS.Internal.Documents.IIndexedChild<System.Windows.Documents.TableRow>.get_Index();
    private sealed virtual override void MS.Internal.Documents.IIndexedChild<System.Windows.Documents.TableRow>.set_Index(int value);
    internal void OnEnterParentTree();
    internal void OnExitParentTree();
    internal void OnAfterExitParentTree(TableRow row);
    internal void ValidateStructure(int columnIndex);
    internal TableRow get_Row();
    internal Table get_Table();
    internal int get_Index();
    internal void set_Index(int value);
    internal int get_RowIndex();
    internal int get_RowGroupIndex();
    internal int get_ColumnIndex();
    internal void set_ColumnIndex(int value);
    internal virtual bool get_IsIMEStructuralElement();
    private void PrivateInitialize();
    private static bool IsValidRowSpan(object value);
    private static bool IsValidColumnSpan(object value);
    private static void OnColumnSpanChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void OnRowSpanChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Documents.TableCellCollection : object {
    private TableTextElementCollectionInternal`2<TableRow, TableCell> _cellCollectionInternal;
    private bool System.Collections.IList.IsFixedSize { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private object System.Collections.IList.Item { get; private set; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public int Capacity { get; public set; }
    public TableCell Item { get; public set; }
    private int PrivateCapacity { get; private set; }
    internal TableCellCollection(TableRow owner);
    public sealed virtual void CopyTo(Array array, int index);
    public sealed virtual void CopyTo(TableCell[] array, int index);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override IEnumerator`1<TableCell> System.Collections.Generic.IEnumerable<System.Windows.Documents.TableCell>.GetEnumerator();
    public sealed virtual void Add(TableCell item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(TableCell item);
    public sealed virtual int IndexOf(TableCell item);
    public sealed virtual void Insert(int index, TableCell item);
    public sealed virtual bool Remove(TableCell item);
    public sealed virtual void RemoveAt(int index);
    public void RemoveRange(int index, int count);
    public void TrimToSize();
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override void System.Collections.IList.Clear();
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.IList.RemoveAt(int index);
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    public int get_Capacity();
    public void set_Capacity(int value);
    public sealed virtual TableCell get_Item(int index);
    public sealed virtual void set_Item(int index, TableCell value);
    internal void InternalAdd(TableCell item);
    internal void InternalRemove(TableCell item);
    private void EnsureCapacity(int min);
    private void PrivateConnectChild(int index, TableCell item);
    private void PrivateDisconnectChild(TableCell item);
    private bool BelongsToOwner(TableCell item);
    private int FindInsertionIndex(TableCell item);
    private int get_PrivateCapacity();
    private void set_PrivateCapacity(int value);
}
public class System.Windows.Documents.TableColumn : FrameworkContentElement {
    private int _parentIndex;
    public static DependencyProperty WidthProperty;
    public static DependencyProperty BackgroundProperty;
    public GridLength Width { get; public set; }
    public Brush Background { get; public set; }
    private int MS.Internal.Documents.IIndexedChild<System.Windows.Documents.Table>.Index { get; private set; }
    internal Table Table { get; }
    internal int Index { get; internal set; }
    internal static GridLength DefaultWidth { get; }
    private static TableColumn();
    public GridLength get_Width();
    public void set_Width(GridLength value);
    public Brush get_Background();
    public void set_Background(Brush value);
    private sealed virtual override void MS.Internal.Documents.IIndexedChild<System.Windows.Documents.Table>.OnEnterParentTree();
    private sealed virtual override void MS.Internal.Documents.IIndexedChild<System.Windows.Documents.Table>.OnExitParentTree();
    private sealed virtual override void MS.Internal.Documents.IIndexedChild<System.Windows.Documents.Table>.OnAfterExitParentTree(Table parent);
    private sealed virtual override int MS.Internal.Documents.IIndexedChild<System.Windows.Documents.Table>.get_Index();
    private sealed virtual override void MS.Internal.Documents.IIndexedChild<System.Windows.Documents.Table>.set_Index(int value);
    internal void OnEnterParentTree();
    internal void OnExitParentTree();
    internal Table get_Table();
    internal int get_Index();
    internal void set_Index(int value);
    internal static GridLength get_DefaultWidth();
    private static bool IsValidWidth(object value);
    private static void OnWidthChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void OnBackgroundChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Documents.TableColumnCollection : object {
    private TableColumnCollectionInternal _columnCollection;
    private bool System.Collections.IList.IsFixedSize { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private object System.Collections.IList.Item { get; private set; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public int Capacity { get; public set; }
    public TableColumn Item { get; public set; }
    internal TableColumnCollection(Table owner);
    public sealed virtual void CopyTo(Array array, int index);
    public sealed virtual void CopyTo(TableColumn[] array, int index);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override IEnumerator`1<TableColumn> System.Collections.Generic.IEnumerable<System.Windows.Documents.TableColumn>.GetEnumerator();
    public sealed virtual void Add(TableColumn item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(TableColumn item);
    public sealed virtual int IndexOf(TableColumn item);
    public sealed virtual void Insert(int index, TableColumn item);
    public sealed virtual bool Remove(TableColumn item);
    public sealed virtual void RemoveAt(int index);
    public void RemoveRange(int index, int count);
    public void TrimToSize();
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override void System.Collections.IList.Clear();
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.IList.RemoveAt(int index);
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    public int get_Capacity();
    public void set_Capacity(int value);
    public sealed virtual TableColumn get_Item(int index);
    public sealed virtual void set_Item(int index, TableColumn value);
}
[ContentPropertyAttribute("Cells")]
public class System.Windows.Documents.TableRow : TextElement {
    private TableCellCollection _cells;
    private TableCell[] _spannedCells;
    private int _parentIndex;
    private int _cellInsertionIndex;
    private int _columnCount;
    private Flags _flags;
    private int _formatCellCount;
    private int MS.Internal.Documents.IIndexedChild<System.Windows.Documents.TableRowGroup>.Index { get; private set; }
    internal TableRowGroup RowGroup { get; }
    internal Table Table { get; }
    [DesignerSerializationVisibilityAttribute("2")]
public TableCellCollection Cells { get; }
    internal int Index { get; internal set; }
    private int MS.Internal.Documents.IAcceptInsertion.InsertionIndex { get; private set; }
    internal int InsertionIndex { get; internal set; }
    internal TableCell[] SpannedCells { get; }
    internal int ColumnCount { get; }
    internal bool HasForeignCells { get; }
    internal bool HasRealCells { get; }
    internal int FormatCellCount { get; }
    internal bool IsIMEStructuralElement { get; }
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object value);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string text);
    internal virtual void OnNewParent(DependencyObject newParent);
    private sealed virtual override void MS.Internal.Documents.IIndexedChild<System.Windows.Documents.TableRowGroup>.OnEnterParentTree();
    private sealed virtual override void MS.Internal.Documents.IIndexedChild<System.Windows.Documents.TableRowGroup>.OnExitParentTree();
    private sealed virtual override void MS.Internal.Documents.IIndexedChild<System.Windows.Documents.TableRowGroup>.OnAfterExitParentTree(TableRowGroup parent);
    private sealed virtual override int MS.Internal.Documents.IIndexedChild<System.Windows.Documents.TableRowGroup>.get_Index();
    private sealed virtual override void MS.Internal.Documents.IIndexedChild<System.Windows.Documents.TableRowGroup>.set_Index(int value);
    internal void OnEnterParentTree();
    internal void OnExitParentTree();
    internal void OnAfterExitParentTree(TableRowGroup rowGroup);
    internal void ValidateStructure(RowSpanVector rowSpanVector);
    internal TableRowGroup get_RowGroup();
    internal Table get_Table();
    public TableCellCollection get_Cells();
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeCells();
    internal int get_Index();
    internal void set_Index(int value);
    private sealed virtual override int MS.Internal.Documents.IAcceptInsertion.get_InsertionIndex();
    private sealed virtual override void MS.Internal.Documents.IAcceptInsertion.set_InsertionIndex(int value);
    internal int get_InsertionIndex();
    internal void set_InsertionIndex(int value);
    internal TableCell[] get_SpannedCells();
    internal int get_ColumnCount();
    internal bool get_HasForeignCells();
    internal bool get_HasRealCells();
    internal int get_FormatCellCount();
    internal virtual bool get_IsIMEStructuralElement();
    private void PrivateInitialize();
    private void SetFlags(bool value, Flags flags);
    private bool CheckFlags(Flags flags);
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Documents.TableRowCollection : object {
    private TableTextElementCollectionInternal`2<TableRowGroup, TableRow> _rowCollectionInternal;
    private bool System.Collections.IList.IsFixedSize { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private object System.Collections.IList.Item { get; private set; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public int Capacity { get; public set; }
    public TableRow Item { get; public set; }
    private int PrivateCapacity { get; private set; }
    internal TableRowCollection(TableRowGroup owner);
    public sealed virtual void CopyTo(Array array, int index);
    public sealed virtual void CopyTo(TableRow[] array, int index);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override IEnumerator`1<TableRow> System.Collections.Generic.IEnumerable<System.Windows.Documents.TableRow>.GetEnumerator();
    public sealed virtual void Add(TableRow item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(TableRow item);
    public sealed virtual int IndexOf(TableRow item);
    public sealed virtual void Insert(int index, TableRow item);
    public sealed virtual bool Remove(TableRow item);
    public sealed virtual void RemoveAt(int index);
    public void RemoveRange(int index, int count);
    public void TrimToSize();
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override void System.Collections.IList.Clear();
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.IList.RemoveAt(int index);
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    public int get_Capacity();
    public void set_Capacity(int value);
    public sealed virtual TableRow get_Item(int index);
    public sealed virtual void set_Item(int index, TableRow value);
    internal void InternalAdd(TableRow item);
    internal void InternalRemove(TableRow item);
    private void EnsureCapacity(int min);
    private void PrivateConnectChild(int index, TableRow item);
    private void PrivateDisconnectChild(TableRow item);
    private bool BelongsToOwner(TableRow item);
    private int FindInsertionIndex(TableRow item);
    private int get_PrivateCapacity();
    private void set_PrivateCapacity(int value);
}
[ContentPropertyAttribute("Rows")]
public class System.Windows.Documents.TableRowGroup : TextElement {
    private TableRowCollection _rows;
    private int _parentIndex;
    private int _rowInsertionIndex;
    private int _columnCount;
    [DesignerSerializationVisibilityAttribute("2")]
public TableRowCollection Rows { get; }
    private int MS.Internal.Documents.IIndexedChild<System.Windows.Documents.Table>.Index { get; private set; }
    internal Table Table { get; }
    internal int Index { get; internal set; }
    private int MS.Internal.Documents.IAcceptInsertion.InsertionIndex { get; private set; }
    internal int InsertionIndex { get; internal set; }
    internal bool IsIMEStructuralElement { get; }
    private void Initialize();
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object value);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string text);
    public TableRowCollection get_Rows();
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeRows();
    private sealed virtual override void MS.Internal.Documents.IIndexedChild<System.Windows.Documents.Table>.OnEnterParentTree();
    private sealed virtual override void MS.Internal.Documents.IIndexedChild<System.Windows.Documents.Table>.OnExitParentTree();
    private sealed virtual override void MS.Internal.Documents.IIndexedChild<System.Windows.Documents.Table>.OnAfterExitParentTree(Table parent);
    private sealed virtual override int MS.Internal.Documents.IIndexedChild<System.Windows.Documents.Table>.get_Index();
    private sealed virtual override void MS.Internal.Documents.IIndexedChild<System.Windows.Documents.Table>.set_Index(int value);
    internal void OnEnterParentTree();
    internal void OnExitParentTree();
    internal void OnAfterExitParentTree(Table table);
    internal void ValidateStructure();
    internal Table get_Table();
    internal int get_Index();
    internal void set_Index(int value);
    private sealed virtual override int MS.Internal.Documents.IAcceptInsertion.get_InsertionIndex();
    private sealed virtual override void MS.Internal.Documents.IAcceptInsertion.set_InsertionIndex(int value);
    internal int get_InsertionIndex();
    internal void set_InsertionIndex(int value);
    internal virtual bool get_IsIMEStructuralElement();
    internal virtual void OnNewParent(DependencyObject newParent);
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Documents.TableRowGroupCollection : object {
    private TableTextElementCollectionInternal`2<Table, TableRowGroup> _rowGroupCollectionInternal;
    private bool System.Collections.IList.IsFixedSize { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private object System.Collections.IList.Item { get; private set; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public int Capacity { get; public set; }
    public TableRowGroup Item { get; public set; }
    private int PrivateCapacity { get; private set; }
    internal TableRowGroupCollection(Table owner);
    public sealed virtual void CopyTo(Array array, int index);
    public sealed virtual void CopyTo(TableRowGroup[] array, int index);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override IEnumerator`1<TableRowGroup> System.Collections.Generic.IEnumerable<System.Windows.Documents.TableRowGroup>.GetEnumerator();
    public sealed virtual void Add(TableRowGroup item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(TableRowGroup item);
    public sealed virtual int IndexOf(TableRowGroup item);
    public sealed virtual void Insert(int index, TableRowGroup item);
    public sealed virtual bool Remove(TableRowGroup item);
    public sealed virtual void RemoveAt(int index);
    public void RemoveRange(int index, int count);
    public void TrimToSize();
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override void System.Collections.IList.Clear();
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.IList.RemoveAt(int index);
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    public int get_Capacity();
    public void set_Capacity(int value);
    public sealed virtual TableRowGroup get_Item(int index);
    public sealed virtual void set_Item(int index, TableRowGroup value);
    internal void InternalAdd(TableRowGroup item);
    internal void InternalRemove(TableRowGroup item);
    private void EnsureCapacity(int min);
    private void PrivateConnectChild(int index, TableRowGroup item);
    private void PrivateDisconnectChild(TableRowGroup item);
    private bool BelongsToOwner(TableRowGroup item);
    private int FindInsertionIndex(TableRowGroup item);
    private int get_PrivateCapacity();
    private void set_PrivateCapacity(int value);
}
internal enum System.Windows.Documents.TextChangeType : Enum {
    public int value__;
    public static TextChangeType ContentAdded;
    public static TextChangeType ContentRemoved;
    public static TextChangeType PropertyModified;
}
internal class System.Windows.Documents.TextContainer : object {
    private DependencyObject _parent;
    private TextTreeRootNode _rootNode;
    private Highlights _highlights;
    private int _changeBlockLevel;
    private TextContainerChangedEventArgs _changes;
    private ITextView _textview;
    private UndoManager _undoManager;
    private ITextSelection _textSelection;
    private ChangeBlockUndoRecord _changeBlockUndoRecord;
    private EventHandler ChangingHandler;
    private TextContainerChangeEventHandler ChangeHandler;
    private TextContainerChangedEventHandler ChangedHandler;
    private Flags _flags;
    internal TextPointer Start { get; }
    internal TextPointer End { get; }
    internal DependencyObject Parent { get; }
    private bool System.Windows.Documents.ITextContainer.IsReadOnly { get; }
    private ITextPointer System.Windows.Documents.ITextContainer.Start { get; }
    private ITextPointer System.Windows.Documents.ITextContainer.End { get; }
    private UInt32 System.Windows.Documents.ITextContainer.Generation { get; }
    private Highlights System.Windows.Documents.ITextContainer.Highlights { get; }
    private DependencyObject System.Windows.Documents.ITextContainer.Parent { get; }
    private ITextSelection System.Windows.Documents.ITextContainer.TextSelection { get; private set; }
    private UndoManager System.Windows.Documents.ITextContainer.UndoManager { get; }
    private ITextView System.Windows.Documents.ITextContainer.TextView { get; private set; }
    internal ITextView TextView { get; internal set; }
    private int System.Windows.Documents.ITextContainer.SymbolCount { get; }
    internal int SymbolCount { get; }
    internal int InternalSymbolCount { get; }
    internal int IMECharCount { get; }
    private int System.Windows.Documents.ITextContainer.IMECharCount { get; }
    internal TextTreeRootTextBlock RootTextBlock { get; }
    internal UInt32 Generation { get; }
    internal UInt32 PositionGeneration { get; }
    internal UInt32 LayoutGeneration { get; }
    internal Highlights Highlights { get; }
    internal TextTreeRootNode RootNode { get; }
    internal TextTreeNode FirstContainedNode { get; }
    internal TextTreeNode LastContainedNode { get; }
    internal UndoManager UndoManager { get; }
    internal ITextSelection TextSelection { get; }
    internal bool HasListeners { get; }
    internal bool PlainTextOnly { get; }
    internal bool CollectTextChanges { get; internal set; }
    private Dispatcher Dispatcher { get; }
    internal TextContainer(DependencyObject parent, bool plainTextOnly);
    public virtual string ToString();
    internal void EnableUndo(FrameworkElement uiScope);
    internal void DisableUndo(FrameworkElement uiScope);
    internal void SetValue(TextPointer position, DependencyProperty property, object value);
    internal void SetValues(TextPointer position, LocalValueEnumerator values);
    internal void BeginChange();
    internal void BeginChangeNoUndo();
    internal void EndChange();
    internal void EndChange(bool skipEvents);
    private sealed virtual override void System.Windows.Documents.ITextContainer.BeginChange();
    private sealed virtual override void System.Windows.Documents.ITextContainer.BeginChangeNoUndo();
    private sealed virtual override void System.Windows.Documents.ITextContainer.EndChange();
    private sealed virtual override void System.Windows.Documents.ITextContainer.EndChange(bool skipEvents);
    private sealed virtual override ITextPointer System.Windows.Documents.ITextContainer.CreatePointerAtOffset(int offset, LogicalDirection direction);
    internal TextPointer CreatePointerAtOffset(int offset, LogicalDirection direction);
    private sealed virtual override ITextPointer System.Windows.Documents.ITextContainer.CreatePointerAtCharOffset(int charOffset, LogicalDirection direction);
    internal TextPointer CreatePointerAtCharOffset(int charOffset, LogicalDirection direction);
    private sealed virtual override ITextPointer System.Windows.Documents.ITextContainer.CreateDynamicTextPointer(StaticTextPointer position, LogicalDirection direction);
    internal StaticTextPointer CreateStaticPointerAtOffset(int offset);
    private sealed virtual override StaticTextPointer System.Windows.Documents.ITextContainer.CreateStaticPointerAtOffset(int offset);
    private sealed virtual override TextPointerContext System.Windows.Documents.ITextContainer.GetPointerContext(StaticTextPointer pointer, LogicalDirection direction);
    internal int GetInternalOffset(StaticTextPointer position);
    private sealed virtual override int System.Windows.Documents.ITextContainer.GetOffsetToPosition(StaticTextPointer position1, StaticTextPointer position2);
    private sealed virtual override int System.Windows.Documents.ITextContainer.GetTextInRun(StaticTextPointer position, LogicalDirection direction, Char[] textBuffer, int startIndex, int count);
    private sealed virtual override object System.Windows.Documents.ITextContainer.GetAdjacentElement(StaticTextPointer position, LogicalDirection direction);
    private TextTreeNode GetScopingNode(StaticTextPointer position);
    private sealed virtual override DependencyObject System.Windows.Documents.ITextContainer.GetParent(StaticTextPointer position);
    private sealed virtual override StaticTextPointer System.Windows.Documents.ITextContainer.CreatePointer(StaticTextPointer position, int offset);
    private sealed virtual override StaticTextPointer System.Windows.Documents.ITextContainer.GetNextContextPosition(StaticTextPointer position, LogicalDirection direction);
    private sealed virtual override int System.Windows.Documents.ITextContainer.CompareTo(StaticTextPointer position1, StaticTextPointer position2);
    private sealed virtual override int System.Windows.Documents.ITextContainer.CompareTo(StaticTextPointer position1, ITextPointer position2);
    private sealed virtual override object System.Windows.Documents.ITextContainer.GetValue(StaticTextPointer position, DependencyProperty formattingProperty);
    internal void BeforeAddChange();
    internal void AddChange(TextPointer startPosition, int symbolCount, int charCount, PrecursorTextChangeType textChange);
    internal void AddChange(TextPointer startPosition, int symbolCount, int charCount, PrecursorTextChangeType textChange, DependencyProperty property, bool affectsRenderOnly);
    internal void AddChange(TextPointer startPosition, TextPointer endPosition, int symbolCount, int leftEdgeCharCount, int childCharCount, PrecursorTextChangeType textChange, DependencyProperty property, bool affectsRenderOnly);
    internal void AddLocalValueChange();
    internal void InsertTextInternal(TextPointer position, object text);
    internal void InsertElementInternal(TextPointer startPosition, TextPointer endPosition, TextElement element);
    internal void InsertEmbeddedObjectInternal(TextPointer position, DependencyObject embeddedObject);
    internal void DeleteContentInternal(TextPointer startPosition, TextPointer endPosition);
    internal void GetNodeAndEdgeAtOffset(int offset, SplayTreeNode& node, ElementEdge& edge);
    internal void GetNodeAndEdgeAtOffset(int offset, bool splitNode, SplayTreeNode& node, ElementEdge& edge);
    internal void GetNodeAndEdgeAtCharOffset(int charOffset, TextTreeNode& node, ElementEdge& edge);
    internal void EmptyDeadPositionList();
    internal static int GetTextLength(object text);
    internal void AssertTree();
    internal int GetContentHashCode();
    internal void NextLayoutGeneration();
    internal void ExtractElementInternal(TextElement element);
    internal bool IsAtCaretUnitBoundary(TextPointer position);
    internal TextPointer get_Start();
    internal TextPointer get_End();
    internal DependencyObject get_Parent();
    private sealed virtual override bool System.Windows.Documents.ITextContainer.get_IsReadOnly();
    private sealed virtual override ITextPointer System.Windows.Documents.ITextContainer.get_Start();
    private sealed virtual override ITextPointer System.Windows.Documents.ITextContainer.get_End();
    private sealed virtual override UInt32 System.Windows.Documents.ITextContainer.get_Generation();
    private sealed virtual override Highlights System.Windows.Documents.ITextContainer.get_Highlights();
    private sealed virtual override DependencyObject System.Windows.Documents.ITextContainer.get_Parent();
    private sealed virtual override ITextSelection System.Windows.Documents.ITextContainer.get_TextSelection();
    private sealed virtual override void System.Windows.Documents.ITextContainer.set_TextSelection(ITextSelection value);
    private sealed virtual override UndoManager System.Windows.Documents.ITextContainer.get_UndoManager();
    private sealed virtual override ITextView System.Windows.Documents.ITextContainer.get_TextView();
    private sealed virtual override void System.Windows.Documents.ITextContainer.set_TextView(ITextView value);
    internal ITextView get_TextView();
    internal void set_TextView(ITextView value);
    private sealed virtual override int System.Windows.Documents.ITextContainer.get_SymbolCount();
    internal int get_SymbolCount();
    internal int get_InternalSymbolCount();
    internal int get_IMECharCount();
    private sealed virtual override int System.Windows.Documents.ITextContainer.get_IMECharCount();
    internal TextTreeRootTextBlock get_RootTextBlock();
    internal UInt32 get_Generation();
    internal UInt32 get_PositionGeneration();
    internal UInt32 get_LayoutGeneration();
    internal Highlights get_Highlights();
    internal TextTreeRootNode get_RootNode();
    internal TextTreeNode get_FirstContainedNode();
    internal TextTreeNode get_LastContainedNode();
    internal UndoManager get_UndoManager();
    internal ITextSelection get_TextSelection();
    internal bool get_HasListeners();
    internal bool get_PlainTextOnly();
    internal bool get_CollectTextChanges();
    internal void set_CollectTextChanges(bool value);
    private sealed virtual override void System.Windows.Documents.ITextContainer.add_Changing(EventHandler value);
    private sealed virtual override void System.Windows.Documents.ITextContainer.remove_Changing(EventHandler value);
    private sealed virtual override void System.Windows.Documents.ITextContainer.add_Change(TextContainerChangeEventHandler value);
    private sealed virtual override void System.Windows.Documents.ITextContainer.remove_Change(TextContainerChangeEventHandler value);
    private sealed virtual override void System.Windows.Documents.ITextContainer.add_Changed(TextContainerChangedEventHandler value);
    private sealed virtual override void System.Windows.Documents.ITextContainer.remove_Changed(TextContainerChangedEventHandler value);
    internal void add_Changing(EventHandler value);
    internal void remove_Changing(EventHandler value);
    internal void add_Change(TextContainerChangeEventHandler value);
    internal void remove_Change(TextContainerChangeEventHandler value);
    internal void add_Changed(TextContainerChangedEventHandler value);
    internal void remove_Changed(TextContainerChangedEventHandler value);
    private void ReparentLogicalChildren(SplayTreeNode containerNode, DependencyObject newParentLogicalNode, DependencyObject oldParentLogicalNode);
    private void ReparentLogicalChildren(SplayTreeNode firstChildNode, SplayTreeNode lastChildNode, DependencyObject newParentLogicalNode, DependencyObject oldParentLogicalNode);
    private SplayTreeNode AdjustForZeroWidthNode(SplayTreeNode node, ElementEdge edge);
    private int InsertElementToSiblingTree(TextPointer startPosition, TextPointer endPosition, TextTreeTextElementNode elementNode);
    private int InsertElementToSiblingTreeComplex(TextPointer startPosition, TextPointer endPosition, TextTreeTextElementNode elementNode, Int32& childCharCount);
    private int DeleteContentFromSiblingTree(SplayTreeNode containingNode, TextPointer startPosition, TextPointer endPosition, bool newFirstIMEVisibleNode, Int32& charCount);
    private int CutTopLevelLogicalNodes(TextTreeNode containingNode, TextPointer startPosition, TextPointer endPosition, Int32& charCount);
    private void AdjustRefCountsForContentDelete(TextTreeNode& previousNode, ElementEdge previousEdge, TextTreeNode& nextNode, ElementEdge nextEdge, TextTreeNode middleSubTree);
    private void GetReferenceCounts(TextTreeNode node, Boolean& leftEdgeReferenceCount, Boolean& rightEdgeReferenceCount);
    private void AdjustRefCountsForShallowDelete(TextTreeNode& previousNode, ElementEdge previousEdge, TextTreeNode& nextNode, ElementEdge nextEdge, TextTreeNode& firstContainedNode, TextTreeNode& lastContainedNode, TextTreeTextElementNode extractedElementNode);
    private int CutContent(TextPointer startPosition, TextPointer endPosition, Int32& charCount, SplayTreeNode& leftSubTree, SplayTreeNode& middleSubTree, SplayTreeNode& rightSubTree);
    private Char[] ExtractElementInternal(TextElement element, bool deep, ExtractChangeEventArgs& extractChangeEventArgs);
    private void ExtractElementFromSiblingTree(SplayTreeNode containingNode, TextTreeTextElementNode elementNode, bool deep);
    private TextTreeTextElementNode DeepCopy(TextTreeTextElementNode elementNode);
    private TextTreeNode DeepCopyContainedNodes(TextTreeNode node);
    private void DemandCreatePositionState();
    private void DemandCreateText();
    private void UpdateContainerSymbolCount(SplayTreeNode containingNode, int symbolCount, int charCount);
    private void NextGeneration(bool deletedContent);
    private DependencyProperty[] LocalValueEnumeratorToArray(LocalValueEnumerator valuesEnumerator);
    private void ValidateSetValue(TextPointer position);
    private void AssertTreeAndTextSize();
    private void BeginChange(bool undo);
    private void FireChangeEvent(TextPointer startPosition, TextPointer endPosition, int symbolCount, int leftEdgeCharCount, int childCharCount, PrecursorTextChangeType precursorTextChange, DependencyProperty property, bool affectsRenderOnly);
    private TextChangeType ConvertSimplePrecursorChangeToTextChange(PrecursorTextChangeType precursorTextChange);
    private TextTreeTextElementNode GetNextIMEVisibleNode(TextPointer startPosition, TextPointer endPosition);
    private void RaiseEventForFormerFirstIMEVisibleNode(TextTreeNode node);
    private void RaiseEventForNewFirstIMEVisibleNode(TextTreeNode node);
    private void SetFlags(bool value, Flags flags);
    private bool CheckFlags(Flags flags);
    private Dispatcher get_Dispatcher();
}
internal class System.Windows.Documents.TextContainerChangedEventArgs : EventArgs {
    private bool _hasContentAddedOrRemoved;
    private bool _hasLocalPropertyValueChange;
    private SortedList`2<int, TextChange> _changes;
    internal bool HasContentAddedOrRemoved { get; }
    internal bool HasLocalPropertyValueChange { get; }
    internal SortedList`2<int, TextChange> Changes { get; }
    internal void SetLocalPropertyValueChanged();
    internal void AddChange(PrecursorTextChangeType textChange, int offset, int length, bool collectTextChanges);
    internal bool get_HasContentAddedOrRemoved();
    internal bool get_HasLocalPropertyValueChange();
    internal SortedList`2<int, TextChange> get_Changes();
    private void AddChangeToList(PrecursorTextChangeType textChange, int offset, int length);
    private void DeleteChangeIfEmpty(TextChange change);
    private bool MergeTextChangeLeft(TextChange oldChange, TextChange newChange, bool isDeletion, int length);
    private void MergeTextChangeRight(TextChange oldChange, TextChange newChange, int offset, int length);
}
internal class System.Windows.Documents.TextContainerChangedEventHandler : MulticastDelegate {
    public TextContainerChangedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, TextContainerChangedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, TextContainerChangedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class System.Windows.Documents.TextContainerChangeEventArgs : EventArgs {
    private ITextPointer _textPosition;
    private int _count;
    private int _charCount;
    private TextChangeType _textChange;
    private DependencyProperty _property;
    private bool _affectsRenderOnly;
    internal ITextPointer ITextPosition { get; }
    internal int IMECharCount { get; }
    internal bool AffectsRenderOnly { get; }
    internal int Count { get; }
    internal TextChangeType TextChange { get; }
    internal DependencyProperty Property { get; }
    internal TextContainerChangeEventArgs(ITextPointer textPosition, int count, int charCount, TextChangeType textChange);
    internal TextContainerChangeEventArgs(ITextPointer textPosition, int count, int charCount, TextChangeType textChange, DependencyProperty property, bool affectsRenderOnly);
    internal ITextPointer get_ITextPosition();
    internal int get_IMECharCount();
    internal bool get_AffectsRenderOnly();
    internal int get_Count();
    internal TextChangeType get_TextChange();
    internal DependencyProperty get_Property();
}
internal class System.Windows.Documents.TextContainerChangeEventHandler : MulticastDelegate {
    public TextContainerChangeEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, TextContainerChangeEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, TextContainerChangeEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class System.Windows.Documents.TextEditor : object {
    internal static DependencyProperty IsReadOnlyProperty;
    internal static DependencyProperty AllowOvertypeProperty;
    internal static DependencyProperty PageHeightProperty;
    private static DependencyProperty InstanceProperty;
    internal Dispatcher _dispatcher;
    private bool _isReadOnly;
    private static ArrayList _registeredEditingTypes;
    private ITextContainer _textContainer;
    private long _contentChangeCounter;
    private FrameworkElement _uiScope;
    private ITextView _textView;
    private ITextSelection _selection;
    private bool _overtypeMode;
    internal double _suggestedX;
    private TextStore _textstore;
    private TextEditorShutDownListener _weakThis;
    private Speller _speller;
    private bool _textStoreInitStarted;
    private bool _pendingTextStoreInit;
    internal Cursor _cursor;
    internal IParentUndoUnit _typingUndoUnit;
    internal _DragDropProcess _dragDropProcess;
    internal bool _forceWordSelection;
    internal bool _forceParagraphSelection;
    internal TableColumnResizeInfo _tableColResizeInfo;
    private UndoState _undoState;
    private bool _acceptsRichContent;
    private static bool _immEnabled;
    private ImmComposition _immComposition;
    private WeakReference`1<ImmComposition> _immCompositionForDetach;
    private static LocalDataStoreSlot _threadLocalStoreSlot;
    internal bool _mouseCapturingInProgress;
    private MouseSelectionState _mouseSelectionState;
    private bool _isContextMenuOpen;
    private static bool _isTableEditingEnabled;
    private ITextPointer _nextLineAdvanceMovingPosition;
    internal bool _isNextLineAdvanceMovingPositionAtDocumentHead;
    private static string KeyAltUndo;
    private static string KeyRedo;
    private static string KeyUndo;
    internal ITextContainer TextContainer { get; }
    internal FrameworkElement UiScope { get; }
    internal ITextView TextView { get; internal set; }
    internal ITextSelection Selection { get; }
    internal TextStore TextStore { get; }
    internal ImmComposition ImmComposition { get; }
    internal bool AcceptsReturn { get; }
    internal bool AcceptsTab { get; internal set; }
    internal bool IsReadOnly { get; internal set; }
    internal bool IsSpellCheckEnabled { get; internal set; }
    internal bool AcceptsRichContent { get; internal set; }
    internal bool AllowOvertype { get; }
    internal int MaxLength { get; }
    internal CharacterCasing CharacterCasing { get; }
    internal bool AutoWordSelection { get; }
    internal bool IsReadOnlyCaretVisible { get; }
    internal UndoState UndoState { get; }
    internal bool IsContextMenuOpen { get; internal set; }
    internal Speller Speller { get; }
    internal bool _IsEnabled { get; }
    internal bool _OvertypeMode { get; internal set; }
    internal FrameworkElement _Scroller { get; }
    internal static TextEditorThreadLocalStore _ThreadLocalStore { get; }
    internal long _ContentChangeCounter { get; }
    internal static bool IsTableEditingEnabled { get; internal set; }
    internal ITextPointer _NextLineAdvanceMovingPosition { get; internal set; }
    internal bool _IsNextLineAdvanceMovingPositionAtDocumentHead { get; internal set; }
    internal TextEditor(ITextContainer textContainer, FrameworkElement uiScope, bool isUndoEnabled);
    private static TextEditor();
    protected virtual override void Finalize();
    internal void OnDetach();
    private void DetachTextStore(bool finalizer);
    internal void SetSpellCheckEnabled(bool value);
    internal void SetCustomDictionaries(bool add);
    internal void SetSpellingReform(SpellingReform spellingReform);
    internal static ITextView GetTextView(UIElement scope);
    internal static ITextSelection GetTextSelection(FrameworkElement frameworkElement);
    internal static void RegisterCommandHandlers(Type controlType, bool acceptsRichContent, bool readOnly, bool registerEventListeners);
    internal SpellingError GetSpellingErrorAtPosition(ITextPointer position, LogicalDirection direction);
    internal SpellingError GetSpellingErrorAtSelection();
    internal ITextPointer GetNextSpellingErrorPosition(ITextPointer position, LogicalDirection direction);
    internal void SetText(ITextRange range, string text, CultureInfo cultureInfo);
    internal void SetSelectedText(string text, CultureInfo cultureInfo);
    internal void MarkCultureProperty(TextRange range, CultureInfo inputCultureInfo);
    internal void RequestExtendSelection(Point point);
    internal void CancelExtendSelection();
    internal void CloseToolTip();
    internal void Undo();
    internal void Redo();
    internal void OnPreviewKeyDown(KeyEventArgs e);
    internal void OnKeyDown(KeyEventArgs e);
    internal void OnKeyUp(KeyEventArgs e);
    internal void OnTextInput(TextCompositionEventArgs e);
    internal void OnMouseDown(MouseButtonEventArgs e);
    internal void OnMouseMove(MouseEventArgs e);
    internal void OnMouseUp(MouseButtonEventArgs e);
    internal void OnQueryCursor(QueryCursorEventArgs e);
    internal void OnQueryContinueDrag(QueryContinueDragEventArgs e);
    internal void OnGiveFeedback(GiveFeedbackEventArgs e);
    internal void OnDragEnter(DragEventArgs e);
    internal void OnDragOver(DragEventArgs e);
    internal void OnDragLeave(DragEventArgs e);
    internal void OnDrop(DragEventArgs e);
    internal void OnContextMenuOpening(ContextMenuEventArgs e);
    internal void OnGotKeyboardFocus(KeyboardFocusChangedEventArgs e);
    internal void OnLostKeyboardFocus(KeyboardFocusChangedEventArgs e);
    internal void OnLostFocus(RoutedEventArgs e);
    internal ITextContainer get_TextContainer();
    internal FrameworkElement get_UiScope();
    internal ITextView get_TextView();
    internal void set_TextView(ITextView value);
    internal ITextSelection get_Selection();
    internal TextStore get_TextStore();
    internal ImmComposition get_ImmComposition();
    internal bool get_AcceptsReturn();
    internal bool get_AcceptsTab();
    internal void set_AcceptsTab(bool value);
    internal bool get_IsReadOnly();
    internal void set_IsReadOnly(bool value);
    internal bool get_IsSpellCheckEnabled();
    internal void set_IsSpellCheckEnabled(bool value);
    internal bool get_AcceptsRichContent();
    internal void set_AcceptsRichContent(bool value);
    internal bool get_AllowOvertype();
    internal int get_MaxLength();
    internal CharacterCasing get_CharacterCasing();
    internal bool get_AutoWordSelection();
    internal bool get_IsReadOnlyCaretVisible();
    internal UndoState get_UndoState();
    internal bool get_IsContextMenuOpen();
    internal void set_IsContextMenuOpen(bool value);
    internal Speller get_Speller();
    internal static TextEditor _GetTextEditor(object element);
    internal UndoManager _GetUndoManager();
    internal string _FilterText(string textData, ITextRange range);
    internal string _FilterText(string textData, int charsToReplaceCount);
    internal string _FilterText(string textData, ITextRange range, bool filterMaxLength);
    internal string _FilterText(string textData, int charsToReplaceCount, bool filterMaxLength);
    internal bool _IsSourceInScope(object source);
    internal void CompleteComposition();
    internal bool get__IsEnabled();
    internal bool get__OvertypeMode();
    internal void set__OvertypeMode(bool value);
    internal FrameworkElement get__Scroller();
    internal static TextEditorThreadLocalStore get__ThreadLocalStore();
    internal long get__ContentChangeCounter();
    internal static bool get_IsTableEditingEnabled();
    internal static void set_IsTableEditingEnabled(bool value);
    internal ITextPointer get__NextLineAdvanceMovingPosition();
    internal void set__NextLineAdvanceMovingPosition(ITextPointer value);
    internal bool get__IsNextLineAdvanceMovingPositionAtDocumentHead();
    internal void set__IsNextLineAdvanceMovingPositionAtDocumentHead(bool value);
    private bool IsBadSplitPosition(string text, int position);
    private void HandleMouseSelectionTick(object sender, EventArgs e);
    private void HandleBringPointIntoViewCompleted(object sender, BringPointIntoViewCompletedEventArgs e);
    private object InitTextStore(object o);
    private void OnTextContainerChanged(object sender, TextContainerChangedEventArgs e);
    private void OnTextViewUpdated(object sender, EventArgs e);
    private object OnTextViewUpdatedWorker(object o);
    private static void OnIsEnabledChanged(object sender, DependencyPropertyChangedEventArgs e);
    private static void OnIsReadOnlyChanged(DependencyObject sender, DependencyPropertyChangedEventArgs e);
    private static void OnGotKeyboardFocus(object sender, KeyboardFocusChangedEventArgs e);
    private static void OnLostKeyboardFocus(object sender, KeyboardFocusChangedEventArgs e);
    private static void OnLostFocus(object sender, RoutedEventArgs e);
    private static void OnUndo(object target, ExecutedRoutedEventArgs args);
    private static void OnRedo(object target, ExecutedRoutedEventArgs args);
    private static void OnQueryStatusUndo(object sender, CanExecuteRoutedEventArgs args);
    private static void OnQueryStatusRedo(object sender, CanExecuteRoutedEventArgs args);
}
internal static class System.Windows.Documents.TextEditorCharacters : object {
    internal static double OneFontPoint;
    internal static double MaxFontPoint;
    private static string KeyDecreaseFontSize;
    private static string KeyIncreaseFontSize;
    private static string KeyResetFormat;
    private static string KeyToggleBold;
    private static string KeyToggleItalic;
    private static string KeyToggleSubscript;
    private static string KeyToggleSuperscript;
    private static string KeyToggleUnderline;
    internal static void _RegisterClassHandlers(Type controlType, bool registerEventListeners);
    internal static void _OnApplyProperty(TextEditor This, DependencyProperty formattingProperty, object propertyValue);
    internal static void _OnApplyProperty(TextEditor This, DependencyProperty formattingProperty, object propertyValue, bool applyToParagraphs);
    internal static void _OnApplyProperty(TextEditor This, DependencyProperty formattingProperty, object propertyValue, bool applyToParagraphs, PropertyValueAction propertyValueAction);
    private static void OnResetFormat(object target, ExecutedRoutedEventArgs args);
    private static void OnToggleBold(object target, ExecutedRoutedEventArgs args);
    private static void OnToggleItalic(object target, ExecutedRoutedEventArgs args);
    private static void OnToggleUnderline(object target, ExecutedRoutedEventArgs args);
    private static void OnToggleSubscript(object sender, ExecutedRoutedEventArgs args);
    private static void OnToggleSuperscript(object sender, ExecutedRoutedEventArgs args);
    private static void OnIncreaseFontSize(object target, ExecutedRoutedEventArgs args);
    private static void OnDecreaseFontSize(object target, ExecutedRoutedEventArgs args);
    private static void OnApplyFontSize(object target, ExecutedRoutedEventArgs args);
    private static void OnApplyFontFamily(object target, ExecutedRoutedEventArgs args);
    private static void OnApplyForeground(object target, ExecutedRoutedEventArgs args);
    private static void OnApplyBackground(object target, ExecutedRoutedEventArgs args);
    private static void OnToggleSpellCheck(object target, ExecutedRoutedEventArgs args);
    private static void OnApplyInlineFlowDirectionRTL(object target, ExecutedRoutedEventArgs args);
    private static void OnApplyInlineFlowDirectionLTR(object target, ExecutedRoutedEventArgs args);
    private static void OnQueryStatusNYI(object target, CanExecuteRoutedEventArgs args);
}
internal static class System.Windows.Documents.TextEditorContextMenu : object {
    internal static void _RegisterClassHandlers(Type controlType, bool registerEventListeners);
    internal static void OnContextMenuOpening(object sender, ContextMenuEventArgs e);
    private static void OnContextMenuClosed(object sender, RoutedEventArgs e);
    private static void GetClippedPositionOffsets(TextEditor This, ITextPointer position, LogicalDirection direction, Double& horizontalOffset, Double& verticalOffset);
    private static void ClipToElement(FrameworkElement element, GeneralTransform transform, Double& horizontalOffset, Double& verticalOffset);
    private static double ClipToBounds(double min, double value, double max);
    private static ITextPointer GetContentPosition(ITextPointer position);
}
internal static class System.Windows.Documents.TextEditorCopyPaste : object {
    private static string KeyCopy;
    private static string KeyCopyFormat;
    private static string KeyCtrlInsert;
    private static string KeyCut;
    private static string KeyPasteFormat;
    private static string KeyShiftDelete;
    private static string KeyShiftInsert;
    internal static void _RegisterClassHandlers(Type controlType, bool acceptsRichContent, bool readOnly, bool registerEventListeners);
    internal static DataObject _CreateDataObject(TextEditor This, bool isDragDrop);
    internal static bool _DoPaste(TextEditor This, IDataObject dataObject, bool isDragDrop);
    internal static string GetPasteApplyFormat(TextEditor This, IDataObject dataObject);
    internal static void Cut(TextEditor This, bool userInitiated);
    internal static void Copy(TextEditor This, bool userInitiated);
    internal static void Paste(TextEditor This);
    internal static string ConvertXamlToRtf(string xamlContent, Stream wpfContainerMemory);
    internal static MemoryStream ConvertRtfToXaml(string rtfContent);
    private static void OnQueryStatusCut(object target, CanExecuteRoutedEventArgs args);
    private static void OnCut(object target, ExecutedRoutedEventArgs args);
    private static void OnQueryStatusCopy(object target, CanExecuteRoutedEventArgs args);
    private static void OnCopy(object target, ExecutedRoutedEventArgs args);
    private static void OnQueryStatusPaste(object target, CanExecuteRoutedEventArgs args);
    private static void OnPaste(object target, ExecutedRoutedEventArgs args);
    private static void OnQueryStatusCopyFormat(object target, CanExecuteRoutedEventArgs args);
    private static void OnCopyFormat(object sender, ExecutedRoutedEventArgs args);
    private static void OnQueryStatusPasteFormat(object target, CanExecuteRoutedEventArgs args);
    private static void OnPasteFormat(object sender, ExecutedRoutedEventArgs args);
    private static bool PasteContentData(TextEditor This, IDataObject dataObject, IDataObject dataObjectToApply, string formatToApply);
    private static object GetPasteData(IDataObject dataObject, string dataFormat);
    private static bool PasteTextElement(TextEditor This, TextElement sectionOrSpan);
    private static bool PasteXaml(TextEditor This, string pasteXaml);
    private static bool PastePlainText(TextEditor This, string pastedText);
    private static bool ConfirmDataFormatSetting(FrameworkElement uiScope, IDataObject dataObject, string format);
}
internal static class System.Windows.Documents.TextEditorDragDrop : object {
    internal static void _RegisterClassHandlers(Type controlType, bool readOnly, bool registerEventListeners);
    internal static void OnQueryContinueDrag(object sender, QueryContinueDragEventArgs e);
    internal static void OnGiveFeedback(object sender, GiveFeedbackEventArgs e);
    internal static void OnDragEnter(object sender, DragEventArgs e);
    internal static void OnDragOver(object sender, DragEventArgs e);
    internal static void OnDragLeave(object sender, DragEventArgs e);
    internal static void OnDrop(object sender, DragEventArgs e);
    internal static void OnClearState(object sender, DragEventArgs e);
}
internal static class System.Windows.Documents.TextEditorLists : object {
    private static string KeyDecreaseIndentation;
    private static string KeyToggleBullets;
    private static string KeyToggleNumbering;
    private static string KeyRemoveListMarkers;
    private static string KeyIncreaseIndentation;
    internal static void _RegisterClassHandlers(Type controlType, bool registerEventListeners);
    internal static void DecreaseIndentation(TextEditor This);
    private static TextEditor IsEnabledNotReadOnlyIsTextSegment(object sender);
    private static void OnQueryStatusTab(object sender, CanExecuteRoutedEventArgs args);
    private static void OnQueryStatusNYI(object target, CanExecuteRoutedEventArgs args);
    private static void OnListCommand(object target, ExecutedRoutedEventArgs args);
    private static void ToggleBullets(TextSelection thisSelection, ListItem parentListItem, ListItem immediateListItem, List list);
    private static void ToggleNumbering(TextSelection thisSelection, ListItem parentListItem, ListItem immediateListItem, List list);
    private static void IncreaseIndentation(TextSelection thisSelection, ListItem parentListItem, ListItem immediateListItem);
    private static void DecreaseIndentation(TextSelection thisSelection, ListItem parentListItem, ListItem immediateListItem);
    private static void CreateImplicitParagraphIfNeededAndUpdateSelection(TextSelection thisSelection);
    private static bool HasBulletMarker(List list);
    private static bool HasNumericMarker(List list);
}
internal static class System.Windows.Documents.TextEditorMouse : object {
    private static bool _selectionChanged;
    internal static void _RegisterClassHandlers(Type controlType, bool registerEventListeners);
    internal static void SetCaretPositionOnMouseEvent(TextEditor This, Point mouseDownPoint, MouseButton changedButton, int clickCount);
    internal static bool IsPointWithinInteractiveArea(TextEditor textEditor, Point point);
    internal static void OnMouseDown(object sender, MouseButtonEventArgs e);
    internal static void OnMouseMove(object sender, MouseEventArgs e);
    internal static void OnMouseUp(object sender, MouseButtonEventArgs e);
    internal static void OnQueryCursor(object sender, QueryCursorEventArgs e);
    private static void OnMouseMoveWithoutFocus(TextEditor This, MouseEventArgs e);
    private static void OnMouseMoveWithFocus(TextEditor This, MouseEventArgs e);
    private static bool MoveFocusToUiScope(TextEditor This);
    private static void OnSelectionChangedDuringGotFocus(object sender, EventArgs e);
    private static void OnScrollChangedDuringGotFocus(object sender, ScrollChangedEventArgs e);
    private static void UpdateCursor(TextEditor This, Point mouseMovePoint);
    private static UIElement GetUIElementWhenMouseOver(TextEditor This, Point mouseMovePoint);
    private static bool IsPointWithinRenderScope(TextEditor textEditor, Point point);
}
internal static class System.Windows.Documents.TextEditorParagraphs : object {
    private static string KeyAlignCenter;
    private static string KeyAlignJustify;
    private static string KeyAlignLeft;
    private static string KeyAlignRight;
    private static string KeyApplyDoubleSpace;
    private static string KeyApplyOneAndAHalfSpace;
    private static string KeyApplySingleSpace;
    internal static void _RegisterClassHandlers(Type controlType, bool acceptsRichContent, bool registerEventListeners);
    private static void OnAlignLeft(object sender, ExecutedRoutedEventArgs e);
    private static void OnAlignCenter(object sender, ExecutedRoutedEventArgs e);
    private static void OnAlignRight(object sender, ExecutedRoutedEventArgs e);
    private static void OnAlignJustify(object sender, ExecutedRoutedEventArgs e);
    private static void OnApplySingleSpace(object sender, ExecutedRoutedEventArgs e);
    private static void OnApplyOneAndAHalfSpace(object sender, ExecutedRoutedEventArgs e);
    private static void OnApplyDoubleSpace(object sender, ExecutedRoutedEventArgs e);
    private static void OnApplyParagraphFlowDirectionLTR(object sender, ExecutedRoutedEventArgs e);
    private static void OnApplyParagraphFlowDirectionRTL(object sender, ExecutedRoutedEventArgs e);
    private static void OnQueryStatusNYI(object sender, CanExecuteRoutedEventArgs e);
}
internal static class System.Windows.Documents.TextEditorSelection : object {
    private static string KeyMoveDownByLine;
    private static string KeyMoveDownByPage;
    private static string KeyMoveDownByParagraph;
    private static string KeyMoveLeftByCharacter;
    private static string KeyMoveLeftByWord;
    private static string KeyMoveRightByCharacter;
    private static string KeyMoveRightByWord;
    private static string KeyMoveToColumnEnd;
    private static string KeyMoveToColumnStart;
    private static string KeyMoveToDocumentEnd;
    private static string KeyMoveToDocumentStart;
    private static string KeyMoveToLineEnd;
    private static string KeyMoveToLineStart;
    private static string KeyMoveToWindowBottom;
    private static string KeyMoveToWindowTop;
    private static string KeyMoveUpByLine;
    private static string KeyMoveUpByPage;
    private static string KeyMoveUpByParagraph;
    private static string KeySelectAll;
    private static string KeySelectDownByLine;
    private static string KeySelectDownByPage;
    private static string KeySelectDownByParagraph;
    private static string KeySelectLeftByCharacter;
    private static string KeySelectLeftByWord;
    private static string KeySelectRightByCharacter;
    private static string KeySelectRightByWord;
    private static string KeySelectToColumnEnd;
    private static string KeySelectToColumnStart;
    private static string KeySelectToDocumentEnd;
    private static string KeySelectToDocumentStart;
    private static string KeySelectToLineEnd;
    private static string KeySelectToLineStart;
    private static string KeySelectToWindowBottom;
    private static string KeySelectToWindowTop;
    private static string KeySelectUpByLine;
    private static string KeySelectUpByPage;
    private static string KeySelectUpByParagraph;
    internal static void _RegisterClassHandlers(Type controlType, bool registerEventListeners);
    internal static void _ClearSuggestedX(TextEditor This);
    internal static TextSegment GetNormalizedLineRange(ITextView textView, ITextPointer position);
    internal static bool IsPaginated(ITextView textview);
    private static void OnSelectAll(object target, ExecutedRoutedEventArgs args);
    private static void OnMoveRightByCharacter(object target, ExecutedRoutedEventArgs args);
    private static void OnMoveLeftByCharacter(object target, ExecutedRoutedEventArgs args);
    private static void OnMoveRightByWord(object target, ExecutedRoutedEventArgs args);
    private static void OnMoveLeftByWord(object target, ExecutedRoutedEventArgs args);
    private static void OnMoveDownByLine(object sender, ExecutedRoutedEventArgs args);
    private static void OnMoveUpByLine(object sender, ExecutedRoutedEventArgs args);
    private static void OnMoveDownByParagraph(object sender, ExecutedRoutedEventArgs args);
    private static void OnMoveUpByParagraph(object sender, ExecutedRoutedEventArgs args);
    private static void OnMoveDownByPage(object sender, ExecutedRoutedEventArgs args);
    private static void OnMoveUpByPage(object sender, ExecutedRoutedEventArgs args);
    private static void OnMoveToLineStart(object target, ExecutedRoutedEventArgs args);
    private static void OnMoveToLineEnd(object target, ExecutedRoutedEventArgs args);
    private static void OnMoveToDocumentStart(object target, ExecutedRoutedEventArgs args);
    private static void OnMoveToDocumentEnd(object target, ExecutedRoutedEventArgs args);
    private static void OnSelectRightByCharacter(object target, ExecutedRoutedEventArgs args);
    private static void OnSelectLeftByCharacter(object target, ExecutedRoutedEventArgs args);
    private static void OnSelectRightByWord(object target, ExecutedRoutedEventArgs args);
    private static void OnSelectLeftByWord(object target, ExecutedRoutedEventArgs args);
    private static void OnSelectDownByLine(object sender, ExecutedRoutedEventArgs args);
    private static void AdjustMovingPositionForSelectDownByLine(TextEditor This, ITextPointer newMovingPosition, ITextPointer originalMovingPosition, double suggestedX);
    private static void OnSelectUpByLine(object sender, ExecutedRoutedEventArgs args);
    private static void OnSelectDownByParagraph(object sender, ExecutedRoutedEventArgs args);
    private static void OnSelectUpByParagraph(object sender, ExecutedRoutedEventArgs args);
    private static void OnSelectDownByPage(object sender, ExecutedRoutedEventArgs args);
    private static void OnSelectUpByPage(object sender, ExecutedRoutedEventArgs args);
    private static void OnSelectToLineStart(object target, ExecutedRoutedEventArgs args);
    private static void OnSelectToLineEnd(object target, ExecutedRoutedEventArgs args);
    private static void OnSelectToDocumentStart(object target, ExecutedRoutedEventArgs args);
    private static void OnSelectToDocumentEnd(object target, ExecutedRoutedEventArgs args);
    private static void HandleMoveByLineCompleted(object sender, BringLineIntoViewCompletedEventArgs e);
    private static void HandleMoveByPageCompleted(object sender, BringPageIntoViewCompletedEventArgs e);
    private static void HandleSelectByLineCompleted(object sender, BringLineIntoViewCompletedEventArgs e);
    private static void HandleSelectByPageCompleted(object sender, BringPageIntoViewCompletedEventArgs e);
    private static void OnQueryStatusKeyboardSelection(object target, CanExecuteRoutedEventArgs args);
    private static void OnQueryStatusCaretNavigation(object target, CanExecuteRoutedEventArgs args);
    private static void OnNYICommand(object source, ExecutedRoutedEventArgs args);
    private static void ClearSpringloadFormatting(TextEditor This);
    private static bool IsFlowDirectionRightToLeftThenTopToBottom(TextEditor textEditor);
    private static void MoveToCharacterLogicalDirection(TextEditor textEditor, LogicalDirection direction, bool extend);
    private static void NavigateWordLogicalDirection(TextEditor textEditor, LogicalDirection direction);
    private static void ExtendWordLogicalDirection(TextEditor textEditor, LogicalDirection direction);
    private static double GetSuggestedX(TextEditor This, ITextPointer& innerMovingPosition);
    private static double GetSuggestedYFromPosition(TextEditor This, ITextPointer position);
    private static void UpdateSuggestedXOnColumnOrPageBoundary(TextEditor This, double newSuggestedX);
    private static ITextPointer GetMovingPositionInner(TextEditor This);
    private static ITextPointer GetStartInner(TextEditor This);
    private static ITextPointer GetEndInner(TextEditor This);
    private static ITextPointer GetPositionAtLineStart(ITextPointer position);
    private static ITextPointer GetPositionAtLineEnd(ITextPointer position);
    private static void ExtendSelectionAndBringIntoView(ITextPointer position, TextEditor textEditor);
    private static void BringIntoView(ITextPointer position, TextEditor textEditor);
    private static void AdjustCaretAtTableRowEnd(TextEditor This);
    private static ITextPointer AdjustPositionAtTableRowEnd(ITextPointer position);
    private static FlowDirection GetScopingParagraphFlowDirection(ITextPointer position);
    private static double GetAbsoluteXOffset(ITextView textview, ITextPointer position);
    private static double GetViewportXOffset(ITextView textview, double suggestedX);
}
internal static class System.Windows.Documents.TextEditorSpelling : object {
    internal static void _RegisterClassHandlers(Type controlType, bool registerEventListeners);
    internal static SpellingError GetSpellingErrorAtPosition(TextEditor This, ITextPointer position, LogicalDirection direction);
    internal static SpellingError GetSpellingErrorAtSelection(TextEditor This);
    internal static ITextPointer GetNextSpellingErrorPosition(TextEditor This, ITextPointer position, LogicalDirection direction);
    private static void OnCorrectSpellingError(object target, ExecutedRoutedEventArgs args);
    private static bool IsErrorAtNonMergeableInlineEdge(SpellingError spellingError, ITextPointer& textStart, ITextPointer& textEnd);
    private static void OnIgnoreSpellingError(object target, ExecutedRoutedEventArgs args);
    private static void OnQueryStatusSpellingError(object target, CanExecuteRoutedEventArgs args);
    private static ITextPointer GetNextTextPosition(ITextPointer position, ITextPointer limit, LogicalDirection direction, Char& character);
    private static ITextPointer GetNextNonWhiteSpacePosition(ITextPointer position, ITextPointer limit);
    private static bool IsSelectionIgnoringErrors(ITextSelection selection);
}
internal static class System.Windows.Documents.TextEditorTables : object {
    private static string KeyDeleteColumns;
    private static string KeyInsertColumns;
    private static string KeyInsertRows;
    private static string KeyInsertTable;
    private static string KeyMergeCells;
    private static string KeySplitCell;
    internal static void _RegisterClassHandlers(Type controlType, bool registerEventListeners);
    private static void OnTableCommand(object target, ExecutedRoutedEventArgs args);
    private static void OnQueryStatusNYI(object target, CanExecuteRoutedEventArgs args);
}
internal class System.Windows.Documents.TextEditorThreadLocalStore : object {
    private int _inputLanguageChangeEventHandlerCount;
    private ArrayList _pendingInputItems;
    private bool _pureControlShift;
    private bool _bidi;
    private TextSelection _focusedTextSelection;
    private TextServicesHost _textServicesHost;
    private bool _hideCursor;
    internal int InputLanguageChangeEventHandlerCount { get; internal set; }
    internal ArrayList PendingInputItems { get; internal set; }
    internal bool PureControlShift { get; internal set; }
    internal bool Bidi { get; internal set; }
    internal TextSelection FocusedTextSelection { get; internal set; }
    internal TextServicesHost TextServicesHost { get; internal set; }
    internal bool HideCursor { get; internal set; }
    internal int get_InputLanguageChangeEventHandlerCount();
    internal void set_InputLanguageChangeEventHandlerCount(int value);
    internal ArrayList get_PendingInputItems();
    internal void set_PendingInputItems(ArrayList value);
    internal bool get_PureControlShift();
    internal void set_PureControlShift(bool value);
    internal bool get_Bidi();
    internal void set_Bidi(bool value);
    internal TextSelection get_FocusedTextSelection();
    internal void set_FocusedTextSelection(TextSelection value);
    internal TextServicesHost get_TextServicesHost();
    internal void set_TextServicesHost(TextServicesHost value);
    internal bool get_HideCursor();
    internal void set_HideCursor(bool value);
}
internal static class System.Windows.Documents.TextEditorTyping : object {
    private static string KeyBackspace;
    private static string KeyDelete;
    private static string KeyDeleteNextWord;
    private static string KeyDeletePreviousWord;
    private static string KeyEnterLineBreak;
    private static string KeyEnterParagraphBreak;
    private static string KeyShiftBackspace;
    private static string KeyShiftSpace;
    private static string KeySpace;
    private static string KeyTabBackward;
    private static string KeyTabForward;
    private static string KeyToggleInsert;
    internal static void _RegisterClassHandlers(Type controlType, bool registerEventListeners);
    internal static void _AddInputLanguageChangedEventHandler(TextEditor This);
    internal static void _RemoveInputLanguageChangedEventHandler(TextEditor This);
    internal static void _BreakTypingSequence(TextEditor This);
    internal static void _FlushPendingInputItems(TextEditor This);
    internal static void _ShowCursor();
    internal static void OnPreviewKeyDown(object sender, KeyEventArgs e);
    internal static void OnKeyDown(object sender, KeyEventArgs e);
    internal static void OnKeyUp(object sender, KeyEventArgs e);
    internal static void OnTextInput(object sender, TextCompositionEventArgs e);
    private static void OnQueryStatusCorrectionList(object target, CanExecuteRoutedEventArgs args);
    private static void OnCorrectionList(object target, ExecutedRoutedEventArgs args);
    private static void OnToggleInsert(object target, ExecutedRoutedEventArgs args);
    private static void OnSourceChanged(object sender, SourceChangedEventArgs args);
    private static void OnDelete(object sender, ExecutedRoutedEventArgs args);
    private static void OnBackspace(object sender, ExecutedRoutedEventArgs args);
    private static bool HandleDeleteWhenStructuralBoundaryIsCrossed(TextEditor This, TextPointer position, TextPointer deletePosition);
    private static bool IsAtIndentedParagraphOrBlockUIContainerStart(ITextPointer position);
    private static bool IsAtListItemStart(ITextPointer position);
    private static bool IsAtListItemChildStart(ITextPointer position, bool emptyChildOnly);
    private static bool IsBlockUIContainerBoundaryCrossed(TextPointer position1, TextPointer position2);
    private static void OnDeleteNextWord(object sender, ExecutedRoutedEventArgs args);
    private static void OnDeletePreviousWord(object sender, ExecutedRoutedEventArgs args);
    private static void OnQueryStatusEnterBreak(object sender, CanExecuteRoutedEventArgs args);
    private static void OnEnterBreak(object sender, ExecutedRoutedEventArgs args);
    private static bool HandleEnterBreakForRichText(TextEditor This, ICommand command);
    private static bool HandleEnterBreakForPlainText(TextEditor This);
    private static bool HandleEnterBreakWhenStructuralBoundaryIsCrossed(TextEditor This, ICommand command);
    private static void OnFlowDirectionCommand(TextEditor This, Key key);
    private static void OnSpace(object sender, ExecutedRoutedEventArgs e);
    private static void OnQueryStatusTabForward(object sender, CanExecuteRoutedEventArgs args);
    private static void OnQueryStatusTabBackward(object sender, CanExecuteRoutedEventArgs args);
    private static void OnTabForward(object sender, ExecutedRoutedEventArgs args);
    private static void OnTabBackward(object sender, ExecutedRoutedEventArgs args);
    private static bool HandleTabInTables(TextEditor This, LogicalDirection direction);
    private static void DoTextInput(TextEditor This, string textData, bool isInsertKeyToggled, bool acceptControlCharacters);
    private static void ScheduleInput(TextEditor This, InputItem item);
    private static bool IsMouseInputPending(TextEditor This);
    private static object BackgroundInputCallback(object This);
    private static void OnDispatcherShutdownFinished(object sender, EventArgs args);
    private static void OnInputLanguageChanged(object sender, InputLanguageEventArgs e);
    private static void OpenTypingUndoUnit(TextEditor This);
    private static void CloseTypingUndoUnit(TextEditor This, UndoCloseAction closeAction);
    private static void OnQueryStatusNYI(object target, CanExecuteRoutedEventArgs args);
    private static void OnMouseMove(object sender, MouseEventArgs e);
    private static void OnMouseLeave(object sender, MouseEventArgs e);
    private static void HideCursor(TextEditor This);
    private static void UpdateHyperlinkCursor(TextEditor This);
}
public static class System.Windows.Documents.TextEffectResolver : object {
    public static TextEffectTarget[] Resolve(TextPointer startPosition, TextPointer endPosition, TextEffect effect);
    private static void MoveToFirstCharacterSymbol(TextPointer navigator);
    private static void MoveToFirstNonCharacterSymbol(TextPointer navigator, TextPointer stopHint);
}
public class System.Windows.Documents.TextEffectTarget : object {
    private DependencyObject _element;
    private TextEffect _effect;
    public DependencyObject Element { get; }
    public TextEffect TextEffect { get; }
    public bool IsEnabled { get; }
    internal TextEffectTarget(DependencyObject element, TextEffect effect);
    public DependencyObject get_Element();
    public TextEffect get_TextEffect();
    public void Enable();
    public void Disable();
    public bool get_IsEnabled();
}
public abstract class System.Windows.Documents.TextElement : FrameworkContentElement {
    internal static UncommonField`1<TextElement> ContainerTextElementField;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty FontFamilyProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty FontStyleProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty FontWeightProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty FontStretchProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty FontSizeProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty ForegroundProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty BackgroundProperty;
    public static DependencyProperty TextEffectsProperty;
    private TextTreeTextElementNode _textElementNode;
    private TypographyProperties _typographyPropertiesGroup;
    internal TextRange TextRange { get; }
    public TextPointer ElementStart { get; }
    internal StaticTextPointer StaticElementStart { get; }
    public TextPointer ContentStart { get; }
    internal StaticTextPointer StaticContentStart { get; }
    public TextPointer ContentEnd { get; }
    internal StaticTextPointer StaticContentEnd { get; }
    public TextPointer ElementEnd { get; }
    internal StaticTextPointer StaticElementEnd { get; }
    [LocalizabilityAttribute("14")]
public FontFamily FontFamily { get; public set; }
    public FontStyle FontStyle { get; public set; }
    public FontWeight FontWeight { get; public set; }
    public FontStretch FontStretch { get; public set; }
    [TypeConverterAttribute("System.Windows.FontSizeConverter")]
[LocalizabilityAttribute("0")]
public double FontSize { get; public set; }
    public Brush Foreground { get; public set; }
    public Brush Background { get; public set; }
    public TextEffectCollection TextEffects { get; public set; }
    public Typography Typography { get; }
    protected internal IEnumerator LogicalChildren { get; }
    internal TextContainer TextContainer { get; }
    internal bool IsEmpty { get; }
    internal bool IsInTree { get; }
    internal int ElementStartOffset { get; }
    internal int ContentStartOffset { get; }
    internal int ContentEndOffset { get; }
    internal int ElementEndOffset { get; }
    internal int SymbolCount { get; }
    internal TextTreeTextElementNode TextElementNode { get; internal set; }
    internal TypographyProperties TypographyPropertiesGroup { get; }
    internal bool IsIMEStructuralElement { get; }
    internal int IMELeftEdgeCharCount { get; }
    internal bool IsFirstIMEVisibleSibling { get; }
    internal TextElement NextElement { get; }
    internal TextElement PreviousElement { get; }
    internal TextElement FirstChildElement { get; }
    internal TextElement LastChildElement { get; }
    private static TextElement();
    internal void Reposition(TextPointer start, TextPointer end);
    internal void RepositionWithContent(TextPointer textPosition);
    internal TextRange get_TextRange();
    public TextPointer get_ElementStart();
    internal StaticTextPointer get_StaticElementStart();
    public TextPointer get_ContentStart();
    internal StaticTextPointer get_StaticContentStart();
    public TextPointer get_ContentEnd();
    internal StaticTextPointer get_StaticContentEnd();
    internal bool Contains(TextPointer position);
    public TextPointer get_ElementEnd();
    internal StaticTextPointer get_StaticElementEnd();
    public FontFamily get_FontFamily();
    public void set_FontFamily(FontFamily value);
    public static void SetFontFamily(DependencyObject element, FontFamily value);
    public static FontFamily GetFontFamily(DependencyObject element);
    public FontStyle get_FontStyle();
    public void set_FontStyle(FontStyle value);
    public static void SetFontStyle(DependencyObject element, FontStyle value);
    public static FontStyle GetFontStyle(DependencyObject element);
    public FontWeight get_FontWeight();
    public void set_FontWeight(FontWeight value);
    public static void SetFontWeight(DependencyObject element, FontWeight value);
    public static FontWeight GetFontWeight(DependencyObject element);
    public FontStretch get_FontStretch();
    public void set_FontStretch(FontStretch value);
    public static void SetFontStretch(DependencyObject element, FontStretch value);
    public static FontStretch GetFontStretch(DependencyObject element);
    public double get_FontSize();
    public void set_FontSize(double value);
    public static void SetFontSize(DependencyObject element, double value);
    [TypeConverterAttribute("System.Windows.FontSizeConverter")]
public static double GetFontSize(DependencyObject element);
    public Brush get_Foreground();
    public void set_Foreground(Brush value);
    public static void SetForeground(DependencyObject element, Brush value);
    public static Brush GetForeground(DependencyObject element);
    public Brush get_Background();
    public void set_Background(Brush value);
    public TextEffectCollection get_TextEffects();
    public void set_TextEffects(TextEffectCollection value);
    public Typography get_Typography();
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object value);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string text);
    protected internal virtual IEnumerator get_LogicalChildren();
    protected virtual void OnPropertyChanged(DependencyPropertyChangedEventArgs e);
    internal void NotifyTypographicPropertyChanged(bool affectsMeasureOrArrange, bool localValueChanged, DependencyProperty property);
    internal static TypographyProperties GetTypographyProperties(DependencyObject element);
    internal void DeepEndInit();
    internal static TextElement GetCommonAncestor(TextElement element1, TextElement element2);
    internal virtual void OnTextUpdated();
    internal virtual void BeforeLogicalTreeChange();
    internal virtual void AfterLogicalTreeChange();
    internal TextContainer get_TextContainer();
    internal bool get_IsEmpty();
    internal bool get_IsInTree();
    internal int get_ElementStartOffset();
    internal int get_ContentStartOffset();
    internal int get_ContentEndOffset();
    internal int get_ElementEndOffset();
    internal int get_SymbolCount();
    internal TextTreeTextElementNode get_TextElementNode();
    internal void set_TextElementNode(TextTreeTextElementNode value);
    internal TypographyProperties get_TypographyPropertiesGroup();
    private static void OnTypographyChanged(DependencyObject element, DependencyPropertyChangedEventArgs e);
    internal virtual bool get_IsIMEStructuralElement();
    internal int get_IMELeftEdgeCharCount();
    internal virtual bool get_IsFirstIMEVisibleSibling();
    internal TextElement get_NextElement();
    internal TextElement get_PreviousElement();
    internal TextElement get_FirstChildElement();
    internal TextElement get_LastChildElement();
    private void Append(string textData);
    private void Append(TextElement element);
    private TextContainer EnsureTextContainer();
    private static bool IsValidFontFamily(object o);
    private static bool IsValidFontSize(object value);
}
public class System.Windows.Documents.TextElementCollection`1 : object {
    private DependencyObject _owner;
    private bool _isOwnerParent;
    private ElementIndexCache<TextElementType> _indexCache;
    public int Count { get; }
    public bool IsReadOnly { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private object System.Collections.IList.Item { get; private set; }
    private int System.Collections.ICollection.Count { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    internal DependencyObject Owner { get; }
    internal DependencyObject Parent { get; }
    internal TextContainer TextContainer { get; }
    internal TextElementType FirstChild { get; }
    internal TextElementType LastChild { get; }
    private TextPointer ContentStart { get; }
    private TextPointer ContentEnd { get; }
    internal TextElementCollection`1(DependencyObject owner, bool isOwnerParent);
    public sealed virtual void Add(TextElementType item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(TextElementType item);
    public sealed virtual void CopyTo(TextElementType[] array, int arrayIndex);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool Remove(TextElementType item);
    public void InsertAfter(TextElementType previousSibling, TextElementType newItem);
    public void InsertBefore(TextElementType nextSibling, TextElementType newItem);
    public void AddRange(IEnumerable range);
    public sealed virtual IEnumerator`1<TextElementType> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    internal virtual int OnAdd(object value);
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override void System.Collections.IList.Clear();
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.IList.RemoveAt(int index);
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int arrayIndex);
    private sealed virtual override int System.Collections.ICollection.get_Count();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    internal DependencyObject get_Owner();
    internal DependencyObject get_Parent();
    internal TextContainer get_TextContainer();
    internal TextElementType get_FirstChild();
    internal TextElementType get_LastChild();
    private TextElementType RemoveAtInternal(int index);
    private TextElementType GetElementAtIndex(int index);
    private TextElementType GetElementAtIndex(int index, Boolean& atCollectionEnd);
    private void SetCache(int index, TextElementType item);
    private int IndexOfInternal(object value, bool isCacheSafePreviousIndex);
    internal virtual void ValidateChild(TextElementType child);
    private TextPointer get_ContentStart();
    private TextPointer get_ContentEnd();
}
internal static class System.Windows.Documents.TextElementCollectionHelper : object {
    private static WeakReference[] _cleanParentList;
    private static TextElementCollectionHelper();
    internal static void MarkDirty(DependencyObject parent);
    internal static void MarkClean(DependencyObject parent, object collection);
    internal static bool IsCleanParent(DependencyObject parent, object collection);
    private static void TouchCleanParent(int index);
    private static int GetCleanParentIndex(DependencyObject parent, object collection, Int32& firstFreeIndex);
}
[AttributeUsageAttribute("4")]
public class System.Windows.Documents.TextElementEditingBehaviorAttribute : Attribute {
    private bool _isMergeable;
    private bool _isTypographicOnly;
    public bool IsMergeable { get; public set; }
    public bool IsTypographicOnly { get; public set; }
    public bool get_IsMergeable();
    public void set_IsMergeable(bool value);
    public bool get_IsTypographicOnly();
    public void set_IsTypographicOnly(bool value);
}
internal class System.Windows.Documents.TextElementEnumerator`1 : object {
    private TextPointer _start;
    private TextPointer _end;
    private UInt32 _generation;
    private TextPointer _navigator;
    private TextElementType _current;
    private object System.Collections.IEnumerator.Current { get; }
    public TextElementType Current { get; }
    internal TextElementEnumerator`1(TextPointer start, TextPointer end);
    public sealed virtual void Dispose();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual TextElementType get_Current();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
}
internal static class System.Windows.Documents.TextFindEngine : object {
    private static int TextBlockLength;
    private static char UnicodeBidiStart;
    private static char UnicodeBidiEnd;
    private static char UnicodeArabicKashida;
    private static char UnicodeArabicAlefMaddaAbove;
    private static char UnicodeArabicAlefHamzaAbove;
    private static char UnicodeArabicAlefHamzaBelow;
    private static char UnicodeArabicAlef;
    public static ITextRange Find(ITextPointer findContainerStartPosition, ITextPointer findContainerEndPosition, string findPattern, FindFlags flags, CultureInfo cultureInfo);
    internal static TextRange InternalFind(ITextPointer startPosition, ITextPointer endPosition, string findPattern, CultureInfo cultureInfo, bool matchCase, bool matchWholeWord, bool matchLast, bool matchDiacritics, bool matchKashida, bool matchAlefHamza);
    private static void GetContextualInformation(ITextPointer position, int oppositeEndOffset, Boolean& hasPreceedingSeparatorChar, Boolean& hasFollowingSeparatorChar);
    private static bool HasNeighboringSeparatorChar(ITextPointer position, LogicalDirection direction);
    private static int FindMatchIndexFromFindContent(string textString, string findPattern, CultureInfo cultureInfo, bool matchCase, bool matchWholeWord, bool matchLast, bool matchDiacritics, bool matchKashida, bool matchAlefHamza, bool hasPreceedingSeparatorChar, bool hasFollowingSeparatorChar, Int32& matchLength);
    private static int StandardMatchIndexCalculation(string textString, string findPattern, bool matchWholeWord, bool matchLast, bool ignoreCase, CompareInfo compareInfo, bool hasPreceedingSeparatorChar, bool hasFollowingSeparatorChar, Int32& matchLength);
    private static int BidiIgnoreDiacriticsMatchIndexCalculation(string textString, string findPattern, bool matchKashida, bool matchAlefHamza, bool matchWholeWord, bool matchLast, bool ignoreCase, CompareInfo compareInfo, bool hasPreceedingSeparatorChar, bool hasFollowingSeparatorChar, Int32& matchLength);
    private static int FindNLSString(int locale, UInt32 flags, string sourceString, string findString, Int32& found);
    private static bool IsKashidaMatch(string text, string pattern, CompareInfo compareInfo);
    private static bool IsAlefHamzaMatch(string text, string pattern, CompareInfo compareInfo);
    private static int SetFindTextAndFindTextPositionMap(ITextPointer startPosition, ITextPointer endPosition, ITextPointer navigator, LogicalDirection direction, bool matchLast, Char[] findText, Int32[] findTextPositionMap);
    internal static void InitializeBidiFlags(string textString, Boolean& stringContainedBidiCharacter, Boolean& stringContainedAlefCharacter);
    internal static string ReplaceAlefHamzaWithAlef(string textString);
    private static bool IsAtWordBoundary(string textString, int matchIndex, int matchLength, bool hasPreceedingSeparatorChar, bool hasFollowingSeparatorChar);
    private static bool IsSeparatorChar(char separatorChar);
    private static bool IsAdjacentToFormatElement(ITextPointer pointer, LogicalDirection direction);
}
internal class System.Windows.Documents.TextParentUndoUnit : ParentUndoUnit {
    private ITextSelection _selection;
    private int _undoAnchorPositionOffset;
    private LogicalDirection _undoAnchorPositionDirection;
    private int _undoMovingPositionOffset;
    private LogicalDirection _undoMovingPositionDirection;
    private int _redoAnchorPositionOffset;
    private LogicalDirection _redoAnchorPositionDirection;
    private int _redoMovingPositionOffset;
    private LogicalDirection _redoMovingPositionDirection;
    private TextParentUndoUnit _redoUnit;
    internal TextParentUndoUnit(ITextSelection selection);
    internal TextParentUndoUnit(ITextSelection selection, ITextPointer anchorPosition, ITextPointer movingPosition);
    protected TextParentUndoUnit(TextParentUndoUnit undoUnit);
    public virtual void Do();
    protected virtual IParentUndoUnit CreateParentUndoUnitForSelf();
    protected virtual TextParentUndoUnit CreateRedoUnit();
    protected void MergeRedoSelectionState(TextParentUndoUnit undoUnit);
    internal void RecordRedoSelectionState();
    internal void RecordRedoSelectionState(ITextPointer anchorPosition, ITextPointer movingPosition);
}
public class System.Windows.Documents.TextPointer : ContentPosition {
    private TextContainer _tree;
    private TextTreeNode _node;
    private UInt32 _generation;
    private UInt32 _layoutGeneration;
    private UInt32 _flags;
    public bool HasValidLayout { get; }
    public LogicalDirection LogicalDirection { get; }
    public DependencyObject Parent { get; }
    public bool IsAtInsertionPosition { get; }
    public bool IsAtLineStartPosition { get; }
    public Paragraph Paragraph { get; }
    internal Block ParagraphOrBlockUIContainer { get; }
    public TextPointer DocumentStart { get; }
    public TextPointer DocumentEnd { get; }
    internal bool IsFrozen { get; }
    private Type System.Windows.Documents.ITextPointer.ParentType { get; }
    private ITextContainer System.Windows.Documents.ITextPointer.TextContainer { get; }
    private bool System.Windows.Documents.ITextPointer.HasValidLayout { get; }
    private bool System.Windows.Documents.ITextPointer.IsAtCaretUnitBoundary { get; }
    private LogicalDirection System.Windows.Documents.ITextPointer.LogicalDirection { get; }
    private bool System.Windows.Documents.ITextPointer.IsAtInsertionPosition { get; }
    private bool System.Windows.Documents.ITextPointer.IsFrozen { get; }
    private int System.Windows.Documents.ITextPointer.Offset { get; }
    internal int Offset { get; }
    private int System.Windows.Documents.ITextPointer.CharOffset { get; }
    internal int CharOffset { get; }
    internal TextContainer TextContainer { get; }
    internal FrameworkElement ContainingFrameworkElement { get; }
    internal bool IsAtRowEnd { get; }
    internal bool HasNonMergeableInlineAncestor { get; }
    internal bool IsAtNonMergeableInlineStart { get; }
    internal TextTreeNode Node { get; }
    internal ElementEdge Edge { get; }
    internal Block ParentBlock { get; }
    private bool IsCaretUnitBoundaryCacheValid { get; private set; }
    private bool CaretUnitBoundaryCache { get; private set; }
    internal TextPointer(TextPointer textPointer);
    internal TextPointer(TextPointer position, int offset);
    internal TextPointer(TextPointer position, LogicalDirection direction);
    internal TextPointer(TextPointer position, int offset, LogicalDirection direction);
    internal TextPointer(TextContainer textContainer, int offset, LogicalDirection direction);
    internal TextPointer(TextContainer tree, TextTreeNode node, ElementEdge edge);
    internal TextPointer(TextContainer tree, TextTreeNode node, ElementEdge edge, LogicalDirection direction);
    internal TextPointer CreatePointer();
    internal TextPointer CreatePointer(LogicalDirection gravity);
    public bool IsInSameDocument(TextPointer textPosition);
    public int CompareTo(TextPointer position);
    public TextPointerContext GetPointerContext(LogicalDirection direction);
    public int GetTextRunLength(LogicalDirection direction);
    public int GetOffsetToPosition(TextPointer position);
    public string GetTextInRun(LogicalDirection direction);
    public int GetTextInRun(LogicalDirection direction, Char[] textBuffer, int startIndex, int count);
    public DependencyObject GetAdjacentElement(LogicalDirection direction);
    public TextPointer GetPositionAtOffset(int offset);
    public TextPointer GetPositionAtOffset(int offset, LogicalDirection direction);
    public TextPointer GetNextContextPosition(LogicalDirection direction);
    public TextPointer GetInsertionPosition(LogicalDirection direction);
    internal TextPointer GetInsertionPosition();
    public TextPointer GetNextInsertionPosition(LogicalDirection direction);
    public TextPointer GetLineStartPosition(int count);
    public TextPointer GetLineStartPosition(int count, Int32& actualCount);
    public Rect GetCharacterRect(LogicalDirection direction);
    public void InsertTextInRun(string textData);
    public int DeleteTextInRun(int count);
    internal void InsertTextElement(TextElement textElement);
    public TextPointer InsertParagraphBreak();
    public TextPointer InsertLineBreak();
    public virtual string ToString();
    public bool get_HasValidLayout();
    public LogicalDirection get_LogicalDirection();
    public DependencyObject get_Parent();
    public bool get_IsAtInsertionPosition();
    public bool get_IsAtLineStartPosition();
    public Paragraph get_Paragraph();
    internal Block get_ParagraphOrBlockUIContainer();
    public TextPointer get_DocumentStart();
    public TextPointer get_DocumentEnd();
    internal Inline GetNonMergeableInlineAncestor();
    internal ListItem GetListAncestor();
    internal static int GetTextInRun(TextContainer textContainer, int symbolOffset, TextTreeTextNode textNode, int nodeOffset, LogicalDirection direction, Char[] textBuffer, int startIndex, int count);
    internal static DependencyObject GetAdjacentElement(TextTreeNode node, ElementEdge edge, LogicalDirection direction);
    internal void MoveToPosition(TextPointer textPosition);
    internal int MoveByOffset(int offset);
    internal bool MoveToNextContextPosition(LogicalDirection direction);
    internal bool MoveToInsertionPosition(LogicalDirection direction);
    internal bool MoveToNextInsertionPosition(LogicalDirection direction);
    internal int MoveToLineBoundary(int count);
    internal void InsertUIElement(UIElement uiElement);
    internal TextElement GetAdjacentElementFromOuterPosition(LogicalDirection direction);
    internal void SetLogicalDirection(LogicalDirection direction);
    internal bool get_IsFrozen();
    internal void Freeze();
    internal TextPointer GetFrozenPointer(LogicalDirection logicalDirection);
    private sealed virtual override void System.Windows.Documents.ITextPointer.SetLogicalDirection(LogicalDirection direction);
    private sealed virtual override int System.Windows.Documents.ITextPointer.CompareTo(ITextPointer position);
    private sealed virtual override int System.Windows.Documents.ITextPointer.CompareTo(StaticTextPointer position);
    private sealed virtual override int System.Windows.Documents.ITextPointer.GetOffsetToPosition(ITextPointer position);
    private sealed virtual override TextPointerContext System.Windows.Documents.ITextPointer.GetPointerContext(LogicalDirection direction);
    private sealed virtual override int System.Windows.Documents.ITextPointer.GetTextRunLength(LogicalDirection direction);
    private sealed virtual override string System.Windows.Documents.ITextPointer.GetTextInRun(LogicalDirection direction);
    private sealed virtual override int System.Windows.Documents.ITextPointer.GetTextInRun(LogicalDirection direction, Char[] textBuffer, int startIndex, int count);
    private sealed virtual override object System.Windows.Documents.ITextPointer.GetAdjacentElement(LogicalDirection direction);
    private sealed virtual override Type System.Windows.Documents.ITextPointer.GetElementType(LogicalDirection direction);
    private sealed virtual override bool System.Windows.Documents.ITextPointer.HasEqualScope(ITextPointer position);
    private sealed virtual override ITextPointer System.Windows.Documents.ITextPointer.GetNextContextPosition(LogicalDirection direction);
    private sealed virtual override ITextPointer System.Windows.Documents.ITextPointer.GetInsertionPosition(LogicalDirection direction);
    private sealed virtual override ITextPointer System.Windows.Documents.ITextPointer.GetFormatNormalizedPosition(LogicalDirection direction);
    private sealed virtual override ITextPointer System.Windows.Documents.ITextPointer.GetNextInsertionPosition(LogicalDirection direction);
    private sealed virtual override object System.Windows.Documents.ITextPointer.GetValue(DependencyProperty formattingProperty);
    private sealed virtual override object System.Windows.Documents.ITextPointer.ReadLocalValue(DependencyProperty formattingProperty);
    private sealed virtual override LocalValueEnumerator System.Windows.Documents.ITextPointer.GetLocalValueEnumerator();
    private sealed virtual override ITextPointer System.Windows.Documents.ITextPointer.CreatePointer();
    private sealed virtual override StaticTextPointer System.Windows.Documents.ITextPointer.CreateStaticPointer();
    private sealed virtual override ITextPointer System.Windows.Documents.ITextPointer.CreatePointer(int offset);
    private sealed virtual override ITextPointer System.Windows.Documents.ITextPointer.CreatePointer(LogicalDirection gravity);
    private sealed virtual override ITextPointer System.Windows.Documents.ITextPointer.CreatePointer(int offset, LogicalDirection gravity);
    private sealed virtual override void System.Windows.Documents.ITextPointer.Freeze();
    private sealed virtual override ITextPointer System.Windows.Documents.ITextPointer.GetFrozenPointer(LogicalDirection logicalDirection);
    private sealed virtual override bool System.Windows.Documents.ITextPointer.MoveToNextContextPosition(LogicalDirection direction);
    private sealed virtual override int System.Windows.Documents.ITextPointer.MoveByOffset(int offset);
    private sealed virtual override void System.Windows.Documents.ITextPointer.MoveToPosition(ITextPointer position);
    private sealed virtual override void System.Windows.Documents.ITextPointer.MoveToElementEdge(ElementEdge edge);
    internal void MoveToElementEdge(ElementEdge edge);
    private sealed virtual override int System.Windows.Documents.ITextPointer.MoveToLineBoundary(int count);
    private sealed virtual override Rect System.Windows.Documents.ITextPointer.GetCharacterRect(LogicalDirection direction);
    private sealed virtual override bool System.Windows.Documents.ITextPointer.MoveToInsertionPosition(LogicalDirection direction);
    private sealed virtual override bool System.Windows.Documents.ITextPointer.MoveToNextInsertionPosition(LogicalDirection direction);
    private sealed virtual override void System.Windows.Documents.ITextPointer.InsertTextInRun(string textData);
    private sealed virtual override void System.Windows.Documents.ITextPointer.DeleteContentToPosition(ITextPointer limit);
    private sealed virtual override bool System.Windows.Documents.ITextPointer.ValidateLayout();
    internal bool ValidateLayout();
    internal TextTreeTextNode GetAdjacentTextNodeSibling(LogicalDirection direction);
    internal static TextTreeTextNode GetAdjacentTextNodeSibling(TextTreeNode node, ElementEdge edge, LogicalDirection direction);
    internal TextTreeTextElementNode GetAdjacentTextElementNodeSibling(LogicalDirection direction);
    internal TextTreeTextElementNode GetAdjacentTextElementNode(LogicalDirection direction);
    internal TextTreeNode GetAdjacentSiblingNode(LogicalDirection direction);
    internal static TextTreeNode GetAdjacentSiblingNode(TextTreeNode node, ElementEdge edge, LogicalDirection direction);
    internal int GetSymbolOffset();
    internal static int GetSymbolOffset(TextContainer tree, TextTreeNode node, ElementEdge edge);
    internal DependencyObject GetLogicalTreeNode();
    internal void SyncToTreeGeneration();
    internal TextTreeNode GetScopingNode();
    internal static TextTreeNode GetScopingNode(TextTreeNode node, ElementEdge edge);
    internal void DebugAssertGeneration();
    internal bool GetNextNodeAndEdge(TextTreeNode& node, ElementEdge& edge);
    internal static bool GetNextNodeAndEdge(TextTreeNode sourceNode, ElementEdge sourceEdge, bool plainTextOnly, TextTreeNode& node, ElementEdge& edge);
    internal bool GetPreviousNodeAndEdge(TextTreeNode& node, ElementEdge& edge);
    internal static bool GetPreviousNodeAndEdge(TextTreeNode sourceNode, ElementEdge sourceEdge, bool plainTextOnly, TextTreeNode& node, ElementEdge& edge);
    internal static TextPointerContext GetPointerContextForward(TextTreeNode node, ElementEdge edge);
    internal static TextPointerContext GetPointerContextBackward(TextTreeNode node, ElementEdge edge);
    internal void InsertInline(Inline inline);
    internal static DependencyObject GetCommonAncestor(TextPointer position1, TextPointer position2);
    private sealed virtual override Type System.Windows.Documents.ITextPointer.get_ParentType();
    private sealed virtual override ITextContainer System.Windows.Documents.ITextPointer.get_TextContainer();
    private sealed virtual override bool System.Windows.Documents.ITextPointer.get_HasValidLayout();
    private sealed virtual override bool System.Windows.Documents.ITextPointer.get_IsAtCaretUnitBoundary();
    private sealed virtual override LogicalDirection System.Windows.Documents.ITextPointer.get_LogicalDirection();
    private sealed virtual override bool System.Windows.Documents.ITextPointer.get_IsAtInsertionPosition();
    private sealed virtual override bool System.Windows.Documents.ITextPointer.get_IsFrozen();
    private sealed virtual override int System.Windows.Documents.ITextPointer.get_Offset();
    internal int get_Offset();
    private sealed virtual override int System.Windows.Documents.ITextPointer.get_CharOffset();
    internal int get_CharOffset();
    internal TextContainer get_TextContainer();
    internal FrameworkElement get_ContainingFrameworkElement();
    internal bool get_IsAtRowEnd();
    internal bool get_HasNonMergeableInlineAncestor();
    internal bool get_IsAtNonMergeableInlineStart();
    internal TextTreeNode get_Node();
    internal ElementEdge get_Edge();
    internal Block get_ParentBlock();
    private void InitializeOffset(TextPointer position, int distance, LogicalDirection direction);
    private void Initialize(TextContainer tree, TextTreeNode node, ElementEdge edge, LogicalDirection gravity, UInt32 generation, bool caretUnitBoundaryCache, bool isCaretUnitBoundaryCacheValid, UInt32 layoutGeneration);
    private void VerifyNotFrozen();
    private TextTreeNode AdjustRefCounts(TextTreeNode newNode, ElementEdge newNodeEdge, TextTreeNode oldNode, ElementEdge oldNodeEdge);
    private static void RepositionForGravity(TextTreeNode& node, ElementEdge& edge, LogicalDirection gravity);
    private LogicalDirection GetGravityInternal();
    private DependencyObject GetDependencyParent();
    internal TextTreeNode GetAdjacentNode(LogicalDirection direction);
    internal static TextTreeNode GetAdjacentNode(TextTreeNode node, ElementEdge edge, LogicalDirection direction);
    private void MoveToNode(TextContainer tree, TextTreeNode node, ElementEdge edge);
    private TextElement GetElement(LogicalDirection direction);
    private void AssertState();
    private void SetNodeAndEdge(TextTreeNode node, ElementEdge edge);
    private void SetIsFrozen();
    private void VerifyFlags();
    private bool get_IsCaretUnitBoundaryCacheValid();
    private void set_IsCaretUnitBoundaryCacheValid(bool value);
    private bool get_CaretUnitBoundaryCache();
    private void set_CaretUnitBoundaryCache(bool value);
}
internal static class System.Windows.Documents.TextPointerBase : object {
    internal static Char[] NextLineCharacters;
    private static TextPointerBase();
    internal static ITextPointer Min(ITextPointer position1, ITextPointer position2);
    internal static ITextPointer Max(ITextPointer position1, ITextPointer position2);
    internal static string GetTextInRun(ITextPointer position, LogicalDirection direction);
    internal static int GetTextWithLimit(ITextPointer thisPointer, LogicalDirection direction, Char[] textBuffer, int startIndex, int count, ITextPointer limit);
    internal static bool IsAtInsertionPosition(ITextPointer position);
    internal static bool IsAtPotentialRunPosition(ITextPointer position);
    internal static bool IsAtPotentialRunPosition(TextElement run);
    private static bool IsAtPotentialRunPosition(ITextPointer backwardPosition, ITextPointer forwardPosition);
    internal static bool IsAtPotentialParagraphPosition(ITextPointer position);
    internal static bool IsBeforeFirstTable(ITextPointer position);
    internal static bool IsInBlockUIContainer(ITextPointer position);
    internal static bool IsAtBlockUIContainerStart(ITextPointer position);
    internal static bool IsAtBlockUIContainerEnd(ITextPointer position);
    private static bool IsInAncestorScope(ITextPointer position, Type allowedParentType, Type limitingType);
    internal static bool IsInAnchoredBlock(ITextPointer position);
    internal static bool IsInHyperlinkScope(ITextPointer position);
    internal static ITextPointer GetFollowingNonMergeableInlineContentStart(ITextPointer position);
    internal static bool IsAtNonMergeableInlineStart(ITextPointer position);
    internal static bool IsAtNonMergeableInlineEnd(ITextPointer position);
    internal static bool IsPositionAtNonMergeableInlineBoundary(ITextPointer position);
    internal static bool IsAtFormatNormalizedPosition(ITextPointer position, LogicalDirection direction);
    internal static bool IsAtInsertionPosition(ITextPointer position, LogicalDirection direction);
    internal static bool IsAtNormalizedPosition(ITextPointer position, LogicalDirection direction, bool respectCaretUnitBoundaries);
    internal static int GetOffset(ITextPointer thisPosition);
    internal static bool IsAtWordBoundary(ITextPointer thisPosition, LogicalDirection insideWordDirection);
    internal static TextSegment GetWordRange(ITextPointer thisPosition);
    internal static TextSegment GetWordRange(ITextPointer thisPosition, LogicalDirection direction);
    private static ITextPointer RestrictWithinBlock(ITextPointer position, ITextPointer limit, LogicalDirection direction);
    internal static bool IsNextToPlainLineBreak(ITextPointer thisPosition, LogicalDirection direction);
    internal static bool IsCharUnicodeNewLine(char ch);
    internal static bool IsNextToRichLineBreak(ITextPointer thisPosition, LogicalDirection direction);
    internal static bool IsNextToParagraphBreak(ITextPointer thisPosition, LogicalDirection direction);
    internal static bool IsNextToAnyBreak(ITextPointer thisPosition, LogicalDirection direction);
    internal static bool IsAtLineWrappingPosition(ITextPointer position, ITextView textView);
    internal static bool IsAtRowEnd(ITextPointer thisPosition);
    internal static bool IsAfterLastParagraph(ITextPointer thisPosition);
    internal static bool IsAtParagraphOrBlockUIContainerStart(ITextPointer pointer);
    internal static ListItem GetListItem(TextPointer pointer);
    internal static ListItem GetImmediateListItem(TextPointer position);
    internal static bool IsInEmptyListItem(TextPointer position);
    internal static int MoveToLineBoundary(ITextPointer thisPointer, ITextView textView, int count);
    internal static int MoveToLineBoundary(ITextPointer thisPointer, ITextView textView, int count, bool respectNonMeargeableInlineStart);
    internal static Rect GetCharacterRect(ITextPointer thisPointer, LogicalDirection direction);
    internal static Rect GetCharacterRect(ITextPointer thisPointer, LogicalDirection direction, bool transformToUiScope);
    internal static bool MoveToFormatNormalizedPosition(ITextPointer thisNavigator, LogicalDirection direction);
    internal static bool MoveToInsertionPosition(ITextPointer thisNavigator, LogicalDirection direction);
    internal static bool MoveToNextInsertionPosition(ITextPointer thisNavigator, LogicalDirection direction);
    internal static bool MoveToNextWordBoundary(ITextPointer thisNavigator, LogicalDirection movingDirection);
    internal static ITextPointer GetFrozenPointer(ITextPointer thisPointer, LogicalDirection logicalDirection);
    internal static bool ValidateLayout(ITextPointer thisPointer, ITextView textView);
    private static bool NormalizePosition(ITextPointer thisNavigator, LogicalDirection direction, bool respectCaretUnitBoundaries);
    private static int LeaveNonMergeableInlineBoundary(ITextPointer thisNavigator, LogicalDirection direction, int symbolCount);
    private static int LeaveNonMergeableAncestor(ITextPointer thisNavigator, LogicalDirection direction);
    private static bool IsAtNormalizedPosition(ITextPointer position, bool respectCaretUnitBoundaries);
    private static bool IsAtCaretUnitBoundary(ITextPointer position);
    private static bool IsInsideCompoundSequence(ITextPointer position);
    private static void GetWordBreakerText(ITextPointer pointer, Char[]& text, Int32& position);
    private static bool IsAtNonMergeableInlineEdge(ITextPointer position, LogicalDirection direction);
    private static BorderingElementCategory GetBorderingElementCategory(ITextPointer position, LogicalDirection direction);
    private static bool IsNextToRichBreak(ITextPointer thisPosition, LogicalDirection direction, Type lineBreakType);
}
public enum System.Windows.Documents.TextPointerContext : Enum {
    public int value__;
    public static TextPointerContext None;
    public static TextPointerContext Text;
    public static TextPointerContext EmbeddedElement;
    public static TextPointerContext ElementStart;
    public static TextPointerContext ElementEnd;
}
public class System.Windows.Documents.TextRange : object {
    [CompilerGeneratedAttribute]
private EventHandler Changed;
    private List`1<TextSegment> _textSegments;
    private int _changeBlockLevel;
    private ChangeBlockUndoRecord _changeBlockUndoRecord;
    private UInt32 _ContentGeneration;
    private Flags _flags;
    private bool _useRestrictiveXamlXmlReader;
    private bool System.Windows.Documents.ITextRange.IgnoreTextUnitBoundaries { get; }
    private ITextPointer System.Windows.Documents.ITextRange.Start { get; }
    private ITextPointer System.Windows.Documents.ITextRange.End { get; }
    private bool System.Windows.Documents.ITextRange.IsEmpty { get; }
    private List`1<TextSegment> System.Windows.Documents.ITextRange.TextSegments { get; }
    private bool System.Windows.Documents.ITextRange.HasConcreteTextContainer { get; }
    private string System.Windows.Documents.ITextRange.Text { get; private set; }
    private string System.Windows.Documents.ITextRange.Xml { get; }
    private int System.Windows.Documents.ITextRange.ChangeBlockLevel { get; }
    private bool System.Windows.Documents.ITextRange.IsTableCellRange { get; }
    private bool System.Windows.Documents.ITextRange._IsTableCellRange { get; private set; }
    private List`1<TextSegment> System.Windows.Documents.ITextRange._TextSegments { get; private set; }
    private int System.Windows.Documents.ITextRange._ChangeBlockLevel { get; private set; }
    private ChangeBlockUndoRecord System.Windows.Documents.ITextRange._ChangeBlockUndoRecord { get; private set; }
    private bool System.Windows.Documents.ITextRange._IsChanged { get; private set; }
    private UInt32 System.Windows.Documents.ITextRange._ContentGeneration { get; private set; }
    public TextPointer Start { get; }
    public TextPointer End { get; }
    public bool IsEmpty { get; }
    internal bool HasConcreteTextContainer { get; }
    internal FrameworkElement ContainingFrameworkElement { get; }
    public string Text { get; public set; }
    internal string Xml { get; internal set; }
    internal bool IsTableCellRange { get; }
    internal bool _IsChanged { get; internal set; }
    internal int ChangeBlockLevel { get; }
    public TextRange(TextPointer position1, TextPointer position2);
    internal TextRange(ITextPointer position1, ITextPointer position2);
    internal TextRange(ITextPointer position1, ITextPointer position2, bool ignoreTextUnitBoundaries);
    internal TextRange(TextPointer position1, TextPointer position2, bool useRestrictiveXamlXmlReader);
    private sealed virtual override bool System.Windows.Documents.ITextRange.Contains(ITextPointer position);
    private sealed virtual override void System.Windows.Documents.ITextRange.Select(ITextPointer position1, ITextPointer position2);
    private sealed virtual override void System.Windows.Documents.ITextRange.SelectWord(ITextPointer position);
    private sealed virtual override void System.Windows.Documents.ITextRange.SelectParagraph(ITextPointer position);
    private sealed virtual override void System.Windows.Documents.ITextRange.ApplyTypingHeuristics(bool overType);
    private sealed virtual override object System.Windows.Documents.ITextRange.GetPropertyValue(DependencyProperty formattingProperty);
    private sealed virtual override UIElement System.Windows.Documents.ITextRange.GetUIElementSelected();
    private sealed virtual override bool System.Windows.Documents.ITextRange.CanSave(string dataFormat);
    private sealed virtual override void System.Windows.Documents.ITextRange.Save(Stream stream, string dataFormat);
    private sealed virtual override void System.Windows.Documents.ITextRange.Save(Stream stream, string dataFormat, bool preserveTextElements);
    private sealed virtual override void System.Windows.Documents.ITextRange.BeginChange();
    private sealed virtual override void System.Windows.Documents.ITextRange.BeginChangeNoUndo();
    private sealed virtual override void System.Windows.Documents.ITextRange.EndChange();
    private sealed virtual override void System.Windows.Documents.ITextRange.EndChange(bool disableScroll, bool skipEvents);
    private sealed virtual override IDisposable System.Windows.Documents.ITextRange.DeclareChangeBlock();
    private sealed virtual override IDisposable System.Windows.Documents.ITextRange.DeclareChangeBlock(bool disableScroll);
    private sealed virtual override void System.Windows.Documents.ITextRange.NotifyChanged(bool disableScroll, bool skipEvents);
    private sealed virtual override bool System.Windows.Documents.ITextRange.get_IgnoreTextUnitBoundaries();
    private sealed virtual override ITextPointer System.Windows.Documents.ITextRange.get_Start();
    private sealed virtual override ITextPointer System.Windows.Documents.ITextRange.get_End();
    private sealed virtual override bool System.Windows.Documents.ITextRange.get_IsEmpty();
    private sealed virtual override List`1<TextSegment> System.Windows.Documents.ITextRange.get_TextSegments();
    private sealed virtual override bool System.Windows.Documents.ITextRange.get_HasConcreteTextContainer();
    private sealed virtual override string System.Windows.Documents.ITextRange.get_Text();
    private sealed virtual override void System.Windows.Documents.ITextRange.set_Text(string value);
    private sealed virtual override string System.Windows.Documents.ITextRange.get_Xml();
    private sealed virtual override int System.Windows.Documents.ITextRange.get_ChangeBlockLevel();
    private sealed virtual override bool System.Windows.Documents.ITextRange.get_IsTableCellRange();
    private sealed virtual override void System.Windows.Documents.ITextRange.add_Changed(EventHandler value);
    private sealed virtual override void System.Windows.Documents.ITextRange.remove_Changed(EventHandler value);
    private sealed virtual override void System.Windows.Documents.ITextRange.FireChanged();
    private sealed virtual override bool System.Windows.Documents.ITextRange.get__IsTableCellRange();
    private sealed virtual override void System.Windows.Documents.ITextRange.set__IsTableCellRange(bool value);
    private sealed virtual override List`1<TextSegment> System.Windows.Documents.ITextRange.get__TextSegments();
    private sealed virtual override void System.Windows.Documents.ITextRange.set__TextSegments(List`1<TextSegment> value);
    private sealed virtual override int System.Windows.Documents.ITextRange.get__ChangeBlockLevel();
    private sealed virtual override void System.Windows.Documents.ITextRange.set__ChangeBlockLevel(int value);
    private sealed virtual override ChangeBlockUndoRecord System.Windows.Documents.ITextRange.get__ChangeBlockUndoRecord();
    private sealed virtual override void System.Windows.Documents.ITextRange.set__ChangeBlockUndoRecord(ChangeBlockUndoRecord value);
    private sealed virtual override bool System.Windows.Documents.ITextRange.get__IsChanged();
    private sealed virtual override void System.Windows.Documents.ITextRange.set__IsChanged(bool value);
    private sealed virtual override UInt32 System.Windows.Documents.ITextRange.get__ContentGeneration();
    private sealed virtual override void System.Windows.Documents.ITextRange.set__ContentGeneration(UInt32 value);
    public bool Contains(TextPointer textPointer);
    public void Select(TextPointer position1, TextPointer position2);
    internal void SelectWord(TextPointer textPointer);
    internal void SelectParagraph(ITextPointer position);
    public void ApplyPropertyValue(DependencyProperty formattingProperty, object value);
    internal void ApplyPropertyValue(DependencyProperty formattingProperty, object value, bool applyToParagraphs);
    internal void ApplyPropertyValue(DependencyProperty formattingProperty, object value, bool applyToParagraphs, PropertyValueAction propertyValueAction);
    public void ClearAllProperties();
    public object GetPropertyValue(DependencyProperty formattingProperty);
    internal UIElement GetUIElementSelected();
    public bool CanSave(string dataFormat);
    public bool CanLoad(string dataFormat);
    public void Save(Stream stream, string dataFormat);
    public void Save(Stream stream, string dataFormat, bool preserveTextElements);
    public void Load(Stream stream, string dataFormat);
    internal void InsertEmbeddedUIElement(FrameworkElement embeddedElement);
    internal void InsertImage(Image image);
    internal virtual void SetXmlVirtual(TextElement fragment);
    internal virtual void LoadVirtual(Stream stream, string dataFormat);
    internal Table InsertTable(int rowCount, int columnCount);
    internal TextRange InsertRows(int rowCount);
    internal bool DeleteRows();
    internal TextRange InsertColumns(int columnCount);
    internal bool DeleteColumns();
    internal TextRange MergeCells();
    internal TextRange SplitCell(int splitCountHorizontal, int splitCountVertical);
    public TextPointer get_Start();
    public TextPointer get_End();
    public bool get_IsEmpty();
    internal bool get_HasConcreteTextContainer();
    internal FrameworkElement get_ContainingFrameworkElement();
    public string get_Text();
    public void set_Text(string value);
    internal string get_Xml();
    internal void set_Xml(string value);
    internal bool get_IsTableCellRange();
    [CompilerGeneratedAttribute]
public void add_Changed(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_Changed(EventHandler value);
    internal void BeginChange();
    internal void EndChange();
    internal IDisposable DeclareChangeBlock();
    internal IDisposable DeclareChangeBlock(bool disableScroll);
    internal bool get__IsChanged();
    internal void set__IsChanged(bool value);
    internal virtual void InsertEmbeddedUIElementVirtual(FrameworkElement embeddedElement);
    internal virtual void ApplyPropertyToTextVirtual(DependencyProperty formattingProperty, object value, bool applyToParagraphs, PropertyValueAction propertyValueAction);
    internal virtual void ClearAllPropertiesVirtual();
    internal virtual Table InsertTableVirtual(int rowCount, int columnCount);
    internal virtual TextRange InsertRowsVirtual(int rowCount);
    internal virtual bool DeleteRowsVirtual();
    internal virtual TextRange InsertColumnsVirtual(int columnCount);
    internal virtual bool DeleteColumnsVirtual();
    internal virtual TextRange MergeCellsVirtual();
    internal virtual TextRange SplitCellVirtual(int splitCountHorizontal, int splitCountVertical);
    internal int get_ChangeBlockLevel();
    private void SetFlags(bool value, Flags flags);
    private bool CheckFlags(Flags flags);
}
internal static class System.Windows.Documents.TextRangeBase : object {
    private static char NumberSuffix;
    private static string DecimalNumerics;
    private static string LowerLatinNumerics;
    private static string UpperLatinNumerics;
    private static String[][] RomanNumerics;
    private static TextRangeBase();
    internal static bool Contains(ITextRange thisRange, ITextPointer textPointer);
    internal static void Select(ITextRange thisRange, ITextPointer position1, ITextPointer position2);
    internal static void Select(ITextRange thisRange, ITextPointer position1, ITextPointer position2, bool includeCellAtMovingPosition);
    internal static void SelectWord(ITextRange thisRange, ITextPointer position);
    internal static TextSegment GetAutoWord(ITextRange thisRange);
    internal static void SelectParagraph(ITextRange thisRange, ITextPointer position);
    internal static void ApplyInitialTypingHeuristics(ITextRange thisRange);
    internal static void ApplyFinalTypingHeuristics(ITextRange thisRange, bool overType);
    internal static void ApplyTypingHeuristics(ITextRange thisRange, bool overType);
    internal static void FindParagraphOrListItemBoundaries(ITextPointer position, ITextPointer& start, ITextPointer& end);
    private static void SkipParagraphContent(ITextPointer navigator, LogicalDirection direction);
    internal static object GetPropertyValue(ITextRange thisRange, DependencyProperty formattingProperty);
    private static object GetCharacterPropertyValue(ITextRange thisRange, DependencyProperty formattingProperty);
    private static object GetCharacterValueFromPosition(ITextPointer pointer, DependencyProperty formattingProperty);
    private static object GetParagraphPropertyValue(ITextRange thisRange, DependencyProperty formattingProperty);
    internal static bool IsParagraphBoundaryCrossed(ITextRange thisRange);
    internal static void BeginChange(ITextRange thisRange);
    internal static void BeginChangeNoUndo(ITextRange thisRange);
    internal static void EndChange(ITextRange thisRange);
    internal static void EndChange(ITextRange thisRange, bool disableScroll, bool skipEvents);
    internal static void NotifyChanged(ITextRange thisRange, bool disableScroll);
    internal static string GetTextInternal(ITextPointer startPosition, ITextPointer endPosition);
    internal static string GetTextInternal(ITextPointer startPosition, ITextPointer endPosition, Char[]& charArray);
    private static void PlainConvertTextRun(StringBuilder textBuffer, ITextPointer navigator, ITextPointer endPosition, Char[]& charArray);
    private static void PlainConvertParagraphEnd(StringBuilder textBuffer, ITextPointer navigator);
    private static void PlainConvertListStart(ITextPointer navigator, Stack`1& listItemCounter);
    private static void PlainConvertListEnd(ITextPointer navigator, Stack`1& listItemCounter);
    private static void PlainConvertListItemStart(StringBuilder textBuffer, ITextPointer navigator, Stack`1& listItemCounter);
    private static void PlainConvertAccessKey(StringBuilder textBuffer, ITextPointer navigator);
    private static Char[] EnsureCharArraySize(Char[] charArray, int textLength);
    private static void WriteListMarker(StringBuilder textBuffer, TextMarkerStyle listMarkerStyle, int listItemNumber);
    private static Char[] ConvertNumberToString(int number, bool oneBased, string numericSymbols);
    private static string ConvertNumberToRomanString(int number, bool uppercase);
    private static void AddRomanNumeric(StringBuilder builder, int number, string oneFiveTen);
    internal static ITextPointer GetStart(ITextRange thisRange);
    internal static ITextPointer GetEnd(ITextRange thisRange);
    internal static bool GetIsEmpty(ITextRange thisRange);
    internal static List`1<TextSegment> GetTextSegments(ITextRange thisRange);
    internal static string GetText(ITextRange thisRange);
    internal static void SetText(ITextRange thisRange, string textData);
    internal static string GetXml(ITextRange thisRange);
    internal static bool CanSave(ITextRange thisRange, string dataFormat);
    internal static bool CanLoad(ITextRange thisRange, string dataFormat);
    internal static void Save(ITextRange thisRange, Stream stream, string dataFormat, bool preserveTextElements);
    internal static void Load(TextRange thisRange, Stream stream, string dataFormat);
    internal static int GetChangeBlockLevel(ITextRange thisRange);
    internal static UIElement GetUIElementSelected(ITextRange range);
    internal static bool GetIsTableCellRange(ITextRange thisRange);
    private static void BeginChangeWorker(ITextRange thisRange, string description);
    private static void CreateNormalizedTextSegment(ITextRange thisRange, ITextPointer start, ITextPointer end);
    private static bool IsAtNormalizedPosition(ITextRange thisRange, ITextPointer position, LogicalDirection direction);
    private static ITextPointer GetNormalizedPosition(ITextRange thisRange, ITextPointer position, LogicalDirection direction);
    internal static void NormalizeAnchoredBlockBoundaries(TextPointer& start, TextPointer& end);
    private static void NormalizeRange(ITextRange thisRange);
    private static void SelectPrivate(ITextRange thisRange, ITextPointer position1, ITextPointer position2, bool includeCellAtMovingPosition, bool markRangeChanged);
    private static void MarkRangeChanged(ITextRange thisRange);
}
internal static class System.Windows.Documents.TextRangeEdit : object {
    internal static TextElement InsertElementClone(TextPointer start, TextPointer end, TextElement element);
    internal static TextPointer SplitFormattingElements(TextPointer splitPosition, bool keepEmptyFormatting);
    internal static TextPointer SplitFormattingElement(TextPointer splitPosition, bool keepEmptyFormatting);
    private static bool InheritablePropertiesAreEqual(Inline firstInline, Inline secondInline);
    private static bool CharacterPropertiesAreEqual(Inline firstElement, Inline secondElement);
    private static bool ExtractEmptyFormattingElements(TextPointer position);
    internal static void SetInlineProperty(TextPointer start, TextPointer end, DependencyProperty formattingProperty, object value, PropertyValueAction propertyValueAction);
    internal static bool MergeFormattingInlines(TextPointer position);
    private static void RemoveUnnecessarySpans(TextPointer position);
    internal static void CharacterResetFormatting(TextPointer start, TextPointer end);
    private static void ClearFormattingInlineProperties(Inline inline);
    private static Span TransferNonFormattingInlineProperties(Span source);
    internal static TextPointer SplitElement(TextPointer position);
    internal static TextPointer InsertParagraphBreak(TextPointer position, bool moveIntoSecondParagraph);
    internal static TextPointer InsertLineBreak(TextPointer position);
    internal static void SetParagraphProperty(TextPointer start, TextPointer end, DependencyProperty property, object value);
    internal static void SetParagraphProperty(TextPointer start, TextPointer end, DependencyProperty property, object value, PropertyValueAction propertyValueAction);
    private static void SetParagraphPropertyWorker(TextPointer start, TextPointer end, DependencyProperty property, object value, PropertyValueAction propertyValueAction);
    private static void SetPropertyOnParagraphOrBlockUIContainer(DependencyObject parent, Block block, DependencyProperty property, object value, PropertyValueAction propertyValueAction);
    private static void PreserveBlockContentStructuralProperty(Block block, DependencyProperty property, object currentValue, object newValue);
    private static void SetStructuralPropertyOnInline(Inline inline, DependencyProperty property, object value);
    private static Block GetNextBlock(TextPointer pointer, TextPointer limit);
    private static Thickness ComputeNewThicknessValue(Thickness currentThickness, Thickness newThickness, FlowDirection parentFlowDirection, FlowDirection flowDirection, PropertyValueAction propertyValueAction);
    private static TextAlignment ComputeNewTextAlignmentValue(TextAlignment textAlignment, FlowDirection flowDirection);
    private static double GetNewDoubleValue(DependencyProperty property, double currentValue, double newValue, PropertyValueAction propertyValueAction);
    private static double NewValue(double currentValue, double newValue, PropertyValueAction propertyValueAction);
    internal static HorizontalAlignment GetHorizontalAlignmentFromTextAlignment(TextAlignment textAlignment);
    internal static TextAlignment GetTextAlignmentFromHorizontalAlignment(HorizontalAlignment horizontalAlignment);
    private static void SetPropertyValue(TextElement element, DependencyProperty property, object currentValue, object newValue);
    private static void SwapBlockLeftAndRightMargins(Block block);
    internal static ITextPointer GetAdjustedRangeEnd(ITextPointer rangeStart, ITextPointer rangeEnd);
    internal static void MergeFlowDirection(TextPointer position);
    internal static bool CanApplyStructuralInlineProperty(TextPointer start, TextPointer end);
    internal static void IncrementParagraphLeadingMargin(TextRange range, double increment, PropertyValueAction propertyValueAction);
    internal static void DeleteInlineContent(ITextPointer start, ITextPointer end);
    internal static void DeleteParagraphContent(ITextPointer start, ITextPointer end);
    private static void MergeEmptyParagraphsAndBlockUIContainers(TextPointer startPosition, TextPointer endPosition);
    private static void DeleteEquiScopedContent(TextPointer start, TextPointer end);
    private static bool DeleteContentBetweenPositions(TextPointer one, TextPointer two);
    private static TextPointer SplitFormattingElements(TextPointer splitPosition, bool keepEmptyFormatting, TextElement limitingAncestor);
    private static TextPointer SplitFormattingElements(TextPointer splitPosition, bool keepEmptyFormatting, bool preserveStructuralFormatting, TextElement limitingAncestor);
    private static void TransferStructuralProperties(Inline source, Inline destination);
    private static bool HasWriteableLocalPropertyValues(Inline inline);
    private static bool HasLocalInheritableStructuralPropertyValue(Inline inline);
    private static bool HasLocalStructuralPropertyValue(Inline inline);
    private static bool HasLocalPropertyValue(Inline inline, DependencyProperty property);
    private static Inline GetScopingFlowDirectionInline(Run run);
    private static void SetNonStructuralInlineProperty(TextPointer start, TextPointer end, DependencyProperty formattingProperty, object value, PropertyValueAction propertyValueAction);
    private static double GetNewFontSizeValue(double currentValue, double value, PropertyValueAction propertyValueAction);
    private static void SetStructuralInlineProperty(TextPointer start, TextPointer end, DependencyProperty formattingProperty, object value);
    private static void FixupStructuralPropertyEnvironment(Inline inline, DependencyProperty property);
    private static void FlattenStructuralProperties(Inline inline);
    private static void ClearParentStructuralPropertyValue(Inline child, DependencyProperty property);
    private static Run GetNextRun(TextPointer pointer, TextPointer limit);
    private static void ClearPropertyValueFromSpansAndRuns(TextPointer start, TextPointer end, DependencyProperty formattingProperty);
    private static void ApplyStructuralInlinePropertyAcrossRun(TextPointer start, TextPointer end, Run run, DependencyProperty formattingProperty, object value);
    private static void ApplyStructuralInlinePropertyAcrossInline(TextPointer start, TextPointer end, TextElement commonAncestor, DependencyProperty formattingProperty, object value);
    private static void ApplyStructuralInlinePropertyAcrossParagraphs(TextPointer start, TextPointer end, DependencyProperty formattingProperty, object value);
    private static bool ValidateApplyStructuralInlineProperty(TextPointer start, TextPointer end, DependencyObject commonAncestor, DependencyProperty property);
}
internal static class System.Windows.Documents.TextRangeEditLists : object {
    internal static bool MergeParagraphs(Block firstParagraphOrBlockUIContainer, Block secondParagraphOrBlockUIContainer);
    internal static bool MergeListsAroundNormalizedPosition(TextPointer mergePosition);
    internal static bool MergeLists(TextPointer mergePosition);
    internal static bool IsListOperationApplicable(TextRange range);
    internal static bool ConvertParagraphsToListItems(TextRange range, TextMarkerStyle markerStyle);
    internal static void ConvertListItemsToParagraphs(TextRange range);
    internal static void IndentListItems(TextRange range);
    internal static bool UnindentListItems(TextRange range);
    private static bool IsRangeWithinSingleList(TextRange range);
    internal static bool ParagraphsAreMergeable(Block firstParagraphOrBlockUIContainer, Block secondParagraphOrBlockUIContainer);
    internal static bool SplitListsForFlowDirectionChange(TextPointer start, TextPointer end, object newFlowDirectionValue);
    private static TextPointer GetPositionAfterList(List list);
}
internal static class System.Windows.Documents.TextRangeEditTables : object {
    internal static bool GetColumnRange(ITextRange range, Table table, Int32& firstColumnIndex, Int32& lastColumnIndex);
    internal static Table GetTableFromPosition(TextPointer position);
    private static TableRow GetTableRowFromPosition(TextPointer position);
    internal static TableCell GetTableCellFromPosition(TextPointer position);
    internal static bool IsTableStructureCrossed(ITextPointer anchorPosition, ITextPointer movingPosition);
    internal static bool IsTableCellRange(TextPointer anchorPosition, TextPointer movingPosition, bool includeCellAtMovingPosition, TableCell& anchorCell, TableCell& movingCell);
    internal static List`1<TextSegment> BuildTableRange(TextPointer anchorPosition, TextPointer movingPosition, bool includeCellAtMovingPosition, Boolean& isTableCellRange);
    private static List`1<TextSegment> BuildCellSelection(TableCell anchorCell, TableCell movingCell);
    private static List`1<TextSegment> BuildCrossTableSelection(TextPointer anchorPosition, TextPointer movingPosition, TableRow anchorRow, TableRow movingRow);
    internal static void IdentifyValidBoundaries(ITextRange range, ITextPointer& start, ITextPointer& end);
    internal static TextPointer GetNextTableCellRangeInsertionPosition(TextSelection selection, LogicalDirection direction);
    internal static TextPointer GetNextRowEndMovingPosition(TextSelection selection, LogicalDirection direction);
    internal static bool MovingPositionCrossesCellBoundary(TextSelection selection);
    internal static TextPointer GetNextRowStartMovingPosition(TextSelection selection, LogicalDirection direction);
    internal static Table InsertTable(TextPointer insertionPosition, int rowCount, int columnCount);
    private static Thickness GetCellBorder(double thickness, int rowIndex, int columnIndex, int rowSpan, int columnSpan, int rowCount, int columnCount);
    internal static TextPointer EnsureInsertionPosition(TextPointer position);
    internal static TextPointer GetAdjustedRowEndPosition(Table currentTable, TextPointer rowEndPosition);
    private static TextPointer CreateInsertionPositionInIncompleteContent(TextPointer position);
    private static TextPointer CreateImplicitRun(TextPointer position);
    private static TextPointer CreateImplicitParagraph(TextPointer position);
    internal static void DeleteContent(TextPointer start, TextPointer end);
    private static void ClearTableCells(TextSegment textSegment);
    internal static TextRange InsertRows(TextRange textRange, int rowCount);
    internal static bool DeleteRows(TextRange textRange);
    private static void CorrectBorders(TableRowCollection rows);
    private static void CorrectRowSpansOnDeleteRows(TableRow nextRow, int deletedRowsCount);
    private static void InsertColumn(int colIndex, Table table);
    internal static TextRange InsertColumns(TextRange textRange, int columnCount);
    internal static void DeleteColumn(int colIndex, Table table);
    internal static bool DeleteColumns(TextRange textRange);
    internal static bool TableBorderHitTest(ITextView textView, Point pt);
    private static bool TableBorderHitTest(ITextView textView, Point point, Table& table, Int32& columnIndex, Rect& columnRect, Double& tableAutofitWidth, Double[]& columnWidths);
    internal static TableColumnResizeInfo StartColumnResize(ITextView textView, Point pt);
    internal static void EnsureTableColumnsAreFixedSize(Table table, Double[] columnWidths);
    internal static TextRange MergeCells(TextRange textRange);
    internal static TextRange SplitCell(TextRange textRange, int splitCountHorizontal, int splitCountVertical);
    private static TextSegment NewNormalizedTextSegment(TextPointer startPosition, TextPointer endPosition);
    private static TextSegment NewNormalizedCellSegment(TableCell startCell, TableCell endCell);
    private static bool IdentifyTableElements(TextPointer anchorPosition, TextPointer movingPosition, bool includeCellAtMovingPosition, TableCell& anchorCell, TableCell& movingCell, TableRow& anchorRow, TableRow& movingRow, TableRowGroup& anchorRowGroup, TableRowGroup& movingRowGroup, Table& anchorTable, Table& movingTable);
    private static bool FindTableElements(TextPointer anchorPosition, TextPointer movingPosition, TableCell& anchorCell, TableCell& movingCell, TableRow& anchorRow, TableRow& movingRow, TableRowGroup& anchorRowGroup, TableRowGroup& movingRowGroup, Table& anchorTable, Table& movingTable);
    private static void FindTableElements(TextElement commonAncestor, TextPointer position, TableCell& cell, TableRow& row, TableRowGroup& rowGroup, Table& table);
    private static TableRow CopyRow(TableRow currentRow);
    private static TableCell AddCellCopy(TableRow newRow, TableCell currentCell, int cellInsertionIndex, bool copyRowSpan, bool copyColumnSpan);
    private static TextRange MergeCellRange(TableRowGroup rowGroup, int topRow, int bottomRow, int leftColumn, int rightColumn);
    private static bool CanMergeCellRange(TableRowGroup rowGroup, int topRow, int bottomRow, int leftColumn, int rightColumn);
    private static TextRange DoMergeCellRange(TableRowGroup rowGroup, int topRow, int bottomRow, int leftColumn, int rightColumn);
    private static bool GetBoundaryCells(TableRow row, int bottomRow, int leftColumn, int rightColumn, TableCell& firstCell, TableCell& lastCell);
    private static bool IsLastCellInRow(TableCell cell);
}
internal static class System.Windows.Documents.TextRangeSerialization : object {
    private static int EmptyDocumentDepth;
    internal static void WriteXaml(XmlWriter xmlWriter, ITextRange range, bool useFlowDocumentAsRoot, WpfPayload wpfPayload);
    internal static void WriteXaml(XmlWriter xmlWriter, ITextRange range, bool useFlowDocumentAsRoot, WpfPayload wpfPayload, bool preserveTextElements);
    internal static void PasteXml(TextRange range, TextElement fragment);
    private static void WriteXamlTextSegment(XmlWriter xmlWriter, ITextPointer rangeStart, ITextPointer rangeEnd, XamlTypeMapper xamlTypeMapper, Int32& elementLevel, WpfPayload wpfPayload, bool ignoreWriteHyperlinkEnd, List`1<int> ignoreList, bool preserveTextElements);
    private static void WriteXamlTableCellRange(XmlWriter xmlWriter, ITextRange range, XamlTypeMapper xamlTypeMapper, Int32& elementLevel, WpfPayload wpfPayload, bool preserveTextElements);
    private static int WriteOpeningTags(ITextRange range, ITextPointer thisElement, ITextPointer scope, XmlWriter xmlWriter, XamlTypeMapper xamlTypeMapper, bool reduceElement, Boolean& ignoreWriteHyperlinkEnd, List`1& ignoreList, bool preserveTextElements);
    private static void WriteStartXamlElement(ITextRange range, ITextPointer textReader, XmlWriter xmlWriter, XamlTypeMapper xamlTypeMapper, bool reduceElement, bool preserveTextElements);
    private static void WriteTableColumnsInformation(ITextRange range, Table table, XmlWriter xmlWriter, XamlTypeMapper xamlTypeMapper);
    private static void WriteRootFlowDocument(ITextRange range, ITextPointer context, XmlWriter xmlWriter, XamlTypeMapper xamlTypeMapper, bool lastParagraphMustBeMerged, bool useFlowDocumentAsRoot);
    private static void WriteInheritablePropertiesForFlowDocument(DependencyObject context, XmlWriter xmlWriter, DependencyObject complexProperties);
    private static void WriteInheritableProperties(Type elementTypeStandardized, ITextPointer context, XmlWriter xmlWriter, bool onlyAffected, DependencyObject complexProperties);
    private static void WriteNoninheritableProperties(Type elementTypeStandardized, ITextPointer context, XmlWriter xmlWriter, bool onlyAffected, DependencyObject complexProperties);
    private static void WriteNoninheritableProperty(XmlWriter xmlWriter, DependencyProperty property, object propertyValue, Type propertyOwnerType, bool onlyAffected, DependencyObject complexProperties, object localValue);
    private static void WriteLocallySetProperties(Type elementTypeStandardized, ITextPointer context, XmlWriter xmlWriter, DependencyObject complexProperties);
    private static bool IsPropertyKnown(DependencyProperty propertyToTest, DependencyProperty[] inheritableProperties, DependencyProperty[] nonInheritableProperties);
    private static void WriteComplexProperties(XmlWriter xmlWriter, DependencyObject complexProperties, Type elementType);
    private static string GetPropertyNameForElement(DependencyProperty property, Type elementType, bool forceComplexName);
    private static void WriteXamlAtomicElement(DependencyObject element, XmlWriter xmlWriter, bool reduceElement);
    private static void WriteEmbeddedObject(object embeddedObject, XmlWriter xmlWriter, WpfPayload wpfPayload);
    private static bool PasteSingleEmbeddedElement(TextRange range, TextElement fragment);
    private static void PasteTextFragment(TextElement fragment, TextRange range);
    private static void PasteNonMergeableTextFragment(TextElement fragment, TextRange range);
    private static void PasteMergeableTextFragment(TextElement fragment, TextRange range, TextPointer insertionPosition);
    private static void CorrectLeadingNestedLists(Section fragment);
    private static bool SplitParagraphForPasting(TextPointer& insertionPosition);
    private static void MergeParagraphsAtPosition(TextPointer position, bool mergingOnFragmentStart);
    private static void ValidateMergingPositions(Type itemType, TextPointer start, TextPointer end);
    private static void AdjustFragmentForTargetRange(TextElement fragment, TextRange range);
    private static void ApplyContextualProperties(TextPointer start, TextPointer end, TextElement propertyBag);
    private static void ApplyContextualProperty(Type targetType, TextPointer start, TextPointer end, DependencyProperty property, object value);
    private static ITextPointer FindSerializationCommonAncestor(ITextRange range);
    private static bool IsAcceptableAncestor(ITextPointer commonAncestor, ITextRange range);
    private static int StripInvalidSurrogateChars(Char[] text, int length);
    private static bool IsBadCode(char code);
    private static bool IsPartialNonTypographic(ITextPointer textReader, ITextPointer rangeEnd);
    private static bool IsHyperlinkInvalid(ITextPointer textReader, ITextPointer rangeEnd);
    private static ITextPointer GetHyperlinkStart(ITextRange range);
    private static string FilterNaNStringValueForDoublePropertyType(string stringValue, Type propertyType);
}
internal static class System.Windows.Documents.TextSchema : object {
    private static DependencyProperty[] _inheritableTextElementProperties;
    private static DependencyProperty[] _inheritableBlockProperties;
    private static DependencyProperty[] _inheritableTableCellProperties;
    private static DependencyProperty[] _hyperlinkProperties;
    private static DependencyProperty[] _inlineProperties;
    private static DependencyProperty[] _paragraphProperties;
    private static DependencyProperty[] _listProperties;
    private static DependencyProperty[] _listItemProperties;
    private static DependencyProperty[] _tableProperties;
    private static DependencyProperty[] _tableColumnProperties;
    private static DependencyProperty[] _tableRowGroupProperties;
    private static DependencyProperty[] _tableRowProperties;
    private static DependencyProperty[] _tableCellProperties;
    private static DependencyProperty[] _floaterProperties;
    private static DependencyProperty[] _figureProperties;
    private static DependencyProperty[] _blockProperties;
    private static DependencyProperty[] _textElementPropertyList;
    private static DependencyProperty[] _imagePropertyList;
    private static DependencyProperty[] _behavioralPropertyList;
    private static DependencyProperty[] _emptyPropertyList;
    private static DependencyProperty[] _structuralCharacterProperties;
    private static DependencyProperty[] _nonFormattingCharacterProperties;
    internal static DependencyProperty[] BehavioralProperties { get; }
    internal static DependencyProperty[] ImageProperties { get; }
    internal static DependencyProperty[] StructuralCharacterProperties { get; }
    private static TextSchema();
    internal static bool IsInTextContent(ITextPointer position);
    internal static bool ValidateChild(TextElement parent, TextElement child, bool throwIfIllegalChild, bool throwIfIllegalHyperlinkDescendent);
    internal static bool IsValidChild(TextElement parent, Type childType);
    internal static bool ValidateChild(TextElement parent, Type childType, bool throwIfIllegalChild, bool throwIfIllegalHyperlinkDescendent);
    internal static bool IsValidChild(TextPointer position, Type childType);
    internal static bool ValidateChild(TextPointer position, Type childType, bool throwIfIllegalChild, bool throwIfIllegalHyperlinkDescendent);
    internal static bool IsValidSibling(Type siblingType, Type newType);
    internal static bool IsValidChild(ITextPointer position, Type childType);
    internal static bool IsValidChildOfContainer(Type parentType, Type childType);
    internal static bool HasHyperlinkAncestor(TextElement element);
    internal static bool IsFormattingType(Type elementType);
    internal static bool IsKnownType(Type elementType);
    internal static bool IsNonFormattingInline(Type elementType);
    internal static bool IsMergeableInline(Type elementType);
    internal static bool IsNonMergeableInline(Type elementType);
    internal static bool AllowsParagraphMerging(Type elementType);
    internal static bool IsParagraphOrBlockUIContainer(Type elementType);
    internal static bool IsBlock(Type type);
    internal static bool IsBreak(Type type);
    internal static bool HasTextDecorations(object value);
    internal static Type GetStandardElementType(Type type, bool reduceElement);
    internal static DependencyProperty[] GetInheritableProperties(Type type);
    internal static DependencyProperty[] GetNoninheritableProperties(Type type);
    internal static bool ValuesAreEqual(object value1, object value2);
    internal static bool IsParagraphProperty(DependencyProperty formattingProperty);
    internal static bool IsCharacterProperty(DependencyProperty formattingProperty);
    internal static bool IsNonFormattingCharacterProperty(DependencyProperty property);
    internal static DependencyProperty[] GetNonFormattingCharacterProperties();
    internal static bool IsStructuralCharacterProperty(DependencyProperty formattingProperty);
    internal static bool IsPropertyIncremental(DependencyProperty property);
    internal static DependencyProperty[] get_BehavioralProperties();
    internal static DependencyProperty[] get_ImageProperties();
    internal static DependencyProperty[] get_StructuralCharacterProperties();
    private static bool IsValidChild(Type parentType, Type childType);
    private static bool HasIllegalHyperlinkDescendant(TextElement element, bool throwIfIllegalDescendent);
    private static bool AreBrushesEqual(Brush brush1, Brush brush2);
}
internal class System.Windows.Documents.TextSegment : ValueType {
    internal static TextSegment Null;
    private ITextPointer _start;
    private ITextPointer _end;
    internal ITextPointer Start { get; }
    internal ITextPointer End { get; }
    internal bool IsNull { get; }
    internal TextSegment(ITextPointer startPosition, ITextPointer endPosition);
    internal TextSegment(ITextPointer startPosition, ITextPointer endPosition, bool preserveLogicalDirection);
    private static TextSegment();
    internal bool Contains(ITextPointer position);
    internal ITextPointer get_Start();
    internal ITextPointer get_End();
    internal bool get_IsNull();
}
public class System.Windows.Documents.TextSelection : TextRange {
    private TextEditor _textEditor;
    private TextSelectionHighlightLayer _highlightLayer;
    private DependencyObject _springloadFormatting;
    private ITextPointer _anchorPosition;
    private MovingEdge _movingPositionEdge;
    private LogicalDirection _movingPositionDirection;
    private ITextPointer _previousCursorPosition;
    private ITextPointer _reenterPosition;
    private bool _anchorWordRangeHasBeenCrossedOnce;
    private bool _allowWordExpansionOnAnchorEnd;
    private static int FONTSIGNATURE_SIZE;
    private static int FONTSIGNATURE_BIDI_INDEX;
    private static int FONTSIGNATURE_BIDI;
    private CaretScrollMethod _caretScrollMethod;
    private bool _pendingCaretNavigation;
    private CaretElement _caretElement;
    private bool _pendingUpdateCaretStateCallback;
    private bool System.Windows.Documents.ITextRange._IsChanged { get; private set; }
    private string System.Windows.Documents.ITextRange.Text { get; private set; }
    private ITextPointer System.Windows.Documents.ITextSelection.AnchorPosition { get; }
    private ITextPointer System.Windows.Documents.ITextSelection.MovingPosition { get; }
    internal bool IsInterimSelection { get; }
    private bool System.Windows.Documents.ITextSelection.IsInterimSelection { get; }
    internal TextPointer AnchorPosition { get; }
    internal TextPointer MovingPosition { get; }
    internal CaretElement CaretElement { get; }
    private CaretElement System.Windows.Documents.ITextSelection.CaretElement { get; }
    private bool System.Windows.Documents.ITextSelection.CoversEntireContent { get; }
    private TextEditor System.Windows.Documents.ITextSelection.TextEditor { get; }
    private ITextView System.Windows.Documents.ITextSelection.TextView { get; }
    private ITextView TextView { get; }
    private TextStore TextStore { get; }
    private ImmComposition ImmComposition { get; }
    private FrameworkElement UiScope { get; }
    private ITextPointer PropertyPosition { get; }
    internal TextSelection(TextEditor textEditor);
    private sealed virtual override void System.Windows.Documents.ITextRange.Select(ITextPointer anchorPosition, ITextPointer movingPosition);
    private sealed virtual override void System.Windows.Documents.ITextRange.SelectWord(ITextPointer position);
    private sealed virtual override void System.Windows.Documents.ITextRange.SelectParagraph(ITextPointer position);
    private sealed virtual override void System.Windows.Documents.ITextRange.ApplyTypingHeuristics(bool overType);
    private sealed virtual override object System.Windows.Documents.ITextRange.GetPropertyValue(DependencyProperty formattingProperty);
    private sealed virtual override bool System.Windows.Documents.ITextRange.get__IsChanged();
    private sealed virtual override void System.Windows.Documents.ITextRange.set__IsChanged(bool value);
    private sealed virtual override void System.Windows.Documents.ITextRange.NotifyChanged(bool disableScroll, bool skipEvents);
    private sealed virtual override string System.Windows.Documents.ITextRange.get_Text();
    private sealed virtual override void System.Windows.Documents.ITextRange.set_Text(string value);
    private sealed virtual override void System.Windows.Documents.ITextSelection.UpdateCaretAndHighlight();
    private sealed virtual override ITextPointer System.Windows.Documents.ITextSelection.get_AnchorPosition();
    private sealed virtual override ITextPointer System.Windows.Documents.ITextSelection.get_MovingPosition();
    private sealed virtual override void System.Windows.Documents.ITextSelection.SetCaretToPosition(ITextPointer caretPosition, LogicalDirection direction, bool allowStopAtLineEnd, bool allowStopNearSpace);
    private sealed virtual override void System.Windows.Documents.ITextSelection.ExtendToPosition(ITextPointer position);
    private sealed virtual override bool System.Windows.Documents.ITextSelection.ExtendToNextInsertionPosition(LogicalDirection direction);
    private ITextPointer GetNextTextSegmentInsertionPosition(LogicalDirection direction);
    private sealed virtual override bool System.Windows.Documents.ITextSelection.Contains(Point point);
    private sealed virtual override void System.Windows.Documents.ITextSelection.OnDetach();
    private sealed virtual override void System.Windows.Documents.ITextSelection.OnTextViewUpdated();
    private sealed virtual override void System.Windows.Documents.ITextSelection.DetachFromVisualTree();
    private sealed virtual override void System.Windows.Documents.ITextSelection.RefreshCaret();
    private sealed virtual override void System.Windows.Documents.ITextSelection.OnInterimSelectionChanged(bool interimSelection);
    private sealed virtual override void System.Windows.Documents.ITextSelection.SetSelectionByMouse(ITextPointer cursorPosition, Point cursorMousePoint);
    private sealed virtual override void System.Windows.Documents.ITextSelection.ExtendSelectionByMouse(ITextPointer cursorPosition, bool forceWordSelection, bool forceParagraphSelection);
    private bool BeginMouseSelectionProcess(ITextPointer cursorPosition);
    private void IdentifyWordsOnSelectionEnds(ITextPointer anchorPosition, ITextPointer cursorPosition, bool forceWordSelection, TextSegment& anchorWordRange, TextSegment& cursorWordRange);
    private sealed virtual override bool System.Windows.Documents.ITextSelection.ExtendToNextTableRow(LogicalDirection direction);
    internal bool get_IsInterimSelection();
    private sealed virtual override bool System.Windows.Documents.ITextSelection.get_IsInterimSelection();
    internal TextPointer get_AnchorPosition();
    internal TextPointer get_MovingPosition();
    internal void SetCaretToPosition(TextPointer caretPosition, LogicalDirection direction, bool allowStopAtLineEnd, bool allowStopNearSpace);
    internal bool ExtendToNextInsertionPosition(LogicalDirection direction);
    internal static void OnInputLanguageChanged(CultureInfo cultureInfo);
    internal bool Contains(Point point);
    internal virtual void InsertEmbeddedUIElementVirtual(FrameworkElement embeddedElement);
    internal virtual void ApplyPropertyToTextVirtual(DependencyProperty formattingProperty, object value, bool applyToParagraphs, PropertyValueAction propertyValueAction);
    internal virtual void ClearAllPropertiesVirtual();
    internal virtual void SetXmlVirtual(TextElement fragment);
    internal virtual void LoadVirtual(Stream stream, string dataFormat);
    internal virtual Table InsertTableVirtual(int rowCount, int columnCount);
    internal object GetCurrentValue(DependencyProperty formattingProperty);
    internal void SpringloadCurrentFormatting();
    private void SpringloadCurrentFormatting(DependencyObject parent);
    internal void ClearSpringloadFormatting();
    internal void ApplySpringloadFormatting();
    internal void UpdateCaretState(CaretScrollMethod caretScrollMethod);
    internal static Brush GetCaretBrush(TextEditor textEditor);
    internal static bool IsBidiInputLanguageInstalled();
    private sealed virtual override void System.Windows.Documents.ITextSelection.ValidateLayout();
    internal CaretElement get_CaretElement();
    private sealed virtual override CaretElement System.Windows.Documents.ITextSelection.get_CaretElement();
    private sealed virtual override bool System.Windows.Documents.ITextSelection.get_CoversEntireContent();
    private void SetThreadSelection();
    private void ClearThreadSelection();
    private void Highlight();
    private void Unhighlight();
    private void SetActivePositions(ITextPointer anchorPosition, ITextPointer movingPosition);
    private MovingEdge ConvertToMovingEdge(ITextPointer anchorPosition, ITextPointer movingPosition);
    private void MoveSelectionByMouse(ITextPointer cursorPosition, Point cursorMousePoint);
    private bool ShouldSelectEmbeddedObject(ITextPointer cursorPosition, Point cursorMousePoint, Rect objectEdgeRect);
    private static void RefreshCaret(TextEditor textEditor, ITextSelection textSelection);
    internal void OnCaretNavigation();
    private sealed virtual override void System.Windows.Documents.ITextSelection.OnCaretNavigation();
    private object UpdateCaretStateWorker(object o);
    private static ITextPointer IdentifyCaretPosition(ITextSelection currentTextSelection);
    private static Rect CalculateCaretRectangle(ITextSelection currentTextSelection, ITextPointer caretPosition);
    private static Rect CalculateInterimCaretRectangle(ITextSelection focusedTextSelection);
    private static double CalculateScrollToOriginPosition(TextEditor textEditor, ITextPointer caretPosition, double horizontalCaretPosition);
    private CaretElement EnsureCaret(bool isBlinkEnabled, bool isSelectionActive, CaretScrollMethod scrollMethod);
    private bool VerifyAdornerLayerExists();
    private static bool IsBidiInputLanguage(CultureInfo cultureInfo);
    private static TableCell FindCellAtColumnIndex(TableCellCollection cells, int columnIndex);
    private static bool IsRootElement(DependencyObject element);
    private bool IsFocusWithinRoot();
    private static DependencyObject GetParentElement(DependencyObject element);
    private void DetachCaretFromVisualTree();
    private sealed virtual override TextEditor System.Windows.Documents.ITextSelection.get_TextEditor();
    private sealed virtual override ITextView System.Windows.Documents.ITextSelection.get_TextView();
    private ITextView get_TextView();
    private TextStore get_TextStore();
    private ImmComposition get_ImmComposition();
    private FrameworkElement get_UiScope();
    private ITextPointer get_PropertyPosition();
}
internal class System.Windows.Documents.TextSelectionHighlightLayer : HighlightLayer {
    [CompilerGeneratedAttribute]
private HighlightChangedEventHandler Changed;
    private ITextSelection _selection;
    private ITextPointer _oldStart;
    private ITextPointer _oldEnd;
    private static object _selectedValue;
    internal Type OwnerType { get; }
    private static TextSelectionHighlightLayer();
    internal TextSelectionHighlightLayer(ITextSelection selection);
    internal virtual object GetHighlightValue(StaticTextPointer textPosition, LogicalDirection direction);
    internal virtual bool IsContentHighlighted(StaticTextPointer textPosition, LogicalDirection direction);
    internal virtual StaticTextPointer GetNextChangePosition(StaticTextPointer textPosition, LogicalDirection direction);
    internal void InternalOnSelectionChanged();
    internal virtual Type get_OwnerType();
    [CompilerGeneratedAttribute]
internal virtual void add_Changed(HighlightChangedEventHandler value);
    [CompilerGeneratedAttribute]
internal virtual void remove_Changed(HighlightChangedEventHandler value);
    private void OnSelectionChanged(object sender, EventArgs e);
    private bool IsTextRangeEmpty(ITextRange textRange);
}
internal class System.Windows.Documents.TextServicesDisplayAttribute : object {
    private static int AlphaShift;
    private static int RedShift;
    private static int GreenShift;
    private static int BlueShift;
    private static int Win32RedShift;
    private static int Win32GreenShift;
    private static int Win32BlueShift;
    private TF_DISPLAYATTRIBUTE _attr;
    internal TF_DA_LINESTYLE LineStyle { get; }
    internal bool IsBoldLine { get; }
    internal TF_DA_ATTR_INFO AttrInfo { get; }
    internal TextServicesDisplayAttribute(TF_DISPLAYATTRIBUTE attr);
    internal bool IsEmptyAttribute();
    internal void Apply(ITextPointer start, ITextPointer end);
    internal static Color GetColor(TF_DA_COLOR dacolor, ITextPointer position);
    internal Color GetLineColor(ITextPointer position);
    internal TF_DA_LINESTYLE get_LineStyle();
    internal bool get_IsBoldLine();
    internal TF_DA_ATTR_INFO get_AttrInfo();
    private static int Encode(int alpha, int red, int green, int blue);
    private static int FromWin32Value(int value);
    private static Color GetSystemColor(int index);
}
internal class System.Windows.Documents.TextServicesDisplayAttributePropertyRanges : TextServicesPropertyRanges {
    private static Hashtable _attributes;
    private CompositionAdorner _compositionAdorner;
    internal TextServicesDisplayAttributePropertyRanges(TextStore textstore);
    internal virtual void OnRange(ITfProperty property, int ecReadOnly, ITfRange range);
    internal virtual void OnEndEdit(ITfContext context, int ecReadOnly, ITfEditRecord editRecord);
    internal void OnLayoutUpdated();
    private static TextServicesDisplayAttribute GetDisplayAttribute(int guidatom);
    private int GetInt32Value(int ecReadOnly, ITfProperty property, ITfRange range);
}
internal class System.Windows.Documents.TextServicesHost : DispatcherObject {
    private int _registeredtextstorecount;
    private SecurityCriticalData`1<int> _clientId;
    private SecurityCriticalDataClass`1<ITfThreadMgr> _threadManager;
    private bool _isDispatcherShutdownFinished;
    private MoveSizeWinEventHandler _winEvent;
    private Thread _thread;
    internal static TextServicesHost Current { get; }
    internal ITfThreadMgr ThreadManager { get; }
    internal void RegisterTextStore(TextStore textstore);
    internal void UnregisterTextStore(TextStore textstore, bool finalizer);
    internal void RegisterWinEventSink(TextStore textstore);
    internal void UnregisterWinEventSink(TextStore textstore);
    internal static void StartTransitoryExtension(TextStore textstore);
    internal static void StopTransitoryExtension(TextStore textstore);
    internal static TextServicesHost get_Current();
    internal ITfThreadMgr get_ThreadManager();
    private object OnUnregisterTextStore(object arg);
    private void OnDispatcherShutdownFinished(object sender, EventArgs args);
    private void _RegisterTextStore(TextStore textstore);
    private void DeactivateThreadManager();
}
internal class System.Windows.Documents.TextServicesProperty : object {
    private TextServicesPropertyRanges _propertyRanges;
    private TextStore _textstore;
    internal TextServicesProperty(TextStore textstore);
    internal void OnEndEdit(ITfContext context, int ecReadOnly, ITfEditRecord editRecord);
    internal void OnLayoutUpdated();
}
internal class System.Windows.Documents.TextServicesPropertyRanges : object {
    private Guid _guid;
    private TextStore _textstore;
    protected Guid Guid { get; }
    protected TextStore TextStore { get; }
    internal TextServicesPropertyRanges(TextStore textstore, Guid guid);
    internal virtual void OnRange(ITfProperty property, int ecReadonly, ITfRange range);
    internal virtual void OnEndEdit(ITfContext context, int ecReadOnly, ITfEditRecord editRecord);
    protected void ConvertToTextPosition(ITfRange range, ITextPointer& start, ITextPointer& end);
    protected static object GetValue(int ecReadOnly, ITfProperty property, ITfRange range);
    private IEnumTfRanges GetPropertyUpdate(ITfEditRecord editRecord);
    protected Guid get_Guid();
    protected TextStore get_TextStore();
}
internal class System.Windows.Documents.TextStore : object {
    private ScopeWeakReference _weakTextEditor;
    private TextServicesHost _textservicesHost;
    private ITextStoreACPSink _sink;
    private bool _pendingWriteReq;
    private LockFlags _lockFlags;
    private LockFlags _pendingAsyncLockFlags;
    private int _textChangeReentrencyCount;
    private int _replayingIMEChangeReentrancyCount;
    private bool _isComposing;
    private bool _isEffectivelyNotComposing;
    private int _previousCompositionStartOffset;
    private int _previousCompositionEndOffset;
    private ITextPointer _previousCompositionStart;
    private ITextPointer _previousCompositionEnd;
    private TextServicesProperty _textservicesproperty;
    private static int _viewCookie;
    private SecurityCriticalDataClass`1<ITfDocumentMgr> _documentmanager;
    private int _threadFocusCookie;
    private int _editSinkCookie;
    private int _editCookie;
    private int _transitoryExtensionSinkCookie;
    private ArrayList _preparedattributes;
    private ArrayList _mouseSinks;
    private static TextServicesAttribute[] _supportingattributes;
    private bool _interimSelection;
    private bool _ignoreNextSelectionChange;
    private int _netCharCount;
    private bool _makeLayoutChangeOnGotFocus;
    private CompositionEventState _compositionEventState;
    private bool _compositionModifiedByEventListener;
    private List`1<CompositionEventRecord> _compositionEventList;
    private bool _nextUndoUnitIsFirstCompositionUnit;
    private string _lastCompositionText;
    private bool _handledByTextStoreListener;
    private bool _isInUpdateLayout;
    private bool _hasTextChangedInUpdateLayout;
    private bool _isTracing;
    private static UncommonField`1<IMECompositionTracingInfo> IMECompositionTracingInfoField;
    internal UIElement RenderScope { get; }
    internal FrameworkElement UiScope { get; }
    internal ITextContainer TextContainer { get; }
    internal ITextView TextView { get; }
    internal ITfDocumentMgr DocumentManager { get; internal set; }
    internal int ThreadFocusCookie { get; internal set; }
    internal int EditSinkCookie { get; internal set; }
    internal int EditCookie { get; internal set; }
    internal bool IsInterimSelection { get; }
    internal bool IsComposing { get; }
    internal bool IsEffectivelyComposing { get; }
    internal int TransitoryExtensionSinkCookie { get; internal set; }
    internal IntPtr CriticalSourceWnd { get; }
    private bool HasSink { get; }
    private bool IsTextEditorValid { get; }
    private TextEditor TextEditor { get; }
    private ITextSelection TextSelection { get; }
    private bool IsReadOnly { get; }
    private List`1<CompositionEventRecord> CompositionEventList { get; }
    private bool IsTracing { get; private set; }
    internal TextStore(TextEditor textEditor);
    private static TextStore();
    public sealed virtual void AdviseSink(Guid& riid, object obj, AdviseFlags flags);
    public sealed virtual void UnadviseSink(object obj);
    public sealed virtual void RequestLock(LockFlags flags, Int32& hrSession);
    private int DeferLockRequest(LockFlags flags);
    public sealed virtual void GetStatus(TS_STATUS& status);
    public sealed virtual void QueryInsert(int startIndex, int endIndex, int cch, Int32& startResultIndex, Int32& endResultIndex);
    public sealed virtual void GetSelection(int index, int count, TS_SELECTION_ACP[] selection, Int32& fetched);
    public sealed virtual void SetSelection(int count, TS_SELECTION_ACP[] selection);
    public sealed virtual void GetText(int startIndex, int endIndex, Char[] text, int cchReq, Int32& charsCopied, TS_RUNINFO[] runInfo, int cRunInfoReq, Int32& cRunInfoRcv, Int32& nextIndex);
    public sealed virtual void SetText(SetTextFlags flags, int startIndex, int endIndex, Char[] text, int cch, TS_TEXTCHANGE& change);
    public sealed virtual void GetFormattedText(int startIndex, int endIndex, Object& obj);
    public sealed virtual void GetEmbedded(int index, Guid& guidService, Guid& riid, Object& obj);
    public sealed virtual void QueryInsertEmbedded(Guid& guidService, int formatEtc, Boolean& insertable);
    public sealed virtual void InsertEmbedded(InsertEmbeddedFlags flags, int startIndex, int endIndex, object obj, TS_TEXTCHANGE& change);
    public sealed virtual void InsertTextAtSelection(InsertAtSelectionFlags flags, Char[] text, int cch, Int32& startIndex, Int32& endIndex, TS_TEXTCHANGE& change);
    public sealed virtual void InsertEmbeddedAtSelection(InsertAtSelectionFlags flags, object obj, Int32& startIndex, Int32& endIndex, TS_TEXTCHANGE& change);
    public sealed virtual int RequestSupportedAttrs(AttributeFlags flags, int count, Guid[] filterAttributes);
    public sealed virtual int RequestAttrsAtPosition(int index, int count, Guid[] filterAttributes, AttributeFlags flags);
    public sealed virtual void RequestAttrsTransitioningAtPosition(int position, int count, Guid[] filterAttributes, AttributeFlags flags);
    public sealed virtual void FindNextAttrTransition(int startIndex, int haltIndex, int count, Guid[] filterAttributes, AttributeFlags flags, Int32& acpNext, Boolean& found, Int32& foundOffset);
    public sealed virtual void RetrieveRequestedAttrs(int count, TS_ATTRVAL[] attributeVals, Int32& fetched);
    public sealed virtual void GetEnd(Int32& end);
    public sealed virtual void GetActiveView(Int32& viewCookie);
    public sealed virtual void GetACPFromPoint(int viewCookie, POINT& tsfPoint, GetPositionFromPointFlags flags, Int32& positionCP);
    private sealed virtual override void MS.Win32.UnsafeNativeMethods.ITextStoreACP.GetTextExt(int viewCookie, int startIndex, int endIndex, RECT& rect, Boolean& clipped);
    public sealed virtual void GetScreenExt(int viewCookie, RECT& rect);
    private sealed virtual override void MS.Win32.UnsafeNativeMethods.ITextStoreACP.GetWnd(int viewCookie, IntPtr& hwnd);
    private sealed virtual override void MS.Win32.UnsafeNativeMethods.ITfThreadFocusSink.OnSetThreadFocus();
    public sealed virtual void OnKillThreadFocus();
    public sealed virtual void OnStartComposition(ITfCompositionView view, Boolean& ok);
    public sealed virtual void OnUpdateComposition(ITfCompositionView view, ITfRange rangeNew);
    public sealed virtual void OnEndComposition(ITfCompositionView view);
    private sealed virtual override void MS.Win32.UnsafeNativeMethods.ITfTextEditSink.OnEndEdit(ITfContext context, int ecReadOnly, ITfEditRecord editRecord);
    public sealed virtual void OnTransitoryExtensionUpdated(ITfContext context, int ecReadOnly, ITfRange rangeResult, ITfRange rangeComposition, Boolean& fDeleteResultRange);
    public sealed virtual int AdviceMouseSink(ITfRangeACP range, ITfMouseSink sink, Int32& dwCookie);
    public sealed virtual int UnadviceMouseSink(int dwCookie);
    internal void OnAttach();
    internal void OnDetach(bool finalizer);
    internal void OnGotFocus();
    internal void OnLostFocus();
    internal void OnLayoutUpdated();
    internal void OnSelectionChange();
    internal void OnSelectionChanged();
    internal bool QueryRangeOrReconvertSelection(bool fDoReconvert);
    internal ITfCandidateList GetReconversionCandidateList();
    private bool GetFnReconv(ITextPointer textStart, ITextPointer textEnd, ITfFnReconversion& funcReconv, ITfRange& rangeNew);
    internal void CompleteCompositionAsync();
    internal void CompleteComposition();
    internal ITextPointer CreatePointerAtCharOffset(int charOffset, LogicalDirection direction);
    internal void MakeLayoutChangeOnGotFocus();
    internal void UpdateCompositionText(FrameworkTextComposition composition);
    internal static FrameworkTextComposition CreateComposition(TextEditor editor, object owner);
    internal UIElement get_RenderScope();
    internal FrameworkElement get_UiScope();
    internal ITextContainer get_TextContainer();
    internal ITextView get_TextView();
    internal ITfDocumentMgr get_DocumentManager();
    internal void set_DocumentManager(ITfDocumentMgr value);
    internal int get_ThreadFocusCookie();
    internal void set_ThreadFocusCookie(int value);
    internal int get_EditSinkCookie();
    internal void set_EditSinkCookie(int value);
    internal int get_EditCookie();
    internal void set_EditCookie(int value);
    internal bool get_IsInterimSelection();
    internal bool get_IsComposing();
    internal bool get_IsEffectivelyComposing();
    internal int get_TransitoryExtensionSinkCookie();
    internal void set_TransitoryExtensionSinkCookie(int value);
    internal IntPtr get_CriticalSourceWnd();
    private void OnTextContainerChange(object sender, TextContainerChangeEventArgs args);
    private object GrantLockHandler(object o);
    private bool get_HasSink();
    private int GrantLockWorker(LockFlags flags);
    private int GrantLock();
    private static bool WalkTextRun(ITextPointer navigator, ITextPointer limit, Char[] text, int cchReq, Int32& charsCopied, TS_RUNINFO[] runInfo, int cRunInfoReq, Int32& cRunInfoRcv);
    private static bool WalkObjectRun(ITextPointer navigator, ITextPointer limit, Char[] text, int cchReq, Int32& charsCopied, TS_RUNINFO[] runInfo, int cRunInfoReq, Int32& cRunInfoRcv);
    private static bool WalkRegionBoundary(ITextPointer navigator, ITextPointer limit, Char[] text, int cchReq, Int32& charsCopied, TS_RUNINFO[] runInfo, int cRunInfoReq, Int32& cRunInfoRcv);
    private void GetVisualInfo(PresentationSource& source, IWin32Window& win32Window, ITextView& view);
    private static RECT TransformRootRectToScreenCoordinates(Point milPointTopLeft, Point milPointBottomRight, IWin32Window win32Window, PresentationSource source);
    private static string GetFontFamilyName(FontFamily fontFamily, XmlLanguage language);
    private void PrepareAttributes(InputScope inputScope, double fontSize, FontFamily fontFamily, XmlLanguage language, Visual visual, int count, Guid[] filterAttributes);
    private void TextPositionsFromITfRange(ITfRange range, ITextPointer& start, ITextPointer& end);
    private void GetCompositionPositions(ITextPointer& start, ITextPointer& end);
    private void GetCompositionPositions(ITfCompositionView view, ITextPointer& start, ITextPointer& end);
    private static string StringFromITfRange(ITfRange range, int ecReadOnly);
    private void OnMouseButtonEvent(object sender, MouseButtonEventArgs e);
    private void OnMouseEvent(object sender, MouseEventArgs e);
    private bool InternalMouseEventHandler();
    private CompositionParentUndoUnit OpenCompositionUndoUnit();
    private CompositionParentUndoUnit OpenCompositionUndoUnit(ITextPointer compositionStart, ITextPointer compositionEnd);
    private static Rect GetLineBounds(ITextPointer start, ITextPointer end);
    private string FilterCompositionString(string text, int charsToReplaceCount);
    private object CompleteCompositionHandler(object o);
    private IntPtr GetSourceWnd(bool callerIsTrusted);
    private void ValidateChange(TS_TEXTCHANGE change);
    private void VerifyTextStoreConsistency();
    private void ValidateCharOffset(int offset);
    private void BreakTypingSequence(ITextPointer caretPosition);
    private static void GetAdjustedSelection(ITextPointer startIn, ITextPointer endIn, ITextPointer& startOut, ITextPointer& endOut);
    private void GetNormalizedRange(int startCharOffset, int endCharOffset, ITextPointer& start, ITextPointer& end);
    private void HandleCompositionEvents(int previousUndoCount);
    private TextParentUndoUnit OpenTextParentUndoUnit();
    private void CloseTextParentUndoUnit(TextParentUndoUnit textParentUndoUnit, UndoCloseAction undoCloseAction);
    private void RaiseCompositionEvents(Int32& appSelectionAnchorOffset, Int32& appSelectionMovingOffset);
    private bool IsMaxLengthExceeded(string textData, int charsToReplaceCount);
    private bool IsCompositionRecordShifted(CompositionEventRecord record);
    private void SetFinalDocumentState(UndoManager undoManager, Stack imeChangeStack, int appChangeCount, int imeSelectionAnchorOffset, int imeSelectionMovingOffset, int appSelectionAnchorOffset, int appSelectionMovingOffset);
    private void UndoQuietly(int count);
    private void RedoQuietly(int count);
    private void MergeCompositionUndoUnits();
    private CompositionParentUndoUnit PeekCompositionParentUndoUnit();
    private bool get_IsTextEditorValid();
    private TextEditor get_TextEditor();
    private ITextSelection get_TextSelection();
    private bool get_IsReadOnly();
    private List`1<CompositionEventRecord> get_CompositionEventList();
    private bool get_IsTracing();
    private void set_IsTracing(bool value);
}
internal class System.Windows.Documents.TextTreeDeleteContentUndoUnit : TextTreeUndoUnit {
    private ContentContainer _content;
    internal TextTreeDeleteContentUndoUnit(TextContainer tree, TextPointer start, TextPointer end);
    public virtual void DoCore();
    internal static TableColumn[] SaveColumns(Table table);
    internal static void RestoreColumns(Table table, TableColumn[] savedColumns);
    private static TableColumn CopyColumn(TableColumn sourceTableColumn);
    private ContentContainer CopyContent(TextTreeNode node, TextTreeNode haltNode);
    private TextTreeNode CopyTextNode(TextTreeTextNode textNode, TextTreeNode haltNode, ContentContainer& container);
    private TextTreeNode CopyObjectNode(TextTreeObjectNode objectNode, ContentContainer& container);
    private TextTreeNode CopyElementNode(TextTreeTextElementNode elementNode, ContentContainer& container);
}
internal class System.Windows.Documents.TextTreeExtractElementUndoUnit : TextTreeUndoUnit {
    private int _symbolCount;
    private Type _type;
    private PropertyRecord[] _localValues;
    private ResourceDictionary _resources;
    private TableColumn[] _columns;
    internal TextTreeExtractElementUndoUnit(TextContainer tree, TextTreeTextElementNode elementNode);
    public virtual void DoCore();
}
internal class System.Windows.Documents.TextTreeFixupNode : TextTreeNode {
    private TextTreeNode _previousNode;
    private ElementEdge _previousEdge;
    private TextTreeNode _nextNode;
    private ElementEdge _nextEdge;
    private TextTreeNode _firstContainedNode;
    private TextTreeNode _lastContainedNode;
    internal SplayTreeNode ParentNode { get; internal set; }
    internal SplayTreeNode ContainedNode { get; internal set; }
    internal int LeftSymbolCount { get; internal set; }
    internal int LeftCharCount { get; internal set; }
    internal SplayTreeNode LeftChildNode { get; internal set; }
    internal SplayTreeNode RightChildNode { get; internal set; }
    internal UInt32 Generation { get; internal set; }
    internal int SymbolOffsetCache { get; internal set; }
    internal int SymbolCount { get; internal set; }
    internal int IMECharCount { get; internal set; }
    internal bool BeforeStartReferenceCount { get; internal set; }
    internal bool AfterStartReferenceCount { get; internal set; }
    internal bool BeforeEndReferenceCount { get; internal set; }
    internal bool AfterEndReferenceCount { get; internal set; }
    internal TextTreeNode PreviousNode { get; }
    internal ElementEdge PreviousEdge { get; }
    internal TextTreeNode NextNode { get; }
    internal ElementEdge NextEdge { get; }
    internal TextTreeNode FirstContainedNode { get; }
    internal TextTreeNode LastContainedNode { get; }
    internal TextTreeFixupNode(TextTreeNode previousNode, ElementEdge previousEdge, TextTreeNode nextNode, ElementEdge nextEdge);
    internal TextTreeFixupNode(TextTreeNode previousNode, ElementEdge previousEdge, TextTreeNode nextNode, ElementEdge nextEdge, TextTreeNode firstContainedNode, TextTreeNode lastContainedNode);
    internal virtual TextTreeNode Clone();
    internal virtual TextPointerContext GetPointerContext(LogicalDirection direction);
    internal virtual SplayTreeNode get_ParentNode();
    internal virtual void set_ParentNode(SplayTreeNode value);
    internal virtual SplayTreeNode get_ContainedNode();
    internal virtual void set_ContainedNode(SplayTreeNode value);
    internal virtual int get_LeftSymbolCount();
    internal virtual void set_LeftSymbolCount(int value);
    internal virtual int get_LeftCharCount();
    internal virtual void set_LeftCharCount(int value);
    internal virtual SplayTreeNode get_LeftChildNode();
    internal virtual void set_LeftChildNode(SplayTreeNode value);
    internal virtual SplayTreeNode get_RightChildNode();
    internal virtual void set_RightChildNode(SplayTreeNode value);
    internal virtual UInt32 get_Generation();
    internal virtual void set_Generation(UInt32 value);
    internal virtual int get_SymbolOffsetCache();
    internal virtual void set_SymbolOffsetCache(int value);
    internal virtual int get_SymbolCount();
    internal virtual void set_SymbolCount(int value);
    internal virtual int get_IMECharCount();
    internal virtual void set_IMECharCount(int value);
    internal virtual bool get_BeforeStartReferenceCount();
    internal virtual void set_BeforeStartReferenceCount(bool value);
    internal virtual bool get_AfterStartReferenceCount();
    internal virtual void set_AfterStartReferenceCount(bool value);
    internal virtual bool get_BeforeEndReferenceCount();
    internal virtual void set_BeforeEndReferenceCount(bool value);
    internal virtual bool get_AfterEndReferenceCount();
    internal virtual void set_AfterEndReferenceCount(bool value);
    internal TextTreeNode get_PreviousNode();
    internal ElementEdge get_PreviousEdge();
    internal TextTreeNode get_NextNode();
    internal ElementEdge get_NextEdge();
    internal TextTreeNode get_FirstContainedNode();
    internal TextTreeNode get_LastContainedNode();
}
internal class System.Windows.Documents.TextTreeInsertElementUndoUnit : TextTreeUndoUnit {
    private bool _deep;
    internal TextTreeInsertElementUndoUnit(TextContainer tree, int symbolOffset, bool deep);
    public virtual void DoCore();
}
internal class System.Windows.Documents.TextTreeInsertUndoUnit : TextTreeUndoUnit {
    private int _symbolCount;
    internal TextTreeInsertUndoUnit(TextContainer tree, int symbolOffset, int symbolCount);
    public virtual void DoCore();
}
internal abstract class System.Windows.Documents.TextTreeNode : SplayTreeNode {
    internal bool BeforeStartReferenceCount { get; internal set; }
    internal bool AfterStartReferenceCount { get; internal set; }
    internal bool BeforeEndReferenceCount { get; internal set; }
    internal bool AfterEndReferenceCount { get; internal set; }
    internal abstract virtual TextTreeNode Clone();
    internal TextContainer GetTextTree();
    internal DependencyObject GetDependencyParent();
    internal DependencyObject GetLogicalTreeNode();
    internal abstract virtual TextPointerContext GetPointerContext(LogicalDirection direction);
    internal TextTreeNode IncrementReferenceCount(ElementEdge edge);
    internal virtual TextTreeNode IncrementReferenceCount(ElementEdge edge, bool delta);
    internal virtual TextTreeNode IncrementReferenceCount(ElementEdge edge, int delta);
    internal virtual void DecrementReferenceCount(ElementEdge edge);
    internal void InsertAtPosition(TextPointer position);
    internal ElementEdge GetEdgeFromOffsetNoBias(int nodeOffset);
    internal ElementEdge GetEdgeFromOffset(int nodeOffset, LogicalDirection bias);
    internal int GetOffsetFromEdge(ElementEdge edge);
    internal abstract virtual bool get_BeforeStartReferenceCount();
    internal abstract virtual void set_BeforeStartReferenceCount(bool value);
    internal abstract virtual bool get_AfterStartReferenceCount();
    internal abstract virtual void set_AfterStartReferenceCount(bool value);
    internal abstract virtual bool get_BeforeEndReferenceCount();
    internal abstract virtual void set_BeforeEndReferenceCount(bool value);
    internal abstract virtual bool get_AfterEndReferenceCount();
    internal abstract virtual void set_AfterEndReferenceCount(bool value);
}
internal class System.Windows.Documents.TextTreeObjectNode : TextTreeNode {
    private int _leftSymbolCount;
    private int _leftCharCount;
    private TextTreeNode _parentNode;
    private TextTreeNode _leftChildNode;
    private TextTreeNode _rightChildNode;
    private UInt32 _generation;
    private int _symbolOffsetCache;
    private ElementEdge _edgeReferenceCounts;
    private DependencyObject _embeddedElement;
    internal SplayTreeNode ParentNode { get; internal set; }
    internal SplayTreeNode ContainedNode { get; internal set; }
    internal int LeftSymbolCount { get; internal set; }
    internal int LeftCharCount { get; internal set; }
    internal SplayTreeNode LeftChildNode { get; internal set; }
    internal SplayTreeNode RightChildNode { get; internal set; }
    internal UInt32 Generation { get; internal set; }
    internal int SymbolOffsetCache { get; internal set; }
    internal int SymbolCount { get; internal set; }
    internal int IMECharCount { get; internal set; }
    internal bool BeforeStartReferenceCount { get; internal set; }
    internal bool AfterStartReferenceCount { get; internal set; }
    internal bool BeforeEndReferenceCount { get; internal set; }
    internal bool AfterEndReferenceCount { get; internal set; }
    internal DependencyObject EmbeddedElement { get; }
    internal TextTreeObjectNode(DependencyObject embeddedElement);
    internal virtual TextTreeNode Clone();
    internal virtual TextPointerContext GetPointerContext(LogicalDirection direction);
    internal virtual SplayTreeNode get_ParentNode();
    internal virtual void set_ParentNode(SplayTreeNode value);
    internal virtual SplayTreeNode get_ContainedNode();
    internal virtual void set_ContainedNode(SplayTreeNode value);
    internal virtual int get_LeftSymbolCount();
    internal virtual void set_LeftSymbolCount(int value);
    internal virtual int get_LeftCharCount();
    internal virtual void set_LeftCharCount(int value);
    internal virtual SplayTreeNode get_LeftChildNode();
    internal virtual void set_LeftChildNode(SplayTreeNode value);
    internal virtual SplayTreeNode get_RightChildNode();
    internal virtual void set_RightChildNode(SplayTreeNode value);
    internal virtual UInt32 get_Generation();
    internal virtual void set_Generation(UInt32 value);
    internal virtual int get_SymbolOffsetCache();
    internal virtual void set_SymbolOffsetCache(int value);
    internal virtual int get_SymbolCount();
    internal virtual void set_SymbolCount(int value);
    internal virtual int get_IMECharCount();
    internal virtual void set_IMECharCount(int value);
    internal virtual bool get_BeforeStartReferenceCount();
    internal virtual void set_BeforeStartReferenceCount(bool value);
    internal virtual bool get_AfterStartReferenceCount();
    internal virtual void set_AfterStartReferenceCount(bool value);
    internal virtual bool get_BeforeEndReferenceCount();
    internal virtual void set_BeforeEndReferenceCount(bool value);
    internal virtual bool get_AfterEndReferenceCount();
    internal virtual void set_AfterEndReferenceCount(bool value);
    internal DependencyObject get_EmbeddedElement();
}
internal class System.Windows.Documents.TextTreePropertyUndoUnit : TextTreeUndoUnit {
    private PropertyRecord _propertyRecord;
    internal TextTreePropertyUndoUnit(TextContainer tree, int symbolOffset, PropertyRecord propertyRecord);
    public virtual void DoCore();
}
internal class System.Windows.Documents.TextTreeRootNode : TextTreeNode {
    private TextContainer _tree;
    private TextTreeNode _containedNode;
    private int _symbolCount;
    private int _imeCharCount;
    private UInt32 _generation;
    private UInt32 _positionGeneration;
    private UInt32 _layoutGeneration;
    private TextTreeRootTextBlock _rootTextBlock;
    private bool _caretUnitBoundaryCache;
    private int _caretUnitBoundaryCacheOffset;
    private DispatcherProcessingDisabled _processingDisabled;
    internal SplayTreeNode ParentNode { get; internal set; }
    internal SplayTreeNode ContainedNode { get; internal set; }
    internal int LeftSymbolCount { get; internal set; }
    internal int LeftCharCount { get; internal set; }
    internal SplayTreeNode LeftChildNode { get; internal set; }
    internal SplayTreeNode RightChildNode { get; internal set; }
    internal UInt32 Generation { get; internal set; }
    internal UInt32 PositionGeneration { get; internal set; }
    internal UInt32 LayoutGeneration { get; internal set; }
    internal int SymbolOffsetCache { get; internal set; }
    internal int SymbolCount { get; internal set; }
    internal int IMECharCount { get; internal set; }
    internal bool BeforeStartReferenceCount { get; internal set; }
    internal bool AfterStartReferenceCount { get; internal set; }
    internal bool BeforeEndReferenceCount { get; internal set; }
    internal bool AfterEndReferenceCount { get; internal set; }
    internal TextContainer TextContainer { get; }
    internal TextTreeRootTextBlock RootTextBlock { get; internal set; }
    internal DispatcherProcessingDisabled DispatcherProcessingDisabled { get; internal set; }
    internal bool CaretUnitBoundaryCache { get; internal set; }
    internal int CaretUnitBoundaryCacheOffset { get; internal set; }
    internal TextTreeRootNode(TextContainer tree);
    internal virtual TextTreeNode Clone();
    internal virtual TextPointerContext GetPointerContext(LogicalDirection direction);
    internal virtual SplayTreeNode get_ParentNode();
    internal virtual void set_ParentNode(SplayTreeNode value);
    internal virtual SplayTreeNode get_ContainedNode();
    internal virtual void set_ContainedNode(SplayTreeNode value);
    internal virtual int get_LeftSymbolCount();
    internal virtual void set_LeftSymbolCount(int value);
    internal virtual int get_LeftCharCount();
    internal virtual void set_LeftCharCount(int value);
    internal virtual SplayTreeNode get_LeftChildNode();
    internal virtual void set_LeftChildNode(SplayTreeNode value);
    internal virtual SplayTreeNode get_RightChildNode();
    internal virtual void set_RightChildNode(SplayTreeNode value);
    internal virtual UInt32 get_Generation();
    internal virtual void set_Generation(UInt32 value);
    internal UInt32 get_PositionGeneration();
    internal void set_PositionGeneration(UInt32 value);
    internal UInt32 get_LayoutGeneration();
    internal void set_LayoutGeneration(UInt32 value);
    internal virtual int get_SymbolOffsetCache();
    internal virtual void set_SymbolOffsetCache(int value);
    internal virtual int get_SymbolCount();
    internal virtual void set_SymbolCount(int value);
    internal virtual int get_IMECharCount();
    internal virtual void set_IMECharCount(int value);
    internal virtual bool get_BeforeStartReferenceCount();
    internal virtual void set_BeforeStartReferenceCount(bool value);
    internal virtual bool get_AfterStartReferenceCount();
    internal virtual void set_AfterStartReferenceCount(bool value);
    internal virtual bool get_BeforeEndReferenceCount();
    internal virtual void set_BeforeEndReferenceCount(bool value);
    internal virtual bool get_AfterEndReferenceCount();
    internal virtual void set_AfterEndReferenceCount(bool value);
    internal TextContainer get_TextContainer();
    internal TextTreeRootTextBlock get_RootTextBlock();
    internal void set_RootTextBlock(TextTreeRootTextBlock value);
    internal DispatcherProcessingDisabled get_DispatcherProcessingDisabled();
    internal void set_DispatcherProcessingDisabled(DispatcherProcessingDisabled value);
    internal bool get_CaretUnitBoundaryCache();
    internal void set_CaretUnitBoundaryCache(bool value);
    internal int get_CaretUnitBoundaryCacheOffset();
    internal void set_CaretUnitBoundaryCacheOffset(int value);
}
internal class System.Windows.Documents.TextTreeRootTextBlock : SplayTreeNode {
    private TextTreeTextBlock _containedNode;
    internal SplayTreeNode ParentNode { get; internal set; }
    internal SplayTreeNode ContainedNode { get; internal set; }
    internal int LeftSymbolCount { get; internal set; }
    internal int LeftCharCount { get; internal set; }
    internal SplayTreeNode LeftChildNode { get; internal set; }
    internal SplayTreeNode RightChildNode { get; internal set; }
    internal UInt32 Generation { get; internal set; }
    internal int SymbolOffsetCache { get; internal set; }
    internal int SymbolCount { get; internal set; }
    internal int IMECharCount { get; internal set; }
    internal virtual SplayTreeNode get_ParentNode();
    internal virtual void set_ParentNode(SplayTreeNode value);
    internal virtual SplayTreeNode get_ContainedNode();
    internal virtual void set_ContainedNode(SplayTreeNode value);
    internal virtual int get_LeftSymbolCount();
    internal virtual void set_LeftSymbolCount(int value);
    internal virtual int get_LeftCharCount();
    internal virtual void set_LeftCharCount(int value);
    internal virtual SplayTreeNode get_LeftChildNode();
    internal virtual void set_LeftChildNode(SplayTreeNode value);
    internal virtual SplayTreeNode get_RightChildNode();
    internal virtual void set_RightChildNode(SplayTreeNode value);
    internal virtual UInt32 get_Generation();
    internal virtual void set_Generation(UInt32 value);
    internal virtual int get_SymbolOffsetCache();
    internal virtual void set_SymbolOffsetCache(int value);
    internal virtual int get_SymbolCount();
    internal virtual void set_SymbolCount(int value);
    internal virtual int get_IMECharCount();
    internal virtual void set_IMECharCount(int value);
}
internal static class System.Windows.Documents.TextTreeText : object {
    internal static void InsertText(TextTreeRootTextBlock rootTextBlock, int offset, object text);
    internal static void RemoveText(TextTreeRootTextBlock rootTextBlock, int offset, int count);
    internal static Char[] CutText(TextTreeRootTextBlock rootTextBlock, int offset, int count);
    internal static void ReadText(TextTreeRootTextBlock rootTextBlock, int offset, int count, Char[] chars, int startIndex);
    internal static void InsertObject(TextTreeRootTextBlock rootTextBlock, int offset);
    internal static void InsertElementEdges(TextTreeRootTextBlock rootTextBlock, int offset, int childSymbolCount);
    internal static void RemoveElementEdges(TextTreeRootTextBlock rootTextBlock, int offset, int symbolCount);
    private static TextTreeTextBlock FindBlock(TextTreeRootTextBlock rootTextBlock, int offset, Int32& localOffset);
    private static void InsertTextLeft(TextTreeTextBlock rightBlock, object text, int textOffset);
    private static void InsertTextRight(TextTreeTextBlock leftBlock, object text, int textOffset);
    internal static void Remove(TextTreeTextBlock firstNode, TextTreeTextBlock lastNode);
}
internal class System.Windows.Documents.TextTreeTextBlock : SplayTreeNode {
    private int _leftSymbolCount;
    private SplayTreeNode _parentNode;
    private TextTreeTextBlock _leftChildNode;
    private TextTreeTextBlock _rightChildNode;
    private Char[] _text;
    private int _gapOffset;
    private int _gapSize;
    internal static int MaxBlockSize;
    internal SplayTreeNode ParentNode { get; internal set; }
    internal SplayTreeNode ContainedNode { get; internal set; }
    internal int LeftSymbolCount { get; internal set; }
    internal int LeftCharCount { get; internal set; }
    internal SplayTreeNode LeftChildNode { get; internal set; }
    internal SplayTreeNode RightChildNode { get; internal set; }
    internal UInt32 Generation { get; internal set; }
    internal int SymbolOffsetCache { get; internal set; }
    internal int SymbolCount { get; internal set; }
    internal int IMECharCount { get; internal set; }
    internal int Count { get; }
    internal int FreeCapacity { get; }
    internal int GapOffset { get; }
    internal TextTreeTextBlock(int size);
    internal int InsertText(int logicalOffset, object text, int textStartIndex, int textEndIndex);
    internal TextTreeTextBlock SplitBlock();
    internal void RemoveText(int logicalOffset, int count);
    internal int ReadText(int logicalOffset, int count, Char[] chars, int charsStartIndex);
    internal virtual SplayTreeNode get_ParentNode();
    internal virtual void set_ParentNode(SplayTreeNode value);
    internal virtual SplayTreeNode get_ContainedNode();
    internal virtual void set_ContainedNode(SplayTreeNode value);
    internal virtual int get_LeftSymbolCount();
    internal virtual void set_LeftSymbolCount(int value);
    internal virtual int get_LeftCharCount();
    internal virtual void set_LeftCharCount(int value);
    internal virtual SplayTreeNode get_LeftChildNode();
    internal virtual void set_LeftChildNode(SplayTreeNode value);
    internal virtual SplayTreeNode get_RightChildNode();
    internal virtual void set_RightChildNode(SplayTreeNode value);
    internal virtual UInt32 get_Generation();
    internal virtual void set_Generation(UInt32 value);
    internal virtual int get_SymbolOffsetCache();
    internal virtual void set_SymbolOffsetCache(int value);
    internal virtual int get_SymbolCount();
    internal virtual void set_SymbolCount(int value);
    internal virtual int get_IMECharCount();
    internal virtual void set_IMECharCount(int value);
    internal int get_Count();
    internal int get_FreeCapacity();
    internal int get_GapOffset();
    private void MoveGap(int offset);
}
internal class System.Windows.Documents.TextTreeTextElementNode : TextTreeNode {
    private int _leftSymbolCount;
    private int _leftCharCount;
    private TextTreeNode _parentNode;
    private TextTreeNode _leftChildNode;
    private TextTreeNode _rightChildNode;
    private TextTreeNode _containedNode;
    private UInt32 _generation;
    private int _symbolOffsetCache;
    private int _symbolCount;
    private int _imeCharCount;
    private TextElement _textElement;
    private ElementEdge _edgeReferenceCounts;
    internal SplayTreeNode ParentNode { get; internal set; }
    internal SplayTreeNode ContainedNode { get; internal set; }
    internal int LeftSymbolCount { get; internal set; }
    internal int LeftCharCount { get; internal set; }
    internal SplayTreeNode LeftChildNode { get; internal set; }
    internal SplayTreeNode RightChildNode { get; internal set; }
    internal UInt32 Generation { get; internal set; }
    internal int SymbolOffsetCache { get; internal set; }
    internal int SymbolCount { get; internal set; }
    internal int IMECharCount { get; internal set; }
    internal bool BeforeStartReferenceCount { get; internal set; }
    internal bool AfterStartReferenceCount { get; internal set; }
    internal bool BeforeEndReferenceCount { get; internal set; }
    internal bool AfterEndReferenceCount { get; internal set; }
    internal TextElement TextElement { get; internal set; }
    internal int IMELeftEdgeCharCount { get; }
    internal bool IsFirstSibling { get; }
    internal virtual TextTreeNode Clone();
    internal virtual TextPointerContext GetPointerContext(LogicalDirection direction);
    internal virtual SplayTreeNode get_ParentNode();
    internal virtual void set_ParentNode(SplayTreeNode value);
    internal virtual SplayTreeNode get_ContainedNode();
    internal virtual void set_ContainedNode(SplayTreeNode value);
    internal virtual int get_LeftSymbolCount();
    internal virtual void set_LeftSymbolCount(int value);
    internal virtual int get_LeftCharCount();
    internal virtual void set_LeftCharCount(int value);
    internal virtual SplayTreeNode get_LeftChildNode();
    internal virtual void set_LeftChildNode(SplayTreeNode value);
    internal virtual SplayTreeNode get_RightChildNode();
    internal virtual void set_RightChildNode(SplayTreeNode value);
    internal virtual UInt32 get_Generation();
    internal virtual void set_Generation(UInt32 value);
    internal virtual int get_SymbolOffsetCache();
    internal virtual void set_SymbolOffsetCache(int value);
    internal virtual int get_SymbolCount();
    internal virtual void set_SymbolCount(int value);
    internal virtual int get_IMECharCount();
    internal virtual void set_IMECharCount(int value);
    internal virtual bool get_BeforeStartReferenceCount();
    internal virtual void set_BeforeStartReferenceCount(bool value);
    internal virtual bool get_AfterStartReferenceCount();
    internal virtual void set_AfterStartReferenceCount(bool value);
    internal virtual bool get_BeforeEndReferenceCount();
    internal virtual void set_BeforeEndReferenceCount(bool value);
    internal virtual bool get_AfterEndReferenceCount();
    internal virtual void set_AfterEndReferenceCount(bool value);
    internal TextElement get_TextElement();
    internal void set_TextElement(TextElement value);
    internal int get_IMELeftEdgeCharCount();
    internal bool get_IsFirstSibling();
}
internal class System.Windows.Documents.TextTreeTextNode : TextTreeNode {
    private int _leftSymbolCount;
    private int _leftCharCount;
    private TextTreeNode _parentNode;
    private TextTreeNode _leftChildNode;
    private TextTreeNode _rightChildNode;
    private UInt32 _generation;
    private int _symbolOffsetCache;
    private int _symbolCount;
    private int _positionRefCount;
    private ElementEdge _referencedEdge;
    internal SplayTreeNode ParentNode { get; internal set; }
    internal SplayTreeNode ContainedNode { get; internal set; }
    internal int LeftSymbolCount { get; internal set; }
    internal int LeftCharCount { get; internal set; }
    internal SplayTreeNode LeftChildNode { get; internal set; }
    internal SplayTreeNode RightChildNode { get; internal set; }
    internal UInt32 Generation { get; internal set; }
    internal int SymbolOffsetCache { get; internal set; }
    internal int SymbolCount { get; internal set; }
    internal int IMECharCount { get; internal set; }
    internal bool BeforeStartReferenceCount { get; internal set; }
    internal bool AfterStartReferenceCount { get; internal set; }
    internal bool BeforeEndReferenceCount { get; internal set; }
    internal bool AfterEndReferenceCount { get; internal set; }
    internal virtual TextTreeNode Clone();
    internal virtual TextPointerContext GetPointerContext(LogicalDirection direction);
    internal virtual TextTreeNode IncrementReferenceCount(ElementEdge edge, int delta);
    internal virtual void DecrementReferenceCount(ElementEdge edge);
    internal TextTreeTextNode Split(int localOffset, ElementEdge edge);
    internal virtual SplayTreeNode get_ParentNode();
    internal virtual void set_ParentNode(SplayTreeNode value);
    internal virtual SplayTreeNode get_ContainedNode();
    internal virtual void set_ContainedNode(SplayTreeNode value);
    internal virtual int get_LeftSymbolCount();
    internal virtual void set_LeftSymbolCount(int value);
    internal virtual int get_LeftCharCount();
    internal virtual void set_LeftCharCount(int value);
    internal virtual SplayTreeNode get_LeftChildNode();
    internal virtual void set_LeftChildNode(SplayTreeNode value);
    internal virtual SplayTreeNode get_RightChildNode();
    internal virtual void set_RightChildNode(SplayTreeNode value);
    internal virtual UInt32 get_Generation();
    internal virtual void set_Generation(UInt32 value);
    internal virtual int get_SymbolOffsetCache();
    internal virtual void set_SymbolOffsetCache(int value);
    internal virtual int get_SymbolCount();
    internal virtual void set_SymbolCount(int value);
    internal virtual int get_IMECharCount();
    internal virtual void set_IMECharCount(int value);
    internal virtual bool get_BeforeStartReferenceCount();
    internal virtual void set_BeforeStartReferenceCount(bool value);
    internal virtual bool get_AfterStartReferenceCount();
    internal virtual void set_AfterStartReferenceCount(bool value);
    internal virtual bool get_BeforeEndReferenceCount();
    internal virtual void set_BeforeEndReferenceCount(bool value);
    internal virtual bool get_AfterEndReferenceCount();
    internal virtual void set_AfterEndReferenceCount(bool value);
    private void Merge();
}
internal static class System.Windows.Documents.TextTreeUndo : object {
    internal static void CreateInsertUndoUnit(TextContainer tree, int symbolOffset, int symbolCount);
    internal static void CreateInsertElementUndoUnit(TextContainer tree, int symbolOffset, bool deep);
    internal static void CreatePropertyUndoUnit(TextElement element, DependencyPropertyChangedEventArgs e);
    internal static TextTreeDeleteContentUndoUnit CreateDeleteContentUndoUnit(TextContainer tree, TextPointer start, TextPointer end);
    internal static TextTreeExtractElementUndoUnit CreateExtractElementUndoUnit(TextContainer tree, TextTreeTextElementNode elementNode);
    internal static UndoManager GetOrClearUndoManager(ITextContainer textContainer);
}
internal abstract class System.Windows.Documents.TextTreeUndoUnit : object {
    private TextContainer _tree;
    private int _symbolOffset;
    private int _treeContentHashCode;
    protected TextContainer TextContainer { get; }
    protected int SymbolOffset { get; }
    internal TextTreeUndoUnit(TextContainer tree, int symbolOffset);
    public sealed virtual void Do();
    public abstract virtual void DoCore();
    public sealed virtual bool Merge(IUndoUnit unit);
    protected TextContainer get_TextContainer();
    protected int get_SymbolOffset();
    internal void SetTreeHashCode();
    internal void VerifyTreeContentHashCode();
    internal static PropertyRecord[] GetPropertyRecordArray(DependencyObject d);
    internal static LocalValueEnumerator ArrayToLocalValueEnumerator(PropertyRecord[] records);
}
internal class System.Windows.Documents.Tracing.SpellerCOMActionTraceLogger : object {
    private static string SpellerCOMLatencyMeasurement;
    private static Dictionary`2<Actions, long> _timeLimits100Ns;
    private static WeakDictionary`2<WinRTSpellerInterop, InstanceInfo> _instanceInfos;
    private static object _lockObject;
    private Actions _action;
    private long _beginTicks;
    private InstanceInfo _instanceInfo;
    private bool _disposed;
    public SpellerCOMActionTraceLogger(WinRTSpellerInterop caller, Actions action);
    private static SpellerCOMActionTraceLogger();
    private void UpdateRunningAverageAndLogDebugInfo(long endTicks);
    protected virtual void Dispose(bool disposing);
    public sealed virtual void Dispose();
}
public class System.Windows.Documents.Typography : object {
    private static Type _typeofThis;
    private static Type _typeofBool;
    public static DependencyProperty StandardLigaturesProperty;
    public static DependencyProperty ContextualLigaturesProperty;
    public static DependencyProperty DiscretionaryLigaturesProperty;
    public static DependencyProperty HistoricalLigaturesProperty;
    public static DependencyProperty AnnotationAlternatesProperty;
    public static DependencyProperty ContextualAlternatesProperty;
    public static DependencyProperty HistoricalFormsProperty;
    public static DependencyProperty KerningProperty;
    public static DependencyProperty CapitalSpacingProperty;
    public static DependencyProperty CaseSensitiveFormsProperty;
    public static DependencyProperty StylisticSet1Property;
    public static DependencyProperty StylisticSet2Property;
    public static DependencyProperty StylisticSet3Property;
    public static DependencyProperty StylisticSet4Property;
    public static DependencyProperty StylisticSet5Property;
    public static DependencyProperty StylisticSet6Property;
    public static DependencyProperty StylisticSet7Property;
    public static DependencyProperty StylisticSet8Property;
    public static DependencyProperty StylisticSet9Property;
    public static DependencyProperty StylisticSet10Property;
    public static DependencyProperty StylisticSet11Property;
    public static DependencyProperty StylisticSet12Property;
    public static DependencyProperty StylisticSet13Property;
    public static DependencyProperty StylisticSet14Property;
    public static DependencyProperty StylisticSet15Property;
    public static DependencyProperty StylisticSet16Property;
    public static DependencyProperty StylisticSet17Property;
    public static DependencyProperty StylisticSet18Property;
    public static DependencyProperty StylisticSet19Property;
    public static DependencyProperty StylisticSet20Property;
    public static DependencyProperty FractionProperty;
    public static DependencyProperty SlashedZeroProperty;
    public static DependencyProperty MathematicalGreekProperty;
    public static DependencyProperty EastAsianExpertFormsProperty;
    public static DependencyProperty VariantsProperty;
    public static DependencyProperty CapitalsProperty;
    public static DependencyProperty NumeralStyleProperty;
    public static DependencyProperty NumeralAlignmentProperty;
    public static DependencyProperty EastAsianWidthsProperty;
    public static DependencyProperty EastAsianLanguageProperty;
    public static DependencyProperty StandardSwashesProperty;
    public static DependencyProperty ContextualSwashesProperty;
    public static DependencyProperty StylisticAlternatesProperty;
    internal static DependencyProperty[] TypographyPropertiesList;
    internal static TypographyProperties Default;
    private DependencyObject _owner;
    public bool StandardLigatures { get; public set; }
    public bool ContextualLigatures { get; public set; }
    public bool DiscretionaryLigatures { get; public set; }
    public bool HistoricalLigatures { get; public set; }
    public int AnnotationAlternates { get; public set; }
    public bool ContextualAlternates { get; public set; }
    public bool HistoricalForms { get; public set; }
    public bool Kerning { get; public set; }
    public bool CapitalSpacing { get; public set; }
    public bool CaseSensitiveForms { get; public set; }
    public bool StylisticSet1 { get; public set; }
    public bool StylisticSet2 { get; public set; }
    public bool StylisticSet3 { get; public set; }
    public bool StylisticSet4 { get; public set; }
    public bool StylisticSet5 { get; public set; }
    public bool StylisticSet6 { get; public set; }
    public bool StylisticSet7 { get; public set; }
    public bool StylisticSet8 { get; public set; }
    public bool StylisticSet9 { get; public set; }
    public bool StylisticSet10 { get; public set; }
    public bool StylisticSet11 { get; public set; }
    public bool StylisticSet12 { get; public set; }
    public bool StylisticSet13 { get; public set; }
    public bool StylisticSet14 { get; public set; }
    public bool StylisticSet15 { get; public set; }
    public bool StylisticSet16 { get; public set; }
    public bool StylisticSet17 { get; public set; }
    public bool StylisticSet18 { get; public set; }
    public bool StylisticSet19 { get; public set; }
    public bool StylisticSet20 { get; public set; }
    public FontFraction Fraction { get; public set; }
    public bool SlashedZero { get; public set; }
    public bool MathematicalGreek { get; public set; }
    public bool EastAsianExpertForms { get; public set; }
    public FontVariants Variants { get; public set; }
    public FontCapitals Capitals { get; public set; }
    public FontNumeralStyle NumeralStyle { get; public set; }
    public FontNumeralAlignment NumeralAlignment { get; public set; }
    public FontEastAsianWidths EastAsianWidths { get; public set; }
    public FontEastAsianLanguage EastAsianLanguage { get; public set; }
    public int StandardSwashes { get; public set; }
    public int ContextualSwashes { get; public set; }
    public int StylisticAlternates { get; public set; }
    internal Typography(DependencyObject owner);
    private static Typography();
    public bool get_StandardLigatures();
    public void set_StandardLigatures(bool value);
    public bool get_ContextualLigatures();
    public void set_ContextualLigatures(bool value);
    public bool get_DiscretionaryLigatures();
    public void set_DiscretionaryLigatures(bool value);
    public bool get_HistoricalLigatures();
    public void set_HistoricalLigatures(bool value);
    public int get_AnnotationAlternates();
    public void set_AnnotationAlternates(int value);
    public bool get_ContextualAlternates();
    public void set_ContextualAlternates(bool value);
    public bool get_HistoricalForms();
    public void set_HistoricalForms(bool value);
    public bool get_Kerning();
    public void set_Kerning(bool value);
    public bool get_CapitalSpacing();
    public void set_CapitalSpacing(bool value);
    public bool get_CaseSensitiveForms();
    public void set_CaseSensitiveForms(bool value);
    public bool get_StylisticSet1();
    public void set_StylisticSet1(bool value);
    public bool get_StylisticSet2();
    public void set_StylisticSet2(bool value);
    public bool get_StylisticSet3();
    public void set_StylisticSet3(bool value);
    public bool get_StylisticSet4();
    public void set_StylisticSet4(bool value);
    public bool get_StylisticSet5();
    public void set_StylisticSet5(bool value);
    public bool get_StylisticSet6();
    public void set_StylisticSet6(bool value);
    public bool get_StylisticSet7();
    public void set_StylisticSet7(bool value);
    public bool get_StylisticSet8();
    public void set_StylisticSet8(bool value);
    public bool get_StylisticSet9();
    public void set_StylisticSet9(bool value);
    public bool get_StylisticSet10();
    public void set_StylisticSet10(bool value);
    public bool get_StylisticSet11();
    public void set_StylisticSet11(bool value);
    public bool get_StylisticSet12();
    public void set_StylisticSet12(bool value);
    public bool get_StylisticSet13();
    public void set_StylisticSet13(bool value);
    public bool get_StylisticSet14();
    public void set_StylisticSet14(bool value);
    public bool get_StylisticSet15();
    public void set_StylisticSet15(bool value);
    public bool get_StylisticSet16();
    public void set_StylisticSet16(bool value);
    public bool get_StylisticSet17();
    public void set_StylisticSet17(bool value);
    public bool get_StylisticSet18();
    public void set_StylisticSet18(bool value);
    public bool get_StylisticSet19();
    public void set_StylisticSet19(bool value);
    public bool get_StylisticSet20();
    public void set_StylisticSet20(bool value);
    public FontFraction get_Fraction();
    public void set_Fraction(FontFraction value);
    public bool get_SlashedZero();
    public void set_SlashedZero(bool value);
    public bool get_MathematicalGreek();
    public void set_MathematicalGreek(bool value);
    public bool get_EastAsianExpertForms();
    public void set_EastAsianExpertForms(bool value);
    public FontVariants get_Variants();
    public void set_Variants(FontVariants value);
    public FontCapitals get_Capitals();
    public void set_Capitals(FontCapitals value);
    public FontNumeralStyle get_NumeralStyle();
    public void set_NumeralStyle(FontNumeralStyle value);
    public FontNumeralAlignment get_NumeralAlignment();
    public void set_NumeralAlignment(FontNumeralAlignment value);
    public FontEastAsianWidths get_EastAsianWidths();
    public void set_EastAsianWidths(FontEastAsianWidths value);
    public FontEastAsianLanguage get_EastAsianLanguage();
    public void set_EastAsianLanguage(FontEastAsianLanguage value);
    public int get_StandardSwashes();
    public void set_StandardSwashes(int value);
    public int get_ContextualSwashes();
    public void set_ContextualSwashes(int value);
    public int get_StylisticAlternates();
    public void set_StylisticAlternates(int value);
    public static void SetStandardLigatures(DependencyObject element, bool value);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static bool GetStandardLigatures(DependencyObject element);
    public static void SetContextualLigatures(DependencyObject element, bool value);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static bool GetContextualLigatures(DependencyObject element);
    public static void SetDiscretionaryLigatures(DependencyObject element, bool value);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static bool GetDiscretionaryLigatures(DependencyObject element);
    public static void SetHistoricalLigatures(DependencyObject element, bool value);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static bool GetHistoricalLigatures(DependencyObject element);
    public static void SetAnnotationAlternates(DependencyObject element, int value);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static int GetAnnotationAlternates(DependencyObject element);
    public static void SetContextualAlternates(DependencyObject element, bool value);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static bool GetContextualAlternates(DependencyObject element);
    public static void SetHistoricalForms(DependencyObject element, bool value);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static bool GetHistoricalForms(DependencyObject element);
    public static void SetKerning(DependencyObject element, bool value);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static bool GetKerning(DependencyObject element);
    public static void SetCapitalSpacing(DependencyObject element, bool value);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static bool GetCapitalSpacing(DependencyObject element);
    public static void SetCaseSensitiveForms(DependencyObject element, bool value);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static bool GetCaseSensitiveForms(DependencyObject element);
    public static void SetStylisticSet1(DependencyObject element, bool value);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static bool GetStylisticSet1(DependencyObject element);
    public static void SetStylisticSet2(DependencyObject element, bool value);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static bool GetStylisticSet2(DependencyObject element);
    public static void SetStylisticSet3(DependencyObject element, bool value);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static bool GetStylisticSet3(DependencyObject element);
    public static void SetStylisticSet4(DependencyObject element, bool value);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static bool GetStylisticSet4(DependencyObject element);
    public static void SetStylisticSet5(DependencyObject element, bool value);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static bool GetStylisticSet5(DependencyObject element);
    public static void SetStylisticSet6(DependencyObject element, bool value);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static bool GetStylisticSet6(DependencyObject element);
    public static void SetStylisticSet7(DependencyObject element, bool value);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static bool GetStylisticSet7(DependencyObject element);
    public static void SetStylisticSet8(DependencyObject element, bool value);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static bool GetStylisticSet8(DependencyObject element);
    public static void SetStylisticSet9(DependencyObject element, bool value);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static bool GetStylisticSet9(DependencyObject element);
    public static void SetStylisticSet10(DependencyObject element, bool value);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static bool GetStylisticSet10(DependencyObject element);
    public static void SetStylisticSet11(DependencyObject element, bool value);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static bool GetStylisticSet11(DependencyObject element);
    public static void SetStylisticSet12(DependencyObject element, bool value);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static bool GetStylisticSet12(DependencyObject element);
    public static void SetStylisticSet13(DependencyObject element, bool value);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static bool GetStylisticSet13(DependencyObject element);
    public static void SetStylisticSet14(DependencyObject element, bool value);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static bool GetStylisticSet14(DependencyObject element);
    public static void SetStylisticSet15(DependencyObject element, bool value);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static bool GetStylisticSet15(DependencyObject element);
    public static void SetStylisticSet16(DependencyObject element, bool value);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static bool GetStylisticSet16(DependencyObject element);
    public static void SetStylisticSet17(DependencyObject element, bool value);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static bool GetStylisticSet17(DependencyObject element);
    public static void SetStylisticSet18(DependencyObject element, bool value);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static bool GetStylisticSet18(DependencyObject element);
    public static void SetStylisticSet19(DependencyObject element, bool value);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static bool GetStylisticSet19(DependencyObject element);
    public static void SetStylisticSet20(DependencyObject element, bool value);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static bool GetStylisticSet20(DependencyObject element);
    public static void SetFraction(DependencyObject element, FontFraction value);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static FontFraction GetFraction(DependencyObject element);
    public static void SetSlashedZero(DependencyObject element, bool value);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static bool GetSlashedZero(DependencyObject element);
    public static void SetMathematicalGreek(DependencyObject element, bool value);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static bool GetMathematicalGreek(DependencyObject element);
    public static void SetEastAsianExpertForms(DependencyObject element, bool value);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static bool GetEastAsianExpertForms(DependencyObject element);
    public static void SetVariants(DependencyObject element, FontVariants value);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static FontVariants GetVariants(DependencyObject element);
    public static void SetCapitals(DependencyObject element, FontCapitals value);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static FontCapitals GetCapitals(DependencyObject element);
    public static void SetNumeralStyle(DependencyObject element, FontNumeralStyle value);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static FontNumeralStyle GetNumeralStyle(DependencyObject element);
    public static void SetNumeralAlignment(DependencyObject element, FontNumeralAlignment value);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static FontNumeralAlignment GetNumeralAlignment(DependencyObject element);
    public static void SetEastAsianWidths(DependencyObject element, FontEastAsianWidths value);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static FontEastAsianWidths GetEastAsianWidths(DependencyObject element);
    public static void SetEastAsianLanguage(DependencyObject element, FontEastAsianLanguage value);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static FontEastAsianLanguage GetEastAsianLanguage(DependencyObject element);
    public static void SetStandardSwashes(DependencyObject element, int value);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static int GetStandardSwashes(DependencyObject element);
    public static void SetContextualSwashes(DependencyObject element, int value);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static int GetContextualSwashes(DependencyObject element);
    public static void SetStylisticAlternates(DependencyObject element, int value);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static int GetStylisticAlternates(DependencyObject element);
}
internal class System.Windows.Documents.UIElementPropertyUndoUnit : object {
    private UIElement _uiElement;
    private DependencyProperty _property;
    private object _oldValue;
    private UIElementPropertyUndoUnit(UIElement uiElement, DependencyProperty property, object oldValue);
    public sealed virtual void Do();
    public sealed virtual bool Merge(IUndoUnit unit);
    internal static void Add(ITextContainer textContainer, UIElement uiElement, DependencyProperty property, HorizontalAlignment newValue);
    internal static void Add(ITextContainer textContainer, UIElement uiElement, DependencyProperty property, FlowDirection newValue);
    private static void AddPrivate(ITextContainer textContainer, UIElement uiElement, DependencyProperty property, object newValue);
}
internal enum System.Windows.Documents.ULState : Enum {
    public int value__;
    public static ULState ULNone;
    public static ULState ULNormal;
    public static ULState ULDot;
    public static ULState ULDash;
    public static ULState ULDashDot;
    public static ULState ULDashDotDot;
    public static ULState ULDouble;
    public static ULState ULHeavyWave;
    public static ULState ULLongDash;
    public static ULState ULThick;
    public static ULState ULThickDot;
    public static ULState ULThickDash;
    public static ULState ULThickDashDot;
    public static ULState ULThickDashDotDot;
    public static ULState ULThickLongDash;
    public static ULState ULDoubleWave;
    public static ULState ULWord;
    public static ULState ULWave;
}
public class System.Windows.Documents.Underline : Span {
    private static Underline();
    public Underline(Inline childInline);
    public Underline(Inline childInline, TextPointer insertionPosition);
    public Underline(TextPointer start, TextPointer end);
}
internal static class System.Windows.Documents.ValidationHelper : object {
    internal static void VerifyPosition(ITextContainer tree, ITextPointer position);
    internal static void VerifyPosition(ITextContainer container, ITextPointer position, string paramName);
    internal static void VerifyPositionPair(ITextPointer startPosition, ITextPointer endPosition);
    internal static void VerifyDirection(LogicalDirection direction, string argumentName);
    internal static void VerifyElementEdge(ElementEdge edge, string param);
    internal static void ValidateChild(TextPointer position, object child, string paramName);
}
internal static class System.Windows.Documents.Validators : object {
    internal static bool IsValidFontSize(long fs);
    internal static bool IsValidWidthType(long wt);
    internal static long MakeValidShading(long s);
    internal static long MakeValidBorderWidth(long w);
}
internal enum System.Windows.Documents.VAlign : Enum {
    public int value__;
    public static VAlign AlignTop;
    public static VAlign AlignCenter;
    public static VAlign AlignBottom;
}
internal enum System.Windows.Documents.WidthType : Enum {
    public int value__;
    public static WidthType WidthIgnore;
    public static WidthType WidthAuto;
    public static WidthType WidthPercent;
    public static WidthType WidthTwips;
}
internal class System.Windows.Documents.WinEventHandler : object {
    private int _eventMin;
    private int _eventMax;
    private SecurityCriticalDataForSet`1<IntPtr> _hHook;
    private SecurityCriticalDataForSet`1<WinEventProcDef> _winEventProc;
    private GCHandle _gchThis;
    private WinEventHandlerShutDownListener _shutdownListener;
    internal WinEventHandler(int eventMin, int eventMax);
    protected virtual override void Finalize();
    public sealed virtual void Dispose();
    internal virtual void WinEventProc(int eventId, IntPtr hwnd);
    internal void Clear();
    internal void Start();
    internal void Stop();
    private void WinEventDefaultProc(int winEventHook, int eventId, IntPtr hwnd, int idObject, int idChild, int eventThread, int eventTime);
}
internal class System.Windows.Documents.WinRTSpellerInterop : SpellerInteropBase {
    private bool _isDisposed;
    private SpellerMode _mode;
    private Dictionary`2<CultureInfo, Tuple`2<WordsSegmenter, SpellChecker>> _spellCheckers;
    private CultureInfo _defaultCulture;
    private CultureInfo _culture;
    private Dictionary`2<string, List`1<string>> _customDictionaryFiles;
    private WeakReference`1<Dispatcher> _dispatcher;
    unknown SpellerMode Mode {internal set; }
    unknown bool MultiWordMode {internal set; }
    private CultureInfo Culture { get; private set; }
    private WordsSegmenter CurrentWordBreaker { get; }
    private WordsSegmenter DefaultCultureWordBreaker { get; }
    private SpellChecker CurrentSpellChecker { get; }
    protected virtual override void Finalize();
    public virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    internal virtual void SetLocale(CultureInfo culture);
    internal virtual void set_Mode(SpellerMode value);
    internal virtual void set_MultiWordMode(bool value);
    internal virtual void SetReformMode(CultureInfo culture, SpellingReform spellingReform);
    internal virtual bool CanSpellCheck(CultureInfo culture);
    internal virtual void UnloadDictionary(object token);
    internal virtual object LoadDictionary(string lexiconFilePath);
    internal virtual object LoadDictionary(Uri item, string trustedFolder);
    internal virtual void ReleaseAllLexicons();
    private bool EnsureWordBreakerAndSpellCheckerForCulture(CultureInfo culture, bool throwOnError);
    internal virtual int EnumTextSegments(Char[] text, int count, EnumSentencesCallback sentenceCallback, EnumTextSegmentsCallback segmentCallback, object data);
    private Tuple`2<string, string> LoadDictionaryImpl(string lexiconFilePath);
    private void ClearDictionaries(bool disposing);
    private static CultureInfo TryParseLexiconCulture(string line);
    private static void CopyToUnicodeFile(string sourcePath, FileStream targetStream);
    private void ProcessUnhandledException(object sender, UnhandledExceptionEventArgs e);
    private void ReleaseAllResources(bool disposing);
    private DispatcherOperation BeginInvokeOnUIThread(Delegate method, DispatcherPriority priority, Object[] args);
    private CultureInfo get_Culture();
    private void set_Culture(CultureInfo value);
    private WordsSegmenter get_CurrentWordBreaker();
    private WordsSegmenter get_DefaultCultureWordBreaker();
    private SpellChecker get_CurrentSpellChecker();
}
internal class System.Windows.Documents.WpfPayload : object {
    private static string XamlContentType;
    internal static string ImageBmpContentType;
    private static string ImageGifContentType;
    private static string ImageJpegContentType;
    private static string ImageTiffContentType;
    private static string ImagePngContentType;
    private static string ImageBmpFileExtension;
    private static string ImageGifFileExtension;
    private static string ImageJpegFileExtension;
    private static string ImageJpgFileExtension;
    private static string ImageTiffFileExtension;
    private static string ImagePngFileExtension;
    private static string XamlRelationshipFromPackageToEntryPart;
    private static string XamlRelationshipFromXamlPartToComponentPart;
    private static string XamlPayloadDirectory;
    private static string XamlEntryName;
    private static string XamlImageName;
    private static int _wpfPayloadCount;
    private Package _package;
    private List`1<Image> _images;
    public Package Package { get; }
    private WpfPayload(Package package);
    internal static string SaveRange(ITextRange range, Stream& stream, bool useFlowDocumentAsRoot);
    internal static string SaveRange(ITextRange range, Stream& stream, bool useFlowDocumentAsRoot, bool preserveTextElements);
    internal static MemoryStream SaveImage(BitmapSource bitmapSource, string imageContentType);
    internal static object LoadElement(Stream stream);
    private PackagePart ValidatePayload();
    public Package get_Package();
    private BitmapSource GetBitmapSourceFromImage(Image image);
    private void CreateComponentParts(PackagePart sourcePart);
    private void CreateImagePart(PackagePart sourcePart, BitmapSource imageSource, string imageContentType, int imageIndex);
    internal string AddImage(Image image);
    private static string GetImageContentType(string imageUriString);
    private static BitmapEncoder GetBitmapEncoder(string imageContentType);
    private static string GetImageFileExtension(string imageContentType);
    private static bool ImagesAreIdentical(BitmapSource imageSource1, BitmapSource imageSource2);
    internal Stream CreateXamlStream();
    internal Stream CreateImageStream(int imageCount, string contentType, String& imagePartUriString);
    internal Stream GetImageStream(string imageSourceString);
    private Package CreatePackage(Stream stream);
    internal static WpfPayload CreateWpfPayload(Stream stream);
    internal static WpfPayload OpenWpfPayload(Stream stream);
    private PackagePart CreateWpfEntryPart();
    private PackagePart GetWpfEntryPart();
    private static string GetImageName(int imageIndex, string imageContentType);
    private static string GetImageReference(string imageName);
}
internal enum System.Windows.Documents.XamlAttribute : Enum {
    public int value__;
    public static XamlAttribute XAUnknown;
    public static XamlAttribute XAFontWeight;
    public static XamlAttribute XAFontSize;
    public static XamlAttribute XAFontStyle;
    public static XamlAttribute XAFontFamily;
    public static XamlAttribute XAFontStretch;
    public static XamlAttribute XABackground;
    public static XamlAttribute XAForeground;
    public static XamlAttribute XAFlowDirection;
    public static XamlAttribute XATextDecorations;
    public static XamlAttribute XATextAlignment;
    public static XamlAttribute XAMarkerStyle;
    public static XamlAttribute XATextIndent;
    public static XamlAttribute XAColumnSpan;
    public static XamlAttribute XARowSpan;
    public static XamlAttribute XAStartIndex;
    public static XamlAttribute XAMarkerOffset;
    public static XamlAttribute XABorderThickness;
    public static XamlAttribute XABorderBrush;
    public static XamlAttribute XAPadding;
    public static XamlAttribute XAMargin;
    public static XamlAttribute XAKeepTogether;
    public static XamlAttribute XAKeepWithNext;
    public static XamlAttribute XABaselineAlignment;
    public static XamlAttribute XABaselineOffset;
    public static XamlAttribute XANavigateUri;
    public static XamlAttribute XATargetName;
    public static XamlAttribute XALineHeight;
    public static XamlAttribute XALocation;
    public static XamlAttribute XAWidth;
    public static XamlAttribute XAHeight;
    public static XamlAttribute XASource;
    public static XamlAttribute XAUriSource;
    public static XamlAttribute XAStretch;
    public static XamlAttribute XAStretchDirection;
    public static XamlAttribute XACellSpacing;
    public static XamlAttribute XATypographyVariants;
    public static XamlAttribute XALang;
}
internal class System.Windows.Documents.XamlRtfConverter : object {
    internal static int RtfCodePage;
    private bool _forceParagraph;
    private WpfPayload _wpfPayload;
    internal bool ForceParagraph { get; internal set; }
    internal WpfPayload WpfPayload { get; internal set; }
    internal string ConvertXamlToRtf(string xamlContent);
    internal string ConvertRtfToXaml(string rtfContent);
    internal bool get_ForceParagraph();
    internal void set_ForceParagraph(bool value);
    internal WpfPayload get_WpfPayload();
    internal void set_WpfPayload(WpfPayload value);
}
internal enum System.Windows.Documents.XamlTokenType : Enum {
    public int value__;
    public static XamlTokenType XTokInvalid;
    public static XamlTokenType XTokEOF;
    public static XamlTokenType XTokCharacters;
    public static XamlTokenType XTokEntity;
    public static XamlTokenType XTokStartElement;
    public static XamlTokenType XTokEndElement;
    public static XamlTokenType XTokCData;
    public static XamlTokenType XTokPI;
    public static XamlTokenType XTokComment;
    public static XamlTokenType XTokWS;
}
internal enum System.Windows.Documents.XamlToRtfError : Enum {
    public int value__;
    public static XamlToRtfError None;
    public static XamlToRtfError InvalidFormat;
    public static XamlToRtfError InvalidParameter;
    public static XamlToRtfError InsufficientMemory;
    public static XamlToRtfError OutOfRange;
    public static XamlToRtfError Unknown;
}
internal class System.Windows.Documents.XamlToRtfParser : object {
    private string _xaml;
    private XamlLexer _xamlLexer;
    private XamlTagStack _xamlTagStack;
    private XamlAttributes _xamlAttributes;
    private IXamlContentHandler _xamlContent;
    private IXamlErrorHandler _xamlError;
    internal XamlToRtfParser(string xaml);
    internal XamlToRtfError Parse();
    internal void SetCallbacks(IXamlContentHandler xamlContent, IXamlErrorHandler xamlError);
    private XamlToRtfError ParseXTokStartElement(XamlToken xamlToken, String& name);
    private XamlToRtfError ParseXTokEndElement(XamlToken xamlToken, String& name);
}
internal class System.Windows.Documents.XamlToRtfWriter : object {
    private string _xaml;
    private StringBuilder _rtfBuilder;
    private ConverterState _converterState;
    private XamlIn _xamlIn;
    private WpfPayload _wpfPayload;
    private static int DefaultCellXAsTwips;
    internal string Output { get; }
    internal bool GenerateListTables { get; }
    unknown WpfPayload WpfPayload {internal set; }
    internal ConverterState ConverterState { get; }
    internal XamlToRtfWriter(string xaml);
    internal XamlToRtfError Process();
    internal string get_Output();
    internal bool get_GenerateListTables();
    internal void set_WpfPayload(WpfPayload value);
    internal ConverterState get_ConverterState();
    private void BuildListTable();
    private int BuildListStyles(ListLevelTable[] levels, ArrayList openLists);
    private void MergeParagraphMargins();
    private void GenerateListLabels();
    private void SetParagraphStructureProperties();
    private void WriteProlog();
    private void WriteHeaderTables();
    private void WriteFontTable();
    private void WriteColorTable();
    private void WriteListTable();
    private void WriteEmptyChild(DocumentNode documentNode);
    private void WriteInlineChild(DocumentNode documentNode);
    private void WriteUIContainerChild(DocumentNode documentNode);
    private void WriteSection(DocumentNode dnThis);
    private void WriteParagraph(DocumentNode dnThis);
    private bool WriteParagraphFontInfo(DocumentNode dnThis, FormatState fsThis, FormatState fsParent);
    private bool WriteParagraphListInfo(DocumentNode dnThis, FormatState fsThis);
    private void WriteRow(DocumentNode dnRow);
    private void WriteRowStart(DocumentNode dnRow);
    private void WriteRowSettings(DocumentNode dnRow);
    private void WriteRowBorders(DocumentNode dnRow);
    private void WriteRowDimensions(DocumentNode dnRow);
    private void WriteRowPadding(DocumentNode dnRow);
    private void WriteRowsCellProperties(DocumentNode dnRow);
    private void WriteRowsCellContents(DocumentNode dnRow);
    private long WriteCellProperties(DocumentNode dnCell, int nCol, long lastCellX);
    private void WriteCellVAlignment(DocumentNode dnCell);
    private void WriteCellBorders(DocumentNode dnCell);
    private void WriteCellPadding(DocumentNode dnCell);
    private void WriteCellColor(DocumentNode dnCell);
    private long WriteCellDimensions(DocumentNode dnCell, int nCol, long lastCellX);
    private long GetDefaultAllTablesWidthFromCell(DocumentNode dnCell);
    private long CalculateDefaultTableWidth(DocumentNode dnTable);
    private void WriteBorder(string borderControlWord, BorderFormat bf);
    private void PatchVerticallyMergedCells(DocumentNode dnThis);
    private void WriteStructure(DocumentNode dnThis);
    private void WriteDocumentContents();
    private void WriteEpilog();
    private void WriteOutput();
    private void WriteImage(DocumentNode documentNode);
    private void WriteShapeImage(DocumentNode documentNode, Stream imageStream, RtfImageFormat imageFormat);
    private string ConvertToImageHexDataString(Stream imageStream);
    private RtfImageFormat GetImageFormatFromImageSourceName(string imageName);
    private Stretch GetImageStretch(string imageStretch);
    private StretchDirection GetImageStretchDirection(string imageStretchDirection);
}
internal class System.Windows.Documents.XpsDocStructSchema : XpsSchema {
    private static ContentType _documentStructureContentType;
    private static ContentType _storyFragmentsContentType;
    private static string _xpsDocStructureSchemaNamespace;
    private static XmlReaderSettings _xmlReaderSettings;
    public string RootNamespaceUri { get; }
    private static Byte[] SchemaBytes { get; }
    private static XpsDocStructSchema();
    public virtual XmlReaderSettings GetXmlReaderSettings();
    public virtual bool IsValidRootNamespaceUri(string namespaceUri);
    public virtual string get_RootNamespaceUri();
    private static Byte[] get_SchemaBytes();
}
internal class System.Windows.Documents.XpsS0FixedPageSchema : XpsS0Schema {
    private static string _printTicketRel;
    private static string _discardControlRel;
    private static string _restrictedFontRel;
    private static string _thumbnailRel;
    public virtual void ValidateRelationships(SecurityCriticalData`1<Package> package, Uri packageUri, Uri partUri, ContentType mimeType);
}
internal class System.Windows.Documents.XpsS0ResourceDictionarySchema : XpsS0Schema {
    public virtual String[] ExtractUriFromAttr(string attrName, string attrValue);
}
internal class System.Windows.Documents.XpsS0Schema : XpsSchema {
    protected static ContentType _fontContentType;
    protected static ContentType _colorContextContentType;
    protected static ContentType _obfuscatedContentType;
    protected static ContentType _jpgContentType;
    protected static ContentType _pngContentType;
    protected static ContentType _tifContentType;
    protected static ContentType _wmpContentType;
    protected static ContentType _fixedDocumentSequenceContentType;
    protected static ContentType _fixedDocumentContentType;
    protected static ContentType _fixedPageContentType;
    protected static ContentType _resourceDictionaryContentType;
    protected static ContentType _printTicketContentType;
    protected static ContentType _discardControlContentType;
    private static string _xpsS0SchemaNamespace;
    private static string _contextColor;
    private static string _colorConvertedBitmap;
    private static XmlReaderSettings _xmlReaderSettings;
    public string RootNamespaceUri { get; }
    private static Byte[] S0SchemaBytes { get; }
    private static Byte[] DictionarySchemaBytes { get; }
    private static XpsS0Schema();
    public virtual XmlReaderSettings GetXmlReaderSettings();
    public virtual bool HasRequiredResources(ContentType mimeType);
    public virtual bool HasUriAttributes(ContentType mimeType);
    public virtual bool AllowsMultipleReferencesToSameUri(ContentType mimeType);
    public virtual bool IsValidRootNamespaceUri(string namespaceUri);
    public virtual string get_RootNamespaceUri();
    public virtual String[] ExtractUriFromAttr(string attrName, string attrValue);
    private static Byte[] get_S0SchemaBytes();
    private static Byte[] get_DictionarySchemaBytes();
}
internal class System.Windows.Documents.XpsSchema : object {
    private static Dictionary`2<ContentType, XpsSchema> _schemas;
    private Hashtable _requiredResourceMimeTypes;
    public string RootNamespaceUri { get; }
    private static XpsSchema();
    protected static void RegisterSchema(XpsSchema schema, ContentType[] handledMimeTypes);
    protected void RegisterRequiredResourceMimeTypes(ContentType[] requiredResourceMimeTypes);
    public virtual XmlReaderSettings GetXmlReaderSettings();
    public virtual void ValidateRelationships(SecurityCriticalData`1<Package> package, Uri packageUri, Uri partUri, ContentType mimeType);
    public virtual bool HasRequiredResources(ContentType mimeType);
    public virtual bool HasUriAttributes(ContentType mimeType);
    public virtual bool AllowsMultipleReferencesToSameUri(ContentType mimeType);
    public virtual bool IsValidRootNamespaceUri(string namespaceUri);
    public virtual string get_RootNamespaceUri();
    public bool IsValidRequiredResourceMimeType(ContentType mimeType);
    public virtual String[] ExtractUriFromAttr(string attrName, string attrValue);
    public static XpsSchema GetSchema(ContentType mimeType);
}
internal class System.Windows.Documents.XpsSchemaValidator : object {
    private XmlReader _compatReader;
    private static String[] _predefinedNamespaces;
    public XmlReader XmlReader { get; }
    public XpsSchemaValidator(XpsValidatingLoader loader, XpsSchema schema, ContentType mimeType, Stream objectStream, Uri packageUri, Uri baseUri);
    private static XpsSchemaValidator();
    public XmlReader get_XmlReader();
}
internal class System.Windows.Documents.XpsValidatingLoader : object {
    private static Stack`1<Hashtable> _validResources;
    private Hashtable _uniqueUriRef;
    private static bool _documentMode;
    private static string _requiredResourceRel;
    private static XpsS0FixedPageSchema xpsS0FixedPageSchema;
    private static XpsS0ResourceDictionarySchema xpsS0ResourceDictionarySchema;
    private static XpsDocStructSchema xpsDocStructSchema;
    internal static bool DocumentMode { get; }
    private static XpsValidatingLoader();
    internal object Load(Stream stream, Uri parentUri, ParserContext pc, ContentType mimeType);
    internal void Validate(Stream stream, Uri parentUri, ParserContext pc, ContentType mimeType, string rootElement);
    private object Load(Stream stream, Uri parentUri, ParserContext pc, ContentType mimeType, string rootElement);
    internal static bool get_DocumentMode();
    internal static void AssertDocumentMode();
    internal void UriHitHandler(int node, Uri uri);
}
public class System.Windows.Documents.ZoomPercentageConverter : object {
    internal static string ZoomPercentageConverterStringFormat;
    public sealed virtual object Convert(object value, Type targetType, object parameter, CultureInfo culture);
    public sealed virtual object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture);
}
[TypeConverterAttribute("System.Windows.DynamicResourceExtensionConverter")]
[MarkupExtensionReturnTypeAttribute("System.Object")]
public class System.Windows.DynamicResourceExtension : MarkupExtension {
    private object _resourceKey;
    [ConstructorArgumentAttribute("resourceKey")]
public object ResourceKey { get; public set; }
    public DynamicResourceExtension(object resourceKey);
    public virtual object ProvideValue(IServiceProvider serviceProvider);
    public object get_ResourceKey();
    public void set_ResourceKey(object value);
}
public class System.Windows.DynamicResourceExtensionConverter : TypeConverter {
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
public class System.Windows.EventSetter : SetterBase {
    private RoutedEvent _event;
    private Delegate _handler;
    private bool _handledEventsToo;
    public RoutedEvent Event { get; public set; }
    [TypeConverterAttribute("System.Windows.Markup.EventSetterHandlerConverter")]
public Delegate Handler { get; public set; }
    [EditorBrowsableAttribute("1")]
public bool HandledEventsToo { get; public set; }
    public EventSetter(RoutedEvent routedEvent, Delegate handler);
    public RoutedEvent get_Event();
    public void set_Event(RoutedEvent value);
    public Delegate get_Handler();
    public void set_Handler(Delegate value);
    public bool get_HandledEventsToo();
    public void set_HandledEventsToo(bool value);
    internal virtual void Seal();
}
[ContentPropertyAttribute("Actions")]
public class System.Windows.EventTrigger : TriggerBase {
    private RoutedEvent _routedEvent;
    private string _sourceName;
    private int _childId;
    private TriggerActionCollection _actions;
    internal static UncommonField`1<TriggerCollection> TriggerCollectionField;
    private RoutedEventHandler _routedEventHandler;
    private FrameworkElement _source;
    public RoutedEvent RoutedEvent { get; public set; }
    [DefaultValueAttribute("")]
public string SourceName { get; public set; }
    internal int TriggerChildIndex { get; internal set; }
    [DesignerSerializationVisibilityAttribute("2")]
public TriggerActionCollection Actions { get; }
    public EventTrigger(RoutedEvent routedEvent);
    private static EventTrigger();
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object value);
    protected virtual void AddChild(object value);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string text);
    protected virtual void AddText(string text);
    public RoutedEvent get_RoutedEvent();
    public void set_RoutedEvent(RoutedEvent value);
    public string get_SourceName();
    public void set_SourceName(string value);
    internal int get_TriggerChildIndex();
    internal void set_TriggerChildIndex(int value);
    public TriggerActionCollection get_Actions();
    internal virtual void OnInheritanceContextChangedCore(EventArgs args);
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeActions();
    internal sealed virtual void Seal();
    internal static void ProcessTriggerCollection(FrameworkElement triggersHost);
    internal static void ProcessOneTrigger(FrameworkElement triggersHost, TriggerBase triggerBase);
    internal static void DisconnectAllTriggers(FrameworkElement triggersHost);
    internal static void DisconnectOneTrigger(FrameworkElement triggersHost, TriggerBase triggerBase);
}
public class System.Windows.ExceptionRoutedEventArgs : RoutedEventArgs {
    private Exception _errorException;
    public Exception ErrorException { get; }
    internal ExceptionRoutedEventArgs(RoutedEvent routedEvent, object sender, Exception errorException);
    public Exception get_ErrorException();
}
public class System.Windows.ExitEventArgs : EventArgs {
    internal int _exitCode;
    public int ApplicationExitCode { get; public set; }
    internal ExitEventArgs(int exitCode);
    public int get_ApplicationExitCode();
    public void set_ApplicationExitCode(int value);
}
public class System.Windows.ExitEventHandler : MulticastDelegate {
    public ExitEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, ExitEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, ExitEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public enum System.Windows.FigureHorizontalAnchor : Enum {
    public int value__;
    public static FigureHorizontalAnchor PageLeft;
    public static FigureHorizontalAnchor PageCenter;
    public static FigureHorizontalAnchor PageRight;
    public static FigureHorizontalAnchor ContentLeft;
    public static FigureHorizontalAnchor ContentCenter;
    public static FigureHorizontalAnchor ContentRight;
    public static FigureHorizontalAnchor ColumnLeft;
    public static FigureHorizontalAnchor ColumnCenter;
    public static FigureHorizontalAnchor ColumnRight;
}
[TypeConverterAttribute("System.Windows.FigureLengthConverter")]
public class System.Windows.FigureLength : ValueType {
    private double _unitValue;
    private FigureUnitType _unitType;
    public bool IsAbsolute { get; }
    public bool IsAuto { get; }
    public bool IsColumn { get; }
    public bool IsContent { get; }
    public bool IsPage { get; }
    public double Value { get; }
    public FigureUnitType FigureUnitType { get; }
    public FigureLength(double pixels);
    public FigureLength(double value, FigureUnitType type);
    public static bool op_Equality(FigureLength fl1, FigureLength fl2);
    public static bool op_Inequality(FigureLength fl1, FigureLength fl2);
    public virtual bool Equals(object oCompare);
    public sealed virtual bool Equals(FigureLength figureLength);
    public virtual int GetHashCode();
    public bool get_IsAbsolute();
    public bool get_IsAuto();
    public bool get_IsColumn();
    public bool get_IsContent();
    public bool get_IsPage();
    public double get_Value();
    public FigureUnitType get_FigureUnitType();
    public virtual string ToString();
}
public class System.Windows.FigureLengthConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext typeDescriptorContext, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext typeDescriptorContext, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext typeDescriptorContext, CultureInfo cultureInfo, object source);
    public virtual object ConvertTo(ITypeDescriptorContext typeDescriptorContext, CultureInfo cultureInfo, object value, Type destinationType);
    internal static string ToString(FigureLength fl, CultureInfo cultureInfo);
    internal static FigureLength FromString(string s, CultureInfo cultureInfo);
}
public enum System.Windows.FigureUnitType : Enum {
    public int value__;
    public static FigureUnitType Auto;
    public static FigureUnitType Pixel;
    public static FigureUnitType Column;
    public static FigureUnitType Content;
    public static FigureUnitType Page;
}
public enum System.Windows.FigureVerticalAnchor : Enum {
    public int value__;
    public static FigureVerticalAnchor PageTop;
    public static FigureVerticalAnchor PageCenter;
    public static FigureVerticalAnchor PageBottom;
    public static FigureVerticalAnchor ContentTop;
    public static FigureVerticalAnchor ContentCenter;
    public static FigureVerticalAnchor ContentBottom;
    public static FigureVerticalAnchor ParagraphTop;
}
public class System.Windows.FontSizeConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
    internal static void FromString(string text, CultureInfo culture, Double& amount);
}
public static class System.Windows.FrameworkCompatibilityPreferences : object {
    private static bool _targetsDesktop_V4_0;
    private static bool _areInactiveSelectionHighlightBrushKeysSupported;
    private static bool _keepTextBoxDisplaySynchronizedWithTextProperty;
    private static bool _useSetWindowPosForTopmostWindows;
    private static bool _vsp45Compat;
    private static string _scrollingTraceTarget;
    private static string _scrollingTraceFile;
    private static bool _shouldThrowOnCopyOrCutFailure;
    private static string _IMECompositionTraceTarget;
    private static string _IMECompositionTraceFile;
    private static bool _isSealed;
    private static object _lockObject;
    internal static bool TargetsDesktop_V4_0 { get; }
    public static bool AreInactiveSelectionHighlightBrushKeysSupported { get; public set; }
    public static bool KeepTextBoxDisplaySynchronizedWithTextProperty { get; public set; }
    internal static bool UseSetWindowPosForTopmostWindows { get; internal set; }
    internal static bool VSP45Compat { get; internal set; }
    public static bool ShouldThrowOnCopyOrCutFailure { get; public set; }
    private static FrameworkCompatibilityPreferences();
    internal static bool get_TargetsDesktop_V4_0();
    public static bool get_AreInactiveSelectionHighlightBrushKeysSupported();
    public static void set_AreInactiveSelectionHighlightBrushKeysSupported(bool value);
    internal static bool GetAreInactiveSelectionHighlightBrushKeysSupported();
    public static bool get_KeepTextBoxDisplaySynchronizedWithTextProperty();
    public static void set_KeepTextBoxDisplaySynchronizedWithTextProperty(bool value);
    internal static bool GetKeepTextBoxDisplaySynchronizedWithTextProperty();
    internal static bool get_UseSetWindowPosForTopmostWindows();
    internal static void set_UseSetWindowPosForTopmostWindows(bool value);
    internal static bool GetUseSetWindowPosForTopmostWindows();
    private static void SetUseSetWindowPosForTopmostWindowsFromAppSettings(NameValueCollection appSettings);
    internal static bool get_VSP45Compat();
    internal static void set_VSP45Compat(bool value);
    internal static bool GetVSP45Compat();
    private static void SetVSP45CompatFromAppSettings(NameValueCollection appSettings);
    internal static string GetScrollingTraceTarget();
    internal static string GetScrollingTraceFile();
    private static void SetScrollingTraceFromAppSettings(NameValueCollection appSettings);
    public static bool get_ShouldThrowOnCopyOrCutFailure();
    public static void set_ShouldThrowOnCopyOrCutFailure(bool value);
    internal static bool GetShouldThrowOnCopyOrCutFailure();
    private static void SetShouldThrowOnCopyOrCutFailuresFromAppSettings(NameValueCollection appSettings);
    internal static string GetIMECompositionTraceTarget();
    internal static string GetIMECompositionTraceFile();
    private static void SetIMECompositionTraceFromAppSettings(NameValueCollection appSettings);
    private static void Seal();
}
[StyleTypedPropertyAttribute]
[XmlLangPropertyAttribute("Language")]
[UsableDuringInitializationAttribute("True")]
[RuntimeNamePropertyAttribute("Name")]
public class System.Windows.FrameworkContentElement : ContentElement {
    internal static NumberSubstitution DefaultNumberSubstitution;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty StyleProperty;
    public static DependencyProperty OverridesDefaultStyleProperty;
    protected internal static DependencyProperty DefaultStyleKeyProperty;
    public static DependencyProperty NameProperty;
    public static DependencyProperty TagProperty;
    public static DependencyProperty LanguageProperty;
    public static DependencyProperty FocusVisualStyleProperty;
    public static DependencyProperty CursorProperty;
    public static DependencyProperty ForceCursorProperty;
    public static DependencyProperty InputScopeProperty;
    public static DependencyProperty DataContextProperty;
    public static DependencyProperty BindingGroupProperty;
    private static DependencyProperty LoadedPendingProperty;
    private static DependencyProperty UnloadedPendingProperty;
    public static RoutedEvent LoadedEvent;
    public static RoutedEvent UnloadedEvent;
    public static DependencyProperty ToolTipProperty;
    public static DependencyProperty ContextMenuProperty;
    public static RoutedEvent ToolTipOpeningEvent;
    public static RoutedEvent ToolTipClosingEvent;
    public static RoutedEvent ContextMenuOpeningEvent;
    public static RoutedEvent ContextMenuClosingEvent;
    private Style _styleCache;
    private Style _themeStyleCache;
    internal DependencyObject _templatedParent;
    private static UncommonField`1<ResourceDictionary> ResourcesField;
    private InternalFlags _flags;
    private InternalFlags2 _flags2;
    internal static DependencyObjectType DType;
    private DependencyObject _parent;
    private FrugalObjectList`1<DependencyProperty> _inheritableProperties;
    private static UncommonField`1<DependencyObject> InheritanceContextField;
    private static UncommonField`1<DependencyObject> MentorField;
    public Style Style { get; public set; }
    public bool OverridesDefaultStyle { get; public set; }
    protected internal object DefaultStyleKey { get; protected internal set; }
    internal Style ThemeStyle { get; }
    internal DependencyObjectType DTypeThemeStyleKey { get; }
    public DependencyObject TemplatedParent { get; }
    internal bool HasResources { get; }
    [AmbientAttribute]
public ResourceDictionary Resources { get; public set; }
    [MergablePropertyAttribute("False")]
[LocalizabilityAttribute("17")]
public string Name { get; public set; }
    public object Tag { get; public set; }
    public XmlLanguage Language { get; public set; }
    public Style FocusVisualStyle { get; public set; }
    public Cursor Cursor { get; public set; }
    public bool ForceCursor { get; public set; }
    public InputScope InputScope { get; public set; }
    [DesignerSerializationVisibilityAttribute("0")]
[LocalizabilityAttribute("17")]
public object DataContext { get; public set; }
    [DesignerSerializationVisibilityAttribute("0")]
[LocalizabilityAttribute("17")]
public BindingGroup BindingGroup { get; public set; }
    internal InheritanceBehavior InheritanceBehavior { get; internal set; }
    [EditorBrowsableAttribute("2")]
public bool IsInitialized { get; }
    public bool IsLoaded { get; }
    [BindableAttribute("True")]
[CategoryAttribute("Appearance")]
public object ToolTip { get; public set; }
    public ContextMenu ContextMenu { get; public set; }
    internal bool HasResourceReference { get; internal set; }
    internal bool IsLogicalChildrenIterationInProgress { get; internal set; }
    internal bool SubtreeHasLoadedChangeHandler { get; internal set; }
    internal bool IsLoadedCache { get; internal set; }
    internal bool IsParentAnFE { get; internal set; }
    internal bool IsTemplatedParentAnFE { get; internal set; }
    internal bool HasLogicalChildren { get; internal set; }
    internal int TemplateChildIndex { get; internal set; }
    internal bool IsRequestingExpression { get; internal set; }
    public DependencyObject Parent { get; }
    protected internal IEnumerator LogicalChildren { get; }
    internal bool ThisHasLoadedChangeEventHandler { get; }
    internal bool HasFefLoadedChangeHandler { get; }
    internal DependencyObject InheritanceContext { get; }
    internal bool IsStyleUpdateInProgress { get; internal set; }
    internal bool IsThemeStyleUpdateInProgress { get; internal set; }
    internal bool StoresParentTemplateValues { get; internal set; }
    internal bool HasNumberSubstitutionChanged { get; internal set; }
    internal bool HasTemplateGeneratedSubTree { get; internal set; }
    internal bool HasImplicitStyleFromResources { get; internal set; }
    internal bool ShouldLookupImplicitStyles { get; internal set; }
    internal bool IsStyleSetFromGenerator { get; internal set; }
    internal bool HasStyleChanged { get; internal set; }
    internal bool HasStyleInvalidated { get; internal set; }
    internal bool HasStyleEverBeenFetched { get; internal set; }
    internal bool HasLocalStyle { get; internal set; }
    internal bool HasThemeStyleEverBeenFetched { get; internal set; }
    internal bool AncestorChangeInProgress { get; internal set; }
    internal FrugalObjectList`1<DependencyProperty> InheritableProperties { get; internal set; }
    internal Object[] LoadedPending { get; }
    internal Object[] UnloadedPending { get; }
    internal bool HasMultipleInheritanceContexts { get; }
    internal bool PotentiallyHasMentees { get; internal set; }
    private static FrameworkContentElement();
    private static void NumberSubstitutionChanged(DependencyObject o, DependencyPropertyChangedEventArgs e);
    public Style get_Style();
    public void set_Style(Style value);
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeStyle();
    private static void OnStyleChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    protected internal virtual void OnStyleChanged(Style oldStyle, Style newStyle);
    public bool get_OverridesDefaultStyle();
    public void set_OverridesDefaultStyle(bool value);
    protected internal object get_DefaultStyleKey();
    protected internal void set_DefaultStyleKey(object value);
    private static void OnThemeStyleKeyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    internal Style get_ThemeStyle();
    internal virtual DependencyObjectType get_DTypeThemeStyleKey();
    internal static void OnThemeStyleChanged(DependencyObject d, object oldValue, object newValue);
    public DependencyObject get_TemplatedParent();
    internal bool get_HasResources();
    public ResourceDictionary get_Resources();
    public void set_Resources(ResourceDictionary value);
    private sealed virtual override bool System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(string propertyName);
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeResources();
    public object FindResource(object resourceKey);
    public object TryFindResource(object resourceKey);
    public void SetResourceReference(DependencyProperty dp, object name);
    public void BeginStoryboard(Storyboard storyboard);
    public void BeginStoryboard(Storyboard storyboard, HandoffBehavior handoffBehavior);
    public void BeginStoryboard(Storyboard storyboard, HandoffBehavior handoffBehavior, bool isControllable);
    internal sealed virtual void EvaluateBaseValueCore(DependencyProperty dp, PropertyMetadata metadata, EffectiveValueEntry& newEntry);
    internal void GetRawValue(DependencyProperty dp, PropertyMetadata metadata, EffectiveValueEntry& entry);
    private bool GetValueFromTemplatedParent(DependencyProperty dp, EffectiveValueEntry& entry);
    internal Expression GetExpressionCore(DependencyProperty dp, PropertyMetadata metadata);
    protected virtual void OnPropertyChanged(DependencyPropertyChangedEventArgs e);
    public sealed virtual string get_Name();
    public sealed virtual void set_Name(string value);
    public object get_Tag();
    public void set_Tag(object value);
    public XmlLanguage get_Language();
    public void set_Language(XmlLanguage value);
    public Style get_FocusVisualStyle();
    public void set_FocusVisualStyle(Style value);
    public Cursor get_Cursor();
    public void set_Cursor(Cursor value);
    private static void OnCursorChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public bool get_ForceCursor();
    public void set_ForceCursor(bool value);
    private static void OnForceCursorChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void OnQueryCursor(object sender, QueryCursorEventArgs e);
    public sealed virtual bool MoveFocus(TraversalRequest request);
    public sealed virtual DependencyObject PredictFocus(FocusNavigationDirection direction);
    protected virtual void OnGotFocus(RoutedEventArgs e);
    private static void OnGotKeyboardFocus(object sender, KeyboardFocusChangedEventArgs e);
    private static void OnLostKeyboardFocus(object sender, KeyboardFocusChangedEventArgs e);
    public void BringIntoView();
    public InputScope get_InputScope();
    public void set_InputScope(InputScope value);
    public void add_TargetUpdated(EventHandler`1<DataTransferEventArgs> value);
    public void remove_TargetUpdated(EventHandler`1<DataTransferEventArgs> value);
    public void add_SourceUpdated(EventHandler`1<DataTransferEventArgs> value);
    public void remove_SourceUpdated(EventHandler`1<DataTransferEventArgs> value);
    public void add_DataContextChanged(DependencyPropertyChangedEventHandler value);
    public void remove_DataContextChanged(DependencyPropertyChangedEventHandler value);
    public object get_DataContext();
    public void set_DataContext(object value);
    private static void OnDataContextChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public BindingExpression GetBindingExpression(DependencyProperty dp);
    public BindingExpressionBase SetBinding(DependencyProperty dp, BindingBase binding);
    public BindingExpression SetBinding(DependencyProperty dp, string path);
    public BindingGroup get_BindingGroup();
    public void set_BindingGroup(BindingGroup value);
    protected internal virtual DependencyObject GetUIParentCore();
    internal virtual object AdjustEventSource(RoutedEventArgs args);
    internal virtual void AdjustBranchSource(RoutedEventArgs args);
    internal virtual bool IgnoreModelParentBuildRoute(RoutedEventArgs args);
    internal sealed virtual bool BuildRouteCore(EventRoute route, RoutedEventArgs args);
    internal virtual void AddToEventRouteCore(EventRoute route, RoutedEventArgs args);
    private bool IsLogicalDescendent(DependencyObject child);
    internal virtual bool InvalidateAutomationAncestorsCore(Stack`1<DependencyObject> branchNodeStack, Boolean& continuePastCoreTree);
    internal virtual void OnAncestorChanged();
    internal virtual void OnContentParentChanged(DependencyObject oldParent);
    internal InheritanceBehavior get_InheritanceBehavior();
    internal void set_InheritanceBehavior(InheritanceBehavior value);
    public virtual void BeginInit();
    public virtual void EndInit();
    public bool get_IsInitialized();
    public void add_Initialized(EventHandler value);
    public void remove_Initialized(EventHandler value);
    protected virtual void OnInitialized(EventArgs e);
    private void TryFireInitialized();
    private void RaiseInitialized(EventPrivateKey key, EventArgs e);
    public bool get_IsLoaded();
    public void add_Loaded(RoutedEventHandler value);
    public void remove_Loaded(RoutedEventHandler value);
    internal void OnLoaded(RoutedEventArgs args);
    public void add_Unloaded(RoutedEventHandler value);
    public void remove_Unloaded(RoutedEventHandler value);
    internal void OnUnloaded(RoutedEventArgs args);
    internal virtual void OnAddHandler(RoutedEvent routedEvent, Delegate handler);
    internal virtual void OnRemoveHandler(RoutedEvent routedEvent, Delegate handler);
    internal void RaiseClrEvent(EventPrivateKey key, EventArgs args);
    public object get_ToolTip();
    public void set_ToolTip(object value);
    public ContextMenu get_ContextMenu();
    public void set_ContextMenu(ContextMenu value);
    public void add_ToolTipOpening(ToolTipEventHandler value);
    public void remove_ToolTipOpening(ToolTipEventHandler value);
    private static void OnToolTipOpeningThunk(object sender, ToolTipEventArgs e);
    protected virtual void OnToolTipOpening(ToolTipEventArgs e);
    public void add_ToolTipClosing(ToolTipEventHandler value);
    public void remove_ToolTipClosing(ToolTipEventHandler value);
    private static void OnToolTipClosingThunk(object sender, ToolTipEventArgs e);
    protected virtual void OnToolTipClosing(ToolTipEventArgs e);
    public void add_ContextMenuOpening(ContextMenuEventHandler value);
    public void remove_ContextMenuOpening(ContextMenuEventHandler value);
    private static void OnContextMenuOpeningThunk(object sender, ContextMenuEventArgs e);
    protected virtual void OnContextMenuOpening(ContextMenuEventArgs e);
    public void add_ContextMenuClosing(ContextMenuEventHandler value);
    public void remove_ContextMenuClosing(ContextMenuEventHandler value);
    private static void OnContextMenuClosingThunk(object sender, ContextMenuEventArgs e);
    protected virtual void OnContextMenuClosing(ContextMenuEventArgs e);
    internal virtual void InvalidateForceInheritPropertyOnChildren(DependencyProperty property);
    private void RaiseDependencyPropertyChanged(EventPrivateKey key, DependencyPropertyChangedEventArgs args);
    private void EventHandlersStoreAdd(EventPrivateKey key, Delegate handler);
    private void EventHandlersStoreRemove(EventPrivateKey key, Delegate handler);
    internal bool get_HasResourceReference();
    internal void set_HasResourceReference(bool value);
    internal bool get_IsLogicalChildrenIterationInProgress();
    internal void set_IsLogicalChildrenIterationInProgress(bool value);
    internal bool get_SubtreeHasLoadedChangeHandler();
    internal void set_SubtreeHasLoadedChangeHandler(bool value);
    internal bool get_IsLoadedCache();
    internal void set_IsLoadedCache(bool value);
    internal bool get_IsParentAnFE();
    internal void set_IsParentAnFE(bool value);
    internal bool get_IsTemplatedParentAnFE();
    internal void set_IsTemplatedParentAnFE(bool value);
    internal bool get_HasLogicalChildren();
    internal void set_HasLogicalChildren(bool value);
    internal int get_TemplateChildIndex();
    internal void set_TemplateChildIndex(int value);
    internal bool get_IsRequestingExpression();
    internal void set_IsRequestingExpression(bool value);
    internal bool ReadInternalFlag(InternalFlags reqFlag);
    internal bool ReadInternalFlag2(InternalFlags2 reqFlag);
    internal void WriteInternalFlag(InternalFlags reqFlag, bool set);
    internal void WriteInternalFlag2(InternalFlags2 reqFlag, bool set);
    public DependencyObject get_Parent();
    public void RegisterName(string name, object scopedElement);
    public void UnregisterName(string name);
    public object FindName(string name);
    internal object FindName(string name, DependencyObject& scopeOwner);
    public void UpdateDefaultStyle();
    protected internal virtual IEnumerator get_LogicalChildren();
    internal object FindResourceOnSelf(object resourceKey, bool allowDeferredResourceReference, bool mustReturnDeferredResourceReference);
    internal DependencyObject ContextVerifiedGetParent();
    protected internal void AddLogicalChild(object child);
    protected internal void RemoveLogicalChild(object child);
    internal void ChangeLogicalParent(DependencyObject newParent);
    internal virtual void OnNewParent(DependencyObject newParent);
    internal void OnAncestorChangedInternal(TreeChangeInfo parentTreeState);
    internal FrugalObjectList`1<DependencyProperty> InvalidateTreeDependentProperties(TreeChangeInfo parentTreeState, bool isSelfInheritanceParent, bool wasSelfInheritanceParent);
    internal bool get_ThisHasLoadedChangeEventHandler();
    internal bool get_HasFefLoadedChangeHandler();
    internal void UpdateStyleProperty();
    internal void UpdateThemeStyleProperty();
    internal virtual void OnThemeChanged();
    internal void FireLoadedOnDescendentsInternal();
    internal void FireUnloadedOnDescendentsInternal();
    internal virtual bool ShouldProvideInheritanceContext(DependencyObject target, DependencyProperty property);
    internal virtual DependencyObject get_InheritanceContext();
    internal virtual void AddInheritanceContext(DependencyObject context, DependencyProperty property);
    internal virtual void RemoveInheritanceContext(DependencyObject context, DependencyProperty property);
    private void ClearInheritanceContext();
    internal virtual void OnInheritanceContextChangedCore(EventArgs args);
    private void ConnectMentor(DependencyObject mentor);
    private void DisconnectMentor(DependencyObject mentor);
    internal void ChangeSubtreeHasLoadedChangedHandler(DependencyObject mentor);
    private void OnMentorLoaded(object sender, RoutedEventArgs e);
    private void OnMentorUnloaded(object sender, RoutedEventArgs e);
    private void ConnectLoadedEvents(FrameworkObject& foMentor, bool isLoaded);
    private void DisconnectLoadedEvents(FrameworkObject& foMentor, bool isLoaded);
    private void OnMentorInheritedPropertyChanged(object sender, InheritedPropertyChangedEventArgs e);
    private void OnMentorResourcesChanged(object sender, EventArgs e);
    internal void RaiseInheritedPropertyChangedEvent(InheritablePropertyChangeInfo& info);
    internal bool get_IsStyleUpdateInProgress();
    internal void set_IsStyleUpdateInProgress(bool value);
    internal bool get_IsThemeStyleUpdateInProgress();
    internal void set_IsThemeStyleUpdateInProgress(bool value);
    internal bool get_StoresParentTemplateValues();
    internal void set_StoresParentTemplateValues(bool value);
    internal bool get_HasNumberSubstitutionChanged();
    internal void set_HasNumberSubstitutionChanged(bool value);
    internal bool get_HasTemplateGeneratedSubTree();
    internal void set_HasTemplateGeneratedSubTree(bool value);
    internal bool get_HasImplicitStyleFromResources();
    internal void set_HasImplicitStyleFromResources(bool value);
    internal bool get_ShouldLookupImplicitStyles();
    internal void set_ShouldLookupImplicitStyles(bool value);
    internal bool get_IsStyleSetFromGenerator();
    internal void set_IsStyleSetFromGenerator(bool value);
    internal bool get_HasStyleChanged();
    internal void set_HasStyleChanged(bool value);
    internal bool get_HasStyleInvalidated();
    internal void set_HasStyleInvalidated(bool value);
    internal bool get_HasStyleEverBeenFetched();
    internal void set_HasStyleEverBeenFetched(bool value);
    internal bool get_HasLocalStyle();
    internal void set_HasLocalStyle(bool value);
    internal bool get_HasThemeStyleEverBeenFetched();
    internal void set_HasThemeStyleEverBeenFetched(bool value);
    internal bool get_AncestorChangeInProgress();
    internal void set_AncestorChangeInProgress(bool value);
    internal FrugalObjectList`1<DependencyProperty> get_InheritableProperties();
    internal void set_InheritableProperties(FrugalObjectList`1<DependencyProperty> value);
    internal Object[] get_LoadedPending();
    internal Object[] get_UnloadedPending();
    internal virtual bool get_HasMultipleInheritanceContexts();
    internal bool get_PotentiallyHasMentees();
    internal void set_PotentiallyHasMentees(bool value);
    internal void add_ResourcesChanged(EventHandler value);
    internal void remove_ResourcesChanged(EventHandler value);
    internal void add_InheritedPropertyChanged(InheritedPropertyChangedEventHandler value);
    internal void remove_InheritedPropertyChanged(InheritedPropertyChangedEventHandler value);
}
internal class System.Windows.FrameworkContextData : object {
    private List`1<WalkerEntry> _currentWalkers;
    public static FrameworkContextData From(Dispatcher context);
    public void AddWalker(object data, DescendentsWalkerBase walker);
    public void RemoveWalker(object data, DescendentsWalkerBase walker);
    public bool WasNodeVisited(DependencyObject d, object data);
}
[StyleTypedPropertyAttribute]
[XmlLangPropertyAttribute("Language")]
[UsableDuringInitializationAttribute("True")]
[RuntimeNamePropertyAttribute("Name")]
public class System.Windows.FrameworkElement : UIElement {
    private static Type _typeofThis;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty StyleProperty;
    public static DependencyProperty OverridesDefaultStyleProperty;
    public static DependencyProperty UseLayoutRoundingProperty;
    protected internal static DependencyProperty DefaultStyleKeyProperty;
    internal static NumberSubstitution DefaultNumberSubstitution;
    public static DependencyProperty DataContextProperty;
    internal static EventPrivateKey DataContextChangedKey;
    public static DependencyProperty BindingGroupProperty;
    public static DependencyProperty LanguageProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty NameProperty;
    public static DependencyProperty TagProperty;
    public static DependencyProperty InputScopeProperty;
    public static RoutedEvent RequestBringIntoViewEvent;
    public static RoutedEvent SizeChangedEvent;
    private static PropertyMetadata _actualWidthMetadata;
    private static DependencyPropertyKey ActualWidthPropertyKey;
    public static DependencyProperty ActualWidthProperty;
    private static PropertyMetadata _actualHeightMetadata;
    private static DependencyPropertyKey ActualHeightPropertyKey;
    public static DependencyProperty ActualHeightProperty;
    public static DependencyProperty LayoutTransformProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty WidthProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty MinWidthProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty MaxWidthProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty HeightProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty MinHeightProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty MaxHeightProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty FlowDirectionProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty MarginProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty HorizontalAlignmentProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty VerticalAlignmentProperty;
    private static Style _defaultFocusVisualStyle;
    public static DependencyProperty FocusVisualStyleProperty;
    public static DependencyProperty CursorProperty;
    public static DependencyProperty ForceCursorProperty;
    internal static EventPrivateKey InitializedKey;
    internal static DependencyPropertyKey LoadedPendingPropertyKey;
    internal static DependencyProperty LoadedPendingProperty;
    internal static DependencyPropertyKey UnloadedPendingPropertyKey;
    internal static DependencyProperty UnloadedPendingProperty;
    public static RoutedEvent LoadedEvent;
    public static RoutedEvent UnloadedEvent;
    public static DependencyProperty ToolTipProperty;
    public static DependencyProperty ContextMenuProperty;
    public static RoutedEvent ToolTipOpeningEvent;
    public static RoutedEvent ToolTipClosingEvent;
    public static RoutedEvent ContextMenuOpeningEvent;
    public static RoutedEvent ContextMenuClosingEvent;
    private Style _themeStyleCache;
    private static UncommonField`1<SizeBox> UnclippedDesiredSizeField;
    private static UncommonField`1<LayoutTransformData> LayoutTransformDataField;
    private Style _styleCache;
    internal static UncommonField`1<ResourceDictionary> ResourcesField;
    internal DependencyObject _templatedParent;
    private UIElement _templateChild;
    private InternalFlags _flags;
    private InternalFlags2 _flags2;
    internal static DependencyObjectType UIElementDType;
    private static DependencyObjectType _controlDType;
    private static DependencyObjectType _contentPresenterDType;
    private static DependencyObjectType _pageFunctionBaseDType;
    private static DependencyObjectType _pageDType;
    [ThreadStaticAttribute]
private static FrameworkServices _frameworkServices;
    internal static EventPrivateKey ResourcesChangedKey;
    internal static EventPrivateKey InheritedPropertyChangedKey;
    internal static DependencyObjectType DType;
    private DependencyObject _parent;
    private FrugalObjectList`1<DependencyProperty> _inheritableProperties;
    private static UncommonField`1<DependencyObject> InheritanceContextField;
    private static UncommonField`1<DependencyObject> MentorField;
    public Style Style { get; public set; }
    public bool OverridesDefaultStyle { get; public set; }
    public bool UseLayoutRounding { get; public set; }
    protected internal object DefaultStyleKey { get; protected internal set; }
    internal Style ThemeStyle { get; }
    internal DependencyObjectType DTypeThemeStyleKey { get; }
    internal FrameworkTemplate TemplateInternal { get; }
    internal FrameworkTemplate TemplateCache { get; internal set; }
    [DesignerSerializationVisibilityAttribute("2")]
public TriggerCollection Triggers { get; }
    public DependencyObject TemplatedParent { get; }
    internal bool IsTemplateRoot { get; }
    internal UIElement TemplateChild { get; internal set; }
    internal FrameworkElement StateGroupsRoot { get; }
    protected int VisualChildrenCount { get; }
    internal bool HasResources { get; }
    [AmbientAttribute]
public ResourceDictionary Resources { get; public set; }
    private ResourceDictionary System.Windows.Markup.IHaveResources.Resources { get; private set; }
    protected internal InheritanceBehavior InheritanceBehavior { get; protected internal set; }
    [LocalizabilityAttribute("17")]
[DesignerSerializationVisibilityAttribute("0")]
public object DataContext { get; public set; }
    [LocalizabilityAttribute("17")]
[DesignerSerializationVisibilityAttribute("0")]
public BindingGroup BindingGroup { get; public set; }
    public XmlLanguage Language { get; public set; }
    [LocalizabilityAttribute("17")]
[MergablePropertyAttribute("False")]
[DesignerSerializationOptionsAttribute("1")]
public string Name { get; public set; }
    [LocalizabilityAttribute("17")]
public object Tag { get; public set; }
    public InputScope InputScope { get; public set; }
    public double ActualWidth { get; }
    public double ActualHeight { get; }
    public Transform LayoutTransform { get; public set; }
    [TypeConverterAttribute("System.Windows.LengthConverter")]
[LocalizabilityAttribute("0")]
public double Width { get; public set; }
    [TypeConverterAttribute("System.Windows.LengthConverter")]
[LocalizabilityAttribute("0")]
public double MinWidth { get; public set; }
    [TypeConverterAttribute("System.Windows.LengthConverter")]
[LocalizabilityAttribute("0")]
public double MaxWidth { get; public set; }
    [TypeConverterAttribute("System.Windows.LengthConverter")]
[LocalizabilityAttribute("0")]
public double Height { get; public set; }
    [LocalizabilityAttribute("0")]
[TypeConverterAttribute("System.Windows.LengthConverter")]
public double MinHeight { get; public set; }
    [TypeConverterAttribute("System.Windows.LengthConverter")]
[LocalizabilityAttribute("0")]
public double MaxHeight { get; public set; }
    [LocalizabilityAttribute("0")]
public FlowDirection FlowDirection { get; public set; }
    public Thickness Margin { get; public set; }
    public HorizontalAlignment HorizontalAlignment { get; public set; }
    public VerticalAlignment VerticalAlignment { get; public set; }
    internal static Style DefaultFocusVisualStyle { get; }
    public Style FocusVisualStyle { get; public set; }
    public Cursor Cursor { get; public set; }
    public bool ForceCursor { get; public set; }
    [EditorBrowsableAttribute("2")]
public bool IsInitialized { get; }
    public bool IsLoaded { get; }
    internal static PopupControlService PopupControlService { get; }
    internal static KeyboardNavigation KeyboardNavigation { get; }
    [BindableAttribute("True")]
[CategoryAttribute("Appearance")]
[LocalizabilityAttribute("10")]
public object ToolTip { get; public set; }
    public ContextMenu ContextMenu { get; public set; }
    internal bool HasResourceReference { get; internal set; }
    internal bool IsLogicalChildrenIterationInProgress { get; internal set; }
    internal bool InVisibilityCollapsedTree { get; internal set; }
    internal bool SubtreeHasLoadedChangeHandler { get; internal set; }
    internal bool IsLoadedCache { get; internal set; }
    internal bool IsParentAnFE { get; internal set; }
    internal bool IsTemplatedParentAnFE { get; internal set; }
    internal bool HasLogicalChildren { get; internal set; }
    private bool NeedsClipBounds { get; private set; }
    private bool HasWidthEverChanged { get; private set; }
    private bool HasHeightEverChanged { get; private set; }
    internal bool IsRightToLeft { get; internal set; }
    internal int TemplateChildIndex { get; internal set; }
    internal bool IsRequestingExpression { get; internal set; }
    internal bool BypassLayoutPolicies { get; internal set; }
    private static DependencyObjectType ControlDType { get; }
    private static DependencyObjectType ContentPresenterDType { get; }
    private static DependencyObjectType PageDType { get; }
    private static DependencyObjectType PageFunctionBaseDType { get; }
    internal int EffectiveValuesInitialSize { get; }
    public DependencyObject Parent { get; }
    protected internal IEnumerator LogicalChildren { get; }
    internal bool ThisHasLoadedChangeEventHandler { get; }
    internal bool HasFefLoadedChangeHandler { get; }
    internal DependencyObject InheritanceContext { get; }
    internal bool IsStyleUpdateInProgress { get; internal set; }
    internal bool IsThemeStyleUpdateInProgress { get; internal set; }
    internal bool StoresParentTemplateValues { get; internal set; }
    internal bool HasNumberSubstitutionChanged { get; internal set; }
    internal bool HasTemplateGeneratedSubTree { get; internal set; }
    internal bool HasImplicitStyleFromResources { get; internal set; }
    internal bool ShouldLookupImplicitStyles { get; internal set; }
    internal bool IsStyleSetFromGenerator { get; internal set; }
    internal bool HasStyleChanged { get; internal set; }
    internal bool HasTemplateChanged { get; internal set; }
    internal bool HasStyleInvalidated { get; internal set; }
    internal bool HasStyleEverBeenFetched { get; internal set; }
    internal bool HasLocalStyle { get; internal set; }
    internal bool HasThemeStyleEverBeenFetched { get; internal set; }
    internal bool AncestorChangeInProgress { get; internal set; }
    internal FrugalObjectList`1<DependencyProperty> InheritableProperties { get; internal set; }
    internal Object[] LoadedPending { get; }
    internal Object[] UnloadedPending { get; }
    internal bool HasMultipleInheritanceContexts { get; }
    internal bool PotentiallyHasMentees { get; internal set; }
    private static FrameworkElement();
    public Style get_Style();
    public void set_Style(Style value);
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeStyle();
    private static void OnStyleChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public bool get_OverridesDefaultStyle();
    public void set_OverridesDefaultStyle(bool value);
    public bool get_UseLayoutRounding();
    public void set_UseLayoutRounding(bool value);
    private static void OnUseLayoutRoundingChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    protected internal object get_DefaultStyleKey();
    protected internal void set_DefaultStyleKey(object value);
    private static void OnThemeStyleKeyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    internal Style get_ThemeStyle();
    internal virtual DependencyObjectType get_DTypeThemeStyleKey();
    internal static void OnThemeStyleChanged(DependencyObject d, object oldValue, object newValue);
    internal virtual FrameworkTemplate get_TemplateInternal();
    internal virtual FrameworkTemplate get_TemplateCache();
    internal virtual void set_TemplateCache(FrameworkTemplate value);
    internal virtual void OnTemplateChangedInternal(FrameworkTemplate oldTemplate, FrameworkTemplate newTemplate);
    protected internal virtual void OnStyleChanged(Style oldStyle, Style newStyle);
    protected internal virtual void ParentLayoutInvalidated(UIElement child);
    public bool ApplyTemplate();
    internal virtual void OnPreApplyTemplate();
    public virtual void OnApplyTemplate();
    internal virtual void OnPostApplyTemplate();
    public void BeginStoryboard(Storyboard storyboard);
    public void BeginStoryboard(Storyboard storyboard, HandoffBehavior handoffBehavior);
    public void BeginStoryboard(Storyboard storyboard, HandoffBehavior handoffBehavior, bool isControllable);
    internal static FrameworkElement FindNamedFrameworkElement(FrameworkElement startElement, string targetName);
    public TriggerCollection get_Triggers();
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeTriggers();
    private void PrivateInitialized();
    public DependencyObject get_TemplatedParent();
    internal bool get_IsTemplateRoot();
    internal virtual UIElement get_TemplateChild();
    internal virtual void set_TemplateChild(UIElement value);
    internal virtual FrameworkElement get_StateGroupsRoot();
    protected virtual int get_VisualChildrenCount();
    protected virtual Visual GetVisualChild(int index);
    internal bool get_HasResources();
    public ResourceDictionary get_Resources();
    public void set_Resources(ResourceDictionary value);
    private sealed virtual override ResourceDictionary System.Windows.Markup.IHaveResources.get_Resources();
    private sealed virtual override void System.Windows.Markup.IHaveResources.set_Resources(ResourceDictionary value);
    private sealed virtual override bool System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(string propertyName);
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeResources();
    protected internal DependencyObject GetTemplateChild(string childName);
    public object FindResource(object resourceKey);
    public object TryFindResource(object resourceKey);
    internal static object FindImplicitStyleResource(FrameworkElement fe, object resourceKey, Object& source);
    internal static object FindImplicitStyleResource(FrameworkContentElement fce, object resourceKey, Object& source);
    internal static object FindResourceInternal(FrameworkElement fe, FrameworkContentElement fce, object resourceKey);
    internal static object FindResourceFromAppOrSystem(object resourceKey, Object& source, bool disableThrowOnResourceNotFound, bool allowDeferredResourceReference, bool mustReturnDeferredResourceReference);
    internal static object FindResourceInternal(FrameworkElement fe, FrameworkContentElement fce, DependencyProperty dp, object resourceKey, object unlinkedParent, bool allowDeferredResourceReference, bool mustReturnDeferredResourceReference, DependencyObject boundaryElement, bool isImplicitStyleLookup, Object& source);
    internal static object FindResourceInTree(FrameworkElement feStart, FrameworkContentElement fceStart, DependencyProperty dp, object resourceKey, object unlinkedParent, bool allowDeferredResourceReference, bool mustReturnDeferredResourceReference, DependencyObject boundaryElement, InheritanceBehavior& inheritanceBehavior, Object& source);
    internal static object FindTemplateResourceInternal(DependencyObject target, object item, Type templateType);
    private static object FindTemplateResourceInTree(DependencyObject target, ArrayList keys, int exactMatch, Int32& bestMatch);
    private static object FindBestMatchInResourceDictionary(ResourceDictionary table, ArrayList keys, int exactMatch, Int32& bestMatch);
    private static ResourceDictionary GetInstanceResourceDictionary(FrameworkElement fe, FrameworkContentElement fce);
    private static ResourceDictionary GetStyleResourceDictionary(FrameworkElement fe, FrameworkContentElement fce);
    private static ResourceDictionary GetThemeStyleResourceDictionary(FrameworkElement fe, FrameworkContentElement fce);
    private static ResourceDictionary GetTemplateResourceDictionary(FrameworkElement fe, FrameworkContentElement fce);
    internal bool HasNonDefaultValue(DependencyProperty dp);
    internal static INameScope FindScope(DependencyObject d);
    internal static INameScope FindScope(DependencyObject d, DependencyObject& scopeOwner);
    public void SetResourceReference(DependencyProperty dp, object name);
    internal sealed virtual void EvaluateBaseValueCore(DependencyProperty dp, PropertyMetadata metadata, EffectiveValueEntry& newEntry);
    internal void GetRawValue(DependencyProperty dp, PropertyMetadata metadata, EffectiveValueEntry& entry);
    private bool GetValueFromTemplatedParent(DependencyProperty dp, EffectiveValueEntry& entry);
    private object GetInheritableValue(DependencyProperty dp, FrameworkPropertyMetadata fmetadata);
    internal Expression GetExpressionCore(DependencyProperty dp, PropertyMetadata metadata);
    protected virtual void OnPropertyChanged(DependencyPropertyChangedEventArgs e);
    internal static DependencyObject GetFrameworkParent(object current);
    internal static bool GetFrameworkParent(FrameworkElement current, FrameworkElement& feParent, FrameworkContentElement& fceParent);
    internal static bool GetFrameworkParent(FrameworkContentElement current, FrameworkElement& feParent, FrameworkContentElement& fceParent);
    internal static bool GetContainingFrameworkElement(DependencyObject current, FrameworkElement& fe, FrameworkContentElement& fce);
    internal static void GetTemplatedParentChildRecord(DependencyObject templatedParent, int childIndex, ChildRecord& childRecord, Boolean& isChildRecordValid);
    internal virtual string GetPlainText();
    private static void TextRenderingMode_Changed(DependencyObject d, DependencyPropertyChangedEventArgs e);
    internal virtual void pushTextRenderingMode();
    internal virtual void OnAncestorChanged();
    protected internal virtual void OnVisualParentChanged(DependencyObject oldParent);
    internal void OnVisualAncestorChanged(object sender, AncestorChangedEventArgs e);
    protected internal InheritanceBehavior get_InheritanceBehavior();
    protected internal void set_InheritanceBehavior(InheritanceBehavior value);
    public void add_TargetUpdated(EventHandler`1<DataTransferEventArgs> value);
    public void remove_TargetUpdated(EventHandler`1<DataTransferEventArgs> value);
    public void add_SourceUpdated(EventHandler`1<DataTransferEventArgs> value);
    public void remove_SourceUpdated(EventHandler`1<DataTransferEventArgs> value);
    public void add_DataContextChanged(DependencyPropertyChangedEventHandler value);
    public void remove_DataContextChanged(DependencyPropertyChangedEventHandler value);
    public object get_DataContext();
    public void set_DataContext(object value);
    private static void OnDataContextChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public BindingExpression GetBindingExpression(DependencyProperty dp);
    public BindingExpressionBase SetBinding(DependencyProperty dp, BindingBase binding);
    public BindingExpression SetBinding(DependencyProperty dp, string path);
    public BindingGroup get_BindingGroup();
    public void set_BindingGroup(BindingGroup value);
    protected internal virtual DependencyObject GetUIParentCore();
    internal virtual object AdjustEventSource(RoutedEventArgs args);
    internal virtual void AdjustBranchSource(RoutedEventArgs args);
    internal virtual bool BuildRouteCore(EventRoute route, RoutedEventArgs args);
    internal bool BuildRouteCoreHelper(EventRoute route, RoutedEventArgs args, bool shouldAddIntermediateElementsToRoute);
    internal virtual void AddToEventRouteCore(EventRoute route, RoutedEventArgs args);
    internal static void AddStyleHandlersToEventRoute(FrameworkElement fe, FrameworkContentElement fce, EventRoute route, RoutedEventArgs args);
    private static void AddStyleHandlersToEventRoute(EventRoute route, DependencyObject source, RoutedEventHandlerInfo[] handlers);
    internal virtual bool IgnoreModelParentBuildRoute(RoutedEventArgs args);
    internal virtual bool InvalidateAutomationAncestorsCore(Stack`1<DependencyObject> branchNodeStack, Boolean& continuePastCoreTree);
    internal virtual void InvalidateForceInheritPropertyOnChildren(DependencyProperty property);
    internal bool InvalidateAutomationAncestorsCoreHelper(Stack`1<DependencyObject> branchNodeStack, Boolean& continuePastCoreTree, bool shouldInvalidateIntermediateElements);
    internal static bool InvalidateAutomationIntermediateElements(DependencyObject mergePoint, DependencyObject modelTreeNode);
    public XmlLanguage get_Language();
    public void set_Language(XmlLanguage value);
    public sealed virtual string get_Name();
    public sealed virtual void set_Name(string value);
    public object get_Tag();
    public void set_Tag(object value);
    public InputScope get_InputScope();
    public void set_InputScope(InputScope value);
    public void add_RequestBringIntoView(RequestBringIntoViewEventHandler value);
    public void remove_RequestBringIntoView(RequestBringIntoViewEventHandler value);
    public void BringIntoView();
    public void BringIntoView(Rect targetRectangle);
    public void add_SizeChanged(SizeChangedEventHandler value);
    public void remove_SizeChanged(SizeChangedEventHandler value);
    private static object GetActualWidth(DependencyObject d, BaseValueSourceInternal& source);
    public double get_ActualWidth();
    private static object GetActualHeight(DependencyObject d, BaseValueSourceInternal& source);
    public double get_ActualHeight();
    public Transform get_LayoutTransform();
    public void set_LayoutTransform(Transform value);
    private static void OnLayoutTransformChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static bool IsWidthHeightValid(object value);
    private static bool IsMinWidthHeightValid(object value);
    private static bool IsMaxWidthHeightValid(object value);
    private static void OnTransformDirty(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public sealed virtual double get_Width();
    public sealed virtual void set_Width(double value);
    public double get_MinWidth();
    public void set_MinWidth(double value);
    public double get_MaxWidth();
    public void set_MaxWidth(double value);
    public sealed virtual double get_Height();
    public sealed virtual void set_Height(double value);
    public double get_MinHeight();
    public void set_MinHeight(double value);
    public double get_MaxHeight();
    public void set_MaxHeight(double value);
    private static object CoerceFlowDirectionProperty(DependencyObject d, object value);
    private static void OnFlowDirectionChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public FlowDirection get_FlowDirection();
    public void set_FlowDirection(FlowDirection value);
    public static FlowDirection GetFlowDirection(DependencyObject element);
    public static void SetFlowDirection(DependencyObject element, FlowDirection value);
    private static bool IsValidFlowDirection(object o);
    private static bool IsMarginValid(object value);
    public Thickness get_Margin();
    public void set_Margin(Thickness value);
    internal static bool ValidateHorizontalAlignmentValue(object value);
    public HorizontalAlignment get_HorizontalAlignment();
    public void set_HorizontalAlignment(HorizontalAlignment value);
    internal static bool ValidateVerticalAlignmentValue(object value);
    public VerticalAlignment get_VerticalAlignment();
    public void set_VerticalAlignment(VerticalAlignment value);
    internal static Style get_DefaultFocusVisualStyle();
    public Style get_FocusVisualStyle();
    public void set_FocusVisualStyle(Style value);
    public Cursor get_Cursor();
    public void set_Cursor(Cursor value);
    private static void OnCursorChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public bool get_ForceCursor();
    public void set_ForceCursor(bool value);
    private static void OnForceCursorChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static void OnQueryCursorOverride(object sender, QueryCursorEventArgs e);
    private Transform GetFlowDirectionTransform();
    internal static bool ShouldApplyMirrorTransform(FrameworkElement fe);
    private static FlowDirection GetFlowDirectionFromVisual(DependencyObject visual);
    internal static bool ApplyMirrorTransform(FlowDirection parentFD, FlowDirection thisFD);
    private Size FindMaximalAreaLocalSpaceRect(Transform layoutTransform, Size transformSpaceBounds);
    protected sealed virtual Size MeasureCore(Size availableSize);
    protected sealed virtual void ArrangeCore(Rect finalRect);
    protected internal virtual void OnRenderSizeChanged(SizeChangedInfo sizeInfo);
    private Vector ComputeAlignmentOffset(Size clientSize, Size inkSize);
    protected virtual Geometry GetLayoutClip(Size layoutSlotSize);
    internal Geometry GetLayoutClipInternal();
    protected virtual Size MeasureOverride(Size availableSize);
    protected virtual Size ArrangeOverride(Size finalSize);
    internal static void InternalSetLayoutTransform(UIElement element, Transform layoutTransform);
    private void SetLayoutOffset(Vector offset, Size oldRenderSize);
    private Point GetRenderTransformOrigin();
    public sealed virtual bool MoveFocus(TraversalRequest request);
    public sealed virtual DependencyObject PredictFocus(FocusNavigationDirection direction);
    private static void OnPreviewGotKeyboardFocus(object sender, KeyboardFocusChangedEventArgs e);
    private static void OnGotKeyboardFocus(object sender, KeyboardFocusChangedEventArgs e);
    private static void OnLostKeyboardFocus(object sender, KeyboardFocusChangedEventArgs e);
    protected virtual void OnGotFocus(RoutedEventArgs e);
    public virtual void BeginInit();
    public virtual void EndInit();
    public bool get_IsInitialized();
    public void add_Initialized(EventHandler value);
    public void remove_Initialized(EventHandler value);
    protected virtual void OnInitialized(EventArgs e);
    private void TryFireInitialized();
    private void RaiseInitialized(EventPrivateKey key, EventArgs e);
    private static void NumberSubstitutionChanged(DependencyObject o, DependencyPropertyChangedEventArgs e);
    private static bool ShouldUseSystemFont(FrameworkElement fe, DependencyProperty dp);
    private static object CoerceFontFamily(DependencyObject o, object value);
    private static object CoerceFontSize(DependencyObject o, object value);
    private static object CoerceFontStyle(DependencyObject o, object value);
    private static object CoerceFontWeight(DependencyObject o, object value);
    internal sealed virtual void OnPresentationSourceChanged(bool attached);
    public bool get_IsLoaded();
    public void add_Loaded(RoutedEventHandler value);
    public void remove_Loaded(RoutedEventHandler value);
    internal virtual void OnAddHandler(RoutedEvent routedEvent, Delegate handler);
    internal virtual void OnRemoveHandler(RoutedEvent routedEvent, Delegate handler);
    internal void OnLoaded(RoutedEventArgs args);
    public void add_Unloaded(RoutedEventHandler value);
    public void remove_Unloaded(RoutedEventHandler value);
    internal void OnUnloaded(RoutedEventArgs args);
    internal virtual void AddSynchronizedInputPreOpportunityHandlerCore(EventRoute route, RoutedEventArgs args);
    internal void RaiseClrEvent(EventPrivateKey key, EventArgs args);
    internal static PopupControlService get_PopupControlService();
    internal static KeyboardNavigation get_KeyboardNavigation();
    private static FrameworkServices EnsureFrameworkServices();
    public object get_ToolTip();
    public void set_ToolTip(object value);
    public ContextMenu get_ContextMenu();
    public void set_ContextMenu(ContextMenu value);
    public void add_ToolTipOpening(ToolTipEventHandler value);
    public void remove_ToolTipOpening(ToolTipEventHandler value);
    private static void OnToolTipOpeningThunk(object sender, ToolTipEventArgs e);
    protected virtual void OnToolTipOpening(ToolTipEventArgs e);
    public void add_ToolTipClosing(ToolTipEventHandler value);
    public void remove_ToolTipClosing(ToolTipEventHandler value);
    private static void OnToolTipClosingThunk(object sender, ToolTipEventArgs e);
    protected virtual void OnToolTipClosing(ToolTipEventArgs e);
    public void add_ContextMenuOpening(ContextMenuEventHandler value);
    public void remove_ContextMenuOpening(ContextMenuEventHandler value);
    private static void OnContextMenuOpeningThunk(object sender, ContextMenuEventArgs e);
    protected virtual void OnContextMenuOpening(ContextMenuEventArgs e);
    public void add_ContextMenuClosing(ContextMenuEventHandler value);
    public void remove_ContextMenuClosing(ContextMenuEventHandler value);
    private static void OnContextMenuClosingThunk(object sender, ContextMenuEventArgs e);
    protected virtual void OnContextMenuClosing(ContextMenuEventArgs e);
    private void RaiseDependencyPropertyChanged(EventPrivateKey key, DependencyPropertyChangedEventArgs args);
    internal static void AddIntermediateElementsToRoute(DependencyObject mergePoint, EventRoute route, RoutedEventArgs args, DependencyObject modelTreeNode);
    private bool IsLogicalDescendent(DependencyObject child);
    internal void EventHandlersStoreAdd(EventPrivateKey key, Delegate handler);
    internal void EventHandlersStoreRemove(EventPrivateKey key, Delegate handler);
    internal bool get_HasResourceReference();
    internal void set_HasResourceReference(bool value);
    internal bool get_IsLogicalChildrenIterationInProgress();
    internal void set_IsLogicalChildrenIterationInProgress(bool value);
    internal bool get_InVisibilityCollapsedTree();
    internal void set_InVisibilityCollapsedTree(bool value);
    internal bool get_SubtreeHasLoadedChangeHandler();
    internal void set_SubtreeHasLoadedChangeHandler(bool value);
    internal bool get_IsLoadedCache();
    internal void set_IsLoadedCache(bool value);
    internal bool get_IsParentAnFE();
    internal void set_IsParentAnFE(bool value);
    internal bool get_IsTemplatedParentAnFE();
    internal void set_IsTemplatedParentAnFE(bool value);
    internal bool get_HasLogicalChildren();
    internal void set_HasLogicalChildren(bool value);
    private bool get_NeedsClipBounds();
    private void set_NeedsClipBounds(bool value);
    private bool get_HasWidthEverChanged();
    private void set_HasWidthEverChanged(bool value);
    private bool get_HasHeightEverChanged();
    private void set_HasHeightEverChanged(bool value);
    internal bool get_IsRightToLeft();
    internal void set_IsRightToLeft(bool value);
    internal int get_TemplateChildIndex();
    internal void set_TemplateChildIndex(int value);
    internal bool get_IsRequestingExpression();
    internal void set_IsRequestingExpression(bool value);
    internal bool get_BypassLayoutPolicies();
    internal void set_BypassLayoutPolicies(bool value);
    internal bool ReadInternalFlag(InternalFlags reqFlag);
    internal bool ReadInternalFlag2(InternalFlags2 reqFlag);
    internal void WriteInternalFlag(InternalFlags reqFlag, bool set);
    internal void WriteInternalFlag2(InternalFlags2 reqFlag, bool set);
    private static DependencyObjectType get_ControlDType();
    private static DependencyObjectType get_ContentPresenterDType();
    private static DependencyObjectType get_PageDType();
    private static DependencyObjectType get_PageFunctionBaseDType();
    internal virtual int get_EffectiveValuesInitialSize();
    public DependencyObject get_Parent();
    public void RegisterName(string name, object scopedElement);
    public void UnregisterName(string name);
    public object FindName(string name);
    internal object FindName(string name, DependencyObject& scopeOwner);
    public void UpdateDefaultStyle();
    protected internal virtual IEnumerator get_LogicalChildren();
    internal object FindResourceOnSelf(object resourceKey, bool allowDeferredResourceReference, bool mustReturnDeferredResourceReference);
    internal DependencyObject ContextVerifiedGetParent();
    protected internal void AddLogicalChild(object child);
    protected internal void RemoveLogicalChild(object child);
    internal void ChangeLogicalParent(DependencyObject newParent);
    internal virtual void OnNewParent(DependencyObject newParent);
    internal void OnAncestorChangedInternal(TreeChangeInfo parentTreeState);
    internal FrugalObjectList`1<DependencyProperty> InvalidateTreeDependentProperties(TreeChangeInfo parentTreeState, bool isSelfInheritanceParent, bool wasSelfInheritanceParent);
    internal bool get_ThisHasLoadedChangeEventHandler();
    internal bool get_HasFefLoadedChangeHandler();
    internal void UpdateStyleProperty();
    internal void UpdateThemeStyleProperty();
    internal virtual void OnThemeChanged();
    internal void FireLoadedOnDescendentsInternal();
    internal void FireUnloadedOnDescendentsInternal();
    internal virtual bool ShouldProvideInheritanceContext(DependencyObject target, DependencyProperty property);
    internal virtual DependencyObject get_InheritanceContext();
    internal virtual void AddInheritanceContext(DependencyObject context, DependencyProperty property);
    internal virtual void RemoveInheritanceContext(DependencyObject context, DependencyProperty property);
    private void ClearInheritanceContext();
    internal virtual void OnInheritanceContextChangedCore(EventArgs args);
    private void ConnectMentor(DependencyObject mentor);
    private void DisconnectMentor(DependencyObject mentor);
    internal void ChangeSubtreeHasLoadedChangedHandler(DependencyObject mentor);
    private void OnMentorLoaded(object sender, RoutedEventArgs e);
    private void OnMentorUnloaded(object sender, RoutedEventArgs e);
    private void ConnectLoadedEvents(FrameworkObject& foMentor, bool isLoaded);
    private void DisconnectLoadedEvents(FrameworkObject& foMentor, bool isLoaded);
    private void OnMentorInheritedPropertyChanged(object sender, InheritedPropertyChangedEventArgs e);
    private void OnMentorResourcesChanged(object sender, EventArgs e);
    internal void RaiseInheritedPropertyChangedEvent(InheritablePropertyChangeInfo& info);
    internal bool get_IsStyleUpdateInProgress();
    internal void set_IsStyleUpdateInProgress(bool value);
    internal bool get_IsThemeStyleUpdateInProgress();
    internal void set_IsThemeStyleUpdateInProgress(bool value);
    internal bool get_StoresParentTemplateValues();
    internal void set_StoresParentTemplateValues(bool value);
    internal bool get_HasNumberSubstitutionChanged();
    internal void set_HasNumberSubstitutionChanged(bool value);
    internal bool get_HasTemplateGeneratedSubTree();
    internal void set_HasTemplateGeneratedSubTree(bool value);
    internal bool get_HasImplicitStyleFromResources();
    internal void set_HasImplicitStyleFromResources(bool value);
    internal bool get_ShouldLookupImplicitStyles();
    internal void set_ShouldLookupImplicitStyles(bool value);
    internal bool get_IsStyleSetFromGenerator();
    internal void set_IsStyleSetFromGenerator(bool value);
    internal bool get_HasStyleChanged();
    internal void set_HasStyleChanged(bool value);
    internal bool get_HasTemplateChanged();
    internal void set_HasTemplateChanged(bool value);
    internal bool get_HasStyleInvalidated();
    internal void set_HasStyleInvalidated(bool value);
    internal bool get_HasStyleEverBeenFetched();
    internal void set_HasStyleEverBeenFetched(bool value);
    internal bool get_HasLocalStyle();
    internal void set_HasLocalStyle(bool value);
    internal bool get_HasThemeStyleEverBeenFetched();
    internal void set_HasThemeStyleEverBeenFetched(bool value);
    internal bool get_AncestorChangeInProgress();
    internal void set_AncestorChangeInProgress(bool value);
    internal FrugalObjectList`1<DependencyProperty> get_InheritableProperties();
    internal void set_InheritableProperties(FrugalObjectList`1<DependencyProperty> value);
    internal Object[] get_LoadedPending();
    internal Object[] get_UnloadedPending();
    internal virtual bool get_HasMultipleInheritanceContexts();
    internal bool get_PotentiallyHasMentees();
    internal void set_PotentiallyHasMentees(bool value);
    internal void add_ResourcesChanged(EventHandler value);
    internal void remove_ResourcesChanged(EventHandler value);
    internal void add_InheritedPropertyChanged(InheritedPropertyChangedEventHandler value);
    internal void remove_InheritedPropertyChanged(InheritedPropertyChangedEventHandler value);
}
[LocalizabilityAttribute("17")]
public class System.Windows.FrameworkElementFactory : object {
    private bool _sealed;
    internal FrugalStructList`1<PropertyValue> PropertyValues;
    private EventHandlersStore _eventHandlersStore;
    internal bool _hasLoadedChangeHandler;
    private Type _type;
    private string _text;
    private Func`1<object> _knownTypeFactory;
    private string _childName;
    internal int _childIndex;
    private FrameworkTemplate _frameworkTemplate;
    private static int AutoGenChildNamePostfix;
    private static string AutoGenChildNamePrefix;
    private FrameworkElementFactory _parent;
    private FrameworkElementFactory _firstChild;
    private FrameworkElementFactory _lastChild;
    private FrameworkElementFactory _nextSibling;
    private object _synchronized;
    public Type Type { get; public set; }
    public string Text { get; public set; }
    public string Name { get; public set; }
    internal EventHandlersStore EventHandlersStore { get; internal set; }
    internal bool HasLoadedChangeHandler { get; internal set; }
    public bool IsSealed { get; }
    public FrameworkElementFactory Parent { get; }
    public FrameworkElementFactory FirstChild { get; }
    public FrameworkElementFactory NextSibling { get; }
    internal FrameworkTemplate FrameworkTemplate { get; }
    public FrameworkElementFactory(Type type);
    public FrameworkElementFactory(string text);
    public FrameworkElementFactory(Type type, string name);
    private static FrameworkElementFactory();
    public Type get_Type();
    public void set_Type(Type value);
    public string get_Text();
    public void set_Text(string value);
    public string get_Name();
    public void set_Name(string value);
    public void AppendChild(FrameworkElementFactory child);
    public void SetValue(DependencyProperty dp, object value);
    public void SetBinding(DependencyProperty dp, BindingBase binding);
    public void SetResourceReference(DependencyProperty dp, object name);
    public void AddHandler(RoutedEvent routedEvent, Delegate handler);
    public void AddHandler(RoutedEvent routedEvent, Delegate handler, bool handledEventsToo);
    public void RemoveHandler(RoutedEvent routedEvent, Delegate handler);
    internal EventHandlersStore get_EventHandlersStore();
    internal void set_EventHandlersStore(EventHandlersStore value);
    internal bool get_HasLoadedChangeHandler();
    internal void set_HasLoadedChangeHandler(bool value);
    private void UpdatePropertyValueList(DependencyProperty dp, PropertyValueType valueType, object value);
    private DependencyObject CreateDependencyObject();
    public bool get_IsSealed();
    public FrameworkElementFactory get_Parent();
    public FrameworkElementFactory get_FirstChild();
    public FrameworkElementFactory get_NextSibling();
    internal FrameworkTemplate get_FrameworkTemplate();
    internal object GetValue(DependencyProperty dp);
    internal void Seal(FrameworkTemplate ownerTemplate);
    private void Seal();
    internal DependencyObject InstantiateTree(UncommonField`1<HybridDictionary[]> dataField, DependencyObject container, DependencyObject parent, List`1<DependencyObject> affectedChildren, List`1& noChildIndexChildren, FrugalStructList`1& resourceDependents);
    private void AddNodeToParent(DependencyObject parent, FrameworkObject childFrameworkObject);
    internal FrameworkObject InstantiateUnoptimizedTree();
    private static void UpdateChildChains(string childID, int childIndex, bool treeNodeIsFE, FrameworkElement treeNodeFE, FrameworkContentElement treeNodeFCE, List`1<DependencyObject> affectedChildren, List`1& noChildIndexChildren);
    internal static void NewNodeBeginInit(bool treeNodeIsFE, FrameworkElement treeNodeFE, FrameworkContentElement treeNodeFCE);
    private static void NewNodeEndInit(bool treeNodeIsFE, FrameworkElement treeNodeFE, FrameworkContentElement treeNodeFCE);
    private static void NewNodeStyledParentProperty(DependencyObject container, bool isContainerAnFE, bool treeNodeIsFE, FrameworkElement treeNodeFE, FrameworkContentElement treeNodeFCE);
    internal static void AddNodeToLogicalTree(DependencyObject parent, Type type, bool treeNodeIsFE, FrameworkElement treeNodeFE, FrameworkContentElement treeNodeFCE);
    internal bool IsChildNameValid(string childName);
    private string GenerateChildName();
    private void ApplyAutoAliasRules();
    private bool IsValueDefined(DependencyProperty dp);
}
public class System.Windows.FrameworkPropertyMetadata : UIPropertyMetadata {
    public bool AffectsMeasure { get; public set; }
    public bool AffectsArrange { get; public set; }
    public bool AffectsParentMeasure { get; public set; }
    public bool AffectsParentArrange { get; public set; }
    public bool AffectsRender { get; public set; }
    public bool Inherits { get; public set; }
    public bool OverridesInheritanceBehavior { get; public set; }
    public bool IsNotDataBindable { get; public set; }
    public bool BindsTwoWayByDefault { get; public set; }
    public UpdateSourceTrigger DefaultUpdateSourceTrigger { get; public set; }
    public bool Journal { get; public set; }
    public bool SubPropertiesDoNotAffectRender { get; public set; }
    private bool ReadOnly { get; private set; }
    public bool IsDataBindingAllowed { get; }
    public FrameworkPropertyMetadata(object defaultValue);
    public FrameworkPropertyMetadata(PropertyChangedCallback propertyChangedCallback);
    public FrameworkPropertyMetadata(PropertyChangedCallback propertyChangedCallback, CoerceValueCallback coerceValueCallback);
    public FrameworkPropertyMetadata(object defaultValue, PropertyChangedCallback propertyChangedCallback);
    public FrameworkPropertyMetadata(object defaultValue, PropertyChangedCallback propertyChangedCallback, CoerceValueCallback coerceValueCallback);
    public FrameworkPropertyMetadata(object defaultValue, FrameworkPropertyMetadataOptions flags);
    public FrameworkPropertyMetadata(object defaultValue, FrameworkPropertyMetadataOptions flags, PropertyChangedCallback propertyChangedCallback);
    public FrameworkPropertyMetadata(object defaultValue, FrameworkPropertyMetadataOptions flags, PropertyChangedCallback propertyChangedCallback, CoerceValueCallback coerceValueCallback);
    public FrameworkPropertyMetadata(object defaultValue, FrameworkPropertyMetadataOptions flags, PropertyChangedCallback propertyChangedCallback, CoerceValueCallback coerceValueCallback, bool isAnimationProhibited);
    public FrameworkPropertyMetadata(object defaultValue, FrameworkPropertyMetadataOptions flags, PropertyChangedCallback propertyChangedCallback, CoerceValueCallback coerceValueCallback, bool isAnimationProhibited, UpdateSourceTrigger defaultUpdateSourceTrigger);
    private void Initialize();
    private static bool IsFlagSet(FrameworkPropertyMetadataOptions flag, FrameworkPropertyMetadataOptions flags);
    private void TranslateFlags(FrameworkPropertyMetadataOptions flags);
    public bool get_AffectsMeasure();
    public void set_AffectsMeasure(bool value);
    public bool get_AffectsArrange();
    public void set_AffectsArrange(bool value);
    public bool get_AffectsParentMeasure();
    public void set_AffectsParentMeasure(bool value);
    public bool get_AffectsParentArrange();
    public void set_AffectsParentArrange(bool value);
    public bool get_AffectsRender();
    public void set_AffectsRender(bool value);
    public bool get_Inherits();
    public void set_Inherits(bool value);
    public bool get_OverridesInheritanceBehavior();
    public void set_OverridesInheritanceBehavior(bool value);
    public bool get_IsNotDataBindable();
    public void set_IsNotDataBindable(bool value);
    public bool get_BindsTwoWayByDefault();
    public void set_BindsTwoWayByDefault(bool value);
    public UpdateSourceTrigger get_DefaultUpdateSourceTrigger();
    public void set_DefaultUpdateSourceTrigger(UpdateSourceTrigger value);
    public bool get_Journal();
    public void set_Journal(bool value);
    public bool get_SubPropertiesDoNotAffectRender();
    public void set_SubPropertiesDoNotAffectRender(bool value);
    private bool get_ReadOnly();
    private void set_ReadOnly(bool value);
    internal virtual PropertyMetadata CreateInstance();
    protected virtual void Merge(PropertyMetadata baseMetadata, DependencyProperty dp);
    protected virtual void OnApply(DependencyProperty dp, Type targetType);
    public bool get_IsDataBindingAllowed();
    internal void SetModified(MetadataFlags id);
    internal bool IsModified(MetadataFlags id);
}
[FlagsAttribute]
public enum System.Windows.FrameworkPropertyMetadataOptions : Enum {
    public int value__;
    public static FrameworkPropertyMetadataOptions None;
    public static FrameworkPropertyMetadataOptions AffectsMeasure;
    public static FrameworkPropertyMetadataOptions AffectsArrange;
    public static FrameworkPropertyMetadataOptions AffectsParentMeasure;
    public static FrameworkPropertyMetadataOptions AffectsParentArrange;
    public static FrameworkPropertyMetadataOptions AffectsRender;
    public static FrameworkPropertyMetadataOptions Inherits;
    public static FrameworkPropertyMetadataOptions OverridesInheritanceBehavior;
    public static FrameworkPropertyMetadataOptions NotDataBindable;
    public static FrameworkPropertyMetadataOptions BindsTwoWayByDefault;
    public static FrameworkPropertyMetadataOptions Journal;
    public static FrameworkPropertyMetadataOptions SubPropertiesDoNotAffectRender;
}
[ContentPropertyAttribute("VisualTree")]
[LocalizabilityAttribute("17")]
public abstract class System.Windows.FrameworkTemplate : DispatcherObject {
    private NameScope _nameScope;
    private XamlContextStack`1<Frame> Names;
    private InternalFlags _flags;
    private bool _sealed;
    internal bool _hasInstanceValues;
    private ParserContext _parserContext;
    private IStyleConnector _styleConnector;
    private IComponentConnector _componentConnector;
    private FrameworkElementFactory _templateRoot;
    private TemplateContent _templateHolder;
    private bool _hasXamlNodeContent;
    private HybridDictionary _childIndexFromChildName;
    private Dictionary`2<int, Type> _childTypeFromChildIndex;
    private int _lastChildIndex;
    private List`1<string> _childNames;
    internal ResourceDictionary _resources;
    internal HybridDictionary _triggerActions;
    internal FrugalStructList`1<ChildRecord> ChildRecordFromChildIndex;
    internal FrugalStructList`1<ItemStructMap`1<TriggerSourceRecord>> TriggerSourceRecordFromChildIndex;
    internal FrugalMap PropertyTriggersWithActions;
    internal FrugalStructList`1<ContainerDependent> ContainerDependents;
    internal FrugalStructList`1<ChildPropertyDependent> ResourceDependents;
    internal HybridDictionary _dataTriggerRecordFromBinding;
    internal HybridDictionary DataTriggersWithActions;
    internal ConditionalWeakTable`2<DependencyObject, List`1<DeferredAction>> DeferredActions;
    internal HybridDictionary _TemplateChildLoadedDictionary;
    internal ItemStructList`1<ChildEventDependent> EventDependents;
    private EventHandlersStore _eventHandlersStore;
    private Object[] _staticResourceValues;
    public bool IsSealed { get; }
    public FrameworkElementFactory VisualTree { get; public set; }
    [AmbientAttribute]
[DefaultValueAttribute("")]
public TemplateContent Template { get; public set; }
    [DesignerSerializationVisibilityAttribute("2")]
[AmbientAttribute]
public ResourceDictionary Resources { get; public set; }
    private ResourceDictionary System.Windows.Markup.IHaveResources.Resources { get; private set; }
    public bool HasContent { get; }
    internal bool CanBuildVisualTree { get; internal set; }
    internal Type TargetTypeInternal { get; }
    internal object DataTypeInternal { get; }
    private bool System.Windows.ISealable.CanSeal { get; }
    private bool System.Windows.ISealable.IsSealed { get; }
    internal TriggerCollection TriggersInternal { get; }
    internal bool HasResourceReferences { get; }
    internal bool HasContainerResourceReferences { get; }
    internal bool HasChildResourceReferences { get; }
    internal bool HasEventDependents { get; }
    internal bool HasInstanceValues { get; }
    internal bool HasLoadedChangeHandler { get; internal set; }
    internal ParserContext ParserContext { get; }
    internal EventHandlersStore EventHandlersStore { get; }
    internal IStyleConnector StyleConnector { get; internal set; }
    internal IComponentConnector ComponentConnector { get; internal set; }
    internal Object[] StaticResourceValues { get; internal set; }
    internal bool HasXamlNodeContent { get; }
    internal HybridDictionary ChildIndexFromChildName { get; }
    internal Dictionary`2<int, Type> ChildTypeFromChildIndex { get; }
    internal int LastChildIndex { get; internal set; }
    internal List`1<string> ChildNames { get; }
    protected virtual void ValidateTemplatedParent(FrameworkElement templatedParent);
    public bool get_IsSealed();
    public FrameworkElementFactory get_VisualTree();
    public void set_VisualTree(FrameworkElementFactory value);
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeVisualTree();
    public TemplateContent get_Template();
    public void set_Template(TemplateContent value);
    public ResourceDictionary get_Resources();
    public void set_Resources(ResourceDictionary value);
    private sealed virtual override ResourceDictionary System.Windows.Markup.IHaveResources.get_Resources();
    private sealed virtual override void System.Windows.Markup.IHaveResources.set_Resources(ResourceDictionary value);
    internal object FindResource(object resourceKey, bool allowDeferredResourceReference, bool mustReturnDeferredResourceReference);
    private sealed virtual override bool System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(string propertyName);
    public object FindName(string name, FrameworkElement templatedParent);
    public sealed virtual void RegisterName(string name, object scopedElement);
    public sealed virtual void UnregisterName(string name);
    private sealed virtual override object System.Windows.Markup.INameScope.FindName(string name);
    private void ValidateVisualTree(FrameworkElementFactory templateRoot);
    internal virtual void ProcessTemplateBeforeSeal();
    public void Seal();
    internal void CheckSealed();
    internal void SetResourceReferenceState();
    internal bool ApplyTemplateContent(UncommonField`1<HybridDictionary[]> templateDataField, FrameworkElement container);
    public DependencyObject LoadContent();
    internal DependencyObject LoadContent(DependencyObject container, List`1<DependencyObject> affectedChildren);
    internal static bool IsNameScope(XamlType type);
    public bool get_HasContent();
    internal virtual bool BuildVisualTree(FrameworkElement container);
    internal bool get_CanBuildVisualTree();
    internal void set_CanBuildVisualTree(bool value);
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeResources(XamlDesignerSerializationManager manager);
    private bool ReadInternalFlag(InternalFlags reqFlag);
    private void WriteInternalFlag(InternalFlags reqFlag, bool set);
    private bool ReceivePropertySet(object targetObject, XamlMember member, object value, DependencyObject templatedParent);
    private DependencyObject LoadOptimizedTemplateContent(DependencyObject container, IComponentConnector componentConnector, IStyleConnector styleConnector, List`1<DependencyObject> affectedChildren, UncommonField`1<Hashtable> templatedNonFeChildrenField);
    private void LoadTemplateXaml(XamlObjectWriter objectWriter);
    private void LoadTemplateXaml(XamlReader templateReader, XamlObjectWriter currentWriter);
    internal static bool IsNameProperty(XamlMember member, XamlType owner);
    private void HandleAfterBeginInit(object createdObject, DependencyObject& rootObject, DependencyObject container, FrameworkElement feContainer, TemplateNameScope nameScope, IEnumerator`1<string> nameEnumerator);
    private void HandleBeforeProperties(object createdObject, DependencyObject& rootObject, DependencyObject container, FrameworkElement feContainer, INameScope nameScope);
    private static DependencyObject WireRootObjectToParent(object createdObject, DependencyObject rootObject, DependencyObject container, FrameworkElement feContainer, INameScope nameScope);
    private void InvalidatePropertiesOnTemplate(DependencyObject container, object currentObject);
    internal static void SetTemplateParentValues(string name, object element, FrameworkTemplate frameworkTemplate, ProvideValueServiceProvider& provideValueServiceProvider);
    internal virtual Type get_TargetTypeInternal();
    internal abstract virtual void SetTargetTypeInternal(Type targetType);
    internal virtual object get_DataTypeInternal();
    private sealed virtual override bool System.Windows.ISealable.get_CanSeal();
    private sealed virtual override bool System.Windows.ISealable.get_IsSealed();
    private sealed virtual override void System.Windows.ISealable.Seal();
    internal virtual TriggerCollection get_TriggersInternal();
    internal bool get_HasResourceReferences();
    internal bool get_HasContainerResourceReferences();
    internal bool get_HasChildResourceReferences();
    internal bool get_HasEventDependents();
    internal bool get_HasInstanceValues();
    internal bool get_HasLoadedChangeHandler();
    internal void set_HasLoadedChangeHandler(bool value);
    internal void CopyParserContext(ParserContext parserContext);
    internal ParserContext get_ParserContext();
    internal EventHandlersStore get_EventHandlersStore();
    internal IStyleConnector get_StyleConnector();
    internal void set_StyleConnector(IStyleConnector value);
    internal IComponentConnector get_ComponentConnector();
    internal void set_ComponentConnector(IComponentConnector value);
    internal Object[] get_StaticResourceValues();
    internal void set_StaticResourceValues(Object[] value);
    internal bool get_HasXamlNodeContent();
    internal HybridDictionary get_ChildIndexFromChildName();
    internal Dictionary`2<int, Type> get_ChildTypeFromChildIndex();
    internal int get_LastChildIndex();
    internal void set_LastChildIndex(int value);
    internal List`1<string> get_ChildNames();
}
[TypeConverterAttribute("System.Windows.GridLengthConverter")]
public class System.Windows.GridLength : ValueType {
    private double _unitValue;
    private GridUnitType _unitType;
    private static GridLength s_auto;
    public bool IsAbsolute { get; }
    public bool IsAuto { get; }
    public bool IsStar { get; }
    public double Value { get; }
    public GridUnitType GridUnitType { get; }
    public static GridLength Auto { get; }
    public GridLength(double pixels);
    public GridLength(double value, GridUnitType type);
    private static GridLength();
    public static bool op_Equality(GridLength gl1, GridLength gl2);
    public static bool op_Inequality(GridLength gl1, GridLength gl2);
    public virtual bool Equals(object oCompare);
    public sealed virtual bool Equals(GridLength gridLength);
    public virtual int GetHashCode();
    public bool get_IsAbsolute();
    public bool get_IsAuto();
    public bool get_IsStar();
    public double get_Value();
    public GridUnitType get_GridUnitType();
    public virtual string ToString();
    public static GridLength get_Auto();
}
public class System.Windows.GridLengthConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext typeDescriptorContext, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext typeDescriptorContext, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext typeDescriptorContext, CultureInfo cultureInfo, object source);
    public virtual object ConvertTo(ITypeDescriptorContext typeDescriptorContext, CultureInfo cultureInfo, object value, Type destinationType);
    internal static string ToString(GridLength gl, CultureInfo cultureInfo);
    internal static GridLength FromString(string s, CultureInfo cultureInfo);
}
public enum System.Windows.GridUnitType : Enum {
    public int value__;
    public static GridUnitType Auto;
    public static GridUnitType Pixel;
    public static GridUnitType Star;
}
public class System.Windows.HierarchicalDataTemplate : DataTemplate {
    private BindingBase _itemsSourceBinding;
    private DataTemplate _itemTemplate;
    private DataTemplateSelector _itemTemplateSelector;
    private Style _itemContainerStyle;
    private StyleSelector _itemContainerStyleSelector;
    private string _itemStringFormat;
    private int _alternationCount;
    private BindingGroup _itemBindingGroup;
    private bool _itemTemplateSet;
    private bool _itemTemplateSelectorSet;
    private bool _itemContainerStyleSet;
    private bool _itemContainerStyleSelectorSet;
    private bool _itemStringFormatSet;
    private bool _alternationCountSet;
    private bool _itemBindingGroupSet;
    public BindingBase ItemsSource { get; public set; }
    public DataTemplate ItemTemplate { get; public set; }
    public DataTemplateSelector ItemTemplateSelector { get; public set; }
    public Style ItemContainerStyle { get; public set; }
    public StyleSelector ItemContainerStyleSelector { get; public set; }
    public string ItemStringFormat { get; public set; }
    public int AlternationCount { get; public set; }
    public BindingGroup ItemBindingGroup { get; public set; }
    internal bool IsItemTemplateSet { get; }
    internal bool IsItemTemplateSelectorSet { get; }
    internal bool IsItemContainerStyleSet { get; }
    internal bool IsItemContainerStyleSelectorSet { get; }
    internal bool IsItemStringFormatSet { get; }
    internal bool IsAlternationCountSet { get; }
    internal bool IsItemBindingGroupSet { get; }
    public HierarchicalDataTemplate(object dataType);
    public BindingBase get_ItemsSource();
    public void set_ItemsSource(BindingBase value);
    public DataTemplate get_ItemTemplate();
    public void set_ItemTemplate(DataTemplate value);
    public DataTemplateSelector get_ItemTemplateSelector();
    public void set_ItemTemplateSelector(DataTemplateSelector value);
    public Style get_ItemContainerStyle();
    public void set_ItemContainerStyle(Style value);
    public StyleSelector get_ItemContainerStyleSelector();
    public void set_ItemContainerStyleSelector(StyleSelector value);
    public string get_ItemStringFormat();
    public void set_ItemStringFormat(string value);
    public int get_AlternationCount();
    public void set_AlternationCount(int value);
    public BindingGroup get_ItemBindingGroup();
    public void set_ItemBindingGroup(BindingGroup value);
    internal bool get_IsItemTemplateSet();
    internal bool get_IsItemTemplateSelectorSet();
    internal bool get_IsItemContainerStyleSet();
    internal bool get_IsItemContainerStyleSelectorSet();
    internal bool get_IsItemStringFormatSet();
    internal bool get_IsAlternationCountSet();
    internal bool get_IsItemBindingGroupSet();
}
[LocalizabilityAttribute("0")]
public enum System.Windows.HorizontalAlignment : Enum {
    public int value__;
    public static HorizontalAlignment Left;
    public static HorizontalAlignment Center;
    public static HorizontalAlignment Right;
    public static HorizontalAlignment Stretch;
}
public interface System.Windows.IFrameworkInputElement {
    public string Name { get; public set; }
    public abstract virtual string get_Name();
    public abstract virtual void set_Name(string value);
}
internal class System.Windows.IndexerParameterInfo : ValueType {
    public Type type;
    public object value;
}
internal class System.Windows.InheritablePropertyChangeInfo : ValueType {
    private DependencyObject _rootElement;
    private DependencyProperty _property;
    private EffectiveValueEntry _oldEntry;
    private EffectiveValueEntry _newEntry;
    internal DependencyObject RootElement { get; }
    internal DependencyProperty Property { get; }
    internal EffectiveValueEntry OldEntry { get; }
    internal EffectiveValueEntry NewEntry { get; }
    internal InheritablePropertyChangeInfo(DependencyObject rootElement, DependencyProperty property, EffectiveValueEntry oldEntry, EffectiveValueEntry newEntry);
    internal DependencyObject get_RootElement();
    internal DependencyProperty get_Property();
    internal EffectiveValueEntry get_OldEntry();
    internal EffectiveValueEntry get_NewEntry();
}
public enum System.Windows.InheritanceBehavior : Enum {
    public int value__;
    public static InheritanceBehavior Default;
    public static InheritanceBehavior SkipToAppNow;
    public static InheritanceBehavior SkipToAppNext;
    public static InheritanceBehavior SkipToThemeNow;
    public static InheritanceBehavior SkipToThemeNext;
    public static InheritanceBehavior SkipAllNow;
    public static InheritanceBehavior SkipAllNext;
}
public class System.Windows.Input.CommandConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object source);
    internal static ICommand ConvertFromHelper(Type ownerType, string localName);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
    internal static bool IsKnownType(Type commandType);
    private Type GetTypeFromContext(ITypeDescriptorContext context, string typeName);
    private void ParseUri(string source, String& typeName, String& localName);
    private static RoutedUICommand GetKnownCommand(string localName, Type ownerType);
    internal static object GetKnownControlCommand(Type ownerType, string commandName);
}
internal class System.Windows.Input.CommandValueSerializer : ValueSerializer {
    public virtual bool CanConvertToString(object value, IValueSerializerContext context);
    public virtual bool CanConvertFromString(string value, IValueSerializerContext context);
    public virtual string ConvertToString(object value, IValueSerializerContext context);
    public virtual IEnumerable`1<Type> TypeReferences(object value, IValueSerializerContext context);
    public virtual object ConvertFromString(string value, IValueSerializerContext context);
}
public class System.Windows.Input.KeyboardNavigation : object {
    private static DependencyProperty TabOnceActiveElementProperty;
    internal static DependencyProperty ControlTabOnceActiveElementProperty;
    internal static DependencyProperty DirectionalNavigationMarginProperty;
    public static DependencyProperty TabIndexProperty;
    public static DependencyProperty IsTabStopProperty;
    [CustomCategoryAttribute("Accessibility")]
[LocalizabilityAttribute("17")]
[CommonDependencyPropertyAttribute]
public static DependencyProperty TabNavigationProperty;
    [CommonDependencyPropertyAttribute]
[LocalizabilityAttribute("17")]
[CustomCategoryAttribute("Accessibility")]
public static DependencyProperty ControlTabNavigationProperty;
    [LocalizabilityAttribute("17")]
[CustomCategoryAttribute("Accessibility")]
[CommonDependencyPropertyAttribute]
public static DependencyProperty DirectionalNavigationProperty;
    internal static DependencyProperty ShowKeyboardCuesProperty;
    public static DependencyProperty AcceptsReturnProperty;
    private WeakReferenceList _weakFocusChangedHandlers;
    private static bool _alwaysShowFocusVisual;
    private FocusVisualAdorner _focusVisualAdornerCache;
    private Key _lastKeyPressed;
    private WeakReferenceList _weakEnterMenuModeHandlers;
    private bool _win32MenuModeWorkAround;
    private WeakReferenceList _weakFocusEnterMainFocusScopeHandlers;
    private static double BASELINE_DEFAULT;
    private double _verticalBaseline;
    private double _horizontalBaseline;
    private DependencyProperty _navigationProperty;
    private Hashtable _containerHashtable;
    private static object _fakeNull;
    internal static bool AlwaysShowFocusVisual { get; internal set; }
    internal static KeyboardNavigation Current { get; }
    private static KeyboardNavigation();
    internal static DependencyObject GetTabOnceActiveElement(DependencyObject d);
    internal static void SetTabOnceActiveElement(DependencyObject d, DependencyObject value);
    private static DependencyObject GetControlTabOnceActiveElement(DependencyObject d);
    private static void SetControlTabOnceActiveElement(DependencyObject d, DependencyObject value);
    private DependencyObject GetActiveElement(DependencyObject d);
    private void SetActiveElement(DependencyObject d, DependencyObject value);
    internal static Visual GetVisualRoot(DependencyObject d);
    private static object CoerceShowKeyboardCues(DependencyObject d, object value);
    internal void add_FocusChanged(KeyboardFocusChangedEventHandler value);
    internal void remove_FocusChanged(KeyboardFocusChangedEventHandler value);
    internal void NotifyFocusChanged(object sender, KeyboardFocusChangedEventArgs e);
    public static void SetTabIndex(DependencyObject element, int index);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static int GetTabIndex(DependencyObject element);
    public static void SetIsTabStop(DependencyObject element, bool isTabStop);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static bool GetIsTabStop(DependencyObject element);
    public static void SetTabNavigation(DependencyObject element, KeyboardNavigationMode mode);
    [CustomCategoryAttribute("Accessibility")]
[AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static KeyboardNavigationMode GetTabNavigation(DependencyObject element);
    public static void SetControlTabNavigation(DependencyObject element, KeyboardNavigationMode mode);
    [CustomCategoryAttribute("Accessibility")]
[AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static KeyboardNavigationMode GetControlTabNavigation(DependencyObject element);
    public static void SetDirectionalNavigation(DependencyObject element, KeyboardNavigationMode mode);
    [CustomCategoryAttribute("Accessibility")]
[AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static KeyboardNavigationMode GetDirectionalNavigation(DependencyObject element);
    public static void SetAcceptsReturn(DependencyObject element, bool enabled);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static bool GetAcceptsReturn(DependencyObject element);
    private static bool IsValidKeyNavigationMode(object o);
    internal static UIElement GetParentUIElementFromContentElement(ContentElement ce);
    private static UIElement GetParentUIElementFromContentElement(ContentElement ce, IContentHost& ichParent);
    internal void HideFocusVisual();
    internal static bool IsKeyboardMostRecentInputDevice();
    internal static bool get_AlwaysShowFocusVisual();
    internal static void set_AlwaysShowFocusVisual(bool value);
    internal static void ShowFocusVisual();
    private void ShowFocusVisual(DependencyObject element);
    internal static void UpdateFocusedElement(DependencyObject focusTarget);
    internal void UpdateActiveElement(DependencyObject activeElement);
    private void UpdateActiveElement(DependencyObject activeElement, DependencyProperty dp);
    internal void UpdateActiveElement(DependencyObject container, DependencyObject activeElement);
    private void UpdateActiveElement(DependencyObject container, DependencyObject activeElement, DependencyProperty dp);
    internal bool Navigate(DependencyObject currentElement, TraversalRequest request);
    private bool Navigate(DependencyObject currentElement, TraversalRequest request, ModifierKeys modifierKeys, bool fromProcessInputTabKey);
    private bool Navigate(DependencyObject currentElement, TraversalRequest request, ModifierKeys modifierKeys, DependencyObject firstElement, bool fromProcessInputTabKey);
    private bool NavigateOutsidePresentationSource(DependencyObject currentElement, TraversalRequest request, bool fromProcessInput, Boolean& shouldCycle);
    private bool ShouldNavigateOutsidePresentationSource(DependencyObject currentElement, TraversalRequest request);
    internal static KeyboardNavigation get_Current();
    private void PostProcessInput(object sender, ProcessInputEventArgs e);
    private void TranslateAccelerator(object sender, KeyEventArgs e);
    private void ProcessInput(InputEventArgs inputEventArgs);
    internal static void EnableKeyboardCues(DependencyObject element, bool enable);
    internal static FocusNavigationDirection KeyToTraversalDirection(Key key);
    internal DependencyObject PredictFocusedElement(DependencyObject sourceElement, FocusNavigationDirection direction);
    internal DependencyObject PredictFocusedElement(DependencyObject sourceElement, FocusNavigationDirection direction, bool treeViewNavigation);
    internal DependencyObject PredictFocusedElement(DependencyObject sourceElement, FocusNavigationDirection direction, bool treeViewNavigation, bool considerDescendants);
    internal DependencyObject PredictFocusedElementAtViewportEdge(DependencyObject sourceElement, FocusNavigationDirection direction, bool treeViewNavigation, FrameworkElement viewportBoundsElement, DependencyObject container);
    private DependencyObject PredictFocusedElementAtViewportEdgeRecursive(DependencyObject sourceElement, FocusNavigationDirection direction, bool treeViewNavigation, FrameworkElement viewportBoundsElement, DependencyObject container);
    internal bool Navigate(DependencyObject sourceElement, Key key, ModifierKeys modifiers, bool fromProcessInput);
    private static bool IsInNavigationTree(DependencyObject visual);
    private DependencyObject GetPreviousSibling(DependencyObject e);
    private DependencyObject GetNextSibling(DependencyObject e);
    private DependencyObject FocusedElement(DependencyObject e);
    private DependencyObject GetFirstChild(DependencyObject e);
    private DependencyObject GetLastChild(DependencyObject e);
    internal static DependencyObject GetParent(DependencyObject e);
    private DependencyObject GetNextInTree(DependencyObject e, DependencyObject container);
    private DependencyObject GetPreviousInTree(DependencyObject e, DependencyObject container);
    private DependencyObject GetLastInTree(DependencyObject container);
    private DependencyObject GetGroupParent(DependencyObject e);
    private DependencyObject GetGroupParent(DependencyObject e, bool includeCurrent);
    private bool IsTabStop(DependencyObject e);
    private bool IsGroup(DependencyObject e);
    internal bool IsFocusableInternal(DependencyObject element);
    private bool IsElementEligible(DependencyObject element, bool treeViewNavigation);
    private bool IsGroupElementEligible(DependencyObject element, bool treeViewNavigation);
    private KeyboardNavigationMode GetKeyNavigationMode(DependencyObject e);
    private bool IsTabStopOrGroup(DependencyObject e);
    private static int GetTabIndexHelper(DependencyObject d);
    internal DependencyObject GetFirstTabInGroup(DependencyObject container);
    private DependencyObject GetNextTabWithSameIndex(DependencyObject e, DependencyObject container);
    private DependencyObject GetNextTabWithNextIndex(DependencyObject e, DependencyObject container, KeyboardNavigationMode tabbingType);
    private DependencyObject GetNextTabInGroup(DependencyObject e, DependencyObject container, KeyboardNavigationMode tabbingType);
    private DependencyObject GetNextTab(DependencyObject e, DependencyObject container, bool goDownOnly);
    internal DependencyObject GetLastTabInGroup(DependencyObject container);
    private DependencyObject GetPrevTabWithSameIndex(DependencyObject e, DependencyObject container);
    private DependencyObject GetPrevTabWithPrevIndex(DependencyObject e, DependencyObject container, KeyboardNavigationMode tabbingType);
    private DependencyObject GetPrevTabInGroup(DependencyObject e, DependencyObject container, KeyboardNavigationMode tabbingType);
    private DependencyObject GetPrevTab(DependencyObject e, DependencyObject container, bool goDownOnly);
    internal static Rect GetRectangle(DependencyObject element);
    private Rect GetRepresentativeRectangle(DependencyObject element);
    private double GetDistance(Point p1, Point p2);
    private double GetPerpDistance(Rect sourceRect, Rect targetRect, FocusNavigationDirection direction);
    private double GetDistance(Rect sourceRect, Rect targetRect, FocusNavigationDirection direction);
    private bool IsInDirection(Rect fromRect, Rect toRect, FocusNavigationDirection direction);
    private bool IsFocusScope(DependencyObject e);
    private bool IsAncestorOf(DependencyObject sourceElement, DependencyObject targetElement);
    internal bool IsAncestorOfEx(DependencyObject sourceElement, DependencyObject targetElement);
    private bool IsInRange(DependencyObject sourceElement, DependencyObject targetElement, Rect sourceRect, Rect targetRect, FocusNavigationDirection direction, double startRange, double endRange);
    private DependencyObject GetNextInDirection(DependencyObject sourceElement, FocusNavigationDirection direction);
    private DependencyObject GetNextInDirection(DependencyObject sourceElement, FocusNavigationDirection direction, bool treeViewNavigation);
    private DependencyObject GetNextInDirection(DependencyObject sourceElement, FocusNavigationDirection direction, bool treeViewNavigation, bool considerDescendants);
    private void OnLayoutUpdated(object sender, EventArgs e);
    private void _LostFocus(object sender, KeyboardFocusChangedEventArgs e);
    private bool IsEndlessLoop(DependencyObject element, DependencyObject container);
    private void ResetBaseLines(double value, bool horizontalDirection);
    private DependencyObject FindNextInDirection(DependencyObject sourceElement, Rect sourceRect, DependencyObject container, FocusNavigationDirection direction, double startRange, double endRange, bool treeViewNavigation, bool considerDescendants);
    private DependencyObject MoveNext(DependencyObject sourceElement, DependencyObject container, FocusNavigationDirection direction, double startRange, double endRange, bool treeViewNavigation, bool considerDescendants);
    private DependencyObject GetActiveElementChain(DependencyObject element, bool treeViewNavigation);
    private DependencyObject FindElementAtViewportEdge(DependencyObject sourceElement, FrameworkElement viewportBoundsElement, DependencyObject container, FocusNavigationDirection direction, bool treeViewNavigation);
    private double ComputeRangeScore(double rangeStart1, double rangeEnd1, double rangeStart2, double rangeEnd2);
    private void ProcessForMenuMode(InputEventArgs inputEventArgs);
    private bool IsMenuKey(Key key);
    private Key GetRealKey(KeyEventArgs e);
    private bool OnEnterMenuMode(object eventSource);
    internal void add_EnterMenuMode(EnterMenuModeEventHandler value);
    internal void remove_EnterMenuMode(EnterMenuModeEventHandler value);
    private void ProcessForUIState(InputEventArgs inputEventArgs);
    private RawUIStateInputReport ExtractRawUIStateInputReport(InputEventArgs e, RoutedEvent Event);
    internal void add_FocusEnterMainFocusScope(EventHandler value);
    internal void remove_FocusEnterMainFocusScope(EventHandler value);
    private void NotifyFocusEnterMainFocusScope(object sender, EventArgs e);
}
public enum System.Windows.Input.KeyboardNavigationMode : Enum {
    public int value__;
    public static KeyboardNavigationMode Continue;
    public static KeyboardNavigationMode Once;
    public static KeyboardNavigationMode Cycle;
    public static KeyboardNavigationMode None;
    public static KeyboardNavigationMode Contained;
    public static KeyboardNavigationMode Local;
}
internal enum System.Windows.InstanceStyleData : Enum {
    public int value__;
    public static InstanceStyleData InstanceValues;
    public static InstanceStyleData ArraySize;
}
internal class System.Windows.InstanceValueKey : object {
    private int _childIndex;
    private int _dpIndex;
    private int _index;
    internal InstanceValueKey(int childIndex, int dpIndex, int index);
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
}
internal enum System.Windows.InternalFlags : Enum {
    public UInt32 value__;
    public static InternalFlags HasResourceReferences;
    public static InternalFlags HasNumberSubstitutionChanged;
    public static InternalFlags HasImplicitStyleFromResources;
    public static InternalFlags InheritanceBehavior0;
    public static InternalFlags InheritanceBehavior1;
    public static InternalFlags InheritanceBehavior2;
    public static InternalFlags IsStyleUpdateInProgress;
    public static InternalFlags IsThemeStyleUpdateInProgress;
    public static InternalFlags StoresParentTemplateValues;
    public static InternalFlags NeedsClipBounds;
    public static InternalFlags HasWidthEverChanged;
    public static InternalFlags HasHeightEverChanged;
    public static InternalFlags IsInitialized;
    public static InternalFlags InitPending;
    public static InternalFlags IsResourceParentValid;
    public static InternalFlags AncestorChangeInProgress;
    public static InternalFlags InVisibilityCollapsedTree;
    public static InternalFlags HasStyleEverBeenFetched;
    public static InternalFlags HasThemeStyleEverBeenFetched;
    public static InternalFlags HasLocalStyle;
    public static InternalFlags HasTemplateGeneratedSubTree;
    public static InternalFlags HasLogicalChildren;
    public static InternalFlags IsLogicalChildrenIterationInProgress;
    public static InternalFlags CreatingRoot;
    public static InternalFlags IsRightToLeft;
    public static InternalFlags ShouldLookupImplicitStyles;
    public static InternalFlags PotentiallyHasMentees;
}
[FlagsAttribute]
internal enum System.Windows.InternalFlags2 : Enum {
    public UInt32 value__;
    public static InternalFlags2 R0;
    public static InternalFlags2 R1;
    public static InternalFlags2 R2;
    public static InternalFlags2 R3;
    public static InternalFlags2 R4;
    public static InternalFlags2 R5;
    public static InternalFlags2 R6;
    public static InternalFlags2 R7;
    public static InternalFlags2 R8;
    public static InternalFlags2 R9;
    public static InternalFlags2 RA;
    public static InternalFlags2 RB;
    public static InternalFlags2 RC;
    public static InternalFlags2 RD;
    public static InternalFlags2 RE;
    public static InternalFlags2 RF;
    public static InternalFlags2 TreeHasLoadedChangeHandler;
    public static InternalFlags2 IsLoadedCache;
    public static InternalFlags2 IsStyleSetFromGenerator;
    public static InternalFlags2 IsParentAnFE;
    public static InternalFlags2 IsTemplatedParentAnFE;
    public static InternalFlags2 HasStyleChanged;
    public static InternalFlags2 HasTemplateChanged;
    public static InternalFlags2 HasStyleInvalidated;
    public static InternalFlags2 IsRequestingExpression;
    public static InternalFlags2 HasMultipleInheritanceContexts;
    public static InternalFlags2 BypassLayoutPolicies;
    public static InternalFlags2 Default;
}
public class System.Windows.Interop.ActiveXHost : HwndHost {
    internal static DependencyProperty TabIndexProperty;
    private static Hashtable invalidatorMap;
    private COMRECT _bounds;
    private Rect _boundRect;
    private Size _cachedSize;
    private HandleRef _hwndParent;
    private bool _isDisposed;
    private SecurityCriticalDataForSet`1<Guid> _clsid;
    private HandleRef _axWindow;
    private BitVector32 _axHostState;
    private ActiveXState _axState;
    private ActiveXSite _axSite;
    private ActiveXContainer _axContainer;
    private object _axInstance;
    private IOleObject _axOleObject;
    private IOleInPlaceObject _axOleInPlaceObject;
    private IOleInPlaceActiveObject _axOleInPlaceActiveObject;
    protected bool IsDisposed { get; }
    internal ActiveXSite ActiveXSite { get; }
    internal ActiveXContainer Container { get; }
    internal ActiveXState ActiveXState { get; internal set; }
    internal int TabIndex { get; internal set; }
    internal HandleRef ParentHandle { get; internal set; }
    internal COMRECT Bounds { get; internal set; }
    internal Rect BoundRect { get; }
    internal HandleRef ControlHandle { get; }
    internal object ActiveXInstance { get; }
    internal IOleInPlaceObject ActiveXInPlaceObject { get; }
    internal IOleInPlaceActiveObject ActiveXInPlaceActiveObject { get; }
    private static ActiveXHost();
    internal ActiveXHost(Guid clsid, bool fTrusted);
    protected virtual void OnPropertyChanged(DependencyPropertyChangedEventArgs e);
    protected virtual HandleRef BuildWindowCore(HandleRef hwndParent);
    protected virtual void OnWindowPositionChanged(Rect bounds);
    protected virtual void DestroyWindowCore(HandleRef hwnd);
    protected virtual Size MeasureOverride(Size swConstraint);
    protected virtual void OnAccessKey(AccessKeyEventArgs args);
    protected virtual void Dispose(bool disposing);
    internal virtual ActiveXSite CreateActiveXSite();
    internal virtual object CreateActiveXObject(Guid clsid);
    internal virtual void AttachInterfaces(object nativeActiveXObject);
    internal virtual void DetachInterfaces();
    internal virtual void CreateSink();
    internal virtual void DetachSink();
    internal virtual void OnActiveXStateChange(int oldState, int newState);
    protected bool get_IsDisposed();
    internal void RegisterAccessKey(char key);
    internal ActiveXSite get_ActiveXSite();
    internal ActiveXContainer get_Container();
    internal ActiveXState get_ActiveXState();
    internal void set_ActiveXState(ActiveXState value);
    internal bool GetAxHostState(int mask);
    internal void SetAxHostState(int mask, bool value);
    internal void TransitionUpTo(ActiveXState state);
    internal void TransitionDownTo(ActiveXState state);
    internal bool DoVerb(int verb);
    internal void AttachWindow(IntPtr hwnd);
    private void StartEvents();
    private void StopEvents();
    private void TransitionFromPassiveToLoaded();
    private void TransitionFromLoadedToPassive();
    private void TransitionFromLoadedToRunning();
    private void TransitionFromRunningToLoaded();
    private void TransitionFromRunningToInPlaceActive();
    private void TransitionFromInPlaceActiveToRunning();
    private void TransitionFromInPlaceActiveToUIActive();
    private void TransitionFromUIActiveToInPlaceActive();
    internal int get_TabIndex();
    internal void set_TabIndex(int value);
    internal HandleRef get_ParentHandle();
    internal void set_ParentHandle(HandleRef value);
    internal COMRECT get_Bounds();
    internal void set_Bounds(COMRECT value);
    internal Rect get_BoundRect();
    internal HandleRef get_ControlHandle();
    internal object get_ActiveXInstance();
    internal IOleInPlaceObject get_ActiveXInPlaceObject();
    internal IOleInPlaceActiveObject get_ActiveXInPlaceActiveObject();
    private void OnInitialized(object sender, EventArgs e);
    private static void OnIsEnabledInvalidated(ActiveXHost axHost);
    private static void OnVisibilityInvalidated(ActiveXHost axHost);
    private static void OnGotFocus(object sender, KeyboardFocusChangedEventArgs e);
    private static void OnLostFocus(object sender, KeyboardFocusChangedEventArgs e);
    private static void OnAccessKeyPressed(object sender, AccessKeyPressedEventArgs args);
    private void AttachInterfacesInternal();
    private void DetachInterfacesInternal();
    private SIZE SetExtent(int width, int height);
    private SIZE GetExtent();
}
public static class System.Windows.Interop.BrowserInteropHelper : object {
    private static SecurityCriticalDataForSet`1<HostingFlags> _hostingFlags;
    private static SecurityCriticalDataForSet`1<bool> _isInitialViewerNavigation;
    private static SecurityCriticalDataForSet`1<Nullable`1<bool>> _isScriptInteropDisabled;
    private static SecurityCriticalDataForSet`1<IServiceProvider> _hostHtmlDocumentServiceProvider;
    private static SecurityCriticalDataForSet`1<bool> _initializedHostScript;
    public static object ClientSite { get; }
    [DynamicAttribute]
public static object HostScript { get; }
    public static bool IsBrowserHosted { get; }
    internal static HostingFlags HostingFlags { get; internal set; }
    public static Uri Source { get; }
    internal static bool IsViewer { get; }
    internal static bool IsHostedInIEorWebOC { get; }
    internal static bool IsInitialViewerNavigation { get; internal set; }
    internal static IServiceProvider HostHtmlDocumentServiceProvider { get; }
    private static BrowserInteropHelper();
    public static object get_ClientSite();
    public static object get_HostScript();
    public static bool get_IsBrowserHosted();
    internal static HostingFlags get_HostingFlags();
    internal static void set_HostingFlags(HostingFlags value);
    public static Uri get_Source();
    internal static bool get_IsViewer();
    internal static bool get_IsHostedInIEorWebOC();
    internal static bool get_IsInitialViewerNavigation();
    internal static void set_IsInitialViewerNavigation(bool value);
    internal static IServiceProvider get_HostHtmlDocumentServiceProvider();
    private static void InitializeHostHtmlDocumentServiceProvider(DynamicScriptObject scriptObject);
    private static void HostFilterInput(MSG& msg, Boolean& handled);
    internal static IntPtr PostFilterInput(IntPtr hwnd, int msg, IntPtr wParam, IntPtr lParam, Boolean& handled);
    internal static void InitializeHostFilterInput();
    private static void EnsureScriptInteropAllowed();
    private static int ForwardTranslateAccelerator(MSG& pMsg, bool appUnhandled);
}
public class System.Windows.Interop.DynamicScriptObject : DynamicObject {
    private IDispatch _scriptObject;
    private IDispatchEx _scriptObjectEx;
    private Dictionary`2<string, int> _dispIdCache;
    internal IDispatch ScriptObject { get; }
    internal DynamicScriptObject(IDispatch scriptObject);
    public virtual bool TryInvokeMember(InvokeMemberBinder binder, Object[] args, Object& result);
    public virtual bool TryGetMember(GetMemberBinder binder, Object& result);
    public virtual bool TrySetMember(SetMemberBinder binder, object value);
    public virtual bool TryGetIndex(GetIndexBinder binder, Object[] indexes, Object& result);
    public virtual bool TrySetIndex(SetIndexBinder binder, Object[] indexes, object value);
    public virtual bool TryInvoke(InvokeBinder binder, Object[] args, Object& result);
    public virtual string ToString();
    internal IDispatch get_ScriptObject();
    internal bool TryFindMemberAndInvokeNonWrapped(string memberName, int flags, bool cacheDispId, Object[] args, Object& result);
    private object InvokeAndReturn(string memberName, int flags, Object[] args);
    private object InvokeAndReturn(string memberName, int flags, bool cacheDispId, Object[] args);
    private bool TryFindMemberAndInvoke(string memberName, int flags, bool cacheDispId, Object[] args, Object& result);
    private bool TryGetDispIdForMember(string memberName, bool cacheDispId, Int32& dispid);
    private HRESULT InvokeOnScriptObject(int dispid, int flags, DISPPARAMS dp, EXCEPINFO exInfo, Object& result);
    private static int GetPropertyPutMethod(object value);
}
public abstract class System.Windows.Interop.HwndHost : FrameworkElement {
    public static RoutedEvent DpiChangedEvent;
    [CompilerGeneratedAttribute]
private IKeyboardInputSite <System.Windows.Interop.IKeyboardInputSink.KeyboardInputSite>k__BackingField;
    private DependencyPropertyChangedEventHandler _handlerEnabledChanged;
    private DependencyPropertyChangedEventHandler _handlerVisibleChanged;
    private EventHandler _handlerLayoutUpdated;
    private HwndSubclass _hwndSubclass;
    private HwndWrapperHook _hwndSubclassHook;
    private HandleRef _hwnd;
    private ArrayList _hooks;
    private Size _desiredSize;
    private bool _hasDpiAwarenessContextTransition;
    private SecurityCriticalDataForSet`1<bool> _fTrusted;
    private bool _isBuildingWindow;
    private bool _isDisposed;
    private WeakEventDispatcherShutdown _weakEventDispatcherShutdown;
    public IntPtr Handle { get; }
    private IKeyboardInputSite System.Windows.Interop.IKeyboardInputSink.KeyboardInputSite { get; private set; }
    private double DpiParentToChildRatio { get; }
    internal IntPtr CriticalHandle { get; }
    private static HwndHost();
    internal HwndHost(bool fTrusted);
    protected virtual override void Finalize();
    public sealed virtual void Dispose();
    public sealed virtual IntPtr get_Handle();
    public void add_MessageHook(HwndSourceHook value);
    public void remove_MessageHook(HwndSourceHook value);
    public void add_DpiChanged(DpiChangedEventHandler value);
    public void remove_DpiChanged(DpiChangedEventHandler value);
    protected virtual void OnKeyUp(KeyEventArgs e);
    protected virtual void OnDpiChanged(DpiScale oldDpi, DpiScale newDpi);
    protected virtual void OnKeyDown(KeyEventArgs e);
    protected virtual IKeyboardInputSite RegisterKeyboardInputSinkCore(IKeyboardInputSink sink);
    private sealed virtual override IKeyboardInputSite System.Windows.Interop.IKeyboardInputSink.RegisterKeyboardInputSink(IKeyboardInputSink sink);
    protected virtual bool TranslateAcceleratorCore(MSG& msg, ModifierKeys modifiers);
    private sealed virtual override bool System.Windows.Interop.IKeyboardInputSink.TranslateAccelerator(MSG& msg, ModifierKeys modifiers);
    protected virtual bool TabIntoCore(TraversalRequest request);
    private sealed virtual override bool System.Windows.Interop.IKeyboardInputSink.TabInto(TraversalRequest request);
    [CompilerGeneratedAttribute]
private sealed virtual override IKeyboardInputSite System.Windows.Interop.IKeyboardInputSink.get_KeyboardInputSite();
    [CompilerGeneratedAttribute]
private sealed virtual override void System.Windows.Interop.IKeyboardInputSink.set_KeyboardInputSite(IKeyboardInputSite value);
    protected virtual bool OnMnemonicCore(MSG& msg, ModifierKeys modifiers);
    private sealed virtual override bool System.Windows.Interop.IKeyboardInputSink.OnMnemonic(MSG& msg, ModifierKeys modifiers);
    protected virtual bool TranslateCharCore(MSG& msg, ModifierKeys modifiers);
    private sealed virtual override bool System.Windows.Interop.IKeyboardInputSink.TranslateChar(MSG& msg, ModifierKeys modifiers);
    protected virtual bool HasFocusWithinCore();
    private sealed virtual override bool System.Windows.Interop.IKeyboardInputSink.HasFocusWithin();
    public void UpdateWindowPos();
    private RECT CalculateAssignedRC(PresentationSource source);
    private double get_DpiParentToChildRatio();
    private RECT AdjustRectForDpi(RECT rcRect);
    protected virtual void Dispose(bool disposing);
    private void OnDispatcherShutdown(object sender, EventArgs e);
    protected abstract virtual HandleRef BuildWindowCore(HandleRef hwndParent);
    protected abstract virtual void DestroyWindowCore(HandleRef hwnd);
    protected virtual IntPtr WndProc(IntPtr hwnd, int msg, IntPtr wParam, IntPtr lParam, Boolean& handled);
    protected virtual AutomationPeer OnCreateAutomationPeer();
    private IntPtr OnWmGetObject(IntPtr wparam, IntPtr lparam);
    protected virtual void OnWindowPositionChanged(Rect rcBoundingBox);
    protected virtual Size MeasureOverride(Size constraint);
    internal virtual DrawingGroup GetDrawing();
    internal virtual Rect GetContentBounds();
    private DrawingGroup GetDrawingHelper();
    private void Initialize(bool fTrusted);
    private void DemandIfUntrusted();
    private void OnSourceChanged(object sender, SourceChangedEventArgs e);
    private void OnLayoutUpdated(object sender, EventArgs e);
    private void OnEnabledChanged(object sender, DependencyPropertyChangedEventArgs e);
    private void OnVisibleChanged(object sender, DependencyPropertyChangedEventArgs e);
    private void BuildOrReparentWindow();
    private void BuildWindow(HandleRef hwndParent);
    private void DestroyWindow();
    private object AsyncDestroyWindow(object arg);
    internal IntPtr get_CriticalHandle();
    private IntPtr SubclassWndProc(IntPtr hwnd, int msg, IntPtr wParam, IntPtr lParam, Boolean& handled);
}
public interface System.Windows.Interop.IErrorPage {
    public Uri DeploymentPath { get; public set; }
    public string ErrorTitle { get; public set; }
    public string ErrorText { get; public set; }
    public bool ErrorFlag { get; public set; }
    public string LogFilePath { get; public set; }
    public Uri SupportUri { get; public set; }
    public DispatcherOperationCallback RefreshCallback { get; public set; }
    public DispatcherOperationCallback GetWinFxCallback { get; public set; }
    public abstract virtual Uri get_DeploymentPath();
    public abstract virtual void set_DeploymentPath(Uri value);
    public abstract virtual string get_ErrorTitle();
    public abstract virtual void set_ErrorTitle(string value);
    public abstract virtual string get_ErrorText();
    public abstract virtual void set_ErrorText(string value);
    public abstract virtual bool get_ErrorFlag();
    public abstract virtual void set_ErrorFlag(bool value);
    public abstract virtual string get_LogFilePath();
    public abstract virtual void set_LogFilePath(string value);
    public abstract virtual Uri get_SupportUri();
    public abstract virtual void set_SupportUri(Uri value);
    public abstract virtual DispatcherOperationCallback get_RefreshCallback();
    public abstract virtual void set_RefreshCallback(DispatcherOperationCallback value);
    public abstract virtual DispatcherOperationCallback get_GetWinFxCallback();
    public abstract virtual void set_GetWinFxCallback(DispatcherOperationCallback value);
}
public interface System.Windows.Interop.IProgressPage {
    public Uri DeploymentPath { get; public set; }
    public DispatcherOperationCallback StopCallback { get; public set; }
    public DispatcherOperationCallback RefreshCallback { get; public set; }
    public string ApplicationName { get; public set; }
    public string PublisherName { get; public set; }
    public abstract virtual Uri get_DeploymentPath();
    public abstract virtual void set_DeploymentPath(Uri value);
    public abstract virtual DispatcherOperationCallback get_StopCallback();
    public abstract virtual void set_StopCallback(DispatcherOperationCallback value);
    public abstract virtual DispatcherOperationCallback get_RefreshCallback();
    public abstract virtual void set_RefreshCallback(DispatcherOperationCallback value);
    public abstract virtual string get_ApplicationName();
    public abstract virtual void set_ApplicationName(string value);
    public abstract virtual string get_PublisherName();
    public abstract virtual void set_PublisherName(string value);
    public abstract virtual void UpdateProgress(long bytesDownloaded, long bytesTotal);
}
public class System.Windows.Interop.WindowInteropHelper : object {
    private Window _window;
    public IntPtr Handle { get; }
    internal IntPtr CriticalHandle { get; }
    public IntPtr Owner { get; public set; }
    public WindowInteropHelper(Window window);
    public IntPtr get_Handle();
    internal IntPtr get_CriticalHandle();
    public IntPtr get_Owner();
    public void set_Owner(IntPtr value);
    public IntPtr EnsureHandle();
}
internal interface System.Windows.IWindowService {
    public string Title { get; public set; }
    public double Height { get; public set; }
    public double Width { get; public set; }
    public bool UserResized { get; }
    public abstract virtual string get_Title();
    public abstract virtual void set_Title(string value);
    public abstract virtual double get_Height();
    public abstract virtual void set_Height(double value);
    public abstract virtual double get_Width();
    public abstract virtual void set_Width(double value);
    public abstract virtual bool get_UserResized();
}
internal static class System.Windows.LayoutDoubleUtil : object {
    private static double eps;
    internal static bool AreClose(double value1, double value2);
    internal static bool LessThan(double value1, double value2);
}
public class System.Windows.LengthConverter : TypeConverter {
    private static String[] PixelUnitStrings;
    private static Double[] PixelUnitFactors;
    private static LengthConverter();
    public virtual bool CanConvertFrom(ITypeDescriptorContext typeDescriptorContext, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext typeDescriptorContext, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext typeDescriptorContext, CultureInfo cultureInfo, object source);
    public virtual object ConvertTo(ITypeDescriptorContext typeDescriptorContext, CultureInfo cultureInfo, object value, Type destinationType);
    internal static double FromString(string s, CultureInfo cultureInfo);
    internal static string ToString(double l, CultureInfo cultureInfo);
}
public enum System.Windows.LineStackingStrategy : Enum {
    public int value__;
    public static LineStackingStrategy BlockLineHeight;
    public static LineStackingStrategy MaxHeight;
}
public static class System.Windows.Localization : object {
    public static DependencyProperty CommentsProperty;
    public static DependencyProperty AttributesProperty;
    private static ConditionalWeakTable`2<object, string> _commentsOnObjects;
    private static ConditionalWeakTable`2<object, string> _attributesOnObjects;
    private static Localization();
    [AttachedPropertyBrowsableForTypeAttribute("System.Object")]
public static string GetComments(object element);
    public static void SetComments(object element, string comments);
    [AttachedPropertyBrowsableForTypeAttribute("System.Object")]
public static string GetAttributes(object element);
    public static void SetAttributes(object element, string attributes);
    private static string GetValue(object element, DependencyProperty property);
    private static void SetValue(object element, DependencyProperty property, string value);
}
internal enum System.Windows.LogicalOp : Enum {
    public int value__;
    public static LogicalOp Equals;
    public static LogicalOp NotEquals;
}
public static class System.Windows.LogicalTreeHelper : object {
    public static DependencyObject FindLogicalNode(DependencyObject logicalTreeNode, string elementName);
    public static DependencyObject GetParent(DependencyObject current);
    public static IEnumerable GetChildren(DependencyObject current);
    public static IEnumerable GetChildren(FrameworkElement current);
    public static IEnumerable GetChildren(FrameworkContentElement current);
    public static void BringIntoView(DependencyObject current);
    internal static void AddLogicalChild(DependencyObject parent, object child);
    internal static void AddLogicalChild(FrameworkElement parentFE, FrameworkContentElement parentFCE, object child);
    internal static void RemoveLogicalChild(DependencyObject parent, object child);
    internal static void RemoveLogicalChild(FrameworkElement parentFE, FrameworkContentElement parentFCE, object child);
    internal static IEnumerator GetLogicalChildren(DependencyObject current);
}
public class System.Windows.LostFocusEventManager : WeakEventManager {
    private static LostFocusEventManager CurrentManager { get; }
    public static void AddListener(DependencyObject source, IWeakEventListener listener);
    public static void RemoveListener(DependencyObject source, IWeakEventListener listener);
    public static void AddHandler(DependencyObject source, EventHandler`1<RoutedEventArgs> handler);
    public static void RemoveHandler(DependencyObject source, EventHandler`1<RoutedEventArgs> handler);
    protected virtual ListenerList NewListenerList();
    protected virtual void StartListening(object source);
    protected virtual void StopListening(object source);
    private static LostFocusEventManager get_CurrentManager();
    private void OnLostFocus(object sender, RoutedEventArgs args);
}
internal class System.Windows.Markup.AssemblyInfoKey : ValueType {
    internal string AssemblyFullName;
    public virtual bool Equals(object o);
    public static bool op_Equality(AssemblyInfoKey key1, AssemblyInfoKey key2);
    public static bool op_Inequality(AssemblyInfoKey key1, AssemblyInfoKey key2);
    public virtual int GetHashCode();
    public virtual string ToString();
}
internal enum System.Windows.Markup.AttributeContext : Enum {
    public int value__;
    public static AttributeContext Unknown;
    public static AttributeContext Property;
    public static AttributeContext RoutedEvent;
    public static AttributeContext ClrEvent;
    public static AttributeContext Code;
}
internal class System.Windows.Markup.AttributeData : DefAttributeData {
    internal string PropertyName;
    internal Type SerializerType;
    internal short ExtensionTypeId;
    internal bool IsValueNestedExtension;
    internal bool IsValueTypeExtension;
    internal object Info;
    internal bool IsTypeExtension { get; }
    internal bool IsStaticExtension { get; }
    internal AttributeData(string targetAssemblyName, string targetFullName, Type targetType, string args, Type declaringType, string propertyName, object info, Type serializerType, int lineNumber, int linePosition, int depth, string targetNamespaceUri, short extensionTypeId, bool isValueNestedExtension, bool isValueTypeExtension, bool isSimple);
    internal bool get_IsTypeExtension();
    internal bool get_IsStaticExtension();
}
internal class System.Windows.Markup.BamlAssemblyInfoRecord : BamlVariableSizedRecord {
    private static Section _assemblyIdLowSection;
    private static Section _assemblyIdHighSection;
    private string _assemblyFullName;
    private Assembly _assembly;
    internal short AssemblyId { get; internal set; }
    internal static Section LastFlagsSection { get; }
    internal string AssemblyFullName { get; internal set; }
    internal BamlRecordType RecordType { get; }
    internal Assembly Assembly { get; internal set; }
    private static BamlAssemblyInfoRecord();
    internal virtual void LoadRecordData(BinaryReader bamlBinaryReader);
    internal virtual void WriteRecordData(BinaryWriter bamlBinaryWriter);
    internal virtual void Copy(BamlRecord record);
    internal short get_AssemblyId();
    internal void set_AssemblyId(short value);
    internal static Section get_LastFlagsSection();
    internal string get_AssemblyFullName();
    internal void set_AssemblyFullName(string value);
    internal virtual BamlRecordType get_RecordType();
    internal Assembly get_Assembly();
    internal void set_Assembly(Assembly value);
}
internal class System.Windows.Markup.BamlAttributeInfoRecord : BamlVariableSizedRecord {
    private static Section _isInternalSection;
    private static Section _attributeUsageSection;
    private short _ownerId;
    private short _attributeId;
    private string _name;
    private Type _ownerType;
    private RoutedEvent _Event;
    private DependencyProperty _dp;
    private EventInfo _ei;
    private PropertyInfo _pi;
    private MethodInfo _smi;
    private MethodInfo _gmi;
    private object _dpOrMiOrPi;
    internal short OwnerTypeId { get; internal set; }
    internal short AttributeId { get; internal set; }
    internal string Name { get; internal set; }
    internal BamlRecordType RecordType { get; }
    internal object PropertyMember { get; internal set; }
    internal Type OwnerType { get; internal set; }
    internal RoutedEvent Event { get; internal set; }
    internal DependencyProperty DP { get; internal set; }
    internal MethodInfo AttachedPropertySetter { get; internal set; }
    internal MethodInfo AttachedPropertyGetter { get; internal set; }
    internal EventInfo EventInfo { get; internal set; }
    internal PropertyInfo PropInfo { get; internal set; }
    internal bool IsInternal { get; internal set; }
    internal BamlAttributeUsage AttributeUsage { get; internal set; }
    internal static Section LastFlagsSection { get; }
    private static BamlAttributeInfoRecord();
    internal virtual void LoadRecordData(BinaryReader bamlBinaryReader);
    internal virtual void WriteRecordData(BinaryWriter bamlBinaryWriter);
    internal virtual void Copy(BamlRecord record);
    internal short get_OwnerTypeId();
    internal void set_OwnerTypeId(short value);
    internal void set_AttributeId(short value);
    internal short get_AttributeId();
    internal string get_Name();
    internal void set_Name(string value);
    internal virtual BamlRecordType get_RecordType();
    internal Type GetPropertyType();
    internal void SetPropertyMember(object propertyMember);
    internal object GetPropertyMember(bool onlyPropInfo);
    internal object get_PropertyMember();
    internal void set_PropertyMember(object value);
    internal Type get_OwnerType();
    internal void set_OwnerType(Type value);
    internal RoutedEvent get_Event();
    internal void set_Event(RoutedEvent value);
    internal DependencyProperty get_DP();
    internal void set_DP(DependencyProperty value);
    internal MethodInfo get_AttachedPropertySetter();
    internal void set_AttachedPropertySetter(MethodInfo value);
    internal MethodInfo get_AttachedPropertyGetter();
    internal void set_AttachedPropertyGetter(MethodInfo value);
    internal EventInfo get_EventInfo();
    internal void set_EventInfo(EventInfo value);
    internal PropertyInfo get_PropInfo();
    internal void set_PropInfo(PropertyInfo value);
    internal bool get_IsInternal();
    internal void set_IsInternal(bool value);
    internal BamlAttributeUsage get_AttributeUsage();
    internal void set_AttributeUsage(BamlAttributeUsage value);
    internal static Section get_LastFlagsSection();
    public virtual string ToString();
}
internal enum System.Windows.Markup.BamlAttributeUsage : Enum {
    public short value__;
    public static BamlAttributeUsage Default;
    public static BamlAttributeUsage XmlLang;
    public static BamlAttributeUsage XmlSpace;
    public static BamlAttributeUsage RuntimeName;
}
internal class System.Windows.Markup.BamlBinaryReader : BinaryReader {
    public BamlBinaryReader(Stream stream, Encoding code);
    public int Read7BitEncodedInt();
}
internal class System.Windows.Markup.BamlBinaryWriter : BinaryWriter {
    public BamlBinaryWriter(Stream stream, Encoding code);
    public void Write7BitEncodedInt(int value);
    public static int SizeOf7bitEncodedSize(int size);
}
internal class System.Windows.Markup.BamlCollectionHolder : object {
    private object _collection;
    private object _defaultCollection;
    private short _attributeId;
    private WpfPropertyDefinition _propDef;
    private object _parent;
    private BamlRecordReader _reader;
    private IHaveResources _resourcesParent;
    private bool _readonly;
    private bool _isClosed;
    private bool _isPropertyValueSet;
    internal object Collection { get; internal set; }
    internal IList List { get; }
    internal IDictionary Dictionary { get; }
    internal ArrayExtension ArrayExt { get; }
    internal object DefaultCollection { get; }
    internal WpfPropertyDefinition PropertyDefinition { get; }
    internal Type PropertyType { get; }
    internal object Parent { get; }
    internal bool ReadOnly { get; internal set; }
    internal bool IsClosed { get; internal set; }
    internal string AttributeName { get; }
    internal BamlCollectionHolder(BamlRecordReader reader, object parent, short attributeId);
    internal BamlCollectionHolder(BamlRecordReader reader, object parent, short attributeId, bool needDefault);
    internal object get_Collection();
    internal void set_Collection(object value);
    internal IList get_List();
    internal IDictionary get_Dictionary();
    internal ArrayExtension get_ArrayExt();
    internal object get_DefaultCollection();
    internal WpfPropertyDefinition get_PropertyDefinition();
    internal Type get_PropertyType();
    internal object get_Parent();
    internal bool get_ReadOnly();
    internal void set_ReadOnly(bool value);
    internal bool get_IsClosed();
    internal void set_IsClosed(bool value);
    internal string get_AttributeName();
    internal void SetPropertyValue();
    internal void InitDefaultValue();
    private void CheckReadOnly();
}
internal class System.Windows.Markup.BamlConnectionIdRecord : BamlRecord {
    private int _connectionId;
    internal BamlRecordType RecordType { get; }
    internal int ConnectionId { get; internal set; }
    internal int RecordSize { get; internal set; }
    internal virtual void LoadRecordData(BinaryReader bamlBinaryReader);
    internal virtual void WriteRecordData(BinaryWriter bamlBinaryWriter);
    internal virtual void Copy(BamlRecord record);
    internal virtual BamlRecordType get_RecordType();
    internal int get_ConnectionId();
    internal void set_ConnectionId(int value);
    internal virtual int get_RecordSize();
    internal virtual void set_RecordSize(int value);
}
internal class System.Windows.Markup.BamlConstructorParametersEndRecord : BamlRecord {
    internal BamlRecordType RecordType { get; }
    internal virtual BamlRecordType get_RecordType();
}
internal class System.Windows.Markup.BamlConstructorParametersStartRecord : BamlRecord {
    internal BamlRecordType RecordType { get; }
    internal virtual BamlRecordType get_RecordType();
}
internal class System.Windows.Markup.BamlConstructorParameterTypeRecord : BamlRecord {
    private short _typeId;
    internal BamlRecordType RecordType { get; }
    internal short TypeId { get; internal set; }
    internal int RecordSize { get; internal set; }
    internal virtual void LoadRecordData(BinaryReader bamlBinaryReader);
    internal virtual void WriteRecordData(BinaryWriter bamlBinaryWriter);
    internal virtual void Copy(BamlRecord record);
    internal virtual BamlRecordType get_RecordType();
    internal short get_TypeId();
    internal void set_TypeId(short value);
    internal virtual int get_RecordSize();
    internal virtual void set_RecordSize(int value);
}
internal class System.Windows.Markup.BamlContentPropertyRecord : BamlRecord {
    private short _attributeId;
    internal short AttributeId { get; internal set; }
    internal BamlRecordType RecordType { get; }
    internal bool HasSerializer { get; }
    internal virtual void LoadRecordData(BinaryReader bamlBinaryReader);
    internal virtual void WriteRecordData(BinaryWriter bamlBinaryWriter);
    internal virtual void Copy(BamlRecord record);
    internal short get_AttributeId();
    internal void set_AttributeId(short value);
    internal virtual BamlRecordType get_RecordType();
    internal virtual bool get_HasSerializer();
}
internal class System.Windows.Markup.BamlDefAttributeKeyStringRecord : BamlStringValueRecord {
    private static Section _sharedSection;
    private static Section _sharedSetSection;
    internal static int ValuePositionSize;
    private int _valuePosition;
    private long _valuePositionPosition;
    private object _keyObject;
    private short _valueId;
    private Object[] _staticResourceValues;
    internal BamlRecordType RecordType { get; }
    private int System.Windows.Markup.IBamlDictionaryKey.ValuePosition { get; private set; }
    private bool System.Windows.Markup.IBamlDictionaryKey.Shared { get; private set; }
    private bool System.Windows.Markup.IBamlDictionaryKey.SharedSet { get; private set; }
    internal static Section LastFlagsSection { get; }
    private object System.Windows.Markup.IBamlDictionaryKey.KeyObject { get; private set; }
    private long System.Windows.Markup.IBamlDictionaryKey.ValuePositionPosition { get; private set; }
    internal short ValueId { get; internal set; }
    private Object[] System.Windows.Markup.IBamlDictionaryKey.StaticResourceValues { get; private set; }
    private static BamlDefAttributeKeyStringRecord();
    internal virtual void LoadRecordData(BinaryReader bamlBinaryReader);
    internal virtual void WriteRecordData(BinaryWriter bamlBinaryWriter);
    private sealed virtual override void System.Windows.Markup.IBamlDictionaryKey.UpdateValuePosition(int newPosition, BinaryWriter bamlBinaryWriter);
    internal virtual void Copy(BamlRecord record);
    internal virtual BamlRecordType get_RecordType();
    private sealed virtual override int System.Windows.Markup.IBamlDictionaryKey.get_ValuePosition();
    private sealed virtual override void System.Windows.Markup.IBamlDictionaryKey.set_ValuePosition(int value);
    private sealed virtual override bool System.Windows.Markup.IBamlDictionaryKey.get_Shared();
    private sealed virtual override void System.Windows.Markup.IBamlDictionaryKey.set_Shared(bool value);
    private sealed virtual override bool System.Windows.Markup.IBamlDictionaryKey.get_SharedSet();
    private sealed virtual override void System.Windows.Markup.IBamlDictionaryKey.set_SharedSet(bool value);
    internal static Section get_LastFlagsSection();
    private sealed virtual override object System.Windows.Markup.IBamlDictionaryKey.get_KeyObject();
    private sealed virtual override void System.Windows.Markup.IBamlDictionaryKey.set_KeyObject(object value);
    private sealed virtual override long System.Windows.Markup.IBamlDictionaryKey.get_ValuePositionPosition();
    private sealed virtual override void System.Windows.Markup.IBamlDictionaryKey.set_ValuePositionPosition(long value);
    internal short get_ValueId();
    internal void set_ValueId(short value);
    private sealed virtual override Object[] System.Windows.Markup.IBamlDictionaryKey.get_StaticResourceValues();
    private sealed virtual override void System.Windows.Markup.IBamlDictionaryKey.set_StaticResourceValues(Object[] value);
}
internal class System.Windows.Markup.BamlDefAttributeKeyTypeRecord : BamlElementStartRecord {
    private static Section _sharedSection;
    private static Section _sharedSetSection;
    internal static int ValuePositionSize;
    private int _valuePosition;
    private long _valuePositionPosition;
    private object _keyObject;
    private Object[] _staticResourceValues;
    internal BamlRecordType RecordType { get; }
    private int System.Windows.Markup.IBamlDictionaryKey.ValuePosition { get; private set; }
    private object System.Windows.Markup.IBamlDictionaryKey.KeyObject { get; private set; }
    private long System.Windows.Markup.IBamlDictionaryKey.ValuePositionPosition { get; private set; }
    private bool System.Windows.Markup.IBamlDictionaryKey.Shared { get; private set; }
    private bool System.Windows.Markup.IBamlDictionaryKey.SharedSet { get; private set; }
    private Object[] System.Windows.Markup.IBamlDictionaryKey.StaticResourceValues { get; private set; }
    internal static Section LastFlagsSection { get; }
    private static BamlDefAttributeKeyTypeRecord();
    internal virtual void LoadRecordData(BinaryReader bamlBinaryReader);
    internal virtual void WriteRecordData(BinaryWriter bamlBinaryWriter);
    private sealed virtual override void System.Windows.Markup.IBamlDictionaryKey.UpdateValuePosition(int newPosition, BinaryWriter bamlBinaryWriter);
    internal virtual void Copy(BamlRecord record);
    internal virtual BamlRecordType get_RecordType();
    private sealed virtual override int System.Windows.Markup.IBamlDictionaryKey.get_ValuePosition();
    private sealed virtual override void System.Windows.Markup.IBamlDictionaryKey.set_ValuePosition(int value);
    private sealed virtual override object System.Windows.Markup.IBamlDictionaryKey.get_KeyObject();
    private sealed virtual override void System.Windows.Markup.IBamlDictionaryKey.set_KeyObject(object value);
    private sealed virtual override long System.Windows.Markup.IBamlDictionaryKey.get_ValuePositionPosition();
    private sealed virtual override void System.Windows.Markup.IBamlDictionaryKey.set_ValuePositionPosition(long value);
    private sealed virtual override bool System.Windows.Markup.IBamlDictionaryKey.get_Shared();
    private sealed virtual override void System.Windows.Markup.IBamlDictionaryKey.set_Shared(bool value);
    private sealed virtual override bool System.Windows.Markup.IBamlDictionaryKey.get_SharedSet();
    private sealed virtual override void System.Windows.Markup.IBamlDictionaryKey.set_SharedSet(bool value);
    private sealed virtual override Object[] System.Windows.Markup.IBamlDictionaryKey.get_StaticResourceValues();
    private sealed virtual override void System.Windows.Markup.IBamlDictionaryKey.set_StaticResourceValues(Object[] value);
    internal static Section get_LastFlagsSection();
}
internal class System.Windows.Markup.BamlDefAttributeRecord : BamlStringValueRecord {
    private string _name;
    private short _nameId;
    private BamlAttributeUsage _attributeUsage;
    internal BamlRecordType RecordType { get; }
    internal short NameId { get; internal set; }
    internal string Name { get; internal set; }
    internal BamlAttributeUsage AttributeUsage { get; internal set; }
    internal virtual void LoadRecordData(BinaryReader bamlBinaryReader);
    internal virtual void WriteRecordData(BinaryWriter bamlBinaryWriter);
    internal virtual void Copy(BamlRecord record);
    internal virtual BamlRecordType get_RecordType();
    internal short get_NameId();
    internal void set_NameId(short value);
    internal string get_Name();
    internal void set_Name(string value);
    internal BamlAttributeUsage get_AttributeUsage();
    internal void set_AttributeUsage(BamlAttributeUsage value);
    public virtual string ToString();
}
internal class System.Windows.Markup.BamlDeferableContentStartRecord : BamlRecord {
    private static long ContentSizeSize;
    private int _contentSize;
    private long _contentSizePosition;
    private Byte[] _valuesBuffer;
    internal BamlRecordType RecordType { get; }
    internal int ContentSize { get; internal set; }
    internal int RecordSize { get; internal set; }
    internal Byte[] ValuesBuffer { get; internal set; }
    internal virtual void LoadRecordData(BinaryReader bamlBinaryReader);
    internal virtual void WriteRecordData(BinaryWriter bamlBinaryWriter);
    internal void UpdateContentSize(int contentSize, BinaryWriter bamlBinaryWriter);
    internal virtual void Copy(BamlRecord record);
    internal virtual BamlRecordType get_RecordType();
    internal int get_ContentSize();
    internal void set_ContentSize(int value);
    internal virtual int get_RecordSize();
    internal virtual void set_RecordSize(int value);
    internal Byte[] get_ValuesBuffer();
    internal void set_ValuesBuffer(Byte[] value);
}
internal class System.Windows.Markup.BamlDocumentEndRecord : BamlRecord {
    internal BamlRecordType RecordType { get; }
    internal virtual BamlRecordType get_RecordType();
}
internal class System.Windows.Markup.BamlDocumentStartRecord : BamlRecord {
    private int _maxAsyncRecords;
    private bool _loadAsync;
    private long _filePos;
    private bool _debugBaml;
    internal BamlRecordType RecordType { get; }
    internal bool LoadAsync { get; internal set; }
    internal int MaxAsyncRecords { get; internal set; }
    internal long FilePos { get; internal set; }
    internal bool DebugBaml { get; internal set; }
    internal virtual void Write(BinaryWriter bamlBinaryWriter);
    internal virtual void UpdateWrite(BinaryWriter bamlBinaryWriter);
    internal virtual void LoadRecordData(BinaryReader bamlBinaryReader);
    internal virtual void WriteRecordData(BinaryWriter bamlBinaryWriter);
    internal virtual void Copy(BamlRecord record);
    internal virtual BamlRecordType get_RecordType();
    internal bool get_LoadAsync();
    internal void set_LoadAsync(bool value);
    internal int get_MaxAsyncRecords();
    internal void set_MaxAsyncRecords(int value);
    internal long get_FilePos();
    internal void set_FilePos(long value);
    internal bool get_DebugBaml();
    internal void set_DebugBaml(bool value);
}
internal class System.Windows.Markup.BamlElementEndRecord : BamlRecord {
    internal BamlRecordType RecordType { get; }
    internal virtual BamlRecordType get_RecordType();
}
internal class System.Windows.Markup.BamlElementStartRecord : BamlRecord {
    private static Section _typeIdLowSection;
    private static Section _typeIdHighSection;
    private static Section _useTypeConverter;
    private static Section _isInjected;
    internal BamlRecordType RecordType { get; }
    internal short TypeId { get; internal set; }
    internal bool CreateUsingTypeConverter { get; internal set; }
    internal bool IsInjected { get; internal set; }
    internal int RecordSize { get; internal set; }
    internal static Section LastFlagsSection { get; }
    private static BamlElementStartRecord();
    internal virtual void LoadRecordData(BinaryReader bamlBinaryReader);
    internal virtual void WriteRecordData(BinaryWriter bamlBinaryWriter);
    internal virtual BamlRecordType get_RecordType();
    internal short get_TypeId();
    internal void set_TypeId(short value);
    internal bool get_CreateUsingTypeConverter();
    internal void set_CreateUsingTypeConverter(bool value);
    internal bool get_IsInjected();
    internal void set_IsInjected(bool value);
    internal virtual int get_RecordSize();
    internal virtual void set_RecordSize(int value);
    public virtual string ToString();
    internal static Section get_LastFlagsSection();
}
internal class System.Windows.Markup.BamlKeyElementEndRecord : BamlElementEndRecord {
    internal BamlRecordType RecordType { get; }
    internal virtual BamlRecordType get_RecordType();
}
internal class System.Windows.Markup.BamlKeyElementStartRecord : BamlDefAttributeKeyTypeRecord {
    internal BamlRecordType RecordType { get; }
    internal virtual BamlRecordType get_RecordType();
}
internal class System.Windows.Markup.BamlLineAndPositionRecord : BamlRecord {
    private UInt32 _lineNumber;
    private UInt32 _linePosition;
    internal BamlRecordType RecordType { get; }
    internal UInt32 LineNumber { get; internal set; }
    internal UInt32 LinePosition { get; internal set; }
    internal int RecordSize { get; }
    internal virtual void LoadRecordData(BinaryReader bamlBinaryReader);
    internal virtual void WriteRecordData(BinaryWriter bamlBinaryWriter);
    internal virtual void Copy(BamlRecord record);
    internal virtual BamlRecordType get_RecordType();
    internal UInt32 get_LineNumber();
    internal void set_LineNumber(UInt32 value);
    internal UInt32 get_LinePosition();
    internal void set_LinePosition(UInt32 value);
    internal virtual int get_RecordSize();
    public virtual string ToString();
}
internal class System.Windows.Markup.BamlLinePositionRecord : BamlRecord {
    private UInt32 _linePosition;
    internal BamlRecordType RecordType { get; }
    internal UInt32 LinePosition { get; internal set; }
    internal int RecordSize { get; }
    internal virtual void LoadRecordData(BinaryReader bamlBinaryReader);
    internal virtual void WriteRecordData(BinaryWriter bamlBinaryWriter);
    internal virtual void Copy(BamlRecord record);
    internal virtual BamlRecordType get_RecordType();
    internal UInt32 get_LinePosition();
    internal void set_LinePosition(UInt32 value);
    internal virtual int get_RecordSize();
    public virtual string ToString();
}
internal class System.Windows.Markup.BamlLiteralContentRecord : BamlStringValueRecord {
    internal BamlRecordType RecordType { get; }
    internal virtual void LoadRecordData(BinaryReader bamlBinaryReader);
    internal virtual void WriteRecordData(BinaryWriter bamlBinaryWriter);
    internal virtual BamlRecordType get_RecordType();
}
internal class System.Windows.Markup.BamlMapTable : object {
    private static string _coreAssembly;
    private static string _frameworkAssembly;
    private static String[] _knownStrings;
    internal static short NameStringId;
    internal static short UidStringId;
    internal static string NameString;
    private Hashtable _objectHashTable;
    private ArrayList _assemblyIdToInfo;
    private ArrayList _typeIdToInfo;
    private ArrayList _attributeIdToInfo;
    private ArrayList _stringIdToInfo;
    private XamlTypeMapper _xamlTypeMapper;
    private BamlAssemblyInfoRecord _knownAssemblyInfoRecord;
    private Hashtable _converterCache;
    private bool _reusingMapTable;
    private Hashtable ObjectHashTable { get; }
    private ArrayList AssemblyIdMap { get; }
    private ArrayList TypeIdMap { get; }
    private ArrayList AttributeIdMap { get; }
    private ArrayList StringIdMap { get; }
    internal XamlTypeMapper XamlTypeMapper { get; internal set; }
    private Hashtable ConverterCache { get; }
    internal BamlMapTable(XamlTypeMapper xamlTypeMapper);
    private static BamlMapTable();
    internal object CreateKnownTypeFromId(short id);
    internal static Type GetKnownTypeFromId(short id);
    internal static short GetKnownTypeIdFromName(string assemblyFullName, string clrNamespace, string typeShortName);
    internal static short GetKnownTypeIdFromType(Type type);
    private static short GetKnownStringIdFromName(string stringValue);
    internal static KnownElements GetKnownTypeConverterIdFromType(Type type);
    internal TypeConverter GetKnownConverterFromType(Type type);
    internal static TypeConverter GetKnownConverterFromType_NoCache(Type type);
    internal Type GetKnownConverterTypeFromType(Type type);
    private static Type GetKnownConverterTypeFromPropName(Type propOwnerType, string propName);
    internal void Initialize();
    internal Type GetTypeFromId(short id);
    internal bool HasSerializerForTypeId(short id);
    internal BamlTypeInfoRecord GetTypeInfoFromId(short id);
    private short GetAssemblyIdForType(Type t);
    internal TypeConverter GetConverterFromId(short typeId, Type propType, ParserContext pc);
    internal string GetStringFromStringId(int id);
    internal BamlAttributeInfoRecord GetAttributeInfoFromId(short id);
    internal BamlAttributeInfoRecord GetAttributeInfoFromIdWithOwnerType(short attributeId);
    private string GetAttributeNameFromKnownId(KnownProperties knownId);
    internal string GetAttributeNameFromId(short id);
    internal bool DoesAttributeMatch(short id, short ownerTypeId, string name);
    internal bool DoesAttributeMatch(short id, string name);
    internal bool DoesAttributeMatch(short id, BamlAttributeUsage attributeUsage);
    internal void GetAttributeInfoFromId(short id, Int16& ownerTypeId, String& name, BamlAttributeUsage& attributeUsage);
    private static BamlAttributeUsage GetAttributeUsageFromKnownAttribute(KnownProperties knownId);
    internal Type GetTypeFromTypeInfo(BamlTypeInfoRecord typeInfo);
    private Type GetAttributeOwnerType(BamlAttributeInfoRecord bamlAttributeInfoRecord);
    internal Type GetCLRPropertyTypeAndNameFromId(short attributeId, String& propName);
    internal DependencyProperty GetDependencyPropertyValueFromId(short memberId, string memberName, Type& declaringType);
    internal DependencyProperty GetDependencyPropertyValueFromId(short memberId);
    internal DependencyProperty GetDependencyProperty(int id);
    internal DependencyProperty GetDependencyProperty(BamlAttributeInfoRecord bamlAttributeInfoRecord);
    internal RoutedEvent GetRoutedEvent(BamlAttributeInfoRecord bamlAttributeInfoRecord);
    internal short GetAttributeOrTypeId(BinaryWriter binaryWriter, Type declaringType, string memberName, Int16& typeId);
    internal BamlAssemblyInfoRecord GetAssemblyInfoFromId(short id);
    private Assembly GetAssemblyFromAssemblyInfo(BamlAssemblyInfoRecord assemblyInfoRecord);
    internal BamlAssemblyInfoRecord AddAssemblyMap(BinaryWriter binaryWriter, string assemblyFullName);
    internal void LoadAssemblyInfoRecord(BamlAssemblyInfoRecord record);
    internal void EnsureAssemblyRecord(Assembly asm);
    private TypeInfoKey GetTypeInfoKey(string assemblyFullName, string typeFullName);
    internal bool GetTypeInfoId(BinaryWriter binaryWriter, string assemblyFullName, string typeFullName, Int16& typeId);
    internal short AddTypeInfoMap(BinaryWriter binaryWriter, string assemblyFullName, string typeFullName, Type elementType, string serializerAssemblyFullName, string serializerTypeFullName);
    internal void LoadTypeInfoRecord(BamlTypeInfoRecord record);
    internal object GetAttributeInfoKey(string ownerTypeName, string attributeName);
    internal short AddAttributeInfoMap(BinaryWriter binaryWriter, string assemblyFullName, string typeFullName, Type owningType, string fieldName, Type attributeType, BamlAttributeUsage attributeUsage);
    internal short AddAttributeInfoMap(BinaryWriter binaryWriter, string assemblyFullName, string typeFullName, Type owningType, string fieldName, Type attributeType, BamlAttributeUsage attributeUsage, BamlAttributeInfoRecord& bamlAttributeInfoRecord);
    internal bool GetCustomSerializerOrConverter(BinaryWriter binaryWriter, Type ownerType, Type attributeType, object piOrMi, string fieldName, Int16& converterOrSerializerTypeId, Type& converterOrSerializerType);
    internal bool GetStringInfoId(string stringValue, Int16& stringId);
    internal short AddStringInfoMap(BinaryWriter binaryWriter, string stringValue);
    internal short GetStaticMemberId(BinaryWriter binaryWriter, ParserContext pc, short extensionTypeId, string memberValue, Type defaultTargetType);
    private bool ShouldBypassCustomCheck(Type declaringType, Type attributeType);
    private Type GetCustomConverter(object piOrMi, Type ownerType, string fieldName, Type attributeType);
    private Type GetCustomSerializer(Type type, Int16& converterOrSerializerTypeId);
    private void ThrowException(string id, string parameter);
    internal void LoadAttributeInfoRecord(BamlAttributeInfoRecord record);
    internal void LoadStringInfoRecord(BamlStringInfoRecord record);
    internal object GetHashTableData(object key);
    internal void AddHashTableData(object key, object data);
    internal BamlMapTable Clone();
    private TypeConverter GetConverterFromCache(short typeId);
    private TypeConverter GetConverterFromCache(Type type);
    internal void ClearConverterCache();
    private Hashtable get_ObjectHashTable();
    private ArrayList get_AssemblyIdMap();
    private ArrayList get_TypeIdMap();
    private ArrayList get_AttributeIdMap();
    private ArrayList get_StringIdMap();
    internal XamlTypeMapper get_XamlTypeMapper();
    internal void set_XamlTypeMapper(XamlTypeMapper value);
    private Hashtable get_ConverterCache();
}
internal class System.Windows.Markup.BamlNamedElementStartRecord : BamlElementStartRecord {
    private bool _isTemplateChild;
    private string _runtimeName;
    internal string RuntimeName { get; internal set; }
    internal bool IsTemplateChild { get; internal set; }
    internal virtual void LoadRecordData(BinaryReader bamlBinaryReader);
    internal virtual void WriteRecordData(BinaryWriter bamlBinaryWriter);
    internal virtual void Copy(BamlRecord record);
    internal string get_RuntimeName();
    internal void set_RuntimeName(string value);
    internal bool get_IsTemplateChild();
    internal void set_IsTemplateChild(bool value);
}
internal enum System.Windows.Markup.BamlNodeType : Enum {
    public int value__;
    public static BamlNodeType None;
    public static BamlNodeType StartDocument;
    public static BamlNodeType EndDocument;
    public static BamlNodeType ConnectionId;
    public static BamlNodeType StartElement;
    public static BamlNodeType EndElement;
    public static BamlNodeType Property;
    public static BamlNodeType ContentProperty;
    public static BamlNodeType XmlnsProperty;
    public static BamlNodeType StartComplexProperty;
    public static BamlNodeType EndComplexProperty;
    public static BamlNodeType LiteralContent;
    public static BamlNodeType Text;
    public static BamlNodeType RoutedEvent;
    public static BamlNodeType Event;
    public static BamlNodeType IncludeReference;
    public static BamlNodeType DefAttribute;
    public static BamlNodeType PresentationOptionsAttribute;
    public static BamlNodeType PIMapping;
    public static BamlNodeType StartConstructor;
    public static BamlNodeType EndConstructor;
}
internal class System.Windows.Markup.BamlOptimizedStaticResourceRecord : BamlRecord {
    private short _valueId;
    private static byte TypeExtensionValueMask;
    private static byte StaticExtensionValueMask;
    private static Section _isValueTypeExtensionSection;
    private static Section _isValueStaticExtensionSection;
    internal BamlRecordType RecordType { get; }
    public short ExtensionTypeId { get; }
    public short ValueId { get; public set; }
    internal int RecordSize { get; internal set; }
    public bool IsValueTypeExtension { get; public set; }
    public bool IsValueStaticExtension { get; public set; }
    internal static Section LastFlagsSection { get; }
    private static BamlOptimizedStaticResourceRecord();
    internal virtual void LoadRecordData(BinaryReader bamlBinaryReader);
    internal virtual void WriteRecordData(BinaryWriter bamlBinaryWriter);
    internal virtual void Copy(BamlRecord record);
    internal virtual BamlRecordType get_RecordType();
    public sealed virtual short get_ExtensionTypeId();
    public sealed virtual short get_ValueId();
    public void set_ValueId(short value);
    internal virtual int get_RecordSize();
    internal virtual void set_RecordSize(int value);
    public sealed virtual bool get_IsValueTypeExtension();
    public void set_IsValueTypeExtension(bool value);
    public sealed virtual bool get_IsValueStaticExtension();
    public void set_IsValueStaticExtension(bool value);
    internal static Section get_LastFlagsSection();
    public virtual string ToString();
}
internal class System.Windows.Markup.BamlPIMappingRecord : BamlVariableSizedRecord {
    private static Section _assemblyIdLowSection;
    private static Section _assemblyIdHighSection;
    private string _xmlns;
    private string _clrns;
    internal BamlRecordType RecordType { get; }
    internal string XmlNamespace { get; internal set; }
    internal string ClrNamespace { get; internal set; }
    internal short AssemblyId { get; internal set; }
    internal static Section LastFlagsSection { get; }
    private static BamlPIMappingRecord();
    internal virtual void LoadRecordData(BinaryReader bamlBinaryReader);
    internal virtual void WriteRecordData(BinaryWriter bamlBinaryWriter);
    internal virtual void Copy(BamlRecord record);
    internal virtual BamlRecordType get_RecordType();
    internal string get_XmlNamespace();
    internal void set_XmlNamespace(string value);
    internal string get_ClrNamespace();
    internal void set_ClrNamespace(string value);
    internal short get_AssemblyId();
    internal void set_AssemblyId(short value);
    internal static Section get_LastFlagsSection();
}
internal class System.Windows.Markup.BamlPresentationOptionsAttributeRecord : BamlStringValueRecord {
    private string _name;
    private short _nameId;
    internal BamlRecordType RecordType { get; }
    internal short NameId { get; internal set; }
    internal string Name { get; internal set; }
    internal virtual void LoadRecordData(BinaryReader bamlBinaryReader);
    internal virtual void WriteRecordData(BinaryWriter bamlBinaryWriter);
    internal virtual void Copy(BamlRecord record);
    internal virtual BamlRecordType get_RecordType();
    internal short get_NameId();
    internal void set_NameId(short value);
    internal string get_Name();
    internal void set_Name(string value);
    public virtual string ToString();
}
internal class System.Windows.Markup.BamlPropertyArrayEndRecord : BamlRecord {
    internal BamlRecordType RecordType { get; }
    internal virtual BamlRecordType get_RecordType();
}
internal class System.Windows.Markup.BamlPropertyArrayStartRecord : BamlPropertyComplexStartRecord {
    internal BamlRecordType RecordType { get; }
    internal virtual BamlRecordType get_RecordType();
}
internal class System.Windows.Markup.BamlPropertyComplexEndRecord : BamlRecord {
    internal BamlRecordType RecordType { get; }
    internal virtual BamlRecordType get_RecordType();
}
internal class System.Windows.Markup.BamlPropertyComplexStartRecord : BamlRecord {
    private short _attributeId;
    internal BamlRecordType RecordType { get; }
    internal short AttributeId { get; internal set; }
    internal int RecordSize { get; internal set; }
    internal virtual void LoadRecordData(BinaryReader bamlBinaryReader);
    internal virtual void WriteRecordData(BinaryWriter bamlBinaryWriter);
    internal virtual void Copy(BamlRecord record);
    internal virtual BamlRecordType get_RecordType();
    internal short get_AttributeId();
    internal void set_AttributeId(short value);
    internal virtual int get_RecordSize();
    internal virtual void set_RecordSize(int value);
    public virtual string ToString();
}
internal class System.Windows.Markup.BamlPropertyCustomRecord : BamlVariableSizedRecord {
    private object _valueObject;
    private static Section _isValueSetSection;
    private static Section _isValueTypeIdSection;
    private static Section _isRawEnumValueSetSection;
    internal static short TypeIdValueMask;
    private short _attributeId;
    private short _serializerTypeId;
    internal BamlRecordType RecordType { get; }
    internal short AttributeId { get; internal set; }
    internal short SerializerTypeId { get; internal set; }
    internal object ValueObject { get; internal set; }
    internal bool ValueObjectSet { get; internal set; }
    internal bool IsValueTypeId { get; internal set; }
    internal bool IsRawEnumValueSet { get; internal set; }
    internal static Section LastFlagsSection { get; }
    private static BamlPropertyCustomRecord();
    internal virtual void LoadRecordData(BinaryReader bamlBinaryReader);
    internal object GetCustomValue(BinaryReader reader, Type propertyType, short serializerId, BamlRecordReader bamlRecordReader);
    internal virtual void Copy(BamlRecord record);
    internal virtual BamlRecordType get_RecordType();
    internal short get_AttributeId();
    internal void set_AttributeId(short value);
    internal short get_SerializerTypeId();
    internal void set_SerializerTypeId(short value);
    internal object get_ValueObject();
    internal void set_ValueObject(object value);
    internal bool get_ValueObjectSet();
    internal void set_ValueObjectSet(bool value);
    internal bool get_IsValueTypeId();
    internal void set_IsValueTypeId(bool value);
    internal bool get_IsRawEnumValueSet();
    internal void set_IsRawEnumValueSet(bool value);
    internal static Section get_LastFlagsSection();
}
internal class System.Windows.Markup.BamlPropertyCustomWriteInfoRecord : BamlPropertyCustomRecord {
    private short _valueId;
    private Type _valueType;
    private string _value;
    private string _valueMemberName;
    private Type _serializerType;
    private ITypeDescriptorContext _typeContext;
    internal short ValueId { get; internal set; }
    internal string ValueMemberName { get; internal set; }
    internal Type ValueType { get; internal set; }
    internal string Value { get; internal set; }
    internal Type SerializerType { get; internal set; }
    internal ITypeDescriptorContext TypeContext { get; internal set; }
    internal virtual void WriteRecordData(BinaryWriter bamlBinaryWriter);
    internal virtual void Copy(BamlRecord record);
    internal short get_ValueId();
    internal void set_ValueId(short value);
    internal string get_ValueMemberName();
    internal void set_ValueMemberName(string value);
    internal Type get_ValueType();
    internal void set_ValueType(Type value);
    internal string get_Value();
    internal void set_Value(string value);
    internal Type get_SerializerType();
    internal void set_SerializerType(Type value);
    internal ITypeDescriptorContext get_TypeContext();
    internal void set_TypeContext(ITypeDescriptorContext value);
}
internal class System.Windows.Markup.BamlPropertyIDictionaryEndRecord : BamlRecord {
    internal BamlRecordType RecordType { get; }
    internal virtual BamlRecordType get_RecordType();
}
internal class System.Windows.Markup.BamlPropertyIDictionaryStartRecord : BamlPropertyComplexStartRecord {
    internal BamlRecordType RecordType { get; }
    internal virtual BamlRecordType get_RecordType();
}
internal class System.Windows.Markup.BamlPropertyIListEndRecord : BamlRecord {
    internal BamlRecordType RecordType { get; }
    internal virtual BamlRecordType get_RecordType();
}
internal class System.Windows.Markup.BamlPropertyIListStartRecord : BamlPropertyComplexStartRecord {
    internal BamlRecordType RecordType { get; }
    internal virtual BamlRecordType get_RecordType();
}
internal class System.Windows.Markup.BamlPropertyRecord : BamlStringValueRecord {
    private short _attributeId;
    internal BamlRecordType RecordType { get; }
    internal short AttributeId { get; internal set; }
    internal virtual void LoadRecordData(BinaryReader bamlBinaryReader);
    internal virtual void WriteRecordData(BinaryWriter bamlBinaryWriter);
    internal virtual void Copy(BamlRecord record);
    internal virtual BamlRecordType get_RecordType();
    internal short get_AttributeId();
    internal void set_AttributeId(short value);
    public virtual string ToString();
}
internal class System.Windows.Markup.BamlPropertyStringReferenceRecord : BamlPropertyComplexStartRecord {
    private short _stringId;
    internal BamlRecordType RecordType { get; }
    internal short StringId { get; internal set; }
    internal int RecordSize { get; internal set; }
    internal virtual void LoadRecordData(BinaryReader bamlBinaryReader);
    internal virtual void WriteRecordData(BinaryWriter bamlBinaryWriter);
    internal virtual void Copy(BamlRecord record);
    internal virtual BamlRecordType get_RecordType();
    internal short get_StringId();
    internal void set_StringId(short value);
    internal virtual int get_RecordSize();
    internal virtual void set_RecordSize(int value);
}
internal class System.Windows.Markup.BamlPropertyTypeReferenceRecord : BamlPropertyComplexStartRecord {
    private short _typeId;
    internal BamlRecordType RecordType { get; }
    internal short TypeId { get; internal set; }
    internal int RecordSize { get; internal set; }
    internal virtual void LoadRecordData(BinaryReader bamlBinaryReader);
    internal virtual void WriteRecordData(BinaryWriter bamlBinaryWriter);
    internal virtual void Copy(BamlRecord record);
    internal virtual BamlRecordType get_RecordType();
    internal short get_TypeId();
    internal void set_TypeId(short value);
    internal virtual int get_RecordSize();
    internal virtual void set_RecordSize(int value);
}
internal class System.Windows.Markup.BamlPropertyWithConverterRecord : BamlPropertyRecord {
    private short _converterTypeId;
    internal short ConverterTypeId { get; internal set; }
    internal BamlRecordType RecordType { get; }
    internal virtual void LoadRecordData(BinaryReader bamlBinaryReader);
    internal virtual void WriteRecordData(BinaryWriter bamlBinaryWriter);
    internal virtual void Copy(BamlRecord record);
    internal short get_ConverterTypeId();
    internal void set_ConverterTypeId(short value);
    internal virtual BamlRecordType get_RecordType();
}
internal class System.Windows.Markup.BamlPropertyWithExtensionRecord : BamlRecord {
    private static Section _isValueTypeExtensionSection;
    private static Section _isValueStaticExtensionSection;
    private short _attributeId;
    private short _extensionTypeId;
    private short _valueId;
    private static short ExtensionIdMask;
    private static short TypeExtensionValueMask;
    private static short StaticExtensionValueMask;
    internal BamlRecordType RecordType { get; }
    internal short AttributeId { get; internal set; }
    public short ExtensionTypeId { get; public set; }
    public short ValueId { get; public set; }
    internal int RecordSize { get; internal set; }
    public bool IsValueTypeExtension { get; public set; }
    public bool IsValueStaticExtension { get; public set; }
    internal static Section LastFlagsSection { get; }
    private static BamlPropertyWithExtensionRecord();
    internal virtual void LoadRecordData(BinaryReader bamlBinaryReader);
    internal virtual void WriteRecordData(BinaryWriter bamlBinaryWriter);
    internal virtual void Copy(BamlRecord record);
    internal virtual BamlRecordType get_RecordType();
    internal short get_AttributeId();
    internal void set_AttributeId(short value);
    public sealed virtual short get_ExtensionTypeId();
    public void set_ExtensionTypeId(short value);
    public sealed virtual short get_ValueId();
    public void set_ValueId(short value);
    internal virtual int get_RecordSize();
    internal virtual void set_RecordSize(int value);
    public sealed virtual bool get_IsValueTypeExtension();
    public void set_IsValueTypeExtension(bool value);
    public sealed virtual bool get_IsValueStaticExtension();
    public void set_IsValueStaticExtension(bool value);
    internal static Section get_LastFlagsSection();
    public virtual string ToString();
}
internal class System.Windows.Markup.BamlPropertyWithStaticResourceIdRecord : BamlStaticResourceIdRecord {
    private short _attributeId;
    internal BamlRecordType RecordType { get; }
    internal int RecordSize { get; internal set; }
    internal short AttributeId { get; internal set; }
    internal virtual void LoadRecordData(BinaryReader bamlBinaryReader);
    internal virtual void WriteRecordData(BinaryWriter bamlBinaryWriter);
    internal virtual void Copy(BamlRecord record);
    internal virtual BamlRecordType get_RecordType();
    internal virtual int get_RecordSize();
    internal virtual void set_RecordSize(int value);
    internal short get_AttributeId();
    internal void set_AttributeId(short value);
    public virtual string ToString();
}
internal class System.Windows.Markup.BamlReader : object {
    private BamlRecordReader _bamlRecordReader;
    private XmlnsDictionary _prefixDictionary;
    private BamlRecord _currentBamlRecord;
    private bool _haveUnprocessedRecord;
    private int _deferableContentBlockDepth;
    private long _deferableContentPosition;
    private List`1<BamlKeyInfo> _deferKeys;
    private BamlKeyInfo _currentKeyInfo;
    private List`1<BamlRecord> _currentStaticResourceRecords;
    private int _currentStaticResourceRecordIndex;
    private BamlNodeType _bamlNodeType;
    private ReadState _readState;
    private string _assemblyName;
    private string _prefix;
    private string _xmlNamespace;
    private string _clrNamespace;
    private string _value;
    private string _name;
    private string _localName;
    private string _ownerTypeName;
    private ArrayList _properties;
    private DependencyProperty _propertyDP;
    private int _propertiesIndex;
    private int _connectionId;
    private string _contentPropertyName;
    private BamlAttributeUsage _attributeUsage;
    private Stack _nodeStack;
    private ParserContext _parserContext;
    private bool _isInjected;
    private bool _useTypeConverter;
    private string _typeConverterAssemblyName;
    private string _typeConverterName;
    private Dictionary`2<string, List`1<string>> _reverseXmlnsTable;
    public int PropertyCount { get; }
    public bool HasProperties { get; }
    public int ConnectionId { get; }
    public BamlAttributeUsage AttributeUsage { get; }
    public BamlNodeType NodeType { get; }
    public string Name { get; }
    public string LocalName { get; }
    public string Prefix { get; }
    public string AssemblyName { get; }
    public string XmlNamespace { get; }
    public string ClrNamespace { get; }
    public string Value { get; }
    public bool IsInjected { get; }
    public bool CreateUsingTypeConverter { get; }
    public string TypeConverterName { get; }
    public string TypeConverterAssemblyName { get; }
    unknown BamlNodeType NodeTypeInternal {private set; }
    private BamlMapTable MapTable { get; }
    public BamlReader(Stream bamlStream);
    public int get_PropertyCount();
    public bool get_HasProperties();
    public int get_ConnectionId();
    public BamlAttributeUsage get_AttributeUsage();
    public BamlNodeType get_NodeType();
    public string get_Name();
    public string get_LocalName();
    public string get_Prefix();
    public string get_AssemblyName();
    public string get_XmlNamespace();
    public string get_ClrNamespace();
    public string get_Value();
    public bool get_IsInjected();
    public bool get_CreateUsingTypeConverter();
    public string get_TypeConverterName();
    public string get_TypeConverterAssemblyName();
    public bool Read();
    private void set_NodeTypeInternal(BamlNodeType value);
    private void AddToPropertyInfoCollection(object info);
    public void Close();
    public bool MoveToFirstProperty();
    public bool MoveToNextProperty();
    private void GetNextRecord();
    private void ReadNextRecord();
    private void ReadProperties();
    private void ProcessPropertyRecord();
    private void ReadXmlnsPropertyRecord();
    private void ReadPropertyRecord();
    private void ReadContentPropertyRecord();
    private void ReadPropertyStringRecord();
    private void ReadPropertyTypeRecord();
    private void ReadPropertyWithExtensionRecord();
    private void ReadPropertyWithStaticResourceIdRecord();
    private BamlPropertyInfo ReadPropertyRecordCore(string value);
    private void ReadPropertyCustomRecord();
    private BamlPropertyInfo GetPropertyCustomRecordInfo();
    private void ReadDefAttributeRecord();
    private void ReadPresentationOptionsAttributeRecord();
    private void ReadDefAttributeKeyTypeRecord();
    private void ReadDeferableContentRecord();
    private long ReadDeferKeys();
    private void ProcessDeferKey();
    private BamlKeyInfo CheckForSharedness();
    private BamlKeyInfo ProcessKeyTree();
    private void ProcessStaticResourceTree(List`1<BamlRecord> srRecords);
    private void ReadStaticResourceId();
    private string EscapeString(string value);
    private void ReadRoutedEventRecord();
    private void ReadClrEventRecord();
    private void ReadDocumentStartRecord();
    private void ReadDocumentEndRecord();
    private void ReadAssemblyInfoRecord();
    private void ReadPIMappingRecord();
    private void ReadLiteralContentRecord();
    private void ReadConnectionIdRecord();
    private void ReadElementStartRecord();
    private void ReadElementEndRecord();
    private void ReadPropertyComplexStartRecord();
    private void ReadPropertyComplexEndRecord();
    private void ReadTextRecord();
    private void ReadConstructorStart();
    private void ReadConstructorEnd();
    private void InsertDeferedKey(int valueOffset);
    private void ClearProperties();
    private BamlAttributeInfoRecord SetCommonPropertyInfo(BamlNodeInfo nodeInfo, short attrId);
    private string GetTemplateBindingExtensionValueString(short memberId);
    private string GetStaticExtensionValueString(short memberId);
    private string GetExtensionPrefixString(string extensionName);
    private string GetInnerExtensionValueString(IOptimizedMarkupExtension optimizedMarkupExtensionRecord);
    private string GetExtensionValueString(IOptimizedMarkupExtension optimizedMarkupExtensionRecord);
    private string GetTypeValueString(short typeId);
    private void GetAssemblyAndPrefixAndXmlns(BamlTypeInfoRecord typeInfo, String& assemblyFullName, String& prefix, String& xmlns);
    private void SetXmlNamespace(string clrNamespace, string assemblyFullName, string xmlNs);
    private List`1<string> GetXmlNamespaceList(string clrNamespace, string assemblyFullName);
    internal string GetXmlnsPrefix(string xmlns);
    private string GetXmlnsPrefix(List`1<string> xmlnsList);
    private BamlMapTable get_MapTable();
}
internal abstract class System.Windows.Markup.BamlRecord : object {
    internal BitVector32 _flags;
    private static Section _pinnedFlagSection;
    private BamlRecord _nextRecord;
    internal static int RecordTypeFieldLength;
    internal int RecordSize { get; internal set; }
    internal BamlRecordType RecordType { get; }
    internal BamlRecord Next { get; internal set; }
    internal bool IsPinned { get; }
    internal int PinnedCount { get; internal set; }
    internal static Section LastFlagsSection { get; }
    private static BamlRecord();
    internal virtual bool LoadRecordSize(BinaryReader bamlBinaryReader, long bytesAvailable);
    internal virtual void LoadRecordData(BinaryReader bamlBinaryReader);
    internal virtual void Write(BinaryWriter bamlBinaryWriter);
    internal virtual void WriteRecordData(BinaryWriter bamlBinaryWriter);
    internal virtual int get_RecordSize();
    internal virtual void set_RecordSize(int value);
    internal virtual BamlRecordType get_RecordType();
    internal BamlRecord get_Next();
    internal void set_Next(BamlRecord value);
    internal bool get_IsPinned();
    internal int get_PinnedCount();
    internal void set_PinnedCount(int value);
    internal void Pin();
    internal void Unpin();
    internal virtual void Copy(BamlRecord record);
    internal static Section get_LastFlagsSection();
    public virtual string ToString();
    protected static string GetTypeName(int typeId);
    internal static bool IsContentRecord(BamlRecordType bamlRecordType);
}
internal static class System.Windows.Markup.BamlRecordHelper : object {
    internal static bool IsMapTableRecordType(BamlRecordType bamlRecordType);
    internal static bool IsDebugBamlRecordType(BamlRecordType recordType);
    internal static bool HasDebugExtensionRecord(bool isDebugBamlStream, BamlRecord bamlRecord);
    internal static bool DoesRecordTypeHaveDebugExtension(BamlRecordType recordType);
}
internal class System.Windows.Markup.BamlRecordManager : object {
    private BamlRecord[] _readCache;
    private BamlRecord[] _writeCache;
    internal BamlRecord ReadNextRecord(BinaryReader bamlBinaryReader, long bytesAvailable, BamlRecordType recordType);
    internal static IAddChild AsIAddChild(object obj);
    internal static bool TreatAsIAddChild(Type parentObjectType);
    internal static BamlRecordType GetPropertyStartRecordType(Type propertyType, bool propertyCanWrite);
    internal BamlRecord CloneRecord(BamlRecord record);
    private BamlRecord AllocateWriteRecord(BamlRecordType recordType);
    private BamlRecord AllocateRecord(BamlRecordType recordType);
    internal BamlRecord GetWriteRecord(BamlRecordType recordType);
    internal void ReleaseWriteRecord(BamlRecord record);
}
internal class System.Windows.Markup.BamlRecordReader : object {
    private static Type NullableType;
    private IComponentConnector _componentConnector;
    private object _rootElement;
    private bool _bamlAsForest;
    private bool _isRootAlreadyLoaded;
    private ArrayList _rootList;
    private ParserContext _parserContext;
    private TypeConvertContext _typeConvertContext;
    private int _persistId;
    private ParserStack _contextStack;
    private XamlParseMode _parseMode;
    private int _maxAsyncRecords;
    private Stream _bamlStream;
    private ReaderStream _xamlReaderStream;
    private BamlBinaryReader _binaryReader;
    private BamlRecordManager _bamlRecordManager;
    private BamlRecord _preParsedBamlRecordsStart;
    private BamlRecord _preParsedIndexRecord;
    private bool _endOfDocument;
    private bool _buildTopDown;
    private BamlRecordReader _previousBamlRecordReader;
    private static List`1<ReaderContextStackData> _stackDataFactoryCache;
    internal ArrayList RootList { get; internal set; }
    internal bool BuildTopDown { get; internal set; }
    internal int BytesAvailible { get; }
    internal BamlRecord PreParsedRecordsStart { get; internal set; }
    internal BamlRecord PreParsedCurrentRecord { get; internal set; }
    internal Stream BamlStream { get; internal set; }
    internal BamlBinaryReader BinaryReader { get; }
    internal XamlTypeMapper XamlTypeMapper { get; }
    internal ParserContext ParserContext { get; internal set; }
    internal TypeConvertContext TypeConvertContext { get; }
    internal XamlParseMode XamlParseMode { get; internal set; }
    internal int MaxAsyncRecords { get; internal set; }
    internal BamlMapTable MapTable { get; }
    internal XmlnsDictionary XmlnsDictionary { get; }
    internal ReaderContextStackData CurrentContext { get; }
    internal ReaderContextStackData ParentContext { get; }
    internal object ParentObjectData { get; }
    internal ReaderContextStackData GrandParentContext { get; }
    internal object GrandParentObjectData { get; }
    internal ReaderContextStackData GreatGrandParentContext { get; }
    internal ParserStack ReaderContextStack { get; }
    internal BamlRecordManager BamlRecordManager { get; }
    internal bool EndOfDocument { get; internal set; }
    internal object RootElement { get; internal set; }
    internal IComponentConnector ComponentConnector { get; internal set; }
    private ReaderStream XamlReaderStream { get; }
    internal ParserStack ContextStack { get; internal set; }
    internal int LineNumber { get; internal set; }
    internal int LinePosition { get; internal set; }
    internal bool IsDebugBamlStream { get; internal set; }
    internal long StreamPosition { get; }
    private long StreamLength { get; }
    internal bool IsRootAlreadyLoaded { get; internal set; }
    internal BamlRecordReader PreviousBamlRecordReader { get; }
    internal BamlRecordReader(Stream bamlStream, ParserContext parserContext);
    internal BamlRecordReader(Stream bamlStream, ParserContext parserContext, object root);
    internal BamlRecordReader(Stream bamlStream, ParserContext parserContext, bool loadMapper);
    private static BamlRecordReader();
    internal void Initialize();
    internal ArrayList get_RootList();
    internal void set_RootList(ArrayList value);
    internal bool get_BuildTopDown();
    internal void set_BuildTopDown(bool value);
    internal int get_BytesAvailible();
    internal BamlRecord GetNextRecord();
    internal BamlRecord ReadNextRecordWithDebugExtension(long bytesAvailable, BamlRecordType recordType);
    internal BamlRecord ReadDebugExtensionRecord();
    internal void ProcessDebugBamlRecord(BamlRecord bamlRecord);
    internal BamlRecordType GetNextRecordType();
    internal void Close();
    internal bool Read(bool singleRecord);
    internal bool Read();
    internal bool Read(BamlRecord bamlRecord, int lineNumber, int linePosition);
    internal void ReadVersionHeader();
    internal object ReadElement(long startPosition, XamlObjectIds contextXamlObjectIds, object dictionaryKey);
    protected virtual void ReadConnectionId(BamlConnectionIdRecord bamlConnectionIdRecord);
    private void ReadDocumentStartRecord(BamlDocumentStartRecord documentStartRecord);
    private void ReadDocumentEndRecord();
    internal virtual bool ReadRecord(BamlRecord bamlRecord);
    protected virtual void ReadXmlnsPropertyRecord(BamlXmlnsPropertyRecord xmlnsRecord);
    private void GetElementAndFlags(BamlElementStartRecord bamlElementStartRecord, Object& element, ReaderFlags& flags, Type& delayCreatedType, Int16& delayCreatedTypeId);
    protected ReaderFlags GetFlagsFromType(Type elementType);
    internal static void CheckForTreeAdd(ReaderFlags& flags, ReaderContextStackData context);
    internal void SetDependencyValue(DependencyObject dependencyObject, DependencyProperty dependencyProperty, object value);
    internal virtual void SetDependencyValueCore(DependencyObject dependencyObject, DependencyProperty dependencyProperty, object value);
    internal object ProvideValueFromMarkupExtension(MarkupExtension markupExtension, object obj, object member);
    internal void BaseReadElementStartRecord(BamlElementStartRecord bamlElementRecord);
    protected virtual bool ReadElementStartRecord(BamlElementStartRecord bamlElementRecord);
    protected internal virtual void ReadElementEndRecord(bool fromNestedBamlRecordReader);
    internal virtual void ReadKeyElementStartRecord(BamlKeyElementStartRecord bamlElementRecord);
    internal virtual void ReadKeyElementEndRecord();
    internal virtual void ReadConstructorParameterTypeRecord(BamlConstructorParameterTypeRecord constructorParameterType);
    internal virtual void ReadContentPropertyRecord(BamlContentPropertyRecord bamlContentPropertyRecord);
    internal virtual void ReadConstructorParametersStartRecord();
    internal virtual void ReadConstructorParametersEndRecord();
    private void ProcessConstructorParameter(ParameterInfo paramInfo, object param, Object& paramArrayItem);
    internal virtual void ReadDeferableContentStart(BamlDeferableContentStartRecord bamlRecord);
    internal void BaseReadDeferableContentStart(BamlDeferableContentStartRecord bamlRecord, ArrayList& defKeyList, List`1& staticResourceValuesList);
    protected virtual void ReadStaticResourceIdRecord(BamlStaticResourceIdRecord bamlStaticResourceIdRecord);
    protected virtual void ReadPropertyWithStaticResourceIdRecord(BamlPropertyWithStaticResourceIdRecord bamlPropertyWithStaticResourceIdRecord);
    internal StaticResourceHolder GetStaticResourceFromId(short staticResourceId);
    internal virtual void ReadLiteralContentRecord(BamlLiteralContentRecord bamlLiteralContentRecord);
    protected virtual void ReadPropertyComplexStartRecord(BamlPropertyComplexStartRecord bamlPropertyRecord);
    protected virtual void ReadPropertyComplexEndRecord();
    internal DependencyProperty GetCustomDependencyPropertyValue(BamlPropertyCustomRecord bamlPropertyRecord);
    internal DependencyProperty GetCustomDependencyPropertyValue(BamlPropertyCustomRecord bamlPropertyRecord, Type& declaringType);
    internal object GetCustomValue(BamlPropertyCustomRecord bamlPropertyRecord, Type propertyType, string propertyName);
    protected virtual void ReadPropertyCustomRecord(BamlPropertyCustomRecord bamlPropertyRecord);
    protected virtual void ReadPropertyRecord(BamlPropertyRecord bamlPropertyRecord);
    protected virtual void ReadPropertyConverterRecord(BamlPropertyWithConverterRecord bamlPropertyRecord);
    protected virtual void ReadPropertyStringRecord(BamlPropertyStringReferenceRecord bamlPropertyRecord);
    private object GetInnerExtensionValue(IOptimizedMarkupExtension optimizedMarkupExtensionRecord);
    private object GetStaticExtensionValue(short memberId);
    internal virtual object GetExtensionValue(IOptimizedMarkupExtension optimizedMarkupExtensionRecord, string propertyName);
    protected virtual void ReadPropertyWithExtensionRecord(BamlPropertyWithExtensionRecord bamlPropertyRecord);
    private void BaseReadOptimizedMarkupExtension(object element, short attributeId, WpfPropertyDefinition propertyDefinition, object value);
    private bool SetPropertyValue(object o, WpfPropertyDefinition propertyDefinition, object value);
    protected virtual void ReadPropertyTypeRecord(BamlPropertyTypeReferenceRecord bamlPropertyRecord);
    private void ReadPropertyRecordBase(string attribValue, short attributeId, short converterTypeId);
    private void DoRegisterName(string name, object element);
    protected void ReadPropertyArrayStartRecord(BamlPropertyArrayStartRecord bamlPropertyArrayStartRecord);
    protected virtual void ReadPropertyArrayEndRecord();
    protected virtual void ReadPropertyIListStartRecord(BamlPropertyIListStartRecord bamlPropertyIListStartRecord);
    protected virtual void ReadPropertyIListEndRecord();
    protected virtual void ReadPropertyIDictionaryStartRecord(BamlPropertyIDictionaryStartRecord bamlPropertyIDictionaryStartRecord);
    protected virtual void ReadPropertyIDictionaryEndRecord();
    private void SetCollectionPropertyValue(ReaderContextStackData context);
    private void InitPropertyCollection(BamlCollectionHolder holder, ReaderContextStackData context);
    private BamlCollectionHolder GetCollectionHolderFromContext(ReaderContextStackData context, bool toInsert);
    protected IDictionary GetDictionaryFromContext(ReaderContextStackData context, bool toInsert);
    private IList GetListFromContext(ReaderContextStackData context);
    private IAddChild GetIAddChildFromContext(ReaderContextStackData context);
    private ArrayExtension GetArrayExtensionFromContext(ReaderContextStackData context);
    protected virtual void ReadDefAttributeRecord(BamlDefAttributeRecord bamlDefAttributeRecord);
    protected virtual void ReadDefAttributeKeyTypeRecord(BamlDefAttributeKeyTypeRecord bamlDefAttributeRecord);
    private void SetKeyOnContext(object key, string attributeName, ReaderContextStackData context, ReaderContextStackData parentContext);
    protected virtual void ReadTextRecord(BamlTextRecord bamlTextRecord);
    protected virtual void ReadPresentationOptionsAttributeRecord(BamlPresentationOptionsAttributeRecord bamlPresentationOptionsAttributeRecord);
    private void SetDependencyComplexProperty(object o);
    private void SetDependencyComplexProperty(object currentTarget, BamlAttributeInfoRecord attribInfo, object o);
    internal static bool IsNullable(Type t);
    internal object OptionallyMakeNullable(Type propertyType, object o, string propName);
    internal static bool TryOptionallyMakeNullable(Type propertyType, string propName, Object& o);
    internal virtual void SetClrComplexPropertyCore(object parentObject, object value, MemberInfo memberInfo);
    private void SetClrComplexProperty(object o);
    private void SetClrComplexProperty(object parentObject, MemberInfo memberInfo, object o);
    private void SetConstructorParameter(object o);
    protected void SetXmlnsOnCurrentObject(BamlXmlnsPropertyRecord xmlnsRecord);
    internal object ParseProperty(object element, Type propertyType, string propertyName, object dpOrPi, string attribValue, short converterTypeId);
    private void ThrowPropertyParseError(Exception e, string propertyName, string attribValue, object element, Type propertyType);
    private object GetObjectFromString(Type type, string s, short converterTypeId);
    private static object Lookup(IDictionary dictionary, object key, bool allowDeferredResourceReference, bool mustReturnDeferredResourceReference);
    internal object FindResourceInParserStack(object resourceNameObject, bool allowDeferredResourceReference, bool mustReturnDeferredResourceReference);
    private object FindResourceInRootOrAppOrTheme(object resourceNameObject, bool allowDeferredResourceReference, bool mustReturnDeferredResourceReference);
    internal object FindResourceInParentChain(object resourceNameObject, bool allowDeferredResourceReference, bool mustReturnDeferredResourceReference);
    internal object LoadResource(string resourceNameString);
    private object GetObjectDataFromContext(ReaderContextStackData context);
    internal object GetCurrentObjectData();
    protected object GetParentObjectData();
    internal void PushContext(ReaderFlags contextFlags, object contextData, Type expectedType, short expectedTypeId);
    internal void PushContext(ReaderFlags contextFlags, object contextData, Type expectedType, short expectedTypeId, bool createUsingTypeConverter);
    internal void PopContext();
    private Uri GetBaseUri();
    private bool ElementInitialize(object element, string name);
    private void ElementEndInit(Object& element);
    private void SetPropertyValueToParent(bool fromStartTag);
    private void SetPropertyValueToParent(bool fromStartTag, Boolean& isMarkupExtension);
    private Type GetParentType();
    private object GetElementValue(object element, object parent, object contentProperty, Boolean& isMarkupExtension);
    private bool CheckExplicitCollectionTag(Boolean& isMarkupExtension);
    private void AddToContentProperty(object container, object contentProperty, object value);
    internal string GetPropertyNameFromAttributeId(short id);
    internal string GetPropertyValueFromStringId(short id);
    private XamlSerializer CreateSerializer(BamlTypeInfoWithSerializerRecord typeWithSerializerInfo);
    internal object GetREOrEiFromAttributeId(short id, Boolean& isInternal, Boolean& isRE);
    private string GetPropNameFrom(object PiOrAttribInfo);
    protected void ThrowException(string id);
    protected internal void ThrowException(string id, string parameter);
    protected void ThrowException(string id, string parameter1, string parameter2);
    protected void ThrowException(string id, string parameter1, string parameter2, string parameter3);
    internal void ThrowExceptionWithLine(string message, Exception innerException);
    internal object CreateInstanceFromType(Type type, short typeId, bool throwOnFail);
    internal void FreezeIfRequired(object element);
    internal void PreParsedBamlReset();
    protected internal void SetPreviousBamlRecordReader(BamlRecordReader previousBamlRecordReader);
    internal BamlRecord get_PreParsedRecordsStart();
    internal void set_PreParsedRecordsStart(BamlRecord value);
    internal BamlRecord get_PreParsedCurrentRecord();
    internal void set_PreParsedCurrentRecord(BamlRecord value);
    internal Stream get_BamlStream();
    internal void set_BamlStream(Stream value);
    internal BamlBinaryReader get_BinaryReader();
    internal XamlTypeMapper get_XamlTypeMapper();
    internal ParserContext get_ParserContext();
    internal void set_ParserContext(ParserContext value);
    internal TypeConvertContext get_TypeConvertContext();
    internal XamlParseMode get_XamlParseMode();
    internal void set_XamlParseMode(XamlParseMode value);
    internal int get_MaxAsyncRecords();
    internal void set_MaxAsyncRecords(int value);
    internal BamlMapTable get_MapTable();
    internal XmlnsDictionary get_XmlnsDictionary();
    internal ReaderContextStackData get_CurrentContext();
    internal ReaderContextStackData get_ParentContext();
    internal object get_ParentObjectData();
    internal ReaderContextStackData get_GrandParentContext();
    internal object get_GrandParentObjectData();
    internal ReaderContextStackData get_GreatGrandParentContext();
    internal ParserStack get_ReaderContextStack();
    internal BamlRecordManager get_BamlRecordManager();
    internal bool get_EndOfDocument();
    internal void set_EndOfDocument(bool value);
    internal object get_RootElement();
    internal void set_RootElement(object value);
    internal IComponentConnector get_ComponentConnector();
    internal void set_ComponentConnector(IComponentConnector value);
    private ReaderStream get_XamlReaderStream();
    internal ParserStack get_ContextStack();
    internal void set_ContextStack(ParserStack value);
    internal int get_LineNumber();
    internal void set_LineNumber(int value);
    internal int get_LinePosition();
    internal void set_LinePosition(int value);
    internal bool get_IsDebugBamlStream();
    internal void set_IsDebugBamlStream(bool value);
    internal long get_StreamPosition();
    private long get_StreamLength();
    internal bool get_IsRootAlreadyLoaded();
    internal void set_IsRootAlreadyLoaded(bool value);
    internal BamlRecordReader get_PreviousBamlRecordReader();
}
internal enum System.Windows.Markup.BamlRecordType : Enum {
    public byte value__;
    public static BamlRecordType Unknown;
    public static BamlRecordType DocumentStart;
    public static BamlRecordType DocumentEnd;
    public static BamlRecordType ElementStart;
    public static BamlRecordType ElementEnd;
    public static BamlRecordType Property;
    public static BamlRecordType PropertyCustom;
    public static BamlRecordType PropertyComplexStart;
    public static BamlRecordType PropertyComplexEnd;
    public static BamlRecordType PropertyArrayStart;
    public static BamlRecordType PropertyArrayEnd;
    public static BamlRecordType PropertyIListStart;
    public static BamlRecordType PropertyIListEnd;
    public static BamlRecordType PropertyIDictionaryStart;
    public static BamlRecordType PropertyIDictionaryEnd;
    public static BamlRecordType LiteralContent;
    public static BamlRecordType Text;
    public static BamlRecordType TextWithConverter;
    public static BamlRecordType RoutedEvent;
    public static BamlRecordType ClrEvent;
    public static BamlRecordType XmlnsProperty;
    public static BamlRecordType XmlAttribute;
    public static BamlRecordType ProcessingInstruction;
    public static BamlRecordType Comment;
    public static BamlRecordType DefTag;
    public static BamlRecordType DefAttribute;
    public static BamlRecordType EndAttributes;
    public static BamlRecordType PIMapping;
    public static BamlRecordType AssemblyInfo;
    public static BamlRecordType TypeInfo;
    public static BamlRecordType TypeSerializerInfo;
    public static BamlRecordType AttributeInfo;
    public static BamlRecordType StringInfo;
    public static BamlRecordType PropertyStringReference;
    public static BamlRecordType PropertyTypeReference;
    public static BamlRecordType PropertyWithExtension;
    public static BamlRecordType PropertyWithConverter;
    public static BamlRecordType DeferableContentStart;
    public static BamlRecordType DefAttributeKeyString;
    public static BamlRecordType DefAttributeKeyType;
    public static BamlRecordType KeyElementStart;
    public static BamlRecordType KeyElementEnd;
    public static BamlRecordType ConstructorParametersStart;
    public static BamlRecordType ConstructorParametersEnd;
    public static BamlRecordType ConstructorParameterType;
    public static BamlRecordType ConnectionId;
    public static BamlRecordType ContentProperty;
    public static BamlRecordType NamedElementStart;
    public static BamlRecordType StaticResourceStart;
    public static BamlRecordType StaticResourceEnd;
    public static BamlRecordType StaticResourceId;
    public static BamlRecordType TextWithId;
    public static BamlRecordType PresentationOptionsAttribute;
    public static BamlRecordType LineNumberAndPosition;
    public static BamlRecordType LinePosition;
    public static BamlRecordType OptimizedStaticResource;
    public static BamlRecordType PropertyWithStaticResourceId;
    public static BamlRecordType LastRecordType;
}
internal class System.Windows.Markup.BamlRecordWriter : object {
    private XamlTypeMapper _xamlTypeMapper;
    private Stream _bamlStream;
    private BamlBinaryWriter _bamlBinaryWriter;
    private BamlDocumentStartRecord _startDocumentRecord;
    private ParserContext _parserContext;
    private BamlMapTable _bamlMapTable;
    private BamlRecordManager _bamlRecordManager;
    private ITypeDescriptorContext _typeConvertContext;
    private bool _deferLoadingSupport;
    private int _deferElementDepth;
    private bool _deferEndOfStartReached;
    private int _deferComplexPropertyDepth;
    private bool _deferKeyCollecting;
    private ArrayList _deferKeys;
    private ArrayList _deferValues;
    private ArrayList _deferElement;
    private short _staticResourceElementDepth;
    private short _dynamicResourceElementDepth;
    private List`1<ValueDeferRecord> _staticResourceRecordList;
    private bool _debugBamlStream;
    private int _lineNumber;
    private int _linePosition;
    private BamlLineAndPositionRecord _bamlLineAndPositionRecord;
    private BamlLinePositionRecord _bamlLinePositionRecord;
    internal bool UpdateParentNodes { get; }
    public bool DebugBamlStream { get; }
    internal BamlLineAndPositionRecord LineAndPositionRecord { get; }
    internal BamlLinePositionRecord LinePositionRecord { get; }
    public Stream BamlStream { get; }
    internal BamlBinaryWriter BinaryWriter { get; }
    internal BamlMapTable MapTable { get; }
    internal ParserContext ParserContext { get; }
    internal BamlRecordManager BamlRecordManager { get; }
    private BamlDocumentStartRecord DocumentStartRecord { get; private set; }
    private bool CollectingValues { get; }
    private ITypeDescriptorContext TypeConvertContext { get; }
    private bool InStaticResourceSection { get; }
    private bool InDynamicResourceSection { get; }
    public BamlRecordWriter(Stream stream, ParserContext parserContext, bool deferLoadingSupport);
    internal virtual void WriteBamlRecord(BamlRecord bamlRecord, int lineNumber, int linePosition);
    internal virtual bool get_UpdateParentNodes();
    internal void SetParseMode(XamlParseMode xamlParseMode);
    internal virtual void SetMaxAsyncRecords(int maxAsyncRecords);
    public bool get_DebugBamlStream();
    internal BamlLineAndPositionRecord get_LineAndPositionRecord();
    internal BamlLinePositionRecord get_LinePositionRecord();
    internal void WriteDebugExtensionRecord(int lineNumber, int linePosition);
    internal void WriteDocumentStart(XamlDocumentStartNode xamlDocumentNode);
    internal void WriteDocumentEnd(XamlDocumentEndNode xamlDocumentEndNode);
    internal void WriteConnectionId(int connectionId);
    internal void WriteElementStart(XamlElementStartNode xamlElementNode);
    internal void WriteElementEnd(XamlElementEndNode xamlElementEndNode);
    internal void WriteEndAttributes(XamlEndAttributesNode xamlEndAttributesNode);
    internal void WriteLiteralContent(XamlLiteralContentNode xamlLiteralContentNode);
    internal void WriteDefAttributeKeyType(XamlDefAttributeKeyTypeNode xamlDefNode);
    private void TransferOldSharedData(IBamlDictionaryKey oldRecord, IBamlDictionaryKey newRecord);
    private IBamlDictionaryKey FindBamlDictionaryKey(KeyDeferRecord record);
    internal void WriteDefAttribute(XamlDefAttributeNode xamlDefNode);
    internal void WritePresentationOptionsAttribute(XamlPresentationOptionsAttributeNode xamlPresentationOptionsNode);
    internal void WriteNamespacePrefix(XamlXmlnsPropertyNode xamlXmlnsPropertyNode);
    internal void WritePIMapping(XamlPIMappingNode xamlPIMappingNode);
    internal void WritePropertyComplexStart(XamlPropertyComplexStartNode xamlComplexPropertyNode);
    internal void WritePropertyComplexEnd(XamlPropertyComplexEndNode xamlPropertyComplexEnd);
    public void WriteKeyElementStart(XamlElementStartNode xamlKeyElementNode);
    internal void WriteKeyElementEnd(XamlElementEndNode xamlKeyElementEnd);
    internal void WriteConstructorParametersStart(XamlConstructorParametersStartNode xamlConstructorParametersStartNode);
    internal void WriteConstructorParametersEnd(XamlConstructorParametersEndNode xamlConstructorParametersEndNode);
    internal virtual void WriteContentProperty(XamlContentPropertyNode xamlContentPropertyNode);
    internal virtual void WriteProperty(XamlPropertyNode xamlProperty);
    internal virtual void WritePropertyWithExtension(XamlPropertyWithExtensionNode xamlPropertyNode);
    internal virtual void WritePropertyWithType(XamlPropertyWithTypeNode xamlPropertyWithType);
    internal void BaseWriteProperty(XamlPropertyNode xamlProperty);
    internal void WriteClrEvent(XamlClrEventNode xamlClrEventNode);
    internal void WritePropertyArrayStart(XamlPropertyArrayStartNode xamlPropertyArrayStartNode);
    internal virtual void WritePropertyArrayEnd(XamlPropertyArrayEndNode xamlPropertyArrayEndNode);
    internal void WritePropertyIListStart(XamlPropertyIListStartNode xamlPropertyIListStart);
    internal virtual void WritePropertyIListEnd(XamlPropertyIListEndNode xamlPropertyIListEndNode);
    internal void WritePropertyIDictionaryStart(XamlPropertyIDictionaryStartNode xamlPropertyIDictionaryStartNode);
    internal virtual void WritePropertyIDictionaryEnd(XamlPropertyIDictionaryEndNode xamlPropertyIDictionaryEndNode);
    internal void WriteRoutedEvent(XamlRoutedEventNode xamlRoutedEventNode);
    internal void WriteText(XamlTextNode xamlTextNode);
    private void WriteAndReleaseRecord(BamlRecord bamlRecord, XamlNode xamlNode);
    private void WriteDeferableContent(XamlElementEndNode xamlNode);
    private void WriteStaticResource();
    public Stream get_BamlStream();
    internal BamlBinaryWriter get_BinaryWriter();
    internal BamlMapTable get_MapTable();
    internal ParserContext get_ParserContext();
    internal virtual BamlRecordManager get_BamlRecordManager();
    private BamlDocumentStartRecord get_DocumentStartRecord();
    private void set_DocumentStartRecord(BamlDocumentStartRecord value);
    private bool get_CollectingValues();
    private ITypeDescriptorContext get_TypeConvertContext();
    private bool get_InStaticResourceSection();
    private bool get_InDynamicResourceSection();
}
internal class System.Windows.Markup.BamlRoutedEventRecord : BamlStringValueRecord {
    private short _attributeId;
    internal BamlRecordType RecordType { get; }
    internal short AttributeId { get; internal set; }
    internal virtual void LoadRecordData(BinaryReader bamlBinaryReader);
    internal virtual void WriteRecordData(BinaryWriter bamlBinaryWriter);
    internal virtual void Copy(BamlRecord record);
    internal virtual BamlRecordType get_RecordType();
    internal short get_AttributeId();
    internal void set_AttributeId(short value);
}
internal class System.Windows.Markup.BamlStaticResourceEndRecord : BamlElementEndRecord {
    internal BamlRecordType RecordType { get; }
    internal virtual BamlRecordType get_RecordType();
}
internal class System.Windows.Markup.BamlStaticResourceIdRecord : BamlRecord {
    private short _staticResourceId;
    internal BamlRecordType RecordType { get; }
    internal int RecordSize { get; internal set; }
    internal short StaticResourceId { get; internal set; }
    internal virtual void LoadRecordData(BinaryReader bamlBinaryReader);
    internal virtual void WriteRecordData(BinaryWriter bamlBinaryWriter);
    internal virtual void Copy(BamlRecord record);
    internal virtual BamlRecordType get_RecordType();
    internal virtual int get_RecordSize();
    internal virtual void set_RecordSize(int value);
    internal short get_StaticResourceId();
    internal void set_StaticResourceId(short value);
    public virtual string ToString();
}
internal class System.Windows.Markup.BamlStaticResourceStartRecord : BamlElementStartRecord {
    internal BamlRecordType RecordType { get; }
    internal virtual BamlRecordType get_RecordType();
}
internal class System.Windows.Markup.BamlStringInfoRecord : BamlVariableSizedRecord {
    private static Section _stringIdLowSection;
    private static Section _stringIdHighSection;
    private string _value;
    internal short StringId { get; internal set; }
    internal string Value { get; internal set; }
    internal BamlRecordType RecordType { get; }
    internal bool HasSerializer { get; }
    internal static Section LastFlagsSection { get; }
    private static BamlStringInfoRecord();
    internal virtual void LoadRecordData(BinaryReader bamlBinaryReader);
    internal virtual void WriteRecordData(BinaryWriter bamlBinaryWriter);
    internal virtual void Copy(BamlRecord record);
    internal short get_StringId();
    internal void set_StringId(short value);
    internal string get_Value();
    internal void set_Value(string value);
    internal virtual BamlRecordType get_RecordType();
    internal virtual bool get_HasSerializer();
    public virtual string ToString();
    internal static Section get_LastFlagsSection();
}
internal abstract class System.Windows.Markup.BamlStringValueRecord : BamlVariableSizedRecord {
    private string _value;
    internal string Value { get; internal set; }
    internal virtual void LoadRecordData(BinaryReader bamlBinaryReader);
    internal virtual void WriteRecordData(BinaryWriter bamlBinaryWriter);
    internal virtual void Copy(BamlRecord record);
    internal string get_Value();
    internal void set_Value(string value);
}
internal class System.Windows.Markup.BamlTextRecord : BamlStringValueRecord {
    internal BamlRecordType RecordType { get; }
    internal virtual BamlRecordType get_RecordType();
}
internal class System.Windows.Markup.BamlTextWithConverterRecord : BamlTextRecord {
    private short _converterTypeId;
    internal short ConverterTypeId { get; internal set; }
    internal BamlRecordType RecordType { get; }
    internal virtual void LoadRecordData(BinaryReader bamlBinaryReader);
    internal virtual void WriteRecordData(BinaryWriter bamlBinaryWriter);
    internal virtual void Copy(BamlRecord record);
    internal short get_ConverterTypeId();
    internal void set_ConverterTypeId(short value);
    internal virtual BamlRecordType get_RecordType();
}
internal class System.Windows.Markup.BamlTextWithIdRecord : BamlTextRecord {
    private short _valueId;
    internal BamlRecordType RecordType { get; }
    internal short ValueId { get; internal set; }
    internal virtual void LoadRecordData(BinaryReader bamlBinaryReader);
    internal virtual void WriteRecordData(BinaryWriter bamlBinaryWriter);
    internal virtual void Copy(BamlRecord record);
    internal virtual BamlRecordType get_RecordType();
    internal short get_ValueId();
    internal void set_ValueId(short value);
}
internal class System.Windows.Markup.BamlTypeInfoRecord : BamlVariableSizedRecord {
    private static Section _typeIdLowSection;
    private static Section _typeIdHighSection;
    private TypeInfoFlags _typeInfoFlags;
    private short _assemblyId;
    private string _typeFullName;
    private Type _type;
    internal short TypeId { get; internal set; }
    internal short AssemblyId { get; internal set; }
    internal string TypeFullName { get; internal set; }
    internal BamlRecordType RecordType { get; }
    internal Type Type { get; internal set; }
    internal string ClrNamespace { get; }
    internal bool HasSerializer { get; }
    internal bool IsInternalType { get; internal set; }
    internal static Section LastFlagsSection { get; }
    private static BamlTypeInfoRecord();
    internal virtual void LoadRecordData(BinaryReader bamlBinaryReader);
    internal virtual void WriteRecordData(BinaryWriter bamlBinaryWriter);
    internal virtual void Copy(BamlRecord record);
    internal short get_TypeId();
    internal void set_TypeId(short value);
    internal short get_AssemblyId();
    internal void set_AssemblyId(short value);
    internal string get_TypeFullName();
    internal void set_TypeFullName(string value);
    internal virtual BamlRecordType get_RecordType();
    internal Type get_Type();
    internal void set_Type(Type value);
    internal string get_ClrNamespace();
    internal virtual bool get_HasSerializer();
    internal bool get_IsInternalType();
    internal void set_IsInternalType(bool value);
    internal static Section get_LastFlagsSection();
}
internal class System.Windows.Markup.BamlTypeInfoWithSerializerRecord : BamlTypeInfoRecord {
    private short _serializerTypeId;
    private Type _serializerType;
    internal short SerializerTypeId { get; internal set; }
    internal BamlRecordType RecordType { get; }
    internal Type SerializerType { get; internal set; }
    internal bool HasSerializer { get; }
    internal virtual void LoadRecordData(BinaryReader bamlBinaryReader);
    internal virtual void WriteRecordData(BinaryWriter bamlBinaryWriter);
    internal virtual void Copy(BamlRecord record);
    internal short get_SerializerTypeId();
    internal void set_SerializerTypeId(short value);
    internal virtual BamlRecordType get_RecordType();
    internal Type get_SerializerType();
    internal void set_SerializerType(Type value);
    internal virtual bool get_HasSerializer();
}
internal abstract class System.Windows.Markup.BamlVariableSizedRecord : BamlRecord {
    internal static int MaxRecordSizeFieldLength;
    private int _recordSize;
    internal int RecordSize { get; internal set; }
    internal static Section LastFlagsSection { get; }
    internal virtual bool LoadRecordSize(BinaryReader bamlBinaryReader, long bytesAvailable);
    internal static bool LoadVariableRecordSize(BinaryReader bamlBinaryReader, long bytesAvailable, Int32& recordSize);
    protected int ComputeSizeOfVariableLengthRecord(long start, long end);
    internal virtual void Write(BinaryWriter bamlBinaryWriter);
    internal void WriteRecordSize(BinaryWriter bamlBinaryWriter);
    internal virtual void Copy(BamlRecord record);
    internal virtual int get_RecordSize();
    internal virtual void set_RecordSize(int value);
    internal static Section get_LastFlagsSection();
}
internal class System.Windows.Markup.BamlVersionHeader : object {
    internal static VersionPair BamlWriterVersion;
    private FormatVersion _bamlVersion;
    public FormatVersion BamlVersion { get; public set; }
    public static int BinarySerializationSize { get; }
    private static BamlVersionHeader();
    public FormatVersion get_BamlVersion();
    public void set_BamlVersion(FormatVersion value);
    public static int get_BinarySerializationSize();
    internal void LoadVersion(BinaryReader bamlBinaryReader);
    internal void WriteVersion(BinaryWriter bamlBinaryWriter);
}
internal class System.Windows.Markup.BamlWriter : object {
    private BamlRecordWriter _bamlRecordWriter;
    private bool _startDocumentWritten;
    private int _depth;
    private bool _closed;
    private DependencyProperty _dpProperty;
    private ParserStack _nodeTypeStack;
    private Hashtable _assemblies;
    private XamlTypeMapper _xamlTypeMapper;
    private ParserContext _parserContext;
    private MarkupExtensionParser _extensionParser;
    private ArrayList _markupExtensionNodes;
    public BamlWriter(Stream stream);
    public void Close();
    private sealed virtual override string System.Windows.Markup.IParserHelper.LookupNamespace(string prefix);
    private sealed virtual override bool System.Windows.Markup.IParserHelper.GetElementType(bool extensionFirst, string localName, string namespaceURI, String& assemblyName, String& typeFullName, Type& baseType, Type& serializerType);
    private sealed virtual override bool System.Windows.Markup.IParserHelper.CanResolveLocalAssemblies();
    public void WriteStartDocument();
    public void WriteEndDocument();
    public void WriteConnectionId(int connectionId);
    public void WriteStartElement(string assemblyName, string typeFullName, bool isInjected, bool useTypeConverter);
    public void WriteEndElement();
    public void WriteStartConstructor();
    public void WriteEndConstructor();
    public void WriteProperty(string assemblyName, string ownerTypeFullName, string propName, string value, BamlAttributeUsage propUsage);
    public void WriteContentProperty(string assemblyName, string ownerTypeFullName, string propName);
    public void WriteXmlnsProperty(string localName, string xmlNamespace);
    public void WriteDefAttribute(string name, string value);
    public void WritePresentationOptionsAttribute(string name, string value);
    public void WriteStartComplexProperty(string assemblyName, string ownerTypeFullName, string propName);
    public void WriteEndComplexProperty();
    public void WriteLiteralContent(string contents);
    public void WritePIMapping(string xmlNamespace, string clrNamespace, string assemblyName);
    public void WriteText(string textContent, string typeConverterAssemblyName, string typeConverterName);
    public void WriteRoutedEvent(string assemblyName, string ownerTypeFullName, string eventIdName, string handlerName);
    public void WriteEvent(string eventName, string handlerName);
    private void ProcessMarkupExtensionNodes();
    private void VerifyWriteState();
    private void VerifyEndTagState(BamlRecordType expectedStartTag, BamlRecordType endTagBeingWritten);
    private Assembly GetAssembly(string assemblyName);
    private Type GetType(string assemblyName, string typeFullName);
    private object GetDpOrPi(Type ownerType, string propName);
    private void GetDpOrPi(string assemblyName, string ownerTypeFullName, string propName, Object& dpOrPi, Type& ownerType);
    private MethodInfo GetMi(Type ownerType, string propName);
    private MethodInfo GetMi(string assemblyName, string ownerTypeFullName, string propName, Type& ownerType);
    private void Push(BamlRecordType recordType);
    private void Push(BamlRecordType recordType, Type elementType);
    private BamlRecordType Pop();
    private BamlRecordType PeekRecordType();
    private Type PeekElementType();
    private void CheckEndAttributes();
}
internal class System.Windows.Markup.BamlWriterXamlTypeMapper : XamlTypeMapper {
    internal BamlWriterXamlTypeMapper(String[] assemblyNames, NamespaceMapEntry[] namespaceMaps);
    protected sealed virtual bool AllowInternalType(Type type);
}
internal class System.Windows.Markup.BamlXmlnsPropertyRecord : BamlVariableSizedRecord {
    private string _prefix;
    private string _xmlNamespace;
    private Int16[] _assemblyIds;
    internal BamlRecordType RecordType { get; }
    internal string Prefix { get; internal set; }
    internal string XmlNamespace { get; internal set; }
    internal Int16[] AssemblyIds { get; internal set; }
    internal virtual void LoadRecordData(BinaryReader bamlBinaryReader);
    internal virtual void WriteRecordData(BinaryWriter bamlBinaryWriter);
    internal virtual void Copy(BamlRecord record);
    internal virtual BamlRecordType get_RecordType();
    internal string get_Prefix();
    internal void set_Prefix(string value);
    internal string get_XmlNamespace();
    internal void set_XmlNamespace(string value);
    internal Int16[] get_AssemblyIds();
    internal void set_AssemblyIds(Int16[] value);
}
internal class System.Windows.Markup.ClrNamespaceAssemblyPair : ValueType {
    private string _assemblyName;
    private string _clrNamespace;
    internal string AssemblyName { get; }
    internal string ClrNamespace { get; }
    internal ClrNamespaceAssemblyPair(string clrNamespace, string assemblyName);
    internal string get_AssemblyName();
    internal string get_ClrNamespace();
}
public class System.Windows.Markup.ComponentResourceKeyConverter : ExpressionConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
internal class System.Windows.Markup.DefAttributeData : object {
    internal Type TargetType;
    internal Type DeclaringType;
    internal string TargetFullName;
    internal string TargetAssemblyName;
    internal string Args;
    internal string TargetNamespaceUri;
    internal int LineNumber;
    internal int LinePosition;
    internal int Depth;
    internal bool IsSimple;
    internal bool IsUnknownExtension { get; }
    internal DefAttributeData(string targetAssemblyName, string targetFullName, Type targetType, string args, Type declaringType, string targetNamespaceUri, int lineNumber, int linePosition, int depth, bool isSimple);
    internal bool get_IsUnknownExtension();
}
public class System.Windows.Markup.DependencyPropertyConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object source);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
    internal static DependencyProperty ResolveProperty(IServiceProvider serviceProvider, string targetName, object source);
    private static Type GetTypeFromName(XamlSchemaContext schemaContext, IAmbientProvider ambientProvider, string target);
}
public class System.Windows.Markup.EventSetterHandlerConverter : TypeConverter {
    private static Type s_ServiceProviderContextType;
    public virtual bool CanConvertFrom(ITypeDescriptorContext typeDescriptorContext, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext typeDescriptorContext, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext typeDescriptorContext, CultureInfo cultureInfo, object source);
    public virtual object ConvertTo(ITypeDescriptorContext typeDescriptorContext, CultureInfo cultureInfo, object value, Type destinationType);
}
[DefaultMemberAttribute("Item")]
internal class System.Windows.Markup.FilteredXmlReader : XmlTextReader {
    private static string uidLocalName;
    private static string uidNamespace;
    private static string defaultPrefix;
    private string uidPrefix;
    private string uidQualifiedName;
    private bool haveUid;
    public int AttributeCount { get; }
    public bool HasAttributes { get; }
    public string Item { get; }
    public string Item { get; }
    public string Item { get; }
    internal FilteredXmlReader(string xmlFragment, XmlNodeType fragmentType, XmlParserContext context);
    public virtual int get_AttributeCount();
    public virtual bool get_HasAttributes();
    public virtual string get_Item(int attributeIndex);
    public virtual string get_Item(string attributeName);
    public virtual string get_Item(string localName, string namespaceUri);
    public virtual string GetAttribute(int attributeIndex);
    public virtual string GetAttribute(string attributeName);
    public virtual string GetAttribute(string localName, string namespaceUri);
    public virtual void MoveToAttribute(int attributeIndex);
    public virtual bool MoveToAttribute(string attributeName);
    public virtual bool MoveToAttribute(string localName, string namespaceUri);
    public virtual bool MoveToFirstAttribute();
    public virtual bool MoveToNextAttribute();
    public virtual bool Read();
    private void CheckForUidAttribute();
    private bool CheckForUidOrNamespaceRedef(bool previousSuccessValue);
    private void CheckForPrefixUpdate();
    private void CheckForNamespaceRedef();
}
internal interface System.Windows.Markup.IBamlDictionaryKey {
    public int ValuePosition { get; public set; }
    public object KeyObject { get; public set; }
    public long ValuePositionPosition { get; public set; }
    public bool Shared { get; public set; }
    public bool SharedSet { get; public set; }
    public Object[] StaticResourceValues { get; public set; }
    public abstract virtual void UpdateValuePosition(int newPosition, BinaryWriter bamlBinaryWriter);
    public abstract virtual int get_ValuePosition();
    public abstract virtual void set_ValuePosition(int value);
    public abstract virtual object get_KeyObject();
    public abstract virtual void set_KeyObject(object value);
    public abstract virtual long get_ValuePositionPosition();
    public abstract virtual void set_ValuePositionPosition(long value);
    public abstract virtual bool get_Shared();
    public abstract virtual void set_Shared(bool value);
    public abstract virtual bool get_SharedSet();
    public abstract virtual void set_SharedSet(bool value);
    public abstract virtual Object[] get_StaticResourceValues();
    public abstract virtual void set_StaticResourceValues(Object[] value);
}
internal interface System.Windows.Markup.IHaveResources {
    public ResourceDictionary Resources { get; public set; }
    public abstract virtual ResourceDictionary get_Resources();
    public abstract virtual void set_Resources(ResourceDictionary value);
}
internal interface System.Windows.Markup.IOptimizedMarkupExtension {
    public short ExtensionTypeId { get; }
    public short ValueId { get; }
    public bool IsValueTypeExtension { get; }
    public bool IsValueStaticExtension { get; }
    public abstract virtual short get_ExtensionTypeId();
    public abstract virtual short get_ValueId();
    public abstract virtual bool get_IsValueTypeExtension();
    public abstract virtual bool get_IsValueStaticExtension();
}
internal interface System.Windows.Markup.IParserHelper {
    public abstract virtual string LookupNamespace(string prefix);
    public abstract virtual bool GetElementType(bool extensionFirst, string localName, string namespaceURI, String& assemblyName, String& typeFullName, Type& baseType, Type& serializerType);
    public abstract virtual bool CanResolveLocalAssemblies();
}
internal interface System.Windows.Markup.IStreamInfo {
    public Assembly Assembly { get; }
    public abstract virtual Assembly get_Assembly();
}
public interface System.Windows.Markup.IStyleConnector {
    public abstract virtual void Connect(int connectionId, object target);
}
internal enum System.Windows.Markup.KnownElements : Enum {
    public short value__;
    public static KnownElements UnknownElement;
    public static KnownElements AccessText;
    public static KnownElements AdornedElementPlaceholder;
    public static KnownElements Adorner;
    public static KnownElements AdornerDecorator;
    public static KnownElements AdornerLayer;
    public static KnownElements AffineTransform3D;
    public static KnownElements AmbientLight;
    public static KnownElements AnchoredBlock;
    public static KnownElements Animatable;
    public static KnownElements AnimationClock;
    public static KnownElements AnimationTimeline;
    public static KnownElements Application;
    public static KnownElements ArcSegment;
    public static KnownElements ArrayExtension;
    public static KnownElements AxisAngleRotation3D;
    public static KnownElements BaseIListConverter;
    public static KnownElements BeginStoryboard;
    public static KnownElements BevelBitmapEffect;
    public static KnownElements BezierSegment;
    public static KnownElements Binding;
    public static KnownElements BindingBase;
    public static KnownElements BindingExpression;
    public static KnownElements BindingExpressionBase;
    public static KnownElements BindingListCollectionView;
    public static KnownElements BitmapDecoder;
    public static KnownElements BitmapEffect;
    public static KnownElements BitmapEffectCollection;
    public static KnownElements BitmapEffectGroup;
    public static KnownElements BitmapEffectInput;
    public static KnownElements BitmapEncoder;
    public static KnownElements BitmapFrame;
    public static KnownElements BitmapImage;
    public static KnownElements BitmapMetadata;
    public static KnownElements BitmapPalette;
    public static KnownElements BitmapSource;
    public static KnownElements Block;
    public static KnownElements BlockUIContainer;
    public static KnownElements BlurBitmapEffect;
    public static KnownElements BmpBitmapDecoder;
    public static KnownElements BmpBitmapEncoder;
    public static KnownElements Bold;
    public static KnownElements BoolIListConverter;
    public static KnownElements Boolean;
    public static KnownElements BooleanAnimationBase;
    public static KnownElements BooleanAnimationUsingKeyFrames;
    public static KnownElements BooleanConverter;
    public static KnownElements BooleanKeyFrame;
    public static KnownElements BooleanKeyFrameCollection;
    public static KnownElements BooleanToVisibilityConverter;
    public static KnownElements Border;
    public static KnownElements BorderGapMaskConverter;
    public static KnownElements Brush;
    public static KnownElements BrushConverter;
    public static KnownElements BulletDecorator;
    public static KnownElements Button;
    public static KnownElements ButtonBase;
    public static KnownElements Byte;
    public static KnownElements ByteAnimation;
    public static KnownElements ByteAnimationBase;
    public static KnownElements ByteAnimationUsingKeyFrames;
    public static KnownElements ByteConverter;
    public static KnownElements ByteKeyFrame;
    public static KnownElements ByteKeyFrameCollection;
    public static KnownElements CachedBitmap;
    public static KnownElements Camera;
    public static KnownElements Canvas;
    public static KnownElements Char;
    public static KnownElements CharAnimationBase;
    public static KnownElements CharAnimationUsingKeyFrames;
    public static KnownElements CharConverter;
    public static KnownElements CharIListConverter;
    public static KnownElements CharKeyFrame;
    public static KnownElements CharKeyFrameCollection;
    public static KnownElements CheckBox;
    public static KnownElements Clock;
    public static KnownElements ClockController;
    public static KnownElements ClockGroup;
    public static KnownElements CollectionContainer;
    public static KnownElements CollectionView;
    public static KnownElements CollectionViewSource;
    public static KnownElements Color;
    public static KnownElements ColorAnimation;
    public static KnownElements ColorAnimationBase;
    public static KnownElements ColorAnimationUsingKeyFrames;
    public static KnownElements ColorConvertedBitmap;
    public static KnownElements ColorConvertedBitmapExtension;
    public static KnownElements ColorConverter;
    public static KnownElements ColorKeyFrame;
    public static KnownElements ColorKeyFrameCollection;
    public static KnownElements ColumnDefinition;
    public static KnownElements CombinedGeometry;
    public static KnownElements ComboBox;
    public static KnownElements ComboBoxItem;
    public static KnownElements CommandConverter;
    public static KnownElements ComponentResourceKey;
    public static KnownElements ComponentResourceKeyConverter;
    public static KnownElements CompositionTarget;
    public static KnownElements Condition;
    public static KnownElements ContainerVisual;
    public static KnownElements ContentControl;
    public static KnownElements ContentElement;
    public static KnownElements ContentPresenter;
    public static KnownElements ContentPropertyAttribute;
    public static KnownElements ContentWrapperAttribute;
    public static KnownElements ContextMenu;
    public static KnownElements ContextMenuService;
    public static KnownElements Control;
    public static KnownElements ControlTemplate;
    public static KnownElements ControllableStoryboardAction;
    public static KnownElements CornerRadius;
    public static KnownElements CornerRadiusConverter;
    public static KnownElements CroppedBitmap;
    public static KnownElements CultureInfo;
    public static KnownElements CultureInfoConverter;
    public static KnownElements CultureInfoIetfLanguageTagConverter;
    public static KnownElements Cursor;
    public static KnownElements CursorConverter;
    public static KnownElements DashStyle;
    public static KnownElements DataChangedEventManager;
    public static KnownElements DataTemplate;
    public static KnownElements DataTemplateKey;
    public static KnownElements DataTrigger;
    public static KnownElements DateTime;
    public static KnownElements DateTimeConverter;
    public static KnownElements DateTimeConverter2;
    public static KnownElements Decimal;
    public static KnownElements DecimalAnimation;
    public static KnownElements DecimalAnimationBase;
    public static KnownElements DecimalAnimationUsingKeyFrames;
    public static KnownElements DecimalConverter;
    public static KnownElements DecimalKeyFrame;
    public static KnownElements DecimalKeyFrameCollection;
    public static KnownElements Decorator;
    public static KnownElements DefinitionBase;
    public static KnownElements DependencyObject;
    public static KnownElements DependencyProperty;
    public static KnownElements DependencyPropertyConverter;
    public static KnownElements DialogResultConverter;
    public static KnownElements DiffuseMaterial;
    public static KnownElements DirectionalLight;
    public static KnownElements DiscreteBooleanKeyFrame;
    public static KnownElements DiscreteByteKeyFrame;
    public static KnownElements DiscreteCharKeyFrame;
    public static KnownElements DiscreteColorKeyFrame;
    public static KnownElements DiscreteDecimalKeyFrame;
    public static KnownElements DiscreteDoubleKeyFrame;
    public static KnownElements DiscreteInt16KeyFrame;
    public static KnownElements DiscreteInt32KeyFrame;
    public static KnownElements DiscreteInt64KeyFrame;
    public static KnownElements DiscreteMatrixKeyFrame;
    public static KnownElements DiscreteObjectKeyFrame;
    public static KnownElements DiscretePoint3DKeyFrame;
    public static KnownElements DiscretePointKeyFrame;
    public static KnownElements DiscreteQuaternionKeyFrame;
    public static KnownElements DiscreteRectKeyFrame;
    public static KnownElements DiscreteRotation3DKeyFrame;
    public static KnownElements DiscreteSingleKeyFrame;
    public static KnownElements DiscreteSizeKeyFrame;
    public static KnownElements DiscreteStringKeyFrame;
    public static KnownElements DiscreteThicknessKeyFrame;
    public static KnownElements DiscreteVector3DKeyFrame;
    public static KnownElements DiscreteVectorKeyFrame;
    public static KnownElements DockPanel;
    public static KnownElements DocumentPageView;
    public static KnownElements DocumentReference;
    public static KnownElements DocumentViewer;
    public static KnownElements DocumentViewerBase;
    public static KnownElements Double;
    public static KnownElements DoubleAnimation;
    public static KnownElements DoubleAnimationBase;
    public static KnownElements DoubleAnimationUsingKeyFrames;
    public static KnownElements DoubleAnimationUsingPath;
    public static KnownElements DoubleCollection;
    public static KnownElements DoubleCollectionConverter;
    public static KnownElements DoubleConverter;
    public static KnownElements DoubleIListConverter;
    public static KnownElements DoubleKeyFrame;
    public static KnownElements DoubleKeyFrameCollection;
    public static KnownElements Drawing;
    public static KnownElements DrawingBrush;
    public static KnownElements DrawingCollection;
    public static KnownElements DrawingContext;
    public static KnownElements DrawingGroup;
    public static KnownElements DrawingImage;
    public static KnownElements DrawingVisual;
    public static KnownElements DropShadowBitmapEffect;
    public static KnownElements Duration;
    public static KnownElements DurationConverter;
    public static KnownElements DynamicResourceExtension;
    public static KnownElements DynamicResourceExtensionConverter;
    public static KnownElements Ellipse;
    public static KnownElements EllipseGeometry;
    public static KnownElements EmbossBitmapEffect;
    public static KnownElements EmissiveMaterial;
    public static KnownElements EnumConverter;
    public static KnownElements EventManager;
    public static KnownElements EventSetter;
    public static KnownElements EventTrigger;
    public static KnownElements Expander;
    public static KnownElements Expression;
    public static KnownElements ExpressionConverter;
    public static KnownElements Figure;
    public static KnownElements FigureLength;
    public static KnownElements FigureLengthConverter;
    public static KnownElements FixedDocument;
    public static KnownElements FixedDocumentSequence;
    public static KnownElements FixedPage;
    public static KnownElements Floater;
    public static KnownElements FlowDocument;
    public static KnownElements FlowDocumentPageViewer;
    public static KnownElements FlowDocumentReader;
    public static KnownElements FlowDocumentScrollViewer;
    public static KnownElements FocusManager;
    public static KnownElements FontFamily;
    public static KnownElements FontFamilyConverter;
    public static KnownElements FontSizeConverter;
    public static KnownElements FontStretch;
    public static KnownElements FontStretchConverter;
    public static KnownElements FontStyle;
    public static KnownElements FontStyleConverter;
    public static KnownElements FontWeight;
    public static KnownElements FontWeightConverter;
    public static KnownElements FormatConvertedBitmap;
    public static KnownElements Frame;
    public static KnownElements FrameworkContentElement;
    public static KnownElements FrameworkElement;
    public static KnownElements FrameworkElementFactory;
    public static KnownElements FrameworkPropertyMetadata;
    public static KnownElements FrameworkPropertyMetadataOptions;
    public static KnownElements FrameworkRichTextComposition;
    public static KnownElements FrameworkTemplate;
    public static KnownElements FrameworkTextComposition;
    public static KnownElements Freezable;
    public static KnownElements GeneralTransform;
    public static KnownElements GeneralTransformCollection;
    public static KnownElements GeneralTransformGroup;
    public static KnownElements Geometry;
    public static KnownElements Geometry3D;
    public static KnownElements GeometryCollection;
    public static KnownElements GeometryConverter;
    public static KnownElements GeometryDrawing;
    public static KnownElements GeometryGroup;
    public static KnownElements GeometryModel3D;
    public static KnownElements GestureRecognizer;
    public static KnownElements GifBitmapDecoder;
    public static KnownElements GifBitmapEncoder;
    public static KnownElements GlyphRun;
    public static KnownElements GlyphRunDrawing;
    public static KnownElements GlyphTypeface;
    public static KnownElements Glyphs;
    public static KnownElements GradientBrush;
    public static KnownElements GradientStop;
    public static KnownElements GradientStopCollection;
    public static KnownElements Grid;
    public static KnownElements GridLength;
    public static KnownElements GridLengthConverter;
    public static KnownElements GridSplitter;
    public static KnownElements GridView;
    public static KnownElements GridViewColumn;
    public static KnownElements GridViewColumnHeader;
    public static KnownElements GridViewHeaderRowPresenter;
    public static KnownElements GridViewRowPresenter;
    public static KnownElements GridViewRowPresenterBase;
    public static KnownElements GroupBox;
    public static KnownElements GroupItem;
    public static KnownElements Guid;
    public static KnownElements GuidConverter;
    public static KnownElements GuidelineSet;
    public static KnownElements HeaderedContentControl;
    public static KnownElements HeaderedItemsControl;
    public static KnownElements HierarchicalDataTemplate;
    public static KnownElements HostVisual;
    public static KnownElements Hyperlink;
    public static KnownElements IAddChild;
    public static KnownElements IAddChildInternal;
    public static KnownElements ICommand;
    public static KnownElements IComponentConnector;
    public static KnownElements INameScope;
    public static KnownElements IStyleConnector;
    public static KnownElements IconBitmapDecoder;
    public static KnownElements Image;
    public static KnownElements ImageBrush;
    public static KnownElements ImageDrawing;
    public static KnownElements ImageMetadata;
    public static KnownElements ImageSource;
    public static KnownElements ImageSourceConverter;
    public static KnownElements InPlaceBitmapMetadataWriter;
    public static KnownElements InkCanvas;
    public static KnownElements InkPresenter;
    public static KnownElements Inline;
    public static KnownElements InlineCollection;
    public static KnownElements InlineUIContainer;
    public static KnownElements InputBinding;
    public static KnownElements InputDevice;
    public static KnownElements InputLanguageManager;
    public static KnownElements InputManager;
    public static KnownElements InputMethod;
    public static KnownElements InputScope;
    public static KnownElements InputScopeConverter;
    public static KnownElements InputScopeName;
    public static KnownElements InputScopeNameConverter;
    public static KnownElements Int16;
    public static KnownElements Int16Animation;
    public static KnownElements Int16AnimationBase;
    public static KnownElements Int16AnimationUsingKeyFrames;
    public static KnownElements Int16Converter;
    public static KnownElements Int16KeyFrame;
    public static KnownElements Int16KeyFrameCollection;
    public static KnownElements Int32;
    public static KnownElements Int32Animation;
    public static KnownElements Int32AnimationBase;
    public static KnownElements Int32AnimationUsingKeyFrames;
    public static KnownElements Int32Collection;
    public static KnownElements Int32CollectionConverter;
    public static KnownElements Int32Converter;
    public static KnownElements Int32KeyFrame;
    public static KnownElements Int32KeyFrameCollection;
    public static KnownElements Int32Rect;
    public static KnownElements Int32RectConverter;
    public static KnownElements Int64;
    public static KnownElements Int64Animation;
    public static KnownElements Int64AnimationBase;
    public static KnownElements Int64AnimationUsingKeyFrames;
    public static KnownElements Int64Converter;
    public static KnownElements Int64KeyFrame;
    public static KnownElements Int64KeyFrameCollection;
    public static KnownElements Italic;
    public static KnownElements ItemCollection;
    public static KnownElements ItemsControl;
    public static KnownElements ItemsPanelTemplate;
    public static KnownElements ItemsPresenter;
    public static KnownElements JournalEntry;
    public static KnownElements JournalEntryListConverter;
    public static KnownElements JournalEntryUnifiedViewConverter;
    public static KnownElements JpegBitmapDecoder;
    public static KnownElements JpegBitmapEncoder;
    public static KnownElements KeyBinding;
    public static KnownElements KeyConverter;
    public static KnownElements KeyGesture;
    public static KnownElements KeyGestureConverter;
    public static KnownElements KeySpline;
    public static KnownElements KeySplineConverter;
    public static KnownElements KeyTime;
    public static KnownElements KeyTimeConverter;
    public static KnownElements KeyboardDevice;
    public static KnownElements Label;
    public static KnownElements LateBoundBitmapDecoder;
    public static KnownElements LengthConverter;
    public static KnownElements Light;
    public static KnownElements Line;
    public static KnownElements LineBreak;
    public static KnownElements LineGeometry;
    public static KnownElements LineSegment;
    public static KnownElements LinearByteKeyFrame;
    public static KnownElements LinearColorKeyFrame;
    public static KnownElements LinearDecimalKeyFrame;
    public static KnownElements LinearDoubleKeyFrame;
    public static KnownElements LinearGradientBrush;
    public static KnownElements LinearInt16KeyFrame;
    public static KnownElements LinearInt32KeyFrame;
    public static KnownElements LinearInt64KeyFrame;
    public static KnownElements LinearPoint3DKeyFrame;
    public static KnownElements LinearPointKeyFrame;
    public static KnownElements LinearQuaternionKeyFrame;
    public static KnownElements LinearRectKeyFrame;
    public static KnownElements LinearRotation3DKeyFrame;
    public static KnownElements LinearSingleKeyFrame;
    public static KnownElements LinearSizeKeyFrame;
    public static KnownElements LinearThicknessKeyFrame;
    public static KnownElements LinearVector3DKeyFrame;
    public static KnownElements LinearVectorKeyFrame;
    public static KnownElements List;
    public static KnownElements ListBox;
    public static KnownElements ListBoxItem;
    public static KnownElements ListCollectionView;
    public static KnownElements ListItem;
    public static KnownElements ListView;
    public static KnownElements ListViewItem;
    public static KnownElements Localization;
    public static KnownElements LostFocusEventManager;
    public static KnownElements MarkupExtension;
    public static KnownElements Material;
    public static KnownElements MaterialCollection;
    public static KnownElements MaterialGroup;
    public static KnownElements Matrix;
    public static KnownElements Matrix3D;
    public static KnownElements Matrix3DConverter;
    public static KnownElements MatrixAnimationBase;
    public static KnownElements MatrixAnimationUsingKeyFrames;
    public static KnownElements MatrixAnimationUsingPath;
    public static KnownElements MatrixCamera;
    public static KnownElements MatrixConverter;
    public static KnownElements MatrixKeyFrame;
    public static KnownElements MatrixKeyFrameCollection;
    public static KnownElements MatrixTransform;
    public static KnownElements MatrixTransform3D;
    public static KnownElements MediaClock;
    public static KnownElements MediaElement;
    public static KnownElements MediaPlayer;
    public static KnownElements MediaTimeline;
    public static KnownElements Menu;
    public static KnownElements MenuBase;
    public static KnownElements MenuItem;
    public static KnownElements MenuScrollingVisibilityConverter;
    public static KnownElements MeshGeometry3D;
    public static KnownElements Model3D;
    public static KnownElements Model3DCollection;
    public static KnownElements Model3DGroup;
    public static KnownElements ModelVisual3D;
    public static KnownElements ModifierKeysConverter;
    public static KnownElements MouseActionConverter;
    public static KnownElements MouseBinding;
    public static KnownElements MouseDevice;
    public static KnownElements MouseGesture;
    public static KnownElements MouseGestureConverter;
    public static KnownElements MultiBinding;
    public static KnownElements MultiBindingExpression;
    public static KnownElements MultiDataTrigger;
    public static KnownElements MultiTrigger;
    public static KnownElements NameScope;
    public static KnownElements NavigationWindow;
    public static KnownElements NullExtension;
    public static KnownElements NullableBoolConverter;
    public static KnownElements NullableConverter;
    public static KnownElements NumberSubstitution;
    public static KnownElements Object;
    public static KnownElements ObjectAnimationBase;
    public static KnownElements ObjectAnimationUsingKeyFrames;
    public static KnownElements ObjectDataProvider;
    public static KnownElements ObjectKeyFrame;
    public static KnownElements ObjectKeyFrameCollection;
    public static KnownElements OrthographicCamera;
    public static KnownElements OuterGlowBitmapEffect;
    public static KnownElements Page;
    public static KnownElements PageContent;
    public static KnownElements PageFunctionBase;
    public static KnownElements Panel;
    public static KnownElements Paragraph;
    public static KnownElements ParallelTimeline;
    public static KnownElements ParserContext;
    public static KnownElements PasswordBox;
    public static KnownElements Path;
    public static KnownElements PathFigure;
    public static KnownElements PathFigureCollection;
    public static KnownElements PathFigureCollectionConverter;
    public static KnownElements PathGeometry;
    public static KnownElements PathSegment;
    public static KnownElements PathSegmentCollection;
    public static KnownElements PauseStoryboard;
    public static KnownElements Pen;
    public static KnownElements PerspectiveCamera;
    public static KnownElements PixelFormat;
    public static KnownElements PixelFormatConverter;
    public static KnownElements PngBitmapDecoder;
    public static KnownElements PngBitmapEncoder;
    public static KnownElements Point;
    public static KnownElements Point3D;
    public static KnownElements Point3DAnimation;
    public static KnownElements Point3DAnimationBase;
    public static KnownElements Point3DAnimationUsingKeyFrames;
    public static KnownElements Point3DCollection;
    public static KnownElements Point3DCollectionConverter;
    public static KnownElements Point3DConverter;
    public static KnownElements Point3DKeyFrame;
    public static KnownElements Point3DKeyFrameCollection;
    public static KnownElements Point4D;
    public static KnownElements Point4DConverter;
    public static KnownElements PointAnimation;
    public static KnownElements PointAnimationBase;
    public static KnownElements PointAnimationUsingKeyFrames;
    public static KnownElements PointAnimationUsingPath;
    public static KnownElements PointCollection;
    public static KnownElements PointCollectionConverter;
    public static KnownElements PointConverter;
    public static KnownElements PointIListConverter;
    public static KnownElements PointKeyFrame;
    public static KnownElements PointKeyFrameCollection;
    public static KnownElements PointLight;
    public static KnownElements PointLightBase;
    public static KnownElements PolyBezierSegment;
    public static KnownElements PolyLineSegment;
    public static KnownElements PolyQuadraticBezierSegment;
    public static KnownElements Polygon;
    public static KnownElements Polyline;
    public static KnownElements Popup;
    public static KnownElements PresentationSource;
    public static KnownElements PriorityBinding;
    public static KnownElements PriorityBindingExpression;
    public static KnownElements ProgressBar;
    public static KnownElements ProjectionCamera;
    public static KnownElements PropertyPath;
    public static KnownElements PropertyPathConverter;
    public static KnownElements QuadraticBezierSegment;
    public static KnownElements Quaternion;
    public static KnownElements QuaternionAnimation;
    public static KnownElements QuaternionAnimationBase;
    public static KnownElements QuaternionAnimationUsingKeyFrames;
    public static KnownElements QuaternionConverter;
    public static KnownElements QuaternionKeyFrame;
    public static KnownElements QuaternionKeyFrameCollection;
    public static KnownElements QuaternionRotation3D;
    public static KnownElements RadialGradientBrush;
    public static KnownElements RadioButton;
    public static KnownElements RangeBase;
    public static KnownElements Rect;
    public static KnownElements Rect3D;
    public static KnownElements Rect3DConverter;
    public static KnownElements RectAnimation;
    public static KnownElements RectAnimationBase;
    public static KnownElements RectAnimationUsingKeyFrames;
    public static KnownElements RectConverter;
    public static KnownElements RectKeyFrame;
    public static KnownElements RectKeyFrameCollection;
    public static KnownElements Rectangle;
    public static KnownElements RectangleGeometry;
    public static KnownElements RelativeSource;
    public static KnownElements RemoveStoryboard;
    public static KnownElements RenderOptions;
    public static KnownElements RenderTargetBitmap;
    public static KnownElements RepeatBehavior;
    public static KnownElements RepeatBehaviorConverter;
    public static KnownElements RepeatButton;
    public static KnownElements ResizeGrip;
    public static KnownElements ResourceDictionary;
    public static KnownElements ResourceKey;
    public static KnownElements ResumeStoryboard;
    public static KnownElements RichTextBox;
    public static KnownElements RotateTransform;
    public static KnownElements RotateTransform3D;
    public static KnownElements Rotation3D;
    public static KnownElements Rotation3DAnimation;
    public static KnownElements Rotation3DAnimationBase;
    public static KnownElements Rotation3DAnimationUsingKeyFrames;
    public static KnownElements Rotation3DKeyFrame;
    public static KnownElements Rotation3DKeyFrameCollection;
    public static KnownElements RoutedCommand;
    public static KnownElements RoutedEvent;
    public static KnownElements RoutedEventConverter;
    public static KnownElements RoutedUICommand;
    public static KnownElements RoutingStrategy;
    public static KnownElements RowDefinition;
    public static KnownElements Run;
    public static KnownElements RuntimeNamePropertyAttribute;
    public static KnownElements SByte;
    public static KnownElements SByteConverter;
    public static KnownElements ScaleTransform;
    public static KnownElements ScaleTransform3D;
    public static KnownElements ScrollBar;
    public static KnownElements ScrollContentPresenter;
    public static KnownElements ScrollViewer;
    public static KnownElements Section;
    public static KnownElements SeekStoryboard;
    public static KnownElements Selector;
    public static KnownElements Separator;
    public static KnownElements SetStoryboardSpeedRatio;
    public static KnownElements Setter;
    public static KnownElements SetterBase;
    public static KnownElements Shape;
    public static KnownElements Single;
    public static KnownElements SingleAnimation;
    public static KnownElements SingleAnimationBase;
    public static KnownElements SingleAnimationUsingKeyFrames;
    public static KnownElements SingleConverter;
    public static KnownElements SingleKeyFrame;
    public static KnownElements SingleKeyFrameCollection;
    public static KnownElements Size;
    public static KnownElements Size3D;
    public static KnownElements Size3DConverter;
    public static KnownElements SizeAnimation;
    public static KnownElements SizeAnimationBase;
    public static KnownElements SizeAnimationUsingKeyFrames;
    public static KnownElements SizeConverter;
    public static KnownElements SizeKeyFrame;
    public static KnownElements SizeKeyFrameCollection;
    public static KnownElements SkewTransform;
    public static KnownElements SkipStoryboardToFill;
    public static KnownElements Slider;
    public static KnownElements SolidColorBrush;
    public static KnownElements SoundPlayerAction;
    public static KnownElements Span;
    public static KnownElements SpecularMaterial;
    public static KnownElements SpellCheck;
    public static KnownElements SplineByteKeyFrame;
    public static KnownElements SplineColorKeyFrame;
    public static KnownElements SplineDecimalKeyFrame;
    public static KnownElements SplineDoubleKeyFrame;
    public static KnownElements SplineInt16KeyFrame;
    public static KnownElements SplineInt32KeyFrame;
    public static KnownElements SplineInt64KeyFrame;
    public static KnownElements SplinePoint3DKeyFrame;
    public static KnownElements SplinePointKeyFrame;
    public static KnownElements SplineQuaternionKeyFrame;
    public static KnownElements SplineRectKeyFrame;
    public static KnownElements SplineRotation3DKeyFrame;
    public static KnownElements SplineSingleKeyFrame;
    public static KnownElements SplineSizeKeyFrame;
    public static KnownElements SplineThicknessKeyFrame;
    public static KnownElements SplineVector3DKeyFrame;
    public static KnownElements SplineVectorKeyFrame;
    public static KnownElements SpotLight;
    public static KnownElements StackPanel;
    public static KnownElements StaticExtension;
    public static KnownElements StaticResourceExtension;
    public static KnownElements StatusBar;
    public static KnownElements StatusBarItem;
    public static KnownElements StickyNoteControl;
    public static KnownElements StopStoryboard;
    public static KnownElements Storyboard;
    public static KnownElements StreamGeometry;
    public static KnownElements StreamGeometryContext;
    public static KnownElements StreamResourceInfo;
    public static KnownElements String;
    public static KnownElements StringAnimationBase;
    public static KnownElements StringAnimationUsingKeyFrames;
    public static KnownElements StringConverter;
    public static KnownElements StringKeyFrame;
    public static KnownElements StringKeyFrameCollection;
    public static KnownElements StrokeCollection;
    public static KnownElements StrokeCollectionConverter;
    public static KnownElements Style;
    public static KnownElements Stylus;
    public static KnownElements StylusDevice;
    public static KnownElements TabControl;
    public static KnownElements TabItem;
    public static KnownElements TabPanel;
    public static KnownElements Table;
    public static KnownElements TableCell;
    public static KnownElements TableColumn;
    public static KnownElements TableRow;
    public static KnownElements TableRowGroup;
    public static KnownElements TabletDevice;
    public static KnownElements TemplateBindingExpression;
    public static KnownElements TemplateBindingExpressionConverter;
    public static KnownElements TemplateBindingExtension;
    public static KnownElements TemplateBindingExtensionConverter;
    public static KnownElements TemplateKey;
    public static KnownElements TemplateKeyConverter;
    public static KnownElements TextBlock;
    public static KnownElements TextBox;
    public static KnownElements TextBoxBase;
    public static KnownElements TextComposition;
    public static KnownElements TextCompositionManager;
    public static KnownElements TextDecoration;
    public static KnownElements TextDecorationCollection;
    public static KnownElements TextDecorationCollectionConverter;
    public static KnownElements TextEffect;
    public static KnownElements TextEffectCollection;
    public static KnownElements TextElement;
    public static KnownElements TextSearch;
    public static KnownElements ThemeDictionaryExtension;
    public static KnownElements Thickness;
    public static KnownElements ThicknessAnimation;
    public static KnownElements ThicknessAnimationBase;
    public static KnownElements ThicknessAnimationUsingKeyFrames;
    public static KnownElements ThicknessConverter;
    public static KnownElements ThicknessKeyFrame;
    public static KnownElements ThicknessKeyFrameCollection;
    public static KnownElements Thumb;
    public static KnownElements TickBar;
    public static KnownElements TiffBitmapDecoder;
    public static KnownElements TiffBitmapEncoder;
    public static KnownElements TileBrush;
    public static KnownElements TimeSpan;
    public static KnownElements TimeSpanConverter;
    public static KnownElements Timeline;
    public static KnownElements TimelineCollection;
    public static KnownElements TimelineGroup;
    public static KnownElements ToggleButton;
    public static KnownElements ToolBar;
    public static KnownElements ToolBarOverflowPanel;
    public static KnownElements ToolBarPanel;
    public static KnownElements ToolBarTray;
    public static KnownElements ToolTip;
    public static KnownElements ToolTipService;
    public static KnownElements Track;
    public static KnownElements Transform;
    public static KnownElements Transform3D;
    public static KnownElements Transform3DCollection;
    public static KnownElements Transform3DGroup;
    public static KnownElements TransformCollection;
    public static KnownElements TransformConverter;
    public static KnownElements TransformGroup;
    public static KnownElements TransformedBitmap;
    public static KnownElements TranslateTransform;
    public static KnownElements TranslateTransform3D;
    public static KnownElements TreeView;
    public static KnownElements TreeViewItem;
    public static KnownElements Trigger;
    public static KnownElements TriggerAction;
    public static KnownElements TriggerBase;
    public static KnownElements TypeExtension;
    public static KnownElements TypeTypeConverter;
    public static KnownElements Typography;
    public static KnownElements UIElement;
    public static KnownElements UInt16;
    public static KnownElements UInt16Converter;
    public static KnownElements UInt32;
    public static KnownElements UInt32Converter;
    public static KnownElements UInt64;
    public static KnownElements UInt64Converter;
    public static KnownElements UShortIListConverter;
    public static KnownElements Underline;
    public static KnownElements UniformGrid;
    public static KnownElements Uri;
    public static KnownElements UriTypeConverter;
    public static KnownElements UserControl;
    public static KnownElements Validation;
    public static KnownElements Vector;
    public static KnownElements Vector3D;
    public static KnownElements Vector3DAnimation;
    public static KnownElements Vector3DAnimationBase;
    public static KnownElements Vector3DAnimationUsingKeyFrames;
    public static KnownElements Vector3DCollection;
    public static KnownElements Vector3DCollectionConverter;
    public static KnownElements Vector3DConverter;
    public static KnownElements Vector3DKeyFrame;
    public static KnownElements Vector3DKeyFrameCollection;
    public static KnownElements VectorAnimation;
    public static KnownElements VectorAnimationBase;
    public static KnownElements VectorAnimationUsingKeyFrames;
    public static KnownElements VectorCollection;
    public static KnownElements VectorCollectionConverter;
    public static KnownElements VectorConverter;
    public static KnownElements VectorKeyFrame;
    public static KnownElements VectorKeyFrameCollection;
    public static KnownElements VideoDrawing;
    public static KnownElements ViewBase;
    public static KnownElements Viewbox;
    public static KnownElements Viewport3D;
    public static KnownElements Viewport3DVisual;
    public static KnownElements VirtualizingPanel;
    public static KnownElements VirtualizingStackPanel;
    public static KnownElements Visual;
    public static KnownElements Visual3D;
    public static KnownElements VisualBrush;
    public static KnownElements VisualTarget;
    public static KnownElements WeakEventManager;
    public static KnownElements WhitespaceSignificantCollectionAttribute;
    public static KnownElements Window;
    public static KnownElements WmpBitmapDecoder;
    public static KnownElements WmpBitmapEncoder;
    public static KnownElements WrapPanel;
    public static KnownElements WriteableBitmap;
    public static KnownElements XamlBrushSerializer;
    public static KnownElements XamlInt32CollectionSerializer;
    public static KnownElements XamlPathDataSerializer;
    public static KnownElements XamlPoint3DCollectionSerializer;
    public static KnownElements XamlPointCollectionSerializer;
    public static KnownElements XamlReader;
    public static KnownElements XamlStyleSerializer;
    public static KnownElements XamlTemplateSerializer;
    public static KnownElements XamlVector3DCollectionSerializer;
    public static KnownElements XamlWriter;
    public static KnownElements XmlDataProvider;
    public static KnownElements XmlLangPropertyAttribute;
    public static KnownElements XmlLanguage;
    public static KnownElements XmlLanguageConverter;
    public static KnownElements XmlNamespaceMapping;
    public static KnownElements ZoomPercentageConverter;
    public static KnownElements MaxElement;
}
internal enum System.Windows.Markup.KnownProperties : Enum {
    public short value__;
    public static KnownProperties UnknownProperty;
    public static KnownProperties AccessText_Text;
    public static KnownProperties BeginStoryboard_Storyboard;
    public static KnownProperties BitmapEffectGroup_Children;
    public static KnownProperties Border_Background;
    public static KnownProperties Border_BorderBrush;
    public static KnownProperties Border_BorderThickness;
    public static KnownProperties ButtonBase_Command;
    public static KnownProperties ButtonBase_CommandParameter;
    public static KnownProperties ButtonBase_CommandTarget;
    public static KnownProperties ButtonBase_IsPressed;
    public static KnownProperties ColumnDefinition_MaxWidth;
    public static KnownProperties ColumnDefinition_MinWidth;
    public static KnownProperties ColumnDefinition_Width;
    public static KnownProperties ContentControl_Content;
    public static KnownProperties ContentControl_ContentTemplate;
    public static KnownProperties ContentControl_ContentTemplateSelector;
    public static KnownProperties ContentControl_HasContent;
    public static KnownProperties ContentElement_Focusable;
    public static KnownProperties ContentPresenter_Content;
    public static KnownProperties ContentPresenter_ContentSource;
    public static KnownProperties ContentPresenter_ContentTemplate;
    public static KnownProperties ContentPresenter_ContentTemplateSelector;
    public static KnownProperties ContentPresenter_RecognizesAccessKey;
    public static KnownProperties Control_Background;
    public static KnownProperties Control_BorderBrush;
    public static KnownProperties Control_BorderThickness;
    public static KnownProperties Control_FontFamily;
    public static KnownProperties Control_FontSize;
    public static KnownProperties Control_FontStretch;
    public static KnownProperties Control_FontStyle;
    public static KnownProperties Control_FontWeight;
    public static KnownProperties Control_Foreground;
    public static KnownProperties Control_HorizontalContentAlignment;
    public static KnownProperties Control_IsTabStop;
    public static KnownProperties Control_Padding;
    public static KnownProperties Control_TabIndex;
    public static KnownProperties Control_Template;
    public static KnownProperties Control_VerticalContentAlignment;
    public static KnownProperties DockPanel_Dock;
    public static KnownProperties DockPanel_LastChildFill;
    public static KnownProperties DocumentViewerBase_Document;
    public static KnownProperties DrawingGroup_Children;
    public static KnownProperties FlowDocumentReader_Document;
    public static KnownProperties FlowDocumentScrollViewer_Document;
    public static KnownProperties FrameworkContentElement_Style;
    public static KnownProperties FrameworkElement_FlowDirection;
    public static KnownProperties FrameworkElement_Height;
    public static KnownProperties FrameworkElement_HorizontalAlignment;
    public static KnownProperties FrameworkElement_Margin;
    public static KnownProperties FrameworkElement_MaxHeight;
    public static KnownProperties FrameworkElement_MaxWidth;
    public static KnownProperties FrameworkElement_MinHeight;
    public static KnownProperties FrameworkElement_MinWidth;
    public static KnownProperties FrameworkElement_Name;
    public static KnownProperties FrameworkElement_Style;
    public static KnownProperties FrameworkElement_VerticalAlignment;
    public static KnownProperties FrameworkElement_Width;
    public static KnownProperties GeneralTransformGroup_Children;
    public static KnownProperties GeometryGroup_Children;
    public static KnownProperties GradientBrush_GradientStops;
    public static KnownProperties Grid_Column;
    public static KnownProperties Grid_ColumnSpan;
    public static KnownProperties Grid_Row;
    public static KnownProperties Grid_RowSpan;
    public static KnownProperties GridViewColumn_Header;
    public static KnownProperties HeaderedContentControl_HasHeader;
    public static KnownProperties HeaderedContentControl_Header;
    public static KnownProperties HeaderedContentControl_HeaderTemplate;
    public static KnownProperties HeaderedContentControl_HeaderTemplateSelector;
    public static KnownProperties HeaderedItemsControl_HasHeader;
    public static KnownProperties HeaderedItemsControl_Header;
    public static KnownProperties HeaderedItemsControl_HeaderTemplate;
    public static KnownProperties HeaderedItemsControl_HeaderTemplateSelector;
    public static KnownProperties Hyperlink_NavigateUri;
    public static KnownProperties Image_Source;
    public static KnownProperties Image_Stretch;
    public static KnownProperties ItemsControl_ItemContainerStyle;
    public static KnownProperties ItemsControl_ItemContainerStyleSelector;
    public static KnownProperties ItemsControl_ItemTemplate;
    public static KnownProperties ItemsControl_ItemTemplateSelector;
    public static KnownProperties ItemsControl_ItemsPanel;
    public static KnownProperties ItemsControl_ItemsSource;
    public static KnownProperties MaterialGroup_Children;
    public static KnownProperties Model3DGroup_Children;
    public static KnownProperties Page_Content;
    public static KnownProperties Panel_Background;
    public static KnownProperties Path_Data;
    public static KnownProperties PathFigure_Segments;
    public static KnownProperties PathGeometry_Figures;
    public static KnownProperties Popup_Child;
    public static KnownProperties Popup_IsOpen;
    public static KnownProperties Popup_Placement;
    public static KnownProperties Popup_PopupAnimation;
    public static KnownProperties RowDefinition_Height;
    public static KnownProperties RowDefinition_MaxHeight;
    public static KnownProperties RowDefinition_MinHeight;
    public static KnownProperties ScrollViewer_CanContentScroll;
    public static KnownProperties ScrollViewer_HorizontalScrollBarVisibility;
    public static KnownProperties ScrollViewer_VerticalScrollBarVisibility;
    public static KnownProperties Shape_Fill;
    public static KnownProperties Shape_Stroke;
    public static KnownProperties Shape_StrokeThickness;
    public static KnownProperties TextBlock_Background;
    public static KnownProperties TextBlock_FontFamily;
    public static KnownProperties TextBlock_FontSize;
    public static KnownProperties TextBlock_FontStretch;
    public static KnownProperties TextBlock_FontStyle;
    public static KnownProperties TextBlock_FontWeight;
    public static KnownProperties TextBlock_Foreground;
    public static KnownProperties TextBlock_Text;
    public static KnownProperties TextBlock_TextDecorations;
    public static KnownProperties TextBlock_TextTrimming;
    public static KnownProperties TextBlock_TextWrapping;
    public static KnownProperties TextBox_Text;
    public static KnownProperties TextElement_Background;
    public static KnownProperties TextElement_FontFamily;
    public static KnownProperties TextElement_FontSize;
    public static KnownProperties TextElement_FontStretch;
    public static KnownProperties TextElement_FontStyle;
    public static KnownProperties TextElement_FontWeight;
    public static KnownProperties TextElement_Foreground;
    public static KnownProperties TimelineGroup_Children;
    public static KnownProperties Track_IsDirectionReversed;
    public static KnownProperties Track_Maximum;
    public static KnownProperties Track_Minimum;
    public static KnownProperties Track_Orientation;
    public static KnownProperties Track_Value;
    public static KnownProperties Track_ViewportSize;
    public static KnownProperties Transform3DGroup_Children;
    public static KnownProperties TransformGroup_Children;
    public static KnownProperties UIElement_ClipToBounds;
    public static KnownProperties UIElement_Focusable;
    public static KnownProperties UIElement_IsEnabled;
    public static KnownProperties UIElement_RenderTransform;
    public static KnownProperties UIElement_Visibility;
    public static KnownProperties Viewport3D_Children;
    public static KnownProperties MaxDependencyProperty;
    public static KnownProperties AdornedElementPlaceholder_Child;
    public static KnownProperties AdornerDecorator_Child;
    public static KnownProperties AnchoredBlock_Blocks;
    public static KnownProperties ArrayExtension_Items;
    public static KnownProperties BlockUIContainer_Child;
    public static KnownProperties Bold_Inlines;
    public static KnownProperties BooleanAnimationUsingKeyFrames_KeyFrames;
    public static KnownProperties Border_Child;
    public static KnownProperties BulletDecorator_Child;
    public static KnownProperties Button_Content;
    public static KnownProperties ButtonBase_Content;
    public static KnownProperties ByteAnimationUsingKeyFrames_KeyFrames;
    public static KnownProperties Canvas_Children;
    public static KnownProperties CharAnimationUsingKeyFrames_KeyFrames;
    public static KnownProperties CheckBox_Content;
    public static KnownProperties ColorAnimationUsingKeyFrames_KeyFrames;
    public static KnownProperties ComboBox_Items;
    public static KnownProperties ComboBoxItem_Content;
    public static KnownProperties ContextMenu_Items;
    public static KnownProperties ControlTemplate_VisualTree;
    public static KnownProperties DataTemplate_VisualTree;
    public static KnownProperties DataTrigger_Setters;
    public static KnownProperties DecimalAnimationUsingKeyFrames_KeyFrames;
    public static KnownProperties Decorator_Child;
    public static KnownProperties DockPanel_Children;
    public static KnownProperties DocumentViewer_Document;
    public static KnownProperties DoubleAnimationUsingKeyFrames_KeyFrames;
    public static KnownProperties EventTrigger_Actions;
    public static KnownProperties Expander_Content;
    public static KnownProperties Figure_Blocks;
    public static KnownProperties FixedDocument_Pages;
    public static KnownProperties FixedDocumentSequence_References;
    public static KnownProperties FixedPage_Children;
    public static KnownProperties Floater_Blocks;
    public static KnownProperties FlowDocument_Blocks;
    public static KnownProperties FlowDocumentPageViewer_Document;
    public static KnownProperties FrameworkTemplate_VisualTree;
    public static KnownProperties Grid_Children;
    public static KnownProperties GridView_Columns;
    public static KnownProperties GridViewColumnHeader_Content;
    public static KnownProperties GroupBox_Content;
    public static KnownProperties GroupItem_Content;
    public static KnownProperties HeaderedContentControl_Content;
    public static KnownProperties HeaderedItemsControl_Items;
    public static KnownProperties HierarchicalDataTemplate_VisualTree;
    public static KnownProperties Hyperlink_Inlines;
    public static KnownProperties InkCanvas_Children;
    public static KnownProperties InkPresenter_Child;
    public static KnownProperties InlineUIContainer_Child;
    public static KnownProperties InputScopeName_NameValue;
    public static KnownProperties Int16AnimationUsingKeyFrames_KeyFrames;
    public static KnownProperties Int32AnimationUsingKeyFrames_KeyFrames;
    public static KnownProperties Int64AnimationUsingKeyFrames_KeyFrames;
    public static KnownProperties Italic_Inlines;
    public static KnownProperties ItemsControl_Items;
    public static KnownProperties ItemsPanelTemplate_VisualTree;
    public static KnownProperties Label_Content;
    public static KnownProperties LinearGradientBrush_GradientStops;
    public static KnownProperties List_ListItems;
    public static KnownProperties ListBox_Items;
    public static KnownProperties ListBoxItem_Content;
    public static KnownProperties ListItem_Blocks;
    public static KnownProperties ListView_Items;
    public static KnownProperties ListViewItem_Content;
    public static KnownProperties MatrixAnimationUsingKeyFrames_KeyFrames;
    public static KnownProperties Menu_Items;
    public static KnownProperties MenuBase_Items;
    public static KnownProperties MenuItem_Items;
    public static KnownProperties ModelVisual3D_Children;
    public static KnownProperties MultiBinding_Bindings;
    public static KnownProperties MultiDataTrigger_Setters;
    public static KnownProperties MultiTrigger_Setters;
    public static KnownProperties ObjectAnimationUsingKeyFrames_KeyFrames;
    public static KnownProperties PageContent_Child;
    public static KnownProperties PageFunctionBase_Content;
    public static KnownProperties Panel_Children;
    public static KnownProperties Paragraph_Inlines;
    public static KnownProperties ParallelTimeline_Children;
    public static KnownProperties Point3DAnimationUsingKeyFrames_KeyFrames;
    public static KnownProperties PointAnimationUsingKeyFrames_KeyFrames;
    public static KnownProperties PriorityBinding_Bindings;
    public static KnownProperties QuaternionAnimationUsingKeyFrames_KeyFrames;
    public static KnownProperties RadialGradientBrush_GradientStops;
    public static KnownProperties RadioButton_Content;
    public static KnownProperties RectAnimationUsingKeyFrames_KeyFrames;
    public static KnownProperties RepeatButton_Content;
    public static KnownProperties RichTextBox_Document;
    public static KnownProperties Rotation3DAnimationUsingKeyFrames_KeyFrames;
    public static KnownProperties Run_Text;
    public static KnownProperties ScrollViewer_Content;
    public static KnownProperties Section_Blocks;
    public static KnownProperties Selector_Items;
    public static KnownProperties SingleAnimationUsingKeyFrames_KeyFrames;
    public static KnownProperties SizeAnimationUsingKeyFrames_KeyFrames;
    public static KnownProperties Span_Inlines;
    public static KnownProperties StackPanel_Children;
    public static KnownProperties StatusBar_Items;
    public static KnownProperties StatusBarItem_Content;
    public static KnownProperties Storyboard_Children;
    public static KnownProperties StringAnimationUsingKeyFrames_KeyFrames;
    public static KnownProperties Style_Setters;
    public static KnownProperties TabControl_Items;
    public static KnownProperties TabItem_Content;
    public static KnownProperties TabPanel_Children;
    public static KnownProperties Table_RowGroups;
    public static KnownProperties TableCell_Blocks;
    public static KnownProperties TableRow_Cells;
    public static KnownProperties TableRowGroup_Rows;
    public static KnownProperties TextBlock_Inlines;
    public static KnownProperties ThicknessAnimationUsingKeyFrames_KeyFrames;
    public static KnownProperties ToggleButton_Content;
    public static KnownProperties ToolBar_Items;
    public static KnownProperties ToolBarOverflowPanel_Children;
    public static KnownProperties ToolBarPanel_Children;
    public static KnownProperties ToolBarTray_ToolBars;
    public static KnownProperties ToolTip_Content;
    public static KnownProperties TreeView_Items;
    public static KnownProperties TreeViewItem_Items;
    public static KnownProperties Trigger_Setters;
    public static KnownProperties Underline_Inlines;
    public static KnownProperties UniformGrid_Children;
    public static KnownProperties UserControl_Content;
    public static KnownProperties Vector3DAnimationUsingKeyFrames_KeyFrames;
    public static KnownProperties VectorAnimationUsingKeyFrames_KeyFrames;
    public static KnownProperties Viewbox_Child;
    public static KnownProperties Viewport3DVisual_Children;
    public static KnownProperties VirtualizingPanel_Children;
    public static KnownProperties VirtualizingStackPanel_Children;
    public static KnownProperties Window_Content;
    public static KnownProperties WrapPanel_Children;
    public static KnownProperties XmlDataProvider_XmlSerializer;
    public static KnownProperties MaxProperty;
}
internal static class System.Windows.Markup.KnownTypes : object {
    private static TypeIndexer _typeIndexer;
    internal static TypeIndexer Types { get; }
    private static KnownTypes();
    internal static object CreateKnownElement(KnownElements knownElement);
    internal static DependencyProperty GetKnownDependencyPropertyFromId(KnownProperties knownProperty);
    internal static KnownElements GetKnownElementFromKnownCommonProperty(KnownProperties knownProperty);
    internal static string GetKnownClrPropertyNameFromId(KnownProperties knownProperty);
    internal static IList GetCollectionForCPA(object o, KnownElements knownElement);
    internal static bool CanCollectionTypeAcceptStrings(KnownElements knownElement);
    internal static string GetContentPropertyName(KnownElements knownElement);
    internal static short GetKnownPropertyAttributeId(KnownElements typeID, string fieldName);
    private static bool IsStandardLengthProp(string propName);
    internal static KnownElements GetKnownTypeConverterId(KnownElements knownElement);
    internal static KnownElements GetKnownTypeConverterIdForProperty(KnownElements id, string propName);
    internal static TypeIndexer get_Types();
}
public abstract class System.Windows.Markup.Localizer.BamlLocalizabilityResolver : object {
    public abstract virtual ElementLocalizability GetElementLocalizability(string assembly, string className);
    public abstract virtual LocalizabilityAttribute GetPropertyLocalizability(string assembly, string className, string property);
    public abstract virtual string ResolveFormattingTagToClass(string formattingTag);
    public abstract virtual string ResolveAssemblyFromClass(string className);
}
public class System.Windows.Markup.Localizer.BamlLocalizableResource : object {
    private string _content;
    private string _comments;
    private LocalizationFlags _flags;
    private LocalizationCategory _category;
    public string Content { get; public set; }
    public string Comments { get; public set; }
    public bool Modifiable { get; public set; }
    public bool Readable { get; public set; }
    public LocalizationCategory Category { get; public set; }
    public BamlLocalizableResource(string content, string comments, LocalizationCategory category, bool modifiable, bool readable);
    internal BamlLocalizableResource(BamlLocalizableResource other);
    public string get_Content();
    public void set_Content(string value);
    public string get_Comments();
    public void set_Comments(string value);
    public bool get_Modifiable();
    public void set_Modifiable(bool value);
    public bool get_Readable();
    public void set_Readable(bool value);
    public LocalizationCategory get_Category();
    public void set_Category(LocalizationCategory value);
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
}
public class System.Windows.Markup.Localizer.BamlLocalizableResourceKey : object {
    private string _uid;
    private string _className;
    private string _propertyName;
    private string _assemblyName;
    public string Uid { get; }
    public string ClassName { get; }
    public string PropertyName { get; }
    public string AssemblyName { get; }
    internal BamlLocalizableResourceKey(string uid, string className, string propertyName, string assemblyName);
    public BamlLocalizableResourceKey(string uid, string className, string propertyName);
    public string get_Uid();
    public string get_ClassName();
    public string get_PropertyName();
    public string get_AssemblyName();
    public bool Equals(BamlLocalizableResourceKey other);
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Markup.Localizer.BamlLocalizationDictionary : object {
    private IDictionary`2<BamlLocalizableResourceKey, BamlLocalizableResource> _dictionary;
    private BamlLocalizableResourceKey _rootElementKey;
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    public BamlLocalizableResourceKey RootElementKey { get; }
    public ICollection Keys { get; }
    public ICollection Values { get; }
    public BamlLocalizableResource Item { get; public set; }
    public int Count { get; }
    private object System.Collections.IDictionary.Item { get; private set; }
    private int System.Collections.ICollection.Count { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual bool get_IsReadOnly();
    public BamlLocalizableResourceKey get_RootElementKey();
    public sealed virtual ICollection get_Keys();
    public sealed virtual ICollection get_Values();
    public BamlLocalizableResource get_Item(BamlLocalizableResourceKey key);
    public void set_Item(BamlLocalizableResourceKey key, BamlLocalizableResource value);
    public void Add(BamlLocalizableResourceKey key, BamlLocalizableResource value);
    public sealed virtual void Clear();
    public void Remove(BamlLocalizableResourceKey key);
    public bool Contains(BamlLocalizableResourceKey key);
    public BamlLocalizationDictionaryEnumerator GetEnumerator();
    public int get_Count();
    public void CopyTo(DictionaryEntry[] array, int arrayIndex);
    private sealed virtual override bool System.Collections.IDictionary.Contains(object key);
    private sealed virtual override void System.Collections.IDictionary.Add(object key, object value);
    private sealed virtual override void System.Collections.IDictionary.Remove(object key);
    private sealed virtual override object System.Collections.IDictionary.get_Item(object key);
    private sealed virtual override void System.Collections.IDictionary.set_Item(object key, object value);
    private sealed virtual override IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override int System.Collections.ICollection.get_Count();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    internal BamlLocalizationDictionary Copy();
    internal void SetRootElementKey(BamlLocalizableResourceKey key);
    private void CheckNonNullParam(object param, string paramName);
}
public class System.Windows.Markup.Localizer.BamlLocalizationDictionaryEnumerator : object {
    private IEnumerator _enumerator;
    public DictionaryEntry Entry { get; }
    public BamlLocalizableResourceKey Key { get; }
    public BamlLocalizableResource Value { get; }
    public DictionaryEntry Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    private object System.Collections.IDictionaryEnumerator.Key { get; }
    private object System.Collections.IDictionaryEnumerator.Value { get; }
    internal BamlLocalizationDictionaryEnumerator(IEnumerator enumerator);
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
    public sealed virtual DictionaryEntry get_Entry();
    public BamlLocalizableResourceKey get_Key();
    public BamlLocalizableResource get_Value();
    public DictionaryEntry get_Current();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    private sealed virtual override object System.Collections.IDictionaryEnumerator.get_Key();
    private sealed virtual override object System.Collections.IDictionaryEnumerator.get_Value();
}
public class System.Windows.Markup.Localizer.BamlLocalizer : object {
    [CompilerGeneratedAttribute]
private BamlLocalizerErrorNotifyEventHandler ErrorNotify;
    private BamlTreeMap _bamlTreeMap;
    private BamlTree _tree;
    public BamlLocalizer(Stream source);
    public BamlLocalizer(Stream source, BamlLocalizabilityResolver resolver);
    public BamlLocalizer(Stream source, BamlLocalizabilityResolver resolver, TextReader comments);
    public BamlLocalizationDictionary ExtractResources();
    public void UpdateBaml(Stream target, BamlLocalizationDictionary updates);
    [CompilerGeneratedAttribute]
public void add_ErrorNotify(BamlLocalizerErrorNotifyEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_ErrorNotify(BamlLocalizerErrorNotifyEventHandler value);
    protected virtual void OnErrorNotify(BamlLocalizerErrorNotifyEventArgs e);
    internal void RaiseErrorNotifyEvent(BamlLocalizerErrorNotifyEventArgs e);
}
public enum System.Windows.Markup.Localizer.BamlLocalizerError : Enum {
    public int value__;
    public static BamlLocalizerError DuplicateUid;
    public static BamlLocalizerError DuplicateElement;
    public static BamlLocalizerError IncompleteElementPlaceholder;
    public static BamlLocalizerError InvalidCommentingXml;
    public static BamlLocalizerError InvalidLocalizationAttributes;
    public static BamlLocalizerError InvalidLocalizationComments;
    public static BamlLocalizerError InvalidUid;
    public static BamlLocalizerError MismatchedElements;
    public static BamlLocalizerError SubstitutionAsPlaintext;
    public static BamlLocalizerError UidMissingOnChildElement;
    public static BamlLocalizerError UnknownFormattingTag;
}
public class System.Windows.Markup.Localizer.BamlLocalizerErrorNotifyEventArgs : EventArgs {
    private BamlLocalizableResourceKey _key;
    private BamlLocalizerError _error;
    public BamlLocalizableResourceKey Key { get; }
    public BamlLocalizerError Error { get; }
    internal BamlLocalizerErrorNotifyEventArgs(BamlLocalizableResourceKey key, BamlLocalizerError error);
    public BamlLocalizableResourceKey get_Key();
    public BamlLocalizerError get_Error();
}
public class System.Windows.Markup.Localizer.BamlLocalizerErrorNotifyEventHandler : MulticastDelegate {
    public BamlLocalizerErrorNotifyEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, BamlLocalizerErrorNotifyEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, BamlLocalizerErrorNotifyEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Windows.Markup.Localizer.ElementLocalizability : object {
    private string _formattingTag;
    private LocalizabilityAttribute _attribute;
    public string FormattingTag { get; public set; }
    public LocalizabilityAttribute Attribute { get; public set; }
    public ElementLocalizability(string formattingTag, LocalizabilityAttribute attribute);
    public string get_FormattingTag();
    public void set_FormattingTag(string value);
    public LocalizabilityAttribute get_Attribute();
    public void set_Attribute(LocalizabilityAttribute value);
}
internal class System.Windows.Markup.MarkupExtensionParser : object {
    private IParserHelper _parserHelper;
    private ParserContext _parserContext;
    internal MarkupExtensionParser(IParserHelper parserHelper, ParserContext parserContext);
    internal AttributeData IsMarkupExtensionAttribute(Type declaringType, string propIdName, String& attrValue, int lineNumber, int linePosition, int depth, object info);
    internal DefAttributeData IsMarkupExtensionDefAttribute(Type declaringType, String& attrValue, int lineNumber, int linePosition, int depth);
    internal static bool LooksLikeAMarkupExtension(string attrValue);
    internal static string AddEscapeToLiteralString(string literalString);
    private KnownElements GetKnownExtensionFromType(Type extensionType, String& propName);
    private bool IsSimpleTypeExtensionArgs(Type extensionType, int lineNumber, int linePosition, String& args);
    private bool IsSimpleExtension(Type extensionType, int lineNumber, int linePosition, int depth, Int16& extensionTypeId, Boolean& isValueNestedExtension, Boolean& isValueTypeExtension, String& args);
    private bool IsSimpleExtensionArgs(int lineNumber, int linePosition, string propName, String& args, Type targetType);
    internal static bool GetMarkupExtensionTypeAndArgs(String& attrValue, String& typeName, String& args);
    private DefAttributeData FillDefAttributeData(Type declaringType, string typename, string args, string attributeValue, int lineNumber, int linePosition, int depth);
    private AttributeData FillAttributeData(Type declaringType, string propIdName, string typename, string args, string attributeValue, int lineNumber, int linePosition, int depth, object info);
    private bool GetExtensionType(string typename, string attributeValue, int lineNumber, int linePosition, String& namespaceURI, String& targetAssemblyName, String& targetFullName, Type& targetType, Type& serializerType);
    internal ArrayList CompileAttributes(ArrayList markupExtensionList, int startingDepth);
    internal void CompileAttribute(ArrayList xamlNodes, AttributeData data);
    internal void CompileAttributeCore(ArrayList xamlNodes, AttributeData data);
    internal ArrayList CompileDictionaryKeys(ArrayList complexDefAttributesList, int startingDepth);
    internal void CompileDictionaryKey(ArrayList xamlNodes, DefAttributeData data);
    private ArrayList TokenizeAttributes(string args, int lineNumber, int linePosition, Type extensionType);
    private static void AddToTokenList(ArrayList list, StringBuilder sb, bool trim);
    private ParameterInfo[] FindLongestConstructor(Type extensionType, Int32& maxConstructorArguments);
    private void WriteConstructorParams(ArrayList xamlNodes, ArrayList list, DefAttributeData data, Int32& listIndex);
    private void WriteProperties(ArrayList xamlNodes, ArrayList list, int listIndex, DefAttributeData data);
    private string ResolveAttributeNamespaceURI(string prefix, string name, string parentURI);
    private SpecialBracketCharacters GetBracketCharacterForProperty(string propertyName, Dictionary`2<string, SpecialBracketCharacters> bracketCharacterCache);
    private void CompileProperty(ArrayList xamlNodes, string name, string value, Type parentType, string parentTypeNamespaceUri, AttributeData data, int lineNumber, int linePosition, int depth);
    internal static void RemoveEscapes(String& value);
    private AttributeContext GetAttributeContext(Type elementBaseType, string elementBaseTypeNamespaceUri, string attributeNamespaceUri, string attributeLocalName, Object& dynamicObject, String& assemblyName, String& typeFullName, Type& declaringType, String& dynamicObjectName);
    private void ThrowException(string id, string parameter1, int lineNumber, int linePosition);
    private void ThrowException(string id, string parameter1, string parameter2, int lineNumber, int linePosition);
    private void ThrowException(string id, string parameter1, string parameter2, string parameter3, int lineNumber, int linePosition);
    private void ThrowExceptionWithLine(string message, int lineNumber, int linePosition);
}
[DebuggerDisplayAttribute("'{_xmlNamespace}'={_clrNamespace}:{_assemblyName}")]
public class System.Windows.Markup.NamespaceMapEntry : object {
    private string _xmlNamespace;
    private string _assemblyName;
    private string _assemblyPath;
    private Assembly _assembly;
    private string _clrNamespace;
    public string XmlNamespace { get; public set; }
    public string AssemblyName { get; public set; }
    public string ClrNamespace { get; public set; }
    internal Assembly Assembly { get; }
    internal string AssemblyPath { get; internal set; }
    public NamespaceMapEntry(string xmlNamespace, string assemblyName, string clrNamespace);
    internal NamespaceMapEntry(string xmlNamespace, string assemblyName, string clrNamespace, string assemblyPath);
    public string get_XmlNamespace();
    public void set_XmlNamespace(string value);
    public string get_AssemblyName();
    public void set_AssemblyName(string value);
    public string get_ClrNamespace();
    public void set_ClrNamespace(string value);
    internal Assembly get_Assembly();
    internal string get_AssemblyPath();
    internal void set_AssemblyPath(string value);
}
internal enum System.Windows.Markup.ParserAction : Enum {
    public int value__;
    public static ParserAction Normal;
    public static ParserAction Skip;
}
public class System.Windows.Markup.ParserContext : object {
    private XamlTypeMapper _xamlTypeMapper;
    private Uri _baseUri;
    private XmlnsDictionary _xmlnsDictionary;
    private string _xmlLang;
    private string _xmlSpace;
    private Stack _langSpaceStack;
    private int _repeat;
    private Type _targetType;
    private Dictionary`2<Type, Dictionary`2<string, SpecialBracketCharacters>> _masterBracketCharacterCache;
    private bool _skipJournaledProperties;
    private SecurityCriticalDataForSet`1<Assembly> _streamCreatedAssembly;
    private bool _ownsBamlStream;
    private ProvideValueServiceProvider _provideValueServiceProvider;
    private IStyleConnector _styleConnector;
    private Stack _nameScopeStack;
    private List`1<Object[]> _staticResourcesStack;
    private object _rootElement;
    private FreezeStackFrame _currentFreezeStackFrame;
    private Dictionary`2<string, Freezable> _freezeCache;
    private Stack _freezeStack;
    private int _lineNumber;
    private int _linePosition;
    private BamlMapTable _mapTable;
    private bool _isDebugBamlStream;
    public XmlnsDictionary XmlnsDictionary { get; }
    public string XmlLang { get; public set; }
    public string XmlSpace { get; public set; }
    internal Type TargetType { get; internal set; }
    public XamlTypeMapper XamlTypeMapper { get; public set; }
    internal Stack NameScopeStack { get; }
    public Uri BaseUri { get; public set; }
    internal bool SkipJournaledProperties { get; internal set; }
    internal Assembly StreamCreatedAssembly { get; internal set; }
    internal int LineNumber { get; internal set; }
    internal int LinePosition { get; internal set; }
    internal bool IsDebugBamlStream { get; internal set; }
    internal object RootElement { get; internal set; }
    internal bool OwnsBamlStream { get; internal set; }
    internal BamlMapTable MapTable { get; internal set; }
    internal IStyleConnector StyleConnector { get; internal set; }
    internal ProvideValueServiceProvider ProvideValueProvider { get; }
    internal List`1<Object[]> StaticResourcesStack { get; }
    internal bool InDeferredSection { get; }
    internal Dictionary`2<Type, Dictionary`2<string, SpecialBracketCharacters>> MasterBracketCharacterCache { get; }
    internal bool FreezeFreezables { get; internal set; }
    public ParserContext(XmlParserContext xmlParserContext);
    internal ParserContext(XmlReader xmlReader);
    internal ParserContext(ParserContext parserContext);
    internal void Initialize();
    internal Dictionary`2<string, SpecialBracketCharacters> InitBracketCharacterCacheForType(Type type);
    internal void PushScope();
    internal void PopScope();
    public XmlnsDictionary get_XmlnsDictionary();
    public string get_XmlLang();
    public void set_XmlLang(string value);
    public string get_XmlSpace();
    public void set_XmlSpace(string value);
    internal Type get_TargetType();
    internal void set_TargetType(Type value);
    public XamlTypeMapper get_XamlTypeMapper();
    public void set_XamlTypeMapper(XamlTypeMapper value);
    internal Stack get_NameScopeStack();
    public sealed virtual Uri get_BaseUri();
    public sealed virtual void set_BaseUri(Uri value);
    internal bool get_SkipJournaledProperties();
    internal void set_SkipJournaledProperties(bool value);
    internal Assembly get_StreamCreatedAssembly();
    internal void set_StreamCreatedAssembly(Assembly value);
    public static XmlParserContext op_Implicit(ParserContext parserContext);
    public static XmlParserContext ToXmlParserContext(ParserContext parserContext);
    private void EndRepeat();
    internal int get_LineNumber();
    internal void set_LineNumber(int value);
    internal int get_LinePosition();
    internal void set_LinePosition(int value);
    internal bool get_IsDebugBamlStream();
    internal void set_IsDebugBamlStream(bool value);
    internal object get_RootElement();
    internal void set_RootElement(object value);
    internal bool get_OwnsBamlStream();
    internal void set_OwnsBamlStream(bool value);
    internal BamlMapTable get_MapTable();
    internal void set_MapTable(BamlMapTable value);
    internal IStyleConnector get_StyleConnector();
    internal void set_StyleConnector(IStyleConnector value);
    internal ProvideValueServiceProvider get_ProvideValueProvider();
    internal List`1<Object[]> get_StaticResourcesStack();
    internal bool get_InDeferredSection();
    internal ParserContext ScopedCopy();
    internal ParserContext ScopedCopy(bool copyNameScopeStack);
    internal void TrimState();
    internal Dictionary`2<Type, Dictionary`2<string, SpecialBracketCharacters>> get_MasterBracketCharacterCache();
    internal ParserContext Clone();
    internal bool get_FreezeFreezables();
    internal void set_FreezeFreezables(bool value);
    internal bool TryCacheFreezable(string value, Freezable freezable);
    internal Freezable TryGetFreezable(string value);
    private Dictionary`2<string, SpecialBracketCharacters> BuildBracketCharacterCacheForType(Type extensionType);
}
internal abstract class System.Windows.Markup.ParserHooks : object {
    internal virtual ParserAction LoadNode(XamlNode tokenNode);
}
internal class System.Windows.Markup.ParserStack : ArrayList {
    internal object CurrentContext { get; }
    internal object ParentContext { get; }
    internal object GrandParentContext { get; }
    internal object GreatGrandParentContext { get; }
    private ParserStack(ICollection collection);
    public void Push(object o);
    public object Pop();
    public object Peek();
    public virtual object Clone();
    internal object get_CurrentContext();
    internal object get_ParentContext();
    internal object get_GrandParentContext();
    internal object get_GreatGrandParentContext();
}
internal class System.Windows.Markup.Primitives.ElementConstructorArgument : ElementPseudoPropertyBase {
    public string Name { get; }
    public bool IsConstructorArgument { get; }
    internal ElementConstructorArgument(object value, Type type, ElementMarkupObject obj);
    public virtual string get_Name();
    public virtual bool get_IsConstructorArgument();
}
internal class System.Windows.Markup.Primitives.ElementDictionaryItemsPseudoProperty : ElementPseudoPropertyBase {
    private IDictionary _value;
    public string Name { get; }
    public bool IsContent { get; }
    public bool IsComposite { get; }
    public IEnumerable`1<MarkupObject> Items { get; }
    internal ElementDictionaryItemsPseudoProperty(IDictionary value, Type type, ElementMarkupObject obj);
    public virtual string get_Name();
    public virtual bool get_IsContent();
    public virtual bool get_IsComposite();
    [IteratorStateMachineAttribute("System.Windows.Markup.Primitives.ElementDictionaryItemsPseudoProperty/<get_Items>d__8")]
public virtual IEnumerable`1<MarkupObject> get_Items();
}
internal class System.Windows.Markup.Primitives.ElementItemsPseudoProperty : ElementPseudoPropertyBase {
    private IEnumerable _value;
    public string Name { get; }
    public bool IsContent { get; }
    public bool IsComposite { get; }
    public IEnumerable`1<MarkupObject> Items { get; }
    internal ElementItemsPseudoProperty(IEnumerable value, Type type, ElementMarkupObject obj);
    public virtual string get_Name();
    public virtual bool get_IsContent();
    public virtual bool get_IsComposite();
    [IteratorStateMachineAttribute("System.Windows.Markup.Primitives.ElementItemsPseudoProperty/<get_Items>d__8")]
public virtual IEnumerable`1<MarkupObject> get_Items();
}
internal class System.Windows.Markup.Primitives.ElementKey : ElementPseudoPropertyBase {
    public string Name { get; }
    public bool IsKey { get; }
    internal ElementKey(object value, Type type, ElementMarkupObject obj);
    public virtual string get_Name();
    public virtual bool get_IsKey();
}
internal class System.Windows.Markup.Primitives.ElementMarkupObject : MarkupObject {
    private static object _shouldSerializeCacheLock;
    private static Hashtable _shouldSerializeCache;
    private static Type[] _shouldSerializeArgsObject;
    private static Type[] _shouldSerializeArgsManager;
    private static Type[] _shouldSerializeArgsMode;
    private static Type[] _shouldSerializeArgsObjectManager;
    private static Attribute[] _propertyAttributes;
    private object _instance;
    private IValueSerializerContext _context;
    private ElementKey _key;
    private XamlDesignerSerializationManager _manager;
    public Type ObjectType { get; }
    public object Instance { get; }
    public AttributeCollection Attributes { get; }
    internal IValueSerializerContext Context { get; }
    internal XamlDesignerSerializationManager Manager { get; }
    internal ElementMarkupObject(object instance, XamlDesignerSerializationManager manager);
    private static ElementMarkupObject();
    public virtual Type get_ObjectType();
    public virtual object get_Instance();
    [IteratorStateMachineAttribute("System.Windows.Markup.Primitives.ElementMarkupObject/<GetProperties>d__5")]
internal virtual IEnumerable`1<MarkupProperty> GetProperties(bool mapToConstructorArgs);
    public virtual AttributeCollection get_Attributes();
    public virtual void AssignRootContext(IValueSerializerContext context);
    internal IValueSerializerContext get_Context();
    internal XamlDesignerSerializationManager get_Manager();
    internal void SetKey(ElementKey key);
    private static bool ShouldSerialize(PropertyDescriptor pd, object instance, XamlDesignerSerializationManager manager);
    private static bool TryGetShouldSerializeMethod(ShouldSerializeKey key, MethodInfo& methodInfo);
    private static void CacheShouldSerializeMethod(ShouldSerializeKey key, MethodInfo methodInfo);
    private bool TryGetConstructorInfoArguments(object instance, ParameterInfo[]& parameters, ICollection& arguments);
}
internal abstract class System.Windows.Markup.Primitives.ElementObjectPropertyBase : ElementPropertyBase {
    protected ElementMarkupObject _object;
    protected ElementObjectPropertyBase(ElementMarkupObject obj);
    protected virtual IValueSerializerContext GetItemContext();
    protected virtual Type GetObjectType();
}
internal class System.Windows.Markup.Primitives.ElementProperty : ElementObjectPropertyBase {
    private PropertyDescriptor _descriptor;
    private bool _isDependencyPropertyCached;
    private DependencyProperty _dependencyProperty;
    private bool _isAttached;
    public string Name { get; }
    public Type PropertyType { get; }
    public PropertyDescriptor PropertyDescriptor { get; }
    public bool IsAttached { get; }
    public DependencyProperty DependencyProperty { get; }
    public object Value { get; }
    public AttributeCollection Attributes { get; }
    internal ElementProperty(ElementMarkupObject obj, PropertyDescriptor descriptor);
    public virtual string get_Name();
    public virtual Type get_PropertyType();
    public virtual PropertyDescriptor get_PropertyDescriptor();
    public virtual bool get_IsAttached();
    public virtual DependencyProperty get_DependencyProperty();
    public virtual object get_Value();
    public virtual AttributeCollection get_Attributes();
    private void UpdateDependencyProperty();
    internal static object CheckForMarkupExtension(Type propertyType, object value, IValueSerializerContext context, bool convertEnums);
}
internal abstract class System.Windows.Markup.Primitives.ElementPropertyBase : MarkupProperty {
    private static List`1<Type> EmptyTypes;
    private static Dictionary`2<Type, Type> _keyTypeMap;
    private bool _isComposite;
    private bool _isCompositeCalculated;
    private IValueSerializerContext _context;
    private XamlDesignerSerializationManager _manager;
    public bool IsComposite { get; }
    public string StringValue { get; }
    public IEnumerable`1<MarkupObject> Items { get; }
    protected IValueSerializerContext Context { get; }
    internal XamlDesignerSerializationManager Manager { get; }
    public IEnumerable`1<Type> TypeReferences { get; }
    public ElementPropertyBase(XamlDesignerSerializationManager manager);
    private static ElementPropertyBase();
    public virtual bool get_IsComposite();
    public virtual string get_StringValue();
    [IteratorStateMachineAttribute("System.Windows.Markup.Primitives.ElementPropertyBase/<get_Items>d__6")]
public virtual IEnumerable`1<MarkupObject> get_Items();
    private bool PropertyIsAttached(PropertyDescriptor descriptor);
    private bool HasNoSerializableProperties(object value);
    private bool IsEmpty(object value);
    protected IValueSerializerContext get_Context();
    internal XamlDesignerSerializationManager get_Manager();
    public virtual IEnumerable`1<Type> get_TypeReferences();
    protected bool CanConvertToString(object value);
    protected abstract virtual IValueSerializerContext GetItemContext();
    protected abstract virtual Type GetObjectType();
    private ValueSerializer GetValueSerializer();
    private static Type GetDictionaryKeyType(IDictionary value);
}
internal abstract class System.Windows.Markup.Primitives.ElementPseudoPropertyBase : ElementObjectPropertyBase {
    private object _value;
    private Type _type;
    public Type PropertyType { get; }
    public object Value { get; }
    public AttributeCollection Attributes { get; }
    public IEnumerable`1<Type> TypeReferences { get; }
    internal ElementPseudoPropertyBase(object value, Type type, ElementMarkupObject obj);
    public virtual Type get_PropertyType();
    public virtual object get_Value();
    public virtual AttributeCollection get_Attributes();
    public virtual IEnumerable`1<Type> get_TypeReferences();
}
internal class System.Windows.Markup.Primitives.ElementStringValueProperty : MarkupProperty {
    private ElementMarkupObject _object;
    public string Name { get; }
    public Type PropertyType { get; }
    public bool IsValueAsString { get; }
    public object Value { get; }
    public string StringValue { get; }
    public IEnumerable`1<MarkupObject> Items { get; }
    public AttributeCollection Attributes { get; }
    public IEnumerable`1<Type> TypeReferences { get; }
    internal ElementStringValueProperty(ElementMarkupObject obj);
    public virtual string get_Name();
    public virtual Type get_PropertyType();
    public virtual bool get_IsValueAsString();
    public virtual object get_Value();
    public virtual string get_StringValue();
    public virtual IEnumerable`1<MarkupObject> get_Items();
    public virtual AttributeCollection get_Attributes();
    public virtual IEnumerable`1<Type> get_TypeReferences();
}
internal class System.Windows.Markup.Primitives.ExtensionSimplifierMarkupObject : MarkupObjectWrapper {
    private IValueSerializerContext _context;
    public ExtensionSimplifierMarkupObject(MarkupObject baseObject, IValueSerializerContext context);
    private IEnumerable`1<MarkupProperty> GetBaseProperties(bool mapToConstructorArgs);
    [IteratorStateMachineAttribute("System.Windows.Markup.Primitives.ExtensionSimplifierMarkupObject/<GetProperties>d__3")]
internal virtual IEnumerable`1<MarkupProperty> GetProperties(bool mapToConstructorArgs);
    public virtual void AssignRootContext(IValueSerializerContext context);
}
internal class System.Windows.Markup.Primitives.ExtensionSimplifierProperty : MarkupPropertyWrapper {
    private IValueSerializerContext _context;
    private static int EXTENSIONLENGTH;
    public bool IsComposite { get; }
    public IEnumerable`1<MarkupObject> Items { get; }
    public string StringValue { get; }
    public ExtensionSimplifierProperty(MarkupProperty baseProperty, IValueSerializerContext context);
    public virtual bool get_IsComposite();
    private IEnumerable`1<MarkupObject> GetBaseItems();
    [IteratorStateMachineAttribute("System.Windows.Markup.Primitives.ExtensionSimplifierProperty/<get_Items>d__6")]
public virtual IEnumerable`1<MarkupObject> get_Items();
    public virtual string get_StringValue();
    private string ConvertMarkupItemToString(MarkupObject item);
    internal virtual void VerifyOnlySerializableTypes();
}
internal class System.Windows.Markup.Primitives.FrameworkElementFactoryContent : ElementPropertyBase {
    private FrameworkElementFactoryMarkupObject _item;
    private FrameworkElementFactory _factory;
    public string Name { get; }
    public bool IsContent { get; }
    public bool IsComposite { get; }
    public IEnumerable`1<MarkupObject> Items { get; }
    public AttributeCollection Attributes { get; }
    public Type PropertyType { get; }
    public object Value { get; }
    internal FrameworkElementFactoryContent(FrameworkElementFactory factory, FrameworkElementFactoryMarkupObject item);
    public virtual string get_Name();
    public virtual bool get_IsContent();
    public virtual bool get_IsComposite();
    [IteratorStateMachineAttribute("System.Windows.Markup.Primitives.FrameworkElementFactoryContent/<get_Items>d__8")]
public virtual IEnumerable`1<MarkupObject> get_Items();
    protected virtual IValueSerializerContext GetItemContext();
    protected virtual Type GetObjectType();
    public virtual AttributeCollection get_Attributes();
    public virtual Type get_PropertyType();
    public virtual object get_Value();
}
internal class System.Windows.Markup.Primitives.FrameworkElementFactoryMarkupObject : MarkupObject {
    private FrameworkElementFactory _factory;
    private IValueSerializerContext _context;
    private XamlDesignerSerializationManager _manager;
    public AttributeCollection Attributes { get; }
    public Type ObjectType { get; }
    public object Instance { get; }
    internal IValueSerializerContext Context { get; }
    internal XamlDesignerSerializationManager Manager { get; }
    internal FrameworkElementFactoryMarkupObject(FrameworkElementFactory factory, XamlDesignerSerializationManager manager);
    public virtual void AssignRootContext(IValueSerializerContext context);
    public virtual AttributeCollection get_Attributes();
    public virtual Type get_ObjectType();
    public virtual object get_Instance();
    [IteratorStateMachineAttribute("System.Windows.Markup.Primitives.FrameworkElementFactoryMarkupObject/<GetProperties>d__8")]
internal virtual IEnumerable`1<MarkupProperty> GetProperties(bool mapToConstructorArgs);
    internal IValueSerializerContext get_Context();
    internal XamlDesignerSerializationManager get_Manager();
}
internal class System.Windows.Markup.Primitives.FrameworkElementFactoryProperty : ElementPropertyBase {
    private PropertyValue _propertyValue;
    private FrameworkElementFactoryMarkupObject _item;
    private bool _descriptorCalculated;
    private PropertyDescriptor _descriptor;
    public PropertyDescriptor PropertyDescriptor { get; }
    public bool IsAttached { get; }
    public AttributeCollection Attributes { get; }
    public string Name { get; }
    public Type PropertyType { get; }
    public DependencyProperty DependencyProperty { get; }
    public object Value { get; }
    public FrameworkElementFactoryProperty(PropertyValue propertyValue, FrameworkElementFactoryMarkupObject item);
    public virtual PropertyDescriptor get_PropertyDescriptor();
    public virtual bool get_IsAttached();
    public virtual AttributeCollection get_Attributes();
    public virtual string get_Name();
    public virtual Type get_PropertyType();
    public virtual DependencyProperty get_DependencyProperty();
    public virtual object get_Value();
    protected virtual IValueSerializerContext GetItemContext();
    protected virtual Type GetObjectType();
}
internal class System.Windows.Markup.Primitives.FrameworkElementFactoryStringContent : ElementPropertyBase {
    private FrameworkElementFactoryMarkupObject _item;
    private FrameworkElementFactory _factory;
    public string Name { get; }
    public bool IsContent { get; }
    public bool IsComposite { get; }
    public bool IsValueAsString { get; }
    public IEnumerable`1<MarkupObject> Items { get; }
    public AttributeCollection Attributes { get; }
    public Type PropertyType { get; }
    public object Value { get; }
    internal FrameworkElementFactoryStringContent(FrameworkElementFactory factory, FrameworkElementFactoryMarkupObject item);
    public virtual string get_Name();
    public virtual bool get_IsContent();
    public virtual bool get_IsComposite();
    public virtual bool get_IsValueAsString();
    public virtual IEnumerable`1<MarkupObject> get_Items();
    protected virtual IValueSerializerContext GetItemContext();
    protected virtual Type GetObjectType();
    public virtual AttributeCollection get_Attributes();
    public virtual Type get_PropertyType();
    public virtual object get_Value();
}
internal class System.Windows.Markup.Primitives.MarkupObjectWrapper : MarkupObject {
    private MarkupObject _baseObject;
    public AttributeCollection Attributes { get; }
    public Type ObjectType { get; }
    public object Instance { get; }
    public MarkupObjectWrapper(MarkupObject baseObject);
    public virtual void AssignRootContext(IValueSerializerContext context);
    public virtual AttributeCollection get_Attributes();
    public virtual Type get_ObjectType();
    public virtual object get_Instance();
    internal virtual IEnumerable`1<MarkupProperty> GetProperties(bool mapToConstructorArgs);
}
internal class System.Windows.Markup.Primitives.MarkupPropertyWrapper : MarkupProperty {
    private MarkupProperty _baseProperty;
    public AttributeCollection Attributes { get; }
    public IEnumerable`1<MarkupObject> Items { get; }
    public string Name { get; }
    public Type PropertyType { get; }
    public string StringValue { get; }
    public IEnumerable`1<Type> TypeReferences { get; }
    public object Value { get; }
    public DependencyProperty DependencyProperty { get; }
    public bool IsAttached { get; }
    public bool IsComposite { get; }
    public bool IsConstructorArgument { get; }
    public bool IsKey { get; }
    public bool IsValueAsString { get; }
    public bool IsContent { get; }
    public PropertyDescriptor PropertyDescriptor { get; }
    public MarkupPropertyWrapper(MarkupProperty baseProperty);
    public virtual AttributeCollection get_Attributes();
    public virtual IEnumerable`1<MarkupObject> get_Items();
    public virtual string get_Name();
    public virtual Type get_PropertyType();
    public virtual string get_StringValue();
    public virtual IEnumerable`1<Type> get_TypeReferences();
    public virtual object get_Value();
    public virtual DependencyProperty get_DependencyProperty();
    public virtual bool get_IsAttached();
    public virtual bool get_IsComposite();
    public virtual bool get_IsConstructorArgument();
    public virtual bool get_IsKey();
    public virtual bool get_IsValueAsString();
    public virtual bool get_IsContent();
    public virtual PropertyDescriptor get_PropertyDescriptor();
    internal virtual void VerifyOnlySerializableTypes();
}
public class System.Windows.Markup.Primitives.MarkupWriter : object {
    private static string clrUriPrefix;
    private static int EXTENSIONLENGTH;
    private XmlWriter _writer;
    private XmlTextWriter _xmlTextWriter;
    private static DefaultValueAttribute _nullDefaultValueAttribute;
    internal MarkupWriter(XmlWriter writer);
    public static MarkupObject GetMarkupObjectFor(object instance);
    public static MarkupObject GetMarkupObjectFor(object instance, XamlDesignerSerializationManager manager);
    internal static void SaveAsXml(XmlWriter writer, object instance);
    internal static void SaveAsXml(XmlWriter writer, object instance, XamlDesignerSerializationManager manager);
    internal static void SaveAsXml(XmlWriter writer, MarkupObject item);
    internal static void VerifyTypeIsSerializable(Type type);
    public sealed virtual void Dispose();
    private bool RecordNamespaces(Scope scope, MarkupObject item, IValueSerializerContext context, bool lastWasString);
    internal void WriteItem(MarkupObject item);
    private void WriteItem(MarkupObject item, Scope scope);
    private bool IsContentProperty(MarkupProperty property, ContentPropertyAttribute cpa, MarkupProperty& contentProperty);
    private bool IsDeferredProperty(MarkupProperty property, Dictionary`2<string, string> writtenAttributes, PartiallyOrderedList`2& deferredProperties);
    private bool NeedToWriteExplicitTag(MarkupProperty property, MarkupObject firstItem);
    private void WriteExplicitTagStart(MarkupProperty property, Scope scope);
    private void WriteExplicitTagEnd();
    private void WritePropertyStart(string prefix, string propertyName, string uri);
    private void WritePropertyEnd();
    private void WriteXmlIsland(IXmlSerializable xmlSerializable, Scope scope);
    private List`1<Type> GetWrapperTypes(Type type);
    private MarkupProperty GetWrappedProperty(List`1<Type> wrapperTypes, MarkupObject item);
    private bool IsInTypes(Type type, List`1<Type> types);
    private string TextValue(MarkupObject item);
    private bool HasNonValueProperties(MarkupObject item);
    private bool IsCollectionType(Type type);
    private bool HasOnlyNormalizationNeutralStrings(MarkupProperty contentProperty, bool keepLeadingSpace, bool keepTrailingSpace);
    private bool ShouldTrimSurroundingWhitespace(MarkupObject item);
    private bool IsNormalizationNeutralString(string value, bool keepLeadingSpace, bool keepTrailingSpace);
}
internal class System.Windows.Markup.Primitives.ValueSerializerContextWrapper : object {
    private IValueSerializerContext _baseContext;
    public IContainer Container { get; }
    public object Instance { get; }
    public PropertyDescriptor PropertyDescriptor { get; }
    public ValueSerializerContextWrapper(IValueSerializerContext baseContext);
    public sealed virtual ValueSerializer GetValueSerializerFor(PropertyDescriptor descriptor);
    public sealed virtual ValueSerializer GetValueSerializerFor(Type type);
    public sealed virtual IContainer get_Container();
    public sealed virtual object get_Instance();
    public sealed virtual void OnComponentChanged();
    public sealed virtual bool OnComponentChanging();
    public sealed virtual PropertyDescriptor get_PropertyDescriptor();
    public sealed virtual object GetService(Type serviceType);
}
internal class System.Windows.Markup.ProvideValueServiceProvider : object {
    private ParserContext _context;
    private object _targetObject;
    private object _targetProperty;
    private object System.Windows.Markup.IProvideValueTarget.TargetObject { get; }
    private object System.Windows.Markup.IProvideValueTarget.TargetProperty { get; }
    private Uri System.Windows.Markup.IUriContext.BaseUri { get; private set; }
    private bool System.Windows.Media.IFreezeFreezables.FreezeFreezables { get; }
    internal ProvideValueServiceProvider(ParserContext context);
    internal void SetData(object targetObject, object targetProperty);
    internal void ClearData();
    private sealed virtual override Type System.Windows.Markup.IXamlTypeResolver.Resolve(string qualifiedTypeName);
    private sealed virtual override object System.Windows.Markup.IProvideValueTarget.get_TargetObject();
    private sealed virtual override object System.Windows.Markup.IProvideValueTarget.get_TargetProperty();
    private sealed virtual override Uri System.Windows.Markup.IUriContext.get_BaseUri();
    private sealed virtual override void System.Windows.Markup.IUriContext.set_BaseUri(Uri value);
    private sealed virtual override bool System.Windows.Media.IFreezeFreezables.get_FreezeFreezables();
    private sealed virtual override bool System.Windows.Media.IFreezeFreezables.TryFreeze(string value, Freezable freezable);
    private sealed virtual override Freezable System.Windows.Media.IFreezeFreezables.TryGetFreezable(string value);
    public sealed virtual object GetService(Type service);
}
internal class System.Windows.Markup.ReaderContextStackData : object {
    private ReaderFlags _contextFlags;
    private object _contextData;
    private object _contextKey;
    private string _uid;
    private string _name;
    private object _contentProperty;
    private Type _expectedType;
    private short _expectedTypeId;
    private bool _createUsingTypeConverter;
    internal ReaderFlags ContextType { get; }
    internal object ObjectData { get; internal set; }
    internal object Key { get; internal set; }
    internal string Uid { get; internal set; }
    internal string ElementNameOrPropertyName { get; internal set; }
    internal object ContentProperty { get; internal set; }
    internal Type ExpectedType { get; internal set; }
    internal short ExpectedTypeId { get; internal set; }
    internal bool CreateUsingTypeConverter { get; internal set; }
    internal ReaderFlags ContextFlags { get; internal set; }
    internal bool NeedToAddToTree { get; }
    internal bool IsObjectElement { get; }
    internal ReaderFlags get_ContextType();
    internal object get_ObjectData();
    internal void set_ObjectData(object value);
    internal object get_Key();
    internal void set_Key(object value);
    internal string get_Uid();
    internal void set_Uid(string value);
    internal string get_ElementNameOrPropertyName();
    internal void set_ElementNameOrPropertyName(string value);
    internal object get_ContentProperty();
    internal void set_ContentProperty(object value);
    internal Type get_ExpectedType();
    internal void set_ExpectedType(Type value);
    internal short get_ExpectedTypeId();
    internal void set_ExpectedTypeId(short value);
    internal bool get_CreateUsingTypeConverter();
    internal void set_CreateUsingTypeConverter(bool value);
    internal ReaderFlags get_ContextFlags();
    internal void set_ContextFlags(ReaderFlags value);
    internal bool get_NeedToAddToTree();
    internal void MarkAddedToTree();
    internal bool CheckFlag(ReaderFlags flag);
    internal void SetFlag(ReaderFlags flag);
    internal void ClearFlag(ReaderFlags flag);
    internal bool get_IsObjectElement();
    internal void ClearData();
}
internal enum System.Windows.Markup.ReaderFlags : Enum {
    public ushort value__;
    public static ReaderFlags Unknown;
    public static ReaderFlags DependencyObject;
    public static ReaderFlags ClrObject;
    public static ReaderFlags PropertyComplexClr;
    public static ReaderFlags PropertyComplexDP;
    public static ReaderFlags PropertyArray;
    public static ReaderFlags PropertyIList;
    public static ReaderFlags PropertyIDictionary;
    public static ReaderFlags PropertyIAddChild;
    public static ReaderFlags RealizeDeferContent;
    public static ReaderFlags ConstructorParams;
    public static ReaderFlags ContextTypeMask;
    public static ReaderFlags StyleObject;
    public static ReaderFlags FrameworkTemplateObject;
    public static ReaderFlags TableTemplateObject;
    public static ReaderFlags SingletonConstructorParam;
    public static ReaderFlags NeedToAddToTree;
    public static ReaderFlags AddedToTree;
    public static ReaderFlags InjectedElement;
    public static ReaderFlags CollectionHolder;
    public static ReaderFlags IDictionary;
    public static ReaderFlags IList;
    public static ReaderFlags ArrayExt;
    public static ReaderFlags IAddChild;
}
internal class System.Windows.Markup.ReaderStream : Stream {
    private ReadWriteStreamManager _streamManager;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    private ReadWriteStreamManager StreamManager { get; }
    internal ReaderStream(ReadWriteStreamManager streamManager);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual void Close();
    public virtual void Flush();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual int ReadByte();
    public virtual long Seek(long offset, SeekOrigin loc);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    internal void ReaderDoneWithFileUpToPosition(long position);
    private ReadWriteStreamManager get_StreamManager();
}
internal class System.Windows.Markup.ReadWriteStreamManager : object {
    private long _readPosition;
    private long _readLength;
    private long _writePosition;
    private long _writeLength;
    private ReaderWriterLock _bufferLock;
    private WriterStream _writerStream;
    private ReaderStream _readerStream;
    private long _readerFirstBufferPosition;
    private long _writerFirstBufferPosition;
    private ArrayList _readerBufferArrayList;
    private ArrayList _writerBufferArrayList;
    private static int _bufferSize;
    internal WriterStream WriterStream { get; }
    internal ReaderStream ReaderStream { get; }
    internal long ReadPosition { get; internal set; }
    internal long ReadLength { get; internal set; }
    internal long WritePosition { get; internal set; }
    internal long WriteLength { get; internal set; }
    private int BufferSize { get; }
    private long ReaderFirstBufferPosition { get; private set; }
    private long WriterFirstBufferPosition { get; private set; }
    private ArrayList ReaderBufferArrayList { get; private set; }
    private ArrayList WriterBufferArrayList { get; private set; }
    internal void Write(Byte[] buffer, int offset, int count);
    internal long WriterSeek(long offset, SeekOrigin loc);
    internal void UpdateReaderLength(long position);
    internal void WriterClose();
    internal int Read(Byte[] buffer, int offset, int count);
    internal int ReadByte();
    internal long ReaderSeek(long offset, SeekOrigin loc);
    internal void ReaderDoneWithFileUpToPosition(long position);
    private Byte[] GetBufferFromFilePosition(long position, bool reader, Int32& bufferOffset, Int32& bufferIndex);
    private void CheckIfCanRemoveFromArrayList(long position, ArrayList arrayList, Int64& firstBufferPosition);
    internal WriterStream get_WriterStream();
    internal ReaderStream get_ReaderStream();
    internal long get_ReadPosition();
    internal void set_ReadPosition(long value);
    internal long get_ReadLength();
    internal void set_ReadLength(long value);
    internal long get_WritePosition();
    internal void set_WritePosition(long value);
    internal long get_WriteLength();
    internal void set_WriteLength(long value);
    private int get_BufferSize();
    private long get_ReaderFirstBufferPosition();
    private void set_ReaderFirstBufferPosition(long value);
    private long get_WriterFirstBufferPosition();
    private void set_WriterFirstBufferPosition(long value);
    private ArrayList get_ReaderBufferArrayList();
    private void set_ReaderBufferArrayList(ArrayList value);
    private ArrayList get_WriterBufferArrayList();
    private void set_WriterBufferArrayList(ArrayList value);
}
public class System.Windows.Markup.ResourceReferenceExpressionConverter : ExpressionConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
internal class System.Windows.Markup.RestrictiveXamlXmlReader : XamlXmlReader {
    private static string AllowedTypesForRestrictiveXamlContexts;
    private static HashSet`1<string> AllXamlNamespaces;
    private static Type DependencyObjectType;
    private static HashSet`1<string> SafeTypesFromRegistry;
    private HashSet`1<Type> _safeTypesSet;
    public RestrictiveXamlXmlReader(XmlReader xmlReader, XamlSchemaContext schemaContext, XamlXmlReaderSettings settings);
    internal RestrictiveXamlXmlReader(XmlReader xmlReader, XamlSchemaContext schemaContext, XamlXmlReaderSettings settings, List`1<Type> safeTypes);
    private static RestrictiveXamlXmlReader();
    private static HashSet`1<string> ReadAllowedTypesForRestrictedXamlContexts();
    public virtual bool Read();
    private bool IsAllowedDirective(XamlDirective directive);
    private bool IsAllowedType(Type type);
}
public class System.Windows.Markup.RoutedEventConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext typeDescriptorContext, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext typeDescriptorContext, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext typeDescriptorContext, CultureInfo cultureInfo, object source);
    public virtual object ConvertTo(ITypeDescriptorContext typeDescriptorContext, CultureInfo cultureInfo, object value, Type destinationType);
    private string ExtractNamespaceString(String& nameString, ParserContext parserContext);
}
internal class System.Windows.Markup.RoutedEventValueSerializer : ValueSerializer {
    private static Dictionary`2<Type, Type> initializedTypes;
    private static RoutedEventValueSerializer();
    public virtual bool CanConvertToString(object value, IValueSerializerContext context);
    public virtual bool CanConvertFromString(string value, IValueSerializerContext context);
    public virtual string ConvertToString(object value, IValueSerializerContext context);
    private static void ForceTypeConstructors(Type currentType);
    public virtual object ConvertFromString(string value, IValueSerializerContext context);
}
public class System.Windows.Markup.SetterTriggerConditionValueConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object source);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
    internal static object ResolveValue(ITypeDescriptorContext serviceProvider, DependencyProperty property, CultureInfo culture, object source);
}
internal class System.Windows.Markup.StaticResourceHolder : StaticResourceExtension {
    private DeferredResourceReference _prefetchedValue;
    internal DeferredResourceReference PrefetchedValue { get; }
    internal StaticResourceHolder(object resourceKey, DeferredResourceReference prefetchedValue);
    internal virtual DeferredResourceReference get_PrefetchedValue();
}
internal enum System.Windows.Markup.StyleMode : Enum {
    public byte value__;
    public static StyleMode Base;
    public static StyleMode TargetTypeProperty;
    public static StyleMode BasedOnProperty;
    public static StyleMode DataTypeProperty;
    public static StyleMode ComplexProperty;
    public static StyleMode Resources;
    public static StyleMode Setters;
    public static StyleMode Key;
    public static StyleMode TriggerBase;
    public static StyleMode TriggerActions;
    public static StyleMode TriggerSetters;
    public static StyleMode TriggerEnterExitActions;
    public static StyleMode VisualTree;
}
internal class System.Windows.Markup.StyleModeStack : object {
    private Stack`1<StyleMode> _stack;
    internal int Depth { get; }
    internal StyleMode Mode { get; }
    internal int get_Depth();
    internal StyleMode get_Mode();
    internal void Push(StyleMode mode);
    internal void Push();
    internal StyleMode Pop();
}
internal class System.Windows.Markup.SystemKeyConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
    internal static Type GetSystemClassType(SystemResourceKeyID id);
    internal static string GetSystemClassName(SystemResourceKeyID id);
    internal static string GetSystemKeyName(SystemResourceKeyID id);
    internal static string GetSystemPropertyName(SystemResourceKeyID id);
}
internal class System.Windows.Markup.TemplateComponentConnector : object {
    private IStyleConnector _styleConnector;
    private IComponentConnector _componentConnector;
    internal TemplateComponentConnector(IComponentConnector componentConnector, IStyleConnector styleConnector);
    public sealed virtual void InitializeComponent();
    public sealed virtual void Connect(int connectionId, object target);
}
public class System.Windows.Markup.TemplateKeyConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object source);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
internal class System.Windows.Markup.TypeAndSerializer : object {
    public Type ObjectType;
    public Type SerializerType;
    public bool IsSerializerTypeSet;
    public PropertyInfo XmlLangProperty;
}
internal class System.Windows.Markup.TypeConvertContext : object {
    private ParserContext _parserContext;
    private string _attribStringValue;
    public IContainer Container { get; }
    public object Instance { get; }
    public PropertyDescriptor PropertyDescriptor { get; }
    public ParserContext ParserContext { get; }
    public TypeConvertContext(ParserContext parserContext);
    public sealed virtual void OnComponentChanged();
    public sealed virtual bool OnComponentChanging();
    public virtual object GetService(Type serviceType);
    public sealed virtual IContainer get_Container();
    public sealed virtual object get_Instance();
    public sealed virtual PropertyDescriptor get_PropertyDescriptor();
    public ParserContext get_ParserContext();
}
[DefaultMemberAttribute("Item")]
internal class System.Windows.Markup.TypeIndexer : object {
    private Type[] _typeTable;
    public Type Item { get; }
    public TypeIndexer(int size);
    private Type InitializeOneType(KnownElements knownElement);
    public Type get_Item(int index);
}
internal class System.Windows.Markup.TypeInfoKey : ValueType {
    internal string DeclaringAssembly;
    internal string TypeFullName;
    public virtual bool Equals(object o);
    public static bool op_Equality(TypeInfoKey key1, TypeInfoKey key2);
    public static bool op_Inequality(TypeInfoKey key1, TypeInfoKey key2);
    public virtual int GetHashCode();
    public virtual string ToString();
}
internal class System.Windows.Markup.WpfPropertyDefinition : ValueType {
    private BamlRecordReader _reader;
    private short _attributeId;
    private BamlAttributeInfoRecord _attributeInfo;
    private DependencyProperty _dependencyProperty;
    public DependencyProperty DependencyProperty { get; }
    public BamlAttributeUsage AttributeUsage { get; }
    public BamlAttributeInfoRecord AttributeInfo { get; }
    public PropertyInfo PropertyInfo { get; }
    public MethodInfo AttachedPropertyGetter { get; }
    public MethodInfo AttachedPropertySetter { get; }
    public bool IsInternal { get; }
    public Type PropertyType { get; }
    public string Name { get; }
    internal object DpOrPiOrMi { get; }
    public WpfPropertyDefinition(BamlRecordReader reader, short attributeId, bool targetIsDependencyObject);
    public DependencyProperty get_DependencyProperty();
    public BamlAttributeUsage get_AttributeUsage();
    public BamlAttributeInfoRecord get_AttributeInfo();
    public PropertyInfo get_PropertyInfo();
    public MethodInfo get_AttachedPropertyGetter();
    public MethodInfo get_AttachedPropertySetter();
    public bool get_IsInternal();
    public Type get_PropertyType();
    public string get_Name();
    internal object get_DpOrPiOrMi();
}
internal class System.Windows.Markup.WpfXamlFrame : XamlFrame {
    [CompilerGeneratedAttribute]
private bool <FreezeFreezable>k__BackingField;
    [CompilerGeneratedAttribute]
private XamlMember <Property>k__BackingField;
    [CompilerGeneratedAttribute]
private XamlType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Instance>k__BackingField;
    [CompilerGeneratedAttribute]
private XmlnsDictionary <XmlnsDictionary>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <XmlSpace>k__BackingField;
    public bool FreezeFreezable { get; public set; }
    public XamlMember Property { get; public set; }
    public XamlType Type { get; public set; }
    public object Instance { get; public set; }
    public XmlnsDictionary XmlnsDictionary { get; public set; }
    public Nullable`1<bool> XmlSpace { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_FreezeFreezable();
    [CompilerGeneratedAttribute]
public void set_FreezeFreezable(bool value);
    [CompilerGeneratedAttribute]
public XamlMember get_Property();
    [CompilerGeneratedAttribute]
public void set_Property(XamlMember value);
    [CompilerGeneratedAttribute]
public XamlType get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(XamlType value);
    [CompilerGeneratedAttribute]
public object get_Instance();
    [CompilerGeneratedAttribute]
public void set_Instance(object value);
    [CompilerGeneratedAttribute]
public XmlnsDictionary get_XmlnsDictionary();
    [CompilerGeneratedAttribute]
public void set_XmlnsDictionary(XmlnsDictionary value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_XmlSpace();
    [CompilerGeneratedAttribute]
public void set_XmlSpace(Nullable`1<bool> value);
    public virtual void Reset();
}
internal class System.Windows.Markup.WpfXamlLoader : object {
    private static Lazy`1<XamlMember> XmlSpace;
    private static WpfXamlLoader();
    public static object Load(XamlReader xamlReader, bool skipJournaledProperties, Uri baseUri);
    public static object LoadDeferredContent(XamlReader xamlReader, IXamlObjectWriterFactory writerFactory, bool skipJournaledProperties, object rootObject, XamlObjectWriterSettings parentSettings, Uri baseUri);
    public static object LoadBaml(XamlReader xamlReader, bool skipJournaledProperties, object rootObject, XamlAccessLevel accessLevel, Uri baseUri);
    internal static void EnsureXmlNamespaceMaps(object rootObject, XamlSchemaContext schemaContext);
    private static object Load(XamlReader xamlReader, IXamlObjectWriterFactory writerFactory, bool skipJournaledProperties, object rootObject, XamlObjectWriterSettings settings, Uri baseUri);
    internal static void TransformNodes(XamlReader xamlReader, XamlObjectWriter xamlWriter, bool onlyLoadOneNode, bool skipJournaledProperties, bool shouldPassLineNumberInfo, IXamlLineInfo xamlLineInfo, IXamlLineInfoConsumer xamlLineInfoConsumer, XamlContextStack`1<WpfXamlFrame> stack, IStyleConnector styleConnector);
    private static void WriteValue(XamlReader xamlReader, XamlObjectWriter xamlWriter, XamlContextStack`1<WpfXamlFrame> stack, IStyleConnector styleConnector);
    private static void WriteStartObject(XamlReader xamlReader, XamlObjectWriter xamlWriter, XamlContextStack`1<WpfXamlFrame> stack);
}
internal class System.Windows.Markup.WriterStream : Stream {
    private ReadWriteStreamManager _streamManager;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    private ReadWriteStreamManager StreamManager { get; }
    internal WriterStream(ReadWriteStreamManager streamManager);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual void Close();
    public virtual void Flush();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual int ReadByte();
    public virtual long Seek(long offset, SeekOrigin loc);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    internal void UpdateReaderLength(long position);
    private ReadWriteStreamManager get_StreamManager();
}
[DebuggerDisplayAttribute("Attr:{_value}")]
internal class System.Windows.Markup.XamlAttributeNode : XamlNode {
    private string _value;
    internal string Value { get; }
    internal XamlAttributeNode(XamlNodeType tokenType, int lineNumber, int linePosition, int depth, string value);
    internal string get_Value();
}
internal class System.Windows.Markup.XamlBrushSerializer : XamlSerializer {
    public virtual bool ConvertStringToCustomBinary(BinaryWriter writer, string stringValue);
    public virtual object ConvertCustomBinaryToObject(BinaryReader reader);
}
internal class System.Windows.Markup.XamlClrEventNode : XamlAttributeNode {
    internal XamlClrEventNode(int lineNumber, int linePosition, int depth, string eventName, MemberInfo eventMember, string value);
}
internal class System.Windows.Markup.XamlConstructorParametersEndNode : XamlNode {
    internal XamlConstructorParametersEndNode(int lineNumber, int linePosition, int depth);
}
internal class System.Windows.Markup.XamlConstructorParametersStartNode : XamlNode {
    internal XamlConstructorParametersStartNode(int lineNumber, int linePosition, int depth);
}
internal class System.Windows.Markup.XamlContentPropertyNode : XamlNode {
    private Type _declaringType;
    private Type _validType;
    private object _propertyMember;
    private string _assemblyName;
    private string _typeFullName;
    private string _propName;
    internal string AssemblyName { get; }
    internal string TypeFullName { get; }
    internal string PropName { get; }
    internal Type PropDeclaringType { get; }
    internal Type PropValidType { get; }
    internal XamlContentPropertyNode(int lineNumber, int linePosition, int depth, object propertyMember, string assemblyName, string typeFullName, string propertyName);
    internal string get_AssemblyName();
    internal string get_TypeFullName();
    internal string get_PropName();
    internal Type get_PropDeclaringType();
    internal Type get_PropValidType();
}
internal class System.Windows.Markup.XamlDefAttributeKeyTypeNode : XamlAttributeNode {
    private string _assemblyName;
    private Type _valueType;
    internal string AssemblyName { get; }
    internal Type ValueType { get; }
    internal XamlDefAttributeKeyTypeNode(int lineNumber, int linePosition, int depth, string value, string assemblyName, Type valueType);
    internal string get_AssemblyName();
    internal Type get_ValueType();
}
internal class System.Windows.Markup.XamlDefAttributeNode : XamlAttributeNode {
    private BamlAttributeUsage _attributeUsage;
    private string _name;
    internal string Name { get; }
    internal BamlAttributeUsage AttributeUsage { get; }
    internal XamlDefAttributeNode(int lineNumber, int linePosition, int depth, string name, string value);
    internal XamlDefAttributeNode(int lineNumber, int linePosition, int depth, string name, string value, BamlAttributeUsage bamlAttributeUsage);
    internal string get_Name();
    internal BamlAttributeUsage get_AttributeUsage();
}
internal class System.Windows.Markup.XamlDefTagNode : XamlAttributeNode {
    internal XamlDefTagNode(int lineNumber, int linePosition, int depth, bool isEmptyElement, XmlReader xmlReader, string defTagName);
}
public class System.Windows.Markup.XamlDesignerSerializationManager : ServiceProviders {
    private XamlWriterMode _xamlWriterMode;
    private XmlWriter _xmlWriter;
    public XamlWriterMode XamlWriterMode { get; public set; }
    internal XmlWriter XmlWriter { get; }
    public XamlDesignerSerializationManager(XmlWriter xmlWriter);
    public XamlWriterMode get_XamlWriterMode();
    public void set_XamlWriterMode(XamlWriterMode value);
    internal XmlWriter get_XmlWriter();
    internal void ClearXmlWriter();
    private static bool IsValidXamlWriterMode(XamlWriterMode value);
}
internal class System.Windows.Markup.XamlDocumentEndNode : XamlNode {
    internal XamlDocumentEndNode(int lineNumber, int linePosition, int depth);
}
internal class System.Windows.Markup.XamlDocumentStartNode : XamlNode {
    internal XamlDocumentStartNode(int lineNumber, int linePosition, int depth);
}
internal class System.Windows.Markup.XamlElementEndNode : XamlNode {
    internal XamlElementEndNode(int lineNumber, int linePosition, int depth);
    internal XamlElementEndNode(XamlNodeType tokenType, int lineNumber, int linePosition, int depth);
}
[DebuggerDisplayAttribute("Elem:{_typeFullName}")]
internal class System.Windows.Markup.XamlElementStartNode : XamlNode {
    private string _assemblyName;
    private string _typeFullName;
    private Type _elementType;
    private Type _serializerType;
    private bool _isEmptyElement;
    private bool _needsDictionaryKey;
    private bool _useTypeConverter;
    private bool _isInjected;
    internal string AssemblyName { get; }
    internal string TypeFullName { get; }
    internal Type ElementType { get; }
    internal Type SerializerType { get; }
    internal string SerializerTypeFullName { get; }
    internal bool CreateUsingTypeConverter { get; internal set; }
    internal bool IsInjected { get; internal set; }
    internal XamlElementStartNode(int lineNumber, int linePosition, int depth, string assemblyName, string typeFullName, Type elementType, Type serializerType);
    internal XamlElementStartNode(XamlNodeType tokenType, int lineNumber, int linePosition, int depth, string assemblyName, string typeFullName, Type elementType, Type serializerType, bool isEmptyElement, bool needsDictionaryKey, bool isInjected);
    internal string get_AssemblyName();
    internal string get_TypeFullName();
    internal Type get_ElementType();
    internal Type get_SerializerType();
    internal string get_SerializerTypeFullName();
    internal bool get_CreateUsingTypeConverter();
    internal void set_CreateUsingTypeConverter(bool value);
    internal bool get_IsInjected();
    internal void set_IsInjected(bool value);
}
internal class System.Windows.Markup.XamlEndAttributesNode : XamlNode {
    private bool _compact;
    internal bool IsCompact { get; }
    internal XamlEndAttributesNode(int lineNumber, int linePosition, int depth, bool compact);
    internal bool get_IsCompact();
}
internal class System.Windows.Markup.XamlFigureLengthSerializer : XamlSerializer {
    private static FigureUnitTypeStringConvert[] UnitStrings;
    private static String[] PixelUnitStrings;
    private static Double[] PixelUnitFactors;
    private static XamlFigureLengthSerializer();
    public virtual bool ConvertStringToCustomBinary(BinaryWriter writer, string stringValue);
    public virtual object ConvertCustomBinaryToObject(BinaryReader reader);
    internal static void FromString(string s, CultureInfo cultureInfo, Double& value, FigureUnitType& unit);
}
internal class System.Windows.Markup.XamlGridLengthSerializer : XamlSerializer {
    private static String[] UnitStrings;
    private static String[] PixelUnitStrings;
    private static Double[] PixelUnitFactors;
    private static XamlGridLengthSerializer();
    public virtual bool ConvertStringToCustomBinary(BinaryWriter writer, string stringValue);
    public virtual object ConvertCustomBinaryToObject(BinaryReader reader);
    internal static void FromString(string s, CultureInfo cultureInfo, Double& value, GridUnitType& unit);
}
public abstract class System.Windows.Markup.XamlInstanceCreator : object {
    public abstract virtual object CreateObject();
}
internal class System.Windows.Markup.XamlInt32CollectionSerializer : XamlSerializer {
    public virtual bool ConvertStringToCustomBinary(BinaryWriter writer, string stringValue);
    public virtual object ConvertCustomBinaryToObject(BinaryReader reader);
    public static object StaticConvertCustomBinaryToObject(BinaryReader reader);
    private static Int32Collection DeserializeFrom(BinaryReader reader);
}
internal class System.Windows.Markup.XamlKeyElementEndNode : XamlElementEndNode {
    internal XamlKeyElementEndNode(int lineNumber, int linePosition, int depth);
}
internal class System.Windows.Markup.XamlKeyElementStartNode : XamlElementStartNode {
    internal XamlKeyElementStartNode(int lineNumber, int linePosition, int depth, string assemblyName, string typeFullName, Type elementType, Type serializerType);
}
[DebuggerDisplayAttribute("Cont:{_content}")]
internal class System.Windows.Markup.XamlLiteralContentNode : XamlNode {
    private string _content;
    internal string Content { get; }
    internal XamlLiteralContentNode(int lineNumber, int linePosition, int depth, string content);
    internal string get_Content();
}
internal class System.Windows.Markup.XamlNode : object {
    internal static XamlNodeType[] ScopeStartTokens;
    internal static XamlNodeType[] ScopeEndTokens;
    private XamlNodeType _token;
    private int _lineNumber;
    private int _linePosition;
    private int _depth;
    internal XamlNodeType TokenType { get; }
    internal int LineNumber { get; }
    internal int LinePosition { get; }
    internal int Depth { get; }
    internal XamlNode(XamlNodeType tokenType, int lineNumber, int linePosition, int depth);
    private static XamlNode();
    internal XamlNodeType get_TokenType();
    internal int get_LineNumber();
    internal int get_LinePosition();
    internal int get_Depth();
}
internal enum System.Windows.Markup.XamlNodeType : Enum {
    public int value__;
    public static XamlNodeType Unknown;
    public static XamlNodeType DocumentStart;
    public static XamlNodeType DocumentEnd;
    public static XamlNodeType ElementStart;
    public static XamlNodeType ElementEnd;
    public static XamlNodeType Property;
    public static XamlNodeType PropertyComplexStart;
    public static XamlNodeType PropertyComplexEnd;
    public static XamlNodeType PropertyArrayStart;
    public static XamlNodeType PropertyArrayEnd;
    public static XamlNodeType PropertyIListStart;
    public static XamlNodeType PropertyIListEnd;
    public static XamlNodeType PropertyIDictionaryStart;
    public static XamlNodeType PropertyIDictionaryEnd;
    public static XamlNodeType PropertyWithExtension;
    public static XamlNodeType PropertyWithType;
    public static XamlNodeType LiteralContent;
    public static XamlNodeType Text;
    public static XamlNodeType RoutedEvent;
    public static XamlNodeType ClrEvent;
    public static XamlNodeType XmlnsProperty;
    public static XamlNodeType XmlAttribute;
    public static XamlNodeType ProcessingInstruction;
    public static XamlNodeType Comment;
    public static XamlNodeType DefTag;
    public static XamlNodeType DefAttribute;
    public static XamlNodeType PresentationOptionsAttribute;
    public static XamlNodeType DefKeyTypeAttribute;
    public static XamlNodeType EndAttributes;
    public static XamlNodeType PIMapping;
    public static XamlNodeType UnknownTagStart;
    public static XamlNodeType UnknownTagEnd;
    public static XamlNodeType UnknownAttribute;
    public static XamlNodeType KeyElementStart;
    public static XamlNodeType KeyElementEnd;
    public static XamlNodeType ConstructorParametersStart;
    public static XamlNodeType ConstructorParametersEnd;
    public static XamlNodeType ConstructorParameterType;
    public static XamlNodeType ContentProperty;
}
internal class System.Windows.Markup.XamlObjectIds : object {
    public string Name;
    public string Uid;
    public object Key;
}
public class System.Windows.Markup.XamlParseException : SystemException {
    internal static string BamlExt;
    internal static string XamlExt;
    private int _lineNumber;
    private int _linePosition;
    private object _keyContext;
    private string _uidContext;
    private string _nameContext;
    private Uri _baseUri;
    public int LineNumber { get; internal set; }
    public int LinePosition { get; internal set; }
    public object KeyContext { get; internal set; }
    public string UidContext { get; internal set; }
    public string NameContext { get; internal set; }
    public Uri BaseUri { get; internal set; }
    public XamlParseException(string message);
    public XamlParseException(string message, Exception innerException);
    public XamlParseException(string message, int lineNumber, int linePosition);
    public XamlParseException(string message, int lineNumber, int linePosition, Exception innerException);
    internal XamlParseException(string message, int lineNumber, int linePosition, Uri baseUri, Exception innerException);
    protected XamlParseException(SerializationInfo info, StreamingContext context);
    public int get_LineNumber();
    internal void set_LineNumber(int value);
    public int get_LinePosition();
    internal void set_LinePosition(int value);
    public object get_KeyContext();
    internal void set_KeyContext(object value);
    public string get_UidContext();
    internal void set_UidContext(string value);
    public string get_NameContext();
    internal void set_NameContext(string value);
    public Uri get_BaseUri();
    internal void set_BaseUri(Uri value);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    internal static string GetMarkupFilePath(Uri resourceUri);
    internal static string GenerateErrorMessageContext(int lineNumber, int linePosition, Uri baseUri, XamlObjectIds xamlObjectIds, Type objectType);
    internal static void ThrowException(string message, Exception innerException, int lineNumber, int linePosition, Uri baseUri, XamlObjectIds currentXamlObjectIds, XamlObjectIds contextXamlObjectIds, Type objectType);
    internal static void ThrowException(ParserContext parserContext, int lineNumber, int linePosition, string message, Exception innerException);
    internal static void ThrowException(string message, Exception innerException, int lineNumber, int linePosition);
}
internal enum System.Windows.Markup.XamlParseMode : Enum {
    public int value__;
    public static XamlParseMode Uninitialized;
    public static XamlParseMode Synchronous;
    public static XamlParseMode Asynchronous;
}
internal class System.Windows.Markup.XamlParser : object {
    internal static void ThrowException(string id, int lineNumber, int linePosition);
    internal static void ThrowException(string id, string value, int lineNumber, int linePosition);
    internal static void ThrowException(string id, string value1, string value2, int lineNumber, int linePosition);
    internal static void ThrowException(string id, string value1, string value2, string value3, int lineNumber, int linePosition);
    internal static void ThrowException(string id, string value1, string value2, string value3, string value4, int lineNumber, int linePosition);
    private static void ThrowExceptionWithLine(string message, int lineNumber, int linePosition);
}
internal class System.Windows.Markup.XamlPathDataSerializer : XamlSerializer {
    public virtual bool ConvertStringToCustomBinary(BinaryWriter writer, string stringValue);
    public virtual object ConvertCustomBinaryToObject(BinaryReader reader);
    public static object StaticConvertCustomBinaryToObject(BinaryReader reader);
}
[DebuggerDisplayAttribute("PIMap:{_xmlns}={_clrns};{_assy}")]
internal class System.Windows.Markup.XamlPIMappingNode : XamlNode {
    private string _xmlns;
    private string _clrns;
    private string _assy;
    internal string XmlNamespace { get; }
    internal string ClrNamespace { get; }
    internal string AssemblyName { get; }
    internal XamlPIMappingNode(int lineNumber, int linePosition, int depth, string xmlNamespace, string clrNamespace, string assemblyName);
    internal string get_XmlNamespace();
    internal string get_ClrNamespace();
    internal string get_AssemblyName();
}
internal class System.Windows.Markup.XamlPoint3DCollectionSerializer : XamlSerializer {
    public virtual bool ConvertStringToCustomBinary(BinaryWriter writer, string stringValue);
    public virtual object ConvertCustomBinaryToObject(BinaryReader reader);
    public static object StaticConvertCustomBinaryToObject(BinaryReader reader);
}
internal class System.Windows.Markup.XamlPointCollectionSerializer : XamlSerializer {
    public virtual bool ConvertStringToCustomBinary(BinaryWriter writer, string stringValue);
    public virtual object ConvertCustomBinaryToObject(BinaryReader reader);
    public static object StaticConvertCustomBinaryToObject(BinaryReader reader);
}
internal class System.Windows.Markup.XamlPresentationOptionsAttributeNode : XamlAttributeNode {
    private string _name;
    internal string Name { get; }
    internal XamlPresentationOptionsAttributeNode(int lineNumber, int linePosition, int depth, string name, string value);
    internal string get_Name();
}
internal class System.Windows.Markup.XamlPropertyArrayEndNode : XamlPropertyComplexEndNode {
    internal XamlPropertyArrayEndNode(int lineNumber, int linePosition, int depth);
}
internal class System.Windows.Markup.XamlPropertyArrayStartNode : XamlPropertyComplexStartNode {
    internal XamlPropertyArrayStartNode(int lineNumber, int linePosition, int depth, object propertyMember, string assemblyName, string typeFullName, string propertyName);
}
[DebuggerDisplayAttribute("Prop:{_typeFullName}.{_propName}")]
internal class System.Windows.Markup.XamlPropertyBaseNode : XamlNode {
    private object _propertyMember;
    private string _assemblyName;
    private string _typeFullName;
    private string _propName;
    private Type _validType;
    private Type _declaringType;
    internal string AssemblyName { get; }
    internal string TypeFullName { get; }
    internal string PropName { get; }
    internal Type PropDeclaringType { get; }
    internal Type PropValidType { get; }
    internal object PropertyMember { get; }
    internal XamlPropertyBaseNode(XamlNodeType token, int lineNumber, int linePosition, int depth, object propertyMember, string assemblyName, string typeFullName, string propertyName);
    internal string get_AssemblyName();
    internal string get_TypeFullName();
    internal string get_PropName();
    internal Type get_PropDeclaringType();
    internal Type get_PropValidType();
    internal object get_PropertyMember();
}
internal class System.Windows.Markup.XamlPropertyComplexEndNode : XamlNode {
    internal XamlPropertyComplexEndNode(int lineNumber, int linePosition, int depth);
    internal XamlPropertyComplexEndNode(XamlNodeType token, int lineNumber, int linePosition, int depth);
}
internal class System.Windows.Markup.XamlPropertyComplexStartNode : XamlPropertyBaseNode {
    internal XamlPropertyComplexStartNode(int lineNumber, int linePosition, int depth, object propertyMember, string assemblyName, string typeFullName, string propertyName);
    internal XamlPropertyComplexStartNode(XamlNodeType token, int lineNumber, int linePosition, int depth, object propertyMember, string assemblyName, string typeFullName, string propertyName);
}
internal class System.Windows.Markup.XamlPropertyIDictionaryEndNode : XamlPropertyComplexEndNode {
    internal XamlPropertyIDictionaryEndNode(int lineNumber, int linePosition, int depth);
}
internal class System.Windows.Markup.XamlPropertyIDictionaryStartNode : XamlPropertyComplexStartNode {
    internal XamlPropertyIDictionaryStartNode(int lineNumber, int linePosition, int depth, object propertyMember, string assemblyName, string typeFullName, string propertyName);
}
internal class System.Windows.Markup.XamlPropertyIListEndNode : XamlPropertyComplexEndNode {
    internal XamlPropertyIListEndNode(int lineNumber, int linePosition, int depth);
}
internal class System.Windows.Markup.XamlPropertyIListStartNode : XamlPropertyComplexStartNode {
    internal XamlPropertyIListStartNode(int lineNumber, int linePosition, int depth, object propertyMember, string assemblyName, string typeFullName, string propertyName);
}
internal class System.Windows.Markup.XamlPropertyNode : XamlPropertyBaseNode {
    private string _value;
    private BamlAttributeUsage _attributeUsage;
    private bool _complexAsSimple;
    private bool _isDefinitionName;
    private Type _valueDeclaringType;
    private string _valuePropertyName;
    private Type _valuePropertyType;
    private object _valuePropertyMember;
    private bool _hasValueId;
    private short _valueId;
    private string _memberName;
    private Type _defaultTargetType;
    internal string Value { get; }
    internal Type ValueDeclaringType { get; internal set; }
    internal string ValuePropertyName { get; internal set; }
    internal Type ValuePropertyType { get; internal set; }
    internal object ValuePropertyMember { get; internal set; }
    internal bool HasValueId { get; }
    internal short ValueId { get; internal set; }
    internal string MemberName { get; internal set; }
    internal Type DefaultTargetType { get; internal set; }
    internal BamlAttributeUsage AttributeUsage { get; }
    internal bool ComplexAsSimple { get; }
    internal XamlPropertyNode(int lineNumber, int linePosition, int depth, object propertyMember, string assemblyName, string typeFullName, string propertyName, string value, BamlAttributeUsage attributeUsage, bool complexAsSimple);
    internal XamlPropertyNode(int lineNumber, int linePosition, int depth, object propertyMember, string assemblyName, string typeFullName, string propertyName, string value, BamlAttributeUsage attributeUsage, bool complexAsSimple, bool isDefinitionName);
    internal string get_Value();
    internal void SetValue(string value);
    internal Type get_ValueDeclaringType();
    internal void set_ValueDeclaringType(Type value);
    internal string get_ValuePropertyName();
    internal void set_ValuePropertyName(string value);
    internal Type get_ValuePropertyType();
    internal void set_ValuePropertyType(Type value);
    internal object get_ValuePropertyMember();
    internal void set_ValuePropertyMember(object value);
    internal bool get_HasValueId();
    internal short get_ValueId();
    internal void set_ValueId(short value);
    internal string get_MemberName();
    internal void set_MemberName(string value);
    internal Type get_DefaultTargetType();
    internal void set_DefaultTargetType(Type value);
    internal BamlAttributeUsage get_AttributeUsage();
    internal bool get_ComplexAsSimple();
}
internal class System.Windows.Markup.XamlPropertyWithExtensionNode : XamlPropertyBaseNode {
    private short _extensionTypeId;
    private string _value;
    private bool _isValueNestedExtension;
    private bool _isValueTypeExtension;
    private Type _defaultTargetType;
    internal short ExtensionTypeId { get; }
    internal string Value { get; }
    internal bool IsValueNestedExtension { get; }
    internal bool IsValueTypeExtension { get; }
    internal Type DefaultTargetType { get; internal set; }
    internal XamlPropertyWithExtensionNode(int lineNumber, int linePosition, int depth, object propertyMember, string assemblyName, string typeFullName, string propertyName, string value, short extensionTypeId, bool isValueNestedExtension, bool isValueTypeExtension);
    internal short get_ExtensionTypeId();
    internal string get_Value();
    internal bool get_IsValueNestedExtension();
    internal bool get_IsValueTypeExtension();
    internal Type get_DefaultTargetType();
    internal void set_DefaultTargetType(Type value);
}
internal class System.Windows.Markup.XamlPropertyWithTypeNode : XamlPropertyBaseNode {
    private string _valueTypeFullname;
    private string _valueTypeAssemblyName;
    private Type _valueElementType;
    private string _valueSerializerTypeFullName;
    private string _valueSerializerTypeAssemblyName;
    internal string ValueTypeFullName { get; }
    internal string ValueTypeAssemblyName { get; }
    internal Type ValueElementType { get; }
    internal string ValueSerializerTypeFullName { get; }
    internal string ValueSerializerTypeAssemblyName { get; }
    internal XamlPropertyWithTypeNode(int lineNumber, int linePosition, int depth, object propertyMember, string assemblyName, string typeFullName, string propertyName, string valueTypeFullName, string valueAssemblyName, Type valueElementType, string valueSerializerTypeFullName, string valueSerializerTypeAssemblyName);
    internal string get_ValueTypeFullName();
    internal string get_ValueTypeAssemblyName();
    internal Type get_ValueElementType();
    internal string get_ValueSerializerTypeFullName();
    internal string get_ValueSerializerTypeAssemblyName();
}
public class System.Windows.Markup.XamlReader : object {
    private static int AsyncLoopTimeout;
    [CompilerGeneratedAttribute]
private AsyncCompletedEventHandler LoadCompleted;
    private Uri _baseUri;
    private XamlReader _textReader;
    private XmlReader _xmlReader;
    private XamlObjectWriter _objectWriter;
    private Stream _stream;
    private bool _parseCancelled;
    private Exception _parseException;
    private int _persistId;
    private bool _skipJournaledProperties;
    private XamlContextStack`1<WpfXamlFrame> _stack;
    private int _maxAsynxRecords;
    private IStyleConnector _styleConnector;
    private static Lazy`1<WpfSharedBamlSchemaContext> _bamlSharedContext;
    private static Lazy`1<WpfSharedXamlSchemaContext> _xamlSharedContext;
    private static Lazy`1<WpfSharedXamlSchemaContext> _xamlV3SharedContext;
    internal static WpfSharedBamlSchemaContext BamlSharedSchemaContext { get; }
    internal static WpfSharedBamlSchemaContext XamlV3SharedSchemaContext { get; }
    private static XamlReader();
    public static object Parse(string xamlText);
    public static object Parse(string xamlText, ParserContext parserContext);
    public static object Load(Stream stream);
    public static object Load(XmlReader reader);
    public static object Load(Stream stream, ParserContext parserContext);
    public object LoadAsync(Stream stream);
    public object LoadAsync(XmlReader reader);
    public object LoadAsync(Stream stream, ParserContext parserContext);
    internal static bool ShouldReWrapException(Exception e, Uri baseUri);
    private object LoadAsync(XmlReader reader, ParserContext parserContext);
    internal static void RewrapException(Exception e, Uri baseUri);
    internal static void RewrapException(Exception e, IXamlLineInfo lineInfo, Uri baseUri);
    internal static XamlParseException WrapException(Exception e, IXamlLineInfo lineInfo, Uri baseUri);
    internal void Post();
    internal void Post(DispatcherPriority priority);
    private object Dispatch(object o);
    private void DispatchParserQueueEvent(XamlReader xamlReader);
    internal virtual void HandleAsyncQueueItem();
    internal void TreeBuildComplete();
    public void CancelAsync();
    [CompilerGeneratedAttribute]
public void add_LoadCompleted(AsyncCompletedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_LoadCompleted(AsyncCompletedEventHandler value);
    internal static XamlObjectWriterSettings CreateObjectWriterSettings();
    internal static XamlObjectWriterSettings CreateObjectWriterSettings(XamlObjectWriterSettings parentSettings);
    internal static XamlObjectWriterSettings CreateObjectWriterSettingsForBaml();
    internal static Baml2006ReaderSettings CreateBamlReaderSettings();
    internal static XamlSchemaContextSettings CreateSchemaContextSettings();
    internal static WpfSharedBamlSchemaContext get_BamlSharedSchemaContext();
    internal static WpfSharedBamlSchemaContext get_XamlV3SharedSchemaContext();
    public static XamlSchemaContext GetWpfSchemaContext();
    internal static object Load(Stream stream, ParserContext parserContext, bool useRestrictiveXamlReader);
    internal static object Load(XmlReader reader, bool useRestrictiveXamlReader);
    internal static object Load(XmlReader reader, ParserContext parserContext, XamlParseMode parseMode);
    internal static object Load(XmlReader reader, ParserContext parserContext, XamlParseMode parseMode, bool useRestrictiveXamlReader);
    internal static object Load(XmlReader reader, ParserContext parserContext, XamlParseMode parseMode, bool useRestrictiveXamlReader, List`1<Type> safeTypes);
    internal static object Load(XamlReader xamlReader, ParserContext parserContext);
    public static object Load(XamlReader reader);
    internal static object LoadBaml(Stream stream, ParserContext parserContext, object parent, bool closeStream);
    private static Uri GetBaseUri(Uri uri);
    private static WpfSharedBamlSchemaContext CreateBamlSchemaContext();
    private static WpfSharedXamlSchemaContext CreateXamlSchemaContext(bool useV3Rules);
    [CompilerGeneratedAttribute]
private object <TreeBuildComplete>b__19_0(object obj);
}
internal class System.Windows.Markup.XamlReaderHelper : object {
    internal static string DefinitionNamespaceURI;
    internal static string DefinitionUid;
    internal static string DefinitionType;
    internal static string DefinitionTypeArgs;
    internal static string DefinitionName;
    internal static string DefinitionRuntimeName;
    internal static string DefinitionShared;
    internal static string DefinitionSynchronousMode;
    internal static string DefinitionAsyncRecords;
    internal static string DefinitionContent;
    internal static string DefinitionClass;
    internal static string DefinitionSubclass;
    internal static string DefinitionClassModifier;
    internal static string DefinitionFieldModifier;
    internal static string DefinitionCodeTag;
    internal static string DefinitionXDataTag;
    internal static string MappingProtocol;
    internal static string MappingAssembly;
    internal static string PresentationOptionsFreeze;
    internal static string DefaultNamespaceURI;
    internal static string DefinitionMetroNamespaceURI;
    internal static string PresentationOptionsNamespaceURI;
    private static XamlDirective _freezeDirective;
    internal static XamlDirective Freeze { get; }
    internal static XamlDirective get_Freeze();
}
internal class System.Windows.Markup.XamlRoutedEventNode : XamlAttributeNode {
    private RoutedEvent _routedEvent;
    private string _assemblyName;
    private string _typeFullName;
    private string _routedEventName;
    internal RoutedEvent Event { get; }
    internal string AssemblyName { get; }
    internal string TypeFullName { get; }
    internal string EventName { get; }
    internal XamlRoutedEventNode(int lineNumber, int linePosition, int depth, RoutedEvent routedEvent, string assemblyName, string typeFullName, string routedEventName, string value);
    internal RoutedEvent get_Event();
    internal string get_AssemblyName();
    internal string get_TypeFullName();
    internal string get_EventName();
}
internal class System.Windows.Markup.XamlSerializer : object {
    internal static string DefNamespacePrefix;
    internal static string DefNamespace;
    internal static string ArrayTag;
    internal static string ArrayTagTypeAttribute;
    internal virtual void ConvertXamlToBaml(XamlReaderHelper tokenReader, ParserContext context, XamlNode xamlNode, BamlRecordWriter bamlWriter);
    internal virtual void ConvertXamlToObject(XamlReaderHelper tokenReader, ReadWriteStreamManager streamManager, ParserContext context, XamlNode xamlNode, BamlRecordReader reader);
    internal virtual void ConvertBamlToObject(BamlRecordReader reader, BamlRecord bamlRecord, ParserContext context);
    public virtual bool ConvertStringToCustomBinary(BinaryWriter writer, string stringValue);
    public virtual object ConvertCustomBinaryToObject(BinaryReader reader);
    internal virtual object GetDictionaryKey(BamlRecord bamlRecord, ParserContext parserContext);
}
internal static class System.Windows.Markup.XamlSerializerUtil : object {
    internal static void ThrowIfNonWhiteSpaceInAddText(string s, object parent);
}
internal class System.Windows.Markup.XamlStyleSerializer : XamlSerializer {
    internal static string StyleTagName;
    internal static string TargetTypePropertyName;
    internal static string BasedOnPropertyName;
    internal static string VisualTriggersPropertyName;
    internal static string ResourcesPropertyName;
    internal static string SettersPropertyName;
    internal static string VisualTriggersFullPropertyName;
    internal static string SettersFullPropertyName;
    internal static string ResourcesFullPropertyName;
    internal static string PropertyTriggerPropertyName;
    internal static string PropertyTriggerValuePropertyName;
    internal static string PropertyTriggerSourceName;
    internal static string PropertyTriggerEnterActions;
    internal static string PropertyTriggerExitActions;
    internal static string DataTriggerBindingPropertyName;
    internal static string EventTriggerEventName;
    internal static string EventTriggerSourceName;
    internal static string EventTriggerActions;
    internal static string MultiPropertyTriggerConditionsPropertyName;
    internal static string SetterTagName;
    internal static string SetterPropertyAttributeName;
    internal static string SetterValueAttributeName;
    internal static string SetterTargetAttributeName;
    internal static string SetterEventAttributeName;
    internal static string SetterHandlerAttributeName;
    internal virtual object GetDictionaryKey(BamlRecord startRecord, ParserContext parserContext);
    private void ThrowException(string id, int lineNumber, int linePosition);
}
internal class System.Windows.Markup.XamlTemplateSerializer : XamlSerializer {
    internal static string ControlTemplateTagName;
    internal static string DataTemplateTagName;
    internal static string HierarchicalDataTemplateTagName;
    internal static string ItemsPanelTemplateTagName;
    internal static string TargetTypePropertyName;
    internal static string DataTypePropertyName;
    internal static string TriggersPropertyName;
    internal static string ResourcesPropertyName;
    internal static string SettersPropertyName;
    internal static string ItemsSourcePropertyName;
    internal static string ItemTemplatePropertyName;
    internal static string ItemTemplateSelectorPropertyName;
    internal static string ItemContainerStylePropertyName;
    internal static string ItemContainerStyleSelectorPropertyName;
    internal static string ItemStringFormatPropertyName;
    internal static string ItemBindingGroupPropertyName;
    internal static string AlternationCountPropertyName;
    internal static string ControlTemplateTriggersFullPropertyName;
    internal static string ControlTemplateResourcesFullPropertyName;
    internal static string DataTemplateTriggersFullPropertyName;
    internal static string DataTemplateResourcesFullPropertyName;
    internal static string HierarchicalDataTemplateTriggersFullPropertyName;
    internal static string HierarchicalDataTemplateItemsSourceFullPropertyName;
    internal static string HierarchicalDataTemplateItemTemplateFullPropertyName;
    internal static string HierarchicalDataTemplateItemTemplateSelectorFullPropertyName;
    internal static string HierarchicalDataTemplateItemContainerStyleFullPropertyName;
    internal static string HierarchicalDataTemplateItemContainerStyleSelectorFullPropertyName;
    internal static string HierarchicalDataTemplateItemStringFormatFullPropertyName;
    internal static string HierarchicalDataTemplateItemBindingGroupFullPropertyName;
    internal static string HierarchicalDataTemplateAlternationCountFullPropertyName;
    internal static string PropertyTriggerPropertyName;
    internal static string PropertyTriggerValuePropertyName;
    internal static string PropertyTriggerSourceName;
    internal static string PropertyTriggerEnterActions;
    internal static string PropertyTriggerExitActions;
    internal static string DataTriggerBindingPropertyName;
    internal static string EventTriggerEventName;
    internal static string EventTriggerSourceName;
    internal static string EventTriggerActions;
    internal static string MultiPropertyTriggerConditionsPropertyName;
    internal static string SetterTagName;
    internal static string SetterPropertyAttributeName;
    internal static string SetterValueAttributeName;
    internal static string SetterTargetAttributeName;
    internal static string SetterEventAttributeName;
    internal static string SetterHandlerAttributeName;
    internal virtual object GetDictionaryKey(BamlRecord startRecord, ParserContext parserContext);
    private void ThrowException(string id, int lineNumber, int linePosition, Exception innerException);
}
[DebuggerDisplayAttribute("Text:{_text}")]
internal class System.Windows.Markup.XamlTextNode : XamlNode {
    private string _text;
    private Type _converterType;
    internal string Text { get; }
    internal Type ConverterType { get; }
    internal XamlTextNode(int lineNumber, int linePosition, int depth, string textContent, Type converterType);
    internal string get_Text();
    internal Type get_ConverterType();
    internal void UpdateText(string text);
}
public class System.Windows.Markup.XamlTypeMapper : object {
    internal static string MarkupExtensionTypeString;
    internal static string MarkupExtensionStaticString;
    internal static string MarkupExtensionDynamicResourceString;
    internal static string PresentationFrameworkDllName;
    internal static string GeneratedNamespace;
    internal static string GeneratedInternalTypeHelperClassName;
    internal static string MarkupExtensionTemplateBindingString;
    private BamlMapTable _mapTable;
    private String[] _assemblyNames;
    private NamespaceMapEntry[] _namespaceMaps;
    private Hashtable _typeLookupFromXmlHashtable;
    private Hashtable _namespaceMapHashList;
    private HybridDictionary _typeInformationCache;
    private HybridDictionary _constructorInformationCache;
    private XamlTypeMapperSchemaContext _schemaContext;
    private HybridDictionary _piTable;
    private Dictionary`2<string, string> _piReverseTable;
    private HybridDictionary _assemblyPathTable;
    private bool _referenceAssembliesLoaded;
    private int _lineNumber;
    private int _linePosition;
    private static XmlnsCache _xmlnsCache;
    public static XamlTypeMapper DefaultMapper { get; }
    internal HybridDictionary PITable { get; }
    internal BamlMapTable MapTable { get; internal set; }
    unknown int LineNumber {internal set; }
    unknown int LinePosition {internal set; }
    internal Hashtable NamespaceMapHashList { get; }
    internal XamlSchemaContext SchemaContext { get; }
    public XamlTypeMapper(String[] assemblyNames);
    public XamlTypeMapper(String[] assemblyNames, NamespaceMapEntry[] namespaceMaps);
    public Type GetType(string xmlNamespace, string localName);
    public void AddMappingProcessingInstruction(string xmlNamespace, string clrNamespace, string assemblyName);
    public void SetAssemblyPath(string assemblyName, string assemblyPath);
    public static XamlTypeMapper get_DefaultMapper();
    internal void Initialize();
    internal XamlTypeMapper Clone();
    private HybridDictionary CloneHybridDictionary(HybridDictionary dict);
    private Dictionary`2<string, string> CloneStringDictionary(Dictionary`2<string, string> dict);
    internal string AssemblyPathFor(string assemblyName);
    private bool LoadReferenceAssemblies();
    internal RoutedEvent GetRoutedEvent(Type owner, string xmlNamespace, string localName);
    internal object ParseProperty(object targetObject, Type propType, string propName, object dpOrPiOrFi, ITypeDescriptorContext typeContext, ParserContext parserContext, string value, short converterTypeId);
    private string TypeConverterFailure(string value, string propName, string propType);
    internal void ValidateNames(string value, int lineNumber, int linePosition);
    internal void ValidateEnums(string propName, Type propType, string attribValue);
    private MemberInfo GetCachedMemberInfo(Type owner, string propName, bool onlyPropInfo, BamlAttributeInfoRecord& infoRecord);
    private void AddCachedAttributeInfo(Type ownerType, BamlAttributeInfoRecord infoRecord);
    internal void UpdateClrPropertyInfo(Type currentParentType, BamlAttributeInfoRecord attribInfo);
    private void UpdateAttachedPropertyMethdodInfo(BamlAttributeInfoRecord attributeInfo, bool isSetter);
    internal void UpdateAttachedPropertySetter(BamlAttributeInfoRecord attributeInfo);
    internal void UpdateAttachedPropertyGetter(BamlAttributeInfoRecord attributeInfo);
    internal MemberInfo GetClrInfo(bool isEvent, Type owner, string xmlNamespace, string localName, String& propName);
    internal bool IsAllowedPropertySet(PropertyInfo pi);
    internal bool IsAllowedPropertyGet(PropertyInfo pi);
    internal static bool IsAllowedPropertySet(PropertyInfo pi, bool allowProtected, Boolean& isPublic);
    private static bool IsAllowedPropertyGet(PropertyInfo pi, bool allowProtected, Boolean& isPublic);
    private static bool IsAllowedEvent(EventInfo ei, bool allowProtected, Boolean& isPublic);
    private static bool IsPublicEvent(EventInfo ei);
    protected virtual bool AllowInternalType(Type type);
    private bool IsInternalTypeAllowedInFullTrust(Type type);
    internal MemberInfo GetClrInfoForClass(bool isEvent, Type owner, string xmlNamespace, string localName, string globalClassName, String& propName);
    private MemberInfo GetClrInfoForClass(bool isEvent, Type owner, string xmlNamespace, string localName, string globalClassName, bool tryInternal, String& propName);
    internal EventInfo GetClrEventInfo(Type owner, string eventName);
    internal object GetDependencyObject(bool isEvent, Type owner, string xmlNamespace, string localName, Type& baseType, String& dynamicObjectName);
    internal DependencyProperty DependencyPropertyFromName(string localName, string xmlNamespace, Type& ownerType);
    internal PropertyInfo GetXmlLangProperty(string xmlNamespace, string localName);
    private PropertyInfo PropertyInfoFromName(string localName, Type ownerType, bool tryInternal, bool tryPublicOnly, Boolean& isInternal);
    internal RoutedEvent RoutedEventFromName(string localName, Type ownerType);
    internal static Type GetPropertyType(object propertyMember);
    internal static void GetPropertyType(object propertyMember, Type& propertyType, Boolean& propertyCanWrite);
    internal static string GetPropertyName(object propertyMember);
    internal static Type GetDeclaringType(object propertyMember);
    internal static Type GetTypeFromName(string typeName, DependencyObject element);
    internal Type GetTargetTypeAndMember(string valueParam, ParserContext context, bool isTypeExpected, String& memberName);
    internal Type GetDependencyPropertyOwnerAndName(string memberValue, ParserContext context, Type defaultTargetType, String& memberName);
    internal MemberInfo GetStaticMemberInfo(Type targetType, string memberName, bool fieldInfoOnly);
    private MemberInfo GetStaticMemberInfo(Type targetType, string memberName, bool fieldInfoOnly, bool tryInternal);
    internal TypeAndSerializer GetTypeOnly(string xmlNamespace, string localName);
    internal TypeAndSerializer GetTypeAndSerializer(string xmlNamespace, string localName, object dpOrPiorMi);
    private TypeAndSerializer CreateTypeAndSerializer(string xmlNamespace, string localName);
    private Type GetObjectType(NamespaceMapEntry namespaceMap, string localName, bool knownTypesOnly);
    internal int GetCustomBamlSerializerIdForType(Type objectType);
    internal Type GetXamlSerializerForType(Type objectType);
    internal static Type GetInternalTypeHelperTypeFromAssembly(ParserContext pc);
    private static InternalTypeHelper GetInternalTypeHelperFromAssembly(ParserContext pc);
    internal static object CreateInternalInstance(ParserContext pc, Type type);
    internal static object GetInternalPropertyValue(ParserContext pc, object rootElement, PropertyInfo pi, object target);
    internal static bool SetInternalPropertyValue(ParserContext pc, object rootElement, PropertyInfo pi, object target, object value);
    internal static Delegate CreateDelegate(ParserContext pc, Type delegateType, object target, string handler);
    internal static bool AddInternalEventHandler(ParserContext pc, object rootElement, EventInfo eventInfo, object target, Delegate handler);
    internal bool IsLocalAssembly(string namespaceUri);
    internal Type GetTypeFromBaseString(string typeString, ParserContext context, bool throwOnError);
    private TypeInformationCacheData GetCachedInformationForType(Type type);
    private Type GetCachedBaseType(Type t);
    internal static string ProcessNameString(ParserContext parserContext, String& nameString);
    internal static DependencyProperty ParsePropertyName(ParserContext parserContext, string propertyName, Type& ownerType);
    internal static RoutedEvent ParseEventName(ParserContext parserContext, string eventName, Type ownerType);
    internal object CreateInstance(Type t);
    internal bool IsXmlNamespaceKnown(string xmlNamespace, String& newXmlNamespace);
    internal void SetUriToAssemblyNameMapping(string xmlNamespace, Int16[] assemblyIds);
    internal NamespaceMapEntry[] GetNamespaceMapEntries(string xmlNamespace);
    internal string GetXmlNamespace(string clrNamespaceFullName, string assemblyFullName);
    private string GetCachedNamespace(Type t);
    internal static List`1<ClrNamespaceAssemblyPair> GetClrNamespacePairFromCache(string namespaceUri);
    internal Type GetTypeConverterType(Type type);
    internal TypeConverter GetTypeConverter(Type type);
    internal Type GetPropertyConverterType(Type propType, object dpOrPiOrMi);
    internal TypeConverter GetPropertyConverter(Type propType, object dpOrPiOrMi);
    internal object GetDictionaryKey(string keyString, ParserContext context);
    internal ConstructorData GetConstructors(Type type);
    internal bool GetCachedTrimSurroundingWhitespace(Type t);
    private bool GetTrimSurroundingWhitespace(Type type);
    private void ThrowException(string id);
    internal void ThrowException(string id, string parameter);
    private void ThrowException(string id, string parameter1, string parameter2);
    private void ThrowException(string id, string parameter1, string parameter2, string parameter3);
    internal void ThrowExceptionWithLine(string message, Exception innerException);
    internal HybridDictionary get_PITable();
    internal BamlMapTable get_MapTable();
    internal void set_MapTable(BamlMapTable value);
    internal void set_LineNumber(int value);
    internal void set_LinePosition(int value);
    internal Hashtable get_NamespaceMapHashList();
    internal XamlSchemaContext get_SchemaContext();
}
internal class System.Windows.Markup.XamlUnknownAttributeNode : XamlAttributeNode {
    private string _xmlNamespace;
    private string _name;
    private BamlAttributeUsage _attributeUsage;
    internal string XmlNamespace { get; }
    internal string Name { get; }
    internal XamlUnknownAttributeNode(int lineNumber, int linePosition, int depth, string xmlNamespace, string name, string value, BamlAttributeUsage attributeUsage);
    internal string get_XmlNamespace();
    internal string get_Name();
}
internal class System.Windows.Markup.XamlUnknownTagEndNode : XamlNode {
    private string _localName;
    private string _xmlNamespace;
    internal XamlUnknownTagEndNode(int lineNumber, int linePosition, int depth, string localName, string xmlNamespace);
}
internal class System.Windows.Markup.XamlUnknownTagStartNode : XamlAttributeNode {
    private string _xmlNamespace;
    internal string XmlNamespace { get; }
    internal XamlUnknownTagStartNode(int lineNumber, int linePosition, int depth, string xmlNamespace, string value);
    internal string get_XmlNamespace();
}
internal class System.Windows.Markup.XamlVector3DCollectionSerializer : XamlSerializer {
    public virtual bool ConvertStringToCustomBinary(BinaryWriter writer, string stringValue);
    public virtual object ConvertCustomBinaryToObject(BinaryReader reader);
    public static object StaticConvertCustomBinaryToObject(BinaryReader reader);
}
public static class System.Windows.Markup.XamlWriter : object {
    public static string Save(object obj);
    public static void Save(object obj, TextWriter writer);
    public static void Save(object obj, Stream stream);
    public static void Save(object obj, XmlWriter xmlWriter);
    public static void Save(object obj, XamlDesignerSerializationManager manager);
}
public enum System.Windows.Markup.XamlWriterMode : Enum {
    public int value__;
    public static XamlWriterMode Expression;
    public static XamlWriterMode Value;
}
public enum System.Windows.Markup.XamlWriterState : Enum {
    public int value__;
    public static XamlWriterState Starting;
    public static XamlWriterState Finished;
}
[DebuggerDisplayAttribute("Xmlns:{_prefix)={_xmlNamespace}")]
internal class System.Windows.Markup.XamlXmlnsPropertyNode : XamlNode {
    private string _prefix;
    private string _xmlNamespace;
    internal string Prefix { get; }
    internal string XmlNamespace { get; }
    internal XamlXmlnsPropertyNode(int lineNumber, int linePosition, int depth, string prefix, string xmlNamespace);
    internal string get_Prefix();
    internal string get_XmlNamespace();
}
public class System.Windows.Markup.XmlAttributeProperties : object {
    [LocalizabilityAttribute("17")]
[BrowsableAttribute("False")]
public static DependencyProperty XmlSpaceProperty;
    [BrowsableAttribute("False")]
public static DependencyProperty XmlnsDictionaryProperty;
    [BrowsableAttribute("False")]
public static DependencyProperty XmlnsDefinitionProperty;
    [BrowsableAttribute("False")]
public static DependencyProperty XmlNamespaceMapsProperty;
    internal static string XmlSpaceString;
    internal static string XmlLangString;
    internal static string XmlnsDefinitionString;
    private static MethodInfo _xmlSpaceSetter;
    internal static MethodInfo XmlSpaceSetter { get; }
    private static XmlAttributeProperties();
    [DesignerSerializationOptionsAttribute("1")]
[AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static string GetXmlSpace(DependencyObject dependencyObject);
    public static void SetXmlSpace(DependencyObject dependencyObject, string value);
    [DesignerSerializationVisibilityAttribute("0")]
[AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static XmlnsDictionary GetXmlnsDictionary(DependencyObject dependencyObject);
    public static void SetXmlnsDictionary(DependencyObject dependencyObject, XmlnsDictionary value);
    [DesignerSerializationVisibilityAttribute("0")]
[DesignerSerializationOptionsAttribute("1")]
[AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
public static string GetXmlnsDefinition(DependencyObject dependencyObject);
    public static void SetXmlnsDefinition(DependencyObject dependencyObject, string value);
    [AttachedPropertyBrowsableForTypeAttribute("System.Windows.DependencyObject")]
[DesignerSerializationVisibilityAttribute("0")]
public static string GetXmlNamespaceMaps(DependencyObject dependencyObject);
    public static void SetXmlNamespaceMaps(DependencyObject dependencyObject, string value);
    internal static MethodInfo get_XmlSpaceSetter();
}
internal class System.Windows.Markup.XmlnsCache : object {
    private HybridDictionary _cacheTable;
    private Dictionary`2<string, string> _compatTable;
    private Dictionary`2<string, string> _compatTableReverse;
    private HybridDictionary _uriToAssemblyNameTable;
    internal List`1<ClrNamespaceAssemblyPair> GetMappingArray(string xmlns);
    internal void SetUriToAssemblyNameMapping(string namespaceUri, String[] asmNameList);
    internal string GetNewXmlnamespace(string oldXmlnamespace);
    private Attribute[] GetAttributes(Assembly asm, Type attrType);
    private void GetNamespacesFromDefinitionAttr(Attribute attr, String& xmlns, String& clrns);
    private void GetNamespacesFromCompatAttr(Attribute attr, String& oldXmlns, String& newXmlns);
    private List`1<ClrNamespaceAssemblyPair> GetClrnsToAssemblyNameMappingList(Assembly[] asmList, string xmlnsRequested);
    private void ProcessXmlnsCompatibleWithAttributes(Assembly[] asmList);
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Markup.XmlnsDictionary : object {
    private NamespaceDeclaration[] _nsDeclarations;
    private int _lastDecl;
    private int _countDecl;
    private bool _sealed;
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    public string Item { get; public set; }
    public object Item { get; public set; }
    public ICollection Keys { get; }
    public ICollection Values { get; }
    public int Count { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public bool Sealed { get; }
    public XmlnsDictionary(XmlnsDictionary xmlnsDictionary);
    public sealed virtual void Add(object prefix, object xmlNamespace);
    public void Add(string prefix, string xmlNamespace);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(object key);
    public void Remove(string prefix);
    public sealed virtual void Remove(object prefix);
    public void CopyTo(DictionaryEntry[] array, int index);
    private sealed virtual override IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void CopyTo(Array array, int index);
    public sealed virtual string GetNamespace(string prefix);
    [IteratorStateMachineAttribute("System.Windows.Markup.XmlnsDictionary/<GetNamespacePrefixes>d__15")]
public sealed virtual IEnumerable`1<NamespaceDeclaration> GetNamespacePrefixes();
    protected IDictionaryEnumerator GetDictionaryEnumerator();
    protected IEnumerator GetEnumerator();
    public void Seal();
    public string LookupNamespace(string prefix);
    public string LookupPrefix(string xmlNamespace);
    public string DefaultNamespace();
    public void PushScope();
    public void PopScope();
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual bool get_IsReadOnly();
    public string get_Item(string prefix);
    public void set_Item(string prefix, string value);
    public sealed virtual object get_Item(object prefix);
    public sealed virtual void set_Item(object prefix, object value);
    public sealed virtual ICollection get_Keys();
    public sealed virtual ICollection get_Values();
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    public bool get_Sealed();
    internal void Unseal();
    private void Initialize();
    private void CheckSealed();
    private void AddNamespace(string prefix, string xmlNamespace);
    private void RemoveNamespace(string prefix, string xmlNamespace);
    private IDictionary GetNamespacesInScope(NamespaceScope scope);
    private bool HasNamespace(string prefix);
}
internal static class System.Windows.Markup.XmlParserDefaults : object {
    private static String[] _defaultAssemblies;
    private static NamespaceMapEntry[] _defaultNamespaceMapTable;
    internal static XamlTypeMapper DefaultMapper { get; }
    private static XmlParserDefaults();
    internal static XamlTypeMapper get_DefaultMapper();
    internal static String[] GetDefaultAssemblyNames();
    internal static NamespaceMapEntry[] GetDefaultNamespaceMaps();
}
public class System.Windows.Media.AdornerHitTestResult : PointHitTestResult {
    private Adorner _adorner;
    public Adorner Adorner { get; }
    internal AdornerHitTestResult(Visual visual, Point pt, Adorner adorner);
    public Adorner get_Adorner();
}
[RuntimeNamePropertyAttribute("Name")]
[ContentPropertyAttribute("Storyboard")]
public class System.Windows.Media.Animation.BeginStoryboard : TriggerAction {
    public static DependencyProperty StoryboardProperty;
    private HandoffBehavior _handoffBehavior;
    private string _name;
    [DefaultValueAttribute("")]
public Storyboard Storyboard { get; public set; }
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
public HandoffBehavior HandoffBehavior { get; public set; }
    [DefaultValueAttribute("")]
public string Name { get; public set; }
    private static BeginStoryboard();
    public Storyboard get_Storyboard();
    public void set_Storyboard(Storyboard value);
    public HandoffBehavior get_HandoffBehavior();
    public void set_HandoffBehavior(HandoffBehavior value);
    public string get_Name();
    public void set_Name(string value);
    private void ThrowIfSealed();
    internal virtual void Seal();
    internal sealed virtual void Invoke(FrameworkElement fe, FrameworkContentElement fce, Style targetStyle, FrameworkTemplate frameworkTemplate, long layer);
    internal sealed virtual void Invoke(FrameworkElement fe);
    private void Begin(DependencyObject targetObject, INameScope nameScope, long layer);
}
public abstract class System.Windows.Media.Animation.ControllableStoryboardAction : TriggerAction {
    private string _beginStoryboardName;
    [DefaultValueAttribute("")]
public string BeginStoryboardName { get; public set; }
    public string get_BeginStoryboardName();
    public void set_BeginStoryboardName(string value);
    internal sealed virtual void Invoke(FrameworkElement fe, FrameworkContentElement fce, Style targetStyle, FrameworkTemplate frameworkTemplate, long layer);
    internal sealed virtual void Invoke(FrameworkElement fe);
    internal virtual void Invoke(FrameworkElement containingFE, FrameworkContentElement containingFCE, Storyboard storyboard);
    private Storyboard GetStoryboard(FrameworkElement fe, FrameworkContentElement fce, INameScope nameScope);
}
public class System.Windows.Media.Animation.DiscreteThicknessKeyFrame : ThicknessKeyFrame {
    public DiscreteThicknessKeyFrame(Thickness value);
    public DiscreteThicknessKeyFrame(Thickness value, KeyTime keyTime);
    protected virtual Freezable CreateInstanceCore();
    protected virtual Thickness InterpolateValueCore(Thickness baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.EasingThicknessKeyFrame : ThicknessKeyFrame {
    public static DependencyProperty EasingFunctionProperty;
    public IEasingFunction EasingFunction { get; public set; }
    public EasingThicknessKeyFrame(Thickness value);
    public EasingThicknessKeyFrame(Thickness value, KeyTime keyTime);
    public EasingThicknessKeyFrame(Thickness value, KeyTime keyTime, IEasingFunction easingFunction);
    private static EasingThicknessKeyFrame();
    protected virtual Freezable CreateInstanceCore();
    protected virtual Thickness InterpolateValueCore(Thickness baseValue, double keyFrameProgress);
    public IEasingFunction get_EasingFunction();
    public void set_EasingFunction(IEasingFunction value);
}
public class System.Windows.Media.Animation.LinearThicknessKeyFrame : ThicknessKeyFrame {
    public LinearThicknessKeyFrame(Thickness value);
    public LinearThicknessKeyFrame(Thickness value, KeyTime keyTime);
    protected virtual Freezable CreateInstanceCore();
    protected virtual Thickness InterpolateValueCore(Thickness baseValue, double keyFrameProgress);
}
public class System.Windows.Media.Animation.PauseStoryboard : ControllableStoryboardAction {
    internal virtual void Invoke(FrameworkElement containingFE, FrameworkContentElement containingFCE, Storyboard storyboard);
}
public class System.Windows.Media.Animation.RemoveStoryboard : ControllableStoryboardAction {
    internal virtual void Invoke(FrameworkElement containingFE, FrameworkContentElement containingFCE, Storyboard storyboard);
}
public class System.Windows.Media.Animation.ResumeStoryboard : ControllableStoryboardAction {
    internal virtual void Invoke(FrameworkElement containingFE, FrameworkContentElement containingFCE, Storyboard storyboard);
}
public class System.Windows.Media.Animation.SeekStoryboard : ControllableStoryboardAction {
    private TimeSpan _offset;
    private TimeSeekOrigin _origin;
    public TimeSpan Offset { get; public set; }
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
public TimeSeekOrigin Origin { get; public set; }
    public TimeSpan get_Offset();
    public void set_Offset(TimeSpan value);
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeOffset();
    public TimeSeekOrigin get_Origin();
    public void set_Origin(TimeSeekOrigin value);
    internal virtual void Invoke(FrameworkElement containingFE, FrameworkContentElement containingFCE, Storyboard storyboard);
}
public class System.Windows.Media.Animation.SetStoryboardSpeedRatio : ControllableStoryboardAction {
    private double _speedRatio;
    [DefaultValueAttribute("1")]
public double SpeedRatio { get; public set; }
    public double get_SpeedRatio();
    public void set_SpeedRatio(double value);
    internal virtual void Invoke(FrameworkElement containingFE, FrameworkContentElement containingFCE, Storyboard storyboard);
}
public class System.Windows.Media.Animation.SkipStoryboardToFill : ControllableStoryboardAction {
    internal virtual void Invoke(FrameworkElement containingFE, FrameworkContentElement containingFCE, Storyboard storyboard);
}
public class System.Windows.Media.Animation.SplineThicknessKeyFrame : ThicknessKeyFrame {
    public static DependencyProperty KeySplineProperty;
    public KeySpline KeySpline { get; public set; }
    public SplineThicknessKeyFrame(Thickness value);
    public SplineThicknessKeyFrame(Thickness value, KeyTime keyTime);
    public SplineThicknessKeyFrame(Thickness value, KeyTime keyTime, KeySpline keySpline);
    private static SplineThicknessKeyFrame();
    protected virtual Freezable CreateInstanceCore();
    protected virtual Thickness InterpolateValueCore(Thickness baseValue, double keyFrameProgress);
    public KeySpline get_KeySpline();
    public void set_KeySpline(KeySpline value);
}
public class System.Windows.Media.Animation.StopStoryboard : ControllableStoryboardAction {
    internal virtual void Invoke(FrameworkElement containingFE, FrameworkContentElement containingFCE, Storyboard storyboard);
}
public class System.Windows.Media.Animation.Storyboard : ParallelTimeline {
    public static DependencyProperty TargetProperty;
    public static DependencyProperty TargetNameProperty;
    public static DependencyProperty TargetPropertyProperty;
    private static UncommonField`1<HybridDictionary> StoryboardClockTreesField;
    private static UncommonField`1<FrugalMap> ComplexPathCloneField;
    private static Storyboard();
    protected virtual Freezable CreateInstanceCore();
    public Storyboard Clone();
    public static void SetTarget(DependencyObject element, DependencyObject value);
    [DesignerSerializationVisibilityAttribute("0")]
public static DependencyObject GetTarget(DependencyObject element);
    private static bool TargetFreezeValueCallback(DependencyObject d, DependencyProperty dp, EntryIndex entryIndex, PropertyMetadata metadata, bool isChecking);
    public static void SetTargetName(DependencyObject element, string name);
    public static string GetTargetName(DependencyObject element);
    public static void SetTargetProperty(DependencyObject element, PropertyPath path);
    public static PropertyPath GetTargetProperty(DependencyObject element);
    internal static DependencyObject ResolveTargetName(string targetName, INameScope nameScope, DependencyObject element);
    internal static BeginStoryboard ResolveBeginStoryboardName(string targetName, INameScope nameScope, FrameworkElement fe, FrameworkContentElement fce);
    private void ClockTreeWalkRecursive(Clock currentClock, DependencyObject containingObject, INameScope nameScope, DependencyObject parentObject, string parentObjectName, PropertyPath parentPropertyPath, HandoffBehavior handoffBehavior, HybridDictionary clockMappings, long layer);
    private static void ApplyMediaClock(INameScope nameScope, DependencyObject containingObject, DependencyObject currentObject, string currentObjectName, MediaClock mediaClock);
    private static void UpdateMappings(HybridDictionary clockMappings, ObjectPropertyPair mappingKey, AnimationClock animationClock);
    private static void ApplyAnimationClocks(HybridDictionary clockMappings, HandoffBehavior handoffBehavior, long layer);
    internal static void VerifyPathIsAnimatable(PropertyPath path);
    private static string AccessorName(PropertyPath path, int index);
    private static void VerifyAnimationIsValid(DependencyProperty targetProperty, AnimationClock animationClock);
    private void ProcessComplexPath(HybridDictionary clockMappings, DependencyObject targetObject, PropertyPath path, AnimationClock animationClock, HandoffBehavior handoffBehavior, long layer);
    private bool PropertyCloningRequired(object targetPropertyValue);
    private void VerifyComplexPathSupport(DependencyObject targetObject);
    internal static void GetComplexPathValue(DependencyObject targetObject, DependencyProperty targetProperty, EffectiveValueEntry& entry, PropertyMetadata metadata);
    private static void CloneEffectiveValue(EffectiveValueEntry& entry, CloneCacheEntry cacheEntry);
    public void Begin(FrameworkElement containingObject);
    public void Begin(FrameworkElement containingObject, HandoffBehavior handoffBehavior);
    public void Begin(FrameworkElement containingObject, bool isControllable);
    public void Begin(FrameworkElement containingObject, HandoffBehavior handoffBehavior, bool isControllable);
    public void Begin(FrameworkElement containingObject, FrameworkTemplate frameworkTemplate);
    public void Begin(FrameworkElement containingObject, FrameworkTemplate frameworkTemplate, HandoffBehavior handoffBehavior);
    public void Begin(FrameworkElement containingObject, FrameworkTemplate frameworkTemplate, bool isControllable);
    public void Begin(FrameworkElement containingObject, FrameworkTemplate frameworkTemplate, HandoffBehavior handoffBehavior, bool isControllable);
    public void Begin(FrameworkContentElement containingObject);
    public void Begin(FrameworkContentElement containingObject, HandoffBehavior handoffBehavior);
    public void Begin(FrameworkContentElement containingObject, bool isControllable);
    public void Begin(FrameworkContentElement containingObject, HandoffBehavior handoffBehavior, bool isControllable);
    public void Begin();
    internal void BeginCommon(DependencyObject containingObject, INameScope nameScope, HandoffBehavior handoffBehavior, bool isControllable, long layer);
    public Nullable`1<double> GetCurrentGlobalSpeed(FrameworkElement containingObject);
    public Nullable`1<double> GetCurrentGlobalSpeed(FrameworkContentElement containingObject);
    public double GetCurrentGlobalSpeed();
    private Nullable`1<double> GetCurrentGlobalSpeedImpl(DependencyObject containingObject);
    public Nullable`1<int> GetCurrentIteration(FrameworkElement containingObject);
    public Nullable`1<int> GetCurrentIteration(FrameworkContentElement containingObject);
    public int GetCurrentIteration();
    private Nullable`1<int> GetCurrentIterationImpl(DependencyObject containingObject);
    public Nullable`1<double> GetCurrentProgress(FrameworkElement containingObject);
    public Nullable`1<double> GetCurrentProgress(FrameworkContentElement containingObject);
    public double GetCurrentProgress();
    private Nullable`1<double> GetCurrentProgressImpl(DependencyObject containingObject);
    public ClockState GetCurrentState(FrameworkElement containingObject);
    public ClockState GetCurrentState(FrameworkContentElement containingObject);
    public ClockState GetCurrentState();
    private ClockState GetCurrentStateImpl(DependencyObject containingObject);
    public Nullable`1<TimeSpan> GetCurrentTime(FrameworkElement containingObject);
    public Nullable`1<TimeSpan> GetCurrentTime(FrameworkContentElement containingObject);
    public TimeSpan GetCurrentTime();
    private Nullable`1<TimeSpan> GetCurrentTimeImpl(DependencyObject containingObject);
    public bool GetIsPaused(FrameworkElement containingObject);
    public bool GetIsPaused(FrameworkContentElement containingObject);
    public bool GetIsPaused();
    private bool GetIsPausedImpl(DependencyObject containingObject);
    public void Pause(FrameworkElement containingObject);
    public void Pause(FrameworkContentElement containingObject);
    public void Pause();
    private void PauseImpl(DependencyObject containingObject);
    public void Remove(FrameworkElement containingObject);
    public void Remove(FrameworkContentElement containingObject);
    public void Remove();
    private void RemoveImpl(DependencyObject containingObject);
    public void Resume(FrameworkElement containingObject);
    public void Resume(FrameworkContentElement containingObject);
    public void Resume();
    private void ResumeImpl(DependencyObject containingObject);
    public void Seek(FrameworkElement containingObject, TimeSpan offset, TimeSeekOrigin origin);
    public void Seek(FrameworkContentElement containingObject, TimeSpan offset, TimeSeekOrigin origin);
    public void Seek(TimeSpan offset, TimeSeekOrigin origin);
    public void Seek(TimeSpan offset);
    private void SeekImpl(DependencyObject containingObject, TimeSpan offset, TimeSeekOrigin origin);
    public void SeekAlignedToLastTick(FrameworkElement containingObject, TimeSpan offset, TimeSeekOrigin origin);
    public void SeekAlignedToLastTick(FrameworkContentElement containingObject, TimeSpan offset, TimeSeekOrigin origin);
    public void SeekAlignedToLastTick(TimeSpan offset, TimeSeekOrigin origin);
    public void SeekAlignedToLastTick(TimeSpan offset);
    private void SeekAlignedToLastTickImpl(DependencyObject containingObject, TimeSpan offset, TimeSeekOrigin origin);
    public void SetSpeedRatio(FrameworkElement containingObject, double speedRatio);
    public void SetSpeedRatio(FrameworkContentElement containingObject, double speedRatio);
    public void SetSpeedRatio(double speedRatio);
    private void SetSpeedRatioImpl(DependencyObject containingObject, double speedRatio);
    public void SkipToFill(FrameworkElement containingObject);
    public void SkipToFill(FrameworkContentElement containingObject);
    public void SkipToFill();
    private void SkipToFillImpl(DependencyObject containingObject);
    public void Stop(FrameworkElement containingObject);
    public void Stop(FrameworkContentElement containingObject);
    public void Stop();
    private void StopImpl(DependencyObject containingObject);
    private Clock GetStoryboardClock(DependencyObject o);
    private Clock GetStoryboardClock(DependencyObject o, bool throwIfNull, InteractiveOperation operation);
    private void SetStoryboardClock(DependencyObject o, Clock clock);
    private static CloneCacheEntry GetComplexPathClone(DependencyObject o, DependencyProperty dp);
    private static void SetComplexPathClone(DependencyObject o, DependencyProperty dp, object source, object clone);
}
public class System.Windows.Media.Animation.ThicknessAnimation : ThicknessAnimationBase {
    private Thickness[] _keyValues;
    private AnimationType _animationType;
    private bool _isAnimationFunctionValid;
    public static DependencyProperty FromProperty;
    public static DependencyProperty ToProperty;
    public static DependencyProperty ByProperty;
    public static DependencyProperty EasingFunctionProperty;
    public Nullable`1<Thickness> From { get; public set; }
    public Nullable`1<Thickness> To { get; public set; }
    public Nullable`1<Thickness> By { get; public set; }
    public IEasingFunction EasingFunction { get; public set; }
    public bool IsAdditive { get; public set; }
    public bool IsCumulative { get; public set; }
    private static ThicknessAnimation();
    public ThicknessAnimation(Thickness toValue, Duration duration);
    public ThicknessAnimation(Thickness toValue, Duration duration, FillBehavior fillBehavior);
    public ThicknessAnimation(Thickness fromValue, Thickness toValue, Duration duration);
    public ThicknessAnimation(Thickness fromValue, Thickness toValue, Duration duration, FillBehavior fillBehavior);
    public ThicknessAnimation Clone();
    protected virtual Freezable CreateInstanceCore();
    protected virtual Thickness GetCurrentValueCore(Thickness defaultOriginValue, Thickness defaultDestinationValue, AnimationClock animationClock);
    private void ValidateAnimationFunction();
    private static void AnimationFunction_Changed(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static bool ValidateFromToOrByValue(object value);
    public Nullable`1<Thickness> get_From();
    public void set_From(Nullable`1<Thickness> value);
    public Nullable`1<Thickness> get_To();
    public void set_To(Nullable`1<Thickness> value);
    public Nullable`1<Thickness> get_By();
    public void set_By(Nullable`1<Thickness> value);
    public IEasingFunction get_EasingFunction();
    public void set_EasingFunction(IEasingFunction value);
    public bool get_IsAdditive();
    public void set_IsAdditive(bool value);
    public bool get_IsCumulative();
    public void set_IsCumulative(bool value);
}
public abstract class System.Windows.Media.Animation.ThicknessAnimationBase : AnimationTimeline {
    public Type TargetPropertyType { get; }
    public ThicknessAnimationBase Clone();
    public sealed virtual object GetCurrentValue(object defaultOriginValue, object defaultDestinationValue, AnimationClock animationClock);
    public sealed virtual Type get_TargetPropertyType();
    public Thickness GetCurrentValue(Thickness defaultOriginValue, Thickness defaultDestinationValue, AnimationClock animationClock);
    protected abstract virtual Thickness GetCurrentValueCore(Thickness defaultOriginValue, Thickness defaultDestinationValue, AnimationClock animationClock);
}
[ContentPropertyAttribute("KeyFrames")]
public class System.Windows.Media.Animation.ThicknessAnimationUsingKeyFrames : ThicknessAnimationBase {
    private ThicknessKeyFrameCollection _keyFrames;
    private ResolvedKeyFrameEntry[] _sortedResolvedKeyFrames;
    private bool _areKeyTimesValid;
    private IList System.Windows.Media.Animation.IKeyFrameAnimation.KeyFrames { get; private set; }
    public ThicknessKeyFrameCollection KeyFrames { get; public set; }
    public bool IsAdditive { get; public set; }
    public bool IsCumulative { get; public set; }
    private TimeSpan LargestTimeSpanKeyTime { get; }
    public ThicknessAnimationUsingKeyFrames Clone();
    public ThicknessAnimationUsingKeyFrames CloneCurrentValue();
    protected virtual bool FreezeCore(bool isChecking);
    protected virtual void OnChanged();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable source);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable source);
    private void CopyCommon(ThicknessAnimationUsingKeyFrames sourceAnimation, bool isCurrentValueClone);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object child);
    [EditorBrowsableAttribute("2")]
protected virtual void AddChild(object child);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string childText);
    [EditorBrowsableAttribute("2")]
protected virtual void AddText(string childText);
    protected sealed virtual Thickness GetCurrentValueCore(Thickness defaultOriginValue, Thickness defaultDestinationValue, AnimationClock animationClock);
    protected sealed virtual Duration GetNaturalDurationCore(Clock clock);
    private sealed virtual override IList System.Windows.Media.Animation.IKeyFrameAnimation.get_KeyFrames();
    private sealed virtual override void System.Windows.Media.Animation.IKeyFrameAnimation.set_KeyFrames(IList value);
    public ThicknessKeyFrameCollection get_KeyFrames();
    public void set_KeyFrames(ThicknessKeyFrameCollection value);
    [EditorBrowsableAttribute("1")]
public bool ShouldSerializeKeyFrames();
    public bool get_IsAdditive();
    public void set_IsAdditive(bool value);
    public bool get_IsCumulative();
    public void set_IsCumulative(bool value);
    private Thickness GetResolvedKeyFrameValue(int resolvedKeyFrameIndex);
    private ThicknessKeyFrame GetResolvedKeyFrame(int resolvedKeyFrameIndex);
    private TimeSpan get_LargestTimeSpanKeyTime();
    private void ResolveKeyTimes();
    private void ResolvePacedKeyTimes();
}
public abstract class System.Windows.Media.Animation.ThicknessKeyFrame : Freezable {
    public static DependencyProperty KeyTimeProperty;
    public static DependencyProperty ValueProperty;
    public KeyTime KeyTime { get; public set; }
    private object System.Windows.Media.Animation.IKeyFrame.Value { get; private set; }
    public Thickness Value { get; public set; }
    protected ThicknessKeyFrame(Thickness value);
    protected ThicknessKeyFrame(Thickness value, KeyTime keyTime);
    private static ThicknessKeyFrame();
    public sealed virtual KeyTime get_KeyTime();
    public sealed virtual void set_KeyTime(KeyTime value);
    private sealed virtual override object System.Windows.Media.Animation.IKeyFrame.get_Value();
    private sealed virtual override void System.Windows.Media.Animation.IKeyFrame.set_Value(object value);
    public Thickness get_Value();
    public void set_Value(Thickness value);
    public Thickness InterpolateValue(Thickness baseValue, double keyFrameProgress);
    protected abstract virtual Thickness InterpolateValueCore(Thickness baseValue, double keyFrameProgress);
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Media.Animation.ThicknessKeyFrameCollection : Freezable {
    private List`1<ThicknessKeyFrame> _keyFrames;
    private static ThicknessKeyFrameCollection s_emptyCollection;
    public static ThicknessKeyFrameCollection Empty { get; }
    public int Count { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    private object System.Collections.IList.Item { get; private set; }
    public ThicknessKeyFrame Item { get; public set; }
    public static ThicknessKeyFrameCollection get_Empty();
    public ThicknessKeyFrameCollection Clone();
    protected virtual Freezable CreateInstanceCore();
    protected virtual void CloneCore(Freezable sourceFreezable);
    protected virtual void CloneCurrentValueCore(Freezable sourceFreezable);
    protected virtual void GetAsFrozenCore(Freezable sourceFreezable);
    protected virtual void GetCurrentValueAsFrozenCore(Freezable sourceFreezable);
    protected virtual bool FreezeCore(bool isChecking);
    public sealed virtual IEnumerator GetEnumerator();
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public void CopyTo(ThicknessKeyFrame[] array, int index);
    private sealed virtual override int System.Collections.IList.Add(object keyFrame);
    public int Add(ThicknessKeyFrame keyFrame);
    public sealed virtual void Clear();
    private sealed virtual override bool System.Collections.IList.Contains(object keyFrame);
    public bool Contains(ThicknessKeyFrame keyFrame);
    private sealed virtual override int System.Collections.IList.IndexOf(object keyFrame);
    public int IndexOf(ThicknessKeyFrame keyFrame);
    private sealed virtual override void System.Collections.IList.Insert(int index, object keyFrame);
    public void Insert(int index, ThicknessKeyFrame keyFrame);
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual bool get_IsReadOnly();
    private sealed virtual override void System.Collections.IList.Remove(object keyFrame);
    public void Remove(ThicknessKeyFrame keyFrame);
    public sealed virtual void RemoveAt(int index);
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public ThicknessKeyFrame get_Item(int index);
    public void set_Item(int index, ThicknessKeyFrame value);
}
public static class System.Windows.Media.TextOptions : object {
    public static DependencyProperty TextFormattingModeProperty;
    public static DependencyProperty TextRenderingModeProperty;
    public static DependencyProperty TextHintingModeProperty;
    private static TextOptions();
    internal static bool IsTextFormattingModeValid(object valueObject);
    public static void SetTextFormattingMode(DependencyObject element, TextFormattingMode value);
    public static TextFormattingMode GetTextFormattingMode(DependencyObject element);
    public static void SetTextRenderingMode(DependencyObject element, TextRenderingMode value);
    public static TextRenderingMode GetTextRenderingMode(DependencyObject element);
    public static void SetTextHintingMode(DependencyObject element, TextHintingMode value);
    public static TextHintingMode GetTextHintingMode(DependencyObject element);
}
public class System.Windows.MediaScriptCommandRoutedEventArgs : RoutedEventArgs {
    private string _parameterType;
    private string _parameterValue;
    public string ParameterType { get; }
    public string ParameterValue { get; }
    internal MediaScriptCommandRoutedEventArgs(RoutedEvent routedEvent, object sender, string parameterType, string parameterValue);
    public string get_ParameterType();
    public string get_ParameterValue();
}
public class System.Windows.MessageBox : object {
    private static int IDOK;
    private static int IDCANCEL;
    private static int IDABORT;
    private static int IDRETRY;
    private static int IDIGNORE;
    private static int IDYES;
    private static int IDNO;
    private static int DEFAULT_BUTTON1;
    private static int DEFAULT_BUTTON2;
    private static int DEFAULT_BUTTON3;
    private static MessageBoxResult Win32ToMessageBoxResult(int value);
    public static MessageBoxResult Show(string messageBoxText, string caption, MessageBoxButton button, MessageBoxImage icon, MessageBoxResult defaultResult, MessageBoxOptions options);
    public static MessageBoxResult Show(string messageBoxText, string caption, MessageBoxButton button, MessageBoxImage icon, MessageBoxResult defaultResult);
    public static MessageBoxResult Show(string messageBoxText, string caption, MessageBoxButton button, MessageBoxImage icon);
    public static MessageBoxResult Show(string messageBoxText, string caption, MessageBoxButton button);
    public static MessageBoxResult Show(string messageBoxText, string caption);
    public static MessageBoxResult Show(string messageBoxText);
    public static MessageBoxResult Show(Window owner, string messageBoxText, string caption, MessageBoxButton button, MessageBoxImage icon, MessageBoxResult defaultResult, MessageBoxOptions options);
    public static MessageBoxResult Show(Window owner, string messageBoxText, string caption, MessageBoxButton button, MessageBoxImage icon, MessageBoxResult defaultResult);
    public static MessageBoxResult Show(Window owner, string messageBoxText, string caption, MessageBoxButton button, MessageBoxImage icon);
    public static MessageBoxResult Show(Window owner, string messageBoxText, string caption, MessageBoxButton button);
    public static MessageBoxResult Show(Window owner, string messageBoxText, string caption);
    public static MessageBoxResult Show(Window owner, string messageBoxText);
    private static int DefaultResultToButtonNumber(MessageBoxResult result, MessageBoxButton button);
    internal static MessageBoxResult ShowCore(IntPtr owner, string messageBoxText, string caption, MessageBoxButton button, MessageBoxImage icon, MessageBoxResult defaultResult, MessageBoxOptions options);
    private static bool IsValidMessageBoxButton(MessageBoxButton value);
    private static bool IsValidMessageBoxImage(MessageBoxImage value);
    private static bool IsValidMessageBoxResult(MessageBoxResult value);
    private static bool IsValidMessageBoxOptions(MessageBoxOptions value);
}
public enum System.Windows.MessageBoxButton : Enum {
    public int value__;
    public static MessageBoxButton OK;
    public static MessageBoxButton OKCancel;
    public static MessageBoxButton YesNoCancel;
    public static MessageBoxButton YesNo;
}
public enum System.Windows.MessageBoxImage : Enum {
    public int value__;
    public static MessageBoxImage None;
    public static MessageBoxImage Hand;
    public static MessageBoxImage Question;
    public static MessageBoxImage Exclamation;
    public static MessageBoxImage Asterisk;
    public static MessageBoxImage Stop;
    public static MessageBoxImage Error;
    public static MessageBoxImage Warning;
    public static MessageBoxImage Information;
}
[FlagsAttribute]
public enum System.Windows.MessageBoxOptions : Enum {
    public int value__;
    public static MessageBoxOptions None;
    public static MessageBoxOptions ServiceNotification;
    public static MessageBoxOptions DefaultDesktopOnly;
    public static MessageBoxOptions RightAlign;
    public static MessageBoxOptions RtlReading;
}
public enum System.Windows.MessageBoxResult : Enum {
    public int value__;
    public static MessageBoxResult None;
    public static MessageBoxResult OK;
    public static MessageBoxResult Cancel;
    public static MessageBoxResult Yes;
    public static MessageBoxResult No;
}
[ContentPropertyAttribute("Setters")]
public class System.Windows.MultiDataTrigger : TriggerBase {
    private ConditionCollection _conditions;
    private SetterBaseCollection _setters;
    [DesignerSerializationVisibilityAttribute("2")]
public ConditionCollection Conditions { get; }
    [DesignerSerializationVisibilityAttribute("2")]
public SetterBaseCollection Setters { get; }
    public ConditionCollection get_Conditions();
    public SetterBaseCollection get_Setters();
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object value);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string text);
    internal virtual void Seal();
    internal virtual bool GetCurrentState(DependencyObject container, UncommonField`1<HybridDictionary[]> dataField);
}
[ContentPropertyAttribute("Setters")]
public class System.Windows.MultiTrigger : TriggerBase {
    private ConditionCollection _conditions;
    private SetterBaseCollection _setters;
    [DesignerSerializationVisibilityAttribute("2")]
public ConditionCollection Conditions { get; }
    [DesignerSerializationVisibilityAttribute("2")]
public SetterBaseCollection Setters { get; }
    public ConditionCollection get_Conditions();
    public SetterBaseCollection get_Setters();
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object value);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string text);
    internal virtual void Seal();
    internal virtual bool GetCurrentState(DependencyObject container, UncommonField`1<HybridDictionary[]> dataField);
}
internal class System.Windows.Navigation.BPReadyEventArgs : CancelEventArgs {
    private object _content;
    private Uri _uri;
    internal object Content { get; }
    internal Uri Uri { get; }
    internal BPReadyEventArgs(object content, Uri uri);
    internal object get_Content();
    internal Uri get_Uri();
}
internal class System.Windows.Navigation.BPReadyEventHandler : MulticastDelegate {
    public BPReadyEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, BPReadyEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, BPReadyEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public abstract class System.Windows.Navigation.CustomContentState : object {
    public string JournalEntryName { get; }
    public virtual string get_JournalEntryName();
    public abstract virtual void Replay(NavigationService navigationService, NavigationMode mode);
}
internal class System.Windows.Navigation.DisposeTreeQueueItem : object {
    private object _root;
    internal DisposeTreeQueueItem(object node);
    internal object Dispatch(object o);
    internal void DisposeElement(object node);
}
internal class System.Windows.Navigation.EventToRaiseTypedEvent : MulticastDelegate {
    public EventToRaiseTypedEvent(object object, IntPtr method);
    public virtual void Invoke(PageFunctionBase sender, RaiseTypedEventArgs args);
    public virtual IAsyncResult BeginInvoke(PageFunctionBase sender, RaiseTypedEventArgs args, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class System.Windows.Navigation.FinishEventHandler : MulticastDelegate {
    public FinishEventHandler(object object, IntPtr method);
    public virtual void Invoke(PageFunctionBase sender, object ReturnEventArgs);
    public virtual IAsyncResult BeginInvoke(PageFunctionBase sender, object ReturnEventArgs, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Windows.Navigation.FragmentNavigationEventArgs : EventArgs {
    private string _fragment;
    private bool _handled;
    private object _navigator;
    public string Fragment { get; }
    public bool Handled { get; public set; }
    public object Navigator { get; }
    internal FragmentNavigationEventArgs(string fragment, object Navigator);
    public string get_Fragment();
    public bool get_Handled();
    public void set_Handled(bool value);
    public object get_Navigator();
}
public class System.Windows.Navigation.FragmentNavigationEventHandler : MulticastDelegate {
    public FragmentNavigationEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, FragmentNavigationEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, FragmentNavigationEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public interface System.Windows.Navigation.IProvideCustomContentState {
    public abstract virtual CustomContentState GetContentState();
}
[DefaultMemberAttribute("Item")]
internal class System.Windows.Navigation.Journal : object {
    private EventHandler _backForwardStateChange;
    private JournalEntryFilter _filter;
    private JournalEntryBackStack _backStack;
    private JournalEntryForwardStack _forwardStack;
    private int _journalEntryId;
    private List`1<JournalEntry> _journalEntryList;
    private int _currentEntryIndex;
    private int _uncommittedCurrentIndex;
    private int _version;
    internal JournalEntry Item { get; }
    internal int TotalCount { get; }
    internal int CurrentIndex { get; }
    internal JournalEntry CurrentEntry { get; }
    internal bool HasUncommittedNavigation { get; }
    internal JournalEntryStack BackStack { get; }
    internal JournalEntryStack ForwardStack { get; }
    internal bool CanGoBack { get; }
    internal bool CanGoForward { get; }
    internal int Version { get; }
    internal JournalEntryFilter Filter { get; internal set; }
    private Journal(SerializationInfo info, StreamingContext context);
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
    internal JournalEntry get_Item(int index);
    internal int get_TotalCount();
    internal int get_CurrentIndex();
    internal JournalEntry get_CurrentEntry();
    internal bool get_HasUncommittedNavigation();
    internal JournalEntryStack get_BackStack();
    internal JournalEntryStack get_ForwardStack();
    internal bool get_CanGoBack();
    internal bool get_CanGoForward();
    internal int get_Version();
    internal JournalEntryFilter get_Filter();
    internal void set_Filter(JournalEntryFilter value);
    internal void add_BackForwardStateChange(EventHandler value);
    internal void remove_BackForwardStateChange(EventHandler value);
    internal JournalEntry RemoveBackEntry();
    internal void UpdateCurrentEntry(JournalEntry journalEntry);
    internal void RecordNewNavigation();
    internal bool ClearForwardStack();
    internal void CommitJournalNavigation(JournalEntry navigated);
    internal void AbortJournalNavigation();
    internal JournalEntry BeginBackNavigation();
    internal JournalEntry BeginForwardNavigation();
    internal NavigationMode GetNavigationMode(JournalEntry entry);
    internal void NavigateTo(JournalEntry target);
    internal int FindIndexForEntryWithId(int id);
    internal void PruneKeepAliveEntries();
    internal JournalEntry RemoveEntryInternal(int index);
    internal void RemoveEntries(Guid navSvcId);
    internal void UpdateView();
    internal JournalEntry GetGoBackEntry(Int32& index);
    internal JournalEntry GetGoBackEntry();
    internal void GetGoForwardEntryIndex(Int32& index);
    private bool ValidateIndexes();
    private void _Initialize();
    internal bool IsNavigable(JournalEntry entry);
}
public class System.Windows.Navigation.JournalEntry : DependencyObject {
    public static DependencyProperty NameProperty;
    public static DependencyProperty KeepAliveProperty;
    private int _id;
    private JournalEntryGroupState _jeGroupState;
    private Uri _source;
    private JournalEntryType _entryType;
    private CustomContentState _customContentState;
    private CustomJournalStateInternal _rootViewerState;
    public Uri Source { get; public set; }
    public CustomContentState CustomContentState { get; internal set; }
    public string Name { get; public set; }
    internal JournalEntryGroupState JEGroupState { get; internal set; }
    internal int Id { get; internal set; }
    internal Guid NavigationServiceId { get; }
    internal JournalEntryType EntryType { get; internal set; }
    internal UInt32 ContentId { get; }
    internal CustomJournalStateInternal RootViewerState { get; internal set; }
    internal JournalEntry(JournalEntryGroupState jeGroupState, Uri uri);
    protected JournalEntry(SerializationInfo info, StreamingContext context);
    private static JournalEntry();
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public static string GetName(DependencyObject dependencyObject);
    public static void SetName(DependencyObject dependencyObject, string name);
    public static bool GetKeepAlive(DependencyObject dependencyObject);
    public static void SetKeepAlive(DependencyObject dependencyObject, bool keepAlive);
    public Uri get_Source();
    public void set_Source(Uri value);
    public CustomContentState get_CustomContentState();
    internal void set_CustomContentState(CustomContentState value);
    public string get_Name();
    public void set_Name(string value);
    internal virtual bool IsPageFunction();
    internal virtual bool IsAlive();
    internal virtual void SaveState(object contentObject);
    internal virtual void RestoreState(object contentObject);
    internal virtual bool Navigate(INavigator navigator, NavigationMode navMode);
    internal static string GetDisplayName(Uri uri, Uri siteOfOrigin);
    internal JournalEntryGroupState get_JEGroupState();
    internal void set_JEGroupState(JournalEntryGroupState value);
    internal int get_Id();
    internal void set_Id(int value);
    internal Guid get_NavigationServiceId();
    internal JournalEntryType get_EntryType();
    internal void set_EntryType(JournalEntryType value);
    internal bool IsNavigable();
    internal UInt32 get_ContentId();
    internal CustomJournalStateInternal get_RootViewerState();
    internal void set_RootViewerState(CustomJournalStateInternal value);
}
internal class System.Windows.Navigation.JournalEntryBackStack : JournalEntryStack {
    public JournalEntryBackStack(Journal journal);
    public virtual IEnumerator GetEnumerator();
}
internal class System.Windows.Navigation.JournalEntryFilter : MulticastDelegate {
    public JournalEntryFilter(object object, IntPtr method);
    public virtual bool Invoke(JournalEntry entry);
    public virtual IAsyncResult BeginInvoke(JournalEntry entry, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
internal class System.Windows.Navigation.JournalEntryForwardStack : JournalEntryStack {
    public JournalEntryForwardStack(Journal journal);
    public virtual IEnumerator GetEnumerator();
}
public class System.Windows.Navigation.JournalEntryListConverter : object {
    public sealed virtual object Convert(object value, Type targetType, object parameter, CultureInfo culture);
    public sealed virtual object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture);
}
public enum System.Windows.Navigation.JournalEntryPosition : Enum {
    public int value__;
    public static JournalEntryPosition Back;
    public static JournalEntryPosition Current;
    public static JournalEntryPosition Forward;
}
internal abstract class System.Windows.Navigation.JournalEntryStack : object {
    private LimitedJournalEntryStackEnumerable _ljese;
    protected JournalEntryFilter _filter;
    [CompilerGeneratedAttribute]
private NotifyCollectionChangedEventHandler CollectionChanged;
    protected Journal _journal;
    internal JournalEntryFilter Filter { get; internal set; }
    internal JournalEntryStack(Journal journal);
    internal void OnCollectionChanged();
    internal JournalEntryFilter get_Filter();
    internal void set_Filter(JournalEntryFilter value);
    internal IEnumerable GetLimitedJournalEntryStackEnumerable();
    [CompilerGeneratedAttribute]
public sealed virtual void add_CollectionChanged(NotifyCollectionChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_CollectionChanged(NotifyCollectionChangedEventHandler value);
    public abstract virtual IEnumerator GetEnumerator();
}
internal class System.Windows.Navigation.JournalEntryStackEnumerator : object {
    private Journal _journal;
    private int _start;
    private int _delta;
    private int _next;
    private JournalEntry _current;
    private JournalEntryFilter _filter;
    private int _version;
    public object Current { get; }
    public JournalEntryStackEnumerator(Journal journal, int start, int delta, JournalEntryFilter filter);
    public sealed virtual void Reset();
    public sealed virtual bool MoveNext();
    public sealed virtual object get_Current();
    protected void VerifyUnchanged();
}
public class System.Windows.Navigation.JournalEntryUnifiedViewConverter : object {
    public static DependencyProperty JournalEntryPositionProperty;
    private static JournalEntryUnifiedViewConverter();
    public static JournalEntryPosition GetJournalEntryPosition(DependencyObject element);
    public static void SetJournalEntryPosition(DependencyObject element, JournalEntryPosition position);
    public sealed virtual object Convert(Object[] values, Type targetType, object parameter, CultureInfo culture);
    public sealed virtual Object[] ConvertBack(object value, Type[] targetTypes, object parameter, CultureInfo culture);
}
public enum System.Windows.Navigation.JournalOwnership : Enum {
    public int value__;
    public static JournalOwnership Automatic;
    public static JournalOwnership OwnsJournal;
    public static JournalOwnership UsesParentJournal;
}
internal class System.Windows.Navigation.LimitedJournalEntryStackEnumerable : object {
    private static UInt32 DefaultMaxMenuEntries;
    [CompilerGeneratedAttribute]
private NotifyCollectionChangedEventHandler CollectionChanged;
    private IEnumerable _ieble;
    internal LimitedJournalEntryStackEnumerable(IEnumerable ieble);
    public sealed virtual IEnumerator GetEnumerator();
    internal void PropogateCollectionChanged(object sender, NotifyCollectionChangedEventArgs e);
    [CompilerGeneratedAttribute]
public sealed virtual void add_CollectionChanged(NotifyCollectionChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_CollectionChanged(NotifyCollectionChangedEventHandler value);
}
internal class System.Windows.Navigation.LimitedJournalEntryStackEnumerator : object {
    private UInt32 _itemsReturned;
    private UInt32 _viewLimit;
    private IEnumerator _ienum;
    public object Current { get; }
    internal LimitedJournalEntryStackEnumerator(IEnumerable ieble, UInt32 viewLimit);
    public sealed virtual void Reset();
    public sealed virtual bool MoveNext();
    public sealed virtual object get_Current();
}
public class System.Windows.Navigation.LoadCompletedEventHandler : MulticastDelegate {
    public LoadCompletedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, NavigationEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, NavigationEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Windows.Navigation.NavigatedEventHandler : MulticastDelegate {
    public NavigatedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, NavigationEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, NavigationEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class System.Windows.Navigation.NavigateInfo : object {
    private Uri _source;
    private NavigationMode _navigationMode;
    private JournalEntry _journalEntry;
    internal Uri Source { get; }
    internal NavigationMode NavigationMode { get; }
    internal JournalEntry JournalEntry { get; }
    internal bool IsConsistent { get; }
    internal NavigateInfo(Uri source);
    internal NavigateInfo(Uri source, NavigationMode navigationMode);
    internal NavigateInfo(Uri source, NavigationMode navigationMode, JournalEntry journalEntry);
    internal Uri get_Source();
    internal NavigationMode get_NavigationMode();
    internal JournalEntry get_JournalEntry();
    internal bool get_IsConsistent();
}
internal class System.Windows.Navigation.NavigateQueueItem : object {
    private Uri _source;
    private object _content;
    private object _navState;
    private NavigationService _nc;
    private NavigationMode _navigationMode;
    private DispatcherOperation _postedOp;
    internal Uri Source { get; }
    internal object NavState { get; }
    internal NavigateQueueItem(Uri source, object content, NavigationMode mode, object navState, NavigationService nc);
    internal void PostNavigation();
    internal void Stop();
    internal Uri get_Source();
    internal object get_NavState();
    private object Dispatch(object obj);
}
public class System.Windows.Navigation.NavigatingCancelEventArgs : CancelEventArgs {
    private Uri _uri;
    private object _content;
    private CustomContentState _targetContentState;
    private CustomContentState _contentStateToSave;
    private object _extraData;
    private NavigationMode _navigationMode;
    private WebRequest _webRequest;
    private bool _isNavInitiator;
    private object _navigator;
    public Uri Uri { get; }
    public object Content { get; }
    public CustomContentState TargetContentState { get; }
    public CustomContentState ContentStateToSave { get; public set; }
    public object ExtraData { get; }
    public NavigationMode NavigationMode { get; }
    public WebRequest WebRequest { get; }
    public bool IsNavigationInitiator { get; }
    public object Navigator { get; }
    internal NavigatingCancelEventArgs(Uri uri, object content, CustomContentState customContentState, object extraData, NavigationMode navigationMode, WebRequest request, object Navigator, bool isNavInitiator);
    public Uri get_Uri();
    public object get_Content();
    public CustomContentState get_TargetContentState();
    public void set_ContentStateToSave(CustomContentState value);
    public CustomContentState get_ContentStateToSave();
    public object get_ExtraData();
    public NavigationMode get_NavigationMode();
    public WebRequest get_WebRequest();
    public bool get_IsNavigationInitiator();
    public object get_Navigator();
}
public class System.Windows.Navigation.NavigatingCancelEventHandler : MulticastDelegate {
    public NavigatingCancelEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, NavigatingCancelEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, NavigatingCancelEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Windows.Navigation.NavigationEventArgs : EventArgs {
    private Uri _uri;
    private object _content;
    private object _extraData;
    private WebResponse _webResponse;
    private bool _isNavigationInitiator;
    private object _navigator;
    public Uri Uri { get; }
    public object Content { get; }
    public bool IsNavigationInitiator { get; }
    public object ExtraData { get; }
    public WebResponse WebResponse { get; }
    public object Navigator { get; }
    internal NavigationEventArgs(Uri uri, object content, object extraData, WebResponse response, object Navigator, bool isNavigationInitiator);
    public Uri get_Uri();
    public object get_Content();
    public bool get_IsNavigationInitiator();
    public object get_ExtraData();
    public WebResponse get_WebResponse();
    public object get_Navigator();
}
public class System.Windows.Navigation.NavigationFailedEventArgs : EventArgs {
    private Uri _uri;
    private object _extraData;
    private object _navigator;
    private WebRequest _request;
    private WebResponse _response;
    private Exception _exception;
    private bool _handled;
    public Uri Uri { get; }
    public object ExtraData { get; }
    public object Navigator { get; }
    public WebRequest WebRequest { get; }
    public WebResponse WebResponse { get; }
    public Exception Exception { get; }
    public bool Handled { get; public set; }
    internal NavigationFailedEventArgs(Uri uri, object extraData, object navigator, WebRequest request, WebResponse response, Exception e);
    public Uri get_Uri();
    public object get_ExtraData();
    public object get_Navigator();
    public WebRequest get_WebRequest();
    public WebResponse get_WebResponse();
    public Exception get_Exception();
    public bool get_Handled();
    public void set_Handled(bool value);
}
public class System.Windows.Navigation.NavigationFailedEventHandler : MulticastDelegate {
    public NavigationFailedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, NavigationFailedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, NavigationFailedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public enum System.Windows.Navigation.NavigationMode : Enum {
    public byte value__;
    public static NavigationMode New;
    public static NavigationMode Back;
    public static NavigationMode Forward;
    public static NavigationMode Refresh;
}
public class System.Windows.Navigation.NavigationProgressEventArgs : EventArgs {
    private Uri _uri;
    private long _bytesRead;
    private long _maxBytes;
    private object _navigator;
    public Uri Uri { get; }
    public long BytesRead { get; }
    public long MaxBytes { get; }
    public object Navigator { get; }
    internal NavigationProgressEventArgs(Uri uri, long bytesRead, long maxBytes, object Navigator);
    public Uri get_Uri();
    public long get_BytesRead();
    public long get_MaxBytes();
    public object get_Navigator();
}
public class System.Windows.Navigation.NavigationProgressEventHandler : MulticastDelegate {
    public NavigationProgressEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, NavigationProgressEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, NavigationProgressEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Windows.Navigation.NavigationService : object {
    internal static DependencyProperty NavigationServiceProperty;
    [CompilerGeneratedAttribute]
private NavigationFailedEventHandler NavigationFailed;
    private NavigatingCancelEventHandler _navigating;
    private NavigatedEventHandler _navigated;
    private NavigationProgressEventHandler _navigationProgress;
    private LoadCompletedEventHandler _loadCompleted;
    private FragmentNavigationEventHandler _fragmentNavigation;
    private NavigationStoppedEventHandler _stopped;
    [CompilerGeneratedAttribute]
private BPReadyEventHandler BPReady;
    [CompilerGeneratedAttribute]
private BPReadyEventHandler PreBPReady;
    private object _bp;
    private UInt32 _contentId;
    private Uri _currentSource;
    private Uri _currentCleanSource;
    private JournalEntryGroupState _journalEntryGroupState;
    private bool _doNotJournalCurrentContent;
    private bool _cancelContentRenderedHandling;
    private CustomContentState _customContentStateToSave;
    private CustomJournalStateInternal _rootViewerStateToSave;
    private WebRequest _request;
    private object _navState;
    private WebResponse _webResponse;
    private XamlReader _asyncObjectConverter;
    private bool _isNavInitiator;
    private bool _isNavInitiatorValid;
    private bool _allowWindowNavigation;
    private Guid _guidId;
    private INavigator _navigatorHost;
    private INavigatorImpl _navigatorHostImpl;
    private JournalNavigationScope _journalScope;
    private ArrayList _childNavigationServices;
    private NavigationService _parentNavigationService;
    private bool _disposed;
    private FinishEventHandler _finishHandler;
    private NavigationStatus _navStatus;
    private ArrayList _pendingNavigationList;
    private ArrayList _recursiveNavigateList;
    private NavigateQueueItem _navigateQueueItem;
    private long _bytesRead;
    private long _maxBytes;
    private Visual _oldRootVisual;
    private static int _noParentPage;
    private WebBrowser _webBrowser;
    public Uri Source { get; public set; }
    public Uri CurrentSource { get; }
    public object Content { get; public set; }
    public bool CanGoForward { get; }
    public bool CanGoBack { get; }
    internal Application Application { get; }
    private bool AllowWindowNavigation { get; internal set; }
    internal long BytesRead { get; internal set; }
    internal long MaxBytes { get; internal set; }
    internal UInt32 ContentId { get; }
    internal Guid GuidId { get; internal set; }
    internal NavigationService ParentNavigationService { get; }
    internal bool CanReloadFromUri { get; }
    internal ArrayList ChildNavigationServices { get; }
    private FinishEventHandler FinishHandler { get; }
    private bool IsTopLevelContainer { get; }
    private bool IsJournalLevelContainer { get; }
    private bool SandboxExternalContent { get; }
    internal INavigator INavigatorHost { get; internal set; }
    internal NavigationStatus NavStatus { get; internal set; }
    internal ArrayList PendingNavigationList { get; }
    internal WebBrowser WebBrowser { get; }
    internal bool IsDisposed { get; }
    private JournalNavigationScope JournalScope { get; }
    private bool IsNavigationInitiator { get; }
    internal NavigationService(INavigator nav);
    private static NavigationService();
    private void ResetPendingNavigationState(NavigationStatus newState);
    private void OnRequestNavigate(object sender, RequestNavigateEventArgs e);
    private static bool IsSameUri(Uri baseUri, Uri a, Uri b, bool withFragment);
    private void NavigateToFragmentOrCustomContentState(Uri uri, object navState);
    private bool NavigateToFragment(string elementId, bool scrollToTopOnEmptyFragment);
    private void ScrollContentToTop();
    private static void BringIntoView(DependencyObject elem);
    private JournalNavigationScope EnsureJournal();
    private bool IsConsistent(NavigateInfo navInfo);
    private bool IsJournalNavigation(NavigateInfo navInfo);
    private CustomJournalStateInternal GetRootViewerState(JournalReason journalReason);
    private bool RestoreRootViewerState(CustomJournalStateInternal rvs);
    internal static INavigatorBase FindTargetInApplication(string targetName);
    private static INavigatorBase FindTargetInWindowCollection(WindowCollection wc, string targetName);
    private static INavigatorBase FindTargetInNavigationWindow(NavigationWindow navigationWindow, string navigatorId);
    internal void InvalidateJournalNavigationScope();
    internal void OnParentNavigationServiceChanged();
    internal void AddChild(NavigationService ncChild);
    internal void RemoveChild(NavigationService ncChild);
    internal NavigationService FindTarget(Guid navigationServiceId);
    internal INavigatorBase FindTarget(string name);
    internal bool IsContentKeepAlive();
    private void SetBaseUri(DependencyObject dobj, Uri fullUri);
    private bool UnhookOldTree(object oldTree);
    private bool HookupNewTree(object newTree, NavigateInfo navInfo, Uri newUri);
    private bool OnBeforeSwitchContent(object newBP, NavigateInfo navInfo, Uri newUri);
    internal void VisualTreeAvailable(Visual v);
    private sealed virtual override void MS.Internal.AppModel.IContentContainer.OnContentReady(ContentType contentType, object bp, Uri bpu, object navState);
    private sealed virtual override void MS.Internal.AppModel.IContentContainer.OnNavigationProgress(Uri sourceUri, long bytesRead, long maxBytes);
    private sealed virtual override void MS.Internal.AppModel.IContentContainer.OnStreamClosed(Uri sourceUri);
    public static NavigationService GetNavigationService(DependencyObject dependencyObject);
    public Uri get_Source();
    public void set_Source(Uri value);
    public Uri get_CurrentSource();
    public object get_Content();
    public void set_Content(object value);
    public void AddBackEntry(CustomContentState state);
    public JournalEntry RemoveBackEntry();
    public bool Navigate(Uri source);
    public bool Navigate(object root);
    public bool Navigate(Uri source, object navigationState);
    public bool Navigate(Uri source, object navigationState, bool sandboxExternalContent);
    internal bool Navigate(Uri source, object navigationState, bool sandboxExternalContent, bool navigateOnSourceChanged);
    private void InformBrowserAboutStoppedNavigation();
    public bool Navigate(object root, object navigationState);
    public bool get_CanGoForward();
    public bool get_CanGoBack();
    public void GoForward();
    public void GoBack();
    public void StopLoading();
    private void DoStopLoading(bool clearRecursiveNavigations, bool fireEvents);
    public void Refresh();
    [CompilerGeneratedAttribute]
public void add_NavigationFailed(NavigationFailedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_NavigationFailed(NavigationFailedEventHandler value);
    public void add_Navigating(NavigatingCancelEventHandler value);
    public void remove_Navigating(NavigatingCancelEventHandler value);
    private bool FireNavigating(Uri source, object bp, object navState, WebRequest request);
    private bool HandleNavigating(Uri source, object content, object navState, WebRequest newRequest, bool navigateOnSourceChanged);
    private void CleanupAfterNavigationCancelled(NavigateQueueItem localNavigateQueueItem);
    public void add_Navigated(NavigatedEventHandler value);
    public void remove_Navigated(NavigatedEventHandler value);
    private void FireNavigated(object navState);
    private void HandleNavigated(object navState, bool navigatedToNewContent);
    public void add_NavigationProgress(NavigationProgressEventHandler value);
    public void remove_NavigationProgress(NavigationProgressEventHandler value);
    private void FireNavigationProgress(Uri source);
    public void add_LoadCompleted(LoadCompletedEventHandler value);
    public void remove_LoadCompleted(LoadCompletedEventHandler value);
    private void FireLoadCompleted(bool isNavInitiator, object navState);
    public void add_FragmentNavigation(FragmentNavigationEventHandler value);
    public void remove_FragmentNavigation(FragmentNavigationEventHandler value);
    private bool FireFragmentNavigation(string fragment);
    private void HandleLoadCompleted(object navState);
    public void add_NavigationStopped(NavigationStoppedEventHandler value);
    public void remove_NavigationStopped(NavigationStoppedEventHandler value);
    private void FireNavigationStopped(object navState);
    private void OnContentLoaded(object sender, RoutedEventArgs args);
    private void ContentRenderedHandler(object sender, EventArgs args);
    private void OnFirstContentLayout();
    internal void DoNavigate(Uri source, NavigationMode f, object navState);
    private bool FireNavigationFailed(NavigationFailedEventArgs e);
    private WebRequest CreateWebRequest(Uri resolvedDestinationUri, NavigateInfo navInfo);
    private void HandleWebResponseOnRightDispatcher(IAsyncResult ar);
    private void HandleWebResponse(IAsyncResult ar);
    private void GetObjectFromResponse(WebRequest request, WebResponse response, Uri destinationUri, object navState);
    private void DelegateToBrowser(bool isPack, Uri destinationUri);
    private void DrainResponseStreamForPartialCacheFileBug(Stream s);
    internal void DoNavigate(object bp, NavigationMode navFlags, object navState);
    private JournalEntry UpdateJournal(NavigationMode navigationMode, JournalReason journalReason, JournalEntry destinationJournalEntry);
    internal JournalEntry MakeJournalEntry(JournalReason journalReason);
    internal void RequestCustomContentStateOnAppShutdown();
    internal Application get_Application();
    private bool get_AllowWindowNavigation();
    internal void set_AllowWindowNavigation(bool value);
    internal long get_BytesRead();
    internal void set_BytesRead(long value);
    internal long get_MaxBytes();
    internal void set_MaxBytes(long value);
    internal UInt32 get_ContentId();
    internal Guid get_GuidId();
    internal void set_GuidId(Guid value);
    internal NavigationService get_ParentNavigationService();
    internal bool get_CanReloadFromUri();
    internal ArrayList get_ChildNavigationServices();
    private FinishEventHandler get_FinishHandler();
    private bool get_IsTopLevelContainer();
    private bool get_IsJournalLevelContainer();
    private bool get_SandboxExternalContent();
    internal INavigator get_INavigatorHost();
    internal void set_INavigatorHost(INavigator value);
    internal NavigationStatus get_NavStatus();
    internal void set_NavStatus(NavigationStatus value);
    internal ArrayList get_PendingNavigationList();
    internal WebBrowser get_WebBrowser();
    internal bool get_IsDisposed();
    internal void Dispose();
    private NavigationWindow FindNavigationWindow();
    internal static bool IsPageFunction(object content);
    private void SetupPageFunctionHandlers(object bp);
    private void HandlePageFunction(NavigateInfo navInfo);
    private void HandleFinish(PageFunctionBase endingPF, object ReturnEventArgs);
    private void FireChildPageFunctionReturnEvent(object parentElem, PageFunctionBase childPF, object ReturnEventArgs);
    private void DoRemoveFromJournal(PageFunctionBase finishingChildPageFunction, int parentEntryIndex);
    private void NavigateToParentPage(PageFunctionBase finishingChildPageFunction, PageFunctionBase parentPF, object returnEventArgs, int parentIndex);
    private bool IsValidRootElement(object bp);
    [CompilerGeneratedAttribute]
internal void add_BPReady(BPReadyEventHandler value);
    [CompilerGeneratedAttribute]
internal void remove_BPReady(BPReadyEventHandler value);
    [CompilerGeneratedAttribute]
internal void add_PreBPReady(BPReadyEventHandler value);
    [CompilerGeneratedAttribute]
internal void remove_PreBPReady(BPReadyEventHandler value);
    private JournalNavigationScope get_JournalScope();
    private bool get_IsNavigationInitiator();
}
public class System.Windows.Navigation.NavigationStoppedEventHandler : MulticastDelegate {
    public NavigationStoppedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, NavigationEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, NavigationEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public enum System.Windows.Navigation.NavigationUIVisibility : Enum {
    public int value__;
    public static NavigationUIVisibility Automatic;
    public static NavigationUIVisibility Visible;
    public static NavigationUIVisibility Hidden;
}
[ContentPropertyAttribute]
[TemplatePartAttribute]
public class System.Windows.Navigation.NavigationWindow : Window {
    public static DependencyProperty SandboxExternalContentProperty;
    public static DependencyProperty ShowsNavigationUIProperty;
    public static DependencyProperty BackStackProperty;
    public static DependencyProperty ForwardStackProperty;
    public static DependencyProperty CanGoBackProperty;
    public static DependencyProperty CanGoForwardProperty;
    public static DependencyProperty SourceProperty;
    private NavigationService _navigationService;
    private JournalNavigationScope _JNS;
    private bool _sourceUpdatedFromNavService;
    private bool _fFramelet;
    private static DependencyObjectType _dType;
    public bool SandboxExternalContent { get; public set; }
    private NavigationService MS.Internal.AppModel.IDownloader.Downloader { get; }
    private Uri System.Windows.Markup.IUriContext.BaseUri { get; private set; }
    public NavigationService NavigationService { get; }
    public IEnumerable BackStack { get; }
    public IEnumerable ForwardStack { get; }
    public bool ShowsNavigationUI { get; public set; }
    [DefaultValueAttribute("")]
public Uri Source { get; public set; }
    public Uri CurrentSource { get; }
    public bool CanGoForward { get; }
    public bool CanGoBack { get; }
    private NavigationService MS.Internal.AppModel.IJournalNavigationScopeHost.NavigationService { get; }
    internal Journal Journal { get; }
    internal JournalNavigationScope JournalNavigationScope { get; }
    private bool InAppShutdown { get; }
    internal int EffectiveValuesInitialSize { get; }
    internal DependencyObjectType DTypeThemeStyleKey { get; }
    private static NavigationWindow();
    internal NavigationWindow(bool inRbw);
    public bool get_SandboxExternalContent();
    public void set_SandboxExternalContent(bool value);
    private static void OnSandboxExternalContentPropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static object CoerceSandBoxExternalContentValue(DependencyObject d, object value);
    private void Initialize();
    private sealed virtual override NavigationService MS.Internal.AppModel.IDownloader.get_Downloader();
    public sealed virtual bool Navigate(Uri source);
    public sealed virtual bool Navigate(Uri source, object extraData);
    public sealed virtual bool Navigate(object content);
    public sealed virtual bool Navigate(object content, object extraData);
    private sealed virtual override JournalNavigationScope MS.Internal.AppModel.INavigator.GetJournal(bool create);
    public sealed virtual void GoForward();
    public sealed virtual void GoBack();
    public sealed virtual void StopLoading();
    public sealed virtual void Refresh();
    public sealed virtual void AddBackEntry(CustomContentState state);
    public sealed virtual JournalEntry RemoveBackEntry();
    private sealed virtual override Uri System.Windows.Markup.IUriContext.get_BaseUri();
    private sealed virtual override void System.Windows.Markup.IUriContext.set_BaseUri(Uri value);
    public virtual void OnApplyTemplate();
    [EditorBrowsableAttribute("1")]
public virtual bool ShouldSerializeContent();
    public NavigationService get_NavigationService();
    public sealed virtual IEnumerable get_BackStack();
    public sealed virtual IEnumerable get_ForwardStack();
    public bool get_ShowsNavigationUI();
    public void set_ShowsNavigationUI(bool value);
    private static void OnSourcePropertyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private sealed virtual override void MS.Internal.AppModel.INavigatorImpl.OnSourceUpdatedFromNavService(bool journalOrCancel);
    public sealed virtual Uri get_Source();
    public sealed virtual void set_Source(Uri value);
    public sealed virtual Uri get_CurrentSource();
    public sealed virtual bool get_CanGoForward();
    public sealed virtual bool get_CanGoBack();
    public sealed virtual void add_Navigating(NavigatingCancelEventHandler value);
    public sealed virtual void remove_Navigating(NavigatingCancelEventHandler value);
    public sealed virtual void add_NavigationProgress(NavigationProgressEventHandler value);
    public sealed virtual void remove_NavigationProgress(NavigationProgressEventHandler value);
    public sealed virtual void add_NavigationFailed(NavigationFailedEventHandler value);
    public sealed virtual void remove_NavigationFailed(NavigationFailedEventHandler value);
    public sealed virtual void add_Navigated(NavigatedEventHandler value);
    public sealed virtual void remove_Navigated(NavigatedEventHandler value);
    public sealed virtual void add_LoadCompleted(LoadCompletedEventHandler value);
    public sealed virtual void remove_LoadCompleted(LoadCompletedEventHandler value);
    public sealed virtual void add_NavigationStopped(NavigationStoppedEventHandler value);
    public sealed virtual void remove_NavigationStopped(NavigationStoppedEventHandler value);
    public sealed virtual void add_FragmentNavigation(FragmentNavigationEventHandler value);
    public sealed virtual void remove_FragmentNavigation(FragmentNavigationEventHandler value);
    protected virtual AutomationPeer OnCreateAutomationPeer();
    protected virtual void AddChild(object value);
    protected virtual void AddText(string text);
    protected virtual void OnClosed(EventArgs args);
    internal virtual void OnPreApplyTemplate();
    private sealed virtual override void MS.Internal.AppModel.IJournalNavigationScopeHost.VerifyContextAndObjectState();
    private sealed virtual override void MS.Internal.AppModel.IJournalNavigationScopeHost.OnJournalAvailable();
    private sealed virtual override bool MS.Internal.AppModel.IJournalNavigationScopeHost.GoBackOverride();
    private sealed virtual override bool MS.Internal.AppModel.IJournalNavigationScopeHost.GoForwardOverride();
    private sealed virtual override NavigationService MS.Internal.AppModel.IJournalNavigationScopeHost.get_NavigationService();
    private sealed virtual override Visual MS.Internal.AppModel.INavigatorImpl.FindRootViewer();
    internal Journal get_Journal();
    internal JournalNavigationScope get_JournalNavigationScope();
    private static object CoerceContent(DependencyObject d, object value);
    private void OnBPReady(object sender, BPReadyEventArgs e);
    private static void OnGoBack(object sender, ExecutedRoutedEventArgs args);
    private static void OnQueryGoBack(object sender, CanExecuteRoutedEventArgs e);
    private static void OnGoForward(object sender, ExecutedRoutedEventArgs e);
    private static void OnQueryGoForward(object sender, CanExecuteRoutedEventArgs e);
    private static void OnRefresh(object sender, ExecutedRoutedEventArgs e);
    private static void OnQueryRefresh(object sender, CanExecuteRoutedEventArgs e);
    private static void OnBrowseStop(object sender, ExecutedRoutedEventArgs e);
    private static void OnQueryBrowseStop(object sender, CanExecuteRoutedEventArgs e);
    private static void OnNavigateJournal(object sender, ExecutedRoutedEventArgs e);
    private bool get_InAppShutdown();
    internal virtual int get_EffectiveValuesInitialSize();
    internal virtual DependencyObjectType get_DTypeThemeStyleKey();
}
public class System.Windows.Navigation.PageFunction`1 : PageFunctionBase {
    protected virtual void OnReturn(ReturnEventArgs`1<T> e);
    internal void RaiseTypedReturnEvent(PageFunctionBase b, RaiseTypedEventArgs args);
    public void add_Return(ReturnEventHandler`1<T> value);
    public void remove_Return(ReturnEventHandler`1<T> value);
}
public abstract class System.Windows.Navigation.PageFunctionBase : Page {
    [CompilerGeneratedAttribute]
private EventToRaiseTypedEvent RaiseTypedEvent;
    private Guid _pageFunctionId;
    private Guid _parentPageFunctionId;
    private bool _fRemoveFromJournal;
    private bool _resume;
    private ReturnEventSaver _saverInfo;
    private FinishEventHandler _finish;
    private Delegate _returnHandler;
    public bool RemoveFromJournal { get; public set; }
    internal Guid PageFunctionId { get; internal set; }
    internal Guid ParentPageFunctionId { get; internal set; }
    internal Delegate _Return { get; }
    internal bool _Resume { get; internal set; }
    internal ReturnEventSaver _Saver { get; internal set; }
    internal FinishEventHandler FinishHandler { get; internal set; }
    public bool get_RemoveFromJournal();
    public void set_RemoveFromJournal(bool value);
    protected virtual void Start();
    internal void CallStart();
    internal void _OnReturnUnTyped(object o);
    internal void _AddEventHandler(Delegate d);
    internal void _RemoveEventHandler(Delegate d);
    internal void _DetachEvents();
    internal void _OnFinish(object returnEventArgs);
    internal Guid get_PageFunctionId();
    internal void set_PageFunctionId(Guid value);
    internal Guid get_ParentPageFunctionId();
    internal void set_ParentPageFunctionId(Guid value);
    internal Delegate get__Return();
    internal bool get__Resume();
    internal void set__Resume(bool value);
    internal ReturnEventSaver get__Saver();
    internal void set__Saver(ReturnEventSaver value);
    internal FinishEventHandler get_FinishHandler();
    internal void set_FinishHandler(FinishEventHandler value);
    [CompilerGeneratedAttribute]
internal void add_RaiseTypedEvent(EventToRaiseTypedEvent value);
    [CompilerGeneratedAttribute]
internal void remove_RaiseTypedEvent(EventToRaiseTypedEvent value);
}
internal class System.Windows.Navigation.PageFunctionReturnInfo : NavigateInfo {
    private object _returnEventArgs;
    private PageFunctionBase _finishingChildPageFunction;
    internal object ReturnEventArgs { get; }
    internal PageFunctionBase FinishingChildPageFunction { get; }
    internal PageFunctionReturnInfo(PageFunctionBase finishingChildPageFunction, Uri source, NavigationMode navigationMode, JournalEntry journalEntry, object returnEventArgs);
    internal object get_ReturnEventArgs();
    internal PageFunctionBase get_FinishingChildPageFunction();
}
internal class System.Windows.Navigation.RaiseTypedEventArgs : EventArgs {
    internal Delegate D;
    internal object O;
    internal RaiseTypedEventArgs(Delegate d, object o);
}
public class System.Windows.Navigation.RequestNavigateEventArgs : RoutedEventArgs {
    private Uri _uri;
    private string _target;
    public Uri Uri { get; }
    public string Target { get; }
    public RequestNavigateEventArgs(Uri uri, string target);
    public Uri get_Uri();
    public string get_Target();
    protected virtual void InvokeEventHandler(Delegate genericHandler, object genericTarget);
}
public class System.Windows.Navigation.RequestNavigateEventHandler : MulticastDelegate {
    public RequestNavigateEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, RequestNavigateEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, RequestNavigateEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class System.Windows.Navigation.RequestState : object {
    private WebRequest _request;
    private Uri _source;
    private object _navState;
    private Dispatcher _callbackDispatcher;
    internal WebRequest Request { get; }
    internal Uri Source { get; }
    internal object NavState { get; }
    internal Dispatcher CallbackDispatcher { get; }
    internal RequestState(WebRequest request, Uri source, object navState, Dispatcher callbackDispatcher);
    internal WebRequest get_Request();
    internal Uri get_Source();
    internal object get_NavState();
    internal Dispatcher get_CallbackDispatcher();
}
public class System.Windows.Navigation.ReturnEventArgs`1 : EventArgs {
    private T _result;
    public T Result { get; public set; }
    public ReturnEventArgs`1(T result);
    public T get_Result();
    public void set_Result(T value);
}
public class System.Windows.Navigation.ReturnEventHandler`1 : MulticastDelegate {
    public ReturnEventHandler`1(object object, IntPtr method);
    public virtual void Invoke(object sender, ReturnEventArgs`1<T> e);
    public virtual IAsyncResult BeginInvoke(object sender, ReturnEventArgs`1<T> e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class System.Windows.Navigation.UnifiedJournalEntryStackEnumerable : object {
    [CompilerGeneratedAttribute]
private NotifyCollectionChangedEventHandler CollectionChanged;
    private LimitedJournalEntryStackEnumerable _backStack;
    private LimitedJournalEntryStackEnumerable _forwardStack;
    private ArrayList _items;
    internal UnifiedJournalEntryStackEnumerable(LimitedJournalEntryStackEnumerable backStack, LimitedJournalEntryStackEnumerable forwardStack);
    public sealed virtual IEnumerator GetEnumerator();
    internal void StacksChanged(object sender, NotifyCollectionChangedEventArgs e);
    [CompilerGeneratedAttribute]
public sealed virtual void add_CollectionChanged(NotifyCollectionChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_CollectionChanged(NotifyCollectionChangedEventHandler value);
}
internal class System.Windows.NestedBamlLoadInfo : object {
    private Uri _BamlUri;
    private Stream _BamlStream;
    private bool _SkipJournaledProperties;
    internal Uri BamlUri { get; internal set; }
    internal Stream BamlStream { get; }
    internal bool SkipJournaledProperties { get; }
    internal NestedBamlLoadInfo(Uri uri, Stream stream, bool bSkipJournalProperty);
    internal Uri get_BamlUri();
    internal void set_BamlUri(Uri value);
    internal Stream get_BamlStream();
    internal bool get_SkipJournaledProperties();
}
public class System.Windows.NullableBoolConverter : NullableConverter {
    [ThreadStaticAttribute]
private static StandardValuesCollection _standardValues;
    public virtual bool GetStandardValuesSupported(ITypeDescriptorContext context);
    public virtual bool GetStandardValuesExclusive(ITypeDescriptorContext context);
    public virtual StandardValuesCollection GetStandardValues(ITypeDescriptorContext context);
}
public enum System.Windows.PowerLineStatus : Enum {
    public int value__;
    public static PowerLineStatus Offline;
    public static PowerLineStatus Online;
    public static PowerLineStatus Unknown;
}
[TypeConverterAttribute("System.Windows.PropertyPathConverter")]
public class System.Windows.PropertyPath : object {
    private static string SingleStepPath;
    private static Char[] s_comma;
    private string _path;
    private PathParameterCollection _parameters;
    private SourceValueInfo[] _arySVI;
    private string _lastError;
    private Object[] _earlyBoundPathParts;
    private PropertyPathWorker _singleWorker;
    public string Path { get; public set; }
    public Collection`1<object> PathParameters { get; }
    internal int Length { get; }
    internal PropertyPathStatus Status { get; }
    internal string LastError { get; }
    internal object LastItem { get; }
    internal object LastAccessor { get; }
    internal Object[] LastIndexerArguments { get; }
    internal bool StartsWithStaticProperty { get; }
    internal SourceValueInfo[] SVI { get; }
    private PropertyPathWorker SingleWorker { get; }
    public PropertyPath(string path, Object[] pathParameters);
    public PropertyPath(object parameter);
    internal PropertyPath(string path, ITypeDescriptorContext typeDescriptorContext);
    private static PropertyPath();
    public string get_Path();
    public void set_Path(string value);
    public Collection`1<object> get_PathParameters();
    internal int get_Length();
    internal PropertyPathStatus get_Status();
    internal string get_LastError();
    internal object get_LastItem();
    internal object get_LastAccessor();
    internal Object[] get_LastIndexerArguments();
    internal bool get_StartsWithStaticProperty();
    internal static bool IsStaticProperty(object accessor);
    internal static void DowncastAccessor(object accessor, DependencyProperty& dp, PropertyInfo& pi, PropertyDescriptor& pd, DynamicObjectAccessor& doa);
    internal IDisposable SetContext(object rootItem);
    internal object GetItem(int k);
    internal object GetAccessor(int k);
    internal Object[] GetIndexerArguments(int k);
    internal object GetValue();
    internal int ComputeUnresolvedAttachedPropertiesInPath();
    internal SourceValueInfo[] get_SVI();
    internal object ResolvePropertyName(int level, object item, Type ownerType, object context);
    internal IndexerParameterInfo[] ResolveIndexerParams(int level, object context);
    internal void ReplaceIndexerByProperty(int level, string name);
    private PropertyPathWorker get_SingleWorker();
    private void PrepareSourceValueInfo(ITypeDescriptorContext typeDescriptorContext);
    private void NormalizePath();
    private void SetPathParameterCollection(PathParameterCollection parameters);
    private void ParameterCollectionChanged(object sender, NotifyCollectionChangedEventArgs e);
    private void ResolvePathParts(ITypeDescriptorContext typeDescriptorContext);
    private object ResolvePropertyName(string name, object item, Type ownerType, object context, bool throwOnError);
    private PropertyInfo GetPropertyHelper(Type ownerType, string propertyName);
    private IndexerParameterInfo[] ResolveIndexerParams(FrugalObjectList`1<IndexerParamInfo> paramList, object context, bool throwOnError);
    private object GetTypedParamValue(string param, Type type, bool throwOnError);
    private Type GetTypeFromName(string name, object context);
    internal static bool IsPropertyReference(string name);
    internal static bool IsParameterIndex(string name, Int32& index);
    private static bool IsValidAccessor(object accessor);
    private static string GetPropertyName(object accessor);
}
public class System.Windows.PropertyPathConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext typeDescriptorContext, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext typeDescriptorContext, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext typeDescriptorContext, CultureInfo cultureInfo, object source);
    public virtual object ConvertTo(ITypeDescriptorContext typeDescriptorContext, CultureInfo cultureInfo, object value, Type destinationType);
}
internal enum System.Windows.PropertyPathStatus : Enum {
    public byte value__;
    public static PropertyPathStatus Inactive;
    public static PropertyPathStatus Active;
    public static PropertyPathStatus PathError;
    public static PropertyPathStatus AsyncRequestPending;
}
internal class System.Windows.PropertyValue : ValueType {
    internal PropertyValueType ValueType;
    internal TriggerCondition[] Conditions;
    internal string ChildName;
    internal DependencyProperty Property;
    internal object ValueInternal;
    internal object Value { get; }
    internal object get_Value();
}
internal enum System.Windows.PropertyValueType : Enum {
    public int value__;
    public static PropertyValueType Set;
    public static PropertyValueType Trigger;
    public static PropertyValueType PropertyTriggerResource;
    public static PropertyValueType DataTrigger;
    public static PropertyValueType DataTriggerResource;
    public static PropertyValueType TemplateBinding;
    public static PropertyValueType Resource;
}
internal class System.Windows.ReadOnlyFrameworkPropertyMetadata : FrameworkPropertyMetadata {
    private GetReadOnlyValueCallback _getValueCallback;
    internal GetReadOnlyValueCallback GetReadOnlyValueCallback { get; }
    public ReadOnlyFrameworkPropertyMetadata(object defaultValue, GetReadOnlyValueCallback getValueCallback);
    internal virtual GetReadOnlyValueCallback get_GetReadOnlyValueCallback();
}
public enum System.Windows.ReasonSessionEnding : Enum {
    public byte value__;
    public static ReasonSessionEnding Logoff;
    public static ReasonSessionEnding Shutdown;
}
public class System.Windows.RequestBringIntoViewEventArgs : RoutedEventArgs {
    private DependencyObject _target;
    private Rect _rcTarget;
    public DependencyObject TargetObject { get; }
    public Rect TargetRect { get; }
    internal RequestBringIntoViewEventArgs(DependencyObject target, Rect targetRect);
    public DependencyObject get_TargetObject();
    public Rect get_TargetRect();
    protected virtual void InvokeEventHandler(Delegate genericHandler, object genericTarget);
}
public class System.Windows.RequestBringIntoViewEventHandler : MulticastDelegate {
    public RequestBringIntoViewEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, RequestBringIntoViewEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, RequestBringIntoViewEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[LocalizabilityAttribute("0")]
public enum System.Windows.ResizeMode : Enum {
    public int value__;
    public static ResizeMode NoResize;
    public static ResizeMode CanMinimize;
    public static ResizeMode CanResize;
    public static ResizeMode CanResizeWithGrip;
}
[DefaultMemberAttribute("Item")]
[LocalizabilityAttribute("16")]
[AmbientAttribute]
[UsableDuringInitializationAttribute("True")]
public class System.Windows.ResourceDictionary : object {
    internal bool IsSourcedFromThemeDictionary;
    private FallbackState _fallbackState;
    private Hashtable _baseDictionary;
    private WeakReferenceList _ownerFEs;
    private WeakReferenceList _ownerFCEs;
    private WeakReferenceList _ownerApps;
    private WeakReferenceList _deferredResourceReferences;
    private ObservableCollection`1<ResourceDictionary> _mergedDictionaries;
    private Uri _source;
    private Uri _baseUri;
    private PrivateFlags _flags;
    private List`1<KeyRecord> _deferredLocationList;
    private Byte[] _buffer;
    private Stream _bamlStream;
    private long _startPosition;
    private int _contentSize;
    private object _rootElement;
    private int _numDefer;
    private WeakReference _inheritanceContext;
    private static DependencyObject DummyInheritanceContext;
    private XamlObjectIds _contextXamlObjectIds;
    private IXamlObjectWriterFactory _objectWriterFactory;
    private XamlObjectWriterSettings _objectWriterSettings;
    private Baml2006Reader _reader;
    public Collection`1<ResourceDictionary> MergedDictionaries { get; }
    [DesignerSerializationVisibilityAttribute("0")]
public Uri Source { get; public set; }
    private Uri System.Windows.Markup.IUriContext.BaseUri { get; private set; }
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; internal set; }
    [DefaultValueAttribute("False")]
public bool InvalidatesImplicitDataTemplateResources { get; public set; }
    public object Item { get; public set; }
    [DesignerSerializationVisibilityAttribute("0")]
public DeferrableContent DeferrableContent { get; public set; }
    public ICollection Keys { get; }
    public ICollection Values { get; }
    public int Count { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    internal WeakReferenceList FrameworkElementOwners { get; }
    internal WeakReferenceList FrameworkContentElementOwners { get; }
    internal WeakReferenceList ApplicationOwners { get; }
    internal WeakReferenceList DeferredResourceReferences { get; }
    private DependencyObject InheritanceContext { get; }
    private bool IsInitialized { get; private set; }
    private bool IsInitializePending { get; private set; }
    private bool IsThemeDictionary { get; private set; }
    internal bool HasImplicitStyles { get; internal set; }
    internal bool HasImplicitDataTemplates { get; internal set; }
    internal bool CanBeAccessedAcrossThreads { get; internal set; }
    private static ResourceDictionary();
    public void CopyTo(DictionaryEntry[] array, int arrayIndex);
    private void CopyToWithoutLock(DictionaryEntry[] array, int arrayIndex);
    public Collection`1<ResourceDictionary> get_MergedDictionaries();
    public Uri get_Source();
    public void set_Source(Uri value);
    public sealed virtual void RegisterName(string name, object scopedElement);
    public sealed virtual void UnregisterName(string name);
    public sealed virtual object FindName(string name);
    private sealed virtual override Uri System.Windows.Markup.IUriContext.get_BaseUri();
    private sealed virtual override void System.Windows.Markup.IUriContext.set_BaseUri(Uri value);
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual bool get_IsReadOnly();
    internal void set_IsReadOnly(bool value);
    public bool get_InvalidatesImplicitDataTemplateResources();
    public void set_InvalidatesImplicitDataTemplateResources(bool value);
    public sealed virtual object get_Item(object key);
    public sealed virtual void set_Item(object key, object value);
    public DeferrableContent get_DeferrableContent();
    public void set_DeferrableContent(DeferrableContent value);
    private void SetValueWithoutLock(object key, object value);
    internal object GetValue(object key, Boolean& canCache);
    private object GetValueWithoutLock(object key, Boolean& canCache);
    internal Type GetValueType(object key, Boolean& found);
    public sealed virtual ICollection get_Keys();
    public sealed virtual ICollection get_Values();
    public sealed virtual void Add(object key, object value);
    private void AddWithoutLock(object key, object value);
    public sealed virtual void Clear();
    private void ClearWithoutLock();
    public sealed virtual bool Contains(object key);
    private bool ContainsBamlObjectFactory(object key);
    private KeyRecord GetBamlObjectFactory(object key);
    public sealed virtual IDictionaryEnumerator GetEnumerator();
    public sealed virtual void Remove(object key);
    private void RemoveWithoutLock(object key);
    public sealed virtual int get_Count();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int arrayIndex);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void BeginInit();
    public sealed virtual void EndInit();
    private bool CanCache(KeyRecord keyRecord, object value);
    private void OnGettingValuePrivate(object key, Object& value, Boolean& canCache);
    protected virtual void OnGettingValue(object key, Object& value, Boolean& canCache);
    private void SetDeferrableContent(DeferrableContent deferrableContent);
    private object GetKeyValue(KeyRecord key, IServiceProvider serviceProvider);
    private object EvaluateMarkupExtensionNodeList(XamlReader reader, IServiceProvider serviceProvider);
    private object GetStaticResourceKeyValue(StaticResource staticResource, IServiceProvider serviceProvider);
    private void SetKeys(IList`1<KeyRecord> keyCollection, IServiceProvider serviceProvider);
    private void SetOptimizedStaticResources(IList`1<object> staticResources, IServiceProvider serviceProvider, StaticResourceExtension staticResourceWorker);
    private Type GetTypeOfFirstObject(KeyRecord keyRecord);
    private object CreateObject(KeyRecord key);
    internal object Lookup(object key, bool allowDeferredResourceReference, bool mustReturnDeferredResourceReference, bool canCacheAsThemeResource);
    internal void AddOwner(DispatcherObject owner);
    internal void RemoveOwner(DispatcherObject owner);
    internal bool ContainsOwner(DispatcherObject owner);
    private void TryInitialize();
    private void NotifyOwners(ResourcesChangeInfo info);
    internal object FetchResource(object resourceKey, bool allowDeferredResourceReference, bool mustReturnDeferredResourceReference, Boolean& canCache);
    private object FetchResource(object resourceKey, bool allowDeferredResourceReference, bool mustReturnDeferredResourceReference, bool canCacheAsThemeResource, Boolean& canCache);
    private void ValidateDeferredResourceReferences(object resourceKey);
    private void OnMergedDictionariesChanged(object sender, NotifyCollectionChangedEventArgs e);
    private void AddOwnerToAllMergedDictionaries(DispatcherObject owner);
    private void RemoveOwnerFromAllMergedDictionaries(DispatcherObject owner);
    private void PropagateParentOwners(ResourceDictionary mergedDictionary);
    internal void RemoveParentOwners(ResourceDictionary mergedDictionary);
    private bool ContainsCycle(ResourceDictionary origin);
    internal WeakReferenceList get_FrameworkElementOwners();
    internal WeakReferenceList get_FrameworkContentElementOwners();
    internal WeakReferenceList get_ApplicationOwners();
    internal WeakReferenceList get_DeferredResourceReferences();
    private void SealValues();
    private void SealValue(object value);
    private void AddInheritanceContext(DependencyObject inheritanceContext, object value);
    private void AddInheritanceContextToValues();
    private void RemoveInheritanceContext(object value);
    private void RemoveInheritanceContextFromValues();
    private void UpdateHasImplicitStyles(object key);
    private void UpdateHasImplicitDataTemplates(object key);
    private DependencyObject get_InheritanceContext();
    private bool get_IsInitialized();
    private void set_IsInitialized(bool value);
    private bool get_IsInitializePending();
    private void set_IsInitializePending(bool value);
    private bool get_IsThemeDictionary();
    private void set_IsThemeDictionary(bool value);
    internal bool get_HasImplicitStyles();
    internal void set_HasImplicitStyles(bool value);
    internal bool get_HasImplicitDataTemplates();
    internal void set_HasImplicitDataTemplates(bool value);
    internal bool get_CanBeAccessedAcrossThreads();
    internal void set_CanBeAccessedAcrossThreads(bool value);
    private void WritePrivateFlag(PrivateFlags bit, bool value);
    private bool ReadPrivateFlag(PrivateFlags bit);
    private void CloseReader();
    private void CopyDeferredContentFrom(ResourceDictionary loadedRD);
    private void MoveDeferredResourceReferencesFrom(ResourceDictionary loadedRD);
}
internal class System.Windows.ResourceDictionaryCollection : ObservableCollection`1<ResourceDictionary> {
    private ResourceDictionary _owner;
    internal ResourceDictionaryCollection(ResourceDictionary owner);
    protected virtual void ClearItems();
    protected virtual void InsertItem(int index, ResourceDictionary item);
    protected virtual void SetItem(int index, ResourceDictionary item);
}
public enum System.Windows.ResourceDictionaryLocation : Enum {
    public int value__;
    public static ResourceDictionaryLocation None;
    public static ResourceDictionaryLocation SourceAssembly;
    public static ResourceDictionaryLocation ExternalAssembly;
}
[MarkupExtensionReturnTypeAttribute("System.Windows.ResourceKey")]
public abstract class System.Windows.ResourceKey : MarkupExtension {
    public Assembly Assembly { get; }
    public abstract virtual Assembly get_Assembly();
    public virtual object ProvideValue(IServiceProvider serviceProvider);
}
[TypeConverterAttribute("System.Windows.Markup.ResourceReferenceExpressionConverter")]
internal class System.Windows.ResourceReferenceExpression : Expression {
    private object _resourceKey;
    private object _cachedResourceValue;
    private DependencyObject _mentorCache;
    private DependencyObject _targetObject;
    private DependencyProperty _targetProperty;
    private InternalState _state;
    private ResourceReferenceExpressionWeakContainer _weakContainerRRE;
    public object ResourceKey { get; }
    public ResourceReferenceExpression(object resourceKey);
    internal virtual DependencySource[] GetSources();
    internal virtual object GetValue(DependencyObject d, DependencyProperty dp);
    internal virtual Expression Copy(DependencyObject targetObject, DependencyProperty targetDP);
    internal object GetRawValue(DependencyObject d, Object& source, DependencyProperty dp);
    internal virtual bool SetValue(DependencyObject d, DependencyProperty dp, object value);
    internal virtual void OnAttach(DependencyObject d, DependencyProperty dp);
    internal virtual void OnDetach(DependencyObject d, DependencyProperty dp);
    public object get_ResourceKey();
    private void InvalidateCacheValue();
    private void InvalidateMentorCache();
    internal void InvalidateExpressionValue(object sender, EventArgs e);
    private void InvalidateTargetProperty(object sender, EventArgs e);
    private void InvalidateTargetSubProperty(object sender, EventArgs e);
    private void ListenForFreezableChanges(object resource);
    private void StopListeningForFreezableChanges(object resource);
    internal void OnDeferredResourceInflated(DeferredResourceReference deferredResourceReference);
    private bool ReadInternalState(InternalState reqFlag);
    private void WriteInternalState(InternalState reqFlag, bool set);
}
public class System.Windows.ResourceReferenceKeyNotFoundException : InvalidOperationException {
    private object _resourceKey;
    public object Key { get; }
    public ResourceReferenceKeyNotFoundException(string message, object resourceKey);
    protected ResourceReferenceKeyNotFoundException(SerializationInfo info, StreamingContext context);
    public object get_Key();
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
public class System.Windows.Resources.ContentTypes : object {
    public static string XamlContentType;
}
public class System.Windows.Resources.StreamResourceInfo : object {
    private string _contentType;
    private Stream _stream;
    public string ContentType { get; }
    public Stream Stream { get; }
    public StreamResourceInfo(Stream stream, string contentType);
    public string get_ContentType();
    public Stream get_Stream();
}
internal class System.Windows.ResourcesChangedEventArgs : EventArgs {
    private ResourcesChangeInfo _info;
    internal ResourcesChangeInfo Info { get; }
    internal ResourcesChangedEventArgs(ResourcesChangeInfo info);
    internal ResourcesChangeInfo get_Info();
}
internal class System.Windows.ResourcesChangeInfo : ValueType {
    private List`1<ResourceDictionary> _oldDictionaries;
    private List`1<ResourceDictionary> _newDictionaries;
    private object _key;
    private DependencyObject _container;
    private PrivateFlags _flags;
    internal static ResourcesChangeInfo ThemeChangeInfo { get; }
    internal static ResourcesChangeInfo TreeChangeInfo { get; }
    internal static ResourcesChangeInfo SysColorsOrSettingsChangeInfo { get; }
    internal static ResourcesChangeInfo CatastrophicDictionaryChangeInfo { get; }
    internal bool IsThemeChange { get; internal set; }
    internal bool IsTreeChange { get; internal set; }
    internal bool IsStyleResourcesChange { get; internal set; }
    internal bool IsTemplateResourcesChange { get; internal set; }
    internal bool IsSysColorsOrSettingsChange { get; internal set; }
    internal bool IsCatastrophicDictionaryChange { get; internal set; }
    internal bool IsImplicitDataTemplateChange { get; internal set; }
    internal bool IsResourceAddOperation { get; }
    internal DependencyObject Container { get; }
    internal ResourcesChangeInfo(object key);
    internal ResourcesChangeInfo(ResourceDictionary oldDictionary, ResourceDictionary newDictionary);
    internal ResourcesChangeInfo(List`1<ResourceDictionary> oldDictionaries, List`1<ResourceDictionary> newDictionaries, bool isStyleResourcesChange, bool isTemplateResourcesChange, DependencyObject container);
    internal static ResourcesChangeInfo get_ThemeChangeInfo();
    internal static ResourcesChangeInfo get_TreeChangeInfo();
    internal static ResourcesChangeInfo get_SysColorsOrSettingsChangeInfo();
    internal static ResourcesChangeInfo get_CatastrophicDictionaryChangeInfo();
    internal bool get_IsThemeChange();
    internal void set_IsThemeChange(bool value);
    internal bool get_IsTreeChange();
    internal void set_IsTreeChange(bool value);
    internal bool get_IsStyleResourcesChange();
    internal void set_IsStyleResourcesChange(bool value);
    internal bool get_IsTemplateResourcesChange();
    internal void set_IsTemplateResourcesChange(bool value);
    internal bool get_IsSysColorsOrSettingsChange();
    internal void set_IsSysColorsOrSettingsChange(bool value);
    internal bool get_IsCatastrophicDictionaryChange();
    internal void set_IsCatastrophicDictionaryChange(bool value);
    internal bool get_IsImplicitDataTemplateChange();
    internal void set_IsImplicitDataTemplateChange(bool value);
    internal bool get_IsResourceAddOperation();
    internal DependencyObject get_Container();
    internal bool Contains(object key, bool isImplicitStyleKey);
    internal void SetIsImplicitDataTemplateChange();
    private void WritePrivateFlag(PrivateFlags bit, bool value);
    private bool ReadPrivateFlag(PrivateFlags bit);
}
public class System.Windows.RoutedPropertyChangedEventArgs`1 : RoutedEventArgs {
    private T _oldValue;
    private T _newValue;
    public T OldValue { get; }
    public T NewValue { get; }
    public RoutedPropertyChangedEventArgs`1(T oldValue, T newValue);
    public RoutedPropertyChangedEventArgs`1(T oldValue, T newValue, RoutedEvent routedEvent);
    public T get_OldValue();
    public T get_NewValue();
    protected virtual void InvokeEventHandler(Delegate genericHandler, object genericTarget);
}
public class System.Windows.RoutedPropertyChangedEventHandler`1 : MulticastDelegate {
    public RoutedPropertyChangedEventHandler`1(object object, IntPtr method);
    public virtual void Invoke(object sender, RoutedPropertyChangedEventArgs`1<T> e);
    public virtual IAsyncResult BeginInvoke(object sender, RoutedPropertyChangedEventArgs`1<T> e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Windows.SessionEndingCancelEventArgs : CancelEventArgs {
    private ReasonSessionEnding _reasonSessionEnding;
    public ReasonSessionEnding ReasonSessionEnding { get; }
    internal SessionEndingCancelEventArgs(ReasonSessionEnding reasonSessionEnding);
    public ReasonSessionEnding get_ReasonSessionEnding();
}
public class System.Windows.SessionEndingCancelEventHandler : MulticastDelegate {
    public SessionEndingCancelEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, SessionEndingCancelEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, SessionEndingCancelEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[XamlSetMarkupExtensionAttribute("ReceiveMarkupExtension")]
[XamlSetTypeConverterAttribute("ReceiveTypeConverter")]
public class System.Windows.Setter : SetterBase {
    private DependencyProperty _property;
    private object _value;
    private string _target;
    private object _unresolvedProperty;
    private object _unresolvedValue;
    private ITypeDescriptorContext _serviceProvider;
    private CultureInfo _cultureInfoForTypeConverter;
    [LocalizabilityAttribute("0")]
[DefaultValueAttribute("")]
[AmbientAttribute]
public DependencyProperty Property { get; public set; }
    [DependsOnAttribute("Property")]
[DependsOnAttribute("TargetName")]
[LocalizabilityAttribute("0")]
[TypeConverterAttribute("System.Windows.Markup.SetterTriggerConditionValueConverter")]
public object Value { get; public set; }
    internal object ValueInternal { get; }
    [DefaultValueAttribute("")]
[AmbientAttribute]
public string TargetName { get; public set; }
    public Setter(DependencyProperty property, object value);
    public Setter(DependencyProperty property, object value, string targetName);
    private void Initialize(DependencyProperty property, object value, string target);
    private void CheckValidProperty(DependencyProperty property);
    internal virtual void Seal();
    public DependencyProperty get_Property();
    public void set_Property(DependencyProperty value);
    public object get_Value();
    public void set_Value(object value);
    internal object get_ValueInternal();
    public string get_TargetName();
    public void set_TargetName(string value);
    public static void ReceiveMarkupExtension(object targetObject, XamlSetMarkupExtensionEventArgs eventArgs);
    public static void ReceiveTypeConverter(object targetObject, XamlSetTypeConverterEventArgs eventArgs);
    private sealed virtual override void System.ComponentModel.ISupportInitialize.BeginInit();
    private sealed virtual override void System.ComponentModel.ISupportInitialize.EndInit();
}
[LocalizabilityAttribute("16")]
public abstract class System.Windows.SetterBase : object {
    private bool _sealed;
    public bool IsSealed { get; }
    public bool get_IsSealed();
    internal virtual void Seal();
    protected void CheckSealed();
}
public class System.Windows.SetterBaseCollection : Collection`1<SetterBase> {
    private bool _sealed;
    public bool IsSealed { get; }
    protected virtual void ClearItems();
    protected virtual void InsertItem(int index, SetterBase item);
    protected virtual void RemoveItem(int index);
    protected virtual void SetItem(int index, SetterBase item);
    public bool get_IsSealed();
    internal void Seal();
    private void CheckSealed();
    private void SetterBaseValidation(SetterBase setterBase);
}
internal class System.Windows.Shapes.BoxedMatrix : object {
    public Matrix Value;
    public BoxedMatrix(Matrix value);
}
public class System.Windows.Shapes.Ellipse : Shape {
    private Rect _rect;
    public Geometry RenderedGeometry { get; }
    public Transform GeometryTransform { get; }
    protected Geometry DefiningGeometry { get; }
    internal int EffectiveValuesInitialSize { get; }
    private static Ellipse();
    public virtual Geometry get_RenderedGeometry();
    public virtual Transform get_GeometryTransform();
    protected virtual Size MeasureOverride(Size constraint);
    protected virtual Size ArrangeOverride(Size finalSize);
    protected virtual Geometry get_DefiningGeometry();
    protected virtual void OnRender(DrawingContext drawingContext);
    internal virtual void CacheDefiningGeometry();
    internal virtual Size GetNaturalSize();
    internal virtual Rect GetDefiningGeometryBounds();
    internal virtual int get_EffectiveValuesInitialSize();
}
public class System.Windows.Shapes.Line : Shape {
    public static DependencyProperty X1Property;
    public static DependencyProperty Y1Property;
    public static DependencyProperty X2Property;
    public static DependencyProperty Y2Property;
    private LineGeometry _lineGeometry;
    [TypeConverterAttribute("System.Windows.LengthConverter")]
public double X1 { get; public set; }
    [TypeConverterAttribute("System.Windows.LengthConverter")]
public double Y1 { get; public set; }
    [TypeConverterAttribute("System.Windows.LengthConverter")]
public double X2 { get; public set; }
    [TypeConverterAttribute("System.Windows.LengthConverter")]
public double Y2 { get; public set; }
    protected Geometry DefiningGeometry { get; }
    private static Line();
    public double get_X1();
    public void set_X1(double value);
    public double get_Y1();
    public void set_Y1(double value);
    public double get_X2();
    public void set_X2(double value);
    public double get_Y2();
    public void set_Y2(double value);
    protected virtual Geometry get_DefiningGeometry();
    internal virtual void CacheDefiningGeometry();
}
public class System.Windows.Shapes.Path : Shape {
    [CommonDependencyPropertyAttribute]
public static DependencyProperty DataProperty;
    public Geometry Data { get; public set; }
    protected Geometry DefiningGeometry { get; }
    internal int EffectiveValuesInitialSize { get; }
    private static Path();
    public Geometry get_Data();
    public void set_Data(Geometry value);
    protected virtual Geometry get_DefiningGeometry();
    internal virtual int get_EffectiveValuesInitialSize();
}
public class System.Windows.Shapes.Polygon : Shape {
    public static DependencyProperty PointsProperty;
    public static DependencyProperty FillRuleProperty;
    private Geometry _polygonGeometry;
    public PointCollection Points { get; public set; }
    public FillRule FillRule { get; public set; }
    protected Geometry DefiningGeometry { get; }
    private static Polygon();
    public PointCollection get_Points();
    public void set_Points(PointCollection value);
    public FillRule get_FillRule();
    public void set_FillRule(FillRule value);
    protected virtual Geometry get_DefiningGeometry();
    internal virtual void CacheDefiningGeometry();
}
public class System.Windows.Shapes.Polyline : Shape {
    public static DependencyProperty PointsProperty;
    public static DependencyProperty FillRuleProperty;
    private Geometry _polylineGeometry;
    public PointCollection Points { get; public set; }
    public FillRule FillRule { get; public set; }
    protected Geometry DefiningGeometry { get; }
    private static Polyline();
    public PointCollection get_Points();
    public void set_Points(PointCollection value);
    public FillRule get_FillRule();
    public void set_FillRule(FillRule value);
    protected virtual Geometry get_DefiningGeometry();
    internal virtual void CacheDefiningGeometry();
}
public class System.Windows.Shapes.Rectangle : Shape {
    public static DependencyProperty RadiusXProperty;
    public static DependencyProperty RadiusYProperty;
    private Rect _rect;
    [TypeConverterAttribute("System.Windows.LengthConverter")]
public double RadiusX { get; public set; }
    [TypeConverterAttribute("System.Windows.LengthConverter")]
public double RadiusY { get; public set; }
    public Geometry RenderedGeometry { get; }
    public Transform GeometryTransform { get; }
    protected Geometry DefiningGeometry { get; }
    internal int EffectiveValuesInitialSize { get; }
    private static Rectangle();
    public double get_RadiusX();
    public void set_RadiusX(double value);
    public double get_RadiusY();
    public void set_RadiusY(double value);
    public virtual Geometry get_RenderedGeometry();
    public virtual Transform get_GeometryTransform();
    protected virtual Size MeasureOverride(Size constraint);
    protected virtual Size ArrangeOverride(Size finalSize);
    protected virtual Geometry get_DefiningGeometry();
    protected virtual void OnRender(DrawingContext drawingContext);
    internal virtual void CacheDefiningGeometry();
    internal virtual Size GetNaturalSize();
    internal virtual Rect GetDefiningGeometryBounds();
    internal virtual int get_EffectiveValuesInitialSize();
}
[LocalizabilityAttribute("0")]
public abstract class System.Windows.Shapes.Shape : FrameworkElement {
    public static DependencyProperty StretchProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty FillProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty StrokeProperty;
    [CommonDependencyPropertyAttribute]
public static DependencyProperty StrokeThicknessProperty;
    public static DependencyProperty StrokeStartLineCapProperty;
    public static DependencyProperty StrokeEndLineCapProperty;
    public static DependencyProperty StrokeDashCapProperty;
    public static DependencyProperty StrokeLineJoinProperty;
    public static DependencyProperty StrokeMiterLimitProperty;
    public static DependencyProperty StrokeDashOffsetProperty;
    public static DependencyProperty StrokeDashArrayProperty;
    private Pen _pen;
    private Geometry _renderedGeometry;
    private static UncommonField`1<BoxedMatrix> StretchMatrixField;
    public Stretch Stretch { get; public set; }
    public Geometry RenderedGeometry { get; }
    public Transform GeometryTransform { get; }
    public Brush Fill { get; public set; }
    public Brush Stroke { get; public set; }
    [TypeConverterAttribute("System.Windows.LengthConverter")]
public double StrokeThickness { get; public set; }
    public PenLineCap StrokeStartLineCap { get; public set; }
    public PenLineCap StrokeEndLineCap { get; public set; }
    public PenLineCap StrokeDashCap { get; public set; }
    public PenLineJoin StrokeLineJoin { get; public set; }
    public double StrokeMiterLimit { get; public set; }
    public double StrokeDashOffset { get; public set; }
    public DoubleCollection StrokeDashArray { get; public set; }
    protected Geometry DefiningGeometry { get; }
    internal bool IsPenNoOp { get; }
    private static Shape();
    public Stretch get_Stretch();
    public void set_Stretch(Stretch value);
    public virtual Geometry get_RenderedGeometry();
    public virtual Transform get_GeometryTransform();
    private static void OnPenChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public Brush get_Fill();
    public void set_Fill(Brush value);
    public Brush get_Stroke();
    public void set_Stroke(Brush value);
    public double get_StrokeThickness();
    public void set_StrokeThickness(double value);
    public PenLineCap get_StrokeStartLineCap();
    public void set_StrokeStartLineCap(PenLineCap value);
    public PenLineCap get_StrokeEndLineCap();
    public void set_StrokeEndLineCap(PenLineCap value);
    public PenLineCap get_StrokeDashCap();
    public void set_StrokeDashCap(PenLineCap value);
    public PenLineJoin get_StrokeLineJoin();
    public void set_StrokeLineJoin(PenLineJoin value);
    public double get_StrokeMiterLimit();
    public void set_StrokeMiterLimit(double value);
    public double get_StrokeDashOffset();
    public void set_StrokeDashOffset(double value);
    public DoubleCollection get_StrokeDashArray();
    public void set_StrokeDashArray(DoubleCollection value);
    protected virtual Size MeasureOverride(Size constraint);
    protected virtual Size ArrangeOverride(Size finalSize);
    protected virtual void OnRender(DrawingContext drawingContext);
    protected abstract virtual Geometry get_DefiningGeometry();
    internal bool SizeIsInvalidOrEmpty(Size size);
    internal bool get_IsPenNoOp();
    internal double GetStrokeThickness();
    internal Pen GetPen();
    internal static bool IsDoubleFiniteNonNegative(object o);
    internal static bool IsDoubleFinite(object o);
    internal static bool IsDoubleFiniteOrNaN(object o);
    internal virtual void CacheDefiningGeometry();
    internal Size GetStretchedRenderSize(Stretch mode, double strokeThickness, Size availableSize, Rect geometryBounds);
    internal Size GetStretchedRenderSizeAndSetStretchMatrix(Stretch mode, double strokeThickness, Size availableSize, Rect geometryBounds);
    internal void ResetRenderedGeometry();
    internal void GetStretchMetrics(Stretch mode, double strokeThickness, Size availableSize, Rect geometryBounds, Double& xScale, Double& yScale, Double& dX, Double& dY, Size& stretchedSize);
    internal virtual Size GetNaturalSize();
    internal virtual Rect GetDefiningGeometryBounds();
    internal void EnsureRenderedGeometry();
}
internal class System.Windows.SharedDp : object {
    internal DependencyProperty Dp;
    internal object Value;
    internal string ElementName;
    internal SharedDp(DependencyProperty dp, object value, string elementName);
}
public abstract class System.Windows.Shell.JumpItem : object {
    [CompilerGeneratedAttribute]
private string <CustomCategory>k__BackingField;
    public string CustomCategory { get; public set; }
    [CompilerGeneratedAttribute]
public string get_CustomCategory();
    [CompilerGeneratedAttribute]
public void set_CustomCategory(string value);
}
public enum System.Windows.Shell.JumpItemRejectionReason : Enum {
    public int value__;
    public static JumpItemRejectionReason None;
    public static JumpItemRejectionReason InvalidItem;
    public static JumpItemRejectionReason NoRegisteredHandler;
    public static JumpItemRejectionReason RemovedByUser;
}
public class System.Windows.Shell.JumpItemsRejectedEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private IList`1<JumpItem> <RejectedItems>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<JumpItemRejectionReason> <RejectionReasons>k__BackingField;
    public IList`1<JumpItem> RejectedItems { get; private set; }
    public IList`1<JumpItemRejectionReason> RejectionReasons { get; private set; }
    public JumpItemsRejectedEventArgs(IList`1<JumpItem> rejectedItems, IList`1<JumpItemRejectionReason> reasons);
    [CompilerGeneratedAttribute]
public IList`1<JumpItem> get_RejectedItems();
    [CompilerGeneratedAttribute]
private void set_RejectedItems(IList`1<JumpItem> value);
    [CompilerGeneratedAttribute]
public IList`1<JumpItemRejectionReason> get_RejectionReasons();
    [CompilerGeneratedAttribute]
private void set_RejectionReasons(IList`1<JumpItemRejectionReason> value);
}
public class System.Windows.Shell.JumpItemsRemovedEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private IList`1<JumpItem> <RemovedItems>k__BackingField;
    public IList`1<JumpItem> RemovedItems { get; private set; }
    public JumpItemsRemovedEventArgs(IList`1<JumpItem> removedItems);
    [CompilerGeneratedAttribute]
public IList`1<JumpItem> get_RemovedItems();
    [CompilerGeneratedAttribute]
private void set_RemovedItems(IList`1<JumpItem> value);
}
[ContentPropertyAttribute("JumpItems")]
public class System.Windows.Shell.JumpList : object {
    private static object s_lock;
    private static Dictionary`2<Application, JumpList> s_applicationMap;
    private Application _application;
    private Nullable`1<bool> _initializing;
    private List`1<JumpItem> _jumpItems;
    [CompilerGeneratedAttribute]
private bool <ShowFrequentCategory>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ShowRecentCategory>k__BackingField;
    private static string _FullName;
    [CompilerGeneratedAttribute]
private EventHandler`1<JumpItemsRejectedEventArgs> JumpItemsRejected;
    [CompilerGeneratedAttribute]
private EventHandler`1<JumpItemsRemovedEventArgs> JumpItemsRemovedByUser;
    public bool ShowFrequentCategory { get; public set; }
    public bool ShowRecentCategory { get; public set; }
    public List`1<JumpItem> JumpItems { get; }
    private bool IsUnmodified { get; }
    private static string _RuntimeId { get; }
    private static JumpList();
    public JumpList(IEnumerable`1<JumpItem> items, bool showFrequent, bool showRecent);
    public static void AddToRecentCategory(string itemPath);
    public static void AddToRecentCategory(JumpPath jumpPath);
    public static void AddToRecentCategory(JumpTask jumpTask);
    public static void SetJumpList(Application application, JumpList value);
    public static JumpList GetJumpList(Application application);
    [CompilerGeneratedAttribute]
public bool get_ShowFrequentCategory();
    [CompilerGeneratedAttribute]
public void set_ShowFrequentCategory(bool value);
    [CompilerGeneratedAttribute]
public bool get_ShowRecentCategory();
    [CompilerGeneratedAttribute]
public void set_ShowRecentCategory(bool value);
    public List`1<JumpItem> get_JumpItems();
    private bool get_IsUnmodified();
    public sealed virtual void BeginInit();
    public sealed virtual void EndInit();
    private static string get__RuntimeId();
    public void Apply();
    private void ApplyFromApplication();
    private void ApplyList();
    private static bool ListContainsShellObject(List`1<_ShellObjectPair> removedList, object shellObject);
    private static object GetShellObjectForJumpItem(JumpItem jumpItem);
    private static List`1<_ShellObjectPair> GenerateJumpItems(IObjectArray shellObjects);
    private static void AddCategory(ICustomDestinationList cdl, string category, List`1<_ShellObjectPair> jumpItems, List`1<JumpItem> successList, List`1<_RejectedJumpItemPair> rejectionList);
    private static void AddCategory(ICustomDestinationList cdl, string category, List`1<_ShellObjectPair> jumpItems, List`1<JumpItem> successList, List`1<_RejectedJumpItemPair> rejectionList, bool isHeterogenous);
    private static IShellLinkW CreateLinkFromJumpTask(JumpTask jumpTask, bool allowSeparators);
    private static IShellItem2 CreateItemFromJumpPath(JumpPath jumpPath);
    private static JumpItem GetJumpItemForShellObject(object shellObject);
    private static string ShellLinkToString(IShellLinkW shellLink);
    private void RejectEverything();
    [CompilerGeneratedAttribute]
public void add_JumpItemsRejected(EventHandler`1<JumpItemsRejectedEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_JumpItemsRejected(EventHandler`1<JumpItemsRejectedEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_JumpItemsRemovedByUser(EventHandler`1<JumpItemsRemovedEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_JumpItemsRemovedByUser(EventHandler`1<JumpItemsRemovedEventArgs> value);
}
public class System.Windows.Shell.JumpPath : JumpItem {
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    public string Path { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
public void set_Path(string value);
}
public class System.Windows.Shell.JumpTask : JumpItem {
    [CompilerGeneratedAttribute]
private string <Title>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ApplicationPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Arguments>k__BackingField;
    [CompilerGeneratedAttribute]
private string <WorkingDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private string <IconResourcePath>k__BackingField;
    [CompilerGeneratedAttribute]
private int <IconResourceIndex>k__BackingField;
    public string Title { get; public set; }
    public string Description { get; public set; }
    public string ApplicationPath { get; public set; }
    public string Arguments { get; public set; }
    public string WorkingDirectory { get; public set; }
    public string IconResourcePath { get; public set; }
    public int IconResourceIndex { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Title();
    [CompilerGeneratedAttribute]
public void set_Title(string value);
    [CompilerGeneratedAttribute]
public string get_Description();
    [CompilerGeneratedAttribute]
public void set_Description(string value);
    [CompilerGeneratedAttribute]
public string get_ApplicationPath();
    [CompilerGeneratedAttribute]
public void set_ApplicationPath(string value);
    [CompilerGeneratedAttribute]
public string get_Arguments();
    [CompilerGeneratedAttribute]
public void set_Arguments(string value);
    [CompilerGeneratedAttribute]
public string get_WorkingDirectory();
    [CompilerGeneratedAttribute]
public void set_WorkingDirectory(string value);
    [CompilerGeneratedAttribute]
public string get_IconResourcePath();
    [CompilerGeneratedAttribute]
public void set_IconResourcePath(string value);
    [CompilerGeneratedAttribute]
public int get_IconResourceIndex();
    [CompilerGeneratedAttribute]
public void set_IconResourceIndex(int value);
}
[FlagsAttribute]
public enum System.Windows.Shell.NonClientFrameEdges : Enum {
    public int value__;
    public static NonClientFrameEdges None;
    public static NonClientFrameEdges Left;
    public static NonClientFrameEdges Top;
    public static NonClientFrameEdges Right;
    public static NonClientFrameEdges Bottom;
}
public enum System.Windows.Shell.ResizeGripDirection : Enum {
    public int value__;
    public static ResizeGripDirection None;
    public static ResizeGripDirection TopLeft;
    public static ResizeGripDirection Top;
    public static ResizeGripDirection TopRight;
    public static ResizeGripDirection Right;
    public static ResizeGripDirection BottomRight;
    public static ResizeGripDirection Bottom;
    public static ResizeGripDirection BottomLeft;
    public static ResizeGripDirection Left;
}
public class System.Windows.Shell.TaskbarItemInfo : Freezable {
    public static DependencyProperty ProgressStateProperty;
    public static DependencyProperty ProgressValueProperty;
    public static DependencyProperty OverlayProperty;
    public static DependencyProperty DescriptionProperty;
    public static DependencyProperty ThumbnailClipMarginProperty;
    public static DependencyProperty ThumbButtonInfosProperty;
    [CompilerGeneratedAttribute]
private DependencyPropertyChangedEventHandler PropertyChanged;
    public TaskbarItemProgressState ProgressState { get; public set; }
    public double ProgressValue { get; public set; }
    public ImageSource Overlay { get; public set; }
    public string Description { get; public set; }
    public Thickness ThumbnailClipMargin { get; public set; }
    public ThumbButtonInfoCollection ThumbButtonInfos { get; public set; }
    private static TaskbarItemInfo();
    protected virtual Freezable CreateInstanceCore();
    public TaskbarItemProgressState get_ProgressState();
    public void set_ProgressState(TaskbarItemProgressState value);
    private TaskbarItemProgressState CoerceProgressState(TaskbarItemProgressState value);
    public double get_ProgressValue();
    public void set_ProgressValue(double value);
    private static double CoerceProgressValue(double progressValue);
    public ImageSource get_Overlay();
    public void set_Overlay(ImageSource value);
    public string get_Description();
    public void set_Description(string value);
    public Thickness get_ThumbnailClipMargin();
    public void set_ThumbnailClipMargin(Thickness value);
    private Thickness CoerceThumbnailClipMargin(Thickness margin);
    public ThumbButtonInfoCollection get_ThumbButtonInfos();
    public void set_ThumbButtonInfos(ThumbButtonInfoCollection value);
    private void NotifyDependencyPropertyChanged(DependencyPropertyChangedEventArgs e);
    [CompilerGeneratedAttribute]
internal void add_PropertyChanged(DependencyPropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
internal void remove_PropertyChanged(DependencyPropertyChangedEventHandler value);
}
public enum System.Windows.Shell.TaskbarItemProgressState : Enum {
    public int value__;
    public static TaskbarItemProgressState None;
    public static TaskbarItemProgressState Indeterminate;
    public static TaskbarItemProgressState Normal;
    public static TaskbarItemProgressState Error;
    public static TaskbarItemProgressState Paused;
}
public class System.Windows.Shell.ThumbButtonInfo : Freezable {
    public static DependencyProperty VisibilityProperty;
    public static DependencyProperty DismissWhenClickedProperty;
    public static DependencyProperty ImageSourceProperty;
    public static DependencyProperty IsBackgroundVisibleProperty;
    public static DependencyProperty DescriptionProperty;
    public static DependencyProperty IsEnabledProperty;
    public static DependencyProperty IsInteractiveProperty;
    public static DependencyProperty CommandProperty;
    public static DependencyProperty CommandParameterProperty;
    public static DependencyProperty CommandTargetProperty;
    private static DependencyProperty _CanExecuteProperty;
    [CompilerGeneratedAttribute]
private EventHandler Click;
    public Visibility Visibility { get; public set; }
    public bool DismissWhenClicked { get; public set; }
    public ImageSource ImageSource { get; public set; }
    public bool IsBackgroundVisible { get; public set; }
    public string Description { get; public set; }
    public bool IsEnabled { get; public set; }
    public bool IsInteractive { get; public set; }
    private bool CanExecute { get; private set; }
    public ICommand Command { get; public set; }
    public object CommandParameter { get; public set; }
    public IInputElement CommandTarget { get; public set; }
    private static ThumbButtonInfo();
    protected virtual Freezable CreateInstanceCore();
    public Visibility get_Visibility();
    public void set_Visibility(Visibility value);
    public bool get_DismissWhenClicked();
    public void set_DismissWhenClicked(bool value);
    public ImageSource get_ImageSource();
    public void set_ImageSource(ImageSource value);
    public bool get_IsBackgroundVisible();
    public void set_IsBackgroundVisible(bool value);
    public string get_Description();
    public void set_Description(string value);
    private static object CoerceDescription(DependencyObject d, object value);
    private object CoerceIsEnabledValue(object value);
    public bool get_IsEnabled();
    public void set_IsEnabled(bool value);
    public bool get_IsInteractive();
    public void set_IsInteractive(bool value);
    private void OnCommandChanged(DependencyPropertyChangedEventArgs e);
    private bool get_CanExecute();
    private void set_CanExecute(bool value);
    [CompilerGeneratedAttribute]
public void add_Click(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_Click(EventHandler value);
    internal void InvokeClick();
    private void _InvokeCommand();
    private void UnhookCommand(ICommand command);
    private void HookCommand(ICommand command);
    private void OnCanExecuteChanged(object sender, EventArgs e);
    private void UpdateCanExecute();
    public sealed virtual ICommand get_Command();
    public void set_Command(ICommand value);
    public sealed virtual object get_CommandParameter();
    public void set_CommandParameter(object value);
    public sealed virtual IInputElement get_CommandTarget();
    public void set_CommandTarget(IInputElement value);
}
public class System.Windows.Shell.ThumbButtonInfoCollection : FreezableCollection`1<ThumbButtonInfo> {
    private static ThumbButtonInfoCollection s_empty;
    internal static ThumbButtonInfoCollection Empty { get; }
    protected virtual Freezable CreateInstanceCore();
    internal static ThumbButtonInfoCollection get_Empty();
}
public class System.Windows.Shell.WindowChrome : Freezable {
    public static DependencyProperty WindowChromeProperty;
    public static DependencyProperty IsHitTestVisibleInChromeProperty;
    public static DependencyProperty ResizeGripDirectionProperty;
    public static DependencyProperty CaptionHeightProperty;
    public static DependencyProperty ResizeBorderThicknessProperty;
    public static DependencyProperty GlassFrameThicknessProperty;
    public static DependencyProperty UseAeroCaptionButtonsProperty;
    public static DependencyProperty CornerRadiusProperty;
    public static DependencyProperty NonClientFrameEdgesProperty;
    private static NonClientFrameEdges NonClientFrameEdges_All;
    private static List`1<_SystemParameterBoundProperty> _BoundProperties;
    [CompilerGeneratedAttribute]
private EventHandler PropertyChangedThatRequiresRepaint;
    public static Thickness GlassFrameCompleteThickness { get; }
    public double CaptionHeight { get; public set; }
    public Thickness ResizeBorderThickness { get; public set; }
    public Thickness GlassFrameThickness { get; public set; }
    public bool UseAeroCaptionButtons { get; public set; }
    public CornerRadius CornerRadius { get; public set; }
    public NonClientFrameEdges NonClientFrameEdges { get; public set; }
    private static WindowChrome();
    public static Thickness get_GlassFrameCompleteThickness();
    private static void _OnChromeChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    public static WindowChrome GetWindowChrome(Window window);
    public static void SetWindowChrome(Window window, WindowChrome chrome);
    public static bool GetIsHitTestVisibleInChrome(IInputElement inputElement);
    public static void SetIsHitTestVisibleInChrome(IInputElement inputElement, bool hitTestVisible);
    public static ResizeGripDirection GetResizeGripDirection(IInputElement inputElement);
    public static void SetResizeGripDirection(IInputElement inputElement, ResizeGripDirection direction);
    public double get_CaptionHeight();
    public void set_CaptionHeight(double value);
    public Thickness get_ResizeBorderThickness();
    public void set_ResizeBorderThickness(Thickness value);
    private static object _CoerceGlassFrameThickness(Thickness thickness);
    public Thickness get_GlassFrameThickness();
    public void set_GlassFrameThickness(Thickness value);
    public bool get_UseAeroCaptionButtons();
    public void set_UseAeroCaptionButtons(bool value);
    public CornerRadius get_CornerRadius();
    public void set_CornerRadius(CornerRadius value);
    private static bool _NonClientFrameEdgesAreValid(object value);
    public NonClientFrameEdges get_NonClientFrameEdges();
    public void set_NonClientFrameEdges(NonClientFrameEdges value);
    protected virtual Freezable CreateInstanceCore();
    private void _OnPropertyChangedThatRequiresRepaint();
    [CompilerGeneratedAttribute]
internal void add_PropertyChangedThatRequiresRepaint(EventHandler value);
    [CompilerGeneratedAttribute]
internal void remove_PropertyChangedThatRequiresRepaint(EventHandler value);
}
internal class System.Windows.Shell.WindowChromeWorker : DependencyObject {
    private static SWP _SwpFlags;
    private List`1<KeyValuePair`2<WM, MessageHandler>> _messageTable;
    private Window _window;
    private IntPtr _hwnd;
    private HwndSource _hwndSource;
    private bool _isHooked;
    private bool _isFixedUp;
    private bool _isUserResizing;
    private bool _hasUserMovedWindow;
    private Point _windowPosAtStartOfUserMove;
    private WindowChrome _chromeInfo;
    private WindowState _lastRoundingState;
    private WindowState _lastMenuState;
    private bool _isGlassEnabled;
    public static DependencyProperty WindowChromeWorkerProperty;
    private static HT[0...,0...] _HitTestBorders;
    private bool _IsWindowDocked { get; }
    private static WindowChromeWorker();
    public void SetWindowChrome(WindowChrome newChrome);
    private void _OnChromePropertyChangedThatRequiresRepaint(object sender, EventArgs e);
    private static void _OnChromeWorkerChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private void _SetWindow(Window window);
    private void _WindowSourceInitialized(object sender, EventArgs e);
    private void UnsubscribeWindowEvents();
    private void _UnsetWindow(object sender, EventArgs e);
    public static WindowChromeWorker GetWindowChromeWorker(Window window);
    public static void SetWindowChromeWorker(Window window, WindowChromeWorker chrome);
    private void _OnWindowPropertyChangedThatRequiresTemplateFixup(object sender, EventArgs e);
    private void _ApplyNewCustomChrome();
    private void RetryFixupTemplateIssuesOnVisualChildrenAdded(object sender, EventArgs e);
    private void _FixupTemplateIssues();
    private void _FixupRestoreBounds(object sender, EventArgs e);
    private RECT _GetAdjustedWindowRect(RECT rcWindow);
    private bool get__IsWindowDocked();
    private IntPtr _WndProc(IntPtr hwnd, int msg, IntPtr wParam, IntPtr lParam, Boolean& handled);
    private IntPtr _HandleSetTextOrIcon(WM uMsg, IntPtr wParam, IntPtr lParam, Boolean& handled);
    private IntPtr _HandleNCActivate(WM uMsg, IntPtr wParam, IntPtr lParam, Boolean& handled);
    private IntPtr _HandleNCCalcSize(WM uMsg, IntPtr wParam, IntPtr lParam, Boolean& handled);
    private HT _GetHTFromResizeGripDirection(ResizeGripDirection direction);
    private IntPtr _HandleNCHitTest(WM uMsg, IntPtr wParam, IntPtr lParam, Boolean& handled);
    private IntPtr _HandleNCRButtonUp(WM uMsg, IntPtr wParam, IntPtr lParam, Boolean& handled);
    private IntPtr _HandleSize(WM uMsg, IntPtr wParam, IntPtr lParam, Boolean& handled);
    private IntPtr _HandleWindowPosChanged(WM uMsg, IntPtr wParam, IntPtr lParam, Boolean& handled);
    private IntPtr _HandleDwmCompositionChanged(WM uMsg, IntPtr wParam, IntPtr lParam, Boolean& handled);
    private IntPtr _HandleSettingChange(WM uMsg, IntPtr wParam, IntPtr lParam, Boolean& handled);
    private IntPtr _HandleEnterSizeMove(WM uMsg, IntPtr wParam, IntPtr lParam, Boolean& handled);
    private IntPtr _HandleExitSizeMove(WM uMsg, IntPtr wParam, IntPtr lParam, Boolean& handled);
    private IntPtr _HandleMove(WM uMsg, IntPtr wParam, IntPtr lParam, Boolean& handled);
    private bool _ModifyStyle(WS removeStyle, WS addStyle);
    private WindowState _GetHwndState();
    private Rect _GetWindowRect();
    private void _UpdateSystemMenu(Nullable`1<WindowState> assumeState);
    private void _UpdateFrameState(bool force);
    private void _ClearRoundingRegion();
    private void _SetRoundingRegion(Nullable`1<WINDOWPOS> wp);
    private static IntPtr _CreateRoundRectRgn(Rect region, double radius);
    private static void _CreateAndCombineRoundRectRgn(IntPtr hrgnSource, Rect region, double radius);
    private static bool _IsUniform(CornerRadius cornerRadius);
    private void _ExtendGlassFrame();
    private HT _HitTestNca(Rect windowPosition, Point mousePosition);
    private bool GetEffectiveClientArea(RECT& rcClient);
    private void _RestoreStandardChromeState(bool isClosing);
    private void _UnhookCustomChrome();
    private void _RestoreFrameworkIssueFixups();
    private void _RestoreGlassFrame();
    private void _RestoreHrgn();
}
public enum System.Windows.ShutdownMode : Enum {
    public byte value__;
    public static ShutdownMode OnLastWindowClose;
    public static ShutdownMode OnMainWindowClose;
    public static ShutdownMode OnExplicitShutdown;
}
internal class System.Windows.SingleChildEnumerator : object {
    private int _index;
    private int _count;
    private object _child;
    private object System.Collections.IEnumerator.Current { get; }
    internal SingleChildEnumerator(object Child);
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    private sealed virtual override bool System.Collections.IEnumerator.MoveNext();
    private sealed virtual override void System.Collections.IEnumerator.Reset();
}
public class System.Windows.SizeChangedEventArgs : RoutedEventArgs {
    private Size _previousSize;
    private UIElement _element;
    private byte _bits;
    private static byte _widthChangedBit;
    private static byte _heightChangedBit;
    public Size PreviousSize { get; }
    public Size NewSize { get; }
    public bool WidthChanged { get; }
    public bool HeightChanged { get; }
    internal SizeChangedEventArgs(UIElement element, SizeChangedInfo info);
    private static SizeChangedEventArgs();
    public Size get_PreviousSize();
    public Size get_NewSize();
    public bool get_WidthChanged();
    public bool get_HeightChanged();
    protected virtual void InvokeEventHandler(Delegate genericHandler, object genericTarget);
}
public class System.Windows.SizeChangedEventHandler : MulticastDelegate {
    public SizeChangedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, SizeChangedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, SizeChangedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal static class System.Windows.SR : object {
    private static ResourceManager ResourceManager { get; }
    private static ResourceManager get_ResourceManager();
    private static bool UsingResourceKeys();
    internal static string GetResourceString(string resourceKey, string defaultString);
    internal static string Format(string resourceFormat, Object[] args);
    internal static string Format(string resourceFormat, object p1);
    internal static string Format(string resourceFormat, object p1, object p2);
    internal static string Format(string resourceFormat, object p1, object p2, object p3);
    public static string Get(string name);
    public static string Get(string name, Object[] args);
}
internal static class System.Windows.SRID : object {
    private static ResourceManager s_resourceManager;
    [CompilerGeneratedAttribute]
private static CultureInfo <Culture>k__BackingField;
    internal static string AbsoluteUriNotAllowed;
    internal static string AbsoluteUriOnly;
    internal static string AccessCollectionAfterShutDown;
    internal static string AddAnnotationsNotImplemented;
    internal static string AddedItemNotAtIndex;
    internal static string AddedItemNotInCollection;
    internal static string AdornedElementNotFound;
    internal static string AdornedElementPlaceholderMustBeInTemplate;
    internal static string AdornerNotFound;
    internal static string AffectedByMsCtfIssue;
    internal static string AlreadyHasLogicalChildren;
    internal static string AlreadyHasParent;
    internal static string AnnotationAdorner_NotUIElement;
    internal static string AnnotationAlreadyExistInService;
    internal static string AnnotationAlreadyExists;
    internal static string AnnotationIsNull;
    internal static string AnnotationServiceAlreadyExists;
    internal static string AnnotationServiceIsAlreadyEnabled;
    internal static string AnnotationServiceNotEnabled;
    internal static string AppActivationException;
    internal static string ApplicationAlreadyRunning;
    internal static string ApplicationShuttingDown;
    internal static string ArgumentLengthMismatch;
    internal static string ArgumentPropertyMustNotBeNull;
    internal static string Argument_InvalidOffLen;
    internal static string ArrangeReentrancyInvalid;
    internal static string AssemblyIdNegative;
    internal static string AssemblyIdOutOfSequence;
    internal static string AssemblyTagMissing;
    internal static string AttachablePropertyNotFound;
    internal static string AudioVideo_CannotControlMedia;
    internal static string AudioVideo_InvalidDependencyObject;
    internal static string AudioVideo_InvalidMediaState;
    internal static string AuxiliaryFilterReturnedAnomalousCountOfCharacters;
    internal static string AxNoConnectionPoint;
    internal static string AxNoConnectionPointContainer;
    internal static string AxNoEventInterface;
    internal static string AXNohWnd;
    internal static string AxNoSinkAdvise;
    internal static string AxNoSinkImplementation;
    internal static string AxRequiresApartmentThread;
    internal static string AxWindowlessControl;
    internal static string BadDistance;
    internal static string BadFixedTextPosition;
    internal static string BadTargetArray;
    internal static string BadTextPositionOrder;
    internal static string BamlAssemblyIdNotFound;
    internal static string BamlBadExtensionValue;
    internal static string BamlIsNotSupportedOutsideOfApplicationResources;
    internal static string BamlReaderClosed;
    internal static string BamlReaderNoOwnerType;
    internal static string BamlScopeError;
    internal static string BamlTypeIdNotFound;
    internal static string BamlWriterBadAssembly;
    internal static string BamlWriterBadScope;
    internal static string BamlWriterBadStream;
    internal static string BamlWriterBadXmlns;
    internal static string BamlWriterClosed;
    internal static string BamlWriterNoInElement;
    internal static string BamlWriterStartDoc;
    internal static string BamlWriterUnknownMarkupExtension;
    internal static string BindingCollectionContainsNonBinding;
    internal static string BindingConflict;
    internal static string BindingExpressionIsDetached;
    internal static string BindingExpressionStatusChanged;
    internal static string BindingGroup_CannotChangeGroups;
    internal static string BindingGroup_NoEntry;
    internal static string BindingGroup_ValueUnavailable;
    internal static string BindingListCannotCustomFilter;
    internal static string BindingListCanOnlySortByOneProperty;
    internal static string BufferOffsetNegative;
    internal static string BufferTooSmall;
    internal static string ByteRangeDownloaderNotInitialized;
    internal static string CalendarAutomationPeer_BlackoutDayHelpText;
    internal static string CalendarAutomationPeer_CalendarButtonLocalizedControlType;
    internal static string CalendarAutomationPeer_DayButtonLocalizedControlType;
    internal static string CalendarAutomationPeer_DecadeMode;
    internal static string CalendarAutomationPeer_MonthMode;
    internal static string CalendarAutomationPeer_YearMode;
    internal static string CalendarCollection_MultiThreadedCollectionChangeNotSupported;
    internal static string CalendarNamePropertyValueNotValid;
    internal static string Calendar_CheckSelectionMode_InvalidOperation;
    internal static string Calendar_NextButtonName;
    internal static string Calendar_OnDisplayModePropertyChanged_InvalidValue;
    internal static string Calendar_OnFirstDayOfWeekChanged_InvalidValue;
    internal static string Calendar_OnSelectedDateChanged_InvalidOperation;
    internal static string Calendar_OnSelectedDateChanged_InvalidValue;
    internal static string Calendar_OnSelectionModeChanged_InvalidValue;
    internal static string Calendar_PreviousButtonName;
    internal static string Calendar_UnSelectableDates;
    internal static string CancelEditNotSupported;
    internal static string CancelledText;
    internal static string CancelledTitle;
    internal static string CannotBeInsidePopup;
    internal static string CannotBeSelfParent;
    internal static string CannotCallRunFromBrowserHostedApp;
    internal static string CannotCallRunMultipleTimes;
    internal static string CannotChangeAfterSealed;
    internal static string CannotChangeLiveShaping;
    internal static string CannotChangeMainWindowInBrowser;
    internal static string CannotDetermineSortByPropertiesForCollection;
    internal static string CannotEditPlaceholder;
    internal static string CannotFilterView;
    internal static string CannotFindRemovedItem;
    internal static string CannotGroupView;
    internal static string CannotHaveEventHandlersInThemeStyle;
    internal static string CannotHaveOverridesDefaultStyleInThemeStyle;
    internal static string CannotHavePropertyInStyle;
    internal static string CannotHavePropertyInTemplate;
    internal static string CannotHookupFCERoot;
    internal static string CannotInvokeScript;
    internal static string CannotModifyLogicalChildrenDuringTreeWalk;
    internal static string CannotMoveToUnknownPosition;
    internal static string CannotParseId;
    internal static string CannotProcessInkCommand;
    internal static string CannotQueryPropertiesWhenPageNotInTreeWithWindow;
    internal static string CannotRecyleHeterogeneousTypes;
    internal static string CannotRemoveUnrealizedItems;
    internal static string CannotSelectNotSelectableItem;
    internal static string CannotSerializeInvalidInstance;
    internal static string CannotSetNegativePosition;
    internal static string CannotSetOwnerToItself;
    internal static string CannotSortView;
    internal static string CannotUseItemsSource;
    internal static string CannotWriteToReadOnly;
    internal static string CanOnlyHaveOneChild;
    internal static string CantSetInMarkup;
    internal static string CantSetOwnerAfterDialogIsShown;
    internal static string CantSetOwnerToClosedWindow;
    internal static string CantSetOwnerWhosHwndIsNotCreated;
    internal static string CantShowMBServiceWithOwner;
    internal static string CantShowModalOnNonInteractive;
    internal static string CantShowOnDifferentThread;
    internal static string CantSwitchVirtualizationModePostMeasure;
    internal static string ChangeNotAllowedAfterShow;
    internal static string ChangeSealedBinding;
    internal static string ChangingCollectionNotSupported;
    internal static string ChangingIdNotAllowed;
    internal static string ChangingTypeNotAllowed;
    internal static string ChildHasWrongType;
    internal static string ChildNameMustBeNonEmpty;
    internal static string ChildNameNamePatternReserved;
    internal static string ChildTemplateInstanceDoesNotExist;
    internal static string ChildWindowMustHaveCorrectParent;
    internal static string ChildWindowNotCreated;
    internal static string CircularOwnerChild;
    internal static string ClearHighlight;
    internal static string ClipboardCopyMode_Disabled;
    internal static string ClipToBoundsNotSupported;
    internal static string CollectionAddEventMissingItem;
    internal static string CollectionChangeIndexOutOfRange;
    internal static string CollectionContainerMustBeUniqueForComposite;
    internal static string CollectionViewTypeIsInitOnly;
    internal static string CollectionView_MissingSynchronizationCallback;
    internal static string CollectionView_NameTypeDuplicity;
    internal static string CollectionView_ViewTypeInsufficient;
    internal static string CollectionView_WrongType;
    internal static string Collection_NoNull;
    internal static string ColorConvertedBitmapExtensionNoSourceImage;
    internal static string ColorConvertedBitmapExtensionNoSourceProfile;
    internal static string ColorConvertedBitmapExtensionSyntax;
    internal static string CompatibilityPreferencesSealed;
    internal static string ComponentAlreadyInPresentationContext;
    internal static string ComponentNotInPresentationContext;
    internal static string CompositeCollectionResetOnlyOnClear;
    internal static string ConditionCannotUseBothPropertyAndBinding;
    internal static string ConditionValueOfExpressionNotSupported;
    internal static string ConditionValueOfMarkupExtensionNotSupported;
    internal static string ContentControlCannotHaveMultipleContent;
    internal static string ContentTypeNotSupported;
    internal static string ContextMenuInDifferentDispatcher;
    internal static string CopyToNotEnoughSpace;
    internal static string CorePropertyEnumeratorPositionedOutOfBounds;
    internal static string CreateHighlight;
    internal static string CreateInkNote;
    internal static string CreateRootPopup_ChildHasLogicalParent;
    internal static string CreateRootPopup_ChildHasVisualParent;
    internal static string CreateTextNote;
    internal static string CrossThreadAccessOfUnshareableFreezable;
    internal static string CustomContentStateMustBeSerializable;
    internal static string CustomDictionaryFailedToLoadDictionaryUri;
    internal static string CustomDictionaryFailedToUnLoadDictionaryUri;
    internal static string CustomDictionaryItemAlreadyExists;
    internal static string CustomDictionaryNullItem;
    internal static string CustomDictionarySourcesUnsupportedURI;
    internal static string CyclicStyleReferenceDetected;
    internal static string CyclicThemeStyleReferenceDetected;
    internal static string DataGridCellItemAutomationPeer_LocalizedControlType;
    internal static string DataGridCellItemAutomationPeer_NameCoreFormat;
    internal static string DataGridColumnHeaderItemAutomationPeer_NameCoreFormat;
    internal static string DataGridColumnHeaderItemAutomationPeer_Unresizable;
    internal static string DataGridColumnHeaderItemAutomationPeer_Unsupported;
    internal static string DataGridLength_Infinity;
    internal static string DataGridLength_InvalidType;
    internal static string DataGridRow_CannotSelectRowWhenCells;
    internal static string DataGrid_AutomationInvokeFailed;
    internal static string DataGrid_CannotSelectCell;
    internal static string DataGrid_ColumnDisplayIndexOutOfRange;
    internal static string DataGrid_ColumnIndexOutOfRange;
    internal static string DataGrid_ColumnIsReadOnly;
    internal static string DataGrid_DisplayIndexOutOfRange;
    internal static string DataGrid_DuplicateDisplayIndex;
    internal static string DataGrid_InvalidColumnReuse;
    internal static string DataGrid_InvalidSortDescription;
    internal static string DataGrid_NewColumnInvalidDisplayIndex;
    internal static string DataGrid_NullColumn;
    internal static string DataGrid_ProbableInvalidSortDescription;
    internal static string DataGrid_ReadonlyCellsItemsSource;
    internal static string DataTypeCannotBeObject;
    internal static string DatePickerAutomationPeer_LocalizedControlType;
    internal static string DatePickerTextBox_DefaultWatermarkText;
    internal static string DatePickerTextBox_TemplatePartIsOfIncorrectType;
    internal static string DatePicker_DropDownButtonName;
    internal static string DatePicker_OnSelectedDateFormatChanged_InvalidValue;
    internal static string DatePicker_WatermarkText;
    internal static string DeferringLoaderNoContext;
    internal static string DeferringLoaderNoSave;
    internal static string DeferSelectionActive;
    internal static string DeferSelectionNotActive;
    internal static string DeleteAnnotations;
    internal static string DeleteNotes;
    internal static string DeployText;
    internal static string DeployTitle;
    internal static string DesignerMetadata_CustomCategory_Accessibility;
    internal static string DesignerMetadata_CustomCategory_Content;
    internal static string DesignerMetadata_CustomCategory_Navigation;
    internal static string DialogResultMustBeSetAfterShowDialog;
    internal static string DisplayMemberPathAndItemTemplateDefined;
    internal static string DisplayMemberPathAndItemTemplateSelectorDefined;
    internal static string DocumentApplicationCannotInitializeUI;
    internal static string DocumentApplicationContextMenuFirstPageInputGesture;
    internal static string DocumentApplicationContextMenuLastPageInputGesture;
    internal static string DocumentApplicationContextMenuNextPageHeader;
    internal static string DocumentApplicationContextMenuNextPageInputGesture;
    internal static string DocumentApplicationContextMenuPreviousPageHeader;
    internal static string DocumentApplicationContextMenuPreviousPageInputGesture;
    internal static string DocumentApplicationNotInFullTrust;
    internal static string DocumentApplicationRegistryKeyNotFound;
    internal static string DocumentApplicationStatusLoaded;
    internal static string DocumentApplicationUnableToOpenDocument;
    internal static string DocumentApplicationUnknownFileFormat;
    internal static string DocumentGridInvalidViewMode;
    internal static string DocumentGridVisualTreeContainsNonBorderAsFirstElement;
    internal static string DocumentGridVisualTreeContainsNonDocumentGridPage;
    internal static string DocumentGridVisualTreeContainsNonUIElement;
    internal static string DocumentGridVisualTreeOutOfSync;
    internal static string DocumentPageView_ParentNotDocumentPageHost;
    internal static string DocumentReadOnly;
    internal static string DocumentReferenceHasInvalidDocument;
    internal static string DocumentReferenceNotFound;
    internal static string DocumentReferenceUnsupportedMimeType;
    internal static string DocumentStructureUnexpectedParameterType1;
    internal static string DocumentStructureUnexpectedParameterType2;
    internal static string DocumentStructureUnexpectedParameterType4;
    internal static string DocumentStructureUnexpectedParameterType6;
    internal static string DocumentViewerArgumentMustBeInteger;
    internal static string DocumentViewerArgumentMustBePercentage;
    internal static string DocumentViewerCanHaveOnlyOneChild;
    internal static string DocumentViewerChildMustImplementIDocumentPaginatorSource;
    internal static string DocumentViewerOneMasterPage;
    internal static string DocumentViewerOnlySupportsFixedDocumentSequence;
    internal static string DocumentViewerPageViewsCollectionEmpty;
    internal static string DocumentViewerSearchCompleteTitle;
    internal static string DocumentViewerSearchDownCompleteLabel;
    internal static string DocumentViewerSearchUpCompleteLabel;
    internal static string DocumentViewerStyleMustIncludeContentHost;
    internal static string DocumentViewerViewFitToHeightCommandText;
    internal static string DocumentViewerViewFitToMaxPagesAcrossCommandText;
    internal static string DocumentViewerViewFitToWidthCommandText;
    internal static string DocumentViewerViewThumbnailsCommandText;
    internal static string DownloadText;
    internal static string DownloadTitle;
    internal static string DragMoveFail;
    internal static string DuplicatedCompatibleUri;
    internal static string DuplicatedUri;
    internal static string DuplicatesNotAllowed;
    internal static string ElementMustBeInPopup;
    internal static string ElementMustBelongToTemplate;
    internal static string EmptySelectionNotSupported;
    internal static string EndInitWithoutBeginInitNotSupported;
    internal static string EntryAssemblyIsNull;
    internal static string EnumeratorCollectionDisposed;
    internal static string EnumeratorInvalidOperation;
    internal static string EnumeratorNotStarted;
    internal static string EnumeratorReachedEnd;
    internal static string EnumeratorVersionChanged;
    internal static string EventTriggerBadAction;
    internal static string EventTriggerDoesNotEnterExit;
    internal static string EventTriggerDoNotSetProperties;
    internal static string EventTriggerEventUnresolvable;
    internal static string EventTriggerNeedEvent;
    internal static string EventTriggerOnStyleNotAllowedToHaveTarget;
    internal static string EventTriggerTargetNameUnresolvable;
    internal static string ExceptionInGetPage;
    internal static string ExceptionValidationRuleValidateNotSupported;
    internal static string ExpectedBamlSchemaContext;
    internal static string ExpectedBinaryContent;
    internal static string ExpectedResourceDictionaryTarget;
    internal static string FailedResumePageFunction;
    internal static string FailedToConvertResource;
    internal static string FailToLaunchDefaultBrowser;
    internal static string FailToNavigateUsingHyperlinkTarget;
    internal static string FileDialogBufferTooSmall;
    internal static string FileDialogCreatePrompt;
    internal static string FileDialogFileNotFound;
    internal static string FileDialogInvalidFileName;
    internal static string FileDialogInvalidFilter;
    internal static string FileDialogInvalidFilterIndex;
    internal static string FileDialogOverwritePrompt;
    internal static string FileDialogSubClassFailure;
    internal static string FileNameMustNotBeNull;
    internal static string FileNameNullOrEmpty;
    internal static string FileToFilterNotLoaded;
    internal static string FilterBindRegionNotImplemented;
    internal static string FilterEndOfChunks;
    internal static string FilterGetChunkNoStream;
    internal static string FilterGetTextBufferOverflow;
    internal static string FilterGetTextNotSupported;
    internal static string FilterGetValueAlreadyCalledOnCurrentChunk;
    internal static string FilterGetValueMustBeStringOrDateTime;
    internal static string FilterGetValueNotSupported;
    internal static string FilterInitInvalidAttributes;
    internal static string FilterIPersistFileIsReadOnly;
    internal static string FilterIPersistStreamIsReadOnly;
    internal static string FilterLoadInvalidModeFlag;
    internal static string FilterNullGetTextBufferPointer;
    internal static string FilterPropSpecUnknownUnionSelector;
    internal static string FixedDocumentExpectsDependencyObject;
    internal static string FixedDocumentReadonly;
    internal static string FlowDocumentFormattingReentrancy;
    internal static string FlowDocumentInvalidContnetChange;
    internal static string FlowDocumentPageViewerOnlySupportsFlowDocument;
    internal static string FlowDocumentReaderCanHaveOnlyOneChild;
    internal static string FlowDocumentReaderCannotDisableAllViewingModes;
    internal static string FlowDocumentReaderDecoratorMarkedAsContentHostMustHaveNoContent;
    internal static string FlowDocumentReaderViewingModeEnabledConflict;
    internal static string FlowDocumentReader_MultipleViewProvider_PageViewName;
    internal static string FlowDocumentReader_MultipleViewProvider_ScrollViewName;
    internal static string FlowDocumentReader_MultipleViewProvider_TwoPageViewName;
    internal static string FlowDocumentScrollViewerCanHaveOnlyOneChild;
    internal static string FlowDocumentScrollViewerDocumentBelongsToAnotherFlowDocumentScrollViewerAlready;
    internal static string FlowDocumentScrollViewerMarkedAsContentHostMustHaveNoContent;
    internal static string FormatRestrictionsExceeded;
    internal static string FrameNoAddChild;
    internal static string FrameworkElementFactoryAlreadyParented;
    internal static string FrameworkElementFactoryCannotAddText;
    internal static string FrameworkElementFactoryMustBeSealed;
    internal static string GenerationInProgress;
    internal static string GenerationNotInProgress;
    internal static string Generator_CountIsWrong;
    internal static string Generator_Inconsistent;
    internal static string Generator_ItemIsWrong;
    internal static string Generator_MoreErrors;
    internal static string Generator_Readme0;
    internal static string Generator_Readme1;
    internal static string Generator_Readme2;
    internal static string Generator_Readme3;
    internal static string Generator_Readme4;
    internal static string Generator_Readme5;
    internal static string Generator_Readme6;
    internal static string Generator_Readme7;
    internal static string Generator_Readme8;
    internal static string Generator_Readme9;
    internal static string Generator_Unnamed;
    internal static string GetResponseFailed;
    internal static string GetStreamFailed;
    internal static string GlyphsAdvanceWidthCannotBeNegative;
    internal static string GlyphsCaretStopsContainsHexDigits;
    internal static string GlyphsCaretStopsLengthCorrespondsToUnicodeString;
    internal static string GlyphsClusterBadCharactersBeforeBracket;
    internal static string GlyphsClusterMisplacedSeparator;
    internal static string GlyphsClusterNoMatchingBracket;
    internal static string GlyphsClusterNoNestedClusters;
    internal static string GlyphsIndexRequiredIfNoUnicode;
    internal static string GlyphsIndexRequiredWithinCluster;
    internal static string GlyphsTooManyCommas;
    internal static string GlyphsUnicodeStringAndIndicesCannotBothBeEmpty;
    internal static string GlyphsUnicodeStringIsTooShort;
    internal static string GridCollection_CannotModifyReadOnly;
    internal static string GridCollection_DestArrayInvalidLength;
    internal static string GridCollection_DestArrayInvalidLowerBound;
    internal static string GridCollection_DestArrayInvalidRank;
    internal static string GridCollection_InOtherCollection;
    internal static string GridCollection_MustBeCertainType;
    internal static string Grid_UnexpectedParameterType;
    internal static string HandlerTypeIllegal;
    internal static string HasLogicalParent;
    internal static string HostedWindowMustBeAChildWindow;
    internal static string HostingStatusCancelled;
    internal static string HostingStatusDownloadApp;
    internal static string HostingStatusDownloadAppInfo;
    internal static string HostingStatusFailed;
    internal static string HostingStatusPreparingToRun;
    internal static string HostingStatusVerifying;
    internal static string HwndHostDoesNotSupportChildKeyboardSinks;
    internal static string HyperLinkTargetNotFound;
    internal static string HyphenatorDisposed;
    internal static string IconMustBeBitmapFrame;
    internal static string IDPInvalidContentPosition;
    internal static string IDPNegativePageNumber;
    internal static string IllegalTreeChangeDetected;
    internal static string IllegalTreeChangeDetectedPostAction;
    internal static string Illegal_InheritanceBehaviorSettor;
    internal static string ImplementOtherMembersWithSort;
    internal static string InavalidStartItem;
    internal static string IncompatibleCLRText;
    internal static string IncompatibleWinFXText;
    internal static string InconsistentBindingList;
    internal static string IncorrectAnchorLength;
    internal static string IncorrectFlowDirection;
    internal static string IncorrectLocatorPartType;
    internal static string IndexedPropDescNotImplemented;
    internal static string InDifferentParagraphs;
    internal static string InDifferentScope;
    internal static string InDifferentTextContainers;
    internal static string InkCanvasDeselectKeyDisplayString;
    internal static string InputScopeAttribute_E_OUTOFMEMORY;
    internal static string InputStreamMustBeReadable;
    internal static string InsertInDeferSelectionActive;
    internal static string IntegerCollectionLengthLessThanZero;
    internal static string InvalidAnchorPosition;
    internal static string InvalidAttachedAnchor;
    internal static string InvalidAttachedAnnotation;
    internal static string InvalidAttributeValue;
    internal static string InvalidByteRanges;
    internal static string InvalidClipboardFormat;
    internal static string InvalidCompositionTarget;
    internal static string InvalidControlTemplateTargetType;
    internal static string InvalidCtorParameterNoInfinity;
    internal static string InvalidCtorParameterNoNaN;
    internal static string InvalidCtorParameterNoNegative;
    internal static string InvalidCtorParameterUnknownFigureUnitType;
    internal static string InvalidCtorParameterUnknownGridUnitType;
    internal static string InvalidCtorParameterUnknownVirtualizationCacheLengthUnitType;
    internal static string InvalidCustomSerialize;
    internal static string InvalidDeployText;
    internal static string InvalidDeployTitle;
    internal static string InvalidDeSerialize;
    internal static string InvalidDiameter;
    internal static string InvalidDSContentType;
    internal static string InvalidEmptyArray;
    internal static string InvalidEmptyStrokeCollection;
    internal static string InvalidEndOfBaml;
    internal static string InvalidEventHandle;
    internal static string InvalidGuid;
    internal static string InvalidHighlightColor;
    internal static string InvalidInkForeground;
    internal static string InvalidItemContainer;
    internal static string InvalidLocalizabilityValue;
    internal static string InvalidLocatorPart;
    internal static string InvalidLocCommentTarget;
    internal static string InvalidLocCommentValue;
    internal static string InvalidNamespace;
    internal static string InvalidOperationDuringClosing;
    internal static string InvalidOperation_AddBackEntryNoContent;
    internal static string InvalidOperation_CannotClearFwdStack;
    internal static string InvalidOperation_CannotReenterPageFunction;
    internal static string InvalidOperation_CantChangeJournalOwnership;
    internal static string InvalidOperation_IComparerFailed;
    internal static string InvalidOperation_MustImplementIPCCSOrHandleNavigating;
    internal static string InvalidOperation_NoJournal;
    internal static string InvalidPageFunctionType;
    internal static string InvalidPoint;
    internal static string InvalidPropertyValue;
    internal static string InvalidSelectionPages;
    internal static string InvalidSetterValue;
    internal static string InvalidSFContentType;
    internal static string InvalidStartNodeForTextSelection;
    internal static string InvalidStartOfBaml;
    internal static string InvalidStickyNoteAnnotation;
    internal static string InvalidStickyNoteTemplate;
    internal static string InvalidStoryFragmentsMarkup;
    internal static string InvalidStringCornerRadius;
    internal static string InvalidStringThickness;
    internal static string InvalidStringVirtualizationCacheLength;
    internal static string InvalidSubTreeProcessor;
    internal static string InvalidTempFileName;
    internal static string InvalidValueForTopLeft;
    internal static string InvalidValueSpecified;
    internal static string InvalidXmlContent;
    internal static string ItemCollectionHasNoCollection;
    internal static string ItemCollectionRemoveArgumentOutOfRange;
    internal static string ItemCollectionShouldUseInnerSyncRoot;
    internal static string ItemsControl_ParentNotFrameworkElement;
    internal static string ItemsPanelNotAPanel;
    internal static string ItemsPanelNotSingleNode;
    internal static string ItemsSourceInUse;
    internal static string ItemTemplateSelectorBreaksDisplayMemberPath;
    internal static string JumpItemsRejectedEventArgs_CountMismatch;
    internal static string JumpList_CantApplyUntilEndInit;
    internal static string JumpList_CantCallUnbalancedEndInit;
    internal static string JumpList_CantNestBeginInitCalls;
    internal static string KeyAlignCenterDisplayString;
    internal static string KeyAlignJustifyDisplayString;
    internal static string KeyAlignLeftDisplayString;
    internal static string KeyAlignRightDisplayString;
    internal static string KeyAltUndoDisplayString;
    internal static string KeyApplyBackground;
    internal static string KeyApplyBackgroundDisplayString;
    internal static string KeyApplyDoubleSpaceDisplayString;
    internal static string KeyApplyFontFamily;
    internal static string KeyApplyFontFamilyDisplayString;
    internal static string KeyApplyFontSize;
    internal static string KeyApplyFontSizeDisplayString;
    internal static string KeyApplyForeground;
    internal static string KeyApplyForegroundDisplayString;
    internal static string KeyApplyOneAndAHalfSpaceDisplayString;
    internal static string KeyApplySingleSpaceDisplayString;
    internal static string KeyBackspaceDisplayString;
    internal static string KeyCollectionHasInvalidKey;
    internal static string KeyCopyDisplayString;
    internal static string KeyCopyFormatDisplayString;
    internal static string KeyCorrectionList;
    internal static string KeyCorrectionListDisplayString;
    internal static string KeyCtrlInsertDisplayString;
    internal static string KeyCutDisplayString;
    internal static string KeyDecreaseFontSizeDisplayString;
    internal static string KeyDecreaseIndentationDisplayString;
    internal static string KeyDeleteColumnsDisplayString;
    internal static string KeyDeleteDisplayString;
    internal static string KeyDeleteNextWordDisplayString;
    internal static string KeyDeletePreviousWordDisplayString;
    internal static string KeyDeleteRows;
    internal static string KeyDeleteRowsDisplayString;
    internal static string KeyEnterLineBreakDisplayString;
    internal static string KeyEnterParagraphBreakDisplayString;
    internal static string KeyIncreaseFontSizeDisplayString;
    internal static string KeyIncreaseIndentationDisplayString;
    internal static string KeyInsertColumnsDisplayString;
    internal static string KeyInsertRowsDisplayString;
    internal static string KeyInsertTableDisplayString;
    internal static string KeyMergeCellsDisplayString;
    internal static string KeyMoveDownByLineDisplayString;
    internal static string KeyMoveDownByPageDisplayString;
    internal static string KeyMoveDownByParagraphDisplayString;
    internal static string KeyMoveLeftByCharacterDisplayString;
    internal static string KeyMoveLeftByWordDisplayString;
    internal static string KeyMoveRightByCharacterDisplayString;
    internal static string KeyMoveRightByWordDisplayString;
    internal static string KeyMoveToColumnEndDisplayString;
    internal static string KeyMoveToColumnStartDisplayString;
    internal static string KeyMoveToDocumentEndDisplayString;
    internal static string KeyMoveToDocumentStartDisplayString;
    internal static string KeyMoveToLineEndDisplayString;
    internal static string KeyMoveToLineStartDisplayString;
    internal static string KeyMoveToWindowBottomDisplayString;
    internal static string KeyMoveToWindowTopDisplayString;
    internal static string KeyMoveUpByLineDisplayString;
    internal static string KeyMoveUpByPageDisplayString;
    internal static string KeyMoveUpByParagraphDisplayString;
    internal static string KeyPasteFormatDisplayString;
    internal static string KeyRedoDisplayString;
    internal static string KeyRemoveListMarkersDisplayString;
    internal static string KeyResetFormatDisplayString;
    internal static string KeySelectAllDisplayString;
    internal static string KeySelectDownByLineDisplayString;
    internal static string KeySelectDownByPageDisplayString;
    internal static string KeySelectDownByParagraphDisplayString;
    internal static string KeySelectLeftByCharacterDisplayString;
    internal static string KeySelectLeftByWordDisplayString;
    internal static string KeySelectRightByCharacterDisplayString;
    internal static string KeySelectRightByWordDisplayString;
    internal static string KeySelectToColumnEndDisplayString;
    internal static string KeySelectToColumnStartDisplayString;
    internal static string KeySelectToDocumentEndDisplayString;
    internal static string KeySelectToDocumentStartDisplayString;
    internal static string KeySelectToLineEndDisplayString;
    internal static string KeySelectToLineStartDisplayString;
    internal static string KeySelectToWindowBottomDisplayString;
    internal static string KeySelectToWindowTopDisplayString;
    internal static string KeySelectUpByLineDisplayString;
    internal static string KeySelectUpByPageDisplayString;
    internal static string KeySelectUpByParagraphDisplayString;
    internal static string KeyShiftBackspaceDisplayString;
    internal static string KeyShiftDeleteDisplayString;
    internal static string KeyShiftInsertDisplayString;
    internal static string KeyShiftSpaceDisplayString;
    internal static string KeySpaceDisplayString;
    internal static string KeySplitCellDisplayString;
    internal static string KeySwitchViewingModeDisplayString;
    internal static string KeyTabBackwardDisplayString;
    internal static string KeyTabForwardDisplayString;
    internal static string KeyToggleBoldDisplayString;
    internal static string KeyToggleBulletsDisplayString;
    internal static string KeyToggleInsertDisplayString;
    internal static string KeyToggleItalicDisplayString;
    internal static string KeyToggleNumberingDisplayString;
    internal static string KeyToggleSpellCheck;
    internal static string KeyToggleSpellCheckDisplayString;
    internal static string KeyToggleSubscriptDisplayString;
    internal static string KeyToggleSuperscriptDisplayString;
    internal static string KeyToggleUnderlineDisplayString;
    internal static string KeyUndoDisplayString;
    internal static string KillBitEnforcedShutdown;
    internal static string KnownTypeIdNegative;
    internal static string LengthFormatError;
    internal static string ListBoxInvalidAnchorItem;
    internal static string ListBoxSelectAllKeyDisplayString;
    internal static string ListBoxSelectAllSelectionMode;
    internal static string ListBoxSelectAllText;
    internal static string ListElementItemNotAChildOfList;
    internal static string ListView_GridViewColumnCollectionIsReadOnly;
    internal static string ListView_IllegalChildrenType;
    internal static string ListView_MissingParameterlessConstructor;
    internal static string ListView_NotAllowShareColumnToTwoColumnCollection;
    internal static string ListView_ViewCannotBeShared;
    internal static string LogicalTreeLoop;
    internal static string LoopDetected;
    internal static string MarkupExtensionBadStatic;
    internal static string MarkupExtensionDynamicOrBindingInCollection;
    internal static string MarkupExtensionDynamicOrBindingOnClrProp;
    internal static string MarkupExtensionNoContext;
    internal static string MarkupExtensionProperty;
    internal static string MarkupExtensionResourceKey;
    internal static string MarkupExtensionResourceNotFound;
    internal static string MarkupExtensionStaticMember;
    internal static string MarkupWriter_CannotSerializeGenerictype;
    internal static string MarkupWriter_CannotSerializeNestedPublictype;
    internal static string MarkupWriter_CannotSerializeNonPublictype;
    internal static string MaximumNoteSizeExceeded;
    internal static string MaxLengthExceedsBufferSize;
    internal static string MeasureReentrancyInvalid;
    internal static string MediaElement_CannotSetSourceOnMediaElementDrivenByClock;
    internal static string MemberNotAllowedDuringAddOrEdit;
    internal static string MemberNotAllowedDuringTransaction;
    internal static string MemberNotAllowedForView;
    internal static string MissingAnnotationHighlightLayer;
    internal static string MissingContentSource;
    internal static string MissingTagInNamespace;
    internal static string MissingTriggerProperty;
    internal static string MissingValueConverter;
    internal static string ModificationEarlierThanCreation;
    internal static string ModifyingLogicalTreeViaStylesNotImplemented;
    internal static string MoreThanOneAttachedAnnotation;
    internal static string MoreThanOneStartingParts;
    internal static string MoveInDeferSelectionActive;
    internal static string MultiBindingHasNoConverter;
    internal static string MultipleAssemblyMatches;
    internal static string MultiSelectorSelectAll;
    internal static string MultiSingleton;
    internal static string MultiThreadedCollectionChangeNotSupported;
    internal static string MustBaseOnStyleOfABaseType;
    internal static string MustBeCondition;
    internal static string MustBeFrameworkDerived;
    internal static string MustBeFrameworkOr3DDerived;
    internal static string MustBeOfType;
    internal static string MustBeTriggerAction;
    internal static string MustBeTypeOrString;
    internal static string MustImplementIUriContext;
    internal static string MustNotTemplateUnassociatedControl;
    internal static string MustUseWindowStyleNone;
    internal static string NamedObjectMustBeFrameworkElement;
    internal static string NameNotEmptyString;
    internal static string NameNotFound;
    internal static string NameScopeDuplicateNamesNotAllowed;
    internal static string NameScopeInvalidIdentifierName;
    internal static string NameScopeNameNotEmptyString;
    internal static string NameScopeNameNotFound;
    internal static string NameScopeNotFound;
    internal static string NamesNotSupportedInsideResourceDictionary;
    internal static string NavWindowMenuCurrentPage;
    internal static string NeedToBeComVisible;
    internal static string NegativeValue;
    internal static string NestedBeginInitNotSupported;
    internal static string NoAddChild;
    internal static string NoAttachedAnnotationToModify;
    internal static string NoBackEntry;
    internal static string NoCheckOrChangeWhenDeferred;
    internal static string NoDefaultUpdateSourceTrigger;
    internal static string NoElement;
    internal static string NoElementObject;
    internal static string NoForwardEntry;
    internal static string NoMulticastHandlers;
    internal static string NonClsActivationException;
    internal static string NonCLSException;
    internal static string NonPackAppAbsoluteUriNotAllowed;
    internal static string NonPackSooAbsoluteUriNotAllowed;
    internal static string NonWhiteSpaceInAddText;
    internal static string NoPresentationContextForGivenElement;
    internal static string NoProcessorForSelectionType;
    internal static string NoScopingElement;
    internal static string NotAllowedBeforeShow;
    internal static string NotHighlightAnnotationType;
    internal static string NotInAssociatedContainer;
    internal static string NotInAssociatedTree;
    internal static string NotInThisTree;
    internal static string NotSupported;
    internal static string NotSupportedInBrowser;
    internal static string NoUpdateSourceTriggerForInnerBindingOfMultiBinding;
    internal static string NullParentNode;
    internal static string NullPropertyIllegal;
    internal static string NullTypeIllegal;
    internal static string NullUri;
    internal static string ObjectDataProviderCanHaveOnlyOneSource;
    internal static string ObjectDataProviderHasNoSource;
    internal static string ObjectDataProviderNonCLSException;
    internal static string ObjectDataProviderNonCLSExceptionInvoke;
    internal static string ObjectDataProviderParameterCollectionIsNotInUse;
    internal static string ObjectDisposed_StoreClosed;
    internal static string OnlyFlowAndFixedSupported;
    internal static string OnlyFlowFixedSupported;
    internal static string PageCacheSizeNotAllowed;
    internal static string PageCannotHaveMultipleContent;
    internal static string PageContentNotFound;
    internal static string PageContentUnsupportedMimeType;
    internal static string PageContentUnsupportedPageType;
    internal static string PanelIsNotItemsHost;
    internal static string Panel_BoundPanel_NoChildren;
    internal static string Panel_ItemsControlNotFound;
    internal static string Panel_NoNullChildren;
    internal static string Panel_NoNullVisualParent;
    internal static string ParameterMustBeLogicalNode;
    internal static string ParentOfPageMustBeWindowOrFrame;
    internal static string ParserAbandonedTypeConverterText;
    internal static string ParserAsyncOnRoot;
    internal static string ParserAttachedPropInheritError;
    internal static string ParserAttributeArgsLow;
    internal static string ParserAttributeNamespaceMisMatch;
    internal static string ParserBadAssemblyName;
    internal static string ParserBadAssemblyPath;
    internal static string ParserBadChild;
    internal static string ParserBadConstructorParams;
    internal static string ParserBadEncoding;
    internal static string ParserBadKey;
    internal static string ParserBadMemberReference;
    internal static string ParserBadName;
    internal static string ParserBadNullableType;
    internal static string ParserBadString;
    internal static string ParserBadSyncMode;
    internal static string ParserBadTypeInArrayProperty;
    internal static string ParserBadUidOrNameME;
    internal static string ParserBamlEvent;
    internal static string ParserBamlVersion;
    internal static string ParserCannotAddAnyChildren;
    internal static string ParserCannotAddAnyChildren2;
    internal static string ParserCannotAddChild;
    internal static string ParserCannotConvertInitializationText;
    internal static string ParserCannotConvertPropertyValue;
    internal static string ParserCannotConvertPropertyValueString;
    internal static string ParserCannotConvertString;
    internal static string ParserCannotReuseXamlReader;
    internal static string ParserCannotSetValue;
    internal static string ParserCanOnlyHaveOneChild;
    internal static string ParserCantCreateDelegate;
    internal static string ParserCantCreateInstanceType;
    internal static string ParserCantCreateTextComplexProp;
    internal static string ParserCantGetDPOrPi;
    internal static string ParserCantGetProperty;
    internal static string ParserCantSetAttribute;
    internal static string ParserCantSetContentProperty;
    internal static string ParserCantSetTriggerCondition;
    internal static string ParserCompatDuplicate;
    internal static string ParserContentMustBeContiguous;
    internal static string ParserDefaultConverterElement;
    internal static string ParserDefaultConverterProperty;
    internal static string ParserDeferContentAsync;
    internal static string ParserDefSharedOnlyInCompiled;
    internal static string ParserDefTag;
    internal static string ParserDictionarySealed;
    internal static string ParserDupDictionaryKey;
    internal static string ParserDuplicateMarkupExtensionProperty;
    internal static string ParserDuplicateProperty1;
    internal static string ParserDuplicateProperty2;
    internal static string ParserEmptyComplexProp;
    internal static string ParserEntityReference;
    internal static string ParserErrorContext_File;
    internal static string ParserErrorContext_File_Line;
    internal static string ParserErrorContext_Line;
    internal static string ParserErrorContext_Type;
    internal static string ParserErrorContext_Type_File;
    internal static string ParserErrorContext_Type_File_Line;
    internal static string ParserErrorContext_Type_Line;
    internal static string ParserErrorCreatingInstance;
    internal static string ParserErrorParsingAttrib;
    internal static string ParserErrorParsingAttribType;
    internal static string ParserEventDelegateTypeNotAccessible;
    internal static string ParserFailedEndInit;
    internal static string ParserFailedToCreateFromConstructor;
    internal static string ParserFailFindType;
    internal static string ParserFilterXmlReaderNoDefinitionPrefixChangeAllowed;
    internal static string ParserFilterXmlReaderNoIndexAttributeAccess;
    internal static string ParserIAddChildText;
    internal static string ParserIEnumerableIAddChild;
    internal static string ParserInvalidContentPropertyAttribute;
    internal static string ParserInvalidIdentifierName;
    internal static string ParserInvalidStaticMember;
    internal static string ParserKeyOnExplicitDictionary;
    internal static string ParserKeysAreStrings;
    internal static string ParserLineAndOffset;
    internal static string ParserMapPIMissingAssembly;
    internal static string ParserMapPIMissingKey;
    internal static string ParserMappingUriInvalid;
    internal static string ParserMarkupExtensionBadConstructorParam;
    internal static string ParserMarkupExtensionBadDelimiter;
    internal static string ParserMarkupExtensionDelimiterBeforeFirstAttribute;
    internal static string ParserMarkupExtensionInvalidClosingBracketCharacers;
    internal static string ParserMarkupExtensionMalformedBracketCharacers;
    internal static string ParserMarkupExtensionNoEndCurlie;
    internal static string ParserMarkupExtensionNoNameValue;
    internal static string ParserMarkupExtensionNoQuotesInName;
    internal static string ParserMarkupExtensionTrailingGarbage;
    internal static string ParserMarkupExtensionUnknownAttr;
    internal static string ParserMetroUnknownAttribute;
    internal static string ParserMultiBamls;
    internal static string ParserMultiRoot;
    internal static string ParserNestedComplexProp;
    internal static string ParserNoAttrArray;
    internal static string ParserNoChildrenTag;
    internal static string ParserNoComplexMulti;
    internal static string ParserNoDefaultConstructor;
    internal static string ParserNoDefaultPropConstructor;
    internal static string ParserNoDictionaryKey;
    internal static string ParserNoDictionaryName;
    internal static string ParserNoDigitEnums;
    internal static string ParserNoDPOnOwner;
    internal static string ParserNoElementCreate2;
    internal static string ParserNoEvents;
    internal static string ParserNoEventTag;
    internal static string ParserNoMatchingArray;
    internal static string ParserNoMatchingIDictionary;
    internal static string ParserNoMatchingIList;
    internal static string ParserNoNameOnType;
    internal static string ParserNoNamespace;
    internal static string ParserNoNameUnderDefinitionScopeType;
    internal static string ParserNoNestedXmlDataIslands;
    internal static string ParserNoPropOnComplexProp;
    internal static string ParserNoPropType;
    internal static string ParserNoResource;
    internal static string ParserNoSerializer;
    internal static string ParserNoSetterChild;
    internal static string ParserNotAllowedInternalType;
    internal static string ParserNotMarkedPublic;
    internal static string ParserNotMarkupExtension;
    internal static string ParserNoType;
    internal static string ParserNoTypeConv;
    internal static string ParserNullPropertyCollection;
    internal static string ParserNullReturned;
    internal static string ParserOwnerEventMustBePublic;
    internal static string ParserParentDO;
    internal static string ParserPrefixNSElement;
    internal static string ParserPrefixNSProperty;
    internal static string ParserPropertyCollectionClosed;
    internal static string ParserPropNoValue;
    internal static string ParserProvideValueCantSetUri;
    internal static string ParserPublicType;
    internal static string ParserReadOnlyNullProperty;
    internal static string ParserReadOnlyProp;
    internal static string ParserResourceKeyType;
    internal static string ParserSyncOnRoot;
    internal static string ParserTextInComplexProp;
    internal static string ParserTextInvalidInArrayOrDictionary;
    internal static string ParserTooManyAssemblies;
    internal static string ParserTypeConverterTextNeedsEndElement;
    internal static string ParserTypeConverterTextUnusable;
    internal static string ParserUndeclaredNS;
    internal static string ParserUnexpectedEndEle;
    internal static string ParserUnexpInBAML;
    internal static string ParserUnknownAttribute;
    internal static string ParserUnknownBaml;
    internal static string ParserUnknownDefAttribute;
    internal static string ParserUnknownDefAttributeCompiler;
    internal static string ParserUnknownPresentationOptionsAttribute;
    internal static string ParserUnknownTag;
    internal static string ParserUnknownXmlType;
    internal static string ParserWriterNoSeekEnd;
    internal static string ParserWriterUnknownOrigin;
    internal static string ParserXmlIslandMissing;
    internal static string ParserXmlIslandUnexpected;
    internal static string ParserXmlLangPropertyValueInvalid;
    internal static string ParserXmlReaderNoLineInfo;
    internal static string PartialTrustPrintDialogMustBeInvoked;
    internal static string PasswordBoxInvalidTextContainer;
    internal static string PathParameterIsNull;
    internal static string PathParametersIndexOutOfRange;
    internal static string PathSyntax;
    internal static string PlatformRequirementTitle;
    internal static string PopupReopeningNotAllowed;
    internal static string PositionalArgumentsWrongLength;
    internal static string PrevoiusPartialPageContentOutstanding;
    internal static string PrevoiusUninitializedDocumentReferenceOutstanding;
    internal static string PrintDialogInstallPrintSupportCaption;
    internal static string PrintDialogInstallPrintSupportMessageBox;
    internal static string PrintDialogInvalidPageRange;
    internal static string PrintDialogPageRange;
    internal static string PrintDialogZeroNotAllowed;
    internal static string PrintJobDescription;
    internal static string ProgressBarReadOnly;
    internal static string PropertyFoundOutsideStartElement;
    internal static string PropertyIdOutOfSequence;
    internal static string PropertyIsImmutable;
    internal static string PropertyIsInitializeOnly;
    internal static string PropertyMustHaveValue;
    internal static string PropertyNotBindable;
    internal static string PropertyNotFound;
    internal static string PropertyNotSupported;
    internal static string PropertyOutOfOrder;
    internal static string PropertyPathIndexWrongType;
    internal static string PropertyPathInvalidAccessor;
    internal static string PropertyPathNoOwnerType;
    internal static string PropertyPathNoProperty;
    internal static string PropertyPathSyntaxError;
    internal static string PropertyToSortByNotFoundOnType;
    internal static string PropertyTriggerCycleDetected;
    internal static string PropertyTriggerLayerLimitExceeded;
    internal static string PTSError;
    internal static string PTSInvalidHandle;
    internal static string RangeActionsNotSupported;
    internal static string ReadCountNegative;
    internal static string ReadNotSupported;
    internal static string ReadOnlyPropertyNotAllowed;
    internal static string RecordOutOfOrder;
    internal static string Rect_WidthAndHeightCannotBeNegative;
    internal static string RelativeSourceInvalidAncestorLevel;
    internal static string RelativeSourceModeInvalid;
    internal static string RelativeSourceModeIsImmutable;
    internal static string RelativeSourceNeedsAncestorType;
    internal static string RelativeSourceNeedsMode;
    internal static string RelativeSourceNotInFindAncestorMode;
    internal static string RemovedItemNotFound;
    internal static string RemoveRequiresOffsetZero;
    internal static string RemoveRequiresPositiveCount;
    internal static string RemovingPlaceholder;
    internal static string ReparentModelChildIllegal;
    internal static string RequestNavigateEventMustHaveRoutedEvent;
    internal static string RequiredAttributeMissing;
    internal static string RequiresExplicitCulture;
    internal static string RequiresXmlNamespaceMapping;
    internal static string RequiresXmlNamespaceMappingUri;
    internal static string ReshowNotAllowed;
    internal static string ResourceDictionaryDeferredContentFailure;
    internal static string ResourceDictionaryDuplicateDeferredContent;
    internal static string ResourceDictionaryInvalidMergedDictionary;
    internal static string ResourceDictionaryIsReadOnly;
    internal static string ResourceDictionaryLoadFromFailure;
    internal static string ReturnEventHandlerMustBeOnParentPage;
    internal static string RichTextBox_CantSetDocumentInsideChangeBlock;
    internal static string RichTextBox_DocumentBelongsToAnotherRichTextBoxAlready;
    internal static string RichTextBox_PointerNotInSameDocument;
    internal static string RowCacheCannotModifyNonExistentLayout;
    internal static string RowCachePageNotFound;
    internal static string RowCacheRecalcWithNoPageCache;
    internal static string RuntimeTypeRequired;
    internal static string ScrollBar_ContextMenu_Bottom;
    internal static string ScrollBar_ContextMenu_LeftEdge;
    internal static string ScrollBar_ContextMenu_PageDown;
    internal static string ScrollBar_ContextMenu_PageLeft;
    internal static string ScrollBar_ContextMenu_PageRight;
    internal static string ScrollBar_ContextMenu_PageUp;
    internal static string ScrollBar_ContextMenu_RightEdge;
    internal static string ScrollBar_ContextMenu_ScrollDown;
    internal static string ScrollBar_ContextMenu_ScrollHere;
    internal static string ScrollBar_ContextMenu_ScrollLeft;
    internal static string ScrollBar_ContextMenu_ScrollRight;
    internal static string ScrollBar_ContextMenu_ScrollUp;
    internal static string ScrollBar_ContextMenu_Top;
    internal static string ScrollViewer_CannotBeNaN;
    internal static string ScrollViewer_OutOfRange;
    internal static string SeekFailed;
    internal static string SeekNegative;
    internal static string SeekNotSupported;
    internal static string SelectedCellsCollection_DuplicateItem;
    internal static string SelectedCellsCollection_InvalidItem;
    internal static string SelectionChangeActive;
    internal static string SelectionChangeNotActive;
    internal static string SelectionDoesNotResolveToAPage;
    internal static string SelectionMustBeServiceProvider;
    internal static string SerializerProviderAlreadyRegistered;
    internal static string SerializerProviderCannotLoad;
    internal static string SerializerProviderDefaultFileExtensionNull;
    internal static string SerializerProviderDisplayNameNull;
    internal static string SerializerProviderManufacturerNameNull;
    internal static string SerializerProviderManufacturerWebsiteNull;
    internal static string SerializerProviderNotRegistered;
    internal static string SerializerProviderUnknownSerializer;
    internal static string SerializerProviderWrongVersion;
    internal static string SetFocusFailed;
    internal static string SetInDeferSelectionActive;
    internal static string SetLengthNotSupported;
    internal static string SetPositionNotSupported;
    internal static string SetterOnStyleNotAllowedToHaveTarget;
    internal static string SetterValueCannotBeUnset;
    internal static string SetterValueOfMarkupExtensionNotSupported;
    internal static string SharedAttributeInLooseXaml;
    internal static string ShowDialogOnModal;
    internal static string ShowDialogOnVisible;
    internal static string ShowNonActivatedAndMaximized;
    internal static string ShutdownModeWhenAppShutdown;
    internal static string SourceNameNotSupportedForDataTriggers;
    internal static string SourceNameNotSupportedForStyleTriggers;
    internal static string Stack_VisualInDifferentSubTree;
    internal static string StartIndexExceedsBufferSize;
    internal static string StartNodeMustBeDocumentPageViewOrFixedPage;
    internal static string StartNodeMustBeFixedPageProxy;
    internal static string StaticResourceInXamlOnly;
    internal static string Storyboard_AnimationMismatch;
    internal static string Storyboard_BeginStoryboardNameNotFound;
    internal static string Storyboard_BeginStoryboardNameRequired;
    internal static string Storyboard_BeginStoryboardNoStoryboard;
    internal static string Storyboard_ComplexPathNotSupported;
    internal static string Storyboard_ImmutableTargetNotSupported;
    internal static string Storyboard_MediaElementNotFound;
    internal static string Storyboard_MediaElementRequired;
    internal static string Storyboard_NameNotFound;
    internal static string Storyboard_NeverApplied;
    internal static string Storyboard_NoNameScope;
    internal static string Storyboard_NoTarget;
    internal static string Storyboard_PropertyPathEmpty;
    internal static string Storyboard_PropertyPathFrozenCheckFailed;
    internal static string Storyboard_PropertyPathIncludesNonAnimatableProperty;
    internal static string Storyboard_PropertyPathMustPointToDependencyObject;
    internal static string Storyboard_PropertyPathMustPointToDependencyProperty;
    internal static string Storyboard_PropertyPathObjectNotFound;
    internal static string Storyboard_PropertyPathPropertyNotFound;
    internal static string Storyboard_PropertyPathSealedCheckFailed;
    internal static string Storyboard_PropertyPathUnresolved;
    internal static string Storyboard_StoryboardReferenceRequired;
    internal static string Storyboard_TargetNameNotAllowedInStyle;
    internal static string Storyboard_TargetNameNotDependencyObject;
    internal static string Storyboard_TargetPropertyRequired;
    internal static string Storyboard_UnableToFreeze;
    internal static string Storyboard_UnrecognizedHandoffBehavior;
    internal static string Storyboard_UnrecognizedTimeSeekOrigin;
    internal static string StreamCannotBeWritten;
    internal static string StreamDoesNotSupportSeek;
    internal static string StreamDoesNotSupportWrite;
    internal static string StreamNotSet;
    internal static string StreamObjectDisposed;
    internal static string StringIdOutOfSequence;
    internal static string StyleBasedOnHasLoop;
    internal static string StyleCannotBeBasedOnSelf;
    internal static string StyleDataTriggerBindingHasBadValue;
    internal static string StyleDataTriggerBindingMissing;
    internal static string StyleForWrongType;
    internal static string StyleHasTooManyElements;
    internal static string StyleImpliedAndComplexChildren;
    internal static string StyleInvalidElementTag;
    internal static string StyleKnownTagWrongLocation;
    internal static string StyleNoClrEvent;
    internal static string StyleNoDef;
    internal static string StyleNoDictionaryKey;
    internal static string StyleNoEventSetters;
    internal static string StyleNoPropOrEvent;
    internal static string StyleNoSetterResource;
    internal static string StyleNoTarget;
    internal static string StyleNoTemplateBindInSetters;
    internal static string StyleNoTemplateBindInVisualTrigger;
    internal static string StyleNoTopLevelElement;
    internal static string StylePropertyCustom;
    internal static string StylePropertyInStyleNotAllowed;
    internal static string StylePropertySetterMinAttrs;
    internal static string StylePropTriggerPropMissing;
    internal static string StyleSetterUnknownProp;
    internal static string StyleTagNotSupported;
    internal static string StyleTargetTypeMismatchWithElement;
    internal static string StyleTextNotSupported;
    internal static string StyleTriggersCannotTargetTheTemplate;
    internal static string StyleUnknownProp;
    internal static string StyleUnknownTrigger;
    internal static string StyleValueOfExpressionNotSupported;
    internal static string SystemResourceForTypeIsNotStyle;
    internal static string TableCollectionCountNeedNonNegNum;
    internal static string TableCollectionElementTypeExpected;
    internal static string TableCollectionInOtherCollection;
    internal static string TableCollectionInvalidOffLen;
    internal static string TableCollectionNotEnoughCapacity;
    internal static string TableCollectionOutOfRange;
    internal static string TableCollectionOutOfRangeNeedNonNegNum;
    internal static string TableCollectionRangeOutOfRange;
    internal static string TableCollectionRankMultiDimNotSupported;
    internal static string TableCollectionWrongProxyParent;
    internal static string TableInvalidParentNodeType;
    internal static string TargetNameNotFound;
    internal static string TargetNameNotSupportedForStyleSetters;
    internal static string Template3DValueOnly;
    internal static string TemplateBadDictionaryKey;
    internal static string TemplateCannotHaveNestedContentPresenterAndGridViewRowPresenter;
    internal static string TemplateChildIndexOutOfRange;
    internal static string TemplateCircularReferenceFound;
    internal static string TemplateContentSetTwice;
    internal static string TemplateDupName;
    internal static string TemplateFindNameInInvalidElement;
    internal static string TemplateHasNestedNameScope;
    internal static string TemplateInvalidBamlRecord;
    internal static string TemplateInvalidRootElementTag;
    internal static string TemplateKnownTagWrongLocation;
    internal static string TemplateMustBeFE;
    internal static string TemplateNoMultipleRoots;
    internal static string TemplateNoProp;
    internal static string TemplateNoTarget;
    internal static string TemplateNoTemplateBindInVisualTrigger;
    internal static string TemplateNoTriggerTarget;
    internal static string TemplateNotTargetType;
    internal static string TemplateTagNotSupported;
    internal static string TemplateTargetTypeMismatch;
    internal static string TemplateTextNotSupported;
    internal static string TemplateUnknownProp;
    internal static string TextBoxBase_CantSetIsUndoEnabledInsideChangeBlock;
    internal static string TextBoxBase_UnmatchedEndChange;
    internal static string TextBoxDecoratorMarkedAsTextBoxContentMustHaveNoContent;
    internal static string TextBoxInvalidChild;
    internal static string TextBoxInvalidTextContainer;
    internal static string TextBoxMinMaxLinesMismatch;
    internal static string TextBoxScrollViewerMarkedAsTextBoxContentMustHaveNoContent;
    internal static string TextBox_ContextMenu_Copy;
    internal static string TextBox_ContextMenu_Cut;
    internal static string TextBox_ContextMenu_Description_DBCSSpace;
    internal static string TextBox_ContextMenu_Description_SBCSSpace;
    internal static string TextBox_ContextMenu_IgnoreAll;
    internal static string TextBox_ContextMenu_More;
    internal static string TextBox_ContextMenu_NoSpellingSuggestions;
    internal static string TextBox_ContextMenu_Paste;
    internal static string TextContainerChangingReentrancyInvalid;
    internal static string TextContainerDoesNotContainElement;
    internal static string TextContainer_UndoManagerCreatedMoreThanOnce;
    internal static string TextEditorCanNotRegisterCommandHandler;
    internal static string TextEditorCopyPaste_EntryPartIsMissingInXamlPackage;
    internal static string TextEditorPropertyIsNotApplicableForTextFormatting;
    internal static string TextEditorSpellerInteropHasBeenDisposed;
    internal static string TextEditorTypeOfParameterIsNotAppropriateForFormattingProperty;
    internal static string TextElementCollection_CannotCopyToArrayNotSufficientMemory;
    internal static string TextElementCollection_IndexOutOfRange;
    internal static string TextElementCollection_ItemHasUnexpectedType;
    internal static string TextElementCollection_NextSiblingDoesNotBelongToThisCollection;
    internal static string TextElementCollection_NoEnumerator;
    internal static string TextElementCollection_PreviousSiblingDoesNotBelongToThisCollection;
    internal static string TextElementCollection_TextElementTypeExpected;
    internal static string TextElement_UnmatchedEndPointer;
    internal static string TextPanelIllegalParaTypeForIAddChild;
    internal static string TextPointer_CannotInsertTextElementBecauseItBelongsToAnotherTree;
    internal static string TextPositionIsFrozen;
    internal static string TextProvider_InvalidChildElement;
    internal static string TextProvider_InvalidPoint;
    internal static string TextProvider_TextSelectionNotSupported;
    internal static string TextRangeEdit_InvalidStructuralPropertyApply;
    internal static string TextRangeProvider_EmptyStringParameter;
    internal static string TextRangeProvider_InvalidParameterValue;
    internal static string TextRangeProvider_WrongTextRange;
    internal static string TextRange_InvalidParameterValue;
    internal static string TextRange_PropertyCannotBeIncrementedOrDecremented;
    internal static string TextRange_UnrecognizedStructureInDataFormat;
    internal static string TextRange_UnsupportedDataFormat;
    internal static string TextSchema_CannotInsertContentInThisPosition;
    internal static string TextSchema_CannotSplitElement;
    internal static string TextSchema_ChildTypeIsInvalid;
    internal static string TextSchema_IllegalElement;
    internal static string TextSchema_IllegalHyperlinkChild;
    internal static string TextSchema_TextIsNotAllowed;
    internal static string TextSchema_TextIsNotAllowedInThisContext;
    internal static string TextSchema_TheChildElementBelongsToAnotherTreeAlready;
    internal static string TextSchema_ThisBlockUIContainerHasAChildUIElementAlready;
    internal static string TextSchema_ThisInlineUIContainerHasAChildUIElementAlready;
    internal static string TextSchema_UIElementNotAllowedInThisPosition;
    internal static string TextSegmentsMustNotOverlap;
    internal static string TextStore_BadIMECharOffset;
    internal static string TextStore_BadLockFlags;
    internal static string TextStore_CompositionRejected;
    internal static string TextStore_CONNECT_E_CANNOTCONNECT;
    internal static string TextStore_CONNECT_E_NOCONNECTION;
    internal static string TextStore_E_NOINTERFACE;
    internal static string TextStore_E_NOTIMPL;
    internal static string TextStore_NoSink;
    internal static string TextStore_ReentrantRequestLock;
    internal static string TextStore_TS_E_FORMAT;
    internal static string TextStore_TS_E_INVALIDPOINT;
    internal static string TextStore_TS_E_NOLAYOUT;
    internal static string TextStore_TS_E_READONLY;
    internal static string TextViewInvalidLayout;
    internal static string ThemeDictionaryExtension_Name;
    internal static string ThemeDictionaryExtension_Source;
    internal static string ToolBar_InvalidStyle_ToolBarOverflowPanel;
    internal static string ToolBar_InvalidStyle_ToolBarPanel;
    internal static string ToolTipStaysOpenFalseNotAllowed;
    internal static string ToStringFormatString_Control;
    internal static string ToStringFormatString_GridView;
    internal static string ToStringFormatString_GridViewColumn;
    internal static string ToStringFormatString_GridViewRowPresenter;
    internal static string ToStringFormatString_GridViewRowPresenterBase;
    internal static string ToStringFormatString_HeaderedContentControl;
    internal static string ToStringFormatString_HeaderedItemsControl;
    internal static string ToStringFormatString_ItemsControl;
    internal static string ToStringFormatString_RangeBase;
    internal static string ToStringFormatString_ToggleButton;
    internal static string Track_SameButtons;
    internal static string TransformNotSupported;
    internal static string TriggerActionAlreadySealed;
    internal static string TriggerActionMustBelongToASingleTrigger;
    internal static string TriggerOnStyleNotAllowedToHaveSource;
    internal static string TriggersSupportsEventTriggersOnly;
    internal static string TrustNotGrantedText;
    internal static string TrustNotGrantedTitle;
    internal static string TwoWayBindingNeedsPath;
    internal static string TypeIdOutOfSequence;
    internal static string TypeMustImplementIAddChild;
    internal static string TypeNameMustBeSpecified;
    internal static string TypeValueSerializerUnavailable;
    internal static string UIA_OperationCannotBePerformed;
    internal static string UiLessPageFunctionNotCallingOnReturn;
    internal static string UnableToConvertInt32;
    internal static string UnableToLocateResource;
    internal static string UndefinedHighlightAnchor;
    internal static string UndoContainerTypeMismatch;
    internal static string UndoManagerAlreadyAttached;
    internal static string UndoNoOpenParentUnit;
    internal static string UndoNoOpenUnit;
    internal static string UndoNotInNormalState;
    internal static string UndoServiceDisabled;
    internal static string UndoUnitAlreadyOpen;
    internal static string UndoUnitCantBeAddedTwice;
    internal static string UndoUnitCantBeOpenedTwice;
    internal static string UndoUnitLocked;
    internal static string UndoUnitNotFound;
    internal static string UndoUnitNotOnTopOfStack;
    internal static string UndoUnitOpen;
    internal static string UnexpectedAttribute;
    internal static string UnexpectedCollectionChangeAction;
    internal static string UnexpectedProperty;
    internal static string UnexpectedType;
    internal static string UnexpectedValueTypeForCondition;
    internal static string UnexpectedValueTypeForDataTrigger;
    internal static string UnexpectedXmlNodeInXmlFixedPageInfoConstructor;
    internal static string UnknownBamlRecord;
    internal static string UnknownContainerFormat;
    internal static string UnknownErrorText;
    internal static string UnknownErrorTitle;
    internal static string UnknownIndexType;
    internal static string UnmatchedBracket;
    internal static string UnmatchedLocComment;
    internal static string UnmatchedParen;
    internal static string UnRecognizedBamlNodeType;
    internal static string UnserializableKeyValue;
    internal static string UnsupportedTriggerInStyle;
    internal static string UnsupportedTriggerInTemplate;
    internal static string Untitled;
    internal static string UntitledPrintJobDescription;
    internal static string UriNotMatchWithRootType;
    internal static string ValidationRule_UnexpectedValue;
    internal static string ValidationRule_UnknownStep;
    internal static string Validation_ConversionFailed;
    internal static string ValueMustBeXamlReader;
    internal static string ValueNotBetweenInt32MinMax;
    internal static string ValueSerializerContextUnavailable;
    internal static string VirtualizedCellInfoCollection_DoesNotSupportIndexChanges;
    internal static string VirtualizedCellInfoCollection_IsReadOnly;
    internal static string VirtualizedElement;
    internal static string VisualTreeRootIsFrameworkElement;
    internal static string VisualTriggerSettersIncludeUnsupportedSetterType;
    internal static string WebBrowserNoCastToIWebBrowser2;
    internal static string WebBrowserOverlap;
    internal static string WebRequestCreationFailed;
    internal static string WindowAlreadyClosed;
    internal static string WindowMustBeRoot;
    internal static string WindowPassedShouldBeOnApplicationThread;
    internal static string WpfPayload_InvalidImageSource;
    internal static string WriteNotSupported;
    internal static string WrongNavigateRootElement;
    internal static string WrongSelectionType;
    internal static string XamlFilterNestedFixedPage;
    internal static string XmlGlyphRunInfoIsNonGraphic;
    internal static string XmlNodeAlreadyOwned;
    internal static string XpsValidatingLoaderDiscardControlHasIncorrectType;
    internal static string XpsValidatingLoaderDuplicateReference;
    internal static string XpsValidatingLoaderMoreThanOneDiscardControlInPackage;
    internal static string XpsValidatingLoaderMoreThanOnePrintTicketPart;
    internal static string XpsValidatingLoaderMoreThanOneThumbnailInPackage;
    internal static string XpsValidatingLoaderMoreThanOneThumbnailPart;
    internal static string XpsValidatingLoaderPrintTicketHasIncorrectType;
    internal static string XpsValidatingLoaderRestrictedFontHasIncorrectType;
    internal static string XpsValidatingLoaderThumbnailHasIncorrectType;
    internal static string XpsValidatingLoaderUnlistedResource;
    internal static string XpsValidatingLoaderUnsupportedEncoding;
    internal static string XpsValidatingLoaderUnsupportedMimeType;
    internal static string XpsValidatingLoaderUnsupportedRootNamespaceUri;
    internal static string XpsValidatingLoaderUriNotInSamePackage;
    internal static string Animation_ChildMustBeKeyFrame;
    internal static string Animation_InvalidAnimationUsingKeyFramesDuration;
    internal static string Animation_InvalidBaseValue;
    internal static string Animation_InvalidResolvedKeyTimes;
    internal static string Animation_InvalidTimeKeyTime;
    internal static string Animation_Invalid_DefaultValue;
    internal static string Animation_NoTextChildren;
    internal static string BrowserHostingNotSupported;
    internal static string CannotConvertStringToType;
    internal static string CannotConvertType;
    internal static string CannotModifyReadOnlyContainer;
    internal static string CannotRetrievePartsOfWriteOnlyContainer;
    internal static string CollectionNumberOfElementsMustBeLessOrEqualTo;
    internal static string Collection_BadType;
    internal static string Collection_CopyTo_ArrayCannotBeMultidimensional;
    internal static string Collection_CopyTo_IndexGreaterThanOrEqualToArrayLength;
    internal static string Collection_CopyTo_NumberOfElementsExceedsArrayLength;
    internal static string Enumerator_VerifyContext;
    internal static string Enum_Invalid;
    internal static string FileFormatException;
    internal static string FileFormatExceptionWithFileName;
    internal static string Freezable_CantBeFrozen;
    internal static string InvalidPermissionStateValue;
    internal static string InvalidPermissionType;
    internal static string ParameterCannotBeNegative;
    internal static string SecurityExceptionForSettingSandboxExternalToTrue;
    internal static string StringEmpty;
    internal static string TokenizerHelperEmptyToken;
    internal static string TokenizerHelperExtraDataEncountered;
    internal static string TokenizerHelperMissingEndQuote;
    internal static string TokenizerHelperPrematureStringTermination;
    internal static string TypeMetadataCannotChangeAfterUse;
    internal static string UnexpectedParameterType;
    internal static string Visual_ArgumentOutOfRange;
    internal static ResourceManager ResourceManager { get; }
    internal static CultureInfo Culture { get; internal set; }
    internal static ResourceManager get_ResourceManager();
    [CompilerGeneratedAttribute]
internal static CultureInfo get_Culture();
    [CompilerGeneratedAttribute]
internal static void set_Culture(CultureInfo value);
    internal static string GetResourceString(string resourceKey, string defaultValue);
}
public class System.Windows.StartupEventArgs : EventArgs {
    private String[] _args;
    private bool _performDefaultAction;
    public String[] Args { get; }
    internal bool PerformDefaultAction { get; internal set; }
    public String[] get_Args();
    internal bool get_PerformDefaultAction();
    internal void set_PerformDefaultAction(bool value);
    private String[] GetCmdLineArgs();
}
public class System.Windows.StartupEventHandler : MulticastDelegate {
    public StartupEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, StartupEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, StartupEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[MarkupExtensionReturnTypeAttribute("System.Object")]
[LocalizabilityAttribute("17")]
public class System.Windows.StaticResourceExtension : MarkupExtension {
    private object _resourceKey;
    [ConstructorArgumentAttribute("resourceKey")]
public object ResourceKey { get; public set; }
    internal DeferredResourceReference PrefetchedValue { get; }
    public StaticResourceExtension(object resourceKey);
    public virtual object ProvideValue(IServiceProvider serviceProvider);
    public object get_ResourceKey();
    public void set_ResourceKey(object value);
    internal virtual DeferredResourceReference get_PrefetchedValue();
    internal object ProvideValueInternal(IServiceProvider serviceProvider, bool allowDeferredReference);
    internal object TryProvideValueInternal(IServiceProvider serviceProvider, bool allowDeferredReference, bool mustReturnDeferredResourceReference);
    private object TryProvideValueWithDiagnosticEvent(IServiceProvider serviceProvider, bool allowDeferredReference, bool mustReturnDeferredResourceReference);
    private object TryProvideValueImpl(IServiceProvider serviceProvider, bool allowDeferredReference, bool mustReturnDeferredResourceReference);
    private ResourceDictionary FindTheResourceDictionary(IServiceProvider serviceProvider, bool isDeferredContentSearch);
    internal object FindResourceInDeferredContent(IServiceProvider serviceProvider, bool allowDeferredReference, bool mustReturnDeferredResourceReference);
    private object FindResourceInAppOrSystem(IServiceProvider serviceProvider, bool allowDeferredReference, bool mustReturnDeferredResourceReference);
    private object FindResourceInEnviroment(IServiceProvider serviceProvider, bool allowDeferredReference, bool mustReturnDeferredResourceReference);
}
[LocalizabilityAttribute("16")]
[DictionaryKeyPropertyAttribute("TargetType")]
[ContentPropertyAttribute("Setters")]
public class System.Windows.Style : DispatcherObject {
    private NameScope _nameScope;
    private EventHandlersStore _eventHandlersStore;
    private bool _sealed;
    private bool _hasInstanceValues;
    internal static Type DefaultTargetType;
    private bool _hasLoadedChangeHandler;
    private Type _targetType;
    private Style _basedOn;
    private TriggerCollection _visualTriggers;
    private SetterBaseCollection _setters;
    internal ResourceDictionary _resources;
    internal int GlobalIndex;
    internal FrugalStructList`1<ChildRecord> ChildRecordFromChildIndex;
    internal FrugalStructList`1<ItemStructMap`1<TriggerSourceRecord>> TriggerSourceRecordFromChildIndex;
    internal FrugalMap PropertyTriggersWithActions;
    internal FrugalStructList`1<PropertyValue> PropertyValues;
    internal FrugalStructList`1<ContainerDependent> ContainerDependents;
    internal FrugalStructList`1<ChildPropertyDependent> ResourceDependents;
    internal ItemStructList`1<ChildEventDependent> EventDependents;
    internal HybridDictionary _triggerActions;
    internal HybridDictionary _dataTriggerRecordFromBinding;
    internal HybridDictionary DataTriggersWithActions;
    private static int StyleInstanceCount;
    internal static object Synchronized;
    private static int TargetTypeID;
    internal static int BasedOnID;
    private static int HasEventSetter;
    private int _modified;
    public bool IsSealed { get; }
    [AmbientAttribute]
[LocalizabilityAttribute("17")]
public Type TargetType { get; public set; }
    [DefaultValueAttribute("")]
[AmbientAttribute]
public Style BasedOn { get; public set; }
    [DesignerSerializationVisibilityAttribute("2")]
public TriggerCollection Triggers { get; }
    [DesignerSerializationVisibilityAttribute("2")]
public SetterBaseCollection Setters { get; }
    [AmbientAttribute]
public ResourceDictionary Resources { get; public set; }
    private ResourceDictionary System.Windows.Markup.IHaveResources.Resources { get; private set; }
    private bool System.Windows.ISealable.CanSeal { get; }
    private bool System.Windows.ISealable.IsSealed { get; }
    internal bool HasResourceReferences { get; }
    internal EventHandlersStore EventHandlersStore { get; }
    internal bool HasEventDependents { get; }
    internal bool HasEventSetters { get; }
    internal bool HasInstanceValues { get; }
    internal bool HasLoadedChangeHandler { get; internal set; }
    internal bool IsBasedOnModified { get; }
    private static Style();
    public Style(Type targetType);
    public Style(Type targetType, Style basedOn);
    public sealed virtual void RegisterName(string name, object scopedElement);
    public sealed virtual void UnregisterName(string name);
    private sealed virtual override object System.Windows.Markup.INameScope.FindName(string name);
    private void GetUniqueGlobalIndex();
    public bool get_IsSealed();
    public Type get_TargetType();
    public void set_TargetType(Type value);
    public Style get_BasedOn();
    public void set_BasedOn(Style value);
    public TriggerCollection get_Triggers();
    public SetterBaseCollection get_Setters();
    public ResourceDictionary get_Resources();
    public void set_Resources(ResourceDictionary value);
    private sealed virtual override ResourceDictionary System.Windows.Markup.IHaveResources.get_Resources();
    private sealed virtual override void System.Windows.Markup.IHaveResources.set_Resources(ResourceDictionary value);
    internal object FindResource(object resourceKey, bool allowDeferredResourceReference, bool mustReturnDeferredResourceReference);
    internal ResourceDictionary FindResourceDictionary(object resourceKey);
    private sealed virtual override bool System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(string propertyName);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object value);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string text);
    private void UpdatePropertyValueList(DependencyProperty dp, PropertyValueType valueType, object value);
    internal void CheckTargetType(object element);
    public void Seal();
    private void CheckForCircularBasedOnReferences();
    private void ProcessSetters(Style style);
    private void ProcessSelfStyles(Style style);
    private void ProcessVisualTriggers(Style style);
    public virtual int GetHashCode();
    private sealed virtual override bool System.Windows.ISealable.get_CanSeal();
    private sealed virtual override bool System.Windows.ISealable.get_IsSealed();
    private sealed virtual override void System.Windows.ISealable.Seal();
    internal bool get_HasResourceReferences();
    internal EventHandlersStore get_EventHandlersStore();
    internal bool get_HasEventDependents();
    internal bool get_HasEventSetters();
    internal bool get_HasInstanceValues();
    internal bool get_HasLoadedChangeHandler();
    internal void set_HasLoadedChangeHandler(bool value);
    private static bool IsEqual(object a, object b);
    internal bool get_IsBasedOnModified();
    private void SetModified(int id);
    internal bool IsModified(int id);
}
internal static class System.Windows.StyleHelper : object {
    internal static UncommonField`1<HybridDictionary[]> StyleDataField;
    internal static UncommonField`1<HybridDictionary[]> TemplateDataField;
    internal static UncommonField`1<HybridDictionary> ParentTemplateValuesField;
    internal static UncommonField`1<HybridDictionary[]> ThemeStyleDataField;
    internal static UncommonField`1<List`1<DependencyObject>> TemplatedFeChildrenField;
    internal static UncommonField`1<Hashtable> TemplatedNonFeChildrenField;
    internal static string SelfName;
    internal static FrugalStructList`1<ContainerDependent> EmptyContainerDependents;
    internal static object NotYetApplied;
    private static AlternativeExpressionStorageCallback _getExpression;
    internal static RoutedEventHandler EventTriggerHandlerOnContainer;
    internal static RoutedEventHandler EventTriggerHandlerOnChild;
    internal static int UnsharedTemplateContentPropertyIndex;
    private static StyleHelper();
    internal static void UpdateStyleCache(FrameworkElement fe, FrameworkContentElement fce, Style oldStyle, Style newStyle, Style& styleCache);
    internal static void UpdateThemeStyleCache(FrameworkElement fe, FrameworkContentElement fce, Style oldThemeStyle, Style newThemeStyle, Style& themeStyleCache);
    internal static Style GetThemeStyle(FrameworkElement fe, FrameworkContentElement fce);
    internal static void UpdateTemplateCache(FrameworkElement fe, FrameworkTemplate oldTemplate, FrameworkTemplate newTemplate, DependencyProperty templateProperty);
    internal static void SealTemplate(FrameworkTemplate frameworkTemplate, Boolean& isSealed, FrameworkElementFactory templateRoot, TriggerCollection triggers, ResourceDictionary resources, HybridDictionary childIndexFromChildID, FrugalStructList`1& childRecordFromChildIndex, FrugalStructList`1& triggerSourceRecordFromChildIndex, FrugalStructList`1& containerDependents, FrugalStructList`1& resourceDependents, ItemStructList`1& eventDependents, HybridDictionary& triggerActions, HybridDictionary& dataTriggerRecordFromBinding, Boolean& hasInstanceValues, EventHandlersStore& eventHandlersStore);
    internal static void UpdateTables(PropertyValue& propertyValue, FrugalStructList`1& childRecordFromChildIndex, FrugalStructList`1& triggerSourceRecordFromChildIndex, FrugalStructList`1& resourceDependents, HybridDictionary& dataTriggerRecordFromBinding, HybridDictionary childIndexFromChildName, Boolean& hasInstanceValues);
    private static bool RequiresInstanceStorage(Object& value);
    internal static void AddContainerDependent(DependencyProperty dp, bool fromVisualTrigger, FrugalStructList`1& containerDependents);
    internal static void AddEventDependent(int childIndex, EventHandlersStore eventHandlersStore, ItemStructList`1& eventDependents);
    private static void AddPropertyDependent(int childIndex, DependencyProperty dp, FrugalStructList`1& propertyDependents);
    private static void AddResourceDependent(int childIndex, DependencyProperty dp, object name, FrugalStructList`1& resourceDependents);
    internal static void ProcessTemplateContentFromFEF(FrameworkElementFactory factory, FrugalStructList`1& childRecordFromChildIndex, FrugalStructList`1& triggerSourceRecordFromChildIndex, FrugalStructList`1& resourceDependents, ItemStructList`1& eventDependents, HybridDictionary& dataTriggerRecordFromBinding, HybridDictionary childIndexFromChildID, Boolean& hasInstanceValues);
    private static void ProcessTemplateTriggers(TriggerCollection triggers, FrameworkTemplate frameworkTemplate, FrugalStructList`1& childRecordFromChildIndex, FrugalStructList`1& triggerSourceRecordFromChildIndex, FrugalStructList`1& containerDependents, FrugalStructList`1& resourceDependents, ItemStructList`1& eventDependents, HybridDictionary& dataTriggerRecordFromBinding, HybridDictionary childIndexFromChildID, Boolean& hasInstanceValues, HybridDictionary& triggerActions, FrameworkElementFactory templateRoot, EventHandlersStore& eventHandlersStore, FrugalMap& propertyTriggersWithActions, HybridDictionary& dataTriggersWithActions, Boolean& hasLoadedChangeHandler);
    private static void DetermineTriggerType(TriggerBase triggerBase, Trigger& trigger, MultiTrigger& multiTrigger, DataTrigger& dataTrigger, MultiDataTrigger& multiDataTrigger, EventTrigger& eventTrigger);
    internal static void ProcessEventTrigger(EventTrigger eventTrigger, HybridDictionary childIndexFromChildName, HybridDictionary& triggerActions, ItemStructList`1& eventDependents, FrameworkElementFactory templateRoot, FrameworkTemplate frameworkTemplate, EventHandlersStore& eventHandlersStore, Boolean& hasLoadedChangeHandler);
    private static void AddDelegateToFireTrigger(RoutedEvent routedEvent, int childIndex, FrameworkElementFactory templateRoot, FrameworkElementFactory childFef, ItemStructList`1& eventDependents, EventHandlersStore& eventHandlersStore);
    private static void AddDelegateToFireTrigger(RoutedEvent routedEvent, int childIndex, ItemStructList`1& eventDependents, EventHandlersStore& eventHandlersStore);
    internal static void SealIfSealable(object value);
    internal static void UpdateInstanceData(UncommonField`1<HybridDictionary[]> dataField, FrameworkElement fe, FrameworkContentElement fce, Style oldStyle, Style newStyle, FrameworkTemplate oldFrameworkTemplate, FrameworkTemplate newFrameworkTemplate, InternalFlags hasGeneratedSubTreeFlag);
    internal static void CreateInstanceData(UncommonField`1<HybridDictionary[]> dataField, DependencyObject container, FrameworkElement fe, FrameworkContentElement fce, Style newStyle, FrameworkTemplate newFrameworkTemplate);
    internal static void CreateInstanceDataForChild(UncommonField`1<HybridDictionary[]> dataField, DependencyObject container, DependencyObject child, int childIndex, bool hasInstanceValues, FrugalStructList`1& childRecordFromChildIndex);
    internal static void ReleaseInstanceData(UncommonField`1<HybridDictionary[]> dataField, DependencyObject container, FrameworkElement fe, FrameworkContentElement fce, Style oldStyle, FrameworkTemplate oldFrameworkTemplate, InternalFlags hasGeneratedSubTreeFlag);
    internal static HybridDictionary EnsureInstanceData(UncommonField`1<HybridDictionary[]> dataField, DependencyObject container, InstanceStyleData dataType);
    internal static HybridDictionary EnsureInstanceData(UncommonField`1<HybridDictionary[]> dataField, DependencyObject container, InstanceStyleData dataType, int initialSize);
    private static void ProcessInstanceValuesForChild(DependencyObject container, DependencyObject child, int childIndex, HybridDictionary instanceValues, bool apply, FrugalStructList`1& childRecordFromChildIndex);
    private static void ProcessInstanceValuesHelper(ItemStructList`1& valueLookupList, DependencyObject target, int childIndex, HybridDictionary instanceValues, bool apply);
    internal static void ProcessInstanceValue(DependencyObject target, int childIndex, HybridDictionary instanceValues, DependencyProperty dp, int i, bool apply);
    private static void ReleaseInstanceDataForDataTriggers(UncommonField`1<HybridDictionary[]> dataField, HybridDictionary instanceValues, Style oldStyle, FrameworkTemplate oldFrameworkTemplate);
    private static void ReleaseInstanceDataForTriggerBinding(BindingBase binding, HybridDictionary instanceValues, EventHandler`1<BindingValueChangedEventArgs> handler);
    internal static bool ApplyTemplateContent(UncommonField`1<HybridDictionary[]> dataField, DependencyObject container, FrameworkElementFactory templateRoot, int lastChildIndex, HybridDictionary childIndexFromChildID, FrameworkTemplate frameworkTemplate);
    internal static void AddCustomTemplateRoot(FrameworkElement container, UIElement child);
    internal static void AddCustomTemplateRoot(FrameworkElement container, UIElement child, bool checkVisualParent, bool mustCacheTreeStateOnChild);
    private static void CheckForCircularReferencesInTemplateTree(DependencyObject container, FrameworkTemplate frameworkTemplate);
    internal static void ClearGeneratedSubTree(HybridDictionary[] instanceData, FrameworkElement feContainer, FrameworkContentElement fceContainer, FrameworkTemplate oldFrameworkTemplate);
    private static void DetachGeneratedSubTree(FrameworkElement feContainer, FrameworkContentElement fceContainer);
    private static void ClearTemplateChain(HybridDictionary[] instanceData, FrameworkElement feContainer, FrameworkContentElement fceContainer, List`1<DependencyObject> templateChain, FrameworkTemplate oldFrameworkTemplate);
    internal static void SpecialDowncastToFEorFCE(DependencyObject d, FrameworkElement& fe, FrameworkContentElement& fce, bool throwIfNeither);
    internal static FrameworkElementFactory FindFEF(FrameworkElementFactory root, int childIndex);
    private static void ExecuteEventTriggerActionsOnContainer(object sender, RoutedEventArgs e);
    private static void ExecuteEventTriggerActionsOnChild(object sender, RoutedEventArgs e);
    private static void InvokeEventTriggerActions(FrameworkElement fe, FrameworkContentElement fce, Style ownerStyle, FrameworkTemplate frameworkTemplate, int childIndex, RoutedEvent Event);
    internal static object GetChildValue(UncommonField`1<HybridDictionary[]> dataField, DependencyObject container, int childIndex, FrameworkObject child, DependencyProperty dp, FrugalStructList`1& childRecordFromChildIndex, EffectiveValueEntry& entry, ValueLookupType& sourceType, FrameworkElementFactory templateRoot);
    private static object GetChildValueHelper(UncommonField`1<HybridDictionary[]> dataField, ItemStructList`1& valueLookupList, DependencyProperty dp, DependencyObject container, FrameworkObject child, int childIndex, bool styleLookup, EffectiveValueEntry& entry, ValueLookupType& sourceType, FrameworkElementFactory templateRoot);
    internal static object GetDataTriggerValue(UncommonField`1<HybridDictionary[]> dataField, DependencyObject container, BindingBase binding);
    internal static object GetInstanceValue(UncommonField`1<HybridDictionary[]> dataField, DependencyObject container, FrameworkElement feChild, FrameworkContentElement fceChild, int childIndex, DependencyProperty dp, int i, EffectiveValueEntry& entry);
    internal static bool ShouldGetValueFromStyle(DependencyProperty dp);
    internal static bool ShouldGetValueFromThemeStyle(DependencyProperty dp);
    internal static bool ShouldGetValueFromTemplate(DependencyProperty dp);
    internal static void DoStyleInvalidations(FrameworkElement fe, FrameworkContentElement fce, Style oldStyle, Style newStyle);
    internal static void DoThemeStyleInvalidations(FrameworkElement fe, FrameworkContentElement fce, Style oldThemeStyle, Style newThemeStyle, Style style);
    internal static void DoTemplateInvalidations(FrameworkElement feContainer, FrameworkTemplate oldFrameworkTemplate);
    internal static void DoStyleResourcesInvalidations(DependencyObject container, FrameworkElement fe, FrameworkContentElement fce, Style oldStyle, Style newStyle);
    internal static void DoTemplateResourcesInvalidations(DependencyObject container, FrameworkElement fe, FrameworkContentElement fce, object oldTemplate, object newTemplate);
    private static void SetShouldLookupImplicitStyles(FrameworkObject fo, List`1<ResourceDictionary> dictionaries);
    private static List`1<ResourceDictionary> GetResourceDictionariesFromStyle(Style style);
    private static List`1<ResourceDictionary> GetResourceDictionaryFromTemplate(object template);
    internal static void UpdateLoadedFlag(DependencyObject d, Style oldStyle, Style newStyle);
    internal static void UpdateLoadedFlag(DependencyObject d, FrameworkTemplate oldFrameworkTemplate, FrameworkTemplate newFrameworkTemplate);
    internal static void InvalidateContainerDependents(DependencyObject container, FrugalStructList`1& exclusionContainerDependents, FrugalStructList`1& oldContainerDependents, FrugalStructList`1& newContainerDependents);
    internal static void ApplyTemplatedParentValue(DependencyObject container, FrameworkObject child, int childIndex, FrugalStructList`1& childRecordFromChildIndex, DependencyProperty dp, FrameworkElementFactory templateRoot);
    internal static bool IsValueDynamic(DependencyObject container, int childIndex, DependencyProperty dp);
    internal static bool GetValueFromTemplatedParent(DependencyObject container, int childIndex, FrameworkObject child, DependencyProperty dp, FrugalStructList`1& childRecordFromChildIndex, FrameworkElementFactory templateRoot, EffectiveValueEntry& entry);
    internal static void ApplyStyleOrTemplateValue(FrameworkObject fo, DependencyProperty dp);
    internal static bool GetValueFromStyleOrTemplate(FrameworkObject fo, DependencyProperty dp, EffectiveValueEntry& entry);
    internal static void SortResourceDependents(FrugalStructList`1& resourceDependents);
    internal static void InvalidateResourceDependents(DependencyObject container, ResourcesChangeInfo info, FrugalStructList`1& resourceDependents, bool invalidateVisualTreeToo);
    internal static void InvalidateResourceDependentsForChild(DependencyObject container, DependencyObject child, int childIndex, ResourcesChangeInfo info, FrameworkTemplate parentTemplate);
    internal static bool HasResourceDependentsForChild(int childIndex, FrugalStructList`1& resourceDependents);
    internal static void InvalidatePropertiesOnTemplateNode(DependencyObject container, FrameworkObject child, int childIndex, FrugalStructList`1& childRecordFromChildIndex, bool isDetach, FrameworkElementFactory templateRoot);
    internal static bool IsSetOnContainer(DependencyProperty dp, FrugalStructList`1& containerDependents, bool alsoFromTriggers);
    internal static void OnTriggerSourcePropertyInvalidated(Style ownerStyle, FrameworkTemplate frameworkTemplate, DependencyObject container, DependencyProperty dp, DependencyPropertyChangedEventArgs changedArgs, bool invalidateOnlyContainer, FrugalStructList`1& triggerSourceRecordFromChildIndex, FrugalMap& propertyTriggersWithActions, int sourceChildIndex);
    private static void InvalidateDependents(Style ownerStyle, FrameworkTemplate frameworkTemplate, DependencyObject container, DependencyProperty dp, FrugalStructList`1& dependents, bool invalidateOnlyContainer);
    private static void InvokeDataTriggerActions(TriggerBase triggerBase, DependencyObject triggerContainer, BindingBase binding, BindingValueChangedEventArgs bindingChangedArgs, Style style, FrameworkTemplate frameworkTemplate, UncommonField`1<HybridDictionary[]> dataField);
    private static void InvokePropertyTriggerActions(TriggerBase triggerBase, DependencyObject triggerContainer, DependencyProperty changedProperty, DependencyPropertyChangedEventArgs changedArgs, int sourceChildIndex, Style style, FrameworkTemplate frameworkTemplate);
    private static void ExecuteOnApplyEnterExitActions(FrameworkElement fe, FrameworkContentElement fce, Style style, UncommonField`1<HybridDictionary[]> dataField);
    private static void ExecuteOnApplyEnterExitActions(FrameworkElement fe, FrameworkContentElement fce, FrameworkTemplate ft);
    private static void ExecuteOnApplyEnterExitActionsLoop(DependencyObject triggerContainer, TriggerCollection triggers, Style style, FrameworkTemplate ft, UncommonField`1<HybridDictionary[]> dataField);
    private static bool NoSourceNameInTrigger(TriggerBase triggerBase);
    private static void InvokeEnterOrExitActions(TriggerBase triggerBase, bool oldState, bool newState, DependencyObject triggerContainer, Style style, FrameworkTemplate frameworkTemplate);
    private static void InvokeActions(TriggerActionCollection actions, TriggerBase triggerBase, DependencyObject triggerContainer, Style style, FrameworkTemplate frameworkTemplate);
    private static bool CanInvokeActionsNow(DependencyObject container, FrameworkTemplate frameworkTemplate);
    private static void DeferActions(TriggerBase triggerBase, DependencyObject triggerContainer, TriggerActionCollection actions, Style style, FrameworkTemplate frameworkTemplate);
    internal static void InvokeDeferredActions(DependencyObject triggerContainer, FrameworkTemplate frameworkTemplate);
    internal static void InvokeActions(TriggerBase triggerBase, DependencyObject triggerContainer, TriggerActionCollection actions, Style style, FrameworkTemplate frameworkTemplate);
    private static void EvaluateOldNewStates(Trigger trigger, DependencyObject triggerContainer, DependencyProperty changedProperty, DependencyPropertyChangedEventArgs changedArgs, int sourceChildIndex, Style style, FrameworkTemplate frameworkTemplate, Boolean& oldState, Boolean& newState);
    private static void EvaluateOldNewStates(DataTrigger dataTrigger, DependencyObject triggerContainer, BindingBase binding, BindingValueChangedEventArgs bindingChangedArgs, UncommonField`1<HybridDictionary[]> dataField, Style style, FrameworkTemplate frameworkTemplate, Boolean& oldState, Boolean& newState);
    private static void EvaluateOldNewStates(MultiTrigger multiTrigger, DependencyObject triggerContainer, DependencyProperty changedProperty, DependencyPropertyChangedEventArgs changedArgs, int sourceChildIndex, Style style, FrameworkTemplate frameworkTemplate, Boolean& oldState, Boolean& newState);
    private static void EvaluateOldNewStates(MultiDataTrigger multiDataTrigger, DependencyObject triggerContainer, BindingBase binding, BindingValueChangedEventArgs changedArgs, UncommonField`1<HybridDictionary[]> dataField, Style style, FrameworkTemplate frameworkTemplate, Boolean& oldState, Boolean& newState);
    internal static void AddPropertyTriggerWithAction(TriggerBase triggerBase, DependencyProperty property, FrugalMap& triggersWithActions);
    internal static void AddDataTriggerWithAction(TriggerBase triggerBase, BindingBase binding, HybridDictionary& dataTriggersWithActions);
    private static void OnBindingValueInStyleChanged(object sender, BindingValueChangedEventArgs e);
    private static void OnBindingValueInTemplateChanged(object sender, BindingValueChangedEventArgs e);
    private static void OnBindingValueInThemeStyleChanged(object sender, BindingValueChangedEventArgs e);
    private static void InvokeApplicableDataTriggerActions(Style style, FrameworkTemplate frameworkTemplate, DependencyObject container, BindingBase binding, BindingValueChangedEventArgs e, UncommonField`1<HybridDictionary[]> dataField);
    internal static int CreateChildIndexFromChildName(string childName, FrameworkTemplate frameworkTemplate);
    internal static int QueryChildIndexFromChildName(string childName, HybridDictionary childIndexFromChildName);
    internal static object FindNameInTemplateContent(DependencyObject container, string childName, FrameworkTemplate frameworkTemplate);
    internal static DependencyObject GetChild(DependencyObject container, int childIndex);
    internal static DependencyObject GetChild(List`1<DependencyObject> styledChildren, int childIndex);
    internal static void RegisterAlternateExpressionStorage();
    private static Expression GetExpressionCore(DependencyObject d, DependencyProperty dp, PropertyMetadata metadata);
    internal static Expression GetExpression(DependencyObject d, DependencyProperty dp);
    internal static RoutedEventHandlerInfo[] GetChildRoutedEventHandlers(int childIndex, RoutedEvent routedEvent, ItemStructList`1& eventDependents);
    internal static bool IsStylingLogicalTree(DependencyProperty dp, object value);
}
[AttributeUsageAttribute("4")]
public class System.Windows.StyleTypedPropertyAttribute : Attribute {
    private string _property;
    private Type _styleTargetType;
    public string Property { get; public set; }
    public Type StyleTargetType { get; public set; }
    public string get_Property();
    public void set_Property(string value);
    public Type get_StyleTargetType();
    public void set_StyleTargetType(Type value);
}
public static class System.Windows.SystemColors : object {
    private static int AlphaShift;
    private static int RedShift;
    private static int GreenShift;
    private static int BlueShift;
    private static int Win32RedShift;
    private static int Win32GreenShift;
    private static int Win32BlueShift;
    private static BitArray _colorCacheValid;
    private static Color[] _colorCache;
    private static BitArray _brushCacheValid;
    private static SolidColorBrush[] _brushCache;
    private static SystemResourceKey _cacheActiveBorderBrush;
    private static SystemResourceKey _cacheActiveCaptionBrush;
    private static SystemResourceKey _cacheActiveCaptionTextBrush;
    private static SystemResourceKey _cacheAppWorkspaceBrush;
    private static SystemResourceKey _cacheControlBrush;
    private static SystemResourceKey _cacheControlDarkBrush;
    private static SystemResourceKey _cacheControlDarkDarkBrush;
    private static SystemResourceKey _cacheControlLightBrush;
    private static SystemResourceKey _cacheControlLightLightBrush;
    private static SystemResourceKey _cacheControlTextBrush;
    private static SystemResourceKey _cacheDesktopBrush;
    private static SystemResourceKey _cacheGradientActiveCaptionBrush;
    private static SystemResourceKey _cacheGradientInactiveCaptionBrush;
    private static SystemResourceKey _cacheGrayTextBrush;
    private static SystemResourceKey _cacheHighlightBrush;
    private static SystemResourceKey _cacheHighlightTextBrush;
    private static SystemResourceKey _cacheHotTrackBrush;
    private static SystemResourceKey _cacheInactiveBorderBrush;
    private static SystemResourceKey _cacheInactiveCaptionBrush;
    private static SystemResourceKey _cacheInactiveCaptionTextBrush;
    private static SystemResourceKey _cacheInfoBrush;
    private static SystemResourceKey _cacheInfoTextBrush;
    private static SystemResourceKey _cacheMenuBrush;
    private static SystemResourceKey _cacheMenuBarBrush;
    private static SystemResourceKey _cacheMenuHighlightBrush;
    private static SystemResourceKey _cacheMenuTextBrush;
    private static SystemResourceKey _cacheScrollBarBrush;
    private static SystemResourceKey _cacheWindowBrush;
    private static SystemResourceKey _cacheWindowFrameBrush;
    private static SystemResourceKey _cacheWindowTextBrush;
    private static SystemResourceKey _cacheInactiveSelectionHighlightBrush;
    private static SystemResourceKey _cacheInactiveSelectionHighlightTextBrush;
    private static SystemResourceKey _cacheActiveBorderColor;
    private static SystemResourceKey _cacheActiveCaptionColor;
    private static SystemResourceKey _cacheActiveCaptionTextColor;
    private static SystemResourceKey _cacheAppWorkspaceColor;
    private static SystemResourceKey _cacheControlColor;
    private static SystemResourceKey _cacheControlDarkColor;
    private static SystemResourceKey _cacheControlDarkDarkColor;
    private static SystemResourceKey _cacheControlLightColor;
    private static SystemResourceKey _cacheControlLightLightColor;
    private static SystemResourceKey _cacheControlTextColor;
    private static SystemResourceKey _cacheDesktopColor;
    private static SystemResourceKey _cacheGradientActiveCaptionColor;
    private static SystemResourceKey _cacheGradientInactiveCaptionColor;
    private static SystemResourceKey _cacheGrayTextColor;
    private static SystemResourceKey _cacheHighlightColor;
    private static SystemResourceKey _cacheHighlightTextColor;
    private static SystemResourceKey _cacheHotTrackColor;
    private static SystemResourceKey _cacheInactiveBorderColor;
    private static SystemResourceKey _cacheInactiveCaptionColor;
    private static SystemResourceKey _cacheInactiveCaptionTextColor;
    private static SystemResourceKey _cacheInfoColor;
    private static SystemResourceKey _cacheInfoTextColor;
    private static SystemResourceKey _cacheMenuColor;
    private static SystemResourceKey _cacheMenuBarColor;
    private static SystemResourceKey _cacheMenuHighlightColor;
    private static SystemResourceKey _cacheMenuTextColor;
    private static SystemResourceKey _cacheScrollBarColor;
    private static SystemResourceKey _cacheWindowColor;
    private static SystemResourceKey _cacheWindowFrameColor;
    private static SystemResourceKey _cacheWindowTextColor;
    public static Color ActiveBorderColor { get; }
    public static Color ActiveCaptionColor { get; }
    public static Color ActiveCaptionTextColor { get; }
    public static Color AppWorkspaceColor { get; }
    public static Color ControlColor { get; }
    public static Color ControlDarkColor { get; }
    public static Color ControlDarkDarkColor { get; }
    public static Color ControlLightColor { get; }
    public static Color ControlLightLightColor { get; }
    public static Color ControlTextColor { get; }
    public static Color DesktopColor { get; }
    public static Color GradientActiveCaptionColor { get; }
    public static Color GradientInactiveCaptionColor { get; }
    public static Color GrayTextColor { get; }
    public static Color HighlightColor { get; }
    public static Color HighlightTextColor { get; }
    public static Color HotTrackColor { get; }
    public static Color InactiveBorderColor { get; }
    public static Color InactiveCaptionColor { get; }
    public static Color InactiveCaptionTextColor { get; }
    public static Color InfoColor { get; }
    public static Color InfoTextColor { get; }
    public static Color MenuColor { get; }
    public static Color MenuBarColor { get; }
    public static Color MenuHighlightColor { get; }
    public static Color MenuTextColor { get; }
    public static Color ScrollBarColor { get; }
    public static Color WindowColor { get; }
    public static Color WindowFrameColor { get; }
    public static Color WindowTextColor { get; }
    public static ResourceKey ActiveBorderColorKey { get; }
    public static ResourceKey ActiveCaptionColorKey { get; }
    public static ResourceKey ActiveCaptionTextColorKey { get; }
    public static ResourceKey AppWorkspaceColorKey { get; }
    public static ResourceKey ControlColorKey { get; }
    public static ResourceKey ControlDarkColorKey { get; }
    public static ResourceKey ControlDarkDarkColorKey { get; }
    public static ResourceKey ControlLightColorKey { get; }
    public static ResourceKey ControlLightLightColorKey { get; }
    public static ResourceKey ControlTextColorKey { get; }
    public static ResourceKey DesktopColorKey { get; }
    public static ResourceKey GradientActiveCaptionColorKey { get; }
    public static ResourceKey GradientInactiveCaptionColorKey { get; }
    public static ResourceKey GrayTextColorKey { get; }
    public static ResourceKey HighlightColorKey { get; }
    public static ResourceKey HighlightTextColorKey { get; }
    public static ResourceKey HotTrackColorKey { get; }
    public static ResourceKey InactiveBorderColorKey { get; }
    public static ResourceKey InactiveCaptionColorKey { get; }
    public static ResourceKey InactiveCaptionTextColorKey { get; }
    public static ResourceKey InfoColorKey { get; }
    public static ResourceKey InfoTextColorKey { get; }
    public static ResourceKey MenuColorKey { get; }
    public static ResourceKey MenuBarColorKey { get; }
    public static ResourceKey MenuHighlightColorKey { get; }
    public static ResourceKey MenuTextColorKey { get; }
    public static ResourceKey ScrollBarColorKey { get; }
    public static ResourceKey WindowColorKey { get; }
    public static ResourceKey WindowFrameColorKey { get; }
    public static ResourceKey WindowTextColorKey { get; }
    public static SolidColorBrush ActiveBorderBrush { get; }
    public static SolidColorBrush ActiveCaptionBrush { get; }
    public static SolidColorBrush ActiveCaptionTextBrush { get; }
    public static SolidColorBrush AppWorkspaceBrush { get; }
    public static SolidColorBrush ControlBrush { get; }
    public static SolidColorBrush ControlDarkBrush { get; }
    public static SolidColorBrush ControlDarkDarkBrush { get; }
    public static SolidColorBrush ControlLightBrush { get; }
    public static SolidColorBrush ControlLightLightBrush { get; }
    public static SolidColorBrush ControlTextBrush { get; }
    public static SolidColorBrush DesktopBrush { get; }
    public static SolidColorBrush GradientActiveCaptionBrush { get; }
    public static SolidColorBrush GradientInactiveCaptionBrush { get; }
    public static SolidColorBrush GrayTextBrush { get; }
    public static SolidColorBrush HighlightBrush { get; }
    public static SolidColorBrush HighlightTextBrush { get; }
    public static SolidColorBrush HotTrackBrush { get; }
    public static SolidColorBrush InactiveBorderBrush { get; }
    public static SolidColorBrush InactiveCaptionBrush { get; }
    public static SolidColorBrush InactiveCaptionTextBrush { get; }
    public static SolidColorBrush InfoBrush { get; }
    public static SolidColorBrush InfoTextBrush { get; }
    public static SolidColorBrush MenuBrush { get; }
    public static SolidColorBrush MenuBarBrush { get; }
    public static SolidColorBrush MenuHighlightBrush { get; }
    public static SolidColorBrush MenuTextBrush { get; }
    public static SolidColorBrush ScrollBarBrush { get; }
    public static SolidColorBrush WindowBrush { get; }
    public static SolidColorBrush WindowFrameBrush { get; }
    public static SolidColorBrush WindowTextBrush { get; }
    public static SolidColorBrush InactiveSelectionHighlightBrush { get; }
    public static SolidColorBrush InactiveSelectionHighlightTextBrush { get; }
    public static ResourceKey ActiveBorderBrushKey { get; }
    public static ResourceKey ActiveCaptionBrushKey { get; }
    public static ResourceKey ActiveCaptionTextBrushKey { get; }
    public static ResourceKey AppWorkspaceBrushKey { get; }
    public static ResourceKey ControlBrushKey { get; }
    public static ResourceKey ControlDarkBrushKey { get; }
    public static ResourceKey ControlDarkDarkBrushKey { get; }
    public static ResourceKey ControlLightBrushKey { get; }
    public static ResourceKey ControlLightLightBrushKey { get; }
    public static ResourceKey ControlTextBrushKey { get; }
    public static ResourceKey DesktopBrushKey { get; }
    public static ResourceKey GradientActiveCaptionBrushKey { get; }
    public static ResourceKey GradientInactiveCaptionBrushKey { get; }
    public static ResourceKey GrayTextBrushKey { get; }
    public static ResourceKey HighlightBrushKey { get; }
    public static ResourceKey HighlightTextBrushKey { get; }
    public static ResourceKey HotTrackBrushKey { get; }
    public static ResourceKey InactiveBorderBrushKey { get; }
    public static ResourceKey InactiveCaptionBrushKey { get; }
    public static ResourceKey InactiveCaptionTextBrushKey { get; }
    public static ResourceKey InfoBrushKey { get; }
    public static ResourceKey InfoTextBrushKey { get; }
    public static ResourceKey MenuBrushKey { get; }
    public static ResourceKey MenuBarBrushKey { get; }
    public static ResourceKey MenuHighlightBrushKey { get; }
    public static ResourceKey MenuTextBrushKey { get; }
    public static ResourceKey ScrollBarBrushKey { get; }
    public static ResourceKey WindowBrushKey { get; }
    public static ResourceKey WindowFrameBrushKey { get; }
    public static ResourceKey WindowTextBrushKey { get; }
    public static ResourceKey InactiveSelectionHighlightBrushKey { get; }
    public static ResourceKey InactiveSelectionHighlightTextBrushKey { get; }
    private static SystemColors();
    public static Color get_ActiveBorderColor();
    public static Color get_ActiveCaptionColor();
    public static Color get_ActiveCaptionTextColor();
    public static Color get_AppWorkspaceColor();
    public static Color get_ControlColor();
    public static Color get_ControlDarkColor();
    public static Color get_ControlDarkDarkColor();
    public static Color get_ControlLightColor();
    public static Color get_ControlLightLightColor();
    public static Color get_ControlTextColor();
    public static Color get_DesktopColor();
    public static Color get_GradientActiveCaptionColor();
    public static Color get_GradientInactiveCaptionColor();
    public static Color get_GrayTextColor();
    public static Color get_HighlightColor();
    public static Color get_HighlightTextColor();
    public static Color get_HotTrackColor();
    public static Color get_InactiveBorderColor();
    public static Color get_InactiveCaptionColor();
    public static Color get_InactiveCaptionTextColor();
    public static Color get_InfoColor();
    public static Color get_InfoTextColor();
    public static Color get_MenuColor();
    public static Color get_MenuBarColor();
    public static Color get_MenuHighlightColor();
    public static Color get_MenuTextColor();
    public static Color get_ScrollBarColor();
    public static Color get_WindowColor();
    public static Color get_WindowFrameColor();
    public static Color get_WindowTextColor();
    private static SystemResourceKey CreateInstance(SystemResourceKeyID KeyId);
    public static ResourceKey get_ActiveBorderColorKey();
    public static ResourceKey get_ActiveCaptionColorKey();
    public static ResourceKey get_ActiveCaptionTextColorKey();
    public static ResourceKey get_AppWorkspaceColorKey();
    public static ResourceKey get_ControlColorKey();
    public static ResourceKey get_ControlDarkColorKey();
    public static ResourceKey get_ControlDarkDarkColorKey();
    public static ResourceKey get_ControlLightColorKey();
    public static ResourceKey get_ControlLightLightColorKey();
    public static ResourceKey get_ControlTextColorKey();
    public static ResourceKey get_DesktopColorKey();
    public static ResourceKey get_GradientActiveCaptionColorKey();
    public static ResourceKey get_GradientInactiveCaptionColorKey();
    public static ResourceKey get_GrayTextColorKey();
    public static ResourceKey get_HighlightColorKey();
    public static ResourceKey get_HighlightTextColorKey();
    public static ResourceKey get_HotTrackColorKey();
    public static ResourceKey get_InactiveBorderColorKey();
    public static ResourceKey get_InactiveCaptionColorKey();
    public static ResourceKey get_InactiveCaptionTextColorKey();
    public static ResourceKey get_InfoColorKey();
    public static ResourceKey get_InfoTextColorKey();
    public static ResourceKey get_MenuColorKey();
    public static ResourceKey get_MenuBarColorKey();
    public static ResourceKey get_MenuHighlightColorKey();
    public static ResourceKey get_MenuTextColorKey();
    public static ResourceKey get_ScrollBarColorKey();
    public static ResourceKey get_WindowColorKey();
    public static ResourceKey get_WindowFrameColorKey();
    public static ResourceKey get_WindowTextColorKey();
    public static SolidColorBrush get_ActiveBorderBrush();
    public static SolidColorBrush get_ActiveCaptionBrush();
    public static SolidColorBrush get_ActiveCaptionTextBrush();
    public static SolidColorBrush get_AppWorkspaceBrush();
    public static SolidColorBrush get_ControlBrush();
    public static SolidColorBrush get_ControlDarkBrush();
    public static SolidColorBrush get_ControlDarkDarkBrush();
    public static SolidColorBrush get_ControlLightBrush();
    public static SolidColorBrush get_ControlLightLightBrush();
    public static SolidColorBrush get_ControlTextBrush();
    public static SolidColorBrush get_DesktopBrush();
    public static SolidColorBrush get_GradientActiveCaptionBrush();
    public static SolidColorBrush get_GradientInactiveCaptionBrush();
    public static SolidColorBrush get_GrayTextBrush();
    public static SolidColorBrush get_HighlightBrush();
    public static SolidColorBrush get_HighlightTextBrush();
    public static SolidColorBrush get_HotTrackBrush();
    public static SolidColorBrush get_InactiveBorderBrush();
    public static SolidColorBrush get_InactiveCaptionBrush();
    public static SolidColorBrush get_InactiveCaptionTextBrush();
    public static SolidColorBrush get_InfoBrush();
    public static SolidColorBrush get_InfoTextBrush();
    public static SolidColorBrush get_MenuBrush();
    public static SolidColorBrush get_MenuBarBrush();
    public static SolidColorBrush get_MenuHighlightBrush();
    public static SolidColorBrush get_MenuTextBrush();
    public static SolidColorBrush get_ScrollBarBrush();
    public static SolidColorBrush get_WindowBrush();
    public static SolidColorBrush get_WindowFrameBrush();
    public static SolidColorBrush get_WindowTextBrush();
    public static SolidColorBrush get_InactiveSelectionHighlightBrush();
    public static SolidColorBrush get_InactiveSelectionHighlightTextBrush();
    public static ResourceKey get_ActiveBorderBrushKey();
    public static ResourceKey get_ActiveCaptionBrushKey();
    public static ResourceKey get_ActiveCaptionTextBrushKey();
    public static ResourceKey get_AppWorkspaceBrushKey();
    public static ResourceKey get_ControlBrushKey();
    public static ResourceKey get_ControlDarkBrushKey();
    public static ResourceKey get_ControlDarkDarkBrushKey();
    public static ResourceKey get_ControlLightBrushKey();
    public static ResourceKey get_ControlLightLightBrushKey();
    public static ResourceKey get_ControlTextBrushKey();
    public static ResourceKey get_DesktopBrushKey();
    public static ResourceKey get_GradientActiveCaptionBrushKey();
    public static ResourceKey get_GradientInactiveCaptionBrushKey();
    public static ResourceKey get_GrayTextBrushKey();
    public static ResourceKey get_HighlightBrushKey();
    public static ResourceKey get_HighlightTextBrushKey();
    public static ResourceKey get_HotTrackBrushKey();
    public static ResourceKey get_InactiveBorderBrushKey();
    public static ResourceKey get_InactiveCaptionBrushKey();
    public static ResourceKey get_InactiveCaptionTextBrushKey();
    public static ResourceKey get_InfoBrushKey();
    public static ResourceKey get_InfoTextBrushKey();
    public static ResourceKey get_MenuBrushKey();
    public static ResourceKey get_MenuBarBrushKey();
    public static ResourceKey get_MenuHighlightBrushKey();
    public static ResourceKey get_MenuTextBrushKey();
    public static ResourceKey get_ScrollBarBrushKey();
    public static ResourceKey get_WindowBrushKey();
    public static ResourceKey get_WindowFrameBrushKey();
    public static ResourceKey get_WindowTextBrushKey();
    public static ResourceKey get_InactiveSelectionHighlightBrushKey();
    public static ResourceKey get_InactiveSelectionHighlightTextBrushKey();
    internal static bool InvalidateCache();
    private static int Encode(int alpha, int red, int green, int blue);
    private static int FromWin32Value(int value);
    private static Color GetSystemColor(CacheSlot slot);
    private static SolidColorBrush MakeBrush(CacheSlot slot);
    private static int SlotToFlag(CacheSlot slot);
}
public static class System.Windows.SystemCommands : object {
    [CompilerGeneratedAttribute]
private static RoutedCommand <CloseWindowCommand>k__BackingField;
    [CompilerGeneratedAttribute]
private static RoutedCommand <MaximizeWindowCommand>k__BackingField;
    [CompilerGeneratedAttribute]
private static RoutedCommand <MinimizeWindowCommand>k__BackingField;
    [CompilerGeneratedAttribute]
private static RoutedCommand <RestoreWindowCommand>k__BackingField;
    [CompilerGeneratedAttribute]
private static RoutedCommand <ShowSystemMenuCommand>k__BackingField;
    public static RoutedCommand CloseWindowCommand { get; private set; }
    public static RoutedCommand MaximizeWindowCommand { get; private set; }
    public static RoutedCommand MinimizeWindowCommand { get; private set; }
    public static RoutedCommand RestoreWindowCommand { get; private set; }
    public static RoutedCommand ShowSystemMenuCommand { get; private set; }
    private static SystemCommands();
    [CompilerGeneratedAttribute]
public static RoutedCommand get_CloseWindowCommand();
    [CompilerGeneratedAttribute]
private static void set_CloseWindowCommand(RoutedCommand value);
    [CompilerGeneratedAttribute]
public static RoutedCommand get_MaximizeWindowCommand();
    [CompilerGeneratedAttribute]
private static void set_MaximizeWindowCommand(RoutedCommand value);
    [CompilerGeneratedAttribute]
public static RoutedCommand get_MinimizeWindowCommand();
    [CompilerGeneratedAttribute]
private static void set_MinimizeWindowCommand(RoutedCommand value);
    [CompilerGeneratedAttribute]
public static RoutedCommand get_RestoreWindowCommand();
    [CompilerGeneratedAttribute]
private static void set_RestoreWindowCommand(RoutedCommand value);
    [CompilerGeneratedAttribute]
public static RoutedCommand get_ShowSystemMenuCommand();
    [CompilerGeneratedAttribute]
private static void set_ShowSystemMenuCommand(RoutedCommand value);
    private static void _PostSystemCommand(Window window, SC command);
    public static void CloseWindow(Window window);
    public static void MaximizeWindow(Window window);
    public static void MinimizeWindow(Window window);
    public static void RestoreWindow(Window window);
    public static void ShowSystemMenu(Window window, Point screenLocation);
    internal static void ShowSystemMenuPhysicalCoordinates(Window window, Point physicalScreenLocation);
}
public static class System.Windows.SystemFonts : object {
    private static double FallbackFontSize;
    private static TextDecorationCollection _iconFontTextDecorations;
    private static TextDecorationCollection _messageFontTextDecorations;
    private static TextDecorationCollection _statusFontTextDecorations;
    private static TextDecorationCollection _menuFontTextDecorations;
    private static TextDecorationCollection _smallCaptionFontTextDecorations;
    private static TextDecorationCollection _captionFontTextDecorations;
    private static FontFamily _iconFontFamily;
    private static FontFamily _messageFontFamily;
    private static FontFamily _statusFontFamily;
    private static FontFamily _menuFontFamily;
    private static FontFamily _smallCaptionFontFamily;
    private static FontFamily _captionFontFamily;
    private static SystemResourceKey _cacheIconFontSize;
    private static SystemResourceKey _cacheIconFontFamily;
    private static SystemResourceKey _cacheIconFontStyle;
    private static SystemResourceKey _cacheIconFontWeight;
    private static SystemResourceKey _cacheIconFontTextDecorations;
    private static SystemResourceKey _cacheCaptionFontSize;
    private static SystemResourceKey _cacheCaptionFontFamily;
    private static SystemResourceKey _cacheCaptionFontStyle;
    private static SystemResourceKey _cacheCaptionFontWeight;
    private static SystemResourceKey _cacheCaptionFontTextDecorations;
    private static SystemResourceKey _cacheSmallCaptionFontSize;
    private static SystemResourceKey _cacheSmallCaptionFontFamily;
    private static SystemResourceKey _cacheSmallCaptionFontStyle;
    private static SystemResourceKey _cacheSmallCaptionFontWeight;
    private static SystemResourceKey _cacheSmallCaptionFontTextDecorations;
    private static SystemResourceKey _cacheMenuFontSize;
    private static SystemResourceKey _cacheMenuFontFamily;
    private static SystemResourceKey _cacheMenuFontStyle;
    private static SystemResourceKey _cacheMenuFontWeight;
    private static SystemResourceKey _cacheMenuFontTextDecorations;
    private static SystemResourceKey _cacheStatusFontSize;
    private static SystemResourceKey _cacheStatusFontFamily;
    private static SystemResourceKey _cacheStatusFontStyle;
    private static SystemResourceKey _cacheStatusFontWeight;
    private static SystemResourceKey _cacheStatusFontTextDecorations;
    private static SystemResourceKey _cacheMessageFontSize;
    private static SystemResourceKey _cacheMessageFontFamily;
    private static SystemResourceKey _cacheMessageFontStyle;
    private static SystemResourceKey _cacheMessageFontWeight;
    private static SystemResourceKey _cacheMessageFontTextDecorations;
    public static double IconFontSize { get; }
    public static FontFamily IconFontFamily { get; }
    public static FontStyle IconFontStyle { get; }
    public static FontWeight IconFontWeight { get; }
    public static TextDecorationCollection IconFontTextDecorations { get; }
    public static double CaptionFontSize { get; }
    public static FontFamily CaptionFontFamily { get; }
    public static FontStyle CaptionFontStyle { get; }
    public static FontWeight CaptionFontWeight { get; }
    public static TextDecorationCollection CaptionFontTextDecorations { get; }
    public static double SmallCaptionFontSize { get; }
    public static FontFamily SmallCaptionFontFamily { get; }
    public static FontStyle SmallCaptionFontStyle { get; }
    public static FontWeight SmallCaptionFontWeight { get; }
    public static TextDecorationCollection SmallCaptionFontTextDecorations { get; }
    public static double MenuFontSize { get; }
    public static FontFamily MenuFontFamily { get; }
    public static FontStyle MenuFontStyle { get; }
    public static FontWeight MenuFontWeight { get; }
    public static TextDecorationCollection MenuFontTextDecorations { get; }
    public static double StatusFontSize { get; }
    public static FontFamily StatusFontFamily { get; }
    public static FontStyle StatusFontStyle { get; }
    public static FontWeight StatusFontWeight { get; }
    public static TextDecorationCollection StatusFontTextDecorations { get; }
    public static double MessageFontSize { get; }
    public static FontFamily MessageFontFamily { get; }
    public static FontStyle MessageFontStyle { get; }
    public static FontWeight MessageFontWeight { get; }
    public static TextDecorationCollection MessageFontTextDecorations { get; }
    public static ResourceKey IconFontSizeKey { get; }
    public static ResourceKey IconFontFamilyKey { get; }
    public static ResourceKey IconFontStyleKey { get; }
    public static ResourceKey IconFontWeightKey { get; }
    public static ResourceKey IconFontTextDecorationsKey { get; }
    public static ResourceKey CaptionFontSizeKey { get; }
    public static ResourceKey CaptionFontFamilyKey { get; }
    public static ResourceKey CaptionFontStyleKey { get; }
    public static ResourceKey CaptionFontWeightKey { get; }
    public static ResourceKey CaptionFontTextDecorationsKey { get; }
    public static ResourceKey SmallCaptionFontSizeKey { get; }
    public static ResourceKey SmallCaptionFontFamilyKey { get; }
    public static ResourceKey SmallCaptionFontStyleKey { get; }
    public static ResourceKey SmallCaptionFontWeightKey { get; }
    public static ResourceKey SmallCaptionFontTextDecorationsKey { get; }
    public static ResourceKey MenuFontSizeKey { get; }
    public static ResourceKey MenuFontFamilyKey { get; }
    public static ResourceKey MenuFontStyleKey { get; }
    public static ResourceKey MenuFontWeightKey { get; }
    public static ResourceKey MenuFontTextDecorationsKey { get; }
    public static ResourceKey StatusFontSizeKey { get; }
    public static ResourceKey StatusFontFamilyKey { get; }
    public static ResourceKey StatusFontStyleKey { get; }
    public static ResourceKey StatusFontWeightKey { get; }
    public static ResourceKey StatusFontTextDecorationsKey { get; }
    public static ResourceKey MessageFontSizeKey { get; }
    public static ResourceKey MessageFontFamilyKey { get; }
    public static ResourceKey MessageFontStyleKey { get; }
    public static ResourceKey MessageFontWeightKey { get; }
    public static ResourceKey MessageFontTextDecorationsKey { get; }
    public static double get_IconFontSize();
    public static FontFamily get_IconFontFamily();
    public static FontStyle get_IconFontStyle();
    public static FontWeight get_IconFontWeight();
    public static TextDecorationCollection get_IconFontTextDecorations();
    public static double get_CaptionFontSize();
    public static FontFamily get_CaptionFontFamily();
    public static FontStyle get_CaptionFontStyle();
    public static FontWeight get_CaptionFontWeight();
    public static TextDecorationCollection get_CaptionFontTextDecorations();
    public static double get_SmallCaptionFontSize();
    public static FontFamily get_SmallCaptionFontFamily();
    public static FontStyle get_SmallCaptionFontStyle();
    public static FontWeight get_SmallCaptionFontWeight();
    public static TextDecorationCollection get_SmallCaptionFontTextDecorations();
    public static double get_MenuFontSize();
    public static FontFamily get_MenuFontFamily();
    public static FontStyle get_MenuFontStyle();
    public static FontWeight get_MenuFontWeight();
    public static TextDecorationCollection get_MenuFontTextDecorations();
    public static double get_StatusFontSize();
    public static FontFamily get_StatusFontFamily();
    public static FontStyle get_StatusFontStyle();
    public static FontWeight get_StatusFontWeight();
    public static TextDecorationCollection get_StatusFontTextDecorations();
    public static double get_MessageFontSize();
    public static FontFamily get_MessageFontFamily();
    public static FontStyle get_MessageFontStyle();
    public static FontWeight get_MessageFontWeight();
    public static TextDecorationCollection get_MessageFontTextDecorations();
    private static void CopyTextDecorationCollection(TextDecorationCollection from, TextDecorationCollection to);
    private static SystemResourceKey CreateInstance(SystemResourceKeyID KeyId);
    public static ResourceKey get_IconFontSizeKey();
    public static ResourceKey get_IconFontFamilyKey();
    public static ResourceKey get_IconFontStyleKey();
    public static ResourceKey get_IconFontWeightKey();
    public static ResourceKey get_IconFontTextDecorationsKey();
    public static ResourceKey get_CaptionFontSizeKey();
    public static ResourceKey get_CaptionFontFamilyKey();
    public static ResourceKey get_CaptionFontStyleKey();
    public static ResourceKey get_CaptionFontWeightKey();
    public static ResourceKey get_CaptionFontTextDecorationsKey();
    public static ResourceKey get_SmallCaptionFontSizeKey();
    public static ResourceKey get_SmallCaptionFontFamilyKey();
    public static ResourceKey get_SmallCaptionFontStyleKey();
    public static ResourceKey get_SmallCaptionFontWeightKey();
    public static ResourceKey get_SmallCaptionFontTextDecorationsKey();
    public static ResourceKey get_MenuFontSizeKey();
    public static ResourceKey get_MenuFontFamilyKey();
    public static ResourceKey get_MenuFontStyleKey();
    public static ResourceKey get_MenuFontWeightKey();
    public static ResourceKey get_MenuFontTextDecorationsKey();
    public static ResourceKey get_StatusFontSizeKey();
    public static ResourceKey get_StatusFontFamilyKey();
    public static ResourceKey get_StatusFontStyleKey();
    public static ResourceKey get_StatusFontWeightKey();
    public static ResourceKey get_StatusFontTextDecorationsKey();
    public static ResourceKey get_MessageFontSizeKey();
    public static ResourceKey get_MessageFontFamilyKey();
    public static ResourceKey get_MessageFontStyleKey();
    public static ResourceKey get_MessageFontWeightKey();
    public static ResourceKey get_MessageFontTextDecorationsKey();
    private static double ConvertFontHeight(int height);
    internal static void InvalidateIconMetrics();
    internal static void InvalidateNonClientMetrics();
}
public static class System.Windows.SystemParameters : object {
    [CompilerGeneratedAttribute]
private static PropertyChangedEventHandler StaticPropertyChanged;
    private static BitArray _cacheValid;
    private static bool _isGlassEnabled;
    private static string _uxThemeName;
    private static string _uxThemeColor;
    private static CornerRadius _windowCornerRadius;
    private static Color _windowGlassColor;
    private static Brush _windowGlassBrush;
    private static Thickness _windowNonClientFrameThickness;
    private static Thickness _windowResizeBorderThickness;
    private static int _dpiX;
    private static bool _setDpiX;
    private static double _focusBorderWidth;
    private static double _focusBorderHeight;
    private static bool _highContrast;
    private static bool _mouseVanish;
    private static bool _dropShadow;
    private static bool _flatMenu;
    private static RECT _workAreaInternal;
    private static Rect _workArea;
    private static ICONMETRICS _iconMetrics;
    private static bool _keyboardCues;
    private static int _keyboardDelay;
    private static bool _keyboardPref;
    private static int _keyboardSpeed;
    private static bool _snapToDefButton;
    private static int _wheelScrollLines;
    private static int _mouseHoverTime;
    private static double _mouseHoverHeight;
    private static double _mouseHoverWidth;
    private static bool _menuDropAlignment;
    private static bool _menuFade;
    private static int _menuShowDelay;
    private static bool _comboBoxAnimation;
    private static bool _clientAreaAnimation;
    private static bool _cursorShadow;
    private static bool _gradientCaptions;
    private static bool _hotTracking;
    private static bool _listBoxSmoothScrolling;
    private static bool _menuAnimation;
    private static bool _selectionFade;
    private static bool _stylusHotTracking;
    private static bool _toolTipAnimation;
    private static bool _tooltipFade;
    private static bool _uiEffects;
    private static bool _minAnimation;
    private static int _border;
    private static double _caretWidth;
    private static bool _dragFullWindows;
    private static int _foregroundFlashCount;
    private static NONCLIENTMETRICS _ncm;
    private static double _thinHorizontalBorderHeight;
    private static double _thinVerticalBorderWidth;
    private static double _cursorWidth;
    private static double _cursorHeight;
    private static double _thickHorizontalBorderHeight;
    private static double _thickVerticalBorderWidth;
    private static double _minimumHorizontalDragDistance;
    private static double _minimumVerticalDragDistance;
    private static double _fixedFrameHorizontalBorderHeight;
    private static double _fixedFrameVerticalBorderWidth;
    private static double _focusHorizontalBorderHeight;
    private static double _focusVerticalBorderWidth;
    private static double _fullPrimaryScreenHeight;
    private static double _fullPrimaryScreenWidth;
    private static double _horizontalScrollBarHeight;
    private static double _horizontalScrollBarButtonWidth;
    private static double _horizontalScrollBarThumbWidth;
    private static double _iconWidth;
    private static double _iconHeight;
    private static double _iconGridWidth;
    private static double _iconGridHeight;
    private static double _maximizedPrimaryScreenWidth;
    private static double _maximizedPrimaryScreenHeight;
    private static double _maximumWindowTrackWidth;
    private static double _maximumWindowTrackHeight;
    private static double _menuCheckmarkWidth;
    private static double _menuCheckmarkHeight;
    private static double _menuButtonWidth;
    private static double _menuButtonHeight;
    private static double _minimumWindowWidth;
    private static double _minimumWindowHeight;
    private static double _minimizedWindowWidth;
    private static double _minimizedWindowHeight;
    private static double _minimizedGridWidth;
    private static double _minimizedGridHeight;
    private static double _minimumWindowTrackWidth;
    private static double _minimumWindowTrackHeight;
    private static double _primaryScreenWidth;
    private static double _primaryScreenHeight;
    private static double _windowCaptionButtonWidth;
    private static double _windowCaptionButtonHeight;
    private static double _resizeFrameHorizontalBorderHeight;
    private static double _resizeFrameVerticalBorderWidth;
    private static double _smallIconWidth;
    private static double _smallIconHeight;
    private static double _smallWindowCaptionButtonWidth;
    private static double _smallWindowCaptionButtonHeight;
    private static double _virtualScreenWidth;
    private static double _virtualScreenHeight;
    private static double _verticalScrollBarWidth;
    private static double _verticalScrollBarButtonHeight;
    private static double _windowCaptionHeight;
    private static double _kanjiWindowHeight;
    private static double _menuBarHeight;
    private static double _verticalScrollBarThumbHeight;
    private static bool _isImmEnabled;
    private static bool _isMediaCenter;
    private static bool _isMenuDropRightAligned;
    private static bool _isMiddleEastEnabled;
    private static bool _isMousePresent;
    private static bool _isMouseWheelPresent;
    private static bool _isPenWindows;
    private static bool _isRemotelyControlled;
    private static bool _isRemoteSession;
    private static bool _showSounds;
    private static bool _isSlowMachine;
    private static bool _swapButtons;
    private static bool _isTabletPC;
    private static double _virtualScreenLeft;
    private static double _virtualScreenTop;
    private static PowerLineStatus _powerLineStatus;
    private static SystemResourceKey _cacheThinHorizontalBorderHeight;
    private static SystemResourceKey _cacheThinVerticalBorderWidth;
    private static SystemResourceKey _cacheCursorWidth;
    private static SystemResourceKey _cacheCursorHeight;
    private static SystemResourceKey _cacheThickHorizontalBorderHeight;
    private static SystemResourceKey _cacheThickVerticalBorderWidth;
    private static SystemResourceKey _cacheFixedFrameHorizontalBorderHeight;
    private static SystemResourceKey _cacheFixedFrameVerticalBorderWidth;
    private static SystemResourceKey _cacheFocusHorizontalBorderHeight;
    private static SystemResourceKey _cacheFocusVerticalBorderWidth;
    private static SystemResourceKey _cacheFullPrimaryScreenWidth;
    private static SystemResourceKey _cacheFullPrimaryScreenHeight;
    private static SystemResourceKey _cacheHorizontalScrollBarButtonWidth;
    private static SystemResourceKey _cacheHorizontalScrollBarHeight;
    private static SystemResourceKey _cacheHorizontalScrollBarThumbWidth;
    private static SystemResourceKey _cacheIconWidth;
    private static SystemResourceKey _cacheIconHeight;
    private static SystemResourceKey _cacheIconGridWidth;
    private static SystemResourceKey _cacheIconGridHeight;
    private static SystemResourceKey _cacheMaximizedPrimaryScreenWidth;
    private static SystemResourceKey _cacheMaximizedPrimaryScreenHeight;
    private static SystemResourceKey _cacheMaximumWindowTrackWidth;
    private static SystemResourceKey _cacheMaximumWindowTrackHeight;
    private static SystemResourceKey _cacheMenuCheckmarkWidth;
    private static SystemResourceKey _cacheMenuCheckmarkHeight;
    private static SystemResourceKey _cacheMenuButtonWidth;
    private static SystemResourceKey _cacheMenuButtonHeight;
    private static SystemResourceKey _cacheMinimumWindowWidth;
    private static SystemResourceKey _cacheMinimumWindowHeight;
    private static SystemResourceKey _cacheMinimizedWindowWidth;
    private static SystemResourceKey _cacheMinimizedWindowHeight;
    private static SystemResourceKey _cacheMinimizedGridWidth;
    private static SystemResourceKey _cacheMinimizedGridHeight;
    private static SystemResourceKey _cacheMinimumWindowTrackWidth;
    private static SystemResourceKey _cacheMinimumWindowTrackHeight;
    private static SystemResourceKey _cachePrimaryScreenWidth;
    private static SystemResourceKey _cachePrimaryScreenHeight;
    private static SystemResourceKey _cacheWindowCaptionButtonWidth;
    private static SystemResourceKey _cacheWindowCaptionButtonHeight;
    private static SystemResourceKey _cacheResizeFrameHorizontalBorderHeight;
    private static SystemResourceKey _cacheResizeFrameVerticalBorderWidth;
    private static SystemResourceKey _cacheSmallIconWidth;
    private static SystemResourceKey _cacheSmallIconHeight;
    private static SystemResourceKey _cacheSmallWindowCaptionButtonWidth;
    private static SystemResourceKey _cacheSmallWindowCaptionButtonHeight;
    private static SystemResourceKey _cacheVirtualScreenWidth;
    private static SystemResourceKey _cacheVirtualScreenHeight;
    private static SystemResourceKey _cacheVerticalScrollBarWidth;
    private static SystemResourceKey _cacheVerticalScrollBarButtonHeight;
    private static SystemResourceKey _cacheWindowCaptionHeight;
    private static SystemResourceKey _cacheKanjiWindowHeight;
    private static SystemResourceKey _cacheMenuBarHeight;
    private static SystemResourceKey _cacheSmallCaptionHeight;
    private static SystemResourceKey _cacheVerticalScrollBarThumbHeight;
    private static SystemResourceKey _cacheIsImmEnabled;
    private static SystemResourceKey _cacheIsMediaCenter;
    private static SystemResourceKey _cacheIsMenuDropRightAligned;
    private static SystemResourceKey _cacheIsMiddleEastEnabled;
    private static SystemResourceKey _cacheIsMousePresent;
    private static SystemResourceKey _cacheIsMouseWheelPresent;
    private static SystemResourceKey _cacheIsPenWindows;
    private static SystemResourceKey _cacheIsRemotelyControlled;
    private static SystemResourceKey _cacheIsRemoteSession;
    private static SystemResourceKey _cacheShowSounds;
    private static SystemResourceKey _cacheIsSlowMachine;
    private static SystemResourceKey _cacheSwapButtons;
    private static SystemResourceKey _cacheIsTabletPC;
    private static SystemResourceKey _cacheVirtualScreenLeft;
    private static SystemResourceKey _cacheVirtualScreenTop;
    private static SystemResourceKey _cacheFocusBorderWidth;
    private static SystemResourceKey _cacheFocusBorderHeight;
    private static SystemResourceKey _cacheHighContrast;
    private static SystemResourceKey _cacheDropShadow;
    private static SystemResourceKey _cacheFlatMenu;
    private static SystemResourceKey _cacheWorkArea;
    private static SystemResourceKey _cacheIconHorizontalSpacing;
    private static SystemResourceKey _cacheIconVerticalSpacing;
    private static SystemResourceKey _cacheIconTitleWrap;
    private static SystemResourceKey _cacheKeyboardCues;
    private static SystemResourceKey _cacheKeyboardDelay;
    private static SystemResourceKey _cacheKeyboardPreference;
    private static SystemResourceKey _cacheKeyboardSpeed;
    private static SystemResourceKey _cacheSnapToDefaultButton;
    private static SystemResourceKey _cacheWheelScrollLines;
    private static SystemResourceKey _cacheMouseHoverTime;
    private static SystemResourceKey _cacheMouseHoverHeight;
    private static SystemResourceKey _cacheMouseHoverWidth;
    private static SystemResourceKey _cacheMenuDropAlignment;
    private static SystemResourceKey _cacheMenuFade;
    private static SystemResourceKey _cacheMenuShowDelay;
    private static SystemResourceKey _cacheComboBoxAnimation;
    private static SystemResourceKey _cacheClientAreaAnimation;
    private static SystemResourceKey _cacheCursorShadow;
    private static SystemResourceKey _cacheGradientCaptions;
    private static SystemResourceKey _cacheHotTracking;
    private static SystemResourceKey _cacheListBoxSmoothScrolling;
    private static SystemResourceKey _cacheMenuAnimation;
    private static SystemResourceKey _cacheSelectionFade;
    private static SystemResourceKey _cacheStylusHotTracking;
    private static SystemResourceKey _cacheToolTipAnimation;
    private static SystemResourceKey _cacheToolTipFade;
    private static SystemResourceKey _cacheUIEffects;
    private static SystemResourceKey _cacheMinimizeAnimation;
    private static SystemResourceKey _cacheBorder;
    private static SystemResourceKey _cacheCaretWidth;
    private static SystemResourceKey _cacheForegroundFlashCount;
    private static SystemResourceKey _cacheDragFullWindows;
    private static SystemResourceKey _cacheBorderWidth;
    private static SystemResourceKey _cacheScrollWidth;
    private static SystemResourceKey _cacheScrollHeight;
    private static SystemResourceKey _cacheCaptionWidth;
    private static SystemResourceKey _cacheCaptionHeight;
    private static SystemResourceKey _cacheSmallCaptionWidth;
    private static SystemResourceKey _cacheMenuWidth;
    private static SystemResourceKey _cacheMenuHeight;
    private static SystemResourceKey _cacheComboBoxPopupAnimation;
    private static SystemResourceKey _cacheMenuPopupAnimation;
    private static SystemResourceKey _cacheToolTipPopupAnimation;
    private static SystemResourceKey _cachePowerLineStatus;
    private static SystemThemeKey _cacheFocusVisualStyle;
    private static SystemThemeKey _cacheNavigationChromeStyle;
    private static SystemThemeKey _cacheNavigationChromeDownLevelStyle;
    public static double FocusBorderWidth { get; }
    public static double FocusBorderHeight { get; }
    public static bool HighContrast { get; }
    internal static bool MouseVanish { get; }
    public static ResourceKey FocusBorderWidthKey { get; }
    public static ResourceKey FocusBorderHeightKey { get; }
    public static ResourceKey HighContrastKey { get; }
    public static bool DropShadow { get; }
    public static bool FlatMenu { get; }
    internal static RECT WorkAreaInternal { get; }
    public static Rect WorkArea { get; }
    public static ResourceKey DropShadowKey { get; }
    public static ResourceKey FlatMenuKey { get; }
    public static ResourceKey WorkAreaKey { get; }
    internal static ICONMETRICS IconMetrics { get; }
    public static double IconHorizontalSpacing { get; }
    public static double IconVerticalSpacing { get; }
    public static bool IconTitleWrap { get; }
    public static ResourceKey IconHorizontalSpacingKey { get; }
    public static ResourceKey IconVerticalSpacingKey { get; }
    public static ResourceKey IconTitleWrapKey { get; }
    public static bool KeyboardCues { get; }
    public static int KeyboardDelay { get; }
    public static bool KeyboardPreference { get; }
    public static int KeyboardSpeed { get; }
    public static bool SnapToDefaultButton { get; }
    public static int WheelScrollLines { get; }
    public static TimeSpan MouseHoverTime { get; }
    internal static int MouseHoverTimeMilliseconds { get; }
    public static double MouseHoverHeight { get; }
    public static double MouseHoverWidth { get; }
    public static ResourceKey KeyboardCuesKey { get; }
    public static ResourceKey KeyboardDelayKey { get; }
    public static ResourceKey KeyboardPreferenceKey { get; }
    public static ResourceKey KeyboardSpeedKey { get; }
    public static ResourceKey SnapToDefaultButtonKey { get; }
    public static ResourceKey WheelScrollLinesKey { get; }
    public static ResourceKey MouseHoverTimeKey { get; }
    public static ResourceKey MouseHoverHeightKey { get; }
    public static ResourceKey MouseHoverWidthKey { get; }
    public static bool MenuDropAlignment { get; }
    public static bool MenuFade { get; }
    public static int MenuShowDelay { get; }
    public static ResourceKey MenuDropAlignmentKey { get; }
    public static ResourceKey MenuFadeKey { get; }
    public static ResourceKey MenuShowDelayKey { get; }
    public static PopupAnimation ComboBoxPopupAnimation { get; }
    public static bool ComboBoxAnimation { get; }
    public static bool ClientAreaAnimation { get; }
    public static bool CursorShadow { get; }
    public static bool GradientCaptions { get; }
    public static bool HotTracking { get; }
    public static bool ListBoxSmoothScrolling { get; }
    public static PopupAnimation MenuPopupAnimation { get; }
    public static bool MenuAnimation { get; }
    public static bool SelectionFade { get; }
    public static bool StylusHotTracking { get; }
    public static PopupAnimation ToolTipPopupAnimation { get; }
    public static bool ToolTipAnimation { get; }
    public static bool ToolTipFade { get; }
    public static bool UIEffects { get; }
    public static ResourceKey ComboBoxAnimationKey { get; }
    public static ResourceKey ClientAreaAnimationKey { get; }
    public static ResourceKey CursorShadowKey { get; }
    public static ResourceKey GradientCaptionsKey { get; }
    public static ResourceKey HotTrackingKey { get; }
    public static ResourceKey ListBoxSmoothScrollingKey { get; }
    public static ResourceKey MenuAnimationKey { get; }
    public static ResourceKey SelectionFadeKey { get; }
    public static ResourceKey StylusHotTrackingKey { get; }
    public static ResourceKey ToolTipAnimationKey { get; }
    public static ResourceKey ToolTipFadeKey { get; }
    public static ResourceKey UIEffectsKey { get; }
    public static ResourceKey ComboBoxPopupAnimationKey { get; }
    public static ResourceKey MenuPopupAnimationKey { get; }
    public static ResourceKey ToolTipPopupAnimationKey { get; }
    public static bool MinimizeAnimation { get; }
    public static int Border { get; }
    public static double CaretWidth { get; }
    public static bool DragFullWindows { get; }
    public static int ForegroundFlashCount { get; }
    internal static NONCLIENTMETRICS NonClientMetrics { get; }
    public static double BorderWidth { get; }
    public static double ScrollWidth { get; }
    public static double ScrollHeight { get; }
    public static double CaptionWidth { get; }
    public static double CaptionHeight { get; }
    public static double SmallCaptionWidth { get; }
    public static double SmallCaptionHeight { get; }
    public static double MenuWidth { get; }
    public static double MenuHeight { get; }
    public static ResourceKey MinimizeAnimationKey { get; }
    public static ResourceKey BorderKey { get; }
    public static ResourceKey CaretWidthKey { get; }
    public static ResourceKey ForegroundFlashCountKey { get; }
    public static ResourceKey DragFullWindowsKey { get; }
    public static ResourceKey BorderWidthKey { get; }
    public static ResourceKey ScrollWidthKey { get; }
    public static ResourceKey ScrollHeightKey { get; }
    public static ResourceKey CaptionWidthKey { get; }
    public static ResourceKey CaptionHeightKey { get; }
    public static ResourceKey SmallCaptionWidthKey { get; }
    public static ResourceKey MenuWidthKey { get; }
    public static ResourceKey MenuHeightKey { get; }
    public static double ThinHorizontalBorderHeight { get; }
    public static double ThinVerticalBorderWidth { get; }
    public static double CursorWidth { get; }
    public static double CursorHeight { get; }
    public static double ThickHorizontalBorderHeight { get; }
    public static double ThickVerticalBorderWidth { get; }
    public static double MinimumHorizontalDragDistance { get; }
    public static double MinimumVerticalDragDistance { get; }
    public static double FixedFrameHorizontalBorderHeight { get; }
    public static double FixedFrameVerticalBorderWidth { get; }
    public static double FocusHorizontalBorderHeight { get; }
    public static double FocusVerticalBorderWidth { get; }
    public static double FullPrimaryScreenWidth { get; }
    public static double FullPrimaryScreenHeight { get; }
    public static double HorizontalScrollBarButtonWidth { get; }
    public static double HorizontalScrollBarHeight { get; }
    public static double HorizontalScrollBarThumbWidth { get; }
    public static double IconWidth { get; }
    public static double IconHeight { get; }
    public static double IconGridWidth { get; }
    public static double IconGridHeight { get; }
    public static double MaximizedPrimaryScreenWidth { get; }
    public static double MaximizedPrimaryScreenHeight { get; }
    public static double MaximumWindowTrackWidth { get; }
    public static double MaximumWindowTrackHeight { get; }
    public static double MenuCheckmarkWidth { get; }
    public static double MenuCheckmarkHeight { get; }
    public static double MenuButtonWidth { get; }
    public static double MenuButtonHeight { get; }
    public static double MinimumWindowWidth { get; }
    public static double MinimumWindowHeight { get; }
    public static double MinimizedWindowWidth { get; }
    public static double MinimizedWindowHeight { get; }
    public static double MinimizedGridWidth { get; }
    public static double MinimizedGridHeight { get; }
    public static double MinimumWindowTrackWidth { get; }
    public static double MinimumWindowTrackHeight { get; }
    public static double PrimaryScreenWidth { get; }
    public static double PrimaryScreenHeight { get; }
    public static double WindowCaptionButtonWidth { get; }
    public static double WindowCaptionButtonHeight { get; }
    public static double ResizeFrameHorizontalBorderHeight { get; }
    public static double ResizeFrameVerticalBorderWidth { get; }
    public static double SmallIconWidth { get; }
    public static double SmallIconHeight { get; }
    public static double SmallWindowCaptionButtonWidth { get; }
    public static double SmallWindowCaptionButtonHeight { get; }
    public static double VirtualScreenWidth { get; }
    public static double VirtualScreenHeight { get; }
    public static double VerticalScrollBarWidth { get; }
    public static double VerticalScrollBarButtonHeight { get; }
    public static double WindowCaptionHeight { get; }
    public static double KanjiWindowHeight { get; }
    public static double MenuBarHeight { get; }
    public static double VerticalScrollBarThumbHeight { get; }
    public static bool IsImmEnabled { get; }
    public static bool IsMediaCenter { get; }
    public static bool IsMenuDropRightAligned { get; }
    public static bool IsMiddleEastEnabled { get; }
    public static bool IsMousePresent { get; }
    public static bool IsMouseWheelPresent { get; }
    public static bool IsPenWindows { get; }
    public static bool IsRemotelyControlled { get; }
    public static bool IsRemoteSession { get; }
    public static bool ShowSounds { get; }
    public static bool IsSlowMachine { get; }
    public static bool SwapButtons { get; }
    public static bool IsTabletPC { get; }
    public static double VirtualScreenLeft { get; }
    public static double VirtualScreenTop { get; }
    public static ResourceKey ThinHorizontalBorderHeightKey { get; }
    public static ResourceKey ThinVerticalBorderWidthKey { get; }
    public static ResourceKey CursorWidthKey { get; }
    public static ResourceKey CursorHeightKey { get; }
    public static ResourceKey ThickHorizontalBorderHeightKey { get; }
    public static ResourceKey ThickVerticalBorderWidthKey { get; }
    public static ResourceKey FixedFrameHorizontalBorderHeightKey { get; }
    public static ResourceKey FixedFrameVerticalBorderWidthKey { get; }
    public static ResourceKey FocusHorizontalBorderHeightKey { get; }
    public static ResourceKey FocusVerticalBorderWidthKey { get; }
    public static ResourceKey FullPrimaryScreenWidthKey { get; }
    public static ResourceKey FullPrimaryScreenHeightKey { get; }
    public static ResourceKey HorizontalScrollBarButtonWidthKey { get; }
    public static ResourceKey HorizontalScrollBarHeightKey { get; }
    public static ResourceKey HorizontalScrollBarThumbWidthKey { get; }
    public static ResourceKey IconWidthKey { get; }
    public static ResourceKey IconHeightKey { get; }
    public static ResourceKey IconGridWidthKey { get; }
    public static ResourceKey IconGridHeightKey { get; }
    public static ResourceKey MaximizedPrimaryScreenWidthKey { get; }
    public static ResourceKey MaximizedPrimaryScreenHeightKey { get; }
    public static ResourceKey MaximumWindowTrackWidthKey { get; }
    public static ResourceKey MaximumWindowTrackHeightKey { get; }
    public static ResourceKey MenuCheckmarkWidthKey { get; }
    public static ResourceKey MenuCheckmarkHeightKey { get; }
    public static ResourceKey MenuButtonWidthKey { get; }
    public static ResourceKey MenuButtonHeightKey { get; }
    public static ResourceKey MinimumWindowWidthKey { get; }
    public static ResourceKey MinimumWindowHeightKey { get; }
    public static ResourceKey MinimizedWindowWidthKey { get; }
    public static ResourceKey MinimizedWindowHeightKey { get; }
    public static ResourceKey MinimizedGridWidthKey { get; }
    public static ResourceKey MinimizedGridHeightKey { get; }
    public static ResourceKey MinimumWindowTrackWidthKey { get; }
    public static ResourceKey MinimumWindowTrackHeightKey { get; }
    public static ResourceKey PrimaryScreenWidthKey { get; }
    public static ResourceKey PrimaryScreenHeightKey { get; }
    public static ResourceKey WindowCaptionButtonWidthKey { get; }
    public static ResourceKey WindowCaptionButtonHeightKey { get; }
    public static ResourceKey ResizeFrameHorizontalBorderHeightKey { get; }
    public static ResourceKey ResizeFrameVerticalBorderWidthKey { get; }
    public static ResourceKey SmallIconWidthKey { get; }
    public static ResourceKey SmallIconHeightKey { get; }
    public static ResourceKey SmallWindowCaptionButtonWidthKey { get; }
    public static ResourceKey SmallWindowCaptionButtonHeightKey { get; }
    public static ResourceKey VirtualScreenWidthKey { get; }
    public static ResourceKey VirtualScreenHeightKey { get; }
    public static ResourceKey VerticalScrollBarWidthKey { get; }
    public static ResourceKey VerticalScrollBarButtonHeightKey { get; }
    public static ResourceKey WindowCaptionHeightKey { get; }
    public static ResourceKey KanjiWindowHeightKey { get; }
    public static ResourceKey MenuBarHeightKey { get; }
    public static ResourceKey SmallCaptionHeightKey { get; }
    public static ResourceKey VerticalScrollBarThumbHeightKey { get; }
    public static ResourceKey IsImmEnabledKey { get; }
    public static ResourceKey IsMediaCenterKey { get; }
    public static ResourceKey IsMenuDropRightAlignedKey { get; }
    public static ResourceKey IsMiddleEastEnabledKey { get; }
    public static ResourceKey IsMousePresentKey { get; }
    public static ResourceKey IsMouseWheelPresentKey { get; }
    public static ResourceKey IsPenWindowsKey { get; }
    public static ResourceKey IsRemotelyControlledKey { get; }
    public static ResourceKey IsRemoteSessionKey { get; }
    public static ResourceKey ShowSoundsKey { get; }
    public static ResourceKey IsSlowMachineKey { get; }
    public static ResourceKey SwapButtonsKey { get; }
    public static ResourceKey IsTabletPCKey { get; }
    public static ResourceKey VirtualScreenLeftKey { get; }
    public static ResourceKey VirtualScreenTopKey { get; }
    public static ResourceKey FocusVisualStyleKey { get; }
    public static ResourceKey NavigationChromeStyleKey { get; }
    public static ResourceKey NavigationChromeDownLevelStyleKey { get; }
    public static PowerLineStatus PowerLineStatus { get; }
    public static ResourceKey PowerLineStatusKey { get; }
    public static bool IsGlassEnabled { get; }
    public static string UxThemeName { get; }
    public static string UxThemeColor { get; }
    public static CornerRadius WindowCornerRadius { get; }
    public static Color WindowGlassColor { get; }
    public static Brush WindowGlassBrush { get; }
    public static Thickness WindowResizeBorderThickness { get; }
    public static Thickness WindowNonClientFrameThickness { get; }
    internal static int Dpi { get; }
    internal static int DpiX { get; }
    private static SystemParameters();
    [CompilerGeneratedAttribute]
public static void add_StaticPropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public static void remove_StaticPropertyChanged(PropertyChangedEventHandler value);
    private static void OnPropertiesChanged(String[] propertyNames);
    private static bool InvalidateProperty(int slot, string name);
    public static double get_FocusBorderWidth();
    public static double get_FocusBorderHeight();
    public static bool get_HighContrast();
    internal static bool get_MouseVanish();
    private static SystemResourceKey CreateInstance(SystemResourceKeyID KeyId);
    public static ResourceKey get_FocusBorderWidthKey();
    public static ResourceKey get_FocusBorderHeightKey();
    public static ResourceKey get_HighContrastKey();
    public static bool get_DropShadow();
    public static bool get_FlatMenu();
    internal static RECT get_WorkAreaInternal();
    public static Rect get_WorkArea();
    public static ResourceKey get_DropShadowKey();
    public static ResourceKey get_FlatMenuKey();
    public static ResourceKey get_WorkAreaKey();
    internal static ICONMETRICS get_IconMetrics();
    public static double get_IconHorizontalSpacing();
    public static double get_IconVerticalSpacing();
    public static bool get_IconTitleWrap();
    public static ResourceKey get_IconHorizontalSpacingKey();
    public static ResourceKey get_IconVerticalSpacingKey();
    public static ResourceKey get_IconTitleWrapKey();
    public static bool get_KeyboardCues();
    public static int get_KeyboardDelay();
    public static bool get_KeyboardPreference();
    public static int get_KeyboardSpeed();
    public static bool get_SnapToDefaultButton();
    public static int get_WheelScrollLines();
    public static TimeSpan get_MouseHoverTime();
    internal static int get_MouseHoverTimeMilliseconds();
    public static double get_MouseHoverHeight();
    public static double get_MouseHoverWidth();
    public static ResourceKey get_KeyboardCuesKey();
    public static ResourceKey get_KeyboardDelayKey();
    public static ResourceKey get_KeyboardPreferenceKey();
    public static ResourceKey get_KeyboardSpeedKey();
    public static ResourceKey get_SnapToDefaultButtonKey();
    public static ResourceKey get_WheelScrollLinesKey();
    public static ResourceKey get_MouseHoverTimeKey();
    public static ResourceKey get_MouseHoverHeightKey();
    public static ResourceKey get_MouseHoverWidthKey();
    public static bool get_MenuDropAlignment();
    public static bool get_MenuFade();
    public static int get_MenuShowDelay();
    public static ResourceKey get_MenuDropAlignmentKey();
    public static ResourceKey get_MenuFadeKey();
    public static ResourceKey get_MenuShowDelayKey();
    public static PopupAnimation get_ComboBoxPopupAnimation();
    public static bool get_ComboBoxAnimation();
    public static bool get_ClientAreaAnimation();
    public static bool get_CursorShadow();
    public static bool get_GradientCaptions();
    public static bool get_HotTracking();
    public static bool get_ListBoxSmoothScrolling();
    public static PopupAnimation get_MenuPopupAnimation();
    public static bool get_MenuAnimation();
    public static bool get_SelectionFade();
    public static bool get_StylusHotTracking();
    public static PopupAnimation get_ToolTipPopupAnimation();
    public static bool get_ToolTipAnimation();
    public static bool get_ToolTipFade();
    public static bool get_UIEffects();
    public static ResourceKey get_ComboBoxAnimationKey();
    public static ResourceKey get_ClientAreaAnimationKey();
    public static ResourceKey get_CursorShadowKey();
    public static ResourceKey get_GradientCaptionsKey();
    public static ResourceKey get_HotTrackingKey();
    public static ResourceKey get_ListBoxSmoothScrollingKey();
    public static ResourceKey get_MenuAnimationKey();
    public static ResourceKey get_SelectionFadeKey();
    public static ResourceKey get_StylusHotTrackingKey();
    public static ResourceKey get_ToolTipAnimationKey();
    public static ResourceKey get_ToolTipFadeKey();
    public static ResourceKey get_UIEffectsKey();
    public static ResourceKey get_ComboBoxPopupAnimationKey();
    public static ResourceKey get_MenuPopupAnimationKey();
    public static ResourceKey get_ToolTipPopupAnimationKey();
    public static bool get_MinimizeAnimation();
    public static int get_Border();
    public static double get_CaretWidth();
    public static bool get_DragFullWindows();
    public static int get_ForegroundFlashCount();
    internal static NONCLIENTMETRICS get_NonClientMetrics();
    public static double get_BorderWidth();
    public static double get_ScrollWidth();
    public static double get_ScrollHeight();
    public static double get_CaptionWidth();
    public static double get_CaptionHeight();
    public static double get_SmallCaptionWidth();
    public static double get_SmallCaptionHeight();
    public static double get_MenuWidth();
    public static double get_MenuHeight();
    public static ResourceKey get_MinimizeAnimationKey();
    public static ResourceKey get_BorderKey();
    public static ResourceKey get_CaretWidthKey();
    public static ResourceKey get_ForegroundFlashCountKey();
    public static ResourceKey get_DragFullWindowsKey();
    public static ResourceKey get_BorderWidthKey();
    public static ResourceKey get_ScrollWidthKey();
    public static ResourceKey get_ScrollHeightKey();
    public static ResourceKey get_CaptionWidthKey();
    public static ResourceKey get_CaptionHeightKey();
    public static ResourceKey get_SmallCaptionWidthKey();
    public static ResourceKey get_MenuWidthKey();
    public static ResourceKey get_MenuHeightKey();
    public static double get_ThinHorizontalBorderHeight();
    public static double get_ThinVerticalBorderWidth();
    public static double get_CursorWidth();
    public static double get_CursorHeight();
    public static double get_ThickHorizontalBorderHeight();
    public static double get_ThickVerticalBorderWidth();
    public static double get_MinimumHorizontalDragDistance();
    public static double get_MinimumVerticalDragDistance();
    public static double get_FixedFrameHorizontalBorderHeight();
    public static double get_FixedFrameVerticalBorderWidth();
    public static double get_FocusHorizontalBorderHeight();
    public static double get_FocusVerticalBorderWidth();
    public static double get_FullPrimaryScreenWidth();
    public static double get_FullPrimaryScreenHeight();
    public static double get_HorizontalScrollBarButtonWidth();
    public static double get_HorizontalScrollBarHeight();
    public static double get_HorizontalScrollBarThumbWidth();
    public static double get_IconWidth();
    public static double get_IconHeight();
    public static double get_IconGridWidth();
    public static double get_IconGridHeight();
    public static double get_MaximizedPrimaryScreenWidth();
    public static double get_MaximizedPrimaryScreenHeight();
    public static double get_MaximumWindowTrackWidth();
    public static double get_MaximumWindowTrackHeight();
    public static double get_MenuCheckmarkWidth();
    public static double get_MenuCheckmarkHeight();
    public static double get_MenuButtonWidth();
    public static double get_MenuButtonHeight();
    public static double get_MinimumWindowWidth();
    public static double get_MinimumWindowHeight();
    public static double get_MinimizedWindowWidth();
    public static double get_MinimizedWindowHeight();
    public static double get_MinimizedGridWidth();
    public static double get_MinimizedGridHeight();
    public static double get_MinimumWindowTrackWidth();
    public static double get_MinimumWindowTrackHeight();
    public static double get_PrimaryScreenWidth();
    public static double get_PrimaryScreenHeight();
    public static double get_WindowCaptionButtonWidth();
    public static double get_WindowCaptionButtonHeight();
    public static double get_ResizeFrameHorizontalBorderHeight();
    public static double get_ResizeFrameVerticalBorderWidth();
    public static double get_SmallIconWidth();
    public static double get_SmallIconHeight();
    public static double get_SmallWindowCaptionButtonWidth();
    public static double get_SmallWindowCaptionButtonHeight();
    public static double get_VirtualScreenWidth();
    public static double get_VirtualScreenHeight();
    public static double get_VerticalScrollBarWidth();
    public static double get_VerticalScrollBarButtonHeight();
    public static double get_WindowCaptionHeight();
    public static double get_KanjiWindowHeight();
    public static double get_MenuBarHeight();
    public static double get_VerticalScrollBarThumbHeight();
    public static bool get_IsImmEnabled();
    public static bool get_IsMediaCenter();
    public static bool get_IsMenuDropRightAligned();
    public static bool get_IsMiddleEastEnabled();
    public static bool get_IsMousePresent();
    public static bool get_IsMouseWheelPresent();
    public static bool get_IsPenWindows();
    public static bool get_IsRemotelyControlled();
    public static bool get_IsRemoteSession();
    public static bool get_ShowSounds();
    public static bool get_IsSlowMachine();
    public static bool get_SwapButtons();
    public static bool get_IsTabletPC();
    public static double get_VirtualScreenLeft();
    public static double get_VirtualScreenTop();
    public static ResourceKey get_ThinHorizontalBorderHeightKey();
    public static ResourceKey get_ThinVerticalBorderWidthKey();
    public static ResourceKey get_CursorWidthKey();
    public static ResourceKey get_CursorHeightKey();
    public static ResourceKey get_ThickHorizontalBorderHeightKey();
    public static ResourceKey get_ThickVerticalBorderWidthKey();
    public static ResourceKey get_FixedFrameHorizontalBorderHeightKey();
    public static ResourceKey get_FixedFrameVerticalBorderWidthKey();
    public static ResourceKey get_FocusHorizontalBorderHeightKey();
    public static ResourceKey get_FocusVerticalBorderWidthKey();
    public static ResourceKey get_FullPrimaryScreenWidthKey();
    public static ResourceKey get_FullPrimaryScreenHeightKey();
    public static ResourceKey get_HorizontalScrollBarButtonWidthKey();
    public static ResourceKey get_HorizontalScrollBarHeightKey();
    public static ResourceKey get_HorizontalScrollBarThumbWidthKey();
    public static ResourceKey get_IconWidthKey();
    public static ResourceKey get_IconHeightKey();
    public static ResourceKey get_IconGridWidthKey();
    public static ResourceKey get_IconGridHeightKey();
    public static ResourceKey get_MaximizedPrimaryScreenWidthKey();
    public static ResourceKey get_MaximizedPrimaryScreenHeightKey();
    public static ResourceKey get_MaximumWindowTrackWidthKey();
    public static ResourceKey get_MaximumWindowTrackHeightKey();
    public static ResourceKey get_MenuCheckmarkWidthKey();
    public static ResourceKey get_MenuCheckmarkHeightKey();
    public static ResourceKey get_MenuButtonWidthKey();
    public static ResourceKey get_MenuButtonHeightKey();
    public static ResourceKey get_MinimumWindowWidthKey();
    public static ResourceKey get_MinimumWindowHeightKey();
    public static ResourceKey get_MinimizedWindowWidthKey();
    public static ResourceKey get_MinimizedWindowHeightKey();
    public static ResourceKey get_MinimizedGridWidthKey();
    public static ResourceKey get_MinimizedGridHeightKey();
    public static ResourceKey get_MinimumWindowTrackWidthKey();
    public static ResourceKey get_MinimumWindowTrackHeightKey();
    public static ResourceKey get_PrimaryScreenWidthKey();
    public static ResourceKey get_PrimaryScreenHeightKey();
    public static ResourceKey get_WindowCaptionButtonWidthKey();
    public static ResourceKey get_WindowCaptionButtonHeightKey();
    public static ResourceKey get_ResizeFrameHorizontalBorderHeightKey();
    public static ResourceKey get_ResizeFrameVerticalBorderWidthKey();
    public static ResourceKey get_SmallIconWidthKey();
    public static ResourceKey get_SmallIconHeightKey();
    public static ResourceKey get_SmallWindowCaptionButtonWidthKey();
    public static ResourceKey get_SmallWindowCaptionButtonHeightKey();
    public static ResourceKey get_VirtualScreenWidthKey();
    public static ResourceKey get_VirtualScreenHeightKey();
    public static ResourceKey get_VerticalScrollBarWidthKey();
    public static ResourceKey get_VerticalScrollBarButtonHeightKey();
    public static ResourceKey get_WindowCaptionHeightKey();
    public static ResourceKey get_KanjiWindowHeightKey();
    public static ResourceKey get_MenuBarHeightKey();
    public static ResourceKey get_SmallCaptionHeightKey();
    public static ResourceKey get_VerticalScrollBarThumbHeightKey();
    public static ResourceKey get_IsImmEnabledKey();
    public static ResourceKey get_IsMediaCenterKey();
    public static ResourceKey get_IsMenuDropRightAlignedKey();
    public static ResourceKey get_IsMiddleEastEnabledKey();
    public static ResourceKey get_IsMousePresentKey();
    public static ResourceKey get_IsMouseWheelPresentKey();
    public static ResourceKey get_IsPenWindowsKey();
    public static ResourceKey get_IsRemotelyControlledKey();
    public static ResourceKey get_IsRemoteSessionKey();
    public static ResourceKey get_ShowSoundsKey();
    public static ResourceKey get_IsSlowMachineKey();
    public static ResourceKey get_SwapButtonsKey();
    public static ResourceKey get_IsTabletPCKey();
    public static ResourceKey get_VirtualScreenLeftKey();
    public static ResourceKey get_VirtualScreenTopKey();
    public static ResourceKey get_FocusVisualStyleKey();
    public static ResourceKey get_NavigationChromeStyleKey();
    public static ResourceKey get_NavigationChromeDownLevelStyleKey();
    public static PowerLineStatus get_PowerLineStatus();
    public static ResourceKey get_PowerLineStatusKey();
    internal static void InvalidateCache();
    internal static bool InvalidateDeviceDependentCache();
    internal static bool InvalidateDisplayDependentCache();
    internal static bool InvalidatePowerDependentCache();
    internal static bool InvalidateCache(int param);
    internal static bool InvalidateIsGlassEnabled();
    internal static void InvalidateDerivedThemeRelatedProperties();
    internal static void InvalidateWindowGlassColorizationProperties();
    internal static void InvalidateWindowFrameThicknessProperties();
    public static bool get_IsGlassEnabled();
    public static string get_UxThemeName();
    public static string get_UxThemeColor();
    public static CornerRadius get_WindowCornerRadius();
    public static Color get_WindowGlassColor();
    public static Brush get_WindowGlassBrush();
    public static Thickness get_WindowResizeBorderThickness();
    public static Thickness get_WindowNonClientFrameThickness();
    internal static int get_Dpi();
    internal static int get_DpiX();
    internal static double ConvertPixel(int pixel);
}
internal class System.Windows.SystemResourceHost : object {
    private static SystemResourceHost _instance;
    internal static SystemResourceHost Instance { get; }
    internal static SystemResourceHost get_Instance();
}
[TypeConverterAttribute("System.Windows.Markup.SystemKeyConverter")]
internal class System.Windows.SystemResourceKey : ResourceKey {
    private static short SystemResourceKeyIDStart;
    private static short SystemResourceKeyIDEnd;
    private static short SystemResourceKeyIDExtendedStart;
    private static short SystemResourceKeyIDExtendedEnd;
    private static short SystemResourceKeyBAMLIDStart;
    private static short SystemResourceKeyBAMLIDEnd;
    private static short SystemResourceBAMLIDStart;
    private static short SystemResourceBAMLIDEnd;
    private static short SystemResourceKeyBAMLIDExtendedStart;
    private static short SystemResourceKeyBAMLIDExtendedEnd;
    private static short SystemResourceBAMLIDExtendedStart;
    private static short SystemResourceBAMLIDExtendedEnd;
    private static SystemThemeKey _cacheSeparatorStyle;
    private static SystemThemeKey _cacheCheckBoxStyle;
    private static SystemThemeKey _cacheToggleButtonStyle;
    private static SystemThemeKey _cacheButtonStyle;
    private static SystemThemeKey _cacheRadioButtonStyle;
    private static SystemThemeKey _cacheComboBoxStyle;
    private static SystemThemeKey _cacheTextBoxStyle;
    private static SystemThemeKey _cacheMenuStyle;
    private static ComponentResourceKey _focusBorderBrushKey;
    private static ComponentResourceKey _textBlockComboBoxStyleKey;
    private static SystemThemeKey _menuItemSeparatorStyleKey;
    private static ComponentResourceKey _columnHeaderDropSeparatorStyleKey;
    private static ComponentResourceKey _columnFloatingHeaderStyleKey;
    private static SystemThemeKey _gridViewItemContainerStyleKey;
    private static SystemThemeKey _scrollViewerStyleKey;
    private static SystemThemeKey _gridViewStyleKey;
    private static SystemThemeKey _statusBarSeparatorStyleKey;
    private SystemResourceKeyID _id;
    [ThreadStaticAttribute]
private static SystemResourceKey _srk;
    internal object Resource { get; }
    internal SystemResourceKeyID InternalKey { get; }
    public Assembly Assembly { get; }
    internal static ComponentResourceKey DataGridFocusBorderBrushKey { get; }
    internal static ComponentResourceKey DataGridComboBoxColumnTextBlockComboBoxStyleKey { get; }
    internal static ResourceKey MenuItemSeparatorStyleKey { get; }
    internal static ComponentResourceKey DataGridColumnHeaderColumnFloatingHeaderStyleKey { get; }
    internal static ComponentResourceKey DataGridColumnHeaderColumnHeaderDropSeparatorStyleKey { get; }
    internal static ResourceKey GridViewItemContainerStyleKey { get; }
    internal static ResourceKey GridViewScrollViewerStyleKey { get; }
    internal static ResourceKey GridViewStyleKey { get; }
    internal static ResourceKey StatusBarSeparatorStyleKey { get; }
    internal static ResourceKey ToolBarButtonStyleKey { get; }
    internal static ResourceKey ToolBarToggleButtonStyleKey { get; }
    internal static ResourceKey ToolBarSeparatorStyleKey { get; }
    internal static ResourceKey ToolBarCheckBoxStyleKey { get; }
    internal static ResourceKey ToolBarRadioButtonStyleKey { get; }
    internal static ResourceKey ToolBarComboBoxStyleKey { get; }
    internal static ResourceKey ToolBarTextBoxStyleKey { get; }
    internal static ResourceKey ToolBarMenuStyleKey { get; }
    internal SystemResourceKey(SystemResourceKeyID id);
    internal static short GetSystemResourceKeyIdFromBamlId(short bamlId, Boolean& isKey);
    internal static short GetBamlIdBasedOnSystemResourceKeyId(Type targetType, string memberName);
    internal object get_Resource();
    internal static ResourceKey GetResourceKey(short id);
    internal static ResourceKey GetSystemResourceKey(string keyName);
    internal static object GetResource(short id);
    internal SystemResourceKeyID get_InternalKey();
    public virtual Assembly get_Assembly();
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
    public virtual string ToString();
    internal static ComponentResourceKey get_DataGridFocusBorderBrushKey();
    internal static ComponentResourceKey get_DataGridComboBoxColumnTextBlockComboBoxStyleKey();
    internal static ResourceKey get_MenuItemSeparatorStyleKey();
    internal static ComponentResourceKey get_DataGridColumnHeaderColumnFloatingHeaderStyleKey();
    internal static ComponentResourceKey get_DataGridColumnHeaderColumnHeaderDropSeparatorStyleKey();
    internal static ResourceKey get_GridViewItemContainerStyleKey();
    internal static ResourceKey get_GridViewScrollViewerStyleKey();
    internal static ResourceKey get_GridViewStyleKey();
    internal static ResourceKey get_StatusBarSeparatorStyleKey();
    internal static ResourceKey get_ToolBarButtonStyleKey();
    internal static ResourceKey get_ToolBarToggleButtonStyleKey();
    internal static ResourceKey get_ToolBarSeparatorStyleKey();
    internal static ResourceKey get_ToolBarCheckBoxStyleKey();
    internal static ResourceKey get_ToolBarRadioButtonStyleKey();
    internal static ResourceKey get_ToolBarComboBoxStyleKey();
    internal static ResourceKey get_ToolBarTextBoxStyleKey();
    internal static ResourceKey get_ToolBarMenuStyleKey();
}
internal enum System.Windows.SystemResourceKeyID : Enum {
    public int value__;
    public static SystemResourceKeyID InternalSystemColorsStart;
    public static SystemResourceKeyID ActiveBorderBrush;
    public static SystemResourceKeyID ActiveCaptionBrush;
    public static SystemResourceKeyID ActiveCaptionTextBrush;
    public static SystemResourceKeyID AppWorkspaceBrush;
    public static SystemResourceKeyID ControlBrush;
    public static SystemResourceKeyID ControlDarkBrush;
    public static SystemResourceKeyID ControlDarkDarkBrush;
    public static SystemResourceKeyID ControlLightBrush;
    public static SystemResourceKeyID ControlLightLightBrush;
    public static SystemResourceKeyID ControlTextBrush;
    public static SystemResourceKeyID DesktopBrush;
    public static SystemResourceKeyID GradientActiveCaptionBrush;
    public static SystemResourceKeyID GradientInactiveCaptionBrush;
    public static SystemResourceKeyID GrayTextBrush;
    public static SystemResourceKeyID HighlightBrush;
    public static SystemResourceKeyID HighlightTextBrush;
    public static SystemResourceKeyID HotTrackBrush;
    public static SystemResourceKeyID InactiveBorderBrush;
    public static SystemResourceKeyID InactiveCaptionBrush;
    public static SystemResourceKeyID InactiveCaptionTextBrush;
    public static SystemResourceKeyID InfoBrush;
    public static SystemResourceKeyID InfoTextBrush;
    public static SystemResourceKeyID MenuBrush;
    public static SystemResourceKeyID MenuBarBrush;
    public static SystemResourceKeyID MenuHighlightBrush;
    public static SystemResourceKeyID MenuTextBrush;
    public static SystemResourceKeyID ScrollBarBrush;
    public static SystemResourceKeyID WindowBrush;
    public static SystemResourceKeyID WindowFrameBrush;
    public static SystemResourceKeyID WindowTextBrush;
    public static SystemResourceKeyID ActiveBorderColor;
    public static SystemResourceKeyID ActiveCaptionColor;
    public static SystemResourceKeyID ActiveCaptionTextColor;
    public static SystemResourceKeyID AppWorkspaceColor;
    public static SystemResourceKeyID ControlColor;
    public static SystemResourceKeyID ControlDarkColor;
    public static SystemResourceKeyID ControlDarkDarkColor;
    public static SystemResourceKeyID ControlLightColor;
    public static SystemResourceKeyID ControlLightLightColor;
    public static SystemResourceKeyID ControlTextColor;
    public static SystemResourceKeyID DesktopColor;
    public static SystemResourceKeyID GradientActiveCaptionColor;
    public static SystemResourceKeyID GradientInactiveCaptionColor;
    public static SystemResourceKeyID GrayTextColor;
    public static SystemResourceKeyID HighlightColor;
    public static SystemResourceKeyID HighlightTextColor;
    public static SystemResourceKeyID HotTrackColor;
    public static SystemResourceKeyID InactiveBorderColor;
    public static SystemResourceKeyID InactiveCaptionColor;
    public static SystemResourceKeyID InactiveCaptionTextColor;
    public static SystemResourceKeyID InfoColor;
    public static SystemResourceKeyID InfoTextColor;
    public static SystemResourceKeyID MenuColor;
    public static SystemResourceKeyID MenuBarColor;
    public static SystemResourceKeyID MenuHighlightColor;
    public static SystemResourceKeyID MenuTextColor;
    public static SystemResourceKeyID ScrollBarColor;
    public static SystemResourceKeyID WindowColor;
    public static SystemResourceKeyID WindowFrameColor;
    public static SystemResourceKeyID WindowTextColor;
    public static SystemResourceKeyID InternalSystemColorsEnd;
    public static SystemResourceKeyID InternalSystemFontsStart;
    public static SystemResourceKeyID CaptionFontSize;
    public static SystemResourceKeyID CaptionFontFamily;
    public static SystemResourceKeyID CaptionFontStyle;
    public static SystemResourceKeyID CaptionFontWeight;
    public static SystemResourceKeyID CaptionFontTextDecorations;
    public static SystemResourceKeyID SmallCaptionFontSize;
    public static SystemResourceKeyID SmallCaptionFontFamily;
    public static SystemResourceKeyID SmallCaptionFontStyle;
    public static SystemResourceKeyID SmallCaptionFontWeight;
    public static SystemResourceKeyID SmallCaptionFontTextDecorations;
    public static SystemResourceKeyID MenuFontSize;
    public static SystemResourceKeyID MenuFontFamily;
    public static SystemResourceKeyID MenuFontStyle;
    public static SystemResourceKeyID MenuFontWeight;
    public static SystemResourceKeyID MenuFontTextDecorations;
    public static SystemResourceKeyID StatusFontSize;
    public static SystemResourceKeyID StatusFontFamily;
    public static SystemResourceKeyID StatusFontStyle;
    public static SystemResourceKeyID StatusFontWeight;
    public static SystemResourceKeyID StatusFontTextDecorations;
    public static SystemResourceKeyID MessageFontSize;
    public static SystemResourceKeyID MessageFontFamily;
    public static SystemResourceKeyID MessageFontStyle;
    public static SystemResourceKeyID MessageFontWeight;
    public static SystemResourceKeyID MessageFontTextDecorations;
    public static SystemResourceKeyID IconFontSize;
    public static SystemResourceKeyID IconFontFamily;
    public static SystemResourceKeyID IconFontStyle;
    public static SystemResourceKeyID IconFontWeight;
    public static SystemResourceKeyID IconFontTextDecorations;
    public static SystemResourceKeyID InternalSystemFontsEnd;
    public static SystemResourceKeyID InternalSystemParametersStart;
    public static SystemResourceKeyID ThinHorizontalBorderHeight;
    public static SystemResourceKeyID ThinVerticalBorderWidth;
    public static SystemResourceKeyID CursorWidth;
    public static SystemResourceKeyID CursorHeight;
    public static SystemResourceKeyID ThickHorizontalBorderHeight;
    public static SystemResourceKeyID ThickVerticalBorderWidth;
    public static SystemResourceKeyID FixedFrameHorizontalBorderHeight;
    public static SystemResourceKeyID FixedFrameVerticalBorderWidth;
    public static SystemResourceKeyID FocusHorizontalBorderHeight;
    public static SystemResourceKeyID FocusVerticalBorderWidth;
    public static SystemResourceKeyID FullPrimaryScreenWidth;
    public static SystemResourceKeyID FullPrimaryScreenHeight;
    public static SystemResourceKeyID HorizontalScrollBarButtonWidth;
    public static SystemResourceKeyID HorizontalScrollBarHeight;
    public static SystemResourceKeyID HorizontalScrollBarThumbWidth;
    public static SystemResourceKeyID IconWidth;
    public static SystemResourceKeyID IconHeight;
    public static SystemResourceKeyID IconGridWidth;
    public static SystemResourceKeyID IconGridHeight;
    public static SystemResourceKeyID MaximizedPrimaryScreenWidth;
    public static SystemResourceKeyID MaximizedPrimaryScreenHeight;
    public static SystemResourceKeyID MaximumWindowTrackWidth;
    public static SystemResourceKeyID MaximumWindowTrackHeight;
    public static SystemResourceKeyID MenuCheckmarkWidth;
    public static SystemResourceKeyID MenuCheckmarkHeight;
    public static SystemResourceKeyID MenuButtonWidth;
    public static SystemResourceKeyID MenuButtonHeight;
    public static SystemResourceKeyID MinimumWindowWidth;
    public static SystemResourceKeyID MinimumWindowHeight;
    public static SystemResourceKeyID MinimizedWindowWidth;
    public static SystemResourceKeyID MinimizedWindowHeight;
    public static SystemResourceKeyID MinimizedGridWidth;
    public static SystemResourceKeyID MinimizedGridHeight;
    public static SystemResourceKeyID MinimumWindowTrackWidth;
    public static SystemResourceKeyID MinimumWindowTrackHeight;
    public static SystemResourceKeyID PrimaryScreenWidth;
    public static SystemResourceKeyID PrimaryScreenHeight;
    public static SystemResourceKeyID WindowCaptionButtonWidth;
    public static SystemResourceKeyID WindowCaptionButtonHeight;
    public static SystemResourceKeyID ResizeFrameHorizontalBorderHeight;
    public static SystemResourceKeyID ResizeFrameVerticalBorderWidth;
    public static SystemResourceKeyID SmallIconWidth;
    public static SystemResourceKeyID SmallIconHeight;
    public static SystemResourceKeyID SmallWindowCaptionButtonWidth;
    public static SystemResourceKeyID SmallWindowCaptionButtonHeight;
    public static SystemResourceKeyID VirtualScreenWidth;
    public static SystemResourceKeyID VirtualScreenHeight;
    public static SystemResourceKeyID VerticalScrollBarWidth;
    public static SystemResourceKeyID VerticalScrollBarButtonHeight;
    public static SystemResourceKeyID WindowCaptionHeight;
    public static SystemResourceKeyID KanjiWindowHeight;
    public static SystemResourceKeyID MenuBarHeight;
    public static SystemResourceKeyID SmallCaptionHeight;
    public static SystemResourceKeyID VerticalScrollBarThumbHeight;
    public static SystemResourceKeyID IsImmEnabled;
    public static SystemResourceKeyID IsMediaCenter;
    public static SystemResourceKeyID IsMenuDropRightAligned;
    public static SystemResourceKeyID IsMiddleEastEnabled;
    public static SystemResourceKeyID IsMousePresent;
    public static SystemResourceKeyID IsMouseWheelPresent;
    public static SystemResourceKeyID IsPenWindows;
    public static SystemResourceKeyID IsRemotelyControlled;
    public static SystemResourceKeyID IsRemoteSession;
    public static SystemResourceKeyID ShowSounds;
    public static SystemResourceKeyID IsSlowMachine;
    public static SystemResourceKeyID SwapButtons;
    public static SystemResourceKeyID IsTabletPC;
    public static SystemResourceKeyID VirtualScreenLeft;
    public static SystemResourceKeyID VirtualScreenTop;
    public static SystemResourceKeyID FocusBorderWidth;
    public static SystemResourceKeyID FocusBorderHeight;
    public static SystemResourceKeyID HighContrast;
    public static SystemResourceKeyID DropShadow;
    public static SystemResourceKeyID FlatMenu;
    public static SystemResourceKeyID WorkArea;
    public static SystemResourceKeyID IconHorizontalSpacing;
    public static SystemResourceKeyID IconVerticalSpacing;
    public static SystemResourceKeyID IconTitleWrap;
    public static SystemResourceKeyID KeyboardCues;
    public static SystemResourceKeyID KeyboardDelay;
    public static SystemResourceKeyID KeyboardPreference;
    public static SystemResourceKeyID KeyboardSpeed;
    public static SystemResourceKeyID SnapToDefaultButton;
    public static SystemResourceKeyID WheelScrollLines;
    public static SystemResourceKeyID MouseHoverTime;
    public static SystemResourceKeyID MouseHoverHeight;
    public static SystemResourceKeyID MouseHoverWidth;
    public static SystemResourceKeyID MenuDropAlignment;
    public static SystemResourceKeyID MenuFade;
    public static SystemResourceKeyID MenuShowDelay;
    public static SystemResourceKeyID ComboBoxAnimation;
    public static SystemResourceKeyID ClientAreaAnimation;
    public static SystemResourceKeyID CursorShadow;
    public static SystemResourceKeyID GradientCaptions;
    public static SystemResourceKeyID HotTracking;
    public static SystemResourceKeyID ListBoxSmoothScrolling;
    public static SystemResourceKeyID MenuAnimation;
    public static SystemResourceKeyID SelectionFade;
    public static SystemResourceKeyID StylusHotTracking;
    public static SystemResourceKeyID ToolTipAnimation;
    public static SystemResourceKeyID ToolTipFade;
    public static SystemResourceKeyID UIEffects;
    public static SystemResourceKeyID MinimizeAnimation;
    public static SystemResourceKeyID Border;
    public static SystemResourceKeyID CaretWidth;
    public static SystemResourceKeyID ForegroundFlashCount;
    public static SystemResourceKeyID DragFullWindows;
    public static SystemResourceKeyID BorderWidth;
    public static SystemResourceKeyID ScrollWidth;
    public static SystemResourceKeyID ScrollHeight;
    public static SystemResourceKeyID CaptionWidth;
    public static SystemResourceKeyID CaptionHeight;
    public static SystemResourceKeyID SmallCaptionWidth;
    public static SystemResourceKeyID MenuWidth;
    public static SystemResourceKeyID MenuHeight;
    public static SystemResourceKeyID ComboBoxPopupAnimation;
    public static SystemResourceKeyID MenuPopupAnimation;
    public static SystemResourceKeyID ToolTipPopupAnimation;
    public static SystemResourceKeyID PowerLineStatus;
    public static SystemResourceKeyID InternalSystemThemeStylesStart;
    public static SystemResourceKeyID FocusVisualStyle;
    public static SystemResourceKeyID NavigationChromeDownLevelStyle;
    public static SystemResourceKeyID NavigationChromeStyle;
    public static SystemResourceKeyID InternalSystemParametersEnd;
    public static SystemResourceKeyID MenuItemSeparatorStyle;
    public static SystemResourceKeyID GridViewScrollViewerStyle;
    public static SystemResourceKeyID GridViewStyle;
    public static SystemResourceKeyID GridViewItemContainerStyle;
    public static SystemResourceKeyID StatusBarSeparatorStyle;
    public static SystemResourceKeyID ToolBarButtonStyle;
    public static SystemResourceKeyID ToolBarToggleButtonStyle;
    public static SystemResourceKeyID ToolBarSeparatorStyle;
    public static SystemResourceKeyID ToolBarCheckBoxStyle;
    public static SystemResourceKeyID ToolBarRadioButtonStyle;
    public static SystemResourceKeyID ToolBarComboBoxStyle;
    public static SystemResourceKeyID ToolBarTextBoxStyle;
    public static SystemResourceKeyID ToolBarMenuStyle;
    public static SystemResourceKeyID InternalSystemThemeStylesEnd;
    public static SystemResourceKeyID InternalSystemColorsExtendedStart;
    public static SystemResourceKeyID InactiveSelectionHighlightBrush;
    public static SystemResourceKeyID InactiveSelectionHighlightTextBrush;
    public static SystemResourceKeyID InternalSystemColorsExtendedEnd;
}
internal static class System.Windows.SystemResources : object {
    [ThreadStaticAttribute]
private static int _parsing;
    [ThreadStaticAttribute]
private static List`1<HwndDpiInfo> _dpiAwarenessContextAndDpis;
    [ThreadStaticAttribute]
private static Dictionary`2<HwndDpiInfo, SecurityCriticalDataClass`1<HwndWrapper>> _hwndNotify;
    [ThreadStaticAttribute]
private static Dictionary`2<HwndDpiInfo, HwndWrapperHook> _hwndNotifyHook;
    private static Hashtable _resourceCache;
    private static DTypeMap _themeStyleCache;
    private static Dictionary`2<Assembly, ResourceDictionaries> _dictionaries;
    private static object _specialNull;
    internal static string GenericResourceName;
    internal static string ClassicResourceName;
    private static Assembly _mscorlib;
    private static Assembly _presentationFramework;
    private static Assembly _presentationCore;
    private static Assembly _windowsBase;
    internal static string PresentationFrameworkName;
    internal static bool SystemResourcesHaveChanged;
    [ThreadStaticAttribute]
internal static bool SystemResourcesAreChanging;
    [CompilerGeneratedAttribute]
private static EventHandler`1<ResourceDictionaryLoadedEventArgs> ThemedDictionaryLoaded;
    [CompilerGeneratedAttribute]
private static EventHandler`1<ResourceDictionaryUnloadedEventArgs> ThemedDictionaryUnloaded;
    [CompilerGeneratedAttribute]
private static EventHandler`1<ResourceDictionaryLoadedEventArgs> GenericDictionaryLoaded;
    internal static ReadOnlyCollection`1<ResourceDictionaryInfo> ThemedResourceDictionaries { get; }
    internal static ReadOnlyCollection`1<ResourceDictionaryInfo> GenericResourceDictionaries { get; }
    private static Assembly MsCorLib { get; }
    private static Assembly PresentationFramework { get; }
    private static Assembly PresentationCore { get; }
    private static Assembly WindowsBase { get; }
    internal static bool IsSystemResourcesParsing { get; internal set; }
    internal static object ThemeDictionaryLock { get; }
    private static DpiAwarenessContextValue ProcessDpiAwarenessContextValue { get; }
    private static bool IsPerMonitorDpiScalingActive { get; }
    private static HwndWrapper Hwnd { get; }
    private static SystemResources();
    internal static object FindThemeStyle(DependencyObjectType key);
    internal static object FindResourceInternal(object key);
    internal static object FindResourceInternal(object key, bool allowDeferredResourceReference, bool mustReturnDeferredResourceReference);
    internal static ReadOnlyCollection`1<ResourceDictionaryInfo> get_ThemedResourceDictionaries();
    internal static ReadOnlyCollection`1<ResourceDictionaryInfo> get_GenericResourceDictionaries();
    internal static void CacheResource(object key, object resource, bool isTraceEnabled);
    private static bool FindCachedResource(object key, Object& resource, bool mustReturnDeferredResourceReference);
    private static object FindDictionaryResource(object key, Type typeKey, ResourceKey resourceKey, bool isTraceEnabled, bool allowDeferredResourceReference, bool mustReturnDeferredResourceReference, Boolean& canCache);
    private static object LookupResourceInDictionary(ResourceDictionary dictionary, object key, bool allowDeferredResourceReference, bool mustReturnDeferredResourceReference, Boolean& canCache);
    private static void Freeze(object resource);
    private static ResourceDictionaries EnsureDictionarySlot(Assembly assembly);
    private static bool IgnoreAssembly(Assembly assembly);
    private static Assembly get_MsCorLib();
    private static Assembly get_PresentationFramework();
    private static Assembly get_PresentationCore();
    private static Assembly get_WindowsBase();
    private static void EnsureResourceChangeListener();
    private static bool EnsureResourceChangeListener(HwndDpiInfo hwndDpiInfo);
    private static HwndDpiInfo CreateResourceChangeListenerWindow(DpiAwarenessContextValue dpiContextValue, int x, int y, string callerName);
    private static void OnShutdownFinished(object sender, EventArgs args);
    private static DpiScale2 GetDpiScaleForUnawareOrSystemAwareContext(DpiAwarenessContextValue dpiContextValue);
    private static void OnThemeChanged();
    private static void OnSystemValueChanged();
    private static object InvalidateTreeResources(object args);
    private static void InvalidateTabletDevices(WindowMessage msg, IntPtr wParam, IntPtr lParam);
    private static void InvalidateResources(bool isSysColorsOrSettingsChange);
    private static IntPtr SystemThemeFilterMessage(IntPtr hwnd, int msg, IntPtr wParam, IntPtr lParam, Boolean& handled);
    internal static bool ClearBitArray(BitArray cacheValid);
    internal static bool ClearSlot(BitArray cacheValid, int slot);
    internal static bool get_IsSystemResourcesParsing();
    internal static void set_IsSystemResourcesParsing(bool value);
    internal static object get_ThemeDictionaryLock();
    private static DpiAwarenessContextValue get_ProcessDpiAwarenessContextValue();
    private static bool get_IsPerMonitorDpiScalingActive();
    private static HwndWrapper get_Hwnd();
    internal static HwndWrapper GetDpiAwarenessCompatibleNotificationWindow(HandleRef hwnd);
    internal static void DelayHwndShutdown();
    [CompilerGeneratedAttribute]
internal static void add_ThemedDictionaryLoaded(EventHandler`1<ResourceDictionaryLoadedEventArgs> value);
    [CompilerGeneratedAttribute]
internal static void remove_ThemedDictionaryLoaded(EventHandler`1<ResourceDictionaryLoadedEventArgs> value);
    [CompilerGeneratedAttribute]
internal static void add_ThemedDictionaryUnloaded(EventHandler`1<ResourceDictionaryUnloadedEventArgs> value);
    [CompilerGeneratedAttribute]
internal static void remove_ThemedDictionaryUnloaded(EventHandler`1<ResourceDictionaryUnloadedEventArgs> value);
    [CompilerGeneratedAttribute]
internal static void add_GenericDictionaryLoaded(EventHandler`1<ResourceDictionaryLoadedEventArgs> value);
    [CompilerGeneratedAttribute]
internal static void remove_GenericDictionaryLoaded(EventHandler`1<ResourceDictionaryLoadedEventArgs> value);
}
[TypeConverterAttribute("System.Windows.Markup.SystemKeyConverter")]
internal class System.Windows.SystemThemeKey : ResourceKey {
    private SystemResourceKeyID _id;
    private static Assembly _presentationFrameworkAssembly;
    public Assembly Assembly { get; }
    internal SystemResourceKeyID InternalKey { get; }
    internal SystemThemeKey(SystemResourceKeyID id);
    public virtual Assembly get_Assembly();
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
    public virtual string ToString();
    internal SystemResourceKeyID get_InternalKey();
}
[TypeConverterAttribute("System.Windows.TemplateBindingExpressionConverter")]
public class System.Windows.TemplateBindingExpression : Expression {
    private TemplateBindingExtension _templateBindingExtension;
    public TemplateBindingExtension TemplateBindingExtension { get; }
    internal TemplateBindingExpression(TemplateBindingExtension templateBindingExtension);
    public TemplateBindingExtension get_TemplateBindingExtension();
    internal virtual object GetValue(DependencyObject d, DependencyProperty dp);
}
public class System.Windows.TemplateBindingExpressionConverter : TypeConverter {
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
[MarkupExtensionReturnTypeAttribute("System.Object")]
[TypeConverterAttribute("System.Windows.TemplateBindingExtensionConverter")]
public class System.Windows.TemplateBindingExtension : MarkupExtension {
    private DependencyProperty _property;
    private IValueConverter _converter;
    private object _parameter;
    [ConstructorArgumentAttribute("property")]
public DependencyProperty Property { get; public set; }
    [DefaultValueAttribute("")]
public IValueConverter Converter { get; public set; }
    [DefaultValueAttribute("")]
public object ConverterParameter { get; public set; }
    public TemplateBindingExtension(DependencyProperty property);
    public virtual object ProvideValue(IServiceProvider serviceProvider);
    public DependencyProperty get_Property();
    public void set_Property(DependencyProperty value);
    public IValueConverter get_Converter();
    public void set_Converter(IValueConverter value);
    public object get_ConverterParameter();
    public void set_ConverterParameter(object value);
}
public class System.Windows.TemplateBindingExtensionConverter : TypeConverter {
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
[XamlDeferLoadAttribute("System.Windows.TemplateContentLoader", "System.Windows.FrameworkElement")]
public class System.Windows.TemplateContent : object {
    [CompilerGeneratedAttribute]
private XamlType <RootType>k__BackingField;
    [CompilerGeneratedAttribute]
private FrameworkTemplate <OwnerTemplate>k__BackingField;
    [CompilerGeneratedAttribute]
private IXamlObjectWriterFactory <ObjectWriterFactory>k__BackingField;
    [CompilerGeneratedAttribute]
private XamlObjectWriterSettings <ObjectWriterParentSettings>k__BackingField;
    [CompilerGeneratedAttribute]
private XamlSchemaContext <SchemaContext>k__BackingField;
    internal XamlNodeList _xamlNodeList;
    private static SharedDp _sharedDpInstance;
    [CompilerGeneratedAttribute]
private TemplateLoadData <TemplateLoadData>k__BackingField;
    internal XamlType RootType { get; private set; }
    internal FrameworkTemplate OwnerTemplate { get; internal set; }
    internal IXamlObjectWriterFactory ObjectWriterFactory { get; private set; }
    internal XamlObjectWriterSettings ObjectWriterParentSettings { get; private set; }
    internal XamlSchemaContext SchemaContext { get; private set; }
    private StackOfFrames Stack { get; private set; }
    internal TemplateLoadData TemplateLoadData { get; internal set; }
    internal TemplateContent(XamlReader xamlReader, IXamlObjectWriterFactory factory, IServiceProvider context);
    private static TemplateContent();
    private void Initialize(IServiceProvider context);
    internal void ParseXaml();
    internal XamlReader PlayXaml();
    internal void ResetTemplateLoadData();
    private void UpdateSharedPropertyNames(string name, List`1<PropertyValue> sharedProperties, XamlType type);
    private void ParseTree(StackOfFrames stack, List`1<PropertyValue> sharedProperties, Int32& nameNumber);
    private void ParseNodes(StackOfFrames stack, List`1<PropertyValue> sharedProperties, Int32& nameNumber);
    private bool ParseNode(XamlReader xamlReader, StackOfFrames stack, List`1<PropertyValue> sharedProperties, Int32& nameNumber, Object& newValue);
    private StaticResourceExtension LoadTimeBindUnshareableStaticResource(XamlReader xamlReader, XamlObjectWriter writer);
    private bool TrySharingProperty(XamlReader xamlReader, XamlType parentType, string parentName, FrugalObjectList`1<NamespaceDeclaration> previousNamespaces, Nullable`1& sharedValue);
    private static bool CheckSpecialCasesShareable(Type typeofValue, DependencyProperty property);
    private static bool IsFreezableDirective(XamlReader reader);
    private static void SkipFreeze(XamlReader reader);
    private bool TrySharingValue(DependencyProperty property, object value, string parentName, XamlReader xamlReader, bool allowRecursive, Nullable`1& sharedValue);
    private bool IsTypeShareable(Type type);
    private void WriteNamespaces(XamlWriter writer, FrugalObjectList`1<NamespaceDeclaration> previousNamespaces, FrugalObjectList`1<NamespaceDeclaration> localNamespaces);
    private static void AutoAliasContentPresenter(Type targetType, string contentSource, string templateChildName, FrugalStructList`1& childRecordFromChildIndex, FrugalStructList`1& triggerSourceRecordFromChildIndex, FrugalStructList`1& resourceDependents, HybridDictionary& dataTriggerRecordFromBinding, Boolean& hasInstanceValues, HybridDictionary childIndexFromChildName, bool isContentPropertyDefined, bool isContentSourceSet, bool isContentTemplatePropertyDefined, bool isContentTemplateSelectorPropertyDefined, bool isContentStringFormatPropertyDefined);
    private static void AutoAliasGridViewRowPresenter(Type targetType, string contentSource, string childName, FrugalStructList`1& childRecordFromChildIndex, FrugalStructList`1& triggerSourceRecordFromChildIndex, FrugalStructList`1& resourceDependents, HybridDictionary& dataTriggerRecordFromBinding, Boolean& hasInstanceValues, HybridDictionary childIndexFromChildID, bool isContentPropertyDefined, bool isColumnsPropertyDefined);
    [CompilerGeneratedAttribute]
internal XamlType get_RootType();
    [CompilerGeneratedAttribute]
private void set_RootType(XamlType value);
    internal XamlType GetTypeForName(string name);
    [CompilerGeneratedAttribute]
internal FrameworkTemplate get_OwnerTemplate();
    [CompilerGeneratedAttribute]
internal void set_OwnerTemplate(FrameworkTemplate value);
    [CompilerGeneratedAttribute]
internal IXamlObjectWriterFactory get_ObjectWriterFactory();
    [CompilerGeneratedAttribute]
private void set_ObjectWriterFactory(IXamlObjectWriterFactory value);
    [CompilerGeneratedAttribute]
internal XamlObjectWriterSettings get_ObjectWriterParentSettings();
    [CompilerGeneratedAttribute]
private void set_ObjectWriterParentSettings(XamlObjectWriterSettings value);
    [CompilerGeneratedAttribute]
internal XamlSchemaContext get_SchemaContext();
    [CompilerGeneratedAttribute]
private void set_SchemaContext(XamlSchemaContext value);
    private StackOfFrames get_Stack();
    private void set_Stack(StackOfFrames value);
    [CompilerGeneratedAttribute]
internal TemplateLoadData get_TemplateLoadData();
    [CompilerGeneratedAttribute]
internal void set_TemplateLoadData(TemplateLoadData value);
    [CompilerGeneratedAttribute]
private void <Initialize>b__3_0(object sender, XamlObjectEventArgs args);
}
public class System.Windows.TemplateContentLoader : XamlDeferringLoader {
    public virtual object Load(XamlReader xamlReader, IServiceProvider serviceProvider);
    private static T RequireService(IServiceProvider provider);
    public virtual XamlReader Save(object value, IServiceProvider serviceProvider);
}
[TypeConverterAttribute("System.Windows.Markup.TemplateKeyConverter")]
public abstract class System.Windows.TemplateKey : ResourceKey {
    private object _dataType;
    private TemplateType _templateType;
    private bool _initializing;
    public object DataType { get; public set; }
    public Assembly Assembly { get; }
    protected TemplateKey(TemplateType templateType);
    protected TemplateKey(TemplateType templateType, object dataType);
    private sealed virtual override void System.ComponentModel.ISupportInitialize.BeginInit();
    private sealed virtual override void System.ComponentModel.ISupportInitialize.EndInit();
    public object get_DataType();
    public void set_DataType(object value);
    public virtual int GetHashCode();
    public virtual bool Equals(object o);
    public virtual string ToString();
    public virtual Assembly get_Assembly();
    internal static Exception ValidateDataType(object dataType, string argName);
}
internal class System.Windows.TemplateLoadData : object {
    [CompilerGeneratedAttribute]
private StackOfFrames <Stack>k__BackingField;
    internal Dictionary`2<string, XamlType> _namedTypes;
    [CompilerGeneratedAttribute]
private XamlReader <Reader>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RootName>k__BackingField;
    [CompilerGeneratedAttribute]
private object <RootObject>k__BackingField;
    [CompilerGeneratedAttribute]
private ServiceProviderWrapper <ServiceProviderWrapper>k__BackingField;
    [CompilerGeneratedAttribute]
private XamlObjectWriter <ObjectWriter>k__BackingField;
    internal StackOfFrames Stack { get; internal set; }
    internal Dictionary`2<string, XamlType> NamedTypes { get; }
    internal XamlReader Reader { get; internal set; }
    internal string RootName { get; internal set; }
    internal object RootObject { get; internal set; }
    internal ServiceProviderWrapper ServiceProviderWrapper { get; internal set; }
    internal XamlObjectWriter ObjectWriter { get; internal set; }
    [CompilerGeneratedAttribute]
internal StackOfFrames get_Stack();
    [CompilerGeneratedAttribute]
internal void set_Stack(StackOfFrames value);
    internal Dictionary`2<string, XamlType> get_NamedTypes();
    [CompilerGeneratedAttribute]
internal XamlReader get_Reader();
    [CompilerGeneratedAttribute]
internal void set_Reader(XamlReader value);
    [CompilerGeneratedAttribute]
internal string get_RootName();
    [CompilerGeneratedAttribute]
internal void set_RootName(string value);
    [CompilerGeneratedAttribute]
internal object get_RootObject();
    [CompilerGeneratedAttribute]
internal void set_RootObject(object value);
    [CompilerGeneratedAttribute]
internal ServiceProviderWrapper get_ServiceProviderWrapper();
    [CompilerGeneratedAttribute]
internal void set_ServiceProviderWrapper(ServiceProviderWrapper value);
    [CompilerGeneratedAttribute]
internal XamlObjectWriter get_ObjectWriter();
    [CompilerGeneratedAttribute]
internal void set_ObjectWriter(XamlObjectWriter value);
}
internal class System.Windows.TemplateNameScope : object {
    private List`1<DependencyObject> _affectedChildren;
    private static UncommonField`1<Hashtable> _templatedNonFeChildrenField;
    private DependencyObject _templatedParent;
    private FrameworkTemplate _frameworkTemplate;
    private bool _isTemplatedParentAnFE;
    private ProvideValueServiceProvider _provideValueServiceProvider;
    private HybridDictionary _nameMap;
    internal TemplateNameScope(DependencyObject templatedParent);
    internal TemplateNameScope(DependencyObject templatedParent, List`1<DependencyObject> affectedChildren, FrameworkTemplate frameworkTemplate);
    private static TemplateNameScope();
    private sealed virtual override void System.Windows.Markup.INameScope.RegisterName(string name, object scopedElement);
    internal void RegisterNameInternal(string name, object scopedElement);
    private sealed virtual override void System.Windows.Markup.INameScope.UnregisterName(string name);
    private sealed virtual override object System.Windows.Markup.INameScope.FindName(string name);
    private void SetTemplateParentValues(string name, object element);
}
[AttributeUsageAttribute("4")]
public class System.Windows.TemplatePartAttribute : Attribute {
    private string _name;
    private Type _type;
    public string Name { get; public set; }
    public Type Type { get; public set; }
    public string get_Name();
    public void set_Name(string value);
    public Type get_Type();
    public void set_Type(Type value);
}
[AttributeUsageAttribute("4")]
public class System.Windows.TemplateVisualStateAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <GroupName>k__BackingField;
    public string Name { get; public set; }
    public string GroupName { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_GroupName();
    [CompilerGeneratedAttribute]
public void set_GroupName(string value);
}
[MarkupExtensionReturnTypeAttribute("System.Uri")]
public class System.Windows.ThemeDictionaryExtension : MarkupExtension {
    private string _assemblyName;
    private static PropertyInfo _sourceProperty;
    [ThreadStaticAttribute]
private static List`1<ThemeDictionaryInfo> _themeDictionaryInfos;
    public string AssemblyName { get; public set; }
    private static PropertyInfo SourceProperty { get; }
    public ThemeDictionaryExtension(string assemblyName);
    public string get_AssemblyName();
    public void set_AssemblyName(string value);
    public virtual object ProvideValue(IServiceProvider serviceProvider);
    private static Uri GenerateUri(string assemblyName, string resourceName, string themeName);
    internal static Uri GenerateFallbackUri(ResourceDictionary dictionary, string resourceName);
    private static PropertyInfo get_SourceProperty();
    private static void Register(ResourceDictionary dictionary, string assemblyName);
    internal static void OnThemeChanged();
}
[AttributeUsageAttribute("1")]
public class System.Windows.ThemeInfoAttribute : Attribute {
    private ResourceDictionaryLocation _themeDictionaryLocation;
    private ResourceDictionaryLocation _genericDictionaryLocation;
    public ResourceDictionaryLocation ThemeDictionaryLocation { get; }
    public ResourceDictionaryLocation GenericDictionaryLocation { get; }
    public ThemeInfoAttribute(ResourceDictionaryLocation themeDictionaryLocation, ResourceDictionaryLocation genericDictionaryLocation);
    public ResourceDictionaryLocation get_ThemeDictionaryLocation();
    public ResourceDictionaryLocation get_GenericDictionaryLocation();
    internal static ThemeInfoAttribute FromAssembly(Assembly assembly);
}
[TypeConverterAttribute("System.Windows.ThicknessConverter")]
[LocalizabilityAttribute("0")]
public class System.Windows.Thickness : ValueType {
    private double _Left;
    private double _Top;
    private double _Right;
    private double _Bottom;
    internal bool IsZero { get; }
    internal bool IsUniform { get; }
    public double Left { get; public set; }
    public double Top { get; public set; }
    public double Right { get; public set; }
    public double Bottom { get; public set; }
    internal Size Size { get; }
    public Thickness(double uniformLength);
    public Thickness(double left, double top, double right, double bottom);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(Thickness thickness);
    public virtual int GetHashCode();
    public virtual string ToString();
    internal string ToString(CultureInfo cultureInfo);
    internal bool get_IsZero();
    internal bool get_IsUniform();
    internal bool IsValid(bool allowNegative, bool allowNaN, bool allowPositiveInfinity, bool allowNegativeInfinity);
    internal bool IsClose(Thickness thickness);
    internal static bool AreClose(Thickness thickness0, Thickness thickness1);
    public static bool op_Equality(Thickness t1, Thickness t2);
    public static bool op_Inequality(Thickness t1, Thickness t2);
    public double get_Left();
    public void set_Left(double value);
    public double get_Top();
    public void set_Top(double value);
    public double get_Right();
    public void set_Right(double value);
    public double get_Bottom();
    public void set_Bottom(double value);
    internal Size get_Size();
}
public class System.Windows.ThicknessConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext typeDescriptorContext, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext typeDescriptorContext, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext typeDescriptorContext, CultureInfo cultureInfo, object source);
    public virtual object ConvertTo(ITypeDescriptorContext typeDescriptorContext, CultureInfo cultureInfo, object value, Type destinationType);
    internal static string ToString(Thickness th, CultureInfo cultureInfo);
    internal static Thickness FromString(string s, CultureInfo cultureInfo);
}
internal class System.Windows.TreeChangeInfo : ValueType {
    private Stack`1<FrugalObjectList`1<DependencyProperty>> _inheritablePropertiesStack;
    private object _topmostCollapsedParentNode;
    private bool _isAddOperation;
    private DependencyObject _rootOfChange;
    private InheritablePropertyChangeInfo[] _rootInheritableValues;
    private int _valueIndexer;
    internal Stack`1<FrugalObjectList`1<DependencyProperty>> InheritablePropertiesStack { get; }
    internal object TopmostCollapsedParentNode { get; internal set; }
    internal bool IsAddOperation { get; }
    internal DependencyObject Root { get; }
    public TreeChangeInfo(DependencyObject root, DependencyObject parent, bool isAddOperation);
    internal FrugalObjectList`1<DependencyProperty> CreateParentInheritableProperties(DependencyObject d, DependencyObject parent, bool isAddOperation);
    internal void ResetInheritableValueIndexer();
    internal InheritablePropertyChangeInfo GetRootInheritableValue(DependencyProperty dp);
    internal Stack`1<FrugalObjectList`1<DependencyProperty>> get_InheritablePropertiesStack();
    internal object get_TopmostCollapsedParentNode();
    internal void set_TopmostCollapsedParentNode(object value);
    internal bool get_IsAddOperation();
    internal DependencyObject get_Root();
}
internal static class System.Windows.TreeWalkHelper : object {
    private static VisitedCallback`1<TreeChangeInfo> TreeChangeDelegate;
    private static VisitedCallback`1<TreeChangeInfo> TreeChangePostDelegate;
    private static VisitedCallback`1<ResourcesChangeInfo> ResourcesChangeDelegate;
    private static VisitedCallback`1<InheritablePropertyChangeInfo> InheritablePropertyChangeDelegate;
    private static TreeWalkHelper();
    internal static void InvalidateOnTreeChange(FrameworkElement fe, FrameworkContentElement fce, DependencyObject parent, bool isAddOperation);
    private static bool OnAncestorChanged(DependencyObject d, TreeChangeInfo info, bool visitedViaVisualTree);
    private static void OnAncestorChanged(FrameworkElement fe, FrameworkContentElement fce, TreeChangeInfo info);
    private static bool OnPostAncestorChanged(DependencyObject d, TreeChangeInfo info, bool visitedViaVisualTree);
    internal static FrugalObjectList`1<DependencyProperty> InvalidateTreeDependentProperties(TreeChangeInfo info, FrameworkElement fe, FrameworkContentElement fce, Style selfStyle, Style selfThemeStyle, ChildRecord& childRecord, bool isChildRecordValid, bool hasStyleChanged, bool isSelfInheritanceParent, bool wasSelfInheritanceParent);
    private static bool InvalidateTreeDependentProperty(TreeChangeInfo info, DependencyObject d, FrameworkObject& fo, DependencyProperty dp, FrameworkPropertyMetadata fMetadata, Style selfStyle, Style selfThemeStyle, ChildRecord& childRecord, bool isChildRecordValid, bool hasStyleChanged, bool isSelfInheritanceParent, bool wasSelfInheritanceParent);
    internal static void InvalidateOnResourcesChange(FrameworkElement fe, FrameworkContentElement fce, ResourcesChangeInfo info);
    private static bool OnResourcesChangedCallback(DependencyObject d, ResourcesChangeInfo info, bool visitedViaVisualTree);
    internal static void OnResourcesChanged(DependencyObject d, ResourcesChangeInfo info, bool raiseResourceChangedEvent);
    private static void InvalidateResourceReferences(DependencyObject d, ResourcesChangeInfo info);
    private static void InvalidateStyleAndReferences(DependencyObject d, ResourcesChangeInfo info, bool containsTypeOfKey);
    internal static void InvalidateOnInheritablePropertyChange(FrameworkElement fe, FrameworkContentElement fce, InheritablePropertyChangeInfo info, bool skipStartNode);
    private static bool OnInheritablePropertyChanged(DependencyObject d, InheritablePropertyChangeInfo info, bool visitedViaVisualTree);
    internal static void OnInheritedPropertyChanged(DependencyObject d, InheritablePropertyChangeInfo& info, InheritanceBehavior inheritanceBehavior);
    internal static bool IsInheritanceNode(DependencyObject d, DependencyProperty dp, InheritanceBehavior& inheritanceBehavior);
    internal static bool IsInheritanceNode(FrameworkElement fe, DependencyProperty dp, InheritanceBehavior& inheritanceBehavior);
    internal static bool IsInheritanceNode(FrameworkContentElement fce, DependencyProperty dp, InheritanceBehavior& inheritanceBehavior);
    internal static bool SkipNow(InheritanceBehavior inheritanceBehavior);
    internal static bool SkipNext(InheritanceBehavior inheritanceBehavior);
    internal static bool HasChildren(FrameworkElement fe, FrameworkContentElement fce);
    private static bool IsForceInheritedProperty(DependencyProperty dp);
}
internal enum System.Windows.TreeWalkPriority : Enum {
    public int value__;
    public static TreeWalkPriority LogicalTree;
    public static TreeWalkPriority VisualTree;
}
[ContentPropertyAttribute("Setters")]
[XamlSetTypeConverterAttribute("ReceiveTypeConverter")]
public class System.Windows.Trigger : TriggerBase {
    private DependencyProperty _property;
    private object _value;
    private string _sourceName;
    private SetterBaseCollection _setters;
    private object _unresolvedProperty;
    private object _unresolvedValue;
    private ITypeDescriptorContext _serviceProvider;
    private CultureInfo _cultureInfoForTypeConverter;
    [AmbientAttribute]
[LocalizabilityAttribute("0")]
public DependencyProperty Property { get; public set; }
    [DependsOnAttribute("Property")]
[DependsOnAttribute("SourceName")]
[LocalizabilityAttribute("0")]
[TypeConverterAttribute("System.Windows.Markup.SetterTriggerConditionValueConverter")]
public object Value { get; public set; }
    [DefaultValueAttribute("")]
[AmbientAttribute]
public string SourceName { get; public set; }
    [DesignerSerializationVisibilityAttribute("2")]
public SetterBaseCollection Setters { get; }
    public DependencyProperty get_Property();
    public void set_Property(DependencyProperty value);
    public object get_Value();
    public void set_Value(object value);
    public string get_SourceName();
    public void set_SourceName(string value);
    public SetterBaseCollection get_Setters();
    private sealed virtual override void System.Windows.Markup.IAddChild.AddChild(object value);
    private sealed virtual override void System.Windows.Markup.IAddChild.AddText(string text);
    internal static Setter CheckChildIsSetter(object o);
    internal sealed virtual void Seal();
    internal virtual bool GetCurrentState(DependencyObject container, UncommonField`1<HybridDictionary[]> dataField);
    private sealed virtual override void System.ComponentModel.ISupportInitialize.BeginInit();
    private sealed virtual override void System.ComponentModel.ISupportInitialize.EndInit();
    public static void ReceiveTypeConverter(object targetObject, XamlSetTypeConverterEventArgs eventArgs);
}
public abstract class System.Windows.TriggerAction : DependencyObject {
    private TriggerBase _containingTrigger;
    private DependencyObject _inheritanceContext;
    private bool _hasMultipleInheritanceContexts;
    internal TriggerBase ContainingTrigger { get; }
    internal DependencyObject InheritanceContext { get; }
    internal bool HasMultipleInheritanceContexts { get; }
    internal abstract virtual void Invoke(FrameworkElement fe, FrameworkContentElement fce, Style targetStyle, FrameworkTemplate targetTemplate, long layer);
    internal abstract virtual void Invoke(FrameworkElement fe);
    internal TriggerBase get_ContainingTrigger();
    internal void Seal(TriggerBase containingTrigger);
    internal virtual void Seal();
    internal void CheckSealed();
    internal virtual DependencyObject get_InheritanceContext();
    internal virtual void AddInheritanceContext(DependencyObject context, DependencyProperty property);
    internal virtual void RemoveInheritanceContext(DependencyObject context, DependencyProperty property);
    internal virtual bool get_HasMultipleInheritanceContexts();
}
[DefaultMemberAttribute("Item")]
public class System.Windows.TriggerActionCollection : object {
    private List`1<TriggerAction> _rawList;
    private bool _sealed;
    private DependencyObject _owner;
    public int Count { get; }
    public bool IsReadOnly { get; }
    public TriggerAction Item { get; public set; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private object System.Collections.IList.Item { get; private set; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    internal DependencyObject Owner { get; internal set; }
    public TriggerActionCollection(int initialSize);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual void Clear();
    public sealed virtual void RemoveAt(int index);
    public sealed virtual void Add(TriggerAction value);
    public sealed virtual bool Contains(TriggerAction value);
    public sealed virtual void CopyTo(TriggerAction[] array, int index);
    public sealed virtual int IndexOf(TriggerAction value);
    public sealed virtual void Insert(int index, TriggerAction value);
    public sealed virtual bool Remove(TriggerAction value);
    public sealed virtual TriggerAction get_Item(int index);
    public sealed virtual void set_Item(int index, TriggerAction value);
    [CLSCompliantAttribute("False")]
public sealed virtual IEnumerator`1<TriggerAction> GetEnumerator();
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    internal void Seal(TriggerBase containingTrigger);
    internal DependencyObject get_Owner();
    internal void set_Owner(DependencyObject value);
    private void CheckSealed();
    private TriggerAction VerifyIsTriggerAction(object value);
}
[LocalizabilityAttribute("0")]
public abstract class System.Windows.TriggerBase : DependencyObject {
    internal FrugalStructList`1<PropertyValue> PropertyValues;
    private static object Synchronized;
    private TriggerCondition[] _triggerConditions;
    private DependencyObject _inheritanceContext;
    private bool _hasMultipleInheritanceContexts;
    private TriggerActionCollection _enterActions;
    private TriggerActionCollection _exitActions;
    private long _globalLayerRank;
    private static long _nextGlobalLayerRank;
    [DesignerSerializationVisibilityAttribute("2")]
public TriggerActionCollection EnterActions { get; }
    internal bool HasEnterActions { get; }
    [DesignerSerializationVisibilityAttribute("2")]
public TriggerActionCollection ExitActions { get; }
    internal bool HasExitActions { get; }
    internal bool ExecuteEnterActionsOnApply { get; }
    internal bool ExecuteExitActionsOnApply { get; }
    internal DependencyObject InheritanceContext { get; }
    internal bool HasMultipleInheritanceContexts { get; }
    internal long Layer { get; }
    internal TriggerCondition[] TriggerConditions { get; internal set; }
    private static TriggerBase();
    public TriggerActionCollection get_EnterActions();
    internal bool get_HasEnterActions();
    public TriggerActionCollection get_ExitActions();
    internal bool get_HasExitActions();
    internal bool get_ExecuteEnterActionsOnApply();
    internal bool get_ExecuteExitActionsOnApply();
    internal void ProcessParametersContainer(DependencyProperty dp);
    internal string ProcessParametersVisualTreeChild(DependencyProperty dp, string target);
    internal void AddToPropertyValues(string childName, DependencyProperty dp, object value, PropertyValueType valueType);
    internal virtual void Seal();
    internal void ProcessSettersCollection(SetterBaseCollection setters);
    internal virtual DependencyObject get_InheritanceContext();
    internal virtual void AddInheritanceContext(DependencyObject context, DependencyProperty property);
    internal virtual void RemoveInheritanceContext(DependencyObject context, DependencyProperty property);
    internal virtual bool get_HasMultipleInheritanceContexts();
    internal long get_Layer();
    internal void EstablishLayer();
    internal virtual bool GetCurrentState(DependencyObject container, UncommonField`1<HybridDictionary[]> dataField);
    internal TriggerCondition[] get_TriggerConditions();
    internal void set_TriggerConditions(TriggerCondition[] value);
}
[LocalizabilityAttribute("0")]
public class System.Windows.TriggerCollection : Collection`1<TriggerBase> {
    private bool _sealed;
    private FrameworkElement _owner;
    public bool IsSealed { get; }
    internal FrameworkElement Owner { get; }
    internal TriggerCollection(FrameworkElement owner);
    protected virtual void ClearItems();
    protected virtual void InsertItem(int index, TriggerBase item);
    protected virtual void RemoveItem(int index);
    protected virtual void SetItem(int index, TriggerBase item);
    public bool get_IsSealed();
    internal void Seal();
    internal FrameworkElement get_Owner();
    private void CheckSealed();
    private void TriggerBaseValidation(TriggerBase triggerBase);
    private void OnAdd(TriggerBase triggerBase);
    private void OnRemove(TriggerBase triggerBase);
    private void OnClear();
}
internal class System.Windows.TriggerCondition : ValueType {
    internal DependencyProperty Property;
    internal BindingBase Binding;
    internal LogicalOp LogicalOp;
    internal object Value;
    internal string SourceName;
    internal int SourceChildIndex;
    internal BindingValueCache BindingValueCache;
    internal TriggerCondition(DependencyProperty dp, LogicalOp logicalOp, object value, string sourceName);
    internal TriggerCondition(BindingBase binding, LogicalOp logicalOp, object value);
    internal TriggerCondition(BindingBase binding, LogicalOp logicalOp, object value, string sourceName);
    internal bool Match(object state);
    private bool Match(object state, object referenceValue);
    internal bool ConvertAndMatch(object state);
    internal bool TypeSpecificEquals(TriggerCondition value);
}
internal class System.Windows.TriggerSourceRecord : ValueType {
    public FrugalStructList`1<ChildPropertyDependent> ChildPropertyDependents;
}
internal enum System.Windows.ValueLookupType : Enum {
    public int value__;
    public static ValueLookupType Simple;
    public static ValueLookupType Trigger;
    public static ValueLookupType PropertyTriggerResource;
    public static ValueLookupType DataTrigger;
    public static ValueLookupType DataTriggerResource;
    public static ValueLookupType TemplateBinding;
    public static ValueLookupType Resource;
}
public class System.Windows.ValueSource : ValueType {
    private BaseValueSource _baseValueSource;
    private bool _isExpression;
    private bool _isAnimated;
    private bool _isCoerced;
    private bool _isCurrent;
    public BaseValueSource BaseValueSource { get; }
    public bool IsExpression { get; }
    public bool IsAnimated { get; }
    public bool IsCoerced { get; }
    public bool IsCurrent { get; }
    internal ValueSource(BaseValueSourceInternal source, bool isExpression, bool isAnimated, bool isCoerced, bool isCurrent);
    public BaseValueSource get_BaseValueSource();
    public bool get_IsExpression();
    public bool get_IsAnimated();
    public bool get_IsCoerced();
    public bool get_IsCurrent();
    public virtual int GetHashCode();
    public virtual bool Equals(object o);
    public static bool op_Equality(ValueSource vs1, ValueSource vs2);
    public static bool op_Inequality(ValueSource vs1, ValueSource vs2);
}
[LocalizabilityAttribute("0")]
public enum System.Windows.VerticalAlignment : Enum {
    public int value__;
    public static VerticalAlignment Top;
    public static VerticalAlignment Center;
    public static VerticalAlignment Bottom;
    public static VerticalAlignment Stretch;
}
internal class System.Windows.VisitedCallback`1 : MulticastDelegate {
    public VisitedCallback`1(object object, IntPtr method);
    public virtual bool Invoke(DependencyObject d, T data, bool visitedViaVisualTree);
    public virtual IAsyncResult BeginInvoke(DependencyObject d, T data, bool visitedViaVisualTree, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
[RuntimeNamePropertyAttribute("Name")]
[ContentPropertyAttribute("Storyboard")]
public class System.Windows.VisualState : DependencyObject {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    private static DependencyProperty StoryboardProperty;
    public string Name { get; public set; }
    public Storyboard Storyboard { get; public set; }
    private static VisualState();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    public Storyboard get_Storyboard();
    public void set_Storyboard(Storyboard value);
}
public class System.Windows.VisualStateChangedEventArgs : EventArgs {
    private VisualState _oldState;
    private VisualState _newState;
    private FrameworkElement _control;
    private FrameworkElement _stateGroupsRoot;
    public VisualState OldState { get; }
    public VisualState NewState { get; }
    public FrameworkElement Control { get; }
    public FrameworkElement StateGroupsRoot { get; }
    internal VisualStateChangedEventArgs(VisualState oldState, VisualState newState, FrameworkElement control, FrameworkElement stateGroupsRoot);
    public VisualState get_OldState();
    public VisualState get_NewState();
    public FrameworkElement get_Control();
    public FrameworkElement get_StateGroupsRoot();
}
[ContentPropertyAttribute("States")]
[RuntimeNamePropertyAttribute("Name")]
public class System.Windows.VisualStateGroup : DependencyObject {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private VisualState <CurrentState>k__BackingField;
    [CompilerGeneratedAttribute]
private EventHandler`1<VisualStateChangedEventArgs> CurrentStateChanged;
    [CompilerGeneratedAttribute]
private EventHandler`1<VisualStateChangedEventArgs> CurrentStateChanging;
    private Collection`1<Storyboard> _currentStoryboards;
    private FreezableCollection`1<VisualState> _states;
    private FreezableCollection`1<VisualTransition> _transitions;
    public string Name { get; public set; }
    public IList States { get; }
    public IList Transitions { get; }
    public VisualState CurrentState { get; internal set; }
    internal Collection`1<Storyboard> CurrentStoryboards { get; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    public IList get_States();
    public IList get_Transitions();
    [CompilerGeneratedAttribute]
public VisualState get_CurrentState();
    [CompilerGeneratedAttribute]
internal void set_CurrentState(VisualState value);
    internal VisualState GetState(string stateName);
    internal Collection`1<Storyboard> get_CurrentStoryboards();
    internal void StartNewThenStopOld(FrameworkElement element, Storyboard[] newStoryboards);
    internal void RaiseCurrentStateChanging(FrameworkElement stateGroupsRoot, VisualState oldState, VisualState newState, FrameworkElement control);
    internal void RaiseCurrentStateChanged(FrameworkElement stateGroupsRoot, VisualState oldState, VisualState newState, FrameworkElement control);
    [CompilerGeneratedAttribute]
public void add_CurrentStateChanged(EventHandler`1<VisualStateChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_CurrentStateChanged(EventHandler`1<VisualStateChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_CurrentStateChanging(EventHandler`1<VisualStateChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_CurrentStateChanging(EventHandler`1<VisualStateChangedEventArgs> value);
}
public class System.Windows.VisualStateManager : DependencyObject {
    public static DependencyProperty CustomVisualStateManagerProperty;
    private static DependencyPropertyKey VisualStateGroupsPropertyKey;
    public static DependencyProperty VisualStateGroupsProperty;
    private static Duration DurationZero;
    private static VisualStateManager();
    private static bool GoToStateCommon(FrameworkElement control, FrameworkElement stateGroupsRoot, string stateName, bool useTransitions);
    public static bool GoToState(FrameworkElement control, string stateName, bool useTransitions);
    public static bool GoToElementState(FrameworkElement stateGroupsRoot, string stateName, bool useTransitions);
    protected virtual bool GoToStateCore(FrameworkElement control, FrameworkElement stateGroupsRoot, string stateName, VisualStateGroup group, VisualState state, bool useTransitions);
    public static VisualStateManager GetCustomVisualStateManager(FrameworkElement obj);
    public static void SetCustomVisualStateManager(FrameworkElement obj, VisualStateManager value);
    internal static Collection`1<VisualStateGroup> GetVisualStateGroupsInternal(FrameworkElement obj);
    [DesignerSerializationVisibilityAttribute("2")]
public static IList GetVisualStateGroups(FrameworkElement obj);
    internal static bool TryGetState(IList`1<VisualStateGroup> groups, string stateName, VisualStateGroup& group, VisualState& state);
    private static bool GoToStateInternal(FrameworkElement control, FrameworkElement stateGroupsRoot, VisualStateGroup group, VisualState state, bool useTransitions);
    private static bool ShouldRunStateStoryboard(FrameworkElement control, FrameworkElement stateGroupsRoot, VisualState state, VisualStateGroup group);
    protected void RaiseCurrentStateChanging(VisualStateGroup stateGroup, VisualState oldState, VisualState newState, FrameworkElement control, FrameworkElement stateGroupsRoot);
    protected void RaiseCurrentStateChanged(VisualStateGroup stateGroup, VisualState oldState, VisualState newState, FrameworkElement control, FrameworkElement stateGroupsRoot);
    private static Storyboard GenerateDynamicTransitionAnimations(FrameworkElement root, VisualStateGroup group, VisualState newState, VisualTransition transition);
    private static Timeline GenerateFromAnimation(FrameworkElement root, Timeline timeline, IEasingFunction easingFunction);
    private static Timeline GenerateToAnimation(FrameworkElement root, Timeline timeline, IEasingFunction easingFunction, bool isEntering);
    private static void CopyStoryboardTargetProperties(FrameworkElement root, Timeline source, Timeline destination);
    internal static VisualTransition GetTransition(FrameworkElement element, VisualStateGroup group, VisualState from, VisualState to);
    private static Nullable`1<Color> GetTargetColor(Timeline timeline, bool isEntering);
    private static Nullable`1<double> GetTargetDouble(Timeline timeline, bool isEntering);
    private static Nullable`1<Point> GetTargetPoint(Timeline timeline, bool isEntering);
    private static Dictionary`2<TimelineDataToken, Timeline> FlattenTimelines(Storyboard storyboard);
    private static Dictionary`2<TimelineDataToken, Timeline> FlattenTimelines(Collection`1<Storyboard> storyboards);
    private static void FlattenTimelines(Storyboard storyboard, Dictionary`2<TimelineDataToken, Timeline> result);
}
[ContentPropertyAttribute("Storyboard")]
public class System.Windows.VisualTransition : DependencyObject {
    [CompilerGeneratedAttribute]
private string <From>k__BackingField;
    [CompilerGeneratedAttribute]
private string <To>k__BackingField;
    [CompilerGeneratedAttribute]
private Storyboard <Storyboard>k__BackingField;
    [CompilerGeneratedAttribute]
private IEasingFunction <GeneratedEasingFunction>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DynamicStoryboardCompleted>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ExplicitStoryboardCompleted>k__BackingField;
    private Duration _generatedDuration;
    public string From { get; public set; }
    public string To { get; public set; }
    public Storyboard Storyboard { get; public set; }
    [TypeConverterAttribute("System.Windows.DurationConverter")]
public Duration GeneratedDuration { get; public set; }
    public IEasingFunction GeneratedEasingFunction { get; public set; }
    internal bool IsDefault { get; }
    internal bool DynamicStoryboardCompleted { get; internal set; }
    internal bool ExplicitStoryboardCompleted { get; internal set; }
    [CompilerGeneratedAttribute]
public string get_From();
    [CompilerGeneratedAttribute]
public void set_From(string value);
    [CompilerGeneratedAttribute]
public string get_To();
    [CompilerGeneratedAttribute]
public void set_To(string value);
    [CompilerGeneratedAttribute]
public Storyboard get_Storyboard();
    [CompilerGeneratedAttribute]
public void set_Storyboard(Storyboard value);
    public Duration get_GeneratedDuration();
    public void set_GeneratedDuration(Duration value);
    [CompilerGeneratedAttribute]
public IEasingFunction get_GeneratedEasingFunction();
    [CompilerGeneratedAttribute]
public void set_GeneratedEasingFunction(IEasingFunction value);
    internal bool get_IsDefault();
    [CompilerGeneratedAttribute]
internal bool get_DynamicStoryboardCompleted();
    [CompilerGeneratedAttribute]
internal void set_DynamicStoryboardCompleted(bool value);
    [CompilerGeneratedAttribute]
internal bool get_ExplicitStoryboardCompleted();
    [CompilerGeneratedAttribute]
internal void set_ExplicitStoryboardCompleted(bool value);
}
[LocalizabilityAttribute("16")]
public class System.Windows.Window : ContentControl {
    public static DependencyProperty TaskbarItemInfoProperty;
    public static RoutedEvent DpiChangedEvent;
    public static DependencyProperty AllowsTransparencyProperty;
    public static DependencyProperty TitleProperty;
    public static DependencyProperty IconProperty;
    public static DependencyProperty SizeToContentProperty;
    public static DependencyProperty TopProperty;
    public static DependencyProperty LeftProperty;
    public static DependencyProperty ShowInTaskbarProperty;
    private static DependencyPropertyKey IsActivePropertyKey;
    public static DependencyProperty IsActiveProperty;
    public static DependencyProperty WindowStyleProperty;
    public static DependencyProperty WindowStateProperty;
    public static DependencyProperty ResizeModeProperty;
    public static DependencyProperty TopmostProperty;
    public static DependencyProperty ShowActivatedProperty;
    internal static RoutedCommand DialogCancelCommand;
    private SourceWindowHelper _swh;
    private Window _ownerWindow;
    private IntPtr _ownerHandle;
    private WindowCollection _ownedWindows;
    private ArrayList _threadWindowHandles;
    private bool _updateHwndSize;
    private bool _updateHwndLocation;
    private bool _updateStartupLocation;
    private bool _isVisible;
    private bool _isVisibilitySet;
    private bool _resetKeyboardCuesProperty;
    private bool _previousKeyboardCuesProperty;
    private static bool _dialogCommandAdded;
    private bool _postContentRenderedFromLoadedHandler;
    private bool _disposed;
    private bool _appShuttingDown;
    private bool _ignoreCancel;
    private bool _showingAsDialog;
    private bool _isClosing;
    private bool _visibilitySetInternally;
    private bool _hwndCreatedButNotShown;
    private double _trackMinWidthDeviceUnits;
    private double _trackMinHeightDeviceUnits;
    private double _trackMaxWidthDeviceUnits;
    private double _trackMaxHeightDeviceUnits;
    private double _windowMaxWidthDeviceUnits;
    private double _windowMaxHeightDeviceUnits;
    private double _actualTop;
    private double _actualLeft;
    private bool _inTrustedSubWindow;
    private ImageSource _icon;
    private IconHandle _defaultLargeIconHandle;
    private IconHandle _defaultSmallIconHandle;
    private IconHandle _currentLargeIconHandle;
    private IconHandle _currentSmallIconHandle;
    private Nullable`1<bool> _dialogResult;
    private IntPtr _dialogOwnerHandle;
    private IntPtr _dialogPreviousActiveHandle;
    private DispatcherFrame _dispatcherFrame;
    private WindowStartupLocation _windowStartupLocation;
    private WindowState _previousWindowState;
    private HwndWrapper _hiddenWindow;
    private EventHandlerList _events;
    private SecurityCriticalDataForSet`1<int> _styleDoNotUse;
    private SecurityCriticalDataForSet`1<int> _styleExDoNotUse;
    private HwndStyleManager _manager;
    private Control _resizeGripControl;
    private Point _prePanningLocation;
    private static object EVENT_SOURCEINITIALIZED;
    private static object EVENT_CLOSING;
    private static object EVENT_CLOSED;
    private static object EVENT_ACTIVATED;
    private static object EVENT_DEACTIVATED;
    private static object EVENT_STATECHANGED;
    private static object EVENT_LOCATIONCHANGED;
    private static object EVENT_CONTENTRENDERED;
    private static object EVENT_VISUALCHILDRENCHANGED;
    private static WindowMessage WM_TASKBARBUTTONCREATED;
    private static WindowMessage WM_APPLYTASKBARITEMINFO;
    private static int c_MaximumThumbButtons;
    private ITaskbarList3 _taskbarList;
    private DispatcherTimer _taskbarRetryTimer;
    private Size _overlaySize;
    internal static DependencyProperty IWindowServiceProperty;
    private DispatcherOperation _contentRenderedCallback;
    private WeakReference _currentPanningTarget;
    private static DependencyObjectType _dType;
    protected internal IEnumerator LogicalChildren { get; }
    public TaskbarItemInfo TaskbarItemInfo { get; public set; }
    public bool AllowsTransparency { get; public set; }
    [LocalizabilityAttribute("2")]
public string Title { get; public set; }
    public ImageSource Icon { get; public set; }
    public SizeToContent SizeToContent { get; public set; }
    [TypeConverterAttribute("System.Windows.LengthConverter, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")]
public double Top { get; public set; }
    [TypeConverterAttribute("System.Windows.LengthConverter, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")]
public double Left { get; public set; }
    public Rect RestoreBounds { get; }
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
public WindowStartupLocation WindowStartupLocation { get; public set; }
    public bool ShowInTaskbar { get; public set; }
    public bool IsActive { get; }
    [DefaultValueAttribute("")]
public Window Owner { get; public set; }
    private bool IsOwnerNull { get; }
    public WindowCollection OwnedWindows { get; }
    [TypeConverterAttribute("System.Windows.DialogResultConverter")]
[DesignerSerializationVisibilityAttribute("0")]
public Nullable`1<bool> DialogResult { get; public set; }
    public WindowStyle WindowStyle { get; public set; }
    public WindowState WindowState { get; public set; }
    public ResizeMode ResizeMode { get; public set; }
    public bool Topmost { get; public set; }
    public bool ShowActivated { get; public set; }
    internal bool IsSourceWindowNull { get; }
    internal bool IsCompositionTargetInvalid { get; }
    internal RECT WorkAreaBoundsForNearestMonitor { get; }
    internal Size WindowSize { get; }
    internal HwndSource HwndSourceWindow { get; }
    internal bool HwndCreatedButNotShown { get; }
    internal bool IsDisposed { get; }
    internal bool IsVisibilitySet { get; }
    internal IntPtr CriticalHandle { get; }
    internal IntPtr OwnerHandle { get; internal set; }
    internal int Win32Style { get; internal set; }
    internal int _Style { get; internal set; }
    internal int _StyleEx { get; internal set; }
    internal HwndStyleManager Manager { get; internal set; }
    private bool System.Windows.IWindowService.UserResized { get; }
    private bool CanCenterOverWPFOwner { get; }
    private SizeToContent HwndSourceSizeToContent { get; private set; }
    private RECT WindowBounds { get; }
    private int StyleFromHwnd { get; }
    private int StyleExFromHwnd { get; }
    private WindowCollection OwnedWindowsInternal { get; }
    private Application App { get; }
    private bool IsInsideApp { get; }
    private EventHandlerList Events { get; }
    internal DependencyObjectType DTypeThemeStyleKey { get; }
    private static Window();
    internal Window(bool inRbw);
    public void Show();
    public void Hide();
    public void Close();
    public void DragMove();
    public Nullable`1<bool> ShowDialog();
    public bool Activate();
    protected internal virtual IEnumerator get_LogicalChildren();
    public static Window GetWindow(DependencyObject dependencyObject);
    public TaskbarItemInfo get_TaskbarItemInfo();
    public void set_TaskbarItemInfo(TaskbarItemInfo value);
    private void OnTaskbarItemInfoChanged(DependencyPropertyChangedEventArgs e);
    private void HandleTaskbarListError(HRESULT hr);
    private void OnTaskbarItemInfoSubPropertyChanged(object sender, DependencyPropertyChangedEventArgs e);
    public bool get_AllowsTransparency();
    public void set_AllowsTransparency(bool value);
    private static void OnAllowsTransparencyChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static object CoerceAllowsTransparency(DependencyObject d, object value);
    public sealed virtual string get_Title();
    public sealed virtual void set_Title(string value);
    public ImageSource get_Icon();
    public void set_Icon(ImageSource value);
    public SizeToContent get_SizeToContent();
    public void set_SizeToContent(SizeToContent value);
    public double get_Top();
    public void set_Top(double value);
    public double get_Left();
    public void set_Left(double value);
    public Rect get_RestoreBounds();
    public WindowStartupLocation get_WindowStartupLocation();
    public void set_WindowStartupLocation(WindowStartupLocation value);
    public bool get_ShowInTaskbar();
    public void set_ShowInTaskbar(bool value);
    public bool get_IsActive();
    public Window get_Owner();
    public void set_Owner(Window value);
    private bool get_IsOwnerNull();
    public WindowCollection get_OwnedWindows();
    public Nullable`1<bool> get_DialogResult();
    public void set_DialogResult(Nullable`1<bool> value);
    public WindowStyle get_WindowStyle();
    public void set_WindowStyle(WindowStyle value);
    private static object CoerceWindowStyle(DependencyObject d, object value);
    public WindowState get_WindowState();
    public void set_WindowState(WindowState value);
    public ResizeMode get_ResizeMode();
    public void set_ResizeMode(ResizeMode value);
    public bool get_Topmost();
    public void set_Topmost(bool value);
    public bool get_ShowActivated();
    public void set_ShowActivated(bool value);
    public void add_SourceInitialized(EventHandler value);
    public void remove_SourceInitialized(EventHandler value);
    public void add_DpiChanged(DpiChangedEventHandler value);
    public void remove_DpiChanged(DpiChangedEventHandler value);
    public void add_Activated(EventHandler value);
    public void remove_Activated(EventHandler value);
    public void add_Deactivated(EventHandler value);
    public void remove_Deactivated(EventHandler value);
    public void add_StateChanged(EventHandler value);
    public void remove_StateChanged(EventHandler value);
    public void add_LocationChanged(EventHandler value);
    public void remove_LocationChanged(EventHandler value);
    public void add_Closing(CancelEventHandler value);
    public void remove_Closing(CancelEventHandler value);
    public void add_Closed(EventHandler value);
    public void remove_Closed(EventHandler value);
    public sealed virtual void add_ContentRendered(EventHandler value);
    public sealed virtual void remove_ContentRendered(EventHandler value);
    internal void add_VisualChildrenChanged(EventHandler`1<EventArgs> value);
    internal void remove_VisualChildrenChanged(EventHandler`1<EventArgs> value);
    protected virtual AutomationPeer OnCreateAutomationPeer();
    protected virtual void OnDpiChanged(DpiScale oldDpi, DpiScale newDpi);
    protected internal sealed virtual void OnVisualParentChanged(DependencyObject oldParent);
    protected virtual Size MeasureOverride(Size availableSize);
    protected virtual Size ArrangeOverride(Size arrangeBounds);
    protected virtual void OnContentChanged(object oldContent, object newContent);
    protected virtual void OnSourceInitialized(EventArgs e);
    protected virtual void OnActivated(EventArgs e);
    protected virtual void OnDeactivated(EventArgs e);
    protected virtual void OnStateChanged(EventArgs e);
    protected virtual void OnLocationChanged(EventArgs e);
    protected virtual void OnClosing(CancelEventArgs e);
    protected virtual void OnClosed(EventArgs e);
    protected virtual void OnContentRendered(EventArgs e);
    protected internal virtual void OnVisualChildrenChanged(DependencyObject visualAdded, DependencyObject visualRemoved);
    internal Point DeviceToLogicalUnits(Point ptDeviceUnits);
    internal Point LogicalToDeviceUnits(Point ptLogicalUnits);
    internal static bool VisibilityToBool(Visibility v);
    internal virtual void SetResizeGripControl(Control ctrl);
    internal virtual void ClearResizeGripControl(Control oldCtrl);
    internal virtual void TryClearingMainWindow();
    internal void InternalClose(bool shutdown, bool ignoreCancel);
    private void CloseWindowBeforeShow();
    internal bool get_IsSourceWindowNull();
    internal bool get_IsCompositionTargetInvalid();
    internal RECT get_WorkAreaBoundsForNearestMonitor();
    internal Size get_WindowSize();
    internal HwndSource get_HwndSourceWindow();
    private void InternalDispose();
    internal virtual void OnAncestorChanged();
    internal virtual void CreateAllStyle();
    internal virtual void CreateSourceWindowDuringShow();
    internal void CreateSourceWindow(bool duringShow);
    internal virtual HwndSourceParameters CreateHwndSourceParameters();
    private void OnSourceSizeToContentChanged(object sender, EventArgs args);
    internal virtual void CorrectStyleForBorderlessWindowCase();
    internal virtual void GetRequestedDimensions(Double& requestedLeft, Double& requestedTop, Double& requestedWidth, Double& requestedHeight);
    internal virtual void SetupInitialState(double requestedTop, double requestedLeft, double requestedWidth, double requestedHeight);
    internal void SetRootVisual();
    internal void SetRootVisualAndUpdateSTC();
    private void CreateWindowStyle();
    internal virtual void UpdateTitle(string title);
    private void UpdateHwndSizeOnWidthHeightChange(double widthLogicalUnits, double heightLogicalUnits);
    internal void HandleActivate(bool windowActivated);
    internal virtual void UpdateHeight(double newHeight);
    internal virtual void UpdateWidth(double newWidth);
    internal virtual void VerifyApiSupported();
    internal bool get_HwndCreatedButNotShown();
    internal bool get_IsDisposed();
    internal bool get_IsVisibilitySet();
    internal IntPtr get_CriticalHandle();
    internal IntPtr get_OwnerHandle();
    internal void set_OwnerHandle(IntPtr value);
    internal int get_Win32Style();
    internal void set_Win32Style(int value);
    internal int get__Style();
    internal void set__Style(int value);
    internal int get__StyleEx();
    internal void set__StyleEx(int value);
    internal HwndStyleManager get_Manager();
    internal void set_Manager(HwndStyleManager value);
    private sealed virtual override bool System.Windows.IWindowService.get_UserResized();
    private Size MeasureOverrideHelper(Size constraint);
    internal virtual WindowMinMax GetWindowMinMax();
    private void LoadedHandler(object sender, RoutedEventArgs e);
    private void PostContentRendered();
    private void EnsureDialogCommand();
    private static void OnDialogCommand(object target, ExecutedRoutedEventArgs e);
    private void OnDialogCancelCommand();
    private bool ThreadWindowsCallback(IntPtr hWnd, IntPtr lparam);
    private void EnableThreadWindows(bool state);
    private void Initialize();
    internal void VerifyContextAndObjectState();
    private void VerifyCanShow();
    private void VerifyNotClosing();
    private void VerifyHwndCreateShowState();
    private void SetIWindowService();
    private IntPtr GetCurrentMonitorFromMousePosition();
    private bool CalculateWindowLocation(Double& leftDeviceUnits, Double& topDeviceUnits, Size currentSizeDeviceUnits);
    private static RECT WorkAreaBoundsForHwnd(IntPtr hwnd);
    private static RECT WorkAreaBoundsForMointor(IntPtr hMonitor);
    private static IntPtr MonitorFromWindow(IntPtr hwnd);
    internal static void CalculateCenterScreenPosition(IntPtr hMonitor, Size currentSizeDeviceUnits, Double& leftDeviceUnits, Double& topDeviceUnits);
    private bool get_CanCenterOverWPFOwner();
    private Rect GetNormalRectDeviceUnits(IntPtr hwndHandle);
    private Rect GetNormalRectLogicalUnits(IntPtr hwndHandle);
    private void CreateWindowState();
    private void CreateTopmost();
    private void CreateResizibility();
    private void UpdateIcon();
    private void SetOwnerHandle(IntPtr ownerHandle);
    private void OnSourceWindowDisposed(object sender, EventArgs e);
    private IntPtr WindowFilterMessage(IntPtr hwnd, int msg, IntPtr wParam, IntPtr lParam, Boolean& handled);
    private bool WmCommand(IntPtr wParam, IntPtr lParam);
    private bool WmClose();
    private void CloseWindowFromWmClose();
    private bool ShouldCloseWindow(bool cancelled);
    private void DoDialogHide();
    private void UpdateWindowListsOnClose();
    private bool WmDestroy();
    private bool WmActivate(IntPtr wParam);
    private void UpdateDimensionsToRestoreBounds();
    private bool WmSizeChanged(IntPtr wParam);
    private bool WmMoveChanged();
    internal virtual void WmMoveChangedHelper();
    private bool WmGetMinMaxInfo(IntPtr lParam);
    private bool WmNcHitTest(IntPtr lParam, IntPtr& refInt);
    internal virtual bool HandleWmNcHitTestMsg(IntPtr lParam, IntPtr& refInt);
    private bool WmShowWindow(IntPtr wParam, IntPtr lParam);
    private static void _OnIconChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private void OnIconChanged(ImageSource newIcon);
    private static void _OnTitleChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static bool _ValidateText(object value);
    private void OnTitleChanged();
    private static void _OnShowInTaskbarChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private void OnShowInTaskbarChanged();
    private static bool _ValidateWindowStateCallback(object value);
    private static void _OnWindowStateChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private void OnWindowStateChanged(WindowState windowState);
    private static bool _ValidateWindowStyleCallback(object value);
    private static void _OnWindowStyleChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private void OnWindowStyleChanged(WindowStyle windowStyle);
    private static void _OnTopmostChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private void OnTopmostChanged(bool topmost);
    private static object CoerceVisibility(DependencyObject d, object value);
    private static void _OnVisibilityChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private void SafeCreateWindowDuringShow();
    private void SetShowKeyboardCueState();
    private void ClearShowKeyboardCueState();
    private void UpdateVisibilityProperty(Visibility value);
    private object ShowHelper(object booleanBox);
    internal virtual int nCmdForShow();
    private void SafeStyleSetter();
    private static bool _ValidateSizeToContentCallback(object value);
    private static object _SizeToContentGetValueOverride(DependencyObject d);
    private static void _OnSizeToContentChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private void OnSizeToContentChanged(SizeToContent sizeToContent);
    private static void ValidateLengthForHeightWidth(double l);
    private static void ValidateTopLeft(double length);
    private static void _OnHeightChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private void OnHeightChanged(double height);
    private static void _OnMinHeightChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private void OnMinHeightChanged(double minHeight);
    private static void _OnMaxHeightChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private void OnMaxHeightChanged(double maxHeight);
    private static void _OnWidthChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private void OnWidthChanged(double width);
    private static void _OnMinWidthChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private void OnMinWidthChanged(double minWidth);
    private static void _OnMaxWidthChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private void OnMaxWidthChanged(double maxWidth);
    private void UpdateHwndRestoreBounds(double newValue, BoundsSpecified specifiedRestoreBounds);
    private Point TransformWorkAreaScreenArea(Point pt, TransformType transformType);
    private static object CoerceTop(DependencyObject d, object value);
    private static void _OnTopChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private void OnTopChanged(double newTop);
    private static object CoerceLeft(DependencyObject d, object value);
    private static void _OnLeftChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private void OnLeftChanged(double newLeft);
    private void UpdateHwndPositionOnTopLeftChange(double leftLogicalUnits, double topLogicalUnits);
    private static bool _ValidateResizeModeCallback(object value);
    private static void _OnResizeModeChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private void OnResizeModeChanged();
    private static object VerifyAccessCoercion(DependencyObject d, object value);
    private static void _OnFlowDirectionChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private void OnFlowDirectionChanged();
    private static object CoerceRenderTransform(DependencyObject d, object value);
    private static void _OnRenderTransformChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private static object CoerceClipToBounds(DependencyObject d, object value);
    private static void _OnClipToBoundsChanged(DependencyObject d, DependencyPropertyChangedEventArgs e);
    private HwndWrapper EnsureHiddenWindow();
    private void SetTaskbarStatus();
    private void OnTaskbarRetryTimerTick(object sender, EventArgs e);
    private void ApplyTaskbarItemInfo();
    private HRESULT UpdateTaskbarProgressState();
    private HRESULT UpdateTaskbarProgressValue();
    private HRESULT UpdateTaskbarOverlay();
    private HRESULT UpdateTaskbarDescription();
    private HRESULT UpdateTaskbarThumbnailClipping();
    private HRESULT RegisterTaskbarThumbButtons();
    private HRESULT UpdateTaskbarThumbButtons();
    private void CreateRtl();
    internal void Flush();
    private void ClearRootVisual();
    private POINT GetPointRelativeToWindow(int x, int y);
    private Size GetHwndNonClientAreaSizeInMeasureUnits();
    private void ClearSourceWindow();
    private void ClearHiddenWindowIfAny();
    private void VerifyConsistencyWithAllowsTransparency();
    private void VerifyConsistencyWithAllowsTransparency(WindowStyle style);
    private void VerifyConsistencyWithShowActivated();
    private static bool IsValidSizeToContent(SizeToContent value);
    private static bool IsValidResizeMode(ResizeMode value);
    private static bool IsValidWindowStartupLocation(WindowStartupLocation value);
    private static bool IsValidWindowState(WindowState value);
    private static bool IsValidWindowStyle(WindowStyle value);
    protected virtual void OnManipulationBoundaryFeedback(ManipulationBoundaryFeedbackEventArgs e);
    private static void OnStaticManipulationInertiaStarting(object sender, ManipulationInertiaStartingEventArgs e);
    private static void OnStaticManipulationCompleted(object sender, ManipulationCompletedEventArgs e);
    private void UpdatePanningFeedback(Vector totalOverpanOffset, object originalSource);
    private void EndPanningFeedback(bool animateBack);
    private Point CompensateForPanningFeedback(Point point);
    private SizeToContent get_HwndSourceSizeToContent();
    private void set_HwndSourceSizeToContent(SizeToContent value);
    private RECT get_WindowBounds();
    private int get_StyleFromHwnd();
    private int get_StyleExFromHwnd();
    private WindowCollection get_OwnedWindowsInternal();
    private Application get_App();
    private bool get_IsInsideApp();
    private EventHandlerList get_Events();
    internal virtual DependencyObjectType get_DTypeThemeStyleKey();
    [CompilerGeneratedAttribute]
private object <PostContentRendered>b__202_0(object unused);
}
[DefaultMemberAttribute("Item")]
public class System.Windows.WindowCollection : object {
    private ArrayList _list;
    public Window Item { get; }
    public int Count { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    internal WindowCollection(int count);
    public Window get_Item(int index);
    public sealed virtual IEnumerator GetEnumerator();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public void CopyTo(Window[] array, int index);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    internal WindowCollection Clone();
    internal void Remove(Window win);
    internal void RemoveAt(int index);
    internal int Add(Window win);
    internal bool HasItem(Window win);
}
[LocalizabilityAttribute("0")]
public enum System.Windows.WindowStartupLocation : Enum {
    public int value__;
    public static WindowStartupLocation Manual;
    public static WindowStartupLocation CenterScreen;
    public static WindowStartupLocation CenterOwner;
}
public enum System.Windows.WindowState : Enum {
    public int value__;
    public static WindowState Normal;
    public static WindowState Minimized;
    public static WindowState Maximized;
}
public enum System.Windows.WindowStyle : Enum {
    public int value__;
    public static WindowStyle None;
    public static WindowStyle SingleBorderWindow;
    public static WindowStyle ThreeDBorderWindow;
    public static WindowStyle ToolWindow;
}
public enum System.Windows.WrapDirection : Enum {
    public int value__;
    public static WrapDirection None;
    public static WrapDirection Left;
    public static WrapDirection Right;
    public static WrapDirection Both;
}
