internal static class FxResources.System.Security.Cryptography.Pkcs.SR : object {
}
[ExtensionAttribute]
internal static class Internal.Cryptography.CryptoThrowHelper : object {
    [ExtensionAttribute]
public static CryptographicException ToCryptographicException(int hr);
}
internal abstract class Internal.Cryptography.DecryptorPal : object {
    [CompilerGeneratedAttribute]
private RecipientInfoCollection <RecipientInfos>k__BackingField;
    public RecipientInfoCollection RecipientInfos { get; }
    internal DecryptorPal(RecipientInfoCollection recipientInfos);
    [CompilerGeneratedAttribute]
public RecipientInfoCollection get_RecipientInfos();
    public abstract virtual ContentInfo TryDecrypt(RecipientInfo recipientInfo, X509Certificate2 cert, AsymmetricAlgorithm privateKey, X509Certificate2Collection originatorCerts, X509Certificate2Collection extraStore, Exception& exception);
    public abstract virtual void Dispose();
}
[ExtensionAttribute]
internal static class Internal.Cryptography.Helpers : object {
    [ExtensionAttribute]
public static Byte[] CloneByteArray(Byte[] src);
}
internal abstract class Internal.Cryptography.KeyAgreeRecipientInfoPal : RecipientInfoPal {
    public DateTime Date { get; }
    public SubjectIdentifierOrKey OriginatorIdentifierOrKey { get; }
    public CryptographicAttributeObject OtherKeyAttribute { get; }
    public abstract virtual DateTime get_Date();
    public abstract virtual SubjectIdentifierOrKey get_OriginatorIdentifierOrKey();
    public abstract virtual CryptographicAttributeObject get_OtherKeyAttribute();
}
internal static class Internal.Cryptography.KeyLengths : object {
    public static int Rc2_40Bit;
    public static int Rc2_56Bit;
    public static int Rc2_64Bit;
    public static int Rc2_128Bit;
    public static int Rc4Max_128Bit;
    public static int Des_64Bit;
    public static int TripleDes_192Bit;
    public static int DefaultKeyLengthForRc2AndRc4;
}
internal abstract class Internal.Cryptography.KeyTransRecipientInfoPal : RecipientInfoPal {
}
[ExtensionAttribute]
internal static class Internal.Cryptography.Pal.AnyOS.AsnHelpers : object {
    [ExtensionAttribute]
internal static SubjectIdentifierOrKey ToSubjectIdentifierOrKey(OriginatorIdentifierOrKeyAsn originator);
    [ExtensionAttribute]
internal static AlgorithmIdentifier ToPresentationObject(AlgorithmIdentifierAsn asn);
}
internal class Internal.Cryptography.Pal.AnyOS.ManagedPkcsPal : PkcsPal {
    private static Byte[] s_invalidEmptyOid;
    private static ManagedPkcsPal();
    public virtual void AddCertsFromStoreForDecryption(X509Certificate2Collection certs);
    public virtual Byte[] GetSubjectKeyIdentifier(X509Certificate2 certificate);
    public virtual T GetPrivateKeyForSigning(X509Certificate2 certificate, bool silent);
    public virtual T GetPrivateKeyForDecryption(X509Certificate2 certificate, bool silent);
    private T GetPrivateKey(X509Certificate2 certificate);
    private static SymmetricAlgorithm OpenAlgorithm(AlgorithmIdentifierAsn contentEncryptionAlgorithm);
    private static SymmetricAlgorithm OpenAlgorithm(AlgorithmIdentifier algorithmIdentifier);
    private static SymmetricAlgorithm OpenAlgorithm(Oid algorithmIdentifier);
    public virtual Byte[] EncodeOctetString(Byte[] octets);
    public virtual Byte[] DecodeOctetString(Byte[] encodedOctets);
    public static Byte[] DecodeOctetStringCore(Byte[] encodedOctets);
    public virtual Byte[] EncodeUtcTime(DateTime utcTime);
    public virtual DateTime DecodeUtcTime(Byte[] encodedUtcTime);
    public virtual string DecodeOid(Byte[] encodedOid);
    public virtual Oid GetEncodedMessageType(Byte[] encodedMessage);
    public virtual DecryptorPal Decode(Byte[] encodedMessage, Int32& version, ContentInfo& contentInfo, AlgorithmIdentifier& contentEncryptionAlgorithm, X509Certificate2Collection& originatorCerts, CryptographicAttributeObjectCollection& unprotectedAttributes);
    public virtual Byte[] Encrypt(CmsRecipientCollection recipients, ContentInfo contentInfo, AlgorithmIdentifier contentEncryptionAlgorithm, X509Certificate2Collection originatorCerts, CryptographicAttributeObjectCollection unprotectedAttributes);
    private Byte[] Encrypt(CmsRecipientCollection recipients, ContentInfo contentInfo, AlgorithmIdentifier contentEncryptionAlgorithm, X509Certificate2Collection originatorCerts, CryptographicAttributeObjectCollection unprotectedAttributes, Byte[] encryptedContent, Byte[] cek, Byte[] parameterBytes);
    private Byte[] EncryptContent(ContentInfo contentInfo, AlgorithmIdentifier contentEncryptionAlgorithm, Byte[]& cek, Byte[]& parameterBytes);
    public virtual Exception CreateRecipientsNotFoundException();
    public virtual Exception CreateRecipientInfosAfterEncryptException();
    public virtual Exception CreateDecryptAfterEncryptException();
    public virtual Exception CreateDecryptTwiceException();
    private static Exception CreateInvalidMessageTypeException();
    private KeyTransRecipientInfoAsn MakeKtri(Byte[] cek, CmsRecipient recipient, Boolean& v0Recipient);
    private static Byte[] DecryptKey(RSA privateKey, RSAEncryptionPadding encryptionPadding, ReadOnlySpan`1<byte> encryptedKey, Exception& exception);
}
internal enum Internal.Cryptography.Pal.Windows.AlgId : Enum {
    public int value__;
    public static AlgId CALG_RSA_KEYX;
    public static AlgId CALG_DH_SF;
    public static AlgId CALG_DH_EPHEM;
    public static AlgId CALG_RC2;
    public static AlgId CALG_RC4;
    public static AlgId CALG_DES;
    public static AlgId CALG_3DES;
}
internal class Internal.Cryptography.Pal.Windows.DecryptorPalWindows : DecryptorPal {
    private SafeCryptMsgHandle _hCryptMsg;
    private AlgorithmIdentifierAsn _contentEncryptionAlgorithm;
    private DecryptorPalWindows(SafeCryptMsgHandle hCryptMsg, RecipientInfoCollection recipientInfos, AlgorithmIdentifierAsn contentEncryptionAlgorithm);
    public sealed virtual void Dispose();
    internal static DecryptorPalWindows Decode(Byte[] encodedMessage, Int32& version, ContentInfo& contentInfo, AlgorithmIdentifier& contentEncryptionAlgorithm, X509Certificate2Collection& originatorCerts, CryptographicAttributeObjectCollection& unprotectedAttributes);
    private static RecipientInfoCollection CreateRecipientInfos(SafeCryptMsgHandle hCryptMsg);
    private static IEnumerable`1<RecipientInfo> ToRecipientInfosForThisIndex(SafeHandle pCmsgCmsRecipientInfoMemory, int index);
    public sealed virtual ContentInfo TryDecrypt(RecipientInfo recipientInfo, X509Certificate2 cert, AsymmetricAlgorithm privateKey, X509Certificate2Collection originatorCerts, X509Certificate2Collection extraStore, Exception& exception);
    private static Exception TryGetKeySpecForCertificate(X509Certificate2 cert, CryptKeySpec& keySpec);
    private Exception TryDecryptTrans(KeyTransRecipientInfo recipientInfo, SafeProvOrNCryptKeyHandle hKey, CryptKeySpec keySpec);
    private Exception TryDecryptAgree(KeyAgreeRecipientInfo keyAgreeRecipientInfo, SafeProvOrNCryptKeyHandle hKey, CryptKeySpec keySpec, X509Certificate2Collection originatorCerts, X509Certificate2Collection extraStore);
    private Exception TryExecuteDecryptAgree(CMSG_CTRL_KEY_AGREE_DECRYPT_PARA& decryptPara);
}
internal class Internal.Cryptography.Pal.Windows.HeapBlockRetainer : object {
    private List`1<object> _mustLive;
    private List`1<SafeHeapAllocHandle> _blocks;
    public IntPtr Alloc(int cbSize);
    public IntPtr Alloc(int howMany, int cbElement);
    public IntPtr AllocAsciiString(string s);
    public IntPtr AllocBytes(Byte[] data);
    public void KeepAlive(object o);
    public sealed virtual void Dispose();
}
[ExtensionAttribute]
internal static class Internal.Cryptography.Pal.Windows.HelpersWindows : object {
    [ExtensionAttribute]
public static CryptographicException ToCryptographicException(ErrorCode errorCode);
    [ExtensionAttribute]
public static string ToStringAnsi(IntPtr psz);
    [ExtensionAttribute]
public static Byte[] GetMsgParamAsByteArray(SafeCryptMsgHandle hCryptMsg, CryptMsgParamType paramType, int index);
    [ExtensionAttribute]
public static SafeHandle GetMsgParamAsMemory(SafeCryptMsgHandle hCryptMsg, CryptMsgParamType paramType, int index);
    [ExtensionAttribute]
public static Byte[] ToByteArray(DATA_BLOB blob);
    [ExtensionAttribute]
public static CryptMsgType GetMessageType(SafeCryptMsgHandle hCryptMsg);
    [ExtensionAttribute]
public static int GetVersion(SafeCryptMsgHandle hCryptMsg);
    [ExtensionAttribute]
public static ContentInfo GetContentInfo(SafeCryptMsgHandle hCryptMsg);
    [ExtensionAttribute]
public static X509Certificate2Collection GetOriginatorCerts(SafeCryptMsgHandle hCryptMsg);
    [ExtensionAttribute]
public static AlgId ToAlgId(string oidValue);
    [ExtensionAttribute]
public static SafeCertContextHandle CreateCertContextHandle(X509Certificate2 cert);
    [ExtensionAttribute]
public static Byte[] GetSubjectKeyIdentifer(SafeCertContextHandle hCertContext);
    [ExtensionAttribute]
public static SubjectIdentifier ToSubjectIdentifier(CERT_ID certId);
    [ExtensionAttribute]
public static SubjectIdentifierOrKey ToSubjectIdentifierOrKey(CERT_ID certId);
    [ExtensionAttribute]
public static SubjectIdentifierOrKey ToSubjectIdentifierOrKey(CERT_PUBLIC_KEY_INFO publicKeyInfo);
    [ExtensionAttribute]
public static AlgorithmIdentifier ToAlgorithmIdentifier(CRYPT_ALGORITHM_IDENTIFIER cryptAlgorithmIdentifer);
    [ExtensionAttribute]
public static CryptographicAttributeObjectCollection GetUnprotectedAttributes(SafeCryptMsgHandle hCryptMsg);
    [ExtensionAttribute]
public static CspParameters GetProvParameters(SafeProvOrNCryptKeyHandle handle);
    private static string GetStringProvParam(SafeProvOrNCryptKeyHandle handle, CryptProvParam dwParam, Span`1& buf, Byte[]& rented, int clearLen);
    private static CryptographicAttributeObjectCollection ToCryptographicAttributeObjectCollection(CRYPT_ATTRIBUTES* pCryptAttributes);
    private static void AddCryptAttribute(CryptographicAttributeObjectCollection collection, CRYPT_ATTRIBUTE* pCryptAttribute);
}
internal class Internal.Cryptography.Pal.Windows.KeyAgreeRecipientInfoPalWindows : KeyAgreeRecipientInfoPal {
    [CompilerGeneratedAttribute]
private int <Index>k__BackingField;
    [CompilerGeneratedAttribute]
private int <SubIndex>k__BackingField;
    private SafeHandle _pCmsgCmsRecipientInfoMemory;
    public int Version { get; }
    public SubjectIdentifier RecipientIdentifier { get; }
    public AlgorithmIdentifier KeyEncryptionAlgorithm { get; }
    public Byte[] EncryptedKey { get; }
    public SubjectIdentifierOrKey OriginatorIdentifierOrKey { get; }
    public DateTime Date { get; }
    public CryptographicAttributeObject OtherKeyAttribute { get; }
    internal int Index { get; }
    internal int SubIndex { get; }
    internal KeyAgreeRecipientInfoPalWindows(SafeHandle pCmsgCmsRecipientInfoMemory, int index, int subIndex);
    public sealed virtual int get_Version();
    public sealed virtual SubjectIdentifier get_RecipientIdentifier();
    public sealed virtual AlgorithmIdentifier get_KeyEncryptionAlgorithm();
    public sealed virtual Byte[] get_EncryptedKey();
    public sealed virtual SubjectIdentifierOrKey get_OriginatorIdentifierOrKey();
    public sealed virtual DateTime get_Date();
    public sealed virtual CryptographicAttributeObject get_OtherKeyAttribute();
    [CompilerGeneratedAttribute]
internal int get_Index();
    [CompilerGeneratedAttribute]
internal int get_SubIndex();
    internal T WithCmsgCmsRecipientInfo(KeyAgreeReceiver`1<T> receiver);
    [CompilerGeneratedAttribute]
private SubjectIdentifier <get_RecipientIdentifier>b__4_0(CMSG_KEY_AGREE_RECIPIENT_INFO* recipient);
    [CompilerGeneratedAttribute]
private Byte[] <get_EncryptedKey>b__8_0(CMSG_KEY_AGREE_RECIPIENT_INFO* recipient);
    [CompilerGeneratedAttribute]
private DateTime <get_Date>b__12_0(CMSG_KEY_AGREE_RECIPIENT_INFO* recipient);
    [CompilerGeneratedAttribute]
private CryptographicAttributeObject <get_OtherKeyAttribute>b__14_0(CMSG_KEY_AGREE_RECIPIENT_INFO* recipient);
}
internal class Internal.Cryptography.Pal.Windows.KeyTransRecipientInfoPalWindows : KeyTransRecipientInfoPal {
    [CompilerGeneratedAttribute]
private int <Index>k__BackingField;
    private SafeHandle _pCmsgCmsRecipientInfoMemory;
    public int Version { get; }
    public SubjectIdentifier RecipientIdentifier { get; }
    public AlgorithmIdentifier KeyEncryptionAlgorithm { get; }
    public Byte[] EncryptedKey { get; }
    internal int Index { get; }
    internal KeyTransRecipientInfoPalWindows(SafeHandle pCmsgCmsRecipientInfoMemory, int index);
    public sealed virtual int get_Version();
    public sealed virtual SubjectIdentifier get_RecipientIdentifier();
    public sealed virtual AlgorithmIdentifier get_KeyEncryptionAlgorithm();
    public sealed virtual Byte[] get_EncryptedKey();
    [CompilerGeneratedAttribute]
internal int get_Index();
    private T WithCmsgCmsRecipientInfo(KeyTransReceiver`1<T> receiver);
}
internal class Internal.Cryptography.Pal.Windows.PkcsPalWindows : PkcsPal {
    public sealed virtual DecryptorPal Decode(Byte[] encodedMessage, Int32& version, ContentInfo& contentInfo, AlgorithmIdentifier& contentEncryptionAlgorithm, X509Certificate2Collection& originatorCerts, CryptographicAttributeObjectCollection& unprotectedAttributes);
    public sealed virtual Byte[] EncodeOctetString(Byte[] octets);
    public sealed virtual Byte[] DecodeOctetString(Byte[] encodedOctets);
    public sealed virtual Byte[] EncodeUtcTime(DateTime utcTime);
    public sealed virtual DateTime DecodeUtcTime(Byte[] encodedUtcTime);
    public sealed virtual string DecodeOid(Byte[] encodedOid);
    public sealed virtual Oid GetEncodedMessageType(Byte[] encodedMessage);
    public sealed virtual void AddCertsFromStoreForDecryption(X509Certificate2Collection certs);
    public sealed virtual Exception CreateRecipientsNotFoundException();
    public sealed virtual Exception CreateRecipientInfosAfterEncryptException();
    public sealed virtual Exception CreateDecryptAfterEncryptException();
    public sealed virtual Exception CreateDecryptTwiceException();
    public sealed virtual Byte[] GetSubjectKeyIdentifier(X509Certificate2 certificate);
    public virtual T GetPrivateKeyForSigning(X509Certificate2 certificate, bool silent);
    public virtual T GetPrivateKeyForDecryption(X509Certificate2 certificate, bool silent);
    private T GetPrivateKey(X509Certificate2 certificate, bool silent, bool preferNCrypt);
    internal static SafeProvOrNCryptKeyHandle GetCertificatePrivateKey(X509Certificate2 cert, bool silent, bool preferNCrypt, CryptKeySpec& keySpec, Exception& exception);
    public sealed virtual Byte[] Encrypt(CmsRecipientCollection recipients, ContentInfo contentInfo, AlgorithmIdentifier contentEncryptionAlgorithm, X509Certificate2Collection originatorCerts, CryptographicAttributeObjectCollection unprotectedAttributes);
    private static void ReencodeIfUsingIndefiniteLengthEncodingOnOuterStructure(Byte[]& encodedContent);
}
[ExtensionAttribute]
internal static class Internal.Cryptography.PkcsHelpers : object {
    private static Byte[] s_pSpecifiedDefaultParameters;
    private static PkcsHelpers();
    internal static HashAlgorithmName GetDigestAlgorithm(Oid oid);
    internal static HashAlgorithmName GetDigestAlgorithm(string oidValue, bool forVerification);
    internal static string GetOidFromHashAlgorithm(HashAlgorithmName algName);
    [ExtensionAttribute]
public static Byte[] Resize(Byte[] a, int size);
    public static void RemoveAt(T[]& arr, int idx);
    public static AttributeAsn[] NormalizeAttributeSet(AttributeAsn[] setItems, Action`1<Byte[]> encodedValueProcessor);
    internal static Byte[] EncodeContentInfo(ReadOnlyMemory`1<byte> content, string contentType, AsnEncodingRules ruleSet);
    [ExtensionAttribute]
public static CmsRecipientCollection DeepCopy(CmsRecipientCollection recipients);
    [ExtensionAttribute]
public static Byte[] UnicodeToOctetString(string s);
    [ExtensionAttribute]
public static string OctetStringToUnicode(Byte[] octets);
    public static X509Certificate2Collection GetStoreCertificates(StoreName storeName, StoreLocation storeLocation, bool openExistingOnly);
    [ExtensionAttribute]
public static X509Certificate2 TryFindMatchingCertificate(X509Certificate2Collection certs, SubjectIdentifier recipientIdentifier);
    internal static bool AreByteArraysEqual(Byte[] ba1, Byte[] ba2);
    [ExtensionAttribute]
internal static Byte[] ToSkiBytes(string skiString);
    [ExtensionAttribute]
public static string ToSkiString(Byte[] skiBytes);
    [ExtensionAttribute]
public static string ToBigEndianHex(ReadOnlySpan`1<byte> bytes);
    [ExtensionAttribute]
internal static Byte[] ToSerialBytes(string serialString);
    [ExtensionAttribute]
public static string ToSerialString(Byte[] serialBytes);
    private static string ToUpperHexString(ReadOnlySpan`1<byte> ba);
    [ExtensionAttribute]
private static Byte[] UpperHexStringToByteArray(string normalizedString);
    private static byte UpperHexCharToNybble(char c);
    public static Pkcs9AttributeObject CreateBestPkcs9AttributeObjectAvailable(Oid oid, Byte[] encodedAttribute);
    private static T Upgrade(Pkcs9AttributeObject basicAttribute);
    [ExtensionAttribute]
internal static Byte[] OneShot(ICryptoTransform transform, Byte[] data);
    [ExtensionAttribute]
internal static Byte[] OneShot(ICryptoTransform transform, Byte[] data, int offset, int length);
    public static ReadOnlyMemory`1<byte> DecodeOctetString(ReadOnlyMemory`1<byte> encodedOctetString);
    public static bool TryGetRsaOaepEncryptionPadding(Nullable`1<ReadOnlyMemory`1<byte>> parameters, RSAEncryptionPadding& rsaEncryptionPadding, Exception& exception);
}
internal abstract class Internal.Cryptography.PkcsPal : object {
    private protected static Byte[] s_rsaOaepSha1Parameters;
    private protected static Byte[] s_rsaOaepSha256Parameters;
    private protected static Byte[] s_rsaOaepSha384Parameters;
    private protected static Byte[] s_rsaOaepSha512Parameters;
    private protected static Byte[] s_rsaPkcsParameters;
    private static PkcsPal s_instance;
    public static PkcsPal Instance { get; }
    private static PkcsPal();
    public abstract virtual Byte[] Encrypt(CmsRecipientCollection recipients, ContentInfo contentInfo, AlgorithmIdentifier contentEncryptionAlgorithm, X509Certificate2Collection originatorCerts, CryptographicAttributeObjectCollection unprotectedAttributes);
    public abstract virtual DecryptorPal Decode(Byte[] encodedMessage, Int32& version, ContentInfo& contentInfo, AlgorithmIdentifier& contentEncryptionAlgorithm, X509Certificate2Collection& originatorCerts, CryptographicAttributeObjectCollection& unprotectedAttributes);
    public abstract virtual Byte[] EncodeOctetString(Byte[] octets);
    public abstract virtual Byte[] DecodeOctetString(Byte[] encodedOctets);
    public abstract virtual Byte[] EncodeUtcTime(DateTime utcTime);
    public abstract virtual DateTime DecodeUtcTime(Byte[] encodedUtcTime);
    public abstract virtual string DecodeOid(Byte[] encodedOid);
    public abstract virtual Oid GetEncodedMessageType(Byte[] encodedMessage);
    public abstract virtual void AddCertsFromStoreForDecryption(X509Certificate2Collection certs);
    public abstract virtual Exception CreateRecipientsNotFoundException();
    public abstract virtual Exception CreateRecipientInfosAfterEncryptException();
    public abstract virtual Exception CreateDecryptAfterEncryptException();
    public abstract virtual Exception CreateDecryptTwiceException();
    public abstract virtual Byte[] GetSubjectKeyIdentifier(X509Certificate2 certificate);
    public abstract virtual T GetPrivateKeyForSigning(X509Certificate2 certificate, bool silent);
    public abstract virtual T GetPrivateKeyForDecryption(X509Certificate2 certificate, bool silent);
    public static PkcsPal get_Instance();
}
internal abstract class Internal.Cryptography.RecipientInfoPal : object {
    public Byte[] EncryptedKey { get; }
    public AlgorithmIdentifier KeyEncryptionAlgorithm { get; }
    public SubjectIdentifier RecipientIdentifier { get; }
    public int Version { get; }
    public abstract virtual Byte[] get_EncryptedKey();
    public abstract virtual AlgorithmIdentifier get_KeyEncryptionAlgorithm();
    public abstract virtual SubjectIdentifier get_RecipientIdentifier();
    public abstract virtual int get_Version();
}
internal static class Interop : object {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
internal class Microsoft.Win32.SafeHandles.SafeCertContextHandle : SafeHandle {
    public bool IsInvalid { get; }
    internal SafeCertContextHandle(IntPtr handle);
    internal CERT_CONTEXT* DangerousGetCertContext();
    public sealed virtual bool get_IsInvalid();
    protected sealed virtual bool ReleaseHandle();
}
internal class Microsoft.Win32.SafeHandles.SafeCryptMsgHandle : SafeHandle {
    public bool IsInvalid { get; }
    public sealed virtual bool get_IsInvalid();
    protected sealed virtual bool ReleaseHandle();
}
internal static class Microsoft.Win32.SafeHandles.SafeHandleCache`1 : object {
    private static T s_invalidHandle;
    internal static T GetInvalidHandle(Func`1<T> invalidHandleFactory);
    internal static bool IsCachedInvalidHandle(SafeHandle handle);
}
internal class Microsoft.Win32.SafeHandles.SafeHeapAllocHandle : SafeBuffer {
    private static IntPtr s_hHeap;
    private static SafeHeapAllocHandle();
    internal static SafeHeapAllocHandle Alloc(int size);
    protected sealed virtual bool ReleaseHandle();
}
internal abstract class Microsoft.Win32.SafeHandles.SafeProvOrNCryptKeyHandle : SafeHandle {
    public bool IsInvalid { get; }
    internal SafeProvOrNCryptKeyHandle(IntPtr handle, bool ownsHandle);
    public sealed virtual bool get_IsInvalid();
}
internal class Microsoft.Win32.SafeHandles.SafeProvOrNCryptKeyHandleUwp : SafeProvOrNCryptKeyHandle {
    private bool _isNcrypt;
    private SafeHandle _parentHandle;
    internal SafeProvOrNCryptKeyHandleUwp(IntPtr handle, SafeHandle parentHandle);
    internal SafeProvOrNCryptKeyHandleUwp(IntPtr handle, bool ownsHandle, bool isNcrypt);
    protected sealed virtual bool ReleaseHandle();
}
internal class System.Buffers.PointerMemoryManager`1 : MemoryManager`1<T> {
    private Void* _pointer;
    private int _length;
    internal PointerMemoryManager`1(Void* pointer, int length);
    protected virtual void Dispose(bool disposing);
    public virtual Span`1<T> GetSpan();
    public virtual MemoryHandle Pin(int elementIndex);
    public virtual void Unpin();
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[EmbeddedAttribute]
[CompilerGeneratedAttribute]
[AttributeUsageAttribute("5198")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.NullablePublicOnlyAttribute : Attribute {
    public bool IncludesInternals;
    public NullablePublicOnlyAttribute(bool );
}
internal class System.Security.Cryptography.Asn1.AlgorithmIdentifierAsn : ValueType {
    internal Oid Algorithm;
    internal Nullable`1<ReadOnlyMemory`1<byte>> Parameters;
    internal static ReadOnlyMemory`1<byte> ExplicitDerNull;
    private static AlgorithmIdentifierAsn();
    internal void Encode(AsnWriter writer);
    internal void Encode(AsnWriter writer, Asn1Tag tag);
    internal static AlgorithmIdentifierAsn Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static AlgorithmIdentifierAsn Decode(Asn1Tag expectedTag, ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static void Decode(AsnReader reader, AlgorithmIdentifierAsn& decoded);
    internal static void Decode(AsnReader reader, Asn1Tag expectedTag, AlgorithmIdentifierAsn& decoded);
    internal bool Equals(AlgorithmIdentifierAsn& other);
    internal bool HasNullEquivalentParameters();
    private static bool RepresentsNull(Nullable`1<ReadOnlyMemory`1<byte>> parameters);
}
internal class System.Security.Cryptography.Asn1.Asn1Tag : ValueType {
    private static byte ClassMask;
    private static byte ConstructedMask;
    private static byte ControlMask;
    private static byte TagNumberMask;
    private byte _controlFlags;
    [CompilerGeneratedAttribute]
private int <TagValue>k__BackingField;
    public static Asn1Tag EndOfContents;
    public static Asn1Tag Boolean;
    public static Asn1Tag Integer;
    public static Asn1Tag PrimitiveBitString;
    public static Asn1Tag ConstructedBitString;
    public static Asn1Tag PrimitiveOctetString;
    public static Asn1Tag ConstructedOctetString;
    public static Asn1Tag Null;
    public static Asn1Tag ObjectIdentifier;
    public static Asn1Tag Enumerated;
    public static Asn1Tag Sequence;
    public static Asn1Tag SetOf;
    public static Asn1Tag UtcTime;
    public static Asn1Tag GeneralizedTime;
    public TagClass TagClass { get; }
    public bool IsConstructed { get; }
    public int TagValue { get; private set; }
    private Asn1Tag(byte controlFlags, int tagValue);
    public Asn1Tag(UniversalTagNumber universalTagNumber, bool isConstructed);
    public Asn1Tag(TagClass tagClass, int tagValue, bool isConstructed);
    private static Asn1Tag();
    public TagClass get_TagClass();
    public bool get_IsConstructed();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_TagValue();
    [CompilerGeneratedAttribute]
private void set_TagValue(int value);
    public Asn1Tag AsConstructed();
    public Asn1Tag AsPrimitive();
    public static bool TryDecode(ArraySegment`1<byte> source, Asn1Tag& tag, Int32& bytesConsumed);
    public static bool TryDecode(ReadOnlySpan`1<byte> source, Asn1Tag& tag, Int32& bytesConsumed);
    public int CalculateEncodedSize();
    public bool TryEncode(Span`1<byte> destination, Int32& bytesWritten);
    public bool TryEncode(ArraySegment`1<byte> destination, Int32& bytesWritten);
    public int Encode(Span`1<byte> destination);
    public int Encode(ArraySegment`1<byte> destination);
    public sealed virtual bool Equals(Asn1Tag other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(Asn1Tag left, Asn1Tag right);
    public static bool op_Inequality(Asn1Tag left, Asn1Tag right);
    public bool HasSameClassAndValue(Asn1Tag other);
    public virtual string ToString();
}
internal static class System.Security.Cryptography.Asn1.AsnCharacterStringEncodings : object {
    private static Encoding s_utf8Encoding;
    private static Encoding s_bmpEncoding;
    private static Encoding s_ia5Encoding;
    private static Encoding s_visibleStringEncoding;
    private static Encoding s_numericStringEncoding;
    private static Encoding s_printableStringEncoding;
    private static Encoding s_t61Encoding;
    private static AsnCharacterStringEncodings();
    internal static Encoding GetEncoding(UniversalTagNumber encodingType);
}
internal enum System.Security.Cryptography.Asn1.AsnEncodingRules : Enum {
    public int value__;
    public static AsnEncodingRules BER;
    public static AsnEncodingRules CER;
    public static AsnEncodingRules DER;
}
internal class System.Security.Cryptography.Asn1.AsnReader : object {
    internal static int MaxCERSegmentSize;
    private static int EndOfContentsEncodedLength;
    private ReadOnlyMemory`1<byte> _data;
    [CompilerGeneratedAttribute]
private AsnEncodingRules <RuleSet>k__BackingField;
    public AsnEncodingRules RuleSet { get; }
    public bool HasData { get; }
    public AsnReader(ReadOnlyMemory`1<byte> data, AsnEncodingRules ruleSet);
    [CompilerGeneratedAttribute]
public AsnEncodingRules get_RuleSet();
    public bool get_HasData();
    public void ThrowIfNotEmpty();
    public Asn1Tag PeekTag();
    public ReadOnlyMemory`1<byte> PeekEncodedValue();
    public ReadOnlyMemory`1<byte> PeekContentBytes();
    public ReadOnlyMemory`1<byte> ReadEncodedValue();
    private static bool TryReadLength(ReadOnlySpan`1<byte> source, AsnEncodingRules ruleSet, Nullable`1& length, Int32& bytesRead);
    internal Asn1Tag ReadTagAndLength(Nullable`1& contentsLength, Int32& bytesRead);
    private static void ValidateEndOfContents(Asn1Tag tag, Nullable`1<int> length, int headerLength);
    private int SeekEndOfContents(ReadOnlyMemory`1<byte> source);
    private static int ParseNonNegativeIntAndSlice(ReadOnlySpan`1& data, int bytesToRead);
    private static int ParseNonNegativeInt(ReadOnlySpan`1<byte> data);
    private static ReadOnlySpan`1<byte> SliceAtMost(ReadOnlySpan`1<byte> source, int longestPermitted);
    private static ReadOnlySpan`1<byte> Slice(ReadOnlySpan`1<byte> source, int offset, int length);
    private static ReadOnlyMemory`1<byte> Slice(ReadOnlyMemory`1<byte> source, int offset, Nullable`1<int> length);
    private static void CheckEncodingRules(AsnEncodingRules ruleSet);
    private static void CheckExpectedTag(Asn1Tag tag, Asn1Tag expectedTag, UniversalTagNumber tagNumber);
    public bool TryReadPrimitiveBitStringValue(Int32& unusedBitCount, ReadOnlyMemory`1& value);
    public bool TryReadPrimitiveBitStringValue(Asn1Tag expectedTag, Int32& unusedBitCount, ReadOnlyMemory`1& value);
    public bool TryCopyBitStringBytes(Span`1<byte> destination, Int32& unusedBitCount, Int32& bytesWritten);
    public bool TryCopyBitStringBytes(Asn1Tag expectedTag, Span`1<byte> destination, Int32& unusedBitCount, Int32& bytesWritten);
    public bool TryCopyBitStringBytes(ArraySegment`1<byte> destination, Int32& unusedBitCount, Int32& bytesWritten);
    public bool TryCopyBitStringBytes(Asn1Tag expectedTag, ArraySegment`1<byte> destination, Int32& unusedBitCount, Int32& bytesWritten);
    public Byte[] ReadBitString(Int32& unusedBitCount);
    public Byte[] ReadBitString(Asn1Tag expectedTag, Int32& unusedBitCount);
    private void ParsePrimitiveBitStringContents(ReadOnlyMemory`1<byte> source, Int32& unusedBitCount, ReadOnlyMemory`1& value, Byte& normalizedLastByte);
    private static void CopyBitStringValue(ReadOnlyMemory`1<byte> value, byte normalizedLastByte, Span`1<byte> destination);
    private int CountConstructedBitString(ReadOnlyMemory`1<byte> source, bool isIndefinite);
    private void CopyConstructedBitString(ReadOnlyMemory`1<byte> source, Span`1<byte> destination, bool isIndefinite, Int32& unusedBitCount, Int32& bytesRead, Int32& bytesWritten);
    private int ProcessConstructedBitString(ReadOnlyMemory`1<byte> source, Span`1<byte> destination, BitStringCopyAction copyAction, bool isIndefinite, Int32& lastUnusedBitCount, Int32& bytesRead);
    private bool TryCopyConstructedBitStringValue(ReadOnlyMemory`1<byte> source, Span`1<byte> dest, bool isIndefinite, Int32& unusedBitCount, Int32& bytesRead, Int32& bytesWritten);
    private bool TryReadPrimitiveBitStringValue(Asn1Tag expectedTag, Asn1Tag& actualTag, Nullable`1& contentsLength, Int32& headerLength, Int32& unusedBitCount, ReadOnlyMemory`1& value, Byte& normalizedLastByte);
    public bool ReadBoolean();
    public bool ReadBoolean(Asn1Tag expectedTag);
    private static bool ReadBooleanValue(ReadOnlySpan`1<byte> source, AsnEncodingRules ruleSet);
    public ReadOnlyMemory`1<byte> ReadEnumeratedBytes();
    public ReadOnlyMemory`1<byte> ReadEnumeratedBytes(Asn1Tag expectedTag);
    public TEnum ReadEnumeratedValue();
    public TEnum ReadEnumeratedValue(Asn1Tag expectedTag);
    public Enum ReadEnumeratedValue(Type tEnum);
    public Enum ReadEnumeratedValue(Asn1Tag expectedTag, Type tEnum);
    public DateTimeOffset ReadGeneralizedTime(bool disallowFractions);
    public DateTimeOffset ReadGeneralizedTime(Asn1Tag expectedTag, bool disallowFractions);
    private static DateTimeOffset ParseGeneralizedTime(AsnEncodingRules ruleSet, ReadOnlySpan`1<byte> contentOctets, bool disallowFractions);
    public ReadOnlyMemory`1<byte> ReadIntegerBytes();
    public ReadOnlyMemory`1<byte> ReadIntegerBytes(Asn1Tag expectedTag);
    public BigInteger ReadInteger();
    public BigInteger ReadInteger(Asn1Tag expectedTag);
    public bool TryReadInt32(Int32& value);
    public bool TryReadInt32(Asn1Tag expectedTag, Int32& value);
    public bool TryReadUInt32(UInt32& value);
    public bool TryReadUInt32(Asn1Tag expectedTag, UInt32& value);
    public bool TryReadInt64(Int64& value);
    public bool TryReadInt64(Asn1Tag expectedTag, Int64& value);
    public bool TryReadUInt64(UInt64& value);
    public bool TryReadUInt64(Asn1Tag expectedTag, UInt64& value);
    public bool TryReadInt16(Int16& value);
    public bool TryReadInt16(Asn1Tag expectedTag, Int16& value);
    public bool TryReadUInt16(UInt16& value);
    public bool TryReadUInt16(Asn1Tag expectedTag, UInt16& value);
    public bool TryReadInt8(SByte& value);
    public bool TryReadInt8(Asn1Tag expectedTag, SByte& value);
    public bool TryReadUInt8(Byte& value);
    public bool TryReadUInt8(Asn1Tag expectedTag, Byte& value);
    private ReadOnlyMemory`1<byte> GetIntegerContents(Asn1Tag expectedTag, UniversalTagNumber tagNumber, Int32& headerLength);
    private bool TryReadSignedInteger(int sizeLimit, Asn1Tag expectedTag, UniversalTagNumber tagNumber, Int64& value);
    private bool TryReadUnsignedInteger(int sizeLimit, Asn1Tag expectedTag, UniversalTagNumber tagNumber, UInt64& value);
    public TFlagsEnum ReadNamedBitListValue();
    public TFlagsEnum ReadNamedBitListValue(Asn1Tag expectedTag);
    public Enum ReadNamedBitListValue(Type tFlagsEnum);
    public Enum ReadNamedBitListValue(Asn1Tag expectedTag, Type tFlagsEnum);
    private static long InterpretNamedBitListReversed(ReadOnlySpan`1<byte> valueSpan);
    public void ReadNull();
    public void ReadNull(Asn1Tag expectedTag);
    public bool TryCopyOctetStringBytes(Span`1<byte> destination, Int32& bytesWritten);
    public bool TryCopyOctetStringBytes(Asn1Tag expectedTag, Span`1<byte> destination, Int32& bytesWritten);
    public bool TryCopyOctetStringBytes(ArraySegment`1<byte> destination, Int32& bytesWritten);
    public bool TryCopyOctetStringBytes(Asn1Tag expectedTag, ArraySegment`1<byte> destination, Int32& bytesWritten);
    public Byte[] ReadOctetString();
    public Byte[] ReadOctetString(Asn1Tag expectedTag);
    private bool TryReadPrimitiveOctetStringBytes(Asn1Tag expectedTag, Asn1Tag& actualTag, Nullable`1& contentLength, Int32& headerLength, ReadOnlyMemory`1& contents, UniversalTagNumber universalTagNumber);
    private bool TryReadPrimitiveOctetStringBytes(Asn1Tag expectedTag, UniversalTagNumber universalTagNumber, ReadOnlyMemory`1& contents);
    public bool TryReadPrimitiveOctetStringBytes(ReadOnlyMemory`1& contents);
    public bool TryReadPrimitiveOctetStringBytes(Asn1Tag expectedTag, ReadOnlyMemory`1& contents);
    private int CountConstructedOctetString(ReadOnlyMemory`1<byte> source, bool isIndefinite);
    private void CopyConstructedOctetString(ReadOnlyMemory`1<byte> source, Span`1<byte> destination, bool isIndefinite, Int32& bytesRead, Int32& bytesWritten);
    private int CopyConstructedOctetString(ReadOnlyMemory`1<byte> source, Span`1<byte> destination, bool write, bool isIndefinite, Int32& bytesRead);
    private bool TryCopyConstructedOctetStringContents(ReadOnlyMemory`1<byte> source, Span`1<byte> dest, bool isIndefinite, Int32& bytesRead, Int32& bytesWritten);
    private ReadOnlySpan`1<byte> GetOctetStringContents(Asn1Tag expectedTag, UniversalTagNumber universalTagNumber, Int32& bytesRead, Byte[]& rented, Span`1<byte> tmpSpace);
    public string ReadObjectIdentifierAsString();
    public string ReadObjectIdentifierAsString(Asn1Tag expectedTag);
    public Oid ReadObjectIdentifier();
    public Oid ReadObjectIdentifier(Asn1Tag expectedTag);
    private static void ReadSubIdentifier(ReadOnlySpan`1<byte> source, Int32& bytesRead, Nullable`1& smallValue, Nullable`1& largeValue);
    private string ReadObjectIdentifierAsString(Asn1Tag expectedTag, Int32& totalBytesRead);
    public AsnReader ReadSequence();
    public AsnReader ReadSequence(Asn1Tag expectedTag);
    public AsnReader ReadSetOf(bool skipSortOrderValidation);
    public AsnReader ReadSetOf(Asn1Tag expectedTag, bool skipSortOrderValidation);
    public bool TryReadPrimitiveCharacterStringBytes(UniversalTagNumber encodingType, ReadOnlyMemory`1& contents);
    public bool TryReadPrimitiveCharacterStringBytes(Asn1Tag expectedTag, UniversalTagNumber encodingType, ReadOnlyMemory`1& contents);
    public bool TryCopyCharacterStringBytes(UniversalTagNumber encodingType, Span`1<byte> destination, Int32& bytesWritten);
    public bool TryCopyCharacterStringBytes(Asn1Tag expectedTag, UniversalTagNumber encodingType, Span`1<byte> destination, Int32& bytesWritten);
    public bool TryCopyCharacterStringBytes(UniversalTagNumber encodingType, ArraySegment`1<byte> destination, Int32& bytesWritten);
    public bool TryCopyCharacterStringBytes(Asn1Tag expectedTag, UniversalTagNumber encodingType, ArraySegment`1<byte> destination, Int32& bytesWritten);
    public bool TryCopyCharacterString(UniversalTagNumber encodingType, Span`1<char> destination, Int32& charsWritten);
    public bool TryCopyCharacterString(Asn1Tag expectedTag, UniversalTagNumber encodingType, Span`1<char> destination, Int32& charsWritten);
    public bool TryCopyCharacterString(UniversalTagNumber encodingType, ArraySegment`1<char> destination, Int32& charsWritten);
    public bool TryCopyCharacterString(Asn1Tag expectedTag, UniversalTagNumber encodingType, ArraySegment`1<char> destination, Int32& charsWritten);
    public string ReadCharacterString(UniversalTagNumber encodingType);
    public string ReadCharacterString(Asn1Tag expectedTag, UniversalTagNumber encodingType);
    private bool TryCopyCharacterStringBytes(Asn1Tag expectedTag, UniversalTagNumber universalTagNumber, Span`1<byte> destination, Int32& bytesRead, Int32& bytesWritten);
    private static bool TryCopyCharacterString(ReadOnlySpan`1<byte> source, Span`1<char> destination, Encoding encoding, Int32& charsWritten);
    private string ReadCharacterString(Asn1Tag expectedTag, UniversalTagNumber universalTagNumber, Encoding encoding);
    private bool TryCopyCharacterString(Asn1Tag expectedTag, UniversalTagNumber universalTagNumber, Encoding encoding, Span`1<char> destination, Int32& charsWritten);
    private static void CheckCharacterStringEncodingType(UniversalTagNumber encodingType);
    public DateTimeOffset ReadUtcTime(int twoDigitYearMax);
    public DateTimeOffset ReadUtcTime(Asn1Tag expectedTag, int twoDigitYearMax);
    private DateTimeOffset ParseUtcTime(ReadOnlySpan`1<byte> contentOctets, int twoDigitYearMax);
    [CompilerGeneratedAttribute]
internal static Nullable`1<byte> <ParseGeneralizedTime>g__GetNextState|52_0(byte octet);
}
internal class System.Security.Cryptography.Asn1.AsnWriter : object {
    private Byte[] _buffer;
    private int _offset;
    private Stack`1<ValueTuple`3<Asn1Tag, int, UniversalTagNumber>> _nestingStack;
    [CompilerGeneratedAttribute]
private AsnEncodingRules <RuleSet>k__BackingField;
    public AsnEncodingRules RuleSet { get; }
    public AsnWriter(AsnEncodingRules ruleSet);
    [CompilerGeneratedAttribute]
public AsnEncodingRules get_RuleSet();
    public sealed virtual void Dispose();
    public void Reset();
    public int GetEncodedLength();
    public bool TryEncode(Span`1<byte> destination, Int32& bytesWritten);
    public Byte[] Encode();
    internal ReadOnlySpan`1<byte> EncodeAsSpan();
    public bool ValueEquals(ReadOnlySpan`1<byte> other);
    private void CheckDisposed();
    private void EnsureWriteCapacity(int pendingCount);
    private void WriteTag(Asn1Tag tag);
    private void WriteLength(int length);
    private static int GetEncodedLengthSubsequentByteCount(int length);
    public void WriteEncodedValue(ReadOnlySpan`1<byte> preEncodedValue);
    private void WriteEncodedValue(ReadOnlyMemory`1<byte> preEncodedValue);
    private void WriteEndOfContents();
    private void PushTag(Asn1Tag tag, UniversalTagNumber tagType);
    private void PopTag(Asn1Tag tag, UniversalTagNumber tagType, bool sortContents);
    private static void SortContents(Byte[] buffer, int start, int end);
    internal static void Reverse(Span`1<byte> span);
    private static void CheckUniversalTag(Asn1Tag tag, UniversalTagNumber universalTagNumber);
    public void WriteBitString(ReadOnlySpan`1<byte> bitString, int unusedBitCount);
    public void WriteBitString(Asn1Tag tag, ReadOnlySpan`1<byte> bitString, int unusedBitCount);
    private void WriteBitStringCore(Asn1Tag tag, ReadOnlySpan`1<byte> bitString, int unusedBitCount);
    private static bool CheckValidLastByte(byte lastByte, int unusedBitCount);
    private static int DetermineCerBitStringTotalLength(Asn1Tag tag, int contentLength);
    private void WriteConstructedCerBitString(Asn1Tag tag, ReadOnlySpan`1<byte> payload, int unusedBitCount);
    public void WriteBoolean(bool value);
    public void WriteBoolean(Asn1Tag tag, bool value);
    private void WriteBooleanCore(Asn1Tag tag, bool value);
    public void WriteEnumeratedValue(object enumValue);
    public void WriteEnumeratedValue(TEnum enumValue);
    public void WriteEnumeratedValue(Asn1Tag tag, object enumValue);
    public void WriteEnumeratedValue(Asn1Tag tag, TEnum enumValue);
    private void WriteEnumeratedValue(Asn1Tag tag, Type tEnum, object enumValue);
    public void WriteGeneralizedTime(DateTimeOffset value, bool omitFractionalSeconds);
    public void WriteGeneralizedTime(Asn1Tag tag, DateTimeOffset value, bool omitFractionalSeconds);
    private void WriteGeneralizedTimeCore(Asn1Tag tag, DateTimeOffset value, bool omitFractionalSeconds);
    public void WriteInteger(long value);
    public void WriteInteger(ulong value);
    public void WriteInteger(BigInteger value);
    public void WriteInteger(ReadOnlySpan`1<byte> value);
    public void WriteInteger(Asn1Tag tag, long value);
    public void WriteInteger(Asn1Tag tag, ulong value);
    public void WriteInteger(Asn1Tag tag, BigInteger value);
    public void WriteInteger(Asn1Tag tag, ReadOnlySpan`1<byte> value);
    public void WriteIntegerUnsigned(ReadOnlySpan`1<byte> value);
    public void WriteIntegerUnsigned(Asn1Tag tag, ReadOnlySpan`1<byte> value);
    private void WriteIntegerCore(Asn1Tag tag, long value);
    private void WriteNonNegativeIntegerCore(Asn1Tag tag, ulong value);
    private void WriteIntegerUnsignedCore(Asn1Tag tag, ReadOnlySpan`1<byte> value);
    private void WriteIntegerCore(Asn1Tag tag, ReadOnlySpan`1<byte> value);
    private void WriteIntegerCore(Asn1Tag tag, BigInteger value);
    public void WriteNamedBitList(object enumValue);
    public void WriteNamedBitList(TEnum enumValue);
    public void WriteNamedBitList(Asn1Tag tag, object enumValue);
    public void WriteNamedBitList(Asn1Tag tag, TEnum enumValue);
    private void WriteNamedBitList(Asn1Tag tag, Type tEnum, object enumValue);
    private void WriteNamedBitList(Asn1Tag tag, ulong integralValue);
    public void WriteNull();
    public void WriteNull(Asn1Tag tag);
    private void WriteNullCore(Asn1Tag tag);
    public void WriteOctetString(ReadOnlySpan`1<byte> octetString);
    public void WriteOctetString(Asn1Tag tag, ReadOnlySpan`1<byte> octetString);
    private void WriteOctetStringCore(Asn1Tag tag, ReadOnlySpan`1<byte> octetString);
    private void WriteConstructedCerOctetString(Asn1Tag tag, ReadOnlySpan`1<byte> payload);
    public void WriteObjectIdentifier(Oid oid);
    public void WriteObjectIdentifier(string oidValue);
    public void WriteObjectIdentifier(ReadOnlySpan`1<char> oidValue);
    public void WriteObjectIdentifier(Asn1Tag tag, Oid oid);
    public void WriteObjectIdentifier(Asn1Tag tag, string oidValue);
    public void WriteObjectIdentifier(Asn1Tag tag, ReadOnlySpan`1<char> oidValue);
    private void WriteObjectIdentifierCore(Asn1Tag tag, ReadOnlySpan`1<char> oidValue);
    private static BigInteger ParseSubIdentifier(ReadOnlySpan`1& oidValue);
    private static int AtoI(char c);
    private static int EncodeSubIdentifier(Span`1<byte> dest, BigInteger& subIdentifier);
    public void PushSequence();
    public void PushSequence(Asn1Tag tag);
    public void PopSequence();
    public void PopSequence(Asn1Tag tag);
    private void PushSequenceCore(Asn1Tag tag);
    private void PopSequenceCore(Asn1Tag tag);
    public void PushSetOf();
    public void PushSetOf(Asn1Tag tag);
    public void PopSetOf();
    public void PopSetOf(Asn1Tag tag);
    private void PushSetOfCore(Asn1Tag tag);
    private void PopSetOfCore(Asn1Tag tag);
    public void WriteCharacterString(UniversalTagNumber encodingType, string str);
    public void WriteCharacterString(UniversalTagNumber encodingType, ReadOnlySpan`1<char> str);
    public void WriteCharacterString(Asn1Tag tag, UniversalTagNumber encodingType, string str);
    public void WriteCharacterString(Asn1Tag tag, UniversalTagNumber encodingType, ReadOnlySpan`1<char> str);
    private void WriteCharacterStringCore(Asn1Tag tag, Encoding encoding, ReadOnlySpan`1<char> str);
    private void WriteConstructedCerCharacterString(Asn1Tag tag, Encoding encoding, ReadOnlySpan`1<char> str, int size);
    public void WriteUtcTime(DateTimeOffset value);
    public void WriteUtcTime(Asn1Tag tag, DateTimeOffset value);
    public void WriteUtcTime(DateTimeOffset value, int twoDigitYearMax);
    public void WriteUtcTime(Asn1Tag tag, DateTimeOffset value, int twoDigitYearMax);
    private void WriteUtcTimeCore(Asn1Tag tag, DateTimeOffset value);
}
internal class System.Security.Cryptography.Asn1.AttributeAsn : ValueType {
    internal Oid AttrType;
    internal ReadOnlyMemory`1[] AttrValues;
    public AttributeAsn(AsnEncodedData attribute);
    internal void Encode(AsnWriter writer);
    internal void Encode(AsnWriter writer, Asn1Tag tag);
    internal static AttributeAsn Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static AttributeAsn Decode(Asn1Tag expectedTag, ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static void Decode(AsnReader reader, AttributeAsn& decoded);
    internal static void Decode(AsnReader reader, Asn1Tag expectedTag, AttributeAsn& decoded);
}
internal class System.Security.Cryptography.Asn1.BMPEncoding : SpanBasedEncoding {
    protected virtual int GetBytes(ReadOnlySpan`1<char> chars, Span`1<byte> bytes, bool write);
    protected virtual int GetChars(ReadOnlySpan`1<byte> bytes, Span`1<char> chars, bool write);
    public virtual int GetMaxByteCount(int charCount);
    public virtual int GetMaxCharCount(int byteCount);
}
internal class System.Security.Cryptography.Asn1.DirectoryStringAsn : ValueType {
    internal string TeletexString;
    internal string PrintableString;
    internal Nullable`1<ReadOnlyMemory`1<byte>> UniversalString;
    internal string Utf8String;
    internal string BmpString;
    internal void Encode(AsnWriter writer);
    internal static DirectoryStringAsn Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static void Decode(AsnReader reader, DirectoryStringAsn& decoded);
}
internal class System.Security.Cryptography.Asn1.EdiPartyNameAsn : ValueType {
    internal Nullable`1<DirectoryStringAsn> NameAssigner;
    internal DirectoryStringAsn PartyName;
    internal void Encode(AsnWriter writer);
    internal void Encode(AsnWriter writer, Asn1Tag tag);
    internal static EdiPartyNameAsn Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static EdiPartyNameAsn Decode(Asn1Tag expectedTag, ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static void Decode(AsnReader reader, EdiPartyNameAsn& decoded);
    internal static void Decode(AsnReader reader, Asn1Tag expectedTag, EdiPartyNameAsn& decoded);
}
internal class System.Security.Cryptography.Asn1.EncryptedPrivateKeyInfoAsn : ValueType {
    internal AlgorithmIdentifierAsn EncryptionAlgorithm;
    internal ReadOnlyMemory`1<byte> EncryptedData;
    internal void Encode(AsnWriter writer);
    internal void Encode(AsnWriter writer, Asn1Tag tag);
    internal static EncryptedPrivateKeyInfoAsn Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static EncryptedPrivateKeyInfoAsn Decode(Asn1Tag expectedTag, ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static void Decode(AsnReader reader, EncryptedPrivateKeyInfoAsn& decoded);
    internal static void Decode(AsnReader reader, Asn1Tag expectedTag, EncryptedPrivateKeyInfoAsn& decoded);
}
internal class System.Security.Cryptography.Asn1.GeneralNameAsn : ValueType {
    internal Nullable`1<OtherNameAsn> OtherName;
    internal string Rfc822Name;
    internal string DnsName;
    internal Nullable`1<ReadOnlyMemory`1<byte>> X400Address;
    internal Nullable`1<ReadOnlyMemory`1<byte>> DirectoryName;
    internal Nullable`1<EdiPartyNameAsn> EdiPartyName;
    internal string Uri;
    internal Nullable`1<ReadOnlyMemory`1<byte>> IPAddress;
    internal string RegisteredId;
    internal void Encode(AsnWriter writer);
    internal static GeneralNameAsn Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static void Decode(AsnReader reader, GeneralNameAsn& decoded);
}
internal class System.Security.Cryptography.Asn1.IA5Encoding : RestrictedAsciiStringEncoding {
}
internal class System.Security.Cryptography.Asn1.NumericStringEncoding : RestrictedAsciiStringEncoding {
}
internal class System.Security.Cryptography.Asn1.OaepParamsAsn : ValueType {
    private static Byte[] s_defaultHashFunc;
    private static Byte[] s_defaultMaskGenFunc;
    private static Byte[] s_defaultPSourceFunc;
    internal AlgorithmIdentifierAsn HashFunc;
    internal AlgorithmIdentifierAsn MaskGenFunc;
    internal AlgorithmIdentifierAsn PSourceFunc;
    private static OaepParamsAsn();
    internal void Encode(AsnWriter writer);
    internal void Encode(AsnWriter writer, Asn1Tag tag);
    internal static OaepParamsAsn Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static OaepParamsAsn Decode(Asn1Tag expectedTag, ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static void Decode(AsnReader reader, OaepParamsAsn& decoded);
    internal static void Decode(AsnReader reader, Asn1Tag expectedTag, OaepParamsAsn& decoded);
}
internal class System.Security.Cryptography.Asn1.OtherNameAsn : ValueType {
    internal string TypeId;
    internal ReadOnlyMemory`1<byte> Value;
    internal void Encode(AsnWriter writer);
    internal void Encode(AsnWriter writer, Asn1Tag tag);
    internal static OtherNameAsn Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static OtherNameAsn Decode(Asn1Tag expectedTag, ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static void Decode(AsnReader reader, OtherNameAsn& decoded);
    internal static void Decode(AsnReader reader, Asn1Tag expectedTag, OtherNameAsn& decoded);
}
internal class System.Security.Cryptography.Asn1.PBEParameter : ValueType {
    internal ReadOnlyMemory`1<byte> Salt;
    internal int IterationCount;
    internal void Encode(AsnWriter writer);
    internal void Encode(AsnWriter writer, Asn1Tag tag);
    internal static PBEParameter Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static PBEParameter Decode(Asn1Tag expectedTag, ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static void Decode(AsnReader reader, PBEParameter& decoded);
    internal static void Decode(AsnReader reader, Asn1Tag expectedTag, PBEParameter& decoded);
}
internal class System.Security.Cryptography.Asn1.PBES2Params : ValueType {
    internal AlgorithmIdentifierAsn KeyDerivationFunc;
    internal AlgorithmIdentifierAsn EncryptionScheme;
    internal void Encode(AsnWriter writer);
    internal void Encode(AsnWriter writer, Asn1Tag tag);
    internal static PBES2Params Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static PBES2Params Decode(Asn1Tag expectedTag, ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static void Decode(AsnReader reader, PBES2Params& decoded);
    internal static void Decode(AsnReader reader, Asn1Tag expectedTag, PBES2Params& decoded);
}
internal class System.Security.Cryptography.Asn1.Pbkdf2Params : ValueType {
    private static Byte[] s_defaultPrf;
    internal Pbkdf2SaltChoice Salt;
    internal int IterationCount;
    internal Nullable`1<byte> KeyLength;
    internal AlgorithmIdentifierAsn Prf;
    private static Pbkdf2Params();
    internal void Encode(AsnWriter writer);
    internal void Encode(AsnWriter writer, Asn1Tag tag);
    internal static Pbkdf2Params Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static Pbkdf2Params Decode(Asn1Tag expectedTag, ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static void Decode(AsnReader reader, Pbkdf2Params& decoded);
    internal static void Decode(AsnReader reader, Asn1Tag expectedTag, Pbkdf2Params& decoded);
}
internal class System.Security.Cryptography.Asn1.Pbkdf2SaltChoice : ValueType {
    internal Nullable`1<ReadOnlyMemory`1<byte>> Specified;
    internal Nullable`1<AlgorithmIdentifierAsn> OtherSource;
    internal void Encode(AsnWriter writer);
    internal static Pbkdf2SaltChoice Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static void Decode(AsnReader reader, Pbkdf2SaltChoice& decoded);
}
internal class System.Security.Cryptography.Asn1.PrintableStringEncoding : RestrictedAsciiStringEncoding {
}
internal class System.Security.Cryptography.Asn1.PrivateKeyInfoAsn : ValueType {
    internal byte Version;
    internal AlgorithmIdentifierAsn PrivateKeyAlgorithm;
    internal ReadOnlyMemory`1<byte> PrivateKey;
    internal AttributeAsn[] Attributes;
    internal void Encode(AsnWriter writer);
    internal void Encode(AsnWriter writer, Asn1Tag tag);
    internal static PrivateKeyInfoAsn Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static PrivateKeyInfoAsn Decode(Asn1Tag expectedTag, ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static void Decode(AsnReader reader, PrivateKeyInfoAsn& decoded);
    internal static void Decode(AsnReader reader, Asn1Tag expectedTag, PrivateKeyInfoAsn& decoded);
}
internal class System.Security.Cryptography.Asn1.PssParamsAsn : ValueType {
    private static Byte[] s_defaultHashAlgorithm;
    private static Byte[] s_defaultMaskGenAlgorithm;
    private static Byte[] s_defaultSaltLength;
    private static Byte[] s_defaultTrailerField;
    internal AlgorithmIdentifierAsn HashAlgorithm;
    internal AlgorithmIdentifierAsn MaskGenAlgorithm;
    internal int SaltLength;
    internal int TrailerField;
    private static PssParamsAsn();
    internal void Encode(AsnWriter writer);
    internal void Encode(AsnWriter writer, Asn1Tag tag);
    internal static PssParamsAsn Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static PssParamsAsn Decode(Asn1Tag expectedTag, ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static void Decode(AsnReader reader, PssParamsAsn& decoded);
    internal static void Decode(AsnReader reader, Asn1Tag expectedTag, PssParamsAsn& decoded);
}
internal class System.Security.Cryptography.Asn1.Rc2CbcParameters : ValueType {
    internal int Rc2Version;
    internal ReadOnlyMemory`1<byte> Iv;
    private static Byte[] s_rc2EkbEncoding;
    internal Rc2CbcParameters(ReadOnlyMemory`1<byte> iv, int keySize);
    private static Rc2CbcParameters();
    internal void Encode(AsnWriter writer);
    internal void Encode(AsnWriter writer, Asn1Tag tag);
    internal static Rc2CbcParameters Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static Rc2CbcParameters Decode(Asn1Tag expectedTag, ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static void Decode(AsnReader reader, Rc2CbcParameters& decoded);
    internal static void Decode(AsnReader reader, Asn1Tag expectedTag, Rc2CbcParameters& decoded);
    internal int GetEffectiveKeyBits();
}
internal abstract class System.Security.Cryptography.Asn1.RestrictedAsciiStringEncoding : SpanBasedEncoding {
    private Boolean[] _isAllowed;
    protected RestrictedAsciiStringEncoding(byte minCharAllowed, byte maxCharAllowed);
    protected RestrictedAsciiStringEncoding(IEnumerable`1<char> allowedChars);
    public virtual int GetMaxByteCount(int charCount);
    public virtual int GetMaxCharCount(int byteCount);
    protected virtual int GetBytes(ReadOnlySpan`1<char> chars, Span`1<byte> bytes, bool write);
    protected virtual int GetChars(ReadOnlySpan`1<byte> bytes, Span`1<char> chars, bool write);
}
internal class System.Security.Cryptography.Asn1.SetOfValueComparer : object {
    [CompilerGeneratedAttribute]
private static SetOfValueComparer <Instance>k__BackingField;
    internal static SetOfValueComparer Instance { get; }
    private static SetOfValueComparer();
    [CompilerGeneratedAttribute]
internal static SetOfValueComparer get_Instance();
    public sealed virtual int Compare(ReadOnlyMemory`1<byte> x, ReadOnlyMemory`1<byte> y);
}
internal abstract class System.Security.Cryptography.Asn1.SpanBasedEncoding : Encoding {
    protected abstract virtual int GetBytes(ReadOnlySpan`1<char> chars, Span`1<byte> bytes, bool write);
    protected abstract virtual int GetChars(ReadOnlySpan`1<byte> bytes, Span`1<char> chars, bool write);
    public virtual int GetByteCount(Char[] chars, int index, int count);
    public virtual int GetByteCount(Char* chars, int count);
    public virtual int GetByteCount(string s);
    public virtual int GetByteCount(ReadOnlySpan`1<char> chars);
    public virtual int GetBytes(Char[] chars, int charIndex, int charCount, Byte[] bytes, int byteIndex);
    public virtual int GetBytes(Char* chars, int charCount, Byte* bytes, int byteCount);
    public virtual int GetCharCount(Byte[] bytes, int index, int count);
    public virtual int GetCharCount(Byte* bytes, int count);
    public virtual int GetCharCount(ReadOnlySpan`1<byte> bytes);
    public virtual int GetChars(Byte[] bytes, int byteIndex, int byteCount, Char[] chars, int charIndex);
    public virtual int GetChars(Byte* bytes, int byteCount, Char* chars, int charCount);
}
internal class System.Security.Cryptography.Asn1.SubjectPublicKeyInfoAsn : ValueType {
    internal AlgorithmIdentifierAsn Algorithm;
    internal ReadOnlyMemory`1<byte> SubjectPublicKey;
    internal void Encode(AsnWriter writer);
    internal void Encode(AsnWriter writer, Asn1Tag tag);
    internal static SubjectPublicKeyInfoAsn Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static SubjectPublicKeyInfoAsn Decode(Asn1Tag expectedTag, ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static void Decode(AsnReader reader, SubjectPublicKeyInfoAsn& decoded);
    internal static void Decode(AsnReader reader, Asn1Tag expectedTag, SubjectPublicKeyInfoAsn& decoded);
}
internal class System.Security.Cryptography.Asn1.T61Encoding : Encoding {
    private static Encoding s_utf8Encoding;
    private static Encoding s_latin1Encoding;
    private static T61Encoding();
    public virtual int GetByteCount(Char[] chars, int index, int count);
    public virtual int GetByteCount(Char* chars, int count);
    public virtual int GetByteCount(string s);
    public virtual int GetByteCount(ReadOnlySpan`1<char> chars);
    public virtual int GetBytes(Char[] chars, int charIndex, int charCount, Byte[] bytes, int byteIndex);
    public virtual int GetBytes(Char* chars, int charCount, Byte* bytes, int byteCount);
    public virtual int GetCharCount(Byte[] bytes, int index, int count);
    public virtual int GetCharCount(Byte* bytes, int count);
    public virtual int GetCharCount(ReadOnlySpan`1<byte> bytes);
    public virtual int GetChars(Byte[] bytes, int byteIndex, int byteCount, Char[] chars, int charIndex);
    public virtual int GetChars(Byte* bytes, int byteCount, Char* chars, int charCount);
    public virtual int GetMaxByteCount(int charCount);
    public virtual int GetMaxCharCount(int byteCount);
}
internal enum System.Security.Cryptography.Asn1.TagClass : Enum {
    public byte value__;
    public static TagClass Universal;
    public static TagClass Application;
    public static TagClass ContextSpecific;
    public static TagClass Private;
}
internal enum System.Security.Cryptography.Asn1.UniversalTagNumber : Enum {
    public int value__;
    public static UniversalTagNumber EndOfContents;
    public static UniversalTagNumber Boolean;
    public static UniversalTagNumber Integer;
    public static UniversalTagNumber BitString;
    public static UniversalTagNumber OctetString;
    public static UniversalTagNumber Null;
    public static UniversalTagNumber ObjectIdentifier;
    public static UniversalTagNumber ObjectDescriptor;
    public static UniversalTagNumber External;
    public static UniversalTagNumber InstanceOf;
    public static UniversalTagNumber Real;
    public static UniversalTagNumber Enumerated;
    public static UniversalTagNumber Embedded;
    public static UniversalTagNumber UTF8String;
    public static UniversalTagNumber RelativeObjectIdentifier;
    public static UniversalTagNumber Time;
    public static UniversalTagNumber Sequence;
    public static UniversalTagNumber SequenceOf;
    public static UniversalTagNumber Set;
    public static UniversalTagNumber SetOf;
    public static UniversalTagNumber NumericString;
    public static UniversalTagNumber PrintableString;
    public static UniversalTagNumber TeletexString;
    public static UniversalTagNumber T61String;
    public static UniversalTagNumber VideotexString;
    public static UniversalTagNumber IA5String;
    public static UniversalTagNumber UtcTime;
    public static UniversalTagNumber GeneralizedTime;
    public static UniversalTagNumber GraphicString;
    public static UniversalTagNumber VisibleString;
    public static UniversalTagNumber ISO646String;
    public static UniversalTagNumber GeneralString;
    public static UniversalTagNumber UniversalString;
    public static UniversalTagNumber UnrestrictedCharacterString;
    public static UniversalTagNumber BMPString;
    public static UniversalTagNumber Date;
    public static UniversalTagNumber TimeOfDay;
    public static UniversalTagNumber DateTime;
    public static UniversalTagNumber Duration;
    public static UniversalTagNumber ObjectIdentifierIRI;
    public static UniversalTagNumber RelativeObjectIdentifierIRI;
}
internal class System.Security.Cryptography.Asn1.VisibleStringEncoding : RestrictedAsciiStringEncoding {
}
internal class System.Security.Cryptography.Asn1.X509ExtensionAsn : ValueType {
    private static Byte[] s_defaultCritical;
    internal Oid ExtnId;
    internal bool Critical;
    internal ReadOnlyMemory`1<byte> ExtnValue;
    public X509ExtensionAsn(X509Extension extension);
    private static X509ExtensionAsn();
    internal void Encode(AsnWriter writer);
    internal void Encode(AsnWriter writer, Asn1Tag tag);
    internal static X509ExtensionAsn Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static X509ExtensionAsn Decode(Asn1Tag expectedTag, ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static void Decode(AsnReader reader, X509ExtensionAsn& decoded);
    internal static void Decode(AsnReader reader, Asn1Tag expectedTag, X509ExtensionAsn& decoded);
}
public class System.Security.Cryptography.CryptographicAttributeObject : object {
    [CompilerGeneratedAttribute]
private AsnEncodedDataCollection <Values>k__BackingField;
    private Oid _oid;
    public Oid Oid { get; }
    public AsnEncodedDataCollection Values { get; }
    public CryptographicAttributeObject(Oid oid);
    public CryptographicAttributeObject(Oid oid, AsnEncodedDataCollection values);
    public Oid get_Oid();
    [CompilerGeneratedAttribute]
public AsnEncodedDataCollection get_Values();
}
[DefaultMemberAttribute("Item")]
public class System.Security.Cryptography.CryptographicAttributeObjectCollection : object {
    private List`1<CryptographicAttributeObject> _list;
    public CryptographicAttributeObject Item { get; }
    public int Count { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public CryptographicAttributeObjectCollection(CryptographicAttributeObject attribute);
    public int Add(AsnEncodedData asnEncodedData);
    public int Add(CryptographicAttributeObject attribute);
    internal void AddWithoutMerge(CryptographicAttributeObject attribute);
    public void Remove(CryptographicAttributeObject attribute);
    public CryptographicAttributeObject get_Item(int index);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    public CryptographicAttributeObjectEnumerator GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public void CopyTo(CryptographicAttributeObject[] array, int index);
}
public class System.Security.Cryptography.CryptographicAttributeObjectEnumerator : object {
    private CryptographicAttributeObjectCollection _attributes;
    private int _current;
    public CryptographicAttributeObject Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    internal CryptographicAttributeObjectEnumerator(CryptographicAttributeObjectCollection attributes);
    public CryptographicAttributeObject get_Current();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
}
internal static class System.Security.Cryptography.CryptoPool : object {
    internal static int ClearAll;
    internal static Byte[] Rent(int minimumLength);
    internal static void Return(Byte[] array, int clearSize);
}
internal static class System.Security.Cryptography.KeyFormatHelper : object {
    internal static void ReadSubjectPublicKeyInfo(String[] validOids, ReadOnlySpan`1<byte> source, KeyReader`1<TRet> keyReader, Int32& bytesRead, TRet& ret);
    internal static ReadOnlyMemory`1<byte> ReadSubjectPublicKeyInfo(String[] validOids, ReadOnlyMemory`1<byte> source, Int32& bytesRead);
    private static void ReadSubjectPublicKeyInfo(String[] validOids, ReadOnlyMemory`1<byte> source, KeyReader`1<TRet> keyReader, Int32& bytesRead, TRet& ret);
    internal static void ReadPkcs8(String[] validOids, ReadOnlySpan`1<byte> source, KeyReader`1<TRet> keyReader, Int32& bytesRead, TRet& ret);
    internal static ReadOnlyMemory`1<byte> ReadPkcs8(String[] validOids, ReadOnlyMemory`1<byte> source, Int32& bytesRead);
    private static void ReadPkcs8(String[] validOids, ReadOnlyMemory`1<byte> source, KeyReader`1<TRet> keyReader, Int32& bytesRead, TRet& ret);
    internal static void ReadEncryptedPkcs8(String[] validOids, ReadOnlySpan`1<byte> source, ReadOnlySpan`1<char> password, KeyReader`1<TRet> keyReader, Int32& bytesRead, TRet& ret);
    internal static void ReadEncryptedPkcs8(String[] validOids, ReadOnlySpan`1<byte> source, ReadOnlySpan`1<byte> passwordBytes, KeyReader`1<TRet> keyReader, Int32& bytesRead, TRet& ret);
    private static void ReadEncryptedPkcs8(String[] validOids, ReadOnlyMemory`1<byte> source, ReadOnlySpan`1<char> password, KeyReader`1<TRet> keyReader, Int32& bytesRead, TRet& ret);
    private static void ReadEncryptedPkcs8(String[] validOids, ReadOnlyMemory`1<byte> source, ReadOnlySpan`1<byte> passwordBytes, KeyReader`1<TRet> keyReader, Int32& bytesRead, TRet& ret);
    private static void ReadEncryptedPkcs8(String[] validOids, ReadOnlyMemory`1<byte> source, ReadOnlySpan`1<char> password, ReadOnlySpan`1<byte> passwordBytes, KeyReader`1<TRet> keyReader, Int32& bytesRead, TRet& ret);
    internal static AsnWriter WritePkcs8(AsnWriter algorithmIdentifierWriter, AsnWriter privateKeyWriter);
    internal static AsnWriter WriteEncryptedPkcs8(ReadOnlySpan`1<char> password, AsnWriter pkcs8Writer, PbeParameters pbeParameters);
    internal static AsnWriter WriteEncryptedPkcs8(ReadOnlySpan`1<byte> passwordBytes, AsnWriter pkcs8Writer, PbeParameters pbeParameters);
    private static AsnWriter WriteEncryptedPkcs8(ReadOnlySpan`1<char> password, ReadOnlySpan`1<byte> passwordBytes, AsnWriter pkcs8Writer, PbeParameters pbeParameters);
    internal static ArraySegment`1<byte> DecryptPkcs8(ReadOnlySpan`1<char> inputPassword, ReadOnlyMemory`1<byte> source, Int32& bytesRead);
    internal static ArraySegment`1<byte> DecryptPkcs8(ReadOnlySpan`1<byte> inputPasswordBytes, ReadOnlyMemory`1<byte> source, Int32& bytesRead);
    private static ArraySegment`1<byte> DecryptPkcs8(ReadOnlySpan`1<char> inputPassword, ReadOnlySpan`1<byte> inputPasswordBytes, ReadOnlyMemory`1<byte> source, Int32& bytesRead);
    internal static AsnWriter ReencryptPkcs8(ReadOnlySpan`1<char> inputPassword, ReadOnlyMemory`1<byte> current, ReadOnlySpan`1<char> newPassword, PbeParameters pbeParameters);
    internal static AsnWriter ReencryptPkcs8(ReadOnlySpan`1<char> inputPassword, ReadOnlyMemory`1<byte> current, ReadOnlySpan`1<byte> newPasswordBytes, PbeParameters pbeParameters);
}
internal static class System.Security.Cryptography.Oids : object {
    internal static string Rc2Cbc;
    internal static string Rc4;
    internal static string TripleDesCbc;
    internal static string DesCbc;
    internal static string Aes128Cbc;
    internal static string Aes192Cbc;
    internal static string Aes256Cbc;
    internal static string Dsa;
    internal static string Rsa;
    internal static string RsaOaep;
    internal static string RsaPss;
    internal static string RsaPkcs1Md5;
    internal static string RsaPkcs1Sha1;
    internal static string RsaPkcs1Sha256;
    internal static string RsaPkcs1Sha384;
    internal static string RsaPkcs1Sha512;
    internal static string Esdh;
    internal static string EcDiffieHellman;
    internal static string DiffieHellman;
    internal static string DiffieHellmanPkcs3;
    internal static string SigningTime;
    internal static string ContentType;
    internal static string DocumentDescription;
    internal static string MessageDigest;
    internal static string CounterSigner;
    internal static string SigningCertificate;
    internal static string SigningCertificateV2;
    internal static string DocumentName;
    internal static string LocalKeyId;
    internal static string EnrollCertTypeExtension;
    internal static string UserPrincipalName;
    internal static string CertificateTemplate;
    internal static string ApplicationCertPolicies;
    internal static string AuthorityInformationAccess;
    internal static string OcspEndpoint;
    internal static string CertificateAuthorityIssuers;
    internal static string Pkcs9ExtensionRequest;
    internal static string CmsRc2Wrap;
    internal static string Cms3DesWrap;
    internal static string Pkcs7Data;
    internal static string Pkcs7Signed;
    internal static string Pkcs7Enveloped;
    internal static string Pkcs7SignedEnveloped;
    internal static string Pkcs7Hashed;
    internal static string Pkcs7Encrypted;
    internal static string Md5;
    internal static string Sha1;
    internal static string Sha256;
    internal static string Sha384;
    internal static string Sha512;
    internal static string DsaWithSha1;
    internal static string DsaWithSha256;
    internal static string DsaWithSha384;
    internal static string DsaWithSha512;
    internal static string EcPublicKey;
    internal static string ECDsaWithSha1;
    internal static string ECDsaWithSha256;
    internal static string ECDsaWithSha384;
    internal static string ECDsaWithSha512;
    internal static string Mgf1;
    internal static string PSpecified;
    internal static string NoSignature;
    internal static string CommonName;
    internal static string Organization;
    internal static string OrganizationalUnit;
    internal static string EmailAddress;
    internal static string BasicConstraints;
    internal static string SubjectKeyIdentifier;
    internal static string KeyUsage;
    internal static string SubjectAltName;
    internal static string IssuerAltName;
    internal static string BasicConstraints2;
    internal static string CrlDistributionPoints;
    internal static string CertPolicies;
    internal static string AnyCertPolicy;
    internal static string CertPolicyMappings;
    internal static string CertPolicyConstraints;
    internal static string EnhancedKeyUsage;
    internal static string InhibitAnyPolicyExtension;
    internal static string TstInfo;
    internal static string TimeStampingPurpose;
    private static string Pkcs12Prefix;
    private static string Pkcs12PbePrefix;
    internal static string Pkcs12PbeWithShaAnd3Key3Des;
    internal static string Pkcs12PbeWithShaAnd2Key3Des;
    internal static string Pkcs12PbeWithShaAnd128BitRC2;
    internal static string Pkcs12PbeWithShaAnd40BitRC2;
    private static string Pkcs12BagTypesPrefix;
    internal static string Pkcs12KeyBag;
    internal static string Pkcs12ShroudedKeyBag;
    internal static string Pkcs12CertBag;
    internal static string Pkcs12CrlBag;
    internal static string Pkcs12SecretBag;
    internal static string Pkcs12SafeContentsBag;
    internal static string Pkcs12X509CertBagType;
    internal static string Pkcs12SdsiCertBagType;
    private static string Pkcs5Prefix;
    internal static string PbeWithMD5AndDESCBC;
    internal static string PbeWithMD5AndRC2CBC;
    internal static string PbeWithSha1AndDESCBC;
    internal static string PbeWithSha1AndRC2CBC;
    internal static string Pbkdf2;
    internal static string PasswordBasedEncryptionScheme2;
    private static string RsaDsiDigestAlgorithmPrefix;
    internal static string HmacWithSha1;
    internal static string HmacWithSha256;
    internal static string HmacWithSha384;
    internal static string HmacWithSha512;
    internal static string secp256r1;
    internal static string secp384r1;
    internal static string secp521r1;
}
internal static class System.Security.Cryptography.PasswordBasedEncryption : object {
    internal static int IterationLimit;
    private static CryptographicException AlgorithmKdfRequiresChars(string algId);
    internal static void ValidatePbeParameters(PbeParameters pbeParameters, ReadOnlySpan`1<char> password, ReadOnlySpan`1<byte> passwordBytes);
    internal static int Decrypt(AlgorithmIdentifierAsn& algorithmIdentifier, ReadOnlySpan`1<char> password, ReadOnlySpan`1<byte> passwordBytes, ReadOnlySpan`1<byte> encryptedData, Span`1<byte> destination);
    internal static void InitiateEncryption(PbeParameters pbeParameters, SymmetricAlgorithm& cipher, String& hmacOid, String& encryptionAlgorithmOid, Boolean& isPkcs12);
    internal static int Encrypt(ReadOnlySpan`1<char> password, ReadOnlySpan`1<byte> passwordBytes, SymmetricAlgorithm cipher, bool isPkcs12, ReadOnlySpan`1<byte> source, PbeParameters pbeParameters, ReadOnlySpan`1<byte> salt, Byte[] destination, Span`1<byte> ivDest);
    private static int Pbes2Decrypt(Nullable`1<ReadOnlyMemory`1<byte>> algorithmParameters, ReadOnlySpan`1<char> password, ReadOnlySpan`1<byte> passwordBytes, ReadOnlySpan`1<byte> encryptedData, Span`1<byte> destination);
    private static int Pbes2Decrypt(Nullable`1<ReadOnlyMemory`1<byte>> algorithmParameters, ReadOnlySpan`1<byte> password, ReadOnlySpan`1<byte> encryptedData, Span`1<byte> destination);
    private static SymmetricAlgorithm OpenCipher(AlgorithmIdentifierAsn encryptionScheme, Nullable`1<byte> requestedKeyLength, Span`1& iv);
    private static void ReadIvParameter(Nullable`1<ReadOnlyMemory`1<byte>> encryptionSchemeParameters, int length, Span`1& iv);
    private static Rfc2898DeriveBytes OpenPbkdf2(ReadOnlySpan`1<byte> password, Nullable`1<ReadOnlyMemory`1<byte>> parameters, Nullable`1& requestedKeyLength);
    private static int Pbes1Decrypt(Nullable`1<ReadOnlyMemory`1<byte>> algorithmParameters, ReadOnlySpan`1<byte> password, IncrementalHash hasher, SymmetricAlgorithm cipher, ReadOnlySpan`1<byte> encryptedData, Span`1<byte> destination);
    private static int Pkcs12PbeDecrypt(AlgorithmIdentifierAsn algorithmIdentifier, ReadOnlySpan`1<char> password, HashAlgorithmName hashAlgorithm, SymmetricAlgorithm cipher, ReadOnlySpan`1<byte> encryptedData, Span`1<byte> destination);
    private static int Decrypt(SymmetricAlgorithm cipher, ReadOnlySpan`1<byte> key, ReadOnlySpan`1<byte> iv, ReadOnlySpan`1<byte> encryptedData, Span`1<byte> destination);
    private static void Pbkdf1(IncrementalHash hasher, ReadOnlySpan`1<byte> password, ReadOnlySpan`1<byte> salt, int iterationCount, Span`1<byte> dk);
    internal static void WritePbeAlgorithmIdentifier(AsnWriter writer, bool isPkcs12, string encryptionAlgorithmOid, Span`1<byte> salt, int iterationCount, string hmacOid, Span`1<byte> iv);
    internal static int NormalizeIterationCount(UInt32 iterationCount);
    internal static int NormalizeIterationCount(int iterationCount);
}
public class System.Security.Cryptography.Pkcs.AlgorithmIdentifier : object {
    [CompilerGeneratedAttribute]
private Oid <Oid>k__BackingField;
    [CompilerGeneratedAttribute]
private int <KeyLength>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <Parameters>k__BackingField;
    public Oid Oid { get; public set; }
    public int KeyLength { get; public set; }
    public Byte[] Parameters { get; public set; }
    public AlgorithmIdentifier(Oid oid);
    public AlgorithmIdentifier(Oid oid, int keyLength);
    [CompilerGeneratedAttribute]
public Oid get_Oid();
    [CompilerGeneratedAttribute]
public void set_Oid(Oid value);
    [CompilerGeneratedAttribute]
public int get_KeyLength();
    [CompilerGeneratedAttribute]
public void set_KeyLength(int value);
    [CompilerGeneratedAttribute]
public Byte[] get_Parameters();
    [CompilerGeneratedAttribute]
public void set_Parameters(Byte[] value);
}
internal class System.Security.Cryptography.Pkcs.Asn1.CadesIssuerSerial : ValueType {
    internal GeneralNameAsn[] Issuer;
    internal ReadOnlyMemory`1<byte> SerialNumber;
    internal void Encode(AsnWriter writer);
    internal void Encode(AsnWriter writer, Asn1Tag tag);
    internal static CadesIssuerSerial Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static CadesIssuerSerial Decode(Asn1Tag expectedTag, ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static void Decode(AsnReader reader, CadesIssuerSerial& decoded);
    internal static void Decode(AsnReader reader, Asn1Tag expectedTag, CadesIssuerSerial& decoded);
}
internal class System.Security.Cryptography.Pkcs.Asn1.CertBagAsn : ValueType {
    internal string CertId;
    internal ReadOnlyMemory`1<byte> CertValue;
    internal void Encode(AsnWriter writer);
    internal void Encode(AsnWriter writer, Asn1Tag tag);
    internal static CertBagAsn Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static CertBagAsn Decode(Asn1Tag expectedTag, ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static void Decode(AsnReader reader, CertBagAsn& decoded);
    internal static void Decode(AsnReader reader, Asn1Tag expectedTag, CertBagAsn& decoded);
}
internal class System.Security.Cryptography.Pkcs.Asn1.CertificateChoiceAsn : ValueType {
    internal Nullable`1<ReadOnlyMemory`1<byte>> Certificate;
    internal void Encode(AsnWriter writer);
    internal static CertificateChoiceAsn Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static void Decode(AsnReader reader, CertificateChoiceAsn& decoded);
}
internal class System.Security.Cryptography.Pkcs.Asn1.ContentInfoAsn : ValueType {
    internal string ContentType;
    internal ReadOnlyMemory`1<byte> Content;
    internal void Encode(AsnWriter writer);
    internal void Encode(AsnWriter writer, Asn1Tag tag);
    internal static ContentInfoAsn Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static ContentInfoAsn Decode(Asn1Tag expectedTag, ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static void Decode(AsnReader reader, ContentInfoAsn& decoded);
    internal static void Decode(AsnReader reader, Asn1Tag expectedTag, ContentInfoAsn& decoded);
}
internal class System.Security.Cryptography.Pkcs.Asn1.DigestInfoAsn : ValueType {
    internal AlgorithmIdentifierAsn DigestAlgorithm;
    internal ReadOnlyMemory`1<byte> Digest;
    internal void Encode(AsnWriter writer);
    internal void Encode(AsnWriter writer, Asn1Tag tag);
    internal static DigestInfoAsn Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static DigestInfoAsn Decode(Asn1Tag expectedTag, ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static void Decode(AsnReader reader, DigestInfoAsn& decoded);
    internal static void Decode(AsnReader reader, Asn1Tag expectedTag, DigestInfoAsn& decoded);
}
internal class System.Security.Cryptography.Pkcs.Asn1.EncapsulatedContentInfoAsn : ValueType {
    internal string ContentType;
    internal Nullable`1<ReadOnlyMemory`1<byte>> Content;
    internal void Encode(AsnWriter writer);
    internal void Encode(AsnWriter writer, Asn1Tag tag);
    internal static EncapsulatedContentInfoAsn Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static EncapsulatedContentInfoAsn Decode(Asn1Tag expectedTag, ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static void Decode(AsnReader reader, EncapsulatedContentInfoAsn& decoded);
    internal static void Decode(AsnReader reader, Asn1Tag expectedTag, EncapsulatedContentInfoAsn& decoded);
}
internal class System.Security.Cryptography.Pkcs.Asn1.EncryptedContentInfoAsn : ValueType {
    internal string ContentType;
    internal AlgorithmIdentifierAsn ContentEncryptionAlgorithm;
    internal Nullable`1<ReadOnlyMemory`1<byte>> EncryptedContent;
    internal void Encode(AsnWriter writer);
    internal void Encode(AsnWriter writer, Asn1Tag tag);
    internal static EncryptedContentInfoAsn Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static EncryptedContentInfoAsn Decode(Asn1Tag expectedTag, ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static void Decode(AsnReader reader, EncryptedContentInfoAsn& decoded);
    internal static void Decode(AsnReader reader, Asn1Tag expectedTag, EncryptedContentInfoAsn& decoded);
}
internal class System.Security.Cryptography.Pkcs.Asn1.EncryptedDataAsn : ValueType {
    internal int Version;
    internal EncryptedContentInfoAsn EncryptedContentInfo;
    internal AttributeAsn[] UnprotectedAttributes;
    internal void Encode(AsnWriter writer);
    internal void Encode(AsnWriter writer, Asn1Tag tag);
    internal static EncryptedDataAsn Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static EncryptedDataAsn Decode(Asn1Tag expectedTag, ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static void Decode(AsnReader reader, EncryptedDataAsn& decoded);
    internal static void Decode(AsnReader reader, Asn1Tag expectedTag, EncryptedDataAsn& decoded);
}
internal class System.Security.Cryptography.Pkcs.Asn1.EnvelopedDataAsn : ValueType {
    internal int Version;
    internal Nullable`1<OriginatorInfoAsn> OriginatorInfo;
    internal RecipientInfoAsn[] RecipientInfos;
    internal EncryptedContentInfoAsn EncryptedContentInfo;
    internal AttributeAsn[] UnprotectedAttributes;
    internal void Encode(AsnWriter writer);
    internal void Encode(AsnWriter writer, Asn1Tag tag);
    internal static EnvelopedDataAsn Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static EnvelopedDataAsn Decode(Asn1Tag expectedTag, ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static void Decode(AsnReader reader, EnvelopedDataAsn& decoded);
    internal static void Decode(AsnReader reader, Asn1Tag expectedTag, EnvelopedDataAsn& decoded);
}
internal class System.Security.Cryptography.Pkcs.Asn1.EssCertId : ValueType {
    internal ReadOnlyMemory`1<byte> Hash;
    internal Nullable`1<CadesIssuerSerial> IssuerSerial;
    internal void Encode(AsnWriter writer);
    internal void Encode(AsnWriter writer, Asn1Tag tag);
    internal static EssCertId Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static EssCertId Decode(Asn1Tag expectedTag, ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static void Decode(AsnReader reader, EssCertId& decoded);
    internal static void Decode(AsnReader reader, Asn1Tag expectedTag, EssCertId& decoded);
}
internal class System.Security.Cryptography.Pkcs.Asn1.EssCertIdV2 : ValueType {
    private static Byte[] s_defaultHashAlgorithm;
    internal AlgorithmIdentifierAsn HashAlgorithm;
    internal ReadOnlyMemory`1<byte> Hash;
    internal Nullable`1<CadesIssuerSerial> IssuerSerial;
    private static EssCertIdV2();
    internal void Encode(AsnWriter writer);
    internal void Encode(AsnWriter writer, Asn1Tag tag);
    internal static EssCertIdV2 Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static EssCertIdV2 Decode(Asn1Tag expectedTag, ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static void Decode(AsnReader reader, EssCertIdV2& decoded);
    internal static void Decode(AsnReader reader, Asn1Tag expectedTag, EssCertIdV2& decoded);
}
internal class System.Security.Cryptography.Pkcs.Asn1.IssuerAndSerialNumberAsn : ValueType {
    internal ReadOnlyMemory`1<byte> Issuer;
    internal ReadOnlyMemory`1<byte> SerialNumber;
    internal void Encode(AsnWriter writer);
    internal void Encode(AsnWriter writer, Asn1Tag tag);
    internal static IssuerAndSerialNumberAsn Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static IssuerAndSerialNumberAsn Decode(Asn1Tag expectedTag, ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static void Decode(AsnReader reader, IssuerAndSerialNumberAsn& decoded);
    internal static void Decode(AsnReader reader, Asn1Tag expectedTag, IssuerAndSerialNumberAsn& decoded);
}
internal class System.Security.Cryptography.Pkcs.Asn1.KeyAgreeRecipientIdentifierAsn : ValueType {
    internal Nullable`1<IssuerAndSerialNumberAsn> IssuerAndSerialNumber;
    internal Nullable`1<RecipientKeyIdentifier> RKeyId;
    internal void Encode(AsnWriter writer);
    internal static KeyAgreeRecipientIdentifierAsn Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static void Decode(AsnReader reader, KeyAgreeRecipientIdentifierAsn& decoded);
}
internal class System.Security.Cryptography.Pkcs.Asn1.KeyAgreeRecipientInfoAsn : ValueType {
    internal int Version;
    internal OriginatorIdentifierOrKeyAsn Originator;
    internal Nullable`1<ReadOnlyMemory`1<byte>> Ukm;
    internal AlgorithmIdentifierAsn KeyEncryptionAlgorithm;
    internal RecipientEncryptedKeyAsn[] RecipientEncryptedKeys;
    internal void Encode(AsnWriter writer);
    internal void Encode(AsnWriter writer, Asn1Tag tag);
    internal static KeyAgreeRecipientInfoAsn Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static KeyAgreeRecipientInfoAsn Decode(Asn1Tag expectedTag, ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static void Decode(AsnReader reader, KeyAgreeRecipientInfoAsn& decoded);
    internal static void Decode(AsnReader reader, Asn1Tag expectedTag, KeyAgreeRecipientInfoAsn& decoded);
}
internal class System.Security.Cryptography.Pkcs.Asn1.KeyTransRecipientInfoAsn : ValueType {
    internal int Version;
    internal RecipientIdentifierAsn Rid;
    internal AlgorithmIdentifierAsn KeyEncryptionAlgorithm;
    internal ReadOnlyMemory`1<byte> EncryptedKey;
    internal void Encode(AsnWriter writer);
    internal void Encode(AsnWriter writer, Asn1Tag tag);
    internal static KeyTransRecipientInfoAsn Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static KeyTransRecipientInfoAsn Decode(Asn1Tag expectedTag, ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static void Decode(AsnReader reader, KeyTransRecipientInfoAsn& decoded);
    internal static void Decode(AsnReader reader, Asn1Tag expectedTag, KeyTransRecipientInfoAsn& decoded);
}
internal class System.Security.Cryptography.Pkcs.Asn1.MacData : ValueType {
    private static Byte[] s_defaultIterationCount;
    internal DigestInfoAsn Mac;
    internal ReadOnlyMemory`1<byte> MacSalt;
    internal int IterationCount;
    private static MacData();
    internal void Encode(AsnWriter writer);
    internal void Encode(AsnWriter writer, Asn1Tag tag);
    internal static MacData Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static MacData Decode(Asn1Tag expectedTag, ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static void Decode(AsnReader reader, MacData& decoded);
    internal static void Decode(AsnReader reader, Asn1Tag expectedTag, MacData& decoded);
}
internal class System.Security.Cryptography.Pkcs.Asn1.MessageImprint : ValueType {
    internal AlgorithmIdentifierAsn HashAlgorithm;
    internal ReadOnlyMemory`1<byte> HashedMessage;
    internal void Encode(AsnWriter writer);
    internal void Encode(AsnWriter writer, Asn1Tag tag);
    internal static MessageImprint Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static MessageImprint Decode(Asn1Tag expectedTag, ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static void Decode(AsnReader reader, MessageImprint& decoded);
    internal static void Decode(AsnReader reader, Asn1Tag expectedTag, MessageImprint& decoded);
}
internal class System.Security.Cryptography.Pkcs.Asn1.OriginatorIdentifierOrKeyAsn : ValueType {
    internal Nullable`1<IssuerAndSerialNumberAsn> IssuerAndSerialNumber;
    internal Nullable`1<ReadOnlyMemory`1<byte>> SubjectKeyIdentifier;
    internal Nullable`1<OriginatorPublicKeyAsn> OriginatorKey;
    internal void Encode(AsnWriter writer);
    internal static OriginatorIdentifierOrKeyAsn Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static void Decode(AsnReader reader, OriginatorIdentifierOrKeyAsn& decoded);
}
internal class System.Security.Cryptography.Pkcs.Asn1.OriginatorInfoAsn : ValueType {
    internal CertificateChoiceAsn[] CertificateSet;
    internal ReadOnlyMemory`1[] RevocationInfoChoices;
    internal void Encode(AsnWriter writer);
    internal void Encode(AsnWriter writer, Asn1Tag tag);
    internal static OriginatorInfoAsn Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static OriginatorInfoAsn Decode(Asn1Tag expectedTag, ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static void Decode(AsnReader reader, OriginatorInfoAsn& decoded);
    internal static void Decode(AsnReader reader, Asn1Tag expectedTag, OriginatorInfoAsn& decoded);
}
internal class System.Security.Cryptography.Pkcs.Asn1.OriginatorPublicKeyAsn : ValueType {
    internal AlgorithmIdentifierAsn Algorithm;
    internal ReadOnlyMemory`1<byte> PublicKey;
    internal void Encode(AsnWriter writer);
    internal void Encode(AsnWriter writer, Asn1Tag tag);
    internal static OriginatorPublicKeyAsn Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static OriginatorPublicKeyAsn Decode(Asn1Tag expectedTag, ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static void Decode(AsnReader reader, OriginatorPublicKeyAsn& decoded);
    internal static void Decode(AsnReader reader, Asn1Tag expectedTag, OriginatorPublicKeyAsn& decoded);
}
internal class System.Security.Cryptography.Pkcs.Asn1.OtherKeyAttributeAsn : ValueType {
    internal string KeyAttrId;
    internal Nullable`1<ReadOnlyMemory`1<byte>> KeyAttr;
    internal void Encode(AsnWriter writer);
    internal void Encode(AsnWriter writer, Asn1Tag tag);
    internal static OtherKeyAttributeAsn Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static OtherKeyAttributeAsn Decode(Asn1Tag expectedTag, ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static void Decode(AsnReader reader, OtherKeyAttributeAsn& decoded);
    internal static void Decode(AsnReader reader, Asn1Tag expectedTag, OtherKeyAttributeAsn& decoded);
}
internal class System.Security.Cryptography.Pkcs.Asn1.PfxAsn : ValueType {
    internal byte Version;
    internal ContentInfoAsn AuthSafe;
    internal Nullable`1<MacData> MacData;
    internal void Encode(AsnWriter writer);
    internal void Encode(AsnWriter writer, Asn1Tag tag);
    internal static PfxAsn Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static PfxAsn Decode(Asn1Tag expectedTag, ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static void Decode(AsnReader reader, PfxAsn& decoded);
    internal static void Decode(AsnReader reader, Asn1Tag expectedTag, PfxAsn& decoded);
}
[FlagsAttribute]
internal enum System.Security.Cryptography.Pkcs.Asn1.PkiFailureInfo : Enum {
    public int value__;
    public static PkiFailureInfo None;
    public static PkiFailureInfo BadAlg;
    public static PkiFailureInfo BadMessageCheck;
    public static PkiFailureInfo BadRequest;
    public static PkiFailureInfo BadTime;
    public static PkiFailureInfo BadCertId;
    public static PkiFailureInfo BadDataFormat;
    public static PkiFailureInfo WrongAuthority;
    public static PkiFailureInfo IncorrectData;
    public static PkiFailureInfo MissingTimeStamp;
    public static PkiFailureInfo BadPop;
    public static PkiFailureInfo CertRevoked;
    public static PkiFailureInfo CertConfirmed;
    public static PkiFailureInfo WrongIntegrity;
    public static PkiFailureInfo BadRecipientNonce;
    public static PkiFailureInfo TimeNotAvailable;
    public static PkiFailureInfo UnacceptedPolicy;
    public static PkiFailureInfo UnacceptedExtension;
    public static PkiFailureInfo AddInfoNotAvailable;
    public static PkiFailureInfo BadSenderNonce;
    public static PkiFailureInfo BadCertTemplate;
    public static PkiFailureInfo SignerNotTrusted;
    public static PkiFailureInfo TransactionIdInUse;
    public static PkiFailureInfo UnsupportedVersion;
    public static PkiFailureInfo NotAuthorized;
    public static PkiFailureInfo SystemUnavail;
    public static PkiFailureInfo SystemFailure;
    public static PkiFailureInfo DuplicateCertReq;
}
internal enum System.Security.Cryptography.Pkcs.Asn1.PkiStatus : Enum {
    public int value__;
    public static PkiStatus Granted;
    public static PkiStatus GrantedWithMods;
    public static PkiStatus Rejection;
    public static PkiStatus Waiting;
    public static PkiStatus RevocationWarning;
    public static PkiStatus RevocationNotification;
    public static PkiStatus KeyUpdateWarning;
}
internal class System.Security.Cryptography.Pkcs.Asn1.PkiStatusInfo : ValueType {
    internal int Status;
    internal Nullable`1<ReadOnlyMemory`1<byte>> StatusString;
    internal Nullable`1<PkiFailureInfo> FailInfo;
    internal void Encode(AsnWriter writer);
    internal void Encode(AsnWriter writer, Asn1Tag tag);
    internal static PkiStatusInfo Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static PkiStatusInfo Decode(Asn1Tag expectedTag, ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static void Decode(AsnReader reader, PkiStatusInfo& decoded);
    internal static void Decode(AsnReader reader, Asn1Tag expectedTag, PkiStatusInfo& decoded);
}
internal class System.Security.Cryptography.Pkcs.Asn1.PolicyInformation : ValueType {
    internal string PolicyIdentifier;
    internal PolicyQualifierInfo[] PolicyQualifiers;
    internal void Encode(AsnWriter writer);
    internal void Encode(AsnWriter writer, Asn1Tag tag);
    internal static PolicyInformation Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static PolicyInformation Decode(Asn1Tag expectedTag, ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static void Decode(AsnReader reader, PolicyInformation& decoded);
    internal static void Decode(AsnReader reader, Asn1Tag expectedTag, PolicyInformation& decoded);
}
internal class System.Security.Cryptography.Pkcs.Asn1.PolicyQualifierInfo : ValueType {
    internal string PolicyQualifierId;
    internal ReadOnlyMemory`1<byte> Qualifier;
    internal void Encode(AsnWriter writer);
    internal void Encode(AsnWriter writer, Asn1Tag tag);
    internal static PolicyQualifierInfo Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static PolicyQualifierInfo Decode(Asn1Tag expectedTag, ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static void Decode(AsnReader reader, PolicyQualifierInfo& decoded);
    internal static void Decode(AsnReader reader, Asn1Tag expectedTag, PolicyQualifierInfo& decoded);
}
internal class System.Security.Cryptography.Pkcs.Asn1.RecipientEncryptedKeyAsn : ValueType {
    internal KeyAgreeRecipientIdentifierAsn Rid;
    internal ReadOnlyMemory`1<byte> EncryptedKey;
    internal void Encode(AsnWriter writer);
    internal void Encode(AsnWriter writer, Asn1Tag tag);
    internal static RecipientEncryptedKeyAsn Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static RecipientEncryptedKeyAsn Decode(Asn1Tag expectedTag, ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static void Decode(AsnReader reader, RecipientEncryptedKeyAsn& decoded);
    internal static void Decode(AsnReader reader, Asn1Tag expectedTag, RecipientEncryptedKeyAsn& decoded);
}
internal class System.Security.Cryptography.Pkcs.Asn1.RecipientIdentifierAsn : ValueType {
    internal Nullable`1<IssuerAndSerialNumberAsn> IssuerAndSerialNumber;
    internal Nullable`1<ReadOnlyMemory`1<byte>> SubjectKeyIdentifier;
    internal void Encode(AsnWriter writer);
    internal static RecipientIdentifierAsn Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static void Decode(AsnReader reader, RecipientIdentifierAsn& decoded);
}
internal class System.Security.Cryptography.Pkcs.Asn1.RecipientInfoAsn : ValueType {
    internal Nullable`1<KeyTransRecipientInfoAsn> Ktri;
    internal Nullable`1<KeyAgreeRecipientInfoAsn> Kari;
    internal void Encode(AsnWriter writer);
    internal static RecipientInfoAsn Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static void Decode(AsnReader reader, RecipientInfoAsn& decoded);
}
internal class System.Security.Cryptography.Pkcs.Asn1.RecipientKeyIdentifier : ValueType {
    internal ReadOnlyMemory`1<byte> SubjectKeyIdentifier;
    internal Nullable`1<DateTimeOffset> Date;
    internal Nullable`1<OtherKeyAttributeAsn> Other;
    internal void Encode(AsnWriter writer);
    internal void Encode(AsnWriter writer, Asn1Tag tag);
    internal static RecipientKeyIdentifier Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static RecipientKeyIdentifier Decode(Asn1Tag expectedTag, ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static void Decode(AsnReader reader, RecipientKeyIdentifier& decoded);
    internal static void Decode(AsnReader reader, Asn1Tag expectedTag, RecipientKeyIdentifier& decoded);
}
internal class System.Security.Cryptography.Pkcs.Asn1.Rfc3161Accuracy : ValueType {
    internal Nullable`1<int> Seconds;
    internal Nullable`1<int> Millis;
    internal Nullable`1<int> Micros;
    internal long TotalMicros { get; }
    internal Rfc3161Accuracy(long accuracyInMicroseconds);
    internal void Encode(AsnWriter writer);
    internal void Encode(AsnWriter writer, Asn1Tag tag);
    internal static Rfc3161Accuracy Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static Rfc3161Accuracy Decode(Asn1Tag expectedTag, ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static void Decode(AsnReader reader, Rfc3161Accuracy& decoded);
    internal static void Decode(AsnReader reader, Asn1Tag expectedTag, Rfc3161Accuracy& decoded);
    internal long get_TotalMicros();
}
internal class System.Security.Cryptography.Pkcs.Asn1.Rfc3161TimeStampReq : ValueType {
    private static Byte[] s_defaultCertReq;
    internal int Version;
    internal MessageImprint MessageImprint;
    internal Oid ReqPolicy;
    internal Nullable`1<ReadOnlyMemory`1<byte>> Nonce;
    internal bool CertReq;
    internal X509ExtensionAsn[] Extensions;
    private static Rfc3161TimeStampReq();
    internal void Encode(AsnWriter writer);
    internal void Encode(AsnWriter writer, Asn1Tag tag);
    internal static Rfc3161TimeStampReq Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static Rfc3161TimeStampReq Decode(Asn1Tag expectedTag, ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static void Decode(AsnReader reader, Rfc3161TimeStampReq& decoded);
    internal static void Decode(AsnReader reader, Asn1Tag expectedTag, Rfc3161TimeStampReq& decoded);
}
internal class System.Security.Cryptography.Pkcs.Asn1.Rfc3161TimeStampResp : ValueType {
    internal PkiStatusInfo Status;
    internal Nullable`1<ReadOnlyMemory`1<byte>> TimeStampToken;
    internal void Encode(AsnWriter writer);
    internal void Encode(AsnWriter writer, Asn1Tag tag);
    internal static Rfc3161TimeStampResp Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static Rfc3161TimeStampResp Decode(Asn1Tag expectedTag, ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static void Decode(AsnReader reader, Rfc3161TimeStampResp& decoded);
    internal static void Decode(AsnReader reader, Asn1Tag expectedTag, Rfc3161TimeStampResp& decoded);
}
internal class System.Security.Cryptography.Pkcs.Asn1.Rfc3161TstInfo : ValueType {
    private static Byte[] s_defaultOrdering;
    internal int Version;
    internal Oid Policy;
    internal MessageImprint MessageImprint;
    internal ReadOnlyMemory`1<byte> SerialNumber;
    internal DateTimeOffset GenTime;
    internal Nullable`1<Rfc3161Accuracy> Accuracy;
    internal bool Ordering;
    internal Nullable`1<ReadOnlyMemory`1<byte>> Nonce;
    internal Nullable`1<GeneralNameAsn> Tsa;
    internal X509ExtensionAsn[] Extensions;
    private static Rfc3161TstInfo();
    internal void Encode(AsnWriter writer);
    internal void Encode(AsnWriter writer, Asn1Tag tag);
    internal static Rfc3161TstInfo Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static Rfc3161TstInfo Decode(Asn1Tag expectedTag, ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static void Decode(AsnReader reader, Rfc3161TstInfo& decoded);
    internal static void Decode(AsnReader reader, Asn1Tag expectedTag, Rfc3161TstInfo& decoded);
}
internal class System.Security.Cryptography.Pkcs.Asn1.SafeBagAsn : ValueType {
    internal string BagId;
    internal ReadOnlyMemory`1<byte> BagValue;
    internal AttributeAsn[] BagAttributes;
    internal void Encode(AsnWriter writer);
    internal void Encode(AsnWriter writer, Asn1Tag tag);
    internal static SafeBagAsn Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static SafeBagAsn Decode(Asn1Tag expectedTag, ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static void Decode(AsnReader reader, SafeBagAsn& decoded);
    internal static void Decode(AsnReader reader, Asn1Tag expectedTag, SafeBagAsn& decoded);
}
internal class System.Security.Cryptography.Pkcs.Asn1.SecretBagAsn : ValueType {
    internal string SecretTypeId;
    internal ReadOnlyMemory`1<byte> SecretValue;
    internal void Encode(AsnWriter writer);
    internal void Encode(AsnWriter writer, Asn1Tag tag);
    internal static SecretBagAsn Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static SecretBagAsn Decode(Asn1Tag expectedTag, ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static void Decode(AsnReader reader, SecretBagAsn& decoded);
    internal static void Decode(AsnReader reader, Asn1Tag expectedTag, SecretBagAsn& decoded);
}
internal class System.Security.Cryptography.Pkcs.Asn1.SignedDataAsn : ValueType {
    internal int Version;
    internal AlgorithmIdentifierAsn[] DigestAlgorithms;
    internal EncapsulatedContentInfoAsn EncapContentInfo;
    internal CertificateChoiceAsn[] CertificateSet;
    internal ReadOnlyMemory`1[] Crls;
    internal SignerInfoAsn[] SignerInfos;
    internal void Encode(AsnWriter writer);
    internal void Encode(AsnWriter writer, Asn1Tag tag);
    internal static SignedDataAsn Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static SignedDataAsn Decode(Asn1Tag expectedTag, ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static void Decode(AsnReader reader, SignedDataAsn& decoded);
    internal static void Decode(AsnReader reader, Asn1Tag expectedTag, SignedDataAsn& decoded);
}
internal class System.Security.Cryptography.Pkcs.Asn1.SignerIdentifierAsn : ValueType {
    internal Nullable`1<IssuerAndSerialNumberAsn> IssuerAndSerialNumber;
    internal Nullable`1<ReadOnlyMemory`1<byte>> SubjectKeyIdentifier;
    internal void Encode(AsnWriter writer);
    internal static SignerIdentifierAsn Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static void Decode(AsnReader reader, SignerIdentifierAsn& decoded);
}
internal class System.Security.Cryptography.Pkcs.Asn1.SignerInfoAsn : ValueType {
    internal int Version;
    internal SignerIdentifierAsn Sid;
    internal AlgorithmIdentifierAsn DigestAlgorithm;
    internal Nullable`1<ReadOnlyMemory`1<byte>> SignedAttributes;
    internal AlgorithmIdentifierAsn SignatureAlgorithm;
    internal ReadOnlyMemory`1<byte> SignatureValue;
    internal AttributeAsn[] UnsignedAttributes;
    internal void Encode(AsnWriter writer);
    internal void Encode(AsnWriter writer, Asn1Tag tag);
    internal static SignerInfoAsn Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static SignerInfoAsn Decode(Asn1Tag expectedTag, ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static void Decode(AsnReader reader, SignerInfoAsn& decoded);
    internal static void Decode(AsnReader reader, Asn1Tag expectedTag, SignerInfoAsn& decoded);
}
internal class System.Security.Cryptography.Pkcs.Asn1.SigningCertificateAsn : ValueType {
    internal EssCertId[] Certs;
    internal PolicyInformation[] Policies;
    internal void Encode(AsnWriter writer);
    internal void Encode(AsnWriter writer, Asn1Tag tag);
    internal static SigningCertificateAsn Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static SigningCertificateAsn Decode(Asn1Tag expectedTag, ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static void Decode(AsnReader reader, SigningCertificateAsn& decoded);
    internal static void Decode(AsnReader reader, Asn1Tag expectedTag, SigningCertificateAsn& decoded);
}
internal class System.Security.Cryptography.Pkcs.Asn1.SigningCertificateV2Asn : ValueType {
    internal EssCertIdV2[] Certs;
    internal PolicyInformation[] Policies;
    internal void Encode(AsnWriter writer);
    internal void Encode(AsnWriter writer, Asn1Tag tag);
    internal static SigningCertificateV2Asn Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static SigningCertificateV2Asn Decode(Asn1Tag expectedTag, ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static void Decode(AsnReader reader, SigningCertificateV2Asn& decoded);
    internal static void Decode(AsnReader reader, Asn1Tag expectedTag, SigningCertificateV2Asn& decoded);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.Pkcs.CmsRecipient : object {
    [CompilerGeneratedAttribute]
private RSAEncryptionPadding <RSAEncryptionPadding>k__BackingField;
    [CompilerGeneratedAttribute]
private SubjectIdentifierType <RecipientIdentifierType>k__BackingField;
    [CompilerGeneratedAttribute]
private X509Certificate2 <Certificate>k__BackingField;
    [NullableAttribute("2")]
public RSAEncryptionPadding RSAEncryptionPadding { get; }
    public SubjectIdentifierType RecipientIdentifierType { get; }
    public X509Certificate2 Certificate { get; }
    public CmsRecipient(X509Certificate2 certificate);
    public CmsRecipient(X509Certificate2 certificate, RSAEncryptionPadding rsaEncryptionPadding);
    public CmsRecipient(SubjectIdentifierType recipientIdentifierType, X509Certificate2 certificate, RSAEncryptionPadding rsaEncryptionPadding);
    public CmsRecipient(SubjectIdentifierType recipientIdentifierType, X509Certificate2 certificate);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public RSAEncryptionPadding get_RSAEncryptionPadding();
    [CompilerGeneratedAttribute]
public SubjectIdentifierType get_RecipientIdentifierType();
    [CompilerGeneratedAttribute]
public X509Certificate2 get_Certificate();
    private static void ValidateRSACertificate(X509Certificate2 certificate);
}
[DefaultMemberAttribute("Item")]
public class System.Security.Cryptography.Pkcs.CmsRecipientCollection : object {
    private List`1<CmsRecipient> _recipients;
    public CmsRecipient Item { get; }
    public int Count { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public CmsRecipientCollection(CmsRecipient recipient);
    public CmsRecipientCollection(SubjectIdentifierType recipientIdentifierType, X509Certificate2Collection certificates);
    public CmsRecipient get_Item(int index);
    public sealed virtual int get_Count();
    public int Add(CmsRecipient recipient);
    public void Remove(CmsRecipient recipient);
    public CmsRecipientEnumerator GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void CopyTo(Array array, int index);
    public void CopyTo(CmsRecipient[] array, int index);
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
}
public class System.Security.Cryptography.Pkcs.CmsRecipientEnumerator : object {
    private CmsRecipientCollection _recipients;
    private int _current;
    public CmsRecipient Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    internal CmsRecipientEnumerator(CmsRecipientCollection recipients);
    public CmsRecipient get_Current();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
}
internal abstract class System.Security.Cryptography.Pkcs.CmsSignature : object {
    private static Dictionary`2<string, CmsSignature> s_lookup;
    private static CmsSignature();
    private static void PrepareRegistrationRsa(Dictionary`2<string, CmsSignature> lookup);
    private static void PrepareRegistrationDsa(Dictionary`2<string, CmsSignature> lookup);
    private static void PrepareRegistrationECDsa(Dictionary`2<string, CmsSignature> lookup);
    protected abstract virtual bool VerifyKeyType(AsymmetricAlgorithm key);
    internal abstract virtual bool VerifySignature(ReadOnlySpan`1<byte> valueHash, ReadOnlyMemory`1<byte> signature, string digestAlgorithmOid, HashAlgorithmName digestAlgorithmName, Nullable`1<ReadOnlyMemory`1<byte>> signatureParameters, X509Certificate2 certificate);
    protected abstract virtual bool Sign(ReadOnlySpan`1<byte> dataHash, HashAlgorithmName hashAlgorithmName, X509Certificate2 certificate, AsymmetricAlgorithm key, bool silent, Oid& signatureAlgorithm, Byte[]& signatureValue);
    internal static CmsSignature ResolveAndVerifyKeyType(string signatureAlgorithmOid, AsymmetricAlgorithm key);
    internal static bool Sign(ReadOnlySpan`1<byte> dataHash, HashAlgorithmName hashAlgorithmName, X509Certificate2 certificate, AsymmetricAlgorithm key, bool silent, Oid& oid, ReadOnlyMemory`1& signatureValue);
    private static bool DsaDerToIeee(ReadOnlyMemory`1<byte> derSignature, Span`1<byte> ieeeSignature);
    private static Byte[] DsaIeeeToDer(ReadOnlySpan`1<byte> ieeeSignature);
}
public class System.Security.Cryptography.Pkcs.CmsSigner : object {
    private static Oid s_defaultAlgorithm;
    private SubjectIdentifierType _signerIdentifierType;
    [CompilerGeneratedAttribute]
private X509Certificate2 <Certificate>k__BackingField;
    [CompilerGeneratedAttribute]
private AsymmetricAlgorithm <PrivateKey>k__BackingField;
    [CompilerGeneratedAttribute]
private X509Certificate2Collection <Certificates>k__BackingField;
    [CompilerGeneratedAttribute]
private Oid <DigestAlgorithm>k__BackingField;
    [CompilerGeneratedAttribute]
private X509IncludeOption <IncludeOption>k__BackingField;
    [CompilerGeneratedAttribute]
private CryptographicAttributeObjectCollection <SignedAttributes>k__BackingField;
    [CompilerGeneratedAttribute]
private CryptographicAttributeObjectCollection <UnsignedAttributes>k__BackingField;
    public X509Certificate2 Certificate { get; public set; }
    public AsymmetricAlgorithm PrivateKey { get; public set; }
    public X509Certificate2Collection Certificates { get; private set; }
    public Oid DigestAlgorithm { get; public set; }
    public X509IncludeOption IncludeOption { get; public set; }
    public CryptographicAttributeObjectCollection SignedAttributes { get; private set; }
    public CryptographicAttributeObjectCollection UnsignedAttributes { get; private set; }
    public SubjectIdentifierType SignerIdentifierType { get; public set; }
    public CmsSigner(SubjectIdentifierType signerIdentifierType);
    public CmsSigner(X509Certificate2 certificate);
    public CmsSigner(CspParameters parameters);
    public CmsSigner(SubjectIdentifierType signerIdentifierType, X509Certificate2 certificate);
    public CmsSigner(SubjectIdentifierType signerIdentifierType, X509Certificate2 certificate, AsymmetricAlgorithm privateKey);
    private static CmsSigner();
    [CompilerGeneratedAttribute]
public X509Certificate2 get_Certificate();
    [CompilerGeneratedAttribute]
public void set_Certificate(X509Certificate2 value);
    [CompilerGeneratedAttribute]
public AsymmetricAlgorithm get_PrivateKey();
    [CompilerGeneratedAttribute]
public void set_PrivateKey(AsymmetricAlgorithm value);
    [CompilerGeneratedAttribute]
public X509Certificate2Collection get_Certificates();
    [CompilerGeneratedAttribute]
private void set_Certificates(X509Certificate2Collection value);
    [CompilerGeneratedAttribute]
public Oid get_DigestAlgorithm();
    [CompilerGeneratedAttribute]
public void set_DigestAlgorithm(Oid value);
    [CompilerGeneratedAttribute]
public X509IncludeOption get_IncludeOption();
    [CompilerGeneratedAttribute]
public void set_IncludeOption(X509IncludeOption value);
    [CompilerGeneratedAttribute]
public CryptographicAttributeObjectCollection get_SignedAttributes();
    [CompilerGeneratedAttribute]
private void set_SignedAttributes(CryptographicAttributeObjectCollection value);
    [CompilerGeneratedAttribute]
public CryptographicAttributeObjectCollection get_UnsignedAttributes();
    [CompilerGeneratedAttribute]
private void set_UnsignedAttributes(CryptographicAttributeObjectCollection value);
    public SubjectIdentifierType get_SignerIdentifierType();
    public void set_SignerIdentifierType(SubjectIdentifierType value);
    internal void CheckCertificateValue();
    internal SignerInfoAsn Sign(ReadOnlyMemory`1<byte> data, string contentTypeOid, bool silent, X509Certificate2Collection& chainCerts);
    internal static List`1<AttributeAsn> BuildAttributes(CryptographicAttributeObjectCollection attributes);
}
public class System.Security.Cryptography.Pkcs.ContentInfo : object {
    [CompilerGeneratedAttribute]
private Oid <ContentType>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <Content>k__BackingField;
    public Oid ContentType { get; }
    public Byte[] Content { get; }
    public ContentInfo(Byte[] content);
    public ContentInfo(Oid contentType, Byte[] content);
    [CompilerGeneratedAttribute]
public Oid get_ContentType();
    [CompilerGeneratedAttribute]
public Byte[] get_Content();
    public static Oid GetContentType(Byte[] encodedMessage);
}
public class System.Security.Cryptography.Pkcs.EnvelopedCms : object {
    [CompilerGeneratedAttribute]
private int <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private ContentInfo <ContentInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private AlgorithmIdentifier <ContentEncryptionAlgorithm>k__BackingField;
    [CompilerGeneratedAttribute]
private X509Certificate2Collection <Certificates>k__BackingField;
    [CompilerGeneratedAttribute]
private CryptographicAttributeObjectCollection <UnprotectedAttributes>k__BackingField;
    private DecryptorPal _decryptorPal;
    private Byte[] _encodedMessage;
    private LastCall _lastCall;
    public int Version { get; private set; }
    public ContentInfo ContentInfo { get; private set; }
    public AlgorithmIdentifier ContentEncryptionAlgorithm { get; private set; }
    public X509Certificate2Collection Certificates { get; private set; }
    public CryptographicAttributeObjectCollection UnprotectedAttributes { get; private set; }
    public RecipientInfoCollection RecipientInfos { get; }
    public EnvelopedCms(ContentInfo contentInfo);
    public EnvelopedCms(ContentInfo contentInfo, AlgorithmIdentifier encryptionAlgorithm);
    [CompilerGeneratedAttribute]
public int get_Version();
    [CompilerGeneratedAttribute]
private void set_Version(int value);
    [CompilerGeneratedAttribute]
public ContentInfo get_ContentInfo();
    [CompilerGeneratedAttribute]
private void set_ContentInfo(ContentInfo value);
    [CompilerGeneratedAttribute]
public AlgorithmIdentifier get_ContentEncryptionAlgorithm();
    [CompilerGeneratedAttribute]
private void set_ContentEncryptionAlgorithm(AlgorithmIdentifier value);
    [CompilerGeneratedAttribute]
public X509Certificate2Collection get_Certificates();
    [CompilerGeneratedAttribute]
private void set_Certificates(X509Certificate2Collection value);
    [CompilerGeneratedAttribute]
public CryptographicAttributeObjectCollection get_UnprotectedAttributes();
    [CompilerGeneratedAttribute]
private void set_UnprotectedAttributes(CryptographicAttributeObjectCollection value);
    public RecipientInfoCollection get_RecipientInfos();
    public void Encrypt(CmsRecipient recipient);
    public void Encrypt(CmsRecipientCollection recipients);
    public Byte[] Encode();
    public void Decode(Byte[] encodedMessage);
    public void Decrypt();
    public void Decrypt(RecipientInfo recipientInfo);
    public void Decrypt(RecipientInfo recipientInfo, X509Certificate2Collection extraStore);
    public void Decrypt(X509Certificate2Collection extraStore);
    public void Decrypt(RecipientInfo recipientInfo, AsymmetricAlgorithm privateKey);
    private void DecryptContent(RecipientInfoCollection recipientInfos, X509Certificate2Collection extraStore);
    private void CheckStateForDecryption();
    private void SetContentInfo(ContentInfo contentInfo);
}
public class System.Security.Cryptography.Pkcs.KeyAgreeRecipientInfo : RecipientInfo {
    private SubjectIdentifier modreq(System.Runtime.CompilerServices.IsVolatile) _lazyRecipientIdentifier;
    private AlgorithmIdentifier modreq(System.Runtime.CompilerServices.IsVolatile) _lazyKeyEncryptionAlgorithm;
    private Byte[] modreq(System.Runtime.CompilerServices.IsVolatile) _lazyEncryptedKey;
    private SubjectIdentifierOrKey modreq(System.Runtime.CompilerServices.IsVolatile) _lazyOriginatorIdentifierKey;
    private Nullable`1<DateTime> _lazyDate;
    private CryptographicAttributeObject modreq(System.Runtime.CompilerServices.IsVolatile) _lazyOtherKeyAttribute;
    public int Version { get; }
    public SubjectIdentifier RecipientIdentifier { get; }
    public AlgorithmIdentifier KeyEncryptionAlgorithm { get; }
    public Byte[] EncryptedKey { get; }
    public SubjectIdentifierOrKey OriginatorIdentifierOrKey { get; }
    public DateTime Date { get; }
    public CryptographicAttributeObject OtherKeyAttribute { get; }
    private KeyAgreeRecipientInfoPal Pal { get; }
    internal KeyAgreeRecipientInfo(KeyAgreeRecipientInfoPal pal);
    public virtual int get_Version();
    public virtual SubjectIdentifier get_RecipientIdentifier();
    public virtual AlgorithmIdentifier get_KeyEncryptionAlgorithm();
    public virtual Byte[] get_EncryptedKey();
    public SubjectIdentifierOrKey get_OriginatorIdentifierOrKey();
    public DateTime get_Date();
    public CryptographicAttributeObject get_OtherKeyAttribute();
    private KeyAgreeRecipientInfoPal get_Pal();
}
public class System.Security.Cryptography.Pkcs.KeyTransRecipientInfo : RecipientInfo {
    private SubjectIdentifier modreq(System.Runtime.CompilerServices.IsVolatile) _lazyRecipientIdentifier;
    private AlgorithmIdentifier modreq(System.Runtime.CompilerServices.IsVolatile) _lazyKeyEncryptionAlgorithm;
    private Byte[] modreq(System.Runtime.CompilerServices.IsVolatile) _lazyEncryptedKey;
    public int Version { get; }
    public SubjectIdentifier RecipientIdentifier { get; }
    public AlgorithmIdentifier KeyEncryptionAlgorithm { get; }
    public Byte[] EncryptedKey { get; }
    private KeyTransRecipientInfoPal Pal { get; }
    internal KeyTransRecipientInfo(KeyTransRecipientInfoPal pal);
    public virtual int get_Version();
    public virtual SubjectIdentifier get_RecipientIdentifier();
    public virtual AlgorithmIdentifier get_KeyEncryptionAlgorithm();
    public virtual Byte[] get_EncryptedKey();
    private KeyTransRecipientInfoPal get_Pal();
}
public class System.Security.Cryptography.Pkcs.Pkcs12Builder : object {
    private ReadOnlyMemory`1<byte> _sealedData;
    private List`1<ContentInfoAsn> _contents;
    public bool IsSealed { get; }
    public bool get_IsSealed();
    public void AddSafeContentsEncrypted(Pkcs12SafeContents safeContents, Byte[] passwordBytes, PbeParameters pbeParameters);
    public void AddSafeContentsEncrypted(Pkcs12SafeContents safeContents, ReadOnlySpan`1<byte> passwordBytes, PbeParameters pbeParameters);
    public void AddSafeContentsEncrypted(Pkcs12SafeContents safeContents, string password, PbeParameters pbeParameters);
    public void AddSafeContentsEncrypted(Pkcs12SafeContents safeContents, ReadOnlySpan`1<char> password, PbeParameters pbeParameters);
    public void AddSafeContentsUnencrypted(Pkcs12SafeContents safeContents);
    public Byte[] Encode();
    public void SealWithMac(string password, HashAlgorithmName hashAlgorithm, int iterationCount);
    public void SealWithMac(ReadOnlySpan`1<char> password, HashAlgorithmName hashAlgorithm, int iterationCount);
    public void SealWithoutIntegrity();
    public bool TryEncode(Span`1<byte> destination, Int32& bytesWritten);
}
public class System.Security.Cryptography.Pkcs.Pkcs12CertBag : Pkcs12SafeBag {
    private Oid _certTypeOid;
    private CertBagAsn _decoded;
    [CompilerGeneratedAttribute]
private bool <IsX509Certificate>k__BackingField;
    public bool IsX509Certificate { get; }
    public ReadOnlyMemory`1<byte> EncodedCertificate { get; }
    private Pkcs12CertBag(ReadOnlyMemory`1<byte> encodedBagValue, CertBagAsn decoded);
    public Pkcs12CertBag(Oid certificateType, ReadOnlyMemory`1<byte> encodedCertificate);
    internal Pkcs12CertBag(X509Certificate2 cert);
    [CompilerGeneratedAttribute]
public bool get_IsX509Certificate();
    public Oid GetCertificateType();
    public ReadOnlyMemory`1<byte> get_EncodedCertificate();
    public X509Certificate2 GetCertificate();
    private static Byte[] EncodeBagValue(Oid certificateType, ReadOnlyMemory`1<byte> encodedCertificate);
    private static Byte[] EncodeBagValue(string certificateType, ReadOnlyMemory`1<byte> encodedCertificate);
    internal static Pkcs12CertBag DecodeValue(ReadOnlyMemory`1<byte> bagValue);
}
public enum System.Security.Cryptography.Pkcs.Pkcs12ConfidentialityMode : Enum {
    public int value__;
    public static Pkcs12ConfidentialityMode Unknown;
    public static Pkcs12ConfidentialityMode None;
    public static Pkcs12ConfidentialityMode Password;
    public static Pkcs12ConfidentialityMode PublicKey;
}
public class System.Security.Cryptography.Pkcs.Pkcs12Info : object {
    private PfxAsn _decoded;
    private ReadOnlyMemory`1<byte> _authSafeContents;
    [CompilerGeneratedAttribute]
private ReadOnlyCollection`1<Pkcs12SafeContents> <AuthenticatedSafe>k__BackingField;
    [CompilerGeneratedAttribute]
private Pkcs12IntegrityMode <IntegrityMode>k__BackingField;
    public ReadOnlyCollection`1<Pkcs12SafeContents> AuthenticatedSafe { get; private set; }
    public Pkcs12IntegrityMode IntegrityMode { get; private set; }
    [CompilerGeneratedAttribute]
public ReadOnlyCollection`1<Pkcs12SafeContents> get_AuthenticatedSafe();
    [CompilerGeneratedAttribute]
private void set_AuthenticatedSafe(ReadOnlyCollection`1<Pkcs12SafeContents> value);
    [CompilerGeneratedAttribute]
public Pkcs12IntegrityMode get_IntegrityMode();
    [CompilerGeneratedAttribute]
private void set_IntegrityMode(Pkcs12IntegrityMode value);
    public bool VerifyMac(string password);
    public bool VerifyMac(ReadOnlySpan`1<char> password);
    public static Pkcs12Info Decode(ReadOnlyMemory`1<byte> encodedBytes, Int32& bytesConsumed, bool skipCopy);
}
public enum System.Security.Cryptography.Pkcs.Pkcs12IntegrityMode : Enum {
    public int value__;
    public static Pkcs12IntegrityMode Unknown;
    public static Pkcs12IntegrityMode None;
    public static Pkcs12IntegrityMode Password;
    public static Pkcs12IntegrityMode PublicKey;
}
internal static class System.Security.Cryptography.Pkcs.Pkcs12Kdf : object {
    private static byte CipherKeyId;
    private static byte IvId;
    private static byte MacKeyId;
    private static Dictionary`2<HashAlgorithmName, Tuple`2<int, int>> s_uvLookup;
    private static Pkcs12Kdf();
    internal static void DeriveCipherKey(ReadOnlySpan`1<char> password, HashAlgorithmName hashAlgorithm, int iterationCount, ReadOnlySpan`1<byte> salt, Span`1<byte> destination);
    internal static void DeriveIV(ReadOnlySpan`1<char> password, HashAlgorithmName hashAlgorithm, int iterationCount, ReadOnlySpan`1<byte> salt, Span`1<byte> destination);
    internal static void DeriveMacKey(ReadOnlySpan`1<char> password, HashAlgorithmName hashAlgorithm, int iterationCount, ReadOnlySpan`1<byte> salt, Span`1<byte> destination);
    private static void Derive(ReadOnlySpan`1<char> password, HashAlgorithmName hashAlgorithm, int iterationCount, byte id, ReadOnlySpan`1<byte> salt, Span`1<byte> destination);
    private static void AddPlusOne(Span`1<byte> into, Span`1<byte> addend);
    private static void CircularCopy(ReadOnlySpan`1<byte> bytes, Span`1<byte> destination);
    private static void CircularCopyUtf16BE(ReadOnlySpan`1<char> password, Span`1<byte> destination);
}
public class System.Security.Cryptography.Pkcs.Pkcs12KeyBag : Pkcs12SafeBag {
    public ReadOnlyMemory`1<byte> Pkcs8PrivateKey { get; }
    public Pkcs12KeyBag(ReadOnlyMemory`1<byte> pkcs8PrivateKey, bool skipCopy);
    public ReadOnlyMemory`1<byte> get_Pkcs8PrivateKey();
}
public abstract class System.Security.Cryptography.Pkcs.Pkcs12SafeBag : object {
    private string _bagIdValue;
    private Oid _bagOid;
    private CryptographicAttributeObjectCollection _attributes;
    [CompilerGeneratedAttribute]
private ReadOnlyMemory`1<byte> <EncodedBagValue>k__BackingField;
    public ReadOnlyMemory`1<byte> EncodedBagValue { get; }
    public CryptographicAttributeObjectCollection Attributes { get; internal set; }
    protected Pkcs12SafeBag(string bagIdValue, ReadOnlyMemory`1<byte> encodedBagValue, bool skipCopy);
    [CompilerGeneratedAttribute]
public ReadOnlyMemory`1<byte> get_EncodedBagValue();
    public CryptographicAttributeObjectCollection get_Attributes();
    internal void set_Attributes(CryptographicAttributeObjectCollection value);
    public Byte[] Encode();
    public Oid GetBagId();
    public bool TryEncode(Span`1<byte> destination, Int32& bytesWritten);
    internal void EncodeTo(AsnWriter writer);
    private AsnWriter EncodeToNewWriter();
}
public class System.Security.Cryptography.Pkcs.Pkcs12SafeContents : object {
    private ReadOnlyMemory`1<byte> _encrypted;
    private List`1<Pkcs12SafeBag> _bags;
    [CompilerGeneratedAttribute]
private Pkcs12ConfidentialityMode <ConfidentialityMode>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsReadOnly>k__BackingField;
    public Pkcs12ConfidentialityMode ConfidentialityMode { get; private set; }
    public bool IsReadOnly { get; }
    internal Pkcs12SafeContents(ReadOnlyMemory`1<byte> serialized);
    internal Pkcs12SafeContents(ContentInfoAsn contentInfoAsn);
    [CompilerGeneratedAttribute]
public Pkcs12ConfidentialityMode get_ConfidentialityMode();
    [CompilerGeneratedAttribute]
private void set_ConfidentialityMode(Pkcs12ConfidentialityMode value);
    [CompilerGeneratedAttribute]
public bool get_IsReadOnly();
    public void AddSafeBag(Pkcs12SafeBag safeBag);
    public Pkcs12CertBag AddCertificate(X509Certificate2 certificate);
    public Pkcs12KeyBag AddKeyUnencrypted(AsymmetricAlgorithm key);
    public Pkcs12SafeContentsBag AddNestedContents(Pkcs12SafeContents safeContents);
    public Pkcs12ShroudedKeyBag AddShroudedKey(AsymmetricAlgorithm key, Byte[] passwordBytes, PbeParameters pbeParameters);
    public Pkcs12ShroudedKeyBag AddShroudedKey(AsymmetricAlgorithm key, ReadOnlySpan`1<byte> passwordBytes, PbeParameters pbeParameters);
    public Pkcs12ShroudedKeyBag AddShroudedKey(AsymmetricAlgorithm key, string password, PbeParameters pbeParameters);
    public Pkcs12ShroudedKeyBag AddShroudedKey(AsymmetricAlgorithm key, ReadOnlySpan`1<char> password, PbeParameters pbeParameters);
    public Pkcs12SecretBag AddSecret(Oid secretType, ReadOnlyMemory`1<byte> secretValue);
    public void Decrypt(Byte[] passwordBytes);
    public void Decrypt(ReadOnlySpan`1<byte> passwordBytes);
    public void Decrypt(string password);
    public void Decrypt(ReadOnlySpan`1<char> password);
    private void Decrypt(ReadOnlySpan`1<char> password, ReadOnlySpan`1<byte> passwordBytes);
    public IEnumerable`1<Pkcs12SafeBag> GetBags();
    private static List`1<Pkcs12SafeBag> ReadBags(ReadOnlyMemory`1<byte> serialized);
    internal Byte[] Encrypt(ReadOnlySpan`1<char> password, ReadOnlySpan`1<byte> passwordBytes, PbeParameters pbeParameters);
    internal AsnWriter Encode();
    internal ContentInfoAsn EncodeToContentInfo();
}
public class System.Security.Cryptography.Pkcs.Pkcs12SafeContentsBag : Pkcs12SafeBag {
    [CompilerGeneratedAttribute]
private Pkcs12SafeContents <SafeContents>k__BackingField;
    public Pkcs12SafeContents SafeContents { get; private set; }
    private Pkcs12SafeContentsBag(ReadOnlyMemory`1<byte> encoded);
    [CompilerGeneratedAttribute]
public Pkcs12SafeContents get_SafeContents();
    [CompilerGeneratedAttribute]
private void set_SafeContents(Pkcs12SafeContents value);
    internal static Pkcs12SafeContentsBag Create(Pkcs12SafeContents copyFrom);
    internal static Pkcs12SafeContentsBag Decode(ReadOnlyMemory`1<byte> encodedValue);
}
public class System.Security.Cryptography.Pkcs.Pkcs12SecretBag : Pkcs12SafeBag {
    private Oid _secretTypeOid;
    private SecretBagAsn _decoded;
    public ReadOnlyMemory`1<byte> SecretValue { get; }
    private Pkcs12SecretBag(ReadOnlyMemory`1<byte> encodedBagValue);
    internal Pkcs12SecretBag(Oid secretTypeOid, ReadOnlyMemory`1<byte> secretValue);
    private Pkcs12SecretBag(SecretBagAsn secretBagAsn, ReadOnlyMemory`1<byte> encodedBagValue);
    public ReadOnlyMemory`1<byte> get_SecretValue();
    public Oid GetSecretType();
    private static Byte[] EncodeBagValue(Oid secretTypeOid, ReadOnlyMemory`1& secretValue);
    internal static Pkcs12SecretBag DecodeValue(ReadOnlyMemory`1<byte> bagValue);
}
public class System.Security.Cryptography.Pkcs.Pkcs12ShroudedKeyBag : Pkcs12SafeBag {
    public ReadOnlyMemory`1<byte> EncryptedPkcs8PrivateKey { get; }
    public Pkcs12ShroudedKeyBag(ReadOnlyMemory`1<byte> encryptedPkcs8PrivateKey, bool skipCopy);
    public ReadOnlyMemory`1<byte> get_EncryptedPkcs8PrivateKey();
}
public class System.Security.Cryptography.Pkcs.Pkcs8PrivateKeyInfo : object {
    [CompilerGeneratedAttribute]
private Oid <AlgorithmId>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<ReadOnlyMemory`1<byte>> <AlgorithmParameters>k__BackingField;
    [CompilerGeneratedAttribute]
private CryptographicAttributeObjectCollection <Attributes>k__BackingField;
    [CompilerGeneratedAttribute]
private ReadOnlyMemory`1<byte> <PrivateKeyBytes>k__BackingField;
    public Oid AlgorithmId { get; }
    public Nullable`1<ReadOnlyMemory`1<byte>> AlgorithmParameters { get; }
    public CryptographicAttributeObjectCollection Attributes { get; }
    public ReadOnlyMemory`1<byte> PrivateKeyBytes { get; }
    public Pkcs8PrivateKeyInfo(Oid algorithmId, Nullable`1<ReadOnlyMemory`1<byte>> algorithmParameters, ReadOnlyMemory`1<byte> privateKey, bool skipCopies);
    private Pkcs8PrivateKeyInfo(Oid algorithmId, Nullable`1<ReadOnlyMemory`1<byte>> algorithmParameters, ReadOnlyMemory`1<byte> privateKey, CryptographicAttributeObjectCollection attributes);
    [CompilerGeneratedAttribute]
public Oid get_AlgorithmId();
    [CompilerGeneratedAttribute]
public Nullable`1<ReadOnlyMemory`1<byte>> get_AlgorithmParameters();
    [CompilerGeneratedAttribute]
public CryptographicAttributeObjectCollection get_Attributes();
    [CompilerGeneratedAttribute]
public ReadOnlyMemory`1<byte> get_PrivateKeyBytes();
    public static Pkcs8PrivateKeyInfo Create(AsymmetricAlgorithm privateKey);
    public static Pkcs8PrivateKeyInfo Decode(ReadOnlyMemory`1<byte> source, Int32& bytesRead, bool skipCopy);
    public Byte[] Encode();
    public Byte[] Encrypt(ReadOnlySpan`1<char> password, PbeParameters pbeParameters);
    public Byte[] Encrypt(ReadOnlySpan`1<byte> passwordBytes, PbeParameters pbeParameters);
    public bool TryEncode(Span`1<byte> destination, Int32& bytesWritten);
    public bool TryEncrypt(ReadOnlySpan`1<char> password, PbeParameters pbeParameters, Span`1<byte> destination, Int32& bytesWritten);
    public bool TryEncrypt(ReadOnlySpan`1<byte> passwordBytes, PbeParameters pbeParameters, Span`1<byte> destination, Int32& bytesWritten);
    public static Pkcs8PrivateKeyInfo DecryptAndDecode(ReadOnlySpan`1<char> password, ReadOnlyMemory`1<byte> source, Int32& bytesRead);
    public static Pkcs8PrivateKeyInfo DecryptAndDecode(ReadOnlySpan`1<byte> passwordBytes, ReadOnlyMemory`1<byte> source, Int32& bytesRead);
    private AsnWriter WritePkcs8();
}
public class System.Security.Cryptography.Pkcs.Pkcs9AttributeObject : AsnEncodedData {
    public Oid Oid { get; }
    public Pkcs9AttributeObject(string oid, Byte[] encodedData);
    public Pkcs9AttributeObject(Oid oid, Byte[] encodedData);
    public Pkcs9AttributeObject(AsnEncodedData asnEncodedData);
    internal Pkcs9AttributeObject(Oid oid);
    public Oid get_Oid();
    public virtual void CopyFrom(AsnEncodedData asnEncodedData);
}
public class System.Security.Cryptography.Pkcs.Pkcs9ContentType : Pkcs9AttributeObject {
    private Oid modreq(System.Runtime.CompilerServices.IsVolatile) _lazyContentType;
    public Oid ContentType { get; }
    public Oid get_ContentType();
    public virtual void CopyFrom(AsnEncodedData asnEncodedData);
    private static Oid Decode(Byte[] rawData);
}
public class System.Security.Cryptography.Pkcs.Pkcs9DocumentDescription : Pkcs9AttributeObject {
    private String modreq(System.Runtime.CompilerServices.IsVolatile) _lazyDocumentDescription;
    public string DocumentDescription { get; }
    public Pkcs9DocumentDescription(string documentDescription);
    public Pkcs9DocumentDescription(Byte[] encodedDocumentDescription);
    public string get_DocumentDescription();
    public virtual void CopyFrom(AsnEncodedData asnEncodedData);
    private static string Decode(Byte[] rawData);
    private static Byte[] Encode(string documentDescription);
}
public class System.Security.Cryptography.Pkcs.Pkcs9DocumentName : Pkcs9AttributeObject {
    private String modreq(System.Runtime.CompilerServices.IsVolatile) _lazyDocumentName;
    public string DocumentName { get; }
    public Pkcs9DocumentName(string documentName);
    public Pkcs9DocumentName(Byte[] encodedDocumentName);
    public string get_DocumentName();
    public virtual void CopyFrom(AsnEncodedData asnEncodedData);
    private static string Decode(Byte[] rawData);
    private static Byte[] Encode(string documentName);
}
public class System.Security.Cryptography.Pkcs.Pkcs9LocalKeyId : Pkcs9AttributeObject {
    private Byte[] _lazyKeyId;
    public ReadOnlyMemory`1<byte> KeyId { get; }
    public Pkcs9LocalKeyId(Byte[] keyId);
    public Pkcs9LocalKeyId(ReadOnlySpan`1<byte> keyId);
    public ReadOnlyMemory`1<byte> get_KeyId();
    public virtual void CopyFrom(AsnEncodedData asnEncodedData);
    private static Byte[] Decode(Byte[] rawData);
}
public class System.Security.Cryptography.Pkcs.Pkcs9MessageDigest : Pkcs9AttributeObject {
    private Byte[] modreq(System.Runtime.CompilerServices.IsVolatile) _lazyMessageDigest;
    public Byte[] MessageDigest { get; }
    internal Pkcs9MessageDigest(ReadOnlySpan`1<byte> signatureDigest);
    public Byte[] get_MessageDigest();
    public virtual void CopyFrom(AsnEncodedData asnEncodedData);
    private static Byte[] Decode(Byte[] rawData);
}
public class System.Security.Cryptography.Pkcs.Pkcs9SigningTime : Pkcs9AttributeObject {
    private Nullable`1<DateTime> _lazySigningTime;
    public DateTime SigningTime { get; }
    public Pkcs9SigningTime(DateTime signingTime);
    public Pkcs9SigningTime(Byte[] encodedSigningTime);
    public DateTime get_SigningTime();
    public virtual void CopyFrom(AsnEncodedData asnEncodedData);
    private static DateTime Decode(Byte[] rawData);
    private static Byte[] Encode(DateTime signingTime);
}
public class System.Security.Cryptography.Pkcs.PublicKeyInfo : object {
    [CompilerGeneratedAttribute]
private AlgorithmIdentifier <Algorithm>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <KeyValue>k__BackingField;
    public AlgorithmIdentifier Algorithm { get; }
    public Byte[] KeyValue { get; }
    internal PublicKeyInfo(AlgorithmIdentifier algorithm, Byte[] keyValue);
    [CompilerGeneratedAttribute]
public AlgorithmIdentifier get_Algorithm();
    [CompilerGeneratedAttribute]
public Byte[] get_KeyValue();
}
public abstract class System.Security.Cryptography.Pkcs.RecipientInfo : object {
    [CompilerGeneratedAttribute]
private RecipientInfoType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private RecipientInfoPal <Pal>k__BackingField;
    public RecipientInfoType Type { get; }
    public int Version { get; }
    public SubjectIdentifier RecipientIdentifier { get; }
    public AlgorithmIdentifier KeyEncryptionAlgorithm { get; }
    public Byte[] EncryptedKey { get; }
    internal RecipientInfoPal Pal { get; }
    internal RecipientInfo(RecipientInfoType type, RecipientInfoPal pal);
    [CompilerGeneratedAttribute]
public RecipientInfoType get_Type();
    public abstract virtual int get_Version();
    public abstract virtual SubjectIdentifier get_RecipientIdentifier();
    public abstract virtual AlgorithmIdentifier get_KeyEncryptionAlgorithm();
    public abstract virtual Byte[] get_EncryptedKey();
    [CompilerGeneratedAttribute]
internal RecipientInfoPal get_Pal();
}
[DefaultMemberAttribute("Item")]
public class System.Security.Cryptography.Pkcs.RecipientInfoCollection : object {
    private RecipientInfo[] _recipientInfos;
    public RecipientInfo Item { get; }
    public int Count { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    internal RecipientInfoCollection(RecipientInfo recipientInfo);
    internal RecipientInfoCollection(ICollection`1<RecipientInfo> recipientInfos);
    public RecipientInfo get_Item(int index);
    public sealed virtual int get_Count();
    public RecipientInfoEnumerator GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void CopyTo(Array array, int index);
    public void CopyTo(RecipientInfo[] array, int index);
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
}
public class System.Security.Cryptography.Pkcs.RecipientInfoEnumerator : object {
    private RecipientInfoCollection _recipientInfos;
    private int _current;
    public RecipientInfo Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    internal RecipientInfoEnumerator(RecipientInfoCollection RecipientInfos);
    public RecipientInfo get_Current();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
}
public enum System.Security.Cryptography.Pkcs.RecipientInfoType : Enum {
    public int value__;
    public static RecipientInfoType Unknown;
    public static RecipientInfoType KeyTransport;
    public static RecipientInfoType KeyAgreement;
}
internal enum System.Security.Cryptography.Pkcs.Rfc3161RequestResponseStatus : Enum {
    public int value__;
    public static Rfc3161RequestResponseStatus Unknown;
    public static Rfc3161RequestResponseStatus Accepted;
    public static Rfc3161RequestResponseStatus DoesNotParse;
    public static Rfc3161RequestResponseStatus RequestFailed;
    public static Rfc3161RequestResponseStatus HashMismatch;
    public static Rfc3161RequestResponseStatus VersionTooNew;
    public static Rfc3161RequestResponseStatus NonceMismatch;
    public static Rfc3161RequestResponseStatus RequestedCertificatesMissing;
    public static Rfc3161RequestResponseStatus UnexpectedCertificates;
}
public class System.Security.Cryptography.Pkcs.Rfc3161TimestampRequest : object {
    private Byte[] _encodedBytes;
    private Rfc3161TimeStampReq _parsedData;
    public int Version { get; }
    public Oid HashAlgorithmId { get; }
    public Oid RequestedPolicyId { get; }
    public bool RequestSignerCertificate { get; }
    public bool HasExtensions { get; }
    public int get_Version();
    public ReadOnlyMemory`1<byte> GetMessageHash();
    public Oid get_HashAlgorithmId();
    public Oid get_RequestedPolicyId();
    public bool get_RequestSignerCertificate();
    public Nullable`1<ReadOnlyMemory`1<byte>> GetNonce();
    public bool get_HasExtensions();
    public X509ExtensionCollection GetExtensions();
    public Rfc3161TimestampToken ProcessResponse(ReadOnlyMemory`1<byte> source, Int32& bytesConsumed);
    private bool ProcessResponse(ReadOnlyMemory`1<byte> source, Rfc3161TimestampToken& token, Rfc3161RequestResponseStatus& status, Int32& bytesConsumed, bool shouldThrow);
    public Byte[] Encode();
    public bool TryEncode(Span`1<byte> destination, Int32& bytesWritten);
    public static Rfc3161TimestampRequest CreateFromSignerInfo(SignerInfo signerInfo, HashAlgorithmName hashAlgorithm, Oid requestedPolicyId, Nullable`1<ReadOnlyMemory`1<byte>> nonce, bool requestSignerCertificates, X509ExtensionCollection extensions);
    public static Rfc3161TimestampRequest CreateFromData(ReadOnlySpan`1<byte> data, HashAlgorithmName hashAlgorithm, Oid requestedPolicyId, Nullable`1<ReadOnlyMemory`1<byte>> nonce, bool requestSignerCertificates, X509ExtensionCollection extensions);
    public static Rfc3161TimestampRequest CreateFromHash(ReadOnlyMemory`1<byte> hash, HashAlgorithmName hashAlgorithm, Oid requestedPolicyId, Nullable`1<ReadOnlyMemory`1<byte>> nonce, bool requestSignerCertificates, X509ExtensionCollection extensions);
    public static Rfc3161TimestampRequest CreateFromHash(ReadOnlyMemory`1<byte> hash, Oid hashAlgorithmId, Oid requestedPolicyId, Nullable`1<ReadOnlyMemory`1<byte>> nonce, bool requestSignerCertificates, X509ExtensionCollection extensions);
    public static bool TryDecode(ReadOnlyMemory`1<byte> encodedBytes, Rfc3161TimestampRequest& request, Int32& bytesConsumed);
    private Rfc3161RequestResponseStatus ValidateResponse(Rfc3161TimestampToken token, bool shouldThrow);
}
public class System.Security.Cryptography.Pkcs.Rfc3161TimestampToken : object {
    private SignedCms _parsedDocument;
    private SignerInfo _signerInfo;
    private Nullable`1<EssCertId> _essCertId;
    private Nullable`1<EssCertIdV2> _essCertIdV2;
    [CompilerGeneratedAttribute]
private Rfc3161TimestampTokenInfo <TokenInfo>k__BackingField;
    public Rfc3161TimestampTokenInfo TokenInfo { get; private set; }
    [CompilerGeneratedAttribute]
public Rfc3161TimestampTokenInfo get_TokenInfo();
    [CompilerGeneratedAttribute]
private void set_TokenInfo(Rfc3161TimestampTokenInfo value);
    public SignedCms AsSignedCms();
    private X509Certificate2 GetSignerCertificate(X509Certificate2Collection extraCandidates);
    public bool VerifySignatureForData(ReadOnlySpan`1<byte> data, X509Certificate2& signerCertificate, X509Certificate2Collection extraCandidates);
    public bool VerifySignatureForHash(ReadOnlySpan`1<byte> hash, HashAlgorithmName hashAlgorithm, X509Certificate2& signerCertificate, X509Certificate2Collection extraCandidates);
    public bool VerifySignatureForHash(ReadOnlySpan`1<byte> hash, Oid hashAlgorithmId, X509Certificate2& signerCertificate, X509Certificate2Collection extraCandidates);
    public bool VerifySignatureForSignerInfo(SignerInfo signerInfo, X509Certificate2& signerCertificate, X509Certificate2Collection extraCandidates);
    internal bool VerifyHash(ReadOnlySpan`1<byte> hash, string hashAlgorithmId);
    private bool VerifyData(ReadOnlySpan`1<byte> data);
    private static bool CheckCertificate(X509Certificate2 tsaCertificate, SignerInfo signer, Nullable`1& certId, Nullable`1& certId2, Rfc3161TimestampTokenInfo tokenInfo);
    public static bool TryDecode(ReadOnlyMemory`1<byte> source, Rfc3161TimestampToken& token, Int32& bytesConsumed);
    private static bool IssuerAndSerialMatch(CadesIssuerSerial issuerSerial, string issuerDirectoryName, string serialNumber);
    private static bool IssuerAndSerialMatch(CadesIssuerSerial issuerSerial, ReadOnlySpan`1<byte> issuerDirectoryName, ReadOnlySpan`1<byte> serialNumber);
    private static bool CertMatchesIds(X509Certificate2 signerCert, Nullable`1& certId, Nullable`1& certId2);
    private static bool TryGetCertIds(SignerInfo signer, Nullable`1& certId, Nullable`1& certId2);
}
public class System.Security.Cryptography.Pkcs.Rfc3161TimestampTokenInfo : object {
    private Byte[] _encodedBytes;
    private Rfc3161TstInfo _parsedData;
    private Nullable`1<ReadOnlyMemory`1<byte>> _tsaNameBytes;
    public int Version { get; }
    public Oid PolicyId { get; }
    public Oid HashAlgorithmId { get; }
    public DateTimeOffset Timestamp { get; }
    public Nullable`1<long> AccuracyInMicroseconds { get; }
    public bool IsOrdering { get; }
    public bool HasExtensions { get; }
    public Rfc3161TimestampTokenInfo(Oid policyId, Oid hashAlgorithmId, ReadOnlyMemory`1<byte> messageHash, ReadOnlyMemory`1<byte> serialNumber, DateTimeOffset timestamp, Nullable`1<long> accuracyInMicroseconds, bool isOrdering, Nullable`1<ReadOnlyMemory`1<byte>> nonce, Nullable`1<ReadOnlyMemory`1<byte>> tsaName, X509ExtensionCollection extensions);
    private Rfc3161TimestampTokenInfo(Byte[] copiedBytes, Rfc3161TstInfo tstInfo);
    public int get_Version();
    public Oid get_PolicyId();
    public Oid get_HashAlgorithmId();
    public ReadOnlyMemory`1<byte> GetMessageHash();
    public ReadOnlyMemory`1<byte> GetSerialNumber();
    public DateTimeOffset get_Timestamp();
    public Nullable`1<long> get_AccuracyInMicroseconds();
    public bool get_IsOrdering();
    public Nullable`1<ReadOnlyMemory`1<byte>> GetNonce();
    public bool get_HasExtensions();
    public Nullable`1<ReadOnlyMemory`1<byte>> GetTimestampAuthorityName();
    public X509ExtensionCollection GetExtensions();
    public Byte[] Encode();
    public bool TryEncode(Span`1<byte> destination, Int32& bytesWritten);
    public static bool TryDecode(ReadOnlyMemory`1<byte> source, Rfc3161TimestampTokenInfo& timestampTokenInfo, Int32& bytesConsumed);
    private static bool TryDecode(ReadOnlyMemory`1<byte> source, bool ownsMemory, Rfc3161TstInfo& tstInfo, Int32& bytesConsumed, Byte[]& copiedBytes);
    private static Byte[] Encode(Oid policyId, Oid hashAlgorithmId, ReadOnlyMemory`1<byte> messageHash, ReadOnlyMemory`1<byte> serialNumber, DateTimeOffset timestamp, bool isOrdering, Nullable`1<long> accuracyInMicroseconds, Nullable`1<ReadOnlyMemory`1<byte>> nonce, Nullable`1<ReadOnlyMemory`1<byte>> tsaName, X509ExtensionCollection extensions);
}
internal class System.Security.Cryptography.Pkcs.SignedAttributesSet : ValueType {
    internal AttributeAsn[] SignedAttributes;
    internal void Encode(AsnWriter writer);
    internal static SignedAttributesSet Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static void Decode(AsnReader reader, SignedAttributesSet& decoded);
}
public class System.Security.Cryptography.Pkcs.SignedCms : object {
    private SignedDataAsn _signedData;
    private bool _hasData;
    private SubjectIdentifierType _signerIdentifierType;
    private Memory`1<byte> _heldData;
    private Nullable`1<ReadOnlyMemory`1<byte>> _heldContent;
    private bool _hasPkcs7Content;
    private string _contentType;
    [CompilerGeneratedAttribute]
private int <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private ContentInfo <ContentInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Detached>k__BackingField;
    private static Oid s_cmsDataOid;
    public int Version { get; private set; }
    public ContentInfo ContentInfo { get; private set; }
    public bool Detached { get; private set; }
    public X509Certificate2Collection Certificates { get; }
    public SignerInfoCollection SignerInfos { get; }
    public SignedCms(SubjectIdentifierType signerIdentifierType, ContentInfo contentInfo, bool detached);
    public SignedCms(SubjectIdentifierType signerIdentifierType);
    public SignedCms(ContentInfo contentInfo);
    public SignedCms(SubjectIdentifierType signerIdentifierType, ContentInfo contentInfo);
    public SignedCms(ContentInfo contentInfo, bool detached);
    private static SignedCms();
    [CompilerGeneratedAttribute]
public int get_Version();
    [CompilerGeneratedAttribute]
private void set_Version(int value);
    [CompilerGeneratedAttribute]
public ContentInfo get_ContentInfo();
    [CompilerGeneratedAttribute]
private void set_ContentInfo(ContentInfo value);
    [CompilerGeneratedAttribute]
public bool get_Detached();
    [CompilerGeneratedAttribute]
private void set_Detached(bool value);
    public X509Certificate2Collection get_Certificates();
    public SignerInfoCollection get_SignerInfos();
    public Byte[] Encode();
    public void Decode(Byte[] encodedMessage);
    internal void Decode(ReadOnlyMemory`1<byte> encodedMessage);
    internal static ReadOnlyMemory`1<byte> GetContent(ReadOnlyMemory`1<byte> wrappedContent, string contentType);
    public void ComputeSignature();
    public void ComputeSignature(CmsSigner signer);
    public void ComputeSignature(CmsSigner signer, bool silent);
    public void RemoveSignature(int index);
    public void RemoveSignature(SignerInfo signerInfo);
    internal ReadOnlySpan`1<byte> GetHashableContentSpan();
    internal void Reencode();
    private void UpdateMetadata();
    private void ConsiderDigestAddition(AlgorithmIdentifierAsn candidate);
    private void ConsiderDigestRemoval(AlgorithmIdentifierAsn candidate);
    internal void UpdateCertificatesFromAddition(X509Certificate2Collection newCerts);
    public void CheckSignature(bool verifySignatureOnly);
    public void CheckSignature(X509Certificate2Collection extraStore, bool verifySignatureOnly);
    private static void CheckSignatures(SignerInfoCollection signers, X509Certificate2Collection extraStore, bool verifySignatureOnly);
    public void CheckHash();
    internal SignedDataAsn& GetRawData();
    public void AddCertificate(X509Certificate2 certificate);
    public void RemoveCertificate(X509Certificate2 certificate);
    private static ContentInfo MakeEmptyContentInfo();
}
public class System.Security.Cryptography.Pkcs.SignerInfo : object {
    [CompilerGeneratedAttribute]
private int <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private SubjectIdentifier <SignerIdentifier>k__BackingField;
    private Oid _digestAlgorithm;
    private AttributeAsn[] _signedAttributes;
    private Nullable`1<ReadOnlyMemory`1<byte>> _signedAttributesMemory;
    private Oid _signatureAlgorithm;
    private Nullable`1<ReadOnlyMemory`1<byte>> _signatureAlgorithmParameters;
    private ReadOnlyMemory`1<byte> _signature;
    private AttributeAsn[] _unsignedAttributes;
    private SignedCms _document;
    private X509Certificate2 _signerCertificate;
    private SignerInfo _parentSignerInfo;
    private CryptographicAttributeObjectCollection _parsedSignedAttrs;
    private CryptographicAttributeObjectCollection _parsedUnsignedAttrs;
    public int Version { get; }
    public SubjectIdentifier SignerIdentifier { get; }
    public CryptographicAttributeObjectCollection SignedAttributes { get; }
    public CryptographicAttributeObjectCollection UnsignedAttributes { get; }
    public X509Certificate2 Certificate { get; }
    public SignerInfoCollection CounterSignerInfos { get; }
    public Oid DigestAlgorithm { get; }
    public Oid SignatureAlgorithm { get; }
    internal SignerInfo(SignerInfoAsn& parsedData, SignedCms ownerDocument);
    [CompilerGeneratedAttribute]
public int get_Version();
    [CompilerGeneratedAttribute]
public SubjectIdentifier get_SignerIdentifier();
    public CryptographicAttributeObjectCollection get_SignedAttributes();
    public CryptographicAttributeObjectCollection get_UnsignedAttributes();
    internal ReadOnlyMemory`1<byte> GetSignatureMemory();
    public Byte[] GetSignature();
    public X509Certificate2 get_Certificate();
    public SignerInfoCollection get_CounterSignerInfos();
    public Oid get_DigestAlgorithm();
    public Oid get_SignatureAlgorithm();
    public void AddUnsignedAttribute(AsnEncodedData unsignedAttribute);
    public void RemoveUnsignedAttribute(AsnEncodedData unsignedAttribute);
    private SignerInfoCollection GetCounterSigners(AttributeAsn[] unsignedAttrs);
    public void ComputeCounterSignature();
    public void ComputeCounterSignature(CmsSigner signer);
    public void RemoveCounterSignature(int index);
    public void RemoveCounterSignature(SignerInfo counterSignerInfo);
    public void CheckSignature(bool verifySignatureOnly);
    public void CheckSignature(X509Certificate2Collection extraStore, bool verifySignatureOnly);
    public void CheckHash();
    private bool CheckHash(bool compatMode);
    private X509Certificate2 FindSignerCertificate();
    private static X509Certificate2 FindSignerCertificate(SubjectIdentifier signerIdentifier, X509Certificate2Collection extraStore);
    private IncrementalHash PrepareDigest(bool compatMode);
    private void Verify(X509Certificate2Collection extraStore, X509Certificate2 certificate, bool verifySignatureOnly);
    private bool VerifySignature(CmsSignature signatureProcessor, X509Certificate2 certificate, bool compatMode);
    private HashAlgorithmName GetDigestAlgorithm();
    internal static CryptographicAttributeObjectCollection MakeAttributeCollection(AttributeAsn[] attributes);
    private static CryptographicAttributeObject MakeAttribute(AttributeAsn attribute);
    private static int FindAttributeIndexByOid(AttributeAsn[] attributes, Oid oid, int startIndex);
    private static int FindAttributeValueIndexByEncodedData(ReadOnlyMemory`1[] attributeValues, ReadOnlySpan`1<byte> asnEncodedData, Boolean& isOnlyValue);
    private static ValueTuple`2<int, int> FindAttributeLocation(AttributeAsn[] attributes, AsnEncodedData attribute, Boolean& isOnlyValue);
}
[DefaultMemberAttribute("Item")]
public class System.Security.Cryptography.Pkcs.SignerInfoCollection : object {
    private SignerInfo[] _signerInfos;
    public SignerInfo Item { get; }
    public int Count { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    internal SignerInfoCollection(SignerInfo[] signerInfos);
    internal SignerInfoCollection(SignerInfoAsn[] signedDataSignerInfos, SignedCms ownerDocument);
    public SignerInfo get_Item(int index);
    public sealed virtual int get_Count();
    public SignerInfoEnumerator GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void CopyTo(Array array, int index);
    public void CopyTo(SignerInfo[] array, int index);
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    internal int FindIndexForSigner(SignerInfo signer);
}
public class System.Security.Cryptography.Pkcs.SignerInfoEnumerator : object {
    private SignerInfoCollection _signerInfos;
    private int _position;
    public SignerInfo Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    internal SignerInfoEnumerator(SignerInfoCollection signerInfos);
    public SignerInfo get_Current();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
}
public class System.Security.Cryptography.Pkcs.SubjectIdentifier : object {
    private static string DummySignerSubjectName;
    internal static Byte[] DummySignerEncodedValue;
    [CompilerGeneratedAttribute]
private SubjectIdentifierType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Value>k__BackingField;
    public SubjectIdentifierType Type { get; }
    public object Value { get; }
    internal SubjectIdentifier(SubjectIdentifierType type, object value);
    internal SubjectIdentifier(SignerIdentifierAsn signerIdentifierAsn);
    internal SubjectIdentifier(Nullable`1<IssuerAndSerialNumberAsn> issuerAndSerialNumber, Nullable`1<ReadOnlyMemory`1<byte>> subjectKeyIdentifier);
    private static SubjectIdentifier();
    [CompilerGeneratedAttribute]
public SubjectIdentifierType get_Type();
    [CompilerGeneratedAttribute]
public object get_Value();
    public bool MatchesCertificate(X509Certificate2 certificate);
}
public class System.Security.Cryptography.Pkcs.SubjectIdentifierOrKey : object {
    [CompilerGeneratedAttribute]
private SubjectIdentifierOrKeyType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Value>k__BackingField;
    public SubjectIdentifierOrKeyType Type { get; }
    public object Value { get; }
    internal SubjectIdentifierOrKey(SubjectIdentifierOrKeyType type, object value);
    [CompilerGeneratedAttribute]
public SubjectIdentifierOrKeyType get_Type();
    [CompilerGeneratedAttribute]
public object get_Value();
}
public enum System.Security.Cryptography.Pkcs.SubjectIdentifierOrKeyType : Enum {
    public int value__;
    public static SubjectIdentifierOrKeyType Unknown;
    public static SubjectIdentifierOrKeyType IssuerAndSerialNumber;
    public static SubjectIdentifierOrKeyType SubjectKeyIdentifier;
    public static SubjectIdentifierOrKeyType PublicKeyInfo;
}
public enum System.Security.Cryptography.Pkcs.SubjectIdentifierType : Enum {
    public int value__;
    public static SubjectIdentifierType Unknown;
    public static SubjectIdentifierType IssuerAndSerialNumber;
    public static SubjectIdentifierType SubjectKeyIdentifier;
    public static SubjectIdentifierType NoSignature;
}
internal class System.Security.Cryptography.SafeHashHandle : SafeHandleZeroOrMinusOneIsInvalid {
    private SafeProvHandle _parent;
    internal static SafeHashHandle InvalidHandle { get; }
    internal void SetParent(SafeProvHandle parent);
    internal static SafeHashHandle get_InvalidHandle();
    protected virtual void Dispose(bool disposing);
    protected virtual bool ReleaseHandle();
}
internal class System.Security.Cryptography.SafeKeyHandle : SafeHandleZeroOrMinusOneIsInvalid {
    private int _keySpec;
    private bool _fPublicOnly;
    private SafeProvHandle _parent;
    internal int KeySpec { get; internal set; }
    internal bool PublicOnly { get; internal set; }
    internal static SafeKeyHandle InvalidHandle { get; }
    internal int get_KeySpec();
    internal void set_KeySpec(int value);
    internal bool get_PublicOnly();
    internal void set_PublicOnly(bool value);
    internal void SetParent(SafeProvHandle parent);
    internal static SafeKeyHandle get_InvalidHandle();
    protected virtual void Dispose(bool disposing);
    protected virtual bool ReleaseHandle();
}
internal class System.Security.Cryptography.SafeProvHandle : SafeHandleZeroOrMinusOneIsInvalid {
    private string _containerName;
    private string _providerName;
    private int _type;
    private UInt32 _flags;
    private bool _fPersistKeyInCsp;
    internal string ContainerName { get; internal set; }
    internal string ProviderName { get; internal set; }
    internal int Types { get; internal set; }
    internal UInt32 Flags { get; internal set; }
    internal bool PersistKeyInCsp { get; internal set; }
    internal static SafeProvHandle InvalidHandle { get; }
    internal string get_ContainerName();
    internal void set_ContainerName(string value);
    internal string get_ProviderName();
    internal void set_ProviderName(string value);
    internal int get_Types();
    internal void set_Types(int value);
    internal UInt32 get_Flags();
    internal void set_Flags(UInt32 value);
    internal bool get_PersistKeyInCsp();
    internal void set_PersistKeyInCsp(bool value);
    internal static SafeProvHandle get_InvalidHandle();
    protected virtual void Dispose(bool disposing);
    protected virtual bool ReleaseHandle();
}
public class System.Security.Cryptography.Xml.X509IssuerSerial : ValueType {
    [CompilerGeneratedAttribute]
private string <IssuerName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SerialNumber>k__BackingField;
    public string IssuerName { get; public set; }
    public string SerialNumber { get; public set; }
    internal X509IssuerSerial(string issuerName, string serialNumber);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_IssuerName();
    [CompilerGeneratedAttribute]
public void set_IssuerName(string value);
    [CompilerGeneratedAttribute]
[IsReadOnlyAttribute]
public string get_SerialNumber();
    [CompilerGeneratedAttribute]
public void set_SerialNumber(string value);
}
internal static class System.SR : object {
    private static ResourceManager s_resourceManager;
    internal static ResourceManager ResourceManager { get; }
    internal static string Arg_EmptyOrNullString { get; }
    internal static string Arg_RankMultiDimNotSupported { get; }
    internal static string Argument_EncodeDestinationTooSmall { get; }
    internal static string Argument_InvalidOffLen { get; }
    internal static string Argument_InvalidOidValue { get; }
    internal static string Argument_InvalidValue { get; }
    internal static string ArgumentOutOfRange_Index { get; }
    internal static string ArgumentOutOfRange_NeedPosNum { get; }
    internal static string Cryptography_AlgKdfRequiresChars { get; }
    internal static string Cryptography_Asn_EnumeratedValueRequiresNonFlagsEnum { get; }
    internal static string Cryptography_Asn_NamedBitListRequiresFlagsEnum { get; }
    internal static string Cryptography_Asn_NamedBitListValueTooBig { get; }
    internal static string Cryptography_Asn_UniversalValueIsFixed { get; }
    internal static string Cryptography_Asn_UnusedBitCountRange { get; }
    internal static string Cryptography_AsnWriter_EncodeUnbalancedStack { get; }
    internal static string Cryptography_AsnWriter_PopWrongTag { get; }
    internal static string Cryptography_BadHashValue { get; }
    internal static string Cryptography_BadSignature { get; }
    internal static string Cryptography_Cms_CannotDetermineSignatureAlgorithm { get; }
    internal static string Cryptography_Cms_IncompleteCertChain { get; }
    internal static string Cryptography_Cms_Invalid_Originator_Identifier_Choice { get; }
    internal static string Cryptography_Cms_Invalid_Subject_Identifier_Type { get; }
    internal static string Cryptography_Cms_InvalidMessageType { get; }
    internal static string Cryptography_Cms_InvalidSignerHashForSignatureAlg { get; }
    internal static string Cryptography_Cms_Key_Agree_Date_Not_Available { get; }
    internal static string Cryptography_Cms_MessageNotEncrypted { get; }
    internal static string Cryptography_Cms_MessageNotSigned { get; }
    internal static string Cryptography_Cms_MissingAuthenticatedAttribute { get; }
    internal static string Cryptography_Cms_NoCounterCounterSigner { get; }
    internal static string Cryptography_Cms_NoRecipients { get; }
    internal static string Cryptography_Cms_NoSignerCert { get; }
    internal static string Cryptography_Cms_NoSignerCertSilent { get; }
    internal static string Cryptography_Cms_NoSignerAtIndex { get; }
    internal static string Cryptography_Cms_RecipientNotFound { get; }
    internal static string Cryptography_Cms_RecipientType_NotSupported { get; }
    internal static string Cryptography_Cms_Sign_Empty_Content { get; }
    internal static string Cryptography_Cms_Sign_No_Signature_First_Signer { get; }
    internal static string Cryptography_Cms_SignerNotFound { get; }
    internal static string Cryptography_Cms_Signing_RequiresPrivateKey { get; }
    internal static string Cryptography_Cms_Ktri_RSARequired { get; }
    internal static string Cryptography_Cms_Recipient_RSARequired_RSAPaddingModeSupplied { get; }
    internal static string Cryptography_Cms_TrustFailure { get; }
    internal static string Cryptography_Cms_UnknownAlgorithm { get; }
    internal static string Cryptography_Cms_UnknownKeySpec { get; }
    internal static string Cryptography_Cms_WrongKeyUsage { get; }
    internal static string Cryptography_NotValidPublicOrPrivateKey { get; }
    internal static string Cryptography_Pkcs12_CannotProcessEncryptedSafeContents { get; }
    internal static string Cryptography_Pkcs12_CertBagNotX509 { get; }
    internal static string Cryptography_Pkcs12_PfxIsSealed { get; }
    internal static string Cryptography_Pkcs12_PfxMustBeSealed { get; }
    internal static string Cryptography_Pkcs12_SafeContentsIsEncrypted { get; }
    internal static string Cryptography_Pkcs12_SafeContentsIsReadOnly { get; }
    internal static string Cryptography_Pkcs12_WrongModeForDecrypt { get; }
    internal static string Cryptography_Pkcs12_WrongModeForVerify { get; }
    internal static string Cryptography_Pkcs_InvalidSignatureParameters { get; }
    internal static string Cryptography_Pkcs8_EncryptedReadFailed { get; }
    internal static string Cryptography_Pkcs9_AttributeMismatch { get; }
    internal static string Cryptography_Pkcs9_MultipleSigningTimeNotAllowed { get; }
    internal static string Cryptography_Pkcs_PssParametersMissing { get; }
    internal static string Cryptography_Pkcs_PssParametersHashMismatch { get; }
    internal static string Cryptography_Pkcs_PssParametersMgfHashMismatch { get; }
    internal static string Cryptography_Pkcs_PssParametersMgfNotSupported { get; }
    internal static string Cryptography_Pkcs_PssParametersSaltMismatch { get; }
    internal static string Cryptography_TimestampReq_BadNonce { get; }
    internal static string Cryptography_TimestampReq_BadResponse { get; }
    internal static string Cryptography_TimestampReq_Failure { get; }
    internal static string Cryptography_TimestampReq_NoCertFound { get; }
    internal static string Cryptography_TimestampReq_UnexpectedCertFound { get; }
    internal static string InvalidOperation_DuplicateItemNotAllowed { get; }
    internal static string InvalidOperation_WrongOidInAsnCollection { get; }
    internal static string PlatformNotSupported_CryptographyPkcs { get; }
    internal static string Cryptography_Der_Invalid_Encoding { get; }
    internal static string Cryptography_Invalid_IA5String { get; }
    internal static string Cryptography_UnknownAlgorithmIdentifier { get; }
    internal static string Cryptography_UnknownHashAlgorithm { get; }
    internal static string Cryptography_WriteEncodedValue_OneValueAtATime { get; }
    internal static string Cryptography_Cms_NoAttributeFound { get; }
    internal static string Cryptography_Cms_NoCertificateFound { get; }
    internal static string Cryptography_Cms_CertificateAlreadyInCollection { get; }
    private static bool UsingResourceKeys();
    internal static string GetResourceString(string resourceKey, string defaultString);
    internal static string Format(string resourceFormat, object p1);
    internal static string Format(string resourceFormat, object p1, object p2);
    internal static string Format(string resourceFormat, object p1, object p2, object p3);
    internal static string Format(string resourceFormat, Object[] args);
    internal static string Format(IFormatProvider provider, string resourceFormat, object p1);
    internal static string Format(IFormatProvider provider, string resourceFormat, object p1, object p2);
    internal static string Format(IFormatProvider provider, string resourceFormat, object p1, object p2, object p3);
    internal static string Format(IFormatProvider provider, string resourceFormat, Object[] args);
    internal static ResourceManager get_ResourceManager();
    internal static string get_Arg_EmptyOrNullString();
    internal static string get_Arg_RankMultiDimNotSupported();
    internal static string get_Argument_EncodeDestinationTooSmall();
    internal static string get_Argument_InvalidOffLen();
    internal static string get_Argument_InvalidOidValue();
    internal static string get_Argument_InvalidValue();
    internal static string get_ArgumentOutOfRange_Index();
    internal static string get_ArgumentOutOfRange_NeedPosNum();
    internal static string get_Cryptography_AlgKdfRequiresChars();
    internal static string get_Cryptography_Asn_EnumeratedValueRequiresNonFlagsEnum();
    internal static string get_Cryptography_Asn_NamedBitListRequiresFlagsEnum();
    internal static string get_Cryptography_Asn_NamedBitListValueTooBig();
    internal static string get_Cryptography_Asn_UniversalValueIsFixed();
    internal static string get_Cryptography_Asn_UnusedBitCountRange();
    internal static string get_Cryptography_AsnWriter_EncodeUnbalancedStack();
    internal static string get_Cryptography_AsnWriter_PopWrongTag();
    internal static string get_Cryptography_BadHashValue();
    internal static string get_Cryptography_BadSignature();
    internal static string get_Cryptography_Cms_CannotDetermineSignatureAlgorithm();
    internal static string get_Cryptography_Cms_IncompleteCertChain();
    internal static string get_Cryptography_Cms_Invalid_Originator_Identifier_Choice();
    internal static string get_Cryptography_Cms_Invalid_Subject_Identifier_Type();
    internal static string get_Cryptography_Cms_InvalidMessageType();
    internal static string get_Cryptography_Cms_InvalidSignerHashForSignatureAlg();
    internal static string get_Cryptography_Cms_Key_Agree_Date_Not_Available();
    internal static string get_Cryptography_Cms_MessageNotEncrypted();
    internal static string get_Cryptography_Cms_MessageNotSigned();
    internal static string get_Cryptography_Cms_MissingAuthenticatedAttribute();
    internal static string get_Cryptography_Cms_NoCounterCounterSigner();
    internal static string get_Cryptography_Cms_NoRecipients();
    internal static string get_Cryptography_Cms_NoSignerCert();
    internal static string get_Cryptography_Cms_NoSignerCertSilent();
    internal static string get_Cryptography_Cms_NoSignerAtIndex();
    internal static string get_Cryptography_Cms_RecipientNotFound();
    internal static string get_Cryptography_Cms_RecipientType_NotSupported();
    internal static string get_Cryptography_Cms_Sign_Empty_Content();
    internal static string get_Cryptography_Cms_Sign_No_Signature_First_Signer();
    internal static string get_Cryptography_Cms_SignerNotFound();
    internal static string get_Cryptography_Cms_Signing_RequiresPrivateKey();
    internal static string get_Cryptography_Cms_Ktri_RSARequired();
    internal static string get_Cryptography_Cms_Recipient_RSARequired_RSAPaddingModeSupplied();
    internal static string get_Cryptography_Cms_TrustFailure();
    internal static string get_Cryptography_Cms_UnknownAlgorithm();
    internal static string get_Cryptography_Cms_UnknownKeySpec();
    internal static string get_Cryptography_Cms_WrongKeyUsage();
    internal static string get_Cryptography_NotValidPublicOrPrivateKey();
    internal static string get_Cryptography_Pkcs12_CannotProcessEncryptedSafeContents();
    internal static string get_Cryptography_Pkcs12_CertBagNotX509();
    internal static string get_Cryptography_Pkcs12_PfxIsSealed();
    internal static string get_Cryptography_Pkcs12_PfxMustBeSealed();
    internal static string get_Cryptography_Pkcs12_SafeContentsIsEncrypted();
    internal static string get_Cryptography_Pkcs12_SafeContentsIsReadOnly();
    internal static string get_Cryptography_Pkcs12_WrongModeForDecrypt();
    internal static string get_Cryptography_Pkcs12_WrongModeForVerify();
    internal static string get_Cryptography_Pkcs_InvalidSignatureParameters();
    internal static string get_Cryptography_Pkcs8_EncryptedReadFailed();
    internal static string get_Cryptography_Pkcs9_AttributeMismatch();
    internal static string get_Cryptography_Pkcs9_MultipleSigningTimeNotAllowed();
    internal static string get_Cryptography_Pkcs_PssParametersMissing();
    internal static string get_Cryptography_Pkcs_PssParametersHashMismatch();
    internal static string get_Cryptography_Pkcs_PssParametersMgfHashMismatch();
    internal static string get_Cryptography_Pkcs_PssParametersMgfNotSupported();
    internal static string get_Cryptography_Pkcs_PssParametersSaltMismatch();
    internal static string get_Cryptography_TimestampReq_BadNonce();
    internal static string get_Cryptography_TimestampReq_BadResponse();
    internal static string get_Cryptography_TimestampReq_Failure();
    internal static string get_Cryptography_TimestampReq_NoCertFound();
    internal static string get_Cryptography_TimestampReq_UnexpectedCertFound();
    internal static string get_InvalidOperation_DuplicateItemNotAllowed();
    internal static string get_InvalidOperation_WrongOidInAsnCollection();
    internal static string get_PlatformNotSupported_CryptographyPkcs();
    internal static string get_Cryptography_Der_Invalid_Encoding();
    internal static string get_Cryptography_Invalid_IA5String();
    internal static string get_Cryptography_UnknownAlgorithmIdentifier();
    internal static string get_Cryptography_UnknownHashAlgorithm();
    internal static string get_Cryptography_WriteEncodedValue_OneValueAtATime();
    internal static string get_Cryptography_Cms_NoAttributeFound();
    internal static string get_Cryptography_Cms_NoCertificateFound();
    internal static string get_Cryptography_Cms_CertificateAlreadyInCollection();
}
