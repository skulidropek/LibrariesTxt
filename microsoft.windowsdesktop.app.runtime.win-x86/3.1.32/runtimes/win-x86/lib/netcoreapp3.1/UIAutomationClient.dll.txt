internal static class FxResources.UIAutomationClient.SR : object {
}
internal static class Microsoft.Internal.BuildInfo : object {
    internal static string WCP_VERSION;
    internal static string WCP_VERSION_SUFFIX;
    internal static string MIL_VERSION_SUFFIX;
    internal static string WCP_PUBLIC_KEY_TOKEN;
    internal static string WCP_PUBLIC_KEY_STRING;
    internal static string DEVDIV_PUBLIC_KEY_STRING;
    internal static string DEVDIV_PUBLIC_KEY_TOKEN;
    internal static string DirectWriteForwarder;
    internal static string PresentationCore;
    internal static string PresentationCFFRasterizer;
    internal static string PresentationFramework;
    internal static string PresentationUI;
    internal static string PresentationFrameworkLuna;
    internal static string PresentationFrameworkRoyale;
    internal static string PresentationFrameworkAero;
    internal static string PresentationFrameworkAero2;
    internal static string PresentationFrameworkAeroLite;
    internal static string PresentationFrameworkClassic;
    internal static string PresentationFrameworkSystemCore;
    internal static string PresentationFrameworkSystemData;
    internal static string PresentationFrameworkSystemDrawing;
    internal static string PresentationFrameworkSystemXml;
    internal static string PresentationFrameworkSystemXmlLinq;
    internal static string ReachFramework;
    internal static string SystemPrinting;
    internal static string SystemXaml;
    internal static string WindowsFormsIntegration;
    internal static string SystemWindowsPresentation;
    internal static string SystemWindowsControlsRibbon;
}
internal static class Microsoft.Internal.DllImport : object {
    internal static string PresentationNative;
    internal static string PresentationCFFRasterizerNative;
    internal static string MilCore;
    internal static string UIAutomationCore;
    internal static string Wininet;
    internal static string WindowsCodecs;
    internal static string WindowsCodecsExt;
    internal static string Mscms;
    internal static string PrntvPt;
    internal static string Ole32;
    internal static string User32;
    internal static string NInput;
}
internal class MS.Internal.Automation.Accessible : object {
    private IntPtr _hwnd;
    private IAccessible _acc;
    private object _child;
    internal int State { get; }
    internal IntPtr Window { get; }
    internal Accessible(IAccessible acc, object child);
    internal static Accessible Create(IntPtr hwnd, int idObject, int idChild);
    internal int get_State();
    internal IntPtr get_Window();
    internal static bool CompareClass(IntPtr hwnd, string szClass);
    internal static bool IsComboDropdown(IntPtr hwnd);
    internal static bool IsStatic(IntPtr hwnd);
    private bool IsCriticalMSAAException(Exception e);
}
internal class MS.Internal.Automation.AutomationAttributeInfo : object {
    private AutomationTextAttribute _id;
    private Type _type;
    private AutomationPropertyConverter _converter;
    internal AutomationTextAttribute ID { get; }
    internal AutomationPropertyConverter ObjectConverter { get; }
    internal Type Type { get; }
    internal AutomationAttributeInfo(AutomationPropertyConverter converter, AutomationTextAttribute id, Type type);
    internal AutomationTextAttribute get_ID();
    internal AutomationPropertyConverter get_ObjectConverter();
    internal Type get_Type();
}
internal class MS.Internal.Automation.AutomationPatternInfo : object {
    private AutomationPattern _id;
    private AutomationProperty[] _properties;
    private WrapObjectClientSide _clientSideWrapper;
    internal AutomationPattern ID { get; }
    internal AutomationProperty[] Properties { get; }
    internal WrapObjectClientSide ClientSideWrapper { get; }
    public AutomationPatternInfo(AutomationPattern id, AutomationProperty[] properties, WrapObjectClientSide clientSideWrapper);
    internal AutomationPattern get_ID();
    internal AutomationProperty[] get_Properties();
    internal WrapObjectClientSide get_ClientSideWrapper();
}
internal class MS.Internal.Automation.AutomationPropertyConverter : MulticastDelegate {
    public AutomationPropertyConverter(object object, IntPtr method);
    public virtual object Invoke(object valueAsObject);
    public virtual IAsyncResult BeginInvoke(object valueAsObject, AsyncCallback callback, object object);
    public virtual object EndInvoke(IAsyncResult result);
}
internal class MS.Internal.Automation.AutomationPropertyInfo : object {
    private AutomationProperty _id;
    private Type _type;
    private object _defaultValue;
    private AutomationPropertyConverter _converter;
    internal AutomationProperty ID { get; }
    internal object DefaultValue { get; }
    internal AutomationPropertyConverter ObjectConverter { get; }
    internal Type Type { get; }
    internal AutomationPropertyInfo(AutomationPropertyConverter converter, AutomationProperty id, Type type, object defaultValue);
    internal AutomationProperty get_ID();
    internal object get_DefaultValue();
    internal AutomationPropertyConverter get_ObjectConverter();
    internal Type get_Type();
}
internal class MS.Internal.Automation.BoundingRectTracker : WinEventWrap {
    private static RECT _emptyRect;
    private RECT _lastRect;
    private IntPtr _lastHwnd;
    private static BoundingRectTracker();
    internal virtual void WinEventProc(int eventId, IntPtr hwnd, int idObject, int idChild, UInt32 eventTime);
    private void OnHide(IntPtr hwnd, int idObject, int idChild);
    private void OnLocationChange(IntPtr hwnd, int idObject, int idChild);
    private void HandleBoundingRectChange(IntPtr hwnd);
    private static bool Compare(RECT rc1, RECT rc2);
}
internal static class MS.Internal.Automation.CacheHelper : object {
    internal static AutomationElement BuildAutomationElementsFromResponse(UiaCacheRequest cacheRequest, UiaCacheResponse response);
    private static AutomationElement ParseTreeDescription(string treeDescription, Object[0...,0...] properties, Int32& index, Int32& propIndex, UiaCacheRequest cacheRequest, bool askedForChildren, bool askedForDescendants);
}
internal class MS.Internal.Automation.CalloutQueueItem : QueueItem {
    internal Delegate _clientCallback;
    internal UiaCacheResponse _cacheResponse;
    internal UiaCacheRequest _cacheRequest;
    internal AutomationEventArgs _e;
    internal CalloutQueueItem(Delegate clientCallback, UiaCacheResponse cacheResponse, AutomationEventArgs e, UiaCacheRequest cacheRequest);
    internal virtual void Process();
}
internal static class MS.Internal.Automation.ClientEventManager : object {
    private static AutomationEvent[] _doNotShouldAdviseProviders;
    private static WinEventWrap[] _winEventTrackers;
    private static QueueProcessor _callbackQueue;
    private static bool _isBkgrdThreadRunning;
    private static ArrayList _listeners;
    private static object _classLock;
    internal static QueueProcessor CBQ { get; }
    private static ClientEventManager();
    internal static void AddFocusListener(Delegate eventCallback, EventListener l);
    internal static void RemoveFocusListener(Delegate eventCallback);
    internal static void AddListener(AutomationElement rawEl, Delegate eventCallback, EventListener l);
    private static Int32[] PropertyArrayToIntArray(AutomationProperty[] properties);
    internal static void RemoveListener(AutomationEvent eventId, AutomationElement el, Delegate eventCallback);
    private static void RemovePropertyTracker(AutomationProperty property, Tracker tracker);
    private static void RemoveMenuListeners();
    internal static void RemoveAllListeners();
    internal static QueueProcessor get_CBQ();
    private static void CheckStartCallbackQueueing();
    private static void CheckStopCallbackQueueing();
    private static void StopWinEventTracking();
    internal static void RaiseEventInThisClientOnly(AutomationEvent eventId, AutomationElement rawEl, AutomationEventArgs e);
    internal static void RaiseEventInThisClientOnly(AutomationEvent eventId, Int32[] rid, AutomationEventArgs e);
    private static WinEventWrap GetNewRootTracker(Tracker idx);
    private static void AddRootListener(Tracker idx, Delegate eventCallback, EventListener l);
    private static void RemoveRootListener(AutomationEvent eventId, Tracker idx, Delegate eventCallback);
    private static void AddWinEventListener(Tracker idx, WinEventWrap eventWrapper);
    private static void RemoveWinEventListener(Tracker idx, Delegate eventCallback);
    private static bool HasProperty(AutomationProperty p, AutomationProperty[] properties);
    private static void OnWindowHideOrClose(IntPtr hwnd, AutomationElement rawEl, Int32[] runtimeId);
    private static void OnWindowShowOrOpen(IntPtr hwnd, AutomationElement rawEl);
    private static void OnMenuEvent(AutomationElement rawEl, bool menuHasOpened);
    private static bool ShouldAdviseProviders(AutomationEvent eventId);
}
internal class MS.Internal.Automation.ClientSideQueueItem : QueueItem {
    private Delegate _clientCallback;
    private AutomationElement _srcEl;
    private UiaCacheRequest _request;
    private AutomationEventArgs _e;
    internal ClientSideQueueItem(Delegate clientCallback, AutomationElement srcEl, UiaCacheRequest request, AutomationEventArgs e);
    internal virtual void Process();
}
internal class MS.Internal.Automation.EventListener : object {
    private AutomationEvent _eventId;
    private TreeScope _scope;
    private AutomationProperty[] _properties;
    private UiaCacheRequest _cacheRequest;
    internal AutomationEvent EventId { get; }
    internal AutomationProperty[] Properties { get; }
    internal TreeScope TreeScope { get; }
    internal UiaCacheRequest CacheRequest { get; }
    internal EventListener(AutomationEvent eventId, TreeScope scope, AutomationProperty[] properties, UiaCacheRequest cacheRequest);
    internal AutomationEvent get_EventId();
    internal AutomationProperty[] get_Properties();
    internal TreeScope get_TreeScope();
    internal UiaCacheRequest get_CacheRequest();
}
internal class MS.Internal.Automation.EventListenerClientSide : MarshalByRefObject {
    private EventListener _eventListener;
    private AutomationElement _refElement;
    private Int32[] _refRid;
    private Delegate _clientCallback;
    private UiaEventCallback _callbackDelegate;
    private GCHandle _gch;
    private SafeEventHandle _eventHandle;
    internal EventListener EventListener { get; }
    internal Delegate ClientCallback { get; }
    internal AutomationElement AutomationElement { get; }
    internal UiaEventCallback CallbackDelegate { get; }
    internal SafeEventHandle EventHandle { get; internal set; }
    internal EventListenerClientSide(AutomationElement elRoot, Delegate clientCallback, EventListener l);
    internal void Dispose();
    internal void OnEvent(IntPtr argsAddr, Object[0...,0...] requestedData, string treeStructure);
    internal bool IsListeningFor(AutomationEvent eventId, AutomationElement el, Delegate clientCallback);
    internal bool WithinScope(AutomationElement el);
    internal bool WithinScope(Int32[] rid);
    internal EventListener get_EventListener();
    internal Delegate get_ClientCallback();
    internal AutomationElement get_AutomationElement();
    internal UiaEventCallback get_CallbackDelegate();
    internal SafeEventHandle get_EventHandle();
    internal void set_EventHandle(SafeEventHandle value);
    private bool IsChildOf(AutomationElement elPossibleParent, AutomationElement el);
}
internal class MS.Internal.Automation.FocusTracker : WinEventWrap {
    private static Int32[] _eventIds;
    private Accessible _accCurrent;
    private Accessible _accLastBeforeMenu;
    private IntPtr _hwndLastBeforeMenu;
    private int _idLastObject;
    private int _idLastChild;
    private bool _fInMenu;
    private static FocusTracker();
    internal virtual void WinEventProc(int eventId, IntPtr hwnd, int idObject, int idChild, UInt32 eventTime);
    private void HandleFocusChange(IntPtr hwnd, Accessible acc, int idObject, int idChild, UInt32 eventTime);
    private AutomationElement GetFocusedElementFromWinEvent(IntPtr hwnd, int idObject, int idChild);
    private void OnEventObjectFocus(int eventId, IntPtr hwnd, int idObject, int idChild, UInt32 eventTime);
    private void OnEventSystemMenuStart(int eventId, IntPtr hwnd, int idObject, int idChild, UInt32 eventTime);
    private void OnEventSystemMenuEnd(int eventId, IntPtr hwnd, int idObject, int idChild, UInt32 eventTime);
    private void OnEventObjectDestroy(int eventId, IntPtr hwnd, int idObject, int idChild, UInt32 eventTime);
    private void OnEventSystemMenuPopupStart(int eventId, IntPtr hwnd, int idObject, int idChild, UInt32 eventTime);
    private void OnEventSystemCaptureStart(int eventId, IntPtr hwnd, int idObject, int idChild, UInt32 eventTime);
    private void OnEventSystemCaptureEnd(int eventId, IntPtr hwnd, int idObject, int idChild, UInt32 eventTime);
}
internal class MS.Internal.Automation.HwndProxyElementProvider : object {
    private static int ScanPrev;
    private static int ScanNext;
    private static bool IncludeSelf;
    private static bool ExcludeSelf;
    private HWND _hwnd;
    private bool _windowPattern;
    private bool _windowPatternChecked;
    private bool _transformPattern;
    private bool _transformPatternChecked;
    private static long MenuTimeOut;
    private ProviderOptions System.Windows.Automation.Provider.IRawElementProviderSimple.ProviderOptions { get; }
    private IRawElementProviderSimple System.Windows.Automation.Provider.IRawElementProviderSimple.HostRawElementProvider { get; }
    private Rect System.Windows.Automation.Provider.IRawElementProviderFragment.BoundingRectangle { get; }
    private IRawElementProviderFragmentRoot System.Windows.Automation.Provider.IRawElementProviderFragment.FragmentRoot { get; }
    private bool System.Windows.Automation.Provider.IWindowProvider.Maximizable { get; }
    private bool System.Windows.Automation.Provider.IWindowProvider.Minimizable { get; }
    private bool System.Windows.Automation.Provider.IWindowProvider.IsModal { get; }
    private WindowVisualState System.Windows.Automation.Provider.IWindowProvider.VisualState { get; }
    private WindowInteractionState System.Windows.Automation.Provider.IWindowProvider.InteractionState { get; }
    private bool System.Windows.Automation.Provider.IWindowProvider.IsTopmost { get; }
    private bool System.Windows.Automation.Provider.ITransformProvider.CanMove { get; }
    private bool System.Windows.Automation.Provider.ITransformProvider.CanResize { get; }
    private bool System.Windows.Automation.Provider.ITransformProvider.CanRotate { get; }
    private bool SupportsWindowPattern { get; }
    private bool SupportsTransformPattern { get; }
    internal HwndProxyElementProvider(HWND hwnd);
    private sealed virtual override ProviderOptions System.Windows.Automation.Provider.IRawElementProviderSimple.get_ProviderOptions();
    private sealed virtual override object System.Windows.Automation.Provider.IRawElementProviderSimple.GetPatternProvider(int patternId);
    private sealed virtual override object System.Windows.Automation.Provider.IRawElementProviderSimple.GetPropertyValue(int propertyId);
    private sealed virtual override IRawElementProviderSimple System.Windows.Automation.Provider.IRawElementProviderSimple.get_HostRawElementProvider();
    private sealed virtual override IRawElementProviderFragment System.Windows.Automation.Provider.IRawElementProviderFragment.Navigate(NavigateDirection direction);
    private sealed virtual override Int32[] System.Windows.Automation.Provider.IRawElementProviderFragment.GetRuntimeId();
    private sealed virtual override Rect System.Windows.Automation.Provider.IRawElementProviderFragment.get_BoundingRectangle();
    private sealed virtual override IRawElementProviderSimple[] System.Windows.Automation.Provider.IRawElementProviderFragment.GetEmbeddedFragmentRoots();
    private sealed virtual override void System.Windows.Automation.Provider.IRawElementProviderFragment.SetFocus();
    private sealed virtual override IRawElementProviderFragmentRoot System.Windows.Automation.Provider.IRawElementProviderFragment.get_FragmentRoot();
    private sealed virtual override IRawElementProviderFragment System.Windows.Automation.Provider.IRawElementProviderFragmentRoot.ElementProviderFromPoint(double x, double y);
    private sealed virtual override IRawElementProviderFragment System.Windows.Automation.Provider.IRawElementProviderFragmentRoot.GetFocus();
    private sealed virtual override void System.Windows.Automation.Provider.IWindowProvider.SetVisualState(WindowVisualState state);
    private sealed virtual override void System.Windows.Automation.Provider.IWindowProvider.Close();
    private sealed virtual override bool System.Windows.Automation.Provider.IWindowProvider.WaitForInputIdle(int milliseconds);
    private sealed virtual override bool System.Windows.Automation.Provider.IWindowProvider.get_Maximizable();
    private sealed virtual override bool System.Windows.Automation.Provider.IWindowProvider.get_Minimizable();
    private sealed virtual override bool System.Windows.Automation.Provider.IWindowProvider.get_IsModal();
    private sealed virtual override WindowVisualState System.Windows.Automation.Provider.IWindowProvider.get_VisualState();
    private sealed virtual override WindowInteractionState System.Windows.Automation.Provider.IWindowProvider.get_InteractionState();
    private sealed virtual override bool System.Windows.Automation.Provider.IWindowProvider.get_IsTopmost();
    private sealed virtual override void System.Windows.Automation.Provider.ITransformProvider.Move(double x, double y);
    private sealed virtual override void System.Windows.Automation.Provider.ITransformProvider.Resize(double width, double height);
    private sealed virtual override void System.Windows.Automation.Provider.ITransformProvider.Rotate(double degrees);
    private sealed virtual override bool System.Windows.Automation.Provider.ITransformProvider.get_CanMove();
    private sealed virtual override bool System.Windows.Automation.Provider.ITransformProvider.get_CanResize();
    private sealed virtual override bool System.Windows.Automation.Provider.ITransformProvider.get_CanRotate();
    internal static IRawElementProviderFragmentRoot GetRootProvider();
    private static bool GetMenuBarInfo(HWND hwnd, int idObject, UInt32 idItem, MENUBARINFO& mbi);
    private IntPtr GetSystemMenuHandle();
    private static HwndProxyElementProvider Wrap(HWND hwnd);
    internal static bool IsWindowPatternWindow(HWND hwnd);
    private static bool IsTransformPatternWindow(HWND hwnd);
    internal static Int32[] MakeRuntimeId(HWND hwnd);
    private static HWND ScanVisible(HWND hwnd, int dir, bool includeSelf, HWND hwndOwnedBy);
    private HWND GetFirstOrLastOwnedWindow(HWND parent, bool wantFirst);
    private HwndProxyElementProvider GetParent();
    private HwndProxyElementProvider GetNextSibling();
    private HwndProxyElementProvider GetPreviousSibling();
    private HwndProxyElementProvider GetFirstChild();
    private HwndProxyElementProvider GetLastChild();
    private static void GetAllUIFragmentRoots(HWND hwnd, bool includeThis, ArrayList uiFragmentRoots);
    private static bool IsWindowReallyEnabled(HWND hwnd);
    private static bool IsWindowReallyVisible(HWND hwnd);
    private static bool IsWindowCloaked(HWND hwnd);
    private static bool IsTopLevelWindow(HWND hwnd);
    private static HWND GetRealOwner(HWND hwnd);
    private bool get_SupportsWindowPattern();
    private bool get_SupportsTransformPattern();
    private static bool IsBitSet(int flags, int bit);
    private bool FindModalWindow();
    private bool EnumWindows(HWND hwnd, HWND possibleOwner);
    private static void ClearMenuMode();
    private static bool InMenuMode();
    private bool IsMenuItemSelectable(IntPtr hmenu, int item);
    private static HwndProxyElementProvider ElementProviderFromPoint(HWND current, double x, double y);
    private static bool PtInRect(RECT rc, double x, double y);
    private static bool Rect1InRect2(RECT rc1, RECT rc2);
    private static IntPtr MAKELPARAM(int low, int high);
    private static HWND ChildWindowFromPoint(HWND hwnd, double x, double y, Boolean& isClientArea);
    private static bool IsProgmanWindow(HWND hwnd);
    private static bool MapWindowPoints(HWND hWndFrom, HWND hWndTo, RECT& rect, int cPoints);
    private static bool MapWindowPoints(HWND hWndFrom, HWND hWndTo, POINT& pt, int cPoints);
    private int GetWindowStyle();
    private static int GetWindowStyle(HWND hwnd);
    private int GetWindowExStyle();
    private static int GetWindowExStyle(HWND hwnd);
    private static bool SetFocus(HWND hwnd);
    private static HWND GetFocusedWindow();
    private static IRawElementProviderFragment GetFocusedProvider();
}
internal class MS.Internal.Automation.Input : object {
    internal static void SendKeyboardInput(Key key, bool press);
    internal static void SendKeyboardInputVK(byte vk, bool press);
    private static bool IsExtendedKey(Key key);
}
internal class MS.Internal.Automation.InternalAutomationFocusChangedEventArgs : AutomationFocusChangedEventArgs {
    internal AutomationFocusChangedEventArgs _args;
    internal UInt32 _eventTime;
    internal InternalAutomationFocusChangedEventArgs(int idObject, int idChild, UInt32 eventTime);
}
internal static class MS.Internal.Automation.InvokeHandlers : object {
    internal static UInt32 _lastFocusEventTime;
    internal static void InvokeClientHandler(Delegate clientCallback, AutomationElement srcEl, AutomationEventArgs args);
}
internal class MS.Internal.Automation.MenuHandler : MulticastDelegate {
    public MenuHandler(object object, IntPtr method);
    public virtual void Invoke(AutomationElement rawEl, bool menuHasOpened);
    public virtual IAsyncResult BeginInvoke(AutomationElement rawEl, bool menuHasOpened, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class MS.Internal.Automation.MenuTracker : WinEventWrap {
    internal MenuTracker(MenuHandler newHandler);
    internal virtual void WinEventProc(int eventId, IntPtr hwnd, int idObject, int idChild, UInt32 eventTime);
}
internal static class MS.Internal.Automation.Misc : object {
    internal static bool Compare(Int32[] a1, Int32[] a2);
    internal static bool Compare(AutomationElement el1, AutomationElement el2);
    internal static Array CombineArrays(IEnumerable arrays, Type t);
    internal static Array RemoveDuplicates(Array a, Type t);
    internal static object WrapInterfaceOnClientSide(AutomationElement el, SafePatternHandle hPattern, AutomationPattern pattern);
    internal static void ValidateArgumentNonNull(object obj, string argName);
    internal static void ThrowInvalidArgument(string argName);
    internal static void ValidateArgument(bool cond, string reason);
    internal static void ValidateArgumentInRange(bool cond, string argName);
    internal static void ValidateCached(bool cached);
    internal static void ValidateCurrent(SafePatternHandle hPattern);
    internal static bool IsCriticalException(Exception e);
    internal static bool IsWindowsFormsControl(string className);
    internal static void ThrowWin32ExceptionsIfError(int errorCode);
    private static int IntPtrToInt32(IntPtr intPtr);
    internal static IntPtr CreateRectRgn(int left, int top, int right, int bottom);
    internal static bool CloseHandle(IntPtr handle);
    internal static bool DeleteObject(IntPtr hrgn);
    internal static bool GetClientRect(HWND hwnd, RECT& rc);
    internal static bool GetGUIThreadInfo(int idThread, GUITHREADINFO& guiThreadInfo);
    internal static bool GetMenuBarInfo(HWND hwnd, int idObject, UInt32 item, MENUBARINFO& mbi);
    internal static int GetModuleFileNameEx(SafeProcessHandle hProcess, IntPtr hModule, StringBuilder buffer, int length);
    internal static int GetMessage(MSG& msg, HWND hwnd, int nMsgFilterMin, int nMsgFilterMax);
    internal static HWND GetWindow(HWND hwnd, int uCmd);
    internal static int GetWindowLong(HWND hWnd, int nIndex);
    internal static bool GetWindowPlacement(HWND hwnd, WINDOWPLACEMENT& wp);
    internal static bool GetWindowRect(HWND hwnd, RECT& rc);
    internal static short GlobalAddAtom(string lpString);
    internal static short GlobalDeleteAtom(short atom);
    internal static int TryMsgWaitForMultipleObjects(SafeWaitHandle handle, bool waitAll, int milliseconds, int wakeMask, Int32& lastWin32Error);
    internal static int MsgWaitForMultipleObjects(SafeWaitHandle handle, bool waitAll, int milliseconds, int wakeMask);
    internal static IntPtr OpenProcess(int dwDesiredAccess, bool fInherit, int dwProcessId, HWND hwnd);
    internal static bool PostMessage(HWND hWnd, int nMsg, IntPtr wParam, IntPtr lParam);
    internal static bool RegisterHotKey(HWND hWnd, int id, int fsModifiers, int vk);
    internal static int SendInput(int nInputs, INPUT& mi, int cbSize);
    internal static IntPtr SendMessageTimeout(HWND hwnd, int Msg, IntPtr wParam, IntPtr lParam);
    internal static IntPtr SendMessageTimeout(HWND hwnd, int Msg, IntPtr wParam, MINMAXINFO& lParam);
    internal static IntPtr SendMessageTimeout(HWND hwnd, int Msg, IntPtr wParam, StringBuilder lParam);
    internal static bool SetWindowPlacement(HWND hwnd, WINDOWPLACEMENT& wp);
    internal static bool SetWindowPos(HWND hWnd, HWND hWndInsertAfter, int x, int y, int cx, int cy, int flags);
    internal static bool UnregisterHotKey(HWND hWnd, int id);
    internal static string StripMnemonic(string s);
    private static void CheckNonNull(object el1, object el2);
    private static void EvaluateSendMessageTimeoutError(int error);
}
internal class MS.Internal.Automation.ProxyManager : object {
    private static String[] BadImplClassnames;
    private static object _lockObj;
    private static Hashtable _classHandlers;
    private static ArrayList _partialClassHandlers;
    private static Hashtable _imageOnlyHandlers;
    private static ArrayList _fallbackHandlers;
    private static bool _defaultProxiesNeeded;
    private static string _defaultProxyAssembly;
    private static ClientSideProviderFactoryCallback[] _pseudoProxies;
    private static String[] _pseudoProxyClassNames;
    private static String[] _classNames;
    internal static ClientSideProviderFactoryCallback NonClientProxyFactory { get; }
    internal static ClientSideProviderFactoryCallback NonClientMenuBarProxyFactory { get; }
    internal static ClientSideProviderFactoryCallback NonClientSysMenuProxyFactory { get; }
    internal static ClientSideProviderFactoryCallback User32FocusedMenuProxyFactory { get; }
    private static ProxyManager();
    internal static void RegisterProxyAssembly(AssemblyName assemblyName);
    internal static void RegisterWindowHandlers(ClientSideProviderDescription[] proxyInfo);
    internal static void SetProxyDescriptionTable(ClientSideProviderDescription[] proxyInfo);
    internal static ClientSideProviderDescription[] GetProxyDescriptionTable();
    internal static IRawElementProviderSimple GetNonClientProvider(IntPtr hwnd);
    internal static IRawElementProviderSimple GetUser32FocusedMenuProvider(IntPtr hwnd);
    internal static string GetClassName(HWND hwnd);
    internal static string RealGetWindowClass(HWND hwnd);
    internal static bool IsKnownBadWindow(HWND hwnd);
    internal static string GetImageName(HWND hwnd);
    internal static void LoadDefaultProxies();
    internal static void DisableDefaultProxies();
    internal static ClientSideProviderFactoryCallback get_NonClientProxyFactory();
    internal static ClientSideProviderFactoryCallback get_NonClientMenuBarProxyFactory();
    internal static ClientSideProviderFactoryCallback get_NonClientSysMenuProxyFactory();
    internal static ClientSideProviderFactoryCallback get_User32FocusedMenuProxyFactory();
    internal static IRawElementProviderSimple ProxyProviderFromHwnd(HWND hwnd, int idChild, int idObject);
    private static IRawElementProviderSimple FindProxyFromImageFallback(String& imageName, HWND hwnd, int idChild, int idObject);
    private static IRawElementProviderSimple FindProxyInEntryOrArrayList(ProxyScoping findType, object entryOrArrayList, String& imageName, HWND hwnd, int idChild, int idObject, string classNameForPartialMatch);
    private static IRawElementProviderSimple GetProxyFromEntry(ProxyScoping findType, object entry, String& imageName, HWND hwnd, int idChild, int idObject, string classNameForPartialMatch);
    private static void AddToProxyDescriptionTable(ClientSideProviderDescription[] proxyInfo);
    private static void AddToHashTable(Hashtable table, string key, object data);
    private static string GetBaseClassName(HWND hwnd);
}
internal abstract class MS.Internal.Automation.QueueItem : object {
    internal abstract virtual void Process();
}
internal class MS.Internal.Automation.QueueProcessor : object {
    private Thread _thread;
    private Queue _q;
    private AutoResetEvent _ev;
    private bool _quitting;
    internal QueueProcessor(int initCapacity);
    internal void StartOnThread();
    internal bool PostWorkItem(QueueItem workItem);
    internal bool PostSyncWorkItem(QueueItem workItem);
    internal void PostQuit();
    private void WaitForWork();
    private void DrainQueue();
}
internal class MS.Internal.Automation.SafeEventHandle : SafeHandle {
    public bool IsInvalid { get; }
    public virtual bool get_IsInvalid();
    protected virtual bool ReleaseHandle();
}
internal class MS.Internal.Automation.SafeNodeHandle : SafeHandle {
    public bool IsInvalid { get; }
    public virtual bool get_IsInvalid();
    protected virtual bool ReleaseHandle();
}
internal class MS.Internal.Automation.SafePatternHandle : SafeHandle {
    public bool IsInvalid { get; }
    public virtual bool get_IsInvalid();
    protected virtual bool ReleaseHandle();
}
internal class MS.Internal.Automation.SafeProcessHandle : SafeHandleZeroOrMinusOneIsInvalid {
    internal SafeProcessHandle(HWND hwnd);
    protected virtual bool ReleaseHandle();
}
internal class MS.Internal.Automation.Schema : object {
    private static AutomationPropertyConverter convertToBool;
    private static AutomationPropertyConverter convertToRowOrColumnMajor;
    private static AutomationPropertyConverter convertToToggleState;
    private static AutomationPropertyConverter convertToWindowInteractionState;
    private static AutomationPropertyConverter convertToWindowVisualState;
    private static AutomationPropertyConverter convertToExpandCollapseState;
    private static AutomationPropertyConverter convertToRect;
    private static AutomationPropertyConverter convertToPoint;
    private static AutomationPropertyConverter convertToOrientationType;
    private static AutomationPropertyConverter convertToDockPosition;
    private static AutomationPropertyConverter convertToElement;
    private static AutomationPropertyConverter convertToElementArray;
    private static AutomationPropertyConverter convertToControlType;
    private static AutomationPropertyConverter convertToCultureInfo;
    private static AutomationPropertyInfo[] _propertyInfoTable;
    private static AutomationProperty[] _basicProperties;
    private static AutomationProperty[] ValueProperties;
    private static AutomationProperty[] RangeValueProperties;
    private static AutomationProperty[] ScrollProperties;
    private static AutomationProperty[] SelectionProperties;
    private static AutomationProperty[] ExpandCollapseProperties;
    private static AutomationProperty[] DockProperties;
    private static AutomationProperty[] GridProperties;
    private static AutomationProperty[] GridItemProperties;
    private static AutomationProperty[] MultipleViewProperties;
    private static AutomationProperty[] WindowProperties;
    private static AutomationProperty[] SelectionItemProperties;
    private static AutomationProperty[] TableProperties;
    private static AutomationProperty[] TableItemProperties;
    private static AutomationProperty[] ToggleProperties;
    private static AutomationProperty[] TransformProperties;
    private static AutomationPatternInfo[] _patternInfoTable;
    private static AutomationAttributeInfo[] _attributeInfoTable;
    private static Schema();
    internal static bool GetPropertyInfo(AutomationProperty id, AutomationPropertyInfo& info);
    internal static object GetDefaultValue(AutomationProperty property);
    internal static bool GetPatternInfo(AutomationPattern id, AutomationPatternInfo& info);
    internal static bool GetAttributeInfo(AutomationTextAttribute id, AutomationAttributeInfo& info);
    internal static AutomationProperty[] GetBasicProperties();
    internal static AutomationPatternInfo[] GetPatternInfoTable();
    private static object ConvertToBool(object value);
    private static object ConvertToRowOrColumnMajor(object value);
    private static object ConvertToToggleState(object value);
    private static object ConvertToWindowInteractionState(object value);
    private static object ConvertToWindowVisualState(object value);
    private static object ConvertToExpandCollapseState(object value);
    private static object ConvertToOrientationType(object value);
    private static object ConvertToDockPosition(object value);
    private static object ConvertToRect(object value);
    private static object ConvertToPoint(object value);
    private static object ConvertToControlType(object value);
    private static object ConvertToCultureInfo(object value);
    private static object ConvertToElement(object value);
    internal static object ConvertToElementArray(object value);
}
internal class MS.Internal.Automation.SelectionPatternProviderSideWrapper : MarshalByRefObject {
    private ISelectionProvider _target;
    public bool CanSelectMultiple { get; }
    public bool IsSelectionRequired { get; }
    private SelectionPatternProviderSideWrapper(ISelectionProvider target);
    internal static object Wrap(object target);
    public IRawElementProviderSimple[] GetSelection();
    public bool get_CanSelectMultiple();
    public bool get_IsSelectionRequired();
}
internal class MS.Internal.Automation.SyncQueueItem : QueueItem {
    internal AutoResetEvent _ev;
    private QueueItem _qItem;
    internal SyncQueueItem(QueueItem qItem);
    internal virtual void Process();
}
internal static class MS.Internal.Automation.UiaCoreApi : object {
    internal static int UIA_E_ELEMENTNOTENABLED;
    internal static int UIA_E_ELEMENTNOTAVAILABLE;
    internal static int UIA_E_NOCLICKABLEPOINT;
    internal static int UIA_E_PROXYASSEMBLYNOTLOADED;
    internal static int UiaHwndRuntimeIdBase;
    private static GCHandle _gchandle;
    private static UiaCoreApi();
    internal static UiaCacheResponse UiaNodeFromPoint(double x, double y, UiaCacheRequest request);
    internal static UiaCacheResponse UiaNodeFromFocus(UiaCacheRequest request);
    internal static UiaCacheResponse UiaGetUpdatedCache(SafeNodeHandle hnode, UiaCacheRequest request, NormalizeState normalize, Condition customCondition);
    internal static void UiaGetPropertyValue(SafeNodeHandle hnode, int propertyId, Object& value);
    internal static SafePatternHandle UiaGetPatternProvider(SafeNodeHandle hnode, int patternId);
    internal static Int32[] UiaGetRuntimeId(SafeNodeHandle hnode);
    internal static void UiaSetFocus(SafeNodeHandle hnode);
    internal static UiaCacheResponse UiaNavigate(SafeNodeHandle hnode, NavigateDirection direction, Condition condition, UiaCacheRequest request);
    internal static UiaCacheResponse[] UiaFind(SafeNodeHandle hnode, UiaFindParams findParams, Condition findCondition, UiaCacheRequest request);
    internal static SafeNodeHandle UiaNodeFromHandle(IntPtr hwnd);
    internal static SafeNodeHandle UiaGetRootNode();
    internal static SafeNodeHandle UiaNodeFromProvider(IRawElementProviderSimple provider);
    internal static SafeNodeHandle UiaHUiaNodeFromVariant(object var);
    internal static SafePatternHandle UiaHPatternObjectFromVariant(object var);
    internal static SafeTextRangeHandle UiaHTextRangeFromVariant(object var);
    internal static bool UiaHasServerSideProvider(IntPtr hwnd);
    internal static bool UiaNodeRelease(IntPtr hnode);
    internal static bool UiaPatternRelease(IntPtr hobj);
    internal static bool UiaTextRangeRelease(IntPtr hobj);
    internal static SafeEventHandle UiaAddEvent(SafeNodeHandle hnode, int eventId, UiaEventCallback callback, TreeScope scope, Int32[] properties, UiaCacheRequest request);
    internal static void UiaRemoveEvent(IntPtr hevent);
    internal static void UiaEventAddWindow(SafeEventHandle hevent, IntPtr hwnd);
    internal static void UiaEventRemoveWindow(SafeEventHandle hevent, IntPtr hwnd);
    private static Int32[] ArrayFromIntPtr(IntPtr pInts, int cInts);
    internal static AutomationEventArgs GetUiaEventArgs(IntPtr argsAddr);
    internal static void DockPattern_SetDockPosition(SafePatternHandle hobj, DockPosition dockPosition);
    internal static void ExpandCollapsePattern_Collapse(SafePatternHandle hobj);
    internal static void ExpandCollapsePattern_Expand(SafePatternHandle hobj);
    internal static SafeNodeHandle GridPattern_GetItem(SafePatternHandle hobj, int row, int column);
    internal static void InvokePattern_Invoke(SafePatternHandle hobj);
    internal static string MultipleViewPattern_GetViewName(SafePatternHandle hobj, int viewId);
    internal static void MultipleViewPattern_SetCurrentView(SafePatternHandle hobj, int viewId);
    internal static void RangeValuePattern_SetValue(SafePatternHandle hobj, double val);
    internal static void ScrollItemPattern_ScrollIntoView(SafePatternHandle hobj);
    internal static void ScrollPattern_Scroll(SafePatternHandle hobj, ScrollAmount horizontalAmount, ScrollAmount verticalAmount);
    internal static void ScrollPattern_SetScrollPercent(SafePatternHandle hobj, double horizontalPercent, double verticalPercent);
    internal static void SelectionItemPattern_AddToSelection(SafePatternHandle hobj);
    internal static void SelectionItemPattern_RemoveFromSelection(SafePatternHandle hobj);
    internal static void SelectionItemPattern_Select(SafePatternHandle hobj);
    internal static void TogglePattern_Toggle(SafePatternHandle hobj);
    internal static void TransformPattern_Move(SafePatternHandle hobj, double x, double y);
    internal static void TransformPattern_Resize(SafePatternHandle hobj, double width, double height);
    internal static void TransformPattern_Rotate(SafePatternHandle hobj, double degrees);
    internal static void ValuePattern_SetValue(SafePatternHandle hobj, string pVal);
    internal static void WindowPattern_Close(SafePatternHandle hobj);
    internal static void WindowPattern_SetWindowVisualState(SafePatternHandle hobj, WindowVisualState state);
    internal static bool WindowPattern_WaitForInputIdle(SafePatternHandle hobj, int milliseconds);
    internal static void SynchronizedInputPattern_StartListening(SafePatternHandle hobj, SynchronizedInputType inputType);
    internal static void SynchronizedInputPattern_Cancel(SafePatternHandle hobj);
    internal static void VirtualizedItemPattern_Realize(SafePatternHandle hobj);
    internal static SafeNodeHandle ItemContainerPattern_FindItemByProperty(SafePatternHandle hobj, SafeNodeHandle hNode, int propertyId, object value);
    internal static SafeTextRangeHandle[] TextPattern_GetSelection(SafePatternHandle hobj);
    internal static SafeTextRangeHandle[] TextPattern_GetVisibleRanges(SafePatternHandle hobj);
    internal static SafeTextRangeHandle TextPattern_RangeFromChild(SafePatternHandle hobj, SafeNodeHandle childElement);
    internal static SafeTextRangeHandle TextPattern_RangeFromPoint(SafePatternHandle hobj, Point point);
    internal static SafeTextRangeHandle TextPattern_get_DocumentRange(SafePatternHandle hobj);
    internal static SupportedTextSelection TextPattern_get_SupportedTextSelection(SafePatternHandle hobj);
    internal static SafeTextRangeHandle TextRange_Clone(SafeTextRangeHandle hobj);
    internal static bool TextRange_Compare(SafeTextRangeHandle hobj, SafeTextRangeHandle range);
    internal static int TextRange_CompareEndpoints(SafeTextRangeHandle hobj, TextPatternRangeEndpoint endpoint, SafeTextRangeHandle targetRange, TextPatternRangeEndpoint targetEndpoint);
    internal static void TextRange_ExpandToEnclosingUnit(SafeTextRangeHandle hobj, TextUnit unit);
    internal static SafeTextRangeHandle TextRange_FindAttribute(SafeTextRangeHandle hobj, int attributeId, object val, bool backward);
    internal static SafeTextRangeHandle TextRange_FindText(SafeTextRangeHandle hobj, string text, bool backward, bool ignoreCase);
    internal static object TextRange_GetAttributeValue(SafeTextRangeHandle hobj, int attributeId);
    internal static Rect[] TextRange_GetBoundingRectangles(SafeTextRangeHandle hobj);
    internal static SafeNodeHandle TextRange_GetEnclosingElement(SafeTextRangeHandle hobj);
    internal static string TextRange_GetText(SafeTextRangeHandle hobj, int maxLength);
    internal static int TextRange_Move(SafeTextRangeHandle hobj, TextUnit unit, int count);
    internal static int TextRange_MoveEndpointByUnit(SafeTextRangeHandle hobj, TextPatternRangeEndpoint endpoint, TextUnit unit, int count);
    internal static void TextRange_MoveEndpointByRange(SafeTextRangeHandle hobj, TextPatternRangeEndpoint endpoint, SafeTextRangeHandle targetRange, TextPatternRangeEndpoint targetEndpoint);
    internal static void TextRange_Select(SafeTextRangeHandle hobj);
    internal static void TextRange_AddToSelection(SafeTextRangeHandle hobj);
    internal static void TextRange_RemoveFromSelection(SafeTextRangeHandle hobj);
    internal static void TextRange_ScrollIntoView(SafeTextRangeHandle hobj, bool alignToTop);
    internal static Object[] TextRange_GetChildren(SafeTextRangeHandle hobj);
    internal static bool IsErrorMarker(object val, bool throwException);
    private static bool UiaGetErrorDescription(String& pDescription);
    private static int SetErrorInfo(int dwReserved, IntPtr errorInfo);
    private static void CheckError(int hr);
    private static int RawUiaGetPropertyValue(SafeNodeHandle hnode, int propertyId, Object& value);
    private static int RawUiaGetPatternProvider(SafeNodeHandle hnode, int patternId, SafePatternHandle& phobj);
    private static int RawUiaGetRuntimeId(SafeNodeHandle hnode, Int32[]& runtimeId);
    private static int RawUiaSetFocus(SafeNodeHandle hnode);
    private static int RawUiaNavigate(SafeNodeHandle hnode, NavigateDirection direction, SafeConditionMemoryHandle condition, UiaMiniCacheRequest pRequest, Object[0...,0...]& requestedData, String& treeStructure);
    private static int RawUiaFind(SafeNodeHandle hnode, UiaFindParams& pParams, UiaMiniCacheRequest pRequest, Object[0...,0...]& requestedData, Int32[]& offsets, String[]& treeStructures);
    private static int RawUiaNodeFromHandle(IntPtr hwnd, SafeNodeHandle& hnode);
    private static int RawUiaNodeFromProvider(IRawElementProviderSimple provider, SafeNodeHandle& hode);
    private static int RawUiaGetRootNode(SafeNodeHandle& hnode);
    private static int RawUiaNodeFromPoint(double x, double y, UiaMiniCacheRequest request, Object[0...,0...]& requestedData, String& treeStructure);
    private static int RawUiaNodeFromFocus(UiaMiniCacheRequest pRequest, Object[0...,0...]& requestedData, String& treeStructure);
    private static int RawUiaGetUpdatedCache(SafeNodeHandle hnode, UiaMiniCacheRequest pRequest, NormalizeState normalizeState, SafeConditionMemoryHandle pNormalizeCondition, Object[0...,0...]& requestedData, String& treeStructure);
    private static int RawUiaHUiaNodeFromVariant(Object& var, SafeNodeHandle& hnode);
    private static int RawUiaHPatternObjectFromVariant(Object& var, SafePatternHandle& hnode);
    private static int RawUiaHTextRangeFromVariant(Object& var, SafeTextRangeHandle& hnode);
    private static bool RawUiaNodeRelease(IntPtr hnode);
    private static bool RawUiaPatternRelease(IntPtr hobj);
    private static bool RawUiaTextRangeRelease(IntPtr hobj);
    private static int RawUiaAddEvent(SafeNodeHandle hnode, int eventId, UiaEventCallback callback, TreeScope scope, Int32[] pProperties, int cProperties, UiaMiniCacheRequest pRequest, SafeEventHandle& hevent);
    private static int RawUiaRemoveEvent(IntPtr hevent);
    private static int RawUiaEventAddWindow(SafeEventHandle hevent, IntPtr hwnd);
    private static int RawUiaEventRemoveWindow(SafeEventHandle hevent, IntPtr hwnd);
    private static int RawDockPattern_SetDockPosition(SafePatternHandle hobj, DockPosition dockPosition);
    private static int RawExpandCollapsePattern_Collapse(SafePatternHandle hobj);
    private static int RawExpandCollapsePattern_Expand(SafePatternHandle hobj);
    private static int RawGridPattern_GetItem(SafePatternHandle hobj, int row, int column, SafeNodeHandle& pResult);
    private static int RawInvokePattern_Invoke(SafePatternHandle hobj);
    private static int RawMultipleViewPattern_GetViewName(SafePatternHandle hobj, int viewId, String& ppStr);
    private static int RawMultipleViewPattern_SetCurrentView(SafePatternHandle hobj, int viewId);
    private static int RawRangeValuePattern_SetValue(SafePatternHandle hobj, double val);
    private static int RawScrollItemPattern_ScrollIntoView(SafePatternHandle hobj);
    private static int RawScrollPattern_Scroll(SafePatternHandle hobj, ScrollAmount horizontalAmount, ScrollAmount verticalAmount);
    private static int RawScrollPattern_SetScrollPercent(SafePatternHandle hobj, double horizontalPercent, double verticalPercent);
    private static int RawSelectionItemPattern_AddToSelection(SafePatternHandle hobj);
    private static int RawSelectionItemPattern_RemoveFromSelection(SafePatternHandle hobj);
    private static int RawSelectionItemPattern_Select(SafePatternHandle hobj);
    private static int RawTogglePattern_Toggle(SafePatternHandle hobj);
    private static int RawTransformPattern_Move(SafePatternHandle hobj, double x, double y);
    private static int RawTransformPattern_Resize(SafePatternHandle hobj, double width, double height);
    private static int RawTransformPattern_Rotate(SafePatternHandle hobj, double degrees);
    private static int RawValuePattern_SetValue(SafePatternHandle hobj, string pVal);
    private static int RawWindowPattern_Close(SafePatternHandle hobj);
    private static int RawWindowPattern_SetWindowVisualState(SafePatternHandle hobj, WindowVisualState state);
    private static int RawWindowPattern_WaitForInputIdle(SafePatternHandle hobj, int milliseconds, Boolean& pResult);
    private static int RawSynchronizedInputPattern_StartListening(SafePatternHandle hobj, SynchronizedInputType inputType);
    private static int RawSynchronizedInputPattern_Cancel(SafePatternHandle hobj);
    private static int RawVirtualizedItemPattern_Realize(SafePatternHandle hobj);
    private static int RawItemContainerPattern_FindItemByProperty(SafePatternHandle hobj, SafeNodeHandle startAfter, int propertyId, object value, SafeNodeHandle& result);
    private static int RawTextPattern_GetSelection(SafePatternHandle hobj, Object[]& result);
    private static int RawTextPattern_GetVisibleRanges(SafePatternHandle hobj, Object[]& result);
    private static int RawTextPattern_RangeFromChild(SafePatternHandle hobj, SafeNodeHandle childElement, SafeTextRangeHandle& result);
    private static int RawTextPattern_RangeFromPoint(SafePatternHandle hobj, Point point, SafeTextRangeHandle& result);
    private static int RawTextPattern_get_DocumentRange(SafePatternHandle hobj, SafeTextRangeHandle& result);
    private static int RawTextPattern_get_SupportedTextSelection(SafePatternHandle hobj, SupportedTextSelection& result);
    private static int RawTextRange_Clone(SafeTextRangeHandle hobj, SafeTextRangeHandle& result);
    private static int RawTextRange_Compare(SafeTextRangeHandle hobj, SafeTextRangeHandle range, Boolean& result);
    private static int RawTextRange_CompareEndpoints(SafeTextRangeHandle hobj, TextPatternRangeEndpoint endpoint, SafeTextRangeHandle targetRange, TextPatternRangeEndpoint targetEndpoint, Int32& result);
    private static int RawTextRange_ExpandToEnclosingUnit(SafeTextRangeHandle hobj, TextUnit unit);
    private static int RawTextRange_FindAttribute(SafeTextRangeHandle hobj, int attributeId, object val, bool backward, SafeTextRangeHandle& result);
    private static int RawTextRange_FindText(SafeTextRangeHandle hobj, string text, bool backward, bool ignoreCase, SafeTextRangeHandle& result);
    private static int RawTextRange_GetAttributeValue(SafeTextRangeHandle hobj, int attributeId, Object& result);
    private static int RawTextRange_GetBoundingRectangles(SafeTextRangeHandle hobj, Double[]& result);
    private static int RawTextRange_GetEnclosingElement(SafeTextRangeHandle hobj, SafeNodeHandle& result);
    private static int RawTextRange_GetText(SafeTextRangeHandle hobj, int maxLength, String& result);
    private static int RawTextRange_Move(SafeTextRangeHandle hobj, TextUnit unit, int count, Int32& result);
    private static int RawTextRange_MoveEndpointByUnit(SafeTextRangeHandle hobj, TextPatternRangeEndpoint endpoint, TextUnit unit, int count, Int32& result);
    private static int RawTextRange_MoveEndpointByRange(SafeTextRangeHandle hobj, TextPatternRangeEndpoint endpoint, SafeTextRangeHandle targetRange, TextPatternRangeEndpoint targetEndpoint);
    private static int RawTextRange_Select(SafeTextRangeHandle hobj);
    private static int RawTextRange_AddToSelection(SafeTextRangeHandle hobj);
    private static int RawTextRange_RemoveFromSelection(SafeTextRangeHandle hobj);
    private static int RawTextRange_ScrollIntoView(SafeTextRangeHandle hobj, bool alignToTop);
    private static int RawTextRange_GetChildren(SafeTextRangeHandle hobj, Object[]& result);
    private static void UiaRegisterProviderCallback(UiaProviderCallback pCallback);
    private static IRawElementProviderSimple[] OnGetProvider(IntPtr hwnd, ProviderType providerType);
}
internal class MS.Internal.Automation.WindowHideOrCloseHandler : MulticastDelegate {
    public WindowHideOrCloseHandler(object object, IntPtr method);
    public virtual void Invoke(IntPtr hwnd, AutomationElement rawEl, Int32[] runtimeId);
    public virtual IAsyncResult BeginInvoke(IntPtr hwnd, AutomationElement rawEl, Int32[] runtimeId, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class MS.Internal.Automation.WindowHideOrCloseTracker : WinEventWrap {
    internal WindowHideOrCloseTracker(WindowHideOrCloseHandler newUIHandler);
    internal virtual void WinEventProc(int eventId, IntPtr hwnd, int idObject, int idChild, UInt32 eventTime);
}
internal class MS.Internal.Automation.WindowInteractionStateTracker : WinEventWrap {
    private WindowInteractionState _lastState;
    private IntPtr _lastHwnd;
    internal virtual void WinEventProc(int eventId, IntPtr hwnd, int idObject, int idChild, UInt32 eventTime);
    private void OnStateChange(IntPtr hwnd, int idObject, int idChild);
}
internal class MS.Internal.Automation.WindowShowOrOpenHandler : MulticastDelegate {
    public WindowShowOrOpenHandler(object object, IntPtr method);
    public virtual void Invoke(IntPtr hwnd, AutomationElement rawEl);
    public virtual IAsyncResult BeginInvoke(IntPtr hwnd, AutomationElement rawEl, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class MS.Internal.Automation.WindowShowOrOpenTracker : WinEventWrap {
    private static string _wcpClassName;
    internal WindowShowOrOpenTracker(WindowShowOrOpenHandler newUIHandler);
    private static WindowShowOrOpenTracker();
    internal virtual void WinEventProc(int eventId, IntPtr hwnd, int idObject, int idChild, UInt32 eventTime);
}
internal class MS.Internal.Automation.WindowVisualStateTracker : WinEventWrap {
    private WindowVisualState _lastState;
    private IntPtr _lastHwnd;
    internal virtual void WinEventProc(int eventId, IntPtr hwnd, int idObject, int idChild, UInt32 eventTime);
    private void OnStateChange(IntPtr hwnd, int idObject, int idChild);
}
internal class MS.Internal.Automation.WinEventQueueItem : QueueItem {
    internal static int StartListening;
    internal static int StopListening;
    private WinEventWrap _winEventWrap;
    private int _state;
    internal WinEventQueueItem(WinEventWrap winEventWrap, int state);
    internal virtual void Process();
}
internal class MS.Internal.Automation.WinEventWrap : object {
    private Queue _qEvents;
    private Int32[] _eventIds;
    private IntPtr[] _hHooks;
    private bool _fBusy;
    private int _fFlags;
    private GCHandle _gchThis;
    private WinEventProcDef _winEventProc;
    protected ArrayList _clientCallbacks;
    internal WinEventWrap(Int32[] eventIds);
    protected virtual override void Finalize();
    internal virtual void WinEventProc(int eventId, IntPtr hwnd, int idObject, int idChild, UInt32 eventTime);
    internal void Clear();
    internal void AddCallback(object clientCallback);
    internal bool RemoveCallback(object clientCallback);
    internal void StartListening();
    internal void StopListening();
    internal Object[] GetHandlers();
    private void WinEventReentrancyFilter(int winEventHook, int eventId, IntPtr hwnd, int idObject, int idChild, int eventThread, UInt32 eventTime);
    private void PreWinEventProc(int eventId, IntPtr hwnd, int idObject, int idChild, UInt32 eventTime);
    private void Init();
}
internal class MS.Internal.Automation.WrapObjectClientSide : MulticastDelegate {
    public WrapObjectClientSide(object object, IntPtr method);
    public virtual object Invoke(AutomationElement el, SafePatternHandle hPattern, bool cached);
    public virtual IAsyncResult BeginInvoke(AutomationElement el, SafePatternHandle hPattern, bool cached, AsyncCallback callback, object object);
    public virtual object EndInvoke(IAsyncResult result);
}
internal static class MS.Internal.UIAutomationClient.NativeMethodsSetLastError : object {
    private static string PresentationNativeDll;
    public static int GetWindowLong(IntPtr hWnd, int nIndex);
    public static IntPtr GetWindowLongPtr(IntPtr hWnd, int nIndex);
    public static short GlobalDeleteAtom(short atom);
    public static bool GetMenuBarInfo(IntPtr hwnd, int idObject, UInt32 idItem, MENUBARINFO& mbi);
    public static HWND GetWindow(HWND hWnd, int uCmd);
    public static int MapWindowPoints(HWND hWndFrom, HWND hWndTo, RECT& rect, int cPoints);
    public static int MapWindowPoints(HWND hWndFrom, HWND hWndTo, POINT& pt, int cPoints);
}
internal static class MS.Win32.NativeMethods : object {
    public static int MAX_PATH;
    internal static int WM_GETDLGCODE;
    internal static int DLGC_STATIC;
    public static int EVENT_MIN;
    public static int EVENT_MAX;
    public static int EVENT_SYSTEM_MENUSTART;
    public static int EVENT_SYSTEM_MENUEND;
    public static int EVENT_SYSTEM_MENUPOPUPSTART;
    public static int EVENT_SYSTEM_MENUPOPUPEND;
    public static int EVENT_SYSTEM_CAPTURESTART;
    public static int EVENT_SYSTEM_CAPTUREEND;
    public static int EVENT_SYSTEM_SWITCHSTART;
    public static int EVENT_SYSTEM_SWITCHEND;
    public static int EVENT_OBJECT_CREATE;
    public static int EVENT_OBJECT_DESTROY;
    public static int EVENT_OBJECT_SHOW;
    public static int EVENT_OBJECT_HIDE;
    public static int EVENT_OBJECT_FOCUS;
    public static int EVENT_OBJECT_STATECHANGE;
    public static int EVENT_OBJECT_LOCATIONCHANGE;
    public static int WINEVENT_OUTOFCONTEXT;
    public static int WINEVENT_SKIPOWNTHREAD;
    public static int WINEVENT_SKIPOWNPROCESS;
    public static int WINEVENT_INCONTEXT;
    public static int EventObjectUIFragmentCreate;
}
internal static class MS.Win32.SafeNativeMethods : object {
    public static int SM_CXMAXTRACK;
    public static int SM_CYMAXTRACK;
    public static int SM_XVIRTUALSCREEN;
    public static int SM_YVIRTUALSCREEN;
    public static int SM_CXVIRTUALSCREEN;
    public static int SM_CYVIRTUALSCREEN;
    public static int SM_SWAPBUTTON;
    public static int SM_CXHSCROLL;
    public static int SM_CYHSCROLL;
    public static int GUI_CARETBLINKING;
    public static int GUI_INMOVESIZE;
    public static int GUI_INMENUMODE;
    public static int GUI_SYSTEMMENUMODE;
    public static int GUI_POPUPMENUMODE;
    public static int GWL_HINSTANCE;
    public static int GWL_ID;
    public static int GWL_STYLE;
    public static int GWL_EXSTYLE;
    public static int WS_MINIMIZE;
    public static int WS_MAXIMIZE;
    public static int WS_THICKFRAME;
    public static int WS_SYSMENU;
    public static int WS_BORDER;
    public static int WS_DLGFRAME;
    public static int WS_CAPTION;
    public static int WS_MINIMIZEBOX;
    public static int WS_MAXIMIZEBOX;
    public static int WS_DISABLED;
    public static int WS_CHILD;
    public static int WS_POPUP;
    public static int WS_EX_DLGMODALFRAME;
    public static int WS_EX_TOPMOST;
    public static int WS_EX_TRANSPARENT;
    public static int WS_EX_MDICHILD;
    public static int WS_EX_TOOLWINDOW;
    public static int WS_EX_APPWINDOW;
    public static int WS_EX_LAYERED;
    public static int GA_PARENT;
    public static int GA_ROOT;
    public static int GW_HWNDFIRST;
    public static int GW_HWNDLAST;
    public static int GW_HWNDNEXT;
    public static int GW_HWNDPREV;
    public static int GW_OWNER;
    public static int GW_CHILD;
    public static int DWMWA_CLOAKED;
    internal static int COMPLEXREGION;
    public static int MONITOR_DEFAULTTONULL;
    public static int GetWindowThreadProcessId(HWND hWnd, Int32& lpdwProcessId);
    public static int GetSystemMetrics(int metric);
    public static bool GetGUIThreadInfo(int idThread, GUITHREADINFO& guiThreadInfo);
    public static HWND GetAncestor(HWND hwnd, int gaFlags);
    public static HWND GetDesktopWindow();
    public static bool EnumThreadWindows(int dwThreadId, EnumThreadWndProc enumThreadWndProc, IntPtr lParam);
    public static bool GetClientRect(HWND hwnd, RECT& rc);
    public static bool GetWindowRect(HWND hwnd, RECT& rc);
    public static bool IsWindow(HWND hwnd);
    public static bool IsWindowEnabled(HWND hwnd);
    public static bool IsWindowVisible(HWND hwnd);
    public static bool IsIconic(HWND hwnd);
    public static int GetClassName(HWND hWnd, StringBuilder classname, int nMax);
    public static int RealGetWindowClass(HWND hWnd, StringBuilder classname, int nMax);
    internal static bool IsChild(HWND parent, HWND child);
    internal static int DwmGetWindowAttribute(HWND hwnd, int dwAttributeToGet, Int32& pvAttributeValue, int cbAttribute);
    internal static IntPtr CreateRectRgn(int left, int top, int right, int bottom);
    internal static int GetWindowRgn(IntPtr hwnd, IntPtr hrgn);
    internal static bool PtInRegion(IntPtr hrgn, int x, int y);
    public static short GlobalAddAtom(string lpString);
    public static int GetModuleFileNameEx(SafeProcessHandle hProcess, IntPtr hModule, StringBuilder buffer, int length);
    public static IntPtr MonitorFromRect(RECT& rect, int dwFlags);
    public static bool PhysicalToLogicalPoint(HWND hwnd, POINT& pt);
    public static UInt32 GetTickCount();
}
internal static class MS.Win32.UnsafeNativeMethods : object {
    public static IntPtr INVALID_HANDLE_VALUE;
    public static int PROCESS_VM_READ;
    public static int PROCESS_DUP_HANDLE;
    public static int PROCESS_QUERY_INFORMATION;
    public static int VK_SHIFT;
    public static int VK_CONTROL;
    public static int VK_MENU;
    public static int KEYEVENTF_EXTENDEDKEY;
    public static int KEYEVENTF_KEYUP;
    public static int KEYEVENTF_UNICODE;
    public static int KEYEVENTF_SCANCODE;
    public static int MOUSEEVENTF_VIRTUALDESK;
    public static int INPUT_MOUSE;
    public static int INPUT_KEYBOARD;
    public static int CHILDID_SELF;
    public static int STATE_SYSTEM_UNAVAILABLE;
    public static int STATE_SYSTEM_FOCUSED;
    public static int OBJID_CARET;
    public static int OBJID_CLIENT;
    public static int OBJID_MENU;
    public static int OBJID_SYSMENU;
    public static int OBJID_WINDOW;
    public static int SMTO_ABORTIFHUNG;
    public static int PM_REMOVE;
    public static int WM_NULL;
    public static int WM_GETTEXT;
    public static int WM_GETTEXTLENGTH;
    public static int WM_QUIT;
    public static int WM_GETMINMAXINFO;
    public static int WM_GETOBJECT;
    public static int WM_NCHITTEST;
    public static IntPtr HTTRANSPARENT;
    public static IntPtr HTCLIENT;
    public static int WM_SYSCOMMAND;
    public static int WM_MDIACTIVATE;
    public static int SC_SIZE;
    public static int SC_MOVE;
    public static int SC_MINIMIZE;
    public static int SC_MAXIMIZE;
    public static int SC_CLOSE;
    public static int SC_RESTORE;
    public static int WM_HOTKEY;
    public static int LB_GETCURSEL;
    public static int QS_KEY;
    public static int QS_MOUSEMOVE;
    public static int QS_MOUSEBUTTON;
    public static int QS_POSTMESSAGE;
    public static int QS_TIMER;
    public static int QS_PAINT;
    public static int QS_SENDMESSAGE;
    public static int QS_HOTKEY;
    public static int QS_ALLPOSTMESSAGE;
    public static int QS_MOUSE;
    public static int QS_INPUT;
    public static int QS_ALLEVENTS;
    public static int QS_ALLINPUT;
    public static int INFINITE;
    public static int WAIT_FAILED;
    public static int WAIT_TIMEOUT;
    public static int WPF_SETMINPOSITION;
    public static int SW_RESTORE;
    public static int SWP_NOACTIVATE;
    public static int SWP_NOSIZE;
    public static int SWP_NOZORDER;
    internal static int MF_BYCOMMAND;
    internal static int MF_BYPOSITION;
    internal static int MF_GRAYED;
    internal static int MF_DISABLED;
    private static UnsafeNativeMethods();
    public static bool CloseHandle(IntPtr handle);
    public static IntPtr OpenProcess(int dwDesiredAccess, bool fInherit, int dwProcessId);
    public static int SendInput(int nInputs, INPUT& mi, int cbSize);
    public static int MapVirtualKey(int nVirtKey, int nMapType);
    public static short GetAsyncKeyState(int nVirtKey);
    public static bool RegisterHotKey(HWND hWnd, int id, int fsModifiers, int vk);
    public static bool UnregisterHotKey(HWND hWnd, int id);
    public static void SwitchToThisWindow(HWND hwnd, bool fAltTab);
    public static int AccessibleObjectFromEvent(IntPtr hwnd, int idObject, int idChild, IAccessible& ppvObject, Object& varChild);
    public static int WindowFromAccessibleObject(IAccessible acc, IntPtr& hwnd);
    internal static IntPtr GetProcessHandleFromHwnd(IntPtr hwnd);
    internal static IntPtr SetWinEventHook(int eventMin, int eventMax, IntPtr hmodWinEventProc, WinEventProcDef WinEventReentrancyFilter, UInt32 idProcess, UInt32 idThread, int dwFlags);
    internal static bool UnhookWinEvent(IntPtr winEventHook);
    private static IntPtr IntWindowFromPoint(POINTSTRUCT pt);
    private static IntPtr IntWindowFromPhysicalPoint(POINTSTRUCT pt);
    public static IntPtr WindowFromPhysicalPoint(int x, int y);
    public static IntPtr SendMessageTimeout(HWND hwnd, int Msg, IntPtr wParam, IntPtr lParam, int flags, int uTimeout, IntPtr& pResult);
    public static IntPtr SendMessageTimeout(HWND hwnd, int Msg, IntPtr wParam, MINMAXINFO& lParam, int flags, int uTimeout, IntPtr& pResult);
    public static IntPtr SendMessageTimeout(HWND hwnd, int Msg, IntPtr wParam, StringBuilder lParam, int flags, int uTimeout, IntPtr& pResult);
    public static int GetMessage(MSG& msg, HWND hwnd, int nMsgFilterMin, int nMsgFilterMax);
    public static bool PeekMessage(MSG& msg, HWND hwnd, int nMsgFilterMin, int nMsgFilterMax, int wRemoveMsg);
    public static bool TranslateMessage(MSG& msg);
    public static IntPtr DispatchMessage(MSG& msg);
    public static bool PostMessage(HWND hWnd, int nMsg, IntPtr wParam, IntPtr lParam);
    public static int MsgWaitForMultipleObjects(int nCount, IntPtr[] handles, bool fWaitAll, int dwMilliseconds, int dwWakeMask);
    public static bool SetWindowPlacement(HWND hwnd, WINDOWPLACEMENT& wp);
    public static bool GetWindowPlacement(HWND hwnd, WINDOWPLACEMENT& wp);
    internal static bool SetWindowPos(HWND hWnd, HWND hWndInsertAfter, int x, int y, int cx, int cy, int flags);
    internal static int GetMenuState(IntPtr hMenu, int uId, int uFlags);
    internal static bool DeleteObject(IntPtr hrgn);
    internal static IntPtr GetProp(IntPtr hwnd, string name);
}
internal static class System.SR : object {
    private static ResourceManager ResourceManager { get; }
    public static string Get(string name);
    public static string Get(string name, Object[] args);
    private static ResourceManager get_ResourceManager();
    private static bool UsingResourceKeys();
    internal static string GetResourceString(string resourceKey, string defaultString);
    internal static string Format(string resourceFormat, Object[] args);
    internal static string Format(string resourceFormat, object p1);
    internal static string Format(string resourceFormat, object p1, object p2);
    internal static string Format(string resourceFormat, object p1, object p2, object p3);
}
internal static class System.SRID : object {
    private static ResourceManager s_resourceManager;
    [CompilerGeneratedAttribute]
private static CultureInfo <Culture>k__BackingField;
    internal static string Assembly0NotFound;
    internal static string AtLeastOnePropertyMustBeSpecified;
    internal static string CachedPropertyNotRequested;
    internal static string CacheReqestCanOnlyPopTop;
    internal static string CacheReqestCantModifyWhileActive;
    internal static string CacheRequestNeedCache;
    internal static string CacheRequestNeedElementReference;
    internal static string CacheRequestNeedLiveForProperties;
    internal static string CantPrefetchTextPattern;
    internal static string CouldNotFindRegisterMethodOnType0InAssembly1;
    internal static string CouldNotFindType0InAssembly1;
    internal static string EventIdMustNotBeAutomationFocusChanged;
    internal static string EventIdMustNotBeAutomationPropertyChanged;
    internal static string EventIdMustNotBeStructureChanged;
    internal static string GenericInvalidArgument;
    internal static string HwndMustBeNonNULL;
    internal static string IgnoreCaseRequiresString;
    internal static string LogicalElementNoClickablePoint;
    internal static string MustBeAtLeastTwoConditions;
    internal static string NonclientClassnameCannotBeUsedWithFlagsOrImagename;
    internal static string OperationCannotBePerformed;
    internal static string ParamsNotApplicableToWindowClosedEvent;
    internal static string PropertyConditionIncorrectType;
    internal static string ScreenCoordinatesOutsideBoundingRect;
    internal static string SetFocusFailed;
    internal static string TextAttributeValueWrongType;
    internal static string TextMustNotBeNullOrEmpty;
    internal static string TreeScopeElementChildrenDescendantsOnly;
    internal static string TreeScopeNeedAtLeastOne;
    internal static string UnexpectedWindowState;
    internal static string UnknownCoreAPIError;
    internal static string UnsupportedAttribute;
    internal static string UnsupportedPattern;
    internal static string UnsupportedProperty;
    internal static string ValueReadonly;
    internal static ResourceManager ResourceManager { get; }
    internal static CultureInfo Culture { get; internal set; }
    internal static ResourceManager get_ResourceManager();
    [CompilerGeneratedAttribute]
internal static CultureInfo get_Culture();
    [CompilerGeneratedAttribute]
internal static void set_Culture(CultureInfo value);
    internal static string GetResourceString(string resourceKey, string defaultValue);
}
public class System.Windows.Automation.AndCondition : Condition {
    private Condition[] _conditions;
    private SafeConditionMemoryHandle _conditionArrayHandle;
    public AndCondition(Condition[] conditions);
    public Condition[] GetConditions();
}
public static class System.Windows.Automation.Automation : object {
    public static Condition RawViewCondition;
    public static Condition ControlViewCondition;
    public static Condition ContentViewCondition;
    private static Automation();
    public static bool Compare(AutomationElement el1, AutomationElement el2);
    public static bool Compare(Int32[] runtimeId1, Int32[] runtimeId2);
    public static string PropertyName(AutomationProperty property);
    public static string PatternName(AutomationPattern pattern);
    public static void AddAutomationEventHandler(AutomationEvent eventId, AutomationElement element, TreeScope scope, AutomationEventHandler eventHandler);
    public static void RemoveAutomationEventHandler(AutomationEvent eventId, AutomationElement element, AutomationEventHandler eventHandler);
    public static void AddAutomationPropertyChangedEventHandler(AutomationElement element, TreeScope scope, AutomationPropertyChangedEventHandler eventHandler, AutomationProperty[] properties);
    public static void RemoveAutomationPropertyChangedEventHandler(AutomationElement element, AutomationPropertyChangedEventHandler eventHandler);
    public static void AddStructureChangedEventHandler(AutomationElement element, TreeScope scope, StructureChangedEventHandler eventHandler);
    public static void RemoveStructureChangedEventHandler(AutomationElement element, StructureChangedEventHandler eventHandler);
    public static void AddAutomationFocusChangedEventHandler(AutomationFocusChangedEventHandler eventHandler);
    public static void RemoveAutomationFocusChangedEventHandler(AutomationFocusChangedEventHandler eventHandler);
    public static void RemoveAllEventHandlers();
}
public class System.Windows.Automation.AutomationElement : object {
    public static object NotSupported;
    public static AutomationProperty IsControlElementProperty;
    public static AutomationProperty ControlTypeProperty;
    public static AutomationProperty IsContentElementProperty;
    public static AutomationProperty LabeledByProperty;
    public static AutomationProperty NativeWindowHandleProperty;
    public static AutomationProperty AutomationIdProperty;
    public static AutomationProperty ItemTypeProperty;
    public static AutomationProperty IsPasswordProperty;
    public static AutomationProperty LocalizedControlTypeProperty;
    public static AutomationProperty NameProperty;
    public static AutomationProperty AcceleratorKeyProperty;
    public static AutomationProperty AccessKeyProperty;
    public static AutomationProperty HasKeyboardFocusProperty;
    public static AutomationProperty IsKeyboardFocusableProperty;
    public static AutomationProperty IsEnabledProperty;
    public static AutomationProperty BoundingRectangleProperty;
    public static AutomationProperty ProcessIdProperty;
    public static AutomationProperty RuntimeIdProperty;
    public static AutomationProperty ClassNameProperty;
    public static AutomationProperty HelpTextProperty;
    public static AutomationProperty ClickablePointProperty;
    public static AutomationProperty CultureProperty;
    public static AutomationProperty IsOffscreenProperty;
    public static AutomationProperty OrientationProperty;
    public static AutomationProperty FrameworkIdProperty;
    public static AutomationProperty IsRequiredForFormProperty;
    public static AutomationProperty ItemStatusProperty;
    public static AutomationProperty SizeOfSetProperty;
    public static AutomationProperty PositionInSetProperty;
    public static AutomationProperty IsDockPatternAvailableProperty;
    public static AutomationProperty IsExpandCollapsePatternAvailableProperty;
    public static AutomationProperty IsGridItemPatternAvailableProperty;
    public static AutomationProperty IsGridPatternAvailableProperty;
    public static AutomationProperty IsInvokePatternAvailableProperty;
    public static AutomationProperty IsMultipleViewPatternAvailableProperty;
    public static AutomationProperty IsRangeValuePatternAvailableProperty;
    public static AutomationProperty IsSelectionItemPatternAvailableProperty;
    public static AutomationProperty IsSelectionPatternAvailableProperty;
    public static AutomationProperty IsScrollPatternAvailableProperty;
    public static AutomationProperty IsSynchronizedInputPatternAvailableProperty;
    public static AutomationProperty IsScrollItemPatternAvailableProperty;
    public static AutomationProperty IsVirtualizedItemPatternAvailableProperty;
    public static AutomationProperty IsItemContainerPatternAvailableProperty;
    public static AutomationProperty IsTablePatternAvailableProperty;
    public static AutomationProperty IsTableItemPatternAvailableProperty;
    public static AutomationProperty IsTextPatternAvailableProperty;
    public static AutomationProperty IsTogglePatternAvailableProperty;
    public static AutomationProperty IsTransformPatternAvailableProperty;
    public static AutomationProperty IsValuePatternAvailableProperty;
    public static AutomationProperty IsWindowPatternAvailableProperty;
    public static AutomationEvent ToolTipOpenedEvent;
    public static AutomationEvent ToolTipClosedEvent;
    public static AutomationEvent StructureChangedEvent;
    public static AutomationEvent MenuOpenedEvent;
    public static AutomationEvent AutomationPropertyChangedEvent;
    public static AutomationEvent AutomationFocusChangedEvent;
    public static AutomationEvent AsyncContentLoadedEvent;
    public static AutomationEvent MenuClosedEvent;
    public static AutomationEvent LayoutInvalidatedEvent;
    private SafeNodeHandle _hnode;
    private Int32[] _runtimeId;
    private Object[0...,0...] _cachedValues;
    private int _cachedValuesIndex;
    private UiaCacheRequest _request;
    private AutomationElement _cachedParent;
    private AutomationElement _cachedFirstChild;
    private AutomationElement _cachedNextSibling;
    public static AutomationElement RootElement { get; }
    public static AutomationElement FocusedElement { get; }
    public AutomationElementInformation Cached { get; }
    public AutomationElementInformation Current { get; }
    public AutomationElement CachedParent { get; }
    public AutomationElementCollection CachedChildren { get; }
    internal SafeNodeHandle RawNode { get; }
    internal AutomationElement(SafeNodeHandle hnode, Object[0...,0...] cachedValues, int cachedValuesIndex, UiaCacheRequest request);
    private static AutomationElement();
    protected virtual override void Finalize();
    internal static AutomationElement Wrap(SafeNodeHandle hnode);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(AutomationElement left, AutomationElement right);
    public static bool op_Inequality(AutomationElement left, AutomationElement right);
    public Int32[] GetRuntimeId();
    public static AutomationElement FromPoint(Point pt);
    public static AutomationElement FromHandle(IntPtr hwnd);
    public static AutomationElement FromLocalProvider(IRawElementProviderSimple localImpl);
    public object GetCurrentPropertyValue(AutomationProperty property);
    public object GetCurrentPropertyValue(AutomationProperty property, bool ignoreDefaultValue);
    public object GetCurrentPattern(AutomationPattern pattern);
    public bool TryGetCurrentPattern(AutomationPattern pattern, Object& patternObject);
    public object GetCachedPropertyValue(AutomationProperty property);
    public object GetCachedPropertyValue(AutomationProperty property, bool ignoreDefaultValue);
    public object GetCachedPattern(AutomationPattern pattern);
    public bool TryGetCachedPattern(AutomationPattern pattern, Object& patternObject);
    public AutomationElement GetUpdatedCache(CacheRequest request);
    public AutomationElement FindFirst(TreeScope scope, Condition condition);
    public AutomationElementCollection FindAll(TreeScope scope, Condition condition);
    public AutomationProperty[] GetSupportedProperties();
    public AutomationPattern[] GetSupportedPatterns();
    public void SetFocus();
    public bool TryGetClickablePoint(Point& pt);
    public Point GetClickablePoint();
    public static AutomationElement get_RootElement();
    public static AutomationElement get_FocusedElement();
    public AutomationElementInformation get_Cached();
    public AutomationElementInformation get_Current();
    public AutomationElement get_CachedParent();
    public AutomationElementCollection get_CachedChildren();
    internal void CheckElement();
    internal AutomationElement Navigate(NavigateDirection direction, Condition condition, CacheRequest request);
    internal AutomationElement Normalize(Condition condition, CacheRequest request);
    internal object GetPatternPropertyValue(AutomationProperty property, bool useCache);
    internal void SetCachedParent(AutomationElement cachedParent);
    internal void SetCachedFirstChild(AutomationElement cachedFirstChild);
    internal void SetCachedNextSibling(AutomationElement cachedNextSibling);
    internal SafeNodeHandle get_RawNode();
    private object LookupCachedValue(AutomationIdentifier id, bool throwIfNotRequested, bool wrap);
    private static AutomationElement DrillForPointOrFocus(bool atPoint, Point pt, UiaCacheRequest cacheRequest);
    private UiaCacheResponse[] Find(TreeScope scope, Condition condition, UiaCacheRequest request, bool findFirst, BackgroundWorker worker);
}
[DefaultMemberAttribute("Item")]
public class System.Windows.Automation.AutomationElementCollection : object {
    private AutomationElement[] _elements;
    public AutomationElement Item { get; }
    public int Count { get; }
    public object SyncRoot { get; }
    public bool IsSynchronized { get; }
    internal AutomationElementCollection(AutomationElement[] elements);
    public AutomationElement get_Item(int index);
    public virtual void CopyTo(Array array, int index);
    public void CopyTo(AutomationElement[] array, int index);
    public sealed virtual int get_Count();
    public virtual object get_SyncRoot();
    public virtual bool get_IsSynchronized();
    public sealed virtual IEnumerator GetEnumerator();
}
public enum System.Windows.Automation.AutomationElementMode : Enum {
    public int value__;
    public static AutomationElementMode None;
    public static AutomationElementMode Full;
}
public class System.Windows.Automation.AutomationFocusChangedEventArgs : AutomationEventArgs {
    private int _idObject;
    private int _idChild;
    public int ObjectId { get; }
    public int ChildId { get; }
    public AutomationFocusChangedEventArgs(int idObject, int idChild);
    public int get_ObjectId();
    public int get_ChildId();
}
public class System.Windows.Automation.AutomationFocusChangedEventHandler : MulticastDelegate {
    public AutomationFocusChangedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, AutomationFocusChangedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, AutomationFocusChangedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Windows.Automation.BasePattern : object {
    internal AutomationElement _el;
    private SafePatternHandle _hPattern;
    internal BasePattern(AutomationElement el, SafePatternHandle hPattern);
    protected virtual override void Finalize();
}
public class System.Windows.Automation.CacheRequest : object {
    private Condition _viewCondition;
    private TreeScope _scope;
    private ArrayList _properties;
    private ArrayList _patterns;
    private AutomationElementMode _automationElementMode;
    private UiaCacheRequest _uiaCacheRequest;
    private int _refCount;
    private object _instanceLock;
    [ThreadStaticAttribute]
private static Stack _threadStack;
    internal static CacheRequest DefaultCacheRequest;
    internal static UiaCacheRequest _defaultUiaCacheRequest;
    public TreeScope TreeScope { get; public set; }
    public Condition TreeFilter { get; public set; }
    public AutomationElementMode AutomationElementMode { get; public set; }
    public static CacheRequest Current { get; }
    internal static UiaCacheRequest DefaultUiaCacheRequest { get; }
    internal static UiaCacheRequest CurrentUiaCacheRequest { get; }
    private CacheRequest(Condition viewCondition, TreeScope scope, ArrayList properties, ArrayList patterns, AutomationElementMode automationElementMode, UiaCacheRequest uiaCacheRequest);
    private static CacheRequest();
    public void Push();
    public void Pop();
    public IDisposable Activate();
    public CacheRequest Clone();
    public void Add(AutomationProperty property);
    public void Add(AutomationPattern pattern);
    public TreeScope get_TreeScope();
    public void set_TreeScope(TreeScope value);
    public Condition get_TreeFilter();
    public void set_TreeFilter(Condition value);
    public AutomationElementMode get_AutomationElementMode();
    public void set_AutomationElementMode(AutomationElementMode value);
    public static CacheRequest get_Current();
    internal static UiaCacheRequest get_DefaultUiaCacheRequest();
    internal UiaCacheRequest GetUiaCacheRequest();
    internal static UiaCacheRequest get_CurrentUiaCacheRequest();
    private void CheckAccess();
    private void Invalidate();
}
internal class System.Windows.Automation.CacheRequestActivation : object {
    private CacheRequest _request;
    internal CacheRequestActivation(CacheRequest request);
    public sealed virtual void Dispose();
}
internal static class System.Windows.Automation.ClickablePoint : object {
    public static bool HitTestForClickablePoint(AutomationElement el, Point& pt);
    private static bool TryLinePattern(Point& pt, Rect& rect, AutomationElement el);
    private static bool TrySparsePattern(Point& pt, Rect& rect, AutomationElement el);
    private static bool TryPattern(double x, double y, Point& pt, Rect& rect, AutomationElement el);
    private static bool TryPoint(Point& pt, AutomationElement el);
    private static bool TryPoint(Point& pt, AutomationElement el, AutomationElement& hitEl);
    private static bool IsTopLevelWindowObscuring(AutomationElement target, Rect targetRect, AutomationElement hitTarget);
    private static AutomationElement GetTopLevelAncestor(AutomationElement target);
}
public static class System.Windows.Automation.ClientSettings : object {
    public static void RegisterClientSideProviderAssembly(AssemblyName assemblyName);
    public static void RegisterClientSideProviders(ClientSideProviderDescription[] clientSideProviderDescription);
}
public class System.Windows.Automation.ClientSideProviderDescription : ValueType {
    private string _className;
    private string _imageName;
    private ClientSideProviderMatchIndicator _flags;
    private ClientSideProviderFactoryCallback _proxyFactoryCallback;
    public string ClassName { get; }
    public ClientSideProviderMatchIndicator Flags { get; }
    public string ImageName { get; }
    public ClientSideProviderFactoryCallback ClientSideProviderFactoryCallback { get; }
    public ClientSideProviderDescription(ClientSideProviderFactoryCallback clientSideProviderFactoryCallback, string className);
    public ClientSideProviderDescription(ClientSideProviderFactoryCallback clientSideProviderFactoryCallback, string className, string imageName, ClientSideProviderMatchIndicator flags);
    public string get_ClassName();
    public ClientSideProviderMatchIndicator get_Flags();
    public string get_ImageName();
    public ClientSideProviderFactoryCallback get_ClientSideProviderFactoryCallback();
}
public class System.Windows.Automation.ClientSideProviderFactoryCallback : MulticastDelegate {
    public ClientSideProviderFactoryCallback(object object, IntPtr method);
    public virtual IRawElementProviderSimple Invoke(IntPtr hwnd, int idChild, int idObject);
    public virtual IAsyncResult BeginInvoke(IntPtr hwnd, int idChild, int idObject, AsyncCallback callback, object object);
    public virtual IRawElementProviderSimple EndInvoke(IAsyncResult result);
}
[FlagsAttribute]
public enum System.Windows.Automation.ClientSideProviderMatchIndicator : Enum {
    public int value__;
    public static ClientSideProviderMatchIndicator None;
    public static ClientSideProviderMatchIndicator AllowSubstringMatch;
    public static ClientSideProviderMatchIndicator DisallowBaseClassNameMatch;
}
public abstract class System.Windows.Automation.Condition : object {
    public static Condition TrueCondition;
    public static Condition FalseCondition;
    internal SafeConditionMemoryHandle _safeHandle;
    private static Condition();
    internal void SetMarshalData(object uiaCondition);
}
public class System.Windows.Automation.DockPattern : BasePattern {
    public static AutomationPattern Pattern;
    public static AutomationProperty DockPositionProperty;
    private SafePatternHandle _hPattern;
    private bool _cached;
    public DockPatternInformation Cached { get; }
    public DockPatternInformation Current { get; }
    private DockPattern(AutomationElement el, SafePatternHandle hPattern, bool cached);
    private static DockPattern();
    public void SetDockPosition(DockPosition dockPosition);
    public DockPatternInformation get_Cached();
    public DockPatternInformation get_Current();
    internal static object Wrap(AutomationElement el, SafePatternHandle hPattern, bool cached);
}
public class System.Windows.Automation.ExpandCollapsePattern : BasePattern {
    public static AutomationPattern Pattern;
    public static AutomationProperty ExpandCollapseStateProperty;
    private SafePatternHandle _hPattern;
    private bool _cached;
    public ExpandCollapsePatternInformation Cached { get; }
    public ExpandCollapsePatternInformation Current { get; }
    private ExpandCollapsePattern(AutomationElement el, SafePatternHandle hPattern, bool cached);
    private static ExpandCollapsePattern();
    public void Expand();
    public void Collapse();
    public ExpandCollapsePatternInformation get_Cached();
    public ExpandCollapsePatternInformation get_Current();
    internal static object Wrap(AutomationElement el, SafePatternHandle hPattern, bool cached);
}
public class System.Windows.Automation.GridItemPattern : BasePattern {
    public static AutomationPattern Pattern;
    public static AutomationProperty RowProperty;
    public static AutomationProperty ColumnProperty;
    public static AutomationProperty RowSpanProperty;
    public static AutomationProperty ColumnSpanProperty;
    public static AutomationProperty ContainingGridProperty;
    private SafePatternHandle _hPattern;
    internal bool _cached;
    public GridItemPatternInformation Cached { get; }
    public GridItemPatternInformation Current { get; }
    internal GridItemPattern(AutomationElement el, SafePatternHandle hPattern, bool cached);
    private static GridItemPattern();
    public GridItemPatternInformation get_Cached();
    public GridItemPatternInformation get_Current();
    internal static object Wrap(AutomationElement el, SafePatternHandle hPattern, bool cached);
}
public class System.Windows.Automation.GridPattern : BasePattern {
    public static AutomationPattern Pattern;
    public static AutomationProperty RowCountProperty;
    public static AutomationProperty ColumnCountProperty;
    internal SafePatternHandle _hPattern;
    internal bool _cached;
    public GridPatternInformation Cached { get; }
    public GridPatternInformation Current { get; }
    internal GridPattern(AutomationElement el, SafePatternHandle hPattern, bool cached);
    private static GridPattern();
    public AutomationElement GetItem(int row, int column);
    public GridPatternInformation get_Cached();
    public GridPatternInformation get_Current();
    internal static object Wrap(AutomationElement el, SafePatternHandle hPattern, bool cached);
}
public class System.Windows.Automation.InvokePattern : BasePattern {
    public static AutomationPattern Pattern;
    public static AutomationEvent InvokedEvent;
    private SafePatternHandle _hPattern;
    private InvokePattern(AutomationElement el, SafePatternHandle hPattern);
    private static InvokePattern();
    public void Invoke();
    internal static object Wrap(AutomationElement el, SafePatternHandle hPattern, bool cached);
}
public class System.Windows.Automation.ItemContainerPattern : BasePattern {
    public static AutomationPattern Pattern;
    private SafePatternHandle _hPattern;
    private ItemContainerPattern(AutomationElement el, SafePatternHandle hPattern);
    private static ItemContainerPattern();
    public AutomationElement FindItemByProperty(AutomationElement startAfter, AutomationProperty property, object value);
    private object PropertyValueValidateAndMap(AutomationProperty property, object value);
    internal static object Wrap(AutomationElement el, SafePatternHandle hPattern, bool cached);
}
public class System.Windows.Automation.MultipleViewPattern : BasePattern {
    public static AutomationPattern Pattern;
    public static AutomationProperty CurrentViewProperty;
    public static AutomationProperty SupportedViewsProperty;
    private SafePatternHandle _hPattern;
    private bool _cached;
    public MultipleViewPatternInformation Cached { get; }
    public MultipleViewPatternInformation Current { get; }
    private MultipleViewPattern(AutomationElement el, SafePatternHandle hPattern, bool cached);
    private static MultipleViewPattern();
    public string GetViewName(int viewId);
    public void SetCurrentView(int viewId);
    public MultipleViewPatternInformation get_Cached();
    public MultipleViewPatternInformation get_Current();
    internal static object Wrap(AutomationElement el, SafePatternHandle hPattern, bool cached);
}
public class System.Windows.Automation.NotCondition : Condition {
    private Condition _condition;
    public Condition Condition { get; }
    public NotCondition(Condition condition);
    public Condition get_Condition();
}
public class System.Windows.Automation.OrCondition : Condition {
    private Condition[] _conditions;
    private SafeConditionMemoryHandle _conditionArrayHandle;
    public OrCondition(Condition[] conditions);
    public Condition[] GetConditions();
}
public class System.Windows.Automation.PropertyCondition : Condition {
    private AutomationProperty _property;
    private object _val;
    private PropertyConditionFlags _flags;
    public AutomationProperty Property { get; }
    public object Value { get; }
    public PropertyConditionFlags Flags { get; }
    public PropertyCondition(AutomationProperty property, object value);
    public PropertyCondition(AutomationProperty property, object value, PropertyConditionFlags flags);
    public AutomationProperty get_Property();
    public object get_Value();
    public PropertyConditionFlags get_Flags();
    private void Init(AutomationProperty property, object val, PropertyConditionFlags flags);
}
[FlagsAttribute]
public enum System.Windows.Automation.PropertyConditionFlags : Enum {
    public int value__;
    public static PropertyConditionFlags None;
    public static PropertyConditionFlags IgnoreCase;
}
public class System.Windows.Automation.RangeValuePattern : BasePattern {
    public static AutomationPattern Pattern;
    public static AutomationProperty ValueProperty;
    public static AutomationProperty IsReadOnlyProperty;
    public static AutomationProperty MinimumProperty;
    public static AutomationProperty MaximumProperty;
    public static AutomationProperty LargeChangeProperty;
    public static AutomationProperty SmallChangeProperty;
    private SafePatternHandle _hPattern;
    private bool _cached;
    public RangeValuePatternInformation Cached { get; }
    public RangeValuePatternInformation Current { get; }
    private RangeValuePattern(AutomationElement el, SafePatternHandle hPattern, bool cached);
    private static RangeValuePattern();
    public void SetValue(double value);
    public RangeValuePatternInformation get_Cached();
    public RangeValuePatternInformation get_Current();
    internal static object Wrap(AutomationElement el, SafePatternHandle hPattern, bool cached);
}
internal class System.Windows.Automation.SafeConditionMemoryHandle : SafeHandle {
    internal static SafeConditionMemoryHandle NullHandle;
    public bool IsInvalid { get; }
    private static SafeConditionMemoryHandle();
    public virtual bool get_IsInvalid();
    protected virtual bool ReleaseHandle();
    internal static SafeConditionMemoryHandle AllocateConditionHandle(object uiaCondition);
    internal static SafeConditionMemoryHandle AllocateConditionArrayHandle(Condition[] conditions);
}
public class System.Windows.Automation.ScrollItemPattern : BasePattern {
    public static AutomationPattern Pattern;
    private SafePatternHandle _hPattern;
    private ScrollItemPattern(AutomationElement el, SafePatternHandle hPattern);
    private static ScrollItemPattern();
    public void ScrollIntoView();
    internal static object Wrap(AutomationElement el, SafePatternHandle hPattern, bool cached);
}
public class System.Windows.Automation.ScrollPattern : BasePattern {
    public static double NoScroll;
    public static AutomationPattern Pattern;
    public static AutomationProperty HorizontalScrollPercentProperty;
    public static AutomationProperty HorizontalViewSizeProperty;
    public static AutomationProperty VerticalScrollPercentProperty;
    public static AutomationProperty VerticalViewSizeProperty;
    public static AutomationProperty HorizontallyScrollableProperty;
    public static AutomationProperty VerticallyScrollableProperty;
    private SafePatternHandle _hPattern;
    private bool _cached;
    public ScrollPatternInformation Cached { get; }
    public ScrollPatternInformation Current { get; }
    private ScrollPattern(AutomationElement el, SafePatternHandle hPattern, bool cached);
    private static ScrollPattern();
    public void SetScrollPercent(double horizontalPercent, double verticalPercent);
    public void Scroll(ScrollAmount horizontalAmount, ScrollAmount verticalAmount);
    public void ScrollHorizontal(ScrollAmount amount);
    public void ScrollVertical(ScrollAmount amount);
    public ScrollPatternInformation get_Cached();
    public ScrollPatternInformation get_Current();
    internal static object Wrap(AutomationElement el, SafePatternHandle hPattern, bool cached);
}
public class System.Windows.Automation.SelectionItemPattern : BasePattern {
    public static AutomationPattern Pattern;
    public static AutomationProperty IsSelectedProperty;
    public static AutomationProperty SelectionContainerProperty;
    public static AutomationEvent ElementAddedToSelectionEvent;
    public static AutomationEvent ElementRemovedFromSelectionEvent;
    public static AutomationEvent ElementSelectedEvent;
    private SafePatternHandle _hPattern;
    private bool _cached;
    public SelectionItemPatternInformation Cached { get; }
    public SelectionItemPatternInformation Current { get; }
    private SelectionItemPattern(AutomationElement el, SafePatternHandle hPattern, bool cached);
    private static SelectionItemPattern();
    public void Select();
    public void AddToSelection();
    public void RemoveFromSelection();
    public SelectionItemPatternInformation get_Cached();
    public SelectionItemPatternInformation get_Current();
    internal static object Wrap(AutomationElement el, SafePatternHandle hPattern, bool cached);
}
public class System.Windows.Automation.SelectionPattern : BasePattern {
    public static AutomationPattern Pattern;
    public static AutomationProperty SelectionProperty;
    public static AutomationProperty CanSelectMultipleProperty;
    public static AutomationProperty IsSelectionRequiredProperty;
    public static AutomationEvent InvalidatedEvent;
    private SafePatternHandle _hPattern;
    private bool _cached;
    public SelectionPatternInformation Cached { get; }
    public SelectionPatternInformation Current { get; }
    private SelectionPattern(AutomationElement el, SafePatternHandle hPattern, bool cached);
    private static SelectionPattern();
    public SelectionPatternInformation get_Cached();
    public SelectionPatternInformation get_Current();
    internal static object Wrap(AutomationElement el, SafePatternHandle hPattern, bool cached);
}
public class System.Windows.Automation.SynchronizedInputPattern : BasePattern {
    public static AutomationPattern Pattern;
    public static AutomationEvent InputReachedTargetEvent;
    public static AutomationEvent InputReachedOtherElementEvent;
    public static AutomationEvent InputDiscardedEvent;
    private SafePatternHandle _hPattern;
    private SynchronizedInputPattern(AutomationElement el, SafePatternHandle hPattern);
    private static SynchronizedInputPattern();
    public void StartListening(SynchronizedInputType inputType);
    public void Cancel();
    internal static object Wrap(AutomationElement el, SafePatternHandle hPattern, bool cached);
}
public class System.Windows.Automation.TableItemPattern : GridItemPattern {
    public static AutomationPattern Pattern;
    public static AutomationProperty RowHeaderItemsProperty;
    public static AutomationProperty ColumnHeaderItemsProperty;
    private SafePatternHandle _hPattern;
    public TableItemPatternInformation Cached { get; }
    public TableItemPatternInformation Current { get; }
    private TableItemPattern(AutomationElement el, SafePatternHandle hPattern, bool cached);
    private static TableItemPattern();
    public TableItemPatternInformation get_Cached();
    public TableItemPatternInformation get_Current();
    internal static object Wrap(AutomationElement el, SafePatternHandle hPattern, bool cached);
}
public class System.Windows.Automation.TablePattern : GridPattern {
    public static AutomationPattern Pattern;
    public static AutomationProperty RowHeadersProperty;
    public static AutomationProperty ColumnHeadersProperty;
    public static AutomationProperty RowOrColumnMajorProperty;
    public TablePatternInformation Cached { get; }
    public TablePatternInformation Current { get; }
    private TablePattern(AutomationElement el, SafePatternHandle hPattern, bool cached);
    private static TablePattern();
    public TablePatternInformation get_Cached();
    public TablePatternInformation get_Current();
    internal static object Wrap(AutomationElement el, SafePatternHandle hPattern, bool cached);
}
internal class System.Windows.Automation.Text.SafeTextRangeHandle : SafeHandle {
    public bool IsInvalid { get; }
    public virtual bool get_IsInvalid();
    protected virtual bool ReleaseHandle();
}
public class System.Windows.Automation.Text.TextPatternRange : object {
    private SafeTextRangeHandle _hTextRange;
    private TextPattern _pattern;
    public TextPattern TextPattern { get; }
    internal TextPatternRange(SafeTextRangeHandle hTextRange, TextPattern pattern);
    internal static TextPatternRange Wrap(SafeTextRangeHandle hTextRange, TextPattern pattern);
    internal static TextPatternRange[] Wrap(SafeTextRangeHandle[] hTextRanges, TextPattern pattern);
    public TextPatternRange Clone();
    public bool Compare(TextPatternRange range);
    public int CompareEndpoints(TextPatternRangeEndpoint endpoint, TextPatternRange targetRange, TextPatternRangeEndpoint targetEndpoint);
    public void ExpandToEnclosingUnit(TextUnit unit);
    public TextPatternRange FindAttribute(AutomationTextAttribute attribute, object value, bool backward);
    public TextPatternRange FindText(string text, bool backward, bool ignoreCase);
    public object GetAttributeValue(AutomationTextAttribute attribute);
    public Rect[] GetBoundingRectangles();
    public AutomationElement GetEnclosingElement();
    public string GetText(int maxLength);
    public int Move(TextUnit unit, int count);
    public int MoveEndpointByUnit(TextPatternRangeEndpoint endpoint, TextUnit unit, int count);
    public void MoveEndpointByRange(TextPatternRangeEndpoint endpoint, TextPatternRange targetRange, TextPatternRangeEndpoint targetEndpoint);
    public void Select();
    public void AddToSelection();
    public void RemoveFromSelection();
    public void ScrollIntoView(bool alignToTop);
    public AutomationElement[] GetChildren();
    public TextPattern get_TextPattern();
    private void ValidateEndpointArgument(TextPatternRangeEndpoint endpoint, string name);
    private void ValidateRangeArgument(TextPatternRange range, string name);
    private void ValidateUnitArgument(TextUnit unit, string name);
}
public class System.Windows.Automation.TextPattern : BasePattern {
    public static object MixedAttributeValue;
    public static AutomationTextAttribute AnimationStyleAttribute;
    public static AutomationTextAttribute BackgroundColorAttribute;
    public static AutomationTextAttribute BulletStyleAttribute;
    public static AutomationTextAttribute CapStyleAttribute;
    public static AutomationTextAttribute CultureAttribute;
    public static AutomationTextAttribute FontNameAttribute;
    public static AutomationTextAttribute FontSizeAttribute;
    public static AutomationTextAttribute FontWeightAttribute;
    public static AutomationTextAttribute ForegroundColorAttribute;
    public static AutomationTextAttribute HorizontalTextAlignmentAttribute;
    public static AutomationTextAttribute IndentationFirstLineAttribute;
    public static AutomationTextAttribute IndentationLeadingAttribute;
    public static AutomationTextAttribute IndentationTrailingAttribute;
    public static AutomationTextAttribute IsHiddenAttribute;
    public static AutomationTextAttribute IsItalicAttribute;
    public static AutomationTextAttribute IsReadOnlyAttribute;
    public static AutomationTextAttribute IsSubscriptAttribute;
    public static AutomationTextAttribute IsSuperscriptAttribute;
    public static AutomationTextAttribute MarginBottomAttribute;
    public static AutomationTextAttribute MarginLeadingAttribute;
    public static AutomationTextAttribute MarginTopAttribute;
    public static AutomationTextAttribute MarginTrailingAttribute;
    public static AutomationTextAttribute OutlineStylesAttribute;
    public static AutomationTextAttribute OverlineColorAttribute;
    public static AutomationTextAttribute OverlineStyleAttribute;
    public static AutomationTextAttribute StrikethroughColorAttribute;
    public static AutomationTextAttribute StrikethroughStyleAttribute;
    public static AutomationTextAttribute TabsAttribute;
    public static AutomationTextAttribute TextFlowDirectionsAttribute;
    public static AutomationTextAttribute UnderlineColorAttribute;
    public static AutomationTextAttribute UnderlineStyleAttribute;
    public static AutomationPattern Pattern;
    public static AutomationEvent TextSelectionChangedEvent;
    public static AutomationEvent TextChangedEvent;
    private SafePatternHandle _hPattern;
    private AutomationElement _element;
    public TextPatternRange DocumentRange { get; }
    public SupportedTextSelection SupportedTextSelection { get; }
    internal TextPattern(AutomationElement el, SafePatternHandle hPattern);
    private static TextPattern();
    public TextPatternRange[] GetSelection();
    public TextPatternRange[] GetVisibleRanges();
    public TextPatternRange RangeFromChild(AutomationElement childElement);
    public TextPatternRange RangeFromPoint(Point screenLocation);
    public TextPatternRange get_DocumentRange();
    public SupportedTextSelection get_SupportedTextSelection();
    internal static object Wrap(AutomationElement el, SafePatternHandle hPattern, bool cached);
    internal static bool Compare(TextPattern t1, TextPattern t2);
}
public class System.Windows.Automation.TogglePattern : BasePattern {
    public static AutomationPattern Pattern;
    public static AutomationProperty ToggleStateProperty;
    private SafePatternHandle _hPattern;
    private bool _cached;
    public TogglePatternInformation Cached { get; }
    public TogglePatternInformation Current { get; }
    private TogglePattern(AutomationElement el, SafePatternHandle hPattern, bool cached);
    private static TogglePattern();
    public void Toggle();
    public TogglePatternInformation get_Cached();
    public TogglePatternInformation get_Current();
    internal static object Wrap(AutomationElement el, SafePatternHandle hPattern, bool cached);
}
public class System.Windows.Automation.TransformPattern : BasePattern {
    public static AutomationPattern Pattern;
    public static AutomationProperty CanMoveProperty;
    public static AutomationProperty CanResizeProperty;
    public static AutomationProperty CanRotateProperty;
    private SafePatternHandle _hPattern;
    private bool _cached;
    public TransformPatternInformation Cached { get; }
    public TransformPatternInformation Current { get; }
    private TransformPattern(AutomationElement el, SafePatternHandle hPattern, bool cached);
    private static TransformPattern();
    public void Move(double x, double y);
    public void Resize(double width, double height);
    public void Rotate(double degrees);
    public TransformPatternInformation get_Cached();
    public TransformPatternInformation get_Current();
    internal static object Wrap(AutomationElement el, SafePatternHandle hPattern, bool cached);
}
public class System.Windows.Automation.TreeWalker : object {
    public static TreeWalker RawViewWalker;
    public static TreeWalker ControlViewWalker;
    public static TreeWalker ContentViewWalker;
    private Condition _condition;
    public Condition Condition { get; }
    public TreeWalker(Condition condition);
    private static TreeWalker();
    public AutomationElement GetParent(AutomationElement element);
    public AutomationElement GetFirstChild(AutomationElement element);
    public AutomationElement GetLastChild(AutomationElement element);
    public AutomationElement GetNextSibling(AutomationElement element);
    public AutomationElement GetPreviousSibling(AutomationElement element);
    public AutomationElement Normalize(AutomationElement element);
    public AutomationElement GetParent(AutomationElement element, CacheRequest request);
    public AutomationElement GetFirstChild(AutomationElement element, CacheRequest request);
    public AutomationElement GetLastChild(AutomationElement element, CacheRequest request);
    public AutomationElement GetNextSibling(AutomationElement element, CacheRequest request);
    public AutomationElement GetPreviousSibling(AutomationElement element, CacheRequest request);
    public AutomationElement Normalize(AutomationElement element, CacheRequest request);
    public Condition get_Condition();
}
public class System.Windows.Automation.ValuePattern : BasePattern {
    public static AutomationPattern Pattern;
    public static AutomationProperty ValueProperty;
    public static AutomationProperty IsReadOnlyProperty;
    private SafePatternHandle _hPattern;
    private bool _cached;
    public ValuePatternInformation Cached { get; }
    public ValuePatternInformation Current { get; }
    internal ValuePattern(AutomationElement el, SafePatternHandle hPattern, bool cached);
    private static ValuePattern();
    public void SetValue(string value);
    public ValuePatternInformation get_Cached();
    public ValuePatternInformation get_Current();
    internal static object Wrap(AutomationElement el, SafePatternHandle hPattern, bool cached);
}
public class System.Windows.Automation.VirtualizedItemPattern : BasePattern {
    public static AutomationPattern Pattern;
    private SafePatternHandle _hPattern;
    private VirtualizedItemPattern(AutomationElement el, SafePatternHandle hPattern);
    private static VirtualizedItemPattern();
    public void Realize();
    internal static object Wrap(AutomationElement el, SafePatternHandle hPattern, bool cached);
}
public class System.Windows.Automation.WindowPattern : BasePattern {
    public static AutomationPattern Pattern;
    public static AutomationProperty CanMaximizeProperty;
    public static AutomationProperty CanMinimizeProperty;
    public static AutomationProperty IsModalProperty;
    public static AutomationProperty WindowVisualStateProperty;
    public static AutomationProperty WindowInteractionStateProperty;
    public static AutomationProperty IsTopmostProperty;
    public static AutomationEvent WindowOpenedEvent;
    public static AutomationEvent WindowClosedEvent;
    private SafePatternHandle _hPattern;
    private bool _cached;
    public WindowPatternInformation Cached { get; }
    public WindowPatternInformation Current { get; }
    private WindowPattern(AutomationElement el, SafePatternHandle hPattern, bool cached);
    private static WindowPattern();
    public void SetWindowVisualState(WindowVisualState state);
    public void Close();
    public bool WaitForInputIdle(int milliseconds);
    public WindowPatternInformation get_Cached();
    public WindowPatternInformation get_Current();
    internal static object Wrap(AutomationElement el, SafePatternHandle hPattern, bool cached);
}
