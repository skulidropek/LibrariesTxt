[FlagsAttribute]
internal enum MimeKit.AddressParserFlags : Enum {
    public int value__;
    public static AddressParserFlags AllowMailboxAddress;
    public static AddressParserFlags AllowGroupAddress;
    public static AddressParserFlags ThrowOnError;
    public static AddressParserFlags Internal;
    public static AddressParserFlags TryParse;
    public static AddressParserFlags InternalTryParse;
    public static AddressParserFlags Parse;
}
[DefaultMemberAttribute("Item")]
public class MimeKit.AttachmentCollection : object {
    private static int BufferLength;
    private List`1<MimeEntity> attachments;
    private bool linked;
    public int Count { get; }
    public bool IsReadOnly { get; }
    public MimeEntity Item { get; public set; }
    public AttachmentCollection(bool linkedResources);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual MimeEntity get_Item(int index);
    public sealed virtual void set_Item(int index, MimeEntity value);
    private static void LoadContent(MimePart attachment, Stream stream, bool copyStream, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MimeKit.AttachmentCollection/<LoadContentAsync>d__13")]
private static Task LoadContentAsync(MimePart attachment, Stream stream, bool copyStream, CancellationToken cancellationToken);
    private static ContentType GetMimeType(string fileName);
    private static string GetFileName(string path);
    private MimeEntity CreateAttachment(ContentType contentType, bool autoDetected, string path, Stream stream, bool copyStream, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MimeKit.AttachmentCollection/<CreateAttachmentAsync>d__17")]
private Task`1<MimeEntity> CreateAttachmentAsync(ContentType contentType, bool autoDetected, string path, Stream stream, bool copyStream, CancellationToken cancellationToken);
    public MimeEntity Add(string fileName, Byte[] data, ContentType contentType);
    public MimeEntity Add(string fileName, Stream stream, ContentType contentType, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MimeKit.AttachmentCollection/<AddAsync>d__20")]
public Task`1<MimeEntity> AddAsync(string fileName, Stream stream, ContentType contentType, CancellationToken cancellationToken);
    public MimeEntity Add(string fileName, Byte[] data);
    public MimeEntity Add(string fileName, Stream stream, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MimeKit.AttachmentCollection/<AddAsync>d__23")]
public Task`1<MimeEntity> AddAsync(string fileName, Stream stream, CancellationToken cancellationToken);
    public MimeEntity Add(string fileName, ContentType contentType, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MimeKit.AttachmentCollection/<AddAsync>d__25")]
public Task`1<MimeEntity> AddAsync(string fileName, ContentType contentType, CancellationToken cancellationToken);
    public MimeEntity Add(string fileName, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MimeKit.AttachmentCollection/<AddAsync>d__27")]
public Task`1<MimeEntity> AddAsync(string fileName, CancellationToken cancellationToken);
    public sealed virtual void Add(MimeEntity attachment);
    public sealed virtual void Clear();
    public void Clear(bool dispose);
    public sealed virtual bool Contains(MimeEntity attachment);
    public sealed virtual void CopyTo(MimeEntity[] array, int arrayIndex);
    public sealed virtual int IndexOf(MimeEntity attachment);
    public sealed virtual void Insert(int index, MimeEntity attachment);
    public sealed virtual bool Remove(MimeEntity attachment);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual IEnumerator`1<MimeEntity> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class MimeKit.BodyBuilder : object {
    [CompilerGeneratedAttribute]
private AttachmentCollection <Attachments>k__BackingField;
    [CompilerGeneratedAttribute]
private AttachmentCollection <LinkedResources>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TextBody>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HtmlBody>k__BackingField;
    public AttachmentCollection Attachments { get; private set; }
    public AttachmentCollection LinkedResources { get; private set; }
    public string TextBody { get; public set; }
    public string HtmlBody { get; public set; }
    [CompilerGeneratedAttribute]
public AttachmentCollection get_Attachments();
    [CompilerGeneratedAttribute]
private void set_Attachments(AttachmentCollection value);
    [CompilerGeneratedAttribute]
public AttachmentCollection get_LinkedResources();
    [CompilerGeneratedAttribute]
private void set_LinkedResources(AttachmentCollection value);
    [CompilerGeneratedAttribute]
public string get_TextBody();
    [CompilerGeneratedAttribute]
public void set_TextBody(string value);
    [CompilerGeneratedAttribute]
public string get_HtmlBody();
    [CompilerGeneratedAttribute]
public void set_HtmlBody(string value);
    public MimeEntity ToMessageBody();
}
internal class MimeKit.Boundary : object {
    public static Byte[] MboxFrom;
    [CompilerGeneratedAttribute]
private Byte[] <Marker>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Length>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxLength>k__BackingField;
    public Byte[] Marker { get; private set; }
    public int FinalLength { get; }
    public int Length { get; private set; }
    public int MaxLength { get; private set; }
    public Boundary(string boundary, int currentMaxLength);
    private static Boundary();
    [CompilerGeneratedAttribute]
public Byte[] get_Marker();
    [CompilerGeneratedAttribute]
private void set_Marker(Byte[] value);
    public int get_FinalLength();
    [CompilerGeneratedAttribute]
public int get_Length();
    [CompilerGeneratedAttribute]
private void set_Length(int value);
    [CompilerGeneratedAttribute]
public int get_MaxLength();
    [CompilerGeneratedAttribute]
private void set_MaxLength(int value);
    public static Boundary CreateMboxBoundary();
}
internal enum MimeKit.BoundaryType : Enum {
    public int value__;
    public static BoundaryType None;
    public static BoundaryType Eos;
    public static BoundaryType ImmediateBoundary;
    public static BoundaryType ImmediateEndBoundary;
    public static BoundaryType ParentBoundary;
    public static BoundaryType ParentEndBoundary;
}
public class MimeKit.ContentDisposition : object {
    public static string Attachment;
    public static string FormData;
    public static string Inline;
    private ParameterList parameters;
    private string disposition;
    [CompilerGeneratedAttribute]
private EventHandler Changed;
    public string Disposition { get; public set; }
    public bool IsAttachment { get; public set; }
    public ParameterList Parameters { get; private set; }
    public string FileName { get; public set; }
    public Nullable`1<DateTimeOffset> CreationDate { get; public set; }
    public Nullable`1<DateTimeOffset> ModificationDate { get; public set; }
    public Nullable`1<DateTimeOffset> ReadDate { get; public set; }
    public Nullable`1<long> Size { get; public set; }
    public ContentDisposition(string disposition);
    private static bool IsAsciiAtom(byte c);
    public string get_Disposition();
    public void set_Disposition(string value);
    public bool get_IsAttachment();
    public void set_IsAttachment(bool value);
    public ParameterList get_Parameters();
    private void set_Parameters(ParameterList value);
    public string get_FileName();
    public void set_FileName(string value);
    public Nullable`1<DateTimeOffset> get_CreationDate();
    public void set_CreationDate(Nullable`1<DateTimeOffset> value);
    public Nullable`1<DateTimeOffset> get_ModificationDate();
    public void set_ModificationDate(Nullable`1<DateTimeOffset> value);
    public Nullable`1<DateTimeOffset> get_ReadDate();
    public void set_ReadDate(Nullable`1<DateTimeOffset> value);
    public Nullable`1<long> get_Size();
    public void set_Size(Nullable`1<long> value);
    public ContentDisposition Clone();
    internal string Encode(FormatOptions options, Encoding charset);
    public string ToString(FormatOptions options, Encoding charset, bool encode);
    public string ToString(Encoding charset, bool encode);
    public string ToString(bool encode);
    public virtual string ToString();
    [CompilerGeneratedAttribute]
internal void add_Changed(EventHandler value);
    [CompilerGeneratedAttribute]
internal void remove_Changed(EventHandler value);
    private void OnParametersChanged(object sender, EventArgs e);
    private void OnChanged();
    internal static bool TryParse(ParserOptions options, Byte[] text, Int32& index, int endIndex, bool throwOnError, ContentDisposition& disposition);
    public static bool TryParse(ParserOptions options, Byte[] buffer, int startIndex, int length, ContentDisposition& disposition);
    public static bool TryParse(Byte[] buffer, int startIndex, int length, ContentDisposition& disposition);
    public static bool TryParse(ParserOptions options, Byte[] buffer, int startIndex, ContentDisposition& disposition);
    public static bool TryParse(Byte[] buffer, int startIndex, ContentDisposition& disposition);
    public static bool TryParse(ParserOptions options, Byte[] buffer, ContentDisposition& disposition);
    public static bool TryParse(Byte[] buffer, ContentDisposition& disposition);
    public static bool TryParse(ParserOptions options, string text, ContentDisposition& disposition);
    public static bool TryParse(string text, ContentDisposition& disposition);
    public static ContentDisposition Parse(ParserOptions options, Byte[] buffer, int startIndex, int length);
    public static ContentDisposition Parse(Byte[] buffer, int startIndex, int length);
    public static ContentDisposition Parse(ParserOptions options, Byte[] buffer, int startIndex);
    public static ContentDisposition Parse(Byte[] buffer, int startIndex);
    public static ContentDisposition Parse(ParserOptions options, Byte[] buffer);
    public static ContentDisposition Parse(Byte[] buffer);
    public static ContentDisposition Parse(ParserOptions options, string text);
    public static ContentDisposition Parse(string text);
}
public enum MimeKit.ContentEncoding : Enum {
    public int value__;
    public static ContentEncoding Default;
    public static ContentEncoding SevenBit;
    public static ContentEncoding EightBit;
    public static ContentEncoding Binary;
    public static ContentEncoding Base64;
    public static ContentEncoding QuotedPrintable;
    public static ContentEncoding UUEncode;
}
public class MimeKit.ContentType : object {
    private ParameterList parameters;
    private string type;
    private string subtype;
    [CompilerGeneratedAttribute]
private EventHandler Changed;
    public string MediaType { get; public set; }
    public string MediaSubtype { get; public set; }
    public ParameterList Parameters { get; internal set; }
    public string Boundary { get; public set; }
    public string Charset { get; public set; }
    public Encoding CharsetEncoding { get; public set; }
    public string Format { get; public set; }
    public string MimeType { get; }
    public string Name { get; public set; }
    public ContentType(string mediaType, string mediaSubtype);
    public string get_MediaType();
    public void set_MediaType(string value);
    public string get_MediaSubtype();
    public void set_MediaSubtype(string value);
    public ParameterList get_Parameters();
    internal void set_Parameters(ParameterList value);
    public string get_Boundary();
    public void set_Boundary(string value);
    public string get_Charset();
    public void set_Charset(string value);
    public Encoding get_CharsetEncoding();
    public void set_CharsetEncoding(Encoding value);
    public string get_Format();
    public void set_Format(string value);
    public string get_MimeType();
    public string get_Name();
    public void set_Name(string value);
    public ContentType Clone();
    public bool IsMimeType(string mediaType, string mediaSubtype);
    internal string Encode(FormatOptions options, Encoding charset);
    public string ToString(FormatOptions options, Encoding charset, bool encode);
    public string ToString(Encoding charset, bool encode);
    public string ToString(bool encode);
    public virtual string ToString();
    [CompilerGeneratedAttribute]
internal void add_Changed(EventHandler value);
    [CompilerGeneratedAttribute]
internal void remove_Changed(EventHandler value);
    private void OnParametersChanged(object sender, EventArgs e);
    private void OnChanged();
    private static bool SkipType(Byte[] text, Int32& index, int endIndex);
    private static bool SkipSubtype(Byte[] text, Int32& index, int endIndex);
    internal static bool TryParse(ParserOptions options, Byte[] text, Int32& index, int endIndex, bool throwOnError, ContentType& contentType);
    public static bool TryParse(ParserOptions options, Byte[] buffer, int startIndex, int length, ContentType& type);
    public static bool TryParse(Byte[] buffer, int startIndex, int length, ContentType& type);
    public static bool TryParse(ParserOptions options, Byte[] buffer, int startIndex, ContentType& type);
    public static bool TryParse(Byte[] buffer, int startIndex, ContentType& type);
    public static bool TryParse(ParserOptions options, Byte[] buffer, ContentType& type);
    public static bool TryParse(Byte[] buffer, ContentType& type);
    public static bool TryParse(ParserOptions options, string text, ContentType& type);
    public static bool TryParse(string text, ContentType& type);
    public static ContentType Parse(ParserOptions options, Byte[] buffer, int startIndex, int length);
    public static ContentType Parse(Byte[] buffer, int startIndex, int length);
    public static ContentType Parse(ParserOptions options, Byte[] buffer, int startIndex);
    public static ContentType Parse(Byte[] buffer, int startIndex);
    public static ContentType Parse(ParserOptions options, Byte[] buffer);
    public static ContentType Parse(Byte[] buffer);
    public static ContentType Parse(ParserOptions options, string text);
    public static ContentType Parse(string text);
}
public class MimeKit.Cryptography.ApplicationPgpEncrypted : MimePart {
    public ApplicationPgpEncrypted(MimeEntityConstructorArgs args);
    private void CheckDisposed();
    public virtual void Accept(MimeVisitor visitor);
}
public class MimeKit.Cryptography.ApplicationPgpSignature : MimePart {
    public ApplicationPgpSignature(MimeEntityConstructorArgs args);
    public ApplicationPgpSignature(Stream stream);
    private void CheckDisposed();
    public virtual void Accept(MimeVisitor visitor);
}
public class MimeKit.Cryptography.ApplicationPkcs7Mime : MimePart {
    public SecureMimeType SecureMimeType { get; }
    public ApplicationPkcs7Mime(MimeEntityConstructorArgs args);
    public ApplicationPkcs7Mime(SecureMimeType type, Stream stream);
    private void CheckDisposed();
    public sealed virtual SecureMimeType get_SecureMimeType();
    public virtual void Accept(MimeVisitor visitor);
    public sealed virtual MimeEntity Decompress(SecureMimeContext ctx, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MimeKit.Cryptography.ApplicationPkcs7Mime/<DecompressAsync>d__7")]
public sealed virtual Task`1<MimeEntity> DecompressAsync(SecureMimeContext ctx, CancellationToken cancellationToken);
    public sealed virtual MimeEntity Decompress(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MimeKit.Cryptography.ApplicationPkcs7Mime/<DecompressAsync>d__9")]
public sealed virtual Task`1<MimeEntity> DecompressAsync(CancellationToken cancellationToken);
    public sealed virtual MimeEntity Decrypt(SecureMimeContext ctx, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MimeKit.Cryptography.ApplicationPkcs7Mime/<DecryptAsync>d__11")]
public sealed virtual Task`1<MimeEntity> DecryptAsync(SecureMimeContext ctx, CancellationToken cancellationToken);
    public sealed virtual MimeEntity Decrypt(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MimeKit.Cryptography.ApplicationPkcs7Mime/<DecryptAsync>d__13")]
public sealed virtual Task`1<MimeEntity> DecryptAsync(CancellationToken cancellationToken);
    public sealed virtual void Import(SecureMimeContext ctx, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MimeKit.Cryptography.ApplicationPkcs7Mime/<ImportAsync>d__15")]
public sealed virtual Task ImportAsync(SecureMimeContext ctx, CancellationToken cancellationToken);
    public sealed virtual DigitalSignatureCollection Verify(SecureMimeContext ctx, MimeEntity& entity, CancellationToken cancellationToken);
    public sealed virtual DigitalSignatureCollection Verify(MimeEntity& entity, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MimeKit.Cryptography.ApplicationPkcs7Mime/<CompressAsync>d__18")]
private static Task`1<ApplicationPkcs7Mime> CompressAsync(SecureMimeContext ctx, MimeEntity entity, bool doAsync, CancellationToken cancellationToken);
    public static ApplicationPkcs7Mime Compress(SecureMimeContext ctx, MimeEntity entity, CancellationToken cancellationToken);
    public static Task`1<ApplicationPkcs7Mime> CompressAsync(SecureMimeContext ctx, MimeEntity entity, CancellationToken cancellationToken);
    public static ApplicationPkcs7Mime Compress(MimeEntity entity, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MimeKit.Cryptography.ApplicationPkcs7Mime/<CompressAsync>d__22")]
public static Task`1<ApplicationPkcs7Mime> CompressAsync(MimeEntity entity, CancellationToken cancellationToken);
    public static ApplicationPkcs7Mime Encrypt(SecureMimeContext ctx, CmsRecipientCollection recipients, MimeEntity entity, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MimeKit.Cryptography.ApplicationPkcs7Mime/<EncryptAsync>d__24")]
public static Task`1<ApplicationPkcs7Mime> EncryptAsync(SecureMimeContext ctx, CmsRecipientCollection recipients, MimeEntity entity, CancellationToken cancellationToken);
    public static ApplicationPkcs7Mime Encrypt(CmsRecipientCollection recipients, MimeEntity entity, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MimeKit.Cryptography.ApplicationPkcs7Mime/<EncryptAsync>d__26")]
public static Task`1<ApplicationPkcs7Mime> EncryptAsync(CmsRecipientCollection recipients, MimeEntity entity, CancellationToken cancellationToken);
    public static ApplicationPkcs7Mime Encrypt(SecureMimeContext ctx, IEnumerable`1<MailboxAddress> recipients, MimeEntity entity, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MimeKit.Cryptography.ApplicationPkcs7Mime/<EncryptAsync>d__28")]
public static Task`1<ApplicationPkcs7Mime> EncryptAsync(SecureMimeContext ctx, IEnumerable`1<MailboxAddress> recipients, MimeEntity entity, CancellationToken cancellationToken);
    public static ApplicationPkcs7Mime Encrypt(IEnumerable`1<MailboxAddress> recipients, MimeEntity entity, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MimeKit.Cryptography.ApplicationPkcs7Mime/<EncryptAsync>d__30")]
public static Task`1<ApplicationPkcs7Mime> EncryptAsync(IEnumerable`1<MailboxAddress> recipients, MimeEntity entity, CancellationToken cancellationToken);
    public static ApplicationPkcs7Mime Sign(SecureMimeContext ctx, CmsSigner signer, MimeEntity entity, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MimeKit.Cryptography.ApplicationPkcs7Mime/<SignAsync>d__32")]
public static Task`1<ApplicationPkcs7Mime> SignAsync(SecureMimeContext ctx, CmsSigner signer, MimeEntity entity, CancellationToken cancellationToken);
    public static ApplicationPkcs7Mime Sign(CmsSigner signer, MimeEntity entity, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MimeKit.Cryptography.ApplicationPkcs7Mime/<SignAsync>d__34")]
public static Task`1<ApplicationPkcs7Mime> SignAsync(CmsSigner signer, MimeEntity entity, CancellationToken cancellationToken);
    public static ApplicationPkcs7Mime Sign(SecureMimeContext ctx, MailboxAddress signer, DigestAlgorithm digestAlgo, MimeEntity entity, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MimeKit.Cryptography.ApplicationPkcs7Mime/<SignAsync>d__36")]
public static Task`1<ApplicationPkcs7Mime> SignAsync(SecureMimeContext ctx, MailboxAddress signer, DigestAlgorithm digestAlgo, MimeEntity entity, CancellationToken cancellationToken);
    public static ApplicationPkcs7Mime Sign(MailboxAddress signer, DigestAlgorithm digestAlgo, MimeEntity entity, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MimeKit.Cryptography.ApplicationPkcs7Mime/<SignAsync>d__38")]
public static Task`1<ApplicationPkcs7Mime> SignAsync(MailboxAddress signer, DigestAlgorithm digestAlgo, MimeEntity entity, CancellationToken cancellationToken);
    public static ApplicationPkcs7Mime SignAndEncrypt(SecureMimeContext ctx, CmsSigner signer, CmsRecipientCollection recipients, MimeEntity entity, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MimeKit.Cryptography.ApplicationPkcs7Mime/<SignAndEncryptAsync>d__40")]
public static Task`1<ApplicationPkcs7Mime> SignAndEncryptAsync(SecureMimeContext ctx, CmsSigner signer, CmsRecipientCollection recipients, MimeEntity entity, CancellationToken cancellationToken);
    public static ApplicationPkcs7Mime SignAndEncrypt(CmsSigner signer, CmsRecipientCollection recipients, MimeEntity entity, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MimeKit.Cryptography.ApplicationPkcs7Mime/<SignAndEncryptAsync>d__42")]
public static Task`1<ApplicationPkcs7Mime> SignAndEncryptAsync(CmsSigner signer, CmsRecipientCollection recipients, MimeEntity entity, CancellationToken cancellationToken);
    public static ApplicationPkcs7Mime SignAndEncrypt(SecureMimeContext ctx, MailboxAddress signer, DigestAlgorithm digestAlgo, IEnumerable`1<MailboxAddress> recipients, MimeEntity entity, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MimeKit.Cryptography.ApplicationPkcs7Mime/<SignAndEncryptAsync>d__44")]
public static Task`1<ApplicationPkcs7Mime> SignAndEncryptAsync(SecureMimeContext ctx, MailboxAddress signer, DigestAlgorithm digestAlgo, IEnumerable`1<MailboxAddress> recipients, MimeEntity entity, CancellationToken cancellationToken);
    public static ApplicationPkcs7Mime SignAndEncrypt(MailboxAddress signer, DigestAlgorithm digestAlgo, IEnumerable`1<MailboxAddress> recipients, MimeEntity entity, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MimeKit.Cryptography.ApplicationPkcs7Mime/<SignAndEncryptAsync>d__46")]
public static Task`1<ApplicationPkcs7Mime> SignAndEncryptAsync(MailboxAddress signer, DigestAlgorithm digestAlgo, IEnumerable`1<MailboxAddress> recipients, MimeEntity entity, CancellationToken cancellationToken);
}
public class MimeKit.Cryptography.ApplicationPkcs7Signature : MimePart {
    public ApplicationPkcs7Signature(MimeEntityConstructorArgs args);
    public ApplicationPkcs7Signature(Stream stream);
    private void CheckDisposed();
    public virtual void Accept(MimeVisitor visitor);
}
internal class MimeKit.Cryptography.ArcHeaderSet : object {
    [CompilerGeneratedAttribute]
private Header <ArcAuthenticationResult>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <ArcMessageSignatureParameters>k__BackingField;
    [CompilerGeneratedAttribute]
private Header <ArcMessageSignature>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <ArcSealParameters>k__BackingField;
    [CompilerGeneratedAttribute]
private Header <ArcSeal>k__BackingField;
    public Header ArcAuthenticationResult { get; private set; }
    public Dictionary`2<string, string> ArcMessageSignatureParameters { get; private set; }
    public Header ArcMessageSignature { get; private set; }
    public Dictionary`2<string, string> ArcSealParameters { get; private set; }
    public Header ArcSeal { get; private set; }
    [CompilerGeneratedAttribute]
public Header get_ArcAuthenticationResult();
    [CompilerGeneratedAttribute]
private void set_ArcAuthenticationResult(Header value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, string> get_ArcMessageSignatureParameters();
    [CompilerGeneratedAttribute]
private void set_ArcMessageSignatureParameters(Dictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public Header get_ArcMessageSignature();
    [CompilerGeneratedAttribute]
private void set_ArcMessageSignature(Header value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, string> get_ArcSealParameters();
    [CompilerGeneratedAttribute]
private void set_ArcSealParameters(Dictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public Header get_ArcSeal();
    [CompilerGeneratedAttribute]
private void set_ArcSeal(Header value);
    public bool Add(Header header, Dictionary`2<string, string> parameters);
}
public class MimeKit.Cryptography.ArcHeaderValidationResult : object {
    [CompilerGeneratedAttribute]
private ArcSignatureValidationResult <Signature>k__BackingField;
    [CompilerGeneratedAttribute]
private Header <Header>k__BackingField;
    public ArcSignatureValidationResult Signature { get; internal set; }
    public Header Header { get; private set; }
    internal ArcHeaderValidationResult(Header header);
    public ArcHeaderValidationResult(Header header, ArcSignatureValidationResult signature);
    [CompilerGeneratedAttribute]
public ArcSignatureValidationResult get_Signature();
    [CompilerGeneratedAttribute]
internal void set_Signature(ArcSignatureValidationResult value);
    [CompilerGeneratedAttribute]
public Header get_Header();
    [CompilerGeneratedAttribute]
private void set_Header(Header value);
}
public enum MimeKit.Cryptography.ArcSignatureValidationResult : Enum {
    public int value__;
    public static ArcSignatureValidationResult None;
    public static ArcSignatureValidationResult Pass;
    public static ArcSignatureValidationResult Fail;
}
public abstract class MimeKit.Cryptography.ArcSigner : DkimSignerBase {
    private static String[] ArcShouldNotInclude;
    protected ArcSigner(string domain, string selector, DkimSignatureAlgorithm algorithm);
    protected ArcSigner(AsymmetricKeyParameter key, string domain, string selector, DkimSignatureAlgorithm algorithm);
    protected ArcSigner(string fileName, string domain, string selector, DkimSignatureAlgorithm algorithm);
    protected ArcSigner(Stream stream, string domain, string selector, DkimSignatureAlgorithm algorithm);
    private static ArcSigner();
    protected abstract virtual AuthenticationResults GenerateArcAuthenticationResults(FormatOptions options, MimeMessage message, CancellationToken cancellationToken);
    protected abstract virtual Task`1<AuthenticationResults> GenerateArcAuthenticationResultsAsync(FormatOptions options, MimeMessage message, CancellationToken cancellationToken);
    protected virtual long GetTimestamp();
    private static void AppendInstanceAndSignatureAlgorithm(ValueStringBuilder& value, int instance, DkimSignatureAlgorithm signatureAlgorithm);
    private Header GenerateArcMessageSignature(FormatOptions options, MimeMessage message, int instance, long t, IList`1<string> headers);
    private Header GenerateArcSeal(FormatOptions options, int instance, string cv, long t, ArcHeaderSet[] sets, int count, Header aar, Header ams);
    [AsyncStateMachineAttribute("MimeKit.Cryptography.ArcSigner/<ArcSignAsync>d__11")]
private Task ArcSignAsync(FormatOptions options, MimeMessage message, IList`1<string> headers, bool doAsync, CancellationToken cancellationToken);
    private Task SignAsync(FormatOptions options, MimeMessage message, IList`1<string> headers, bool doAsync, CancellationToken cancellationToken);
    private Task SignAsync(FormatOptions options, MimeMessage message, IList`1<HeaderId> headers, bool doAsync, CancellationToken cancellationToken);
    public void Sign(FormatOptions options, MimeMessage message, IList`1<string> headers, CancellationToken cancellationToken);
    public Task SignAsync(FormatOptions options, MimeMessage message, IList`1<string> headers, CancellationToken cancellationToken);
    public void Sign(MimeMessage message, IList`1<string> headers, CancellationToken cancellationToken);
    public Task SignAsync(MimeMessage message, IList`1<string> headers, CancellationToken cancellationToken);
    public void Sign(FormatOptions options, MimeMessage message, IList`1<HeaderId> headers, CancellationToken cancellationToken);
    public Task SignAsync(FormatOptions options, MimeMessage message, IList`1<HeaderId> headers, CancellationToken cancellationToken);
    public void Sign(MimeMessage message, IList`1<HeaderId> headers, CancellationToken cancellationToken);
    public Task SignAsync(MimeMessage message, IList`1<HeaderId> headers, CancellationToken cancellationToken);
}
[FlagsAttribute]
public enum MimeKit.Cryptography.ArcValidationErrors : Enum {
    public int value__;
    public static ArcValidationErrors None;
    public static ArcValidationErrors DuplicateArcAuthenticationResults;
    public static ArcValidationErrors DuplicateArcMessageSignature;
    public static ArcValidationErrors DuplicateArcSeal;
    public static ArcValidationErrors MissingArcAuthenticationResults;
    public static ArcValidationErrors MissingArcMessageSignature;
    public static ArcValidationErrors MissingArcSeal;
    public static ArcValidationErrors InvalidArcAuthenticationResults;
    public static ArcValidationErrors InvalidArcMessageSignature;
    public static ArcValidationErrors InvalidArcSeal;
    public static ArcValidationErrors InvalidArcSealChainValidationValue;
    public static ArcValidationErrors MissingArcSealChainValidationValue;
    public static ArcValidationErrors MessageSignatureValidationFailed;
    public static ArcValidationErrors SealValidationFailed;
}
public class MimeKit.Cryptography.ArcValidationResult : object {
    [CompilerGeneratedAttribute]
private ArcHeaderValidationResult <MessageSignature>k__BackingField;
    [CompilerGeneratedAttribute]
private ArcHeaderValidationResult[] <Seals>k__BackingField;
    [CompilerGeneratedAttribute]
private ArcSignatureValidationResult <Chain>k__BackingField;
    [CompilerGeneratedAttribute]
private ArcValidationErrors <ChainErrors>k__BackingField;
    public ArcHeaderValidationResult MessageSignature { get; internal set; }
    public ArcHeaderValidationResult[] Seals { get; internal set; }
    public ArcSignatureValidationResult Chain { get; internal set; }
    public ArcValidationErrors ChainErrors { get; internal set; }
    public ArcValidationResult(ArcSignatureValidationResult chain, ArcHeaderValidationResult messageSignature, ArcHeaderValidationResult[] seals);
    [CompilerGeneratedAttribute]
public ArcHeaderValidationResult get_MessageSignature();
    [CompilerGeneratedAttribute]
internal void set_MessageSignature(ArcHeaderValidationResult value);
    [CompilerGeneratedAttribute]
public ArcHeaderValidationResult[] get_Seals();
    [CompilerGeneratedAttribute]
internal void set_Seals(ArcHeaderValidationResult[] value);
    [CompilerGeneratedAttribute]
public ArcSignatureValidationResult get_Chain();
    [CompilerGeneratedAttribute]
internal void set_Chain(ArcSignatureValidationResult value);
    [CompilerGeneratedAttribute]
public ArcValidationErrors get_ChainErrors();
    [CompilerGeneratedAttribute]
internal void set_ChainErrors(ArcValidationErrors value);
}
public class MimeKit.Cryptography.ArcVerifier : DkimVerifierBase {
    public ArcVerifier(IDkimPublicKeyLocator publicKeyLocator);
    private static void ValidateArcMessageSignatureParameters(Dictionary`2<string, string> parameters, DkimSignatureAlgorithm& algorithm, DkimCanonicalizationAlgorithm& headerAlgorithm, DkimCanonicalizationAlgorithm& bodyAlgorithm, String& d, String& s, String& q, String[]& headers, String& bh, String& b, Int32& maxLength);
    private static void ValidateArcSealParameters(Dictionary`2<string, string> parameters, DkimSignatureAlgorithm& algorithm, String& d, String& s, String& q, String& b);
    [AsyncStateMachineAttribute("MimeKit.Cryptography.ArcVerifier/<VerifyArcMessageSignatureAsync>d__3")]
private Task`1<bool> VerifyArcMessageSignatureAsync(FormatOptions options, MimeMessage message, Header arcSignature, Dictionary`2<string, string> parameters, bool doAsync, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MimeKit.Cryptography.ArcVerifier/<VerifyArcSealAsync>d__4")]
private Task`1<bool> VerifyArcSealAsync(FormatOptions options, ArcHeaderSet[] sets, int i, bool doAsync, CancellationToken cancellationToken);
    internal static ArcSignatureValidationResult GetArcHeaderSets(MimeMessage message, bool throwOnError, ArcHeaderSet[]& sets, Int32& count, ArcValidationErrors& errors);
    [AsyncStateMachineAttribute("MimeKit.Cryptography.ArcVerifier/<VerifyAsync>d__6")]
private Task`1<ArcValidationResult> VerifyAsync(FormatOptions options, MimeMessage message, bool doAsync, CancellationToken cancellationToken);
    public ArcValidationResult Verify(FormatOptions options, MimeMessage message, CancellationToken cancellationToken);
    public Task`1<ArcValidationResult> VerifyAsync(FormatOptions options, MimeMessage message, CancellationToken cancellationToken);
    public ArcValidationResult Verify(MimeMessage message, CancellationToken cancellationToken);
    public Task`1<ArcValidationResult> VerifyAsync(MimeMessage message, CancellationToken cancellationToken);
}
[ExtensionAttribute]
public static class MimeKit.Cryptography.AsymmetricAlgorithmExtensions : object {
    private static void GetAsymmetricKeyParameters(DSA dsa, bool publicOnly, AsymmetricKeyParameter& pub, AsymmetricKeyParameter& key);
    private static AsymmetricKeyParameter GetAsymmetricKeyParameter(DSACryptoServiceProvider dsa);
    private static AsymmetricCipherKeyPair GetAsymmetricCipherKeyPair(DSACryptoServiceProvider dsa);
    private static AsymmetricKeyParameter GetAsymmetricKeyParameter(DSA dsa);
    private static AsymmetricCipherKeyPair GetAsymmetricCipherKeyPair(DSA dsa);
    private static void GetAsymmetricKeyParameters(RSA rsa, bool publicOnly, AsymmetricKeyParameter& pub, AsymmetricKeyParameter& key);
    private static AsymmetricKeyParameter GetAsymmetricKeyParameter(RSACryptoServiceProvider rsa);
    private static AsymmetricCipherKeyPair GetAsymmetricCipherKeyPair(RSACryptoServiceProvider rsa);
    private static AsymmetricKeyParameter GetAsymmetricKeyParameter(RSA rsa);
    private static AsymmetricCipherKeyPair GetAsymmetricCipherKeyPair(RSA rsa);
    [ExtensionAttribute]
public static AsymmetricKeyParameter AsAsymmetricKeyParameter(AsymmetricAlgorithm key);
    [ExtensionAttribute]
public static AsymmetricCipherKeyPair AsAsymmetricCipherKeyPair(AsymmetricAlgorithm key);
    private static Byte[] GetPaddedByteArray(BigInteger big, int length);
    private static DSAParameters GetDSAParameters(DsaKeyParameters key);
    private static AsymmetricAlgorithm GetAsymmetricAlgorithm(DsaPrivateKeyParameters key, DsaPublicKeyParameters pub);
    private static AsymmetricAlgorithm GetAsymmetricAlgorithm(DsaPublicKeyParameters key);
    private static AsymmetricAlgorithm GetAsymmetricAlgorithm(RsaPrivateCrtKeyParameters key);
    private static AsymmetricAlgorithm GetAsymmetricAlgorithm(RsaKeyParameters key);
    [ExtensionAttribute]
public static AsymmetricAlgorithm AsAsymmetricAlgorithm(AsymmetricKeyParameter key);
    [ExtensionAttribute]
public static AsymmetricAlgorithm AsAsymmetricAlgorithm(AsymmetricCipherKeyPair key);
}
public class MimeKit.Cryptography.AuthenticationMethodProperty : object {
    private static Char[] TokenSpecials;
    private Nullable`1<bool> quoted;
    [CompilerGeneratedAttribute]
private string <PropertyType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Property>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    public string PropertyType { get; private set; }
    public string Property { get; private set; }
    public string Value { get; private set; }
    internal AuthenticationMethodProperty(string ptype, string property, string value, Nullable`1<bool> quoted);
    public AuthenticationMethodProperty(string ptype, string property, string value);
    private static AuthenticationMethodProperty();
    [CompilerGeneratedAttribute]
public string get_PropertyType();
    [CompilerGeneratedAttribute]
private void set_PropertyType(string value);
    [CompilerGeneratedAttribute]
public string get_Property();
    [CompilerGeneratedAttribute]
private void set_Property(string value);
    [CompilerGeneratedAttribute]
public string get_Value();
    [CompilerGeneratedAttribute]
private void set_Value(string value);
    internal void AppendTokens(FormatOptions options, List`1<string> tokens);
    public virtual string ToString();
    internal void WriteTo(ValueStringBuilder& builder);
}
public class MimeKit.Cryptography.AuthenticationMethodResult : object {
    [CompilerGeneratedAttribute]
private string <Office365AuthenticationServiceIdentifier>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Method>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Result>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ResultComment>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Action>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Reason>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<AuthenticationMethodProperty> <Properties>k__BackingField;
    public string Office365AuthenticationServiceIdentifier { get; internal set; }
    public string Method { get; private set; }
    public Nullable`1<int> Version { get; public set; }
    public string Result { get; internal set; }
    public string ResultComment { get; public set; }
    public string Action { get; internal set; }
    public string Reason { get; public set; }
    public List`1<AuthenticationMethodProperty> Properties { get; private set; }
    internal AuthenticationMethodResult(string method);
    public AuthenticationMethodResult(string method, string result);
    [CompilerGeneratedAttribute]
public string get_Office365AuthenticationServiceIdentifier();
    [CompilerGeneratedAttribute]
internal void set_Office365AuthenticationServiceIdentifier(string value);
    [CompilerGeneratedAttribute]
public string get_Method();
    [CompilerGeneratedAttribute]
private void set_Method(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_Version();
    [CompilerGeneratedAttribute]
public void set_Version(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public string get_Result();
    [CompilerGeneratedAttribute]
internal void set_Result(string value);
    [CompilerGeneratedAttribute]
public string get_ResultComment();
    [CompilerGeneratedAttribute]
public void set_ResultComment(string value);
    [CompilerGeneratedAttribute]
public string get_Action();
    [CompilerGeneratedAttribute]
internal void set_Action(string value);
    [CompilerGeneratedAttribute]
public string get_Reason();
    [CompilerGeneratedAttribute]
public void set_Reason(string value);
    [CompilerGeneratedAttribute]
public List`1<AuthenticationMethodProperty> get_Properties();
    [CompilerGeneratedAttribute]
private void set_Properties(List`1<AuthenticationMethodProperty> value);
    internal void Encode(FormatOptions options, StringBuilder builder, Int32& lineLength);
    public virtual string ToString();
    internal void WriteTo(ValueStringBuilder& builder);
}
public class MimeKit.Cryptography.AuthenticationResults : object {
    [CompilerGeneratedAttribute]
private string <AuthenticationServiceIdentifier>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <Instance>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<AuthenticationMethodResult> <Results>k__BackingField;
    public string AuthenticationServiceIdentifier { get; private set; }
    public Nullable`1<int> Instance { get; public set; }
    public Nullable`1<int> Version { get; public set; }
    public List`1<AuthenticationMethodResult> Results { get; private set; }
    public AuthenticationResults(string authservid);
    [CompilerGeneratedAttribute]
public string get_AuthenticationServiceIdentifier();
    [CompilerGeneratedAttribute]
private void set_AuthenticationServiceIdentifier(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_Instance();
    [CompilerGeneratedAttribute]
public void set_Instance(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_Version();
    [CompilerGeneratedAttribute]
public void set_Version(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public List`1<AuthenticationMethodResult> get_Results();
    [CompilerGeneratedAttribute]
private void set_Results(List`1<AuthenticationMethodResult> value);
    internal void Encode(FormatOptions options, StringBuilder builder, int lineLength);
    public virtual string ToString();
    internal void WriteTo(ValueStringBuilder& builder);
    private static bool IsKeyword(byte c);
    private static bool SkipKeyword(Byte[] text, Int32& index, int endIndex);
    private static bool SkipValue(Byte[] text, Int32& index, int endIndex, Boolean& quoted);
    private static bool SkipDomain(Byte[] text, Int32& index, int endIndex);
    private static bool SkipPropertyValue(Byte[] text, Int32& index, int endIndex, Boolean& quoted);
    private static bool TryParseMethods(Byte[] text, Int32& index, int endIndex, bool throwOnError, AuthenticationResults authres);
    private static bool TryParse(Byte[] text, Int32& index, int endIndex, bool throwOnError, AuthenticationResults& authres);
    public static bool TryParse(Byte[] buffer, int startIndex, int length, AuthenticationResults& authres);
    public static bool TryParse(Byte[] buffer, AuthenticationResults& authres);
    public static AuthenticationResults Parse(Byte[] buffer, int startIndex, int length);
    public static AuthenticationResults Parse(Byte[] buffer);
}
[ExtensionAttribute]
public static class MimeKit.Cryptography.BouncyCastleCertificateExtensions : object {
    [ExtensionAttribute]
public static X509Certificate2 AsX509Certificate2(X509Certificate certificate);
    [ExtensionAttribute]
internal static bool IsSelfSigned(X509Certificate certificate);
    [ExtensionAttribute]
public static string GetIssuerNameInfo(X509Certificate certificate, DerObjectIdentifier identifier);
    [ExtensionAttribute]
public static string GetSubjectNameInfo(X509Certificate certificate, DerObjectIdentifier identifier);
    [ExtensionAttribute]
public static string GetCommonName(X509Certificate certificate);
    [ExtensionAttribute]
public static string GetSubjectName(X509Certificate certificate);
    [ExtensionAttribute]
public static string GetSubjectEmailAddress(X509Certificate certificate);
    [ExtensionAttribute]
internal static string AsHex(Byte[] blob);
    [ExtensionAttribute]
public static string GetFingerprint(X509Certificate certificate);
    [ExtensionAttribute]
public static PublicKeyAlgorithm GetPublicKeyAlgorithm(X509Certificate certificate);
    internal static X509KeyUsageFlags GetKeyUsageFlags(Boolean[] usage);
    [ExtensionAttribute]
public static X509KeyUsageFlags GetKeyUsageFlags(X509Certificate certificate);
    private static EncryptionAlgorithm[] DecodeEncryptionAlgorithms(Byte[] rawData);
    [ExtensionAttribute]
public static EncryptionAlgorithm[] GetEncryptionAlgorithms(X509Certificate certificate);
    [ExtensionAttribute]
internal static bool IsDelta(X509Crl crl);
}
public abstract class MimeKit.Cryptography.BouncyCastleSecureMimeContext : SecureMimeContext {
    private static string RsassaPssOid;
    private HttpClient client;
    [CompilerGeneratedAttribute]
private SecureRandom <RandomNumberGenerator>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CheckCertificateRevocation>k__BackingField;
    protected SecureRandom RandomNumberGenerator { get; private set; }
    public bool CheckCertificateRevocation { get; public set; }
    protected BouncyCastleSecureMimeContext(SecureRandom random);
    private static BouncyCastleSecureMimeContext();
    [CompilerGeneratedAttribute]
protected SecureRandom get_RandomNumberGenerator();
    [CompilerGeneratedAttribute]
private void set_RandomNumberGenerator(SecureRandom value);
    [CompilerGeneratedAttribute]
public bool get_CheckCertificateRevocation();
    [CompilerGeneratedAttribute]
public void set_CheckCertificateRevocation(bool value);
    protected abstract virtual X509Certificate GetCertificate(ISelector`1<X509Certificate> selector);
    protected abstract virtual AsymmetricKeyParameter GetPrivateKey(ISelector`1<X509Certificate> selector);
    protected abstract virtual ISet`1<TrustAnchor> GetTrustedAnchors();
    protected abstract virtual IStore`1<X509Certificate> GetIntermediateCertificates();
    protected abstract virtual IStore`1<X509Crl> GetCertificateRevocationLists();
    protected abstract virtual DateTime GetNextCertificateRevocationListUpdate(X509Name issuer);
    protected abstract virtual CmsRecipient GetCmsRecipient(MailboxAddress mailbox);
    protected CmsRecipientCollection GetCmsRecipients(IEnumerable`1<MailboxAddress> mailboxes);
    protected abstract virtual CmsSigner GetCmsSigner(MailboxAddress mailbox, DigestAlgorithm digestAlgo);
    protected abstract virtual void UpdateSecureMimeCapabilities(X509Certificate certificate, EncryptionAlgorithm[] algorithms, DateTime timestamp);
    private CmsAttributeTableGenerator AddSecureMimeCapabilities(AttributeTable signedAttributes);
    private CmsSignedDataStreamGenerator CreateSignedDataGenerator(CmsSigner signer);
    private Stream Sign(CmsSigner signer, Stream content, bool encapsulate, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MimeKit.Cryptography.BouncyCastleSecureMimeContext/<SignAsync>d__25")]
private Task`1<Stream> SignAsync(CmsSigner signer, Stream content, bool encapsulate, CancellationToken cancellationToken);
    public virtual ApplicationPkcs7Mime EncapsulatedSign(CmsSigner signer, Stream content, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MimeKit.Cryptography.BouncyCastleSecureMimeContext/<EncapsulatedSignAsync>d__27")]
public virtual Task`1<ApplicationPkcs7Mime> EncapsulatedSignAsync(CmsSigner signer, Stream content, CancellationToken cancellationToken);
    public virtual ApplicationPkcs7Mime EncapsulatedSign(MailboxAddress signer, DigestAlgorithm digestAlgo, Stream content, CancellationToken cancellationToken);
    public virtual Task`1<ApplicationPkcs7Mime> EncapsulatedSignAsync(MailboxAddress signer, DigestAlgorithm digestAlgo, Stream content, CancellationToken cancellationToken);
    public virtual ApplicationPkcs7Signature Sign(CmsSigner signer, Stream content, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MimeKit.Cryptography.BouncyCastleSecureMimeContext/<SignAsync>d__31")]
public virtual Task`1<ApplicationPkcs7Signature> SignAsync(CmsSigner signer, Stream content, CancellationToken cancellationToken);
    public virtual MimePart Sign(MailboxAddress signer, DigestAlgorithm digestAlgo, Stream content, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MimeKit.Cryptography.BouncyCastleSecureMimeContext/<SignAsync>d__33")]
public virtual Task`1<MimePart> SignAsync(MailboxAddress signer, DigestAlgorithm digestAlgo, Stream content, CancellationToken cancellationToken);
    private X509Certificate GetCertificate(IStore`1<X509Certificate> store, SignerID signer);
    protected IList`1<X509Certificate> BuildCertificateChain(X509Certificate certificate);
    private PkixCertPath BuildCertPath(ISet`1<TrustAnchor> anchors, IStore`1<X509Certificate> certificates, IStore`1<X509Crl> crls, X509Certificate certificate, DateTime signingTime);
    protected internal static bool TryGetDigestAlgorithm(AlgorithmIdentifier identifier, DigestAlgorithm& algorithm);
    protected internal static bool TryGetEncryptionAlgorithm(AlgorithmIdentifier identifier, EncryptionAlgorithm& algorithm);
    [AsyncStateMachineAttribute("MimeKit.Cryptography.BouncyCastleSecureMimeContext/<DownloadCrlsOverHttpAsync>d__39")]
private Task`1<bool> DownloadCrlsOverHttpAsync(string location, Stream stream, bool doAsync, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MimeKit.Cryptography.BouncyCastleSecureMimeContext/<DownloadCrlsAsync>d__40")]
private Task DownloadCrlsAsync(X509Certificate certificate, bool doAsync, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MimeKit.Cryptography.BouncyCastleSecureMimeContext/<GetDigitalSignaturesAsync>d__41")]
private Task`1<DigitalSignatureCollection> GetDigitalSignaturesAsync(CmsSignedDataParser parser, bool doAsync, CancellationToken cancellationToken);
    public virtual DigitalSignatureCollection Verify(Stream content, Stream signatureData, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MimeKit.Cryptography.BouncyCastleSecureMimeContext/<VerifyAsync>d__43")]
public virtual Task`1<DigitalSignatureCollection> VerifyAsync(Stream content, Stream signatureData, CancellationToken cancellationToken);
    public virtual DigitalSignatureCollection Verify(Stream signedData, MimeEntity& entity, CancellationToken cancellationToken);
    public virtual Stream Verify(Stream signedData, DigitalSignatureCollection& signatures, CancellationToken cancellationToken);
    private void CmsEnvelopeAddEllipticCurve(CmsEnvelopedDataGenerator cms, CmsRecipient recipient, X509Certificate certificate, ECKeyParameters publicKey);
    private Stream Envelope(CmsRecipientCollection recipients, Stream content, CancellationToken cancellationToken);
    public virtual ApplicationPkcs7Mime Encrypt(CmsRecipientCollection recipients, Stream content, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MimeKit.Cryptography.BouncyCastleSecureMimeContext/<EncryptAsync>d__50")]
public virtual Task`1<ApplicationPkcs7Mime> EncryptAsync(CmsRecipientCollection recipients, Stream content, CancellationToken cancellationToken);
    public virtual MimePart Encrypt(IEnumerable`1<MailboxAddress> recipients, Stream content, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MimeKit.Cryptography.BouncyCastleSecureMimeContext/<EncryptAsync>d__52")]
public virtual Task`1<MimePart> EncryptAsync(IEnumerable`1<MailboxAddress> recipients, Stream content, CancellationToken cancellationToken);
    private CmsTypedStream GetDecryptedContent(CmsEnvelopedDataParser parser);
    public virtual MimeEntity Decrypt(Stream encryptedData, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MimeKit.Cryptography.BouncyCastleSecureMimeContext/<DecryptAsync>d__55")]
public virtual Task`1<MimeEntity> DecryptAsync(Stream encryptedData, CancellationToken cancellationToken);
    public virtual void DecryptTo(Stream encryptedData, Stream decryptedData, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MimeKit.Cryptography.BouncyCastleSecureMimeContext/<DecryptToAsync>d__57")]
public virtual Task DecryptToAsync(Stream encryptedData, Stream decryptedData, CancellationToken cancellationToken);
    public virtual MimePart Export(IEnumerable`1<MailboxAddress> mailboxes, CancellationToken cancellationToken);
    public virtual Task`1<MimePart> ExportAsync(IEnumerable`1<MailboxAddress> mailboxes, CancellationToken cancellationToken);
    protected virtual void Dispose(bool disposing);
}
public class MimeKit.Cryptography.CertificateNotFoundException : Exception {
    [CompilerGeneratedAttribute]
private MailboxAddress <Mailbox>k__BackingField;
    public MailboxAddress Mailbox { get; private set; }
    public CertificateNotFoundException(MailboxAddress mailbox, string message);
    [CompilerGeneratedAttribute]
public MailboxAddress get_Mailbox();
    [CompilerGeneratedAttribute]
private void set_Mailbox(MailboxAddress value);
}
public class MimeKit.Cryptography.CmsRecipient : object {
    [CompilerGeneratedAttribute]
private X509Certificate <Certificate>k__BackingField;
    [CompilerGeneratedAttribute]
private SubjectIdentifierType <RecipientIdentifierType>k__BackingField;
    [CompilerGeneratedAttribute]
private EncryptionAlgorithm[] <EncryptionAlgorithms>k__BackingField;
    [CompilerGeneratedAttribute]
private RsaEncryptionPadding <RsaEncryptionPadding>k__BackingField;
    public X509Certificate Certificate { get; private set; }
    public SubjectIdentifierType RecipientIdentifierType { get; private set; }
    public EncryptionAlgorithm[] EncryptionAlgorithms { get; public set; }
    public RsaEncryptionPadding RsaEncryptionPadding { get; public set; }
    public CmsRecipient(X509Certificate certificate, SubjectIdentifierType recipientIdentifierType);
    public CmsRecipient(Stream stream, SubjectIdentifierType recipientIdentifierType);
    public CmsRecipient(string fileName, SubjectIdentifierType recipientIdentifierType);
    public CmsRecipient(X509Certificate2 certificate, SubjectIdentifierType recipientIdentifierType);
    [CompilerGeneratedAttribute]
public X509Certificate get_Certificate();
    [CompilerGeneratedAttribute]
private void set_Certificate(X509Certificate value);
    [CompilerGeneratedAttribute]
public SubjectIdentifierType get_RecipientIdentifierType();
    [CompilerGeneratedAttribute]
private void set_RecipientIdentifierType(SubjectIdentifierType value);
    [CompilerGeneratedAttribute]
public EncryptionAlgorithm[] get_EncryptionAlgorithms();
    [CompilerGeneratedAttribute]
public void set_EncryptionAlgorithms(EncryptionAlgorithm[] value);
    [CompilerGeneratedAttribute]
public RsaEncryptionPadding get_RsaEncryptionPadding();
    [CompilerGeneratedAttribute]
public void set_RsaEncryptionPadding(RsaEncryptionPadding value);
}
public class MimeKit.Cryptography.CmsRecipientCollection : object {
    private IList`1<CmsRecipient> recipients;
    public int Count { get; }
    public bool IsReadOnly { get; }
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual void Add(CmsRecipient recipient);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(CmsRecipient recipient);
    public sealed virtual void CopyTo(CmsRecipient[] array, int arrayIndex);
    public sealed virtual bool Remove(CmsRecipient recipient);
    public sealed virtual IEnumerator`1<CmsRecipient> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class MimeKit.Cryptography.CmsSigner : object {
    [CompilerGeneratedAttribute]
private X509Certificate2 <WindowsCertificate>k__BackingField;
    [CompilerGeneratedAttribute]
private X509Certificate <Certificate>k__BackingField;
    [CompilerGeneratedAttribute]
private X509CertificateChain <CertificateChain>k__BackingField;
    [CompilerGeneratedAttribute]
private DigestAlgorithm <DigestAlgorithm>k__BackingField;
    [CompilerGeneratedAttribute]
private AsymmetricKeyParameter <PrivateKey>k__BackingField;
    [CompilerGeneratedAttribute]
private RsaSignaturePadding <RsaSignaturePadding>k__BackingField;
    [CompilerGeneratedAttribute]
private SubjectIdentifierType <SignerIdentifierType>k__BackingField;
    [CompilerGeneratedAttribute]
private AttributeTable <SignedAttributes>k__BackingField;
    [CompilerGeneratedAttribute]
private AttributeTable <UnsignedAttributes>k__BackingField;
    internal X509Certificate2 WindowsCertificate { get; internal set; }
    public X509Certificate Certificate { get; private set; }
    public X509CertificateChain CertificateChain { get; private set; }
    public DigestAlgorithm DigestAlgorithm { get; public set; }
    public AsymmetricKeyParameter PrivateKey { get; private set; }
    public RsaSignaturePadding RsaSignaturePadding { get; public set; }
    public SubjectIdentifierType SignerIdentifierType { get; private set; }
    public AttributeTable SignedAttributes { get; public set; }
    public AttributeTable UnsignedAttributes { get; public set; }
    public CmsSigner(IEnumerable`1<X509Certificate> chain, AsymmetricKeyParameter key, SubjectIdentifierType signerIdentifierType);
    public CmsSigner(X509Certificate certificate, AsymmetricKeyParameter key, SubjectIdentifierType signerIdentifierType);
    public CmsSigner(Stream stream, string password, SubjectIdentifierType signerIdentifierType);
    public CmsSigner(string fileName, string password, SubjectIdentifierType signerIdentifierType);
    public CmsSigner(X509Certificate2 certificate, SubjectIdentifierType signerIdentifierType);
    private static bool CanSign(X509Certificate certificate);
    private static void CheckCertificateCanBeUsedForSigning(X509Certificate certificate);
    private void LoadPkcs12(Stream stream, string password, SubjectIdentifierType signerIdentifierType);
    [CompilerGeneratedAttribute]
internal X509Certificate2 get_WindowsCertificate();
    [CompilerGeneratedAttribute]
internal void set_WindowsCertificate(X509Certificate2 value);
    [CompilerGeneratedAttribute]
public X509Certificate get_Certificate();
    [CompilerGeneratedAttribute]
private void set_Certificate(X509Certificate value);
    [CompilerGeneratedAttribute]
public X509CertificateChain get_CertificateChain();
    [CompilerGeneratedAttribute]
private void set_CertificateChain(X509CertificateChain value);
    [CompilerGeneratedAttribute]
public DigestAlgorithm get_DigestAlgorithm();
    [CompilerGeneratedAttribute]
public void set_DigestAlgorithm(DigestAlgorithm value);
    [CompilerGeneratedAttribute]
public AsymmetricKeyParameter get_PrivateKey();
    [CompilerGeneratedAttribute]
private void set_PrivateKey(AsymmetricKeyParameter value);
    [CompilerGeneratedAttribute]
public RsaSignaturePadding get_RsaSignaturePadding();
    [CompilerGeneratedAttribute]
public void set_RsaSignaturePadding(RsaSignaturePadding value);
    [CompilerGeneratedAttribute]
public SubjectIdentifierType get_SignerIdentifierType();
    [CompilerGeneratedAttribute]
private void set_SignerIdentifierType(SubjectIdentifierType value);
    [CompilerGeneratedAttribute]
public AttributeTable get_SignedAttributes();
    [CompilerGeneratedAttribute]
public void set_SignedAttributes(AttributeTable value);
    [CompilerGeneratedAttribute]
public AttributeTable get_UnsignedAttributes();
    [CompilerGeneratedAttribute]
public void set_UnsignedAttributes(AttributeTable value);
}
public abstract class MimeKit.Cryptography.CryptographyContext : object {
    private static string SubclassAndRegisterFormat;
    private static Func`1<SecureMimeContext> SecureMimeContextFactory;
    private static Func`1<OpenPgpContext> PgpContextFactory;
    private static object mutex;
    private EncryptionAlgorithm[] encryptionAlgorithmRank;
    private DigestAlgorithm[] digestAlgorithmRank;
    private int enabledEncryptionAlgorithms;
    private int enabledDigestAlgorithms;
    [CompilerGeneratedAttribute]
private bool <PrepareBeforeSigning>k__BackingField;
    public bool PrepareBeforeSigning { get; public set; }
    public string SignatureProtocol { get; }
    public string EncryptionProtocol { get; }
    public string KeyExchangeProtocol { get; }
    protected EncryptionAlgorithm[] EncryptionAlgorithmRank { get; protected set; }
    public EncryptionAlgorithm[] EnabledEncryptionAlgorithms { get; }
    protected DigestAlgorithm[] DigestAlgorithmRank { get; protected set; }
    public DigestAlgorithm[] EnabledDigestAlgorithms { get; }
    private static CryptographyContext();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_PrepareBeforeSigning();
    [CompilerGeneratedAttribute]
public sealed virtual void set_PrepareBeforeSigning(bool value);
    public abstract virtual string get_SignatureProtocol();
    public abstract virtual string get_EncryptionProtocol();
    public abstract virtual string get_KeyExchangeProtocol();
    protected EncryptionAlgorithm[] get_EncryptionAlgorithmRank();
    protected void set_EncryptionAlgorithmRank(EncryptionAlgorithm[] value);
    public sealed virtual EncryptionAlgorithm[] get_EnabledEncryptionAlgorithms();
    public sealed virtual void Enable(EncryptionAlgorithm algorithm);
    public sealed virtual void Disable(EncryptionAlgorithm algorithm);
    public sealed virtual bool IsEnabled(EncryptionAlgorithm algorithm);
    protected DigestAlgorithm[] get_DigestAlgorithmRank();
    protected void set_DigestAlgorithmRank(DigestAlgorithm[] value);
    public sealed virtual DigestAlgorithm[] get_EnabledDigestAlgorithms();
    public sealed virtual void Enable(DigestAlgorithm algorithm);
    public sealed virtual void Disable(DigestAlgorithm algorithm);
    public sealed virtual bool IsEnabled(DigestAlgorithm algorithm);
    public abstract virtual bool Supports(string protocol);
    public abstract virtual string GetDigestAlgorithmName(DigestAlgorithm micalg);
    public abstract virtual DigestAlgorithm GetDigestAlgorithm(string micalg);
    public abstract virtual bool CanSign(MailboxAddress signer, CancellationToken cancellationToken);
    public virtual Task`1<bool> CanSignAsync(MailboxAddress signer, CancellationToken cancellationToken);
    public abstract virtual bool CanEncrypt(MailboxAddress mailbox, CancellationToken cancellationToken);
    public virtual Task`1<bool> CanEncryptAsync(MailboxAddress mailbox, CancellationToken cancellationToken);
    public abstract virtual MimePart Sign(MailboxAddress signer, DigestAlgorithm digestAlgo, Stream content, CancellationToken cancellationToken);
    public abstract virtual Task`1<MimePart> SignAsync(MailboxAddress signer, DigestAlgorithm digestAlgo, Stream content, CancellationToken cancellationToken);
    public abstract virtual DigitalSignatureCollection Verify(Stream content, Stream signatureData, CancellationToken cancellationToken);
    public abstract virtual Task`1<DigitalSignatureCollection> VerifyAsync(Stream content, Stream signatureData, CancellationToken cancellationToken);
    public abstract virtual MimePart Encrypt(IEnumerable`1<MailboxAddress> recipients, Stream content, CancellationToken cancellationToken);
    public abstract virtual Task`1<MimePart> EncryptAsync(IEnumerable`1<MailboxAddress> recipients, Stream content, CancellationToken cancellationToken);
    public abstract virtual MimeEntity Decrypt(Stream encryptedData, CancellationToken cancellationToken);
    public abstract virtual Task`1<MimeEntity> DecryptAsync(Stream encryptedData, CancellationToken cancellationToken);
    public abstract virtual void Import(Stream stream, CancellationToken cancellationToken);
    public abstract virtual Task ImportAsync(Stream stream, CancellationToken cancellationToken);
    public abstract virtual MimePart Export(IEnumerable`1<MailboxAddress> mailboxes, CancellationToken cancellationToken);
    public abstract virtual Task`1<MimePart> ExportAsync(IEnumerable`1<MailboxAddress> mailboxes, CancellationToken cancellationToken);
    protected virtual void Dispose(bool disposing);
    public sealed virtual void Dispose();
    public static CryptographyContext Create(string protocol);
    public static void Register(Type type);
    public static void Register(Func`1<SecureMimeContext> factory);
    public static void Register(Func`1<OpenPgpContext> factory);
}
[ExtensionAttribute]
internal static class MimeKit.Cryptography.DbExtensions : object {
    [ExtensionAttribute]
public static int AddParameterWithValue(DbCommand command, string name, object value);
}
public class MimeKit.Cryptography.DefaultSecureMimeContext : BouncyCastleSecureMimeContext {
    private static X509CertificateRecordFields CmsRecipientFields;
    private static X509CertificateRecordFields CmsSignerFields;
    private static X509CertificateRecordFields AlgorithmFields;
    private static X509CertificateRecordFields ImportPkcs12Fields;
    public static string DefaultDatabasePath;
    private IX509CertificateDatabase dbase;
    private static DefaultSecureMimeContext();
    public DefaultSecureMimeContext(string fileName, string password);
    public DefaultSecureMimeContext(string fileName, string password, SecureRandom random);
    public DefaultSecureMimeContext(string password);
    public DefaultSecureMimeContext(string password, SecureRandom random);
    public DefaultSecureMimeContext(IX509CertificateDatabase database);
    public DefaultSecureMimeContext(IX509CertificateDatabase database, SecureRandom random);
    private static void CheckIsAvailable();
    public virtual bool CanSign(MailboxAddress signer, CancellationToken cancellationToken);
    public virtual bool CanEncrypt(MailboxAddress mailbox, CancellationToken cancellationToken);
    protected virtual X509Certificate GetCertificate(ISelector`1<X509Certificate> selector);
    protected virtual AsymmetricKeyParameter GetPrivateKey(ISelector`1<X509Certificate> selector);
    protected virtual ISet`1<TrustAnchor> GetTrustedAnchors();
    protected virtual IStore`1<X509Certificate> GetIntermediateCertificates();
    protected virtual IStore`1<X509Crl> GetCertificateRevocationLists();
    protected virtual DateTime GetNextCertificateRevocationListUpdate(X509Name issuer);
    protected virtual CmsRecipient GetCmsRecipient(MailboxAddress mailbox);
    protected virtual CmsSigner GetCmsSigner(MailboxAddress mailbox, DigestAlgorithm digestAlgo);
    protected virtual void UpdateSecureMimeCapabilities(X509Certificate certificate, EncryptionAlgorithm[] algorithms, DateTime timestamp);
    public virtual void Import(X509Certificate certificate, CancellationToken cancellationToken);
    public virtual void Import(X509Certificate2 certificate, CancellationToken cancellationToken);
    public virtual void Import(X509Crl crl, CancellationToken cancellationToken);
    public virtual void Import(Stream stream, string password, CancellationToken cancellationToken);
    public virtual Task ImportAsync(Stream stream, string password, CancellationToken cancellationToken);
    public void Import(X509Certificate certificate, bool trusted, CancellationToken cancellationToken);
    public Task ImportAsync(X509Certificate certificate, bool trusted, CancellationToken cancellationToken);
    public void Import(Stream stream, bool trusted, CancellationToken cancellationToken);
    public Task ImportAsync(Stream stream, bool trusted, CancellationToken cancellationToken);
    protected virtual void Dispose(bool disposing);
}
public enum MimeKit.Cryptography.DigestAlgorithm : Enum {
    public int value__;
    public static DigestAlgorithm None;
    public static DigestAlgorithm MD5;
    public static DigestAlgorithm Sha1;
    public static DigestAlgorithm RipeMD160;
    public static DigestAlgorithm DoubleSha;
    public static DigestAlgorithm MD2;
    public static DigestAlgorithm Tiger192;
    public static DigestAlgorithm Haval5160;
    public static DigestAlgorithm Sha256;
    public static DigestAlgorithm Sha384;
    public static DigestAlgorithm Sha512;
    public static DigestAlgorithm Sha224;
    public static DigestAlgorithm MD4;
}
public class MimeKit.Cryptography.DigitalSignatureCollection : ReadOnlyCollection`1<IDigitalSignature> {
    public DigitalSignatureCollection(IList`1<IDigitalSignature> signatures);
}
public class MimeKit.Cryptography.DigitalSignatureVerifyException : Exception {
    [CompilerGeneratedAttribute]
private Nullable`1<long> <KeyId>k__BackingField;
    public Nullable`1<long> KeyId { get; private set; }
    public DigitalSignatureVerifyException(long keyId, string message, Exception innerException);
    public DigitalSignatureVerifyException(long keyId, string message);
    public DigitalSignatureVerifyException(string message, Exception innerException);
    public DigitalSignatureVerifyException(string message);
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_KeyId();
    [CompilerGeneratedAttribute]
private void set_KeyId(Nullable`1<long> value);
}
internal abstract class MimeKit.Cryptography.DkimBodyFilter : MimeFilterBase {
    protected internal bool LastWasNewLine;
    protected bool IsEmptyLine;
    protected int EmptyLines;
}
public enum MimeKit.Cryptography.DkimCanonicalizationAlgorithm : Enum {
    public int value__;
    public static DkimCanonicalizationAlgorithm Simple;
    public static DkimCanonicalizationAlgorithm Relaxed;
}
internal class MimeKit.Cryptography.DkimHashStream : Stream {
    private IDigest digest;
    private int max;
    private bool disposed;
    private int length;
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public bool CanSeek { get; }
    public bool CanTimeout { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public DkimHashStream(DkimSignatureAlgorithm algorithm, int maxLength);
    public Byte[] GenerateHash();
    private void CheckDisposed();
    public virtual bool get_CanRead();
    public virtual bool get_CanWrite();
    public virtual bool get_CanSeek();
    public virtual bool get_CanTimeout();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    private static void ValidateArguments(Byte[] buffer, int offset, int count);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void Flush();
    public virtual void SetLength(long value);
    protected virtual void Dispose(bool disposing);
}
public abstract class MimeKit.Cryptography.DkimPublicKeyLocatorBase : object {
    protected static AsymmetricKeyParameter GetPublicKey(string txt);
    public abstract virtual AsymmetricKeyParameter LocatePublicKey(string methods, string domain, string selector, CancellationToken cancellationToken);
    public abstract virtual Task`1<AsymmetricKeyParameter> LocatePublicKeyAsync(string methods, string domain, string selector, CancellationToken cancellationToken);
}
internal class MimeKit.Cryptography.DkimRelaxedBodyFilter : DkimBodyFilter {
    private bool lwsp;
    private bool cr;
    private int Filter(ReadOnlySpan`1<byte> input, Span`1<byte> output);
    protected virtual Byte[] Filter(Byte[] input, int startIndex, int length, Int32& outputIndex, Int32& outputLength, bool flush);
    public virtual void Reset();
}
public enum MimeKit.Cryptography.DkimSignatureAlgorithm : Enum {
    public int value__;
    public static DkimSignatureAlgorithm RsaSha1;
    public static DkimSignatureAlgorithm RsaSha256;
    public static DkimSignatureAlgorithm Ed25519Sha256;
}
internal class MimeKit.Cryptography.DkimSignatureStream : Stream {
    private bool disposed;
    private long length;
    [CompilerGeneratedAttribute]
private ISigner <Signer>k__BackingField;
    public ISigner Signer { get; private set; }
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public bool CanSeek { get; }
    public bool CanTimeout { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public DkimSignatureStream(ISigner signer);
    [CompilerGeneratedAttribute]
public ISigner get_Signer();
    [CompilerGeneratedAttribute]
private void set_Signer(ISigner value);
    public Byte[] GenerateSignature();
    public bool VerifySignature(string signature);
    private void CheckDisposed();
    public virtual bool get_CanRead();
    public virtual bool get_CanWrite();
    public virtual bool get_CanSeek();
    public virtual bool get_CanTimeout();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    private static void ValidateArguments(Byte[] buffer, int offset, int count);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void Flush();
    public virtual void SetLength(long value);
    protected virtual void Dispose(bool disposing);
}
public class MimeKit.Cryptography.DkimSigner : DkimSignerBase {
    private static String[] DkimShouldNotInclude;
    [CompilerGeneratedAttribute]
private string <AgentOrUserIdentifier>k__BackingField;
    [CompilerGeneratedAttribute]
private string <QueryMethod>k__BackingField;
    public string AgentOrUserIdentifier { get; public set; }
    public string QueryMethod { get; public set; }
    protected DkimSigner(string domain, string selector, DkimSignatureAlgorithm algorithm);
    public DkimSigner(AsymmetricKeyParameter key, string domain, string selector, DkimSignatureAlgorithm algorithm);
    public DkimSigner(string fileName, string domain, string selector, DkimSignatureAlgorithm algorithm);
    public DkimSigner(Stream stream, string domain, string selector, DkimSignatureAlgorithm algorithm);
    private static DkimSigner();
    [CompilerGeneratedAttribute]
public string get_AgentOrUserIdentifier();
    [CompilerGeneratedAttribute]
public void set_AgentOrUserIdentifier(string value);
    [CompilerGeneratedAttribute]
public string get_QueryMethod();
    [CompilerGeneratedAttribute]
public void set_QueryMethod(string value);
    protected virtual long GetTimestamp();
    private void DkimSign(FormatOptions options, MimeMessage message, IList`1<string> headers);
    public void Sign(FormatOptions options, MimeMessage message, IList`1<string> headers);
    public void Sign(MimeMessage message, IList`1<string> headers);
    public void Sign(FormatOptions options, MimeMessage message, IList`1<HeaderId> headers);
    public void Sign(MimeMessage message, IList`1<HeaderId> headers);
}
public abstract class MimeKit.Cryptography.DkimSignerBase : object {
    [CompilerGeneratedAttribute]
private string <Domain>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Selector>k__BackingField;
    [CompilerGeneratedAttribute]
private DkimSignatureAlgorithm <SignatureAlgorithm>k__BackingField;
    [CompilerGeneratedAttribute]
private DkimCanonicalizationAlgorithm <BodyCanonicalizationAlgorithm>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<TimeSpan> <SignaturesExpireAfter>k__BackingField;
    [CompilerGeneratedAttribute]
private DkimCanonicalizationAlgorithm <HeaderCanonicalizationAlgorithm>k__BackingField;
    [CompilerGeneratedAttribute]
private AsymmetricKeyParameter <PrivateKey>k__BackingField;
    public string Domain { get; private set; }
    public string Selector { get; private set; }
    public DkimSignatureAlgorithm SignatureAlgorithm { get; public set; }
    public DkimCanonicalizationAlgorithm BodyCanonicalizationAlgorithm { get; public set; }
    public Nullable`1<TimeSpan> SignaturesExpireAfter { get; public set; }
    public DkimCanonicalizationAlgorithm HeaderCanonicalizationAlgorithm { get; public set; }
    protected AsymmetricKeyParameter PrivateKey { get; protected set; }
    protected DkimSignerBase(string domain, string selector, DkimSignatureAlgorithm algorithm);
    [CompilerGeneratedAttribute]
public string get_Domain();
    [CompilerGeneratedAttribute]
private void set_Domain(string value);
    [CompilerGeneratedAttribute]
public string get_Selector();
    [CompilerGeneratedAttribute]
private void set_Selector(string value);
    [CompilerGeneratedAttribute]
public DkimSignatureAlgorithm get_SignatureAlgorithm();
    [CompilerGeneratedAttribute]
public void set_SignatureAlgorithm(DkimSignatureAlgorithm value);
    [CompilerGeneratedAttribute]
public DkimCanonicalizationAlgorithm get_BodyCanonicalizationAlgorithm();
    [CompilerGeneratedAttribute]
public void set_BodyCanonicalizationAlgorithm(DkimCanonicalizationAlgorithm value);
    [CompilerGeneratedAttribute]
public Nullable`1<TimeSpan> get_SignaturesExpireAfter();
    [CompilerGeneratedAttribute]
public void set_SignaturesExpireAfter(Nullable`1<TimeSpan> value);
    [CompilerGeneratedAttribute]
public DkimCanonicalizationAlgorithm get_HeaderCanonicalizationAlgorithm();
    [CompilerGeneratedAttribute]
public void set_HeaderCanonicalizationAlgorithm(DkimCanonicalizationAlgorithm value);
    [CompilerGeneratedAttribute]
protected AsymmetricKeyParameter get_PrivateKey();
    [CompilerGeneratedAttribute]
protected void set_PrivateKey(AsymmetricKeyParameter value);
    internal static AsymmetricKeyParameter LoadPrivateKey(Stream stream);
    protected internal virtual ISigner CreateSigningContext();
}
internal class MimeKit.Cryptography.DkimSimpleBodyFilter : DkimBodyFilter {
    private int Filter(ReadOnlySpan`1<byte> input, Span`1<byte> output);
    protected virtual Byte[] Filter(Byte[] input, int startIndex, int length, Int32& outputIndex, Int32& outputLength, bool flush);
    public virtual void Reset();
}
public class MimeKit.Cryptography.DkimVerifier : DkimVerifierBase {
    public DkimVerifier(IDkimPublicKeyLocator publicKeyLocator);
    private static void ValidateDkimSignatureParameters(Dictionary`2<string, string> parameters, DkimSignatureAlgorithm& algorithm, DkimCanonicalizationAlgorithm& headerAlgorithm, DkimCanonicalizationAlgorithm& bodyAlgorithm, String& d, String& s, String& q, String[]& headers, String& bh, String& b, Int32& maxLength);
    [AsyncStateMachineAttribute("MimeKit.Cryptography.DkimVerifier/<VerifyAsync>d__2")]
private Task`1<bool> VerifyAsync(FormatOptions options, MimeMessage message, Header dkimSignature, bool doAsync, CancellationToken cancellationToken);
    public bool Verify(FormatOptions options, MimeMessage message, Header dkimSignature, CancellationToken cancellationToken);
    public Task`1<bool> VerifyAsync(FormatOptions options, MimeMessage message, Header dkimSignature, CancellationToken cancellationToken);
    public bool Verify(MimeMessage message, Header dkimSignature, CancellationToken cancellationToken);
    public Task`1<bool> VerifyAsync(MimeMessage message, Header dkimSignature, CancellationToken cancellationToken);
}
public abstract class MimeKit.Cryptography.DkimVerifierBase : object {
    private int enabledSignatureAlgorithms;
    [CompilerGeneratedAttribute]
private IDkimPublicKeyLocator <PublicKeyLocator>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MinimumRsaKeyLength>k__BackingField;
    protected IDkimPublicKeyLocator PublicKeyLocator { get; private set; }
    public int MinimumRsaKeyLength { get; public set; }
    protected DkimVerifierBase(IDkimPublicKeyLocator publicKeyLocator);
    [CompilerGeneratedAttribute]
protected IDkimPublicKeyLocator get_PublicKeyLocator();
    [CompilerGeneratedAttribute]
private void set_PublicKeyLocator(IDkimPublicKeyLocator value);
    [CompilerGeneratedAttribute]
public int get_MinimumRsaKeyLength();
    [CompilerGeneratedAttribute]
public void set_MinimumRsaKeyLength(int value);
    public void Enable(DkimSignatureAlgorithm algorithm);
    public void Disable(DkimSignatureAlgorithm algorithm);
    public bool IsEnabled(DkimSignatureAlgorithm algorithm);
    private static bool IsWhiteSpace(char c);
    private static bool IsAlpha(char c);
    internal static Dictionary`2<string, string> ParseParameterTags(HeaderId header, string signature);
    internal static void ValidateCommonParameters(string header, IDictionary`2<string, string> parameters, DkimSignatureAlgorithm& algorithm, String& d, String& s, String& q, String& b);
    internal static void ValidateCommonSignatureParameters(string header, IDictionary`2<string, string> parameters, DkimSignatureAlgorithm& algorithm, DkimCanonicalizationAlgorithm& headerAlgorithm, DkimCanonicalizationAlgorithm& bodyAlgorithm, String& d, String& s, String& q, String[]& headers, String& bh, String& b, Int32& maxLength);
    internal static void WriteHeaderRelaxed(FormatOptions options, Stream stream, Header header, bool isDkimSignature);
    internal static void WriteHeaderSimple(FormatOptions options, Stream stream, Header header, bool isDkimSignature);
    internal virtual ISigner CreateVerifyContext(DkimSignatureAlgorithm algorithm, AsymmetricKeyParameter key);
    internal static void WriteHeaders(FormatOptions options, MimeMessage message, IList`1<string> fields, DkimCanonicalizationAlgorithm headerCanonicalizationAlgorithm, Stream stream);
    internal static Header GetSignedSignatureHeader(Header header);
    protected static bool VerifyBodyHash(FormatOptions options, MimeMessage message, DkimSignatureAlgorithm signatureAlgorithm, DkimCanonicalizationAlgorithm canonicalizationAlgorithm, int maxLength, string bodyHash);
    protected bool VerifySignature(FormatOptions options, MimeMessage message, Header dkimSignature, DkimSignatureAlgorithm signatureAlgorithm, AsymmetricKeyParameter key, String[] headers, DkimCanonicalizationAlgorithm canonicalizationAlgorithm, string signature);
}
internal class MimeKit.Cryptography.Ed25519DigestSigner : object {
    private Ed25519PrivateKeyParameters privateKey;
    private Ed25519PublicKeyParameters publicKey;
    private IDigest digest;
    public string AlgorithmName { get; }
    public Ed25519DigestSigner(IDigest digest);
    public sealed virtual int GetMaxSignatureSize();
    public sealed virtual string get_AlgorithmName();
    public sealed virtual void Init(bool forSigning, ICipherParameters parameters);
    public sealed virtual void Update(byte input);
    public sealed virtual void BlockUpdate(Byte[] input, int inOff, int length);
    public sealed virtual void BlockUpdate(ReadOnlySpan`1<byte> input);
    public sealed virtual Byte[] GenerateSignature();
    public sealed virtual bool VerifySignature(Byte[] signature);
    public sealed virtual void Reset();
}
public enum MimeKit.Cryptography.EncryptionAlgorithm : Enum {
    public int value__;
    public static EncryptionAlgorithm Aes128;
    public static EncryptionAlgorithm Aes192;
    public static EncryptionAlgorithm Aes256;
    public static EncryptionAlgorithm Camellia128;
    public static EncryptionAlgorithm Camellia192;
    public static EncryptionAlgorithm Camellia256;
    public static EncryptionAlgorithm Cast5;
    public static EncryptionAlgorithm Des;
    public static EncryptionAlgorithm TripleDes;
    public static EncryptionAlgorithm Idea;
    public static EncryptionAlgorithm Blowfish;
    public static EncryptionAlgorithm Twofish;
    public static EncryptionAlgorithm RC240;
    public static EncryptionAlgorithm RC264;
    public static EncryptionAlgorithm RC2128;
    public static EncryptionAlgorithm Seed;
}
public abstract class MimeKit.Cryptography.GnuPGContext : OpenPgpContext {
    private static Dictionary`2<string, EncryptionAlgorithm> EncryptionAlgorithms;
    private static Dictionary`2<string, DigestAlgorithm> DigestAlgorithms;
    private static Byte[] EmptyKeyRingBundle;
    private static Char[] Whitespace;
    private static string GnuPGHomeDir;
    [CompilerGeneratedAttribute]
private string <PublicKeyRingPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SecretKeyRingPath>k__BackingField;
    [CompilerGeneratedAttribute]
private PgpPublicKeyRingBundle <PublicKeyRingBundle>k__BackingField;
    [CompilerGeneratedAttribute]
private PgpSecretKeyRingBundle <SecretKeyRingBundle>k__BackingField;
    protected string PublicKeyRingPath { get; protected set; }
    protected string SecretKeyRingPath { get; protected set; }
    public PgpPublicKeyRingBundle PublicKeyRingBundle { get; protected set; }
    public PgpSecretKeyRingBundle SecretKeyRingBundle { get; protected set; }
    private static GnuPGContext();
    protected GnuPGContext(string gnupgDir);
    [CompilerGeneratedAttribute]
protected string get_PublicKeyRingPath();
    [CompilerGeneratedAttribute]
protected void set_PublicKeyRingPath(string value);
    [CompilerGeneratedAttribute]
protected string get_SecretKeyRingPath();
    [CompilerGeneratedAttribute]
protected void set_SecretKeyRingPath(string value);
    [CompilerGeneratedAttribute]
public PgpPublicKeyRingBundle get_PublicKeyRingBundle();
    [CompilerGeneratedAttribute]
protected void set_PublicKeyRingBundle(PgpPublicKeyRingBundle value);
    [CompilerGeneratedAttribute]
public PgpSecretKeyRingBundle get_SecretKeyRingBundle();
    [CompilerGeneratedAttribute]
protected void set_SecretKeyRingBundle(PgpSecretKeyRingBundle value);
    private bool TryGetPublicKeyRing(long keyId, PgpPublicKeyRing& keyring);
    protected virtual PgpPublicKeyRing GetPublicKeyRing(long keyId, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MimeKit.Cryptography.GnuPGContext/<GetPublicKeyRingAsync>d__26")]
protected virtual Task`1<PgpPublicKeyRing> GetPublicKeyRingAsync(long keyId, CancellationToken cancellationToken);
    [IteratorStateMachineAttribute("MimeKit.Cryptography.GnuPGContext/<EnumeratePublicKeyRings>d__27")]
public virtual IEnumerable`1<PgpPublicKeyRing> EnumeratePublicKeyRings();
    [IteratorStateMachineAttribute("MimeKit.Cryptography.GnuPGContext/<EnumeratePublicKeys>d__28")]
public virtual IEnumerable`1<PgpPublicKey> EnumeratePublicKeys();
    [IteratorStateMachineAttribute("MimeKit.Cryptography.GnuPGContext/<EnumeratePublicKeyRings>d__29")]
public virtual IEnumerable`1<PgpPublicKeyRing> EnumeratePublicKeyRings(MailboxAddress mailbox);
    [IteratorStateMachineAttribute("MimeKit.Cryptography.GnuPGContext/<EnumeratePublicKeys>d__30")]
public virtual IEnumerable`1<PgpPublicKey> EnumeratePublicKeys(MailboxAddress mailbox);
    [IteratorStateMachineAttribute("MimeKit.Cryptography.GnuPGContext/<EnumerateSecretKeyRings>d__31")]
public virtual IEnumerable`1<PgpSecretKeyRing> EnumerateSecretKeyRings();
    [IteratorStateMachineAttribute("MimeKit.Cryptography.GnuPGContext/<EnumerateSecretKeys>d__32")]
public virtual IEnumerable`1<PgpSecretKey> EnumerateSecretKeys();
    [IteratorStateMachineAttribute("MimeKit.Cryptography.GnuPGContext/<EnumerateSecretKeyRings>d__33")]
public virtual IEnumerable`1<PgpSecretKeyRing> EnumerateSecretKeyRings(MailboxAddress mailbox);
    [IteratorStateMachineAttribute("MimeKit.Cryptography.GnuPGContext/<EnumerateSecretKeys>d__34")]
public virtual IEnumerable`1<PgpSecretKey> EnumerateSecretKeys(MailboxAddress mailbox);
    protected virtual PgpPublicKey GetPublicKey(MailboxAddress mailbox);
    public virtual IList`1<PgpPublicKey> GetPublicKeys(IEnumerable`1<MailboxAddress> mailboxes, CancellationToken cancellationToken);
    protected virtual PgpSecretKey GetSecretKey(long keyId, CancellationToken cancellationToken);
    public virtual PgpSecretKey GetSigningKey(MailboxAddress mailbox, CancellationToken cancellationToken);
    public virtual bool CanSign(MailboxAddress signer, CancellationToken cancellationToken);
    public virtual bool CanEncrypt(MailboxAddress mailbox, CancellationToken cancellationToken);
    private static void AddEncryptionKeyPair(PgpKeyRingGenerator keyRingGenerator, KeyGenerationParameters parameters, PublicKeyAlgorithmTag algorithm, DateTime now, long expirationTime, Int32[] encryptionAlgorithms, Int32[] digestAlgorithms);
    private PgpKeyRingGenerator CreateKeyRingGenerator(MailboxAddress mailbox, EncryptionAlgorithm algorithm, long expirationTime, string password, DateTime now, SecureRandom random);
    public void GenerateKeyPair(MailboxAddress mailbox, string password, Nullable`1<DateTime> expirationDate, EncryptionAlgorithm algorithm, SecureRandom random);
    public void SignKey(PgpSecretKey secretKey, PgpPublicKey publicKey, DigestAlgorithm digestAlgo, OpenPgpKeyCertification certification);
    protected void SavePublicKeyRingBundle();
    protected void SaveSecretKeyRingBundle();
    private void UpdateKeyServer(string value);
    private void UpdateKeyServerOptions(string value);
    private static EncryptionAlgorithm[] ParseEncryptionAlgorithms(string value);
    private static DigestAlgorithm[] ParseDigestAlgorithms(string value);
    private void UpdatePersonalCipherPreferences(string value);
    private void UpdatePersonalDigestPreferences(string value);
    private void LoadConfiguration(string configFile);
    public virtual void Import(PgpPublicKeyRing keyring, CancellationToken cancellationToken);
    public virtual void Import(PgpPublicKeyRingBundle bundle, CancellationToken cancellationToken);
    public virtual void Import(PgpSecretKeyRing keyring, CancellationToken cancellationToken);
    public virtual void Import(PgpSecretKeyRingBundle bundle, CancellationToken cancellationToken);
    public virtual MimePart Export(IEnumerable`1<MailboxAddress> mailboxes, CancellationToken cancellationToken);
    public virtual Task`1<MimePart> ExportAsync(IEnumerable`1<MailboxAddress> mailboxes, CancellationToken cancellationToken);
    public virtual void Export(IEnumerable`1<MailboxAddress> mailboxes, Stream stream, bool armor, CancellationToken cancellationToken);
    public virtual Task ExportAsync(IEnumerable`1<MailboxAddress> mailboxes, Stream stream, bool armor, CancellationToken cancellationToken);
    public virtual void Delete(PgpPublicKeyRing keyring);
    public virtual void Delete(PgpSecretKeyRing keyring);
}
public interface MimeKit.Cryptography.IApplicationPgpEncrypted {
}
public interface MimeKit.Cryptography.IApplicationPgpSignature {
}
public interface MimeKit.Cryptography.IApplicationPkcs7Mime {
    public SecureMimeType SecureMimeType { get; }
    public abstract virtual SecureMimeType get_SecureMimeType();
    public abstract virtual MimeEntity Decompress(SecureMimeContext ctx, CancellationToken cancellationToken);
    public abstract virtual Task`1<MimeEntity> DecompressAsync(SecureMimeContext ctx, CancellationToken cancellationToken);
    public abstract virtual MimeEntity Decompress(CancellationToken cancellationToken);
    public abstract virtual Task`1<MimeEntity> DecompressAsync(CancellationToken cancellationToken);
    public abstract virtual MimeEntity Decrypt(SecureMimeContext ctx, CancellationToken cancellationToken);
    public abstract virtual Task`1<MimeEntity> DecryptAsync(SecureMimeContext ctx, CancellationToken cancellationToken);
    public abstract virtual MimeEntity Decrypt(CancellationToken cancellationToken);
    public abstract virtual Task`1<MimeEntity> DecryptAsync(CancellationToken cancellationToken);
    public abstract virtual void Import(SecureMimeContext ctx, CancellationToken cancellationToken);
    public abstract virtual Task ImportAsync(SecureMimeContext ctx, CancellationToken cancellationToken);
    public abstract virtual DigitalSignatureCollection Verify(SecureMimeContext ctx, MimeEntity& entity, CancellationToken cancellationToken);
    public abstract virtual DigitalSignatureCollection Verify(MimeEntity& entity, CancellationToken cancellationToken);
}
public interface MimeKit.Cryptography.IApplicationPkcs7Signature {
}
public interface MimeKit.Cryptography.ICryptographyContext {
    public bool PrepareBeforeSigning { get; public set; }
    public string SignatureProtocol { get; }
    public string EncryptionProtocol { get; }
    public string KeyExchangeProtocol { get; }
    public DigestAlgorithm[] EnabledDigestAlgorithms { get; }
    public EncryptionAlgorithm[] EnabledEncryptionAlgorithms { get; }
    public abstract virtual bool get_PrepareBeforeSigning();
    public abstract virtual void set_PrepareBeforeSigning(bool value);
    public abstract virtual string get_SignatureProtocol();
    public abstract virtual string get_EncryptionProtocol();
    public abstract virtual string get_KeyExchangeProtocol();
    public abstract virtual bool Supports(string protocol);
    public abstract virtual DigestAlgorithm[] get_EnabledDigestAlgorithms();
    public abstract virtual void Enable(DigestAlgorithm algorithm);
    public abstract virtual void Disable(DigestAlgorithm algorithm);
    public abstract virtual DigestAlgorithm GetDigestAlgorithm(string micalg);
    public abstract virtual string GetDigestAlgorithmName(DigestAlgorithm micalg);
    public abstract virtual bool IsEnabled(DigestAlgorithm algorithm);
    public abstract virtual EncryptionAlgorithm[] get_EnabledEncryptionAlgorithms();
    public abstract virtual void Enable(EncryptionAlgorithm algorithm);
    public abstract virtual void Disable(EncryptionAlgorithm algorithm);
    public abstract virtual bool IsEnabled(EncryptionAlgorithm algorithm);
    public abstract virtual bool CanEncrypt(MailboxAddress mailbox, CancellationToken cancellationToken);
    public abstract virtual Task`1<bool> CanEncryptAsync(MailboxAddress mailbox, CancellationToken cancellationToken);
    public abstract virtual MimePart Encrypt(IEnumerable`1<MailboxAddress> recipients, Stream content, CancellationToken cancellationToken);
    public abstract virtual Task`1<MimePart> EncryptAsync(IEnumerable`1<MailboxAddress> recipients, Stream content, CancellationToken cancellationToken);
    public abstract virtual MimeEntity Decrypt(Stream encryptedData, CancellationToken cancellationToken);
    public abstract virtual Task`1<MimeEntity> DecryptAsync(Stream encryptedData, CancellationToken cancellationToken);
    public abstract virtual bool CanSign(MailboxAddress signer, CancellationToken cancellationToken);
    public abstract virtual Task`1<bool> CanSignAsync(MailboxAddress signer, CancellationToken cancellationToken);
    public abstract virtual MimePart Sign(MailboxAddress signer, DigestAlgorithm digestAlgo, Stream content, CancellationToken cancellationToken);
    public abstract virtual Task`1<MimePart> SignAsync(MailboxAddress signer, DigestAlgorithm digestAlgo, Stream content, CancellationToken cancellationToken);
    public abstract virtual DigitalSignatureCollection Verify(Stream content, Stream signatureData, CancellationToken cancellationToken);
    public abstract virtual Task`1<DigitalSignatureCollection> VerifyAsync(Stream content, Stream signatureData, CancellationToken cancellationToken);
    public abstract virtual void Import(Stream stream, CancellationToken cancellationToken);
    public abstract virtual Task ImportAsync(Stream stream, CancellationToken cancellationToken);
    public abstract virtual MimePart Export(IEnumerable`1<MailboxAddress> mailboxes, CancellationToken cancellationToken);
    public abstract virtual Task`1<MimePart> ExportAsync(IEnumerable`1<MailboxAddress> mailboxes, CancellationToken cancellationToken);
}
public interface MimeKit.Cryptography.IDigitalCertificate {
    public PublicKeyAlgorithm PublicKeyAlgorithm { get; }
    public DateTime CreationDate { get; }
    public DateTime ExpirationDate { get; }
    public string Fingerprint { get; }
    public string Email { get; }
    public string Name { get; }
    public abstract virtual PublicKeyAlgorithm get_PublicKeyAlgorithm();
    public abstract virtual DateTime get_CreationDate();
    public abstract virtual DateTime get_ExpirationDate();
    public abstract virtual string get_Fingerprint();
    public abstract virtual string get_Email();
    public abstract virtual string get_Name();
}
public interface MimeKit.Cryptography.IDigitalSignature {
    public IDigitalCertificate SignerCertificate { get; }
    public PublicKeyAlgorithm PublicKeyAlgorithm { get; }
    public DigestAlgorithm DigestAlgorithm { get; }
    public DateTime CreationDate { get; }
    public abstract virtual IDigitalCertificate get_SignerCertificate();
    public abstract virtual PublicKeyAlgorithm get_PublicKeyAlgorithm();
    public abstract virtual DigestAlgorithm get_DigestAlgorithm();
    public abstract virtual DateTime get_CreationDate();
    public abstract virtual bool Verify();
    public abstract virtual bool Verify(bool verifySignatureOnly);
}
public interface MimeKit.Cryptography.IDkimPublicKeyLocator {
    public abstract virtual AsymmetricKeyParameter LocatePublicKey(string methods, string domain, string selector, CancellationToken cancellationToken);
    public abstract virtual Task`1<AsymmetricKeyParameter> LocatePublicKeyAsync(string methods, string domain, string selector, CancellationToken cancellationToken);
}
public interface MimeKit.Cryptography.IMultipartEncrypted {
    public abstract virtual MimeEntity Decrypt(OpenPgpContext ctx, DigitalSignatureCollection& signatures, CancellationToken cancellationToken);
    public abstract virtual MimeEntity Decrypt(OpenPgpContext ctx, CancellationToken cancellationToken);
    public abstract virtual MimeEntity Decrypt(DigitalSignatureCollection& signatures, CancellationToken cancellationToken);
    public abstract virtual MimeEntity Decrypt(CancellationToken cancellationToken);
}
public interface MimeKit.Cryptography.IMultipartSigned {
    public abstract virtual DigitalSignatureCollection Verify(CryptographyContext ctx, CancellationToken cancellationToken);
    public abstract virtual Task`1<DigitalSignatureCollection> VerifyAsync(CryptographyContext ctx, CancellationToken cancellationToken);
    public abstract virtual DigitalSignatureCollection Verify(CancellationToken cancellationToken);
    public abstract virtual Task`1<DigitalSignatureCollection> VerifyAsync(CancellationToken cancellationToken);
}
public interface MimeKit.Cryptography.ISecureMimeContext {
    public abstract virtual ApplicationPkcs7Mime Compress(Stream stream, CancellationToken cancellationToken);
    public abstract virtual Task`1<ApplicationPkcs7Mime> CompressAsync(Stream stream, CancellationToken cancellationToken);
    public abstract virtual MimeEntity Decompress(Stream stream, CancellationToken cancellationToken);
    public abstract virtual Task`1<MimeEntity> DecompressAsync(Stream stream, CancellationToken cancellationToken);
    public abstract virtual void DecompressTo(Stream stream, Stream output, CancellationToken cancellationToken);
    public abstract virtual Task DecompressToAsync(Stream stream, Stream output, CancellationToken cancellationToken);
    public abstract virtual ApplicationPkcs7Mime Encrypt(CmsRecipientCollection recipients, Stream content, CancellationToken cancellationToken);
    public abstract virtual Task`1<ApplicationPkcs7Mime> EncryptAsync(CmsRecipientCollection recipients, Stream content, CancellationToken cancellationToken);
    public abstract virtual void DecryptTo(Stream encryptedData, Stream decryptedData, CancellationToken cancellationToken);
    public abstract virtual Task DecryptToAsync(Stream encryptedData, Stream decryptedData, CancellationToken cancellationToken);
    public abstract virtual ApplicationPkcs7Mime EncapsulatedSign(CmsSigner signer, Stream content, CancellationToken cancellationToken);
    public abstract virtual Task`1<ApplicationPkcs7Mime> EncapsulatedSignAsync(CmsSigner signer, Stream content, CancellationToken cancellationToken);
    public abstract virtual ApplicationPkcs7Mime EncapsulatedSign(MailboxAddress signer, DigestAlgorithm digestAlgo, Stream content, CancellationToken cancellationToken);
    public abstract virtual Task`1<ApplicationPkcs7Mime> EncapsulatedSignAsync(MailboxAddress signer, DigestAlgorithm digestAlgo, Stream content, CancellationToken cancellationToken);
    public abstract virtual ApplicationPkcs7Signature Sign(CmsSigner signer, Stream content, CancellationToken cancellationToken);
    public abstract virtual Task`1<ApplicationPkcs7Signature> SignAsync(CmsSigner signer, Stream content, CancellationToken cancellationToken);
    public abstract virtual DigitalSignatureCollection Verify(Stream signedData, MimeEntity& entity, CancellationToken cancellationToken);
    public abstract virtual Stream Verify(Stream signedData, DigitalSignatureCollection& signatures, CancellationToken cancellationToken);
    public abstract virtual void Import(Stream stream, string password, CancellationToken cancellationToken);
    public abstract virtual Task ImportAsync(Stream stream, string password, CancellationToken cancellationToken);
    public abstract virtual void Import(string fileName, string password, CancellationToken cancellationToken);
    public abstract virtual Task ImportAsync(string fileName, string password, CancellationToken cancellationToken);
    public abstract virtual void Import(X509Certificate2 certificate, CancellationToken cancellationToken);
    public abstract virtual Task ImportAsync(X509Certificate2 certificate, CancellationToken cancellationToken);
}
public interface MimeKit.Cryptography.IX509CertificateDatabase {
    public abstract virtual X509CertificateRecord Find(X509Certificate certificate, X509CertificateRecordFields fields);
    public abstract virtual IEnumerable`1<X509Certificate> FindCertificates(ISelector`1<X509Certificate> selector);
    public abstract virtual IEnumerable`1<AsymmetricKeyParameter> FindPrivateKeys(ISelector`1<X509Certificate> selector);
    public abstract virtual IEnumerable`1<X509CertificateRecord> Find(MailboxAddress mailbox, DateTime now, bool requirePrivateKey, X509CertificateRecordFields fields);
    public abstract virtual IEnumerable`1<X509CertificateRecord> Find(ISelector`1<X509Certificate> selector, bool trustedAnchorsOnly, X509CertificateRecordFields fields);
    public abstract virtual void Add(X509CertificateRecord record);
    public abstract virtual void Remove(X509CertificateRecord record);
    public abstract virtual void Update(X509CertificateRecord record, X509CertificateRecordFields fields);
    public abstract virtual IEnumerable`1<X509CrlRecord> Find(X509Name issuer, X509CrlRecordFields fields);
    public abstract virtual X509CrlRecord Find(X509Crl crl, X509CrlRecordFields fields);
    public abstract virtual void Add(X509CrlRecord record);
    public abstract virtual void Remove(X509CrlRecord record);
    public abstract virtual void Update(X509CrlRecord record);
    public abstract virtual IStore`1<X509Crl> GetCrlStore();
}
public class MimeKit.Cryptography.MultipartEncrypted : Multipart {
    public MultipartEncrypted(MimeEntityConstructorArgs args);
    private void CheckDisposed();
    public virtual void Accept(MimeVisitor visitor);
    private static MultipartEncrypted CreateMultipartEncrypted(OpenPgpContext ctx, MimeEntity part);
    [AsyncStateMachineAttribute("MimeKit.Cryptography.MultipartEncrypted/<SignAndEncryptAsync>d__5")]
private static Task`1<MultipartEncrypted> SignAndEncryptAsync(OpenPgpContext ctx, MailboxAddress signer, DigestAlgorithm digestAlgo, EncryptionAlgorithm cipherAlgo, IEnumerable`1<MailboxAddress> recipients, MimeEntity entity, bool doAsync, CancellationToken cancellationToken);
    public static MultipartEncrypted SignAndEncrypt(OpenPgpContext ctx, MailboxAddress signer, DigestAlgorithm digestAlgo, EncryptionAlgorithm cipherAlgo, IEnumerable`1<MailboxAddress> recipients, MimeEntity entity, CancellationToken cancellationToken);
    public static Task`1<MultipartEncrypted> SignAndEncryptAsync(OpenPgpContext ctx, MailboxAddress signer, DigestAlgorithm digestAlgo, EncryptionAlgorithm cipherAlgo, IEnumerable`1<MailboxAddress> recipients, MimeEntity entity, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MimeKit.Cryptography.MultipartEncrypted/<SignAndEncryptAsync>d__8")]
private static Task`1<MultipartEncrypted> SignAndEncryptAsync(OpenPgpContext ctx, MailboxAddress signer, DigestAlgorithm digestAlgo, IEnumerable`1<MailboxAddress> recipients, MimeEntity entity, bool doAsync, CancellationToken cancellationToken);
    public static MultipartEncrypted SignAndEncrypt(OpenPgpContext ctx, MailboxAddress signer, DigestAlgorithm digestAlgo, IEnumerable`1<MailboxAddress> recipients, MimeEntity entity, CancellationToken cancellationToken);
    public static Task`1<MultipartEncrypted> SignAndEncryptAsync(OpenPgpContext ctx, MailboxAddress signer, DigestAlgorithm digestAlgo, IEnumerable`1<MailboxAddress> recipients, MimeEntity entity, CancellationToken cancellationToken);
    public static MultipartEncrypted SignAndEncrypt(MailboxAddress signer, DigestAlgorithm digestAlgo, EncryptionAlgorithm cipherAlgo, IEnumerable`1<MailboxAddress> recipients, MimeEntity entity, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MimeKit.Cryptography.MultipartEncrypted/<SignAndEncryptAsync>d__12")]
public static Task`1<MultipartEncrypted> SignAndEncryptAsync(MailboxAddress signer, DigestAlgorithm digestAlgo, EncryptionAlgorithm cipherAlgo, IEnumerable`1<MailboxAddress> recipients, MimeEntity entity, CancellationToken cancellationToken);
    public static MultipartEncrypted SignAndEncrypt(MailboxAddress signer, DigestAlgorithm digestAlgo, IEnumerable`1<MailboxAddress> recipients, MimeEntity entity, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MimeKit.Cryptography.MultipartEncrypted/<SignAndEncryptAsync>d__14")]
public static Task`1<MultipartEncrypted> SignAndEncryptAsync(MailboxAddress signer, DigestAlgorithm digestAlgo, IEnumerable`1<MailboxAddress> recipients, MimeEntity entity, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MimeKit.Cryptography.MultipartEncrypted/<SignAndEncryptAsync>d__15")]
private static Task`1<MultipartEncrypted> SignAndEncryptAsync(OpenPgpContext ctx, PgpSecretKey signer, DigestAlgorithm digestAlgo, EncryptionAlgorithm cipherAlgo, IEnumerable`1<PgpPublicKey> recipients, MimeEntity entity, bool doAsync, CancellationToken cancellationToken);
    public static MultipartEncrypted SignAndEncrypt(OpenPgpContext ctx, PgpSecretKey signer, DigestAlgorithm digestAlgo, EncryptionAlgorithm cipherAlgo, IEnumerable`1<PgpPublicKey> recipients, MimeEntity entity, CancellationToken cancellationToken);
    public static Task`1<MultipartEncrypted> SignAndEncryptAsync(OpenPgpContext ctx, PgpSecretKey signer, DigestAlgorithm digestAlgo, EncryptionAlgorithm cipherAlgo, IEnumerable`1<PgpPublicKey> recipients, MimeEntity entity, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MimeKit.Cryptography.MultipartEncrypted/<SignAndEncryptAsync>d__18")]
private static Task`1<MultipartEncrypted> SignAndEncryptAsync(OpenPgpContext ctx, PgpSecretKey signer, DigestAlgorithm digestAlgo, IEnumerable`1<PgpPublicKey> recipients, MimeEntity entity, bool doAsync, CancellationToken cancellationToken);
    public static MultipartEncrypted SignAndEncrypt(OpenPgpContext ctx, PgpSecretKey signer, DigestAlgorithm digestAlgo, IEnumerable`1<PgpPublicKey> recipients, MimeEntity entity, CancellationToken cancellationToken);
    public static Task`1<MultipartEncrypted> SignAndEncryptAsync(OpenPgpContext ctx, PgpSecretKey signer, DigestAlgorithm digestAlgo, IEnumerable`1<PgpPublicKey> recipients, MimeEntity entity, CancellationToken cancellationToken);
    public static MultipartEncrypted SignAndEncrypt(PgpSecretKey signer, DigestAlgorithm digestAlgo, EncryptionAlgorithm cipherAlgo, IEnumerable`1<PgpPublicKey> recipients, MimeEntity entity, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MimeKit.Cryptography.MultipartEncrypted/<SignAndEncryptAsync>d__22")]
public static Task`1<MultipartEncrypted> SignAndEncryptAsync(PgpSecretKey signer, DigestAlgorithm digestAlgo, EncryptionAlgorithm cipherAlgo, IEnumerable`1<PgpPublicKey> recipients, MimeEntity entity, CancellationToken cancellationToken);
    public static MultipartEncrypted SignAndEncrypt(PgpSecretKey signer, DigestAlgorithm digestAlgo, IEnumerable`1<PgpPublicKey> recipients, MimeEntity entity, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MimeKit.Cryptography.MultipartEncrypted/<SignAndEncryptAsync>d__24")]
public static Task`1<MultipartEncrypted> SignAndEncryptAsync(PgpSecretKey signer, DigestAlgorithm digestAlgo, IEnumerable`1<PgpPublicKey> recipients, MimeEntity entity, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MimeKit.Cryptography.MultipartEncrypted/<EncryptAsync>d__25")]
private static Task`1<MultipartEncrypted> EncryptAsync(OpenPgpContext ctx, EncryptionAlgorithm algorithm, IEnumerable`1<MailboxAddress> recipients, MimeEntity entity, bool doAsync, CancellationToken cancellationToken);
    public static MultipartEncrypted Encrypt(OpenPgpContext ctx, EncryptionAlgorithm algorithm, IEnumerable`1<MailboxAddress> recipients, MimeEntity entity, CancellationToken cancellationToken);
    public static Task`1<MultipartEncrypted> EncryptAsync(OpenPgpContext ctx, EncryptionAlgorithm algorithm, IEnumerable`1<MailboxAddress> recipients, MimeEntity entity, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MimeKit.Cryptography.MultipartEncrypted/<EncryptAsync>d__28")]
private static Task`1<MultipartEncrypted> EncryptAsync(OpenPgpContext ctx, IEnumerable`1<MailboxAddress> recipients, MimeEntity entity, bool doAsync, CancellationToken cancellationToken);
    public static MultipartEncrypted Encrypt(OpenPgpContext ctx, IEnumerable`1<MailboxAddress> recipients, MimeEntity entity, CancellationToken cancellationToken);
    public static Task`1<MultipartEncrypted> EncryptAsync(OpenPgpContext ctx, IEnumerable`1<MailboxAddress> recipients, MimeEntity entity, CancellationToken cancellationToken);
    public static MultipartEncrypted Encrypt(EncryptionAlgorithm algorithm, IEnumerable`1<MailboxAddress> recipients, MimeEntity entity, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MimeKit.Cryptography.MultipartEncrypted/<EncryptAsync>d__32")]
public static Task`1<MultipartEncrypted> EncryptAsync(EncryptionAlgorithm algorithm, IEnumerable`1<MailboxAddress> recipients, MimeEntity entity, CancellationToken cancellationToken);
    public static MultipartEncrypted Encrypt(IEnumerable`1<MailboxAddress> recipients, MimeEntity entity, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MimeKit.Cryptography.MultipartEncrypted/<EncryptAsync>d__34")]
public static Task`1<MultipartEncrypted> EncryptAsync(IEnumerable`1<MailboxAddress> recipients, MimeEntity entity, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MimeKit.Cryptography.MultipartEncrypted/<EncryptAsync>d__35")]
private static Task`1<MultipartEncrypted> EncryptAsync(OpenPgpContext ctx, EncryptionAlgorithm algorithm, IEnumerable`1<PgpPublicKey> recipients, MimeEntity entity, bool doAsync, CancellationToken cancellationToken);
    public static MultipartEncrypted Encrypt(OpenPgpContext ctx, EncryptionAlgorithm algorithm, IEnumerable`1<PgpPublicKey> recipients, MimeEntity entity, CancellationToken cancellationToken);
    public static Task`1<MultipartEncrypted> EncryptAsync(OpenPgpContext ctx, EncryptionAlgorithm algorithm, IEnumerable`1<PgpPublicKey> recipients, MimeEntity entity, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MimeKit.Cryptography.MultipartEncrypted/<EncryptAsync>d__38")]
private static Task`1<MultipartEncrypted> EncryptAsync(OpenPgpContext ctx, IEnumerable`1<PgpPublicKey> recipients, MimeEntity entity, bool doAsync, CancellationToken cancellationToken);
    public static MultipartEncrypted Encrypt(OpenPgpContext ctx, IEnumerable`1<PgpPublicKey> recipients, MimeEntity entity, CancellationToken cancellationToken);
    public static Task`1<MultipartEncrypted> EncryptAsync(OpenPgpContext ctx, IEnumerable`1<PgpPublicKey> recipients, MimeEntity entity, CancellationToken cancellationToken);
    public static MultipartEncrypted Encrypt(EncryptionAlgorithm algorithm, IEnumerable`1<PgpPublicKey> recipients, MimeEntity entity, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MimeKit.Cryptography.MultipartEncrypted/<EncryptAsync>d__42")]
public static Task`1<MultipartEncrypted> EncryptAsync(EncryptionAlgorithm algorithm, IEnumerable`1<PgpPublicKey> recipients, MimeEntity entity, CancellationToken cancellationToken);
    public static MultipartEncrypted Encrypt(IEnumerable`1<PgpPublicKey> recipients, MimeEntity entity, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MimeKit.Cryptography.MultipartEncrypted/<EncryptAsync>d__44")]
public static Task`1<MultipartEncrypted> EncryptAsync(IEnumerable`1<PgpPublicKey> recipients, MimeEntity entity, CancellationToken cancellationToken);
    public sealed virtual MimeEntity Decrypt(OpenPgpContext ctx, DigitalSignatureCollection& signatures, CancellationToken cancellationToken);
    public sealed virtual MimeEntity Decrypt(OpenPgpContext ctx, CancellationToken cancellationToken);
    public sealed virtual MimeEntity Decrypt(DigitalSignatureCollection& signatures, CancellationToken cancellationToken);
    public sealed virtual MimeEntity Decrypt(CancellationToken cancellationToken);
}
public class MimeKit.Cryptography.MultipartSigned : Multipart {
    public MultipartSigned(MimeEntityConstructorArgs args);
    private void CheckDisposed();
    public virtual void Accept(MimeVisitor visitor);
    private static MimeEntity Prepare(CryptographyContext ctx, MimeEntity entity, Stream memory, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MimeKit.Cryptography.MultipartSigned/<PrepareAsync>d__5")]
private static Task`1<MimeEntity> PrepareAsync(CryptographyContext ctx, MimeEntity entity, Stream memory, CancellationToken cancellationToken);
    private static MultipartSigned Create(CryptographyContext ctx, DigestAlgorithm digestAlgo, MimeEntity entity, MimeEntity signature);
    [AsyncStateMachineAttribute("MimeKit.Cryptography.MultipartSigned/<CreateAsync>d__7")]
private static Task`1<MultipartSigned> CreateAsync(CryptographyContext ctx, MailboxAddress signer, DigestAlgorithm digestAlgo, MimeEntity entity, bool doAsync, CancellationToken cancellationToken);
    public static MultipartSigned Create(CryptographyContext ctx, MailboxAddress signer, DigestAlgorithm digestAlgo, MimeEntity entity, CancellationToken cancellationToken);
    public static Task`1<MultipartSigned> CreateAsync(CryptographyContext ctx, MailboxAddress signer, DigestAlgorithm digestAlgo, MimeEntity entity, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MimeKit.Cryptography.MultipartSigned/<CreateAsync>d__10")]
private static Task`1<MultipartSigned> CreateAsync(OpenPgpContext ctx, PgpSecretKey signer, DigestAlgorithm digestAlgo, MimeEntity entity, bool doAsync, CancellationToken cancellationToken);
    public static MultipartSigned Create(OpenPgpContext ctx, PgpSecretKey signer, DigestAlgorithm digestAlgo, MimeEntity entity, CancellationToken cancellationToken);
    public static Task`1<MultipartSigned> CreateAsync(OpenPgpContext ctx, PgpSecretKey signer, DigestAlgorithm digestAlgo, MimeEntity entity, CancellationToken cancellationToken);
    public static MultipartSigned Create(PgpSecretKey signer, DigestAlgorithm digestAlgo, MimeEntity entity, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MimeKit.Cryptography.MultipartSigned/<CreateAsync>d__14")]
public static Task`1<MultipartSigned> CreateAsync(PgpSecretKey signer, DigestAlgorithm digestAlgo, MimeEntity entity, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MimeKit.Cryptography.MultipartSigned/<CreateAsync>d__15")]
private static Task`1<MultipartSigned> CreateAsync(SecureMimeContext ctx, CmsSigner signer, MimeEntity entity, bool doAsync, CancellationToken cancellationToken);
    public static MultipartSigned Create(SecureMimeContext ctx, CmsSigner signer, MimeEntity entity, CancellationToken cancellationToken);
    public static Task`1<MultipartSigned> CreateAsync(SecureMimeContext ctx, CmsSigner signer, MimeEntity entity, CancellationToken cancellationToken);
    public static MultipartSigned Create(CmsSigner signer, MimeEntity entity, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MimeKit.Cryptography.MultipartSigned/<CreateAsync>d__19")]
public static Task`1<MultipartSigned> CreateAsync(CmsSigner signer, MimeEntity entity, CancellationToken cancellationToken);
    public virtual void Prepare(EncodingConstraint constraint, int maxLineLength);
    public sealed virtual DigitalSignatureCollection Verify(CryptographyContext ctx, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MimeKit.Cryptography.MultipartSigned/<VerifyAsync>d__22")]
public sealed virtual Task`1<DigitalSignatureCollection> VerifyAsync(CryptographyContext ctx, CancellationToken cancellationToken);
    public sealed virtual DigitalSignatureCollection Verify(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MimeKit.Cryptography.MultipartSigned/<VerifyAsync>d__24")]
public sealed virtual Task`1<DigitalSignatureCollection> VerifyAsync(CancellationToken cancellationToken);
}
internal class MimeKit.Cryptography.OpenPgpBlockFilter : MimeFilterBase {
    private Byte[] beginMarker;
    private Byte[] endMarker;
    private bool seenBeginMarker;
    private bool seenEndMarker;
    private bool midline;
    public OpenPgpBlockFilter(string beginMarker, string endMarker);
    private static bool IsMarker(Byte[] input, int startIndex, Byte[] marker);
    private static bool IsPartialMatch(Byte[] input, int startIndex, int endIndex, Byte[] marker);
    protected virtual Byte[] Filter(Byte[] input, int startIndex, int length, Int32& outputIndex, Int32& outputLength, bool flush);
    public virtual void Reset();
}
public abstract class MimeKit.Cryptography.OpenPgpContext : CryptographyContext {
    private static String[] ProtocolSubtypes;
    private static string BeginPublicKeyBlock;
    private static string EndPublicKeyBlock;
    private static int BufferLength;
    private static EncryptionAlgorithm[] DefaultEncryptionAlgorithmRank;
    private static DigestAlgorithm[] DefaultDigestAlgorithmRank;
    private EncryptionAlgorithm defaultAlgorithm;
    private HttpClient client;
    private Uri keyServer;
    [CompilerGeneratedAttribute]
private bool <AutoKeyRetrieve>k__BackingField;
    public EncryptionAlgorithm DefaultEncryptionAlgorithm { get; public set; }
    private bool IsValidKeyServer { get; }
    public Uri KeyServer { get; public set; }
    public bool AutoKeyRetrieve { get; public set; }
    public string SignatureProtocol { get; }
    public string EncryptionProtocol { get; }
    public string KeyExchangeProtocol { get; }
    private static OpenPgpContext();
    protected abstract virtual string GetPasswordForKey(PgpSecretKey key);
    protected abstract virtual PgpPublicKeyRing GetPublicKeyRing(long keyId, CancellationToken cancellationToken);
    protected abstract virtual Task`1<PgpPublicKeyRing> GetPublicKeyRingAsync(long keyId, CancellationToken cancellationToken);
    protected abstract virtual PgpSecretKey GetSecretKey(long keyId, CancellationToken cancellationToken);
    protected virtual Task`1<PgpSecretKey> GetSecretKeyAsync(long keyId, CancellationToken cancellationToken);
    public abstract virtual IList`1<PgpPublicKey> GetPublicKeys(IEnumerable`1<MailboxAddress> mailboxes, CancellationToken cancellationToken);
    public virtual Task`1<IList`1<PgpPublicKey>> GetPublicKeysAsync(IEnumerable`1<MailboxAddress> mailboxes, CancellationToken cancellationToken);
    public abstract virtual PgpSecretKey GetSigningKey(MailboxAddress mailbox, CancellationToken cancellationToken);
    public virtual Task`1<PgpSecretKey> GetSigningKeyAsync(MailboxAddress mailbox, CancellationToken cancellationToken);
    public EncryptionAlgorithm get_DefaultEncryptionAlgorithm();
    public void set_DefaultEncryptionAlgorithm(EncryptionAlgorithm value);
    private bool get_IsValidKeyServer();
    public Uri get_KeyServer();
    public void set_KeyServer(Uri value);
    [CompilerGeneratedAttribute]
public bool get_AutoKeyRetrieve();
    [CompilerGeneratedAttribute]
public void set_AutoKeyRetrieve(bool value);
    public virtual string get_SignatureProtocol();
    public virtual string get_EncryptionProtocol();
    public virtual string get_KeyExchangeProtocol();
    public virtual bool Supports(string protocol);
    public virtual string GetDigestAlgorithmName(DigestAlgorithm micalg);
    public virtual DigestAlgorithm GetDigestAlgorithm(string micalg);
    private static string HexEncode(Byte[] data);
    protected static bool IsMatch(PgpPublicKey key, MailboxAddress mailbox);
    protected static bool IsMatch(PgpSecretKey key, MailboxAddress mailbox);
    protected static bool IsExpired(PgpPublicKey key);
    [AsyncStateMachineAttribute("MimeKit.Cryptography.OpenPgpContext/<RetrievePublicKeyRingAsync>d__44")]
private Task`1<PgpPublicKeyRing> RetrievePublicKeyRingAsync(long keyId, bool doAsync, CancellationToken cancellationToken);
    protected PgpPublicKeyRing RetrievePublicKeyRing(long keyId, CancellationToken cancellationToken);
    protected Task`1<PgpPublicKeyRing> RetrievePublicKeyRingAsync(long keyId, CancellationToken cancellationToken);
    protected PgpPrivateKey GetPrivateKey(PgpSecretKey key);
    public static HashAlgorithmTag GetHashAlgorithm(DigestAlgorithm digestAlgo);
    public virtual MimePart Sign(MailboxAddress signer, DigestAlgorithm digestAlgo, Stream content, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MimeKit.Cryptography.OpenPgpContext/<SignAsync>d__50")]
public virtual Task`1<MimePart> SignAsync(MailboxAddress signer, DigestAlgorithm digestAlgo, Stream content, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MimeKit.Cryptography.OpenPgpContext/<SignAsync>d__51")]
private Task`1<ApplicationPgpSignature> SignAsync(PgpSecretKey signer, DigestAlgorithm digestAlgo, Stream content, bool doAsync, CancellationToken cancellationToken);
    public ApplicationPgpSignature Sign(PgpSecretKey signer, DigestAlgorithm digestAlgo, Stream content, CancellationToken cancellationToken);
    public Task`1<ApplicationPgpSignature> SignAsync(PgpSecretKey signer, DigestAlgorithm digestAlgo, Stream content, CancellationToken cancellationToken);
    public static DigestAlgorithm GetDigestAlgorithm(HashAlgorithmTag hashAlgorithm);
    public static PublicKeyAlgorithm GetPublicKeyAlgorithm(PublicKeyAlgorithmTag algorithm);
    private static bool TryGetPublicKey(PgpPublicKeyRing keyring, long keyId, PgpPublicKey& pubkey);
    [AsyncStateMachineAttribute("MimeKit.Cryptography.OpenPgpContext/<GetDigitalSignaturesAsync>d__57")]
private Task`1<DigitalSignatureCollection> GetDigitalSignaturesAsync(PgpSignatureList signatureList, Stream content, bool doAsync, CancellationToken cancellationToken);
    private Task`1<DigitalSignatureCollection> VerifyAsync(Stream content, Stream signatureData, bool doAsync, CancellationToken cancellationToken);
    public virtual DigitalSignatureCollection Verify(Stream content, Stream signatureData, CancellationToken cancellationToken);
    public virtual Task`1<DigitalSignatureCollection> VerifyAsync(Stream content, Stream signatureData, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MimeKit.Cryptography.OpenPgpContext/<CompressAsync>d__61")]
private static Task`1<Stream> CompressAsync(Stream content, Byte[] buf, int bufferLength, bool doAsync, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MimeKit.Cryptography.OpenPgpContext/<EncryptAsync>d__62")]
private static Task`1<Stream> EncryptAsync(PgpEncryptedDataGenerator encrypter, Stream content, bool doAsync, CancellationToken cancellationToken);
    internal static SymmetricKeyAlgorithmTag GetSymmetricKeyAlgorithm(EncryptionAlgorithm algorithm);
    public virtual MimePart Encrypt(IEnumerable`1<MailboxAddress> recipients, Stream content, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MimeKit.Cryptography.OpenPgpContext/<EncryptAsync>d__65")]
public virtual Task`1<MimePart> EncryptAsync(IEnumerable`1<MailboxAddress> recipients, Stream content, CancellationToken cancellationToken);
    public MimePart Encrypt(EncryptionAlgorithm algorithm, IEnumerable`1<MailboxAddress> recipients, Stream content, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MimeKit.Cryptography.OpenPgpContext/<EncryptAsync>d__67")]
public Task`1<MimePart> EncryptAsync(EncryptionAlgorithm algorithm, IEnumerable`1<MailboxAddress> recipients, Stream content, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MimeKit.Cryptography.OpenPgpContext/<EncryptAsync>d__68")]
private static Task`1<MimePart> EncryptAsync(EncryptionAlgorithm algorithm, IEnumerable`1<PgpPublicKey> recipients, Stream content, bool doAsync, CancellationToken cancellationToken);
    public MimePart Encrypt(EncryptionAlgorithm algorithm, IEnumerable`1<PgpPublicKey> recipients, Stream content, CancellationToken cancellationToken);
    public Task`1<MimePart> EncryptAsync(EncryptionAlgorithm algorithm, IEnumerable`1<PgpPublicKey> recipients, Stream content, CancellationToken cancellationToken);
    public MimePart Encrypt(IEnumerable`1<PgpPublicKey> recipients, Stream content, CancellationToken cancellationToken);
    public Task`1<MimePart> EncryptAsync(IEnumerable`1<PgpPublicKey> recipients, Stream content, CancellationToken cancellationToken);
    public MimePart SignAndEncrypt(MailboxAddress signer, DigestAlgorithm digestAlgo, IEnumerable`1<MailboxAddress> recipients, Stream content, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MimeKit.Cryptography.OpenPgpContext/<SignAndEncryptAsync>d__74")]
public Task`1<MimePart> SignAndEncryptAsync(MailboxAddress signer, DigestAlgorithm digestAlgo, IEnumerable`1<MailboxAddress> recipients, Stream content, CancellationToken cancellationToken);
    public MimePart SignAndEncrypt(MailboxAddress signer, DigestAlgorithm digestAlgo, EncryptionAlgorithm cipherAlgo, IEnumerable`1<MailboxAddress> recipients, Stream content, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MimeKit.Cryptography.OpenPgpContext/<SignAndEncryptAsync>d__76")]
public Task`1<MimePart> SignAndEncryptAsync(MailboxAddress signer, DigestAlgorithm digestAlgo, EncryptionAlgorithm cipherAlgo, IEnumerable`1<MailboxAddress> recipients, Stream content, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MimeKit.Cryptography.OpenPgpContext/<SignAndEncryptAsync>d__77")]
private Task`1<MimePart> SignAndEncryptAsync(PgpSecretKey signer, DigestAlgorithm digestAlgo, EncryptionAlgorithm cipherAlgo, IEnumerable`1<PgpPublicKey> recipients, Stream content, bool doAsync, CancellationToken cancellationToken);
    public MimePart SignAndEncrypt(PgpSecretKey signer, DigestAlgorithm digestAlgo, EncryptionAlgorithm cipherAlgo, IEnumerable`1<PgpPublicKey> recipients, Stream content, CancellationToken cancellationToken);
    public Task`1<MimePart> SignAndEncryptAsync(PgpSecretKey signer, DigestAlgorithm digestAlgo, EncryptionAlgorithm cipherAlgo, IEnumerable`1<PgpPublicKey> recipients, Stream content, CancellationToken cancellationToken);
    public MimePart SignAndEncrypt(PgpSecretKey signer, DigestAlgorithm digestAlgo, IEnumerable`1<PgpPublicKey> recipients, Stream content, CancellationToken cancellationToken);
    public Task`1<MimePart> SignAndEncryptAsync(PgpSecretKey signer, DigestAlgorithm digestAlgo, IEnumerable`1<PgpPublicKey> recipients, Stream content, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MimeKit.Cryptography.OpenPgpContext/<DecryptToAsync>d__82")]
private Task`1<DigitalSignatureCollection> DecryptToAsync(Stream encryptedData, Stream decryptedData, bool doAsync, CancellationToken cancellationToken);
    public DigitalSignatureCollection DecryptTo(Stream encryptedData, Stream decryptedData, CancellationToken cancellationToken);
    public Task`1<DigitalSignatureCollection> DecryptToAsync(Stream encryptedData, Stream decryptedData, CancellationToken cancellationToken);
    public MimeEntity Decrypt(Stream encryptedData, DigitalSignatureCollection& signatures, CancellationToken cancellationToken);
    public virtual MimeEntity Decrypt(Stream encryptedData, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MimeKit.Cryptography.OpenPgpContext/<DecryptAsync>d__87")]
public virtual Task`1<MimeEntity> DecryptAsync(Stream encryptedData, CancellationToken cancellationToken);
    public abstract virtual void Import(PgpPublicKeyRing keyring, CancellationToken cancellationToken);
    public abstract virtual void Import(PgpPublicKeyRingBundle bundle, CancellationToken cancellationToken);
    public abstract virtual void Import(PgpSecretKeyRing keyring, CancellationToken cancellationToken);
    public abstract virtual void Import(PgpSecretKeyRingBundle bundle, CancellationToken cancellationToken);
    public virtual void Import(Stream stream, CancellationToken cancellationToken);
    public virtual Task ImportAsync(Stream stream, CancellationToken cancellationToken);
    public MimePart Export(IEnumerable`1<PgpPublicKey> keys, CancellationToken cancellationToken);
    public Task`1<MimePart> ExportAsync(IEnumerable`1<PgpPublicKey> keys, CancellationToken cancellationToken);
    public MimePart Export(PgpPublicKeyRingBundle keys, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MimeKit.Cryptography.OpenPgpContext/<ExportAsync>d__97")]
public Task`1<MimePart> ExportAsync(PgpPublicKeyRingBundle keys, CancellationToken cancellationToken);
    public void Export(IEnumerable`1<PgpPublicKey> keys, Stream stream, bool armor, CancellationToken cancellationToken);
    public Task ExportAsync(IEnumerable`1<PgpPublicKey> keys, Stream stream, bool armor, CancellationToken cancellationToken);
    public void Export(PgpPublicKeyRingBundle keys, Stream stream, bool armor, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MimeKit.Cryptography.OpenPgpContext/<ExportAsync>d__101")]
public Task ExportAsync(PgpPublicKeyRingBundle keys, Stream stream, bool armor, CancellationToken cancellationToken);
    public abstract virtual void Export(IEnumerable`1<MailboxAddress> mailboxes, Stream stream, bool armor, CancellationToken cancellationToken);
    public abstract virtual Task ExportAsync(IEnumerable`1<MailboxAddress> mailboxes, Stream stream, bool armor, CancellationToken cancellationToken);
    protected virtual void Dispose(bool disposing);
}
public enum MimeKit.Cryptography.OpenPgpDataType : Enum {
    public int value__;
    public static OpenPgpDataType None;
    public static OpenPgpDataType SignedMessage;
    public static OpenPgpDataType EncryptedMessage;
    public static OpenPgpDataType PublicKey;
    public static OpenPgpDataType PrivateKey;
}
public class MimeKit.Cryptography.OpenPgpDetectionFilter : MimeFilterBase {
    private static OpenPgpMarker[] OpenPgpMarkers;
    private OpenPgpState state;
    private int position;
    private int next;
    private bool seenEndMarker;
    private bool midline;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <BeginOffset>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <EndOffset>k__BackingField;
    public Nullable`1<int> BeginOffset { get; private set; }
    public Nullable`1<int> EndOffset { get; private set; }
    public OpenPgpDataType DataType { get; }
    private static OpenPgpDetectionFilter();
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_BeginOffset();
    [CompilerGeneratedAttribute]
private void set_BeginOffset(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_EndOffset();
    [CompilerGeneratedAttribute]
private void set_EndOffset(Nullable`1<int> value);
    public OpenPgpDataType get_DataType();
    private static bool IsMarker(Byte[] input, int startIndex, int endIndex, Byte[] marker, Boolean& cr);
    private static bool IsPartialMatch(Byte[] input, int startIndex, int endIndex, Byte[] marker);
    private void SetPosition(int offset, int marker, bool cr);
    protected virtual Byte[] Filter(Byte[] input, int startIndex, int length, Int32& outputIndex, Int32& outputLength, bool flush);
    public virtual void Reset();
}
public class MimeKit.Cryptography.OpenPgpDigitalCertificate : object {
    [CompilerGeneratedAttribute]
private PgpPublicKeyRing <KeyRing>k__BackingField;
    [CompilerGeneratedAttribute]
private PgpPublicKey <PublicKey>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Fingerprint>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Email>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public PgpPublicKeyRing KeyRing { get; private set; }
    public PgpPublicKey PublicKey { get; private set; }
    public PublicKeyAlgorithm PublicKeyAlgorithm { get; }
    public DateTime CreationDate { get; }
    public DateTime ExpirationDate { get; }
    public string Fingerprint { get; private set; }
    public string Email { get; private set; }
    public string Name { get; private set; }
    internal OpenPgpDigitalCertificate(PgpPublicKeyRing keyring, PgpPublicKey pubkey);
    private bool UpdateUserId(PgpPublicKey pubkey);
    [CompilerGeneratedAttribute]
public PgpPublicKeyRing get_KeyRing();
    [CompilerGeneratedAttribute]
private void set_KeyRing(PgpPublicKeyRing value);
    [CompilerGeneratedAttribute]
public PgpPublicKey get_PublicKey();
    [CompilerGeneratedAttribute]
private void set_PublicKey(PgpPublicKey value);
    public sealed virtual PublicKeyAlgorithm get_PublicKeyAlgorithm();
    public sealed virtual DateTime get_CreationDate();
    public sealed virtual DateTime get_ExpirationDate();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Fingerprint();
    [CompilerGeneratedAttribute]
private void set_Fingerprint(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Email();
    [CompilerGeneratedAttribute]
private void set_Email(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
}
public class MimeKit.Cryptography.OpenPgpDigitalSignature : object {
    private DigitalSignatureVerifyException vex;
    private Nullable`1<bool> valid;
    [CompilerGeneratedAttribute]
private PgpOnePassSignature <OnePassSignature>k__BackingField;
    [CompilerGeneratedAttribute]
private PgpSignature <Signature>k__BackingField;
    [CompilerGeneratedAttribute]
private IDigitalCertificate <SignerCertificate>k__BackingField;
    [CompilerGeneratedAttribute]
private PublicKeyAlgorithm <PublicKeyAlgorithm>k__BackingField;
    [CompilerGeneratedAttribute]
private DigestAlgorithm <DigestAlgorithm>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <CreationDate>k__BackingField;
    internal PgpOnePassSignature OnePassSignature { get; private set; }
    internal PgpSignature Signature { get; internal set; }
    public IDigitalCertificate SignerCertificate { get; private set; }
    public PublicKeyAlgorithm PublicKeyAlgorithm { get; internal set; }
    public DigestAlgorithm DigestAlgorithm { get; internal set; }
    public DateTime CreationDate { get; internal set; }
    internal OpenPgpDigitalSignature(PgpPublicKeyRing keyring, PgpPublicKey pubkey, PgpOnePassSignature signature);
    internal OpenPgpDigitalSignature(PgpPublicKeyRing keyring, PgpPublicKey pubkey, PgpSignature signature);
    [CompilerGeneratedAttribute]
internal PgpOnePassSignature get_OnePassSignature();
    [CompilerGeneratedAttribute]
private void set_OnePassSignature(PgpOnePassSignature value);
    [CompilerGeneratedAttribute]
internal PgpSignature get_Signature();
    [CompilerGeneratedAttribute]
internal void set_Signature(PgpSignature value);
    [CompilerGeneratedAttribute]
public sealed virtual IDigitalCertificate get_SignerCertificate();
    [CompilerGeneratedAttribute]
private void set_SignerCertificate(IDigitalCertificate value);
    [CompilerGeneratedAttribute]
public sealed virtual PublicKeyAlgorithm get_PublicKeyAlgorithm();
    [CompilerGeneratedAttribute]
internal void set_PublicKeyAlgorithm(PublicKeyAlgorithm value);
    [CompilerGeneratedAttribute]
public sealed virtual DigestAlgorithm get_DigestAlgorithm();
    [CompilerGeneratedAttribute]
internal void set_DigestAlgorithm(DigestAlgorithm value);
    [CompilerGeneratedAttribute]
public sealed virtual DateTime get_CreationDate();
    [CompilerGeneratedAttribute]
internal void set_CreationDate(DateTime value);
    public sealed virtual bool Verify();
    public sealed virtual bool Verify(bool verifySignatureOnly);
}
public enum MimeKit.Cryptography.OpenPgpKeyCertification : Enum {
    public int value__;
    public static OpenPgpKeyCertification GenericCertification;
    public static OpenPgpKeyCertification PersonaCertification;
    public static OpenPgpKeyCertification CasualCertification;
    public static OpenPgpKeyCertification PositiveCertification;
}
public class MimeKit.Cryptography.PrivateKeyNotFoundException : Exception {
    [CompilerGeneratedAttribute]
private string <KeyId>k__BackingField;
    public string KeyId { get; private set; }
    public PrivateKeyNotFoundException(MailboxAddress mailbox, string message);
    public PrivateKeyNotFoundException(string keyid, string message);
    public PrivateKeyNotFoundException(long keyid, string message);
    [CompilerGeneratedAttribute]
public string get_KeyId();
    [CompilerGeneratedAttribute]
private void set_KeyId(string value);
}
public enum MimeKit.Cryptography.PublicKeyAlgorithm : Enum {
    public int value__;
    public static PublicKeyAlgorithm None;
    public static PublicKeyAlgorithm RsaGeneral;
    public static PublicKeyAlgorithm RsaEncrypt;
    public static PublicKeyAlgorithm RsaSign;
    public static PublicKeyAlgorithm ElGamalEncrypt;
    public static PublicKeyAlgorithm Dsa;
    public static PublicKeyAlgorithm EllipticCurve;
    public static PublicKeyAlgorithm EllipticCurveDsa;
    public static PublicKeyAlgorithm ElGamalGeneral;
    public static PublicKeyAlgorithm DiffieHellman;
    public static PublicKeyAlgorithm EdwardsCurveDsa;
}
public class MimeKit.Cryptography.PublicKeyNotFoundException : Exception {
    [CompilerGeneratedAttribute]
private MailboxAddress <Mailbox>k__BackingField;
    public MailboxAddress Mailbox { get; private set; }
    public PublicKeyNotFoundException(MailboxAddress mailbox, string message);
    [CompilerGeneratedAttribute]
public MailboxAddress get_Mailbox();
    [CompilerGeneratedAttribute]
private void set_Mailbox(MailboxAddress value);
}
public class MimeKit.Cryptography.RsaEncryptionPadding : object {
    public static RsaEncryptionPadding Pkcs1;
    public static RsaEncryptionPadding OaepSha1;
    public static RsaEncryptionPadding OaepSha256;
    public static RsaEncryptionPadding OaepSha384;
    public static RsaEncryptionPadding OaepSha512;
    [CompilerGeneratedAttribute]
private RsaEncryptionPaddingScheme <Scheme>k__BackingField;
    [CompilerGeneratedAttribute]
private DigestAlgorithm <OaepHashAlgorithm>k__BackingField;
    public RsaEncryptionPaddingScheme Scheme { get; private set; }
    public DigestAlgorithm OaepHashAlgorithm { get; private set; }
    private RsaEncryptionPadding(RsaEncryptionPaddingScheme scheme, DigestAlgorithm oaepHashAlgorithm);
    private static RsaEncryptionPadding();
    [CompilerGeneratedAttribute]
public RsaEncryptionPaddingScheme get_Scheme();
    [CompilerGeneratedAttribute]
private void set_Scheme(RsaEncryptionPaddingScheme value);
    [CompilerGeneratedAttribute]
public DigestAlgorithm get_OaepHashAlgorithm();
    [CompilerGeneratedAttribute]
private void set_OaepHashAlgorithm(DigestAlgorithm value);
    public sealed virtual bool Equals(RsaEncryptionPadding other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public static bool op_Equality(RsaEncryptionPadding left, RsaEncryptionPadding right);
    public static bool op_Inequality(RsaEncryptionPadding left, RsaEncryptionPadding right);
    public static RsaEncryptionPadding CreateOaep(DigestAlgorithm hashAlgorithm);
    internal RsaesOaepParameters GetRsaesOaepParameters();
    internal AlgorithmIdentifier GetAlgorithmIdentifier();
}
public enum MimeKit.Cryptography.RsaEncryptionPaddingScheme : Enum {
    public int value__;
    public static RsaEncryptionPaddingScheme Pkcs1;
    public static RsaEncryptionPaddingScheme Oaep;
}
public class MimeKit.Cryptography.RsaSignaturePadding : object {
    public static RsaSignaturePadding Pkcs1;
    public static RsaSignaturePadding Pss;
    [CompilerGeneratedAttribute]
private RsaSignaturePaddingScheme <Scheme>k__BackingField;
    public RsaSignaturePaddingScheme Scheme { get; private set; }
    private RsaSignaturePadding(RsaSignaturePaddingScheme scheme);
    private static RsaSignaturePadding();
    [CompilerGeneratedAttribute]
public RsaSignaturePaddingScheme get_Scheme();
    [CompilerGeneratedAttribute]
private void set_Scheme(RsaSignaturePaddingScheme value);
    public sealed virtual bool Equals(RsaSignaturePadding other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public static bool op_Equality(RsaSignaturePadding left, RsaSignaturePadding right);
    public static bool op_Inequality(RsaSignaturePadding left, RsaSignaturePadding right);
}
public enum MimeKit.Cryptography.RsaSignaturePaddingScheme : Enum {
    public int value__;
    public static RsaSignaturePaddingScheme Pkcs1;
    public static RsaSignaturePaddingScheme Pss;
}
public class MimeKit.Cryptography.SecureMailboxAddress : MailboxAddress {
    [CompilerGeneratedAttribute]
private string <Fingerprint>k__BackingField;
    public string Fingerprint { get; private set; }
    public SecureMailboxAddress(Encoding encoding, string name, IEnumerable`1<string> route, string address, string fingerprint);
    public SecureMailboxAddress(string name, IEnumerable`1<string> route, string address, string fingerprint);
    public SecureMailboxAddress(Encoding encoding, string name, string address, string fingerprint);
    public SecureMailboxAddress(string name, string address, string fingerprint);
    private static void ValidateFingerprint(string fingerprint);
    [CompilerGeneratedAttribute]
public string get_Fingerprint();
    [CompilerGeneratedAttribute]
private void set_Fingerprint(string value);
}
public abstract class MimeKit.Cryptography.SecureMimeContext : CryptographyContext {
    private static String[] ProtocolSubtypes;
    internal static X509KeyUsageFlags DigitalSignatureKeyUsageFlags;
    internal static int EncryptionAlgorithmCount;
    internal static DerObjectIdentifier Blowfish;
    internal static DerObjectIdentifier Twofish;
    public string SignatureProtocol { get; }
    public string EncryptionProtocol { get; }
    public string KeyExchangeProtocol { get; }
    private static SecureMimeContext();
    public virtual string get_SignatureProtocol();
    public virtual string get_EncryptionProtocol();
    public virtual string get_KeyExchangeProtocol();
    public virtual bool Supports(string protocol);
    public virtual string GetDigestAlgorithmName(DigestAlgorithm micalg);
    public virtual DigestAlgorithm GetDigestAlgorithm(string micalg);
    protected internal static string GetDigestOid(DigestAlgorithm digestAlgo);
    internal static bool TryGetDigestAlgorithm(string id, DigestAlgorithm& algorithm);
    protected virtual EncryptionAlgorithm GetPreferredEncryptionAlgorithm(CmsRecipientCollection recipients);
    public virtual ApplicationPkcs7Mime Compress(Stream stream, CancellationToken cancellationToken);
    public virtual Task`1<ApplicationPkcs7Mime> CompressAsync(Stream stream, CancellationToken cancellationToken);
    public virtual MimeEntity Decompress(Stream stream, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MimeKit.Cryptography.SecureMimeContext/<DecompressAsync>d__21")]
public virtual Task`1<MimeEntity> DecompressAsync(Stream stream, CancellationToken cancellationToken);
    public virtual void DecompressTo(Stream stream, Stream output, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MimeKit.Cryptography.SecureMimeContext/<DecompressToAsync>d__23")]
public virtual Task DecompressToAsync(Stream stream, Stream output, CancellationToken cancellationToken);
    internal SmimeCapabilitiesAttribute GetSecureMimeCapabilitiesAttribute(bool includeRsaesOaep);
    public abstract virtual ApplicationPkcs7Mime EncapsulatedSign(CmsSigner signer, Stream content, CancellationToken cancellationToken);
    public abstract virtual Task`1<ApplicationPkcs7Mime> EncapsulatedSignAsync(CmsSigner signer, Stream content, CancellationToken cancellationToken);
    public abstract virtual ApplicationPkcs7Mime EncapsulatedSign(MailboxAddress signer, DigestAlgorithm digestAlgo, Stream content, CancellationToken cancellationToken);
    public abstract virtual Task`1<ApplicationPkcs7Mime> EncapsulatedSignAsync(MailboxAddress signer, DigestAlgorithm digestAlgo, Stream content, CancellationToken cancellationToken);
    public abstract virtual ApplicationPkcs7Signature Sign(CmsSigner signer, Stream content, CancellationToken cancellationToken);
    public abstract virtual Task`1<ApplicationPkcs7Signature> SignAsync(CmsSigner signer, Stream content, CancellationToken cancellationToken);
    public abstract virtual DigitalSignatureCollection Verify(Stream signedData, MimeEntity& entity, CancellationToken cancellationToken);
    public abstract virtual Stream Verify(Stream signedData, DigitalSignatureCollection& signatures, CancellationToken cancellationToken);
    public abstract virtual ApplicationPkcs7Mime Encrypt(CmsRecipientCollection recipients, Stream content, CancellationToken cancellationToken);
    public abstract virtual Task`1<ApplicationPkcs7Mime> EncryptAsync(CmsRecipientCollection recipients, Stream content, CancellationToken cancellationToken);
    public abstract virtual void DecryptTo(Stream encryptedData, Stream decryptedData, CancellationToken cancellationToken);
    public abstract virtual Task DecryptToAsync(Stream encryptedData, Stream decryptedData, CancellationToken cancellationToken);
    public abstract virtual void Import(Stream stream, string password, CancellationToken cancellationToken);
    public abstract virtual Task ImportAsync(Stream stream, string password, CancellationToken cancellationToken);
    public virtual void Import(string fileName, string password, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MimeKit.Cryptography.SecureMimeContext/<ImportAsync>d__40")]
public virtual Task ImportAsync(string fileName, string password, CancellationToken cancellationToken);
    public abstract virtual void Import(X509Certificate certificate, CancellationToken cancellationToken);
    public virtual Task ImportAsync(X509Certificate certificate, CancellationToken cancellationToken);
    public virtual void Import(X509Certificate2 certificate, CancellationToken cancellationToken);
    public virtual Task ImportAsync(X509Certificate2 certificate, CancellationToken cancellationToken);
    public abstract virtual void Import(X509Crl crl, CancellationToken cancellationToken);
    public virtual Task ImportAsync(X509Crl crl, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MimeKit.Cryptography.SecureMimeContext/<ImportAsync>d__47")]
private Task ImportAsync(Stream stream, bool doAsync, CancellationToken cancellationToken);
    public virtual void Import(Stream stream, CancellationToken cancellationToken);
    public virtual Task ImportAsync(Stream stream, CancellationToken cancellationToken);
}
public class MimeKit.Cryptography.SecureMimeDigitalCertificate : object {
    [CompilerGeneratedAttribute]
private X509Certificate <Certificate>k__BackingField;
    [CompilerGeneratedAttribute]
private PublicKeyAlgorithm <PublicKeyAlgorithm>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Fingerprint>k__BackingField;
    public X509Certificate Certificate { get; private set; }
    public PublicKeyAlgorithm PublicKeyAlgorithm { get; private set; }
    public DateTime CreationDate { get; }
    public DateTime ExpirationDate { get; }
    public string Fingerprint { get; private set; }
    public string Email { get; }
    public string Name { get; }
    public SecureMimeDigitalCertificate(X509Certificate certificate);
    [CompilerGeneratedAttribute]
public X509Certificate get_Certificate();
    [CompilerGeneratedAttribute]
private void set_Certificate(X509Certificate value);
    [CompilerGeneratedAttribute]
public sealed virtual PublicKeyAlgorithm get_PublicKeyAlgorithm();
    [CompilerGeneratedAttribute]
private void set_PublicKeyAlgorithm(PublicKeyAlgorithm value);
    public sealed virtual DateTime get_CreationDate();
    public sealed virtual DateTime get_ExpirationDate();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Fingerprint();
    [CompilerGeneratedAttribute]
private void set_Fingerprint(string value);
    public sealed virtual string get_Email();
    public sealed virtual string get_Name();
}
public class MimeKit.Cryptography.SecureMimeDigitalSignature : object {
    private DigitalSignatureVerifyException vex;
    private Nullable`1<bool> valid;
    [CompilerGeneratedAttribute]
private SignerInformation <SignerInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private EncryptionAlgorithm[] <EncryptionAlgorithms>k__BackingField;
    [CompilerGeneratedAttribute]
private PkixCertPath <Chain>k__BackingField;
    [CompilerGeneratedAttribute]
private Exception <ChainException>k__BackingField;
    [CompilerGeneratedAttribute]
private IDigitalCertificate <SignerCertificate>k__BackingField;
    [CompilerGeneratedAttribute]
private DigestAlgorithm <DigestAlgorithm>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <CreationDate>k__BackingField;
    public SignerInformation SignerInfo { get; private set; }
    public EncryptionAlgorithm[] EncryptionAlgorithms { get; private set; }
    public PkixCertPath Chain { get; internal set; }
    public Exception ChainException { get; internal set; }
    public IDigitalCertificate SignerCertificate { get; private set; }
    public PublicKeyAlgorithm PublicKeyAlgorithm { get; }
    public DigestAlgorithm DigestAlgorithm { get; private set; }
    public DateTime CreationDate { get; private set; }
    public SecureMimeDigitalSignature(SignerInformation signerInfo, X509Certificate certificate);
    [CompilerGeneratedAttribute]
public SignerInformation get_SignerInfo();
    [CompilerGeneratedAttribute]
private void set_SignerInfo(SignerInformation value);
    [CompilerGeneratedAttribute]
public EncryptionAlgorithm[] get_EncryptionAlgorithms();
    [CompilerGeneratedAttribute]
private void set_EncryptionAlgorithms(EncryptionAlgorithm[] value);
    [CompilerGeneratedAttribute]
public PkixCertPath get_Chain();
    [CompilerGeneratedAttribute]
internal void set_Chain(PkixCertPath value);
    [CompilerGeneratedAttribute]
public Exception get_ChainException();
    [CompilerGeneratedAttribute]
internal void set_ChainException(Exception value);
    [CompilerGeneratedAttribute]
public sealed virtual IDigitalCertificate get_SignerCertificate();
    [CompilerGeneratedAttribute]
private void set_SignerCertificate(IDigitalCertificate value);
    public sealed virtual PublicKeyAlgorithm get_PublicKeyAlgorithm();
    [CompilerGeneratedAttribute]
public sealed virtual DigestAlgorithm get_DigestAlgorithm();
    [CompilerGeneratedAttribute]
private void set_DigestAlgorithm(DigestAlgorithm value);
    [CompilerGeneratedAttribute]
public sealed virtual DateTime get_CreationDate();
    [CompilerGeneratedAttribute]
private void set_CreationDate(DateTime value);
    public sealed virtual bool Verify();
    public sealed virtual bool Verify(bool verifySignatureOnly);
}
public enum MimeKit.Cryptography.SecureMimeType : Enum {
    public int value__;
    public static SecureMimeType Unknown;
    public static SecureMimeType CompressedData;
    public static SecureMimeType EnvelopedData;
    public static SecureMimeType SignedData;
    public static SecureMimeType CertsOnly;
    public static SecureMimeType AuthEnvelopedData;
}
public abstract class MimeKit.Cryptography.SqlCertificateDatabase : X509CertificateDatabase {
    private bool disposed;
    [CompilerGeneratedAttribute]
private DataTable <CertificatesTable>k__BackingField;
    [CompilerGeneratedAttribute]
private DataTable <CrlsTable>k__BackingField;
    protected DataTable CertificatesTable { get; private set; }
    protected DataTable CrlsTable { get; private set; }
    protected SqlCertificateDatabase(DbConnection connection, string password);
    protected SqlCertificateDatabase(DbConnection connection, string password, SecureRandom random);
    [CompilerGeneratedAttribute]
protected DataTable get_CertificatesTable();
    [CompilerGeneratedAttribute]
private void set_CertificatesTable(DataTable value);
    [CompilerGeneratedAttribute]
protected DataTable get_CrlsTable();
    [CompilerGeneratedAttribute]
private void set_CrlsTable(DataTable value);
    private static DataTable CreateCertificatesDataTable(string tableName);
    private static DataTable CreateCrlsDataTable(string tableName);
    protected abstract virtual IList`1<DataColumn> GetTableColumns(DbConnection connection, string tableName);
    protected abstract virtual void CreateTable(DbConnection connection, DataTable table);
    protected abstract virtual void AddTableColumn(DbConnection connection, DataTable table, DataColumn column);
    protected static string GetIndexName(string tableName, String[] columnNames);
    protected virtual void CreateIndex(DbConnection connection, string tableName, String[] columnNames);
    protected virtual void RemoveIndex(DbConnection connection, string tableName, String[] columnNames);
    private void CreateCertificatesTable(DbConnection connection, DataTable table);
    private void CreateCrlsTable(DbConnection connection, DataTable table);
    protected static StringBuilder CreateSelectQuery(X509CertificateRecordFields fields);
    protected virtual DbCommand GetSelectCommand(DbConnection connection, X509Certificate certificate, X509CertificateRecordFields fields);
    protected virtual DbCommand GetSelectCommand(DbConnection connection, MailboxAddress mailbox, DateTime now, bool requirePrivateKey, X509CertificateRecordFields fields);
    protected virtual DbCommand GetSelectCommand(DbConnection connection, ISelector`1<X509Certificate> selector, bool trustedAnchorsOnly, bool requirePrivateKey, X509CertificateRecordFields fields);
    protected virtual DbCommand GetSelectCommand(DbConnection connection, X509Name issuer, X509CrlRecordFields fields);
    protected virtual DbCommand GetSelectCommand(DbConnection connection, X509Crl crl, X509CrlRecordFields fields);
    protected virtual DbCommand GetSelectAllCrlsCommand(DbConnection connection);
    protected virtual DbCommand GetDeleteCommand(DbConnection connection, X509CertificateRecord record);
    protected virtual DbCommand GetDeleteCommand(DbConnection connection, X509CrlRecord record);
    protected virtual DbCommand GetInsertCommand(DbConnection connection, X509CertificateRecord record);
    protected virtual DbCommand GetInsertCommand(DbConnection connection, X509CrlRecord record);
    protected virtual DbCommand GetUpdateCommand(DbConnection connection, X509CertificateRecord record, X509CertificateRecordFields fields);
    protected virtual DbCommand GetUpdateCommand(DbConnection connection, X509CrlRecord record);
    protected virtual void Dispose(bool disposing);
}
public class MimeKit.Cryptography.SqliteCertificateDatabase : SqlCertificateDatabase {
    private static SQLiteAssembly sqliteAssembly;
    [CompilerGeneratedAttribute]
private static bool <IsAvailable>k__BackingField;
    internal static bool IsAvailable { get; private set; }
    private static SqliteCertificateDatabase();
    public SqliteCertificateDatabase(string fileName, string password);
    public SqliteCertificateDatabase(string fileName, string password, SecureRandom random);
    public SqliteCertificateDatabase(DbConnection connection, string password);
    public SqliteCertificateDatabase(DbConnection connection, string password, SecureRandom random);
    private static bool VerifySQLiteAssemblyIsUsable();
    [CompilerGeneratedAttribute]
internal static bool get_IsAvailable();
    [CompilerGeneratedAttribute]
private static void set_IsAvailable(bool value);
    internal static DbConnection CreateConnection(string fileName);
    protected virtual IList`1<DataColumn> GetTableColumns(DbConnection connection, string tableName);
    private static void Build(StringBuilder statement, DataTable table, DataColumn column, Int32& primaryKeys, bool create);
    protected virtual void CreateTable(DbConnection connection, DataTable table);
    protected virtual void AddTableColumn(DbConnection connection, DataTable table, DataColumn column);
}
public class MimeKit.Cryptography.SQLServerCertificateDatabase : SqlCertificateDatabase {
    public SQLServerCertificateDatabase(DbConnection connection, string password);
    public SQLServerCertificateDatabase(DbConnection connection, string password, SecureRandom random);
    protected virtual void AddTableColumn(DbConnection connection, DataTable table, DataColumn column);
    protected virtual void CreateTable(DbConnection connection, DataTable table);
    private static void Build(StringBuilder statement, DataTable table, DataColumn column, Int32& primaryKeys);
    protected virtual IList`1<DataColumn> GetTableColumns(DbConnection connection, string tableName);
    protected virtual void CreateIndex(DbConnection connection, string tableName, String[] columnNames);
    protected virtual void RemoveIndex(DbConnection connection, string tableName, String[] columnNames);
    protected virtual DbCommand GetSelectCommand(DbConnection connection, X509Certificate certificate, X509CertificateRecordFields fields);
    protected virtual DbCommand GetInsertCommand(DbConnection connection, X509CertificateRecord record);
}
public enum MimeKit.Cryptography.SubjectIdentifierType : Enum {
    public int value__;
    public static SubjectIdentifierType Unknown;
    public static SubjectIdentifierType IssuerAndSerialNumber;
    public static SubjectIdentifierType SubjectKeyIdentifier;
}
public class MimeKit.Cryptography.TemporarySecureMimeContext : BouncyCastleSecureMimeContext {
    private Dictionary`2<string, EncryptionAlgorithm[]> capabilities;
    internal Dictionary`2<string, AsymmetricKeyParameter> keys;
    internal List`1<X509Certificate> certificates;
    private HashSet`1<string> fingerprints;
    private List`1<X509Crl> crls;
    public TemporarySecureMimeContext(SecureRandom random);
    public virtual bool CanSign(MailboxAddress signer, CancellationToken cancellationToken);
    public virtual bool CanEncrypt(MailboxAddress mailbox, CancellationToken cancellationToken);
    protected virtual X509Certificate GetCertificate(ISelector`1<X509Certificate> selector);
    protected virtual AsymmetricKeyParameter GetPrivateKey(ISelector`1<X509Certificate> selector);
    protected virtual ISet`1<TrustAnchor> GetTrustedAnchors();
    protected virtual IStore`1<X509Certificate> GetIntermediateCertificates();
    protected virtual IStore`1<X509Crl> GetCertificateRevocationLists();
    protected virtual DateTime GetNextCertificateRevocationListUpdate(X509Name issuer);
    private X509Certificate GetCmsRecipientCertificate(MailboxAddress mailbox);
    protected virtual CmsRecipient GetCmsRecipient(MailboxAddress mailbox);
    private X509Certificate GetCmsSignerCertificate(MailboxAddress mailbox, AsymmetricKeyParameter& key);
    protected virtual CmsSigner GetCmsSigner(MailboxAddress mailbox, DigestAlgorithm digestAlgo);
    protected virtual void UpdateSecureMimeCapabilities(X509Certificate certificate, EncryptionAlgorithm[] algorithms, DateTime timestamp);
    public virtual void Import(Stream stream, string password, CancellationToken cancellationToken);
    public virtual Task ImportAsync(Stream stream, string password, CancellationToken cancellationToken);
    public virtual void Import(X509Certificate2 certificate, CancellationToken cancellationToken);
    public virtual void Import(X509Certificate certificate, CancellationToken cancellationToken);
    public virtual void Import(X509Crl crl, CancellationToken cancellationToken);
}
public class MimeKit.Cryptography.WindowsSecureMimeContext : SecureMimeContext {
    private static X509KeyStorageFlags DefaultKeyStorageFlags;
    [CompilerGeneratedAttribute]
private StoreLocation <StoreLocation>k__BackingField;
    public StoreLocation StoreLocation { get; private set; }
    public WindowsSecureMimeContext(StoreLocation location);
    [CompilerGeneratedAttribute]
public StoreLocation get_StoreLocation();
    [CompilerGeneratedAttribute]
private void set_StoreLocation(StoreLocation value);
    public virtual bool CanSign(MailboxAddress signer, CancellationToken cancellationToken);
    public virtual bool CanEncrypt(MailboxAddress mailbox, CancellationToken cancellationToken);
    protected virtual X509Certificate2 GetRecipientCertificate(MailboxAddress mailbox);
    protected virtual CmsRecipient GetCmsRecipient(MailboxAddress mailbox);
    private CmsRecipientCollection GetCmsRecipients(IEnumerable`1<MailboxAddress> mailboxes);
    private static CmsRecipientCollection GetCmsRecipients(CmsRecipientCollection recipients);
    protected virtual X509Certificate2 GetSignerCertificate(MailboxAddress mailbox);
    private AsnEncodedData GetSecureMimeCapabilities();
    private CmsSigner GetRealCmsSigner(SubjectIdentifierType type, X509Certificate2 certificate, DigestAlgorithm digestAlgo);
    private CmsSigner GetRealCmsSigner(CmsSigner signer);
    protected virtual CmsSigner GetCmsSigner(MailboxAddress mailbox, DigestAlgorithm digestAlgo);
    protected virtual void UpdateSecureMimeCapabilities(X509Certificate2 certificate, EncryptionAlgorithm[] algorithms, DateTime timestamp);
    private static Byte[] ReadAllBytes(Stream stream);
    [AsyncStateMachineAttribute("MimeKit.Cryptography.WindowsSecureMimeContext/<ReadAllBytesAsync>d__20")]
private static Task`1<Byte[]> ReadAllBytesAsync(Stream stream, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MimeKit.Cryptography.WindowsSecureMimeContext/<SignAsync>d__21")]
private static Task`1<Stream> SignAsync(CmsSigner signer, Stream content, bool detach, bool doAsync, CancellationToken cancellationToken);
    public virtual ApplicationPkcs7Mime EncapsulatedSign(CmsSigner signer, Stream content, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MimeKit.Cryptography.WindowsSecureMimeContext/<EncapsulatedSignAsync>d__23")]
public virtual Task`1<ApplicationPkcs7Mime> EncapsulatedSignAsync(CmsSigner signer, Stream content, CancellationToken cancellationToken);
    public virtual ApplicationPkcs7Mime EncapsulatedSign(MailboxAddress signer, DigestAlgorithm digestAlgo, Stream content, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MimeKit.Cryptography.WindowsSecureMimeContext/<EncapsulatedSignAsync>d__25")]
public virtual Task`1<ApplicationPkcs7Mime> EncapsulatedSignAsync(MailboxAddress signer, DigestAlgorithm digestAlgo, Stream content, CancellationToken cancellationToken);
    public virtual ApplicationPkcs7Signature Sign(CmsSigner signer, Stream content, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MimeKit.Cryptography.WindowsSecureMimeContext/<SignAsync>d__27")]
public virtual Task`1<ApplicationPkcs7Signature> SignAsync(CmsSigner signer, Stream content, CancellationToken cancellationToken);
    public virtual MimePart Sign(MailboxAddress signer, DigestAlgorithm digestAlgo, Stream content, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MimeKit.Cryptography.WindowsSecureMimeContext/<SignAsync>d__29")]
public virtual Task`1<MimePart> SignAsync(MailboxAddress signer, DigestAlgorithm digestAlgo, Stream content, CancellationToken cancellationToken);
    protected internal static bool TryGetDigestAlgorithm(Oid identifier, DigestAlgorithm& algorithm);
    private DigitalSignatureCollection GetDigitalSignatures(SignedCms signed);
    public virtual DigitalSignatureCollection Verify(Stream content, Stream signatureData, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MimeKit.Cryptography.WindowsSecureMimeContext/<VerifyAsync>d__33")]
public virtual Task`1<DigitalSignatureCollection> VerifyAsync(Stream content, Stream signatureData, CancellationToken cancellationToken);
    public virtual DigitalSignatureCollection Verify(Stream signedData, MimeEntity& entity, CancellationToken cancellationToken);
    public virtual Stream Verify(Stream signedData, DigitalSignatureCollection& signatures, CancellationToken cancellationToken);
    protected virtual EncryptionAlgorithm GetPreferredEncryptionAlgorithm(CmsRecipientCollection recipients);
    internal AlgorithmIdentifier GetAlgorithmIdentifier(EncryptionAlgorithm algorithm);
    [AsyncStateMachineAttribute("MimeKit.Cryptography.WindowsSecureMimeContext/<EnvelopeAsync>d__38")]
private Task`1<Stream> EnvelopeAsync(CmsRecipientCollection recipients, Stream content, EncryptionAlgorithm encryptionAlgorithm, bool doAsync, CancellationToken cancellationToken);
    private Task`1<Stream> EnvelopeAsync(CmsRecipientCollection recipients, Stream content, bool doAsync, CancellationToken cancellationToken);
    private Task`1<Stream> EnvelopeAsync(CmsRecipientCollection recipients, Stream content, bool doAsync, CancellationToken cancellationToken);
    public virtual ApplicationPkcs7Mime Encrypt(CmsRecipientCollection recipients, Stream content, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MimeKit.Cryptography.WindowsSecureMimeContext/<EncryptAsync>d__42")]
public virtual Task`1<ApplicationPkcs7Mime> EncryptAsync(CmsRecipientCollection recipients, Stream content, CancellationToken cancellationToken);
    public virtual MimePart Encrypt(IEnumerable`1<MailboxAddress> recipients, Stream content, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MimeKit.Cryptography.WindowsSecureMimeContext/<EncryptAsync>d__44")]
public virtual Task`1<MimePart> EncryptAsync(IEnumerable`1<MailboxAddress> recipients, Stream content, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MimeKit.Cryptography.WindowsSecureMimeContext/<DecryptAsync>d__45")]
private static Task`1<MimeEntity> DecryptAsync(Stream encryptedData, bool doAsync, CancellationToken cancellationToken);
    public virtual MimeEntity Decrypt(Stream encryptedData, CancellationToken cancellationToken);
    public virtual Task`1<MimeEntity> DecryptAsync(Stream encryptedData, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MimeKit.Cryptography.WindowsSecureMimeContext/<DecryptToAsync>d__48")]
private static Task DecryptToAsync(Stream encryptedData, Stream decryptedData, bool doAsync, CancellationToken cancellationToken);
    public virtual void DecryptTo(Stream encryptedData, Stream decryptedData, CancellationToken cancellationToken);
    public virtual Task DecryptToAsync(Stream encryptedData, Stream decryptedData, CancellationToken cancellationToken);
    public void Import(StoreName storeName, X509Certificate2 certificate, CancellationToken cancellationToken);
    public virtual void Import(X509Certificate2 certificate, CancellationToken cancellationToken);
    public void Import(StoreName storeName, X509Certificate certificate, CancellationToken cancellationToken);
    public virtual void Import(X509Certificate certificate, CancellationToken cancellationToken);
    private static string GetSerialNumber(X509CrlEntry crlEntry);
    private static X500DistinguishedName GetIssuerName(X509CrlEntry crlEntry);
    public virtual void Import(X509Crl crl, CancellationToken cancellationToken);
    public void Import(Stream stream, string password, X509KeyStorageFlags flags, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MimeKit.Cryptography.WindowsSecureMimeContext/<ImportAsync>d__59")]
public Task ImportAsync(Stream stream, string password, X509KeyStorageFlags flags, CancellationToken cancellationToken);
    public virtual void Import(Stream stream, string password, CancellationToken cancellationToken);
    public virtual Task ImportAsync(Stream stream, string password, CancellationToken cancellationToken);
    public virtual MimePart Export(IEnumerable`1<MailboxAddress> mailboxes, CancellationToken cancellationToken);
    public virtual Task`1<MimePart> ExportAsync(IEnumerable`1<MailboxAddress> mailboxes, CancellationToken cancellationToken);
}
public class MimeKit.Cryptography.WindowsSecureMimeDigitalCertificate : object {
    [CompilerGeneratedAttribute]
private X509Certificate2 <Certificate>k__BackingField;
    [CompilerGeneratedAttribute]
private PublicKeyAlgorithm <PublicKeyAlgorithm>k__BackingField;
    public X509Certificate2 Certificate { get; private set; }
    public PublicKeyAlgorithm PublicKeyAlgorithm { get; private set; }
    public DateTime CreationDate { get; }
    public DateTime ExpirationDate { get; }
    public string Fingerprint { get; }
    public string Email { get; }
    public string Name { get; }
    public WindowsSecureMimeDigitalCertificate(X509Certificate2 certificate);
    [CompilerGeneratedAttribute]
public X509Certificate2 get_Certificate();
    [CompilerGeneratedAttribute]
private void set_Certificate(X509Certificate2 value);
    [CompilerGeneratedAttribute]
public sealed virtual PublicKeyAlgorithm get_PublicKeyAlgorithm();
    [CompilerGeneratedAttribute]
private void set_PublicKeyAlgorithm(PublicKeyAlgorithm value);
    public sealed virtual DateTime get_CreationDate();
    public sealed virtual DateTime get_ExpirationDate();
    public sealed virtual string get_Fingerprint();
    public sealed virtual string get_Email();
    public sealed virtual string get_Name();
}
public class MimeKit.Cryptography.WindowsSecureMimeDigitalSignature : object {
    private DigitalSignatureVerifyException vex;
    [CompilerGeneratedAttribute]
private SignerInfo <SignerInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private EncryptionAlgorithm[] <EncryptionAlgorithms>k__BackingField;
    [CompilerGeneratedAttribute]
private IDigitalCertificate <SignerCertificate>k__BackingField;
    [CompilerGeneratedAttribute]
private DigestAlgorithm <DigestAlgorithm>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <CreationDate>k__BackingField;
    public SignerInfo SignerInfo { get; private set; }
    public EncryptionAlgorithm[] EncryptionAlgorithms { get; private set; }
    public IDigitalCertificate SignerCertificate { get; private set; }
    public PublicKeyAlgorithm PublicKeyAlgorithm { get; }
    public DigestAlgorithm DigestAlgorithm { get; private set; }
    public DateTime CreationDate { get; private set; }
    public WindowsSecureMimeDigitalSignature(SignerInfo signerInfo);
    [CompilerGeneratedAttribute]
public SignerInfo get_SignerInfo();
    [CompilerGeneratedAttribute]
private void set_SignerInfo(SignerInfo value);
    [CompilerGeneratedAttribute]
public EncryptionAlgorithm[] get_EncryptionAlgorithms();
    [CompilerGeneratedAttribute]
private void set_EncryptionAlgorithms(EncryptionAlgorithm[] value);
    [CompilerGeneratedAttribute]
public sealed virtual IDigitalCertificate get_SignerCertificate();
    [CompilerGeneratedAttribute]
private void set_SignerCertificate(IDigitalCertificate value);
    public sealed virtual PublicKeyAlgorithm get_PublicKeyAlgorithm();
    [CompilerGeneratedAttribute]
public sealed virtual DigestAlgorithm get_DigestAlgorithm();
    [CompilerGeneratedAttribute]
private void set_DigestAlgorithm(DigestAlgorithm value);
    [CompilerGeneratedAttribute]
public sealed virtual DateTime get_CreationDate();
    [CompilerGeneratedAttribute]
private void set_CreationDate(DateTime value);
    public sealed virtual bool Verify();
    public sealed virtual bool Verify(bool verifySignatureOnly);
}
[ExtensionAttribute]
public static class MimeKit.Cryptography.X509Certificate2Extensions : object {
    [ExtensionAttribute]
public static X509Certificate AsBouncyCastleCertificate(X509Certificate2 certificate);
    [ExtensionAttribute]
public static PublicKeyAlgorithm GetPublicKeyAlgorithm(X509Certificate2 certificate);
    private static EncryptionAlgorithm[] DecodeEncryptionAlgorithms(Byte[] rawData);
    [ExtensionAttribute]
public static EncryptionAlgorithm[] GetEncryptionAlgorithms(X509Certificate2 certificate);
    [ExtensionAttribute]
public static AsymmetricKeyParameter GetPrivateKeyAsAsymmetricKeyParameter(X509Certificate2 certificate);
}
[DefaultMemberAttribute("Item")]
public class MimeKit.Cryptography.X509CertificateChain : object {
    private List`1<X509Certificate> certificates;
    public X509Certificate Item { get; public set; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public X509CertificateChain(IEnumerable`1<X509Certificate> collection);
    public sealed virtual int IndexOf(X509Certificate certificate);
    public sealed virtual void Insert(int index, X509Certificate certificate);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual X509Certificate get_Item(int index);
    public sealed virtual void set_Item(int index, X509Certificate value);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual void Add(X509Certificate certificate);
    public void AddRange(IEnumerable`1<X509Certificate> certificates);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(X509Certificate certificate);
    public sealed virtual void CopyTo(X509Certificate[] array, int arrayIndex);
    public sealed virtual bool Remove(X509Certificate certificate);
    public void RemoveRange(IEnumerable`1<X509Certificate> certificates);
    public sealed virtual IEnumerator`1<X509Certificate> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [IteratorStateMachineAttribute("MimeKit.Cryptography.X509CertificateChain/<GetMatches>d__22")]
public IEnumerable`1<X509Certificate> GetMatches(ISelector`1<X509Certificate> selector);
    private sealed virtual override IEnumerable`1<X509Certificate> Org.BouncyCastle.Utilities.Collections.IStore<Org.BouncyCastle.X509.X509Certificate>.EnumerateMatches(ISelector`1<X509Certificate> selector);
}
public abstract class MimeKit.Cryptography.X509CertificateDatabase : object {
    private static X509CertificateRecordFields PrivateKeyFields;
    private static DerObjectIdentifier DefaultEncryptionAlgorithm;
    private static int DefaultMinIterations;
    private static int DefaultSaltSize;
    private DbConnection connection;
    private Char[] password;
    [CompilerGeneratedAttribute]
private DerObjectIdentifier <EncryptionAlgorithm>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MinIterations>k__BackingField;
    [CompilerGeneratedAttribute]
private SecureRandom <RandomNumberGenerator>k__BackingField;
    [CompilerGeneratedAttribute]
private int <SaltSize>k__BackingField;
    protected DerObjectIdentifier EncryptionAlgorithm { get; protected set; }
    protected int MinIterations { get; protected set; }
    protected SecureRandom RandomNumberGenerator { get; private set; }
    protected int SaltSize { get; protected set; }
    protected X509CertificateDatabase(DbConnection connection, string password);
    protected X509CertificateDatabase(DbConnection connection, string password, SecureRandom random);
    private static X509CertificateDatabase();
    protected virtual override void Finalize();
    [CompilerGeneratedAttribute]
protected DerObjectIdentifier get_EncryptionAlgorithm();
    [CompilerGeneratedAttribute]
protected void set_EncryptionAlgorithm(DerObjectIdentifier value);
    [CompilerGeneratedAttribute]
protected int get_MinIterations();
    [CompilerGeneratedAttribute]
protected void set_MinIterations(int value);
    [CompilerGeneratedAttribute]
protected SecureRandom get_RandomNumberGenerator();
    [CompilerGeneratedAttribute]
private void set_RandomNumberGenerator(SecureRandom value);
    [CompilerGeneratedAttribute]
protected int get_SaltSize();
    [CompilerGeneratedAttribute]
protected void set_SaltSize(int value);
    private static int ReadBinaryBlob(DbDataReader reader, int column, Byte[]& buffer);
    private static X509Certificate DecodeCertificate(DbDataReader reader, X509CertificateParser parser, int column, Byte[]& buffer);
    private static X509Crl DecodeX509Crl(DbDataReader reader, X509CrlParser parser, int column, Byte[]& buffer);
    private Byte[] EncryptAsymmetricKeyParameter(AsymmetricKeyParameter key);
    private AsymmetricKeyParameter DecryptAsymmetricKeyParameter(Byte[] buffer, int length);
    private AsymmetricKeyParameter DecodePrivateKey(DbDataReader reader, int column, Byte[]& buffer);
    private object EncodePrivateKey(AsymmetricKeyParameter key);
    private static EncryptionAlgorithm[] DecodeEncryptionAlgorithms(DbDataReader reader, int column);
    private static object EncodeEncryptionAlgorithms(EncryptionAlgorithm[] algorithms);
    private X509CertificateRecord LoadCertificateRecord(DbDataReader reader, X509CertificateParser parser, Byte[]& buffer);
    private static X509CrlRecord LoadCrlRecord(DbDataReader reader, X509CrlParser parser, Byte[]& buffer);
    protected static String[] GetColumnNames(X509CertificateRecordFields fields);
    protected abstract virtual DbCommand GetSelectCommand(DbConnection connection, X509Certificate certificate, X509CertificateRecordFields fields);
    protected abstract virtual DbCommand GetSelectCommand(DbConnection connection, MailboxAddress mailbox, DateTime now, bool requirePrivateKey, X509CertificateRecordFields fields);
    protected abstract virtual DbCommand GetSelectCommand(DbConnection connection, ISelector`1<X509Certificate> selector, bool trustedAnchorsOnly, bool requirePrivateKey, X509CertificateRecordFields fields);
    protected static String[] GetColumnNames(X509CrlRecordFields fields);
    protected abstract virtual DbCommand GetSelectCommand(DbConnection connection, X509Name issuer, X509CrlRecordFields fields);
    protected abstract virtual DbCommand GetSelectCommand(DbConnection connection, X509Crl crl, X509CrlRecordFields fields);
    protected abstract virtual DbCommand GetSelectAllCrlsCommand(DbConnection connection);
    protected abstract virtual DbCommand GetDeleteCommand(DbConnection connection, X509CertificateRecord record);
    protected abstract virtual DbCommand GetDeleteCommand(DbConnection connection, X509CrlRecord record);
    protected object GetValue(X509CertificateRecord record, string columnName);
    protected static object GetValue(X509CrlRecord record, string columnName);
    protected abstract virtual DbCommand GetInsertCommand(DbConnection connection, X509CertificateRecord record);
    protected abstract virtual DbCommand GetInsertCommand(DbConnection connection, X509CrlRecord record);
    protected abstract virtual DbCommand GetUpdateCommand(DbConnection connection, X509CertificateRecord record, X509CertificateRecordFields fields);
    protected abstract virtual DbCommand GetUpdateCommand(DbConnection connection, X509CrlRecord record);
    public sealed virtual X509CertificateRecord Find(X509Certificate certificate, X509CertificateRecordFields fields);
    [IteratorStateMachineAttribute("MimeKit.Cryptography.X509CertificateDatabase/<FindCertificates>d__53")]
public sealed virtual IEnumerable`1<X509Certificate> FindCertificates(ISelector`1<X509Certificate> selector);
    [IteratorStateMachineAttribute("MimeKit.Cryptography.X509CertificateDatabase/<FindPrivateKeys>d__54")]
public sealed virtual IEnumerable`1<AsymmetricKeyParameter> FindPrivateKeys(ISelector`1<X509Certificate> selector);
    [IteratorStateMachineAttribute("MimeKit.Cryptography.X509CertificateDatabase/<Find>d__55")]
public sealed virtual IEnumerable`1<X509CertificateRecord> Find(MailboxAddress mailbox, DateTime now, bool requirePrivateKey, X509CertificateRecordFields fields);
    [IteratorStateMachineAttribute("MimeKit.Cryptography.X509CertificateDatabase/<Find>d__56")]
public sealed virtual IEnumerable`1<X509CertificateRecord> Find(ISelector`1<X509Certificate> selector, bool trustedAnchorsOnly, X509CertificateRecordFields fields);
    public sealed virtual void Add(X509CertificateRecord record);
    public sealed virtual void Remove(X509CertificateRecord record);
    public sealed virtual void Update(X509CertificateRecord record, X509CertificateRecordFields fields);
    [IteratorStateMachineAttribute("MimeKit.Cryptography.X509CertificateDatabase/<Find>d__60")]
public sealed virtual IEnumerable`1<X509CrlRecord> Find(X509Name issuer, X509CrlRecordFields fields);
    public sealed virtual X509CrlRecord Find(X509Crl crl, X509CrlRecordFields fields);
    public sealed virtual void Add(X509CrlRecord record);
    public sealed virtual void Remove(X509CrlRecord record);
    public sealed virtual void Update(X509CrlRecord record);
    public sealed virtual IStore`1<X509Crl> GetCrlStore();
    private sealed virtual override IEnumerable`1<X509Certificate> Org.BouncyCastle.Utilities.Collections.IStore<Org.BouncyCastle.X509.X509Certificate>.EnumerateMatches(ISelector`1<X509Certificate> selector);
    protected virtual void Dispose(bool disposing);
    public sealed virtual void Dispose();
}
public class MimeKit.Cryptography.X509CertificateRecord : object {
    [CompilerGeneratedAttribute]
private int <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsTrusted>k__BackingField;
    [CompilerGeneratedAttribute]
private EncryptionAlgorithm[] <Algorithms>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <AlgorithmsUpdated>k__BackingField;
    [CompilerGeneratedAttribute]
private X509Certificate <Certificate>k__BackingField;
    [CompilerGeneratedAttribute]
private AsymmetricKeyParameter <PrivateKey>k__BackingField;
    public int Id { get; internal set; }
    public int BasicConstraints { get; }
    public bool IsTrusted { get; public set; }
    public bool IsAnchor { get; }
    public X509KeyUsageFlags KeyUsage { get; }
    public DateTime NotBefore { get; }
    public DateTime NotAfter { get; }
    public string IssuerName { get; }
    public string SerialNumber { get; }
    public string SubjectName { get; }
    public Byte[] SubjectKeyIdentifier { get; }
    public string SubjectEmail { get; }
    public string Fingerprint { get; }
    public EncryptionAlgorithm[] Algorithms { get; public set; }
    public DateTime AlgorithmsUpdated { get; public set; }
    public X509Certificate Certificate { get; internal set; }
    public AsymmetricKeyParameter PrivateKey { get; public set; }
    public X509CertificateRecord(X509Certificate certificate, AsymmetricKeyParameter key);
    public X509CertificateRecord(X509Certificate certificate);
    [CompilerGeneratedAttribute]
public int get_Id();
    [CompilerGeneratedAttribute]
internal void set_Id(int value);
    public int get_BasicConstraints();
    [CompilerGeneratedAttribute]
public bool get_IsTrusted();
    [CompilerGeneratedAttribute]
public void set_IsTrusted(bool value);
    public bool get_IsAnchor();
    public X509KeyUsageFlags get_KeyUsage();
    public DateTime get_NotBefore();
    public DateTime get_NotAfter();
    public string get_IssuerName();
    public string get_SerialNumber();
    public string get_SubjectName();
    public Byte[] get_SubjectKeyIdentifier();
    public string get_SubjectEmail();
    public string get_Fingerprint();
    [CompilerGeneratedAttribute]
public EncryptionAlgorithm[] get_Algorithms();
    [CompilerGeneratedAttribute]
public void set_Algorithms(EncryptionAlgorithm[] value);
    [CompilerGeneratedAttribute]
public DateTime get_AlgorithmsUpdated();
    [CompilerGeneratedAttribute]
public void set_AlgorithmsUpdated(DateTime value);
    [CompilerGeneratedAttribute]
public X509Certificate get_Certificate();
    [CompilerGeneratedAttribute]
internal void set_Certificate(X509Certificate value);
    [CompilerGeneratedAttribute]
public AsymmetricKeyParameter get_PrivateKey();
    [CompilerGeneratedAttribute]
public void set_PrivateKey(AsymmetricKeyParameter value);
}
[FlagsAttribute]
public enum MimeKit.Cryptography.X509CertificateRecordFields : Enum {
    public int value__;
    public static X509CertificateRecordFields Id;
    public static X509CertificateRecordFields Trusted;
    public static X509CertificateRecordFields Algorithms;
    public static X509CertificateRecordFields AlgorithmsUpdated;
    public static X509CertificateRecordFields Certificate;
    public static X509CertificateRecordFields PrivateKey;
}
public class MimeKit.Cryptography.X509CertificateStore : object {
    private Dictionary`2<X509Certificate, AsymmetricKeyParameter> keys;
    private HashSet`1<X509Certificate> unique;
    private List`1<X509Certificate> certs;
    public IEnumerable`1<X509Certificate> Certificates { get; }
    public IEnumerable`1<X509Certificate> get_Certificates();
    public AsymmetricKeyParameter GetPrivateKey(X509Certificate certificate);
    public void Add(X509Certificate certificate);
    public void AddRange(IEnumerable`1<X509Certificate> certificates);
    public void Remove(X509Certificate certificate);
    public void RemoveRange(IEnumerable`1<X509Certificate> certificates);
    public void Import(Stream stream);
    public void Import(string fileName);
    public void Import(Byte[] rawData);
    public void Import(Stream stream, string password);
    public void Import(string fileName, string password);
    public void Import(Byte[] rawData, string password);
    public void Export(Stream stream);
    public void Export(string fileName);
    public void Export(Stream stream, string password);
    public void Export(string fileName, string password);
    [IteratorStateMachineAttribute("MimeKit.Cryptography.X509CertificateStore/<GetMatches>d__21")]
public IEnumerable`1<X509Certificate> GetMatches(ISelector`1<X509Certificate> selector);
    private sealed virtual override IEnumerable`1<X509Certificate> Org.BouncyCastle.Utilities.Collections.IStore<Org.BouncyCastle.X509.X509Certificate>.EnumerateMatches(ISelector`1<X509Certificate> selector);
}
public class MimeKit.Cryptography.X509CrlRecord : object {
    [CompilerGeneratedAttribute]
private int <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsDelta>k__BackingField;
    [CompilerGeneratedAttribute]
private string <IssuerName>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <ThisUpdate>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <NextUpdate>k__BackingField;
    [CompilerGeneratedAttribute]
private X509Crl <Crl>k__BackingField;
    public int Id { get; internal set; }
    public bool IsDelta { get; internal set; }
    public string IssuerName { get; internal set; }
    public DateTime ThisUpdate { get; internal set; }
    public DateTime NextUpdate { get; internal set; }
    public X509Crl Crl { get; public set; }
    public X509CrlRecord(X509Crl crl);
    [CompilerGeneratedAttribute]
public int get_Id();
    [CompilerGeneratedAttribute]
internal void set_Id(int value);
    [CompilerGeneratedAttribute]
public bool get_IsDelta();
    [CompilerGeneratedAttribute]
internal void set_IsDelta(bool value);
    [CompilerGeneratedAttribute]
public string get_IssuerName();
    [CompilerGeneratedAttribute]
internal void set_IssuerName(string value);
    [CompilerGeneratedAttribute]
public DateTime get_ThisUpdate();
    [CompilerGeneratedAttribute]
internal void set_ThisUpdate(DateTime value);
    [CompilerGeneratedAttribute]
public DateTime get_NextUpdate();
    [CompilerGeneratedAttribute]
internal void set_NextUpdate(DateTime value);
    [CompilerGeneratedAttribute]
public X509Crl get_Crl();
    [CompilerGeneratedAttribute]
public void set_Crl(X509Crl value);
}
[FlagsAttribute]
public enum MimeKit.Cryptography.X509CrlRecordFields : Enum {
    public int value__;
    public static X509CrlRecordFields Id;
    public static X509CrlRecordFields IsDelta;
    public static X509CrlRecordFields IssuerName;
    public static X509CrlRecordFields ThisUpdate;
    public static X509CrlRecordFields NextUpdate;
    public static X509CrlRecordFields Crl;
}
internal enum MimeKit.Cryptography.X509KeyUsageBits : Enum {
    public int value__;
    public static X509KeyUsageBits DigitalSignature;
    public static X509KeyUsageBits NonRepudiation;
    public static X509KeyUsageBits KeyEncipherment;
    public static X509KeyUsageBits DataEncipherment;
    public static X509KeyUsageBits KeyAgreement;
    public static X509KeyUsageBits KeyCertSign;
    public static X509KeyUsageBits CrlSign;
    public static X509KeyUsageBits EncipherOnly;
    public static X509KeyUsageBits DecipherOnly;
}
[FlagsAttribute]
public enum MimeKit.Cryptography.X509KeyUsageFlags : Enum {
    public int value__;
    public static X509KeyUsageFlags None;
    public static X509KeyUsageFlags EncipherOnly;
    public static X509KeyUsageFlags CrlSign;
    public static X509KeyUsageFlags KeyCertSign;
    public static X509KeyUsageFlags KeyAgreement;
    public static X509KeyUsageFlags DataEncipherment;
    public static X509KeyUsageFlags KeyEncipherment;
    public static X509KeyUsageFlags NonRepudiation;
    public static X509KeyUsageFlags DigitalSignature;
    public static X509KeyUsageFlags DecipherOnly;
}
[DefaultMemberAttribute("Item")]
public class MimeKit.DomainList : object {
    private static Byte[] DomainSentinels;
    private IList`1<string> domains;
    [CompilerGeneratedAttribute]
private EventHandler Changed;
    public string Item { get; public set; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public DomainList(IEnumerable`1<string> domains);
    private static DomainList();
    private void EnsureAllocated();
    public sealed virtual int IndexOf(string domain);
    public sealed virtual void Insert(int index, string domain);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual string get_Item(int index);
    public sealed virtual void set_Item(int index, string value);
    public sealed virtual void Add(string domain);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(string domain);
    public sealed virtual void CopyTo(String[] array, int arrayIndex);
    public sealed virtual bool Remove(string domain);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual IEnumerator`1<string> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    internal string Encode(FormatOptions options);
    public virtual string ToString();
    [CompilerGeneratedAttribute]
internal void add_Changed(EventHandler value);
    [CompilerGeneratedAttribute]
internal void remove_Changed(EventHandler value);
    private void OnChanged();
    internal static bool TryParse(Byte[] buffer, Int32& index, int endIndex, bool throwOnError, DomainList& route);
    public static bool TryParse(string text, DomainList& route);
}
public enum MimeKit.EncodingConstraint : Enum {
    public int value__;
    public static EncodingConstraint None;
    public static EncodingConstraint EightBit;
    public static EncodingConstraint SevenBit;
}
public class MimeKit.Encodings.Base64Decoder : object {
    private int previous;
    private UInt32 saved;
    private byte bytes;
    private static ReadOnlySpan`1<byte> base64_rank { get; }
    public ContentEncoding Encoding { get; }
    private static ReadOnlySpan`1<byte> get_base64_rank();
    public sealed virtual IMimeDecoder Clone();
    public sealed virtual ContentEncoding get_Encoding();
    public sealed virtual int EstimateOutputLength(int inputLength);
    private void ValidateArguments(Byte[] input, int startIndex, int length, Byte[] output);
    public sealed virtual int Decode(Byte* input, int length, Byte* output);
    public sealed virtual int Decode(Byte[] input, int startIndex, int length, Byte[] output);
    public sealed virtual void Reset();
}
public class MimeKit.Encodings.Base64Encoder : object {
    private int quartetsPerLine;
    private bool rfc2047;
    private int quartets;
    private byte saved1;
    private byte saved2;
    private byte saved;
    private static ReadOnlySpan`1<byte> base64_alphabet { get; }
    public ContentEncoding Encoding { get; }
    internal Base64Encoder(bool rfc2047, int maxLineLength);
    public Base64Encoder(int maxLineLength);
    private static ReadOnlySpan`1<byte> get_base64_alphabet();
    public sealed virtual IMimeEncoder Clone();
    public sealed virtual ContentEncoding get_Encoding();
    public sealed virtual int EstimateOutputLength(int inputLength);
    private void ValidateArguments(Byte[] input, int startIndex, int length, Byte[] output);
    private int Encode(Byte* input, int length, Byte* output);
    public sealed virtual int Encode(Byte[] input, int startIndex, int length, Byte[] output);
    private int Flush(Byte* input, int length, Byte* output);
    public sealed virtual int Flush(Byte[] input, int startIndex, int length, Byte[] output);
    public sealed virtual void Reset();
}
public class MimeKit.Encodings.HexDecoder : object {
    private HexDecoderState state;
    private byte saved;
    public ContentEncoding Encoding { get; }
    public sealed virtual IMimeDecoder Clone();
    public sealed virtual ContentEncoding get_Encoding();
    public sealed virtual int EstimateOutputLength(int inputLength);
    private void ValidateArguments(Byte[] input, int startIndex, int length, Byte[] output);
    public sealed virtual int Decode(Byte* input, int length, Byte* output);
    public sealed virtual int Decode(Byte[] input, int startIndex, int length, Byte[] output);
    public sealed virtual void Reset();
}
public class MimeKit.Encodings.HexEncoder : object {
    private static ReadOnlySpan`1<byte> hex_alphabet { get; }
    public ContentEncoding Encoding { get; }
    private static ReadOnlySpan`1<byte> get_hex_alphabet();
    public sealed virtual IMimeEncoder Clone();
    public sealed virtual ContentEncoding get_Encoding();
    public sealed virtual int EstimateOutputLength(int inputLength);
    private void ValidateArguments(Byte[] input, int startIndex, int length, Byte[] output);
    private static int Encode(Byte* input, int length, Byte* output);
    public sealed virtual int Encode(Byte[] input, int startIndex, int length, Byte[] output);
    public sealed virtual int Flush(Byte[] input, int startIndex, int length, Byte[] output);
    public sealed virtual void Reset();
}
public interface MimeKit.Encodings.IMimeDecoder {
    public ContentEncoding Encoding { get; }
    public abstract virtual ContentEncoding get_Encoding();
    public abstract virtual IMimeDecoder Clone();
    public abstract virtual int EstimateOutputLength(int inputLength);
    public abstract virtual int Decode(Byte* input, int length, Byte* output);
    public abstract virtual int Decode(Byte[] input, int startIndex, int length, Byte[] output);
    public abstract virtual void Reset();
}
public interface MimeKit.Encodings.IMimeEncoder {
    public ContentEncoding Encoding { get; }
    public abstract virtual ContentEncoding get_Encoding();
    public abstract virtual IMimeEncoder Clone();
    public abstract virtual int EstimateOutputLength(int inputLength);
    public abstract virtual int Encode(Byte[] input, int startIndex, int length, Byte[] output);
    public abstract virtual int Flush(Byte[] input, int startIndex, int length, Byte[] output);
    public abstract virtual void Reset();
}
public interface MimeKit.Encodings.IPunycode {
    public abstract virtual string Encode(string domain);
    public abstract virtual string Encode(string domain, int index);
    public abstract virtual string Encode(string domain, int index, int count);
    public abstract virtual string Decode(string domain);
    public abstract virtual string Decode(string domain, int index);
    public abstract virtual string Decode(string domain, int index, int count);
}
public class MimeKit.Encodings.PassThroughDecoder : object {
    [CompilerGeneratedAttribute]
private ContentEncoding <Encoding>k__BackingField;
    public ContentEncoding Encoding { get; private set; }
    public PassThroughDecoder(ContentEncoding encoding);
    public sealed virtual IMimeDecoder Clone();
    [CompilerGeneratedAttribute]
public sealed virtual ContentEncoding get_Encoding();
    [CompilerGeneratedAttribute]
private void set_Encoding(ContentEncoding value);
    public sealed virtual int EstimateOutputLength(int inputLength);
    private void ValidateArguments(Byte[] input, int startIndex, int length, Byte[] output);
    public sealed virtual int Decode(Byte* input, int length, Byte* output);
    public sealed virtual int Decode(Byte[] input, int startIndex, int length, Byte[] output);
    public sealed virtual void Reset();
}
public class MimeKit.Encodings.PassThroughEncoder : object {
    [CompilerGeneratedAttribute]
private ContentEncoding <Encoding>k__BackingField;
    public ContentEncoding Encoding { get; private set; }
    public PassThroughEncoder(ContentEncoding encoding);
    public sealed virtual IMimeEncoder Clone();
    [CompilerGeneratedAttribute]
public sealed virtual ContentEncoding get_Encoding();
    [CompilerGeneratedAttribute]
private void set_Encoding(ContentEncoding value);
    public sealed virtual int EstimateOutputLength(int inputLength);
    private void ValidateArguments(Byte[] input, int startIndex, int length, Byte[] output);
    public sealed virtual int Encode(Byte[] input, int startIndex, int length, Byte[] output);
    public sealed virtual int Flush(Byte[] input, int startIndex, int length, Byte[] output);
    public sealed virtual void Reset();
}
public class MimeKit.Encodings.Punycode : object {
    private IdnMapping idn;
    public Punycode(IdnMapping idnMapping);
    public sealed virtual string Encode(string unicode);
    public sealed virtual string Encode(string unicode, int index);
    public sealed virtual string Encode(string unicode, int index, int count);
    public sealed virtual string Decode(string ascii);
    public sealed virtual string Decode(string ascii, int index);
    public sealed virtual string Decode(string ascii, int index, int count);
}
public enum MimeKit.Encodings.QEncodeMode : Enum {
    public byte value__;
    public static QEncodeMode Phrase;
    public static QEncodeMode Text;
}
public class MimeKit.Encodings.QEncoder : object {
    private CharType mask;
    private static ReadOnlySpan`1<byte> hex_alphabet { get; }
    public ContentEncoding Encoding { get; }
    public QEncoder(QEncodeMode mode);
    private static ReadOnlySpan`1<byte> get_hex_alphabet();
    public sealed virtual IMimeEncoder Clone();
    public sealed virtual ContentEncoding get_Encoding();
    public sealed virtual int EstimateOutputLength(int inputLength);
    private void ValidateArguments(Byte[] input, int startIndex, int length, Byte[] output);
    private int Encode(Byte* input, int length, Byte* output);
    public sealed virtual int Encode(Byte[] input, int startIndex, int length, Byte[] output);
    private int Flush(Byte* input, int length, Byte* output);
    public sealed virtual int Flush(Byte[] input, int startIndex, int length, Byte[] output);
    public sealed virtual void Reset();
}
public class MimeKit.Encodings.QuotedPrintableDecoder : object {
    private bool rfc2047;
    private QpDecoderState state;
    private byte saved;
    public ContentEncoding Encoding { get; }
    public QuotedPrintableDecoder(bool rfc2047);
    public sealed virtual IMimeDecoder Clone();
    public sealed virtual ContentEncoding get_Encoding();
    public sealed virtual int EstimateOutputLength(int inputLength);
    private void ValidateArguments(Byte[] input, int startIndex, int length, Byte[] output);
    public sealed virtual int Decode(Byte* input, int length, Byte* output);
    public sealed virtual int Decode(Byte[] input, int startIndex, int length, Byte[] output);
    public sealed virtual void Reset();
}
public class MimeKit.Encodings.QuotedPrintableEncoder : object {
    private short tripletsPerLine;
    private short maxLineLength;
    private short currentLineLength;
    private short saved;
    private static ReadOnlySpan`1<byte> hex_alphabet { get; }
    public ContentEncoding Encoding { get; }
    private QuotedPrintableEncoder(short tripletsPerLine, short maxLineLength);
    public QuotedPrintableEncoder(int maxLineLength);
    private static ReadOnlySpan`1<byte> get_hex_alphabet();
    public sealed virtual IMimeEncoder Clone();
    public sealed virtual ContentEncoding get_Encoding();
    public sealed virtual int EstimateOutputLength(int inputLength);
    private void ValidateArguments(Byte[] input, int startIndex, int length, Byte[] output);
    private int Encode(Byte* input, int length, Byte* output);
    public sealed virtual int Encode(Byte[] input, int startIndex, int length, Byte[] output);
    private int Flush(Byte* input, int length, Byte* output);
    public sealed virtual int Flush(Byte[] input, int startIndex, int length, Byte[] output);
    public sealed virtual void Reset();
}
public class MimeKit.Encodings.UUDecoder : object {
    private UUDecoderState initial;
    private UUDecoderState state;
    private byte nsaved;
    private byte uulen;
    private UInt32 saved;
    private static ReadOnlySpan`1<byte> uudecode_rank { get; }
    public ContentEncoding Encoding { get; }
    public UUDecoder(bool payloadOnly);
    private static ReadOnlySpan`1<byte> get_uudecode_rank();
    public sealed virtual IMimeDecoder Clone();
    public sealed virtual ContentEncoding get_Encoding();
    public sealed virtual int EstimateOutputLength(int inputLength);
    private void ValidateArguments(Byte[] input, int startIndex, int length, Byte[] output);
    private Byte* ScanBeginMarker(Byte* inptr, Byte* inend);
    public sealed virtual int Decode(Byte* input, int length, Byte* output);
    public sealed virtual int Decode(Byte[] input, int startIndex, int length, Byte[] output);
    public sealed virtual void Reset();
}
public class MimeKit.Encodings.UUEncoder : object {
    private static int MaxInputPerLine;
    private static int MaxOutputPerLine;
    private Byte[] uubuf;
    private UInt32 saved;
    private byte nsaved;
    private byte uulen;
    public ContentEncoding Encoding { get; }
    public sealed virtual IMimeEncoder Clone();
    public sealed virtual ContentEncoding get_Encoding();
    public sealed virtual int EstimateOutputLength(int inputLength);
    private void ValidateArguments(Byte[] input, int startIndex, int length, Byte[] output);
    private static byte Encode(int c);
    private int Encode(Byte* input, int length, Byte[] outbuf, Byte* output, Byte* uuptr);
    public sealed virtual int Encode(Byte[] input, int startIndex, int length, Byte[] output);
    private int Flush(Byte* input, int length, Byte[] outbuf, Byte* output, Byte* uuptr);
    public sealed virtual int Flush(Byte[] input, int startIndex, int length, Byte[] output);
    public sealed virtual void Reset();
}
public class MimeKit.Encodings.YDecoder : object {
    private YDecoderState initial;
    private YDecoderState state;
    private bool escaped;
    private byte octet;
    private bool eoln;
    private Crc32 crc;
    public int Checksum { get; }
    public ContentEncoding Encoding { get; }
    public YDecoder(bool payloadOnly);
    public int get_Checksum();
    public sealed virtual IMimeDecoder Clone();
    public sealed virtual ContentEncoding get_Encoding();
    public sealed virtual int EstimateOutputLength(int inputLength);
    private void ValidateArguments(Byte[] input, int startIndex, int length, Byte[] output);
    private Byte* ScanYBeginMarker(Byte* inptr, Byte* inend);
    public sealed virtual int Decode(Byte* input, int length, Byte* output);
    public sealed virtual int Decode(Byte[] input, int startIndex, int length, Byte[] output);
    public sealed virtual void Reset();
}
public class MimeKit.Encodings.YEncoder : object {
    private int lineLength;
    private byte octets;
    private Crc32 crc;
    public int Checksum { get; }
    public ContentEncoding Encoding { get; }
    public YEncoder(int maxLineLength);
    public int get_Checksum();
    public sealed virtual IMimeEncoder Clone();
    public sealed virtual ContentEncoding get_Encoding();
    public sealed virtual int EstimateOutputLength(int inputLength);
    private void ValidateArguments(Byte[] input, int startIndex, int length, Byte[] output);
    private int Encode(Byte* input, int length, Byte* output);
    public sealed virtual int Encode(Byte[] input, int startIndex, int length, Byte[] output);
    private int Flush(Byte* input, int length, Byte* output);
    public sealed virtual int Flush(Byte[] input, int startIndex, int length, Byte[] output);
    public sealed virtual void Reset();
}
public class MimeKit.ExperimentalMimeParser : MimeReader {
    private Stack`1<object> stack;
    private Byte[] mboxMarkerBuffer;
    private long mboxMarkerOffset;
    private int mboxMarkerLength;
    private List`1<Header> headers;
    private Byte[] preHeaderBuffer;
    private int preHeaderLength;
    private Stream content;
    private bool parsingMessageHeaders;
    private int depth;
    private bool persistent;
    public long MboxMarkerOffset { get; }
    public string MboxMarker { get; }
    public ExperimentalMimeParser(Stream stream, MimeFormat format, bool persistent);
    public ExperimentalMimeParser(Stream stream, bool persistent);
    public ExperimentalMimeParser(ParserOptions options, Stream stream, bool persistent);
    public ExperimentalMimeParser(ParserOptions options, Stream stream, MimeFormat format, bool persistent);
    public sealed virtual long get_MboxMarkerOffset();
    public sealed virtual string get_MboxMarker();
    public sealed virtual void SetStream(Stream stream, MimeFormat format, bool persistent);
    public virtual void SetStream(Stream stream, MimeFormat format);
    public sealed virtual void SetStream(Stream stream, bool persistent);
    private void PopEntity();
    protected virtual void OnMboxMarkerRead(Byte[] buffer, int startIndex, int count, long beginOffset, int lineNumber, CancellationToken cancellationToken);
    protected virtual void OnHeadersBegin(long beginOffset, int beginLineNumber, CancellationToken cancellationToken);
    protected virtual void OnHeaderRead(Header header, int beginLineNumber, CancellationToken cancellationToken);
    protected virtual void OnHeadersEnd(long beginOffset, int beginLineNumber, long endOffset, int endLineNumber, CancellationToken cancellationToken);
    protected virtual void OnMimeMessageBegin(long beginOffset, int beginLineNumber, CancellationToken cancellationToken);
    protected virtual void OnMimeMessageEnd(long beginOffset, int beginLineNumber, long headersEndOffset, long endOffset, int lines, CancellationToken cancellationToken);
    protected virtual void OnMimePartBegin(ContentType contentType, long beginOffset, int beginLineNumber, CancellationToken cancellationToken);
    protected virtual void OnMimePartContentBegin(long beginOffset, int beginLineNumber, CancellationToken cancellationToken);
    protected virtual void OnMimePartContentRead(Byte[] buffer, int startIndex, int count, CancellationToken cancellationToken);
    protected virtual void OnMimePartContentEnd(long beginOffset, int beginLineNumber, long endOffset, int lines, Nullable`1<NewLineFormat> newLineFormat, CancellationToken cancellationToken);
    protected virtual void OnMimePartEnd(ContentType contentType, long beginOffset, int beginLineNumber, long headersEndOffset, long endOffset, int lines, CancellationToken cancellationToken);
    protected virtual void OnMessagePartBegin(ContentType contentType, long beginOffset, int beginLineNumber, CancellationToken cancellationToken);
    protected virtual void OnMessagePartEnd(ContentType contentType, long beginOffset, int beginLineNumber, long headersEndOffset, long endOffset, int lines, CancellationToken cancellationToken);
    protected virtual void OnMultipartBegin(ContentType contentType, long beginOffset, int beginLineNumber, CancellationToken cancellationToken);
    protected virtual void OnMultipartBoundary(string boundary, long beginOffset, long endOffset, int lineNumber, CancellationToken cancellationToken);
    protected virtual void OnMultipartEndBoundary(string boundary, long beginOffset, long endOffset, int lineNumber, CancellationToken cancellationToken);
    protected virtual void OnMultipartPreambleBegin(long beginOffset, int beginLineNumber, CancellationToken cancellationToken);
    protected virtual void OnMultipartPreambleRead(Byte[] buffer, int startIndex, int count, CancellationToken cancellationToken);
    protected virtual void OnMultipartPreambleEnd(long beginOffset, int beginLineNumber, long endOffset, int lines, CancellationToken cancellationToken);
    protected virtual void OnMultipartEpilogueBegin(long beginOffset, int beginLineNumber, CancellationToken cancellationToken);
    protected virtual void OnMultipartEpilogueRead(Byte[] buffer, int startIndex, int count, CancellationToken cancellationToken);
    protected virtual void OnMultipartEpilogueEnd(long beginOffset, int beginLineNumber, long endOffset, int lines, CancellationToken cancellationToken);
    protected virtual void OnMultipartEnd(ContentType contentType, long beginOffset, int beginLineNumber, long headersEndOffset, long endOffset, int lines, CancellationToken cancellationToken);
    private void Reset();
    private void Initialize(bool parsingMessageHeaders);
    public sealed virtual HeaderList ParseHeaders(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MimeKit.ExperimentalMimeParser/<ParseHeadersAsync>d__49")]
public sealed virtual Task`1<HeaderList> ParseHeadersAsync(CancellationToken cancellationToken);
    public sealed virtual MimeEntity ParseEntity(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MimeKit.ExperimentalMimeParser/<ParseEntityAsync>d__51")]
public sealed virtual Task`1<MimeEntity> ParseEntityAsync(CancellationToken cancellationToken);
    public sealed virtual MimeMessage ParseMessage(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MimeKit.ExperimentalMimeParser/<ParseMessageAsync>d__53")]
public sealed virtual Task`1<MimeMessage> ParseMessageAsync(CancellationToken cancellationToken);
}
public class MimeKit.FormatOptions : object {
    private static Byte[][] NewLineFormats;
    internal static int MaximumLineLength;
    internal static int MinimumLineLength;
    private static int DefaultMaxLineLength;
    private ParameterEncodingMethod parameterEncodingMethod;
    private bool alwaysQuoteParameterValues;
    private bool allowMixedHeaderCharsets;
    private NewLineFormat newLineFormat;
    private bool verifyingSignature;
    private bool ensureNewLine;
    private bool international;
    private int maxLineLength;
    public static FormatOptions Default;
    [CompilerGeneratedAttribute]
private HashSet`1<HeaderId> <HiddenHeaders>k__BackingField;
    public int MaxLineLength { get; public set; }
    public NewLineFormat NewLineFormat { get; public set; }
    public bool EnsureNewLine { get; public set; }
    internal string NewLine { get; }
    internal Byte[] NewLineBytes { get; }
    internal bool VerifyingSignature { get; internal set; }
    public HashSet`1<HeaderId> HiddenHeaders { get; private set; }
    public bool International { get; public set; }
    public bool AllowMixedHeaderCharsets { get; public set; }
    public ParameterEncodingMethod ParameterEncodingMethod { get; public set; }
    public bool AlwaysQuoteParameterValues { get; public set; }
    private static FormatOptions();
    public int get_MaxLineLength();
    public void set_MaxLineLength(int value);
    public NewLineFormat get_NewLineFormat();
    public void set_NewLineFormat(NewLineFormat value);
    public bool get_EnsureNewLine();
    public void set_EnsureNewLine(bool value);
    internal IMimeFilter CreateNewLineFilter(bool ensureNewLine);
    internal string get_NewLine();
    internal Byte[] get_NewLineBytes();
    internal bool get_VerifyingSignature();
    internal void set_VerifyingSignature(bool value);
    [CompilerGeneratedAttribute]
public HashSet`1<HeaderId> get_HiddenHeaders();
    [CompilerGeneratedAttribute]
private void set_HiddenHeaders(HashSet`1<HeaderId> value);
    public bool get_International();
    public void set_International(bool value);
    public bool get_AllowMixedHeaderCharsets();
    public void set_AllowMixedHeaderCharsets(bool value);
    public ParameterEncodingMethod get_ParameterEncodingMethod();
    public void set_ParameterEncodingMethod(ParameterEncodingMethod value);
    public bool get_AlwaysQuoteParameterValues();
    public void set_AlwaysQuoteParameterValues(bool value);
    public FormatOptions Clone();
}
public class MimeKit.GroupAddress : InternetAddress {
    [CompilerGeneratedAttribute]
private InternetAddressList <Members>k__BackingField;
    public InternetAddressList Members { get; private set; }
    public GroupAddress(Encoding encoding, string name, IEnumerable`1<InternetAddress> addresses);
    public GroupAddress(string name, IEnumerable`1<InternetAddress> addresses);
    public GroupAddress(Encoding encoding, string name);
    public GroupAddress(string name);
    public virtual InternetAddress Clone();
    [CompilerGeneratedAttribute]
public InternetAddressList get_Members();
    [CompilerGeneratedAttribute]
private void set_Members(InternetAddressList value);
    internal virtual void Encode(FormatOptions options, StringBuilder builder, bool firstToken, Int32& lineLength);
    public virtual string ToString(FormatOptions options, bool encode);
    public virtual bool Equals(InternetAddress other);
    private void MembersChanged(object sender, EventArgs e);
    private static bool TryParse(ParserOptions options, Byte[] text, Int32& index, int endIndex, bool throwOnError, GroupAddress& group);
    public static bool TryParse(ParserOptions options, Byte[] buffer, int startIndex, int length, GroupAddress& group);
    public static bool TryParse(Byte[] buffer, int startIndex, int length, GroupAddress& group);
    public static bool TryParse(ParserOptions options, Byte[] buffer, int startIndex, GroupAddress& group);
    public static bool TryParse(Byte[] buffer, int startIndex, GroupAddress& group);
    public static bool TryParse(ParserOptions options, Byte[] buffer, GroupAddress& group);
    public static bool TryParse(Byte[] buffer, GroupAddress& group);
    public static bool TryParse(ParserOptions options, string text, GroupAddress& group);
    public static bool TryParse(string text, GroupAddress& group);
    public static GroupAddress Parse(ParserOptions options, Byte[] buffer, int startIndex, int length);
    public static GroupAddress Parse(Byte[] buffer, int startIndex, int length);
    public static GroupAddress Parse(ParserOptions options, Byte[] buffer, int startIndex);
    public static GroupAddress Parse(Byte[] buffer, int startIndex);
    public static GroupAddress Parse(ParserOptions options, Byte[] buffer);
    public static GroupAddress Parse(Byte[] buffer);
    public static GroupAddress Parse(ParserOptions options, string text);
    public static GroupAddress Parse(string text);
}
public class MimeKit.Header : object {
    internal static Byte[] Colon;
    private static Char[] WhiteSpace;
    internal ParserOptions Options;
    private Byte[] rawField;
    private bool explicitRawValue;
    private string textValue;
    private Byte[] rawValue;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <Offset>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Field>k__BackingField;
    [CompilerGeneratedAttribute]
private HeaderId <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsInvalid>k__BackingField;
    private static ReceivedToken[] ReceivedTokens;
    [CompilerGeneratedAttribute]
private EventHandler Changed;
    public Nullable`1<long> Offset { get; internal set; }
    public string Field { get; private set; }
    public HeaderId Id { get; private set; }
    internal bool IsInvalid { get; private set; }
    public Byte[] RawField { get; }
    public Byte[] RawValue { get; }
    public string Value { get; public set; }
    private static ReadOnlySpan`1<byte> ReceivedAddrSpecSentinels { get; }
    private static ReadOnlySpan`1<byte> ReceivedMessageIdSentinels { get; }
    public Header(Encoding encoding, HeaderId id, string value);
    public Header(string charset, HeaderId id, string value);
    public Header(HeaderId id, string value);
    public Header(Encoding encoding, string field, string value);
    public Header(string charset, string field, string value);
    public Header(string field, string value);
    protected Header(ParserOptions options, HeaderId id, string name, Byte[] field, Byte[] value);
    [SkipLocalsInitAttribute]
protected internal Header(ParserOptions options, Byte[] field, int fieldNameLength, Byte[] value, bool invalid);
    [SkipLocalsInitAttribute]
protected internal Header(ParserOptions options, Byte[] field, Byte[] value, bool invalid);
    protected internal Header(ParserOptions options, HeaderId id, string field, Byte[] value);
    private static Header();
    private static void ValidateFieldName(string field);
    public Header Clone();
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_Offset();
    [CompilerGeneratedAttribute]
internal void set_Offset(Nullable`1<long> value);
    [CompilerGeneratedAttribute]
public string get_Field();
    [CompilerGeneratedAttribute]
private void set_Field(string value);
    [CompilerGeneratedAttribute]
public HeaderId get_Id();
    [CompilerGeneratedAttribute]
private void set_Id(HeaderId value);
    [CompilerGeneratedAttribute]
internal bool get_IsInvalid();
    [CompilerGeneratedAttribute]
private void set_IsInvalid(bool value);
    public Byte[] get_RawField();
    public Byte[] get_RawValue();
    public string get_Value();
    public void set_Value(string value);
    public string GetValue(Encoding encoding);
    public string GetValue(string charset);
    internal static Byte[] ReformatAddressHeader(ParserOptions options, FormatOptions format, string field, Byte[] rawValue);
    private static Byte[] EncodeAddressHeader(ParserOptions options, FormatOptions format, Encoding encoding, string field, string value);
    private static Byte[] EncodeMessageIdHeader(ParserOptions options, FormatOptions format, Encoding encoding, string field, string value);
    private static void ReceivedTokenSkipAtom(Byte[] text, Int32& index);
    private static void ReceivedTokenSkipDomain(Byte[] text, Int32& index);
    private static ReadOnlySpan`1<byte> get_ReceivedAddrSpecSentinels();
    private static ReadOnlySpan`1<byte> get_ReceivedMessageIdSentinels();
    private static void ReceivedTokenSkipAddress(Byte[] text, Int32& index);
    private static void ReceivedTokenSkipMessageId(Byte[] text, Int32& index);
    private static Byte[] EncodeReceivedHeader(ParserOptions options, FormatOptions format, Encoding encoding, string field, string value);
    private static Byte[] EncodeAuthenticationResultsHeader(ParserOptions options, FormatOptions format, Encoding encoding, string field, string value);
    private static void EncodeDkimLongValue(FormatOptions format, ValueStringBuilder& encoded, Int32& lineLength, ReadOnlySpan`1<char> value);
    private static void EncodeDkimHeaderList(FormatOptions format, ValueStringBuilder& encoded, Int32& lineLength, ReadOnlySpan`1<char> value, char delim);
    private static Byte[] EncodeDkimOrArcSignatureHeader(ParserOptions options, FormatOptions format, Encoding encoding, string field, string value);
    private static Byte[] EncodeDispositionNotificationOptions(ParserOptions options, FormatOptions format, Encoding encoding, string field, string value);
    private static Byte[] EncodeReferencesHeader(ParserOptions options, FormatOptions format, Encoding encoding, string field, string value);
    private static bool IsWhiteSpace(char c);
    [IteratorStateMachineAttribute("MimeKit.Header/<TokenizeText>d__68")]
private static IEnumerable`1<Word> TokenizeText(string text);
    internal static string Fold(FormatOptions format, string field, string value);
    private static Byte[] ReformatContentDisposition(ParserOptions options, FormatOptions format, Encoding encoding, string field, Byte[] rawValue);
    private static Byte[] EncodeContentDisposition(ParserOptions options, FormatOptions format, Encoding encoding, string field, string value);
    private static Byte[] ReformatContentType(ParserOptions options, FormatOptions format, Encoding encoding, string field, Byte[] rawValue);
    private static Byte[] EncodeContentType(ParserOptions options, FormatOptions format, Encoding encoding, string field, string value);
    private static void AppendWord(FormatOptions format, ValueStringBuilder& builder, Int32& lineLength, ReadOnlySpan`1<char> word);
    private static void AppendComment(FormatOptions format, Encoding encoding, ValueStringBuilder& builder, Int32& lineLength, string value, int startIndex, int length);
    private static bool IsMailingListCommandSpecial(char c);
    private static Byte[] EncodeMailingListCommandHeader(ParserOptions options, FormatOptions format, Encoding encoding, string field, string value);
    private static Byte[] EncodeUnstructuredHeader(ParserOptions options, FormatOptions format, Encoding encoding, string field, string value);
    protected virtual Byte[] FormatRawValue(FormatOptions format, Encoding encoding, string value);
    internal Byte[] GetRawValue(FormatOptions format);
    public void SetValue(FormatOptions format, Encoding encoding, string value);
    public void SetValue(Encoding encoding, string value);
    public void SetValue(FormatOptions format, string charset, string value);
    public void SetValue(string charset, string value);
    public void SetRawValue(Byte[] value);
    [CompilerGeneratedAttribute]
internal void add_Changed(EventHandler value);
    [CompilerGeneratedAttribute]
internal void remove_Changed(EventHandler value);
    private void OnChanged();
    public virtual string ToString();
    [SkipLocalsInitAttribute]
public static string Unfold(string text);
    private static bool IsFieldText(byte c);
    private static bool IsBlank(byte c);
    internal static bool TryParse(ParserOptions options, Byte* input, int length, bool strict, Header& header);
    public static bool TryParse(ParserOptions options, Byte[] buffer, int startIndex, int length, Header& header);
    public static bool TryParse(Byte[] buffer, int startIndex, int length, Header& header);
    public static bool TryParse(ParserOptions options, Byte[] buffer, int startIndex, Header& header);
    public static bool TryParse(Byte[] buffer, int startIndex, Header& header);
    public static bool TryParse(ParserOptions options, Byte[] buffer, Header& header);
    public static bool TryParse(Byte[] buffer, Header& header);
    public static bool TryParse(ParserOptions options, string text, Header& header);
    public static bool TryParse(string text, Header& header);
}
public enum MimeKit.HeaderId : Enum {
    public int value__;
    public static HeaderId AcceptLanguage;
    public static HeaderId AdHoc;
    public static HeaderId AlternateRecipient;
    public static HeaderId ApparentlyTo;
    public static HeaderId Approved;
    public static HeaderId ArcAuthenticationResults;
    public static HeaderId ArcMessageSignature;
    public static HeaderId ArcSeal;
    public static HeaderId Archive;
    public static HeaderId ArchivedAt;
    public static HeaderId Article;
    public static HeaderId AuthenticationResults;
    public static HeaderId Autocrypt;
    public static HeaderId AutocryptGossip;
    public static HeaderId AutocryptSetupMessage;
    public static HeaderId Autoforwarded;
    public static HeaderId AutoSubmitted;
    public static HeaderId Autosubmitted;
    public static HeaderId Base;
    public static HeaderId Bcc;
    public static HeaderId Body;
    public static HeaderId Bytes;
    public static HeaderId Cc;
    public static HeaderId Comments;
    public static HeaderId ContentAlternative;
    public static HeaderId ContentBase;
    public static HeaderId ContentClass;
    public static HeaderId ContentDescription;
    public static HeaderId ContentDisposition;
    public static HeaderId ContentDuration;
    public static HeaderId ContentFeatures;
    public static HeaderId ContentId;
    public static HeaderId ContentIdentifier;
    public static HeaderId ContentLanguage;
    public static HeaderId ContentLength;
    public static HeaderId ContentLocation;
    public static HeaderId ContentMd5;
    public static HeaderId ContentReturn;
    public static HeaderId ContentTransferEncoding;
    public static HeaderId ContentTranslationType;
    public static HeaderId ContentType;
    public static HeaderId Control;
    public static HeaderId Conversion;
    public static HeaderId ConversionWithLoss;
    public static HeaderId Date;
    public static HeaderId DateReceived;
    public static HeaderId DeferredDelivery;
    public static HeaderId DeliveryDate;
    public static HeaderId DiscloseRecipients;
    public static HeaderId DispositionNotificationOptions;
    public static HeaderId DispositionNotificationTo;
    public static HeaderId Distribution;
    public static HeaderId DkimSignature;
    public static HeaderId DomainKeySignature;
    public static HeaderId Encoding;
    public static HeaderId Encrypted;
    public static HeaderId Expires;
    public static HeaderId ExpiryDate;
    public static HeaderId FollowupTo;
    public static HeaderId From;
    public static HeaderId GenerateDeliveryReport;
    public static HeaderId Importance;
    public static HeaderId InjectionDate;
    public static HeaderId InjectionInfo;
    public static HeaderId InReplyTo;
    public static HeaderId Keywords;
    public static HeaderId Language;
    public static HeaderId LatestDeliveryTime;
    public static HeaderId Lines;
    public static HeaderId ListArchive;
    public static HeaderId ListHelp;
    public static HeaderId ListId;
    public static HeaderId ListOwner;
    public static HeaderId ListPost;
    public static HeaderId ListSubscribe;
    public static HeaderId ListUnsubscribe;
    public static HeaderId ListUnsubscribePost;
    public static HeaderId MessageId;
    public static HeaderId MimeVersion;
    public static HeaderId Newsgroups;
    public static HeaderId NntpPostingHost;
    public static HeaderId Organization;
    public static HeaderId OriginalFrom;
    public static HeaderId OriginalMessageId;
    public static HeaderId OriginalRecipient;
    public static HeaderId OriginalReturnAddress;
    public static HeaderId OriginalSubject;
    public static HeaderId Path;
    public static HeaderId Precedence;
    public static HeaderId PreventNonDeliveryReport;
    public static HeaderId Priority;
    public static HeaderId Received;
    public static HeaderId ReceivedSPF;
    public static HeaderId References;
    public static HeaderId RelayVersion;
    public static HeaderId ReplyBy;
    public static HeaderId ReplyTo;
    public static HeaderId RequireRecipientValidSince;
    public static HeaderId ResentBcc;
    public static HeaderId ResentCc;
    public static HeaderId ResentDate;
    public static HeaderId ResentFrom;
    public static HeaderId ResentMessageId;
    public static HeaderId ResentReplyTo;
    public static HeaderId ResentSender;
    public static HeaderId ResentTo;
    public static HeaderId ReturnPath;
    public static HeaderId ReturnReceiptTo;
    public static HeaderId SeeAlso;
    public static HeaderId Sender;
    public static HeaderId Sensitivity;
    public static HeaderId Solicitation;
    public static HeaderId Status;
    public static HeaderId Subject;
    public static HeaderId Summary;
    public static HeaderId Supersedes;
    public static HeaderId TLSRequired;
    public static HeaderId To;
    public static HeaderId UserAgent;
    public static HeaderId X400ContentIdentifier;
    public static HeaderId X400ContentReturn;
    public static HeaderId X400ContentType;
    public static HeaderId X400MTSIdentifier;
    public static HeaderId X400Originator;
    public static HeaderId X400Received;
    public static HeaderId X400Recipients;
    public static HeaderId X400Trace;
    public static HeaderId XMailer;
    public static HeaderId XMSMailPriority;
    public static HeaderId XPriority;
    public static HeaderId XStatus;
    public static HeaderId Unknown;
}
[ExtensionAttribute]
public static class MimeKit.HeaderIdExtensions : object {
    private static String[] HeaderNames;
    private static Dictionary`2<string, HeaderId> IdMapping;
    private static HeaderIdExtensions();
    [ExtensionAttribute]
public static string ToHeaderName(HeaderId value);
    [ExtensionAttribute]
internal static HeaderId ToHeaderId(string name);
}
[DefaultMemberAttribute("Item")]
public class MimeKit.HeaderList : object {
    internal ParserOptions Options;
    private Dictionary`2<string, Header> table;
    private List`1<Header> headers;
    [CompilerGeneratedAttribute]
private EventHandler`1<HeaderListChangedEventArgs> Changed;
    public string Item { get; public set; }
    public string Item { get; public set; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public Header Item { get; public set; }
    internal HeaderList(ParserOptions options);
    public void Add(HeaderId id, string value);
    public void Add(string field, string value);
    public void Add(HeaderId id, Encoding encoding, string value);
    public void Add(string field, Encoding encoding, string value);
    public bool Contains(HeaderId id);
    public bool Contains(string field);
    public int IndexOf(HeaderId id);
    public int IndexOf(string field);
    public void Insert(int index, HeaderId id, string value);
    public void Insert(int index, string field, string value);
    public void Insert(int index, HeaderId id, Encoding encoding, string value);
    public void Insert(int index, string field, Encoding encoding, string value);
    public int LastIndexOf(HeaderId id);
    public int LastIndexOf(string field);
    public bool Remove(HeaderId id);
    public bool Remove(string field);
    public void RemoveAll(HeaderId id);
    public void RemoveAll(string field);
    public void Replace(HeaderId id, Encoding encoding, string value);
    public void Replace(HeaderId id, string value);
    public void Replace(string field, Encoding encoding, string value);
    public void Replace(string field, string value);
    public string get_Item(HeaderId id);
    public void set_Item(HeaderId id, string value);
    public string get_Item(string field);
    public void set_Item(string field, string value);
    public void WriteTo(FormatOptions options, Stream stream, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MimeKit.HeaderList/<WriteToAsync>d__34")]
public Task WriteToAsync(FormatOptions options, Stream stream, CancellationToken cancellationToken);
    public void WriteTo(Stream stream, CancellationToken cancellationToken);
    public Task WriteToAsync(Stream stream, CancellationToken cancellationToken);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual void Add(Header header);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(Header header);
    public sealed virtual void CopyTo(Header[] array, int arrayIndex);
    public sealed virtual bool Remove(Header header);
    public void Replace(Header header);
    public sealed virtual int IndexOf(Header header);
    public sealed virtual void Insert(int index, Header header);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual Header get_Item(int index);
    public sealed virtual void set_Item(int index, Header value);
    public sealed virtual IEnumerator`1<Header> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [CompilerGeneratedAttribute]
internal void add_Changed(EventHandler`1<HeaderListChangedEventArgs> value);
    [CompilerGeneratedAttribute]
internal void remove_Changed(EventHandler`1<HeaderListChangedEventArgs> value);
    private void HeaderChanged(object sender, EventArgs args);
    private void OnChanged(Header header, HeaderListChangedAction action);
    internal bool TryGetHeader(HeaderId id, Header& header);
    internal bool TryGetHeader(string field, Header& header);
    public static HeaderList Load(ParserOptions options, Stream stream, CancellationToken cancellationToken);
    public static Task`1<HeaderList> LoadAsync(ParserOptions options, Stream stream, CancellationToken cancellationToken);
    public static HeaderList Load(Stream stream, CancellationToken cancellationToken);
    public static Task`1<HeaderList> LoadAsync(Stream stream, CancellationToken cancellationToken);
    public static HeaderList Load(ParserOptions options, string fileName, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MimeKit.HeaderList/<LoadAsync>d__67")]
public static Task`1<HeaderList> LoadAsync(ParserOptions options, string fileName, CancellationToken cancellationToken);
    public static HeaderList Load(string fileName, CancellationToken cancellationToken);
    public static Task`1<HeaderList> LoadAsync(string fileName, CancellationToken cancellationToken);
}
public enum MimeKit.HeaderListChangedAction : Enum {
    public int value__;
    public static HeaderListChangedAction Added;
    public static HeaderListChangedAction Changed;
    public static HeaderListChangedAction Removed;
    public static HeaderListChangedAction Cleared;
}
internal class MimeKit.HeaderListChangedEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private HeaderListChangedAction <Action>k__BackingField;
    [CompilerGeneratedAttribute]
private Header <Header>k__BackingField;
    public HeaderListChangedAction Action { get; private set; }
    public Header Header { get; private set; }
    internal HeaderListChangedEventArgs(Header header, HeaderListChangedAction action);
    [CompilerGeneratedAttribute]
public HeaderListChangedAction get_Action();
    [CompilerGeneratedAttribute]
private void set_Action(HeaderListChangedAction value);
    [CompilerGeneratedAttribute]
public Header get_Header();
    [CompilerGeneratedAttribute]
private void set_Header(Header value);
}
[DefaultMemberAttribute("Item")]
public class MimeKit.HeaderListCollection : object {
    private List`1<HeaderList> groups;
    [CompilerGeneratedAttribute]
private EventHandler Changed;
    public int Count { get; }
    public bool IsReadOnly { get; }
    public HeaderList Item { get; public set; }
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public HeaderList get_Item(int index);
    public void set_Item(int index, HeaderList value);
    public sealed virtual void Add(HeaderList group);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(HeaderList group);
    public sealed virtual void CopyTo(HeaderList[] array, int arrayIndex);
    public sealed virtual bool Remove(HeaderList group);
    public sealed virtual IEnumerator`1<HeaderList> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [CompilerGeneratedAttribute]
internal void add_Changed(EventHandler value);
    [CompilerGeneratedAttribute]
internal void remove_Changed(EventHandler value);
    private void OnChanged();
    private void OnGroupChanged(object sender, HeaderListChangedEventArgs e);
}
public interface MimeKit.IMessageDeliveryStatus {
    public HeaderListCollection StatusGroups { get; }
    public abstract virtual HeaderListCollection get_StatusGroups();
}
public interface MimeKit.IMessageDispositionNotification {
    public HeaderList Fields { get; }
    public abstract virtual HeaderList get_Fields();
}
public interface MimeKit.IMessageFeedbackReport {
    public HeaderList Fields { get; }
    public abstract virtual HeaderList get_Fields();
}
public interface MimeKit.IMessagePart {
    public MimeMessage Message { get; public set; }
    public abstract virtual MimeMessage get_Message();
    public abstract virtual void set_Message(MimeMessage value);
}
public interface MimeKit.IMessagePartial {
    public string Id { get; }
    public Nullable`1<int> Number { get; }
    public Nullable`1<int> Total { get; }
    public abstract virtual string get_Id();
    public abstract virtual Nullable`1<int> get_Number();
    public abstract virtual Nullable`1<int> get_Total();
}
public interface MimeKit.IMimeContent {
    public ContentEncoding Encoding { get; }
    public Nullable`1<NewLineFormat> NewLineFormat { get; }
    public Stream Stream { get; }
    public abstract virtual ContentEncoding get_Encoding();
    public abstract virtual Nullable`1<NewLineFormat> get_NewLineFormat();
    public abstract virtual Stream get_Stream();
    public abstract virtual Stream Open();
    public abstract virtual void DecodeTo(Stream stream, CancellationToken cancellationToken);
    public abstract virtual Task DecodeToAsync(Stream stream, CancellationToken cancellationToken);
    public abstract virtual void WriteTo(Stream stream, CancellationToken cancellationToken);
    public abstract virtual Task WriteToAsync(Stream stream, CancellationToken cancellationToken);
}
public interface MimeKit.IMimeEntity {
    public HeaderList Headers { get; }
    public ContentDisposition ContentDisposition { get; public set; }
    public ContentType ContentType { get; }
    public Uri ContentBase { get; public set; }
    public Uri ContentLocation { get; public set; }
    public string ContentId { get; public set; }
    public bool IsAttachment { get; public set; }
    public abstract virtual HeaderList get_Headers();
    public abstract virtual ContentDisposition get_ContentDisposition();
    public abstract virtual void set_ContentDisposition(ContentDisposition value);
    public abstract virtual ContentType get_ContentType();
    public abstract virtual Uri get_ContentBase();
    public abstract virtual void set_ContentBase(Uri value);
    public abstract virtual Uri get_ContentLocation();
    public abstract virtual void set_ContentLocation(Uri value);
    public abstract virtual string get_ContentId();
    public abstract virtual void set_ContentId(string value);
    public abstract virtual bool get_IsAttachment();
    public abstract virtual void set_IsAttachment(bool value);
    public abstract virtual void Accept(MimeVisitor visitor);
    public abstract virtual void Prepare(EncodingConstraint constraint, int maxLineLength);
    public abstract virtual void WriteTo(FormatOptions options, Stream stream, bool contentOnly, CancellationToken cancellationToken);
    public abstract virtual Task WriteToAsync(FormatOptions options, Stream stream, bool contentOnly, CancellationToken cancellationToken);
    public abstract virtual void WriteTo(FormatOptions options, Stream stream, CancellationToken cancellationToken);
    public abstract virtual Task WriteToAsync(FormatOptions options, Stream stream, CancellationToken cancellationToken);
    public abstract virtual void WriteTo(Stream stream, bool contentOnly, CancellationToken cancellationToken);
    public abstract virtual Task WriteToAsync(Stream stream, bool contentOnly, CancellationToken cancellationToken);
    public abstract virtual void WriteTo(Stream stream, CancellationToken cancellationToken);
    public abstract virtual Task WriteToAsync(Stream stream, CancellationToken cancellationToken);
    public abstract virtual void WriteTo(FormatOptions options, string fileName, bool contentOnly, CancellationToken cancellationToken);
    public abstract virtual Task WriteToAsync(FormatOptions options, string fileName, bool contentOnly, CancellationToken cancellationToken);
    public abstract virtual void WriteTo(FormatOptions options, string fileName, CancellationToken cancellationToken);
    public abstract virtual Task WriteToAsync(FormatOptions options, string fileName, CancellationToken cancellationToken);
    public abstract virtual void WriteTo(string fileName, bool contentOnly, CancellationToken cancellationToken);
    public abstract virtual Task WriteToAsync(string fileName, bool contentOnly, CancellationToken cancellationToken);
    public abstract virtual void WriteTo(string fileName, CancellationToken cancellationToken);
    public abstract virtual Task WriteToAsync(string fileName, CancellationToken cancellationToken);
}
public interface MimeKit.IMimeMessage {
    public HeaderList Headers { get; }
    public MessageImportance Importance { get; public set; }
    public MessagePriority Priority { get; public set; }
    public XMessagePriority XPriority { get; public set; }
    public MailboxAddress Sender { get; public set; }
    public MailboxAddress ResentSender { get; public set; }
    public InternetAddressList From { get; }
    public InternetAddressList ResentFrom { get; }
    public InternetAddressList ReplyTo { get; }
    public InternetAddressList ResentReplyTo { get; }
    public InternetAddressList To { get; }
    public InternetAddressList ResentTo { get; }
    public InternetAddressList Cc { get; }
    public InternetAddressList ResentCc { get; }
    public InternetAddressList Bcc { get; }
    public InternetAddressList ResentBcc { get; }
    public string Subject { get; public set; }
    public DateTimeOffset Date { get; public set; }
    public DateTimeOffset ResentDate { get; public set; }
    public MessageIdList References { get; }
    public string InReplyTo { get; public set; }
    public string MessageId { get; public set; }
    public string ResentMessageId { get; public set; }
    public Version MimeVersion { get; public set; }
    public MimeEntity Body { get; public set; }
    public string TextBody { get; }
    public string HtmlBody { get; }
    public IEnumerable`1<MimeEntity> BodyParts { get; }
    public IEnumerable`1<MimeEntity> Attachments { get; }
    public abstract virtual HeaderList get_Headers();
    public abstract virtual MessageImportance get_Importance();
    public abstract virtual void set_Importance(MessageImportance value);
    public abstract virtual MessagePriority get_Priority();
    public abstract virtual void set_Priority(MessagePriority value);
    public abstract virtual XMessagePriority get_XPriority();
    public abstract virtual void set_XPriority(XMessagePriority value);
    public abstract virtual MailboxAddress get_Sender();
    public abstract virtual void set_Sender(MailboxAddress value);
    public abstract virtual MailboxAddress get_ResentSender();
    public abstract virtual void set_ResentSender(MailboxAddress value);
    public abstract virtual InternetAddressList get_From();
    public abstract virtual InternetAddressList get_ResentFrom();
    public abstract virtual InternetAddressList get_ReplyTo();
    public abstract virtual InternetAddressList get_ResentReplyTo();
    public abstract virtual InternetAddressList get_To();
    public abstract virtual InternetAddressList get_ResentTo();
    public abstract virtual InternetAddressList get_Cc();
    public abstract virtual InternetAddressList get_ResentCc();
    public abstract virtual InternetAddressList get_Bcc();
    public abstract virtual InternetAddressList get_ResentBcc();
    public abstract virtual string get_Subject();
    public abstract virtual void set_Subject(string value);
    public abstract virtual DateTimeOffset get_Date();
    public abstract virtual void set_Date(DateTimeOffset value);
    public abstract virtual DateTimeOffset get_ResentDate();
    public abstract virtual void set_ResentDate(DateTimeOffset value);
    public abstract virtual MessageIdList get_References();
    public abstract virtual string get_InReplyTo();
    public abstract virtual void set_InReplyTo(string value);
    public abstract virtual string get_MessageId();
    public abstract virtual void set_MessageId(string value);
    public abstract virtual string get_ResentMessageId();
    public abstract virtual void set_ResentMessageId(string value);
    public abstract virtual Version get_MimeVersion();
    public abstract virtual void set_MimeVersion(Version value);
    public abstract virtual MimeEntity get_Body();
    public abstract virtual void set_Body(MimeEntity value);
    public abstract virtual string get_TextBody();
    public abstract virtual string get_HtmlBody();
    public abstract virtual string GetTextBody(TextFormat format);
    public abstract virtual IEnumerable`1<MimeEntity> get_BodyParts();
    public abstract virtual IEnumerable`1<MimeEntity> get_Attachments();
    public abstract virtual void Accept(MimeVisitor visitor);
    public abstract virtual void Prepare(EncodingConstraint constraint, int maxLineLength);
    public abstract virtual void WriteTo(FormatOptions options, Stream stream, bool headersOnly, CancellationToken cancellationToken);
    public abstract virtual Task WriteToAsync(FormatOptions options, Stream stream, bool headersOnly, CancellationToken cancellationToken);
    public abstract virtual void WriteTo(FormatOptions options, Stream stream, CancellationToken cancellationToken);
    public abstract virtual Task WriteToAsync(FormatOptions options, Stream stream, CancellationToken cancellationToken);
    public abstract virtual void WriteTo(Stream stream, bool headersOnly, CancellationToken cancellationToken);
    public abstract virtual Task WriteToAsync(Stream stream, bool headersOnly, CancellationToken cancellationToken);
    public abstract virtual void WriteTo(Stream stream, CancellationToken cancellationToken);
    public abstract virtual Task WriteToAsync(Stream stream, CancellationToken cancellationToken);
    public abstract virtual void WriteTo(FormatOptions options, string fileName, CancellationToken cancellationToken);
    public abstract virtual Task WriteToAsync(FormatOptions options, string fileName, CancellationToken cancellationToken);
    public abstract virtual void WriteTo(string fileName, CancellationToken cancellationToken);
    public abstract virtual Task WriteToAsync(string fileName, CancellationToken cancellationToken);
}
public interface MimeKit.IMimeParser {
    public ParserOptions Options { get; public set; }
    public bool IsEndOfStream { get; }
    public long Position { get; }
    public long MboxMarkerOffset { get; }
    public string MboxMarker { get; }
    public abstract virtual ParserOptions get_Options();
    public abstract virtual void set_Options(ParserOptions value);
    public abstract virtual bool get_IsEndOfStream();
    public abstract virtual long get_Position();
    public abstract virtual long get_MboxMarkerOffset();
    public abstract virtual string get_MboxMarker();
    public abstract virtual void SetStream(Stream stream, MimeFormat format, bool persistent);
    public abstract virtual void SetStream(Stream stream, MimeFormat format);
    public abstract virtual void SetStream(Stream stream, bool persistent);
    public abstract virtual HeaderList ParseHeaders(CancellationToken cancellationToken);
    public abstract virtual Task`1<HeaderList> ParseHeadersAsync(CancellationToken cancellationToken);
    public abstract virtual MimeEntity ParseEntity(CancellationToken cancellationToken);
    public abstract virtual Task`1<MimeEntity> ParseEntityAsync(CancellationToken cancellationToken);
    public abstract virtual MimeMessage ParseMessage(CancellationToken cancellationToken);
    public abstract virtual Task`1<MimeMessage> ParseMessageAsync(CancellationToken cancellationToken);
}
public interface MimeKit.IMimePart {
    public string ContentDescription { get; public set; }
    public Nullable`1<int> ContentDuration { get; public set; }
    public string ContentMd5 { get; public set; }
    public ContentEncoding ContentTransferEncoding { get; public set; }
    public string FileName { get; public set; }
    public IMimeContent Content { get; public set; }
    public abstract virtual string get_ContentDescription();
    public abstract virtual void set_ContentDescription(string value);
    public abstract virtual Nullable`1<int> get_ContentDuration();
    public abstract virtual void set_ContentDuration(Nullable`1<int> value);
    public abstract virtual string get_ContentMd5();
    public abstract virtual void set_ContentMd5(string value);
    public abstract virtual ContentEncoding get_ContentTransferEncoding();
    public abstract virtual void set_ContentTransferEncoding(ContentEncoding value);
    public abstract virtual string get_FileName();
    public abstract virtual void set_FileName(string value);
    public abstract virtual IMimeContent get_Content();
    public abstract virtual void set_Content(IMimeContent value);
    public abstract virtual ContentEncoding GetBestEncoding(EncodingConstraint constraint, CancellationToken cancellationToken);
    public abstract virtual ContentEncoding GetBestEncoding(EncodingConstraint constraint, int maxLineLength, CancellationToken cancellationToken);
    public abstract virtual string ComputeContentMd5();
    public abstract virtual bool VerifyContentMd5();
}
public interface MimeKit.IMultipart {
    public string Boundary { get; public set; }
    public string Preamble { get; public set; }
    public string Epilogue { get; public set; }
    public abstract virtual string get_Boundary();
    public abstract virtual void set_Boundary(string value);
    public abstract virtual string get_Preamble();
    public abstract virtual void set_Preamble(string value);
    public abstract virtual string get_Epilogue();
    public abstract virtual void set_Epilogue(string value);
}
public interface MimeKit.IMultipartAlternative {
    public string TextBody { get; }
    public string HtmlBody { get; }
    public abstract virtual string get_TextBody();
    public abstract virtual string get_HtmlBody();
    public abstract virtual string GetTextBody(TextFormat format);
}
public interface MimeKit.IMultipartRelated {
    public MimeEntity Root { get; public set; }
    public abstract virtual MimeEntity get_Root();
    public abstract virtual void set_Root(MimeEntity value);
    public abstract virtual bool Contains(Uri uri);
    public abstract virtual int IndexOf(Uri uri);
    public abstract virtual Stream Open(Uri uri, String& mimeType, String& charset);
    public abstract virtual Stream Open(Uri uri);
}
public interface MimeKit.IMultipartReport {
    public string ReportType { get; public set; }
    public abstract virtual string get_ReportType();
    public abstract virtual void set_ReportType(string value);
}
[TypeConverterAttribute("MimeKit.InternetAddressConverter")]
public abstract class MimeKit.InternetAddress : object {
    private static string AtomSpecials;
    private Encoding encoding;
    private string name;
    [CompilerGeneratedAttribute]
private EventHandler Changed;
    public Encoding Encoding { get; public set; }
    public string Name { get; public set; }
    private static ReadOnlySpan`1<byte> CommaGreaterThanOrSemiColon { get; }
    protected InternetAddress(Encoding encoding, string name);
    public Encoding get_Encoding();
    public void set_Encoding(Encoding value);
    public string get_Name();
    public void set_Name(string value);
    public abstract virtual InternetAddress Clone();
    public sealed virtual int CompareTo(InternetAddress other);
    public abstract virtual bool Equals(InternetAddress other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    internal static string EncodeInternationalizedPhrase(string phrase);
    internal abstract virtual void Encode(FormatOptions options, StringBuilder builder, bool firstToken, Int32& lineLength);
    public abstract virtual string ToString(FormatOptions options, bool encode);
    public string ToString(bool encode);
    public virtual string ToString();
    [CompilerGeneratedAttribute]
internal void add_Changed(EventHandler value);
    [CompilerGeneratedAttribute]
internal void remove_Changed(EventHandler value);
    protected virtual void OnChanged();
    internal static bool TryParseLocalPart(Byte[] text, Int32& index, int endIndex, RfcComplianceMode compliance, bool skipTrailingCfws, bool throwOnError, String& localpart);
    private static ReadOnlySpan`1<byte> get_CommaGreaterThanOrSemiColon();
    internal static bool TryParseAddrspec(Byte[] text, Int32& index, int endIndex, ReadOnlySpan`1<byte> sentinels, RfcComplianceMode compliance, bool throwOnError, String& addrspec, Int32& at);
    internal static bool TryParseMailbox(ParserOptions options, Byte[] text, int startIndex, Int32& index, int endIndex, string name, int codepage, bool throwOnError, InternetAddress& address);
    private static bool TryParseGroup(AddressParserFlags flags, ParserOptions options, Byte[] text, int startIndex, Int32& index, int endIndex, int groupDepth, string name, int codepage, InternetAddress& address);
    internal static bool TryParse(AddressParserFlags flags, ParserOptions options, Byte[] text, Int32& index, int endIndex, int groupDepth, InternetAddress& address);
    public static bool TryParse(ParserOptions options, Byte[] buffer, int startIndex, int length, InternetAddress& address);
    public static bool TryParse(Byte[] buffer, int startIndex, int length, InternetAddress& address);
    public static bool TryParse(ParserOptions options, Byte[] buffer, int startIndex, InternetAddress& address);
    public static bool TryParse(Byte[] buffer, int startIndex, InternetAddress& address);
    public static bool TryParse(ParserOptions options, Byte[] buffer, InternetAddress& address);
    public static bool TryParse(Byte[] buffer, InternetAddress& address);
    public static bool TryParse(ParserOptions options, string text, InternetAddress& address);
    public static bool TryParse(string text, InternetAddress& address);
    public static InternetAddress Parse(ParserOptions options, Byte[] buffer, int startIndex, int length);
    public static InternetAddress Parse(Byte[] buffer, int startIndex, int length);
    public static InternetAddress Parse(ParserOptions options, Byte[] buffer, int startIndex);
    public static InternetAddress Parse(Byte[] buffer, int startIndex);
    public static InternetAddress Parse(ParserOptions options, Byte[] buffer);
    public static InternetAddress Parse(Byte[] buffer);
    public static InternetAddress Parse(ParserOptions options, string text);
    public static InternetAddress Parse(string text);
}
public class MimeKit.InternetAddressConverter : TypeConverter {
    private static ParserOptions Options;
    public static void Register(ParserOptions options);
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
    public virtual bool IsValid(ITypeDescriptorContext context, object value);
}
[DefaultMemberAttribute("Item")]
[TypeConverterAttribute("MimeKit.InternetAddressListConverter")]
public class MimeKit.InternetAddressList : object {
    private List`1<InternetAddress> list;
    [CompilerGeneratedAttribute]
private EventHandler Changed;
    public IEnumerable`1<MailboxAddress> Mailboxes { get; }
    public InternetAddress Item { get; public set; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public InternetAddressList(IEnumerable`1<InternetAddress> addresses);
    [IteratorStateMachineAttribute("MimeKit.InternetAddressList/<get_Mailboxes>d__4")]
public IEnumerable`1<MailboxAddress> get_Mailboxes();
    public sealed virtual int IndexOf(InternetAddress address);
    public sealed virtual void Insert(int index, InternetAddress address);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual InternetAddress get_Item(int index);
    public sealed virtual void set_Item(int index, InternetAddress value);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual void Add(InternetAddress address);
    public void AddRange(IEnumerable`1<InternetAddress> addresses);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(InternetAddress address);
    public sealed virtual void CopyTo(InternetAddress[] array, int arrayIndex);
    public sealed virtual bool Remove(InternetAddress address);
    public sealed virtual IEnumerator`1<InternetAddress> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual bool Equals(InternetAddressList other);
    public sealed virtual int CompareTo(InternetAddressList other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    internal void Encode(FormatOptions options, StringBuilder builder, bool firstToken, Int32& lineLength);
    public string ToString(FormatOptions options, bool encode);
    public string ToString(bool encode);
    public virtual string ToString();
    [CompilerGeneratedAttribute]
internal void add_Changed(EventHandler value);
    [CompilerGeneratedAttribute]
internal void remove_Changed(EventHandler value);
    private void OnChanged();
    private void AddressChanged(object sender, EventArgs e);
    internal static bool TryParse(AddressParserFlags flags, ParserOptions options, Byte[] text, Int32& index, int endIndex, bool isGroup, int groupDepth, List`1& addresses);
    public static bool TryParse(ParserOptions options, Byte[] buffer, int startIndex, int length, InternetAddressList& addresses);
    public static bool TryParse(Byte[] buffer, int startIndex, int length, InternetAddressList& addresses);
    public static bool TryParse(ParserOptions options, Byte[] buffer, int startIndex, InternetAddressList& addresses);
    public static bool TryParse(Byte[] buffer, int startIndex, InternetAddressList& addresses);
    public static bool TryParse(ParserOptions options, Byte[] buffer, InternetAddressList& addresses);
    public static bool TryParse(Byte[] buffer, InternetAddressList& addresses);
    public static bool TryParse(ParserOptions options, string text, InternetAddressList& addresses);
    public static bool TryParse(string text, InternetAddressList& addresses);
    public static InternetAddressList Parse(ParserOptions options, Byte[] buffer, int startIndex, int length);
    public static InternetAddressList Parse(Byte[] buffer, int startIndex, int length);
    public static InternetAddressList Parse(ParserOptions options, Byte[] buffer, int startIndex);
    public static InternetAddressList Parse(Byte[] buffer, int startIndex);
    public static InternetAddressList Parse(ParserOptions options, Byte[] buffer);
    public static InternetAddressList Parse(Byte[] buffer);
    public static InternetAddressList Parse(ParserOptions options, string text);
    public static InternetAddressList Parse(string text);
    public static MailAddressCollection op_Explicit(InternetAddressList addresses);
    public static InternetAddressList op_Explicit(MailAddressCollection addresses);
}
public class MimeKit.InternetAddressListConverter : TypeConverter {
    private static ParserOptions Options;
    public static void Register(ParserOptions options);
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
    public virtual bool IsValid(ITypeDescriptorContext context, object value);
}
public class MimeKit.IO.BoundStream : Stream {
    private long position;
    private bool disposed;
    private bool eos;
    [CompilerGeneratedAttribute]
private Stream <BaseStream>k__BackingField;
    [CompilerGeneratedAttribute]
private long <StartBoundary>k__BackingField;
    [CompilerGeneratedAttribute]
private long <EndBoundary>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <LeaveOpen>k__BackingField;
    public Stream BaseStream { get; private set; }
    public long StartBoundary { get; private set; }
    public long EndBoundary { get; private set; }
    protected bool LeaveOpen { get; private set; }
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public bool CanSeek { get; }
    public bool CanTimeout { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public int ReadTimeout { get; public set; }
    public int WriteTimeout { get; public set; }
    public BoundStream(Stream baseStream, long startBoundary, long endBoundary, bool leaveOpen);
    [CompilerGeneratedAttribute]
public Stream get_BaseStream();
    [CompilerGeneratedAttribute]
private void set_BaseStream(Stream value);
    [CompilerGeneratedAttribute]
public long get_StartBoundary();
    [CompilerGeneratedAttribute]
private void set_StartBoundary(long value);
    [CompilerGeneratedAttribute]
public long get_EndBoundary();
    [CompilerGeneratedAttribute]
private void set_EndBoundary(long value);
    [CompilerGeneratedAttribute]
protected bool get_LeaveOpen();
    [CompilerGeneratedAttribute]
private void set_LeaveOpen(bool value);
    private void CheckDisposed();
    private void CheckCanSeek();
    private void CheckCanRead();
    private void CheckCanWrite();
    public virtual bool get_CanRead();
    public virtual bool get_CanWrite();
    public virtual bool get_CanSeek();
    public virtual bool get_CanTimeout();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual int get_ReadTimeout();
    public virtual void set_ReadTimeout(int value);
    public virtual int get_WriteTimeout();
    public virtual void set_WriteTimeout(int value);
    private static void ValidateArguments(Byte[] buffer, int offset, int count);
    public virtual int Read(Byte[] buffer, int offset, int count);
    [AsyncStateMachineAttribute("MimeKit.IO.BoundStream/<ReadAsync>d__45")]
public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual void Write(Byte[] buffer, int offset, int count);
    [AsyncStateMachineAttribute("MimeKit.IO.BoundStream/<WriteAsync>d__47")]
public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void Flush();
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    public virtual void SetLength(long value);
    protected virtual void Dispose(bool disposing);
}
public class MimeKit.IO.ChainedStream : Stream {
    private List`1<Stream> streams;
    private List`1<bool> leaveOpen;
    private long position;
    private bool disposed;
    private int current;
    private bool eos;
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public bool CanSeek { get; }
    public bool CanTimeout { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public void Add(Stream stream, bool leaveOpen);
    private void CheckDisposed();
    private void CheckCanSeek();
    private void CheckCanRead();
    private void CheckCanWrite();
    public virtual bool get_CanRead();
    public virtual bool get_CanWrite();
    public virtual bool get_CanSeek();
    public virtual bool get_CanTimeout();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    private static void ValidateArguments(Byte[] buffer, int offset, int count);
    public virtual int Read(Byte[] buffer, int offset, int count);
    [AsyncStateMachineAttribute("MimeKit.IO.ChainedStream/<ReadAsync>d__27")]
public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual void Write(Byte[] buffer, int offset, int count);
    [AsyncStateMachineAttribute("MimeKit.IO.ChainedStream/<WriteAsync>d__29")]
public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void Flush();
    [AsyncStateMachineAttribute("MimeKit.IO.ChainedStream/<FlushAsync>d__32")]
public virtual Task FlushAsync(CancellationToken cancellationToken);
    public virtual void SetLength(long value);
    protected virtual void Dispose(bool disposing);
}
public class MimeKit.IO.FilteredStream : Stream {
    private static int ReadBufferSize;
    private List`1<IMimeFilter> filters;
    private IOOperation lastOp;
    private int filteredLength;
    private int filteredIndex;
    private Byte[] filtered;
    private Byte[] readbuf;
    private bool disposed;
    private bool flushed;
    [CompilerGeneratedAttribute]
private Stream <Source>k__BackingField;
    public Stream Source { get; private set; }
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public bool CanSeek { get; }
    public bool CanTimeout { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public int ReadTimeout { get; public set; }
    public int WriteTimeout { get; public set; }
    public FilteredStream(Stream source);
    [CompilerGeneratedAttribute]
public Stream get_Source();
    [CompilerGeneratedAttribute]
private void set_Source(Stream value);
    public void Add(IMimeFilter filter);
    public bool Contains(IMimeFilter filter);
    public bool Remove(IMimeFilter filter);
    private void CheckDisposed();
    private void CheckCanRead();
    private void CheckCanWrite();
    public virtual bool get_CanRead();
    public virtual bool get_CanWrite();
    public virtual bool get_CanSeek();
    public virtual bool get_CanTimeout();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual int get_ReadTimeout();
    public virtual void set_ReadTimeout(int value);
    public virtual int get_WriteTimeout();
    public virtual void set_WriteTimeout(int value);
    private static void ValidateArguments(Byte[] buffer, int offset, int count);
    public sealed virtual int Read(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual int Read(Byte[] buffer, int offset, int count);
    [AsyncStateMachineAttribute("MimeKit.IO.FilteredStream/<ReadAsync>d__43")]
public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public sealed virtual void Write(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual long Seek(long offset, SeekOrigin origin);
    public sealed virtual void Flush(CancellationToken cancellationToken);
    public virtual void Flush();
    [AsyncStateMachineAttribute("MimeKit.IO.FilteredStream/<FlushAsync>d__50")]
public virtual Task FlushAsync(CancellationToken cancellationToken);
    public virtual void SetLength(long value);
    protected virtual void Dispose(bool disposing);
}
public class MimeKit.IO.Filters.ArmoredFromFilter : MimeFilterBase {
    private bool midline;
    private static ReadOnlySpan`1<byte> From { get; }
    private static ReadOnlySpan`1<byte> get_From();
    private static bool StartsWithFrom(Byte[] input, int startIndex, int endIndex);
    protected virtual Byte[] Filter(Byte[] input, int startIndex, int length, Int32& outputIndex, Int32& outputLength, bool flush);
    public virtual void Reset();
}
public class MimeKit.IO.Filters.BestEncodingFilter : object {
    private Byte[] marker;
    private int maxline;
    private int linelen;
    private int count0;
    private int count8;
    private int markerLength;
    private bool hasMarker;
    private int total;
    private byte pc;
    public ContentEncoding GetBestEncoding(EncodingConstraint constraint, int maxLineLength);
    private static bool IsMboxMarker(Byte[] marker);
    private void Scan(Byte* inptr, Byte* inend);
    private static void ValidateArguments(Byte[] input, int startIndex, int length);
    public sealed virtual Byte[] Filter(Byte[] input, int startIndex, int length, Int32& outputIndex, Int32& outputLength);
    public sealed virtual Byte[] Flush(Byte[] input, int startIndex, int length, Int32& outputIndex, Int32& outputLength);
    public sealed virtual void Reset();
}
public class MimeKit.IO.Filters.CharsetFilter : MimeFilterBase {
    private Char[] chars;
    private Decoder decoder;
    private Encoder encoder;
    [CompilerGeneratedAttribute]
private Encoding <SourceEncoding>k__BackingField;
    [CompilerGeneratedAttribute]
private Encoding <TargetEncoding>k__BackingField;
    public Encoding SourceEncoding { get; private set; }
    public Encoding TargetEncoding { get; private set; }
    public CharsetFilter(string sourceEncodingName, string targetEncodingName);
    public CharsetFilter(int sourceCodePage, int targetCodePage);
    public CharsetFilter(Encoding sourceEncoding, Encoding targetEncoding);
    private static Encoding GetEncoding(string paramName, string encodingName);
    [CompilerGeneratedAttribute]
public Encoding get_SourceEncoding();
    [CompilerGeneratedAttribute]
private void set_SourceEncoding(Encoding value);
    [CompilerGeneratedAttribute]
public Encoding get_TargetEncoding();
    [CompilerGeneratedAttribute]
private void set_TargetEncoding(Encoding value);
    protected virtual Byte[] Filter(Byte[] input, int startIndex, int length, Int32& outputIndex, Int32& outputLength, bool flush);
    public virtual void Reset();
}
public class MimeKit.IO.Filters.DecoderFilter : MimeFilterBase {
    [CompilerGeneratedAttribute]
private IMimeDecoder <Decoder>k__BackingField;
    public IMimeDecoder Decoder { get; private set; }
    public ContentEncoding Encoding { get; }
    public DecoderFilter(IMimeDecoder decoder);
    [CompilerGeneratedAttribute]
public IMimeDecoder get_Decoder();
    [CompilerGeneratedAttribute]
private void set_Decoder(IMimeDecoder value);
    public ContentEncoding get_Encoding();
    public static IMimeFilter Create(ContentEncoding encoding);
    public static IMimeFilter Create(string name);
    protected virtual Byte[] Filter(Byte[] input, int startIndex, int length, Int32& outputIndex, Int32& outputLength, bool flush);
    public virtual void Reset();
}
public class MimeKit.IO.Filters.Dos2UnixFilter : MimeFilterBase {
    private bool ensureNewLine;
    private byte pc;
    public Dos2UnixFilter(bool ensureNewLine);
    private int Filter(ReadOnlySpan`1<byte> input, Byte[] output, bool flush);
    protected virtual Byte[] Filter(Byte[] input, int startIndex, int length, Int32& outputIndex, Int32& outputLength, bool flush);
    public virtual void Reset();
}
public class MimeKit.IO.Filters.EncoderFilter : MimeFilterBase {
    [CompilerGeneratedAttribute]
private IMimeEncoder <Encoder>k__BackingField;
    public IMimeEncoder Encoder { get; private set; }
    public ContentEncoding Encoding { get; }
    public EncoderFilter(IMimeEncoder encoder);
    [CompilerGeneratedAttribute]
public IMimeEncoder get_Encoder();
    [CompilerGeneratedAttribute]
private void set_Encoder(IMimeEncoder value);
    public ContentEncoding get_Encoding();
    public static IMimeFilter Create(ContentEncoding encoding, int maxLineLength);
    public static IMimeFilter Create(string name, int maxLineLength);
    protected virtual Byte[] Filter(Byte[] input, int startIndex, int length, Int32& outputIndex, Int32& outputLength, bool flush);
    public virtual void Reset();
}
public interface MimeKit.IO.Filters.IMimeFilter {
    public abstract virtual Byte[] Filter(Byte[] input, int startIndex, int length, Int32& outputIndex, Int32& outputLength);
    public abstract virtual Byte[] Flush(Byte[] input, int startIndex, int length, Int32& outputIndex, Int32& outputLength);
    public abstract virtual void Reset();
}
public class MimeKit.IO.Filters.MboxFromFilter : MimeFilterBase {
    private bool midline;
    private static ReadOnlySpan`1<byte> From { get; }
    private static ReadOnlySpan`1<byte> get_From();
    private static bool StartsWithFrom(Byte[] input, int startIndex, int endIndex);
    protected virtual Byte[] Filter(Byte[] input, int startIndex, int length, Int32& outputIndex, Int32& outputLength, bool flush);
    public virtual void Reset();
}
public abstract class MimeKit.IO.Filters.MimeFilterBase : object {
    private int preloadLength;
    private Byte[] preload;
    private Byte[] output;
    private Byte[] inbuf;
    protected Byte[] OutputBuffer { get; }
    protected Byte[] get_OutputBuffer();
    protected abstract virtual Byte[] Filter(Byte[] input, int startIndex, int length, Int32& outputIndex, Int32& outputLength, bool flush);
    private static int GetIdealBufferSize(int need);
    private Byte[] PreFilter(Byte[] input, Int32& startIndex, Int32& length);
    private static void ValidateArguments(Byte[] input, int startIndex, int length);
    public sealed virtual Byte[] Filter(Byte[] input, int startIndex, int length, Int32& outputIndex, Int32& outputLength);
    public sealed virtual Byte[] Flush(Byte[] input, int startIndex, int length, Int32& outputIndex, Int32& outputLength);
    public virtual void Reset();
    protected void SaveRemainingInput(Byte[] input, int startIndex, int length);
    protected void EnsureOutputSize(int size, bool keep);
}
public class MimeKit.IO.Filters.PassThroughFilter : object {
    public sealed virtual Byte[] Filter(Byte[] input, int startIndex, int length, Int32& outputIndex, Int32& outputLength);
    public sealed virtual Byte[] Flush(Byte[] input, int startIndex, int length, Int32& outputIndex, Int32& outputLength);
    public sealed virtual void Reset();
}
public class MimeKit.IO.Filters.TrailingWhitespaceFilter : MimeFilterBase {
    private PackedByteArray lwsp;
    private int Filter(ReadOnlySpan`1<byte> input, Byte[] output);
    protected virtual Byte[] Filter(Byte[] input, int startIndex, int length, Int32& outputIndex, Int32& outputLength, bool flush);
    public virtual void Reset();
}
public class MimeKit.IO.Filters.Unix2DosFilter : MimeFilterBase {
    private bool ensureNewLine;
    private byte pc;
    public Unix2DosFilter(bool ensureNewLine);
    private int Filter(ReadOnlySpan`1<byte> input, Byte[] output, bool flush);
    protected virtual Byte[] Filter(Byte[] input, int startIndex, int length, Int32& outputIndex, Int32& outputLength, bool flush);
    public virtual void Reset();
}
public interface MimeKit.IO.ICancellableStream {
    public abstract virtual int Read(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public abstract virtual void Write(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public abstract virtual void Flush(CancellationToken cancellationToken);
}
public class MimeKit.IO.MeasuringStream : Stream {
    private bool disposed;
    private long position;
    private long length;
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public bool CanSeek { get; }
    public bool CanTimeout { get; }
    public long Length { get; }
    public long Position { get; public set; }
    private void CheckDisposed();
    public virtual bool get_CanRead();
    public virtual bool get_CanWrite();
    public virtual bool get_CanSeek();
    public virtual bool get_CanTimeout();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    private static void ValidateArguments(Byte[] buffer, int offset, int count);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void Flush();
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    public virtual void SetLength(long value);
    protected virtual void Dispose(bool disposing);
}
public class MimeKit.IO.MemoryBlockStream : Stream {
    private static long MaxCapacity;
    private static long BlockSize;
    private static BufferPool DefaultPool;
    private List`1<Byte[]> blocks;
    private BufferPool pool;
    private Task`1<int> lastReadTask;
    private long position;
    private long length;
    private bool disposed;
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public bool CanSeek { get; }
    public bool CanTimeout { get; }
    public long Length { get; }
    public long Position { get; public set; }
    private static MemoryBlockStream();
    public Byte[] ToArray();
    private void CheckDisposed();
    public virtual bool get_CanRead();
    public virtual bool get_CanWrite();
    public virtual bool get_CanSeek();
    public virtual bool get_CanTimeout();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    private static void ValidateArguments(Byte[] buffer, int offset, int count);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void Flush();
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    public virtual void SetLength(long value);
    protected virtual void Dispose(bool disposing);
}
public interface MimeKit.ITextPart {
    public TextFormat Format { get; }
    public bool IsEnriched { get; }
    public bool IsFlowed { get; }
    public bool IsHtml { get; }
    public bool IsPlain { get; }
    public bool IsRichText { get; }
    public string Text { get; public set; }
    public abstract virtual TextFormat get_Format();
    public abstract virtual bool get_IsEnriched();
    public abstract virtual bool get_IsFlowed();
    public abstract virtual bool get_IsHtml();
    public abstract virtual bool get_IsPlain();
    public abstract virtual bool get_IsRichText();
    public abstract virtual string get_Text();
    public abstract virtual void set_Text(string value);
    public abstract virtual bool TryDetectEncoding(Encoding& encoding, TextEncodingConfidence& confidence);
    public abstract virtual string GetText(Encoding& encoding);
    public abstract virtual string GetText(Encoding encoding);
    public abstract virtual string GetText(string charset);
    public abstract virtual void SetText(Encoding encoding, string text);
    public abstract virtual void SetText(string charset, string text);
}
public interface MimeKit.ITextRfc822Headers {
}
public class MimeKit.MailboxAddress : InternetAddress {
    private static Byte[] EmptySentinels;
    [CompilerGeneratedAttribute]
private static IPunycode <IdnMapping>k__BackingField;
    private string address;
    private int at;
    [CompilerGeneratedAttribute]
private DomainList <Route>k__BackingField;
    public static IPunycode IdnMapping { get; public set; }
    public DomainList Route { get; private set; }
    public string Address { get; public set; }
    public string LocalPart { get; }
    public string Domain { get; }
    public bool IsInternational { get; }
    private static MailboxAddress();
    internal MailboxAddress(Encoding encoding, string name, IEnumerable`1<string> route, string address, int at);
    internal MailboxAddress(Encoding encoding, string name, string address, int at);
    public MailboxAddress(Encoding encoding, string name, IEnumerable`1<string> route, string address);
    public MailboxAddress(string name, IEnumerable`1<string> route, string address);
    public MailboxAddress(Encoding encoding, string name, string address);
    public MailboxAddress(string name, string address);
    [CompilerGeneratedAttribute]
public static IPunycode get_IdnMapping();
    [CompilerGeneratedAttribute]
public static void set_IdnMapping(IPunycode value);
    public virtual InternetAddress Clone();
    [CompilerGeneratedAttribute]
public DomainList get_Route();
    [CompilerGeneratedAttribute]
private void set_Route(DomainList value);
    public string get_Address();
    public void set_Address(string value);
    public string get_LocalPart();
    public string get_Domain();
    public bool get_IsInternational();
    private static string EncodeAddrspec(string addrspec, int at);
    public static string EncodeAddrspec(string addrspec);
    public static string DecodeAddrspec(string addrspec);
    public string GetAddress(bool idnEncode);
    internal virtual void Encode(FormatOptions options, StringBuilder builder, bool firstToken, Int32& lineLength);
    public virtual string ToString(FormatOptions options, bool encode);
    public virtual bool Equals(InternetAddress other);
    private void RouteChanged(object sender, EventArgs e);
    internal static bool TryParse(ParserOptions options, Byte[] text, Int32& index, int endIndex, bool throwOnError, MailboxAddress& mailbox);
    public static bool TryParse(ParserOptions options, Byte[] buffer, int startIndex, int length, MailboxAddress& mailbox);
    public static bool TryParse(Byte[] buffer, int startIndex, int length, MailboxAddress& mailbox);
    public static bool TryParse(ParserOptions options, Byte[] buffer, int startIndex, MailboxAddress& mailbox);
    public static bool TryParse(Byte[] buffer, int startIndex, MailboxAddress& mailbox);
    public static bool TryParse(ParserOptions options, Byte[] buffer, MailboxAddress& mailbox);
    public static bool TryParse(Byte[] buffer, MailboxAddress& mailbox);
    public static bool TryParse(ParserOptions options, string text, MailboxAddress& mailbox);
    public static bool TryParse(string text, MailboxAddress& mailbox);
    public static MailboxAddress Parse(ParserOptions options, Byte[] buffer, int startIndex, int length);
    public static MailboxAddress Parse(Byte[] buffer, int startIndex, int length);
    public static MailboxAddress Parse(ParserOptions options, Byte[] buffer, int startIndex);
    public static MailboxAddress Parse(Byte[] buffer, int startIndex);
    public static MailboxAddress Parse(ParserOptions options, Byte[] buffer);
    public static MailboxAddress Parse(Byte[] buffer);
    public static MailboxAddress Parse(ParserOptions options, string text);
    public static MailboxAddress Parse(string text);
    public static MailAddress op_Explicit(MailboxAddress mailbox);
    public static MailboxAddress op_Explicit(MailAddress address);
}
public class MimeKit.MessageDeliveryStatus : MimePart {
    private HeaderListCollection groups;
    public HeaderListCollection StatusGroups { get; }
    public MessageDeliveryStatus(MimeEntityConstructorArgs args);
    private void CheckDisposed();
    public sealed virtual HeaderListCollection get_StatusGroups();
    private void ParseStatusGroups();
    private void OnGroupsChanged(object sender, EventArgs e);
    public virtual void Accept(MimeVisitor visitor);
}
public class MimeKit.MessageDispositionNotification : MimePart {
    private HeaderList fields;
    public HeaderList Fields { get; }
    public MessageDispositionNotification(MimeEntityConstructorArgs args);
    private void CheckDisposed();
    public sealed virtual HeaderList get_Fields();
    private void OnFieldsChanged(object sender, HeaderListChangedEventArgs e);
    public virtual void Accept(MimeVisitor visitor);
}
public class MimeKit.MessageFeedbackReport : MimePart {
    private HeaderList fields;
    public HeaderList Fields { get; }
    public MessageFeedbackReport(MimeEntityConstructorArgs args);
    private void CheckDisposed();
    public sealed virtual HeaderList get_Fields();
    private void OnFieldsChanged(object sender, HeaderListChangedEventArgs e);
    public virtual void Accept(MimeVisitor visitor);
}
[DefaultMemberAttribute("Item")]
public class MimeKit.MessageIdList : object {
    private List`1<string> references;
    [CompilerGeneratedAttribute]
private EventHandler Changed;
    public string Item { get; public set; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public MessageIdList Clone();
    public sealed virtual int IndexOf(string messageId);
    private static string ValidateMessageId(string messageId);
    public sealed virtual void Insert(int index, string messageId);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual string get_Item(int index);
    public sealed virtual void set_Item(int index, string value);
    public sealed virtual void Add(string messageId);
    public void AddRange(IEnumerable`1<string> items);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(string messageId);
    public sealed virtual void CopyTo(String[] array, int arrayIndex);
    public sealed virtual bool Remove(string messageId);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual IEnumerator`1<string> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public virtual string ToString();
    [CompilerGeneratedAttribute]
internal void add_Changed(EventHandler value);
    [CompilerGeneratedAttribute]
internal void remove_Changed(EventHandler value);
    private void OnChanged();
}
public enum MimeKit.MessageImportance : Enum {
    public int value__;
    public static MessageImportance Low;
    public static MessageImportance Normal;
    public static MessageImportance High;
}
public class MimeKit.MessagePart : MimeEntity {
    [CompilerGeneratedAttribute]
private MimeMessage <Message>k__BackingField;
    public MimeMessage Message { get; public set; }
    public MessagePart(MimeEntityConstructorArgs args);
    public MessagePart(string subtype, Object[] args);
    protected MessagePart(string mediaType, string mediaSubtype);
    public MessagePart(string subtype);
    private void CheckDisposed();
    [CompilerGeneratedAttribute]
public sealed virtual MimeMessage get_Message();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Message(MimeMessage value);
    public virtual void Accept(MimeVisitor visitor);
    public virtual void Prepare(EncodingConstraint constraint, int maxLineLength);
    public virtual void WriteTo(FormatOptions options, Stream stream, bool contentOnly, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MimeKit.MessagePart/<WriteToAsync>d__13")]
public virtual Task WriteToAsync(FormatOptions options, Stream stream, bool contentOnly, CancellationToken cancellationToken);
    protected virtual void Dispose(bool disposing);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task <>n__0(FormatOptions options, Stream stream, bool contentOnly, CancellationToken cancellationToken);
}
public class MimeKit.MessagePartial : MimePart {
    public string Id { get; }
    public Nullable`1<int> Number { get; }
    public Nullable`1<int> Total { get; }
    public MessagePartial(MimeEntityConstructorArgs args);
    public MessagePartial(string id, int number, int total);
    private void CheckDisposed();
    public sealed virtual string get_Id();
    public sealed virtual Nullable`1<int> get_Number();
    public sealed virtual Nullable`1<int> get_Total();
    public virtual void Accept(MimeVisitor visitor);
    private static MimeMessage CloneMessage(MimeMessage message);
    [IteratorStateMachineAttribute("MimeKit.MessagePartial/<Split>d__11")]
public static IEnumerable`1<MimeMessage> Split(MimeMessage message, int maxSize);
    private static int PartialCompare(MessagePartial partial1, MessagePartial partial2);
    private static void CombineHeaders(MimeMessage message, MimeMessage joined);
    public static MimeMessage Join(ParserOptions options, MimeMessage message, IEnumerable`1<MessagePartial> partials);
    public static MimeMessage Join(MimeMessage message, IEnumerable`1<MessagePartial> partials);
}
public enum MimeKit.MessagePriority : Enum {
    public int value__;
    public static MessagePriority NonUrgent;
    public static MessagePriority Normal;
    public static MessagePriority Urgent;
}
public class MimeKit.MimeContent : object {
    private static int BufferLength;
    [CompilerGeneratedAttribute]
private ContentEncoding <Encoding>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<NewLineFormat> <NewLineFormat>k__BackingField;
    [CompilerGeneratedAttribute]
private Stream <Stream>k__BackingField;
    public ContentEncoding Encoding { get; private set; }
    public Nullable`1<NewLineFormat> NewLineFormat { get; public set; }
    public Stream Stream { get; private set; }
    public MimeContent(Stream stream, ContentEncoding encoding);
    protected virtual override void Finalize();
    private void CheckDisposed();
    [CompilerGeneratedAttribute]
public sealed virtual ContentEncoding get_Encoding();
    [CompilerGeneratedAttribute]
private void set_Encoding(ContentEncoding value);
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<NewLineFormat> get_NewLineFormat();
    [CompilerGeneratedAttribute]
public void set_NewLineFormat(Nullable`1<NewLineFormat> value);
    [CompilerGeneratedAttribute]
public sealed virtual Stream get_Stream();
    [CompilerGeneratedAttribute]
private void set_Stream(Stream value);
    public sealed virtual Stream Open();
    public sealed virtual void WriteTo(Stream stream, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MimeKit.MimeContent/<WriteToAsync>d__18")]
public sealed virtual Task WriteToAsync(Stream stream, CancellationToken cancellationToken);
    public sealed virtual void DecodeTo(Stream stream, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MimeKit.MimeContent/<DecodeToAsync>d__20")]
public sealed virtual Task DecodeToAsync(Stream stream, CancellationToken cancellationToken);
    protected virtual void Dispose(bool disposing);
    public sealed virtual void Dispose();
}
public abstract class MimeKit.MimeEntity : object {
    internal LazyLoadedFields LazyLoaded;
    internal bool EnsureNewLine;
    internal bool IsDisposed;
    private ContentDisposition disposition;
    private string contentId;
    private Uri location;
    private Uri baseUri;
    [CompilerGeneratedAttribute]
private HeaderList <Headers>k__BackingField;
    [CompilerGeneratedAttribute]
private ContentType <ContentType>k__BackingField;
    public HeaderList Headers { get; private set; }
    public ContentDisposition ContentDisposition { get; public set; }
    public ContentType ContentType { get; private set; }
    public Uri ContentBase { get; public set; }
    public Uri ContentLocation { get; public set; }
    public string ContentId { get; public set; }
    public bool IsAttachment { get; public set; }
    protected MimeEntity(MimeEntityConstructorArgs args);
    protected MimeEntity(string mediaType, string mediaSubtype);
    protected MimeEntity(ContentType contentType);
    protected virtual override void Finalize();
    internal void CheckDisposed(string objectName);
    private void CheckDisposed();
    protected bool TryInit(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual HeaderList get_Headers();
    [CompilerGeneratedAttribute]
private void set_Headers(HeaderList value);
    public sealed virtual ContentDisposition get_ContentDisposition();
    public sealed virtual void set_ContentDisposition(ContentDisposition value);
    [CompilerGeneratedAttribute]
public sealed virtual ContentType get_ContentType();
    [CompilerGeneratedAttribute]
private void set_ContentType(ContentType value);
    public sealed virtual Uri get_ContentBase();
    public sealed virtual void set_ContentBase(Uri value);
    public sealed virtual Uri get_ContentLocation();
    public sealed virtual void set_ContentLocation(Uri value);
    public sealed virtual string get_ContentId();
    public sealed virtual void set_ContentId(string value);
    public sealed virtual bool get_IsAttachment();
    public sealed virtual void set_IsAttachment(bool value);
    public virtual string ToString();
    public virtual void Accept(MimeVisitor visitor);
    public abstract virtual void Prepare(EncodingConstraint constraint, int maxLineLength);
    public virtual void WriteTo(FormatOptions options, Stream stream, bool contentOnly, CancellationToken cancellationToken);
    public virtual Task WriteToAsync(FormatOptions options, Stream stream, bool contentOnly, CancellationToken cancellationToken);
    public sealed virtual void WriteTo(FormatOptions options, Stream stream, CancellationToken cancellationToken);
    public sealed virtual Task WriteToAsync(FormatOptions options, Stream stream, CancellationToken cancellationToken);
    public sealed virtual void WriteTo(Stream stream, bool contentOnly, CancellationToken cancellationToken);
    public sealed virtual Task WriteToAsync(Stream stream, bool contentOnly, CancellationToken cancellationToken);
    public sealed virtual void WriteTo(Stream stream, CancellationToken cancellationToken);
    public sealed virtual Task WriteToAsync(Stream stream, CancellationToken cancellationToken);
    public sealed virtual void WriteTo(FormatOptions options, string fileName, bool contentOnly, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MimeKit.MimeEntity/<WriteToAsync>d__50")]
public sealed virtual Task WriteToAsync(FormatOptions options, string fileName, bool contentOnly, CancellationToken cancellationToken);
    public sealed virtual void WriteTo(FormatOptions options, string fileName, CancellationToken cancellationToken);
    public sealed virtual Task WriteToAsync(FormatOptions options, string fileName, CancellationToken cancellationToken);
    public sealed virtual void WriteTo(string fileName, bool contentOnly, CancellationToken cancellationToken);
    public sealed virtual Task WriteToAsync(string fileName, bool contentOnly, CancellationToken cancellationToken);
    public sealed virtual void WriteTo(string fileName, CancellationToken cancellationToken);
    public sealed virtual Task WriteToAsync(string fileName, CancellationToken cancellationToken);
    protected void RemoveHeader(string name);
    protected void SetHeader(string name, string value);
    protected void SetHeader(string name, Byte[] rawValue);
    private void SerializeContentDisposition();
    private void SerializeContentType();
    private void ContentDispositionChanged(object sender, EventArgs e);
    private void ContentTypeChanged(object sender, EventArgs e);
    protected virtual void OnHeadersChanged(HeaderListChangedAction action, Header header);
    private void HeadersChanged(object sender, HeaderListChangedEventArgs e);
    protected virtual void Dispose(bool disposing);
    public sealed virtual void Dispose();
    public static MimeEntity Load(ParserOptions options, Stream stream, bool persistent, CancellationToken cancellationToken);
    public static Task`1<MimeEntity> LoadAsync(ParserOptions options, Stream stream, bool persistent, CancellationToken cancellationToken);
    public static MimeEntity Load(ParserOptions options, Stream stream, CancellationToken cancellationToken);
    public static Task`1<MimeEntity> LoadAsync(ParserOptions options, Stream stream, CancellationToken cancellationToken);
    public static MimeEntity Load(Stream stream, bool persistent, CancellationToken cancellationToken);
    public static Task`1<MimeEntity> LoadAsync(Stream stream, bool persistent, CancellationToken cancellationToken);
    public static MimeEntity Load(Stream stream, CancellationToken cancellationToken);
    public static Task`1<MimeEntity> LoadAsync(Stream stream, CancellationToken cancellationToken);
    public static MimeEntity Load(ParserOptions options, string fileName, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MimeKit.MimeEntity/<LoadAsync>d__77")]
public static Task`1<MimeEntity> LoadAsync(ParserOptions options, string fileName, CancellationToken cancellationToken);
    public static MimeEntity Load(string fileName, CancellationToken cancellationToken);
    public static Task`1<MimeEntity> LoadAsync(string fileName, CancellationToken cancellationToken);
    public static MimeEntity Load(ParserOptions options, ContentType contentType, Stream content, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MimeKit.MimeEntity/<LoadAsync>d__81")]
public static Task`1<MimeEntity> LoadAsync(ParserOptions options, ContentType contentType, Stream content, CancellationToken cancellationToken);
    public static MimeEntity Load(ContentType contentType, Stream content, CancellationToken cancellationToken);
    public static Task`1<MimeEntity> LoadAsync(ContentType contentType, Stream content, CancellationToken cancellationToken);
}
public class MimeKit.MimeEntityBeginEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private MimeEntity <Entity>k__BackingField;
    [CompilerGeneratedAttribute]
private Multipart <Parent>k__BackingField;
    [CompilerGeneratedAttribute]
private long <BeginOffset>k__BackingField;
    [CompilerGeneratedAttribute]
private int <LineNumber>k__BackingField;
    public MimeEntity Entity { get; }
    public Multipart Parent { get; }
    public long BeginOffset { get; public set; }
    public int LineNumber { get; public set; }
    public MimeEntityBeginEventArgs(MimeEntity entity);
    public MimeEntityBeginEventArgs(MimeEntity entity, Multipart parent);
    [CompilerGeneratedAttribute]
public MimeEntity get_Entity();
    [CompilerGeneratedAttribute]
public Multipart get_Parent();
    [CompilerGeneratedAttribute]
public long get_BeginOffset();
    [CompilerGeneratedAttribute]
public void set_BeginOffset(long value);
    [CompilerGeneratedAttribute]
public int get_LineNumber();
    [CompilerGeneratedAttribute]
public void set_LineNumber(int value);
}
public class MimeKit.MimeEntityConstructorArgs : object {
    internal ParserOptions ParserOptions;
    internal IEnumerable`1<Header> Headers;
    internal ContentType ContentType;
    internal bool IsTopLevel;
    internal MimeEntityConstructorArgs(ParserOptions options, ContentType ctype, IEnumerable`1<Header> headers, bool toplevel);
}
public class MimeKit.MimeEntityEndEventArgs : MimeEntityBeginEventArgs {
    [CompilerGeneratedAttribute]
private long <HeadersEndOffset>k__BackingField;
    [CompilerGeneratedAttribute]
private long <EndOffset>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Lines>k__BackingField;
    public long HeadersEndOffset { get; public set; }
    public long EndOffset { get; public set; }
    public int Lines { get; public set; }
    public MimeEntityEndEventArgs(MimeEntity entity);
    public MimeEntityEndEventArgs(MimeEntity entity, Multipart parent);
    [CompilerGeneratedAttribute]
public long get_HeadersEndOffset();
    [CompilerGeneratedAttribute]
public void set_HeadersEndOffset(long value);
    [CompilerGeneratedAttribute]
public long get_EndOffset();
    [CompilerGeneratedAttribute]
public void set_EndOffset(long value);
    [CompilerGeneratedAttribute]
public int get_Lines();
    [CompilerGeneratedAttribute]
public void set_Lines(int value);
}
public enum MimeKit.MimeFormat : Enum {
    public byte value__;
    public static MimeFormat Entity;
    public static MimeFormat Mbox;
    public static MimeFormat Default;
}
public class MimeKit.MimeIterator : object {
    private Stack`1<MimeNode> stack;
    private List`1<int> path;
    private bool moveFirst;
    private MimeEntity current;
    private int index;
    [CompilerGeneratedAttribute]
private MimeMessage <Message>k__BackingField;
    public MimeMessage Message { get; private set; }
    public MimeEntity Parent { get; }
    public MimeEntity Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    public string PathSpecifier { get; }
    public int Depth { get; }
    public MimeIterator(MimeMessage message);
    protected virtual override void Finalize();
    [CompilerGeneratedAttribute]
public MimeMessage get_Message();
    [CompilerGeneratedAttribute]
private void set_Message(MimeMessage value);
    public MimeEntity get_Parent();
    public sealed virtual MimeEntity get_Current();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public string get_PathSpecifier();
    public int get_Depth();
    private void Push(MimeEntity entity);
    private bool Pop();
    public sealed virtual bool MoveNext();
    private static Int32[] Parse(string pathSpecifier);
    public bool MoveTo(string pathSpecifier);
    public sealed virtual void Reset();
    protected virtual void Dispose(bool disposing);
    public sealed virtual void Dispose();
}
public class MimeKit.MimeMessage : object {
    private static HeaderId[] StandardAddressHeaders;
    private Dictionary`2<HeaderId, InternetAddressList> addresses;
    private MessageImportance importance;
    private XMessagePriority xpriority;
    private MessagePriority priority;
    private RfcComplianceMode compliance;
    private MessageIdList references;
    private LazyLoadedFields lazyLoaded;
    private MailboxAddress resentSender;
    private DateTimeOffset resentDate;
    private string resentMessageId;
    private MailboxAddress sender;
    private DateTimeOffset date;
    private string messageId;
    private string inreplyto;
    private Version version;
    [CompilerGeneratedAttribute]
private Byte[] <MboxMarker>k__BackingField;
    [CompilerGeneratedAttribute]
private HeaderList <Headers>k__BackingField;
    [CompilerGeneratedAttribute]
private MimeEntity <Body>k__BackingField;
    internal Byte[] MboxMarker { get; internal set; }
    public HeaderList Headers { get; private set; }
    public MessageImportance Importance { get; public set; }
    public MessagePriority Priority { get; public set; }
    public XMessagePriority XPriority { get; public set; }
    public MailboxAddress Sender { get; public set; }
    public MailboxAddress ResentSender { get; public set; }
    public InternetAddressList From { get; }
    public InternetAddressList ResentFrom { get; }
    public InternetAddressList ReplyTo { get; }
    public InternetAddressList ResentReplyTo { get; }
    public InternetAddressList To { get; }
    public InternetAddressList ResentTo { get; }
    public InternetAddressList Cc { get; }
    public InternetAddressList ResentCc { get; }
    public InternetAddressList Bcc { get; }
    public InternetAddressList ResentBcc { get; }
    public string Subject { get; public set; }
    public DateTimeOffset Date { get; public set; }
    public DateTimeOffset ResentDate { get; public set; }
    public MessageIdList References { get; }
    public string InReplyTo { get; public set; }
    public string MessageId { get; public set; }
    public string ResentMessageId { get; public set; }
    public Version MimeVersion { get; public set; }
    public MimeEntity Body { get; public set; }
    public string TextBody { get; }
    public string HtmlBody { get; }
    public IEnumerable`1<MimeEntity> BodyParts { get; }
    public IEnumerable`1<MimeEntity> Attachments { get; }
    internal MimeMessage(ParserOptions options, IEnumerable`1<Header> headers, RfcComplianceMode mode);
    internal MimeMessage(ParserOptions options);
    public MimeMessage(Object[] args);
    public MimeMessage(IEnumerable`1<InternetAddress> from, IEnumerable`1<InternetAddress> to, string subject, MimeEntity body);
    private static MimeMessage();
    protected virtual override void Finalize();
    [CompilerGeneratedAttribute]
internal Byte[] get_MboxMarker();
    [CompilerGeneratedAttribute]
internal void set_MboxMarker(Byte[] value);
    [CompilerGeneratedAttribute]
public sealed virtual HeaderList get_Headers();
    [CompilerGeneratedAttribute]
private void set_Headers(HeaderList value);
    public sealed virtual MessageImportance get_Importance();
    public sealed virtual void set_Importance(MessageImportance value);
    public sealed virtual MessagePriority get_Priority();
    public sealed virtual void set_Priority(MessagePriority value);
    public sealed virtual XMessagePriority get_XPriority();
    public sealed virtual void set_XPriority(XMessagePriority value);
    public sealed virtual MailboxAddress get_Sender();
    public sealed virtual void set_Sender(MailboxAddress value);
    public sealed virtual MailboxAddress get_ResentSender();
    public sealed virtual void set_ResentSender(MailboxAddress value);
    private InternetAddressList GetLazyLoadedAddresses(HeaderId id, LazyLoadedFields bit);
    public sealed virtual InternetAddressList get_From();
    public sealed virtual InternetAddressList get_ResentFrom();
    public sealed virtual InternetAddressList get_ReplyTo();
    public sealed virtual InternetAddressList get_ResentReplyTo();
    public sealed virtual InternetAddressList get_To();
    public sealed virtual InternetAddressList get_ResentTo();
    public sealed virtual InternetAddressList get_Cc();
    public sealed virtual InternetAddressList get_ResentCc();
    public sealed virtual InternetAddressList get_Bcc();
    public sealed virtual InternetAddressList get_ResentBcc();
    public sealed virtual string get_Subject();
    public sealed virtual void set_Subject(string value);
    public sealed virtual DateTimeOffset get_Date();
    public sealed virtual void set_Date(DateTimeOffset value);
    public sealed virtual DateTimeOffset get_ResentDate();
    public sealed virtual void set_ResentDate(DateTimeOffset value);
    public sealed virtual MessageIdList get_References();
    public sealed virtual string get_InReplyTo();
    public sealed virtual void set_InReplyTo(string value);
    public sealed virtual string get_MessageId();
    public sealed virtual void set_MessageId(string value);
    public sealed virtual string get_ResentMessageId();
    public sealed virtual void set_ResentMessageId(string value);
    public sealed virtual Version get_MimeVersion();
    public sealed virtual void set_MimeVersion(Version value);
    [CompilerGeneratedAttribute]
public sealed virtual MimeEntity get_Body();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Body(MimeEntity value);
    public sealed virtual string get_TextBody();
    public sealed virtual string get_HtmlBody();
    public sealed virtual string GetTextBody(TextFormat format);
    [IteratorStateMachineAttribute("MimeKit.MimeMessage/<EnumerateMimeParts>d__99")]
private static IEnumerable`1<MimeEntity> EnumerateMimeParts(MimeEntity entity);
    public sealed virtual IEnumerable`1<MimeEntity> get_BodyParts();
    public sealed virtual IEnumerable`1<MimeEntity> get_Attachments();
    private static void AddMailboxes(List`1<MailboxAddress> recipients, HashSet`1<string> unique, IEnumerable`1<MailboxAddress> mailboxes);
    private IList`1<MailboxAddress> GetMailboxes(bool includeSenders, bool onlyUnique);
    public IList`1<MailboxAddress> GetRecipients(bool onlyUnique);
    public virtual string ToString();
    public virtual void Accept(MimeVisitor visitor);
    public virtual void Prepare(EncodingConstraint constraint, int maxLineLength);
    public sealed virtual void WriteTo(FormatOptions options, Stream stream, bool headersOnly, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MimeKit.MimeMessage/<WriteToAsync>d__111")]
public sealed virtual Task WriteToAsync(FormatOptions options, Stream stream, bool headersOnly, CancellationToken cancellationToken);
    public sealed virtual void WriteTo(FormatOptions options, Stream stream, CancellationToken cancellationToken);
    public sealed virtual Task WriteToAsync(FormatOptions options, Stream stream, CancellationToken cancellationToken);
    public sealed virtual void WriteTo(Stream stream, bool headersOnly, CancellationToken cancellationToken);
    public sealed virtual Task WriteToAsync(Stream stream, bool headersOnly, CancellationToken cancellationToken);
    public sealed virtual void WriteTo(Stream stream, CancellationToken cancellationToken);
    public sealed virtual Task WriteToAsync(Stream stream, CancellationToken cancellationToken);
    public sealed virtual void WriteTo(FormatOptions options, string fileName, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MimeKit.MimeMessage/<WriteToAsync>d__119")]
public sealed virtual Task WriteToAsync(FormatOptions options, string fileName, CancellationToken cancellationToken);
    public sealed virtual void WriteTo(string fileName, CancellationToken cancellationToken);
    public sealed virtual Task WriteToAsync(string fileName, CancellationToken cancellationToken);
    private MailboxAddress GetMessageSigner();
    private IList`1<MailboxAddress> GetEncryptionRecipients();
    internal Byte[] HashBody(FormatOptions options, DkimSignatureAlgorithm signatureAlgorithm, DkimCanonicalizationAlgorithm bodyCanonicalizationAlgorithm, int maxLength);
    public void Sign(CryptographyContext ctx, DigestAlgorithm digestAlgo, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MimeKit.MimeMessage/<SignAsync>d__126")]
public Task SignAsync(CryptographyContext ctx, DigestAlgorithm digestAlgo, CancellationToken cancellationToken);
    public void Sign(CryptographyContext ctx, CancellationToken cancellationToken);
    public Task SignAsync(CryptographyContext ctx, CancellationToken cancellationToken);
    public void Encrypt(CryptographyContext ctx, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MimeKit.MimeMessage/<EncryptAsync>d__130")]
public Task EncryptAsync(CryptographyContext ctx, CancellationToken cancellationToken);
    public void SignAndEncrypt(CryptographyContext ctx, DigestAlgorithm digestAlgo, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MimeKit.MimeMessage/<SignAndEncryptAsync>d__132")]
public Task SignAndEncryptAsync(CryptographyContext ctx, DigestAlgorithm digestAlgo, CancellationToken cancellationToken);
    public void SignAndEncrypt(CryptographyContext ctx, CancellationToken cancellationToken);
    public Task SignAndEncryptAsync(CryptographyContext ctx, CancellationToken cancellationToken);
    [IteratorStateMachineAttribute("MimeKit.MimeMessage/<MergeHeaders>d__135")]
private IEnumerable`1<Header> MergeHeaders();
    private void RemoveHeader(HeaderId id);
    private void ReplaceHeader(HeaderId id, string name, Byte[] raw);
    private void SetHeader(string name, string value);
    private void SerializeAddressList(HeaderId id, InternetAddressList list);
    private void InternetAddressListChanged(object addrlist, EventArgs e);
    private void ReferencesChanged(object o, EventArgs e);
    private void AddAddresses(Header header, InternetAddressList list);
    private static LazyLoadedFields GetAddressListLazyLoadField(HeaderId id);
    private void HeadersChanged(object o, HeaderListChangedEventArgs e);
    protected virtual void Dispose(bool disposing);
    public sealed virtual void Dispose();
    public static MimeMessage Load(ParserOptions options, Stream stream, bool persistent, CancellationToken cancellationToken);
    public static Task`1<MimeMessage> LoadAsync(ParserOptions options, Stream stream, bool persistent, CancellationToken cancellationToken);
    public static MimeMessage Load(ParserOptions options, Stream stream, CancellationToken cancellationToken);
    public static Task`1<MimeMessage> LoadAsync(ParserOptions options, Stream stream, CancellationToken cancellationToken);
    public static MimeMessage Load(Stream stream, bool persistent, CancellationToken cancellationToken);
    public static Task`1<MimeMessage> LoadAsync(Stream stream, bool persistent, CancellationToken cancellationToken);
    public static MimeMessage Load(Stream stream, CancellationToken cancellationToken);
    public static Task`1<MimeMessage> LoadAsync(Stream stream, CancellationToken cancellationToken);
    public static MimeMessage Load(ParserOptions options, string fileName, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MimeKit.MimeMessage/<LoadAsync>d__156")]
public static Task`1<MimeMessage> LoadAsync(ParserOptions options, string fileName, CancellationToken cancellationToken);
    public static MimeMessage Load(string fileName, CancellationToken cancellationToken);
    public static Task`1<MimeMessage> LoadAsync(string fileName, CancellationToken cancellationToken);
    private static MimePart GetMimePart(AttachmentBase item);
    private static void AddLinkedResources(MultipartAlternative alternative, MimePart root, AlternateView view);
    private static MimeEntity AddAlternateViews(MimeEntity body, AlternateViewCollection alternateViews);
    public static MimeMessage CreateFromMailMessage(MailMessage message);
    public static MimeMessage op_Explicit(MailMessage message);
}
public class MimeKit.MimeMessageBeginEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private MimeMessage <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private MessagePart <Parent>k__BackingField;
    [CompilerGeneratedAttribute]
private long <BeginOffset>k__BackingField;
    [CompilerGeneratedAttribute]
private int <LineNumber>k__BackingField;
    public MimeMessage Message { get; }
    public MessagePart Parent { get; }
    public long BeginOffset { get; public set; }
    public int LineNumber { get; public set; }
    public MimeMessageBeginEventArgs(MimeMessage message);
    public MimeMessageBeginEventArgs(MimeMessage message, MessagePart parent);
    [CompilerGeneratedAttribute]
public MimeMessage get_Message();
    [CompilerGeneratedAttribute]
public MessagePart get_Parent();
    [CompilerGeneratedAttribute]
public long get_BeginOffset();
    [CompilerGeneratedAttribute]
public void set_BeginOffset(long value);
    [CompilerGeneratedAttribute]
public int get_LineNumber();
    [CompilerGeneratedAttribute]
public void set_LineNumber(int value);
}
public class MimeKit.MimeMessageEndEventArgs : MimeMessageBeginEventArgs {
    [CompilerGeneratedAttribute]
private long <HeadersEndOffset>k__BackingField;
    [CompilerGeneratedAttribute]
private long <EndOffset>k__BackingField;
    public long HeadersEndOffset { get; public set; }
    public long EndOffset { get; public set; }
    public MimeMessageEndEventArgs(MimeMessage message);
    public MimeMessageEndEventArgs(MimeMessage message, MessagePart parent);
    [CompilerGeneratedAttribute]
public long get_HeadersEndOffset();
    [CompilerGeneratedAttribute]
public void set_HeadersEndOffset(long value);
    [CompilerGeneratedAttribute]
public long get_EndOffset();
    [CompilerGeneratedAttribute]
public void set_EndOffset(long value);
}
public class MimeKit.MimeParser : object {
    private static int ReadAheadSize;
    private static int BlockSize;
    private static int PadSize;
    private Byte[] input;
    private static int inputStart;
    private int inputIndex;
    private int inputEnd;
    private Byte[] mboxMarkerBuffer;
    private long mboxMarkerOffset;
    private int mboxMarkerLength;
    private Byte[] preHeaderBuffer;
    private int preHeaderLength;
    private Byte[] headerBuffer;
    private long headerOffset;
    private int headerIndex;
    private List`1<Boundary> bounds;
    private List`1<Header> headers;
    private MimeParserState state;
    private BoundaryType boundary;
    private MimeFormat format;
    private bool persistent;
    private bool toplevel;
    private bool eos;
    private ParserOptions options;
    private long headerBlockBegin;
    private long headerBlockEnd;
    private long contentEnd;
    private long prevLineBeginOffset;
    private long lineBeginOffset;
    private int lineNumber;
    private Stream stream;
    private long position;
    [CompilerGeneratedAttribute]
private EventHandler`1<MimeMessageBeginEventArgs> MimeMessageBegin;
    [CompilerGeneratedAttribute]
private EventHandler`1<MimeMessageEndEventArgs> MimeMessageEnd;
    [CompilerGeneratedAttribute]
private EventHandler`1<MimeEntityBeginEventArgs> MimeEntityBegin;
    [CompilerGeneratedAttribute]
private EventHandler`1<MimeEntityEndEventArgs> MimeEntityEnd;
    private static ReadOnlySpan`1<byte> UTF8ByteOrderMark { get; }
    public ParserOptions Options { get; public set; }
    public bool IsEndOfStream { get; }
    public long Position { get; }
    public long MboxMarkerOffset { get; }
    public string MboxMarker { get; }
    public MimeParser(Stream stream, MimeFormat format, bool persistent);
    public MimeParser(Stream stream, bool persistent);
    public MimeParser(ParserOptions options, Stream stream, bool persistent);
    public MimeParser(ParserOptions options, Stream stream, MimeFormat format, bool persistent);
    [AsyncStateMachineAttribute("MimeKit.MimeParser/<ReadAheadAsync>d__0")]
private Task`1<int> ReadAheadAsync(int atleast, int save, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MimeKit.MimeParser/<StepByteOrderMarkAsync>d__1")]
private Task`1<bool> StepByteOrderMarkAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MimeKit.MimeParser/<StepMboxMarkerAsync>d__2")]
private Task StepMboxMarkerAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MimeKit.MimeParser/<StepHeadersAsync>d__3")]
private Task StepHeadersAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MimeKit.MimeParser/<SkipLineAsync>d__4")]
private Task`1<bool> SkipLineAsync(bool consumeNewLine, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MimeKit.MimeParser/<StepAsync>d__5")]
private Task`1<MimeParserState> StepAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MimeKit.MimeParser/<ScanContentAsync>d__6")]
private Task`1<ScanContentResult> ScanContentAsync(Stream content, bool trimNewLine, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MimeKit.MimeParser/<ConstructMimePartAsync>d__7")]
private Task ConstructMimePartAsync(MimePart part, MimeEntityEndEventArgs args, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MimeKit.MimeParser/<ConstructMessagePartAsync>d__8")]
private Task ConstructMessagePartAsync(MessagePart rfc822, MimeEntityEndEventArgs args, int depth, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MimeKit.MimeParser/<MultipartScanPreambleAsync>d__9")]
private Task MultipartScanPreambleAsync(Multipart multipart, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MimeKit.MimeParser/<MultipartScanEpilogueAsync>d__10")]
private Task MultipartScanEpilogueAsync(Multipart multipart, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MimeKit.MimeParser/<MultipartScanSubpartsAsync>d__11")]
private Task MultipartScanSubpartsAsync(Multipart multipart, int depth, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MimeKit.MimeParser/<ConstructMultipartAsync>d__12")]
private Task ConstructMultipartAsync(Multipart multipart, MimeEntityEndEventArgs args, int depth, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MimeKit.MimeParser/<ParseHeadersAsync>d__13")]
public sealed virtual Task`1<HeaderList> ParseHeadersAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MimeKit.MimeParser/<ParseEntityAsync>d__14")]
public sealed virtual Task`1<MimeEntity> ParseEntityAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MimeKit.MimeParser/<ParseMessageAsync>d__15")]
public sealed virtual Task`1<MimeMessage> ParseMessageAsync(CancellationToken cancellationToken);
    private static ReadOnlySpan`1<byte> get_UTF8ByteOrderMark();
    public sealed virtual ParserOptions get_Options();
    public sealed virtual void set_Options(ParserOptions value);
    public sealed virtual bool get_IsEndOfStream();
    public sealed virtual long get_Position();
    public sealed virtual long get_MboxMarkerOffset();
    public sealed virtual string get_MboxMarker();
    [ObsoleteAttribute("Use SetStream(Stream, MimeFormat) or SetStream(Stream, MimeFormat, bool) instead.")]
public void SetStream(ParserOptions options, Stream stream, MimeFormat format, bool persistent);
    [ObsoleteAttribute("Use SetStream(Stream, MimeFormat) or SetStream(Stream, MimeFormat, bool) instead.")]
public void SetStream(ParserOptions options, Stream stream, bool persistent);
    public sealed virtual void SetStream(Stream stream, MimeFormat format, bool persistent);
    public sealed virtual void SetStream(Stream stream, MimeFormat format);
    public sealed virtual void SetStream(Stream stream, bool persistent);
    [CompilerGeneratedAttribute]
public void add_MimeMessageBegin(EventHandler`1<MimeMessageBeginEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_MimeMessageBegin(EventHandler`1<MimeMessageBeginEventArgs> value);
    protected virtual void OnMimeMessageBegin(MimeMessageBeginEventArgs args);
    [CompilerGeneratedAttribute]
public void add_MimeMessageEnd(EventHandler`1<MimeMessageEndEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_MimeMessageEnd(EventHandler`1<MimeMessageEndEventArgs> value);
    protected virtual void OnMimeMessageEnd(MimeMessageEndEventArgs args);
    [CompilerGeneratedAttribute]
public void add_MimeEntityBegin(EventHandler`1<MimeEntityBeginEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_MimeEntityBegin(EventHandler`1<MimeEntityBeginEventArgs> value);
    protected virtual void OnMimeEntityBegin(MimeEntityBeginEventArgs args);
    [CompilerGeneratedAttribute]
public void add_MimeEntityEnd(EventHandler`1<MimeEntityEndEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_MimeEntityEnd(EventHandler`1<MimeEntityEndEventArgs> value);
    protected virtual void OnMimeEntityEnd(MimeEntityEndEventArgs args);
    private static int NextAllocSize(int need);
    private bool AlignReadAheadBuffer(int atleast, int save, Int32& left, Int32& start, Int32& end);
    private int ReadAhead(int atleast, int save, CancellationToken cancellationToken);
    private long GetOffset(int index);
    private long GetEndOffset(int index);
    private int GetLineCount(int beginLineNumber, long beginOffset, long endOffset);
    private static bool CStringsEqual(Byte* str1, Byte* str2, int length);
    private void StepByteOrderMark(Byte* inbuf, Int32& bomIndex);
    private bool StepByteOrderMark(Byte* inbuf, CancellationToken cancellationToken);
    private static bool IsMboxMarker(Byte* text, bool allowMunged);
    private bool StepMboxMarker(Byte* inbuf, Int32& left);
    private void StepMboxMarker(Byte* inbuf, CancellationToken cancellationToken);
    private void AppendRawHeaderData(int startIndex, int length);
    private void ResetRawHeaderData();
    private void ParseAndAppendHeader();
    private static bool IsControl(byte c);
    private static bool IsBlank(byte c);
    private static bool IsEoln(Byte* text);
    private bool StepHeaders(Byte* inbuf, Boolean& scanningFieldName, Boolean& checkFolded, Boolean& midline, Boolean& blank, Boolean& valid, Int32& left);
    private void StepHeaders(Byte* inbuf, CancellationToken cancellationToken);
    private bool InnerSkipLine(Byte* inbuf, bool consumeNewLine);
    private bool SkipLine(Byte* inbuf, bool consumeNewLine, CancellationToken cancellationToken);
    private MimeParserState Step(Byte* inbuf, CancellationToken cancellationToken);
    private ContentType GetContentType(ContentType parent);
    private bool IsPossibleBoundary(Byte* text, int length);
    private static bool IsBoundary(Byte* text, int length, Byte[] boundary, int boundaryLength);
    private BoundaryType CheckBoundary(int startIndex, Byte* start, int length);
    private bool FoundImmediateBoundary(Byte* inbuf, bool final);
    private int GetMaxBoundaryLength();
    private void ScanContent(Byte* inbuf, Int32& nleft, Boolean& midline, Boolean[]& formats);
    private ScanContentResult ScanContent(Byte* inbuf, Stream content, bool trimNewLine, CancellationToken cancellationToken);
    private void ConstructMimePart(MimePart part, MimeEntityEndEventArgs args, Byte* inbuf, CancellationToken cancellationToken);
    private void ConstructMessagePart(MessagePart rfc822, MimeEntityEndEventArgs args, Byte* inbuf, int depth, CancellationToken cancellationToken);
    private void MultipartScanPreamble(Multipart multipart, Byte* inbuf, CancellationToken cancellationToken);
    private void MultipartScanEpilogue(Multipart multipart, Byte* inbuf, CancellationToken cancellationToken);
    private void MultipartScanSubparts(Multipart multipart, Byte* inbuf, int depth, CancellationToken cancellationToken);
    private void PushBoundary(string boundary);
    private void PopBoundary();
    private void ConstructMultipart(Multipart multipart, MimeEntityEndEventArgs args, Byte* inbuf, int depth, CancellationToken cancellationToken);
    internal Stream ReadToEos();
    private HeaderList ParseHeaders(Byte* inbuf, CancellationToken cancellationToken);
    public sealed virtual HeaderList ParseHeaders(CancellationToken cancellationToken);
    private bool IsBlankLine(Byte* inbuf, CancellationToken cancellationToken);
    private HeaderList ParseStatusGroup(Byte* inbuf, CancellationToken cancellationToken);
    internal HeaderList ParseStatusGroup(CancellationToken cancellationToken);
    private MimeEntity ParseEntity(Byte* inbuf, CancellationToken cancellationToken);
    public sealed virtual MimeEntity ParseEntity(CancellationToken cancellationToken);
    private MimeMessage ParseMessage(Byte* inbuf, CancellationToken cancellationToken);
    public sealed virtual MimeMessage ParseMessage(CancellationToken cancellationToken);
    [IteratorStateMachineAttribute("MimeKit.MimeParser/<GetEnumerator>d__136")]
public sealed virtual IEnumerator`1<MimeMessage> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal enum MimeKit.MimeParserState : Enum {
    public sbyte value__;
    public static MimeParserState Error;
    public static MimeParserState Initialized;
    public static MimeParserState MboxMarker;
    public static MimeParserState MessageHeaders;
    public static MimeParserState Headers;
    public static MimeParserState Content;
    public static MimeParserState Boundary;
    public static MimeParserState Complete;
    public static MimeParserState Eos;
}
public class MimeKit.MimePart : MimeEntity {
    private static String[] ContentTransferEncodings;
    private static int DefaultMaxLineLength;
    private int encoderMaxLineLength;
    private ContentEncoding encoding;
    private string description;
    private string md5sum;
    private Nullable`1<int> duration;
    [CompilerGeneratedAttribute]
private IMimeContent <Content>k__BackingField;
    public string ContentDescription { get; public set; }
    public Nullable`1<int> ContentDuration { get; public set; }
    public string ContentMd5 { get; public set; }
    public ContentEncoding ContentTransferEncoding { get; public set; }
    public string FileName { get; public set; }
    public IMimeContent Content { get; public set; }
    public MimePart(MimeEntityConstructorArgs args);
    public MimePart(string mediaType, string mediaSubtype, Object[] args);
    public MimePart(string mediaType, string mediaSubtype);
    public MimePart(ContentType contentType);
    public MimePart(string contentType);
    private static MimePart();
    private void CheckDisposed();
    public sealed virtual string get_ContentDescription();
    public sealed virtual void set_ContentDescription(string value);
    public sealed virtual Nullable`1<int> get_ContentDuration();
    public sealed virtual void set_ContentDuration(Nullable`1<int> value);
    public sealed virtual string get_ContentMd5();
    public sealed virtual void set_ContentMd5(string value);
    public sealed virtual ContentEncoding get_ContentTransferEncoding();
    public sealed virtual void set_ContentTransferEncoding(ContentEncoding value);
    public sealed virtual string get_FileName();
    public sealed virtual void set_FileName(string value);
    [CompilerGeneratedAttribute]
public sealed virtual IMimeContent get_Content();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Content(IMimeContent value);
    public virtual void Accept(MimeVisitor visitor);
    public sealed virtual ContentEncoding GetBestEncoding(EncodingConstraint constraint, CancellationToken cancellationToken);
    public sealed virtual ContentEncoding GetBestEncoding(EncodingConstraint constraint, int maxLineLength, CancellationToken cancellationToken);
    public sealed virtual string ComputeContentMd5();
    public sealed virtual bool VerifyContentMd5();
    public virtual void Prepare(EncodingConstraint constraint, int maxLineLength);
    public virtual void WriteTo(FormatOptions options, Stream stream, bool contentOnly, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MimeKit.MimePart/<WriteToAsync>d__40")]
public virtual Task WriteToAsync(FormatOptions options, Stream stream, bool contentOnly, CancellationToken cancellationToken);
    protected virtual void OnHeadersChanged(HeaderListChangedAction action, Header header);
    protected virtual void Dispose(bool disposing);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task <>n__0(FormatOptions options, Stream stream, bool contentOnly, CancellationToken cancellationToken);
}
public class MimeKit.MimeReader : object {
    private static int HeaderBufferGrowSize;
    private static int ReadAheadSize;
    private static int BlockSize;
    private static int PadSize;
    private Byte[] input;
    private static int inputStart;
    private int inputIndex;
    private int inputEnd;
    private Byte[] headerBuffer;
    private int headerIndex;
    private int headerCount;
    private List`1<Boundary> bounds;
    private Nullable`1<ContentEncoding> currentEncoding;
    private ContentType currentContentType;
    private Nullable`1<long> currentContentLength;
    private MimeParserState state;
    private BoundaryType boundary;
    private MimeFormat format;
    private bool toplevel;
    private bool eos;
    private long headerBlockBegin;
    private long headerBlockEnd;
    private long contentEnd;
    private long prevLineBeginOffset;
    private long lineBeginOffset;
    private int lineNumber;
    private ParserOptions options;
    internal Stream stream;
    internal long position;
    private static String[] MessageMediaSubtypes;
    private static ReadOnlySpan`1<byte> UTF8ByteOrderMark { get; }
    public ParserOptions Options { get; public set; }
    public bool IsEndOfStream { get; }
    public long Position { get; }
    public MimeReader(Stream stream, MimeFormat format);
    public MimeReader(ParserOptions options, Stream stream, MimeFormat format);
    private static MimeReader();
    [AsyncStateMachineAttribute("MimeKit.MimeReader/<ReadAheadAsync>d__0")]
private Task`1<int> ReadAheadAsync(int atleast, int save, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MimeKit.MimeReader/<StepByteOrderMarkAsync>d__1")]
private Task`1<bool> StepByteOrderMarkAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MimeKit.MimeReader/<StepMboxMarkerAsync>d__2")]
private Task StepMboxMarkerAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MimeKit.MimeReader/<StepHeadersAsync>d__3")]
private Task StepHeadersAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MimeKit.MimeReader/<SkipLineAsync>d__4")]
private Task`1<bool> SkipLineAsync(bool consumeNewLine, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MimeKit.MimeReader/<StepAsync>d__5")]
private Task`1<MimeParserState> StepAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MimeKit.MimeReader/<ScanContentAsync>d__6")]
private Task`1<ScanContentResult> ScanContentAsync(ScanContentType type, long beginOffset, int beginLineNumber, bool trimNewLine, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MimeKit.MimeReader/<ConstructMimePartAsync>d__7")]
private Task`1<int> ConstructMimePartAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MimeKit.MimeReader/<ConstructMessagePartAsync>d__8")]
private Task`1<int> ConstructMessagePartAsync(int depth, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MimeKit.MimeReader/<MultipartScanPreambleAsync>d__9")]
private Task MultipartScanPreambleAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MimeKit.MimeReader/<MultipartScanEpilogueAsync>d__10")]
private Task MultipartScanEpilogueAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MimeKit.MimeReader/<MultipartScanSubpartsAsync>d__11")]
private Task MultipartScanSubpartsAsync(ContentType multipartContentType, int depth, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MimeKit.MimeReader/<ConstructMultipartAsync>d__12")]
private Task`1<int> ConstructMultipartAsync(ContentType contentType, int depth, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MimeKit.MimeReader/<ReadHeadersAsync>d__13")]
public Task ReadHeadersAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MimeKit.MimeReader/<ReadEntityAsync>d__14")]
public Task ReadEntityAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MimeKit.MimeReader/<ReadMessageAsync>d__15")]
public Task ReadMessageAsync(CancellationToken cancellationToken);
    private static ReadOnlySpan`1<byte> get_UTF8ByteOrderMark();
    public sealed virtual ParserOptions get_Options();
    public sealed virtual void set_Options(ParserOptions value);
    public sealed virtual bool get_IsEndOfStream();
    public sealed virtual long get_Position();
    public virtual void SetStream(Stream stream, MimeFormat format);
    protected virtual void OnMboxMarkerRead(Byte[] buffer, int startIndex, int count, long beginOffset, int lineNumber, CancellationToken cancellationToken);
    protected virtual Task OnMboxMarkerReadAsync(Byte[] buffer, int startIndex, int count, long beginOffset, int lineNumber, CancellationToken cancellationToken);
    protected virtual void OnHeadersBegin(long beginOffset, int beginLineNumber, CancellationToken cancellationToken);
    protected virtual Task OnHeadersBeginAsync(long beginOffset, int beginLineNumber, CancellationToken cancellationToken);
    protected virtual void OnHeaderRead(Header header, int beginLineNumber, CancellationToken cancellationToken);
    protected virtual Task OnHeaderReadAsync(Header header, int beginLineNumber, CancellationToken cancellationToken);
    protected virtual void OnHeadersEnd(long beginOffset, int beginLineNumber, long endOffset, int endLineNumber, CancellationToken cancellationToken);
    protected virtual Task OnHeadersEndAsync(long beginOffset, int beginLineNumber, long endOffset, int endLineNumber, CancellationToken cancellationToken);
    protected virtual void OnMimeMessageBegin(long beginOffset, int beginLineNumber, CancellationToken cancellationToken);
    protected virtual Task OnMimeMessageBeginAsync(long beginOffset, int beginLineNumber, CancellationToken cancellationToken);
    protected virtual void OnMimeMessageEnd(long beginOffset, int beginLineNumber, long headersEndOffset, long endOffset, int lines, CancellationToken cancellationToken);
    protected virtual Task OnMimeMessageEndAsync(long beginOffset, int beginLineNumber, long headersEndOffset, long endOffset, int lines, CancellationToken cancellationToken);
    protected virtual void OnMimePartBegin(ContentType contentType, long beginOffset, int beginLineNumber, CancellationToken cancellationToken);
    protected virtual Task OnMimePartBeginAsync(ContentType contentType, long beginOffset, int beginLineNumber, CancellationToken cancellationToken);
    protected virtual void OnMimePartContentBegin(long beginOffset, int beginLineNumber, CancellationToken cancellationToken);
    protected virtual Task OnMimePartContentBeginAsync(long beginOffset, int beginLineNumber, CancellationToken cancellationToken);
    protected virtual void OnMimePartContentRead(Byte[] buffer, int startIndex, int count, CancellationToken cancellationToken);
    protected virtual Task OnMimePartContentReadAsync(Byte[] buffer, int startIndex, int count, CancellationToken cancellationToken);
    protected virtual void OnMimePartContentEnd(long beginOffset, int beginLineNumber, long endOffset, int lines, Nullable`1<NewLineFormat> newLineFormat, CancellationToken cancellationToken);
    protected virtual Task OnMimePartContentEndAsync(long beginOffset, int beginLineNumber, long endOffset, int lines, Nullable`1<NewLineFormat> newLineFormat, CancellationToken cancellationToken);
    protected virtual void OnMimePartEnd(ContentType contentType, long beginOffset, int beginLineNumber, long headersEndOffset, long endOffset, int lines, CancellationToken cancellationToken);
    protected virtual Task OnMimePartEndAsync(ContentType contentType, long beginOffset, int beginLineNumber, long headersEndOffset, long endOffset, int lines, CancellationToken cancellationToken);
    protected virtual void OnMessagePartBegin(ContentType contentType, long beginOffset, int beginLineNumber, CancellationToken cancellationToken);
    protected virtual Task OnMessagePartBeginAsync(ContentType contentType, long beginOffset, int beginLineNumber, CancellationToken cancellationToken);
    protected virtual void OnMessagePartEnd(ContentType contentType, long beginOffset, int beginLineNumber, long headersEndOffset, long endOffset, int lines, CancellationToken cancellationToken);
    protected virtual Task OnMessagePartEndAsync(ContentType contentType, long beginOffset, int beginLineNumber, long headersEndOffset, long endOffset, int lines, CancellationToken cancellationToken);
    protected virtual void OnMultipartBegin(ContentType contentType, long beginOffset, int beginLineNumber, CancellationToken cancellationToken);
    protected virtual Task OnMultipartBeginAsync(ContentType contentType, long beginOffset, int beginLineNumber, CancellationToken cancellationToken);
    protected virtual void OnMultipartBoundary(string boundary, long beginOffset, long endOffset, int lineNumber, CancellationToken cancellationToken);
    protected virtual Task OnMultipartBoundaryAsync(string boundary, long beginOffset, long endOffset, int lineNumber, CancellationToken cancellationToken);
    protected virtual void OnMultipartEndBoundary(string boundary, long beginOffset, long endOffset, int lineNumber, CancellationToken cancellationToken);
    protected virtual Task OnMultipartEndBoundaryAsync(string boundary, long beginOffset, long endOffset, int lineNumber, CancellationToken cancellationToken);
    protected virtual void OnMultipartPreambleBegin(long beginOffset, int beginLineNumber, CancellationToken cancellationToken);
    protected virtual Task OnMultipartPreambleBeginAsync(long beginOffset, int beginLineNumber, CancellationToken cancellationToken);
    protected virtual void OnMultipartPreambleRead(Byte[] buffer, int startIndex, int count, CancellationToken cancellationToken);
    protected virtual Task OnMultipartPreambleReadAsync(Byte[] buffer, int startIndex, int count, CancellationToken cancellationToken);
    protected virtual void OnMultipartPreambleEnd(long beginOffset, int beginLineNumber, long endOffset, int lines, CancellationToken cancellationToken);
    protected virtual Task OnMultipartPreambleEndAsync(long beginOffset, int beginLineNumber, long endOffset, int lines, CancellationToken cancellationToken);
    protected virtual void OnMultipartEpilogueBegin(long beginOffset, int beginLineNumber, CancellationToken cancellationToken);
    protected virtual Task OnMultipartEpilogueBeginAsync(long beginOffset, int beginLineNumber, CancellationToken cancellationToken);
    protected virtual void OnMultipartEpilogueRead(Byte[] buffer, int startIndex, int count, CancellationToken cancellationToken);
    protected virtual Task OnMultipartEpilogueReadAsync(Byte[] buffer, int startIndex, int count, CancellationToken cancellationToken);
    protected virtual void OnMultipartEpilogueEnd(long beginOffset, int beginLineNumber, long endOffset, int lines, CancellationToken cancellationToken);
    protected virtual Task OnMultipartEpilogueEndAsync(long beginOffset, int beginLineNumber, long endOffset, int lines, CancellationToken cancellationToken);
    protected virtual void OnMultipartEnd(ContentType contentType, long beginOffset, int beginLineNumber, long headersEndOffset, long endOffset, int lines, CancellationToken cancellationToken);
    protected virtual Task OnMultipartEndAsync(ContentType contentType, long beginOffset, int beginLineNumber, long headersEndOffset, long endOffset, int lines, CancellationToken cancellationToken);
    private static int NextAllocSize(int need);
    private bool AlignReadAheadBuffer(int atleast, int save, Int32& left, Int32& start, Int32& end);
    private int ReadAhead(int atleast, int save, CancellationToken cancellationToken);
    private long GetOffset(int index);
    private long GetEndOffset(int index);
    private int GetLineCount(int beginLineNumber, long beginOffset, long endOffset);
    private void IncrementLineNumber(int index);
    private static bool CStringsEqual(Byte* str1, Byte* str2, int length);
    private void StepByteOrderMark(Byte* inbuf, Int32& bomIndex);
    private bool StepByteOrderMark(Byte* inbuf, CancellationToken cancellationToken);
    private static bool IsMboxMarker(Byte* text, bool allowMunged);
    private static bool IsMboxMarker(Byte[] text, bool allowMunged);
    private bool StepMboxMarker(Byte* inbuf, Int32& left, Int32& mboxMarkerIndex, Int32& mboxMarkerLength, Int64& mboxMarkerOffset);
    private void StepMboxMarker(Byte* inbuf, CancellationToken cancellationToken);
    private void UpdateHeaderState(Header header);
    private static bool IsControl(byte c);
    private static bool IsBlank(byte c);
    private void EnsureHeaderBufferSize(int size);
    private bool TryDetectInvalidHeader(Byte* inbuf, Boolean& invalid, Int32& fieldNameLength, Int32& headerFieldLength);
    private void StepHeaderField(int headerFieldLength);
    private bool StepHeaderValue(Byte* inbuf, Boolean& midline);
    private bool IsEndOfHeaderBlock(int left);
    private bool TryCheckBoundaryWithinHeaderBlock(Byte* inbuf);
    private bool TryCheckMboxMarkerWithinHeaderBlock(Byte* inbuf);
    private Header CreateHeader(long beginOffset, int fieldNameLength, int headerFieldLength, bool invalid);
    private void StepHeaders(Byte* inbuf, CancellationToken cancellationToken);
    private bool InnerSkipLine(Byte* inbuf, bool consumeNewLine);
    private bool SkipLine(Byte* inbuf, bool consumeNewLine, CancellationToken cancellationToken);
    private MimeParserState Step(Byte* inbuf, CancellationToken cancellationToken);
    private ContentType GetContentType(ContentType parent);
    private bool IsPossibleBoundary(Byte* text, int length);
    private static bool IsBoundary(Byte* text, int length, Byte[] boundary, int boundaryLength);
    private BoundaryType CheckBoundary(int startIndex, Byte* start, int length);
    private bool FoundImmediateBoundary(Byte* inbuf, bool final);
    private int GetMaxBoundaryLength();
    private static bool IsMultipart(ContentType contentType);
    private static bool IsMessagePart(ContentType contentType, Nullable`1<ContentEncoding> encoding);
    private void ScanContent(Byte* inbuf, Int32& nleft, Boolean& midline, Boolean[]& formats);
    private ScanContentResult ScanContent(ScanContentType type, Byte* inbuf, long beginOffset, int beginLineNumber, bool trimNewLine, CancellationToken cancellationToken);
    private int ConstructMimePart(Byte* inbuf, CancellationToken cancellationToken);
    private int ConstructMessagePart(Byte* inbuf, int depth, CancellationToken cancellationToken);
    private void MultipartScanPreamble(Byte* inbuf, CancellationToken cancellationToken);
    private void MultipartScanEpilogue(Byte* inbuf, CancellationToken cancellationToken);
    private void MultipartScanSubparts(ContentType multipartContentType, Byte* inbuf, int depth, CancellationToken cancellationToken);
    private void PushBoundary(string boundary);
    private void PopBoundary();
    private int ConstructMultipart(ContentType contentType, Byte* inbuf, int depth, CancellationToken cancellationToken);
    private void ReadHeaders(Byte* inbuf, CancellationToken cancellationToken);
    public void ReadHeaders(CancellationToken cancellationToken);
    private void ReadEntity(Byte* inbuf, CancellationToken cancellationToken);
    public void ReadEntity(CancellationToken cancellationToken);
    private void ReadMessage(Byte* inbuf, CancellationToken cancellationToken);
    public void ReadMessage(CancellationToken cancellationToken);
}
public static class MimeKit.MimeTypes : object {
    private static Dictionary`2<string, string> extensions;
    private static Dictionary`2<string, string> mimeTypes;
    private static MimeTypes();
    private static Dictionary`2<string, string> LoadMimeTypes();
    private static Dictionary`2<string, string> LoadExtensions();
    public static string GetMimeType(string fileName);
    public static bool TryGetExtension(string mimeType, String& extension);
    public static void Register(string mimeType, string extension);
}
public abstract class MimeKit.MimeVisitor : object {
    public virtual void Visit(MimeEntity entity);
    public virtual void Visit(MimeMessage message);
    protected internal virtual void VisitApplicationPgpEncrypted(ApplicationPgpEncrypted entity);
    protected internal virtual void VisitApplicationPgpSignature(ApplicationPgpSignature entity);
    protected internal virtual void VisitApplicationPkcs7Mime(ApplicationPkcs7Mime entity);
    protected internal virtual void VisitApplicationPkcs7Signature(ApplicationPkcs7Signature entity);
    protected internal virtual void VisitMessageDispositionNotification(MessageDispositionNotification entity);
    protected internal virtual void VisitMessageDeliveryStatus(MessageDeliveryStatus entity);
    protected internal virtual void VisitMessageFeedbackReport(MessageFeedbackReport entity);
    protected virtual void VisitMessage(MessagePart entity);
    protected internal virtual void VisitMessagePart(MessagePart entity);
    protected internal virtual void VisitMessagePartial(MessagePartial entity);
    protected internal virtual void VisitMimeEntity(MimeEntity entity);
    protected virtual void VisitBody(MimeMessage message);
    protected internal virtual void VisitMimeMessage(MimeMessage message);
    protected internal virtual void VisitMimePart(MimePart entity);
    protected virtual void VisitChildren(Multipart multipart);
    protected internal virtual void VisitMultipart(Multipart multipart);
    protected internal virtual void VisitMultipartAlternative(MultipartAlternative alternative);
    protected internal virtual void VisitMultipartEncrypted(MultipartEncrypted encrypted);
    protected internal virtual void VisitMultipartRelated(MultipartRelated related);
    protected internal virtual void VisitMultipartReport(MultipartReport report);
    protected internal virtual void VisitMultipartSigned(MultipartSigned signed);
    protected internal virtual void VisitTextPart(TextPart entity);
    protected internal virtual void VisitTextRfc822Headers(TextRfc822Headers entity);
    protected internal virtual void VisitTnefPart(TnefPart entity);
}
[DefaultMemberAttribute("Item")]
public class MimeKit.Multipart : MimeEntity {
    private List`1<MimeEntity> children;
    private string preamble;
    private string epilogue;
    [CompilerGeneratedAttribute]
private Byte[] <RawPreamble>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <RawEpilogue>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <WriteEndBoundary>k__BackingField;
    public string Boundary { get; public set; }
    internal Byte[] RawPreamble { get; internal set; }
    public string Preamble { get; public set; }
    internal Byte[] RawEpilogue { get; internal set; }
    public string Epilogue { get; public set; }
    internal bool WriteEndBoundary { get; internal set; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public MimeEntity Item { get; public set; }
    public Multipart(MimeEntityConstructorArgs args);
    public Multipart(string subtype, Object[] args);
    public Multipart(string subtype);
    private void CheckDisposed();
    [SkipLocalsInitAttribute]
private static string GenerateBoundary();
    public sealed virtual string get_Boundary();
    public sealed virtual void set_Boundary(string value);
    [CompilerGeneratedAttribute]
internal Byte[] get_RawPreamble();
    [CompilerGeneratedAttribute]
internal void set_RawPreamble(Byte[] value);
    public sealed virtual string get_Preamble();
    public sealed virtual void set_Preamble(string value);
    [CompilerGeneratedAttribute]
internal Byte[] get_RawEpilogue();
    [CompilerGeneratedAttribute]
internal void set_RawEpilogue(Byte[] value);
    public sealed virtual string get_Epilogue();
    public sealed virtual void set_Epilogue(string value);
    [CompilerGeneratedAttribute]
internal bool get_WriteEndBoundary();
    [CompilerGeneratedAttribute]
internal void set_WriteEndBoundary(bool value);
    public virtual void Accept(MimeVisitor visitor);
    public virtual bool TryGetValue(TextFormat format, TextPart& body);
    internal static string FoldPreambleOrEpilogue(FormatOptions options, string text, bool isEpilogue);
    private static void WriteBytes(FormatOptions options, Stream stream, Byte[] bytes, bool ensureNewLine, CancellationToken cancellationToken);
    private static Task WriteBytesAsync(FormatOptions options, Stream stream, Byte[] bytes, bool ensureNewLine, CancellationToken cancellationToken);
    public virtual void Prepare(EncodingConstraint constraint, int maxLineLength);
    private static FormatOptions GetMultipartSignedFormatOptions(FormatOptions options);
    public virtual void WriteTo(FormatOptions options, Stream stream, bool contentOnly, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MimeKit.Multipart/<WriteToAsync>d__38")]
public virtual Task WriteToAsync(FormatOptions options, Stream stream, bool contentOnly, CancellationToken cancellationToken);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    internal void InternalAdd(MimeEntity entity);
    public sealed virtual void Add(MimeEntity entity);
    public sealed virtual void Clear();
    public void Clear(bool dispose);
    public sealed virtual bool Contains(MimeEntity entity);
    public sealed virtual void CopyTo(MimeEntity[] array, int arrayIndex);
    public sealed virtual bool Remove(MimeEntity entity);
    public sealed virtual int IndexOf(MimeEntity entity);
    public sealed virtual void Insert(int index, MimeEntity entity);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual MimeEntity get_Item(int index);
    public sealed virtual void set_Item(int index, MimeEntity value);
    public sealed virtual IEnumerator`1<MimeEntity> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    protected virtual void Dispose(bool disposing);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task <>n__0(FormatOptions options, Stream stream, bool contentOnly, CancellationToken cancellationToken);
}
public class MimeKit.MultipartAlternative : Multipart {
    public string TextBody { get; }
    public string HtmlBody { get; }
    public MultipartAlternative(MimeEntityConstructorArgs args);
    public MultipartAlternative(Object[] args);
    private void CheckDisposed();
    public sealed virtual string get_TextBody();
    public sealed virtual string get_HtmlBody();
    public virtual void Accept(MimeVisitor visitor);
    internal static string GetText(TextPart text);
    public sealed virtual string GetTextBody(TextFormat format);
    public virtual bool TryGetValue(TextFormat format, TextPart& body);
}
public class MimeKit.MultipartRelated : Multipart {
    public MimeEntity Root { get; public set; }
    public MultipartRelated(MimeEntityConstructorArgs args);
    public MultipartRelated(Object[] args);
    private void CheckDisposed();
    private int GetRootIndex();
    public sealed virtual MimeEntity get_Root();
    public sealed virtual void set_Root(MimeEntity value);
    public virtual void Accept(MimeVisitor visitor);
    public virtual bool TryGetValue(TextFormat format, TextPart& body);
    public sealed virtual bool Contains(Uri uri);
    public sealed virtual int IndexOf(Uri uri);
    public sealed virtual Stream Open(Uri uri, String& mimeType, String& charset);
    public sealed virtual Stream Open(Uri uri);
}
public class MimeKit.MultipartReport : Multipart {
    public string ReportType { get; public set; }
    public MultipartReport(MimeEntityConstructorArgs args);
    public MultipartReport(string reportType, Object[] args);
    public MultipartReport(string reportType);
    private void CheckDisposed();
    public sealed virtual string get_ReportType();
    public sealed virtual void set_ReportType(string value);
    public virtual void Accept(MimeVisitor visitor);
}
public enum MimeKit.NewLineFormat : Enum {
    public byte value__;
    public static NewLineFormat Unix;
    public static NewLineFormat Dos;
    public static NewLineFormat Mixed;
}
public class MimeKit.Parameter : object {
    private ParameterEncodingMethod encodingMethod;
    private Encoding encoding;
    private bool alwaysQuote;
    private string text;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private EventHandler Changed;
    public string Name { get; private set; }
    public Encoding Encoding { get; public set; }
    public ParameterEncodingMethod EncodingMethod { get; public set; }
    public bool AlwaysQuote { get; public set; }
    public string Value { get; public set; }
    public Parameter(string name, string value);
    public Parameter(Encoding encoding, string name, string value);
    public Parameter(string charset, string name, string value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
    public Encoding get_Encoding();
    public void set_Encoding(Encoding value);
    public ParameterEncodingMethod get_EncodingMethod();
    public void set_EncodingMethod(ParameterEncodingMethod value);
    public bool get_AlwaysQuote();
    public void set_AlwaysQuote(bool value);
    public string get_Value();
    public void set_Value(string value);
    public Parameter Clone();
    private static bool IsAttr(byte c);
    private static bool IsCtrl(char c);
    private EncodeMethod GetEncodeMethod(FormatOptions options, string name, string value, String& quoted);
    private static EncodeMethod GetEncodeMethod(FormatOptions options, Char[] value, int startIndex, int length);
    private static EncodeMethod GetEncodeMethod(FormatOptions options, Byte[] value, int length);
    private static Encoding GetBestEncoding(string value, Encoding defaultEncoding);
    private static bool Rfc2231GetNextValue(FormatOptions options, string charset, Encoder encoder, HexEncoder hex, Char[] chars, Boolean& isFirstValue, Int32& index, Byte[]& bytes, Byte[]& encoded, int maxLength, String& value);
    private void EncodeRfc2231(FormatOptions options, ValueStringBuilder& builder, Int32& lineLength, Encoding headerEncoding);
    private static int EstimateEncodedWordLength(string charset, int byteCount, int encodeCount);
    private static bool ExceedsMaxWordLength(string charset, int byteCount, int encodeCount, int maxLength);
    private static int Rfc2047EncodeNextChunk(ValueStringBuilder& builder, string text, Int32& index, Encoding encoding, string charset, Encoder encoder, int maxLength);
    private void EncodeRfc2047(FormatOptions options, ValueStringBuilder& builder, Int32& lineLength, Encoding headerEncoding);
    internal void Encode(FormatOptions options, ValueStringBuilder& builder, Int32& lineLength, Encoding headerEncoding);
    internal void WriteTo(ValueStringBuilder& builder);
    public virtual string ToString();
    [CompilerGeneratedAttribute]
internal void add_Changed(EventHandler value);
    [CompilerGeneratedAttribute]
internal void remove_Changed(EventHandler value);
    private void OnChanged();
}
public enum MimeKit.ParameterEncodingMethod : Enum {
    public int value__;
    public static ParameterEncodingMethod Default;
    public static ParameterEncodingMethod Rfc2231;
    public static ParameterEncodingMethod Rfc2047;
}
[DefaultMemberAttribute("Item")]
public class MimeKit.ParameterList : object {
    private Dictionary`2<string, Parameter> table;
    private List`1<Parameter> parameters;
    [CompilerGeneratedAttribute]
private EventHandler Changed;
    public string Item { get; public set; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public Parameter Item { get; public set; }
    public void Add(string name, string value);
    public void Add(Encoding encoding, string name, string value);
    public void Add(string charset, string name, string value);
    public bool Contains(string name);
    public int IndexOf(string name);
    public void Insert(int index, string name, string value);
    public bool Remove(string name);
    public string get_Item(string name);
    public void set_Item(string name, string value);
    public bool TryGetValue(string name, Parameter& param);
    public bool TryGetValue(string name, String& value);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual void Add(Parameter param);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(Parameter param);
    public sealed virtual void CopyTo(Parameter[] array, int arrayIndex);
    public sealed virtual bool Remove(Parameter param);
    public sealed virtual int IndexOf(Parameter param);
    public sealed virtual void Insert(int index, Parameter param);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual Parameter get_Item(int index);
    public sealed virtual void set_Item(int index, Parameter value);
    public sealed virtual IEnumerator`1<Parameter> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    internal void Encode(FormatOptions options, ValueStringBuilder& builder, Int32& lineLength, Encoding charset);
    internal void WriteTo(ValueStringBuilder& builder);
    public virtual string ToString();
    [CompilerGeneratedAttribute]
internal void add_Changed(EventHandler value);
    [CompilerGeneratedAttribute]
internal void remove_Changed(EventHandler value);
    private void OnParamChanged(object sender, EventArgs args);
    private void OnChanged();
    private static bool SkipParamName(Byte[] text, Int32& index, int endIndex);
    private static bool TryParseNameValuePair(ParserOptions options, Byte[] text, Int32& index, int endIndex, bool throwOnError, NameValuePair& pair);
    private static bool TryGetCharset(Byte[] text, Int32& index, int endIndex, String& charset);
    private static string DecodeRfc2231(Encoding& encoding, Decoder& decoder, HexDecoder hex, Byte[] text, int startIndex, int count, bool flush);
    internal static bool TryParse(ParserOptions options, Byte[] text, Int32& index, int endIndex, bool throwOnError, ParameterList& paramList);
}
public class MimeKit.ParseException : FormatException {
    [CompilerGeneratedAttribute]
private int <TokenIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ErrorIndex>k__BackingField;
    public int TokenIndex { get; private set; }
    public int ErrorIndex { get; private set; }
    public ParseException(string message, int tokenIndex, int errorIndex, Exception innerException);
    public ParseException(string message, int tokenIndex, int errorIndex);
    [CompilerGeneratedAttribute]
public int get_TokenIndex();
    [CompilerGeneratedAttribute]
private void set_TokenIndex(int value);
    [CompilerGeneratedAttribute]
public int get_ErrorIndex();
    [CompilerGeneratedAttribute]
private void set_ErrorIndex(int value);
}
public class MimeKit.ParserOptions : object {
    private Dictionary`2<string, ConstructorInfo> mimeTypes;
    private static Type[] ConstructorArgTypes;
    public static ParserOptions Default;
    [CompilerGeneratedAttribute]
private RfcComplianceMode <AddressParserComplianceMode>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowUnquotedCommasInAddresses>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowAddressesWithoutDomain>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxAddressGroupDepth>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxMimeDepth>k__BackingField;
    [CompilerGeneratedAttribute]
private RfcComplianceMode <ParameterComplianceMode>k__BackingField;
    [CompilerGeneratedAttribute]
private RfcComplianceMode <Rfc2047ComplianceMode>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RespectContentLength>k__BackingField;
    [CompilerGeneratedAttribute]
private Encoding <CharsetEncoding>k__BackingField;
    public RfcComplianceMode AddressParserComplianceMode { get; public set; }
    public bool AllowUnquotedCommasInAddresses { get; public set; }
    public bool AllowAddressesWithoutDomain { get; public set; }
    public int MaxAddressGroupDepth { get; public set; }
    public int MaxMimeDepth { get; public set; }
    public RfcComplianceMode ParameterComplianceMode { get; public set; }
    public RfcComplianceMode Rfc2047ComplianceMode { get; public set; }
    public bool RespectContentLength { get; public set; }
    public Encoding CharsetEncoding { get; public set; }
    private static ParserOptions();
    [CompilerGeneratedAttribute]
public RfcComplianceMode get_AddressParserComplianceMode();
    [CompilerGeneratedAttribute]
public void set_AddressParserComplianceMode(RfcComplianceMode value);
    [CompilerGeneratedAttribute]
public bool get_AllowUnquotedCommasInAddresses();
    [CompilerGeneratedAttribute]
public void set_AllowUnquotedCommasInAddresses(bool value);
    [CompilerGeneratedAttribute]
public bool get_AllowAddressesWithoutDomain();
    [CompilerGeneratedAttribute]
public void set_AllowAddressesWithoutDomain(bool value);
    [CompilerGeneratedAttribute]
public int get_MaxAddressGroupDepth();
    [CompilerGeneratedAttribute]
public void set_MaxAddressGroupDepth(int value);
    [CompilerGeneratedAttribute]
public int get_MaxMimeDepth();
    [CompilerGeneratedAttribute]
public void set_MaxMimeDepth(int value);
    [CompilerGeneratedAttribute]
public RfcComplianceMode get_ParameterComplianceMode();
    [CompilerGeneratedAttribute]
public void set_ParameterComplianceMode(RfcComplianceMode value);
    [CompilerGeneratedAttribute]
public RfcComplianceMode get_Rfc2047ComplianceMode();
    [CompilerGeneratedAttribute]
public void set_Rfc2047ComplianceMode(RfcComplianceMode value);
    [CompilerGeneratedAttribute]
public bool get_RespectContentLength();
    [CompilerGeneratedAttribute]
public void set_RespectContentLength(bool value);
    [CompilerGeneratedAttribute]
public Encoding get_CharsetEncoding();
    [CompilerGeneratedAttribute]
public void set_CharsetEncoding(Encoding value);
    public ParserOptions Clone();
    public void RegisterMimeType(string mimeType, Type type);
    internal static bool IsEncoded(ContentEncoding encoding);
    private static bool IsEncoded(IList`1<Header> headers);
    private static bool EqualsAny(string value, String[] values);
    internal MimeEntity CreateEntity(ContentType contentType, IList`1<Header> headers, bool toplevel, int depth);
}
public enum MimeKit.RfcComplianceMode : Enum {
    public int value__;
    public static RfcComplianceMode Looser;
    public static RfcComplianceMode Loose;
    public static RfcComplianceMode Strict;
}
[DefaultMemberAttribute("Item")]
internal class MimeKit.Text.CharBuffer : object {
    private Char[] buffer;
    [CompilerGeneratedAttribute]
private int <Length>k__BackingField;
    public int Length { get; public set; }
    public char Item { get; public set; }
    public CharBuffer(int capacity);
    [CompilerGeneratedAttribute]
public int get_Length();
    [CompilerGeneratedAttribute]
public void set_Length(int value);
    public char get_Item(int index);
    public void set_Item(int index, char value);
    private void EnsureCapacity(int length);
    public void Append(char c);
    public void Append(string str);
    public virtual string ToString();
}
public class MimeKit.Text.FlowedToHtml : TextConverter {
    private UrlScanner scanner;
    [CompilerGeneratedAttribute]
private bool <DeleteSpace>k__BackingField;
    [CompilerGeneratedAttribute]
private HeaderFooterFormat <FooterFormat>k__BackingField;
    [CompilerGeneratedAttribute]
private HeaderFooterFormat <HeaderFormat>k__BackingField;
    [CompilerGeneratedAttribute]
private HtmlTagCallback <HtmlTagCallback>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <OutputHtmlFragment>k__BackingField;
    public TextFormat InputFormat { get; }
    public TextFormat OutputFormat { get; }
    public bool DeleteSpace { get; public set; }
    public HeaderFooterFormat FooterFormat { get; public set; }
    public HeaderFooterFormat HeaderFormat { get; public set; }
    public HtmlTagCallback HtmlTagCallback { get; public set; }
    public bool OutputHtmlFragment { get; public set; }
    public virtual TextFormat get_InputFormat();
    public virtual TextFormat get_OutputFormat();
    [CompilerGeneratedAttribute]
public bool get_DeleteSpace();
    [CompilerGeneratedAttribute]
public void set_DeleteSpace(bool value);
    [CompilerGeneratedAttribute]
public HeaderFooterFormat get_FooterFormat();
    [CompilerGeneratedAttribute]
public void set_FooterFormat(HeaderFooterFormat value);
    [CompilerGeneratedAttribute]
public HeaderFooterFormat get_HeaderFormat();
    [CompilerGeneratedAttribute]
public void set_HeaderFormat(HeaderFooterFormat value);
    [CompilerGeneratedAttribute]
public HtmlTagCallback get_HtmlTagCallback();
    [CompilerGeneratedAttribute]
public void set_HtmlTagCallback(HtmlTagCallback value);
    [CompilerGeneratedAttribute]
public bool get_OutputHtmlFragment();
    [CompilerGeneratedAttribute]
public void set_OutputHtmlFragment(bool value);
    private static void DefaultHtmlTagCallback(HtmlTagContext tagContext, HtmlWriter htmlWriter);
    private static ReadOnlySpan`1<char> Unquote(ReadOnlySpan`1<char> line, Int32& quoteDepth);
    private static bool SuppressContent(IList`1<FlowedToHtmlTagContext> stack);
    private void WriteText(HtmlWriter htmlWriter, string text);
    private void WriteParagraph(HtmlWriter htmlWriter, IList`1<FlowedToHtmlTagContext> stack, Int32& currentQuoteDepth, StringBuilder para, int quoteDepth);
    public virtual void Convert(TextReader reader, TextWriter writer);
}
public class MimeKit.Text.FlowedToText : TextConverter {
    [CompilerGeneratedAttribute]
private bool <DeleteSpace>k__BackingField;
    public TextFormat InputFormat { get; }
    public TextFormat OutputFormat { get; }
    public bool DeleteSpace { get; public set; }
    public virtual TextFormat get_InputFormat();
    public virtual TextFormat get_OutputFormat();
    [CompilerGeneratedAttribute]
public bool get_DeleteSpace();
    [CompilerGeneratedAttribute]
public void set_DeleteSpace(bool value);
    private static ReadOnlySpan`1<char> Unquote(ReadOnlySpan`1<char> line, Int32& quoteDepth);
    public virtual void Convert(TextReader reader, TextWriter writer);
}
public enum MimeKit.Text.HeaderFooterFormat : Enum {
    public int value__;
    public static HeaderFooterFormat Text;
    public static HeaderFooterFormat Html;
}
public class MimeKit.Text.HtmlAttribute : object {
    private HtmlAttributeId id;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    public HtmlAttributeId Id { get; }
    public string Name { get; private set; }
    public string Value { get; internal set; }
    public HtmlAttribute(HtmlAttributeId id, string value);
    public HtmlAttribute(string name, string value);
    internal HtmlAttribute(string name);
    public HtmlAttributeId get_Id();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_Value();
    [CompilerGeneratedAttribute]
internal void set_Value(string value);
}
[DefaultMemberAttribute("Item")]
public class MimeKit.Text.HtmlAttributeCollection : object {
    public static HtmlAttributeCollection Empty;
    private List`1<HtmlAttribute> attributes;
    public int Count { get; }
    public HtmlAttribute Item { get; }
    public HtmlAttributeCollection(IEnumerable`1<HtmlAttribute> collection);
    private static HtmlAttributeCollection();
    public int get_Count();
    internal void Add(HtmlAttribute attribute);
    public bool Contains(HtmlAttributeId id);
    public bool Contains(string name);
    public int IndexOf(HtmlAttributeId id);
    public int IndexOf(string name);
    public HtmlAttribute get_Item(int index);
    public bool TryGetValue(HtmlAttributeId id, HtmlAttribute& attribute);
    public bool TryGetValue(string name, HtmlAttribute& attribute);
    public sealed virtual IEnumerator`1<HtmlAttribute> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public enum MimeKit.Text.HtmlAttributeId : Enum {
    public int value__;
    public static HtmlAttributeId Unknown;
    public static HtmlAttributeId Abbr;
    public static HtmlAttributeId Accept;
    public static HtmlAttributeId AcceptCharset;
    public static HtmlAttributeId AccessKey;
    public static HtmlAttributeId Action;
    public static HtmlAttributeId Align;
    public static HtmlAttributeId Alink;
    public static HtmlAttributeId Alt;
    public static HtmlAttributeId Archive;
    public static HtmlAttributeId Axis;
    public static HtmlAttributeId Background;
    public static HtmlAttributeId BGColor;
    public static HtmlAttributeId Border;
    public static HtmlAttributeId CellPadding;
    public static HtmlAttributeId CellSpacing;
    public static HtmlAttributeId Char;
    public static HtmlAttributeId CharOff;
    public static HtmlAttributeId Charset;
    public static HtmlAttributeId Checked;
    public static HtmlAttributeId Cite;
    public static HtmlAttributeId Class;
    public static HtmlAttributeId ClassId;
    public static HtmlAttributeId Clear;
    public static HtmlAttributeId Code;
    public static HtmlAttributeId CodeBase;
    public static HtmlAttributeId CodeType;
    public static HtmlAttributeId Color;
    public static HtmlAttributeId Cols;
    public static HtmlAttributeId ColSpan;
    public static HtmlAttributeId Compact;
    public static HtmlAttributeId Content;
    public static HtmlAttributeId Coords;
    public static HtmlAttributeId Data;
    public static HtmlAttributeId DateTime;
    public static HtmlAttributeId Declare;
    public static HtmlAttributeId Defer;
    public static HtmlAttributeId Dir;
    public static HtmlAttributeId Disabled;
    public static HtmlAttributeId DynSrc;
    public static HtmlAttributeId EncType;
    public static HtmlAttributeId Face;
    public static HtmlAttributeId For;
    public static HtmlAttributeId Frame;
    public static HtmlAttributeId FrameBorder;
    public static HtmlAttributeId Headers;
    public static HtmlAttributeId Height;
    public static HtmlAttributeId Href;
    public static HtmlAttributeId HrefLang;
    public static HtmlAttributeId Hspace;
    public static HtmlAttributeId HttpEquiv;
    public static HtmlAttributeId Id;
    public static HtmlAttributeId IsMap;
    public static HtmlAttributeId Label;
    public static HtmlAttributeId Lang;
    public static HtmlAttributeId Language;
    public static HtmlAttributeId LeftMargin;
    public static HtmlAttributeId Link;
    public static HtmlAttributeId LongDesc;
    public static HtmlAttributeId LowSrc;
    public static HtmlAttributeId MarginHeight;
    public static HtmlAttributeId MarginWidth;
    public static HtmlAttributeId MaxLength;
    public static HtmlAttributeId Media;
    public static HtmlAttributeId Method;
    public static HtmlAttributeId Multiple;
    public static HtmlAttributeId Name;
    public static HtmlAttributeId NoHref;
    public static HtmlAttributeId NoResize;
    public static HtmlAttributeId NoShade;
    public static HtmlAttributeId NoWrap;
    public static HtmlAttributeId Object;
    public static HtmlAttributeId Profile;
    public static HtmlAttributeId Prompt;
    public static HtmlAttributeId ReadOnly;
    public static HtmlAttributeId Rel;
    public static HtmlAttributeId Rev;
    public static HtmlAttributeId Rows;
    public static HtmlAttributeId RowSpan;
    public static HtmlAttributeId Rules;
    public static HtmlAttributeId Scheme;
    public static HtmlAttributeId Scope;
    public static HtmlAttributeId Scrolling;
    public static HtmlAttributeId Selected;
    public static HtmlAttributeId Shape;
    public static HtmlAttributeId Size;
    public static HtmlAttributeId Span;
    public static HtmlAttributeId Src;
    public static HtmlAttributeId StandBy;
    public static HtmlAttributeId Start;
    public static HtmlAttributeId Style;
    public static HtmlAttributeId Summary;
    public static HtmlAttributeId TabIndex;
    public static HtmlAttributeId Target;
    public static HtmlAttributeId Text;
    public static HtmlAttributeId Title;
    public static HtmlAttributeId TopMargin;
    public static HtmlAttributeId Type;
    public static HtmlAttributeId UseMap;
    public static HtmlAttributeId Valign;
    public static HtmlAttributeId Value;
    public static HtmlAttributeId ValueType;
    public static HtmlAttributeId Version;
    public static HtmlAttributeId Vlink;
    public static HtmlAttributeId Vspace;
    public static HtmlAttributeId Width;
    public static HtmlAttributeId XmlNS;
}
[ExtensionAttribute]
public static class MimeKit.Text.HtmlAttributeIdExtensions : object {
    private static String[] AttributeNames;
    private static Dictionary`2<string, HtmlAttributeId> IdMapping;
    private static HtmlAttributeIdExtensions();
    [ExtensionAttribute]
public static string ToAttributeName(HtmlAttributeId value);
    [ExtensionAttribute]
internal static HtmlAttributeId ToHtmlAttributeId(string name);
}
public class MimeKit.Text.HtmlCDataToken : HtmlDataToken {
    public HtmlCDataToken(string data);
    public virtual void WriteTo(TextWriter output);
}
public class MimeKit.Text.HtmlCommentToken : HtmlToken {
    [CompilerGeneratedAttribute]
private string <Comment>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsBogusComment>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsBangComment>k__BackingField;
    public string Comment { get; private set; }
    public bool IsBogusComment { get; private set; }
    internal bool IsBangComment { get; internal set; }
    public HtmlCommentToken(string comment, bool bogus);
    [CompilerGeneratedAttribute]
public string get_Comment();
    [CompilerGeneratedAttribute]
private void set_Comment(string value);
    [CompilerGeneratedAttribute]
public bool get_IsBogusComment();
    [CompilerGeneratedAttribute]
private void set_IsBogusComment(bool value);
    [CompilerGeneratedAttribute]
internal bool get_IsBangComment();
    [CompilerGeneratedAttribute]
internal void set_IsBangComment(bool value);
    public virtual void WriteTo(TextWriter output);
}
public class MimeKit.Text.HtmlDataToken : HtmlToken {
    [CompilerGeneratedAttribute]
private bool <EncodeEntities>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Data>k__BackingField;
    internal bool EncodeEntities { get; internal set; }
    public string Data { get; private set; }
    protected HtmlDataToken(HtmlTokenKind kind, string data);
    public HtmlDataToken(string data);
    [CompilerGeneratedAttribute]
internal bool get_EncodeEntities();
    [CompilerGeneratedAttribute]
internal void set_EncodeEntities(bool value);
    [CompilerGeneratedAttribute]
public string get_Data();
    [CompilerGeneratedAttribute]
private void set_Data(string value);
    public virtual void WriteTo(TextWriter output);
}
public class MimeKit.Text.HtmlDocTypeToken : HtmlToken {
    private string publicIdentifier;
    private string systemIdentifier;
    [CompilerGeneratedAttribute]
private string <RawTagName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ForceQuirksMode>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PublicKeyword>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SystemKeyword>k__BackingField;
    internal string RawTagName { get; internal set; }
    public bool ForceQuirksMode { get; public set; }
    public string Name { get; public set; }
    public string PublicIdentifier { get; public set; }
    public string PublicKeyword { get; internal set; }
    public string SystemIdentifier { get; public set; }
    public string SystemKeyword { get; internal set; }
    [CompilerGeneratedAttribute]
internal string get_RawTagName();
    [CompilerGeneratedAttribute]
internal void set_RawTagName(string value);
    [CompilerGeneratedAttribute]
public bool get_ForceQuirksMode();
    [CompilerGeneratedAttribute]
public void set_ForceQuirksMode(bool value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    public string get_PublicIdentifier();
    public void set_PublicIdentifier(string value);
    [CompilerGeneratedAttribute]
public string get_PublicKeyword();
    [CompilerGeneratedAttribute]
internal void set_PublicKeyword(string value);
    public string get_SystemIdentifier();
    public void set_SystemIdentifier(string value);
    [CompilerGeneratedAttribute]
public string get_SystemKeyword();
    [CompilerGeneratedAttribute]
internal void set_SystemKeyword(string value);
    public virtual void WriteTo(TextWriter output);
}
public class MimeKit.Text.HtmlEntityDecoder : object {
    private Char[] pushed;
    private Int32[] states;
    private bool semicolon;
    private bool numeric;
    private byte digits;
    private byte xbase;
    private int index;
    private static int MaxEntityLength;
    private static Dictionary`2<int, string> NamedEntities;
    private static Transition[] TransitionTable_1;
    private static Transition[] TransitionTable_2;
    private static Transition[] TransitionTable_3;
    private static Transition[] TransitionTable_4;
    private static Transition[] TransitionTable_5;
    private static Transition[] TransitionTable_6;
    private static Transition[] TransitionTable_7;
    private static Transition[] TransitionTable_8;
    private static Transition[] TransitionTable_semicolon;
    private static Transition[] TransitionTable_A;
    private static Transition[] TransitionTable_B;
    private static Transition[] TransitionTable_C;
    private static Transition[] TransitionTable_D;
    private static Transition[] TransitionTable_E;
    private static Transition[] TransitionTable_F;
    private static Transition[] TransitionTable_G;
    private static Transition[] TransitionTable_H;
    private static Transition[] TransitionTable_I;
    private static Transition[] TransitionTable_J;
    private static Transition[] TransitionTable_K;
    private static Transition[] TransitionTable_L;
    private static Transition[] TransitionTable_M;
    private static Transition[] TransitionTable_N;
    private static Transition[] TransitionTable_O;
    private static Transition[] TransitionTable_P;
    private static Transition[] TransitionTable_Q;
    private static Transition[] TransitionTable_R;
    private static Transition[] TransitionTable_S;
    private static Transition[] TransitionTable_T;
    private static Transition[] TransitionTable_U;
    private static Transition[] TransitionTable_V;
    private static Transition[] TransitionTable_W;
    private static Transition[] TransitionTable_X;
    private static Transition[] TransitionTable_Y;
    private static Transition[] TransitionTable_Z;
    private static Transition[] TransitionTable_a;
    private static Transition[] TransitionTable_b;
    private static Transition[] TransitionTable_c;
    private static Transition[] TransitionTable_d;
    private static Transition[] TransitionTable_e;
    private static Transition[] TransitionTable_f;
    private static Transition[] TransitionTable_g;
    private static Transition[] TransitionTable_h;
    private static Transition[] TransitionTable_i;
    private static Transition[] TransitionTable_j;
    private static Transition[] TransitionTable_k;
    private static Transition[] TransitionTable_l;
    private static Transition[] TransitionTable_m;
    private static Transition[] TransitionTable_n;
    private static Transition[] TransitionTable_o;
    private static Transition[] TransitionTable_p;
    private static Transition[] TransitionTable_q;
    private static Transition[] TransitionTable_r;
    private static Transition[] TransitionTable_s;
    private static Transition[] TransitionTable_t;
    private static Transition[] TransitionTable_u;
    private static Transition[] TransitionTable_v;
    private static Transition[] TransitionTable_w;
    private static Transition[] TransitionTable_x;
    private static Transition[] TransitionTable_y;
    private static Transition[] TransitionTable_z;
    private static HtmlEntityDecoder();
    private bool PushNumericEntity(char c);
    public bool Push(char c);
    private string GetNumericEntityValue();
    public string GetValue();
    internal string GetPushedInput();
    public void Reset();
    private static int BinarySearchNextState(Transition[] transitions, int state);
    private bool PushNamedEntity(char c);
    private string GetNamedEntityValue();
}
public enum MimeKit.Text.HtmlNamespace : Enum {
    public int value__;
    public static HtmlNamespace Html;
    public static HtmlNamespace MathML;
    public static HtmlNamespace Svg;
    public static HtmlNamespace XLink;
    public static HtmlNamespace Xml;
    public static HtmlNamespace XmlNS;
}
[ExtensionAttribute]
internal static class MimeKit.Text.HtmlNamespaceExtensions : object {
    private static int NamespacePrefixLength;
    private static String[] NamespaceValues;
    private static HtmlNamespaceExtensions();
    [ExtensionAttribute]
public static string ToNamespaceUrl(HtmlNamespace value);
    [ExtensionAttribute]
public static HtmlNamespace ToHtmlNamespace(string ns);
}
public class MimeKit.Text.HtmlScriptDataToken : HtmlDataToken {
    public HtmlScriptDataToken(string data);
    public virtual void WriteTo(TextWriter output);
}
public class MimeKit.Text.HtmlTagCallback : MulticastDelegate {
    public HtmlTagCallback(object object, IntPtr method);
    public virtual void Invoke(HtmlTagContext tagContext, HtmlWriter htmlWriter);
    public virtual IAsyncResult BeginInvoke(HtmlTagContext tagContext, HtmlWriter htmlWriter, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public abstract class MimeKit.Text.HtmlTagContext : object {
    [CompilerGeneratedAttribute]
private bool <DeleteEndTag>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DeleteTag>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <InvokeCallbackForEndTag>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SuppressInnerContent>k__BackingField;
    [CompilerGeneratedAttribute]
private HtmlTagId <TagId>k__BackingField;
    public HtmlAttributeCollection Attributes { get; }
    public bool DeleteEndTag { get; public set; }
    public bool DeleteTag { get; public set; }
    public bool InvokeCallbackForEndTag { get; public set; }
    public bool IsEmptyElementTag { get; }
    public bool IsEndTag { get; }
    public bool SuppressInnerContent { get; public set; }
    public HtmlTagId TagId { get; private set; }
    public string TagName { get; }
    protected HtmlTagContext(HtmlTagId tagId);
    public abstract virtual HtmlAttributeCollection get_Attributes();
    [CompilerGeneratedAttribute]
public bool get_DeleteEndTag();
    [CompilerGeneratedAttribute]
public void set_DeleteEndTag(bool value);
    [CompilerGeneratedAttribute]
public bool get_DeleteTag();
    [CompilerGeneratedAttribute]
public void set_DeleteTag(bool value);
    [CompilerGeneratedAttribute]
public bool get_InvokeCallbackForEndTag();
    [CompilerGeneratedAttribute]
public void set_InvokeCallbackForEndTag(bool value);
    public abstract virtual bool get_IsEmptyElementTag();
    public abstract virtual bool get_IsEndTag();
    [CompilerGeneratedAttribute]
public bool get_SuppressInnerContent();
    [CompilerGeneratedAttribute]
public void set_SuppressInnerContent(bool value);
    [CompilerGeneratedAttribute]
public HtmlTagId get_TagId();
    [CompilerGeneratedAttribute]
private void set_TagId(HtmlTagId value);
    public abstract virtual string get_TagName();
    public void WriteTag(HtmlWriter htmlWriter);
    public void WriteTag(HtmlWriter htmlWriter, bool writeAttributes);
}
public enum MimeKit.Text.HtmlTagId : Enum {
    public int value__;
    public static HtmlTagId Unknown;
    public static HtmlTagId A;
    public static HtmlTagId Abbr;
    public static HtmlTagId Acronym;
    public static HtmlTagId Address;
    public static HtmlTagId Applet;
    public static HtmlTagId Area;
    public static HtmlTagId Article;
    public static HtmlTagId Aside;
    public static HtmlTagId Audio;
    public static HtmlTagId B;
    public static HtmlTagId Base;
    public static HtmlTagId BaseFont;
    public static HtmlTagId Bdi;
    public static HtmlTagId Bdo;
    public static HtmlTagId BGSound;
    public static HtmlTagId Big;
    public static HtmlTagId Blink;
    public static HtmlTagId BlockQuote;
    public static HtmlTagId Body;
    public static HtmlTagId Br;
    public static HtmlTagId Button;
    public static HtmlTagId Canvas;
    public static HtmlTagId Caption;
    public static HtmlTagId Center;
    public static HtmlTagId Cite;
    public static HtmlTagId Code;
    public static HtmlTagId Col;
    public static HtmlTagId ColGroup;
    public static HtmlTagId Command;
    public static HtmlTagId Comment;
    public static HtmlTagId DataList;
    public static HtmlTagId DD;
    public static HtmlTagId Del;
    public static HtmlTagId Details;
    public static HtmlTagId Dfn;
    public static HtmlTagId Dialog;
    public static HtmlTagId Dir;
    public static HtmlTagId Div;
    public static HtmlTagId DL;
    public static HtmlTagId DT;
    public static HtmlTagId EM;
    public static HtmlTagId Embed;
    public static HtmlTagId FieldSet;
    public static HtmlTagId FigCaption;
    public static HtmlTagId Figure;
    public static HtmlTagId Font;
    public static HtmlTagId Footer;
    public static HtmlTagId Form;
    public static HtmlTagId Frame;
    public static HtmlTagId FrameSet;
    public static HtmlTagId H1;
    public static HtmlTagId H2;
    public static HtmlTagId H3;
    public static HtmlTagId H4;
    public static HtmlTagId H5;
    public static HtmlTagId H6;
    public static HtmlTagId Head;
    public static HtmlTagId Header;
    public static HtmlTagId HR;
    public static HtmlTagId Html;
    public static HtmlTagId I;
    public static HtmlTagId IFrame;
    public static HtmlTagId Image;
    public static HtmlTagId Input;
    public static HtmlTagId Ins;
    public static HtmlTagId IsIndex;
    public static HtmlTagId Kbd;
    public static HtmlTagId Keygen;
    public static HtmlTagId Label;
    public static HtmlTagId Legend;
    public static HtmlTagId LI;
    public static HtmlTagId Link;
    public static HtmlTagId Listing;
    public static HtmlTagId Main;
    public static HtmlTagId Map;
    public static HtmlTagId Mark;
    public static HtmlTagId Marquee;
    public static HtmlTagId Menu;
    public static HtmlTagId MenuItem;
    public static HtmlTagId Meta;
    public static HtmlTagId Meter;
    public static HtmlTagId Nav;
    public static HtmlTagId NextId;
    public static HtmlTagId NoBR;
    public static HtmlTagId NoEmbed;
    public static HtmlTagId NoFrames;
    public static HtmlTagId NoScript;
    public static HtmlTagId Object;
    public static HtmlTagId OL;
    public static HtmlTagId OptGroup;
    public static HtmlTagId Option;
    public static HtmlTagId Output;
    public static HtmlTagId P;
    public static HtmlTagId Param;
    public static HtmlTagId PlainText;
    public static HtmlTagId Pre;
    public static HtmlTagId Progress;
    public static HtmlTagId Q;
    public static HtmlTagId RP;
    public static HtmlTagId RT;
    public static HtmlTagId Ruby;
    public static HtmlTagId S;
    public static HtmlTagId Samp;
    public static HtmlTagId Script;
    public static HtmlTagId Section;
    public static HtmlTagId Select;
    public static HtmlTagId Small;
    public static HtmlTagId Source;
    public static HtmlTagId Span;
    public static HtmlTagId Strike;
    public static HtmlTagId Strong;
    public static HtmlTagId Style;
    public static HtmlTagId Sub;
    public static HtmlTagId Summary;
    public static HtmlTagId Sup;
    public static HtmlTagId Table;
    public static HtmlTagId TBody;
    public static HtmlTagId TD;
    public static HtmlTagId TextArea;
    public static HtmlTagId Tfoot;
    public static HtmlTagId TH;
    public static HtmlTagId THead;
    public static HtmlTagId Time;
    public static HtmlTagId Title;
    public static HtmlTagId TR;
    public static HtmlTagId Track;
    public static HtmlTagId TT;
    public static HtmlTagId U;
    public static HtmlTagId UL;
    public static HtmlTagId Var;
    public static HtmlTagId Video;
    public static HtmlTagId Wbr;
    public static HtmlTagId Xml;
    public static HtmlTagId Xmp;
}
[ExtensionAttribute]
public static class MimeKit.Text.HtmlTagIdExtensions : object {
    private static String[] TagNames;
    private static Dictionary`2<string, HtmlTagId> IdMapping;
    private static HtmlTagIdExtensions();
    [ExtensionAttribute]
public static string ToHtmlTagName(HtmlTagId value);
    [ExtensionAttribute]
internal static HtmlTagId ToHtmlTagId(string name);
    [ExtensionAttribute]
public static bool IsEmptyElement(HtmlTagId id);
    [ExtensionAttribute]
public static bool IsFormattingElement(HtmlTagId id);
}
public class MimeKit.Text.HtmlTagToken : HtmlToken {
    private HtmlTagId id;
    [CompilerGeneratedAttribute]
private HtmlAttributeCollection <Attributes>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsEmptyElement>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsEndTag>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public HtmlAttributeCollection Attributes { get; private set; }
    public HtmlTagId Id { get; }
    public bool IsEmptyElement { get; internal set; }
    public bool IsEndTag { get; private set; }
    public string Name { get; private set; }
    public HtmlTagToken(string name, IEnumerable`1<HtmlAttribute> attributes, bool isEmptyElement);
    public HtmlTagToken(string name, bool isEndTag);
    [CompilerGeneratedAttribute]
public HtmlAttributeCollection get_Attributes();
    [CompilerGeneratedAttribute]
private void set_Attributes(HtmlAttributeCollection value);
    public HtmlTagId get_Id();
    [CompilerGeneratedAttribute]
public bool get_IsEmptyElement();
    [CompilerGeneratedAttribute]
internal void set_IsEmptyElement(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsEndTag();
    [CompilerGeneratedAttribute]
private void set_IsEndTag(bool value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
    public virtual void WriteTo(TextWriter output);
}
public class MimeKit.Text.HtmlTextPreviewer : TextPreviewer {
    public TextFormat InputFormat { get; }
    public virtual TextFormat get_InputFormat();
    private static bool IsWhiteSpace(char c);
    private static bool Append(Char[] preview, Int32& previewLength, string value, Boolean& lwsp);
    private static void Pop(IList`1<HtmlTagContext> stack, HtmlTagId id);
    private static bool ShouldSuppressInnerContent(HtmlTagId id);
    private static bool SuppressContent(IList`1<HtmlTagContext> stack);
    private static HtmlTagContext GetListItemContext(IList`1<HtmlTagContext> stack);
    public virtual string GetPreviewText(TextReader reader);
}
public class MimeKit.Text.HtmlToHtml : TextConverter {
    [CompilerGeneratedAttribute]
private bool <FilterComments>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <FilterHtml>k__BackingField;
    [CompilerGeneratedAttribute]
private HeaderFooterFormat <FooterFormat>k__BackingField;
    [CompilerGeneratedAttribute]
private HeaderFooterFormat <HeaderFormat>k__BackingField;
    [CompilerGeneratedAttribute]
private HtmlTagCallback <HtmlTagCallback>k__BackingField;
    public TextFormat InputFormat { get; }
    public TextFormat OutputFormat { get; }
    public bool FilterComments { get; public set; }
    public bool FilterHtml { get; public set; }
    public HeaderFooterFormat FooterFormat { get; public set; }
    public HeaderFooterFormat HeaderFormat { get; public set; }
    public HtmlTagCallback HtmlTagCallback { get; public set; }
    public virtual TextFormat get_InputFormat();
    public virtual TextFormat get_OutputFormat();
    [CompilerGeneratedAttribute]
public bool get_FilterComments();
    [CompilerGeneratedAttribute]
public void set_FilterComments(bool value);
    [CompilerGeneratedAttribute]
public bool get_FilterHtml();
    [CompilerGeneratedAttribute]
public void set_FilterHtml(bool value);
    [CompilerGeneratedAttribute]
public HeaderFooterFormat get_FooterFormat();
    [CompilerGeneratedAttribute]
public void set_FooterFormat(HeaderFooterFormat value);
    [CompilerGeneratedAttribute]
public HeaderFooterFormat get_HeaderFormat();
    [CompilerGeneratedAttribute]
public void set_HeaderFormat(HeaderFooterFormat value);
    [CompilerGeneratedAttribute]
public HtmlTagCallback get_HtmlTagCallback();
    [CompilerGeneratedAttribute]
public void set_HtmlTagCallback(HtmlTagCallback value);
    private static void DefaultHtmlTagCallback(HtmlTagContext tagContext, HtmlWriter htmlWriter);
    private static bool SuppressContent(IList`1<HtmlToHtmlTagContext> stack);
    private static HtmlToHtmlTagContext Pop(IList`1<HtmlToHtmlTagContext> stack, string name);
    public virtual void Convert(TextReader reader, TextWriter writer);
}
public abstract class MimeKit.Text.HtmlToken : object {
    [CompilerGeneratedAttribute]
private HtmlTokenKind <Kind>k__BackingField;
    public HtmlTokenKind Kind { get; private set; }
    protected HtmlToken(HtmlTokenKind kind);
    [CompilerGeneratedAttribute]
public HtmlTokenKind get_Kind();
    [CompilerGeneratedAttribute]
private void set_Kind(HtmlTokenKind value);
    public abstract virtual void WriteTo(TextWriter output);
    public virtual string ToString();
}
public class MimeKit.Text.HtmlTokenizer : object {
    private static string DocType;
    private static string CData;
    private static int MinimumBufferSize;
    private HtmlEntityDecoder entity;
    private CharBuffer data;
    private CharBuffer name;
    private TextReader textReader;
    private Stream stream;
    private Encoding encoding;
    private Decoder decoder;
    private Byte[] input;
    private int inputEnd;
    private Char[] buffer;
    private int bufferIndex;
    private int bufferEnd;
    private Char[] cdata;
    private int cdataIndex;
    private HtmlDocTypeToken doctype;
    private HtmlAttribute attribute;
    private string activeTagName;
    private HtmlTagToken tag;
    private char quote;
    private bool detectEncodingFromByteOrderMarks;
    private bool detectByteOrderMark;
    private bool isEndTag;
    private bool bang;
    private bool eof;
    [CompilerGeneratedAttribute]
private bool <DecodeCharacterReferences>k__BackingField;
    [CompilerGeneratedAttribute]
private HtmlNamespace <HtmlNamespace>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IgnoreTruncatedTags>k__BackingField;
    [CompilerGeneratedAttribute]
private int <LineNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private int <LinePosition>k__BackingField;
    [CompilerGeneratedAttribute]
private HtmlTokenizerState <TokenizerState>k__BackingField;
    public bool DecodeCharacterReferences { get; public set; }
    public HtmlNamespace HtmlNamespace { get; private set; }
    public bool IgnoreTruncatedTags { get; public set; }
    public int LineNumber { get; private set; }
    public int LinePosition { get; private set; }
    public HtmlTokenizerState TokenizerState { get; private set; }
    public HtmlTokenizer(Stream stream);
    public HtmlTokenizer(Stream stream, Encoding encoding);
    public HtmlTokenizer(Stream stream, Encoding encoding, bool detectEncodingFromByteOrderMarks, int bufferSize);
    public HtmlTokenizer(TextReader reader);
    [CompilerGeneratedAttribute]
public bool get_DecodeCharacterReferences();
    [CompilerGeneratedAttribute]
public void set_DecodeCharacterReferences(bool value);
    [CompilerGeneratedAttribute]
public HtmlNamespace get_HtmlNamespace();
    [CompilerGeneratedAttribute]
private void set_HtmlNamespace(HtmlNamespace value);
    [CompilerGeneratedAttribute]
public bool get_IgnoreTruncatedTags();
    [CompilerGeneratedAttribute]
public void set_IgnoreTruncatedTags(bool value);
    [CompilerGeneratedAttribute]
public int get_LineNumber();
    [CompilerGeneratedAttribute]
private void set_LineNumber(int value);
    [CompilerGeneratedAttribute]
public int get_LinePosition();
    [CompilerGeneratedAttribute]
private void set_LinePosition(int value);
    [CompilerGeneratedAttribute]
public HtmlTokenizerState get_TokenizerState();
    [CompilerGeneratedAttribute]
private void set_TokenizerState(HtmlTokenizerState value);
    protected virtual HtmlDocTypeToken CreateDocType();
    private HtmlDocTypeToken CreateDocTypeToken(string rawTagName);
    protected virtual HtmlCommentToken CreateCommentToken(string comment, bool bogus);
    protected virtual HtmlDataToken CreateDataToken(string data);
    protected virtual HtmlCDataToken CreateCDataToken(string data);
    protected virtual HtmlScriptDataToken CreateScriptDataToken(string data);
    protected virtual HtmlTagToken CreateTagToken(string name, bool isEndTag);
    protected virtual HtmlAttribute CreateAttribute(string name);
    private static bool IsAlphaNumeric(int c);
    private static bool IsAsciiLetter(int c);
    private static char ToLower(int c);
    private int SkipByteOrderMark(ReadOnlySpan`1<byte> preamble);
    private int DetectByteOrderMark();
    private int DetectEncodingFromByteOrderMarks();
    private void FillBuffer();
    private bool TryPeek(Char& c);
    private void IncrementLineNumber();
    private void ConsumeCharacter(char c);
    private bool TryRead(Char& c);
    private bool NameIs(string value);
    private void EmitTagAttribute();
    private HtmlToken EmitCommentToken(string comment, bool bogus);
    private HtmlToken EmitCommentToken(CharBuffer comment, bool bogus);
    private HtmlToken EmitDocType();
    private HtmlToken EmitDataToken(bool encodeEntities, bool truncated);
    private HtmlToken EmitCDataToken();
    private HtmlToken EmitScriptDataToken();
    private HtmlToken EmitTagToken();
    private HtmlToken ReadCharacterReference(HtmlTokenizerState next);
    private HtmlToken ReadGenericRawTextLessThan(HtmlTokenizerState rawText, HtmlTokenizerState rawTextEndTagOpen);
    private HtmlToken ReadGenericRawTextEndTagOpen(bool decoded, HtmlTokenizerState rawText, HtmlTokenizerState rawTextEndTagName);
    private HtmlToken ReadGenericRawTextEndTagName(bool decoded, HtmlTokenizerState rawText);
    private HtmlToken ReadData();
    private HtmlToken ReadCharacterReferenceInData();
    private HtmlToken ReadRcData();
    private HtmlToken ReadCharacterReferenceInRcData();
    private HtmlToken ReadRawText();
    private HtmlToken ReadScriptData();
    private HtmlToken ReadPlainText();
    private HtmlToken ReadTagOpen();
    private HtmlToken ReadEndTagOpen();
    private HtmlToken ReadTagName();
    private HtmlToken ReadRcDataLessThan();
    private HtmlToken ReadRcDataEndTagOpen();
    private HtmlToken ReadRcDataEndTagName();
    private HtmlToken ReadRawTextLessThan();
    private HtmlToken ReadRawTextEndTagOpen();
    private HtmlToken ReadRawTextEndTagName();
    private HtmlToken ReadScriptDataLessThan();
    private HtmlToken ReadScriptDataEndTagOpen();
    private HtmlToken ReadScriptDataEndTagName();
    private HtmlToken ReadScriptDataEscapeStart();
    private HtmlToken ReadScriptDataEscapeStartDash();
    private HtmlToken ReadScriptDataEscaped();
    private HtmlToken ReadScriptDataEscapedDash();
    private HtmlToken ReadScriptDataEscapedDashDash();
    private HtmlToken ReadScriptDataEscapedLessThan();
    private HtmlToken ReadScriptDataEscapedEndTagOpen();
    private HtmlToken ReadScriptDataEscapedEndTagName();
    private HtmlToken ReadScriptDataDoubleEscapeStart();
    private HtmlToken ReadScriptDataDoubleEscaped();
    private HtmlToken ReadScriptDataDoubleEscapedDash();
    private HtmlToken ReadScriptDataDoubleEscapedDashDash();
    private HtmlToken ReadScriptDataDoubleEscapedLessThan();
    private HtmlToken ReadScriptDataDoubleEscapeEnd();
    private HtmlToken ReadBeforeAttributeName();
    private HtmlToken ReadAttributeName();
    private HtmlToken ReadAfterAttributeName();
    private HtmlToken ReadBeforeAttributeValue();
    private HtmlToken ReadAttributeValueQuoted();
    private HtmlToken ReadAttributeValueUnquoted();
    private HtmlToken ReadCharacterReferenceInAttributeValue();
    private HtmlToken ReadAfterAttributeValueQuoted();
    private HtmlToken ReadSelfClosingStartTag();
    private HtmlToken ReadBogusComment();
    private HtmlToken ReadMarkupDeclarationOpen();
    private HtmlToken ReadCommentStart();
    private HtmlToken ReadCommentStartDash();
    private HtmlToken ReadComment();
    private HtmlToken ReadCommentEndDash();
    private HtmlToken ReadCommentEnd();
    private HtmlToken ReadCommentEndBang();
    private HtmlToken ReadDocType();
    private HtmlToken ReadBeforeDocTypeName();
    private HtmlToken ReadDocTypeName();
    private HtmlToken ReadAfterDocTypeName();
    private HtmlToken ReadAfterDocTypePublicKeyword();
    private HtmlToken ReadBeforeDocTypePublicIdentifier();
    private HtmlToken ReadDocTypePublicIdentifierQuoted();
    private HtmlToken ReadAfterDocTypePublicIdentifier();
    private HtmlToken ReadBetweenDocTypePublicAndSystemIdentifiers();
    private HtmlToken ReadAfterDocTypeSystemKeyword();
    private HtmlToken ReadBeforeDocTypeSystemIdentifier();
    private HtmlToken ReadDocTypeSystemIdentifierQuoted();
    private HtmlToken ReadAfterDocTypeSystemIdentifier();
    private HtmlToken ReadBogusDocType();
    private HtmlToken ReadCDataSection();
    public bool ReadNextToken(HtmlToken& token);
}
public enum MimeKit.Text.HtmlTokenizerState : Enum {
    public int value__;
    public static HtmlTokenizerState Data;
    public static HtmlTokenizerState CharacterReferenceInData;
    public static HtmlTokenizerState RcData;
    public static HtmlTokenizerState CharacterReferenceInRcData;
    public static HtmlTokenizerState RawText;
    public static HtmlTokenizerState ScriptData;
    public static HtmlTokenizerState PlainText;
    public static HtmlTokenizerState TagOpen;
    public static HtmlTokenizerState EndTagOpen;
    public static HtmlTokenizerState TagName;
    public static HtmlTokenizerState RcDataLessThan;
    public static HtmlTokenizerState RcDataEndTagOpen;
    public static HtmlTokenizerState RcDataEndTagName;
    public static HtmlTokenizerState RawTextLessThan;
    public static HtmlTokenizerState RawTextEndTagOpen;
    public static HtmlTokenizerState RawTextEndTagName;
    public static HtmlTokenizerState ScriptDataLessThan;
    public static HtmlTokenizerState ScriptDataEndTagOpen;
    public static HtmlTokenizerState ScriptDataEndTagName;
    public static HtmlTokenizerState ScriptDataEscapeStart;
    public static HtmlTokenizerState ScriptDataEscapeStartDash;
    public static HtmlTokenizerState ScriptDataEscaped;
    public static HtmlTokenizerState ScriptDataEscapedDash;
    public static HtmlTokenizerState ScriptDataEscapedDashDash;
    public static HtmlTokenizerState ScriptDataEscapedLessThan;
    public static HtmlTokenizerState ScriptDataEscapedEndTagOpen;
    public static HtmlTokenizerState ScriptDataEscapedEndTagName;
    public static HtmlTokenizerState ScriptDataDoubleEscapeStart;
    public static HtmlTokenizerState ScriptDataDoubleEscaped;
    public static HtmlTokenizerState ScriptDataDoubleEscapedDash;
    public static HtmlTokenizerState ScriptDataDoubleEscapedDashDash;
    public static HtmlTokenizerState ScriptDataDoubleEscapedLessThan;
    public static HtmlTokenizerState ScriptDataDoubleEscapeEnd;
    public static HtmlTokenizerState BeforeAttributeName;
    public static HtmlTokenizerState AttributeName;
    public static HtmlTokenizerState AfterAttributeName;
    public static HtmlTokenizerState BeforeAttributeValue;
    public static HtmlTokenizerState AttributeValueQuoted;
    public static HtmlTokenizerState AttributeValueUnquoted;
    public static HtmlTokenizerState CharacterReferenceInAttributeValue;
    public static HtmlTokenizerState AfterAttributeValueQuoted;
    public static HtmlTokenizerState SelfClosingStartTag;
    public static HtmlTokenizerState BogusComment;
    public static HtmlTokenizerState MarkupDeclarationOpen;
    public static HtmlTokenizerState CommentStart;
    public static HtmlTokenizerState CommentStartDash;
    public static HtmlTokenizerState Comment;
    public static HtmlTokenizerState CommentEndDash;
    public static HtmlTokenizerState CommentEnd;
    public static HtmlTokenizerState CommentEndBang;
    public static HtmlTokenizerState DocType;
    public static HtmlTokenizerState BeforeDocTypeName;
    public static HtmlTokenizerState DocTypeName;
    public static HtmlTokenizerState AfterDocTypeName;
    public static HtmlTokenizerState AfterDocTypePublicKeyword;
    public static HtmlTokenizerState BeforeDocTypePublicIdentifier;
    public static HtmlTokenizerState DocTypePublicIdentifierQuoted;
    public static HtmlTokenizerState AfterDocTypePublicIdentifier;
    public static HtmlTokenizerState BetweenDocTypePublicAndSystemIdentifiers;
    public static HtmlTokenizerState AfterDocTypeSystemKeyword;
    public static HtmlTokenizerState BeforeDocTypeSystemIdentifier;
    public static HtmlTokenizerState DocTypeSystemIdentifierQuoted;
    public static HtmlTokenizerState AfterDocTypeSystemIdentifier;
    public static HtmlTokenizerState BogusDocType;
    public static HtmlTokenizerState CDataSection;
    public static HtmlTokenizerState EndOfFile;
}
public enum MimeKit.Text.HtmlTokenKind : Enum {
    public int value__;
    public static HtmlTokenKind CData;
    public static HtmlTokenKind Comment;
    public static HtmlTokenKind Data;
    public static HtmlTokenKind DocType;
    public static HtmlTokenKind ScriptData;
    public static HtmlTokenKind Tag;
}
public static class MimeKit.Text.HtmlUtils : object {
    internal static bool IsValidTokenName(string name);
    private static int IndexOfHtmlEncodeAttributeChar(ReadOnlySpan`1<char> value, char quote);
    public static void HtmlAttributeEncode(TextWriter output, ReadOnlySpan`1<char> value, char quote);
    public static string HtmlAttributeEncode(ReadOnlySpan`1<char> value, char quote);
    public static void HtmlAttributeEncode(TextWriter output, Char[] value, int startIndex, int count, char quote);
    public static string HtmlAttributeEncode(Char[] value, int startIndex, int count, char quote);
    public static void HtmlAttributeEncode(TextWriter output, string value, int startIndex, int count, char quote);
    public static string HtmlAttributeEncode(string value, int startIndex, int count, char quote);
    public static void HtmlAttributeEncode(TextWriter output, string value, char quote);
    public static string HtmlAttributeEncode(string value, char quote);
    private static int IndexOfHtmlEncodeChar(ReadOnlySpan`1<char> data);
    public static void HtmlEncode(TextWriter output, ReadOnlySpan`1<char> data);
    public static string HtmlEncode(ReadOnlySpan`1<char> data);
    public static void HtmlEncode(TextWriter output, Char[] data, int startIndex, int count);
    public static string HtmlEncode(Char[] data, int startIndex, int count);
    public static void HtmlEncode(TextWriter output, string data, int startIndex, int count);
    public static string HtmlEncode(string data, int startIndex, int count);
    public static void HtmlEncode(TextWriter output, string data);
    public static string HtmlEncode(string data);
    public static void HtmlDecode(TextWriter output, string data, int startIndex, int count);
    public static void HtmlDecode(TextWriter output, string data);
    public static string HtmlDecode(string data, int startIndex, int count);
    public static string HtmlDecode(string data);
}
public class MimeKit.Text.HtmlWriter : object {
    private TextWriter html;
    private bool empty;
    [CompilerGeneratedAttribute]
private HtmlWriterState <WriterState>k__BackingField;
    public HtmlWriterState WriterState { get; private set; }
    public HtmlWriter(Stream stream, Encoding encoding);
    public HtmlWriter(TextWriter output);
    protected virtual override void Finalize();
    private void CheckDisposed();
    [CompilerGeneratedAttribute]
public HtmlWriterState get_WriterState();
    [CompilerGeneratedAttribute]
private void set_WriterState(HtmlWriterState value);
    private static void ValidateArguments(Char[] buffer, int index, int count);
    private static void ValidateAttributeName(string name);
    private static void ValidateTagName(string name);
    private void EncodeAttributeName(string name);
    private void EncodeAttributeValue(Char[] value, int startIndex, int count);
    private void EncodeAttributeValue(string value);
    private void EncodeAttribute(string name, Char[] value, int startIndex, int count);
    private void EncodeAttribute(string name, string value);
    public void WriteAttribute(HtmlAttributeId id, Char[] buffer, int index, int count);
    public void WriteAttribute(string name, Char[] buffer, int index, int count);
    public void WriteAttribute(HtmlAttributeId id, string value);
    public void WriteAttribute(string name, string value);
    public void WriteAttribute(HtmlAttribute attribute);
    public void WriteAttributeName(HtmlAttributeId id);
    public void WriteAttributeName(string name);
    public void WriteAttributeValue(Char[] buffer, int index, int count);
    public void WriteAttributeValue(string value);
    private void FlushWriterState();
    public void WriteEmptyElementTag(HtmlTagId id);
    public void WriteEmptyElementTag(string name);
    public void WriteEndTag(HtmlTagId id);
    public void WriteEndTag(string name);
    public void WriteMarkupText(Char[] buffer, int index, int count);
    public void WriteMarkupText(string value);
    public void WriteStartTag(HtmlTagId id);
    public void WriteStartTag(string name);
    public void WriteText(Char[] buffer, int index, int count);
    public void WriteText(string value);
    public void WriteText(string format, Object[] args);
    public void WriteToken(HtmlToken token);
    public void Flush();
    protected virtual void Dispose(bool disposing);
    public sealed virtual void Dispose();
}
public enum MimeKit.Text.HtmlWriterState : Enum {
    public int value__;
    public static HtmlWriterState Default;
    public static HtmlWriterState Tag;
    public static HtmlWriterState Attribute;
}
public class MimeKit.Text.PlainTextPreviewer : TextPreviewer {
    public TextFormat InputFormat { get; }
    public virtual TextFormat get_InputFormat();
    private static bool IsWhiteSpace(char c);
    public virtual string GetPreviewText(string text);
    public virtual string GetPreviewText(TextReader reader);
}
public abstract class MimeKit.Text.TextConverter : object {
    internal static List`1<UrlPattern> UrlPatterns;
    private Encoding outputEncoding;
    private Encoding inputEncoding;
    private int outputStreamBufferSize;
    private int inputStreamBufferSize;
    [CompilerGeneratedAttribute]
private bool <DetectEncodingFromByteOrderMark>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Footer>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Header>k__BackingField;
    public bool DetectEncodingFromByteOrderMark { get; public set; }
    public Encoding InputEncoding { get; public set; }
    public TextFormat InputFormat { get; }
    public Encoding OutputEncoding { get; public set; }
    public TextFormat OutputFormat { get; }
    public int InputStreamBufferSize { get; public set; }
    public int OutputStreamBufferSize { get; public set; }
    public string Footer { get; public set; }
    public string Header { get; public set; }
    private static TextConverter();
    [CompilerGeneratedAttribute]
public bool get_DetectEncodingFromByteOrderMark();
    [CompilerGeneratedAttribute]
public void set_DetectEncodingFromByteOrderMark(bool value);
    public Encoding get_InputEncoding();
    public void set_InputEncoding(Encoding value);
    public abstract virtual TextFormat get_InputFormat();
    public Encoding get_OutputEncoding();
    public void set_OutputEncoding(Encoding value);
    public abstract virtual TextFormat get_OutputFormat();
    public int get_InputStreamBufferSize();
    public void set_InputStreamBufferSize(int value);
    public int get_OutputStreamBufferSize();
    public void set_OutputStreamBufferSize(int value);
    [CompilerGeneratedAttribute]
public string get_Footer();
    [CompilerGeneratedAttribute]
public void set_Footer(string value);
    [CompilerGeneratedAttribute]
public string get_Header();
    [CompilerGeneratedAttribute]
public void set_Header(string value);
    private TextReader CreateReader(Stream stream);
    private TextWriter CreateWriter(Stream stream);
    public virtual void Convert(Stream source, Stream destination);
    public virtual void Convert(Stream source, TextWriter writer);
    public virtual void Convert(TextReader reader, Stream destination);
    public abstract virtual void Convert(TextReader reader, TextWriter writer);
    public virtual string Convert(string text);
}
public enum MimeKit.Text.TextEncodingConfidence : Enum {
    public int value__;
    public static TextEncodingConfidence Undefined;
    public static TextEncodingConfidence Tentative;
    public static TextEncodingConfidence Certain;
    public static TextEncodingConfidence Irrelevant;
}
public enum MimeKit.Text.TextFormat : Enum {
    public int value__;
    public static TextFormat Plain;
    public static TextFormat Text;
    public static TextFormat Flowed;
    public static TextFormat Html;
    public static TextFormat Enriched;
    public static TextFormat CompressedRichText;
    public static TextFormat RichText;
}
public abstract class MimeKit.Text.TextPreviewer : object {
    private int maximumPreviewLength;
    public TextFormat InputFormat { get; }
    public int MaximumPreviewLength { get; public set; }
    public abstract virtual TextFormat get_InputFormat();
    public int get_MaximumPreviewLength();
    public void set_MaximumPreviewLength(int value);
    private static TextPreviewer Create(TextFormat format);
    public static string GetPreviewText(TextPart body);
    public virtual string GetPreviewText(string text);
    public virtual string GetPreviewText(Stream stream, string charset);
    public virtual string GetPreviewText(Stream stream, Encoding encoding);
    public abstract virtual string GetPreviewText(TextReader reader);
}
public class MimeKit.Text.TextToFlowed : TextConverter {
    private static int MaxLineLength;
    public TextFormat InputFormat { get; }
    public TextFormat OutputFormat { get; }
    public virtual TextFormat get_InputFormat();
    public virtual TextFormat get_OutputFormat();
    private static ReadOnlySpan`1<char> Unquote(ReadOnlySpan`1<char> line, Int32& quoteDepth);
    private static string GetFlowedLine(StringBuilder flowed, ReadOnlySpan`1<char> line, Int32& index, int quoteDepth);
    public virtual void Convert(TextReader reader, TextWriter writer);
}
public class MimeKit.Text.TextToHtml : TextConverter {
    private UrlScanner scanner;
    [CompilerGeneratedAttribute]
private HeaderFooterFormat <FooterFormat>k__BackingField;
    [CompilerGeneratedAttribute]
private HeaderFooterFormat <HeaderFormat>k__BackingField;
    [CompilerGeneratedAttribute]
private HtmlTagCallback <HtmlTagCallback>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <OutputHtmlFragment>k__BackingField;
    public TextFormat InputFormat { get; }
    public TextFormat OutputFormat { get; }
    public HeaderFooterFormat FooterFormat { get; public set; }
    public HeaderFooterFormat HeaderFormat { get; public set; }
    public HtmlTagCallback HtmlTagCallback { get; public set; }
    public bool OutputHtmlFragment { get; public set; }
    public virtual TextFormat get_InputFormat();
    public virtual TextFormat get_OutputFormat();
    [CompilerGeneratedAttribute]
public HeaderFooterFormat get_FooterFormat();
    [CompilerGeneratedAttribute]
public void set_FooterFormat(HeaderFooterFormat value);
    [CompilerGeneratedAttribute]
public HeaderFooterFormat get_HeaderFormat();
    [CompilerGeneratedAttribute]
public void set_HeaderFormat(HeaderFooterFormat value);
    [CompilerGeneratedAttribute]
public HtmlTagCallback get_HtmlTagCallback();
    [CompilerGeneratedAttribute]
public void set_HtmlTagCallback(HtmlTagCallback value);
    [CompilerGeneratedAttribute]
public bool get_OutputHtmlFragment();
    [CompilerGeneratedAttribute]
public void set_OutputHtmlFragment(bool value);
    private static void DefaultHtmlTagCallback(HtmlTagContext tagContext, HtmlWriter htmlWriter);
    private static string Unquote(string line, Int32& quoteDepth);
    private static bool SuppressContent(IList`1<TextToHtmlTagContext> stack);
    private void WriteText(HtmlWriter htmlWriter, string text);
    public virtual void Convert(TextReader reader, TextWriter writer);
}
public class MimeKit.Text.TextToText : TextConverter {
    public TextFormat InputFormat { get; }
    public TextFormat OutputFormat { get; }
    public virtual TextFormat get_InputFormat();
    public virtual TextFormat get_OutputFormat();
    public virtual void Convert(TextReader reader, TextWriter writer);
}
internal class MimeKit.Text.Trie : object {
    private List`1<TrieState> failStates;
    private TrieState root;
    private bool icase;
    public Trie(bool ignoreCase);
    private static void ValidateArguments(Char[] text, int startIndex, int count);
    private static TrieMatch FindMatch(TrieState state, char value);
    private TrieState Insert(TrieState state, int depth, char value);
    public void Add(string pattern);
    public int Search(Char[] text, int startIndex, int count, String& pattern);
    public int Search(Char[] text, int startIndex, String& pattern);
    public int Search(Char[] text, String& pattern);
}
internal class MimeKit.Text.UrlMatch : object {
    public string Pattern;
    public string Prefix;
    public int StartIndex;
    public int EndIndex;
    public UrlMatch(string pattern, string prefix);
}
internal class MimeKit.Text.UrlPattern : object {
    public UrlPatternType Type;
    public string Pattern;
    public string Prefix;
    public UrlPattern(UrlPatternType type, string pattern, string prefix);
}
internal enum MimeKit.Text.UrlPatternType : Enum {
    public int value__;
    public static UrlPatternType Addrspec;
    public static UrlPatternType MailTo;
    public static UrlPatternType File;
    public static UrlPatternType Web;
}
internal class MimeKit.Text.UrlScanner : object {
    private static string AtomCharacters;
    private static string UrlSafeCharacters;
    private Dictionary`2<string, UrlPattern> patterns;
    private Trie trie;
    public void Add(UrlPattern pattern);
    public bool Scan(Char[] text, int startIndex, int count, UrlMatch& match);
    private static char GetClosingBrace(UrlMatch match, Char[] text, int startIndex);
    private static bool IsDigit(char c);
    private static bool IsLetterOrDigit(char c);
    private static bool IsUrlSafe(char c);
    private static bool IsAtom(char c);
    private static bool IsDomain(char c);
    private static bool SkipAtom(Char[] text, int endIndex, Int32& index);
    private static bool SkipAtomBackwards(Char[] text, int startIndex, Int32& index);
    private static bool SkipSubDomain(Char[] text, int endIndex, Int32& index);
    private static bool SkipDomain(Char[] text, int endIndex, Int32& index);
    private static bool SkipQuoted(Char[] text, int endIndex, Int32& index);
    private static bool SkipQuotedBackwards(Char[] text, int startIndex, Int32& index);
    private static bool SkipWord(Char[] text, int endIndex, Int32& index);
    private static bool SkipWordBackwards(Char[] text, int startIndex, Int32& index);
    private static bool SkipIPv4Literal(Char[] text, int endIndex, Int32& index);
    private static bool IsHexDigit(char c);
    private static bool IsIPv6(Char[] text, int startIndex);
    private static bool SkipIPv6Literal(Char[] text, int endIndex, Int32& index);
    private static bool GetAddrspecStartIndex(UrlMatch match, Char[] text, int startIndex, int matchIndex, int endIndex);
    private static bool GetAddrspecEndIndex(UrlMatch match, Char[] text, int startIndex, int matchIndex, int endIndex);
    private static bool GetFileStartIndex(UrlMatch match, Char[] text, int startIndex, int matchIndex, int endIndex);
    private static bool GetFileEndIndex(UrlMatch match, Char[] text, int startIndex, int matchIndex, int endIndex);
    private static bool GetMailToStartIndex(UrlMatch match, Char[] text, int startIndex, int matchIndex, int endIndex);
    private static bool SkipAddrspec(Char[] text, int endIndex, Int32& index);
    private static bool GetMailToEndIndex(UrlMatch match, Char[] text, int startIndex, int matchIndex, int endIndex);
    private static bool GetWebStartIndex(UrlMatch match, Char[] text, int startIndex, int matchIndex, int endIndex);
    private static bool GetWebEndIndex(UrlMatch match, Char[] text, int startIndex, int matchIndex, int endIndex);
}
public class MimeKit.TextPart : MimePart {
    public TextFormat Format { get; }
    public bool IsEnriched { get; }
    public bool IsFlowed { get; }
    public bool IsHtml { get; }
    public bool IsPlain { get; }
    public bool IsRichText { get; }
    public string Text { get; public set; }
    public TextPart(MimeEntityConstructorArgs args);
    public TextPart(string subtype, Object[] args);
    internal TextPart(ContentType contentType);
    public TextPart(string subtype);
    public TextPart(TextFormat format);
    private static string GetMediaSubtype(TextFormat format);
    private void CheckDisposed();
    public sealed virtual TextFormat get_Format();
    public sealed virtual bool get_IsEnriched();
    public sealed virtual bool get_IsFlowed();
    public sealed virtual bool get_IsHtml();
    public sealed virtual bool get_IsPlain();
    public sealed virtual bool get_IsRichText();
    public sealed virtual string get_Text();
    public sealed virtual void set_Text(string value);
    public virtual void Accept(MimeVisitor visitor);
    internal bool IsFormat(TextFormat format);
    private static bool TryDetectHtmlEncoding(TextReader reader, Encoding& encoding, TextEncodingConfidence& confidence);
    private bool TryDetectHtmlEncoding(Encoding& encoding, TextEncodingConfidence& confidence);
    public sealed virtual bool TryDetectEncoding(Encoding& encoding, TextEncodingConfidence& confidence);
    public sealed virtual string GetText(Encoding& encoding);
    public sealed virtual string GetText(Encoding encoding);
    public sealed virtual string GetText(string charset);
    public sealed virtual void SetText(Encoding encoding, string text);
    public sealed virtual void SetText(string charset, string text);
}
public class MimeKit.TextRfc822Headers : MessagePart {
    public TextRfc822Headers(MimeEntityConstructorArgs args);
    public TextRfc822Headers(Object[] args);
    public virtual void Accept(MimeVisitor visitor);
}
public interface MimeKit.Tnef.ITnefPart {
    public abstract virtual MimeMessage ConvertToMessage();
    public abstract virtual IEnumerable`1<MimeEntity> ExtractAttachments();
}
public class MimeKit.Tnef.RtfCompressedToRtf : MimeFilterBase {
    private static string DictionaryInitializerText;
    private static Byte[] DictionaryInitializer;
    private Byte[] dict;
    private Crc32 crc32;
    private FilterState state;
    private int uncompressedSize;
    private int compressedSize;
    private short dictWriteOffset;
    private short dictReadOffset;
    private short dictEndOffset;
    private byte flagCount;
    private byte flags;
    private int checksum;
    private int saved;
    private int size;
    [CompilerGeneratedAttribute]
private RtfCompressionMode <CompressionMode>k__BackingField;
    public RtfCompressionMode CompressionMode { get; private set; }
    public bool IsValidCrc32 { get; }
    private static RtfCompressedToRtf();
    [CompilerGeneratedAttribute]
public RtfCompressionMode get_CompressionMode();
    [CompilerGeneratedAttribute]
private void set_CompressionMode(RtfCompressionMode value);
    public bool get_IsValidCrc32();
    private bool TryReadInt32(Byte[] buffer, Int32& index, int endIndex, Int32& value);
    protected virtual Byte[] Filter(Byte[] input, int startIndex, int length, Int32& outputIndex, Int32& outputLength, bool flush);
    public virtual void Reset();
}
public enum MimeKit.Tnef.RtfCompressionMode : Enum {
    public int value__;
    public static RtfCompressionMode Unknown;
    public static RtfCompressionMode Uncompressed;
    public static RtfCompressionMode Compressed;
}
[FlagsAttribute]
public enum MimeKit.Tnef.TnefAttachFlags : Enum {
    public int value__;
    public static TnefAttachFlags None;
    public static TnefAttachFlags InvisibleInHtml;
    public static TnefAttachFlags InvisibleInRtf;
    public static TnefAttachFlags RenderedInBody;
}
public enum MimeKit.Tnef.TnefAttachMethod : Enum {
    public int value__;
    public static TnefAttachMethod None;
    public static TnefAttachMethod ByValue;
    public static TnefAttachMethod EmbeddedMessage;
    public static TnefAttachMethod Ole;
}
public enum MimeKit.Tnef.TnefAttributeLevel : Enum {
    public int value__;
    public static TnefAttributeLevel Message;
    public static TnefAttributeLevel Attachment;
}
public enum MimeKit.Tnef.TnefAttributeTag : Enum {
    public int value__;
    public static TnefAttributeTag Null;
    public static TnefAttributeTag Owner;
    public static TnefAttributeTag SentFor;
    public static TnefAttributeTag Delegate;
    public static TnefAttributeTag OriginalMessageClass;
    public static TnefAttributeTag DateStart;
    public static TnefAttributeTag DateEnd;
    public static TnefAttributeTag AidOwner;
    public static TnefAttributeTag RequestResponse;
    public static TnefAttributeTag From;
    public static TnefAttributeTag Subject;
    public static TnefAttributeTag DateSent;
    public static TnefAttributeTag DateReceived;
    public static TnefAttributeTag MessageStatus;
    public static TnefAttributeTag MessageClass;
    public static TnefAttributeTag MessageId;
    public static TnefAttributeTag ParentId;
    public static TnefAttributeTag ConversationId;
    public static TnefAttributeTag Body;
    public static TnefAttributeTag Priority;
    public static TnefAttributeTag AttachData;
    public static TnefAttributeTag AttachTitle;
    public static TnefAttributeTag AttachMetaFile;
    public static TnefAttributeTag AttachCreateDate;
    public static TnefAttributeTag AttachModifyDate;
    public static TnefAttributeTag DateModified;
    public static TnefAttributeTag AttachTransportFilename;
    public static TnefAttributeTag AttachRenderData;
    public static TnefAttributeTag MapiProperties;
    public static TnefAttributeTag RecipientTable;
    public static TnefAttributeTag Attachment;
    public static TnefAttributeTag TnefVersion;
    public static TnefAttributeTag OemCodepage;
}
internal enum MimeKit.Tnef.TnefAttributeType : Enum {
    public int value__;
    public static TnefAttributeType Triples;
    public static TnefAttributeType String;
    public static TnefAttributeType Text;
    public static TnefAttributeType Date;
    public static TnefAttributeType Short;
    public static TnefAttributeType Long;
    public static TnefAttributeType Byte;
    public static TnefAttributeType Word;
    public static TnefAttributeType DWord;
    public static TnefAttributeType Max;
}
public enum MimeKit.Tnef.TnefComplianceMode : Enum {
    public int value__;
    public static TnefComplianceMode Loose;
    public static TnefComplianceMode Strict;
}
[FlagsAttribute]
public enum MimeKit.Tnef.TnefComplianceStatus : Enum {
    public int value__;
    public static TnefComplianceStatus Compliant;
    public static TnefComplianceStatus AttributeOverflow;
    public static TnefComplianceStatus InvalidAttribute;
    public static TnefComplianceStatus InvalidAttributeChecksum;
    public static TnefComplianceStatus InvalidAttributeLength;
    public static TnefComplianceStatus InvalidAttributeLevel;
    public static TnefComplianceStatus InvalidAttributeValue;
    public static TnefComplianceStatus InvalidDate;
    public static TnefComplianceStatus InvalidMessageClass;
    public static TnefComplianceStatus InvalidMessageCodepage;
    public static TnefComplianceStatus InvalidPropertyLength;
    public static TnefComplianceStatus InvalidRowCount;
    public static TnefComplianceStatus InvalidTnefSignature;
    public static TnefComplianceStatus InvalidTnefVersion;
    public static TnefComplianceStatus NestingTooDeep;
    public static TnefComplianceStatus StreamTruncated;
    public static TnefComplianceStatus UnsupportedPropertyType;
}
public class MimeKit.Tnef.TnefException : FormatException {
    [CompilerGeneratedAttribute]
private TnefComplianceStatus <Error>k__BackingField;
    public TnefComplianceStatus Error { get; private set; }
    public TnefException(TnefComplianceStatus error, string message, Exception innerException);
    public TnefException(TnefComplianceStatus error, string message);
    [CompilerGeneratedAttribute]
public TnefComplianceStatus get_Error();
    [CompilerGeneratedAttribute]
private void set_Error(TnefComplianceStatus value);
}
[IsReadOnlyAttribute]
public class MimeKit.Tnef.TnefNameId : ValueType {
    private TnefNameIdKind kind;
    private string name;
    private Guid guid;
    private int id;
    public Guid PropertySetGuid { get; }
    public TnefNameIdKind Kind { get; }
    public string Name { get; }
    public int Id { get; }
    public TnefNameId(Guid propertySetGuid, int id);
    public TnefNameId(Guid propertySetGuid, string name);
    public Guid get_PropertySetGuid();
    public TnefNameIdKind get_Kind();
    public string get_Name();
    public int get_Id();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(TnefNameId other);
    public static bool op_Equality(TnefNameId left, TnefNameId right);
    public static bool op_Inequality(TnefNameId left, TnefNameId right);
}
public enum MimeKit.Tnef.TnefNameIdKind : Enum {
    public int value__;
    public static TnefNameIdKind Id;
    public static TnefNameIdKind Name;
}
public class MimeKit.Tnef.TnefPart : MimePart {
    public TnefPart(MimeEntityConstructorArgs args);
    private void CheckDisposed();
    public virtual void Accept(MimeVisitor visitor);
    private static void ExtractRecipientTable(TnefReader reader, MimeMessage message);
    private static string GetHtmlBody(TnefPropertyReader prop, int codepage, Encoding& encoding);
    private static void ExtractMapiProperties(TnefReader reader, MimeMessage message, MultipartAlternative alternatives);
    private static TnefPart PromoteToTnefPart(MimePart part);
    private static void ExtractAttachments(TnefReader reader, Multipart attachments);
    private static MimeMessage ExtractTnefMessage(TnefReader reader);
    public sealed virtual MimeMessage ConvertToMessage();
    [IteratorStateMachineAttribute("MimeKit.Tnef.TnefPart/<ExtractAttachments>d__12")]
public sealed virtual IEnumerable`1<MimeEntity> ExtractAttachments();
}
public enum MimeKit.Tnef.TnefPropertyId : Enum {
    public short value__;
    public static TnefPropertyId AbDefaultDir;
    public static TnefPropertyId AbDefaultPab;
    public static TnefPropertyId AbProviderId;
    public static TnefPropertyId AbProviders;
    public static TnefPropertyId AbSearchPath;
    public static TnefPropertyId AbSearchPathUpdate;
    public static TnefPropertyId Access;
    public static TnefPropertyId AccessLevel;
    public static TnefPropertyId Account;
    public static TnefPropertyId AcknowledgementMode;
    public static TnefPropertyId Addrtype;
    public static TnefPropertyId AlternateRecipient;
    public static TnefPropertyId AlternateRecipientAllowed;
    public static TnefPropertyId Anr;
    public static TnefPropertyId Assistant;
    public static TnefPropertyId AssistantTelephoneNumber;
    public static TnefPropertyId AssocContentCount;
    public static TnefPropertyId AttachAdditionalInfo;
    public static TnefPropertyId AttachContentBase;
    public static TnefPropertyId AttachContentId;
    public static TnefPropertyId AttachContentLocation;
    public static TnefPropertyId AttachData;
    public static TnefPropertyId AttachDisposition;
    public static TnefPropertyId AttachEncoding;
    public static TnefPropertyId AttachExtension;
    public static TnefPropertyId AttachFilename;
    public static TnefPropertyId AttachFlags;
    public static TnefPropertyId AttachLongFilename;
    public static TnefPropertyId AttachLongPathname;
    public static TnefPropertyId AttachmentContactPhoto;
    public static TnefPropertyId AttachmentFlags;
    public static TnefPropertyId AttachmentHidden;
    public static TnefPropertyId AttachmentLinkId;
    public static TnefPropertyId AttachmentX400Parameters;
    public static TnefPropertyId AttachMethod;
    public static TnefPropertyId AttachMimeSequence;
    public static TnefPropertyId AttachMimeTag;
    public static TnefPropertyId AttachNetscapeMacInfo;
    public static TnefPropertyId AttachNum;
    public static TnefPropertyId AttachPathname;
    public static TnefPropertyId AttachRendering;
    public static TnefPropertyId AttachSize;
    public static TnefPropertyId AttachTag;
    public static TnefPropertyId AttachTransportName;
    public static TnefPropertyId AuthorizingUsers;
    public static TnefPropertyId AutoForwarded;
    public static TnefPropertyId AutoForwardingComment;
    public static TnefPropertyId AutoResponseSuppress;
    public static TnefPropertyId BeeperTelephoneNumber;
    public static TnefPropertyId Birthday;
    public static TnefPropertyId Body;
    public static TnefPropertyId BodyContentId;
    public static TnefPropertyId BodyContentLocation;
    public static TnefPropertyId BodyCrc;
    public static TnefPropertyId BodyHtml;
    public static TnefPropertyId Business2TelephoneNumber;
    public static TnefPropertyId BusinessAddressCity;
    public static TnefPropertyId BusinessAddressCountry;
    public static TnefPropertyId BusinessAddressPostalCode;
    public static TnefPropertyId BusinessAddressPostOfficeBox;
    public static TnefPropertyId BusinessAddressStateOrProvince;
    public static TnefPropertyId BusinessAddressStreet;
    public static TnefPropertyId BusinessFaxNumber;
    public static TnefPropertyId BusinessHomePage;
    public static TnefPropertyId CallbackTelephoneNumber;
    public static TnefPropertyId CarTelephoneNumber;
    public static TnefPropertyId CellularTelephoneNumber;
    public static TnefPropertyId ChildrensNames;
    public static TnefPropertyId ClientSubmitTime;
    public static TnefPropertyId Comment;
    public static TnefPropertyId CommonViewsEntryId;
    public static TnefPropertyId CompanyMainPhoneNumber;
    public static TnefPropertyId CompanyName;
    public static TnefPropertyId ComputerNetworkName;
    public static TnefPropertyId ContactAddrtypes;
    public static TnefPropertyId ContactDefaultAddressIndex;
    public static TnefPropertyId ContactEmailAddresses;
    public static TnefPropertyId ContactEntryIds;
    public static TnefPropertyId ContactVersion;
    public static TnefPropertyId ContainerClass;
    public static TnefPropertyId ContainerContents;
    public static TnefPropertyId ContainerFlags;
    public static TnefPropertyId ContainerHierarchy;
    public static TnefPropertyId ContainerModifyVersion;
    public static TnefPropertyId ContentConfidentialityAlgorithmId;
    public static TnefPropertyId ContentCorrelator;
    public static TnefPropertyId ContentCount;
    public static TnefPropertyId ContentIdentifier;
    public static TnefPropertyId ContentIntegrityCheck;
    public static TnefPropertyId ContentLength;
    public static TnefPropertyId ContentReturnRequested;
    public static TnefPropertyId ContentsSortOrder;
    public static TnefPropertyId ContentUnread;
    public static TnefPropertyId ControlFlags;
    public static TnefPropertyId ControlId;
    public static TnefPropertyId ControlStructure;
    public static TnefPropertyId ControlType;
    public static TnefPropertyId ConversationIndex;
    public static TnefPropertyId ConversationKey;
    public static TnefPropertyId ConversationTopic;
    public static TnefPropertyId ConversionEits;
    public static TnefPropertyId ConversionProhibited;
    public static TnefPropertyId ConversionWithLossProhibited;
    public static TnefPropertyId ConvertedEits;
    public static TnefPropertyId Correlate;
    public static TnefPropertyId CorrelateMtsid;
    public static TnefPropertyId Country;
    public static TnefPropertyId CreateTemplates;
    public static TnefPropertyId CreationTime;
    public static TnefPropertyId CreationVersion;
    public static TnefPropertyId CreatorSmtpAddress;
    public static TnefPropertyId CurrentVersion;
    public static TnefPropertyId CustomerId;
    public static TnefPropertyId DefaultProfile;
    public static TnefPropertyId DefaultStore;
    public static TnefPropertyId DefaultViewEntryId;
    public static TnefPropertyId DefCreateDl;
    public static TnefPropertyId DefCreateMailuser;
    public static TnefPropertyId DeferredDeliveryTime;
    public static TnefPropertyId Delegation;
    public static TnefPropertyId DeleteAfterSubmit;
    public static TnefPropertyId DeliverTime;
    public static TnefPropertyId DeliveryPoint;
    public static TnefPropertyId Deltax;
    public static TnefPropertyId Deltay;
    public static TnefPropertyId DepartmentName;
    public static TnefPropertyId Depth;
    public static TnefPropertyId DetailsTable;
    public static TnefPropertyId DiscardReason;
    public static TnefPropertyId DiscloseRecipients;
    public static TnefPropertyId DisclosureOfRecipients;
    public static TnefPropertyId DiscreteValues;
    public static TnefPropertyId DiscVal;
    public static TnefPropertyId DisplayBcc;
    public static TnefPropertyId DisplayCc;
    public static TnefPropertyId DisplayName;
    public static TnefPropertyId DisplayNamePrefix;
    public static TnefPropertyId DisplayTo;
    public static TnefPropertyId DisplayType;
    public static TnefPropertyId DlExpansionHistory;
    public static TnefPropertyId DlExpansionProhibited;
    public static TnefPropertyId EmailAddress;
    public static TnefPropertyId EndDate;
    public static TnefPropertyId EntryId;
    public static TnefPropertyId ExceptionStartTime;
    public static TnefPropertyId ExceptionEndTime;
    public static TnefPropertyId ExpandBeginTime;
    public static TnefPropertyId ExpandedBeginTime;
    public static TnefPropertyId ExpandedEndTime;
    public static TnefPropertyId ExpandEndTime;
    public static TnefPropertyId ExpiryTime;
    public static TnefPropertyId ExplicitConversion;
    public static TnefPropertyId FilteringHooks;
    public static TnefPropertyId FinderEntryId;
    public static TnefPropertyId FolderAssociatedContents;
    public static TnefPropertyId FolderType;
    public static TnefPropertyId FormCategory;
    public static TnefPropertyId FormCategorySub;
    public static TnefPropertyId FormClsid;
    public static TnefPropertyId FormContactName;
    public static TnefPropertyId FormDesignerGuid;
    public static TnefPropertyId FormDesignerName;
    public static TnefPropertyId FormHidden;
    public static TnefPropertyId FormHostMap;
    public static TnefPropertyId FormMessageBehavior;
    public static TnefPropertyId FormVersion;
    public static TnefPropertyId FtpSite;
    public static TnefPropertyId Gender;
    public static TnefPropertyId Generation;
    public static TnefPropertyId GivenName;
    public static TnefPropertyId GovernmentIdNumber;
    public static TnefPropertyId Hasattach;
    public static TnefPropertyId HeaderFolderEntryId;
    public static TnefPropertyId Hobbies;
    public static TnefPropertyId Home2TelephoneNumber;
    public static TnefPropertyId HomeAddressCity;
    public static TnefPropertyId HomeAddressCountry;
    public static TnefPropertyId HomeAddressPostalCode;
    public static TnefPropertyId HomeAddressPostOfficeBox;
    public static TnefPropertyId HomeAddressStateOrProvince;
    public static TnefPropertyId HomeAddressStreet;
    public static TnefPropertyId HomeFaxNumber;
    public static TnefPropertyId HomeTelephoneNumber;
    public static TnefPropertyId Icon;
    public static TnefPropertyId IdentityDisplay;
    public static TnefPropertyId IdentityEntryId;
    public static TnefPropertyId IdentitySearchKey;
    public static TnefPropertyId ImplicitConversionProhibited;
    public static TnefPropertyId Importance;
    public static TnefPropertyId IncompleteCopy;
    public static TnefPropertyId INetMailOverrideCharset;
    public static TnefPropertyId INetMailOverrideFormat;
    public static TnefPropertyId InitialDetailsPane;
    public static TnefPropertyId Initials;
    public static TnefPropertyId InReplyToId;
    public static TnefPropertyId InstanceKey;
    public static TnefPropertyId InternetApproved;
    public static TnefPropertyId InternetArticleNumber;
    public static TnefPropertyId InternetControl;
    public static TnefPropertyId InternetCPID;
    public static TnefPropertyId InternetDistribution;
    public static TnefPropertyId InternetFollowupTo;
    public static TnefPropertyId InternetLines;
    public static TnefPropertyId InternetMessageId;
    public static TnefPropertyId InternetNewsgroups;
    public static TnefPropertyId InternetNntpPath;
    public static TnefPropertyId InternetOrganization;
    public static TnefPropertyId InternetPrecedence;
    public static TnefPropertyId InternetReferences;
    public static TnefPropertyId IpmId;
    public static TnefPropertyId IpmOutboxEntryId;
    public static TnefPropertyId IpmOutboxSearchKey;
    public static TnefPropertyId IpmReturnRequested;
    public static TnefPropertyId IpmSentmailEntryId;
    public static TnefPropertyId IpmSentmailSearchKey;
    public static TnefPropertyId IpmSubtreeEntryId;
    public static TnefPropertyId IpmSubtreeSearchKey;
    public static TnefPropertyId IpmWastebasketEntryId;
    public static TnefPropertyId IpmWastebasketSearchKey;
    public static TnefPropertyId IsdnNumber;
    public static TnefPropertyId Keyword;
    public static TnefPropertyId Language;
    public static TnefPropertyId Languages;
    public static TnefPropertyId LastModificationTime;
    public static TnefPropertyId LastModifierName;
    public static TnefPropertyId LastModifierSmtpAddress;
    public static TnefPropertyId LatestDeliveryTime;
    public static TnefPropertyId ListHelp;
    public static TnefPropertyId ListSubscribe;
    public static TnefPropertyId ListUnsubscribe;
    public static TnefPropertyId Locality;
    public static TnefPropertyId LocallyDelivered;
    public static TnefPropertyId Location;
    public static TnefPropertyId LockBranchId;
    public static TnefPropertyId LockDepth;
    public static TnefPropertyId LockEnlistmentContext;
    public static TnefPropertyId LockExpiryTime;
    public static TnefPropertyId LockPersistent;
    public static TnefPropertyId LockResourceDid;
    public static TnefPropertyId LockResourceFid;
    public static TnefPropertyId LockResourceMid;
    public static TnefPropertyId LockScope;
    public static TnefPropertyId LockTimeout;
    public static TnefPropertyId LockType;
    public static TnefPropertyId MailPermission;
    public static TnefPropertyId ManagerName;
    public static TnefPropertyId MappingSignature;
    public static TnefPropertyId MdbProvider;
    public static TnefPropertyId MessageAttachments;
    public static TnefPropertyId MessageCcMe;
    public static TnefPropertyId MessageClass;
    public static TnefPropertyId MessageCodepage;
    public static TnefPropertyId MessageDeliveryId;
    public static TnefPropertyId MessageDeliveryTime;
    public static TnefPropertyId MessageDownloadTime;
    public static TnefPropertyId MessageFlags;
    public static TnefPropertyId MessageRecipients;
    public static TnefPropertyId MessageRecipMe;
    public static TnefPropertyId MessageSecurityLabel;
    public static TnefPropertyId MessageSize;
    public static TnefPropertyId MessageSubmissionId;
    public static TnefPropertyId MessageToken;
    public static TnefPropertyId MessageToMe;
    public static TnefPropertyId MhsCommonName;
    public static TnefPropertyId MiddleName;
    public static TnefPropertyId MiniIcon;
    public static TnefPropertyId MobileTelephoneNumber;
    public static TnefPropertyId ModifyVersion;
    public static TnefPropertyId MsgStatus;
    public static TnefPropertyId NdrDiagCode;
    public static TnefPropertyId NdrReasonCode;
    public static TnefPropertyId NdrStatusCode;
    public static TnefPropertyId NewsgroupName;
    public static TnefPropertyId Nickname;
    public static TnefPropertyId NntpXref;
    public static TnefPropertyId NonReceiptNotificationRequested;
    public static TnefPropertyId NonReceiptReason;
    public static TnefPropertyId NormalizedSubject;
    public static TnefPropertyId NtSecurityDescriptor;
    public static TnefPropertyId Null;
    public static TnefPropertyId ObjectType;
    public static TnefPropertyId ObsoletedIpms;
    public static TnefPropertyId Office2TelephoneNumber;
    public static TnefPropertyId OfficeLocation;
    public static TnefPropertyId OfficeTelephoneNumber;
    public static TnefPropertyId OofReplyType;
    public static TnefPropertyId OrganizationalIdNumber;
    public static TnefPropertyId OrigEntryId;
    public static TnefPropertyId OriginalAuthorAddrtype;
    public static TnefPropertyId OriginalAuthorEmailAddress;
    public static TnefPropertyId OriginalAuthorEntryId;
    public static TnefPropertyId OriginalAuthorName;
    public static TnefPropertyId OriginalAuthorSearchKey;
    public static TnefPropertyId OriginalDeliveryTime;
    public static TnefPropertyId OriginalDisplayBcc;
    public static TnefPropertyId OriginalDisplayCc;
    public static TnefPropertyId OriginalDisplayName;
    public static TnefPropertyId OriginalDisplayTo;
    public static TnefPropertyId OriginalEits;
    public static TnefPropertyId OriginalEntryId;
    public static TnefPropertyId OriginallyIntendedRecipAddrtype;
    public static TnefPropertyId OriginallyIntendedRecipEmailAddress;
    public static TnefPropertyId OriginallyIntendedRecipEntryId;
    public static TnefPropertyId OriginallyIntendedRecipientName;
    public static TnefPropertyId OriginalSearchKey;
    public static TnefPropertyId OriginalSenderAddrtype;
    public static TnefPropertyId OriginalSenderEmailAddress;
    public static TnefPropertyId OriginalSenderEntryId;
    public static TnefPropertyId OriginalSenderName;
    public static TnefPropertyId OriginalSenderSearchKey;
    public static TnefPropertyId OriginalSensitivity;
    public static TnefPropertyId OriginalSentRepresentingAddrtype;
    public static TnefPropertyId OriginalSentRepresentingEmailAddress;
    public static TnefPropertyId OriginalSentRepresentingEntryId;
    public static TnefPropertyId OriginalSentRepresentingName;
    public static TnefPropertyId OriginalSentRepresentingSearchKey;
    public static TnefPropertyId OriginalSubject;
    public static TnefPropertyId OriginalSubmitTime;
    public static TnefPropertyId OriginatingMtaCertificate;
    public static TnefPropertyId OriginatorAndDlExpansionHistory;
    public static TnefPropertyId OriginatorCertificate;
    public static TnefPropertyId OriginatorDeliveryReportRequested;
    public static TnefPropertyId OriginatorNonDeliveryReportRequested;
    public static TnefPropertyId OriginatorRequestedAlternateRecipient;
    public static TnefPropertyId OriginatorReturnAddress;
    public static TnefPropertyId OriginCheck;
    public static TnefPropertyId OrigMessageClass;
    public static TnefPropertyId OtherAddressCity;
    public static TnefPropertyId OtherAddressCountry;
    public static TnefPropertyId OtherAddressPostalCode;
    public static TnefPropertyId OtherAddressPostOfficeBox;
    public static TnefPropertyId OtherAddressStateOrProvince;
    public static TnefPropertyId OtherAddressStreet;
    public static TnefPropertyId OtherTelephoneNumber;
    public static TnefPropertyId OwnerApptId;
    public static TnefPropertyId OwnStoreEntryId;
    public static TnefPropertyId PagerTelephoneNumber;
    public static TnefPropertyId ParentDisplay;
    public static TnefPropertyId ParentEntryId;
    public static TnefPropertyId ParentKey;
    public static TnefPropertyId PersonalHomePage;
    public static TnefPropertyId PhysicalDeliveryBureauFaxDelivery;
    public static TnefPropertyId PhysicalDeliveryMode;
    public static TnefPropertyId PhysicalDeliveryReportRequest;
    public static TnefPropertyId PhysicalForwardingAddress;
    public static TnefPropertyId PhysicalForwardingAddressRequested;
    public static TnefPropertyId PhysicalForwardingProhibited;
    public static TnefPropertyId PhysicalRenditionAttributes;
    public static TnefPropertyId PostalAddress;
    public static TnefPropertyId PostalCode;
    public static TnefPropertyId PostFolderEntries;
    public static TnefPropertyId PostFolderNames;
    public static TnefPropertyId PostOfficeBox;
    public static TnefPropertyId PostReplyDenied;
    public static TnefPropertyId PostReplyFolderEntries;
    public static TnefPropertyId PostReplyFolderNames;
    public static TnefPropertyId PreferredByName;
    public static TnefPropertyId Preprocess;
    public static TnefPropertyId PrimaryCapability;
    public static TnefPropertyId PrimaryFaxNumber;
    public static TnefPropertyId PrimaryTelephoneNumber;
    public static TnefPropertyId Priority;
    public static TnefPropertyId Profession;
    public static TnefPropertyId ProfileName;
    public static TnefPropertyId ProofOfDelivery;
    public static TnefPropertyId ProofOfDeliveryRequested;
    public static TnefPropertyId ProofOfSubmission;
    public static TnefPropertyId ProofOfSubmissionRequested;
    public static TnefPropertyId PropIdSecureMax;
    public static TnefPropertyId PropIdSecureMin;
    public static TnefPropertyId ProviderDisplay;
    public static TnefPropertyId ProviderDllName;
    public static TnefPropertyId ProviderOrdinal;
    public static TnefPropertyId ProviderSubmitTime;
    public static TnefPropertyId ProviderUid;
    public static TnefPropertyId Puid;
    public static TnefPropertyId RadioTelephoneNumber;
    public static TnefPropertyId RcvdRepresentingAddrtype;
    public static TnefPropertyId RcvdRepresentingEmailAddress;
    public static TnefPropertyId RcvdRepresentingEntryId;
    public static TnefPropertyId RcvdRepresentingName;
    public static TnefPropertyId RcvdRepresentingSearchKey;
    public static TnefPropertyId ReadReceiptEntryId;
    public static TnefPropertyId ReadReceiptRequested;
    public static TnefPropertyId ReadReceiptSearchKey;
    public static TnefPropertyId ReceiptTime;
    public static TnefPropertyId ReceivedByAddrtype;
    public static TnefPropertyId ReceivedByEmailAddress;
    public static TnefPropertyId ReceivedByEntryId;
    public static TnefPropertyId ReceivedByName;
    public static TnefPropertyId ReceivedBySearchKey;
    public static TnefPropertyId ReceiveFolderSettings;
    public static TnefPropertyId RecipientCertificate;
    public static TnefPropertyId RecipientDisplayName;
    public static TnefPropertyId RecipientNumberForAdvice;
    public static TnefPropertyId RecipientReassignmentProhibited;
    public static TnefPropertyId RecipientStatus;
    public static TnefPropertyId RecipientType;
    public static TnefPropertyId RecordKey;
    public static TnefPropertyId RedirectionHistory;
    public static TnefPropertyId ReferredByName;
    public static TnefPropertyId RegisteredMailType;
    public static TnefPropertyId RelatedIpms;
    public static TnefPropertyId RemoteProgress;
    public static TnefPropertyId RemoteProgressText;
    public static TnefPropertyId RemoteValidateOk;
    public static TnefPropertyId RenderingPosition;
    public static TnefPropertyId ReplyRecipientEntries;
    public static TnefPropertyId ReplyRecipientNames;
    public static TnefPropertyId ReplyRecipientSmtpProxies;
    public static TnefPropertyId ReplyRequested;
    public static TnefPropertyId ReplyTime;
    public static TnefPropertyId ReportEntryId;
    public static TnefPropertyId ReportingDlName;
    public static TnefPropertyId ReportingMtaCertificate;
    public static TnefPropertyId ReportName;
    public static TnefPropertyId ReportSearchKey;
    public static TnefPropertyId ReportTag;
    public static TnefPropertyId ReportText;
    public static TnefPropertyId ReportTime;
    public static TnefPropertyId RequestedDeliveryMethod;
    public static TnefPropertyId ResourceFlags;
    public static TnefPropertyId ResourceMethods;
    public static TnefPropertyId ResourcePath;
    public static TnefPropertyId ResourceType;
    public static TnefPropertyId ResponseRequested;
    public static TnefPropertyId Responsibility;
    public static TnefPropertyId ReturnedIpm;
    public static TnefPropertyId Rowid;
    public static TnefPropertyId RowType;
    public static TnefPropertyId RtfCompressed;
    public static TnefPropertyId RtfInSync;
    public static TnefPropertyId RtfSyncBodyCount;
    public static TnefPropertyId RtfSyncBodyCrc;
    public static TnefPropertyId RtfSyncBodyTag;
    public static TnefPropertyId RtfSyncPrefixCount;
    public static TnefPropertyId RtfSyncTrailingCount;
    public static TnefPropertyId Search;
    public static TnefPropertyId SearchKey;
    public static TnefPropertyId Security;
    public static TnefPropertyId Selectable;
    public static TnefPropertyId SenderAddrtype;
    public static TnefPropertyId SenderEmailAddress;
    public static TnefPropertyId SenderEntryId;
    public static TnefPropertyId SenderName;
    public static TnefPropertyId SenderSearchKey;
    public static TnefPropertyId SenderSimpleDispName;
    public static TnefPropertyId SenderSmtpAddress;
    public static TnefPropertyId SendInternetEncoding;
    public static TnefPropertyId SendRecallReport;
    public static TnefPropertyId SendRichInfo;
    public static TnefPropertyId Sensitivity;
    public static TnefPropertyId SentmailEntryId;
    public static TnefPropertyId SentRepresentingAddrtype;
    public static TnefPropertyId SentRepresentingEmailAddress;
    public static TnefPropertyId SentRepresentingEntryId;
    public static TnefPropertyId SentRepresentingName;
    public static TnefPropertyId SentRepresentingSearchKey;
    public static TnefPropertyId SentRepresentingSimpleDispName;
    public static TnefPropertyId ServiceDeleteFiles;
    public static TnefPropertyId ServiceDllName;
    public static TnefPropertyId ServiceEntryName;
    public static TnefPropertyId ServiceExtraUids;
    public static TnefPropertyId ServiceName;
    public static TnefPropertyId Services;
    public static TnefPropertyId ServiceSupportFiles;
    public static TnefPropertyId ServiceUid;
    public static TnefPropertyId SevenBitDisplayName;
    public static TnefPropertyId SmtpAddress;
    public static TnefPropertyId SpoolerStatus;
    public static TnefPropertyId SpouseName;
    public static TnefPropertyId StartDate;
    public static TnefPropertyId StateOrProvince;
    public static TnefPropertyId Status;
    public static TnefPropertyId StatusCode;
    public static TnefPropertyId StatusString;
    public static TnefPropertyId StoreEntryId;
    public static TnefPropertyId StoreProviders;
    public static TnefPropertyId StoreRecordKey;
    public static TnefPropertyId StoreState;
    public static TnefPropertyId StoreSupportMask;
    public static TnefPropertyId StreetAddress;
    public static TnefPropertyId Subfolders;
    public static TnefPropertyId Subject;
    public static TnefPropertyId SubjectIpm;
    public static TnefPropertyId SubjectPrefix;
    public static TnefPropertyId SubmitFlags;
    public static TnefPropertyId Supersedes;
    public static TnefPropertyId SupplementaryInfo;
    public static TnefPropertyId Surname;
    public static TnefPropertyId TelexNumber;
    public static TnefPropertyId Templateid;
    public static TnefPropertyId Title;
    public static TnefPropertyId TnefCorrelationKey;
    public static TnefPropertyId TransmitableDisplayName;
    public static TnefPropertyId TransportKey;
    public static TnefPropertyId TransportMessageHeaders;
    public static TnefPropertyId TransportProviders;
    public static TnefPropertyId TransportStatus;
    public static TnefPropertyId TtytddPhoneNumber;
    public static TnefPropertyId TypeOfMtsUser;
    public static TnefPropertyId UserCertificate;
    public static TnefPropertyId UserX509Certificate;
    public static TnefPropertyId ValidFolderMask;
    public static TnefPropertyId ViewsEntryId;
    public static TnefPropertyId WeddingAnniversary;
    public static TnefPropertyId X400ContentType;
    public static TnefPropertyId X400DeferredDeliveryCancel;
    public static TnefPropertyId Xpos;
    public static TnefPropertyId Ypos;
}
public class MimeKit.Tnef.TnefPropertyReader : object {
    private static Encoding DefaultEncoding;
    private TnefPropertyTag propertyTag;
    private TnefReader reader;
    private TnefNameId propertyName;
    private int rawValueOffset;
    private int rawValueLength;
    private int propertyIndex;
    private int propertyCount;
    private Decoder decoder;
    private int valueIndex;
    private int valueCount;
    private int rowIndex;
    private int rowCount;
    [CompilerGeneratedAttribute]
private TnefAttachMethod <AttachMethod>k__BackingField;
    internal TnefAttachMethod AttachMethod { get; internal set; }
    public bool IsEmbeddedMessage { get; }
    public bool IsMultiValuedProperty { get; }
    public bool IsNamedProperty { get; }
    public bool IsObjectProperty { get; }
    public int PropertyCount { get; }
    public TnefNameId PropertyNameId { get; }
    public TnefPropertyTag PropertyTag { get; }
    public int RawValueLength { get; }
    public int RawValueStreamOffset { get; }
    public int RowCount { get; }
    public int ValueCount { get; }
    public Type ValueType { get; }
    internal TnefPropertyReader(TnefReader tnef);
    private static TnefPropertyReader();
    [CompilerGeneratedAttribute]
internal TnefAttachMethod get_AttachMethod();
    [CompilerGeneratedAttribute]
internal void set_AttachMethod(TnefAttachMethod value);
    public bool get_IsEmbeddedMessage();
    public bool get_IsMultiValuedProperty();
    public bool get_IsNamedProperty();
    public bool get_IsObjectProperty();
    public int get_PropertyCount();
    public TnefNameId get_PropertyNameId();
    public TnefPropertyTag get_PropertyTag();
    public int get_RawValueLength();
    public int get_RawValueStreamOffset();
    public int get_RowCount();
    public int get_ValueCount();
    public Type get_ValueType();
    public TnefReader GetEmbeddedMessageReader();
    public Stream GetRawValueReadStream();
    private bool CheckRawValueLength();
    private byte ReadByte();
    private Byte[] ReadBytes(int count);
    private short ReadInt16();
    private int ReadInt32();
    private int PeekInt32();
    private long ReadInt64();
    private float ReadSingle();
    private double ReadDouble();
    private DateTime ReadAppTime();
    private DateTime ReadSysTime();
    private static int GetPaddedLength(int length);
    private Byte[] ReadByteArray();
    private string ReadUnicodeString();
    private Encoding GetMessageEncoding();
    private string DecodeAnsiString(Byte[] bytes);
    private string ReadString();
    private Byte[] ReadAttrBytes();
    private string ReadAttrString();
    private DateTime ReadAttrDateTime();
    private void LoadPropertyName();
    public bool ReadNextProperty();
    public bool ReadNextRow();
    public bool ReadNextValue();
    public int ReadRawValue(Byte[] buffer, int offset, int count);
    public int ReadTextValue(Char[] buffer, int offset, int count);
    private bool TryGetPropertyValueLength(Int32& length);
    private Type GetPropertyValueType();
    private Type GetAttributeValueType();
    private object ReadPropertyValue();
    public object ReadValue();
    public bool ReadValueAsBoolean();
    public Byte[] ReadValueAsBytes();
    public DateTime ReadValueAsDateTime();
    public double ReadValueAsDouble();
    public float ReadValueAsFloat();
    public Guid ReadValueAsGuid();
    public short ReadValueAsInt16();
    public int ReadValueAsInt32();
    public long ReadValueAsInt64();
    public string ReadValueAsString();
    internal Uri ReadValueAsUri();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    private void LoadPropertyCount();
    private int ReadValueCount();
    private void LoadValueCount();
    private void LoadRowCount();
    internal void Load();
}
public class MimeKit.Tnef.TnefPropertyTag : ValueType {
    public static TnefPropertyTag AbDefaultDir;
    public static TnefPropertyTag AbDefaultPab;
    public static TnefPropertyTag AbProviderId;
    public static TnefPropertyTag AbProviders;
    public static TnefPropertyTag AbSearchPath;
    public static TnefPropertyTag AbSearchPathUpdate;
    public static TnefPropertyTag Access;
    public static TnefPropertyTag AccessLevel;
    public static TnefPropertyTag AccountA;
    public static TnefPropertyTag AccountW;
    public static TnefPropertyTag AcknowledgementMode;
    public static TnefPropertyTag AddrtypeA;
    public static TnefPropertyTag AddrtypeW;
    public static TnefPropertyTag AlternateRecipient;
    public static TnefPropertyTag AlternateRecipientAllowed;
    public static TnefPropertyTag AnrA;
    public static TnefPropertyTag AnrW;
    public static TnefPropertyTag AssistantA;
    public static TnefPropertyTag AssistantW;
    public static TnefPropertyTag AssistantTelephoneNumberA;
    public static TnefPropertyTag AssistantTelephoneNumberW;
    public static TnefPropertyTag AssocContentCount;
    public static TnefPropertyTag AttachAdditionalInfo;
    public static TnefPropertyTag AttachContentBaseA;
    public static TnefPropertyTag AttachContentBaseW;
    public static TnefPropertyTag AttachContentIdA;
    public static TnefPropertyTag AttachContentIdW;
    public static TnefPropertyTag AttachContentLocationA;
    public static TnefPropertyTag AttachContentLocationW;
    public static TnefPropertyTag AttachDataBin;
    public static TnefPropertyTag AttachDataObj;
    public static TnefPropertyTag AttachDispositionA;
    public static TnefPropertyTag AttachDispositionW;
    public static TnefPropertyTag AttachEncoding;
    public static TnefPropertyTag AttachExtensionA;
    public static TnefPropertyTag AttachExtensionW;
    public static TnefPropertyTag AttachFilenameA;
    public static TnefPropertyTag AttachFilenameW;
    public static TnefPropertyTag AttachFlags;
    public static TnefPropertyTag AttachLongFilenameA;
    public static TnefPropertyTag AttachLongFilenameW;
    public static TnefPropertyTag AttachLongPathnameA;
    public static TnefPropertyTag AttachLongPathnameW;
    public static TnefPropertyTag AttachmentContactPhoto;
    public static TnefPropertyTag AttachmentFlags;
    public static TnefPropertyTag AttachmentHidden;
    public static TnefPropertyTag AttachmentLinkId;
    public static TnefPropertyTag AttachmentX400Parameters;
    public static TnefPropertyTag AttachMethod;
    public static TnefPropertyTag AttachMimeSequence;
    public static TnefPropertyTag AttachMimeTagA;
    public static TnefPropertyTag AttachMimeTagW;
    public static TnefPropertyTag AttachNetscapeMacInfo;
    public static TnefPropertyTag AttachNum;
    public static TnefPropertyTag AttachPathnameA;
    public static TnefPropertyTag AttachPathnameW;
    public static TnefPropertyTag AttachRendering;
    public static TnefPropertyTag AttachSize;
    public static TnefPropertyTag AttachTag;
    public static TnefPropertyTag AttachTransportNameA;
    public static TnefPropertyTag AttachTransportNameW;
    public static TnefPropertyTag AuthorizingUsers;
    public static TnefPropertyTag AutoForwarded;
    public static TnefPropertyTag AutoForwardingCommentA;
    public static TnefPropertyTag AutoForwardingCommentW;
    public static TnefPropertyTag AutoResponseSuppress;
    public static TnefPropertyTag BeeperTelephoneNumberA;
    public static TnefPropertyTag BeeperTelephoneNumberW;
    public static TnefPropertyTag Birthday;
    public static TnefPropertyTag BodyA;
    public static TnefPropertyTag BodyW;
    public static TnefPropertyTag BodyContentIdA;
    public static TnefPropertyTag BodyContentIdW;
    public static TnefPropertyTag BodyContentLocationA;
    public static TnefPropertyTag BodyContentLocationW;
    public static TnefPropertyTag BodyCrc;
    public static TnefPropertyTag BodyHtmlA;
    public static TnefPropertyTag BodyHtmlB;
    public static TnefPropertyTag BodyHtmlW;
    public static TnefPropertyTag Business2TelephoneNumberA;
    public static TnefPropertyTag Business2TelephoneNumberAMv;
    public static TnefPropertyTag Business2TelephoneNumberW;
    public static TnefPropertyTag Business2TelephoneNumberWMv;
    public static TnefPropertyTag BusinessAddressCityA;
    public static TnefPropertyTag BusinessAddressCityW;
    public static TnefPropertyTag BusinessAddressCountryA;
    public static TnefPropertyTag BusinessAddressCountryW;
    public static TnefPropertyTag BusinessAddressPostalCodeA;
    public static TnefPropertyTag BusinessAddressPostalCodeW;
    public static TnefPropertyTag BusinessAddressStreetA;
    public static TnefPropertyTag BusinessAddressStreetW;
    public static TnefPropertyTag BusinessFaxNumberA;
    public static TnefPropertyTag BusinessFaxNumberW;
    public static TnefPropertyTag BusinessHomePageA;
    public static TnefPropertyTag BusinessHomePageW;
    public static TnefPropertyTag CallbackTelephoneNumberA;
    public static TnefPropertyTag CallbackTelephoneNumberW;
    public static TnefPropertyTag CarTelephoneNumberA;
    public static TnefPropertyTag CarTelephoneNumberW;
    public static TnefPropertyTag ChildrensNamesA;
    public static TnefPropertyTag ChildrensNamesW;
    public static TnefPropertyTag ClientSubmitTime;
    public static TnefPropertyTag CommentA;
    public static TnefPropertyTag CommentW;
    public static TnefPropertyTag CommonViewsEntryId;
    public static TnefPropertyTag CompanyMainPhoneNumberA;
    public static TnefPropertyTag CompanyMainPhoneNumberW;
    public static TnefPropertyTag CompanyNameA;
    public static TnefPropertyTag CompanyNameW;
    public static TnefPropertyTag ComputerNetworkNameA;
    public static TnefPropertyTag ComputerNetworkNameW;
    public static TnefPropertyTag ContactAddrtypesA;
    public static TnefPropertyTag ContactAddrtypesW;
    public static TnefPropertyTag ContactDefaultAddressIndex;
    public static TnefPropertyTag ContactEmailAddressesA;
    public static TnefPropertyTag ContactEmailAddressesW;
    public static TnefPropertyTag ContactEntryIds;
    public static TnefPropertyTag ContactVersion;
    public static TnefPropertyTag ContainerClassA;
    public static TnefPropertyTag ContainerClassW;
    public static TnefPropertyTag ContainerContents;
    public static TnefPropertyTag ContainerFlags;
    public static TnefPropertyTag ContainerHierarchy;
    public static TnefPropertyTag ContainerModifyVersion;
    public static TnefPropertyTag ContentConfidentialityAlgorithmId;
    public static TnefPropertyTag ContentCorrelator;
    public static TnefPropertyTag ContentCount;
    public static TnefPropertyTag ContentIdentifierA;
    public static TnefPropertyTag ContentIdentifierW;
    public static TnefPropertyTag ContentIntegrityCheck;
    public static TnefPropertyTag ContentLength;
    public static TnefPropertyTag ContentReturnRequested;
    public static TnefPropertyTag ContentsSortOrder;
    public static TnefPropertyTag ContentUnread;
    public static TnefPropertyTag ControlFlags;
    public static TnefPropertyTag ControlId;
    public static TnefPropertyTag ControlStructure;
    public static TnefPropertyTag ControlType;
    public static TnefPropertyTag ConversationIndex;
    public static TnefPropertyTag ConversationKey;
    public static TnefPropertyTag ConversationTopicA;
    public static TnefPropertyTag ConversationTopicW;
    public static TnefPropertyTag ConversionEits;
    public static TnefPropertyTag ConversionProhibited;
    public static TnefPropertyTag ConversionWithLossProhibited;
    public static TnefPropertyTag ConvertedEits;
    public static TnefPropertyTag Correlate;
    public static TnefPropertyTag CorrelateMtsid;
    public static TnefPropertyTag CountryA;
    public static TnefPropertyTag CountryW;
    public static TnefPropertyTag CreateTemplates;
    public static TnefPropertyTag CreationTime;
    public static TnefPropertyTag CreationVersion;
    public static TnefPropertyTag CurrentVersion;
    public static TnefPropertyTag CustomerIdA;
    public static TnefPropertyTag CustomerIdW;
    public static TnefPropertyTag DefaultProfile;
    public static TnefPropertyTag DefaultStore;
    public static TnefPropertyTag DefaultViewEntryId;
    public static TnefPropertyTag DefCreateDl;
    public static TnefPropertyTag DefCreateMailuser;
    public static TnefPropertyTag DeferredDeliveryTime;
    public static TnefPropertyTag Delegation;
    public static TnefPropertyTag DeleteAfterSubmit;
    public static TnefPropertyTag DeliverTime;
    public static TnefPropertyTag DeliveryPoint;
    public static TnefPropertyTag Deltax;
    public static TnefPropertyTag Deltay;
    public static TnefPropertyTag DepartmentNameA;
    public static TnefPropertyTag DepartmentNameW;
    public static TnefPropertyTag Depth;
    public static TnefPropertyTag DetailsTable;
    public static TnefPropertyTag DiscardReason;
    public static TnefPropertyTag DiscloseRecipients;
    public static TnefPropertyTag DisclosureOfRecipients;
    public static TnefPropertyTag DiscreteValues;
    public static TnefPropertyTag DiscVal;
    public static TnefPropertyTag DisplayBccA;
    public static TnefPropertyTag DisplayBccW;
    public static TnefPropertyTag DisplayCcA;
    public static TnefPropertyTag DisplayCcW;
    public static TnefPropertyTag DisplayNameA;
    public static TnefPropertyTag DisplayNameW;
    public static TnefPropertyTag DisplayNamePrefixA;
    public static TnefPropertyTag DisplayNamePrefixW;
    public static TnefPropertyTag DisplayToA;
    public static TnefPropertyTag DisplayToW;
    public static TnefPropertyTag DisplayType;
    public static TnefPropertyTag DlExpansionHistory;
    public static TnefPropertyTag DlExpansionProhibited;
    public static TnefPropertyTag EmailAddressA;
    public static TnefPropertyTag EmailAddressW;
    public static TnefPropertyTag EndDate;
    public static TnefPropertyTag EntryId;
    public static TnefPropertyTag ExpandBeginTime;
    public static TnefPropertyTag ExpandedBeginTime;
    public static TnefPropertyTag ExpandedEndTime;
    public static TnefPropertyTag ExpandEndTime;
    public static TnefPropertyTag ExpiryTime;
    public static TnefPropertyTag ExplicitConversion;
    public static TnefPropertyTag FilteringHooks;
    public static TnefPropertyTag FinderEntryId;
    public static TnefPropertyTag FolderAssociatedContents;
    public static TnefPropertyTag FolderType;
    public static TnefPropertyTag FormCategoryA;
    public static TnefPropertyTag FormCategoryW;
    public static TnefPropertyTag FormCategorySubA;
    public static TnefPropertyTag FormCategorySubW;
    public static TnefPropertyTag FormClsid;
    public static TnefPropertyTag FormContactNameA;
    public static TnefPropertyTag FormContactNameW;
    public static TnefPropertyTag FormDesignerGuid;
    public static TnefPropertyTag FormDesignerNameA;
    public static TnefPropertyTag FormDesignerNameW;
    public static TnefPropertyTag FormHidden;
    public static TnefPropertyTag FormHostMap;
    public static TnefPropertyTag FormMessageBehavior;
    public static TnefPropertyTag FormVersionA;
    public static TnefPropertyTag FormVersionW;
    public static TnefPropertyTag FtpSiteA;
    public static TnefPropertyTag FtpSiteW;
    public static TnefPropertyTag Gender;
    public static TnefPropertyTag GenerationA;
    public static TnefPropertyTag GenerationW;
    public static TnefPropertyTag GivenNameA;
    public static TnefPropertyTag GivenNameW;
    public static TnefPropertyTag GovernmentIdNumberA;
    public static TnefPropertyTag GovernmentIdNumberW;
    public static TnefPropertyTag Hasattach;
    public static TnefPropertyTag HeaderFolderEntryId;
    public static TnefPropertyTag HobbiesA;
    public static TnefPropertyTag HobbiesW;
    public static TnefPropertyTag Home2TelephoneNumberA;
    public static TnefPropertyTag Home2TelephoneNumberAMv;
    public static TnefPropertyTag Home2TelephoneNumberW;
    public static TnefPropertyTag Home2TelephoneNumberWMv;
    public static TnefPropertyTag HomeAddressCityA;
    public static TnefPropertyTag HomeAddressCityW;
    public static TnefPropertyTag HomeAddressCountryA;
    public static TnefPropertyTag HomeAddressCountryW;
    public static TnefPropertyTag HomeAddressPostalCodeA;
    public static TnefPropertyTag HomeAddressPostalCodeW;
    public static TnefPropertyTag HomeAddressPostOfficeBoxA;
    public static TnefPropertyTag HomeAddressPostOfficeBoxW;
    public static TnefPropertyTag HomeAddressStateOrProvinceA;
    public static TnefPropertyTag HomeAddressStateOrProvinceW;
    public static TnefPropertyTag HomeAddressStreetA;
    public static TnefPropertyTag HomeAddressStreetW;
    public static TnefPropertyTag HomeFaxNumberA;
    public static TnefPropertyTag HomeFaxNumberW;
    public static TnefPropertyTag HomeTelephoneNumberA;
    public static TnefPropertyTag HomeTelephoneNumberW;
    public static TnefPropertyTag Icon;
    public static TnefPropertyTag IdentityDisplayA;
    public static TnefPropertyTag IdentityDisplayW;
    public static TnefPropertyTag IdentityEntryId;
    public static TnefPropertyTag IdentitySearchKey;
    public static TnefPropertyTag ImplicitConversionProhibited;
    public static TnefPropertyTag Importance;
    public static TnefPropertyTag IncompleteCopy;
    public static TnefPropertyTag INetMailOverrideCharset;
    public static TnefPropertyTag INetMailOverrideFormat;
    public static TnefPropertyTag InitialDetailsPane;
    public static TnefPropertyTag InitialsA;
    public static TnefPropertyTag InitialsW;
    public static TnefPropertyTag InReplyToIdA;
    public static TnefPropertyTag InReplyToIdW;
    public static TnefPropertyTag InstanceKey;
    public static TnefPropertyTag InternetApprovedA;
    public static TnefPropertyTag InternetApprovedW;
    public static TnefPropertyTag InternetArticleNumber;
    public static TnefPropertyTag InternetControlA;
    public static TnefPropertyTag InternetControlW;
    public static TnefPropertyTag InternetCPID;
    public static TnefPropertyTag InternetDistributionA;
    public static TnefPropertyTag InternetDistributionW;
    public static TnefPropertyTag InternetFollowupToA;
    public static TnefPropertyTag InternetFollowupToW;
    public static TnefPropertyTag InternetLines;
    public static TnefPropertyTag InternetMessageIdA;
    public static TnefPropertyTag InternetMessageIdW;
    public static TnefPropertyTag InternetNewsgroupsA;
    public static TnefPropertyTag InternetNewsgroupsW;
    public static TnefPropertyTag InternetNntpPathA;
    public static TnefPropertyTag InternetNntpPathW;
    public static TnefPropertyTag InternetOrganizationA;
    public static TnefPropertyTag InternetOrganizationW;
    public static TnefPropertyTag InternetPrecedenceA;
    public static TnefPropertyTag InternetPrecedenceW;
    public static TnefPropertyTag InternetReferencesA;
    public static TnefPropertyTag InternetReferencesW;
    public static TnefPropertyTag IpmId;
    public static TnefPropertyTag IpmOutboxEntryId;
    public static TnefPropertyTag IpmOutboxSearchKey;
    public static TnefPropertyTag IpmReturnRequested;
    public static TnefPropertyTag IpmSentmailEntryId;
    public static TnefPropertyTag IpmSentmailSearchKey;
    public static TnefPropertyTag IpmSubtreeEntryId;
    public static TnefPropertyTag IpmSubtreeSearchKey;
    public static TnefPropertyTag IpmWastebasketEntryId;
    public static TnefPropertyTag IpmWastebasketSearchKey;
    public static TnefPropertyTag IsdnNumberA;
    public static TnefPropertyTag IsdnNumberW;
    public static TnefPropertyTag KeywordA;
    public static TnefPropertyTag KeywordW;
    public static TnefPropertyTag LanguageA;
    public static TnefPropertyTag LanguageW;
    public static TnefPropertyTag LanguagesA;
    public static TnefPropertyTag LanguagesW;
    public static TnefPropertyTag LastModificationTime;
    public static TnefPropertyTag LastModifierNameA;
    public static TnefPropertyTag LastModifierNameW;
    public static TnefPropertyTag LatestDeliveryTime;
    public static TnefPropertyTag ListHelpA;
    public static TnefPropertyTag ListHelpW;
    public static TnefPropertyTag ListSubscribeA;
    public static TnefPropertyTag ListSubscribeW;
    public static TnefPropertyTag ListUnsubscribeA;
    public static TnefPropertyTag ListUnsubscribeW;
    public static TnefPropertyTag LocalityA;
    public static TnefPropertyTag LocalityW;
    public static TnefPropertyTag LocationA;
    public static TnefPropertyTag LocationW;
    public static TnefPropertyTag LockBranchId;
    public static TnefPropertyTag LockDepth;
    public static TnefPropertyTag LockEnlistmentContext;
    public static TnefPropertyTag LockExpiryTime;
    public static TnefPropertyTag LockPersistent;
    public static TnefPropertyTag LockResourceDid;
    public static TnefPropertyTag LockResourceFid;
    public static TnefPropertyTag LockResourceMid;
    public static TnefPropertyTag LockScope;
    public static TnefPropertyTag LockTimeout;
    public static TnefPropertyTag LockType;
    public static TnefPropertyTag MailPermission;
    public static TnefPropertyTag ManagerNameA;
    public static TnefPropertyTag ManagerNameW;
    public static TnefPropertyTag MappingSignature;
    public static TnefPropertyTag MdbProvider;
    public static TnefPropertyTag MessageAttachments;
    public static TnefPropertyTag MessageCcMe;
    public static TnefPropertyTag MessageClassA;
    public static TnefPropertyTag MessageClassW;
    public static TnefPropertyTag MessageCodepage;
    public static TnefPropertyTag MessageDeliveryId;
    public static TnefPropertyTag MessageDeliveryTime;
    public static TnefPropertyTag MessageDownloadTime;
    public static TnefPropertyTag MessageFlags;
    public static TnefPropertyTag MessageRecipients;
    public static TnefPropertyTag MessageRecipMe;
    public static TnefPropertyTag MessageSecurityLabel;
    public static TnefPropertyTag MessageSize;
    public static TnefPropertyTag MessageSubmissionId;
    public static TnefPropertyTag MessageToken;
    public static TnefPropertyTag MessageToMe;
    public static TnefPropertyTag MhsCommonNameA;
    public static TnefPropertyTag MhsCommonNameW;
    public static TnefPropertyTag MiddleNameA;
    public static TnefPropertyTag MiddleNameW;
    public static TnefPropertyTag MiniIcon;
    public static TnefPropertyTag MobileTelephoneNumberA;
    public static TnefPropertyTag MobileTelephoneNumberW;
    public static TnefPropertyTag ModifyVersion;
    public static TnefPropertyTag MsgStatus;
    public static TnefPropertyTag NdrDiagCode;
    public static TnefPropertyTag NdrReasonCode;
    public static TnefPropertyTag NdrStatusCode;
    public static TnefPropertyTag NewsgroupNameA;
    public static TnefPropertyTag NewsgroupNameW;
    public static TnefPropertyTag NicknameA;
    public static TnefPropertyTag NicknameW;
    public static TnefPropertyTag NntpXrefA;
    public static TnefPropertyTag NntpXrefW;
    public static TnefPropertyTag NonReceiptNotificationRequested;
    public static TnefPropertyTag NonReceiptReason;
    public static TnefPropertyTag NormalizedSubjectA;
    public static TnefPropertyTag NormalizedSubjectW;
    public static TnefPropertyTag NtSecurityDescriptor;
    public static TnefPropertyTag Null;
    public static TnefPropertyTag ObjectType;
    public static TnefPropertyTag ObsoletedIpms;
    public static TnefPropertyTag Office2TelephoneNumberA;
    public static TnefPropertyTag Office2TelephoneNumberW;
    public static TnefPropertyTag OfficeLocationA;
    public static TnefPropertyTag OfficeLocationW;
    public static TnefPropertyTag OfficeTelephoneNumberA;
    public static TnefPropertyTag OfficeTelephoneNumberW;
    public static TnefPropertyTag OofReplyType;
    public static TnefPropertyTag OrganizationalIdNumberA;
    public static TnefPropertyTag OrganizationalIdNumberW;
    public static TnefPropertyTag OrigEntryId;
    public static TnefPropertyTag OriginalAuthorAddrtypeA;
    public static TnefPropertyTag OriginalAuthorAddrtypeW;
    public static TnefPropertyTag OriginalAuthorEmailAddressA;
    public static TnefPropertyTag OriginalAuthorEmailAddressW;
    public static TnefPropertyTag OriginalAuthorEntryId;
    public static TnefPropertyTag OriginalAuthorNameA;
    public static TnefPropertyTag OriginalAuthorNameW;
    public static TnefPropertyTag OriginalAuthorSearchKey;
    public static TnefPropertyTag OriginalDeliveryTime;
    public static TnefPropertyTag OriginalDisplayBccA;
    public static TnefPropertyTag OriginalDisplayBccW;
    public static TnefPropertyTag OriginalDisplayCcA;
    public static TnefPropertyTag OriginalDisplayCcW;
    public static TnefPropertyTag OriginalDisplayNameA;
    public static TnefPropertyTag OriginalDisplayNameW;
    public static TnefPropertyTag OriginalDisplayToA;
    public static TnefPropertyTag OriginalDisplayToW;
    public static TnefPropertyTag OriginalEits;
    public static TnefPropertyTag OriginalEntryId;
    public static TnefPropertyTag OriginallyIntendedRecipAddrtypeA;
    public static TnefPropertyTag OriginallyIntendedRecipAddrtypeW;
    public static TnefPropertyTag OriginallyIntendedRecipEmailAddressA;
    public static TnefPropertyTag OriginallyIntendedRecipEmailAddressW;
    public static TnefPropertyTag OriginallyIntendedRecipEntryId;
    public static TnefPropertyTag OriginallyIntendedRecipientName;
    public static TnefPropertyTag OriginalSearchKey;
    public static TnefPropertyTag OriginalSenderAddrtypeA;
    public static TnefPropertyTag OriginalSenderAddrtypeW;
    public static TnefPropertyTag OriginalSenderEmailAddressA;
    public static TnefPropertyTag OriginalSenderEmailAddressW;
    public static TnefPropertyTag OriginalSenderEntryId;
    public static TnefPropertyTag OriginalSenderNameA;
    public static TnefPropertyTag OriginalSenderNameW;
    public static TnefPropertyTag OriginalSenderSearchKey;
    public static TnefPropertyTag OriginalSensitivity;
    public static TnefPropertyTag OriginalSentRepresentingAddrtypeA;
    public static TnefPropertyTag OriginalSentRepresentingAddrtypeW;
    public static TnefPropertyTag OriginalSentRepresentingEmailAddressA;
    public static TnefPropertyTag OriginalSentRepresentingEmailAddressW;
    public static TnefPropertyTag OriginalSentRepresentingEntryId;
    public static TnefPropertyTag OriginalSentRepresentingNameA;
    public static TnefPropertyTag OriginalSentRepresentingNameW;
    public static TnefPropertyTag OriginalSentRepresentingSearchKey;
    public static TnefPropertyTag OriginalSubjectA;
    public static TnefPropertyTag OriginalSubjectW;
    public static TnefPropertyTag OriginalSubmitTime;
    public static TnefPropertyTag OriginatingMtaCertificate;
    public static TnefPropertyTag OriginatorAndDlExpansionHistory;
    public static TnefPropertyTag OriginatorCertificate;
    public static TnefPropertyTag OriginatorDeliveryReportRequested;
    public static TnefPropertyTag OriginatorNonDeliveryReportRequested;
    public static TnefPropertyTag OriginatorRequestedAlternateRecipient;
    public static TnefPropertyTag OriginatorReturnAddress;
    public static TnefPropertyTag OriginCheck;
    public static TnefPropertyTag OrigMessageClassA;
    public static TnefPropertyTag OrigMessageClassW;
    public static TnefPropertyTag OtherAddressCityA;
    public static TnefPropertyTag OtherAddressCityW;
    public static TnefPropertyTag OtherAddressCountryA;
    public static TnefPropertyTag OtherAddressCountryW;
    public static TnefPropertyTag OtherAddressPostalCodeA;
    public static TnefPropertyTag OtherAddressPostalCodeW;
    public static TnefPropertyTag OtherAddressPostOfficeBoxA;
    public static TnefPropertyTag OtherAddressPostOfficeBoxW;
    public static TnefPropertyTag OtherAddressStateOrProvinceA;
    public static TnefPropertyTag OtherAddressStateOrProvinceW;
    public static TnefPropertyTag OtherAddressStreetA;
    public static TnefPropertyTag OtherAddressStreetW;
    public static TnefPropertyTag OtherTelephoneNumberA;
    public static TnefPropertyTag OtherTelephoneNumberW;
    public static TnefPropertyTag OwnerApptId;
    public static TnefPropertyTag OwnStoreEntryId;
    public static TnefPropertyTag PagerTelephoneNumberA;
    public static TnefPropertyTag PagerTelephoneNumberW;
    public static TnefPropertyTag ParentDisplayA;
    public static TnefPropertyTag ParentDisplayW;
    public static TnefPropertyTag ParentEntryId;
    public static TnefPropertyTag ParentKey;
    public static TnefPropertyTag PersonalHomePageA;
    public static TnefPropertyTag PersonalHomePageW;
    public static TnefPropertyTag PhysicalDeliveryBureauFaxDelivery;
    public static TnefPropertyTag PhysicalDeliveryMode;
    public static TnefPropertyTag PhysicalDeliveryReportRequest;
    public static TnefPropertyTag PhysicalForwardingAddress;
    public static TnefPropertyTag PhysicalForwardingAddressRequested;
    public static TnefPropertyTag PhysicalForwardingProhibited;
    public static TnefPropertyTag PhysicalRenditionAttributes;
    public static TnefPropertyTag PostalAddressA;
    public static TnefPropertyTag PostalAddressW;
    public static TnefPropertyTag PostalCodeA;
    public static TnefPropertyTag PostalCodeW;
    public static TnefPropertyTag PostFolderEntries;
    public static TnefPropertyTag PostFolderNamesA;
    public static TnefPropertyTag PostFolderNamesW;
    public static TnefPropertyTag PostOfficeBoxA;
    public static TnefPropertyTag PostOfficeBoxW;
    public static TnefPropertyTag PostReplyDenied;
    public static TnefPropertyTag PostReplyFolderEntries;
    public static TnefPropertyTag PostReplyFolderNamesA;
    public static TnefPropertyTag PostReplyFolderNamesW;
    public static TnefPropertyTag PreferredByNameA;
    public static TnefPropertyTag PreferredByNameW;
    public static TnefPropertyTag Preprocess;
    public static TnefPropertyTag PrimaryCapability;
    public static TnefPropertyTag PrimaryFaxNumberA;
    public static TnefPropertyTag PrimaryFaxNumberW;
    public static TnefPropertyTag PrimaryTelephoneNumberA;
    public static TnefPropertyTag PrimaryTelephoneNumberW;
    public static TnefPropertyTag Priority;
    public static TnefPropertyTag ProfessionA;
    public static TnefPropertyTag ProfessionW;
    public static TnefPropertyTag ProfileNameA;
    public static TnefPropertyTag ProfileNameW;
    public static TnefPropertyTag ProofOfDelivery;
    public static TnefPropertyTag ProofOfDeliveryRequested;
    public static TnefPropertyTag ProofOfSubmission;
    public static TnefPropertyTag ProofOfSubmissionRequested;
    public static TnefPropertyTag ProviderDisplayA;
    public static TnefPropertyTag ProviderDisplayW;
    public static TnefPropertyTag ProviderDllNameA;
    public static TnefPropertyTag ProviderDllNameW;
    public static TnefPropertyTag ProviderOrdinal;
    public static TnefPropertyTag ProviderSubmitTime;
    public static TnefPropertyTag ProviderUid;
    public static TnefPropertyTag Puid;
    public static TnefPropertyTag RadioTelephoneNumberA;
    public static TnefPropertyTag RadioTelephoneNumberW;
    public static TnefPropertyTag RcvdRepresentingAddrtypeA;
    public static TnefPropertyTag RcvdRepresentingAddrtypeW;
    public static TnefPropertyTag RcvdRepresentingEmailAddressA;
    public static TnefPropertyTag RcvdRepresentingEmailAddressW;
    public static TnefPropertyTag RcvdRepresentingEntryId;
    public static TnefPropertyTag RcvdRepresentingNameA;
    public static TnefPropertyTag RcvdRepresentingNameW;
    public static TnefPropertyTag RcvdRepresentingSearchKey;
    public static TnefPropertyTag ReadReceiptEntryId;
    public static TnefPropertyTag ReadReceiptRequested;
    public static TnefPropertyTag ReadReceiptSearchKey;
    public static TnefPropertyTag ReceiptTime;
    public static TnefPropertyTag ReceivedByAddrtypeA;
    public static TnefPropertyTag ReceivedByAddrtypeW;
    public static TnefPropertyTag ReceivedByEmailAddressA;
    public static TnefPropertyTag ReceivedByEmailAddressW;
    public static TnefPropertyTag ReceivedByEntryId;
    public static TnefPropertyTag ReceivedByNameA;
    public static TnefPropertyTag ReceivedByNameW;
    public static TnefPropertyTag ReceivedBySearchKey;
    public static TnefPropertyTag ReceiveFolderSettings;
    public static TnefPropertyTag RecipientCertificate;
    public static TnefPropertyTag RecipientDisplayNameA;
    public static TnefPropertyTag RecipientDisplayNameW;
    public static TnefPropertyTag RecipientNumberForAdviceA;
    public static TnefPropertyTag RecipientNumberForAdviceW;
    public static TnefPropertyTag RecipientReassignmentProhibited;
    public static TnefPropertyTag RecipientStatus;
    public static TnefPropertyTag RecipientType;
    public static TnefPropertyTag RedirectionHistory;
    public static TnefPropertyTag ReferredByNameA;
    public static TnefPropertyTag ReferredByNameW;
    public static TnefPropertyTag RegisteredMailType;
    public static TnefPropertyTag RelatedIpms;
    public static TnefPropertyTag RemoteProgress;
    public static TnefPropertyTag RemoteProgressTextA;
    public static TnefPropertyTag RemoteProgressTextW;
    public static TnefPropertyTag RemoteValidateOk;
    public static TnefPropertyTag RenderingPosition;
    public static TnefPropertyTag ReplyRecipientEntries;
    public static TnefPropertyTag ReplyRecipientNamesA;
    public static TnefPropertyTag ReplyRecipientNamesW;
    public static TnefPropertyTag ReplyRequested;
    public static TnefPropertyTag ReplyTime;
    public static TnefPropertyTag ReportEntryId;
    public static TnefPropertyTag ReportingDlName;
    public static TnefPropertyTag ReportingMtaCertificate;
    public static TnefPropertyTag ReportNameA;
    public static TnefPropertyTag ReportNameW;
    public static TnefPropertyTag ReportSearchKey;
    public static TnefPropertyTag ReportTag;
    public static TnefPropertyTag ReportTextA;
    public static TnefPropertyTag ReportTextW;
    public static TnefPropertyTag ReportTime;
    public static TnefPropertyTag RequestedDeliveryMethod;
    public static TnefPropertyTag ResourceFlags;
    public static TnefPropertyTag ResourceMethods;
    public static TnefPropertyTag ResourcePathA;
    public static TnefPropertyTag ResourcePathW;
    public static TnefPropertyTag ResourceType;
    public static TnefPropertyTag ResponseRequested;
    public static TnefPropertyTag Responsibility;
    public static TnefPropertyTag ReturnedIpm;
    public static TnefPropertyTag Rowid;
    public static TnefPropertyTag RowType;
    public static TnefPropertyTag RtfCompressed;
    public static TnefPropertyTag RtfInSync;
    public static TnefPropertyTag RtfSyncBodyCount;
    public static TnefPropertyTag RtfSyncBodyCrc;
    public static TnefPropertyTag RtfSyncBodyTagA;
    public static TnefPropertyTag RtfSyncBodyTagW;
    public static TnefPropertyTag RtfSyncPrefixCount;
    public static TnefPropertyTag RtfSyncTrailingCount;
    public static TnefPropertyTag Search;
    public static TnefPropertyTag SearchKey;
    public static TnefPropertyTag Security;
    public static TnefPropertyTag Selectable;
    public static TnefPropertyTag SenderAddrtypeA;
    public static TnefPropertyTag SenderAddrtypeW;
    public static TnefPropertyTag SenderEmailAddressA;
    public static TnefPropertyTag SenderEmailAddressW;
    public static TnefPropertyTag SenderEntryId;
    public static TnefPropertyTag SenderNameA;
    public static TnefPropertyTag SenderNameW;
    public static TnefPropertyTag SenderSearchKey;
    public static TnefPropertyTag SendInternetEncoding;
    public static TnefPropertyTag SendRecallReport;
    public static TnefPropertyTag SendRichInfo;
    public static TnefPropertyTag Sensitivity;
    public static TnefPropertyTag SentmailEntryId;
    public static TnefPropertyTag SentRepresentingAddrtypeA;
    public static TnefPropertyTag SentRepresentingAddrtypeW;
    public static TnefPropertyTag SentRepresentingEmailAddressA;
    public static TnefPropertyTag SentRepresentingEmailAddressW;
    public static TnefPropertyTag SentRepresentingEntryId;
    public static TnefPropertyTag SentRepresentingNameA;
    public static TnefPropertyTag SentRepresentingNameW;
    public static TnefPropertyTag SentRepresentingSearchKey;
    public static TnefPropertyTag ServiceDeleteFilesA;
    public static TnefPropertyTag ServiceDeleteFilesW;
    public static TnefPropertyTag ServiceDllNameA;
    public static TnefPropertyTag ServiceDllNameW;
    public static TnefPropertyTag ServiceEntryName;
    public static TnefPropertyTag ServiceExtraUids;
    public static TnefPropertyTag ServiceNameA;
    public static TnefPropertyTag ServiceNameW;
    public static TnefPropertyTag Services;
    public static TnefPropertyTag ServiceSupportFilesA;
    public static TnefPropertyTag ServiceSupportFilesW;
    public static TnefPropertyTag ServiceUid;
    public static TnefPropertyTag SevenBitDisplayName;
    public static TnefPropertyTag SmtpAddressA;
    public static TnefPropertyTag SmtpAddressW;
    public static TnefPropertyTag SpoolerStatus;
    public static TnefPropertyTag SpouseNameA;
    public static TnefPropertyTag SpouseNameW;
    public static TnefPropertyTag StartDate;
    public static TnefPropertyTag StateOrProvinceA;
    public static TnefPropertyTag StateOrProvinceW;
    public static TnefPropertyTag Status;
    public static TnefPropertyTag StatusCode;
    public static TnefPropertyTag StatusStringA;
    public static TnefPropertyTag StatusStringW;
    public static TnefPropertyTag StoreEntryId;
    public static TnefPropertyTag StoreProviders;
    public static TnefPropertyTag StoreRecordKey;
    public static TnefPropertyTag StoreState;
    public static TnefPropertyTag StoreSupportMask;
    public static TnefPropertyTag StreetAddressA;
    public static TnefPropertyTag StreetAddressW;
    public static TnefPropertyTag Subfolders;
    public static TnefPropertyTag SubjectA;
    public static TnefPropertyTag SubjectW;
    public static TnefPropertyTag SubjectIpm;
    public static TnefPropertyTag SubjectPrefixA;
    public static TnefPropertyTag SubjectPrefixW;
    public static TnefPropertyTag SubmitFlags;
    public static TnefPropertyTag SupersedesA;
    public static TnefPropertyTag SupersedesW;
    public static TnefPropertyTag SupplementaryInfoA;
    public static TnefPropertyTag SupplementaryInfoW;
    public static TnefPropertyTag SurnameA;
    public static TnefPropertyTag SurnameW;
    public static TnefPropertyTag TelexNumberA;
    public static TnefPropertyTag TelexNumberW;
    public static TnefPropertyTag Templateid;
    public static TnefPropertyTag TitleA;
    public static TnefPropertyTag TitleW;
    public static TnefPropertyTag TnefCorrelationKey;
    public static TnefPropertyTag TransmitableDisplayNameA;
    public static TnefPropertyTag TransmitableDisplayNameW;
    public static TnefPropertyTag TransportKey;
    public static TnefPropertyTag TransportMessageHeadersA;
    public static TnefPropertyTag TransportMessageHeadersW;
    public static TnefPropertyTag TransportProviders;
    public static TnefPropertyTag TransportStatus;
    public static TnefPropertyTag TtytddPhoneNumberA;
    public static TnefPropertyTag TtytddPhoneNumberW;
    public static TnefPropertyTag TypeOfMtsUser;
    public static TnefPropertyTag UserCertificate;
    public static TnefPropertyTag UserX509Certificate;
    public static TnefPropertyTag ValidFolderMask;
    public static TnefPropertyTag ViewsEntryId;
    public static TnefPropertyTag WeddingAnniversary;
    public static TnefPropertyTag X400ContentType;
    public static TnefPropertyTag X400DeferredDeliveryCancel;
    public static TnefPropertyTag Xpos;
    public static TnefPropertyTag Ypos;
    private static TnefPropertyId NamedMin;
    private static TnefPropertyId NamedMax;
    private static short MultiValuedFlag;
    private TnefPropertyType type;
    private TnefPropertyId id;
    public TnefPropertyId Id { get; }
    public bool IsMultiValued { get; }
    public bool IsNamed { get; }
    public bool IsTnefTypeValid { get; }
    public TnefPropertyType TnefType { get; }
    public TnefPropertyType ValueTnefType { get; }
    public TnefPropertyTag(int tag);
    private TnefPropertyTag(TnefPropertyId id, TnefPropertyType type, bool multiValue);
    public TnefPropertyTag(TnefPropertyId id, TnefPropertyType type);
    private static TnefPropertyTag();
    public TnefPropertyId get_Id();
    public bool get_IsMultiValued();
    public bool get_IsNamed();
    public bool get_IsTnefTypeValid();
    public TnefPropertyType get_TnefType();
    public TnefPropertyType get_ValueTnefType();
    public static TnefPropertyTag op_Implicit(int tag);
    public static int op_Implicit(TnefPropertyTag tag);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public virtual string ToString();
    public TnefPropertyTag ToUnicode();
    public static bool op_Equality(TnefPropertyTag left, TnefPropertyTag right);
    public static bool op_Inequality(TnefPropertyTag left, TnefPropertyTag right);
}
public enum MimeKit.Tnef.TnefPropertyType : Enum {
    public short value__;
    public static TnefPropertyType Unspecified;
    public static TnefPropertyType Null;
    public static TnefPropertyType I2;
    public static TnefPropertyType Long;
    public static TnefPropertyType R4;
    public static TnefPropertyType Double;
    public static TnefPropertyType Currency;
    public static TnefPropertyType AppTime;
    public static TnefPropertyType Error;
    public static TnefPropertyType Boolean;
    public static TnefPropertyType Object;
    public static TnefPropertyType I8;
    public static TnefPropertyType String8;
    public static TnefPropertyType Unicode;
    public static TnefPropertyType SysTime;
    public static TnefPropertyType ClassId;
    public static TnefPropertyType Binary;
    public static TnefPropertyType MultiValued;
}
public class MimeKit.Tnef.TnefReader : object {
    internal static int TnefSignature;
    private static int ReadAheadSize;
    private static int BlockSize;
    private static int PadSize;
    private Byte[] input;
    private static int inputStart;
    private int inputIndex;
    private int inputEnd;
    private long position;
    private int checksum;
    private int codepage;
    private int version;
    private bool closed;
    private bool eos;
    [CompilerGeneratedAttribute]
private short <AttachmentKey>k__BackingField;
    [CompilerGeneratedAttribute]
private TnefAttributeLevel <AttributeLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private int <AttributeRawValueLength>k__BackingField;
    [CompilerGeneratedAttribute]
private int <AttributeRawValueStreamOffset>k__BackingField;
    [CompilerGeneratedAttribute]
private TnefAttributeTag <AttributeTag>k__BackingField;
    [CompilerGeneratedAttribute]
private TnefComplianceMode <ComplianceMode>k__BackingField;
    [CompilerGeneratedAttribute]
private TnefComplianceStatus <ComplianceStatus>k__BackingField;
    [CompilerGeneratedAttribute]
private Stream <InputStream>k__BackingField;
    [CompilerGeneratedAttribute]
private TnefPropertyReader <TnefPropertyReader>k__BackingField;
    public short AttachmentKey { get; private set; }
    public TnefAttributeLevel AttributeLevel { get; private set; }
    public int AttributeRawValueLength { get; private set; }
    public int AttributeRawValueStreamOffset { get; private set; }
    public TnefAttributeTag AttributeTag { get; private set; }
    internal TnefAttributeType AttributeType { get; }
    public TnefComplianceMode ComplianceMode { get; private set; }
    public TnefComplianceStatus ComplianceStatus { get; internal set; }
    internal Stream InputStream { get; private set; }
    public int MessageCodepage { get; private set; }
    public TnefPropertyReader TnefPropertyReader { get; private set; }
    public int StreamOffset { get; }
    public int TnefVersion { get; private set; }
    public TnefReader(Stream inputStream, int defaultMessageCodepage, TnefComplianceMode complianceMode);
    public TnefReader(Stream inputStream);
    [CompilerGeneratedAttribute]
public short get_AttachmentKey();
    [CompilerGeneratedAttribute]
private void set_AttachmentKey(short value);
    [CompilerGeneratedAttribute]
public TnefAttributeLevel get_AttributeLevel();
    [CompilerGeneratedAttribute]
private void set_AttributeLevel(TnefAttributeLevel value);
    [CompilerGeneratedAttribute]
public int get_AttributeRawValueLength();
    [CompilerGeneratedAttribute]
private void set_AttributeRawValueLength(int value);
    [CompilerGeneratedAttribute]
public int get_AttributeRawValueStreamOffset();
    [CompilerGeneratedAttribute]
private void set_AttributeRawValueStreamOffset(int value);
    [CompilerGeneratedAttribute]
public TnefAttributeTag get_AttributeTag();
    [CompilerGeneratedAttribute]
private void set_AttributeTag(TnefAttributeTag value);
    internal TnefAttributeType get_AttributeType();
    [CompilerGeneratedAttribute]
public TnefComplianceMode get_ComplianceMode();
    [CompilerGeneratedAttribute]
private void set_ComplianceMode(TnefComplianceMode value);
    [CompilerGeneratedAttribute]
public TnefComplianceStatus get_ComplianceStatus();
    [CompilerGeneratedAttribute]
internal void set_ComplianceStatus(TnefComplianceStatus value);
    [CompilerGeneratedAttribute]
internal Stream get_InputStream();
    [CompilerGeneratedAttribute]
private void set_InputStream(Stream value);
    public int get_MessageCodepage();
    private void set_MessageCodepage(int value);
    [CompilerGeneratedAttribute]
public TnefPropertyReader get_TnefPropertyReader();
    [CompilerGeneratedAttribute]
private void set_TnefPropertyReader(TnefPropertyReader value);
    public int get_StreamOffset();
    public int get_TnefVersion();
    private void set_TnefVersion(int value);
    protected virtual override void Finalize();
    private void CheckDisposed();
    internal int ReadAhead(int atleast);
    internal void SetComplianceError(TnefComplianceStatus error, Exception innerException);
    private void DecodeHeader();
    private void CheckAttributeLevel();
    private void CheckAttributeTag();
    internal byte ReadByte();
    internal short ReadInt16();
    internal int ReadInt32();
    internal int PeekInt32();
    internal long ReadInt64();
    internal float ReadSingle();
    internal double ReadDouble();
    internal bool Seek(int offset);
    private bool SkipAttributeRawValue();
    public bool ReadNextAttribute();
    private void UpdateChecksum(Byte[] buffer, int offset, int count);
    public int ReadAttributeRawValue(Byte[] buffer, int offset, int count);
    public void ResetComplianceStatus();
    public void Close();
    protected virtual void Dispose(bool disposing);
    public sealed virtual void Dispose();
}
internal class MimeKit.Tnef.TnefReaderStream : Stream {
    private int valueEndOffset;
    private int dataEndOffset;
    private TnefReader reader;
    private bool disposed;
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public bool CanSeek { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public TnefReaderStream(TnefReader tnefReader, int dataEndOffset, int valueEndOffset);
    private void CheckDisposed();
    public virtual bool get_CanRead();
    public virtual bool get_CanWrite();
    public virtual bool get_CanSeek();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    private static void ValidateArguments(Byte[] buffer, int offset, int count);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void Flush();
    public virtual void SetLength(long value);
    protected virtual void Dispose(bool disposing);
}
internal class MimeKit.Utils.BufferPool : object {
    private Byte[][] buffers;
    private SpinLock spinLock;
    private int index;
    [CompilerGeneratedAttribute]
private int <BufferSize>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxBufferCount>k__BackingField;
    public int BufferSize { get; private set; }
    public int MaxBufferCount { get; private set; }
    public BufferPool(int bufferSize, int maxBufferCount);
    [CompilerGeneratedAttribute]
public int get_BufferSize();
    [CompilerGeneratedAttribute]
private void set_BufferSize(int value);
    [CompilerGeneratedAttribute]
public int get_MaxBufferCount();
    [CompilerGeneratedAttribute]
private void set_MaxBufferCount(int value);
    public Byte[] Rent(bool clear);
    public void Return(Byte[] buffer);
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[CompilerFeatureRequiredAttribute("RefStructs")]
internal class MimeKit.Utils.ByteArrayBuilder : ValueType {
    private Byte[] buffer;
    private int length;
    public ByteArrayBuilder(int initialCapacity);
    private void EnsureCapacity(int capacity);
    public void Append(byte c);
    public void Append(Byte[] text, int startIndex, int count);
    public Byte[] ToArray();
    public void Dispose();
}
[ExtensionAttribute]
internal static class MimeKit.Utils.ByteExtensions : object {
    private static string AtomSafeCharacters;
    private static string AttributeSpecials;
    private static string CommentSpecials;
    private static string DomainSpecials;
    private static string EncodedWordSpecials;
    private static string EncodedPhraseSpecials;
    private static string Specials;
    internal static string TokenSpecials;
    private static string Whitespace;
    private static CharType[] table;
    private static ByteExtensions();
    private static void RemoveFlags(string values, CharType bit);
    private static void SetFlags(string values, CharType bit, CharType bitcopy, bool remove);
    [ExtensionAttribute]
public static bool IsAsciiAtom(byte c);
    [ExtensionAttribute]
public static bool IsPhraseAtom(byte c);
    [ExtensionAttribute]
public static bool IsAtom(byte c);
    [ExtensionAttribute]
public static bool IsAttr(byte c);
    [ExtensionAttribute]
public static bool IsBlank(byte c);
    [ExtensionAttribute]
public static bool IsCtrl(byte c);
    [ExtensionAttribute]
public static bool IsDomain(byte c);
    [ExtensionAttribute]
public static bool IsFieldText(byte c);
    [ExtensionAttribute]
public static bool IsQpSafe(byte c);
    [ExtensionAttribute]
public static bool IsToken(byte c);
    [ExtensionAttribute]
public static bool IsType(byte c, CharType type);
    [ExtensionAttribute]
public static bool IsWhitespace(byte c);
    [ExtensionAttribute]
public static bool IsXDigit(byte c);
    [ExtensionAttribute]
public static byte ToXDigit(byte c);
}
internal static class MimeKit.Utils.CharsetUtils : object {
    private static Char[] DashUnderscore;
    private static Dictionary`2<string, int> aliases;
    public static Encoding Latin1;
    public static Encoding UTF8;
    private static CharsetUtils();
    private static bool ProbeCharset(int codepage);
    private static int AddAliases(Dictionary`2<string, int> dict, int codepage, int fallback, String[] names);
    public static string GetMimeCharset(Encoding encoding);
    public static string GetMimeCharset(string charset);
    private static bool TryParseInt32(string text, int startIndex, int count, Int32& value);
    private static int ParseIsoCodePage(string charset, int startIndex);
    internal static int ParseCodePage(string charset);
    public static int GetCodePage(string charset);
    public static Encoding GetEncoding(string charset, string fallback);
    public static Encoding GetEncoding(string charset);
    public static Encoding GetEncoding(int codepage, string fallback);
    public static Encoding GetEncoding(int codepage);
    public static Encoding GetEncodingOrDefault(int codepage, Encoding defaultEncoding);
    internal static Char[] ConvertToUnicode(ParserOptions options, Byte[] input, int startIndex, int length, Int32& charCount);
    public static string ConvertToUnicode(ParserOptions options, Byte[] buffer, int startIndex, int length);
    internal static Char[] ConvertToUnicode(Encoding encoding, Byte[] input, int startIndex, int length, Int32& charCount);
    internal static Char[] ConvertToUnicode(ParserOptions options, int codepage, Byte[] input, int startIndex, int length, Int32& charCount);
    public static string ConvertToUnicode(Encoding encoding, Byte[] buffer, int startIndex, int length);
    public static bool TryGetBomEncoding(Byte[] buffer, int length, Encoding& encoding);
    public static bool TryGetBomEncoding(Stream stream, Encoding& encoding);
}
[FlagsAttribute]
internal enum MimeKit.Utils.CharType : Enum {
    public ushort value__;
    public static CharType None;
    public static CharType IsAscii;
    public static CharType IsAtom;
    public static CharType IsAttrChar;
    public static CharType IsBlank;
    public static CharType IsControl;
    public static CharType IsDomainSafe;
    public static CharType IsEncodedPhraseSafe;
    public static CharType IsEncodedWordSafe;
    public static CharType IsQuotedPrintableSafe;
    public static CharType IsSpace;
    public static CharType IsSpecial;
    public static CharType IsTokenSpecial;
    public static CharType IsWhitespace;
    public static CharType IsXDigit;
    public static CharType IsPhraseAtom;
    public static CharType IsFieldText;
    public static CharType IsAsciiAtom;
}
internal class MimeKit.Utils.Crc32 : object {
    private static UInt32[] Crc32Table;
    private int initialValue;
    private int crc;
    public int Checksum { get; }
    public Crc32(int initialValue);
    private static Crc32();
    public Crc32 Clone();
    public int get_Checksum();
    private static void ValidateArguments(Byte[] buffer, int offset, int count);
    public int Update(Byte[] buffer, int offset, int count);
    public int Update(byte value);
    public void Reset();
}
[IsReadOnlyAttribute]
internal class MimeKit.Utils.DateToken : ValueType {
    [CompilerGeneratedAttribute]
private DateTokenFlags <Flags>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Start>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Length>k__BackingField;
    public DateTokenFlags Flags { get; }
    public int Start { get; }
    public int Length { get; }
    public bool IsNumeric { get; }
    public bool IsWeekday { get; }
    public bool IsMonth { get; }
    public bool IsTimeOfDay { get; }
    public bool IsNumericZone { get; }
    public bool IsAlphaZone { get; }
    public bool IsTimeZone { get; }
    public DateToken(DateTokenFlags flags, int start, int length);
    [CompilerGeneratedAttribute]
public DateTokenFlags get_Flags();
    [CompilerGeneratedAttribute]
public int get_Start();
    [CompilerGeneratedAttribute]
public int get_Length();
    public bool get_IsNumeric();
    public bool get_IsWeekday();
    public bool get_IsMonth();
    public bool get_IsTimeOfDay();
    public bool get_IsNumericZone();
    public bool get_IsAlphaZone();
    public bool get_IsTimeZone();
}
[FlagsAttribute]
internal enum MimeKit.Utils.DateTokenFlags : Enum {
    public byte value__;
    public static DateTokenFlags None;
    public static DateTokenFlags NonNumeric;
    public static DateTokenFlags NonWeekday;
    public static DateTokenFlags NonMonth;
    public static DateTokenFlags NonTime;
    public static DateTokenFlags NonAlphaZone;
    public static DateTokenFlags NonNumericZone;
    public static DateTokenFlags HasColon;
    public static DateTokenFlags HasSign;
}
public static class MimeKit.Utils.DateUtils : object {
    internal static DateTime UnixEpoch;
    private static string MonthCharacters;
    private static string WeekdayCharacters;
    private static string AlphaZoneCharacters;
    private static string NumericZoneCharacters;
    private static string NumericCharacters;
    private static string TimeCharacters;
    private static String[] Months;
    private static String[] WeekDays;
    private static Dictionary`2<string, int> timezones;
    private static DateTokenFlags[] datetok;
    private static DateUtils();
    private static bool TryGetWeekday(DateToken& token, Byte[] text, DayOfWeek& weekday);
    private static bool TryGetDayOfMonth(DateToken& token, Byte[] text, Int32& day);
    private static bool TryGetMonth(DateToken& token, Byte[] text, Int32& month);
    private static bool TryGetYear(DateToken& token, Byte[] text, Int32& year);
    private static bool TryGetTimeOfDay(DateToken& token, Byte[] text, Int32& hour, Int32& minute, Int32& second);
    private static bool TryGetTimeZone(DateToken& token, Byte[] text, Int32& tzone);
    private static bool IsTokenDelimiter(byte c);
    private static List`1<DateToken> TokenizeDate(Byte[] text, int startIndex, int length);
    private static bool TryParseStandardDateFormat(List`1<DateToken> tokens, Byte[] text, DateTimeOffset& date);
    private static bool TryParseUnknownDateFormat(IList`1<DateToken> tokens, Byte[] text, DateTimeOffset& date);
    public static bool TryParse(Byte[] buffer, int startIndex, int length, DateTimeOffset& date);
    public static bool TryParse(Byte[] buffer, int startIndex, DateTimeOffset& date);
    public static bool TryParse(Byte[] buffer, DateTimeOffset& date);
    public static bool TryParse(string text, DateTimeOffset& date);
    public static string FormatDate(DateTimeOffset date);
}
[ExtensionAttribute]
public static class MimeKit.Utils.MimeUtils : object {
    private static string base36;
    private static string DefaultHostName;
    private static Char[] UnquoteChars;
    public static IEqualityComparer`1<string> OrdinalIgnoreCase;
    private static MimeUtils();
    public static string GenerateMessageId(string domain);
    public static string GenerateMessageId();
    [IteratorStateMachineAttribute("MimeKit.Utils.MimeUtils/<EnumerateReferences>d__7")]
public static IEnumerable`1<string> EnumerateReferences(Byte[] buffer, int startIndex, int length);
    public static IEnumerable`1<string> EnumerateReferences(string text);
    public static string ParseMessageId(Byte[] buffer, int startIndex, int length);
    public static string ParseMessageId(string text);
    public static bool TryParse(Byte[] buffer, int startIndex, int length, Version& version);
    public static bool TryParse(string text, Version& version);
    private static bool IsEncoding(string value, string text, int startIndex, int length);
    public static bool TryParse(string text, ContentEncoding& encoding);
    public static StringBuilder AppendQuoted(StringBuilder builder, string text);
    internal static void AppendQuoted(ValueStringBuilder& builder, ReadOnlySpan`1<char> text);
    [ExtensionAttribute]
internal static void AppendQuoted(ValueStringBuilder& builder, string text);
    public static string Quote(ReadOnlySpan`1<char> text);
    public static string Quote(string text);
    public static string Unquote(string text, bool convertTabsToSpaces);
    internal static Byte[] Unquote(Byte[] text, int startIndex, int length, bool convertTabsToSpaces);
}
internal class MimeKit.Utils.PackedByteArray : object {
    private static int InitialBufferSize;
    private UInt16[] buffer;
    private int length;
    private int cursor;
    public int Count { get; }
    public int get_Count();
    private void EnsureBufferSize(int size);
    public void Add(byte item);
    public void Clear();
    public void CopyTo(Byte[] array, int arrayIndex);
}
internal static class MimeKit.Utils.ParseUtils : object {
    private static ReadOnlySpan`1<byte> GreaterThanOrAt { get; }
    public static void ValidateArguments(ParserOptions options, Byte[] buffer, int startIndex, int length);
    public static void ValidateArguments(ParserOptions options, Byte[] buffer, int startIndex);
    public static void ValidateArguments(ParserOptions options, Byte[] buffer);
    public static void ValidateArguments(ParserOptions options, string text);
    public static void ValidateArguments(Byte[] buffer, int startIndex, int length);
    public static bool TryParseInt32(Byte[] text, Int32& index, int endIndex, Int32& value);
    public static bool SkipWhiteSpace(Byte[] text, Int32& index, int endIndex);
    public static bool SkipComment(Byte[] text, Int32& index, int endIndex);
    public static bool SkipComment(string text, Int32& index, int endIndex);
    public static bool SkipCommentsAndWhiteSpace(Byte[] text, Int32& index, int endIndex, bool throwOnError);
    public static bool SkipQuoted(Byte[] text, Int32& index, int endIndex, bool throwOnError);
    public static bool SkipAtom(Byte[] text, Int32& index, int endIndex);
    public static bool SkipPhraseAtom(Byte[] text, Int32& index, int endIndex);
    public static bool SkipToken(Byte[] text, Int32& index, int endIndex);
    public static bool SkipWord(Byte[] text, Int32& index, int endIndex, bool throwOnError);
    public static bool IsSentinel(byte c, ReadOnlySpan`1<byte> sentinels);
    private static bool TryParseDotAtom(Byte[] text, Int32& index, int endIndex, ReadOnlySpan`1<byte> sentinels, bool throwOnError, string tokenType, String& dotatom);
    private static bool TryParseDomainLiteral(Byte[] text, Int32& index, int endIndex, bool throwOnError, String& domain);
    public static bool TryParseDomain(Byte[] text, Int32& index, int endIndex, ReadOnlySpan`1<byte> sentinels, bool throwOnError, String& domain);
    private static ReadOnlySpan`1<byte> get_GreaterThanOrAt();
    public static bool TryParseMsgId(Byte[] text, Int32& index, int endIndex, bool requireAngleAddr, bool throwOnError, String& msgid);
    public static bool IsInternational(string value, int startIndex, int count);
    public static bool IsInternational(string value, int startIndex);
    public static bool IsInternational(string value);
    public static bool IsIdnEncoded(string value);
}
[ExtensionAttribute]
internal static class MimeKit.Utils.ReadOnlySpanExtensions : object {
    [ExtensionAttribute]
public static ReadOnlySpanTokenizer`1<T> Tokenize(ReadOnlySpan`1<T> span, T separator);
    [ExtensionAttribute]
public static ReadOnlySpanTokenizer`1<char> Tokenize(string text, char separator);
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[CompilerFeatureRequiredAttribute("RefStructs")]
[EditorBrowsableAttribute("1")]
internal class MimeKit.Utils.ReadOnlySpanTokenizer`1 : ValueType {
    private ReadOnlySpan`1<T> span;
    private T separator;
    private int start;
    private int end;
    public ReadOnlySpan`1<T> Current { get; }
    public ReadOnlySpanTokenizer`1(ReadOnlySpan`1<T> span, T separator);
    [IsReadOnlyAttribute]
public ReadOnlySpanTokenizer`1<T> GetEnumerator();
    public bool MoveNext();
    [IsReadOnlyAttribute]
public ReadOnlySpan`1<T> get_Current();
}
public static class MimeKit.Utils.Rfc2047 : object {
    private static bool IsAscii(byte c);
    private static bool IsAsciiAtom(byte c);
    private static bool IsAtom(byte c);
    private static bool IsBbQq(byte c);
    private static bool IsLwsp(byte c);
    private static bool TryGetEncodedWordToken(Byte* input, Byte* word, int length, Token& token);
    private static void TokenizePhrase(ParserOptions options, ITokenWriter writer, ValueStringBuilder& decoded, Byte* inbuf, int startIndex, int length);
    private static void TokenizeText(ParserOptions options, ITokenWriter writer, ValueStringBuilder& output, Byte* inbuf, int startIndex, int length);
    internal static string DecodePhrase(ParserOptions options, Byte[] phrase, int startIndex, int count, Int32& codepage);
    public static string DecodePhrase(ParserOptions options, Byte[] phrase, int startIndex, int count);
    public static string DecodePhrase(Byte[] phrase, int startIndex, int count);
    public static string DecodePhrase(ParserOptions options, Byte[] phrase);
    public static string DecodePhrase(Byte[] phrase);
    internal static string DecodeText(ParserOptions options, Byte[] text, int startIndex, int count, Int32& codepage);
    public static string DecodeText(ParserOptions options, Byte[] text, int startIndex, int count);
    public static string DecodeText(Byte[] text, int startIndex, int count);
    public static string DecodeText(ParserOptions options, Byte[] text);
    public static string DecodeText(Byte[] text);
    internal static Byte[] FoldUnstructuredHeader(FormatOptions options, string field, Byte[] text);
    private static Byte[] CharsetConvert(Encoding charset, Char[] word, int length, Int32& converted);
    private static ContentEncoding GetBestContentEncoding(Byte[] text, int startIndex, int length);
    private static bool CharsetRequiresBase64(Encoding encoding);
    internal static int AppendEncodedWord(ValueStringBuilder& builder, Encoding charset, string text, int startIndex, int length, QEncodeMode mode);
    private static void AppendQuoted(ValueStringBuilder& str, string text, int startIndex, int length);
    private static bool IsAtom(char c);
    private static bool IsBlank(char c);
    private static bool IsCtrl(char c);
    private static int EstimateEncodedWordLength(string charset, int byteCount, int encodeCount);
    private static int EstimateEncodedWordLength(Encoding charset, int byteCount, int encodeCount);
    private static bool ExceedsMaxLineLength(FormatOptions options, Encoding charset, Word word);
    private static List`1<Word> GetRfc822Words(FormatOptions options, Encoding charset, string text, int startIndex, int count, bool phrase);
    private static bool ShouldMergeWords(FormatOptions options, Encoding charset, List`1<Word> words, Word word, int i);
    private static void Merge(Word word, Word next);
    private static List`1<Word> MergeAdjacent(FormatOptions options, Encoding charset, List`1<Word> words);
    private static List`1<Word> Merge(FormatOptions options, Encoding charset, List`1<Word> words);
    private static void Encode(ValueStringBuilder& builder, FormatOptions options, Encoding charset, string text, int startIndex, int count, EncodeType type);
    private static Byte[] AsByteArray(ValueStringBuilder& builder);
    private static Byte[] EncodeAsBytes(FormatOptions options, Encoding charset, string text, int startIndex, int count, EncodeType type);
    private static string EncodeAsString(FormatOptions options, Encoding charset, string text, int startIndex, int count, EncodeType type);
    private static void ValidateArguments(FormatOptions options, Encoding charset, string text, string textArgName);
    private static void ValidateArguments(FormatOptions options, Encoding charset, string text, string textArgName, int startIndex, int count);
    internal static string EncodeComment(FormatOptions options, Encoding charset, string text, int startIndex, int count);
    internal static string EncodePhraseAsString(FormatOptions options, Encoding charset, string phrase);
    public static Byte[] EncodePhrase(FormatOptions options, Encoding charset, string phrase, int startIndex, int count);
    public static Byte[] EncodePhrase(Encoding charset, string phrase, int startIndex, int count);
    public static Byte[] EncodePhrase(FormatOptions options, Encoding charset, string phrase);
    public static Byte[] EncodePhrase(Encoding charset, string phrase);
    public static Byte[] EncodeText(FormatOptions options, Encoding charset, string text, int startIndex, int count);
    public static Byte[] EncodeText(Encoding charset, string text, int startIndex, int count);
    public static Byte[] EncodeText(FormatOptions options, Encoding charset, string text);
    public static Byte[] EncodeText(Encoding charset, string text);
}
[ExtensionAttribute]
internal static class MimeKit.Utils.StringBuilderExtensions : object {
    [ExtensionAttribute]
public static StringBuilder LineWrap(StringBuilder text, FormatOptions options);
    [ExtensionAttribute]
public static void AppendTokens(StringBuilder text, FormatOptions options, Int32& lineLength, List`1<string> tokens);
    [ExtensionAttribute]
public static StringBuilder AppendFolded(StringBuilder text, FormatOptions options, bool firstToken, string value, Int32& lineLength);
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[CompilerFeatureRequiredAttribute("RefStructs")]
[DefaultMemberAttribute("Item")]
internal class MimeKit.Utils.ValueStringBuilder : ValueType {
    [NullableAttribute("2")]
private Char[] _arrayToReturnToPool;
    private Span`1<char> _chars;
    private int _pos;
    public int Length { get; }
    public Char& Item { get; }
    public ValueStringBuilder(int initialCapacity);
    public int get_Length();
    public Char& get_Item(int index);
    [NullableContextAttribute("1")]
public virtual string ToString();
    public ReadOnlySpan`1<char> AsSpan();
    [NullableContextAttribute("2")]
public void Insert(int index, string s);
    public void Append(char c);
    [NullableContextAttribute("2")]
public void Append(string s);
    [NullableContextAttribute("1")]
public void AppendJoin(char seperator, IList`1<string> values);
    [NullableContextAttribute("1")]
private void AppendSlow(string s);
    public void Append(ReadOnlySpan`1<char> value);
    [NullableContextAttribute("1")]
internal void AppendInvariant(T value, string format);
    private void GrowAndAppend(char c);
    private void Grow(int additionalCapacityBeyondPos);
    public void Dispose();
}
public enum MimeKit.XMessagePriority : Enum {
    public int value__;
    public static XMessagePriority Highest;
    public static XMessagePriority High;
    public static XMessagePriority Normal;
    public static XMessagePriority Low;
    public static XMessagePriority Lowest;
}
