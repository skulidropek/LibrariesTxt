public class Holzer.AccessDeniedException : ApplicationException {
    private string displayName;
    [CompilerGeneratedAttribute]
private string <ErrorCode>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ErrorReportNumber>k__BackingField;
    public string DisplayName { get; }
    public string ErrorCode { get; public set; }
    public string ErrorReportNumber { get; public set; }
    protected AccessDeniedException(SerializationInfo info, StreamingContext context);
    public AccessDeniedException(string displayName);
    public AccessDeniedException(string description, bool assembleMessage, bool appendCurrentUserInfo);
    private static string AssembleMessage(string description, bool assembleMessage, bool appendCurrentUserInfo);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public string get_DisplayName();
    [CompilerGeneratedAttribute]
public string get_ErrorCode();
    [CompilerGeneratedAttribute]
public void set_ErrorCode(string value);
    [CompilerGeneratedAttribute]
public string get_ErrorReportNumber();
    [CompilerGeneratedAttribute]
public void set_ErrorReportNumber(string value);
}
public class Holzer.AccessDeniedFaultException : FaultException {
    public AccessDeniedFaultException(string message);
}
public class Holzer.Actions.ActionHandler : MulticastDelegate {
    public ActionHandler(object object, IntPtr method);
    public virtual void Invoke(object sender);
    public virtual IAsyncResult BeginInvoke(object sender, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class Holzer.Actions.ActionLogEntry : object {
    private ActionLogEntryType type;
    private string text;
    private int indentation;
    [CompilerGeneratedAttribute]
private DateTime <Occured>k__BackingField;
    public ActionLogEntryType Type { get; public set; }
    public int Indentation { get; public set; }
    public string Text { get; public set; }
    public DateTime Occured { get; public set; }
    public ActionLogEntry(ActionLogEntryType type, int indentation, string text);
    public ActionLogEntryType get_Type();
    public void set_Type(ActionLogEntryType value);
    public int get_Indentation();
    public void set_Indentation(int value);
    public string get_Text();
    public void set_Text(string value);
    [CompilerGeneratedAttribute]
public DateTime get_Occured();
    [CompilerGeneratedAttribute]
public void set_Occured(DateTime value);
}
public enum Holzer.Actions.ActionLogEntryType : Enum {
    public int value__;
    public static ActionLogEntryType Standard;
    public static ActionLogEntryType Passive;
    public static ActionLogEntryType Error;
}
public class Holzer.Actions.ActionLogEntryWriter : object {
    private List`1<ActionLogEntry> entries;
    private bool hasErrors;
    private int indents;
    public bool HasErrors { get; }
    public bool HasEntries { get; }
    public int Indentation { get; }
    public ActionLogEntry[] GetEntries();
    public sealed virtual bool get_HasErrors();
    public sealed virtual bool get_HasEntries();
    public sealed virtual int get_Indentation();
    public sealed virtual void Indent();
    public sealed virtual void Unindent();
    public sealed virtual void WritePassiveLine(string s);
    public sealed virtual void WritePassiveLine(string s, Object[] args);
    public sealed virtual void WriteLine();
    public sealed virtual void WriteLine(string s);
    public void WriteLineFirst(string s);
    public sealed virtual void WriteLine(string s, Object[] args);
    public sealed virtual void WriteProgress(ActionProgressLog progress);
    public sealed virtual void WriteErrorLine(string s);
    public sealed virtual void WriteErrorLine(string s, Object[] args);
    public ActionLogEntry GetLastEntry();
    public void CopyTo(IActionLog to);
    public virtual string ToString();
}
public class Holzer.Actions.ActionMulticastLog : object {
    private List`1<IActionLog> logs;
    private bool hasErrors;
    private int indentation;
    private bool entryWritten;
    public bool HasErrors { get; }
    public bool HasEntries { get; }
    public int Indentation { get; }
    public virtual string ToString();
    public void AddTarget(IActionLog log);
    public sealed virtual bool get_HasErrors();
    public sealed virtual bool get_HasEntries();
    public sealed virtual int get_Indentation();
    public sealed virtual void Indent();
    public sealed virtual void Unindent();
    public sealed virtual void WritePassiveLine(string s);
    public sealed virtual void WritePassiveLine(string s, Object[] args);
    public sealed virtual void WriteLine();
    public sealed virtual void WriteLine(string s);
    public sealed virtual void WriteLine(string s, Object[] args);
    public sealed virtual void WriteProgress(ActionProgressLog progress);
    public sealed virtual void WriteErrorLine(string s);
    public sealed virtual void WriteErrorLine(string s, Object[] args);
    public sealed virtual void Dispose();
}
public class Holzer.Actions.ActionProgressLog : object {
    [CompilerGeneratedAttribute]
private int <ActivityId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Activity>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Status>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<decimal> <Progress>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <SecondsRemaining>k__BackingField;
    public int ActivityId { get; public set; }
    public string Activity { get; public set; }
    public string Status { get; public set; }
    public Nullable`1<decimal> Progress { get; public set; }
    public Nullable`1<int> SecondsRemaining { get; public set; }
    public ActionProgressLog(string activity, string status, Nullable`1<decimal> progress, Nullable`1<int> activityId);
    [CompilerGeneratedAttribute]
public int get_ActivityId();
    [CompilerGeneratedAttribute]
public void set_ActivityId(int value);
    [CompilerGeneratedAttribute]
public string get_Activity();
    [CompilerGeneratedAttribute]
public void set_Activity(string value);
    [CompilerGeneratedAttribute]
public string get_Status();
    [CompilerGeneratedAttribute]
public void set_Status(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<decimal> get_Progress();
    [CompilerGeneratedAttribute]
public void set_Progress(Nullable`1<decimal> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_SecondsRemaining();
    [CompilerGeneratedAttribute]
public void set_SecondsRemaining(Nullable`1<int> value);
    public virtual string ToString();
}
public class Holzer.Actions.ApplicationCommandLine : object {
    private static ApplicationCommandLine environmentCommandLine;
    private Dictionary`2<string, string> keyValue;
    public static ApplicationCommandLine GetCurrentEnvironmentCommandLine();
    public virtual string ToString();
    private static ApplicationCommandLine ParseCommandLine();
    public static ApplicationCommandLine ParseCommandLineArgs(String[] args);
    public static ApplicationCommandLine ParseCommandLineArgs(string line);
    private static void AddFromCommandLine(ApplicationCommandLine command, string line);
    private static void AddFromCommandLineArgs(ApplicationCommandLine command, String[] lineParts);
    private static String[] SplitParts(string s);
    public string GetNamedArgumentValue(string name);
}
public class Holzer.Actions.CommandLine : object {
    private string command;
    private String[] arguments;
    public String[] Arguments { get; }
    public string Command { get; }
    public CommandLine(string command, String[] arguments);
    public String[] get_Arguments();
    public string get_Command();
}
public class Holzer.Actions.ConsoleAction : MulticastDelegate {
    public ConsoleAction(object object, IntPtr method);
    public virtual void Invoke(ConsoleResult result, string cmd, Object[] args);
    public virtual IAsyncResult BeginInvoke(ConsoleResult result, string cmd, Object[] args, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class Holzer.Actions.ConsoleActionAttribute : Attribute {
    private string description;
    public string Description { get; }
    public ConsoleActionAttribute(string description);
    public string get_Description();
}
public class Holzer.Actions.ConsoleActionInfo : object {
    private string name;
    private string description;
    public string Name { get; }
    public string Description { get; }
    public ConsoleActionInfo(string name, string description);
    public ConsoleActionInfo(string name);
    public static string ConvertMethodNameToActionName(string name);
    public string get_Name();
    public string get_Description();
}
public class Holzer.Actions.ConsoleHelper : object {
    private static IntPtr hStdin;
    private static IntPtr hStdout;
    private static int dwSaveOldMode;
    private static int dwMode;
    private static int iCounter;
    private static Hashtable htCodeLookup;
    private static int iMaxNumberOfCharacters;
    private static int MaxNumberOfCharacters { get; private set; }
    private static ConsoleHelper();
    private static bool ReadConsoleInput(IntPtr hConsoleInput, INPUT_RECORD[] lpBuffer, UInt32 nLength, UInt32& lpNumberOfEventsRead);
    private static IntPtr GetStdHandle(int nStdHandle);
    private static bool GetConsoleMode(IntPtr hConsoleHandle, Int32& Mode);
    private static bool SetConsoleMode(IntPtr hConsoleHandle, int Mode);
    private static UInt32 GetLastError();
    private static bool WriteConsole(IntPtr hConsoleOutput, string lpBuffer, UInt32 nNumberOfCharsToWrite, UInt32& lpNumberOfCharsWritten, IntPtr lpReserved);
    private static bool FlushConsoleInputBuffer(IntPtr hConsoleInput);
    private static bool WriteConsoleOutputCharacter(IntPtr hConsoleOutput, string lpCharacter, UInt32 nLength, COORD dwWriteCoord, UInt32& lpNumberOfCharsWritten);
    private static bool KeyEventProc(INPUT_RECORD input_record, String& strBuildup);
    private static bool MouseEventProc(INPUT_RECORD input_record, String& strBuildup);
    private static bool WindowBufferSizeEventProc(INPUT_RECORD input_record, String& strBuildup);
    private static bool MenuEventProc(INPUT_RECORD input_record, String& strBuildup);
    private static bool FocusEventProc(INPUT_RECORD input_record, String& strBuildup);
    private static int get_MaxNumberOfCharacters();
    private static void set_MaxNumberOfCharacters(int value);
    public static string ReadPassword(int iMaxNumberOfCharactersSet);
}
public class Holzer.Actions.ConsoleResult : MarshalByRefObject {
    private IConsoleResult result;
    public ConsoleResult(IConsoleResult result);
    public sealed virtual void WriteData(string type, object context);
    public sealed virtual void WriteLine(string s);
    public sealed virtual void WriteErrorLine(string s);
    public sealed virtual void WriteWarningLine(string s);
    public sealed virtual void Complete(string command);
    public sealed virtual string Input(string question);
    public sealed virtual string InputKey(string question);
    public sealed virtual void Clear();
    public sealed virtual void Reconnect();
    public sealed virtual void Close();
    public virtual object InitializeLifetimeService();
}
public class Holzer.Actions.ConsoleResultTextWriter : MarshalByRefObject {
    private static ConsoleColor localConsoleColor;
    private TextWriter output;
    private TextReader reader;
    private ActionHandler close;
    private ActionHandler reconnect;
    public ConsoleResultTextWriter(TextWriter output, TextReader reader, ActionHandler close, ActionHandler reconnect);
    public sealed virtual void WriteData(string type, object context);
    public sealed virtual void WriteLine(string s);
    public sealed virtual void WriteErrorLine(string s);
    public sealed virtual void WriteWarningLine(string s);
    public sealed virtual void Complete(string command);
    public sealed virtual string Input(string question);
    public sealed virtual string InputKey(string question);
    private void Output(string s, ConsoleColor color);
    public sealed virtual void Clear();
    public sealed virtual void Reconnect();
    public sealed virtual void Close();
    public virtual object InitializeLifetimeService();
}
public class Holzer.Actions.ConsoleRuntime : object {
    private static string customPermissionName;
    private static ArrayList actionInfos;
    private static HybridDictionary actionByName;
    private static ConsoleRuntime();
    public static CommandLine ParseCommandLine(string commandLine);
    public static String[] ParseArguments(string s);
    public static void AddAssemblyActions(Assembly assembly);
    public static void Register(ConsoleActionInfo actionInfo, ConsoleAction action);
    public static void Execute(ConsoleResult result, string cmd, Object[] args);
    public static void Execute(ConsoleResult result, string cmd, Object[] args, Type[] allowedActionTypes);
    private static string FindAction(string cmd, ConsoleAction& action);
    public static ConsoleActionInfo[] GetActions();
    public static void CheckPermission();
    public static void SetCustomPermissionName(string customPermissionName);
}
public class Holzer.Actions.ConsoleWriterActionLog : TextActionLog {
    private StringBuilder line;
    public ConsoleWriterActionLog(bool writeLineBreaksImmediately);
    public sealed virtual void Dispose();
    protected virtual void Write(string s);
    protected virtual void WriteLineBreak();
    public virtual void WriteErrorLineCore(string s, Object[] args);
    private void WriteOutstandingLine();
}
internal class Holzer.Actions.Constants : object {
    internal static int STD_INPUT_HANDLE;
    internal static int STD_OUTPUT_HANDLE;
    internal static int STD_ERROR_HANDLE;
    internal static int ENABLE_WINDOW_INPUT;
    internal static int ENABLE_MOUSE_INPUT;
    internal static int KEY_EVENT;
    internal static int MOUSE_EVENT;
    internal static int WINDOW_BUFFER_SIZE_EVENT;
    internal static int MENU_EVENT;
    internal static int FOCUS_EVENT;
    internal static IntPtr INVALID_HANDLE_VALUE;
    private static Constants();
}
internal class Holzer.Actions.COORD : ValueType {
    public short X;
    public short Y;
    public COORD(short x, short y);
}
public class Holzer.Actions.DefaultAction : MulticastDelegate {
    public DefaultAction(object object, IntPtr method);
    public virtual void Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class Holzer.Actions.EventUnion : ValueType {
    internal KEY_EVENT_RECORD KeyEvent;
    internal MOUSE_EVENT_RECORD MouseEvent;
    internal WINDOW_BUFFER_SIZE_RECORD WindowBufferSizeEvent;
    internal MENU_EVENT_RECORD MenuEvent;
    internal FOCUS_EVENT_RECORD FocusEvent;
}
internal class Holzer.Actions.FOCUS_EVENT_RECORD : ValueType {
    internal bool bSetFocus;
}
public abstract class Holzer.Actions.HtmlActionLog : object {
    private string itemCssClass;
    private string indentCssClass;
    private int indents;
    private bool hasErrors;
    private string htmlLogPreamble;
    private string htmlLogPostamble;
    private bool entryWritten;
    public bool HasErrors { get; }
    public bool HasEntries { get; }
    public int Indentation { get; }
    public HtmlActionLog(string itemCssClass, string indentCssClass, string htmlLogPreamble, string htmlLogPostamble);
    public sealed virtual bool get_HasErrors();
    public sealed virtual bool get_HasEntries();
    public sealed virtual void Indent();
    public sealed virtual void Unindent();
    public sealed virtual int get_Indentation();
    public sealed virtual void WritePassiveLine(string s);
    private string Encode(string html);
    public sealed virtual void WritePassiveLine(string s, Object[] args);
    public sealed virtual void WriteLine();
    public sealed virtual void WriteLine(string s);
    public sealed virtual void WriteLine(string s, Object[] args);
    public sealed virtual void WriteProgress(ActionProgressLog progress);
    public sealed virtual void WriteErrorLine(string s);
    public sealed virtual void WriteErrorLine(string s, Object[] args);
    protected string GetCloseTags();
    private void WriteHtmlLineCore(string html);
    protected abstract virtual void WriteHtmlLine(string html);
    public virtual void Dispose();
    public void End();
}
public class Holzer.Actions.HtmlStringActionLog : HtmlActionLog {
    private StringBuilder text;
    private string outerCssClass;
    public HtmlStringActionLog(string itemCssClass, string indentCssClass, string outerCssClass, string htmlLogPreamble, string htmlLogPostamble);
    public HtmlStringActionLog(string itemCssClass, string indentCssClass, string outerCssClass);
    protected virtual void WriteHtmlLine(string html);
    public virtual string ToString();
}
public class Holzer.Actions.HtmlWriterActionLog : HtmlActionLog {
    private TextWriter writer;
    public HtmlWriterActionLog(string itemCssClass, string indentCssClass, TextWriter writer);
    public HtmlWriterActionLog(string itemCssClass, string indentCssClass, TextWriter writer, string htmlLogPreamble, string htmlLogPostamble);
    protected virtual void WriteHtmlLine(string html);
    public virtual void Dispose();
}
public interface Holzer.Actions.IActionLog {
    public bool HasErrors { get; }
    public bool HasEntries { get; }
    public int Indentation { get; }
    public abstract virtual bool get_HasErrors();
    public abstract virtual bool get_HasEntries();
    public abstract virtual int get_Indentation();
    public abstract virtual void Indent();
    public abstract virtual void Unindent();
    public abstract virtual void WritePassiveLine(string s);
    public abstract virtual void WritePassiveLine(string s, Object[] args);
    public abstract virtual void WriteLine();
    public abstract virtual void WriteLine(string s);
    public abstract virtual void WriteLine(string s, Object[] args);
    public abstract virtual void WriteProgress(ActionProgressLog progress);
    public abstract virtual void WriteErrorLine(string s);
    public abstract virtual void WriteErrorLine(string s, Object[] args);
}
public interface Holzer.Actions.IConsoleResult {
    public abstract virtual void WriteLine(string s);
    public abstract virtual void WriteErrorLine(string s);
    public abstract virtual void WriteWarningLine(string s);
    public abstract virtual void WriteData(string type, object context);
    public abstract virtual void Complete(string command);
    public abstract virtual string Input(string question);
    public abstract virtual string InputKey(string question);
    public abstract virtual void Clear();
    public abstract virtual void Reconnect();
    public abstract virtual void Close();
}
internal class Holzer.Actions.INPUT_RECORD : ValueType {
    internal ushort EventType;
    internal EventUnion Event;
}
internal class Holzer.Actions.KEY_EVENT_RECORD : ValueType {
    internal int bKeyDown;
    internal ushort wRepeatCount;
    internal ushort wVirtualKeyCode;
    internal ushort wVirtualScanCode;
    internal uCharUnion uchar;
    internal UInt32 dwControlKeyState;
}
internal class Holzer.Actions.MENU_EVENT_RECORD : ValueType {
    internal UInt32 dwCommandId;
}
internal class Holzer.Actions.MOUSE_EVENT_RECORD : ValueType {
    public COORD dwMousePosition;
    public UInt32 dwButtonState;
    public UInt32 dwControlKeyState;
    public UInt32 dwEventFlags;
}
public class Holzer.Actions.StringActionLog : TextActionLog {
    private StringBuilder text;
    public int Length { get; }
    protected virtual void Write(string s);
    protected virtual void WriteLineBreak();
    public virtual string ToString();
    public int get_Length();
}
public abstract class Holzer.Actions.TextActionLog : object {
    private bool breakNext;
    private string indent;
    private int indentation;
    private bool hasErrors;
    private bool writeLineBreaksImmediately;
    private bool writePassiveLine;
    private bool prependIndentationCharacters;
    private bool entryWritten;
    [CompilerGeneratedAttribute]
private bool <WriteEntryTypes>k__BackingField;
    public bool HasErrors { get; }
    public bool HasEntries { get; }
    public int Indentation { get; }
    public bool OutputPassiveLine { get; public set; }
    public bool PrependIndentationCharacters { get; }
    public bool WriteEntryTypes { get; public set; }
    public TextActionLog(bool writeLineBreaksImmediately, bool prependIndentationCharacters, int indentation);
    public sealed virtual bool get_HasErrors();
    public sealed virtual bool get_HasEntries();
    public sealed virtual void Indent();
    public sealed virtual void Unindent();
    public sealed virtual int get_Indentation();
    public sealed virtual void WriteLine();
    public virtual void WriteProgress(ActionProgressLog progress);
    public sealed virtual void WritePassiveLine(string s);
    public sealed virtual void WritePassiveLine(string s, Object[] arg);
    public sealed virtual void WriteErrorLine(string s);
    public sealed virtual void WriteErrorLine(string s, Object[] args);
    public virtual void WriteErrorLineCore(string s, Object[] args);
    public sealed virtual void WriteLine(string s, Object[] arg);
    public sealed virtual void WriteLine(string s);
    protected void WriteLineBreakIfNeeded();
    protected abstract virtual void Write(string s);
    protected abstract virtual void WriteLineBreak();
    public bool get_OutputPassiveLine();
    public void set_OutputPassiveLine(bool value);
    public bool get_PrependIndentationCharacters();
    [CompilerGeneratedAttribute]
public bool get_WriteEntryTypes();
    [CompilerGeneratedAttribute]
public void set_WriteEntryTypes(bool value);
}
public class Holzer.Actions.TextWriterActionLog : TextActionLog {
    private TextWriter writer;
    public TextWriterActionLog(TextWriter writer);
    protected virtual void Write(string s);
    protected virtual void WriteLineBreak();
    public sealed virtual void Dispose();
}
public class Holzer.Actions.ThreadSafeActionLog : object {
    private IActionLog inner;
    private bool entryWritten;
    public bool HasErrors { get; }
    public bool HasEntries { get; }
    public int Indentation { get; }
    public ThreadSafeActionLog(IActionLog inner);
    public sealed virtual bool get_HasErrors();
    public sealed virtual bool get_HasEntries();
    public sealed virtual void Indent();
    public sealed virtual void Unindent();
    public sealed virtual int get_Indentation();
    public sealed virtual void WritePassiveLine(string s);
    public sealed virtual void WritePassiveLine(string s, Object[] args);
    public sealed virtual void WriteLine();
    public sealed virtual void WriteLine(string s);
    public sealed virtual void WriteLine(string s, Object[] args);
    public sealed virtual void WriteProgress(ActionProgressLog progress);
    public sealed virtual void WriteErrorLine(string s);
    public sealed virtual void WriteErrorLine(string s, Object[] args);
}
internal class Holzer.Actions.uCharUnion : ValueType {
    internal ushort UnicodeChar;
    internal byte AsciiChar;
}
internal class Holzer.Actions.WINDOW_BUFFER_SIZE_RECORD : ValueType {
    internal COORD dwSize;
}
public enum Holzer.ActionType : Enum {
    public byte value__;
    public static ActionType Get;
    public static ActionType Enumerate;
    public static ActionType Insert;
    public static ActionType Update;
    public static ActionType Delete;
}
[DataContractAttribute]
public class Holzer.Actor : object {
    private int id;
    private string federationGuid;
    private string federationName;
    private string guid;
    private string name;
    private string displayName;
    [DataMemberAttribute]
public int Id { get; public set; }
    [DataMemberAttribute]
public string FederationName { get; public set; }
    [DataMemberAttribute]
public string FederationGuid { get; public set; }
    [DataMemberAttribute]
public string Guid { get; public set; }
    [DataMemberAttribute]
public string Name { get; public set; }
    [DataMemberAttribute]
public string DisplayName { get; public set; }
    public Actor(int id, string federationName, string federationGuid, string guid, string name, string displayName);
    public int get_Id();
    public void set_Id(int value);
    public string get_FederationName();
    public void set_FederationName(string value);
    public string get_FederationGuid();
    public void set_FederationGuid(string value);
    public string get_Guid();
    public void set_Guid(string value);
    public string get_Name();
    public void set_Name(string value);
    public string get_DisplayName();
    public void set_DisplayName(string value);
    public virtual string ToString();
}
public class Holzer.Caching.CacheClearHandler : MulticastDelegate {
    public CacheClearHandler(object object, IntPtr method);
    public virtual void Invoke(Transaction transaction);
    public virtual IAsyncResult BeginInvoke(Transaction transaction, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class Holzer.Caching.CacheCollection`1 : object {
    private bool ignoreID;
    private bool clearCache;
    private bool hasIRefreshableObject;
    private ICacheDependency cacheDependency;
    private Dictionary`2<int, CacheItem`1<TData, TData>> idTable;
    private Dictionary`2<string, CacheItem`1<TData, TData>> nameTable;
    public int Count { get; }
    public CacheCollection`1(bool clearCache, bool ignoreID);
    public CacheCollection`1(ICacheDependency cacheDependency, bool ignoreID);
    public int get_Count();
    private void EnsureFreshCache(SessionContext sessionContext);
    public bool Contains(SessionContext sessionContext, int id);
    public TData Get(SessionContext sessionContext, int id);
    public TData Get(SessionContext sessionContext, string name);
    private CacheItem`1<TData, TData> GetCacheItem(int id);
    private CacheItem`1<TData, TData> GetCacheItem(string name);
    public TData InsertOrGet(SessionContext sessionContext, string name, TData item);
    public TData InsertOrGet(SessionContext sessionContext, int id, string name, TData item);
    public void Clear(SessionContext sessionContext);
    public TData[] ToArray();
    private void CacheSystem_Clear(SessionContext sessionContext);
}
public class Holzer.Caching.CacheDependencies : object {
    private static int VersionCacheLifeTimeMs;
    private static int VersionCacheLifeTimeMsAsyncCollect;
    private static ICacheTracker tracker;
    private static long lastCollection;
    private static long asyncCollectBegun;
    private static Dictionary`2<int, int> versions;
    private static WaitCallback asyncCacheRefresh;
    private static CacheDependencies();
    public static void SetTracker(ICacheTracker tracker);
    public static void IncrementVersion(SessionContext sessionContext, int scope);
    public static ICacheDependency CreateDependency(int scope);
    public static ICacheDependency CreateDependency(int scope, bool isInitiallyChanged);
    private static void CheckTrackerAttached();
    public static int GetSerial(SessionContext sessionContext, int scope);
    private static void EnsureFreshCache(SessionContext sessionContext);
    private static long GetCacheLifeTime();
    private static void AsyncCacheRefresh(object state);
    private static void RefreshCache();
}
public class Holzer.Caching.CacheDependencyWatcher : object {
    private ICacheDependency cacheDependency;
    private int checkDependencyIntervalMs;
    private Timer checkDependencyTimer;
    [CompilerGeneratedAttribute]
private DefaultAction Changed;
    public CacheDependencyWatcher(ICacheDependency cacheDependency, int checkDependencyIntervalMs);
    private void CheckDependency(object state);
    private void OnChanged();
    [CompilerGeneratedAttribute]
public void add_Changed(DefaultAction value);
    [CompilerGeneratedAttribute]
public void remove_Changed(DefaultAction value);
    public sealed virtual void Dispose();
}
public class Holzer.Caching.CacheDictionary`2 : object {
    private bool fastCollect;
    private int sessionExpirationSeconds;
    private bool renewExpirationOnGet;
    private DateTime lastCollectTime;
    private Dictionary`2<TKey, StateContainer<TKey, TData>> stateTable;
    public CacheDictionary`2(IEqualityComparer`1<TKey> comparer, bool renewExpirationOnGet, int sessionExpirationSeconds, bool fastCollect);
    public CacheDictionary`2(bool renewExpirationOnGet, int sessionExpirationSeconds, bool fastCollect);
    public bool Contains(TKey key);
    public bool Contains(Func`2<TData, bool> predicate);
    public void Clear();
    public TData SetOrGet(TKey key, TData state);
    public void Set(TKey key, TData state);
    public void Set(TKey key, TData state, int expirationSeconds, bool renewOnGet);
    public TData Get(TKey key);
    public TData Find(Predicate`1<TData> predicate);
    public void Delete(TKey key);
    private long CacheCollectionLifetime();
    private void CollectGarbage();
}
public class Holzer.Caching.CacheFileChange : object {
    private string tempFile;
    private string cacheFile;
    private bool commited;
    private bool rollbacked;
    public string TempFile { get; }
    internal CacheFileChange(string tempFile, string cacheFile);
    public string get_TempFile();
    public void CommitIfNoneExistent();
    public void Rollback();
    public sealed virtual void Dispose();
}
public class Holzer.Caching.CacheStore : object {
    private bool fastCollect;
    private int sessionExpirationSeconds;
    private bool renewExpirationOnGet;
    private DateTime lastCollectTime;
    private Hashtable stateTable;
    public CacheStore(bool renewExpirationOnGet, int sessionExpirationSeconds, bool fastCollect);
    public bool Contains(object key);
    public void Clear();
    public object SetOrGet(object key, object state);
    public void Set(object key, object state);
    public void Set(object key, object state, int expirationSeconds, bool renewOnGet);
    public object Get(object key);
    public void Delete(object key);
    private long CacheCollectionLifetime();
    private void CollectGarbage();
}
public abstract class Holzer.Caching.CacheSystem : object {
    [CompilerGeneratedAttribute]
private static CacheClearHandler Clear;
    public static void Refresh(Transaction transaction);
    [CompilerGeneratedAttribute]
public static void add_Clear(CacheClearHandler value);
    [CompilerGeneratedAttribute]
public static void remove_Clear(CacheClearHandler value);
}
public class Holzer.Caching.FileCache : object {
    private static int CollectInterval;
    private static int Partions;
    private static string Prefix;
    private static string FileExtension;
    private static string startupGuid;
    private static long idCounter;
    private bool disposed;
    private Thread gcThread;
    private string folder;
    private long maxSize;
    private long size;
    private TelemetryBackgroundTaskItem telemetryTaskFilesClientCleanFileCache;
    public string Folder { get; }
    public long Size { get; }
    public long MaxSize { get; }
    public FileCache(string folder, long maxSizeMB);
    private static FileCache();
    public CacheFileChange BeginFileChange(string cacheFile);
    private void InitializeFolder();
    private string GetFolderName(int folderPartion);
    private void StartCollector();
    private void GCThread();
    private void CleanFileCache();
    private long GetFolderSize(DirectoryInfo directory);
    private void Clean(double cleanRatio);
    private void CleanDir(DirectoryInfo directory, double cleanRatio);
    public string GetFileName(string cacheKey);
    public sealed virtual void Dispose();
    public string get_Folder();
    public long get_Size();
    public long get_MaxSize();
    [CompilerGeneratedAttribute]
private void <GCThread>b__11_0();
}
public interface Holzer.Caching.ICacheDependency {
    public abstract virtual bool IsChanged(SessionContext sessionContext);
    public abstract virtual bool BeginReset(SessionContext sessionContext);
    public abstract virtual void EndReset(SessionContext sessionContext);
    public abstract virtual void CancelReset(SessionContext sessionContext);
}
public interface Holzer.Caching.ICacheLifetimeManager {
    public bool Expired { get; }
    public abstract virtual bool get_Expired();
}
public interface Holzer.Caching.ICacheTracker {
    public abstract virtual void Increment(SessionContext sessionContext, int scope);
    public abstract virtual Dictionary`2<int, int> GetVersions();
    public abstract virtual int EnsureExists(int scope);
}
public interface Holzer.Caching.IRefreshableObject {
    public string Name { get; }
    public abstract virtual bool Refresh(SessionContext sessionContext);
    public abstract virtual string get_Name();
}
public static class Holzer.Collections.Compare : object {
    public static int Bool(bool a, bool b);
    public static int Byte(Nullable`1<byte> a, Nullable`1<byte> b, bool sorteraNullFörst);
    public static int Decimal(Nullable`1<decimal> a, Nullable`1<decimal> b, bool sorteraNullFörst);
    public static int DateTime(Nullable`1<DateTime> a, Nullable`1<DateTime> b, bool sorteraNullFörst);
    public static int Date(Nullable`1<DateTime> a, Nullable`1<DateTime> b, bool sorteraNullFörst);
    public static int Int(Nullable`1<int> a, Nullable`1<int> b, bool sorteraNullFörst);
    public static int String(string a, string b, bool sorteraNullFörst);
}
public class Holzer.Collections.GenericObjectStringComparer : object {
    private static GenericObjectStringComparer invariantCultureIgnoreCase;
    private StringComparer stringComparer;
    public static GenericObjectStringComparer InvariantCultureIgnoreCase { get; }
    public GenericObjectStringComparer(StringComparer stringComparer);
    private static GenericObjectStringComparer();
    public static GenericObjectStringComparer get_InvariantCultureIgnoreCase();
    private sealed virtual override bool System.Collections.Generic.IEqualityComparer<System.Object>.Equals(object a, object b);
    public sealed virtual int GetHashCode(object obj);
}
public class Holzer.Collections.KeyDictionary`1 : object {
    private Dictionary`2<TKey, object> keys;
    public int Count { get; }
    public KeyDictionary`1(TKey[] keyArray);
    public KeyDictionary`1(IEnumerable`1<TKey> k);
    public KeyDictionary`1(IEqualityComparer`1<TKey> comparer);
    private void Fill(IEnumerable`1<TKey> k);
    public void SetRange(IEnumerable`1<TKey> k);
    public void Add(TKey key);
    public void Set(TKey key);
    public void Remove(TKey key);
    public int get_Count();
    public void Clear();
    public bool Contains(TKey key);
    public sealed virtual IEnumerator`1<TKey> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public virtual string ToString();
    public string ToString(char separator);
    public TKey[] ToArray();
}
public class Holzer.Collections.ParsableKeyDictionary`1 : KeyDictionary`1<TKey> {
    private TypedParser`1<TKey> parser;
    private char separator;
    public ParsableKeyDictionary`1(TypedParser`1<TKey> parser);
    public ParsableKeyDictionary`1(TypedParser`1<TKey> parser, string data);
    public ParsableKeyDictionary`1(TypedParser`1<TKey> parser, string data, char separator);
    public void Parse(string data);
    public void Parse(string data, char separator);
    public virtual string ToString();
}
public static class Holzer.Common.GlobalAssemblyInfo : object {
    public static string CompanyName;
    public static string CompanyNameShort;
    public static string ProductNameMessaging;
    public static string ProductNameDataVault;
    public static string ProductNameModus;
    public static string ProductNameApps;
    public static string ProductNameBusiness;
    public static string ProductNameBoplats;
    public static string ProductNameReporting;
    public static string ProductNameFiles;
    public static string ProductNameLogin;
    public static string ProductNameAvalanche;
    public static string ProductNameSignaling;
    public static string ProductNameGraphQL;
    public static string ProductNameCommon;
    public static string ProductNameConsetti;
    public static string ProductNameMaintainDB;
    public static string ProductNameRedisHost;
    public static string CopyrightText;
    public static string CopyrightTextYears;
}
[XmlRootAttribute]
public class Holzer.Configuration.ApplicationInstanceConfig : object {
    private static XmlSerializationHelper`1<ApplicationInstanceConfig> serializer;
    [CompilerGeneratedAttribute]
private string <ApplicationInstanceId>k__BackingField;
    [CompilerGeneratedAttribute]
private SecurityKeyValue <PublicKey>k__BackingField;
    [CompilerGeneratedAttribute]
private HostingSupportEnvironmentType <HostingSupportEnvironment>k__BackingField;
    [XmlAttributeAttribute]
public string ApplicationInstanceId { get; public set; }
    [XmlElementAttribute]
public SecurityKeyValue PublicKey { get; public set; }
    [XmlAttributeAttribute]
public HostingSupportEnvironmentType HostingSupportEnvironment { get; public set; }
    private static ApplicationInstanceConfig();
    [CompilerGeneratedAttribute]
public string get_ApplicationInstanceId();
    [CompilerGeneratedAttribute]
public void set_ApplicationInstanceId(string value);
    [CompilerGeneratedAttribute]
public SecurityKeyValue get_PublicKey();
    [CompilerGeneratedAttribute]
public void set_PublicKey(SecurityKeyValue value);
    [CompilerGeneratedAttribute]
public HostingSupportEnvironmentType get_HostingSupportEnvironment();
    [CompilerGeneratedAttribute]
public void set_HostingSupportEnvironment(HostingSupportEnvironmentType value);
    public Byte[] Serialize();
    public static ApplicationInstanceConfig Deserialize(Byte[] data);
}
public class Holzer.Configuration.ConfigurationBase : object {
    protected static object GetConfig(bool throwOnError, string sectionName);
    protected string ReadRequiredAttribute(XmlNode section, string name);
    protected int ReadRequiredAttributeInt(XmlNode section, string name);
    protected XmlNodeList ReadOptionalNodes(XmlNode section, string name);
    protected XmlNode ReadRequiredNode(XmlNode section, string name);
    protected int ReadOptionalAttributeInt(XmlNode section, string name, int defaultValue);
    protected bool ReadOptionalAttributeBool(XmlNode section, string name, bool defaultValue);
    protected double ReadOptionalAttributeDouble(XmlNode section, string name, double defaultValue);
    protected string ReadOptionalAttribute(XmlNode section, string name, string defaultValue);
    protected string ReadOptionalAttribute(XmlNode section, string name);
    public static string GetApplicationName(XmlNode section, string defaultName);
}
public static class Holzer.Configuration.ConfigurationString : object {
    private static List`1<FileSystemWatcher> watchers;
    private static bool changedEventFailed;
    [CompilerGeneratedAttribute]
private static Action Changed;
    private static ConfigurationString();
    private static void AddWatcher(string path);
    private static void watcher_Error(object sender, ErrorEventArgs e);
    private static void watcher_Changed(object sender, FileSystemEventArgs e);
    private static void watcher_Deleted(object sender, FileSystemEventArgs e);
    private static void watcher_Renamed(object sender, RenamedEventArgs e);
    private static void OnChanged();
    [CompilerGeneratedAttribute]
public static void add_Changed(Action value);
    [CompilerGeneratedAttribute]
public static void remove_Changed(Action value);
    public static string ReadString(string file, bool searchMoreThanApplicationFolder);
    private static string AttemptReadScan(string file, bool searchMoreThanApplicationFolder, string appDir);
    private static string AttemptRead(string path);
    public static string GetPathsForDisplay(bool searchMoreThanApplicationFolder);
    public static string ReadRequiredAttribute(string file, bool searchMoreThanApplicationFolder, XmlNode section, String[] attributeNames);
    public static int ReadRequiredAttributeInt(string file, bool searchMoreThanApplicationFolder, XmlNode section, String[] attributeNames);
    public static string ReadOptionalAttribute(string file, bool searchMoreThanApplicationFolder, XmlNode section, String[] attributeNames);
    public static double ReadAttributeDouble(string file, bool searchMoreThanApplicationFolder, XmlNode section, double defaultValue, String[] attributeNames);
    public static bool ReadAttributeBit(string file, bool searchMoreThanApplicationFolder, XmlNode section, bool defaultValue, String[] attributeNames);
    public static Nullable`1<bool> ReadAttributeBitNullable(string file, bool searchMoreThanApplicationFolder, Nullable`1<bool> defaultValue);
    public static int ReadAttributeInt(string file, bool searchMoreThanApplicationFolder, XmlNode section, int defaultValue, String[] attributeNames);
    public static Nullable`1<int> ReadAttributeIntNullable(string file, bool searchMoreThanApplicationFolder, Nullable`1<int> defaultValue);
    public static string ReadAttributeString(string file, bool searchMoreThanApplicationFolder, XmlNode section, string defaultValue, String[] attributeNames);
    internal static void WriteNew(string file, string value);
}
public class Holzer.Configuration.StandAloneConfiguration : object {
    private static string Filename;
    private static bool isStandAlone;
    private static Hashtable values;
    public static bool IsActive { get; }
    private static StandAloneConfiguration();
    public static bool get_IsActive();
    public static string Replace(string name, string standardSetting);
    public static string Get(string name);
}
public class Holzer.Data.AuditChangeSetInfo : object {
    private Nullable`1<short> changeSourceId;
    private Nullable`1<int> changeActionId;
    [CompilerGeneratedAttribute]
private string <ChangeSourceData>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ChangeSourceHost>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RayId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DeviceKey>k__BackingField;
    public Nullable`1<short> ChangeSourceId { get; public set; }
    public Nullable`1<int> ChangeActionId { get; }
    public string ChangeSourceData { get; public set; }
    public string ChangeSourceHost { get; public set; }
    public string RayId { get; public set; }
    public string DeviceKey { get; internal set; }
    public AuditChangeSetInfo(Nullable`1<short> changeSourceId, Nullable`1<int> changeActionId);
    public Nullable`1<short> get_ChangeSourceId();
    public void set_ChangeSourceId(Nullable`1<short> value);
    public Nullable`1<int> get_ChangeActionId();
    [CompilerGeneratedAttribute]
public string get_ChangeSourceData();
    [CompilerGeneratedAttribute]
public void set_ChangeSourceData(string value);
    [CompilerGeneratedAttribute]
public string get_ChangeSourceHost();
    [CompilerGeneratedAttribute]
public void set_ChangeSourceHost(string value);
    [CompilerGeneratedAttribute]
public string get_RayId();
    [CompilerGeneratedAttribute]
public void set_RayId(string value);
    [CompilerGeneratedAttribute]
public string get_DeviceKey();
    [CompilerGeneratedAttribute]
internal void set_DeviceKey(string value);
}
public static class Holzer.Data.AuditServices : object {
    private static List`1<AuditSourceInfoRetriever> sourceInfoRetrievers;
    [CompilerGeneratedAttribute]
private static Nullable`1<short> <ChangeSourceId>k__BackingField;
    public static Nullable`1<short> ChangeSourceId { get; public set; }
    private static AuditServices();
    public static void RegisterMetaDataRetriever(AuditSourceInfoRetriever retriever);
    public static AuditChangeSetInfo RetrieveMetaData();
    public static void RetrieveMetaData(AuditChangeSetInfo changeSetInfo);
    [CompilerGeneratedAttribute]
public static Nullable`1<short> get_ChangeSourceId();
    [CompilerGeneratedAttribute]
public static void set_ChangeSourceId(Nullable`1<short> value);
}
public class Holzer.Data.AuditSourceInfoRetriever : MulticastDelegate {
    public AuditSourceInfoRetriever(object object, IntPtr method);
    public virtual void Invoke(AuditChangeSetInfo data);
    public virtual IAsyncResult BeginInvoke(AuditChangeSetInfo data, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public static class Holzer.Data.ConnectionFactory : object {
    public static string ApplicationPrefix;
    private static string standAloneConnectionString;
    private static Dictionary`2<string, DataConnectionResolveResult> resolveCache;
    private static IsolationLevel defaultIsolationLevelIfNotConfigured;
    private static int defaultCommandTimeoutIfNotConfigured;
    private static Nullable`1<int> maxPoolSize;
    private static string SqlCreateTableUserInfo;
    private static string SqlSelectInfoUserInfoTable;
    [CompilerGeneratedAttribute]
private static string <DefaultConnectionString>k__BackingField;
    [CompilerGeneratedAttribute]
private static EventHandler`1<PrepareDatabaseConnectionEventArgs> PrepareConnection;
    [CompilerGeneratedAttribute]
private static EventHandler`1<TranslateConnectionStringEventArgs> TranslateConnectionString;
    [CompilerGeneratedAttribute]
private static bool <BlockAppendUserInfo>k__BackingField;
    public static string DefaultConnectionString { get; public set; }
    public static IsolationLevel DefaultIsolationLevelIfNotConfigured { get; public set; }
    public static int DefaultCommandTimeoutIfNotConfigured { get; public set; }
    public static bool BlockAppendUserInfo { get; public set; }
    public static Nullable`1<int> MaxPoolSize { get; public set; }
    private static ConnectionFactory();
    [CompilerGeneratedAttribute]
public static string get_DefaultConnectionString();
    [CompilerGeneratedAttribute]
public static void set_DefaultConnectionString(string value);
    private static void DatabasesConfig_Changed();
    public static SqlConnection Open(string connectionString, bool appendUserInfo);
    public static SqlConnection Open(string connectionString, bool appendUserInfo, AuditChangeSetInfo changeSetInfo);
    public static Task`1<SqlConnection> OpenAsync(CancellationToken cancellation, string connectionString, bool appendUserInfo, AuditChangeSetInfo changeSetInfo);
    public static SqlTransaction BeginTransaction(string connectionString, bool appendUserInfo, IsolationLevel isolationLevel);
    public static SqlTransaction BeginTransaction(string connectionString, bool appendUserInfo);
    public static IDbTransaction BeginTransaction(IDbConnection connection, string nonTranslatedConnectionString, Nullable`1<IsolationLevel> isolationLevel);
    internal static SqlConnection ConnectNativeTranslated(string connectionString, bool appendUserInfo, AuditChangeSetInfo changeSetInfo);
    [AsyncStateMachineAttribute("Holzer.Data.ConnectionFactory/<ConnectNativeTranslatedAsync>d__21")]
internal static Task`1<SqlConnection> ConnectNativeTranslatedAsync(CancellationToken cancellation, string connectionString, bool appendUserInfo, AuditChangeSetInfo changeSetInfo);
    private static void OnConnectionOpened(SqlConnection connection, AuditChangeSetInfo changeSetInfo, bool appendUserInfo);
    [AsyncStateMachineAttribute("Holzer.Data.ConnectionFactory/<OnConnectionOpenedAsync>d__23")]
private static Task OnConnectionOpenedAsync(SqlConnection connection, AuditChangeSetInfo changeSetInfo, bool appendUserInfo);
    private static void AppendUserInfo(SqlConnection connection, SqlCommand command, AuditChangeSetInfo changeSetInfo, LoginTicket currentUser);
    private static object LimitLength(string s, int length);
    private static void AppendUserInfoCreateTable(SqlConnection connection);
    [AsyncStateMachineAttribute("Holzer.Data.ConnectionFactory/<AppendUserInfoCreateTableAsync>d__27")]
private static Task AppendUserInfoCreateTableAsync(SqlConnection connection);
    private static void OnPrepareConnection(SqlConnection connection, SqlCommand command, LoginTicket currentUser, AuditChangeSetInfo changeSetInfo);
    public static string GetConnectionString(string connectionString);
    public static DataConnectionResolveResult GetConnectionStringInfo();
    public static DataConnectionResolveResult GetConnectionStringInfo(string connectionString);
    internal static DataConnectionResolveResult TranslateConnectionStringCore(string connectionString);
    private static void ClearConnectionStringCache();
    private static string OnTranslateConnectionString(string connectionString);
    [CompilerGeneratedAttribute]
public static void add_PrepareConnection(EventHandler`1<PrepareDatabaseConnectionEventArgs> value);
    [CompilerGeneratedAttribute]
public static void remove_PrepareConnection(EventHandler`1<PrepareDatabaseConnectionEventArgs> value);
    [CompilerGeneratedAttribute]
public static void add_TranslateConnectionString(EventHandler`1<TranslateConnectionStringEventArgs> value);
    [CompilerGeneratedAttribute]
public static void remove_TranslateConnectionString(EventHandler`1<TranslateConnectionStringEventArgs> value);
    public static IsolationLevel get_DefaultIsolationLevelIfNotConfigured();
    public static void set_DefaultIsolationLevelIfNotConfigured(IsolationLevel value);
    public static int get_DefaultCommandTimeoutIfNotConfigured();
    public static void set_DefaultCommandTimeoutIfNotConfigured(int value);
    [CompilerGeneratedAttribute]
public static bool get_BlockAppendUserInfo();
    [CompilerGeneratedAttribute]
public static void set_BlockAppendUserInfo(bool value);
    public static Nullable`1<int> get_MaxPoolSize();
    public static void set_MaxPoolSize(Nullable`1<int> value);
}
public class Holzer.Data.ConnectionString : object {
    private string server;
    private string database;
    private string user;
    private string password;
    private string rawConnectionString;
    private Nullable`1<IsolationLevel> defaultIsolationLevel;
    public string RawConnectionString { get; }
    public string Server { get; }
    public string Database { get; }
    public string User { get; }
    public string Password { get; }
    public Nullable`1<IsolationLevel> DefaultIsolationLevel { get; }
    public ConnectionString(string rawConnectionString, Nullable`1<IsolationLevel> defaultIsolationLevel);
    public ConnectionString(string rawConnectionString);
    public string get_RawConnectionString();
    public string get_Server();
    public string get_Database();
    public string get_User();
    public string get_Password();
    public Nullable`1<IsolationLevel> get_DefaultIsolationLevel();
}
public class Holzer.Data.ConnectionStringProvider : MulticastDelegate {
    public ConnectionStringProvider(object object, IntPtr method);
    public virtual ConnectionString Invoke(string applicationName);
    public virtual IAsyncResult BeginInvoke(string applicationName, AsyncCallback callback, object object);
    public virtual ConnectionString EndInvoke(IAsyncResult result);
}
public class Holzer.Data.DatabaseConfigHandler : object {
    public sealed virtual object Create(object parent, object configContext, XmlNode section);
}
public class Holzer.Data.DatabaseConfiguration : object {
    private static DatabaseConfiguration config;
    private string connectionString;
    private Nullable`1<IsolationLevel> defaultIsolationLevel;
    public string ConnectionString { get; }
    public Nullable`1<IsolationLevel> DefaultIsolationLevel { get; }
    public DatabaseConfiguration(string connectionString, Nullable`1<IsolationLevel> defaultIsolationLevel);
    public static DatabaseConfiguration GetConfig();
    public string get_ConnectionString();
    public Nullable`1<IsolationLevel> get_DefaultIsolationLevel();
}
public class Holzer.Data.DatabasesConfig : ConfigurationBase {
    private static DatabasesConfig config;
    private static ConnectionStringProvider customConnectionStringProvider;
    private Dictionary`2<string, ConnectionString> connectionStrings;
    private string currentlyLoadedConfigurationStringFile;
    [CompilerGeneratedAttribute]
private static DefaultAction Changed;
    unknown static ConnectionStringProvider CustomConnectionStringProvider {public set; }
    public DatabasesConfig(XmlNode section);
    public DatabasesConfig(string databaseStrings);
    public static DatabasesConfig GetConfig();
    public static DatabasesConfig GetConfig(bool throwOnError);
    private static string FillVariables(string connectionString);
    private void ConfigurationString_Changed();
    private static void OnChanged();
    [CompilerGeneratedAttribute]
public static void add_Changed(DefaultAction value);
    [CompilerGeneratedAttribute]
public static void remove_Changed(DefaultAction value);
    private void ReloadFromConfigurationStringFile(string databaseStrings);
    public ConnectionString GetConnectionString(string applicationName);
    public ConnectionString GetConnectionString(string applicationName, bool throwIfMissing);
    public static void set_CustomConnectionStringProvider(ConnectionStringProvider value);
}
public class Holzer.Data.DatabasesConfigHandler : object {
    public sealed virtual object Create(object parent, object configContext, XmlNode section);
}
public class Holzer.Data.DataChangeTracker : object {
    private static int ReconnectTimeSeconds;
    private static int WaitOnFailure;
    private static HashSet`1<string> startedSqlDependencyConnectionStrings;
    private bool disposed;
    private ConnectionString connectionString;
    private string commandText;
    private SqlConnection connection;
    private SqlCommand command;
    private SqlDependency dependency;
    private Timer reconnectTimer;
    private int failureCounter;
    [CompilerGeneratedAttribute]
private OnChangeEventHandler Changed;
    [CompilerGeneratedAttribute]
private EventHandler Reconnected;
    public DataChangeTracker(ConnectionString connectionString, string commandText, bool throwOnError, bool autoFix);
    private static DataChangeTracker();
    private static void StartSqlDependency(ConnectionString connectionString, bool throwOnError, bool autoFix);
    private static bool EnableBrokerServices(ConnectionString connectionString);
    private static bool TryRunSql(string sqlText, ConnectionString connectionString);
    private void ReconnectTimer(object state);
    private void ReconnectDependency(bool raiseOnConnected);
    private void DisposeDependency();
    private void dependency_OnChange(object sender, SqlNotificationEventArgs e);
    private void OnChanged(SqlNotificationEventArgs e);
    [CompilerGeneratedAttribute]
public void add_Changed(OnChangeEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_Changed(OnChangeEventHandler value);
    private void OnReconnected();
    [CompilerGeneratedAttribute]
public void add_Reconnected(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_Reconnected(EventHandler value);
    public sealed virtual void Dispose();
}
public class Holzer.Data.DataConnectionResolveResult : object {
    private string connectionString;
    private Nullable`1<IsolationLevel> defaultIsolationLevel;
    public IsolationLevel DefaultIsolationLevel { get; }
    public string ConnectionString { get; }
    public DataConnectionResolveResult(string connectionString, Nullable`1<IsolationLevel> defaultIsolationLevel);
    public IsolationLevel get_DefaultIsolationLevel();
    public string get_ConnectionString();
}
public class Holzer.Data.DataSessionCommand : object {
    [CompilerGeneratedAttribute]
private bool <CloseConnection>k__BackingField;
    [CompilerGeneratedAttribute]
private SqlCommand <Command>k__BackingField;
    public bool CloseConnection { get; public set; }
    public SqlCommand Command { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_CloseConnection();
    [CompilerGeneratedAttribute]
public void set_CloseConnection(bool value);
    [CompilerGeneratedAttribute]
public SqlCommand get_Command();
    [CompilerGeneratedAttribute]
public void set_Command(SqlCommand value);
    public sealed virtual void Dispose();
}
public static class Holzer.Data.DataSessionContext : object {
    public static SqlDataReader Read(SessionContext sessionContextOverride, string procedureName, string connectionString, Hashtable additionalParameters, Object[] inParameters);
    public static void Read(SessionContext sessionContextOverride, string procedureName, string connectionString, DataSet dataSet, Hashtable additionalParameters, Object[] inParameters);
    public static SqlDataReader Read(SessionContext sessionContextOverride, string procedureName, string connectionString, Object[] inParameters);
    [AsyncStateMachineAttribute("Holzer.Data.DataSessionContext/<ReadAsync>d__3")]
public static Task`1<SqlDataReader> ReadAsync(CancellationToken cancellation, SessionContext sessionContextOverride, string procedureName, string connectionString, Object[] inParameters);
    [AsyncStateMachineAttribute("Holzer.Data.DataSessionContext/<ReadAsync>d__4`1")]
public static Task`1<List`1<T>> ReadAsync(CancellationToken cancellation, SessionContext sessionContextOverride, string procedureName, string connectionString, Object[] inParameters);
    private static Func`2<SqlDataReader, T> BuildMapFunction(SqlDataReader reader);
    public static SqlDataReader ReadQuery(SessionContext sessionContextOverride, string sqlText, string connectionString, SqlParameter[] inParameters);
    public static SqlDataReader ReadQuery(SessionContext sessionContextOverride, string sqlText, string connectionString, CommandType ct, SqlParameter[] inParameters);
    public static SqlDataReader ReadQuery(SessionContext sessionContextOverride, string operationName, string sqlText, string connectionString, CommandType ct, SqlParameter[] inParameters);
    public static void Read(SessionContext sessionContextOverride, string procedureName, string connectionString, DataSet dataSet, Object[] inParameters);
    public static DataTable ReadTable(SessionContext sessionContextOverride, string procedureName, string connectionString, Object[] inParameters);
    public static void ExecuteQuery(SessionContext sessionContextOverride, string sqlText, string connectionString, Object[] inParameters);
    public static Dictionary`2<string, object> Execute(SessionContext sessionContextOverride, string procedureName, string connectionString, Object[] inParameters);
    public static object ExecuteScalarQuery(SessionContext sessionContextOverride, string sqlText, string connectionString, SqlParameter[] inParameters);
    [AsyncStateMachineAttribute("Holzer.Data.DataSessionContext/<ExecuteScalarAsync>d__14`1")]
public static Task`1<T> ExecuteScalarAsync(CancellationToken cancellation, SessionContext sessionContextOverride, bool allowNull, string procedureName, string connectionString, Object[] inParameters);
    public static object ExecuteScalar(SessionContext sessionContextOverride, string procedureName, string connectionString, Object[] inParameters);
    public static int ExecuteNoResult(SessionContext sessionContextOverride, string procedureName, string connectionString, Object[] inParameters);
    [AsyncStateMachineAttribute("Holzer.Data.DataSessionContext/<ExecuteNoResultAsync>d__17")]
public static Task`1<int> ExecuteNoResultAsync(CancellationToken cancellation, SessionContext sessionContextOverride, string procedureName, string connectionString, Object[] inParameters);
    public static Dictionary`2<string, object> Write(SessionContext sessionContextOverride, string procedureName, string connectionString, Object[] inParameters);
    public static SqlCommand CreateCommand(SessionContext context, CommandType commandType, string cmdText, string connectionString, Boolean& closeConnection);
    [AsyncStateMachineAttribute("Holzer.Data.DataSessionContext/<CreateCommandAsync>d__20")]
public static Task`1<DataSessionCommand> CreateCommandAsync(CancellationToken cancellation, SessionContext context, CommandType commandType, string cmdText, string connectionString);
    private static SqlCommand BuildCommand(SessionContext context, CommandType commandType, string cmdText, SqlTransaction transaction, SqlConnection connection);
    public static DataChangeTracker GetDataChangeTracker(string connectionString, string sqlText, bool throwOnError, bool autoFix);
    private static SqlParameter[] AttachCommandParameters(string procedureName, string connectionString, Object[] inParams, SqlCommand command, Hashtable additionalParameters);
    internal static Dictionary`2<string, object> ExtractOutputParameters(SqlParameter[] parameters);
    private static Exception HandleException(Exception x);
    internal static bool IsHumanError(Exception error);
}
internal class Holzer.Data.DataSessionInstrumentation : ValueType {
    private static int CommandTextMaxLength;
    private static TelemetryFlag telemetryFlag;
    private SqlCommand command;
    private string specialOperation;
    private string operationName;
    private Stopwatch stopwatch;
    private bool logged;
    public DataSessionInstrumentation(SqlCommand command, string specialOperation, string operationName);
    private static DataSessionInstrumentation();
    public void Fail(Exception error);
    public sealed virtual void Dispose();
    private void CompleteInstrumentation(Exception error);
    private string GetCommandType();
}
public abstract class Holzer.Data.DataStoreDefinition : object {
    private DataStoreType[] types;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public DataStoreType[] Types { get; }
    public string Name { get; private set; }
    protected DataStoreDefinition(string name);
    public DataStoreType[] get_Types();
    protected void EnsureTypesLoaded();
    protected abstract virtual void LoadTypes();
    protected void RegisterTypes(DataStoreType[] types);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
}
public class Holzer.Data.DataStoreField : object {
    private Nullable`1<RegularExpressionType> regexType;
    [CompilerGeneratedAttribute]
private DataStoreType <DefinedBy>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Index>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <ValueType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FieldName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DisplayName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RegEx>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsComputed>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsIdentityColumn>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsPrimaryKey>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsForeignKey>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ForeignKeyConstraintName>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CharMaxLength>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <StructureId>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Precision>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Scale>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsNullable>k__BackingField;
    public DataStoreType DefinedBy { get; protected set; }
    public int Index { get; protected set; }
    public Type ValueType { get; protected set; }
    public string FieldName { get; protected set; }
    public string DisplayName { get; protected set; }
    public string Description { get; protected set; }
    public string RegEx { get; protected set; }
    public Nullable`1<RegularExpressionType> RegExType { get; }
    public bool IsComputed { get; protected set; }
    public bool IsIdentityColumn { get; protected set; }
    public bool IsPrimaryKey { get; protected set; }
    public bool IsForeignKey { get; protected set; }
    public string ForeignKeyConstraintName { get; protected set; }
    public int CharMaxLength { get; protected set; }
    public Nullable`1<long> StructureId { get; protected set; }
    public int Precision { get; protected set; }
    public int Scale { get; protected set; }
    public bool IsNullable { get; protected set; }
    public DataStoreField(DataStoreType definedBy, int index, Type valueType, string name, bool isComputed, bool isIdentityColumn, bool isPrimaryKey, bool isForeignKey, string foreignKeyConstraintName, int charMaxLength, int precision, int scale, bool isNullable, string displayName, string description, Nullable`1<long> structureId, string regEx);
    [CompilerGeneratedAttribute]
public DataStoreType get_DefinedBy();
    [CompilerGeneratedAttribute]
protected void set_DefinedBy(DataStoreType value);
    [CompilerGeneratedAttribute]
public int get_Index();
    [CompilerGeneratedAttribute]
protected void set_Index(int value);
    [CompilerGeneratedAttribute]
public Type get_ValueType();
    [CompilerGeneratedAttribute]
protected void set_ValueType(Type value);
    [CompilerGeneratedAttribute]
public string get_FieldName();
    [CompilerGeneratedAttribute]
protected void set_FieldName(string value);
    [CompilerGeneratedAttribute]
public string get_DisplayName();
    [CompilerGeneratedAttribute]
protected void set_DisplayName(string value);
    [CompilerGeneratedAttribute]
public string get_Description();
    [CompilerGeneratedAttribute]
protected void set_Description(string value);
    [CompilerGeneratedAttribute]
public string get_RegEx();
    [CompilerGeneratedAttribute]
protected void set_RegEx(string value);
    public Nullable`1<RegularExpressionType> get_RegExType();
    [CompilerGeneratedAttribute]
public bool get_IsComputed();
    [CompilerGeneratedAttribute]
protected void set_IsComputed(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsIdentityColumn();
    [CompilerGeneratedAttribute]
protected void set_IsIdentityColumn(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsPrimaryKey();
    [CompilerGeneratedAttribute]
protected void set_IsPrimaryKey(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsForeignKey();
    [CompilerGeneratedAttribute]
protected void set_IsForeignKey(bool value);
    [CompilerGeneratedAttribute]
public string get_ForeignKeyConstraintName();
    [CompilerGeneratedAttribute]
protected void set_ForeignKeyConstraintName(string value);
    [CompilerGeneratedAttribute]
public int get_CharMaxLength();
    [CompilerGeneratedAttribute]
protected void set_CharMaxLength(int value);
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_StructureId();
    [CompilerGeneratedAttribute]
protected void set_StructureId(Nullable`1<long> value);
    [CompilerGeneratedAttribute]
public int get_Precision();
    [CompilerGeneratedAttribute]
protected void set_Precision(int value);
    [CompilerGeneratedAttribute]
public int get_Scale();
    [CompilerGeneratedAttribute]
protected void set_Scale(int value);
    [CompilerGeneratedAttribute]
public bool get_IsNullable();
    [CompilerGeneratedAttribute]
protected void set_IsNullable(bool value);
}
public abstract class Holzer.Data.DataStoreFieldCollection : object {
    private DataStoreType type;
    private DataStoreField[] fields;
    public DataStoreFieldCollection(DataStoreType type);
    protected void RegisterFields(DataStoreField[] fields);
    public DataStoreField[] ToArray();
}
public abstract class Holzer.Data.DataStoreType : object {
    private DataStoreDefinition dataStore;
    private DataStoreFieldCollection fields;
    private string name;
    private string description;
    private string displayName;
    private Nullable`1<long> structureId;
    public DataStoreDefinition DataStore { get; }
    public DataStoreFieldCollection Fields { get; }
    public Nullable`1<long> StructureId { get; }
    public string TypeName { get; }
    public string Description { get; }
    public string DisplayName { get; }
    protected void Bind(DataStoreDefinition dataStore, Nullable`1<long> structureId, string name, DataStoreFieldCollection fields, string displayName, string description);
    public DataStoreDefinition get_DataStore();
    public DataStoreFieldCollection get_Fields();
    public Nullable`1<long> get_StructureId();
    public string get_TypeName();
    public string get_Description();
    public string get_DisplayName();
}
[DefaultMemberAttribute("Item")]
public abstract class Holzer.Data.GenericTypedDataCollection`1 : object {
    private List`1<TData> list;
    public TData Item { get; public set; }
    public int Count { get; }
    protected void FillCore(DataView data);
    protected void FillCore(SqlDataReader reader);
    [AsyncStateMachineAttribute("Holzer.Data.GenericTypedDataCollection`1/<FillCoreAsync>d__3")]
protected Task FillCoreAsync(SqlDataReader reader);
    public void Sort(Comparison`1<TData> comparison);
    public void Add(TData item);
    public void AddRange(IEnumerable`1<TData> items);
    public void Remove(TData item);
    public int IndexOf(TData item);
    public void Remove(int index);
    public void Clear();
    public void Reverse();
    public TData[] ToArray();
    public TData get_Item(int index);
    public void set_Item(int index, TData value);
    public int get_Count();
    public sealed virtual IEnumerator`1<TData> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[DefaultMemberAttribute("Item")]
public abstract class Holzer.Data.GenericTypedDataDictionary`1 : object {
    private Dictionary`2<object, TData> table;
    public TData Item { get; public set; }
    public IEnumerable`1<object> Keys { get; }
    public IEnumerable`1<TData> Values { get; }
    public int Count { get; }
    protected void FillCore(DataView data, int indexField);
    protected void FillCore(SqlDataReader reader, int indexField);
    public void Add(object key, TData item);
    public TData get_Item(object key);
    public void set_Item(object key, TData value);
    public bool Contains(object key);
    public bool ContainsValue(TData value);
    public void Remove(object key);
    public IEnumerable`1<object> get_Keys();
    public IEnumerable`1<TData> get_Values();
    public int get_Count();
    private sealed virtual override IEnumerator`1<TData> System.Collections.Generic.IEnumerable<TData>.GetEnumerator();
    public sealed virtual IEnumerator GetEnumerator();
}
public abstract class Holzer.Data.GenericTypedDataReaderBase`1 : object {
    private SqlDataReader reader;
    private TData current;
    public TData Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    protected GenericTypedDataReaderBase`1(SqlDataReader reader);
    public bool NextResult();
    public bool Read();
    [AsyncStateMachineAttribute("Holzer.Data.GenericTypedDataReaderBase`1/<ReadAsync>d__5")]
public Task`1<bool> ReadAsync();
    [AsyncStateMachineAttribute("Holzer.Data.GenericTypedDataReaderBase`1/<ReadAsync>d__6")]
public Task`1<bool> ReadAsync(CancellationToken cancellation);
    public void Close();
    public sealed virtual void Dispose();
    protected void Clear();
    private void Populate(bool read, bool closed);
    public sealed virtual TData get_Current();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
    public sealed virtual IEnumerator`1<TData> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public interface Holzer.Data.IDatabaseConnectionFactory {
}
public interface Holzer.Data.IObjectDataFill {
    public abstract virtual void Fill(IDataRecord record);
    public abstract virtual void Fill(DataRow row);
    public abstract virtual void Fill(DataRowView row);
}
public class Holzer.Data.PrepareDatabaseConnectionEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private SqlConnection <Connection>k__BackingField;
    [CompilerGeneratedAttribute]
private SqlCommand <Command>k__BackingField;
    [CompilerGeneratedAttribute]
private LoginTicket <CurrentUser>k__BackingField;
    [CompilerGeneratedAttribute]
private AuditChangeSetInfo <ChangeSetInfo>k__BackingField;
    public SqlConnection Connection { get; public set; }
    public SqlCommand Command { get; public set; }
    public LoginTicket CurrentUser { get; internal set; }
    public AuditChangeSetInfo ChangeSetInfo { get; internal set; }
    [CompilerGeneratedAttribute]
public SqlConnection get_Connection();
    [CompilerGeneratedAttribute]
public void set_Connection(SqlConnection value);
    [CompilerGeneratedAttribute]
public SqlCommand get_Command();
    [CompilerGeneratedAttribute]
public void set_Command(SqlCommand value);
    [CompilerGeneratedAttribute]
public LoginTicket get_CurrentUser();
    [CompilerGeneratedAttribute]
internal void set_CurrentUser(LoginTicket value);
    [CompilerGeneratedAttribute]
public AuditChangeSetInfo get_ChangeSetInfo();
    [CompilerGeneratedAttribute]
internal void set_ChangeSetInfo(AuditChangeSetInfo value);
}
public class Holzer.Data.ProcedureHelper : object {
    private static Dictionary`2<string, SqlParameter[]> parameterCache;
    private static ProcedureHelper();
    public static SqlParameter[] GetParameters(string procedureName, string connectionString);
    public static SqlParameter[] DiscoverParameters(string procedureName, string connectionString);
    private static SqlParameter[] CloneParameters(SqlParameter[] originalParams);
    public static void AttachCommandParameters(SqlCommand command, SqlParameter[] parameters, Object[] parameterValues, bool allParametersAreOptional);
    public static void AttachAdditionParameters(SqlCommand command, Hashtable addtionalParameters);
    public static string GetSqlTypeDeclaration(SqlParameter functionParameter);
    public static object Parse(SqlParameter sqlParameter, string value);
    private static object ParseTimeSpan(string value);
    private static DateTime ParseDateTime(string value);
}
public class Holzer.Data.SearchOptionParameters : object {
    public Hashtable NamedParameters;
    public string SearchMethod;
    public SearchOptionParameters(Hashtable NamedParameters, string SearchMethod);
}
public static class Holzer.Data.StandardAuditSourceInfoRetrievers : object {
    private static AuditSourceInfoRetriever generic;
    private static AuditSourceInfoRetriever webContextAvalanche;
    public static AuditSourceInfoRetriever Generic { get; }
    public static AuditSourceInfoRetriever WebContextAvalanche { get; }
    private static StandardAuditSourceInfoRetrievers();
    public static AuditSourceInfoRetriever get_Generic();
    public static AuditSourceInfoRetriever get_WebContextAvalanche();
}
public class Holzer.Data.TranslateConnectionStringEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private string <OriginalConnectionString>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TranslatedConnectionString>k__BackingField;
    public string OriginalConnectionString { get; public set; }
    public string TranslatedConnectionString { get; public set; }
    [CompilerGeneratedAttribute]
public string get_OriginalConnectionString();
    [CompilerGeneratedAttribute]
public void set_OriginalConnectionString(string value);
    [CompilerGeneratedAttribute]
public string get_TranslatedConnectionString();
    [CompilerGeneratedAttribute]
public void set_TranslatedConnectionString(string value);
}
public class Holzer.Data.XmlSerializationHelper`1 : object {
    private static int MagicNumber;
    private XmlSerializer serializer;
    public Byte[] Serialize(TData data, bool compress);
    public string SerializeToString(TData data);
    public void WriteCompressed(TData data, string file, bool storeBackup);
    public void Write(TData data, string file, bool storeBackup);
    public TData UncompressAndDeserialize(Byte[] data);
    public TData Read(Stream stream);
    public TData Read(string file);
    private int ReadInt(Stream s);
    private void WriteInt(Stream s, int value);
    public TData Deserialize(Byte[] data);
}
[DataContractAttribute]
public class Holzer.Diagnostics.Contract.BasicEndpointTestServiceRequest : object {
}
[DataContractAttribute]
public class Holzer.Diagnostics.Contract.BasicEndpointTestServiceResponse : object {
    [CompilerGeneratedAttribute]
private DateTime <Generated>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsAvailable>k__BackingField;
    [DataMemberAttribute]
public DateTime Generated { get; public set; }
    [DataMemberAttribute]
public bool IsAvailable { get; public set; }
    public static BasicEndpointTestServiceResponse CreateAvailableResponse();
    [CompilerGeneratedAttribute]
public DateTime get_Generated();
    [CompilerGeneratedAttribute]
public void set_Generated(DateTime value);
    [CompilerGeneratedAttribute]
public bool get_IsAvailable();
    [CompilerGeneratedAttribute]
public void set_IsAvailable(bool value);
}
public class Holzer.Diagnostics.DiagnosticsHelperLegacy : object {
    public static string GetRayIdWithFallback();
}
[ServiceContractAttribute]
public interface Holzer.Diagnostics.IBasicEndpointTestService {
    [OperationContractAttribute]
public abstract virtual BasicEndpointTestServiceResponse Test(BasicEndpointTestServiceRequest request);
}
[ServiceContractAttribute]
public interface Holzer.Diagnostics.IDiagnosticsInformationService {
}
public class Holzer.ExceptionReporting : object {
    private static string RedactedString;
    [CompilerGeneratedAttribute]
private static ExceptionReportingWriteHandler WriteExceptionReport;
    [CompilerGeneratedAttribute]
private static ExceptionReportingWriteHandlerAsync <WriteExceptionReportAsync>k__BackingField;
    public static ExceptionReportingWriteHandlerAsync WriteExceptionReportAsync { get; public set; }
    public static string DecodeReportingUrl(string encodedUrl);
    public static string EncodeReportingUrl(string url);
    public static string EncodeInjectHtml(string b64Html);
    public static string DecodeInjectHtml(string b64Html);
    public static void Test(string message);
    public static void CheckMaintainanceMode();
    [AsyncStateMachineAttribute("Holzer.ExceptionReporting/<ReportOneWayAsync>d__8")]
public static Task`1<ReportingInfo> ReportOneWayAsync(Exception exception, FaultPriority priority, string source, string additionalInfo, string appInstanceId);
    public static ReportingInfo ReportOneWay(Exception exception);
    public static ReportingInfo ReportOneWay(Exception exception, FaultPriority priority);
    public static ReportingInfo ReportOneWay(Exception exception, string source, string additionalInfo);
    public static ReportingInfo ReportOneWay(Exception exception, string source, string additionalInfo, FaultPriority priority);
    public static ReportingInfo Report(Exception exception);
    public static ReportingInfo Report(Exception exception, FaultPriority priority);
    public static ReportingInfo Report(Exception exception, string source, string additionalInfo);
    private static bool IsProtectedData(string name);
    public static ReportingInfo Report(Exception exception, string source, string additionalInfo, FaultPriority priority);
    public static Task`1<ReportingInfo> ReportAsync(Exception exception, string source, string additionalInfo, FaultPriority priority);
    private static string TryGetCurrentUserName();
    public static ReportingInfo Report(Exception exception, string source, string additionalInfo, FaultPriority priority, string loginName);
    [AsyncStateMachineAttribute("Holzer.ExceptionReporting/<ReportAsync>d__21")]
public static Task`1<ReportingInfo> ReportAsync(Exception exception, string source, string additionalInfo, FaultPriority priority, string loginName, string appInstanceId);
    private static ReportingInfo ReportToHosting(Exception exception, String& source, string additionalInfo, FaultPriority priority, string loginName);
    private static string LogExceptionToFile(Exception x, Exception original, string loginName, string message, bool test);
    [AsyncStateMachineAttribute("Holzer.ExceptionReporting/<LogExceptionToFileAsync>d__24")]
private static Task`1<string> LogExceptionToFileAsync(Exception x, Exception original, string loginName, string message, bool test);
    internal static string AddUrlParameter(string url, string parameter);
    private static ExceptionService GetService(string provider);
    [CompilerGeneratedAttribute]
public static void add_WriteExceptionReport(ExceptionReportingWriteHandler value);
    [CompilerGeneratedAttribute]
public static void remove_WriteExceptionReport(ExceptionReportingWriteHandler value);
    [CompilerGeneratedAttribute]
public static ExceptionReportingWriteHandlerAsync get_WriteExceptionReportAsync();
    [CompilerGeneratedAttribute]
public static void set_WriteExceptionReportAsync(ExceptionReportingWriteHandlerAsync value);
}
public class Holzer.ExceptionServices : object {
    [CompilerGeneratedAttribute]
private static Func`2<ServiceExceptionFaultProviderEventArgs, FaultException> <ProvideExternalFault>k__BackingField;
    [CompilerGeneratedAttribute]
private static Func`2<FaultException, Message> <ProvideExternalFaultMessage>k__BackingField;
    private static bool FilterSecurityExceptions { get; }
    private static Func`2<ServiceExceptionFaultProviderEventArgs, FaultException> ProvideExternalFault { get; public set; }
    private static Func`2<FaultException, Message> ProvideExternalFaultMessage { get; public set; }
    public static Exception UnwrapException(SoapException e);
    public static SoapException WrapException(Exception e, ReportingInfo reportingInfo, bool filterSecurityExceptions);
    public static FaultException`1<GenericProcessedFault> WrapFaultException(Exception e, ReportingInfo reportingInfo, bool filterSecurityExceptions);
    public static FaultException`1<GenericProcessedFault> ProcessFaultExceptionOnBorder(Exception x, bool reportError);
    public static Exception ProcessWebServiceExceptionOnBorder(Exception e);
    public static Exception ProcessWebServiceExceptionOnBorder(Exception e, bool reportError);
    public static Exception ProcessWebServiceExceptionOnBorder(Exception e, bool reportError, FaultPriority priority);
    [AsyncStateMachineAttribute("Holzer.ExceptionServices/<ProcessWebServiceExceptionOnBorderAsync>d__8")]
public static Task`1<Exception> ProcessWebServiceExceptionOnBorderAsync(Exception e, bool reportError, FaultPriority priority);
    public static Exception ProcessWebServiceExceptionOnBorder(Exception e, ReportingInfo reportingInfo);
    public static Exception ProcessWebServiceExceptionOnBorder(Exception e, ReportingInfo reportingInfo, bool filterSecurityExceptions);
    public static Exception ProcessRemotingExceptionOnBorder(Exception e);
    private static bool ShouldBeReported(Exception e);
    private static bool get_FilterSecurityExceptions();
    internal static FaultException OnProvideExternalFault(ServiceExceptionFaultProviderEventArgs args);
    [CompilerGeneratedAttribute]
private static Func`2<ServiceExceptionFaultProviderEventArgs, FaultException> get_ProvideExternalFault();
    [CompilerGeneratedAttribute]
public static void set_ProvideExternalFault(Func`2<ServiceExceptionFaultProviderEventArgs, FaultException> value);
    internal static Message OnProvideExternalFaultMessage(FaultException exception);
    [CompilerGeneratedAttribute]
private static Func`2<FaultException, Message> get_ProvideExternalFaultMessage();
    [CompilerGeneratedAttribute]
public static void set_ProvideExternalFaultMessage(Func`2<FaultException, Message> value);
}
public class Holzer.Extensibility.DynamicBindingContainer : object {
    private Dictionary`2<Type, DynamicBindingExport> exports;
    private List`1<DynamicBindingImport> imports;
    private List`1<string> bindFailures;
    public bool HasBindFailures { get; }
    public void Export(Assembly assembly);
    public void Export(Type contract, Type service);
    private void AddExport(Type contract, Type service, string serviceAssemblyName);
    public void Import(Assembly assembly);
    public void Bind();
    private static string GetAssemblyName(Assembly assembly);
    public bool get_HasBindFailures();
    public string GetBindFailures();
    public DynamicBindingImport[] GetImports(Assembly assembly);
    public DynamicBindingExport[] GetExports(Assembly assembly);
}
public class Holzer.Extensibility.DynamicBindingExport : object {
    [CompilerGeneratedAttribute]
private string <SourceAssemblyName>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <Contract>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    public string SourceAssemblyName { get; internal set; }
    public Type Contract { get; internal set; }
    public Type Type { get; internal set; }
    [CompilerGeneratedAttribute]
public string get_SourceAssemblyName();
    [CompilerGeneratedAttribute]
internal void set_SourceAssemblyName(string value);
    [CompilerGeneratedAttribute]
public Type get_Contract();
    [CompilerGeneratedAttribute]
internal void set_Contract(Type value);
    [CompilerGeneratedAttribute]
public Type get_Type();
    [CompilerGeneratedAttribute]
internal void set_Type(Type value);
}
public class Holzer.Extensibility.DynamicBindingImport : object {
    [CompilerGeneratedAttribute]
private Type <Contract>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsRequired>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SourceAssemblyName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SourceDebugDescription>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`1<object> <Setter>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsConnected>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsError>k__BackingField;
    [CompilerGeneratedAttribute]
private string <StatusDescription>k__BackingField;
    public Type Contract { get; internal set; }
    public bool IsRequired { get; internal set; }
    public string SourceAssemblyName { get; internal set; }
    public string SourceDebugDescription { get; internal set; }
    public Action`1<object> Setter { get; internal set; }
    public bool IsConnected { get; internal set; }
    public bool IsError { get; internal set; }
    public string StatusDescription { get; internal set; }
    [CompilerGeneratedAttribute]
public Type get_Contract();
    [CompilerGeneratedAttribute]
internal void set_Contract(Type value);
    [CompilerGeneratedAttribute]
public bool get_IsRequired();
    [CompilerGeneratedAttribute]
internal void set_IsRequired(bool value);
    [CompilerGeneratedAttribute]
public string get_SourceAssemblyName();
    [CompilerGeneratedAttribute]
internal void set_SourceAssemblyName(string value);
    [CompilerGeneratedAttribute]
public string get_SourceDebugDescription();
    [CompilerGeneratedAttribute]
internal void set_SourceDebugDescription(string value);
    [CompilerGeneratedAttribute]
public Action`1<object> get_Setter();
    [CompilerGeneratedAttribute]
internal void set_Setter(Action`1<object> value);
    [CompilerGeneratedAttribute]
public bool get_IsConnected();
    [CompilerGeneratedAttribute]
internal void set_IsConnected(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsError();
    [CompilerGeneratedAttribute]
internal void set_IsError(bool value);
    [CompilerGeneratedAttribute]
public string get_StatusDescription();
    [CompilerGeneratedAttribute]
internal void set_StatusDescription(string value);
    internal void SetStatus(bool connected, bool error, string statusDescription);
}
public static class Holzer.Extensibility.ObjectActivator : object {
    private static BindingFlags constructorBindingFlags;
    private static string pluginPath;
    private static FileSystemWatcher pluginWatcher;
    private static KeyDictionary`1<string> extensionAssembliesLoad;
    private static Dictionary`2<string, ConstructorInfo> constructors;
    private static Dictionary`2<string, ConstructorInfo> redirectedConstructors;
    private static Dictionary`2<string, Type> typeCache;
    private static Dictionary`2<string, Assembly> assemblyCache;
    [CompilerGeneratedAttribute]
private static Action`1<Assembly> AssemblyLoaded;
    [CompilerGeneratedAttribute]
private static Action`1<Assembly> AssemblyPluginChanged;
    [CompilerGeneratedAttribute]
private static Func`2<Type, object> <ObjectConstructor>k__BackingField;
    [CompilerGeneratedAttribute]
private static Action`1<object> ObjectActivated;
    public static string PluginPath { get; }
    public static Func`2<Type, object> ObjectConstructor { get; public set; }
    private static ObjectActivator();
    public static string get_PluginPath();
    public static void InitializePluginPath(string path);
    private static void pluginWatcher_Changed(object sender, FileSystemEventArgs e);
    public static void ClearCache(string assemblyName);
    public static T Activate(string typeName, NamedParameterCollection parameters);
    public static T Activate(string typeName, NamedParameter[] parameters);
    public static TObject Activate();
    public static TObject Activate(Type baseType);
    public static TObject Activate(string typeName);
    public static object Activate(Type baseType);
    private static object ActivateCore(Type baseType);
    public static Type GetType(string fullTypeName);
    public static Assembly GetAssembly(string assemblyName);
    private static Assembly LoadAssembly(string assemblyName, Assembly assembly);
    private static Byte[] ReadAllBytes(string file);
    private static void EnsureExtensionsInitialized(Assembly baseAssembly);
    private static void LoadExtensionsForBaseAssembly(Assembly baseAssembly);
    private static string GetConstructorCacheName(Type type);
    private static void LoadExtension(Assembly baseAssembly, Assembly assembly);
    [CompilerGeneratedAttribute]
public static void add_AssemblyLoaded(Action`1<Assembly> value);
    [CompilerGeneratedAttribute]
public static void remove_AssemblyLoaded(Action`1<Assembly> value);
    [CompilerGeneratedAttribute]
public static void add_AssemblyPluginChanged(Action`1<Assembly> value);
    [CompilerGeneratedAttribute]
public static void remove_AssemblyPluginChanged(Action`1<Assembly> value);
    [CompilerGeneratedAttribute]
public static Func`2<Type, object> get_ObjectConstructor();
    [CompilerGeneratedAttribute]
public static void set_ObjectConstructor(Func`2<Type, object> value);
    [CompilerGeneratedAttribute]
public static void add_ObjectActivated(Action`1<object> value);
    [CompilerGeneratedAttribute]
public static void remove_ObjectActivated(Action`1<object> value);
    public static string GetTypeName(Type type);
    public static string GetAssemblyDisplayName(Assembly assembly);
}
[AttributeUsageAttribute("4")]
public class Holzer.Extensibility.PluginExportAttribute : Attribute {
    private Type contract;
    public Type Contract { get; }
    public PluginExportAttribute(Type contract);
    public Type get_Contract();
}
[AttributeUsageAttribute("128")]
public class Holzer.Extensibility.PluginImportAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <IsRequired>k__BackingField;
    public bool IsRequired { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_IsRequired();
    [CompilerGeneratedAttribute]
public void set_IsRequired(bool value);
}
[ExtensionAttribute]
public static class Holzer.Extension.DateTimeExtensions : object {
    [ExtensionAttribute]
public static DateTime FirstDayOfWeek(DateTime dt);
    [ExtensionAttribute]
public static DateTime LastDayOfWeek(DateTime dt);
    [ExtensionAttribute]
public static DateTime FirstDayOfMonth(DateTime dt);
    [ExtensionAttribute]
public static DateTime LastDayOfMonth(DateTime dt);
    [ExtensionAttribute]
public static DateTime FirstDayOfNextMonth(DateTime dt);
    [ExtensionAttribute]
public static List`1<DateTime> FirstDayOfNextMonths(DateTime dt);
}
public static class Holzer.Extension.GuidExtension : object {
    public static bool IsGuid(string value);
}
public class Holzer.FieldFilterOption : SearchOption {
    private string field;
    public string Field { get; }
    public FieldFilterOption(string field);
    public string get_Field();
    public sealed virtual void BuildTo(Hashtable namedParameters);
}
[DataContractAttribute]
public class Holzer.GenericProcessedFault : object {
    private string title;
    private string displayMessage;
    private string trackingId;
    [DataMemberAttribute]
public string DisplayMessage { get; public set; }
    [DataMemberAttribute]
public string TrackingId { get; public set; }
    [DataMemberAttribute]
public string Title { get; public set; }
    public GenericProcessedFault(string title, string displayMessage, string trackingId);
    public string get_DisplayMessage();
    public void set_DisplayMessage(string value);
    public string get_TrackingId();
    public void set_TrackingId(string value);
    public string get_Title();
    public void set_Title(string value);
}
public interface Holzer.Globalization.ILocalizationProvider {
    public abstract virtual string GetString(string systemStringName, int lcid, bool returnNullIfMissing);
    public abstract virtual string GetString(SessionContext sessionContext, int stringId, int lcid);
    public abstract virtual LanguageInfo[] GetLanguages();
    public abstract virtual int NewStringId(SessionContext sessionContext);
    public abstract virtual void AddString(SessionContext sessionContext, int stringId, int lcid, string localizedString);
    public abstract virtual void UpdateString(SessionContext sessionContext, int stringId, int lcid, string localizedString);
    public abstract virtual void RemoveString(SessionContext sessionContext, int stringId);
    public abstract virtual void RemoveString(SessionContext sessionContext, int stringId, int lcid);
    public abstract virtual StringInfo[] GetStrings(SessionContext sessionContext, int stringId);
    public abstract virtual string GetText(SessionContext sessionContext, int textId, int lcid);
    public abstract virtual StringInfo[] GetTexts(SessionContext sessionContext, int textId);
    public abstract virtual int NewTextId(SessionContext sessionContext);
    public abstract virtual void AddText(SessionContext sessionContext, int textId, int lcid, string localizedText);
    public abstract virtual void UpdateText(SessionContext sessionContext, int textId, int lcid, string localizedText);
    public abstract virtual void RemoveText(SessionContext sessionContext, int textId);
    public abstract virtual void RemoveText(SessionContext sessionContext, int textId, int lcid);
}
public class Holzer.Globalization.LanguageInfo : object {
    private int lcid;
    private string name;
    public int Lcid { get; }
    public string Name { get; }
    public LanguageInfo(int lcid, string name);
    public int get_Lcid();
    public string get_Name();
}
public class Holzer.Globalization.Localization : object {
    private static ILocalizationProvider provider;
    public static int LanguageId { get; }
    public static void SetProvider(ILocalizationProvider provider);
    public static string GetString(string systemStringName, string defaultValue, Nullable`1<int> lcid);
    public static LanguageInfo[] GetLanguages();
    public static int get_LanguageId();
    public static string GetString(string systemStringName);
    public static string GetString(int lcId, string systemStringName);
    public static string GetString(Nullable`1<int> stringId);
    public static string GetString(int stringId, int lcid);
    public static string GetString(SessionContext sessionContext, int stringId);
    public static string GetString(SessionContext sessionContext, int stringId, int lcid);
    public static int NewStringId();
    public static int NewStringId(SessionContext sessionContext);
    public static StringInfo[] GetStrings(int stringId);
    public static StringInfo[] GetStrings(SessionContext sessionContext, int stringId);
    public static void AddString(int stringId, int lcid, string localizedString);
    public static void AddString(SessionContext sessionContext, int stringId, int lcid, string localizedString);
    public static void UpdateString(int stringId, int lcid, string localizedString);
    public static void UpdateString(SessionContext sessionContext, int stringId, int lcid, string localizedString);
    public static void RemoveString(int stringId, int lcid);
    public static void RemoveString(SessionContext sessionContext, int stringId);
    public static void RemoveString(SessionContext sessionContext, int stringId, int lcid);
    public static string GetText(SessionContext sessionContext, int textId, int lcid);
    public static StringInfo[] GetTexts(int textId);
    public static int NewTextId(SessionContext sessionContext);
    public static void AddText(SessionContext sessionContext, int textId, int lcid, string localizedText);
    public static void UpdateText(SessionContext sessionContext, int textId, int lcid, string localizedText);
    public static void RemoveText(SessionContext sessionContext, int textId, int lcid);
    public static void UpdateString(SessionContext session, object language);
}
public class Holzer.Globalization.StringInfo : object {
    private int lcid;
    private string languageName;
    private int stringId;
    private string v;
    public int Lcid { get; }
    public string Language { get; }
    public int StringId { get; }
    public string Value { get; public set; }
    public StringInfo(int lcid, string languageName, int stringId, string v);
    public int get_Lcid();
    public string get_Language();
    public int get_StringId();
    public string get_Value();
    public void set_Value(string value);
}
public static class Holzer.Hosting.ApplicationInstance : object {
    private static ApplicationInstanceConfig config;
    private static string applicationInstanceInfoFile;
    public static string ApplicationInstanceInfoFile { get; }
    public static SecurityKeyValue PublicKey { get; }
    public static string ApplicationInstanceId { get; }
    public static HostingSupportEnvironmentType HostingSupportEnvironment { get; }
    private static ApplicationInstance();
    public static string get_ApplicationInstanceInfoFile();
    private static void EnsureLoaded();
    public static string WriteForOtherApplication(string directory, HostingSupportEnvironmentType hostingSupportEnvironmentType, string applicationInstanceId, string accountName, bool isContainer, SecurityKeyValue publicKey);
    private static void AddFileSecurity(string filePath, string userAccount, FileSystemRights rights, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AccessControlType controlType);
    public static SecurityKeyValue WaitForPublicKeyInOtherApplication(string directory, int timeoutSeconds, bool isContainer);
    private static SecurityKeyValue WaitForPublicKeyInApplicationInstanceFile(int timeoutSeconds, string applicationInstanceInfoFile);
    public static void WritePublicKey(SecurityKeyValue publicKey);
    public static SecurityKeyValue get_PublicKey();
    public static string get_ApplicationInstanceId();
    public static HostingSupportEnvironmentType get_HostingSupportEnvironment();
}
[DataContractAttribute]
public class Holzer.Hosting.AppNotice : object {
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private AppNoticeType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <ValidFrom>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <ValidTo>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Subject>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Body>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Version>k__BackingField;
    [DataMemberAttribute]
public string Id { get; public set; }
    [DataMemberAttribute]
public AppNoticeType Type { get; public set; }
    [DataMemberAttribute]
public Nullable`1<DateTime> ValidFrom { get; public set; }
    [DataMemberAttribute]
public Nullable`1<DateTime> ValidTo { get; public set; }
    [DataMemberAttribute]
public string Subject { get; public set; }
    [DataMemberAttribute]
public string Body { get; public set; }
    [DataMemberAttribute]
public long Version { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(string value);
    [CompilerGeneratedAttribute]
public AppNoticeType get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(AppNoticeType value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_ValidFrom();
    [CompilerGeneratedAttribute]
public void set_ValidFrom(Nullable`1<DateTime> value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_ValidTo();
    [CompilerGeneratedAttribute]
public void set_ValidTo(Nullable`1<DateTime> value);
    [CompilerGeneratedAttribute]
public string get_Subject();
    [CompilerGeneratedAttribute]
public void set_Subject(string value);
    [CompilerGeneratedAttribute]
public string get_Body();
    [CompilerGeneratedAttribute]
public void set_Body(string value);
    [CompilerGeneratedAttribute]
public long get_Version();
    [CompilerGeneratedAttribute]
public void set_Version(long value);
}
[DataContractAttribute]
public class Holzer.Hosting.AppNoticeType : object {
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ShortName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DisplayName>k__BackingField;
    [DataMemberAttribute]
public string Id { get; public set; }
    [DataMemberAttribute]
public string ShortName { get; public set; }
    [DataMemberAttribute]
public string DisplayName { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(string value);
    [CompilerGeneratedAttribute]
public string get_ShortName();
    [CompilerGeneratedAttribute]
public void set_ShortName(string value);
    [CompilerGeneratedAttribute]
public string get_DisplayName();
    [CompilerGeneratedAttribute]
public void set_DisplayName(string value);
}
public static class Holzer.Hosting.AppNoticeTypeId : object {
    public static string Error;
    public static string Update;
    public static string Info;
    public static string Version;
}
public static class Holzer.Hosting.Deployment.CurrentDeployment : object {
    private static long lastChecked;
    private static long lastLoadedFileVersion;
    private static Guid releaseIdentifier;
    private static int revision;
    private static DateTime releaseDate;
    private static string trackingId;
    private static bool available;
    public static bool InformationIsAvailable { get; }
    public static Guid ReleaseIdentifier { get; }
    public static int Revision { get; }
    public static DateTime ReleaseDate { get; }
    public static string TrackingId { get; }
    private static CurrentDeployment();
    private static void EnsureCurrent();
    public static bool get_InformationIsAvailable();
    public static Guid get_ReleaseIdentifier();
    public static int get_Revision();
    public static DateTime get_ReleaseDate();
    public static string get_TrackingId();
}
public class Holzer.Hosting.Deployment.DeploymentInfo : object {
    private string targetPath;
    private string backupPath;
    private IActionLog log;
    private Nullable`1<int> applicationInstallationId;
    private string notes;
    public string TargetPath { get; public set; }
    public string BackupPath { get; public set; }
    public IActionLog Log { get; }
    public Nullable`1<int> ApplicationInstallationId { get; }
    public string Notes { get; }
    public DeploymentInfo(string targetPath, string backupPath, IActionLog log, Nullable`1<int> applicationInstallationId, string notes);
    public string get_TargetPath();
    public void set_TargetPath(string value);
    public string get_BackupPath();
    public void set_BackupPath(string value);
    public IActionLog get_Log();
    public Nullable`1<int> get_ApplicationInstallationId();
    public string get_Notes();
}
[XmlRootAttribute]
public class Holzer.Hosting.Deployment.DeploymentMetaInfo : object {
    private static XmlSerializationHelper`1<DeploymentMetaInfo> serializer;
    private DateTime created;
    private string machineName;
    private string userName;
    private string packageReleaseIdentifier;
    private int revision;
    [XmlAttributeAttribute]
public DateTime Created { get; public set; }
    [XmlAttributeAttribute]
public string CreatedOnMachineName { get; public set; }
    [XmlAttributeAttribute]
public string CreatedByUserName { get; public set; }
    [XmlAttributeAttribute]
public string PackageReleaseIdentifier { get; public set; }
    [XmlAttributeAttribute]
public int Revision { get; public set; }
    public DeploymentMetaInfo(DateTime created, string machineName, string userName, string packageReleaseIdentifier, int revision);
    private static DeploymentMetaInfo();
    public DateTime get_Created();
    public void set_Created(DateTime value);
    public string get_CreatedOnMachineName();
    public void set_CreatedOnMachineName(string value);
    public string get_CreatedByUserName();
    public void set_CreatedByUserName(string value);
    public string get_PackageReleaseIdentifier();
    public void set_PackageReleaseIdentifier(string value);
    public int get_Revision();
    public void set_Revision(int value);
    public Byte[] Serialize();
    public static DeploymentMetaInfo Deserialize(Byte[] data);
}
public class Holzer.Hosting.Deployment.DeploymentPackageInfo : object {
    private DateTime created;
    private string machine;
    private string user;
    private int version;
    private Guid packageReleaseIdentifier;
    private int revision;
    private SoftwarePublisherCertificate publisher;
    public DateTime Created { get; }
    public string Machine { get; }
    public string User { get; }
    public int Version { get; }
    public Guid ReleaseIdentifier { get; }
    public int ReleaseRevision { get; }
    public SoftwarePublisherCertificate Publisher { get; }
    public DeploymentPackageInfo(DateTime created, string machine, string user, int version, Guid packageReleaseIdentifier, int revision, SoftwarePublisherCertificate publisher);
    public DateTime get_Created();
    public string get_Machine();
    public string get_User();
    public int get_Version();
    public Guid get_ReleaseIdentifier();
    public int get_ReleaseRevision();
    public SoftwarePublisherCertificate get_Publisher();
}
[XmlRootAttribute]
public class Holzer.Hosting.Deployment.SoftwarePublisherCertificate : object {
    private static XmlSerializationHelper`1<SoftwarePublisherCertificate> serializer;
    private SoftwarePublisherInfo publisher;
    private SoftwarePublisherSignature signature;
    [XmlElementAttribute]
public SoftwarePublisherInfo Data { get; public set; }
    [XmlElementAttribute]
public SoftwarePublisherSignature Signature { get; public set; }
    public SoftwarePublisherCertificate(SoftwarePublisherInfo publisher, SoftwarePublisherSignature signature);
    private static SoftwarePublisherCertificate();
    public SoftwarePublisherInfo get_Data();
    public void set_Data(SoftwarePublisherInfo value);
    public SoftwarePublisherSignature get_Signature();
    public void set_Signature(SoftwarePublisherSignature value);
    public void VerifyCertificate(SoftwarePublisherTrustPolicy trustPolicy);
    internal void VerifyCertificate(SoftwarePublisherTrustPolicy trustPolicy, int depth);
    public SoftwarePublisherSignature SignData(RSA privateKey, Byte[] data);
    public SoftwarePublisherSignature SignData(RSA privateKey, Stream stream);
    public void VerifyDataSignature(SoftwarePublisherSignature dataSignature, Byte[] data);
    internal static bool KeyEquals(SoftwarePublisherKeyInfo k1, SoftwarePublisherKeyInfo k2);
    internal static bool KeyEqualsData(Byte[] p1, Byte[] p2);
    internal static SoftwarePublisherSignature SignRsaSha1(RSA privateKey, Byte[] hash);
    internal static void VerifyRsaSha1(SoftwarePublisherSignature signature, Byte[] hash, SoftwarePublisherKeyInfo issuerKeyInfo);
    private Byte[] Sha1Hash(Byte[] data);
    public Byte[] Serialize();
    public static SoftwarePublisherCertificate Read(string path);
    public void Write(string path);
}
public enum Holzer.Hosting.Deployment.SoftwarePublisherCertificateType : Enum {
    public int value__;
    public static SoftwarePublisherCertificateType Authority;
    public static SoftwarePublisherCertificateType Publisher;
    public static SoftwarePublisherCertificateType Developer;
}
[XmlRootAttribute]
public class Holzer.Hosting.Deployment.SoftwarePublisherInfo : object {
    private XmlSerializer serializer;
    private string name;
    private SoftwarePublisherCertificateType type;
    private string companyName;
    private SoftwarePublisherKeyInfo key;
    private SoftwarePublisherCertificate issuer;
    private DateTime issued;
    private DateTime expires;
    private string apiServiceUri;
    [XmlElementAttribute]
public SoftwarePublisherCertificate Issuer { get; public set; }
    [XmlAttributeAttribute]
public SoftwarePublisherCertificateType Type { get; public set; }
    [XmlAttributeAttribute]
public string Name { get; public set; }
    [XmlAttributeAttribute]
public string CompanyName { get; public set; }
    [XmlElementAttribute]
public SoftwarePublisherKeyInfo Key { get; public set; }
    [XmlAttributeAttribute]
public DateTime Issued { get; public set; }
    [XmlAttributeAttribute]
public DateTime Expires { get; public set; }
    [XmlAttributeAttribute]
public string ApiServiceUri { get; public set; }
    public SoftwarePublisherInfo(SoftwarePublisherCertificate issuer, SoftwarePublisherCertificateType type, string name, string companyName, SoftwarePublisherKeyInfo key, DateTime issued, DateTime expires, string apiServiceUri);
    public SoftwarePublisherCertificate get_Issuer();
    public void set_Issuer(SoftwarePublisherCertificate value);
    public SoftwarePublisherCertificateType get_Type();
    public void set_Type(SoftwarePublisherCertificateType value);
    public string get_Name();
    public void set_Name(string value);
    public string get_CompanyName();
    public void set_CompanyName(string value);
    public SoftwarePublisherKeyInfo get_Key();
    public void set_Key(SoftwarePublisherKeyInfo value);
    public DateTime get_Issued();
    public void set_Issued(DateTime value);
    public DateTime get_Expires();
    public void set_Expires(DateTime value);
    public string get_ApiServiceUri();
    public void set_ApiServiceUri(string value);
    public SoftwarePublisherSignature SignCertificate(RSA privateKey);
    internal void VerifyCertificate(SoftwarePublisherTrustPolicy trustPolicy, SoftwarePublisherSignature signature, int depth);
    internal Byte[] GetSha1Hash();
}
[XmlRootAttribute]
public class Holzer.Hosting.Deployment.SoftwarePublisherKeyInfo : object {
    public static string RsaXmlPublicKeyType;
    private Byte[] keyData;
    private string keyType;
    [XmlAttributeAttribute]
public string KeyType { get; public set; }
    [XmlAttributeAttribute]
public Byte[] KeyData { get; public set; }
    public SoftwarePublisherKeyInfo(RSA key);
    public string get_KeyType();
    public void set_KeyType(string value);
    public Byte[] get_KeyData();
    public void set_KeyData(Byte[] value);
    internal RSA GetRsaKey();
}
public class Holzer.Hosting.Deployment.SoftwarePublisherOwnedCertificateInfo : object {
    [CompilerGeneratedAttribute]
private RSA <PrivateKey>k__BackingField;
    [CompilerGeneratedAttribute]
private SoftwarePublisherCertificate <Certificate>k__BackingField;
    public RSA PrivateKey { get; public set; }
    public SoftwarePublisherCertificate Certificate { get; public set; }
    [CompilerGeneratedAttribute]
public RSA get_PrivateKey();
    [CompilerGeneratedAttribute]
public void set_PrivateKey(RSA value);
    [CompilerGeneratedAttribute]
public SoftwarePublisherCertificate get_Certificate();
    [CompilerGeneratedAttribute]
public void set_Certificate(SoftwarePublisherCertificate value);
}
public static class Holzer.Hosting.Deployment.SoftwarePublisherOwnedCertificateLoader : object {
    public static SoftwarePublisherOwnedCertificateInfo Find();
}
public class Holzer.Hosting.Deployment.SoftwarePublisherSignature : object {
    public static string RsaSha1Pkcs1;
    private string signatureType;
    private Byte[] signatureData;
    [XmlAttributeAttribute]
public string SignatureType { get; public set; }
    [XmlAttributeAttribute]
public Byte[] SignatureData { get; public set; }
    public SoftwarePublisherSignature(string signatureType, Byte[] signatureData);
    public string get_SignatureType();
    public void set_SignatureType(string value);
    public Byte[] get_SignatureData();
    public void set_SignatureData(Byte[] value);
}
[XmlRootAttribute]
public class Holzer.Hosting.Deployment.SoftwarePublisherTrustPolicy : object {
    private static XmlSerializationHelper`1<SoftwarePublisherTrustPolicy> serializer;
    private static SoftwarePublisherTrustPolicy builtInCache;
    private SoftwarePublisherCertificate[] rootAuthorities;
    private SoftwarePublisherCertificate[] trustedSoftwarePublishers;
    [XmlArrayAttribute]
public SoftwarePublisherCertificate[] RootAuthorities { get; public set; }
    [XmlArrayAttribute]
public SoftwarePublisherCertificate[] TrustedSoftwarePublishers { get; public set; }
    public SoftwarePublisherTrustPolicy(SoftwarePublisherCertificate[] rootAuthorities);
    private static SoftwarePublisherTrustPolicy();
    public SoftwarePublisherCertificate[] get_RootAuthorities();
    public void set_RootAuthorities(SoftwarePublisherCertificate[] value);
    public SoftwarePublisherCertificate[] get_TrustedSoftwarePublishers();
    public void set_TrustedSoftwarePublishers(SoftwarePublisherCertificate[] value);
    public bool IsTrustedRootAuthority(SoftwarePublisherKeyInfo key);
    public bool IsTrustedSoftwarePublisher(SoftwarePublisherKeyInfo key);
    public Byte[] Serialize();
    public void Write(string path);
    public static SoftwarePublisherTrustPolicy Read(string path);
    public void VerifySoftwareInstallTrustChain(SoftwarePublisherCertificate verifiedCertificate);
    public static SoftwarePublisherTrustPolicy GetBuiltIn();
}
[XmlRootAttribute]
public class Holzer.Hosting.Deployment.StandaloneSoftwarePublisherSignature : object {
    private static XmlSerializationHelper`1<StandaloneSoftwarePublisherSignature> serializer;
    private SoftwarePublisherCertificate publisher;
    private SoftwarePublisherSignature dataSignature;
    public SoftwarePublisherCertificate Publisher { get; public set; }
    public SoftwarePublisherSignature DataSignature { get; public set; }
    public StandaloneSoftwarePublisherSignature(SoftwarePublisherCertificate publisher, SoftwarePublisherSignature dataSignature);
    private static StandaloneSoftwarePublisherSignature();
    public SoftwarePublisherCertificate get_Publisher();
    public void set_Publisher(SoftwarePublisherCertificate value);
    public SoftwarePublisherSignature get_DataSignature();
    public void set_DataSignature(SoftwarePublisherSignature value);
    public void VerifyCertificateAndDataSignature(SoftwarePublisherTrustPolicy trustPolicy, Byte[] data);
    public void VerifyDataSignature(Byte[] data);
    public void VerifyCertificate(SoftwarePublisherTrustPolicy trustPolicy);
    public static StandaloneSoftwarePublisherSignature Deserialize(Byte[] data);
    internal Byte[] Serialize(bool compress);
}
public class Holzer.Hosting.ExceptionHandler : MulticastDelegate {
    public ExceptionHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, Exception x);
    public virtual IAsyncResult BeginInvoke(object sender, Exception x, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class Holzer.Hosting.Faults.ErrorTypes : object {
    public static string DotNet;
}
public class Holzer.Hosting.Faults.ExceptionHandlerModule : object {
    private static string AccessControlAllowedMethods;
    private static string AccessControlAllowedHeaders;
    private static string MimeTypeJson;
    private static string MimeTypeJsonProblem;
    private static Dictionary`2<string, Exception> temporaryExceptions;
    private static ExceptionHandlerModule();
    public sealed virtual void Init(HttpApplication context);
    public sealed virtual void Dispose();
    private void context_PreRequestHandlerExecute(object sender, EventArgs e);
    private void CheckMaintainanceMode(HttpApplication application, HostingConfig config);
    private void context_Error(object sender, EventArgs e);
    private void ReturnError(HostingExceptionConfig config, HttpApplication application, string messageUrl, string managementUrl, string injectHtml, string trackingID, string cause, Exception x);
    private static void ReturnErrorJson(HttpApplication application, string trackingId, Exception exception);
    private void DoScriptedRedirect(HostingExceptionConfig config, HttpApplication application, string messageUrl, string managementUrl, string injectHtml, string trackingID, string cause, Exception x);
    private string SaveLocalError(HostingExceptionConfig config, Exception x);
    public static Exception GetLocalErrorDiagnostics(string localIncidentKey);
    private static void ResetRequest(HttpApplication application);
    public static string EncodeParamStringWithoutQuotes(string p);
}
public class Holzer.Hosting.Faults.ExceptionReportingWriteEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private Exception <Exception>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Source>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AppInstanceId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AdditionalInformation>k__BackingField;
    [CompilerGeneratedAttribute]
private FaultPriority <FaultPriority>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsHandled>k__BackingField;
    [CompilerGeneratedAttribute]
private ReportingInfo <ReturnResult>k__BackingField;
    public Exception Exception { get; public set; }
    public string Source { get; public set; }
    public string AppInstanceId { get; public set; }
    public string AdditionalInformation { get; public set; }
    public FaultPriority FaultPriority { get; public set; }
    public bool IsHandled { get; private set; }
    public ReportingInfo ReturnResult { get; private set; }
    [CompilerGeneratedAttribute]
public Exception get_Exception();
    [CompilerGeneratedAttribute]
public void set_Exception(Exception value);
    [CompilerGeneratedAttribute]
public string get_Source();
    [CompilerGeneratedAttribute]
public void set_Source(string value);
    [CompilerGeneratedAttribute]
public string get_AppInstanceId();
    [CompilerGeneratedAttribute]
public void set_AppInstanceId(string value);
    [CompilerGeneratedAttribute]
public string get_AdditionalInformation();
    [CompilerGeneratedAttribute]
public void set_AdditionalInformation(string value);
    [CompilerGeneratedAttribute]
public FaultPriority get_FaultPriority();
    [CompilerGeneratedAttribute]
public void set_FaultPriority(FaultPriority value);
    [CompilerGeneratedAttribute]
public bool get_IsHandled();
    [CompilerGeneratedAttribute]
private void set_IsHandled(bool value);
    [CompilerGeneratedAttribute]
public ReportingInfo get_ReturnResult();
    [CompilerGeneratedAttribute]
private void set_ReturnResult(ReportingInfo value);
    public void SetIsHandled(ReportingInfo result);
    public void ResetIsHandled();
}
public class Holzer.Hosting.Faults.ExceptionReportingWriteHandler : MulticastDelegate {
    public ExceptionReportingWriteHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, ExceptionReportingWriteEventArgs args);
    public virtual IAsyncResult BeginInvoke(object sender, ExceptionReportingWriteEventArgs args, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class Holzer.Hosting.Faults.ExceptionReportingWriteHandlerAsync : MulticastDelegate {
    public ExceptionReportingWriteHandlerAsync(object object, IntPtr method);
    public virtual Task Invoke(ExceptionReportingWriteEventArgs args);
    public virtual IAsyncResult BeginInvoke(ExceptionReportingWriteEventArgs args, AsyncCallback callback, object object);
    public virtual Task EndInvoke(IAsyncResult result);
}
public static class Holzer.Hosting.HostEnvironment : object {
    private static string processSessionGuid;
    private static bool isClient;
    private static Nullable`1<bool> runningInContainer;
    private static string applicationSystemName;
    private static string applicationDisplayName;
    private static string applicationWebPath;
    private static DateTime started;
    private static string machineName;
    private static string configurationPath;
    private static string localStatePath;
    private static string programDataPath;
    private static bool isInstalling;
    private static bool isInMaintenance;
    private static bool isSupportEnvironmentInitialized;
    private static bool isConfiguring;
    private static HashSet`1<string> maintenanceUsers;
    private static List`1<AppNotice> maintenanceNotices;
    private static Dictionary`2<string, HostEnvironmentProperty> properties;
    private static string programPath;
    private static string externalApplicationWebPath;
    [CompilerGeneratedAttribute]
private static string <FileStorePath>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <TemporaryFilesPath>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <ApplicationServiceAdress>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <ApplicationWebAddress>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <ExternalApplicationWebAddress>k__BackingField;
    [CompilerGeneratedAttribute]
private static Nullable`1<int> <ApplicationWebSocketPort>k__BackingField;
    [CompilerGeneratedAttribute]
private static EventHandler StateChanged;
    [CompilerGeneratedAttribute]
private static bool <IsStopping>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <MaintenanceMessage>k__BackingField;
    [CompilerGeneratedAttribute]
private static HostEnvironmentType <EnvironmentType>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <EnvironmentDisplayName>k__BackingField;
    [CompilerGeneratedAttribute]
private static HostEnvironmentAppVersion <AppVersion>k__BackingField;
    private static bool ConfigurationReady { get; }
    public static string ProgramPath { get; }
    public static string ConfigurationPath { get; }
    public static string StateDataPath { get; public set; }
    public static string ProgramDataPath { get; public set; }
    public static string FileStorePath { get; public set; }
    public static string TemporaryFilesPath { get; public set; }
    public static bool RunningInContainer { get; }
    public static bool IsClient { get; public set; }
    public static string ApplicationInstanceId { get; }
    public static string MachineName { get; }
    public static string ProcessSessionGuid { get; }
    public static string ApplicationName { get; public set; }
    public static string ApplicationWebPath { get; public set; }
    public static string ApplicationServiceAdress { get; public set; }
    public static string ApplicationWebAddress { get; public set; }
    public static string ExternalApplicationWebAddress { get; public set; }
    private static string ExternalApplicationWebPath { get; }
    public static Nullable`1<int> ApplicationWebSocketPort { get; public set; }
    public static string ApplicationDisplayName { get; public set; }
    public static bool IsSupportEnvironmentInitialized { get; public set; }
    public static bool IsInstalling { get; public set; }
    public static IEnumerable`1<HostEnvironmentProperty> Properties { get; }
    public static bool IsInMaintenance { get; public set; }
    public static bool IsConfiguring { get; public set; }
    public static DateTime Started { get; }
    public static TimeSpan Uptime { get; }
    public static TimeSpan SystemUpTime { get; }
    public static bool IsStopping { get; public set; }
    public static string MaintenanceMessage { get; public set; }
    unknown static string MaintenanceUsers {public set; }
    public static List`1<AppNotice> MaintenanceNotices { get; public set; }
    public static HostEnvironmentType EnvironmentType { get; public set; }
    public static string EnvironmentDisplayName { get; public set; }
    public static HostEnvironmentAppVersion AppVersion { get; public set; }
    private static HostEnvironment();
    public static void OnReady(Action action);
    private static bool get_ConfigurationReady();
    public static string get_ProgramPath();
    public static string get_ConfigurationPath();
    public static string get_StateDataPath();
    public static void set_StateDataPath(string value);
    public static string get_ProgramDataPath();
    public static void set_ProgramDataPath(string value);
    [CompilerGeneratedAttribute]
public static string get_FileStorePath();
    [CompilerGeneratedAttribute]
public static void set_FileStorePath(string value);
    [CompilerGeneratedAttribute]
public static string get_TemporaryFilesPath();
    [CompilerGeneratedAttribute]
public static void set_TemporaryFilesPath(string value);
    public static bool get_RunningInContainer();
    public static bool get_IsClient();
    public static void set_IsClient(bool value);
    public static string get_ApplicationInstanceId();
    public static string get_MachineName();
    public static string get_ProcessSessionGuid();
    public static string get_ApplicationName();
    public static void set_ApplicationName(string value);
    public static string get_ApplicationWebPath();
    public static void set_ApplicationWebPath(string value);
    [CompilerGeneratedAttribute]
public static string get_ApplicationServiceAdress();
    [CompilerGeneratedAttribute]
public static void set_ApplicationServiceAdress(string value);
    [CompilerGeneratedAttribute]
public static string get_ApplicationWebAddress();
    [CompilerGeneratedAttribute]
public static void set_ApplicationWebAddress(string value);
    [CompilerGeneratedAttribute]
public static string get_ExternalApplicationWebAddress();
    [CompilerGeneratedAttribute]
public static void set_ExternalApplicationWebAddress(string value);
    private static string get_ExternalApplicationWebPath();
    public static string GetApplicationWebAddress(string path);
    public static string GetApplicationWebAddressExternal(string path);
    public static string GetApplicationWebPathExternal(string path);
    private static string Combine(string url1, string url2);
    public static string EndingSlash(string url);
    [CompilerGeneratedAttribute]
public static Nullable`1<int> get_ApplicationWebSocketPort();
    [CompilerGeneratedAttribute]
public static void set_ApplicationWebSocketPort(Nullable`1<int> value);
    public static string get_ApplicationDisplayName();
    public static void set_ApplicationDisplayName(string value);
    public static bool get_IsSupportEnvironmentInitialized();
    public static void set_IsSupportEnvironmentInitialized(bool value);
    public static bool get_IsInstalling();
    public static void set_IsInstalling(bool value);
    public static void SetProperty(string name, object value);
    public static HostEnvironmentProperty GetProperty(string name);
    public static IEnumerable`1<HostEnvironmentProperty> get_Properties();
    public static bool get_IsInMaintenance();
    public static void set_IsInMaintenance(bool value);
    public static bool get_IsConfiguring();
    public static void set_IsConfiguring(bool value);
    private static void RaiseStateChanged();
    [CompilerGeneratedAttribute]
public static void add_StateChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public static void remove_StateChanged(EventHandler value);
    public static DateTime get_Started();
    public static TimeSpan get_Uptime();
    public static TimeSpan get_SystemUpTime();
    [CompilerGeneratedAttribute]
public static bool get_IsStopping();
    [CompilerGeneratedAttribute]
public static void set_IsStopping(bool value);
    [CompilerGeneratedAttribute]
public static string get_MaintenanceMessage();
    [CompilerGeneratedAttribute]
public static void set_MaintenanceMessage(string value);
    public static void set_MaintenanceUsers(string value);
    public static List`1<AppNotice> get_MaintenanceNotices();
    public static void set_MaintenanceNotices(List`1<AppNotice> value);
    [CompilerGeneratedAttribute]
public static HostEnvironmentType get_EnvironmentType();
    [CompilerGeneratedAttribute]
public static void set_EnvironmentType(HostEnvironmentType value);
    [CompilerGeneratedAttribute]
public static string get_EnvironmentDisplayName();
    [CompilerGeneratedAttribute]
public static void set_EnvironmentDisplayName(string value);
    [CompilerGeneratedAttribute]
public static HostEnvironmentAppVersion get_AppVersion();
    [CompilerGeneratedAttribute]
public static void set_AppVersion(HostEnvironmentAppVersion value);
    public static bool InMaintenanceUser(string username);
    public static bool InMaintenanceUser();
    internal static string GetConfigurationOption(string name);
}
public class Holzer.Hosting.HostEnvironmentAppVersion : object {
    [CompilerGeneratedAttribute]
private string <DisplayName>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <Deployed>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <Created>k__BackingField;
    public string DisplayName { get; public set; }
    public Nullable`1<DateTime> Deployed { get; public set; }
    public Nullable`1<DateTime> Created { get; public set; }
    [CompilerGeneratedAttribute]
public string get_DisplayName();
    [CompilerGeneratedAttribute]
public void set_DisplayName(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_Deployed();
    [CompilerGeneratedAttribute]
public void set_Deployed(Nullable`1<DateTime> value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_Created();
    [CompilerGeneratedAttribute]
public void set_Created(Nullable`1<DateTime> value);
}
public class Holzer.Hosting.HostEnvironmentProperty : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Value>k__BackingField;
    public string Name { get; }
    public object Value { get; }
    public HostEnvironmentProperty(string name, object value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public object get_Value();
}
public class Holzer.Hosting.HostEnvironmentType : object {
    [CompilerGeneratedAttribute]
private string <DisplayName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ReferenceName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ShortName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsDevelopment>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsTest>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsDemo>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsProd>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsSandbox>k__BackingField;
    public string DisplayName { get; public set; }
    public string ReferenceName { get; public set; }
    public string ShortName { get; public set; }
    public bool IsDevelopment { get; public set; }
    public bool IsTest { get; public set; }
    public bool IsDemo { get; public set; }
    public bool IsProd { get; public set; }
    public bool IsSandbox { get; public set; }
    [CompilerGeneratedAttribute]
public string get_DisplayName();
    [CompilerGeneratedAttribute]
public void set_DisplayName(string value);
    [CompilerGeneratedAttribute]
public string get_ReferenceName();
    [CompilerGeneratedAttribute]
public void set_ReferenceName(string value);
    [CompilerGeneratedAttribute]
public string get_ShortName();
    [CompilerGeneratedAttribute]
public void set_ShortName(string value);
    [CompilerGeneratedAttribute]
public bool get_IsDevelopment();
    [CompilerGeneratedAttribute]
public void set_IsDevelopment(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsTest();
    [CompilerGeneratedAttribute]
public void set_IsTest(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsDemo();
    [CompilerGeneratedAttribute]
public void set_IsDemo(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsProd();
    [CompilerGeneratedAttribute]
public void set_IsProd(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsSandbox();
    [CompilerGeneratedAttribute]
public void set_IsSandbox(bool value);
}
public class Holzer.Hosting.HostingConfig : object {
    private static HostingConfig config;
    private static HostingConfig configOverride;
    private HostingExceptionConfig exceptions;
    private HybridDictionary maintainanceUsers;
    private bool maintainanceMode;
    private string applicationName;
    private string serverKey;
    private string reportingPath;
    public string ApplicationName { get; }
    public string ServerKey { get; }
    public string ReportingPath { get; }
    public HostingExceptionConfig Exceptions { get; }
    public bool MaintainanceMode { get; }
    private static HostingConfig();
    public HostingConfig(string applicationName, string serverKey, string provider, string errorPage, string permissionDeniedPage, string versionErrorPage, bool enabled, bool manageHandlerFailures, string reportingPath, string cookiesErrorPage, bool maintainanceMode, string displayTarget, string displayScript, string maintainanceUser, string applicationRootPage, bool permissionDebug, bool filterSecurityInfo, bool isDeveloperMode);
    private static void ConfigurationString_Changed();
    public static HostingConfig GetConfig(bool throwOnError);
    public static void Override(HostingConfig config, string applicationName);
    public string get_ApplicationName();
    public string get_ServerKey();
    public string get_ReportingPath();
    public HostingExceptionConfig get_Exceptions();
    public bool get_MaintainanceMode();
    public bool IsMaintainanceUser(string username);
}
public class Holzer.Hosting.HostingConfigHandler : object {
    private static XmlNode section;
    private static string AppsHostingErrorPage;
    private static string AppsHostingProvider;
    [CompilerGeneratedAttribute]
private static string <ErrorPageOverride>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <ProviderOverride>k__BackingField;
    private static string ErrorPageOverride { get; private set; }
    private static string ProviderOverride { get; private set; }
    public sealed virtual object Create(object parent, object configContext, XmlNode section);
    public static HostingConfig DefaultForClient();
    internal static HostingConfig GetConfigObject();
    private static string GetErrorPage(XmlNode exceptions);
    private static string GetProvider(XmlNode exceptions);
    private static string GetKey(XmlNode section);
    private static string GetApplicationName(XmlNode section);
    private static string ReadRequiredAttribute(XmlNode section, string name);
    private static string ReadOptionalAttribute(XmlNode section, string name);
    private static XmlNode ReadOptionalNode(XmlNode section, string name);
    private static XmlNode ReadRequiredNode(XmlNode section, string name);
    public static void RedirectReportingToMomentumApps();
    [CompilerGeneratedAttribute]
private static string get_ErrorPageOverride();
    [CompilerGeneratedAttribute]
private static void set_ErrorPageOverride(string value);
    [CompilerGeneratedAttribute]
private static string get_ProviderOverride();
    [CompilerGeneratedAttribute]
private static void set_ProviderOverride(string value);
}
public class Holzer.Hosting.HostingExceptionConfig : object {
    [CompilerGeneratedAttribute]
private bool <IsDeveloperMode>k__BackingField;
    private string provider;
    private string errorPage;
    private string permissionDeniedPage;
    private string versionErrorPage;
    private string cookiesErrorPage;
    private string displayTarget;
    private bool enabled;
    private bool manageHandlerFailures;
    private string displayScript;
    private string applicationRootPage;
    private bool permissionDebug;
    private bool filterSecurityExceptions;
    public string Provider { get; public set; }
    public string ErrorPage { get; public set; }
    public string PermissionDeniedPage { get; }
    public string VersionErrorPage { get; }
    public bool Enabled { get; }
    public bool ManageHandlerFailures { get; }
    public string CookiesErrorPage { get; }
    public string DisplayTarget { get; }
    public string DisplayScript { get; }
    public string ApplicationRootPage { get; }
    public bool PermissionDebug { get; }
    public bool FilterSecurityExceptions { get; }
    public bool IsDeveloperMode { get; private set; }
    internal HostingExceptionConfig(string provider, string errorPage, string permissionDeniedPage, string versionErrorPage, bool enabled, bool manageHandlerFailures, string cookiesErrorPage, string displayTarget, string displayScript, string applicationRootPage, bool permissionDebug, bool filterSecurityExceptions, bool isDeveloperMode);
    public string get_Provider();
    public void set_Provider(string value);
    public string get_ErrorPage();
    public void set_ErrorPage(string value);
    public string get_PermissionDeniedPage();
    public string get_VersionErrorPage();
    public bool get_Enabled();
    public bool get_ManageHandlerFailures();
    public string get_CookiesErrorPage();
    public string get_DisplayTarget();
    public string get_DisplayScript();
    public string get_ApplicationRootPage();
    public bool get_PermissionDebug();
    public bool get_FilterSecurityExceptions();
    [CompilerGeneratedAttribute]
public bool get_IsDeveloperMode();
    [CompilerGeneratedAttribute]
private void set_IsDeveloperMode(bool value);
}
public static class Holzer.Hosting.MachineIdentityInfo : object {
    private static string MachineIdentityStringFile;
    private static string id;
    public static string Id { get; }
    private static MachineIdentityInfo();
    public static string get_Id();
}
public class Holzer.Hosting.Platforms : object {
    public static string AspDotNet;
}
public interface Holzer.IConsole {
    public abstract virtual void Run(ConsoleResult result, string cmd, Object[] args);
}
public class Holzer.Input : object {
    public static DateTime SqlDateTimeNullValue;
    private static Input();
    public static object ParseDate(string s, string localizedFieldName);
    public static object ParseDate(string s, string localizedFieldName, object defaultValue);
    public static Nullable`1<DateTime> ParseDateTime(string s, string localizedFieldName);
    public static DateTime ParseDateTime(string s, string localizedFieldName, DateTime defaultValue);
    public static Nullable`1<DateTime> ParseDateTime(string s, string localizedFieldName, Nullable`1<DateTime> defaultValue);
    public static object ParseInt(string s, string localizedFieldName);
    public static object ParseInt(string s, string localizedFieldName, object defaultValue);
    public static object ParseDouble(string s, string localizedFieldName);
    public static object ParseDouble(string s, string localizedFieldName, object defaultValue);
}
public class Holzer.IO.DiskInfo : object {
    private long userFreeSpace;
    private long totalBytes;
    private long totalFreeSpace;
    public long UserFreeSpace { get; }
    public long TotalBytes { get; }
    public long TotalFreeSpace { get; }
    public DiskInfo(string path);
    private static bool GetDiskFreeSpaceEx(string lpDirectoryName, UInt64& lpFreeBytesAvailable, UInt64& lpTotalNumberOfBytes, UInt64& lpTotalNumberOfFreeBytes);
    public long get_UserFreeSpace();
    public long get_TotalBytes();
    public long get_TotalFreeSpace();
}
public class Holzer.IO.PackageReader : StreamPackageReader {
    public PackageReader(string path);
    public PackageReader(Stream stream);
}
public class Holzer.IO.PackageWriter : object {
    private string tempFile;
    private string tempOutputFile;
    private FileStream output;
    protected virtual override void Finalize();
    public void WriteInt(int value);
    public void WriteLong(long value);
    public void WriteString(string value);
    public void WriteFile(string path);
    public void WriteStream(Stream stream);
    public sealed virtual void Dispose();
    public void Save(string targetPath, long fileHeaderSignature, int fileHeaderVersion, SoftwarePublisherCertificate cert, RSA key, IActionLog log);
    public void Write(Stream writeStream, long fileHeaderSignature, int fileHeaderVersion, SoftwarePublisherCertificate cert, RSA key, IActionLog log);
    public void WriteBytes(Byte[] buffer);
}
public class Holzer.IO.StreamPackageReader : object {
    private Stream reader;
    public StreamPackageReader(Stream reader);
    public sealed virtual void Dispose();
    public int ReadOptionalInt();
    public int ReadInt();
    public long ReadLong();
    public string ReadString();
    public void ReadFileTo(string fullFileTargetPath);
    public long ReadFileTo(string fullFileTargetPath, bool overwrite);
    public Byte[] ReadFile();
    public long SkipFile();
    private void SeekForward(long length);
    public void SkipBytes();
    public Byte[] ReadBytes();
    public Byte[] ReadBytes(int length);
    public bool GetIsEndOfFile();
}
public interface Holzer.IParameterBuilder {
    public abstract virtual void BuildTo(Hashtable namedParameters);
}
public interface Holzer.ITransaction {
    public abstract virtual void Commit();
    public abstract virtual void Rollback();
}
public class Holzer.Licencing.ApplicationLicenceInfo : object {
    private int applicationId;
    private string applicationDisplayName;
    private string applicationSystemName;
    private DateTime validFrom;
    private DateTime validTo;
    public DateTime ValidTo { get; public set; }
    public DateTime ValidFrom { get; public set; }
    public string ApplicationDisplayName { get; public set; }
    public string ApplicationSystemName { get; public set; }
    public int ApplicationId { get; public set; }
    public DateTime get_ValidTo();
    public void set_ValidTo(DateTime value);
    public DateTime get_ValidFrom();
    public void set_ValidFrom(DateTime value);
    public string get_ApplicationDisplayName();
    public void set_ApplicationDisplayName(string value);
    public string get_ApplicationSystemName();
    public void set_ApplicationSystemName(string value);
    public int get_ApplicationId();
    public void set_ApplicationId(int value);
}
public class Holzer.Licencing.InvalidLicenceException : Exception {
    protected InvalidLicenceException(SerializationInfo info, StreamingContext context);
    public InvalidLicenceException(string message);
    public InvalidLicenceException(string message, Exception inner);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
public class Holzer.Licencing.LicenceExpiredException : Exception {
    protected LicenceExpiredException(SerializationInfo info, StreamingContext context);
    public LicenceExpiredException(string message);
    public LicenceExpiredException(string message, Exception inner);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
public class Holzer.Licencing.LicenceInfo : object {
    private int customerId;
    private int licenceId;
    private DateTime validFrom;
    private Nullable`1<DateTime> validTo;
    private string message;
    private string customerName;
    public int LicenceId { get; public set; }
    public int CustomerId { get; public set; }
    public DateTime ValidFrom { get; public set; }
    public Nullable`1<DateTime> ValidTo { get; public set; }
    public string Message { get; public set; }
    public string CustomerName { get; public set; }
    public LicenceInfo(int customerId, int licenceId, DateTime validFrom, Nullable`1<DateTime> validTo, string message, string customerName);
    public int get_LicenceId();
    public void set_LicenceId(int value);
    public int get_CustomerId();
    public void set_CustomerId(int value);
    public DateTime get_ValidFrom();
    public void set_ValidFrom(DateTime value);
    public Nullable`1<DateTime> get_ValidTo();
    public void set_ValidTo(Nullable`1<DateTime> value);
    public string get_Message();
    public void set_Message(string value);
    public string get_CustomerName();
    public void set_CustomerName(string value);
}
public static class Holzer.Licencing.LicenceKey : object {
    public static string Generate(int number);
    public static string GetProtectionKeyPart(string licenceKey);
}
public static class Holzer.Licencing.LicenceVerificationPackage : object {
    internal static string PackageHeader;
    public static string Create();
}
public class Holzer.Licencing.LicencingServices : object {
    private static bool isCached;
    private static LicenceInfo cached;
    [DebuggerStepThroughAttribute]
public static LicenceInfo VerifyLicencePackage(string licenceVerificationPackage);
    private static LicenceInfo Translate(LicenceInfo licenceInfo);
    public static LicenceInfo GetLicenceInfo();
    [DebuggerStepThroughAttribute]
public static int GetLicenceId();
}
public class Holzer.Licensing.LicenceConfig : ConfigurationBase {
    private static string KeyStringFile;
    private static LicenceConfig config;
    private string key;
    public string Key { get; }
    public LicenceConfig(XmlNode section);
    public static LicenceConfig GetConfig(bool requireConfiguration);
    internal static bool GetIsConfigured();
    public string get_Key();
}
public class Holzer.Licensing.LicenceSection : object {
    public sealed virtual object Create(object parent, object configContext, XmlNode section);
}
public class Holzer.LocalizedFault : ScopedFault {
    public LocalizedFault(string message);
    public LocalizedFault(object scope, string message);
}
public class Holzer.LocalizedFaultCollection : object {
    private ArrayList list;
    public int Count { get; }
    public LocalizedFaultCollection(LocalizedFault fault);
    public void ThrowOnErrors();
    public void Add(object scope, string message);
    public void Add(LocalizedFault fault);
    public void Add(LocalizedFaultCollection faults);
    public int get_Count();
    public virtual string ToString();
    public sealed virtual IEnumerator GetEnumerator();
    public LocalizedFaultCollection RemoveFaults(object scope);
}
public class Holzer.LocalizedFaultException : HumanErrorException {
    private LocalizedFaultCollection faults;
    public LocalizedFaultCollection Faults { get; }
    protected LocalizedFaultException(SerializationInfo info, StreamingContext context);
    public LocalizedFaultException(LocalizedFaultCollection faults);
    public LocalizedFaultException(string message);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public LocalizedFaultCollection get_Faults();
}
[DataContractAttribute]
public class Holzer.LoginActor : Actor {
    [CompilerGeneratedAttribute]
private string <IssuerKeyId>k__BackingField;
    public string IssuerKeyId { get; }
    public LoginActor(int id, string federationName, string federationGuid, string guid, string name, string displayName, string issuerKeyId);
    [CompilerGeneratedAttribute]
public string get_IssuerKeyId();
}
[DataContractAttribute]
public class Holzer.Messaging.UtskriftStyrningOmListInfo : object {
    [CompilerGeneratedAttribute]
private Nullable`1<int> <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DisplayName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Selectable>k__BackingField;
    [DataMemberAttribute]
public Nullable`1<int> Id { get; public set; }
    [DataMemberAttribute]
public string DisplayName { get; public set; }
    [DataMemberAttribute]
public bool Selectable { get; public set; }
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public string get_DisplayName();
    [CompilerGeneratedAttribute]
public void set_DisplayName(string value);
    [CompilerGeneratedAttribute]
public bool get_Selectable();
    [CompilerGeneratedAttribute]
public void set_Selectable(bool value);
}
public class Holzer.NamedParameter : object {
    private string key;
    private string value;
    public string Key { get; }
    public string Value { get; public set; }
    public NamedParameter(string key, string value);
    public NamedParameter(string key, Nullable`1<long> value);
    public string get_Key();
    public string get_Value();
    public void set_Value(string value);
}
public class Holzer.NamedParameterAttribute : Attribute {
}
[DefaultMemberAttribute("Item")]
public class Holzer.NamedParameterCollection : object {
    private string cachedToString;
    private Dictionary`2<string, NamedParameter> namedParameters;
    private List`1<NamedParameter> namedParametersList;
    public NamedParameter Item { get; }
    public string Item { get; public set; }
    public int Count { get; }
    public NamedParameterCollection(NamedParameter[] parameters);
    public NamedParameter get_Item(int i);
    public string get_Item(string key);
    public void set_Item(string key, string value);
    public void Append(NamedParameterCollection parameters, bool overrideExisting);
    public void Remove(int i);
    public string ExtractValue(string key);
    public int get_Count();
    public static NamedParameterCollection GetNamedParameters(object o);
    public T SetNamedParameters(T o);
    private object GenericParse(string value, Type fieldType);
    public string GetString(string name, string defaultValue);
    public string GetString(string name);
    public long GetLong(string name, long defaultValue);
    public Nullable`1<long> GetNullableLong(string name);
    public long GetLong(string name);
    public int GetInt(string name);
    public bool GetBool(string name);
    public decimal GetDecimal(string name);
    public void Add(string key, string value);
    public void Add(string name, Nullable`1<long> value);
    public string ToString(string encryptionKey);
    public virtual string ToString();
    private static string EncodeString(string data);
    public string ToUrlParameters(bool beginWithAmp);
    public string ToParseListString();
    public static NamedParameterCollection ParseList(string namedParameterString);
    public static NamedParameterCollection Parse(NamedParameter[] namedParameters);
    public static NamedParameterCollection Parse(string namedParameterString);
    public static NamedParameterCollection ParsePlane(string namedParameterString);
    public static NamedParameterCollection Parse(string encryptedNamedParameterString, string decryptionKey);
    private static string DecodeString(string data);
    public NamedParameter[] ToArray();
    public sealed virtual IEnumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<NamedParameter> System.Collections.Generic.IEnumerable<Holzer.NamedParameter>.GetEnumerator();
}
public abstract class Holzer.OperatingSystem : OperatingSystem {
}
public class Holzer.Reflection.TypeInfo : object {
    private static Dictionary`2<Type, TypeInfo> typeInfoCache;
    private static string AbbreviationPrefixSuffix;
    private static string AbbreviationPrefixSuffixReplacement;
    private static List`1<string> abbreviationNames;
    private static List`1<string> abbreviationAbbreviations;
    private static KeyDictionary`1<string> abbreviationsUsed;
    private static Dictionary`2<string, string> abbreviationsCacheFromName;
    private static Dictionary`2<string, string> abbreviationsCacheFromAbbreviation;
    private Type type;
    private FieldInfo[] fieldsWithNamedParameterAttribute;
    public FieldInfo[] FieldsWithNamedParameterAttribute { get; }
    private static TypeInfo();
    public TypeInfo(Type type);
    public static TypeInfo Get(Type type);
    public static void AddAbbreviation(string name, string abbreviation);
    public static void AddAbbreviationFirst(string name, string abbreviation);
    private FieldInfo[] GetFieldsWithNamedParameterAttribute();
    private void GetFieldsWithNamedParameterAttribute(Type type, ArrayList list, Hashtable addedFields);
    private FieldInfo[] GetFields();
    private void GetFields(Type type, ArrayList list);
    public FieldInfo[] get_FieldsWithNamedParameterAttribute();
    public static string EncodeTypeName(Type type);
    public static string EncodeTemplateName(Type type);
    public static Type DecodeTypeName(string typeName);
    public static string EncodeTypeNameAsString(Assembly assembly, string typeNameWithoutAssemblyName);
    public static string DecodeTypeNameToString(string encodedTypeName);
}
public abstract class Holzer.ScopedFault : object {
    private string message;
    private object scope;
    public string Message { get; }
    public object Scope { get; }
    public ScopedFault(object scope, string message);
    public string get_Message();
    public object get_Scope();
}
public enum Holzer.SearchMethod : Enum {
    public byte value__;
    public static SearchMethod Exact;
    public static SearchMethod Like;
}
public class Holzer.SearchMethodOption : SearchOption {
    private SearchMethod searchMethod;
    public SearchMethod SearchMethod { get; }
    public SearchMethodOption(SearchMethod searchMethod);
    public SearchMethod get_SearchMethod();
}
public abstract class Holzer.SearchOption : object {
}
public abstract class Holzer.SearchOptionsBase : object {
    private ArrayList options;
    public void Add(SearchOption option);
    protected abstract virtual void CheckAdd(SearchOption option);
    protected bool IsGenericOption(SearchOption option);
    public sealed virtual IEnumerator GetEnumerator();
}
public class Holzer.Security.AnonymousCredentialScope : object {
    [ThreadStaticAttribute]
private static bool isActived;
    public static bool IsInAnonymousScope { get; }
    public sealed virtual void Dispose();
    public static bool get_IsInAnonymousScope();
}
public class Holzer.Security.ApplicationIdentityContext : IdentityContext {
    private SecurityTokenCache securityTokenCache;
    private CacheDictionary`2<string, ChannelFactory> channelFactoryCache;
    private CacheDictionary`2<string, AuthorizationToken> authorizationTokenCache;
    private SemaphoreSlim authorizationTokenCacheLock;
    private LoginTicket onBehalfOf;
    private SemaphoreSlim renewLock;
    private Stopwatch ticketLifetime;
    private LoginTicket ticket;
    internal ApplicationIdentityContext(LoginTicket onBehalfOf);
    protected internal virtual ChannelFactory`1<TContract> CreateChannelFactoryWsFederationHttp(ServiceAddressInfo targetAddress, StandardServiceBindingOptions options);
    private XmlElement CreateOnBehalfOfElement();
    protected internal virtual void ConfigureWebApiClient(ServiceClient`1<TContract> client, ServiceAddressInfo address, StandardServiceBindingOptions options, ServicePortInfo port);
    public virtual AuthorizationToken GetAuthorizationToken(AuthorizationTokenOptions options, AuthorizationException authorizationException);
    [AsyncStateMachineAttribute("Holzer.Security.ApplicationIdentityContext/<GetAuthorizationTokenAsync>d__14")]
public virtual Task`1<AuthorizationToken> GetAuthorizationTokenAsync(AuthorizationTokenOptions options, AuthorizationException authorizationException);
    private bool TokenUsable(AuthorizationToken token, Exception authorizationException);
    protected internal virtual ServiceClient`1<IDirectoryService> ConnectDirectoryService();
    private ISecurityBinding GetSecurityBinding(bool throwIfMissing);
    public virtual LoginTicket GetLoginTicket();
    [AsyncStateMachineAttribute("Holzer.Security.ApplicationIdentityContext/<GetLoginTicketAsync>d__19")]
public virtual Task`1<LoginTicket> GetLoginTicketAsync();
    private bool TimeToRenewTicket();
    public virtual string ToString();
}
public class Holzer.Security.AuthenticatedEventHandler : MulticastDelegate {
    public AuthenticatedEventHandler(object object, IntPtr method);
    public virtual void Invoke(LoginTicket ticket);
    public virtual IAsyncResult BeginInvoke(LoginTicket ticket, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class Holzer.Security.AuthenticationPackage : object {
    private string federation;
    private string loginName;
    private string password;
    public string Federation { get; }
    public string LoginName { get; }
    internal string Password { get; }
    public AuthenticationPackage(string federation, string loginName, string password);
    public string get_Federation();
    public string get_LoginName();
    internal string get_Password();
    public virtual string ToString();
    public static AuthenticationPackage Parse(string s);
}
[DataContractAttribute]
public class Holzer.Security.BasicAccessControlEntry : object {
    private int id;
    private Actor actor;
    private Role role;
    private BasicAccessControlFunction[] functions;
    [DataMemberAttribute]
public int Id { get; public set; }
    [DataMemberAttribute]
public Actor Actor { get; public set; }
    [DataMemberAttribute]
public Role Role { get; public set; }
    [DataMemberAttribute]
public BasicAccessControlFunction[] Functions { get; public set; }
    public BasicAccessControlEntry(int id, Actor actor, BasicAccessControlFunction[] functions);
    public BasicAccessControlEntry(int id, Role role, BasicAccessControlFunction[] functions);
    public int get_Id();
    public void set_Id(int value);
    public Actor get_Actor();
    public void set_Actor(Actor value);
    public Role get_Role();
    public void set_Role(Role value);
    public BasicAccessControlFunction[] get_Functions();
    public void set_Functions(BasicAccessControlFunction[] value);
}
[DataContractAttribute]
public class Holzer.Security.BasicAccessControlFunction : object {
    private bool deny;
    private string systemName;
    private string displayName;
    [DataMemberAttribute]
public bool Deny { get; public set; }
    [DataMemberAttribute]
public string SystemName { get; public set; }
    [DataMemberAttribute]
public string DisplayName { get; public set; }
    public BasicAccessControlFunction(bool deny, string systemName, string displayName);
    public bool get_Deny();
    public void set_Deny(bool value);
    public string get_SystemName();
    public void set_SystemName(string value);
    public string get_DisplayName();
    public void set_DisplayName(string value);
}
[DataContractAttribute]
public class Holzer.Security.BasicAccessControlList : object {
    private BasicAccessControlEntry[] entries;
    private string objectDisplayName;
    [DataMemberAttribute]
public string ObjectDisplayName { get; public set; }
    [DataMemberAttribute]
public BasicAccessControlEntry[] Entries { get; public set; }
    public BasicAccessControlList(string objectDisplayName, BasicAccessControlEntry[] entries);
    public string get_ObjectDisplayName();
    public void set_ObjectDisplayName(string value);
    public BasicAccessControlEntry[] get_Entries();
    public void set_Entries(BasicAccessControlEntry[] value);
}
public class Holzer.Security.Cache.CachedIssuedSecurityTokenProvider : SecurityTokenProvider {
    internal static bool CachedMode;
    private SecurityTokenCache cache;
    private IssuedSecurityTokenProvider innerProvider;
    private ClientApplicationCertificateCredentials clientCertificateCredentials;
    private TimeSpan tokenIssueTimeout;
    public CommunicationState State { get; }
    public CachedIssuedSecurityTokenProvider(SecurityTokenCache cache, IssuedSecurityTokenProvider innerProvider, ClientApplicationCertificateCredentials clientCertificateCredentials);
    protected virtual SecurityToken GetTokenCore(TimeSpan timeout);
    protected virtual IAsyncResult BeginGetTokenCore(TimeSpan timeout, AsyncCallback callback, object state);
    protected virtual SecurityToken EndGetTokenCore(IAsyncResult result);
    private bool IsServiceTokenTimeValid(SecurityToken serviceToken);
    protected virtual override void Finalize();
    public void Abort();
    public IAsyncResult BeginClose(TimeSpan timeout, AsyncCallback callback, object state);
    public IAsyncResult BeginClose(AsyncCallback callback, object state);
    public IAsyncResult BeginOpen(TimeSpan timeout, AsyncCallback callback, object state);
    public IAsyncResult BeginOpen(AsyncCallback callback, object state);
    public void Close(TimeSpan timeout);
    public void Close();
    public void add_Closed(EventHandler value);
    public void remove_Closed(EventHandler value);
    public void add_Closing(EventHandler value);
    public void remove_Closing(EventHandler value);
    public void EndClose(IAsyncResult result);
    public void EndOpen(IAsyncResult result);
    public void add_Faulted(EventHandler value);
    public void remove_Faulted(EventHandler value);
    public void Open(TimeSpan timeout);
    public void Open();
    public void add_Opened(EventHandler value);
    public void remove_Opened(EventHandler value);
    public void add_Opening(EventHandler value);
    public void remove_Opening(EventHandler value);
    public CommunicationState get_State();
}
public class Holzer.Security.Certificates.ClientApplicationCertificateCredentials : ClientCredentials {
    private SecurityTokenCache tokenCache;
    private ClientApplicationCertificateCredentials(SecurityTokenCache tokenCache, X509Certificate2 defaultCertificate, Uri target, X509Certificate2 targetCertificate, X509Certificate2 clientCertificate, IEnumerable`1<X509Certificate2> targetCertificateList, EndpointAddress securityTokenServiceEndpointAddress);
    private ClientApplicationCertificateCredentials(ClientApplicationCertificateCredentials other);
    public static void Apply(SecurityTokenCache tokenCache, ServiceEndpoint serviceEndPoint, X509Certificate2 defaultCertificate, Uri target, X509Certificate2 targetCertificate, X509Certificate2 clientCertificate, EndpointAddress securityTokenServiceEndpointAddress, IEnumerable`1<X509Certificate2> targetCertificateList);
    protected virtual ClientCredentials CloneCore();
    public virtual SecurityTokenManager CreateSecurityTokenManager();
}
public class Holzer.Security.Certificates.ClientApplicationCertificateTokenManager : ClientCredentialsSecurityTokenManager {
    private SecurityTokenCache tokenCache;
    private ClientApplicationCertificateCredentials clientCertificateCredentials;
    public ClientApplicationCertificateTokenManager(SecurityTokenCache tokenCache, ClientApplicationCertificateCredentials clientCertificateCredentials);
    public virtual SecurityTokenProvider CreateSecurityTokenProvider(SecurityTokenRequirement tokenRequirement);
    public virtual SecurityTokenAuthenticator CreateSecurityTokenAuthenticator(SecurityTokenRequirement tokenRequirement, SecurityTokenResolver& outOfBandTokenResolver);
}
public class Holzer.Security.ClientRemotingHelper : object {
    private static ClientRemotingHelper();
    public static void Initialize(bool acceptIncomming);
}
public static class Holzer.Security.ClientStandaloneSecuritySession : object {
    public static StandaloneUserIdentityContext Logon(string domainName, string loginAddress);
    private static string ReplaceHostName(string address, string newHostname);
}
[DataContractAttribute]
public class Holzer.Security.Contracts.LoginTicketForSelfResponse : object {
    [CompilerGeneratedAttribute]
private PermissionInfo[] <Permissions>k__BackingField;
    [CompilerGeneratedAttribute]
private string <IdentityClass>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DisplayName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TicketId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TicketTrackingId>k__BackingField;
    [CompilerGeneratedAttribute]
private int <RenewIntervalSeconds>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LoginMethod>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LoginGuid>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FederationMemberGuid>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FederationMemberDisplayName>k__BackingField;
    [CompilerGeneratedAttribute]
private long <LogId>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Lcid>k__BackingField;
    [DataMemberAttribute]
public PermissionInfo[] Permissions { get; public set; }
    [DataMemberAttribute]
public string IdentityClass { get; public set; }
    [DataMemberAttribute]
public string Name { get; public set; }
    [DataMemberAttribute]
public string DisplayName { get; public set; }
    [DataMemberAttribute]
public string TicketId { get; public set; }
    [DataMemberAttribute]
public string TicketTrackingId { get; public set; }
    [DataMemberAttribute]
public int RenewIntervalSeconds { get; public set; }
    [DataMemberAttribute]
public string LoginMethod { get; public set; }
    [DataMemberAttribute]
public string LoginGuid { get; public set; }
    [DataMemberAttribute]
public string FederationMemberGuid { get; public set; }
    [DataMemberAttribute]
public string FederationMemberDisplayName { get; public set; }
    [DataMemberAttribute]
public long LogId { get; public set; }
    [DataMemberAttribute]
public int Lcid { get; public set; }
    [CompilerGeneratedAttribute]
public PermissionInfo[] get_Permissions();
    [CompilerGeneratedAttribute]
public void set_Permissions(PermissionInfo[] value);
    [CompilerGeneratedAttribute]
public string get_IdentityClass();
    [CompilerGeneratedAttribute]
public void set_IdentityClass(string value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_DisplayName();
    [CompilerGeneratedAttribute]
public void set_DisplayName(string value);
    [CompilerGeneratedAttribute]
public string get_TicketId();
    [CompilerGeneratedAttribute]
public void set_TicketId(string value);
    [CompilerGeneratedAttribute]
public string get_TicketTrackingId();
    [CompilerGeneratedAttribute]
public void set_TicketTrackingId(string value);
    [CompilerGeneratedAttribute]
public int get_RenewIntervalSeconds();
    [CompilerGeneratedAttribute]
public void set_RenewIntervalSeconds(int value);
    [CompilerGeneratedAttribute]
public string get_LoginMethod();
    [CompilerGeneratedAttribute]
public void set_LoginMethod(string value);
    [CompilerGeneratedAttribute]
public string get_LoginGuid();
    [CompilerGeneratedAttribute]
public void set_LoginGuid(string value);
    [CompilerGeneratedAttribute]
public string get_FederationMemberGuid();
    [CompilerGeneratedAttribute]
public void set_FederationMemberGuid(string value);
    [CompilerGeneratedAttribute]
public string get_FederationMemberDisplayName();
    [CompilerGeneratedAttribute]
public void set_FederationMemberDisplayName(string value);
    [CompilerGeneratedAttribute]
public long get_LogId();
    [CompilerGeneratedAttribute]
public void set_LogId(long value);
    [CompilerGeneratedAttribute]
public int get_Lcid();
    [CompilerGeneratedAttribute]
public void set_Lcid(int value);
}
public static class Holzer.Security.Contracts.SecurityClaimTypes : object {
    public static string IssuerThumbprint;
    public static string Namespace;
    public static string IdentityId;
    public static string IdentityFederationMemberId;
    public static string IdentityFederationMemberDisplayName;
    public static string IdentityName;
    public static string IdentityLoginMethod;
    public static string IdentityDisplayName;
    public static string IdentityLcid;
    public static string IdentityEncryptionKey;
    public static string IdentityEncryptedTicketId;
    public static string IdentityEncryptedTicketTrackingId;
    public static string IdentityRenewIntervalSeconds;
    public static string IdentityLogId;
    public static string IdentityClass;
}
[DataContractAttribute]
public class Holzer.Security.Contracts.SecurityTokenDataResponse : object {
    [CompilerGeneratedAttribute]
private PermissionInfo[] <Permissions>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<LoginTicketInfoItem> <Info>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SynchronizeToApplication>k__BackingField;
    [DataMemberAttribute]
public PermissionInfo[] Permissions { get; public set; }
    [DataMemberAttribute]
public List`1<LoginTicketInfoItem> Info { get; public set; }
    [DataMemberAttribute]
public bool SynchronizeToApplication { get; public set; }
    [CompilerGeneratedAttribute]
public PermissionInfo[] get_Permissions();
    [CompilerGeneratedAttribute]
public void set_Permissions(PermissionInfo[] value);
    [CompilerGeneratedAttribute]
public List`1<LoginTicketInfoItem> get_Info();
    [CompilerGeneratedAttribute]
public void set_Info(List`1<LoginTicketInfoItem> value);
    [CompilerGeneratedAttribute]
public bool get_SynchronizeToApplication();
    [CompilerGeneratedAttribute]
public void set_SynchronizeToApplication(bool value);
}
[DataContractAttribute]
public class Holzer.Security.Contracts.StartWebLoginRequest : object {
    [CompilerGeneratedAttribute]
private String[] <AcceptableLoginMethods>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AcceptableLoginMethodsIsRestriction>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DefaultLogonMethod>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LoginParameters>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RunAsByEncryptedTicketTrackingId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ReturnUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FallbackUrl>k__BackingField;
    [DataMemberAttribute]
public String[] AcceptableLoginMethods { get; public set; }
    [DataMemberAttribute]
public bool AcceptableLoginMethodsIsRestriction { get; public set; }
    [DataMemberAttribute]
public string DefaultLogonMethod { get; public set; }
    [DataMemberAttribute]
public string LoginParameters { get; public set; }
    [DataMemberAttribute]
public string RunAsByEncryptedTicketTrackingId { get; public set; }
    [DataMemberAttribute]
public string ReturnUrl { get; public set; }
    [DataMemberAttribute]
public string FallbackUrl { get; public set; }
    [CompilerGeneratedAttribute]
public String[] get_AcceptableLoginMethods();
    [CompilerGeneratedAttribute]
public void set_AcceptableLoginMethods(String[] value);
    [CompilerGeneratedAttribute]
public bool get_AcceptableLoginMethodsIsRestriction();
    [CompilerGeneratedAttribute]
public void set_AcceptableLoginMethodsIsRestriction(bool value);
    [CompilerGeneratedAttribute]
public string get_DefaultLogonMethod();
    [CompilerGeneratedAttribute]
public void set_DefaultLogonMethod(string value);
    [CompilerGeneratedAttribute]
public string get_LoginParameters();
    [CompilerGeneratedAttribute]
public void set_LoginParameters(string value);
    [CompilerGeneratedAttribute]
public string get_RunAsByEncryptedTicketTrackingId();
    [CompilerGeneratedAttribute]
public void set_RunAsByEncryptedTicketTrackingId(string value);
    [CompilerGeneratedAttribute]
public string get_ReturnUrl();
    [CompilerGeneratedAttribute]
public void set_ReturnUrl(string value);
    [CompilerGeneratedAttribute]
public string get_FallbackUrl();
    [CompilerGeneratedAttribute]
public void set_FallbackUrl(string value);
}
public class Holzer.Security.CreateRunAsLoginKey : object {
    [CompilerGeneratedAttribute]
private string <FederationMemberGuid>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LoginName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Key>k__BackingField;
    public string FederationMemberGuid { get; public set; }
    public string LoginName { get; public set; }
    public string Key { get; public set; }
    public CreateRunAsLoginKey(string federationMemberGuid, string loginName, string key);
    [CompilerGeneratedAttribute]
public string get_FederationMemberGuid();
    [CompilerGeneratedAttribute]
public void set_FederationMemberGuid(string value);
    [CompilerGeneratedAttribute]
public string get_LoginName();
    [CompilerGeneratedAttribute]
public void set_LoginName(string value);
    [CompilerGeneratedAttribute]
public string get_Key();
    [CompilerGeneratedAttribute]
public void set_Key(string value);
}
public class Holzer.Security.Cryptography : object {
    public static char Separator;
    public static Char[] IdCharacters;
    public static HashSet`1<char> IdCharactersSet;
    private static Cryptography();
    public static string CreateKey();
    public static RSACryptoServiceProvider CreateAsymmetricKey();
    public static string CreateAndEncodeKey();
    public static string EncodeKey(SymmetricAlgorithm key);
    public static string EncodeKey(RSACryptoServiceProvider key);
    public static SymmetricAlgorithm DecodeKey(string key);
    public static RSACryptoServiceProvider DecodeKeyRsa(string key);
    public static string Decrypt(string cipherText, SymmetricAlgorithm key);
    public static string Decrypt(string cipherText, string base64EncodedKey);
    public static MemoryStream DecryptToStream(string cipherText, string base64EncodedKey);
    public static MemoryStream DecryptToStream(string cipherText, SymmetricAlgorithm key);
    public static string Encrypt(string clearText, SymmetricAlgorithm key);
    public static string Encrypt(string clearText, string base64EncodedKey);
    public static string Encrypt(Byte[] data, string base64EncodedKey);
    public static string Encrypt(MemoryStream clearTextStream, string base64EncodedKey);
    public static string Encrypt(Byte[] data, SymmetricAlgorithm key);
    public static string Encrypt(MemoryStream clearTextStream, SymmetricAlgorithm key);
    public static string HashVersionUnsafe(string s);
    public static string Hash(string s);
    public static string HashSha256(string data);
    public static string HashSha256(Byte[] data);
    public static string HashSha256Base16(Byte[] data);
    public static string HashSha256Base16(string data);
    public static string HashSha512(string s);
    public static string HashSha512(string s, int rounds);
    public static string GenerateRandomId(int length);
    public static bool IsValidRandomId(string id);
    public static string GenerateRandomText(int approximateByteLength);
    public static string GenerateNumberCode(int length, int spaceInterval);
    public static string GenerateRecoveryKey(int length, int dividerInterval);
    public static string GeneratePassword(int length, int numberOfNonAlphanumericCharacters);
    public static Byte[] RijndaelKeyToBytes(RijndaelManaged exchangeKey);
    public static RijndaelManaged BytesToRijndaelKey(Byte[] bytes);
    public static string RsaKeyToString(RSACryptoServiceProvider publickey);
    public static RSACryptoServiceProvider StringToRsaKey(string data);
    public static string EncryptWithPassword(string clearText, string password);
    public static Byte[] EncryptBytesWithPassword(Byte[] buffer, string password);
    public static string DecryptWithPassword(string cipherText, string password);
    public static Byte[] DecryptBytesWithPassword(Byte[] buffer, string password);
    public static string EncryptKey(RijndaelManaged protectionKey, AsymmetricAlgorithm publicKey);
    public static RijndaelManaged DecryptKey(string encryptedProtectionKey, AsymmetricAlgorithm privateKey);
    public static string Encrypt(string plainText, AsymmetricAlgorithm publicKey);
    public static string Decrypt(string encryptedText, AsymmetricAlgorithm privateKey);
    public static void CheckServiceCertificate(X509Certificate2 cert);
}
public class Holzer.Security.DataProtection : object {
    private static Byte[] optionalEntropy;
    public string Encrypt(string data, ProtectionContext context);
    public Byte[] Encrypt(Byte[] data, ProtectionContext context);
    public string Decrypt(string data, ProtectionContext context);
    public Byte[] Decrypt(Byte[] data, ProtectionContext context);
    private static int GetFlags(ProtectionContext context);
    private static Byte[] GetOptionalEntropy();
    private static string ProtectData(string data, string secretName, int flags);
    private static string UnprotectData(string data, int flags);
    private static Byte[] UnprotectData(Byte[] data, int dwFlags);
    private static Byte[] ProtectData(Byte[] data, string name, int dwFlags);
}
public class Holzer.Security.DelegationChallenge : object {
    public string ApplicationName;
    public string ServerName;
    public string FederationMemberGuid;
    public string FederationMemberFriendlyName;
    public DelegationChallenge(string applicationName, string serverName, string federationMemberGuid, string federationMemberFriendlyName);
}
public class Holzer.Security.DelegationChallengeResponse : object {
    public string EncryptedStateKey;
    public string FederationMemberGuid;
    public string FederationMemberFriendlyName;
    public DelegationChallengeResponse(string encryptedStateKey, string federationMemberGuid, string federationMemberFriendlyName);
}
public class Holzer.Security.DisableCertificateValidationScope : object {
    private static RemoteCertificateValidationCallback handler;
    private bool isActive;
    [ThreadStaticAttribute]
private static DisableCertificateValidationScope current;
    private static bool IsAnyScopeActive { get; }
    private static DisableCertificateValidationScope();
    public sealed virtual void Dispose();
    private static bool get_IsAnyScopeActive();
    private static void EnsureInstalled();
}
public class Holzer.Security.EmbeddedLoginResult : object {
    private LoginTicket ticket;
    private string singleSignonKey;
    public LoginTicket Ticket { get; }
    public string SingleSignonKey { get; }
    public EmbeddedLoginResult(LoginTicket ticket, string singleSignonKey);
    public LoginTicket get_Ticket();
    public string get_SingleSignonKey();
}
public class Holzer.Security.FederationMemberInfo : object {
    private string guid;
    private string displayName;
    public string DisplayName { get; }
    public string Guid { get; }
    public FederationMemberInfo(string guid, string displayName);
    public string get_DisplayName();
    public string get_Guid();
}
public class Holzer.Security.GroupInfo : object {
    private GroupTypeInfo type;
    private string federation;
    private string guid;
    private string displayName;
    private StringInfo[] localizedName;
    public GroupTypeInfo Type { get; }
    public string FederationGuid { get; }
    public string Guid { get; }
    public string DisplayName { get; }
    public StringInfo[] LocalizedName { get; }
    public GroupInfo(GroupTypeInfo type, string federation, string guid, string displayName, StringInfo[] localizedName);
    public GroupTypeInfo get_Type();
    public string get_FederationGuid();
    public string get_Guid();
    public string get_DisplayName();
    public StringInfo[] get_LocalizedName();
}
public class Holzer.Security.GroupTypeInfo : object {
    private string name;
    private string displayName;
    public string Name { get; }
    public string DisplayName { get; }
    public GroupTypeInfo(string name, string displayName);
    public string get_Name();
    public string get_DisplayName();
}
public abstract class Holzer.Security.IdentityContext : object {
    private ConcurrentDictionary`2<string, object> state;
    [CompilerGeneratedAttribute]
private Actor <Actor>k__BackingField;
    public Actor Actor { get; internal set; }
    public object GetState(string key);
    public void SetState(string key, object value);
    protected internal virtual ChannelFactory`1<TContract> CreateChannelFactoryWsFederationHttp(ServiceAddressInfo serviceAddressInfo, StandardServiceBindingOptions options);
    protected internal virtual void ConfigureWebApiClient(ServiceClient`1<TContract> client, ServiceAddressInfo address, StandardServiceBindingOptions options, ServicePortInfo port);
    protected internal virtual ServiceClient`1<IDirectoryService> ConnectDirectoryService();
    public abstract virtual AuthorizationToken GetAuthorizationToken(AuthorizationTokenOptions options, AuthorizationException authorizationException);
    public virtual Task`1<AuthorizationToken> GetAuthorizationTokenAsync(AuthorizationTokenOptions options, AuthorizationException authorizationException);
    [CompilerGeneratedAttribute]
public Actor get_Actor();
    [CompilerGeneratedAttribute]
internal void set_Actor(Actor value);
    public virtual LoginTicket GetLoginTicket();
    public virtual Task`1<LoginTicket> GetLoginTicketAsync();
}
public class Holzer.Security.IdentityScope : object {
    private static string LogicalCallContextDataName;
    private DisposableObject disposable;
    private IdentityScope outerIdentityScope;
    private IdentityContext identityContext;
    private bool setThreadPrincipal;
    private LoginTicket revertPrincipal;
    public static IdentityContext CurrentIdentityContext { get; }
    private static IdentityScope CurrentIdentityScope { get; private set; }
    public IdentityContext IdentityContext { get; }
    private IdentityScope(IdentityContext identityContext, IdentityScope outerIdentityScope);
    public static IdentityContext get_CurrentIdentityContext();
    private static void set_CurrentIdentityScope(IdentityScope value);
    private static IdentityScope get_CurrentIdentityScope();
    public static IdentityScope BeginOnCurrentThread(IdentityContext identityContext, bool setThreadPrincipal);
    private void InitializeThreadPrincipal(IdentityContext identityContext);
    [AsyncStateMachineAttribute("Holzer.Security.IdentityScope/<InitializeThreadPrincipalAsync>d__14")]
private Task InitializeThreadPrincipalAsync(IdentityContext identityContext);
    public sealed virtual void Dispose();
    protected virtual override void Finalize();
    public void DisposeCore(bool disposedByGarbageCollector);
    public IdentityContext get_IdentityContext();
    public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
[ServiceContractAttribute]
[ClientExceptionBehavior]
public interface Holzer.Security.IDirectoryService {
    [OperationContractAttribute]
public abstract virtual ServicePortInfo[] Search(DirectoryQuery query);
}
[ServiceContractAttribute]
[ClientExceptionBehavior]
public interface Holzer.Security.IDirectoryServiceAsync {
    [OperationContractAttribute]
public abstract virtual Task`1<ServicePortInfo[]> SearchAsync(DirectoryQuery query);
    [OperationContractAttribute]
public abstract virtual void PublishApplicationInstance(ApplicationInstanceMetaInfo definition);
    [OperationContractAttribute]
public abstract virtual LoginActor GetCurrentActor();
}
public interface Holzer.Security.ILogonSessionManager {
    public abstract virtual LoginTicket InitializeTicket(string defaultSessionID);
    public abstract virtual void SaveTicket(LoginTicket ticket, string secureSessionIdentifier);
    public abstract virtual void LogOff(LoginTicket ticket, string secureSessionIdentifier);
    public abstract virtual String[] GetActiveLogins();
}
public interface Holzer.Security.IOwnedIdentity {
    public abstract virtual ChannelFactory`1<TContract> CreateChannelFactoryWsFederationHttp(ServiceAddressInfo serviceAddressInfo);
}
public interface Holzer.Security.ISecurityBinding {
    public bool IsAvailable { get; }
    public string LegacyLoginKey { get; }
    public string ApplicationInstanceName { get; }
    public string FederationGuid { get; }
    public string Realm { get; }
    public ServiceAddressInfo SecurityServiceBaseAddress { get; }
    public Uri PublicOpenIdConnectUrl { get; }
    public Uri PublicOAuthTokenUrl { get; }
    public Uri PublicOAuthAuthorizationUrl { get; }
    public ServiceAddressInfo SecurityTokenServiceAddress { get; }
    public EndpointAddress SecurityTokenServiceEndpointAddress { get; }
    public ServiceAddressInfo DirectoryServiceAddress { get; }
    public Uri ApplicationInstallServiceAddress { get; }
    public string LoginServiceAddress { get; }
    public SecurityKeyValue OwnPublicKey { get; }
    public AsymmetricAlgorithm OwnPrivateKey { get; }
    public X509Certificate2 ApplicationClientCertificate { get; }
    public X509Certificate2 ApplicationServiceCertificate { get; }
    public abstract virtual bool get_IsAvailable();
    public abstract virtual string get_LegacyLoginKey();
    public abstract virtual string get_ApplicationInstanceName();
    public abstract virtual string get_FederationGuid();
    public abstract virtual string get_Realm();
    public abstract virtual ServiceAddressInfo get_SecurityServiceBaseAddress();
    public abstract virtual Uri get_PublicOpenIdConnectUrl();
    public abstract virtual Uri get_PublicOAuthTokenUrl();
    public abstract virtual Uri get_PublicOAuthAuthorizationUrl();
    public abstract virtual ServiceAddressInfo get_SecurityTokenServiceAddress();
    public abstract virtual EndpointAddress get_SecurityTokenServiceEndpointAddress();
    public abstract virtual ServiceAddressInfo get_DirectoryServiceAddress();
    public abstract virtual Uri get_ApplicationInstallServiceAddress();
    public abstract virtual string get_LoginServiceAddress();
    public abstract virtual SecurityKeyValue get_OwnPublicKey();
    public abstract virtual AsymmetricAlgorithm get_OwnPrivateKey();
    public abstract virtual X509Certificate2 get_ApplicationClientCertificate();
    public abstract virtual X509Certificate2 get_ApplicationServiceCertificate();
    public abstract virtual void OverrideExternalAddress(string loginServiceExternalOverride);
    public abstract virtual void BindCustomSecurity(Byte[] securityBinding, string customAddress, string externalCustomAddress);
}
public interface Holzer.Security.ISecurityBindingStandalone {
    public bool IsAvailable { get; }
    public string FederationGuid { get; }
    public string FederationName { get; }
    public ServiceAddressInfo DirectoryServiceAddress { get; }
    public ServiceAddressInfo SecurityTokenServiceAddress { get; }
    public EndpointAddress SecurityTokenServiceEndpointAddress { get; }
    public WSHttpBinding IssuerBinding { get; }
    public abstract virtual bool get_IsAvailable();
    public abstract virtual string get_FederationGuid();
    public abstract virtual string get_FederationName();
    public abstract virtual ServiceAddressInfo get_DirectoryServiceAddress();
    public abstract virtual ServiceAddressInfo get_SecurityTokenServiceAddress();
    public abstract virtual EndpointAddress get_SecurityTokenServiceEndpointAddress();
    public abstract virtual WSHttpBinding get_IssuerBinding();
}
[ServiceContractAttribute]
public interface Holzer.Security.ISecurityDiscoveryService {
    [OperationContractAttribute]
public abstract virtual SecurityDiscoveryResponse Discover();
}
public interface Holzer.Security.ISecurityTokenFilter {
    public abstract virtual void InitializeToken(ServiceAddress address);
}
[ServiceContractAttribute]
public interface Holzer.Security.ISecurityTokenService {
    [OperationContractAttribute]
public abstract virtual Message IssueToken(Message request);
    [OperationContractAttribute]
public abstract virtual SecurityTokenDataResponse GetExtendedTokenData(string ticketId, bool returnPermissions, long logId);
    [OperationContractAttribute]
public abstract virtual LoginTicketForSelfResponse CreateLoginTicketForSelf(bool returnPermissions);
    [OperationContractAttribute]
public abstract virtual SecurityTokenDataResponse GetFederatedExtendedTokenData(string accountFederationMemberGuid, string accountLoginGuid, bool returnPermissions);
}
public class Holzer.Security.LoginContextInfo : object {
    public static string AuthDeviceCookieName;
    [CompilerGeneratedAttribute]
private string <UserAgent>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RayId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Referer>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Client>k__BackingField;
    private string channel;
    private bool secure;
    private string hostAddress;
    private string hostName;
    private string hostAgent;
    private string additionalData;
    private string server;
    private string deviceKey;
    public string Channel { get; }
    public bool IsSecure { get; }
    public string HostAddress { get; }
    public string HostName { get; }
    public string HostAgent { get; }
    public string AdditionalData { get; }
    public string Server { get; }
    public string DeviceKey { get; }
    public string UserAgent { get; public set; }
    public string RayId { get; }
    public string Referer { get; }
    public string Client { get; }
    public LoginContextInfo(string channel, bool secure, string hostAddress, string hostName, string hostAgent, string additionalData, string server, string deviceKey, string userAgent, string rayId, string referer, string client);
    public static LoginContextInfo Create(bool allowSystemContext);
    public static LoginContextInfo CreateFromWcfContext(string additionalInfo, string additionalHostAdress, bool requireDeviceKey, bool parseHostAddress);
    public void RequireDeviceKey();
    public static LoginContextInfo CreateFromHttpContext();
    public static LoginContextInfo CreateFromHttpContext(string additionalInfo);
    [DebuggerStepThroughAttribute]
public static LoginContextInfo CreateFromHttpContext(string additionalInfo, bool fallbackToSystemContext);
    [DebuggerStepThroughAttribute]
private static LoginContextInfo CreateFromHttpContext(string additionalInfo, HttpContext context, HttpRequest request);
    public static LoginContextInfo CreateFromSystemContext(string additionalInfo);
    public string GetOriginalHostAddress(bool trimInterfaceName, bool ignoreErrors);
    public IPAddress GetOriginalHostAddressIp(bool ignoreErrors);
    public string get_Channel();
    public bool get_IsSecure();
    public string get_HostAddress();
    public string get_HostName();
    public string get_HostAgent();
    public string get_AdditionalData();
    public string get_Server();
    public string get_DeviceKey();
    [CompilerGeneratedAttribute]
public string get_UserAgent();
    [CompilerGeneratedAttribute]
public void set_UserAgent(string value);
    [CompilerGeneratedAttribute]
public string get_RayId();
    [CompilerGeneratedAttribute]
public string get_Referer();
    [CompilerGeneratedAttribute]
public string get_Client();
}
public class Holzer.Security.LoginIdentifier : object {
    private string federation;
    private string login;
    public string Federation { get; }
    public string Login { get; }
    public LoginIdentifier(string federation, string login);
    public string get_Federation();
    public string get_Login();
}
public class Holzer.Security.LoginIdentity : object {
    private static string AuthenticationTypeName;
    private string name;
    public bool IsAuthenticated { get; }
    public string Name { get; }
    public string AuthenticationType { get; }
    internal LoginIdentity(string name);
    public sealed virtual bool get_IsAuthenticated();
    public sealed virtual string get_Name();
    public sealed virtual string get_AuthenticationType();
}
[ServiceBehaviorAttribute]
public class Holzer.Security.LoginInfo : object {
    private string guid;
    private string name;
    private string displayName;
    private bool isActivated;
    private bool isValid;
    private bool mustChangeName;
    private bool mustChangePassword;
    private string federationGuid;
    private string federationName;
    [ObsoleteAttribute("Replaced by UniqueIdentifier.")]
[DataMemberAttribute]
public Guid Guid { get; }
    [DataMemberAttribute]
public string UniqueIdentifier { get; }
    [DataMemberAttribute]
public string Name { get; }
    [DataMemberAttribute]
public string DisplayName { get; }
    [DataMemberAttribute]
public bool IsActivated { get; }
    [DataMemberAttribute]
public bool IsValid { get; }
    [DataMemberAttribute]
public bool MustChangeName { get; }
    [DataMemberAttribute]
public bool MustChangePassword { get; }
    [DataMemberAttribute]
public string FederationGuid { get; }
    [DataMemberAttribute]
public string FederationName { get; }
    public LoginInfo(string guid, string name, string displayName, bool isActivated, bool isValid, bool mustChangeName, bool mustChangePassword, string federationGuid, string federationName);
    public virtual string ToString();
    public Guid get_Guid();
    public string get_UniqueIdentifier();
    public string get_Name();
    public string get_DisplayName();
    public bool get_IsActivated();
    public bool get_IsValid();
    public bool get_MustChangeName();
    public bool get_MustChangePassword();
    public string get_FederationGuid();
    public string get_FederationName();
}
public class Holzer.Security.LoginLogInfo : object {
    private string federation;
    private long logId;
    private string loginGuid;
    private string loginName;
    public string Federation { get; }
    public long LogId { get; }
    public string LoginGuid { get; }
    public string LoginName { get; }
    public LoginLogInfo(string federation, long logId, string loginGuid, string loginName);
    public static LoginLogInfo Create();
    public string Serialize(string key);
    public static LoginLogInfo Deserialize(string data, string key);
    public string get_Federation();
    public long get_LogId();
    public string get_LoginGuid();
    public string get_LoginName();
}
public class Holzer.Security.LoginPrincipal : MarshalByRefObject {
    private LoginTicket ticket;
    private LoginIdentity identity;
    public IIdentity Identity { get; }
    public LoginTicket Ticket { get; }
    public LoginPrincipal(LoginTicket ticket, string name);
    public sealed virtual IIdentity get_Identity();
    public LoginTicket get_Ticket();
    public sealed virtual bool IsInRole(string role);
}
public class Holzer.Security.LoginTicket : object {
    private int ClockSkewSeconds;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <Expires>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsDisconnectedTicket>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AccessTokenData>k__BackingField;
    private ISecurityProvider provider;
    private string guid;
    private LoginTicketByRef marshalledRef;
    private string displayName;
    private string name;
    private LoginPrincipal principal;
    private string loginMethod;
    private bool isDelegated;
    private bool isPublicComputer;
    private bool mustChangeName;
    private bool mustChangePassword;
    private string federationMemberGuid;
    private string federationMemberFriendlyName;
    private bool isFederated;
    private long logId;
    private int lcid;
    private CultureInfo culture;
    private string userCacheKey;
    private bool runAs;
    [OptionalFieldAttribute]
private string runAsByLoginName;
    [OptionalFieldAttribute]
private string runAsByLoginFederationMemberGuid;
    [OptionalFieldAttribute]
private string runAsByLoginGuid;
    [OptionalFieldAttribute]
private string runAsByDisplayName;
    [OptionalFieldAttribute]
private string identityClass;
    [OptionalFieldAttribute]
private bool synchronizeToApplication;
    private bool isValid;
    private bool collected;
    private SimpleStateBag state;
    private NameValueCollection sessionIdentifiers;
    private string secureSessionIdentifier;
    private PermissionSet permissions;
    private long lastCollection;
    private int renewIntervalSeconds;
    private string trackingIdentifier;
    private LoginTicketRoleCollection roles;
    private IdentityContext identityContext;
    private bool renewing;
    private LoginTicketInfoSet info;
    internal ISecurityProvider Provider { get; }
    public int RenewIntervalSeconds { get; }
    public string Name { get; }
    public string NameUnsafe { get; }
    public string DisplayName { get; }
    public string DisplayNameUnsafe { get; }
    public LoginPrincipal Principal { get; }
    public bool IsValid { get; }
    public string SecureSessionIdentifier { get; }
    public PermissionSet Permissions { get; }
    public LoginTicketRoleCollection Roles { get; }
    public LoginTicketInfoSet Info { get; }
    public bool IsPublicComputer { get; }
    public string LoginMethod { get; }
    public string Guid { get; }
    public string IdentityClass { get; }
    [ObsoleteAttribute("Replaced by Guid.", "False")]
public Guid UniqueIdentifier { get; }
    public bool MustChangeName { get; }
    public bool MustChangePassword { get; }
    public SimpleStateBag State { get; }
    public IdentityContext IdentityContext { get; }
    public string FederationGuid { get; }
    public string FederationDisplayName { get; }
    [ObsoleteAttribute("Replaced by LogId.", "False")]
public long LoginLogId { get; }
    public long LogId { get; }
    public int Lcid { get; }
    public CultureInfo Culture { get; }
    public string CacheKey { get; }
    public bool SynchronizeToApplication { get; }
    public bool IsRunAsSession { get; }
    public string RunAsByLoginName { get; }
    public string RunAsByLoginGuid { get; }
    public string RunAsByLoginFederationMemberGuid { get; }
    public string RunAsByDisplayName { get; }
    public Nullable`1<DateTime> Expires { get; }
    public bool IsDisconnectedTicket { get; }
    public string AccessTokenData { get; }
    public long ExpiresInSeconds { get; }
    public DateTime ValidTo { get; }
    public DateTime RenewAfter { get; }
    public LoginTicket(ISecurityProvider provider, string identityClass, string name, string displayName, string secureSessionIdentifier, PermissionSet permissions, bool isDelegated, string trackingIdentifier, int renewIntervalSeconds, bool isPublicComputer, string loginMethod, string guid, bool mustChangeName, bool mustChangePassword, string federationMemberGuid, string federationMemberFriendlyName, bool isFederated, long logId, int lcid, bool runAs, string runAsByLoginName, string runAsByLoginFederationMemberGuid, string runAsByLoginGuid, string runAsByDisplayName, bool isPartialTicket, LoginTicketInfoSet info, bool synchronizeToApplication, bool disconnectedTicket, Nullable`1<DateTime> expires, string accessTokenData);
    internal ISecurityProvider get_Provider();
    public ISecurityProvider GetProvider(bool throwIfNotEnabled);
    internal LoginLogInfo GetLoginLogInfo();
    private void EnsureFresh(bool throwIfInvalid, bool throwIfOffline);
    public bool TimeToRenew();
    public int get_RenewIntervalSeconds();
    private long GetLifeTime();
    public bool Renew(bool throwOnError, bool ignoreOnNotSignedInException);
    public string get_Name();
    public string get_NameUnsafe();
    public string get_DisplayName();
    public string get_DisplayNameUnsafe();
    public LoginPrincipal get_Principal();
    public bool get_IsValid();
    public string get_SecureSessionIdentifier();
    public string GetTrackingIdentifier(bool throwIfInvalid, bool throwIfOffline);
    public PermissionSet get_Permissions();
    public LoginTicketRoleCollection get_Roles();
    public LoginTicketInfoSet get_Info();
    public bool HasPermission(string permissionName, bool isActiveCheck);
    public bool HasPermissions(String[] permissionNames, bool isActiveCheck);
    public void ChangeFormsPassword(string oldPassword, string newPassword, string additionalLogInfo);
    public void ChangeName(string newName, string additionalLogInfo);
    public void ChangeDisplayName(string newDisplayName, string additionalLogInfo);
    public void ChangeNameAndDisplayName(string newName, string newDisplayName, string additionalLogInfo);
    public DateTime DisableAccount(string additionalInfo, DateTime disableAt);
    public DateTime DisableAccount(string additionalInfo);
    public virtual string ToString();
    internal string GetSessionIdentifier(string key);
    internal void SetSessionIdentifier(string key, string id);
    public bool get_IsPublicComputer();
    public string get_LoginMethod();
    public string get_Guid();
    public string get_IdentityClass();
    public string GetGuid(bool mustBeValid);
    public Guid get_UniqueIdentifier();
    [ObsoleteAttribute("Replaced by GetGuid().", "False")]
public Guid GetUniqueIdentifier(bool mustBeValid);
    public bool get_MustChangeName();
    public bool get_MustChangePassword();
    public SimpleStateBag get_State();
    public sealed virtual void OnDeserialization(object sender);
    public IdentityContext get_IdentityContext();
    public bool IsCreated();
    public LoginTicket GetCreatedTicket();
    public string get_FederationGuid();
    public string get_FederationDisplayName();
    public long get_LoginLogId();
    public long get_LogId();
    public int get_Lcid();
    public CultureInfo get_Culture();
    public string get_CacheKey();
    public bool get_SynchronizeToApplication();
    public bool get_IsRunAsSession();
    public string get_RunAsByLoginName();
    public string get_RunAsByLoginGuid();
    public string get_RunAsByLoginFederationMemberGuid();
    public string get_RunAsByDisplayName();
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_Expires();
    [CompilerGeneratedAttribute]
public bool get_IsDisconnectedTicket();
    [CompilerGeneratedAttribute]
public string get_AccessTokenData();
    private void RequireConnectedTicket();
    public long get_ExpiresInSeconds();
    public DateTime get_ValidTo();
    public DateTime get_RenewAfter();
}
internal class Holzer.Security.LoginTicketByRef : MarshalByRefObject {
    private LoginTicket ticket;
    internal LoginTicket Ticket { get; }
    public LoginTicketByRef(LoginTicket ticket);
    internal LoginTicket get_Ticket();
}
[DataContractAttribute]
public class Holzer.Security.LoginTicketInfoItem : object {
    [CompilerGeneratedAttribute]
private long <InternalId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DisplayName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Authenticated>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <ValidFrom>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <ValidTo>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FromFederationMemberName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FromFederationMemberGuid>k__BackingField;
    [DataMemberAttribute]
public long InternalId { get; public set; }
    [DataMemberAttribute]
public string Name { get; public set; }
    [DataMemberAttribute]
public string DisplayName { get; public set; }
    [DataMemberAttribute]
public string Value { get; public set; }
    [DataMemberAttribute]
public bool Authenticated { get; public set; }
    [DataMemberAttribute]
public DateTime ValidFrom { get; public set; }
    [DataMemberAttribute]
public DateTime ValidTo { get; public set; }
    [DataMemberAttribute]
public string FromFederationMemberName { get; public set; }
    [DataMemberAttribute]
public string FromFederationMemberGuid { get; public set; }
    public bool IsValidNow { get; }
    public LoginTicketInfoItem(string name, string displayName, string value, bool authenticated, DateTime validFrom, DateTime validTo, string fromFederationMemberName, string fromFederationMemberGuid, long internalId);
    [CompilerGeneratedAttribute]
public long get_InternalId();
    [CompilerGeneratedAttribute]
public void set_InternalId(long value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_DisplayName();
    [CompilerGeneratedAttribute]
public void set_DisplayName(string value);
    [CompilerGeneratedAttribute]
public string get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(string value);
    [CompilerGeneratedAttribute]
public bool get_Authenticated();
    [CompilerGeneratedAttribute]
public void set_Authenticated(bool value);
    [CompilerGeneratedAttribute]
public DateTime get_ValidFrom();
    [CompilerGeneratedAttribute]
public void set_ValidFrom(DateTime value);
    [CompilerGeneratedAttribute]
public DateTime get_ValidTo();
    [CompilerGeneratedAttribute]
public void set_ValidTo(DateTime value);
    [CompilerGeneratedAttribute]
public string get_FromFederationMemberName();
    [CompilerGeneratedAttribute]
public void set_FromFederationMemberName(string value);
    [CompilerGeneratedAttribute]
public string get_FromFederationMemberGuid();
    [CompilerGeneratedAttribute]
public void set_FromFederationMemberGuid(string value);
    public bool get_IsValidNow();
}
public class Holzer.Security.LoginTicketInfoSet : object {
    private List`1<LoginTicketInfoItem> info;
    private Dictionary`2<string, LoginTicketInfoItem> currentValues;
    public int Count { get; }
    public LoginTicketInfoSet(IEnumerable`1<LoginTicketInfoItem> infoList);
    public void Add(LoginTicketInfoItem item);
    public string GetValue(string name);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual IEnumerator`1<LoginTicketInfoItem> GetEnumerator();
    public int get_Count();
}
public class Holzer.Security.LoginTicketRoleCollection : object {
    public static string RolePermissionNamePrefix;
    private HashSet`1<string> guids;
    private string guidsAsString;
    public LoginTicketRoleCollection(PermissionSet permissions);
    public string ToGuidString();
    public bool Contains(string guid);
}
[DataContractAttribute]
public class Holzer.Security.LogOffResult : object {
    [CompilerGeneratedAttribute]
private string <LogOffUrl>k__BackingField;
    [DataMemberAttribute]
public string LogOffUrl { get; public set; }
    public LogOffResult(string logOffUrl);
    [CompilerGeneratedAttribute]
public string get_LogOffUrl();
    [CompilerGeneratedAttribute]
public void set_LogOffUrl(string value);
}
internal class Holzer.Security.NativeMethods : object {
    private static string crypt32;
    private static string kernel32;
    public static int PromptOnProtect;
    public static int PromptOnUnprotect;
    public static int UIForbidden;
    public static int PromptStrong;
    public static int LocalMachine;
    public static int CredSync;
    public static int Audit;
    public static int NoRecovery;
    public static int VerifyProtection;
    public static bool CryptProtectData(DATA_BLOB& dataIn, string szDataDescr, IntPtr optionalEntropy, IntPtr pvReserved, IntPtr pPromptStruct, int dwFlags, DATA_BLOB& pDataOut);
    public static bool CryptUnprotectData(DATA_BLOB& dataIn, StringBuilder ppszDataDescr, IntPtr optionalEntropy, IntPtr pvReserved, IntPtr pPromptStruct, int dwFlags, DATA_BLOB& pDataOut);
    public static IntPtr LocalFree(IntPtr hMem);
}
public class Holzer.Security.NetworkLogInfo : object {
    private string remoteHostAddress;
    public string RemoteHostAddress { get; }
    public NetworkLogInfo(string remoteHostAddress);
    public static NetworkLogInfo Create();
    [DebuggerStepThroughAttribute]
public void Extend(HttpContext context);
    public void Extend(ITransportHeaders requestHeaders);
    private static string GetAt();
    public string Serialize(string key);
    public static NetworkLogInfo Deserialize(string data, string key);
    public string get_RemoteHostAddress();
}
[DataContractAttribute]
public class Holzer.Security.OpenFederationMemberInfo : object {
    private string guid;
    private string displayName;
    [DataMemberAttribute]
public string DisplayName { get; public set; }
    [DataMemberAttribute]
public string Guid { get; public set; }
    public OpenFederationMemberInfo(string guid, string displayName);
    public string get_DisplayName();
    public void set_DisplayName(string value);
    public string get_Guid();
    public void set_Guid(string value);
}
public class Holzer.Security.PasswordChallenge : object {
    public Byte[] Salt;
    public string Challenge;
    public string StateKey;
    public string Federation;
    public PasswordChallengeMethod[] Methods;
    public string Algorithm;
    public PasswordChallenge(Byte[] salt, string challenge, string stateKey, string federation, string algorithm);
}
public class Holzer.Security.PasswordChallengeMethod : object {
    public string TypeName;
    public PasswordChallengeMethod(string typeName);
}
public class Holzer.Security.PasswordChallengeResponse : object {
    public string Response;
    public string ResponseType;
    public string StateKey;
    public string Federation;
    public PasswordChallengeResponse(string federation, string response, string stateKey);
    public PasswordChallengeResponse(string federation, string response, string responseType, string stateKey);
}
public class Holzer.Security.PasswordChangeRequest : object {
    private string key;
    private string baseUrl;
    public string Key { get; }
    public string BaseUrl { get; }
    public string Url { get; }
    public PasswordChangeRequest(string key, string baseUrl);
    public string get_Key();
    public string get_BaseUrl();
    public string get_Url();
}
public class Holzer.Security.PasswordChangeResult : object {
    [CompilerGeneratedAttribute]
private int <LoginId>k__BackingField;
    private string username;
    private string password;
    private string returnUrl;
    public string Username { get; }
    public string Password { get; }
    public string ReturnUrl { get; }
    public int LoginId { get; public set; }
    public PasswordChangeResult(string username, string password, string returnUrl);
    public string get_Username();
    public string get_Password();
    public string get_ReturnUrl();
    [CompilerGeneratedAttribute]
public int get_LoginId();
    [CompilerGeneratedAttribute]
public void set_LoginId(int value);
}
public class Holzer.Security.PasswordCredentials : object {
    [ThreadStaticAttribute]
private static PasswordCredentials current;
    internal string Federation;
    internal string LoginName;
    internal string Password;
    private NameValueCollection sessionIdentifiers;
    public static PasswordCredentials Current { get; public set; }
    public string Name { get; }
    public string FederationGuid { get; }
    public PasswordCredentials(AuthenticationPackage authenticationPackage);
    public PasswordCredentials(string federation, string loginName, string password);
    public PasswordCredentials(string loginName, string password);
    public static PasswordCredentials get_Current();
    public static void set_Current(PasswordCredentials value);
    internal string GetSessionIdentifier(string key);
    internal void SetSessionIdentifier(string key, string id);
    public void IndicatePasswordEnabled(IMessage msg);
    public string get_Name();
    public string get_FederationGuid();
}
public class Holzer.Security.PasswordCredentialScope : object {
    public PasswordCredentialScope(AuthenticationPackage authenticationPackage);
    public PasswordCredentialScope(string loginName, string password);
    public PasswordCredentialScope(string federation, string loginName, string password);
    public sealed virtual void Dispose();
}
public class Holzer.Security.PasswordHash : object {
    private static int SaltLength;
    private static int MaxPasswordLength;
    public static string Create(string password);
    private static Byte[] CreateSalt();
    public static bool IsCorrect(string passwordPackage, string password);
    public static Byte[] GetSalt(Transaction t, string passwordPackage);
}
public class Holzer.Security.PermissionDescription : object {
    private string name;
    private string displayName;
    public string Name { get; }
    public string DisplayName { get; }
    public PermissionDescription(string name, string displayName);
    public string get_Name();
    public string get_DisplayName();
    public virtual string ToString();
}
internal class Holzer.Security.PermissionDescriptionCache : object {
    private Hashtable cache;
    public PermissionDescription GetPermissionDescription(string permissionName);
}
[DataContractAttribute]
public class Holzer.Security.PermissionInfo : object {
    [CompilerGeneratedAttribute]
private string <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Application>k__BackingField;
    [DataMemberAttribute]
public string Key { get; public set; }
    [DataMemberAttribute]
public string Name { get; public set; }
    public int Application { get; public set; }
    public PermissionInfo(string key, string name);
    public PermissionInfo(string key, string name, int application);
    [CompilerGeneratedAttribute]
public string get_Key();
    [CompilerGeneratedAttribute]
public void set_Key(string value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public int get_Application();
    [CompilerGeneratedAttribute]
public void set_Application(int value);
}
public class Holzer.Security.PermissionSet : object {
    private bool locked;
    private Dictionary`2<string, PermissionDescription> permissions;
    public int Count { get; }
    public PermissionSet(PermissionInfo[] permissions);
    public bool Contains(string permissionName);
    public void Add(PermissionDescription permission);
    public void Add(IEnumerable`1<PermissionDescription> permission);
    public void Lock();
    [IteratorStateMachineAttribute("Holzer.Security.PermissionSet/<FindByName>d__6")]
public IEnumerable`1<string> FindByName(Predicate`1<string> permissionNamePredicate);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual IEnumerator`1<PermissionDescription> GetEnumerator();
    public int get_Count();
}
public class Holzer.Security.ProcessAuthorizationHeaderArgs : object {
    [CompilerGeneratedAttribute]
private string <Scheme>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Parameters>k__BackingField;
    public string Scheme { get; }
    public string Parameters { get; }
    public ProcessAuthorizationHeaderArgs(string scheme, string parameters);
    [CompilerGeneratedAttribute]
public string get_Scheme();
    [CompilerGeneratedAttribute]
public string get_Parameters();
}
public enum Holzer.Security.ProtectionContext : Enum {
    public int value__;
    public static ProtectionContext Machine;
    public static ProtectionContext User;
}
public class Holzer.Security.Providers.CompleteWebLoginResult : object {
    [CompilerGeneratedAttribute]
private LoginTicket <Ticket>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RefreshToken>k__BackingField;
    public LoginTicket Ticket { get; }
    public string RefreshToken { get; }
    public CompleteWebLoginResult(LoginTicket ticket, string refreshToken);
    [CompilerGeneratedAttribute]
public LoginTicket get_Ticket();
    [CompilerGeneratedAttribute]
public string get_RefreshToken();
}
public interface Holzer.Security.Providers.ISecurityProvider {
    public FederationMemberIdentifier FederationMember { get; }
    public string ApplicationName { get; }
    public string ServerName { get; }
    public bool IsEnabled { get; }
    public bool IsAnonymous { get; }
    public Uri PublicOAuthAuthorizationUrl { get; }
    public Uri PublicOAuthTokenUrl { get; }
    public EndpointAddress SecurityTokenServiceEndpointAddress { get; }
    public abstract virtual void ConnectProvider(string providerUrl);
    public abstract virtual string GetInstallRedirectAddress();
    public abstract virtual Byte[] GetActiveCertificateRequest();
    public abstract virtual ISecurityBinding GetSecurityBinding(bool throwIfMissing, bool returnIncompleteSecurityBinding);
    [CompilerGeneratedAttribute]
public abstract virtual void add_SecurityBindingAvailable(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_SecurityBindingAvailable(EventHandler value);
    public abstract virtual FederationMemberIdentifier get_FederationMember();
    public abstract virtual string get_ApplicationName();
    public abstract virtual string get_ServerName();
    public abstract virtual bool get_IsEnabled();
    public abstract virtual bool get_IsAnonymous();
    public abstract virtual Uri get_PublicOAuthAuthorizationUrl();
    public abstract virtual Uri get_PublicOAuthTokenUrl();
    public abstract virtual IEnumerable`1<SecurityKey> ResolveIssuerKey(string issuer, string kid);
    public abstract virtual EndpointAddress get_SecurityTokenServiceEndpointAddress();
    public abstract virtual string StartWebLogin(string returnUrl, string loginParameters, string userFederationMemberGuid, string defaultLoginMethod);
    public abstract virtual string StartRunAsWebLogin(string returnUrl, string defaultUserName, string userFederationMemberGuid);
    public abstract virtual LoginTicket CompleteWebLogin(string ticketTransferId, bool setPrincipal);
    public abstract virtual Task`1<CompleteWebLoginResult> CompleteLoginAsync(string authorizationCode, string authorizationCodeVerifier, bool skipAuthorizationCodeVerification, bool setPrincipal);
    public abstract virtual void CompleteWebLogin(LoginTicket ticket, bool setPrincipal);
    public abstract virtual void ForceWebLogin(string loginParameters, string defaultLoginMethod);
    public abstract virtual EmbeddedLogin StartEmbeddedLogin(string federation, string username, string loginParameters, NetworkLogInfo networkLogInfo);
    public abstract virtual EmbeddedLoginResult CompleteEmbeddedLogin(PasswordChallengeResponse response, bool isPublicComputer, bool setPrincipal, bool saveSingleSignon, NetworkLogInfo networkLogInfo);
    public abstract virtual EmbeddedLoginResult CompleteEmbeddedWebLogin(PasswordChallengeResponse response, bool isPublicComputer, bool setPrincipal, bool saveSingleSignon, NetworkLogInfo networkLogInfo);
    public abstract virtual SecureSession BeginEmbeddedSession(AuthenticationPackage package, string packagePassword, bool setPrincipal, bool cacheSession);
    public abstract virtual CreateRunAsLoginKey CreateRunAsLoginKey(string runAsFederationMemberGuid, string runAsLoginName, string loginParameters, NetworkLogInfo networkLogInfo);
    public abstract virtual bool HasPermissionToCreateRunAsLoginKey(string runAsFederationMemberGuid, string runAsLoginName, string loginParameters, NetworkLogInfo networkLogInfo);
    public abstract virtual bool IndicateDelegationEnabled(IMessage msg);
    public abstract virtual DelegationChallenge CreateDelegationChallenge(IMessage msg);
    public abstract virtual DelegationChallengeResponse StartDelegatedLogin(DelegationChallenge challenge, string loginParameters);
    public abstract virtual LoginTicket CompleteDelegatedLogin(DelegationChallengeResponse response);
    public abstract virtual void SaveWebSingleSignon(LoginTicket ticket);
    public abstract virtual LoginTicket AttemptSingleSignon(string singleSignonKey, LoginContextInfo loginContext, string loginParameters);
    public abstract virtual LoginTicket AttemptSingleSignon(string singleSignonKey, LoginContextInfo loginContext, string loginParameters, string returnUrl);
    public abstract virtual void SaveRemotingTicket(LoginTicket ticket, string secureSessionIdentifier);
    public abstract virtual LoginTicket GetRemotingTicket(string secureSessionIdentifier);
    public abstract virtual LoginTicket FinalizeRemotingTransfer(LoginTicket ticket);
    public abstract virtual LoginTicket BeginServiceIdentityContext(X509Certificate2 customProtectionCertificate);
    public abstract virtual void EndServiceIdentityContext(object correlationState);
    public abstract virtual LoginTicket CreateLoginTicketAsSelf(X509Certificate2 customProtectionCertificate);
    public abstract virtual Task`1<LoginTicket> CreateLoginTicketAsSelfAsync(X509Certificate2 customProtectionCertificate);
    public abstract virtual ApplicationConfiguration GetAppConfig(int millisecondsTimeout);
    public abstract virtual ApplicationConfiguration TryGetAppConfig(int maxWaitMilliseconds);
    public abstract virtual SecurityApplicationConfigStatus GetApplicationConfigStatus();
    public abstract virtual string GetAppConfigInspection(int millisecondsTimeout);
    public abstract virtual void VerifySignature(string signature);
    public abstract virtual PermissionDescription GetPermissionDescription(string permissionName);
    public abstract virtual void TestWebLoginWithRedirect(string returnUrl, bool endResponse);
    public abstract virtual ILogonSessionManager CreateWebSessionManager();
    public abstract virtual ILogonSessionManager CreateRemotingSessionManager();
    public abstract virtual LoginTicket InitializeCurrentWebUser();
    public abstract virtual LoginTicket ProcessAuthorizationHeader(ProcessAuthorizationHeaderArgs args);
    public abstract virtual Task`1<LoginTicket> ProcessAuthorizationHeaderAsync(ProcessAuthorizationHeaderArgs args);
    public abstract virtual Task`1<LoginTicket> BuildLoginTicketFromTokenAsync(string accessToken, ClaimsPrincipal user, string resource);
    public abstract virtual LoginTicket RenewTicket(string ticketTrackingId);
    public abstract virtual LoginTicket RecoverTicket(string federationGuid, string ticketId, string returnUrl);
    public abstract virtual LoginTicket RecoverTicketEmbedded(string federationGuid, string ticketId, string returnUrl, LoginContextInfo loginContext);
    public abstract virtual Task`1<LoginTicket> RecoverTicketEmbeddedAsync(string federationGuid, string ticketId, string returnUrl, LoginContextInfo loginContext);
    public abstract virtual LogOffResult LogOff();
    public abstract virtual LogOffResult LogOff(LoginTicket ticket, string secureSessionIdentifier, string redirectToUrl);
    public abstract virtual LogOffResult LogOffEmbedded(LoginTicket ticket, string redirectToUrl);
    public abstract virtual FederationMemberInfo GetFederation(string federationGuid);
    public abstract virtual AuthorizationToken CreateApplicationAuthorizationToken(AuthorizationTokenOptions options);
    public abstract virtual Task`1<AuthorizationToken> CreateApplicationAuthorizationTokenAsync(AuthorizationTokenOptions options);
    public abstract virtual string GeneratePassword();
    public abstract virtual Role[] GetRoles(string federationGuid, int lcid);
    public abstract virtual LoginInfo GetLogin(string federationGuid, string loginName, bool mustBeValid, bool mustBeActivated);
    public abstract virtual LoginInfo GetLoginByGuid(string federationGuid, string loginGuid, bool mustBeValid, bool mustBeActivated);
    public abstract virtual void AssignAccountToRole(string roleName);
    public abstract virtual void AssignAccountToRole(string federationGuid, string loginGuid, string roleName);
    public abstract virtual void UnassignAccountToRole(string federationGuid, string loginGuid, string roleName);
    public abstract virtual LoginInfo CreateAccount(string federationGuid, string username, string password, string displayName, string accountCategoryName, string notes, string roleName, bool mustChangeUsername, bool mustChangePassword, bool useOwnershipActivation);
    public abstract virtual DateTime DisableAccount(string federationGuid, string loginGuid, DateTime disableAt, string additionalInfo);
    public abstract virtual GroupInfo CreateGroup(string federationGuid, string type, int lcid, string localizedName);
    public abstract virtual GroupInfo GetGroup(string federationGuid, string groupGuid, int lcid);
    public abstract virtual void ChangeGroupDisplayName(string federationGuid, string groupGuid, int lcid, string localizedName);
    public abstract virtual void RemoveGroup(string federationGuid, string groupGuid);
    public abstract virtual void AssignAccountToGroup(string federationGuid, string groupGuid, string loginGuid, DateTime validFrom, DateTime validTo);
    public abstract virtual void UnassignAccountToGroup(string federationGuid, string groupGuid, string loginGuid);
    public abstract virtual void SetAccountName(string federationGuid, string loginGuid, string newName);
    public abstract virtual RightInfo CreateRight(string federationGuid, string federatedApplicationName, string parentRightName, string rightName, int lcid, string localizedName, string description);
    public abstract virtual RightInfo GetRight(string federationGuid, string federatedApplicationName, string rightName, int lcid);
    public abstract virtual void ChangeRightDisplayName(string federationGuid, string federatedApplicationName, string rightName, int lcid, string localizedName);
    public abstract virtual void RemoveRight(string federationGuid, string federatedApplicationName, string rightName);
    public abstract virtual void SetMustChangeName(string federationGuid, string loginGuid, bool mustChangeName);
    public abstract virtual void SetMustChangePassword(string federationGuid, string loginGuid, bool mustChangePassword);
    public abstract virtual void ChangeFormsPassword(LoginTicket ticket, string oldPassword, string newPassword, string additionalLogInfo);
    public abstract virtual void ChangeName(LoginTicket ticket, string newName, string additionalLogInfo);
    public abstract virtual void ChangeDisplayName(LoginTicket ticket, string newDisplayName, string additionalLogInfo);
    public abstract virtual void ChangeNameAndDisplayName(LoginTicket ticket, string newName, string newDisplayName, string additionalLogInfo);
    public abstract virtual void UpdateApplicationDefinition(string definition, string signature, string additionalInfo);
    public abstract virtual void UpdateApplicationDefinition(string definition, string signature, string additionalInfo, bool dryRun, bool appendOnly);
}
public class Holzer.Security.Providers.SecurityApplicationConfigStatus : object {
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <LastUpdated>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <LastSync>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsAvailable>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Error>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Version>k__BackingField;
    public Nullable`1<DateTime> LastUpdated { get; public set; }
    public Nullable`1<DateTime> LastSync { get; public set; }
    public bool IsAvailable { get; public set; }
    public string Error { get; public set; }
    public string Version { get; public set; }
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_LastUpdated();
    [CompilerGeneratedAttribute]
public void set_LastUpdated(Nullable`1<DateTime> value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_LastSync();
    [CompilerGeneratedAttribute]
public void set_LastSync(Nullable`1<DateTime> value);
    [CompilerGeneratedAttribute]
public bool get_IsAvailable();
    [CompilerGeneratedAttribute]
public void set_IsAvailable(bool value);
    [CompilerGeneratedAttribute]
public string get_Error();
    [CompilerGeneratedAttribute]
public void set_Error(string value);
    [CompilerGeneratedAttribute]
public string get_Version();
    [CompilerGeneratedAttribute]
public void set_Version(string value);
}
internal class Holzer.Security.Remoting.ClientAuthenticationSink : object {
    private IClientFormatterSink next;
    public IClientChannelSink NextChannelSink { get; }
    public IMessageSink NextSink { get; }
    public IDictionary Properties { get; }
    internal ClientAuthenticationSink(IClientFormatterSink next);
    public sealed virtual void AsyncProcessRequest(IClientChannelSinkStack sinkStack, IMessage msg, ITransportHeaders headers, Stream stream);
    public sealed virtual void AsyncProcessResponse(IClientResponseChannelSinkStack sinkStack, object state, ITransportHeaders headers, Stream stream);
    public sealed virtual void ProcessMessage(IMessage msg, ITransportHeaders requestHeaders, Stream requestStream, ITransportHeaders& responseHeaders, Stream& responseStream);
    public sealed virtual Stream GetRequestStream(IMessage msg, ITransportHeaders headers);
    public sealed virtual IClientChannelSink get_NextChannelSink();
    [DebuggerStepThroughAttribute]
public sealed virtual IMessage SyncProcessMessage(IMessage m);
    public sealed virtual IMessageSink get_NextSink();
    public sealed virtual IMessageCtrl AsyncProcessMessage(IMessage msg, IMessageSink replySink);
    public sealed virtual IDictionary get_Properties();
}
public class Holzer.Security.Remoting.ClientAuthenticationSinkProvider : object {
    private IClientChannelSinkProvider next;
    public IClientChannelSinkProvider Next { get; public set; }
    public sealed virtual IClientChannelSink CreateSink(IChannelSender channel, string url, object channelData);
    public sealed virtual IClientChannelSinkProvider get_Next();
    public sealed virtual void set_Next(IClientChannelSinkProvider value);
}
internal class Holzer.Security.Remoting.Credentials : object {
    [ThreadStaticAttribute]
private static Hashtable threadStaticIdentifiers;
    internal static string GetSessionIdentifier(string key);
    internal static void SetSessionIdentifier(string key, string id, bool usesPasswordCredentials);
}
internal class Holzer.Security.Remoting.ServerAuthenticationSink : object {
    private IServerChannelSink next;
    private IServerChannelSink System.Runtime.Remoting.Channels.IServerChannelSink.NextChannelSink { get; }
    public IDictionary Properties { get; }
    internal ServerAuthenticationSink(IServerChannelSink next);
    public sealed virtual Stream GetResponseStream(IServerResponseChannelSinkStack sinkStack, object state, IMessage msg, ITransportHeaders headers);
    public sealed virtual ServerProcessing ProcessMessage(IServerChannelSinkStack sinkStack, IMessage requestMsg, ITransportHeaders requestHeaders, Stream requestStream, IMessage& responseMsg, ITransportHeaders& responseHeaders, Stream& responseStream);
    private sealed virtual override void System.Runtime.Remoting.Channels.IServerChannelSink.AsyncProcessResponse(IServerResponseChannelSinkStack sinkStack, object state, IMessage msg, ITransportHeaders headers, Stream stream);
    private sealed virtual override IServerChannelSink System.Runtime.Remoting.Channels.IServerChannelSink.get_NextChannelSink();
    public sealed virtual IDictionary get_Properties();
}
public class Holzer.Security.Remoting.ServerAuthenticationSinkProvider : object {
    private IServerChannelSinkProvider next;
    public IServerChannelSinkProvider Next { get; public set; }
    private sealed virtual override IServerChannelSink System.Runtime.Remoting.Channels.IServerChannelSinkProvider.CreateSink(IChannelReceiver channel);
    public sealed virtual IServerChannelSinkProvider get_Next();
    public sealed virtual void set_Next(IServerChannelSinkProvider value);
    public sealed virtual void GetChannelData(IChannelDataStore channelData);
}
public class Holzer.Security.ReturnUrlArgs : object {
    private string returnUrl;
    private bool isNewAccount;
    public string ReturnUrl { get; }
    public bool IsNewAccount { get; }
    public ReturnUrlArgs(string returnUrl, bool isNewAccount);
    public string get_ReturnUrl();
    public bool get_IsNewAccount();
}
public class Holzer.Security.RightInfo : object {
    private string federation;
    private string parentRightName;
    private string name;
    private string displayName;
    private string description;
    private bool isDynamic;
    private string permissionName;
    private StringInfo[] localizedName;
    public string Federation { get; }
    public string ParentRightName { get; }
    public string Name { get; }
    public string DisplayName { get; }
    public string Description { get; }
    public bool IsDynamic { get; }
    public string PermissionName { get; }
    public StringInfo[] LocalizedName { get; }
    public RightInfo(string federation, string parentRightName, string name, string displayName, string description, bool isDynamic, string permissionName, StringInfo[] localizedName);
    public string get_Federation();
    public string get_ParentRightName();
    public string get_Name();
    public string get_DisplayName();
    public string get_Description();
    public bool get_IsDynamic();
    public string get_PermissionName();
    public StringInfo[] get_LocalizedName();
}
[DataContractAttribute]
public class Holzer.Security.Role : object {
    private Guid guid;
    private string name;
    private string displayName;
    [DataMemberAttribute]
public Guid Guid { get; public set; }
    [DataMemberAttribute]
public string Name { get; public set; }
    [DataMemberAttribute]
public string DisplayName { get; public set; }
    public Role(Guid guid, string name, string displayName);
    public Guid get_Guid();
    public void set_Guid(Guid value);
    public string get_Name();
    public void set_Name(string value);
    public string get_DisplayName();
    public void set_DisplayName(string value);
    public virtual string ToString();
}
public abstract class Holzer.Security.SecureSession : object {
    private LoginTicket ticket;
    private LoginTicket restoreToTicketOnDispose;
    public LoginTicket Ticket { get; }
    protected SecureSession(LoginTicket ticket);
    protected SecureSession(LoginTicket ticket, LoginTicket restoreToTicketOnDispose);
    public static SecureSession Begin(AuthenticationPackage package);
    private static SecureSession Begin(AuthenticationPackage package, bool setPrincipal, bool cacheSession);
    public LoginTicket get_Ticket();
    public virtual void Dispose();
}
public class Holzer.Security.SecureState : object {
    private static CacheStore encryptionCache;
    private static CacheStore decryptionCache;
    private static SecureState();
    public static void Test();
    public static string Encrypt(string state);
    public static string Decrypt(string encryptedState);
    public static string EncryptWeb(string state);
    public static string DecryptWeb(string encryptedState);
}
public class Holzer.Security.SecurityBindingStandalone : object {
    [CompilerGeneratedAttribute]
private bool <IsAvailable>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FederationGuid>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FederationName>k__BackingField;
    [CompilerGeneratedAttribute]
private ServiceAddressInfo <DirectoryServiceAddress>k__BackingField;
    [CompilerGeneratedAttribute]
private ServiceAddressInfo <SecurityTokenServiceAddress>k__BackingField;
    [CompilerGeneratedAttribute]
private EndpointAddress <SecurityTokenServiceEndpointAddress>k__BackingField;
    [CompilerGeneratedAttribute]
private WSHttpBinding <IssuerBinding>k__BackingField;
    public bool IsAvailable { get; protected set; }
    public string FederationGuid { get; protected set; }
    public string FederationName { get; protected set; }
    public ServiceAddressInfo DirectoryServiceAddress { get; protected set; }
    public ServiceAddressInfo SecurityTokenServiceAddress { get; protected set; }
    public EndpointAddress SecurityTokenServiceEndpointAddress { get; protected set; }
    public WSHttpBinding IssuerBinding { get; protected set; }
    public SecurityBindingStandalone(bool isAvailable, string federationGuid, string federationName, ServiceAddressInfo directoryServiceAddress, ServiceAddressInfo securityTokenServiceAddress, WSHttpBinding issuerBinding);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsAvailable();
    [CompilerGeneratedAttribute]
protected void set_IsAvailable(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_FederationGuid();
    [CompilerGeneratedAttribute]
protected void set_FederationGuid(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_FederationName();
    [CompilerGeneratedAttribute]
protected void set_FederationName(string value);
    [CompilerGeneratedAttribute]
public sealed virtual ServiceAddressInfo get_DirectoryServiceAddress();
    [CompilerGeneratedAttribute]
protected void set_DirectoryServiceAddress(ServiceAddressInfo value);
    [CompilerGeneratedAttribute]
public sealed virtual ServiceAddressInfo get_SecurityTokenServiceAddress();
    [CompilerGeneratedAttribute]
protected void set_SecurityTokenServiceAddress(ServiceAddressInfo value);
    [CompilerGeneratedAttribute]
public sealed virtual EndpointAddress get_SecurityTokenServiceEndpointAddress();
    [CompilerGeneratedAttribute]
protected void set_SecurityTokenServiceEndpointAddress(EndpointAddress value);
    [CompilerGeneratedAttribute]
public sealed virtual WSHttpBinding get_IssuerBinding();
    [CompilerGeneratedAttribute]
protected void set_IssuerBinding(WSHttpBinding value);
    public virtual string ToString();
}
public class Holzer.Security.SecurityDisabledScope : object {
    private static AsyncLocal`1<bool> securityDisabledScopeMarker;
    private static bool disableSecurityChecksAllThreads;
    private bool isDisabled;
    public static bool ChecksIsDisabled { get; }
    public SecurityDisabledScope(bool disableSecurityChecks);
    private static SecurityDisabledScope();
    public static bool get_ChecksIsDisabled();
    public sealed virtual void Dispose();
    public static void DisableSecurityChecksAllThreads();
    internal static void BeginDisableSecurityInt();
    internal static void EndDisableSecurityInt();
    private static bool GetSecurityChecksIsDisabled();
    private static void SetSecurityChecksIsDisabledMarker(bool value);
    public static IDisposable SuppressFlow();
}
[DataContractAttribute]
public class Holzer.Security.SecurityDiscoveryBinding : object {
    [CompilerGeneratedAttribute]
private ServiceAddressInfo <SecurityTokenServiceAddress>k__BackingField;
    [CompilerGeneratedAttribute]
private ServiceAddressInfo <DirectoryServiceAddress>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FederationMemberGuid>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FederationMemberName>k__BackingField;
    [DataMemberAttribute]
public ServiceAddressInfo SecurityTokenServiceAddress { get; public set; }
    [DataMemberAttribute]
public ServiceAddressInfo DirectoryServiceAddress { get; public set; }
    [DataMemberAttribute]
public string FederationMemberGuid { get; public set; }
    [DataMemberAttribute]
public string FederationMemberName { get; public set; }
    [CompilerGeneratedAttribute]
public ServiceAddressInfo get_SecurityTokenServiceAddress();
    [CompilerGeneratedAttribute]
public void set_SecurityTokenServiceAddress(ServiceAddressInfo value);
    [CompilerGeneratedAttribute]
public ServiceAddressInfo get_DirectoryServiceAddress();
    [CompilerGeneratedAttribute]
public void set_DirectoryServiceAddress(ServiceAddressInfo value);
    [CompilerGeneratedAttribute]
public string get_FederationMemberGuid();
    [CompilerGeneratedAttribute]
public void set_FederationMemberGuid(string value);
    [CompilerGeneratedAttribute]
public string get_FederationMemberName();
    [CompilerGeneratedAttribute]
public void set_FederationMemberName(string value);
}
[DataContractAttribute]
public class Holzer.Security.SecurityDiscoveryResponse : object {
    [CompilerGeneratedAttribute]
private SecurityDiscoveryBinding <WindowsIntegrated>k__BackingField;
    [DataMemberAttribute]
public SecurityDiscoveryBinding WindowsIntegrated { get; public set; }
    [CompilerGeneratedAttribute]
public SecurityDiscoveryBinding get_WindowsIntegrated();
    [CompilerGeneratedAttribute]
public void set_WindowsIntegrated(SecurityDiscoveryBinding value);
}
public class Holzer.Security.SecurityDomainConfiguration : object {
    [CompilerGeneratedAttribute]
private string <FederationGuid>k__BackingField;
    public string FederationGuid { get; public set; }
    [CompilerGeneratedAttribute]
public string get_FederationGuid();
    [CompilerGeneratedAttribute]
public void set_FederationGuid(string value);
}
public class Holzer.Security.SecurityDomainConfigurationHandler : MulticastDelegate {
    public SecurityDomainConfigurationHandler(object object, IntPtr method);
    public virtual SecurityDomainConfiguration Invoke(string hostName);
    public virtual IAsyncResult BeginInvoke(string hostName, AsyncCallback callback, object object);
    public virtual SecurityDomainConfiguration EndInvoke(IAsyncResult result);
}
public static class Holzer.Security.SecurityDomainConfigurationManager : object {
    private static CacheDictionary`2<string, SecurityDomainConfiguration> domainConfigurationCache;
    [CompilerGeneratedAttribute]
private static SecurityDomainConfigurationHandler ResolveDomainConfigurationHandler;
    private static SecurityDomainConfigurationManager();
    public static SecurityDomainConfiguration GetConfiguration(string hostName);
    [CompilerGeneratedAttribute]
public static void add_ResolveDomainConfigurationHandler(SecurityDomainConfigurationHandler value);
    [CompilerGeneratedAttribute]
public static void remove_ResolveDomainConfigurationHandler(SecurityDomainConfigurationHandler value);
}
public class Holzer.Security.SecurityHelper : object {
    public static PasswordChallengeResponse CreateEmbeddedLoginResponse(PasswordChallenge challenge, string plainTextPassword);
    private static PasswordChallengeResponse CreateEmbeddedLoginResponse_PasswordChallengeResponse(PasswordChallenge challenge, PasswordChallengeMethod method, string plainTextPassword, int saltLength);
    private static PasswordChallengeResponse CreateEmbeddedLoginResponse_ExternalAuthenticationHash(PasswordChallenge challenge, PasswordChallengeMethod method, string plainTextPassword);
    private static PasswordChallengeResponse CreateEmbeddedLoginResponse_RunAsOneTimePassword(PasswordChallenge challenge, PasswordChallengeMethod method, string plainTextPassword);
    private static PasswordChallengeResponse CreateEmbeddedLoginResponse_PasswordPassThrough(PasswordChallenge challenge, PasswordChallengeMethod method, string plainTextPassword);
}
[XmlTypeAttribute]
[XmlRootAttribute]
[DataContractAttribute]
public class Holzer.Security.SecurityKeyInfo : object {
    [CompilerGeneratedAttribute]
private SecurityKeyValue <KeyValue>k__BackingField;
    [DataMemberAttribute]
public SecurityKeyValue KeyValue { get; public set; }
    [CompilerGeneratedAttribute]
public SecurityKeyValue get_KeyValue();
    [CompilerGeneratedAttribute]
public void set_KeyValue(SecurityKeyValue value);
}
[XmlTypeAttribute]
[XmlRootAttribute]
[DataContractAttribute]
public class Holzer.Security.SecurityKeyValue : object {
    private static XmlSerializer serializer;
    [CompilerGeneratedAttribute]
private SecurityKeyValueRSA <RSAKeyValue>k__BackingField;
    [DataMemberAttribute]
public SecurityKeyValueRSA RSAKeyValue { get; public set; }
    [CompilerGeneratedAttribute]
public SecurityKeyValueRSA get_RSAKeyValue();
    [CompilerGeneratedAttribute]
public void set_RSAKeyValue(SecurityKeyValueRSA value);
    public static SecurityKeyValue GetPublicKey(RSA rsaKeyValue);
    public static SecurityKeyValue GetPrivateKey(RSA rsaKeyValue);
    public AsymmetricAlgorithm ToAsymmetricKey();
    public static SecurityKeyValue FromXmlString(string s);
    public string ToXmlString();
    public bool IsSameKey(SecurityKeyValue publicKey);
}
[XmlTypeAttribute]
[XmlRootAttribute]
[DataContractAttribute]
public class Holzer.Security.SecurityKeyValueRSA : object {
    [CompilerGeneratedAttribute]
private Byte[] <Modulus>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <Exponent>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <D>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <P>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <Q>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <Dp>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <Dq>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <Inq>k__BackingField;
    [DataMemberAttribute]
public Byte[] Modulus { get; public set; }
    [DataMemberAttribute]
public Byte[] Exponent { get; public set; }
    [DataMemberAttribute]
public Byte[] D { get; public set; }
    [DataMemberAttribute]
public Byte[] P { get; public set; }
    [DataMemberAttribute]
public Byte[] Q { get; public set; }
    [DataMemberAttribute]
public Byte[] Dp { get; public set; }
    [DataMemberAttribute]
public Byte[] Dq { get; public set; }
    [DataMemberAttribute]
public Byte[] Inq { get; public set; }
    [CompilerGeneratedAttribute]
public Byte[] get_Modulus();
    [CompilerGeneratedAttribute]
public void set_Modulus(Byte[] value);
    [CompilerGeneratedAttribute]
public Byte[] get_Exponent();
    [CompilerGeneratedAttribute]
public void set_Exponent(Byte[] value);
    [CompilerGeneratedAttribute]
public Byte[] get_D();
    [CompilerGeneratedAttribute]
public void set_D(Byte[] value);
    [CompilerGeneratedAttribute]
public Byte[] get_P();
    [CompilerGeneratedAttribute]
public void set_P(Byte[] value);
    [CompilerGeneratedAttribute]
public Byte[] get_Q();
    [CompilerGeneratedAttribute]
public void set_Q(Byte[] value);
    [CompilerGeneratedAttribute]
public Byte[] get_Dp();
    [CompilerGeneratedAttribute]
public void set_Dp(Byte[] value);
    [CompilerGeneratedAttribute]
public Byte[] get_Dq();
    [CompilerGeneratedAttribute]
public void set_Dq(Byte[] value);
    [CompilerGeneratedAttribute]
public Byte[] get_Inq();
    [CompilerGeneratedAttribute]
public void set_Inq(Byte[] value);
    public bool SameKey(SecurityKeyValueRSA other);
}
public class Holzer.Security.SecurityServices : object {
    private static string DefaultSecurityProvider;
    private static string HostKeyFile;
    private static string HostKeyFileLegacy;
    private static AsyncLocal`1<LoginTicket> currentUserAsyncLocal;
    private static ApplicationIdentityContext applicationIdentityContext;
    private static string hostKey;
    private static ISecurityProvider securityProvider;
    private static PermissionDescriptionCache permissionCache;
    private static bool isEnabled;
    private static Type providerType;
    private static Dictionary`2<string, Dictionary`2<string, Role>> roleCache;
    private static bool trustRemotedTickets;
    [CompilerGeneratedAttribute]
private static EventHandler SecurityBindingIsAvailableChanged;
    private static Func`2<ProcessAuthorizationHeaderArgs, LoginTicket> authorizationHeaderProcessor;
    private static Func`2<ProcessAuthorizationHeaderArgs, Task`1<LoginTicket>> authorizationHeaderProcessorAsync;
    [CompilerGeneratedAttribute]
private static AuthenticatedEventHandler Authenticated;
    [CompilerGeneratedAttribute]
private static AuthenticatedEventHandler RequestAuthenticated;
    [CompilerGeneratedAttribute]
private static TranslateReturnUrlHandler TranslateReturnUrl;
    public static bool IsEnabled { get; }
    public static string ApplicationName { get; }
    public static bool SecurityBindingIsAvailable { get; }
    public static string ServerName { get; }
    public static bool TrustRemotedTickets { get; public set; }
    public static FederationMemberIdentifier Federation { get; }
    public static string UserCacheKeyNullable { get; }
    public static bool HasCurrentUser { get; }
    public static LoginTicket CurrentUser { get; }
    public static LoginTicket CurrentUserUnsafe { get; }
    public static LoginTicket CurrentUserRequired { get; }
    public static bool ChecksIsDisabled { get; }
    public static bool ChecksIsDisabledMarker { get; }
    public static ApplicationIdentityContext ApplicationIdentityContext { get; }
    private static SecurityServices();
    public static ISecurityProvider Connect(string providerAddress);
    public static string GetHostEncryptionKey();
    public static void Activate();
    public static bool get_IsEnabled();
    public static string get_ApplicationName();
    public static bool get_SecurityBindingIsAvailable();
    public static void SecurityBindingWhenAvailable(Action a);
    public static ISecurityBinding GetSecurityBinding(bool throwIfMissing, bool returnIncompleteSecurityBinding);
    private static void SecurityProvider_SecurityBindingAvailable(object sender, EventArgs e);
    private static void OnSecurityBindingIsAvailableChanged();
    [CompilerGeneratedAttribute]
public static void add_SecurityBindingIsAvailableChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public static void remove_SecurityBindingIsAvailableChanged(EventHandler value);
    public static string get_ServerName();
    public static ISecurityProvider GetProvider(bool throwIfNotEnabled);
    public static ISecurityProvider GetProviderWithoutCurrentUser(bool throwIfNotEnabled);
    public static EmbeddedLoginResult LogOnEmbedded(string federation, string username, string password, bool isPublicComputer, bool singleSignOn, bool setPrincipal, NetworkLogInfo networkLogInfo);
    public static LoginTicket LogOn(string federation, string username, string password, bool isPublicComputer, bool singleSignOn, string returnUrl, bool endResponse, NetworkLogInfo networkLogInfo);
    private static PasswordChallenge TranslateToChallenge(EmbeddedLogin loginRequest);
    public static LoginTicket LogOn(string username, string password, bool isPublicComputer, bool singleSignOn, string returnUrl, bool endResponse, NetworkLogInfo networkLogInfo);
    public static LoginTicket LogOn(string username, string password, bool isPublicComputer, bool singleSignOn, string returnUrl, bool endResponse);
    public static void LogOn(string loginParameters, string defaultLoginMethod);
    public static CreateRunAsLoginKey CreateRunAsLoginKey(string runAsLoginName, string runAsFederationMemberGuid);
    public static bool HasPermissionToCreateRunAsLoginKey(string runAsLoginName, string runAsFederationMemberGuid);
    public static LoginTicket ProcessAuthorizationHeader(ProcessAuthorizationHeaderArgs args);
    public static Task`1<LoginTicket> ProcessAuthorizationHeaderAsync(ProcessAuthorizationHeaderArgs args);
    public static void SetAuthorizationHeaderProcessor(Func`2<ProcessAuthorizationHeaderArgs, LoginTicket> processor, Func`2<ProcessAuthorizationHeaderArgs, Task`1<LoginTicket>> processorAsync);
    public static bool get_TrustRemotedTickets();
    public static void set_TrustRemotedTickets(bool value);
    public static void SetPrincipal(LoginTicket ticket, bool setPrincipal, bool raiseAuthenticated);
    private static void SetPrincipalInt(LoginTicket ticket);
    public static void VerifySignature(string signature);
    private static void OnAuthenticated(LoginTicket ticket);
    [CompilerGeneratedAttribute]
public static void add_Authenticated(AuthenticatedEventHandler value);
    [CompilerGeneratedAttribute]
public static void remove_Authenticated(AuthenticatedEventHandler value);
    [CompilerGeneratedAttribute]
public static void add_RequestAuthenticated(AuthenticatedEventHandler value);
    [CompilerGeneratedAttribute]
public static void remove_RequestAuthenticated(AuthenticatedEventHandler value);
    private static void OnPricipalSet(LoginTicket ticket);
    [CompilerGeneratedAttribute]
public static void add_TranslateReturnUrl(TranslateReturnUrlHandler value);
    [CompilerGeneratedAttribute]
public static void remove_TranslateReturnUrl(TranslateReturnUrlHandler value);
    public static string OnTranslateReturnUrl(object sender, ReturnUrlArgs e);
    public static LogOffResult LogOff();
    public static LogOffResult LogOff(string redirectToUrl);
    public static bool HasPermission(string permissionName);
    private static bool HasPermission(string permissionName, bool activeCheck);
    public static void CheckPermission(string permissionName);
    public static void CheckPermissionAll(IEnumerable`1<string> permissionNameList);
    public static void CheckPermissionAny(String[] permissionNameList);
    public static PermissionDescription GetDeniedPermission(string permissionName);
    public static PermissionDescription GetPermissionDescription(string permissionName);
    public static FederationMemberIdentifier get_Federation();
    public static FederationMemberInfo GetFederationInfo(string federationGuid);
    public static string get_UserCacheKeyNullable();
    public static bool get_HasCurrentUser();
    [DebuggerStepThroughAttribute]
public static LoginTicket get_CurrentUser();
    [DebuggerStepThroughAttribute]
public static LoginTicket get_CurrentUserUnsafe();
    public static LoginTicket get_CurrentUserRequired();
    public static void SetMustChangeName(string federationGuid, string loginGuid, bool mustChangeName);
    public static void SetMustChangePassword(string federationGuid, string loginGuid, bool mustChangePassword);
    public static GroupInfo CreateGroup(string federationGuid, string type, int lcid, string displayName);
    public static GroupInfo GetGroup(string federationGuid, string groupGuid);
    public static void ChangeGroupDisplayName(string federationGuid, string groupGuid, int lcid, string displayName);
    public static void RemoveGroup(string federationGuid, string groupGuid);
    public static void AssignAccountToGroup(string federationGuid, string groupGuid, string loginGuid, DateTime validFrom, DateTime validTo);
    public static void UnassignAccountFromGroup(string federationGuid, string groupGuid, string loginGuid);
    public static Role[] GetRoles();
    public static Role[] GetRoles(string federationGuid);
    public static Role[] GetRoles(string federationGuid, int lcid);
    public static void AssignAccountToRole(string federationGuid, string loginGuid, string roleName);
    public static void AssignAccountToRole(string roleName);
    public static void UnassignAccountFromRole(string federationGuid, string loginGuid, string roleName);
    [ObsoleteAttribute("Replaced by GetAccountByName().")]
public static LoginInfo GetLogin(string loginName, bool mustBeValid, bool mustBeActivated);
    [ObsoleteAttribute("Replaced by GetAccount().")]
public static LoginInfo GetLogin(Guid loginGuid, bool mustBeValid, bool mustBeActivated);
    public static LoginInfo GetAccountByName(string federationGuid, string loginName, bool mustBeValid, bool mustBeActivated);
    public static LoginInfo GetAccount(string federationGuid, string loginGuid, bool mustBeValid, bool mustBeActivated);
    public static void UpdateApplicationDefinition(string definition, string signature, string additionalInfo, bool dryRun, bool appendOnly);
    public static void UpdateApplicationDefinition(string definition, string signature, string additionalInfo);
    public static RightInfo CreateRight(string rightName, int lcid, string displayName, string description, string parentRightName);
    public static RightInfo GetRight(string rightName, int lcid);
    public static void ChangeRightDisplayName(string rightName, int lcid, string localizedName);
    public static void RemoveRight(string rightName);
    public static LoginInfo CreateAccount(string username, string password, string displayName, string accountCategoryName, string notes);
    public static LoginInfo CreateAccount(string username, string password, string displayName, string accountCategoryName, string notes, string roleName);
    public static LoginInfo CreateAccount(string username, string password, string displayName, string accountCategoryName, string notes, string roleName, bool mustChangeUsername, bool mustChangePassword, bool useOwnershipActivation);
    public static LoginInfo CreateAccount(string federationGuid, string username, string password, string displayName, string accountCategoryName, string notes, string roleName);
    public static LoginInfo CreateAccount(string federationGuid, string username, string password, string displayName, string accountCategoryName, string notes, string roleName, bool mustChangeUsername, bool mustChangePassword, bool useOwnershipActivation);
    [ObsoleteAttribute("Replaced by DisableAccount(federationGuid, ...).")]
public static DateTime DisableAccount(string loginGuid, DateTime disableAt, string additionalInfo);
    public static DateTime DisableAccount(string federationGuid, string loginGuid, DateTime disableAt, string additionalInfo);
    public static string GeneratePassword();
    public static void DisableSecurityChecksAllThreads();
    [ObsoleteAttribute("Replaced by SecurityDisabledContext.")]
public static void BeginDisableSecurity();
    public static void EndDisableSecurity();
    public static bool get_ChecksIsDisabled();
    public static bool get_ChecksIsDisabledMarker();
    public static ApplicationIdentityContext get_ApplicationIdentityContext();
    public static Role GetRole(string federationGuid, int lcid, string guid);
    private static Dictionary`2<string, Role> GetRolesCacheByFederation(string federationGuid, int lcid);
    private static Dictionary`2<string, Role> RefreshRolesCacheByFederation(string federationGuid, int lcid);
    public static void SetAccountName(string federationGuid, string loginGuid, string newName);
    internal static LoginTicket CreateLoginTicketAsSelf();
    internal static Task`1<LoginTicket> CreateLoginTicketAsSelfAsync();
}
public class Holzer.Security.SecurityTokenCache : object {
    private static int MaxExpirationSeconds;
    private CacheDictionary`2<Uri, SecurityToken> tokenCache;
    internal SecurityToken GetToken(Uri cacheKey);
    internal void SetToken(Uri cacheKey, SecurityToken securityToken);
}
public class Holzer.Security.ServiceAddress : object {
    private string policy;
    private LoginIdentifier applicationIdentity;
    private string destination;
    public string Policy { get; }
    public string Destination { get; }
    public LoginIdentifier ApplicationIdentity { get; }
    public ServiceAddress(string policy, LoginIdentifier applicationIdentity, string destination);
    public ServiceAddress(string serviceAddress);
    public virtual string ToString();
    public string get_Policy();
    public string get_Destination();
    public LoginIdentifier get_ApplicationIdentity();
}
[DefaultMemberAttribute("Item")]
public class Holzer.Security.SimpleStateBag : object {
    private HybridDictionary inner;
    public object Item { get; public set; }
    public int Count { get; }
    public object get_Item(string key);
    public void set_Item(string key, object value);
    public int get_Count();
    public sealed virtual IEnumerator GetEnumerator();
}
public class Holzer.Security.StandaloneUserIdentityContext : IdentityContext {
    private SecurityTokenCache securityTokenCache;
    private CacheDictionary`2<string, ChannelFactory> channelFactoryCache;
    private ISecurityBindingStandalone securityBinding;
    public ISecurityBindingStandalone StandaloneSecurityBinding { get; }
    public StandaloneUserIdentityContext(ISecurityBindingStandalone standaloneSecurityBinding);
    protected internal virtual ChannelFactory`1<TContract> CreateChannelFactoryWsFederationHttp(ServiceAddressInfo targetAddress, StandardServiceBindingOptions options);
    public ServiceClient`1<ISecurityTokenService> ConnectSecurityTokenService();
    protected internal virtual ServiceClient`1<IDirectoryService> ConnectDirectoryService();
    public virtual LoginTicket GetLoginTicket();
    public ISecurityBindingStandalone get_StandaloneSecurityBinding();
    public virtual string ToString();
    protected internal virtual void ConfigureWebApiClient(ServiceClient`1<TContract> client, ServiceAddressInfo address, StandardServiceBindingOptions options, ServicePortInfo port);
    public virtual AuthorizationToken GetAuthorizationToken(AuthorizationTokenOptions options, AuthorizationException authorizationException);
    public virtual Task`1<AuthorizationToken> GetAuthorizationTokenAsync(AuthorizationTokenOptions options, AuthorizationException authorizationException);
}
internal class Holzer.Security.SuspendedSecurityDisabledScope : object {
    private bool wasDisabled;
    public SuspendedSecurityDisabledScope(bool wasDisabled);
    public sealed virtual void Dispose();
}
public class Holzer.Security.TicketRenewResult : object {
    private LoginTicket ticket;
    public LoginTicket Ticket { get; }
    public TicketRenewResult(LoginTicket ticket);
    public LoginTicket get_Ticket();
}
public class Holzer.Security.TranslateReturnUrlHandler : MulticastDelegate {
    public TranslateReturnUrlHandler(object object, IntPtr method);
    public virtual string Invoke(object sender, ReturnUrlArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, ReturnUrlArgs e, AsyncCallback callback, object object);
    public virtual string EndInvoke(IAsyncResult result);
}
[DataContractAttribute]
public class Holzer.Services.AccessDeniedFault : object {
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ErrorReportNumber>k__BackingField;
    [DataMemberAttribute]
public string Message { get; public set; }
    [DataMemberAttribute]
public string ErrorReportNumber { get; public set; }
    public AccessDeniedFault(string message, string errorReportNumber);
    [CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
public void set_Message(string value);
    [CompilerGeneratedAttribute]
public string get_ErrorReportNumber();
    [CompilerGeneratedAttribute]
public void set_ErrorReportNumber(string value);
}
internal class Holzer.Services.Actions.CircuitBreakerActions : object {
    [ConsoleActionAttribute("List circuit breaker status.")]
internal static void Get_Breakers(ConsoleResult result, string cmd, Object[] args);
}
internal class Holzer.Services.Actions.CoreActions : object {
    [ConsoleActionAttribute("Displays the server greeting.")]
public static void Greeting(ConsoleResult result, string cmd, Object[] args);
    [ConsoleActionAttribute("Log off and close the console.")]
internal static void Exit(ConsoleResult result, string cmd, Object[] args);
    [ConsoleActionAttribute("Publish application to directory service.")]
internal static void Publish_App(ConsoleResult result, string cmd, Object[] args);
    [ConsoleActionAttribute("List service ports.")]
internal static void Get_Port(ConsoleResult result, string cmd, Object[] args);
    [ConsoleActionAttribute("List task status.")]
internal static void Get_Task(ConsoleResult result, string cmd, Object[] args);
    [ConsoleActionAttribute("Displays this help message.")]
private static void Get_Help(ConsoleResult result, string cmd, Object[] args);
    [ConsoleActionAttribute("Enables verbose debug logging.")]
internal static void Verbose(ConsoleResult result, string cmd, Object[] args);
    [ConsoleActionAttribute("Enable brief debug logging.")]
internal static void Brief(ConsoleResult result, string cmd, Object[] args);
    [ConsoleActionAttribute("Test to send a test error report. [number of errors] [delay in milli seconds]")]
internal static void Test_ErrorReporting(ConsoleResult result, string cmd, Object[] args);
    [ConsoleActionAttribute("Displays information about the host.")]
private static void Get_Environment(ConsoleResult result, string cmd, Object[] args);
    [ConsoleActionAttribute("Displays information about outbound dependencies from this instance.")]
private static void Get_Dependencies(ConsoleResult result, string cmd, Object[] args);
    [ConsoleActionAttribute("Displays the current security app config synced from the Login service.")]
private static void Get_SecurityAppConfig(ConsoleResult result, string cmd, Object[] args);
    [ConsoleActionAttribute("Test security binding, e g the connection to Login")]
private static void Test_SecurityBinding(ConsoleResult result, string cmd, Object[] args);
    [ConsoleActionAttribute("List service point table, use arg all to show details.")]
private static void Get_ServicePointTable(ConsoleResult result, string cmd, Object[] args);
}
internal class Holzer.Services.Actionss.KeyActions : object {
    [ConsoleActionAttribute("List keys.")]
internal static void Get_Key(ConsoleResult result, string cmd, Object[] args);
    [ConsoleActionAttribute("Create a new data protection key, with not_before set to the specified number of minutes in the future to allow time for replication and manual reconfiguration when necessary.")]
internal static void New_DataProtectionKey(ConsoleResult result, string cmd, Object[] args);
    [ConsoleActionAttribute("Create a new transport key, with not_before set to the specified number of minutes in the future to allow time for replication and manual reconfiguration when necessary.")]
internal static void New_TransportKey(ConsoleResult result, string cmd, Object[] args);
    [ConsoleActionAttribute("Expire a protection key to a specified date and time")]
internal static void Set_KeyExpires(ConsoleResult result, string cmd, Object[] args);
}
[DataContractAttribute]
public class Holzer.Services.ApplicationInfo : object {
    [CompilerGeneratedAttribute]
private Nullable`1<int> <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SystemName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DisplayName>k__BackingField;
    [DataMemberAttribute]
public Nullable`1<int> Id { get; public set; }
    [DataMemberAttribute]
public string SystemName { get; public set; }
    [DataMemberAttribute]
public string DisplayName { get; public set; }
    public ApplicationInfo(Nullable`1<int> id, string systemName, string displayName);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public string get_SystemName();
    [CompilerGeneratedAttribute]
public void set_SystemName(string value);
    [CompilerGeneratedAttribute]
public string get_DisplayName();
    [CompilerGeneratedAttribute]
public void set_DisplayName(string value);
}
[DataContractAttribute]
public class Holzer.Services.ApplicationInstanceMetaInfo : object {
    [CompilerGeneratedAttribute]
private ServicePortInfo[] <ServicePorts>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ServicePortsAllKnown>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FederationGuid>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Guid>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LoginGuid>k__BackingField;
    [CompilerGeneratedAttribute]
private MachineInfo <Machine>k__BackingField;
    [CompilerGeneratedAttribute]
private ApplicationInfo <Application>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsInMaintainanceMode>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsAvailable>k__BackingField;
    [DataMemberAttribute]
public ServicePortInfo[] ServicePorts { get; public set; }
    [DataMemberAttribute]
public bool ServicePortsAllKnown { get; public set; }
    [DataMemberAttribute]
public string FederationGuid { get; public set; }
    [DataMemberAttribute]
public string Guid { get; public set; }
    [DataMemberAttribute]
public string LoginGuid { get; public set; }
    [DataMemberAttribute]
public MachineInfo Machine { get; public set; }
    [DataMemberAttribute]
public ApplicationInfo Application { get; public set; }
    [DataMemberAttribute]
public bool IsInMaintainanceMode { get; public set; }
    [DataMemberAttribute]
public bool IsAvailable { get; public set; }
    public ApplicationInstanceMetaInfo(string federationGuid, string guid, string loginGuid, MachineInfo machine, ApplicationInfo application, bool isInMaintainanceMode, bool isAvailable, ServicePortInfo[] servicePorts, bool servicePortsAllKnown);
    [CompilerGeneratedAttribute]
public ServicePortInfo[] get_ServicePorts();
    [CompilerGeneratedAttribute]
public void set_ServicePorts(ServicePortInfo[] value);
    [CompilerGeneratedAttribute]
public bool get_ServicePortsAllKnown();
    [CompilerGeneratedAttribute]
public void set_ServicePortsAllKnown(bool value);
    [CompilerGeneratedAttribute]
public string get_FederationGuid();
    [CompilerGeneratedAttribute]
public void set_FederationGuid(string value);
    [CompilerGeneratedAttribute]
public string get_Guid();
    [CompilerGeneratedAttribute]
public void set_Guid(string value);
    [CompilerGeneratedAttribute]
public string get_LoginGuid();
    [CompilerGeneratedAttribute]
public void set_LoginGuid(string value);
    [CompilerGeneratedAttribute]
public MachineInfo get_Machine();
    [CompilerGeneratedAttribute]
public void set_Machine(MachineInfo value);
    [CompilerGeneratedAttribute]
public ApplicationInfo get_Application();
    [CompilerGeneratedAttribute]
public void set_Application(ApplicationInfo value);
    [CompilerGeneratedAttribute]
public bool get_IsInMaintainanceMode();
    [CompilerGeneratedAttribute]
public void set_IsInMaintainanceMode(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsAvailable();
    [CompilerGeneratedAttribute]
public void set_IsAvailable(bool value);
    public virtual string ToString();
}
public class Holzer.Services.Bindings.StandardBindings : object {
    private static string BindingNamespace;
    public static string DefaultHttpSoap11BindingWithoutProtectionName;
    public static string DefaultHttpSoap11BindingWithStreamingWithoutProtection;
    public static string DefaultHttpSoap11BindingWithAsymmetricSecurityName;
    public static string DefaultHttpsSoap11BindingWithStreamingWithoutProtection;
    public static string DefaultWSFederationHttpBindingName;
    public static string DefaultWSHttpCertificateBindingName;
    public static string DefaultWSHttpWindowsIntegratedBindingName;
    public static string DefaultHttpApiJsonBindingName;
    private static Binding defaultHttpSoap11BindingWithoutProtection;
    private static Binding defaultHttpSoap11BindingWithAsymmetricSecurity;
    public static Binding DefaultHttpSoap11BindingWithoutProtection { get; }
    public static Binding DefaultHttpSoap11BindingWithAsymmetricSecurity { get; }
    public static Binding CreateDefaultHttpSoap11BindingWithoutProtection(StandardServiceBindingOptions options);
    public static Binding CreateDefaultHttpsSoap11BindingWithoutProtection(StandardServiceBindingOptions options);
    public static Binding CreateDefaultHttpSoap11BindingWithStreamingWithoutProtection();
    public static Binding CreateDefaultHttpsSoap11BindingWithStreamingWithoutProtection();
    public static Binding CreateDefaultHttpSoap11BindingWithAsymmetricSecurity(StandardServiceBindingOptions options);
    public static Binding CreateDefaultHttpsSoap11BindingWithAsymmetricSecurity(StandardServiceBindingOptions options);
    public static Binding CreateDefaultWSHttpBindingWithoutProtection();
    public static WSHttpBinding CreateDefaultWSHttpCertificateBinding();
    public static WSHttpBinding CreateDefaultWSHttpsWindowsIntegratedBinding();
    public static WSHttpBinding CreateDefaultWSHttpWindowsIntegratedBinding();
    public static WSFederationHttpBinding CreateDefaultWSFederationBinding(Binding issuerBinding, EndpointAddress issuerAddress, StandardServiceBindingOptions options);
    public static WSFederationHttpBinding CreateDefaultWSFederationBindingOverHttps(Binding issuerBinding, EndpointAddress issuerAddress, StandardServiceBindingOptions options);
    private static void SetOptions(StandardServiceBindingOptions options, WSHttpBindingBase binding);
    private static void SetOptions(StandardServiceBindingOptions options, BasicHttpBinding binding);
    public static Binding get_DefaultHttpSoap11BindingWithoutProtection();
    public static Binding get_DefaultHttpSoap11BindingWithAsymmetricSecurity();
}
public class Holzer.Services.Bindings.StandardServiceBindingOptions : object {
    private string cacheKey;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <MaxReceivedMessageSize>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MaxArrayLength>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MaxStringContentLength>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MaxBufferPoolSize>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<TimeSpan> <SendTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<TimeSpan> <ReceiveTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<WSMessageEncoding> <MessageEncoding>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AddClientExceptionBehavior>k__BackingField;
    public Nullable`1<long> MaxReceivedMessageSize { get; public set; }
    public Nullable`1<int> MaxArrayLength { get; public set; }
    public Nullable`1<int> MaxStringContentLength { get; public set; }
    public Nullable`1<int> MaxBufferPoolSize { get; public set; }
    public Nullable`1<TimeSpan> SendTimeout { get; public set; }
    public Nullable`1<TimeSpan> ReceiveTimeout { get; public set; }
    public Nullable`1<WSMessageEncoding> MessageEncoding { get; public set; }
    public bool AddClientExceptionBehavior { get; public set; }
    [JsonIgnoreAttribute]
public string CacheKey { get; }
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_MaxReceivedMessageSize();
    [CompilerGeneratedAttribute]
public void set_MaxReceivedMessageSize(Nullable`1<long> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_MaxArrayLength();
    [CompilerGeneratedAttribute]
public void set_MaxArrayLength(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_MaxStringContentLength();
    [CompilerGeneratedAttribute]
public void set_MaxStringContentLength(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_MaxBufferPoolSize();
    [CompilerGeneratedAttribute]
public void set_MaxBufferPoolSize(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<TimeSpan> get_SendTimeout();
    [CompilerGeneratedAttribute]
public void set_SendTimeout(Nullable`1<TimeSpan> value);
    [CompilerGeneratedAttribute]
public Nullable`1<TimeSpan> get_ReceiveTimeout();
    [CompilerGeneratedAttribute]
public void set_ReceiveTimeout(Nullable`1<TimeSpan> value);
    [CompilerGeneratedAttribute]
public Nullable`1<WSMessageEncoding> get_MessageEncoding();
    [CompilerGeneratedAttribute]
public void set_MessageEncoding(Nullable`1<WSMessageEncoding> value);
    [CompilerGeneratedAttribute]
public bool get_AddClientExceptionBehavior();
    [CompilerGeneratedAttribute]
public void set_AddClientExceptionBehavior(bool value);
    public string get_CacheKey();
}
public class Holzer.Services.ClientExceptionBehavior : Attribute {
    private sealed virtual override void System.ServiceModel.Description.IContractBehavior.ApplyClientBehavior(ContractDescription contract, ServiceEndpoint endpoint, ClientRuntime runtime);
    private sealed virtual override void System.ServiceModel.Description.IContractBehavior.ApplyDispatchBehavior(ContractDescription contract, ServiceEndpoint endpoint, DispatchRuntime runtime);
    private void ApplyClientBehavior(ClientRuntime runtime);
    public sealed virtual void AddBindingParameters(ContractDescription contractDescription, ServiceEndpoint endpoint, BindingParameterCollection bindingParameters);
    public sealed virtual void Validate(ContractDescription contractDescription, ServiceEndpoint endpoint);
}
public class Holzer.Services.ClientExceptionMarshallingElement : BehaviorExtensionElement {
    public Type BehaviorType { get; }
    public virtual Type get_BehaviorType();
    protected virtual object CreateBehavior();
}
public class Holzer.Services.ClientExceptionMarshallingMessageInspector : object {
    private static string RayIdHeader;
    public sealed virtual object BeforeSendRequest(Message& request, IClientChannel channel);
    public sealed virtual void AfterReceiveReply(Message& reply, object state);
    protected virtual void ThrowException(ClientExceptionRequestState requestState, XmlDictionaryReader reader, Message reply, MessageFault fault);
    private static string GetMessage(MessageFault fault);
}
public class Holzer.Services.ClientExceptionRequestState : object {
    [CompilerGeneratedAttribute]
private string <RayId>k__BackingField;
    [CompilerGeneratedAttribute]
private LoginTicket <CurrentUser>k__BackingField;
    public string RayId { get; public set; }
    public LoginTicket CurrentUser { get; public set; }
    [CompilerGeneratedAttribute]
public string get_RayId();
    [CompilerGeneratedAttribute]
public void set_RayId(string value);
    [CompilerGeneratedAttribute]
public LoginTicket get_CurrentUser();
    [CompilerGeneratedAttribute]
public void set_CurrentUser(LoginTicket value);
}
public class Holzer.Services.Communication : object {
    private static List`1<ServiceAdapterRegistration> registrations;
    private static Communication();
    public static void Publish(string name, Type serviceAdapterType);
    public static void Publish(string name, Type serviceAdapterType, Type interfaceType);
    public static void Publish(ServiceAdapterRegistration r);
    public static ServiceAdapterRegistration[] GetRegistrations();
}
[DataContractAttribute]
public class Holzer.Services.CredentialsFault : object {
}
[DataContractAttribute]
public class Holzer.Services.HumanErrorFault : object {
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ErrorReportNumber>k__BackingField;
    [DataMemberAttribute]
public string Message { get; public set; }
    [DataMemberAttribute]
public string ErrorReportNumber { get; public set; }
    public HumanErrorFault(string message, string errorReportNumber);
    [CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
public void set_Message(string value);
    [CompilerGeneratedAttribute]
public string get_ErrorReportNumber();
    [CompilerGeneratedAttribute]
public void set_ErrorReportNumber(string value);
}
public class Holzer.Services.HumanErrorFaultException : FaultException`1<HumanErrorFault> {
    public HumanErrorFaultException(string message);
}
public class Holzer.Services.IdentityCallContextInitializer : object {
    private X509Certificate2 customOwnedCertificate;
    [CompilerGeneratedAttribute]
private String[] <RequirePermissions>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RequireLocalIdentity>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RequireIdentityClass>k__BackingField;
    public String[] RequirePermissions { get; public set; }
    public bool RequireLocalIdentity { get; public set; }
    public string RequireIdentityClass { get; public set; }
    public IdentityCallContextInitializer(X509Certificate2 customOwnedCertificate, String[] requirePermissions, bool requireLocalIdentity, string requireIdentityClass);
    public sealed virtual object BeforeInvoke(InstanceContext instanceContext, IClientChannel channel, Message message);
    public sealed virtual void AfterInvoke(object correlationState);
    [CompilerGeneratedAttribute]
public String[] get_RequirePermissions();
    [CompilerGeneratedAttribute]
public void set_RequirePermissions(String[] value);
    [CompilerGeneratedAttribute]
public bool get_RequireLocalIdentity();
    [CompilerGeneratedAttribute]
public void set_RequireLocalIdentity(bool value);
    [CompilerGeneratedAttribute]
public string get_RequireIdentityClass();
    [CompilerGeneratedAttribute]
public void set_RequireIdentityClass(string value);
}
public class Holzer.Services.IdentityContextBehaviorAttribute : Attribute {
    [CompilerGeneratedAttribute]
private String[] <Permissions>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RequireLocalIdentity>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RequireIdentityClass>k__BackingField;
    public String[] Permissions { get; public set; }
    public bool RequireLocalIdentity { get; public set; }
    public string RequireIdentityClass { get; public set; }
    public IdentityContextBehaviorAttribute(String[] permissions);
    private IdentityContextBehaviorAttribute(IdentityContextBehaviorAttribute clone);
    private sealed virtual override void System.ServiceModel.Description.IServiceBehavior.Validate(ServiceDescription serviceDescription, ServiceHostBase serviceHostBase);
    private sealed virtual override void System.ServiceModel.Description.IServiceBehavior.AddBindingParameters(ServiceDescription serviceDescription, ServiceHostBase serviceHostBase, Collection`1<ServiceEndpoint> endpoints, BindingParameterCollection bindingParameters);
    private sealed virtual override void System.ServiceModel.Description.IServiceBehavior.ApplyDispatchBehavior(ServiceDescription serviceDescription, ServiceHostBase serviceHostBase);
    private sealed virtual override void System.ServiceModel.Description.IOperationBehavior.AddBindingParameters(OperationDescription operationDescription, BindingParameterCollection bindingParameters);
    private sealed virtual override void System.ServiceModel.Description.IOperationBehavior.ApplyClientBehavior(OperationDescription operationDescription, ClientOperation clientOperation);
    private sealed virtual override void System.ServiceModel.Description.IOperationBehavior.ApplyDispatchBehavior(OperationDescription operationDescription, DispatchOperation dispatchOperation);
    private sealed virtual override void System.ServiceModel.Description.IOperationBehavior.Validate(OperationDescription operationDescription);
    [CompilerGeneratedAttribute]
public String[] get_Permissions();
    [CompilerGeneratedAttribute]
public void set_Permissions(String[] value);
    [CompilerGeneratedAttribute]
public bool get_RequireLocalIdentity();
    [CompilerGeneratedAttribute]
public void set_RequireLocalIdentity(bool value);
    [CompilerGeneratedAttribute]
public string get_RequireIdentityClass();
    [CompilerGeneratedAttribute]
public void set_RequireIdentityClass(string value);
}
[DataContractAttribute]
public class Holzer.Services.MachineErrorFault : object {
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ErrorReportNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ErrorCode>k__BackingField;
    [DataMemberAttribute]
public string Message { get; public set; }
    [DataMemberAttribute]
public string ErrorReportNumber { get; public set; }
    [DataMemberAttribute]
public string ErrorCode { get; public set; }
    public MachineErrorFault(string message, string errorReportNumber, string errorCode);
    [CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
public void set_Message(string value);
    [CompilerGeneratedAttribute]
public string get_ErrorReportNumber();
    [CompilerGeneratedAttribute]
public void set_ErrorReportNumber(string value);
    [CompilerGeneratedAttribute]
public string get_ErrorCode();
    [CompilerGeneratedAttribute]
public void set_ErrorCode(string value);
}
[DataContractAttribute]
public class Holzer.Services.MachineInfo : object {
    [CompilerGeneratedAttribute]
private Nullable`1<int> <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SystemName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DisplayName>k__BackingField;
    [DataMemberAttribute]
public Nullable`1<int> Id { get; public set; }
    [DataMemberAttribute]
public string SystemName { get; public set; }
    [DataMemberAttribute]
public string DisplayName { get; public set; }
    public MachineInfo(Nullable`1<int> id, string systemName, string displayName);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public string get_SystemName();
    [CompilerGeneratedAttribute]
public void set_SystemName(string value);
    [CompilerGeneratedAttribute]
public string get_DisplayName();
    [CompilerGeneratedAttribute]
public void set_DisplayName(string value);
}
public class Holzer.Services.Network.BasicHttpAsymmetricSecurityCommunicationPort : HttpCommunicationPortBase {
    public BasicHttpAsymmetricSecurityCommunicationPort(Nullable`1<int> port, string path, Type serviceType, Type contractType, string serverName, StandardServiceBindingOptions options);
    public BasicHttpAsymmetricSecurityCommunicationPort(Nullable`1<int> port, string path, object serviceInstance, Type contractType, string serverName, StandardServiceBindingOptions options);
}
public class Holzer.Services.Network.BasicHttpCommunicationPort : HttpCommunicationPortBase {
    public BasicHttpCommunicationPort(Nullable`1<int> port, string path, Type serviceType, Type contractType, string resourceKey);
    public BasicHttpCommunicationPort(Nullable`1<int> port, string path, object service, Type contractType, string resourceKey);
}
public class Holzer.Services.Network.CertificateCredentialsHostServiceFactory : ServiceHostFactory {
    public virtual ServiceHostBase CreateServiceHost(string constructorString, Uri[] baseAddresses);
}
public abstract class Holzer.Services.Network.CommunicationPortBase : object {
    private Uri metaDataExchangeAddress;
    private List`1<Uri> addresses;
    private bool onBeforeOpenCalled;
    public Uri MetaDataExchangeAddress { get; protected set; }
    public void OnBeforeAddPortCore();
    private void EnsureOnBeforeOpenCalled();
    protected abstract virtual void OnBeforeOpen();
    public void Open();
    protected abstract virtual void OnOpen();
    public void Close();
    protected abstract virtual void OnClose();
    protected static ServiceContractAttribute GetServiceContractAttribute(Type contractType);
    public static string GetContractSystemName(Type contractType);
    public static string GetContractDisplayName(Type contractType);
    protected void AddAddress(Uri serviceAddress);
    public Uri[] GetAddresses();
    public Uri get_MetaDataExchangeAddress();
    protected void set_MetaDataExchangeAddress(Uri value);
}
public abstract class Holzer.Services.Network.HttpCommunicationPortBase : CommunicationPortBase {
    private int port;
    private string path;
    private Uri baseAddress;
    private Type contractType;
    private Type serviceType;
    private Binding binding;
    private ServiceHost host;
    private ServiceEndpoint metaExchange;
    private ServiceEndpoint service;
    private ServiceAdapterRegistration serviceAdapterRegistration;
    private string resourceKey;
    public ServiceHost Host { get; }
    public ServiceEndpoint MetaExchangeEndpoint { get; }
    public ServiceEndpoint ServiceEndpoint { get; }
    public Uri BaseAddress { get; }
    internal HttpCommunicationPortBase(Nullable`1<int> port, string path, Type serviceType, Type contractType, Binding binding, string serverName, string resourceKey);
    internal HttpCommunicationPortBase(Nullable`1<int> port, string path, object serviceInstance, Type contractType, Binding binding, string serverName, string resourceKey);
    private HttpCommunicationPortBase(Nullable`1<int> port, string path, Type serviceType, object serviceInstance, Type contractType, Binding binding, string serverName, string resourceKey);
    private ServiceEndpoint AddEndPoint(Type contractType, Binding binding, Uri serviceAddress);
    protected virtual void OnBeforeOpen();
    protected virtual void OnOpen();
    protected virtual void OnClose();
    public ServiceHost get_Host();
    public void ConfigureCredentialsForMutalCertificates(X509Certificate2 serviceCertificate);
    public ServiceEndpoint get_MetaExchangeEndpoint();
    public ServiceEndpoint get_ServiceEndpoint();
    public Uri get_BaseAddress();
}
public class Holzer.Services.Network.NamedPipesCommunicationPort : CommunicationPortBase {
    private string pipeName;
    private Uri baseAddress;
    private Type contractType;
    private Type serviceType;
    private Binding binding;
    private ServiceHost host;
    private ServiceEndpoint metaExchange;
    private ServiceEndpoint service;
    private ServiceAdapterRegistration serviceAdapterRegistration;
    private string resourceKey;
    public ServiceHost Host { get; }
    public ServiceEndpoint MetaExchangeEndpoint { get; }
    public ServiceEndpoint ServiceEndpoint { get; }
    public Uri BaseAddress { get; }
    public NamedPipesCommunicationPort(string pipeName, Type serviceType, object serviceInstance, Type contractType, Binding binding, string resourceKey);
    protected virtual void OnBeforeOpen();
    protected virtual void OnOpen();
    protected virtual void OnClose();
    public ServiceHost get_Host();
    public ServiceEndpoint get_MetaExchangeEndpoint();
    public ServiceEndpoint get_ServiceEndpoint();
    public Uri get_BaseAddress();
}
public class Holzer.Services.Network.NetworkResourcePort : object {
    public int PortNumber;
}
public class Holzer.Services.Network.NetworkResourcePortResolveEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private string <ResourceKey>k__BackingField;
    [CompilerGeneratedAttribute]
private NetworkResourcePort <Port>k__BackingField;
    public string ResourceKey { get; public set; }
    public NetworkResourcePort Port { get; public set; }
    [CompilerGeneratedAttribute]
public string get_ResourceKey();
    [CompilerGeneratedAttribute]
public void set_ResourceKey(string value);
    [CompilerGeneratedAttribute]
public NetworkResourcePort get_Port();
    [CompilerGeneratedAttribute]
public void set_Port(NetworkResourcePort value);
}
public static class Holzer.Services.Network.NetworkServices : object {
    private static string serverName;
    private static int defaultPort;
    private static string defaultServiceAddressPath;
    [CompilerGeneratedAttribute]
private static EventHandler`1<NetworkResourcePortResolveEventArgs> ResolveResourcePort;
    [DebuggerStepThroughAttribute]
private static NetworkServices();
    public static string GetRelativeServicePathStandardNaming(string path);
    public static string GetRelativeServicePathRoot();
    public static string GetAbsoluteServiceAddress(string protocol, Nullable`1<int> port, string path);
    public static string GetAbsoluteServiceAddress(string protocol, Nullable`1<int> port, string path, string serverName);
    public static string GetAbsoluteServiceAddressWeb(string protocol, Nullable`1<int> port, string pathToApp, string pathWithinApp);
    public static string GetServerName();
    internal static int GetDefaultPort();
    public static string GetCurrentDomainForestName();
    internal static String[] GetDnsTxtRecord(string hostname);
    public static NetworkResourcePort GetResourcePort(string resourceKey);
    [CompilerGeneratedAttribute]
public static void add_ResolveResourcePort(EventHandler`1<NetworkResourcePortResolveEventArgs> value);
    [CompilerGeneratedAttribute]
public static void remove_ResolveResourcePort(EventHandler`1<NetworkResourcePortResolveEventArgs> value);
    public static bool IsPrivateNetwork(IPAddress address);
}
internal static class Holzer.Services.Network.NetworkWin32 : object {
    internal static int DsGetDcName(string ComputerName, string DomainName, int DomainGuid, string SiteName, UInt32 Flags, IntPtr& pDOMAIN_CONTROLLER_INFO);
    private static int NetApiBufferFree(IntPtr Buffer);
    public static Nullable`1<DOMAIN_CONTROLLER_INFO> GetDomainInfo();
    private static int DnsQuery(String& pszName, QueryTypes wType, QueryOptions options, int aipServers, IntPtr& ppQueryResults, int pReserved);
    private static void DnsRecordListFree(IntPtr pRecordList, int FreeType);
    internal static String[] GetDnsTxtRecord(string domain);
}
public static class Holzer.Services.Network.ServiceConnectionFactory : object {
    private static string IdentityContextClientCacheStateKey;
    private static Dictionary`2<Type, Func`5<ServiceAddressInfo, StandardServiceBindingOptions, ServicePortInfo, IdentityContext, ServiceClientBase>> webApiClientFactories;
    private static ServiceConnectionFactory();
    public static void RegisterWebApiClientFactory(Func`5<ServiceAddressInfo, StandardServiceBindingOptions, ServicePortInfo, IdentityContext, ServiceClient`1<TContract>> factory);
    public static ServiceClient`1<TContract> Connect(ServiceAddressInfo serviceAddressInfo, bool throwIfNotSupported, StandardServiceBindingOptions options, ServicePortInfo port);
    private static ServiceClient`1<TContract> ConnectWsFederationHttpBinding(ServiceAddressInfo targetAddress, StandardServiceBindingOptions options, ServicePortInfo port);
    private static ServiceClient`1<TContract> ConnectWebApiClient(ServiceAddressInfo address, StandardServiceBindingOptions options, ServicePortInfo port);
    private static ServiceClient`1<TContract> BuildWebApiClient(ServiceAddressInfo address, StandardServiceBindingOptions options, ServicePortInfo port, IdentityContext identityContext);
    private static CacheDictionary`2<string, ServiceClientBase> GetClientCache(IdentityContext identityContext);
}
public class Holzer.Services.Network.WsFederationSecurityCommunicationPort : HttpCommunicationPortBase {
    public WsFederationSecurityCommunicationPort(Nullable`1<int> port, string path, Type serviceType, Type contractType, StandardServiceBindingOptions options, string resourceKey);
}
[DataContractAttribute]
public class Holzer.Services.NotSignedInFault : object {
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [DataMemberAttribute]
public string Message { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
public void set_Message(string value);
}
public class Holzer.Services.NotSupportedFaultException : FaultException {
    public NotSupportedFaultException(string message);
}
public class Holzer.Services.PresentationLogicServices : object {
    public static DateTime Date00010101;
    public static DateTime Date19000101;
    public static DateTime Date19500101;
    public static DateTime Date99991231;
    public static DateTime DateSqlDateTimeMin;
    public static decimal DecimalMoneySynteticMax;
    public static int MathRoundDecimalDigitsMax;
    public static string PercentFormatting;
    public static string PercentDecimalFormatting;
    public static string PercentTrimmedDecimalFormatting;
    public static string CurrencyFormatting;
    public static string NumberFormatting;
    public static string NumberWithDecimalsFormatting;
    public static string NumberWithDecimalsTruncateFormatting;
    public static string CurrencyDecimalFormatting;
    public static string CurrencyFourDecimalFormatting;
    public static string DateFormattingString;
    public static string ShortDateFormattingString;
    public static string DateTimeFormattingString;
    public static string DateTimeWithSecondsFormattingString;
    public static string PeriodDateFormattingString;
    public static string ShortPeriodDateFormattingString;
    public static string TimeFormattingString;
    public static string TimeWithSecondsFormatingString;
    public static string MonthDateFormattingString;
    public static string DateMonthFormattingString;
    public static string YearFormattingString;
    private static PresentationLogicServices();
    public static string GetYearString(DateTime dateTime);
    public static string GetYearString(Nullable`1<DateTime> dateTime);
    public static string GetPeriodDateString(DateTime dateTime);
    public static string GetPeriodDateString(Nullable`1<DateTime> dateTime);
    public static string GetDateStringDateWhenNeeded(Nullable`1<DateTime> dateTime, bool isToDate);
    public static string GetShortPeriodDateString(DateTime dateTime);
    public static string GetShortPeriodDateString(Nullable`1<DateTime> dateTime);
    public static DateTime GetPeriodDateFromString(string period);
    public static string GetDateString(DateTime dateTime);
    public static string GetDateString(Nullable`1<DateTime> dateTime);
    public static string GetShortDateString(Nullable`1<DateTime> dateTime);
    public static string GetMonthDateString(DateTime dateTime);
    public static string GetDateMonthString(DateTime dateTime);
    public static string GetMonthDateString(Nullable`1<DateTime> dateTime);
    public static string GetDateTimeString(DateTime dateTime);
    public static string GetDateTimeString(Nullable`1<DateTime> dateTime);
    public static string GetDateTimeWithSecondsString(Nullable`1<DateTime> dateTime);
    public static string GetDateTimeWithSecondsString(DateTime dateTime);
    public static string GetDateTimeWithSecondsTrimString(Nullable`1<DateTime> dateTime);
    public static string GetDateTimeWithSecondsTrimString(DateTime dateTime);
    public static string GetDateTimeTrimString(Nullable`1<DateTime> dateTime);
    public static string GetTimeString(DateTime dateTime);
    public static string GetTimeWithSecondsString(DateTime dateTime);
    public static string GetAge(Nullable`1<TimeSpan> age, bool appendAgo);
    public static string GetTimeSpanString(Nullable`1<TimeSpan> t);
    public static string GetTimeSpanString(TimeSpan t);
    public static string GetTimeSpanStringLång(Nullable`1<TimeSpan> t);
    public static string GetTimeSpanStringMilliseconds(TimeSpan t);
    public static string GetTimeSpanStringInternational(TimeSpan t);
    public static string GetTimeString(Nullable`1<DateTime> dateTime);
    public static bool IsNullDate(DateTime date);
    public static bool IsNullDate(Nullable`1<DateTime> date);
    public static bool IsLeapYear(int year);
    public static string GetDateStringWith1950(DateTime dateTime);
    public static string GetDateStringWith1950(Nullable`1<DateTime> dateTime);
    public static string GetMonthDateStringWith1950(DateTime dateTime);
    public static string GetMonthDateStringWith1950(Nullable`1<DateTime> dateTime);
    public static string GetDateTimeStringWith1950(DateTime dateTime);
    public static string GetDateTimeStringWith1950(Nullable`1<DateTime> dateTime);
    public static string GetDateTimeWithSecondsStringWith1950(DateTime dateTime);
    public static string GetTimeStringWith1950(DateTime dateTime);
    public static string GetTimeStringWith1950(Nullable`1<DateTime> dateTime);
    public static bool IsNullDateWith1950(DateTime date);
    public static bool IsNullDateWith1950(Nullable`1<DateTime> date);
    public static string GetPercentDecimalString(Nullable`1<decimal> value);
    public static string GetPercentTrimmedDecimalFormattingString(Nullable`1<decimal> value);
    public static string GetPercentString(Nullable`1<decimal> value);
    public static string GetNumberString(Nullable`1<long> value);
    public static string GetNumberStringShortenUnitPefix(Nullable`1<long> value);
    public static string GetNumberStringAutoDecimals(Nullable`1<decimal> value);
    public static string GetNumberStringAutoTruncateDecimals(Nullable`1<decimal> value);
    public static string GetNumberStringDecimals(Nullable`1<decimal> value);
    public static string GetCurrencyString(decimal money);
    public static string GetCurrencyDecimalString(Nullable`1<decimal> money);
    public static string GetCurrencyDecimalStringWhenNeeded(Nullable`1<decimal> money);
    public static string GetCurrencyDecimalStringWhenNeededFourDecimals(Nullable`1<decimal> money);
    public static string GetCurrencyFourDecimalString(Nullable`1<decimal> money);
    public static string GetCurrencyString(Nullable`1<decimal> money, short numberofDecimals);
    public static string GetCurrencyString(Nullable`1<decimal> money);
    public static string GetShortCurrencyString(decimal money);
    public static string GetShortCurrencyString(Nullable`1<decimal> money);
    public static string GetDoubleDecimalStringWhenNeeded(Nullable`1<double> value);
    public static string GetTheNumbers(string inputVal);
    public static string InsertPersonNrHyphen(string pNummer);
    public static string InsertOrgNrHyphen(string orgNr);
    public static string InsertDateNrHyphen(string date);
    public static string GetHeltal(Nullable`1<decimal> number);
    public static string GetHeltal(decimal number);
    public static string GetYta(Nullable`1<decimal> number);
    public static string GetYta(decimal number);
    public static string GetYta(Nullable`1<decimal> number, int decimals);
    public static string GetYta(decimal number, int decimals);
    public static string GetSqlSearchStringInnerWildcard(string s);
    public static string GetSqlSearchString(string s);
    public static string GetSqlSearchStringLeadingWildcard(string s);
    public static string GetByteSizeString(Nullable`1<long> value);
    public static string GetByteSizeString(Nullable`1<double> value);
    public static string GetByteSizeStringKilo(Nullable`1<long> value);
    public static string GetByteSizeStringKilo(Nullable`1<double> value);
    public static string GetBitSizeString(Nullable`1<double> value);
    public static string GetBitSizeString(Nullable`1<long> value);
    public static string GetBitString(bool value);
    public static string GetBitString(Nullable`1<bool> value);
    public static string GetTruncatedString(string value, int maxLength);
}
public class Holzer.Services.ServiceAdapterRegistration : MarshalByRefObject {
    private string name;
    private Type interfaceType;
    private Type instanceType;
    private List`1<string> addresses;
    private Uri metaDataExchangeAddress;
    [CompilerGeneratedAttribute]
private string <ResouceKey>k__BackingField;
    public String[] Addresses { get; }
    public string Name { get; }
    public Type InterfaceType { get; }
    public Type InstanceType { get; }
    public Uri MetaDataExchangeAddress { get; public set; }
    public string ResouceKey { get; public set; }
    public ServiceAdapterRegistration(string name, Type interfaceType, Type instanceType, string resourceKey);
    public String[] get_Addresses();
    public string get_Name();
    public Type get_InterfaceType();
    public Type get_InstanceType();
    public void AddAddress(string address);
    public void AddAddress(Uri uri);
    public Uri get_MetaDataExchangeAddress();
    public void set_MetaDataExchangeAddress(Uri value);
    [CompilerGeneratedAttribute]
public string get_ResouceKey();
    [CompilerGeneratedAttribute]
public void set_ResouceKey(string value);
}
[DataContractAttribute]
public class Holzer.Services.ServiceAddressInfo : object {
    private string cacheKey;
    private Uri addressUri;
    private ServiceAddressKey[] keyList;
    private X509Certificate2Collection keyListCertificates;
    private X509CertificateEndpointIdentity certificateEndpointIdentity;
    private EndpointAddress endpointAddress;
    private X509Certificate2 certificate;
    [CompilerGeneratedAttribute]
private string <FederationMemberGuid>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ApplicationInstanceId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AddressData>k__BackingField;
    [CompilerGeneratedAttribute]
private string <BindingSystemName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <BindingDisplayName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <BindingConfiguration>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <CertificateData>k__BackingField;
    [CompilerGeneratedAttribute]
private ServiceAddressInfoKeyData[] <KeyListData>k__BackingField;
    [DataMemberAttribute]
public string FederationMemberGuid { get; public set; }
    [DataMemberAttribute]
public string ApplicationInstanceId { get; public set; }
    [DataMemberAttribute]
public string AddressData { get; public set; }
    [DataMemberAttribute]
public string BindingSystemName { get; public set; }
    [DataMemberAttribute]
public string BindingDisplayName { get; public set; }
    [DataMemberAttribute]
public string BindingConfiguration { get; public set; }
    [JsonIgnoreAttribute]
public Uri Address { get; }
    [DataMemberAttribute]
public Byte[] CertificateData { get; public set; }
    [JsonIgnoreAttribute]
public X509Certificate2 Certificate { get; }
    [DataMemberAttribute]
public ServiceAddressInfoKeyData[] KeyListData { get; public set; }
    [JsonIgnoreAttribute]
public ServiceAddressKey[] KeyList { get; }
    [JsonIgnoreAttribute]
public X509CertificateEndpointIdentity EndpointIdentity { get; }
    [JsonIgnoreAttribute]
public EndpointAddress EndpointAddress { get; }
    [JsonIgnoreAttribute]
public string CacheKey { get; }
    public ServiceAddressInfo(string addressData, string bindingSystemName, string bindingDisplayName);
    public ServiceAddressInfo(string federationMemberGuid, string applicationInstanceId, string addressData, string bindingSystemName, string bindingDisplayName, Byte[] certificateData, ServiceAddressInfoKeyData[] keyListData);
    public ServiceAddressInfo ChangeAddress(string newAddressData);
    [CompilerGeneratedAttribute]
public string get_FederationMemberGuid();
    [CompilerGeneratedAttribute]
public void set_FederationMemberGuid(string value);
    [CompilerGeneratedAttribute]
public string get_ApplicationInstanceId();
    [CompilerGeneratedAttribute]
public void set_ApplicationInstanceId(string value);
    [CompilerGeneratedAttribute]
public string get_AddressData();
    [CompilerGeneratedAttribute]
public void set_AddressData(string value);
    [CompilerGeneratedAttribute]
public string get_BindingSystemName();
    [CompilerGeneratedAttribute]
public void set_BindingSystemName(string value);
    [CompilerGeneratedAttribute]
public string get_BindingDisplayName();
    [CompilerGeneratedAttribute]
public void set_BindingDisplayName(string value);
    [CompilerGeneratedAttribute]
public string get_BindingConfiguration();
    [CompilerGeneratedAttribute]
public void set_BindingConfiguration(string value);
    public Uri get_Address();
    [CompilerGeneratedAttribute]
public Byte[] get_CertificateData();
    [CompilerGeneratedAttribute]
public void set_CertificateData(Byte[] value);
    public X509Certificate2 get_Certificate();
    [CompilerGeneratedAttribute]
public ServiceAddressInfoKeyData[] get_KeyListData();
    [CompilerGeneratedAttribute]
public void set_KeyListData(ServiceAddressInfoKeyData[] value);
    public ServiceAddressKey[] get_KeyList();
    public X509CertificateEndpointIdentity get_EndpointIdentity();
    private X509Certificate2Collection KeyListCertificateCollection();
    public EndpointAddress get_EndpointAddress();
    public string get_CacheKey();
    public virtual string ToString();
}
[DataContractAttribute]
public class Holzer.Services.ServiceApplicationInstanceInfo : object {
    [CompilerGeneratedAttribute]
private ApplicationInfo <Application>k__BackingField;
    [DataMemberAttribute]
public ApplicationInfo Application { get; public set; }
    [CompilerGeneratedAttribute]
public ApplicationInfo get_Application();
    [CompilerGeneratedAttribute]
public void set_Application(ApplicationInfo value);
}
public class Holzer.Services.ServiceClient`1 : ServiceClientBase {
    private bool isAvailable;
    private TService service;
    private IChannel channel;
    private ServiceAddressInfo serviceAddress;
    private IdentityContext identityContext;
    private ServicePortInfo port;
    public ServiceAddressInfo ServiceAddress { get; }
    public IdentityContext IdentityContext { get; }
    public TService Channel { get; }
    public bool IsAvailable { get; }
    public ServicePortInfo Port { get; }
    public ServiceClient`1(TService service, ServiceAddressInfo serviceAddress, IdentityContext identityContext, ServicePortInfo port);
    public ServiceAddressInfo get_ServiceAddress();
    public IdentityContext get_IdentityContext();
    public TService get_Channel();
    public sealed virtual void Dispose();
    private void EndClose(IAsyncResult result);
    public bool get_IsAvailable();
    public ServicePortInfo get_Port();
}
public class Holzer.Services.ServiceClientBase : object {
}
[DataContractAttribute]
public class Holzer.Services.ServiceContractMetaInfo : object {
    [CompilerGeneratedAttribute]
private Nullable`1<int> <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SystemName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DisplayName>k__BackingField;
    [DataMemberAttribute]
public Nullable`1<int> Id { get; public set; }
    [DataMemberAttribute]
public string SystemName { get; public set; }
    [DataMemberAttribute]
public string DisplayName { get; public set; }
    public ServiceContractMetaInfo(int id, string systemName, string displayName);
    public ServiceContractMetaInfo(string systemName, string displayName);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public string get_SystemName();
    [CompilerGeneratedAttribute]
public void set_SystemName(string value);
    [CompilerGeneratedAttribute]
public string get_DisplayName();
    [CompilerGeneratedAttribute]
public void set_DisplayName(string value);
}
[DataContractAttribute]
public class Holzer.Services.ServiceDirectory.DirectoryQuery : object {
    [CompilerGeneratedAttribute]
private Nullable`1<int> <Lcid>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FederationMemberGuid>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ServiceContract>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludeOfflineServices>k__BackingField;
    [DataMemberAttribute]
public Nullable`1<int> Lcid { get; public set; }
    [DataMemberAttribute]
public string FederationMemberGuid { get; public set; }
    [DataMemberAttribute]
public string ServiceContract { get; public set; }
    [DataMemberAttribute]
public bool IncludeOfflineServices { get; public set; }
    public DirectoryQuery(Type contract);
    public DirectoryQuery(Type contract, string federationMemberGuid);
    public virtual string ToString();
    internal string GetCacheKey();
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_Lcid();
    [CompilerGeneratedAttribute]
public void set_Lcid(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public string get_FederationMemberGuid();
    [CompilerGeneratedAttribute]
public void set_FederationMemberGuid(string value);
    [CompilerGeneratedAttribute]
public string get_ServiceContract();
    [CompilerGeneratedAttribute]
public void set_ServiceContract(string value);
    [CompilerGeneratedAttribute]
public bool get_IncludeOfflineServices();
    [CompilerGeneratedAttribute]
public void set_IncludeOfflineServices(bool value);
}
public static class Holzer.Services.ServiceDirectory.DirectoryServices : object {
    private static string IdentityContextCacheStateKey;
    private static int MaxNumberOfPorts;
    private static TelemetryBackgroundTaskItem directoryPublisherTimerTaskTelemetry;
    private static List`1<ServicePortInfo> servicePorts;
    private static bool servicePortsComplete;
    private static DirectoryServices();
    public static ServiceClient`1<TContract> Connect(bool throwIfMissing);
    public static Task`1<ServiceClient`1<TContract>> ConnectAsync(bool throwIfMissing);
    public static ServiceClient`1<TContract> Connect(bool throwIfMissing, StandardServiceBindingOptions options);
    public static ServiceClient`1<TContract> Connect(string federationMemberGuid, bool throwIfMissing);
    public static ServiceClient`1<TContract> Connect(DirectoryQuery query, bool throwIfMissing);
    public static ServiceClient`1<TContract> Connect(DirectoryQuery query, bool throwIfMissing, StandardServiceBindingOptions options);
    [AsyncStateMachineAttribute("Holzer.Services.ServiceDirectory.DirectoryServices/<ConnectAsync>d__11`1")]
public static Task`1<ServiceClient`1<TContract>> ConnectAsync(DirectoryQuery query, bool throwIfMissing, StandardServiceBindingOptions options);
    public static ServiceClient`1<TContract> Connect(ServiceAddressInfo address, StandardServiceBindingOptions options, ServicePortInfo port);
    public static Actor GetCurrentActor();
    public static string GetPermanentResourceIdentifier(string federationMemberGuid, string applicationSystemName);
    public static BasicEndpointTestServiceResponse Test();
    public static ServicePortInfo[] Search(DirectoryQuery query, bool useCache);
    [AsyncStateMachineAttribute("Holzer.Services.ServiceDirectory.DirectoryServices/<SearchAsync>d__17")]
public static Task`1<ServicePortInfo[]> SearchAsync(DirectoryQuery query, bool useCache);
    private static ServicePortInfo[] LookupInCache(CacheDictionary`2<string, ServicePortInfo[]> lookupCache, string cacheKey);
    private static CacheDictionary`2<string, ServicePortInfo[]> GetLookupCache(IdentityContext identityContext);
    public static void RegisterServicePort(string address, Type contract, string bindingSystemName, string bindingDisplayName);
    public static void RegisterServicePort(string address, string contractSystemName, string contractDisplayName, string bindingSystemName, string bindingDisplayName);
    public static void PublishApplication();
    public static void UpdateApplicationInstanceDefinition();
    [DebuggerStepThroughAttribute]
private static void BeginPublishApplicationTask();
    private static bool TryPublishApplication();
    public static void PublishNow();
    public static ApplicationInstanceMetaInfo GetApplicationInstanceMetaInfo();
}
public class Holzer.Services.ServiceExceptionBehaviorAttribute : Attribute {
    private sealed virtual override void System.ServiceModel.Description.IServiceBehavior.AddBindingParameters(ServiceDescription serviceDescription, ServiceHostBase serviceHostBase, Collection`1<ServiceEndpoint> endpoints, BindingParameterCollection bindingParameters);
    private sealed virtual override void System.ServiceModel.Description.IServiceBehavior.ApplyDispatchBehavior(ServiceDescription serviceDescription, ServiceHostBase serviceHostBase);
    private sealed virtual override void System.ServiceModel.Description.IServiceBehavior.Validate(ServiceDescription serviceDescription, ServiceHostBase serviceHostBase);
    private sealed virtual override bool System.ServiceModel.Dispatcher.IErrorHandler.HandleError(Exception error);
    private sealed virtual override void System.ServiceModel.Dispatcher.IErrorHandler.ProvideFault(Exception error, MessageVersion version, Message& message);
    private static void AddMessageInspectors(EndpointDispatcher endpointDispatcher);
    private void ProvideFault(Exception exception, MessageVersion version, Message& message);
    protected virtual FaultException OnProvideFaultException(ServiceExceptionFaultProviderEventArgs args);
    public static FaultException WrapException(Exception exception, ReportingInfo errorReport);
}
public class Holzer.Services.ServiceExceptionFaultProviderEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private Exception <Exception>k__BackingField;
    [CompilerGeneratedAttribute]
private ReportingInfo <ErrorReport>k__BackingField;
    [CompilerGeneratedAttribute]
private Message <Message>k__BackingField;
    public Exception Exception { get; public set; }
    public ReportingInfo ErrorReport { get; public set; }
    public Message Message { get; public set; }
    [CompilerGeneratedAttribute]
public Exception get_Exception();
    [CompilerGeneratedAttribute]
public void set_Exception(Exception value);
    [CompilerGeneratedAttribute]
public ReportingInfo get_ErrorReport();
    [CompilerGeneratedAttribute]
public void set_ErrorReport(ReportingInfo value);
    [CompilerGeneratedAttribute]
public Message get_Message();
    [CompilerGeneratedAttribute]
public void set_Message(Message value);
}
[DataContractAttribute]
public class Holzer.Services.ServicePortInfo : object {
    [CompilerGeneratedAttribute]
private string <PermanentResourceIdentifier>k__BackingField;
    [CompilerGeneratedAttribute]
private ServiceApplicationInstanceInfo <ApplicationInstance>k__BackingField;
    [CompilerGeneratedAttribute]
private ServiceAddressInfo <Adressing>k__BackingField;
    [CompilerGeneratedAttribute]
private ServiceContractMetaInfo <Contract>k__BackingField;
    [DataMemberAttribute]
public string PermanentResourceIdentifier { get; public set; }
    [DataMemberAttribute]
public ServiceApplicationInstanceInfo ApplicationInstance { get; public set; }
    [DataMemberAttribute]
public ServiceAddressInfo Adressing { get; public set; }
    [DataMemberAttribute]
public ServiceContractMetaInfo Contract { get; public set; }
    public ServicePortInfo(string permanentResourceIdentifier, ServiceContractMetaInfo contract, ServiceAddressInfo addressing, ServiceApplicationInstanceInfo applicationInstance);
    public ServicePortInfo(ServiceContractMetaInfo contract, ServiceAddressInfo addressing);
    [CompilerGeneratedAttribute]
public string get_PermanentResourceIdentifier();
    [CompilerGeneratedAttribute]
public void set_PermanentResourceIdentifier(string value);
    [CompilerGeneratedAttribute]
public ServiceApplicationInstanceInfo get_ApplicationInstance();
    [CompilerGeneratedAttribute]
public void set_ApplicationInstance(ServiceApplicationInstanceInfo value);
    [CompilerGeneratedAttribute]
public ServiceAddressInfo get_Adressing();
    [CompilerGeneratedAttribute]
public void set_Adressing(ServiceAddressInfo value);
    [CompilerGeneratedAttribute]
public ServiceContractMetaInfo get_Contract();
    [CompilerGeneratedAttribute]
public void set_Contract(ServiceContractMetaInfo value);
}
public class Holzer.Services.ServiceTelemetryBehaviorAttribute : Attribute {
    private bool writeServiceRequestTelemetry;
    public ServiceTelemetryBehaviorAttribute(bool writeServiceRequestTelemetry);
    private sealed virtual override void System.ServiceModel.Description.IServiceBehavior.AddBindingParameters(ServiceDescription serviceDescription, ServiceHostBase serviceHostBase, Collection`1<ServiceEndpoint> endpoints, BindingParameterCollection bindingParameters);
    private sealed virtual override void System.ServiceModel.Description.IServiceBehavior.ApplyDispatchBehavior(ServiceDescription serviceDescription, ServiceHostBase serviceHostBase);
    private sealed virtual override void System.ServiceModel.Description.IServiceBehavior.Validate(ServiceDescription serviceDescription, ServiceHostBase serviceHostBase);
    private sealed virtual override bool System.ServiceModel.Dispatcher.IErrorHandler.HandleError(Exception error);
    private sealed virtual override void System.ServiceModel.Dispatcher.IErrorHandler.ProvideFault(Exception error, MessageVersion version, Message& message);
    private void AddMessageInspectors(EndpointDispatcher endpointDispatcher);
    private void ProvideFault(Exception error, MessageVersion version, Message& message);
}
public class Holzer.Services.ServiceTelemetryMessageInspector : object {
    public static string RayIdHeader;
    private static int MaxRequestLogLength;
    private static TelemetryFlag telemetryFlag;
    private bool writeServiceRequestTelemetry;
    public ServiceTelemetryMessageInspector(bool writeServiceRequestTelemetry);
    private static ServiceTelemetryMessageInspector();
    public sealed virtual object AfterReceiveRequest(Message& request, IClientChannel channel, InstanceContext instanceContext);
    public sealed virtual void BeforeSendReply(Message& reply, object correlationState);
}
internal class Holzer.Services.ServiceTelemetryMessageInspectorState : object {
    [CompilerGeneratedAttribute]
private DateTime <Start>k__BackingField;
    [CompilerGeneratedAttribute]
private Stopwatch <Stopwatch>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RayId>k__BackingField;
    [CompilerGeneratedAttribute]
private LoginTicket <Actor>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DeviceId>k__BackingField;
    public DateTime Start { get; }
    public Stopwatch Stopwatch { get; }
    public string RayId { get; }
    public LoginTicket Actor { get; }
    public string DeviceId { get; }
    public ServiceTelemetryMessageInspectorState(DateTime utcNow, Stopwatch stopwatch, string rayId, LoginTicket actor, string deviceId);
    [CompilerGeneratedAttribute]
public DateTime get_Start();
    [CompilerGeneratedAttribute]
public Stopwatch get_Stopwatch();
    [CompilerGeneratedAttribute]
public string get_RayId();
    [CompilerGeneratedAttribute]
public LoginTicket get_Actor();
    [CompilerGeneratedAttribute]
public string get_DeviceId();
}
public class Holzer.Sessions.ChangeSetContext : object {
    private static string LogicalCallContextDataName;
    private bool disallowedRemotingTransfer;
    private bool isThreadContext;
    private ChangeSetContext outerThreadContext;
    private DisposableObject disposable;
    private long changeSetId;
    public static ChangeSetContext ThreadContext { get; internal set; }
    public long ChangeSetId { get; }
    protected ChangeSetContext(SerializationInfo info, StreamingContext context);
    private ChangeSetContext(long changeSetId, bool isThreadContext, ChangeSetContext outerThreadContext);
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
    private static bool IsAcceptableContextTransfer(StreamingContextStates state);
    public static ChangeSetContext get_ThreadContext();
    internal static void set_ThreadContext(ChangeSetContext value);
    public static ChangeSetContext BeginOnCurrentThread(long changeSetId);
    public sealed virtual void Dispose();
    public long get_ChangeSetId();
}
[ExtensionAttribute]
public static class Holzer.Sessions.DataAccessExtensions : object {
    [ExtensionAttribute]
public static TKey Save(IDataAccessComponent`2<TKey, TData> d, SessionContext session, TData data);
    [AsyncStateMachineAttribute("Holzer.Sessions.DataAccessExtensions/<SaveAsync>d__1`2")]
[ExtensionAttribute]
public static Task`1<TKey> SaveAsync(IDataAccessComponentAsync`2<TKey, TData> d, SessionContext session, TData data, CancellationToken cancellation);
    [ExtensionAttribute]
public static void Save(IDataAccessComponent`2<TKey, TData> d, SessionContext session, TKey insertKey, TData data);
    [AsyncStateMachineAttribute("Holzer.Sessions.DataAccessExtensions/<SaveAsync>d__3`2")]
[ExtensionAttribute]
public static Task SaveAsync(IDataAccessComponentAsync`2<TKey, TData> d, SessionContext session, TKey insertKey, TData data, CancellationToken cancellation);
}
public interface Holzer.Sessions.ISessionObject {
    public abstract virtual void Commit();
}
public class Holzer.Sessions.SessionContext : object {
    private static string LogicalCallContextDataName;
    private static int CollectInterval;
    private static List`1<SessionContext> activeSessionsWithMaximumLifetimeLimit;
    private static Thread collectorThread;
    private static long lastCollection;
    private static int defaultMaximumLifetimeforRemoteContext;
    private bool disallowedRemotingTransfer;
    private bool isThreadContext;
    private SessionContext outerThreadContext;
    private long created;
    private DisposableObject disposable;
    private int maximumLifetimeSeconds;
    private bool disposedByGarbageCollector;
    private AuditChangeSetInfo changeSetInfo;
    private Nullable`1<IsolationLevel> isolationLevel;
    private int commandTimeout;
    private Dictionary`2<string, IDbConnection> databaseConnections;
    private SemaphoreSlim databaseConnectionsLock;
    private IDbTransaction databaseTransaction;
    private Dictionary`2<TransactionHandler, TransactionSubInfo> beforeCommitSubscriptionsUnique;
    private List`1<TransactionSubInfo> beforeCommitSubscriptionsList;
    private Dictionary`2<TransactionHandler, TransactionSubInfo> afterCommitSubscriptionsUnique;
    private List`1<TransactionSubInfo> afterCommitSubscriptionsList;
    private bool databaseTransactionClosedWithRollbackOrCommit;
    private bool transacted;
    private bool committed;
    private bool appendUserInfo;
    private SessionContextData data;
    [CompilerGeneratedAttribute]
private EventHandler Disposed;
    public static int DefaultMaximumLifetimeForRemoteContexts { get; public set; }
    public static SessionContext ThreadContext { get; internal set; }
    public int CommandTimeout { get; public set; }
    public Nullable`1<IsolationLevel> TransactionIsolationLevel { get; public set; }
    public int MaximumLifetimeInSeconds { get; }
    public long CurrentLifetimeInSeconds { get; }
    public bool Transacted { get; public set; }
    public bool Committed { get; }
    public bool AppendUserInfo { get; public set; }
    public bool HasData { get; }
    public SessionContextData Data { get; }
    public bool TransactionOpened { get; }
    public SessionContext(SerializationInfo info, StreamingContext context);
    internal SessionContext(bool transacted, bool isThreadContext, SessionContext outerThreadContext, Nullable`1<int> changeActionId);
    internal SessionContext(IsolationLevel isolationLevel, bool isThreadContext, SessionContext outerThreadContext, Nullable`1<int> changeActionId);
    internal SessionContext(bool transacted, Nullable`1<IsolationLevel> isolationLevel, int maximumLifetimeSeconds, bool isThreadContext, SessionContext outerThreadContext, Nullable`1<int> changeActionId);
    private static SessionContext();
    public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    private static bool IsAcceptableContextTransfer(StreamingContextStates state);
    public static int get_DefaultMaximumLifetimeForRemoteContexts();
    public static void set_DefaultMaximumLifetimeForRemoteContexts(int value);
    private static void EnsureCollectorThread();
    private static void CollectThread();
    private static void GarbageCollect();
    private static void AsyncDispose(object state);
    private static long GetCollectionTime();
    public static int GetActiveSessionsWithMaximumLifetimeLimit();
    public static SessionContext GetCurrent(SessionContext sessionContextOverride, bool throwIfNull);
    public static SessionContext get_ThreadContext();
    internal static void set_ThreadContext(SessionContext value);
    public static SessionContext BeginOnCurrentThread(bool transacted, Nullable`1<int> changeActionId);
    public static SessionContext BeginOnCurrentThread(IsolationLevel isolationLevel, Nullable`1<int> changeActionId);
    public static SessionContext Begin(bool transacted, Nullable`1<int> changeActionId);
    public static SessionContext Begin(IsolationLevel isolationLevel, Nullable`1<int> changeActionId);
    public static SessionContext BeginOnCurrentThread(bool transacted);
    public static SessionContext BeginOnCurrentThread(IsolationLevel isolationLevel);
    public static SessionContext Begin(bool transacted);
    public static SessionContext Begin(IsolationLevel isolationLevel);
    public static SessionContext BeginTransacted(Nullable`1<int> changeActionId);
    public static SessionContext BeginRead();
    public static SessionContext BeginReadOnCurrentThread(Nullable`1<int> changeActionId);
    public static SessionContext Require(SessionContext session);
    public IDbConnection GetDatabaseConnection(string nonTranslatedConnectionString);
    [AsyncStateMachineAttribute("Holzer.Sessions.SessionContext/<GetDatabaseConnectionAsync>d__60")]
public Task`1<IDbConnection> GetDatabaseConnectionAsync(CancellationToken cancellation, string nonTranslatedConnectionString);
    public int GetTransactionCount();
    public IDbTransaction GetDatabaseTransaction(string nonTranslatedConnectionString);
    public IDbTransaction GetDatabaseTransaction(IDbConnection connection, string nonTranslatedConnectionString);
    private void CheckTransacted();
    public virtual void Commit();
    public virtual void Rollback();
    private void OnBeforeCommit();
    private void OnAfterCommit();
    private Exception CommitDatabaseTransactions();
    private Exception RollbackDatabaseTransactions();
    public sealed virtual void Dispose();
    private void DisposeCore(bool disposedByGarbageCollector);
    [CompilerGeneratedAttribute]
public void add_Disposed(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_Disposed(EventHandler value);
    public void Subscribe(TransactionSubscription type, Action handler, object state, bool onePerHandler);
    public void Subscribe(TransactionSubscription type, TransactionHandler handler, object state, bool onePerHandler);
    internal bool IsExpired();
    public int get_CommandTimeout();
    public void set_CommandTimeout(int value);
    public Nullable`1<IsolationLevel> get_TransactionIsolationLevel();
    public void set_TransactionIsolationLevel(Nullable`1<IsolationLevel> value);
    public int get_MaximumLifetimeInSeconds();
    public long get_CurrentLifetimeInSeconds();
    public bool get_Transacted();
    public void set_Transacted(bool value);
    public bool get_Committed();
    public bool get_AppendUserInfo();
    public void set_AppendUserInfo(bool value);
    public bool get_HasData();
    public SessionContextData get_Data();
    public static SessionContextState SuppressFlow();
    public bool get_TransactionOpened();
}
[DefaultMemberAttribute("Item")]
public class Holzer.Sessions.SessionContextData : object {
    private Dictionary`2<string, object> data;
    public object Item { get; public set; }
    public object get_Item(string key);
    public void set_Item(string key, object value);
}
public class Holzer.Sessions.SessionContextState : object {
    private SessionContext session;
    internal SessionContextState(SessionContext session);
    public void RestoreFlow();
}
public class Holzer.Sessions.SessionScope : object {
    private bool owner;
    private bool disposed;
    [ThreadStaticAttribute]
private static Dictionary`2<string, ISessionObject> sessionObjects;
    [ThreadStaticAttribute]
private static List`1<SessionScope> scopes;
    [ThreadStaticAttribute]
private static bool useTransactions;
    public static bool UseTransactions { get; }
    public SessionScope Current { get; }
    public SessionScope(bool useTransactions);
    private void UpgradeToTransactions();
    public static bool get_UseTransactions();
    public SessionScope get_Current();
    public static TSessionObject GetState();
    public sealed virtual void Dispose();
    public void Commit();
    private void Unlink();
    private void ValidateScope();
}
public abstract class Holzer.SortOptionBase : SearchOption {
}
public enum Holzer.SortOrder : Enum {
    public byte value__;
    public static SortOrder Ascending;
    public static SortOrder Descending;
}
public class Holzer.Text.InputParser : object {
    public static RegistrationNumberVerificationResult VerifyRegistrationNumber(string number, RegistrationNumberFormat format, Språk språk);
    public static Nullable`1<DateTime> ParseRegistrationNumberDate(string number, RegistrationNumberFormat format);
    private static bool IsValidMod10CheckSum(string number);
}
public class Holzer.Text.InputType : object {
    private static Dictionary`2<string, InputType> types;
    private string name;
    private string formatErrorMessage;
    private string regularExpression;
    private string cleanType;
    public string TypeName { get; }
    public string CleanType { get; }
    public string RegularExpression { get; }
    public static InputType Integer { get; }
    public static InputType Date { get; }
    public static InputType Year { get; }
    public static InputType Decimal { get; }
    public static InputType Email { get; }
    public static InputType Time { get; }
    public static InputType FirstName { get; }
    public static InputType LastName { get; }
    public static InputType Phone { get; }
    public static InputType Address { get; }
    public static InputType ShortUsername { get; }
    public static InputType LongUsername { get; }
    public static InputType LongString { get; }
    private static InputType();
    public InputType(string name, RegularExpressionType regularExpressionType);
    public InputType(string name, string formatErrorMessage, string regularExpression, string cleanType);
    private static void AddType(RegularExpressionType regularExpressionType);
    public static void AddType(string inputTypeName, RegularExpressionType regularExpressionType);
    public static void AddType(InputType inputTypeInfo);
    public static InputType GetType(string inputTypeName);
    public InputType Derive(string errorMessage);
    public virtual bool IsValid(string value);
    public virtual string Clean(string value);
    public string get_TypeName();
    public string get_CleanType();
    public string get_RegularExpression();
    public string GetErrorMessage(string fieldName);
    public static InputType get_Integer();
    public static InputType get_Date();
    public static InputType get_Year();
    public static InputType get_Decimal();
    public static InputType get_Email();
    public static InputType get_Time();
    public static InputType get_FirstName();
    public static InputType get_LastName();
    public static InputType get_Phone();
    public static InputType get_Address();
    public static InputType get_ShortUsername();
    public static InputType get_LongUsername();
    public static InputType get_LongString();
}
public enum Holzer.Text.KompileringTyp : Enum {
    public byte value__;
    public static KompileringTyp Realtid;
    public static KompileringTyp Tidsstyrd;
    public static KompileringTyp Full;
    public static KompileringTyp Köad;
}
public class Holzer.Text.ParseHelper : object {
    public static bool IsInt(string s);
    public static int ParseInt(string s);
    public static int ParseInt(string s, int valueIfNoneInt);
    public static Nullable`1<int> ParseIntNullable(string s);
    public static bool TryParseNullable(string text, Nullable`1& value);
    public static bool TryParseNullable(string text, Nullable`1& value);
    public static bool TryParseNullable(string text, Nullable`1& value);
    public static string ParseIntToColorHex(Nullable`1<int> value);
}
public enum Holzer.Text.RegistrationNumberFormat : Enum {
    public int value__;
    public static RegistrationNumberFormat Unknown;
    public static RegistrationNumberFormat CompanySwedish;
    public static RegistrationNumberFormat CivicSwedish;
    public static RegistrationNumberFormat CivicBirthdate;
}
public class Holzer.Text.RegistrationNumberVerificationResult : object {
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ErrorCode>k__BackingField;
    [CompilerGeneratedAttribute]
private RegistrationNumberVerificationResultType <Type>k__BackingField;
    public string Message { get; public set; }
    public string ErrorCode { get; public set; }
    public RegistrationNumberVerificationResultType Type { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
public void set_Message(string value);
    [CompilerGeneratedAttribute]
public string get_ErrorCode();
    [CompilerGeneratedAttribute]
public void set_ErrorCode(string value);
    [CompilerGeneratedAttribute]
public RegistrationNumberVerificationResultType get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(RegistrationNumberVerificationResultType value);
}
public enum Holzer.Text.RegistrationNumberVerificationResultType : Enum {
    public int value__;
    public static RegistrationNumberVerificationResultType Godkänd;
    public static RegistrationNumberVerificationResultType EjGodkänd;
    public static RegistrationNumberVerificationResultType EjValiderad;
    public static RegistrationNumberVerificationResultType Ofullständigt;
    public static RegistrationNumberVerificationResultType Varning;
}
public abstract class Holzer.Text.RegularExpression : object {
    private static string datePattern;
    private static string dateTimePattern;
    private static string yearPattern;
    private static string intPattern;
    private static string decimalPattern;
    private static string numberPattern;
    private static string emailPattern;
    private static string timePattern;
    private static string civicRegistrationNumberPatternSwedish;
    private static string civicRegistrationNumberPatternBirthDate;
    private static string orgRegistrationNumberPatternSwedish;
    private static string orgRegistrationNumberPatternUnknown;
    private static string phoneNumberPattern;
    private static string mobilePhoneNumerPattern;
    private static string nameCharacters;
    private static string firstNamePattern;
    private static string generalNamePattern;
    private static string lastNamePattern;
    private static string fullNamePattern;
    private static string hostPattern;
    private static string addressPattern;
    private static string postCodePattern;
    private static string postCodePatternSwedish;
    private static string postCodePatternFinish;
    private static string postCodePatternDanish;
    private static string postCodePatternNorway;
    private static string cityPattern;
    private static string shortUsernamePattern;
    private static string longUsernamePattern;
    private static string longStringPattern;
    private static string stringPattern;
    public static string Get(RegularExpressionType type);
    public static string GetJsFunctionReference(RegularExpressionType type);
    public static string GetErrorMessage(string fieldName, RegularExpressionType type);
    public static string GetRegistrationNumber(RegistrationNumberFormat format);
    public static bool IsValidDate(string dateStr);
    public static bool IsValidDateTime(string dateTimeStr);
    public static bool IsValidYear(string yearStr);
    public static bool IsValidInt(string intStr);
    public static string CleanInt(string text);
    public static bool IsValidDecimal(string decStr);
    public static bool IsValidNumber(string numStr);
    public static bool IsValidEmail(string emailStr);
    public static bool IsValidTime(string timeStr);
    public static string CleanTime(string timeStr);
    public static string CleanDate(string dateStr);
    public static bool IsValidPhoneNumber(string text);
    public static bool IsValidMobilePhoneNumber(string text);
    public static string CleanPhoneNumber(string text);
    public static string CleanMobilePhoneNumber(string text);
    public static bool IsValidName(string text);
    public static bool IsValidFirstName(string text);
    public static bool IsValidLastName(string text);
    public static bool IsValidFullName(string text);
    public static bool IsValidHost(string text);
    public static bool IsValidAddress(string text);
    public static string CleanPostCode(string text, string countryCode);
    public static string GetPostcodeExample(string countryCode);
    public static bool IsValidPostCode(string text, string countryCode);
    public static bool IsValidCity(string text);
    public static bool IsEmpty(string text);
    public static string CleanRegistrationNumber(string number, RegistrationNumberFormat format, bool removeDashes);
    public static string SkapaKontrollSiffra(string nummer);
    public static string CleanRegistrationNumber(string number);
    public static bool HasValue(string text);
    public static string CleanEmpty(string text);
    protected static string GetDateRegex();
    protected static string GetDateTimeRegex();
    protected static string GetYearRegex();
    protected static string GetIntRegex();
    protected static string GetDecimalRegex();
    protected static string GetNumberRegex();
    protected static string GetEmailRegex();
    protected static string GetTimeRegex();
}
public enum Holzer.Text.RegularExpressionType : Enum {
    public int value__;
    public static RegularExpressionType Date;
    public static RegularExpressionType Int;
    public static RegularExpressionType Decimal;
    public static RegularExpressionType Number;
    public static RegularExpressionType Email;
    public static RegularExpressionType Time;
    public static RegularExpressionType FirstName;
    public static RegularExpressionType LastName;
    public static RegularExpressionType Phone;
    public static RegularExpressionType Address;
    public static RegularExpressionType ShortUsername;
    public static RegularExpressionType LongUsername;
    public static RegularExpressionType LongString;
    public static RegularExpressionType CivicRegNrSwedish;
    public static RegularExpressionType CivicRegNrBirthDate;
    public static RegularExpressionType OrgRegNrSwedish;
    public static RegularExpressionType OrgRegNrForeign;
    public static RegularExpressionType Year;
    public static RegularExpressionType String;
    public static RegularExpressionType Custom;
    public static RegularExpressionType DateTime;
}
public class Holzer.Text.StringHelper : object {
    public static string Join(string separator, String[] parts);
    public static string JoinSkipEmpty(string separator, String[] parts);
    public static String[] Split(string s, string separator);
    public static IEnumerable`1<string> SplitStream(string s, string separator);
    public static String[] Split(string s, string separator, int start, bool removeEmptyEntries);
    [IteratorStateMachineAttribute("Holzer.Text.StringHelper/<SplitStream>d__6")]
public static IEnumerable`1<string> SplitStream(string s, string separator, int start, bool removeEmptyEntries);
    public static string TrimLength(string value, int maximumLength, bool addEllipsis);
}
public static class Holzer.Text.TextConvert : object {
    private static String[] hextable;
    public static string DateFormattingString;
    public static string DateTimeFormattingString;
    private static string base16;
    private static TextConvert();
    public static string ToDate(DateTime dateTime);
    public static string ToDateTime(DateTime dateTime);
    public static string ToByteString(Nullable`1<long> value);
    public static string ToByteStringMega(Nullable`1<long> value);
    public static string ToByteStringKilo(Nullable`1<long> value);
    public static Nullable`1<int> ToIntNullable(string text);
    public static Nullable`1<long> ToLongNullable(string text);
    public static string ToHexString(Byte[] buffer);
    public static string ToBase16String(Byte[] ba);
    public static string ToBase64StringWeb(Byte[] v);
    public static string ToBase64StringWeb(string v);
    public static string FromBase64StringWebToString(string v);
    public static string ValueListToString(IEnumerable`1<T> valueList);
}
public enum Holzer.Text.TextEncoding : Enum {
    public int value__;
    public static TextEncoding Utf8;
    public static TextEncoding Unicode;
    public static TextEncoding Ascii;
}
public class Holzer.Text.TextEncodingConvert : object {
    public static Encoding ToEncoding(TextEncoding encoding);
}
public class Holzer.Text.TypedParser`1 : MulticastDelegate {
    public TypedParser`1(object object, IntPtr method);
    public virtual TValue Invoke(string data);
    public virtual IAsyncResult BeginInvoke(string data, AsyncCallback callback, object object);
    public virtual TValue EndInvoke(IAsyncResult result);
}
public class Holzer.Threading.DisposableObject : object {
    private string name;
    private bool threadSafe;
    private bool disposing;
    private bool disposed;
    private bool disposedByGarbageCollector;
    private long created;
    private long disposedAt;
    public bool IsDisposing { get; }
    public bool IsDisposed { get; }
    public DisposableObject(Type ownerType, bool threadSafe);
    public void CheckDisposing();
    public bool get_IsDisposing();
    public bool get_IsDisposed();
    internal void CheckDisposed();
    public bool BeginDispose();
    public bool BeginDispose(bool disposedByGarbageCollector);
    private bool BeginDisposeCore(bool disposedByGarbageCollector);
    public void EndDispose();
}
public class Holzer.Threading.InvokeWithRetryResult : object {
    [CompilerGeneratedAttribute]
private Exception <Exception>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsSuccessful>k__BackingField;
    [CompilerGeneratedAttribute]
private int <FailedAttempts>k__BackingField;
    public Exception Exception { get; public set; }
    public bool IsSuccessful { get; public set; }
    public int FailedAttempts { get; public set; }
    [CompilerGeneratedAttribute]
public Exception get_Exception();
    [CompilerGeneratedAttribute]
public void set_Exception(Exception value);
    [CompilerGeneratedAttribute]
public bool get_IsSuccessful();
    [CompilerGeneratedAttribute]
public void set_IsSuccessful(bool value);
    [CompilerGeneratedAttribute]
public int get_FailedAttempts();
    [CompilerGeneratedAttribute]
public void set_FailedAttempts(int value);
}
public class Holzer.Threading.InvokeWithRetryResult`1 : InvokeWithRetryResult {
    [CompilerGeneratedAttribute]
private TResult <ReturnValue>k__BackingField;
    public TResult ReturnValue { get; public set; }
    [CompilerGeneratedAttribute]
public TResult get_ReturnValue();
    [CompilerGeneratedAttribute]
public void set_ReturnValue(TResult value);
}
public interface Holzer.Threading.IWorker {
    public abstract virtual void DoWork(object state);
}
public static class Holzer.Threading.ThreadHelper : object {
    public static void RunInParallel(IList`1<Action> tasks);
    private static Exception RunTask(Exception firstError, Action task);
    public static InvokeWithRetryResult InvokeWithRetryQuick(Action a, int retryAttempts, int waitOnFailure, Nullable`1<int> waitOnFailureRandomRange, bool throwOnError, bool reportErrors, Func`2<Exception, bool> failImmediatelyWhen);
    public static InvokeWithRetryResult`1<TResult> InvokeWithRetryQuickResult(Func`1<TResult> a, int retryAttempts, int waitOnFailure, Nullable`1<int> waitOnFailureRandomRange, bool throwOnError, bool reportErrors, Func`2<Exception, bool> failImmediatelyWhen);
    public static Task`1<InvokeWithRetryResult> InvokeWithRetryQuickAsync(Func`1<Task> a, int retryAttempts, int waitOnFailure, int waitOnFailureRandomRange, bool throwOnError, bool reportErrors, Func`2<Exception, bool> failImmediatelyWhen);
    public static InvokeWithRetryResult InvokeWithRetry(Action a, int retryAttempts, int waitOnFailure, Nullable`1<int> waitOnFailureRandomRange, bool throwOnError, bool reportErrors, Func`2<Exception, bool> failImmediatelyWhen);
    public static InvokeWithRetryResult`1<TResult> InvokeWithRetry(Func`1<TResult> a, int retryAttempts, int waitOnFailure, Nullable`1<int> waitOnFailureRandomRange, bool throwOnError, bool reportErrors, Func`2<Exception, bool> failImmediatelyWhen);
    [AsyncStateMachineAttribute("Holzer.Threading.ThreadHelper/<InvokeWithRetryAsync>d__7")]
public static Task`1<InvokeWithRetryResult> InvokeWithRetryAsync(Func`1<Task> a, int attempts, int waitOnFailure, int waitOnFailureRandomRange, bool throwOnError, bool reportAbsorbedErrors, Func`2<Exception, bool> failImmediatelyWhen);
    [AsyncStateMachineAttribute("Holzer.Threading.ThreadHelper/<InvokeWithRetryAsync>d__8`1")]
public static Task`1<InvokeWithRetryResult`1<TResult>> InvokeWithRetryAsync(Func`1<Task`1<TResult>> a, int attempts, int waitOnFailure, int waitOnFailureRandomRange, bool throwOnError, bool reportAbsorbedErrors, Func`2<Exception, bool> failImmediatelyWhen);
}
public static class Holzer.Threading.WorkerPool : object {
    private static Dictionary`2<WorkPriority, WorkerPoolQueue> workQueues;
    private static WorkerPoolQueue[] workQueueArray;
    private static List`1<WorkerThread> workerThreads;
    private static int divider;
    private static WorkerPool();
    private static void CreateQueue(WorkPriority workPriority);
    private static int GetNumberOfThreads(WorkPriority workPriority);
    internal static WorkItem Dequeue(WorkPriority priority);
    internal static WorkItem Dequeue();
    public static void Enqueue(WorkPriority priority, IWorker worker, object state);
    public static void Enqueue(WorkPriority priority, WorkHandler work, object state);
}
internal class Holzer.Threading.WorkerPoolQueue : object {
    private WorkPriority workPriority;
    private Queue`1<WorkItem> workers;
    private KeyDictionary`1<WorkItem> workersByWorker;
    public WorkerPoolQueue(WorkPriority workPriority);
    internal WorkItem Dequeue();
    internal void Enqueue(WorkItem worker);
}
internal class Holzer.Threading.WorkerThread : object {
    private WorkPriority priority;
    private Thread thread;
    public WorkerThread(WorkPriority priority);
    private void Run();
}
public class Holzer.Threading.WorkHandler : MulticastDelegate {
    public WorkHandler(object object, IntPtr method);
    public virtual void Invoke(object state);
    public virtual IAsyncResult BeginInvoke(object state, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class Holzer.Threading.WorkHandlerProxy : object {
    private WorkHandler work;
    public WorkHandlerProxy(WorkHandler work);
    public sealed virtual void DoWork(object state);
}
internal class Holzer.Threading.WorkItem : object {
    private IWorker worker;
    private object state;
    public IWorker Worker { get; }
    public object State { get; }
    public WorkItem(IWorker worker, object state);
    public IWorker get_Worker();
    public object get_State();
}
public enum Holzer.Threading.WorkPriority : Enum {
    public int value__;
    public static WorkPriority VeryHigh;
    public static WorkPriority High;
    public static WorkPriority Medium;
    public static WorkPriority BelowMedium;
    public static WorkPriority Low;
    public static WorkPriority Lowest;
}
public class Holzer.TopFilterOption : SearchOption {
    private int top;
    public int Top { get; }
    public TopFilterOption(int top);
    public int get_Top();
    public sealed virtual void BuildTo(Hashtable namedParameters);
}
public class Holzer.Transaction : SessionContext {
    public Transaction(Nullable`1<IsolationLevel> iso);
    public Transaction(Nullable`1<IsolationLevel> iso, int maximumLifetimeSeconds);
    public Transaction(int maximumLifetimeSeconds);
}
public class Holzer.Transactions.RemoteTransaction : Transaction {
    public RemoteTransaction(Nullable`1<IsolationLevel> isolationLevel);
    public RemoteTransaction(Nullable`1<IsolationLevel> isolationLevel, int maximumLifetimeForRemoteContext);
}
public class Holzer.Transactions.TransactionHandler : MulticastDelegate {
    public TransactionHandler(object object, IntPtr method);
    public virtual void Invoke(TransactionSubscription type, SessionContext sessionContext, object state);
    public virtual IAsyncResult BeginInvoke(TransactionSubscription type, SessionContext sessionContext, object state, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public enum Holzer.Transactions.TransactionSubscription : Enum {
    public byte value__;
    public static TransactionSubscription BeforeCommit;
    public static TransactionSubscription AfterCommit;
}
public abstract class Holzer.TypedDataReaderBase : object {
    private SqlDataReader reader;
    protected TypedDataReaderBase(SqlDataReader reader);
    private void Populate(bool read, bool closed);
    protected abstract virtual void OnPopulate(SqlDataReader reader);
    protected abstract virtual void Clear();
    public bool NextResult();
    public bool Read();
    public void Close();
    public sealed virtual IEnumerator GetEnumerator();
    private object GetCurrentPrivate();
    protected abstract virtual object GetCurrent();
    public sealed virtual void Dispose();
}
public abstract class Holzer.TypedDataSetBase : DataSet {
    protected DataTable defaultTable;
    public DataTable DefaultTable { get; }
    protected abstract virtual DataTable CreateTable();
    public DataTable get_DefaultTable();
    public void Fill(SqlCommand selectCommand);
}
public class Holzer.TypedParameter : object {
    private string key;
    private object value;
    public string Key { get; }
    public object Value { get; }
    public TypedParameter(string key, object value);
    public string get_Key();
    public object get_Value();
}
[DefaultMemberAttribute("Item")]
public class Holzer.TypedParameterCollection : object {
    private HybridDictionary typedParameters;
    public object Item { get; public set; }
    public TypedParameterCollection(int d);
    public object get_Item(string key);
    public void set_Item(string key, object value);
    public void Add(string key, object value);
    public static TypedParameterCollection Parse(TypedParameter[] typedParameters);
    public static TypedParameterCollection Parse(string typedParameterString);
    public sealed virtual IEnumerator GetEnumerator();
}
public class Holzer.Web.Url : object {
    public static string TrimEndingSlash(string url);
    public static string EndingSlash(string url);
    public static string Combine(string url1, string url2);
    public static string AppendParameters(string url, string parameters);
    public static string TrimParameters(string url, string name);
}
public static class Holzer.Web.WebLinkTarget : object {
    public static string ToString(WebLinkTargetType type);
}
public enum Holzer.Web.WebLinkTargetType : Enum {
    public int value__;
    public static WebLinkTargetType Blank;
    public static WebLinkTargetType Parent;
    public static WebLinkTargetType Self;
    public static WebLinkTargetType Top;
}
public class Holzer.XmlHelper : object {
    public static string ToHtml(string s);
    public static string ToXml(string s);
    public static string ToString(string xml);
    public static string ToXmlUtc(DateTime utc);
    public static string ReadRequiredAttribute(XmlNode section, string name);
    public static int ReadRequiredAttributeInt(XmlNode section, string name);
    public static long ReadRequiredAttributeLong(XmlNode section, string name);
    public static XmlNodeList ReadOptionalNodes(XmlNode section, string name);
    public static XmlNode ReadRequiredNode(XmlNode section, string name);
    public static int ReadOptionalAttributeInt(XmlNode section, string name, int defaultValue);
    public static bool ReadOptionalAttributeBool(XmlNode section, string name, bool defaultValue);
    public static double ReadOptionalAttributeDouble(XmlNode section, string name, double defaultValue);
    public static string ReadOptionalAttribute(XmlNode section, string name, string defaultValue);
    public static string ReadOptionalAttribute(XmlNode section, string name);
}
[ExtensionAttribute]
public static class Momentum.Collections.CollectionExtensions : object {
    [ExtensionAttribute]
public static TValue TryGetValueDefault(Dictionary`2<TKey, TValue> dict, TKey key);
}
public static class Momentum.Common.Api.ErrorHandling.ApiErrorResponseBuilder : object {
    [CompilerGeneratedAttribute]
private static Func`2<string, bool> <IsApiRequest>k__BackingField;
    [CompilerGeneratedAttribute]
private static Func`3<string, ErrorTranslation, EncodedError> <EncodeError>k__BackingField;
    public static Func`2<string, bool> IsApiRequest { get; public set; }
    public static Func`3<string, ErrorTranslation, EncodedError> EncodeError { get; public set; }
    [CompilerGeneratedAttribute]
public static Func`2<string, bool> get_IsApiRequest();
    [CompilerGeneratedAttribute]
public static void set_IsApiRequest(Func`2<string, bool> value);
    [CompilerGeneratedAttribute]
public static Func`3<string, ErrorTranslation, EncodedError> get_EncodeError();
    [CompilerGeneratedAttribute]
public static void set_EncodeError(Func`3<string, ErrorTranslation, EncodedError> value);
}
public class Momentum.Common.Api.ErrorHandling.EncodedError : object {
    [CompilerGeneratedAttribute]
private string <ContentType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Content>k__BackingField;
    public string ContentType { get; public set; }
    public string Content { get; public set; }
    [CompilerGeneratedAttribute]
public string get_ContentType();
    [CompilerGeneratedAttribute]
public void set_ContentType(string value);
    [CompilerGeneratedAttribute]
public string get_Content();
    [CompilerGeneratedAttribute]
public void set_Content(string value);
}
public class Momentum.Common.Api.ErrorHandling.ErrorTranslation : object {
    [CompilerGeneratedAttribute]
private HttpStatusCode <HttpStatus>k__BackingField;
    [CompilerGeneratedAttribute]
private ApiError <Error>k__BackingField;
    public HttpStatusCode HttpStatus { get; }
    public ApiError Error { get; }
    public ErrorTranslation(HttpStatusCode status, ApiError error);
    [CompilerGeneratedAttribute]
public HttpStatusCode get_HttpStatus();
    [CompilerGeneratedAttribute]
public ApiError get_Error();
}
public static class Momentum.Common.Api.ErrorHandling.ErrorTranslator : object {
    private static IErrorTranslatorService defaultService;
    public static IErrorTranslatorService Default { get; public set; }
    private static ErrorTranslator();
    public static IErrorTranslatorService get_Default();
    public static void set_Default(IErrorTranslatorService value);
}
public class Momentum.Common.Api.ErrorHandling.ErrorTranslatorService : object {
    private List`1<Func`3<Exception, string, ErrorTranslation>> toErrorHandlers;
    public sealed virtual Exception ToException(ApiError error);
    private string AppendErrorReportNumber(string message, string report, bool english);
    public sealed virtual void RegisterToErrorHandler(Func`3<Exception, string, ErrorTranslation> handler);
    public sealed virtual ErrorTranslation ToError(Exception exception, string errorReportNumber);
    private static HttpStatusCode GetMachineErrorStatuscode(MachineErrorException machineError);
}
public interface Momentum.Common.Api.ErrorHandling.IErrorTranslatorService {
    public abstract virtual void RegisterToErrorHandler(Func`3<Exception, string, ErrorTranslation> handler);
    public abstract virtual ErrorTranslation ToError(Exception exception, string errorReportNumber);
    public abstract virtual Exception ToException(ApiError error);
}
public class Momentum.Common.Errors.Reporting.DefaultErrorReportingService : object {
    public sealed virtual void Report(Exception error);
    public sealed virtual Task ReportAsync(Exception error);
}
public class Momentum.Common.Hosting.DefaultHostEnvironmentService : object {
    public string AppVersionDisplayName { get; }
    public string ApplicationInstanceId { get; }
    public string EnvironmentTypeReferenceName { get; }
    public HostingSupportEnvironmentType SupportEnvironment { get; }
    public sealed virtual string ToPlatformPath(string path);
    public sealed virtual string GetConfigurationPath(string innerPath);
    public sealed virtual string GetWebAddress(string path);
    public sealed virtual string GetWebAddressExternal(string path);
    public sealed virtual string GetConfigurationOption(string name);
    public sealed virtual string get_AppVersionDisplayName();
    public sealed virtual string get_ApplicationInstanceId();
    public sealed virtual string get_EnvironmentTypeReferenceName();
    public sealed virtual HostingSupportEnvironmentType get_SupportEnvironment();
}
public static class Momentum.Common.Security.Keys.ApplicationKeyStore : object {
    private static RSA rsaKey;
    private static bool useExportableKey;
    private static bool useExportableKeyAccessed;
    [CompilerGeneratedAttribute]
private static EventHandler BuildingPrivateKeyParameters;
    public static bool UseExportableKey { get; public set; }
    public static void set_UseExportableKey(bool value);
    public static bool get_UseExportableKey();
    public static RSA GetPrivateKeyRsa();
    private static RSA ReadRsaKey();
    public static RSA GeneratePrivateKey();
    private static void WriteKeyFile(string keyFile, RSA newKey);
    [DebuggerStepThroughAttribute]
private static bool KeyContainerExists(string keyName);
    [CompilerGeneratedAttribute]
public static void add_BuildingPrivateKeyParameters(EventHandler value);
    [CompilerGeneratedAttribute]
public static void remove_BuildingPrivateKeyParameters(EventHandler value);
}
public class Momentum.Common.Threading.Breakers.ThrottlingCircuitBreaker : object {
    private string systemName;
    private string displayName;
    private int failureLimit;
    private Action opened;
    private TimeSpan halfOpenAfter;
    private int autoCloseAfterHalfOpenWithNoWork;
    private SemaphoreSlim throttling;
    private int throttlingMaxWaitMilliseconds;
    private bool isOpen;
    private bool isHalfOpen;
    private DateTime nextHalfOpen;
    private long halfOpens;
    private long halfOpenRemaining;
    private long halfOpenWithNoWork;
    private long halfOpenRunning;
    private bool halfOpenTimerRunning;
    private int failuresCurrent;
    private long runCount;
    private long failuresTotal;
    private long rejectCountOpen;
    private long rejectCountThrottling;
    [CompilerGeneratedAttribute]
private Exception <LastError>k__BackingField;
    private string Momentum.Threading.Breakers.ICircuitBreaker.SystemName { get; }
    private string Momentum.Threading.Breakers.ICircuitBreaker.DisplayName { get; }
    private string Momentum.Threading.Breakers.ICircuitBreaker.Status { get; }
    public bool IsOpen { get; }
    public bool IsClosed { get; }
    public Exception LastError { get; private set; }
    private ThrottlingCircuitBreaker(string systemName, string displayName, TimeSpan halfOpenAfter, int failureLimit, int throttlingLimit, int throttlingMaxWaitMilliseconds, Action opened);
    public static ThrottlingCircuitBreaker CreateAndRegister(string systemName, string displayName, TimeSpan halfOpenAfter, int failureLimit, int throttlingLimit, int throttlingMaxWaitMilliseconds, Action opened);
    private sealed virtual override string Momentum.Threading.Breakers.ICircuitBreaker.get_SystemName();
    private sealed virtual override string Momentum.Threading.Breakers.ICircuitBreaker.get_DisplayName();
    private sealed virtual override string Momentum.Threading.Breakers.ICircuitBreaker.get_Status();
    public void Protect(Action action, bool skipIfOpened);
    public TResult Protect(Func`1<TResult> action, bool skipIfOpened);
    public Task ProtectAsync(Func`1<Task> action, bool skipIfOpened, bool absorbErrors);
    [AsyncStateMachineAttribute("Momentum.Common.Threading.Breakers.ThrottlingCircuitBreaker/<ProtectAsync>d__32`1")]
public Task`1<TResult> ProtectAsync(Func`1<Task`1<TResult>> action, bool skipRunIfOpened, bool absorbErrors);
    private void RunStarting();
    private bool HalfOpenEntry();
    private void HalfOpenExit();
    private bool EnterBreaker(bool skipRunIfOpened);
    [AsyncStateMachineAttribute("Momentum.Common.Threading.Breakers.ThrottlingCircuitBreaker/<EnterBreakerAsync>d__37")]
private Task`1<bool> EnterBreakerAsync(bool skipRunIfOpened);
    private void LeaveBreaker();
    private void ThrowBreakerOpen();
    private void ThrowThrottlingLimitReached();
    private void HandleFailureError(Exception x);
    private static bool IsClientError(Exception x);
    private void IncrementRejectCountOpen();
    private void IncrementRejectCountThrottling();
    public void IncrementFailureCounter(string reason, Exception exception);
    public sealed virtual bool get_IsOpen();
    public bool get_IsClosed();
    [CompilerGeneratedAttribute]
public sealed virtual Exception get_LastError();
    [CompilerGeneratedAttribute]
private void set_LastError(Exception value);
    private void Open();
    private void StartHalfOpenTimer();
    private void HalfOpen();
    private void Close();
    [IteratorStateMachineAttribute("Momentum.Common.Threading.Breakers.ThrottlingCircuitBreaker/<GetCounters>d__58")]
public sealed virtual IEnumerable`1<CircuitBreakerCounter> GetCounters();
    [AsyncStateMachineAttribute("Momentum.Common.Threading.Breakers.ThrottlingCircuitBreaker/<<StartHalfOpenTimer>b__55_0>d")]
[CompilerGeneratedAttribute]
private Task <StartHalfOpenTimer>b__55_0();
}
public class Momentum.Configuration.GenericDependencyConfiguration : object {
    private static Dictionary`2<string, GenericDependencyConfiguration> configurations;
    [CompilerGeneratedAttribute]
private static EventHandler ConfigurationChanged;
    [CompilerGeneratedAttribute]
private string <DependencyTargetId>k__BackingField;
    [CompilerGeneratedAttribute]
private GenericDependencyConfigurationPort[] <Ports>k__BackingField;
    [CompilerGeneratedAttribute]
private GenericDependencyConfigurationAppModel <AppModel>k__BackingField;
    [CompilerGeneratedAttribute]
private GenericDependencyConfigurationCredentials <Credentials>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Address>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DatabaseConnectionString>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AddressExternal>k__BackingField;
    public static IEnumerable`1<KeyValuePair`2<string, GenericDependencyConfiguration>> All { get; }
    public string DependencyTargetId { get; public set; }
    public GenericDependencyConfigurationPort[] Ports { get; public set; }
    public GenericDependencyConfigurationAppModel AppModel { get; public set; }
    public GenericDependencyConfigurationCredentials Credentials { get; public set; }
    public string Address { get; public set; }
    public string DatabaseConnectionString { get; public set; }
    public string AddressExternal { get; public set; }
    private static GenericDependencyConfiguration();
    public static void SetConfiguration(string dependencyKey, GenericDependencyConfiguration config);
    public static GenericDependencyConfiguration GetConfiguration(string dependencyKey);
    public static GenericDependencyConfiguration Find(Func`2<GenericDependencyConfiguration, bool> predicate);
    public static IEnumerable`1<KeyValuePair`2<string, GenericDependencyConfiguration>> get_All();
    private static void OnConfigurationChanged();
    [CompilerGeneratedAttribute]
public static void add_ConfigurationChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public static void remove_ConfigurationChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public string get_DependencyTargetId();
    [CompilerGeneratedAttribute]
public void set_DependencyTargetId(string value);
    [CompilerGeneratedAttribute]
public GenericDependencyConfigurationPort[] get_Ports();
    [CompilerGeneratedAttribute]
public void set_Ports(GenericDependencyConfigurationPort[] value);
    [CompilerGeneratedAttribute]
public GenericDependencyConfigurationAppModel get_AppModel();
    [CompilerGeneratedAttribute]
public void set_AppModel(GenericDependencyConfigurationAppModel value);
    [CompilerGeneratedAttribute]
public GenericDependencyConfigurationCredentials get_Credentials();
    [CompilerGeneratedAttribute]
public void set_Credentials(GenericDependencyConfigurationCredentials value);
    [CompilerGeneratedAttribute]
public string get_Address();
    [CompilerGeneratedAttribute]
public void set_Address(string value);
    [CompilerGeneratedAttribute]
public string get_DatabaseConnectionString();
    [CompilerGeneratedAttribute]
public void set_DatabaseConnectionString(string value);
    [CompilerGeneratedAttribute]
public string get_AddressExternal();
    [CompilerGeneratedAttribute]
public void set_AddressExternal(string value);
}
public class Momentum.Configuration.GenericDependencyConfigurationAppModel : object {
    [CompilerGeneratedAttribute]
private string <ApplicationInstanceId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TargetApp>k__BackingField;
    public string ApplicationInstanceId { get; public set; }
    public string TargetApp { get; public set; }
    [CompilerGeneratedAttribute]
public string get_ApplicationInstanceId();
    [CompilerGeneratedAttribute]
public void set_ApplicationInstanceId(string value);
    [CompilerGeneratedAttribute]
public string get_TargetApp();
    [CompilerGeneratedAttribute]
public void set_TargetApp(string value);
}
public class Momentum.Configuration.GenericDependencyConfigurationCredentials : object {
    [CompilerGeneratedAttribute]
private string <SharedAccessKey>k__BackingField;
    public string SharedAccessKey { get; public set; }
    [CompilerGeneratedAttribute]
public string get_SharedAccessKey();
    [CompilerGeneratedAttribute]
public void set_SharedAccessKey(string value);
}
public class Momentum.Configuration.GenericDependencyConfigurationPort : object {
    [CompilerGeneratedAttribute]
private string <ResourceKey>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DisplayName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MachineName>k__BackingField;
    [CompilerGeneratedAttribute]
private int <PortNumber>k__BackingField;
    public string ResourceKey { get; public set; }
    public string DisplayName { get; public set; }
    public string MachineName { get; public set; }
    public int PortNumber { get; public set; }
    [CompilerGeneratedAttribute]
public string get_ResourceKey();
    [CompilerGeneratedAttribute]
public void set_ResourceKey(string value);
    [CompilerGeneratedAttribute]
public string get_DisplayName();
    [CompilerGeneratedAttribute]
public void set_DisplayName(string value);
    [CompilerGeneratedAttribute]
public string get_MachineName();
    [CompilerGeneratedAttribute]
public void set_MachineName(string value);
    [CompilerGeneratedAttribute]
public int get_PortNumber();
    [CompilerGeneratedAttribute]
public void set_PortNumber(int value);
}
public static class Momentum.Data.DataQueryHelper : object {
    private static HashSet`1<char> allowedCharacters;
    private static HashSet`1<char> allowedNumberListCharacters;
    private static DataQueryHelper();
    public static string CleanInput(IEnumerable`1<string> list);
    public static string CleanInput(string s, bool throwOnError);
    public static string CleanInputNumberList(string s, bool throwOnError);
    public static string CleanInputCompiled(string s, bool throwOnError);
}
public interface Momentum.Data.IDataAccessComponent`2 {
    public abstract virtual TData GetItem(SessionContext session, TKey key, bool throwIfMissing, bool mustBeUnique);
    public abstract virtual void Insert(SessionContext session, TData data);
    public abstract virtual void Update(SessionContext session, TData data);
}
public interface Momentum.Data.IDataAccessComponent`3 {
    public abstract virtual TData GetItem(SessionContext session, TKey1 key1, TKey2 key2, bool throwIfMissing, bool mustBeUnique);
    public abstract virtual void Insert(SessionContext session, TData data);
    public abstract virtual void Update(SessionContext session, TData data);
}
public interface Momentum.Data.IDataAccessComponent`4 {
    public abstract virtual TData GetItem(SessionContext session, TKey1 key1, TKey2 key2, TKey3 key3, bool throwIfMissing, bool mustBeUnique);
    public abstract virtual void Insert(SessionContext session, TData data);
    public abstract virtual void Update(SessionContext session, TData data);
}
public interface Momentum.Data.IDataAccessComponent`5 {
    public abstract virtual TData GetItem(SessionContext session, TKey1 key1, TKey2 key2, TKey3 key3, TKey4 key4, bool throwIfMissing, bool mustBeUnique);
    public abstract virtual void Insert(SessionContext session, TData data);
    public abstract virtual void Update(SessionContext session, TData data);
}
public interface Momentum.Data.IDataAccessComponent`6 {
    public abstract virtual TData GetItem(SessionContext session, TKey1 key1, TKey2 key2, TKey3 key3, TKey4 key4, TKey5 key5, bool throwIfMissing, bool mustBeUnique);
    public abstract virtual void Insert(SessionContext session, TData data);
    public abstract virtual void Update(SessionContext session, TData data);
}
public interface Momentum.Data.IDataAccessComponent`7 {
    public abstract virtual TData GetItem(SessionContext session, TKey1 key1, TKey2 key2, TKey3 key3, TKey4 key4, TKey5 key5, TKey6 key6, bool throwIfMissing, bool mustBeUnique);
    public abstract virtual void Insert(SessionContext session, TData data);
    public abstract virtual void Update(SessionContext session, TData data);
}
public interface Momentum.Data.IDataAccessComponent`8 {
    public abstract virtual TData GetItem(SessionContext session, TKey1 key1, TKey2 key2, TKey3 key3, TKey4 key4, TKey5 key5, TKey6 key6, TKey7 key7, bool throwIfMissing, bool mustBeUnique);
    public abstract virtual void Insert(SessionContext session, TData data);
    public abstract virtual void Update(SessionContext session, TData data);
}
public interface Momentum.Data.IDataAccessComponentAsync`2 {
    public abstract virtual Task`1<TData> GetItemAsync(SessionContext session, TKey key, bool throwIfMissing, bool mustBeUnique, CancellationToken cancellation);
    public abstract virtual Task InsertAsync(SessionContext session, TData data, CancellationToken cancellation);
    public abstract virtual Task UpdateAsync(SessionContext session, TData data, CancellationToken cancellation);
}
public interface Momentum.Data.IDataAccessComponentAsync`3 {
    public abstract virtual Task`1<TData> GetItemAsync(SessionContext session, TKey1 key1, TKey2 key2, bool throwIfMissing, bool mustBeUnique, CancellationToken cancellation);
    public abstract virtual Task InsertAsync(SessionContext session, TData data, CancellationToken cancellation);
    public abstract virtual Task UpdateAsync(SessionContext session, TData data, CancellationToken cancellation);
}
public interface Momentum.Data.IDataAccessComponentAsync`4 {
    public abstract virtual Task`1<TData> GetItemAsync(SessionContext session, TKey1 key1, TKey2 key2, TKey3 key3, bool throwIfMissing, bool mustBeUnique, CancellationToken cancellation);
    public abstract virtual Task InsertAsync(SessionContext session, TData data, CancellationToken cancellation);
    public abstract virtual Task UpdateAsync(SessionContext session, TData data, CancellationToken cancellation);
}
public interface Momentum.Data.IDataAccessComponentAsync`5 {
    public abstract virtual Task`1<TData> GetItemAsync(SessionContext session, TKey1 key1, TKey2 key2, TKey3 key3, TKey4 key4, bool throwIfMissing, bool mustBeUnique, CancellationToken cancellation);
    public abstract virtual Task InsertAsync(SessionContext session, TData data, CancellationToken cancellation);
    public abstract virtual Task UpdateAsync(SessionContext session, TData data, CancellationToken cancellation);
}
public interface Momentum.Data.IDataAccessComponentAsync`6 {
    public abstract virtual Task`1<TData> GetItemAsync(SessionContext session, TKey1 key1, TKey2 key2, TKey3 key3, TKey4 key4, TKey5 key5, bool throwIfMissing, bool mustBeUnique, CancellationToken cancellation);
    public abstract virtual Task InsertAsync(SessionContext session, TData data, CancellationToken cancellation);
    public abstract virtual Task UpdateAsync(SessionContext session, TData data, CancellationToken cancellation);
}
public interface Momentum.Data.IDataAccessComponentAsync`7 {
    public abstract virtual Task`1<TData> GetItemAsync(SessionContext session, TKey1 key1, TKey2 key2, TKey3 key3, TKey4 key4, TKey5 key5, TKey6 key6, bool throwIfMissing, bool mustBeUnique, CancellationToken cancellation);
    public abstract virtual Task InsertAsync(SessionContext session, TData data, CancellationToken cancellation);
    public abstract virtual Task UpdateAsync(SessionContext session, TData data, CancellationToken cancellation);
}
public interface Momentum.Data.IDataAccessComponentAsync`8 {
    public abstract virtual Task`1<TData> GetItemAsync(SessionContext session, TKey1 key1, TKey2 key2, TKey3 key3, TKey4 key4, TKey5 key5, TKey6 key6, TKey7 key7, bool throwIfMissing, bool mustBeUnique, CancellationToken cancellation);
    public abstract virtual Task InsertAsync(SessionContext session, TData data, CancellationToken cancellation);
    public abstract virtual Task UpdateAsync(SessionContext session, TData data, CancellationToken cancellation);
}
public interface Momentum.Data.IDataAccessEntity`1 {
    public TKey Id { get; public set; }
    public abstract virtual TKey get_Id();
    public abstract virtual void set_Id(TKey value);
}
public interface Momentum.Data.IDataAccessEntity`2 {
}
public interface Momentum.Data.IDataAccessEntity`3 {
}
public interface Momentum.Data.IDataAccessEntity`4 {
}
public interface Momentum.Data.IDataAccessEntity`5 {
}
public interface Momentum.Data.IDataAccessEntity`6 {
}
public interface Momentum.Data.IDataAccessEntity`7 {
}
public static class Momentum.Data.InstrumentationUtility : object {
    private static String[] privateParameterKeywords;
    private static String[] privateParameterKeywordsExact;
    private static String[] publicParameterKeywords;
    private static TelemetryFlag logPrivateParameters;
    private static InstrumentationUtility();
    public static bool IsPrivateParameter(string parameterName);
    public static bool Exclude(string key);
}
public interface Momentum.Data.IPersistentDistributedQueueStore {
    public abstract virtual Task StreamEnsureGroupCreatedAsync(string key, string groupName, int maximumGroupsCount, Nullable`1<int> evictIfIdleMilliseconds, string position);
    public abstract virtual Task`1<string> StreamAddAsync(string key, T data, int trimMaxLength, bool fireAndForget);
    public abstract virtual Task`1<List`1<PersistentQueueStreamEntry`1<T>>> StreamReadAsync(string key, string position, int count, Func`3<string, Exception, Task> serializationErrorHandler);
    public abstract virtual Task`1<List`1<PersistentQueueStreamEntry`1<T>>> StreamGroupReadAsync(string key, string groupName, string consumerName, string position, int count, Func`4<string, Exception, List`1<PersistentQueueStreamEntry`1<T>>, Task> serializationErrorHandler);
    public abstract virtual Task`1<long> StreamGroupAcknowledgeAsync(string key, string groupName, string messageId, bool fireAndForget);
    public abstract virtual Task`1<long> StreamGroupAcknowledgeAsync(string key, string groupName, IEnumerable`1<string> messageId, bool fireAndForget);
    public abstract virtual Task`1<long> StreamMessageDeleteAsync(string key, string messageId, bool fireAndForget);
    public abstract virtual Task`1<IQueueSubscription> SubscribeAsync(string key, Action`1<T> handler);
    public abstract virtual Task PublishAsync(string key, T data, bool fireAndForget);
}
public interface Momentum.Data.IPersistentKeyValueStore {
    public abstract virtual long Increment(string key, long increment);
    public abstract virtual Task`1<long> IncrementAsync(string key, long increment);
    public abstract virtual Nullable`1<long> GetIncrementValue(string key);
    public abstract virtual Task`1<Nullable`1<long>> GetIncrementValueAsync(string key);
    public abstract virtual TData Get(string key);
    public abstract virtual Task`1<TData> GetAsync(string key);
    public abstract virtual void Set(string key, TData data, Nullable`1<TimeSpan> expireAfter);
    public abstract virtual Task SetAsync(string key, TData data, Nullable`1<TimeSpan> expireAfter, bool fireAndForget);
    public abstract virtual void Remove(string key);
    public abstract virtual Task RemoveAsync(string key);
    public abstract virtual void FlushAll();
    public abstract virtual Task`1<bool> TakeLockAsync(string key, int maxWaitSeconds, int expirySeconds, bool throwOnTimeout);
    public abstract virtual void ReleaseLock(string key);
    public abstract virtual Task ReleaseLockAsync(string key);
}
public interface Momentum.Data.IQueueSubscription {
    public abstract virtual Task DisposeAsync();
}
public class Momentum.Data.LogSet.LogSetPartWrittenEventArgs : EventArgs {
    private string fileWriterFileName;
    public string LogSetPartFileName { get; }
    public LogSetPartWrittenEventArgs(string fileWriterFileName);
    public string get_LogSetPartFileName();
}
public class Momentum.Data.LogSet.LogSetReader : object {
    private String[] currentLineElements;
    private int position;
    private StreamReader reader;
    public LogSetReader(StreamReader reader);
    [AsyncStateMachineAttribute("Momentum.Data.LogSet.LogSetReader/<ReadLineAsync>d__4")]
public Task`1<bool> ReadLineAsync();
    [ObsoleteAttribute("Use GetLineValue")]
public string GetLineElement(int index);
    public string GetLineValue(int index);
    public Nullable`1<int> GetLineValueInt(int index);
    public Nullable`1<bool> GetLineValueBool(int index);
    public Nullable`1<double> GetLineValueDouble(int index);
    public Nullable`1<decimal> GetLineValueDecimal(int index);
    public Nullable`1<long> GetLineValueLong(int index);
    public TimeSpan GetLineValueTimeSpan(int index);
    public long GetLineValueTimeSpanMilliseconds(int index);
}
public class Momentum.Data.LogSet.LogSetReaderString : object {
    private String[] lines;
    private String[] currentLineElements;
    private int position;
    public LogSetReaderString(string data);
    public bool ReadLine();
    public string GetLineElement(int index);
}
public class Momentum.Data.LogSet.LogSetWriter : object {
    private static int AverageLineSize;
    private static int FileDeleteAttempts;
    private static int FileOpenAttempts;
    private static int PendingWritesLimit;
    private static int PendingWritesLimitWait;
    private string dir;
    private string filePrefix;
    private string fileExtension;
    private TimeSpan writeChangeInterval;
    private long maxTotalSize;
    private long maxFileSize;
    private int maxFileCount;
    private FileStream fileWriter;
    private string fileWriterFileName;
    private StreamWriter streamWriter;
    private Timer changeWriterTimer;
    private long currentTotalSize;
    private long currentFileCount;
    private long pendingWrites;
    private bool fileShareRead;
    private bool absorbErrors;
    [CompilerGeneratedAttribute]
private EventHandler`1<LogSetWriterCleanArgs> cleaned;
    [CompilerGeneratedAttribute]
private EventHandler`1<LogSetPartWrittenEventArgs> LogSetPartWritten;
    public string FilePrefix { get; }
    public LogSetWriter(string dir, string filePrefix, string fileExtension, TimeSpan writeChangeInterval, long maxTotalSize, long maxFileSize, bool fileShareRead, bool absorbErrors, int maxFileCount, EventHandler`1<LogSetWriterCleanArgs> cleaned);
    public string get_FilePrefix();
    public void RaiseLogSetPartWrittenOnExisting(bool reverse, bool queuedLogSetPartWrittenEvent);
    private void CurrentDomain_ProcessExit(object sender, EventArgs e);
    private void CleanFilesIfNeeded();
    private long CalculateFileSpaceUsage();
    private long CalculateFileCount();
    private static long GetFileLength(FileInfo i);
    private void OpenFileStream();
    private void CleanFiles();
    public void OnClean(List`1<DateTime> datesList, long spaceToClean, long fileCountToClean);
    [CompilerGeneratedAttribute]
private void add_cleaned(EventHandler`1<LogSetWriterCleanArgs> value);
    [CompilerGeneratedAttribute]
private void remove_cleaned(EventHandler`1<LogSetWriterCleanArgs> value);
    private static bool TryDeleteFile(string fileName);
    public void SuggestChangeLogPart();
    private void ChangeWriterTimer(object state);
    private void ChangeWriter();
    private void CloseWriter();
    private void RaiseLogSetPartWritten(string fileWriterFileName, bool queued);
    [CompilerGeneratedAttribute]
public void add_LogSetPartWritten(EventHandler`1<LogSetPartWrittenEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_LogSetPartWritten(EventHandler`1<LogSetPartWrittenEventArgs> value);
    private void CreateWriter();
    public void Write(Object[] data);
    private void WriteCore(Object[] data);
    private static string CleanTabSegment(string s);
    public void DeleteLogPart(string fileName);
    protected virtual override void Finalize();
    public sealed virtual void Dispose();
    private void Dispose(bool disposing);
    [CompilerGeneratedAttribute]
private void <SuggestChangeLogPart>b__37_0(object s);
}
public class Momentum.Data.LogSet.LogSetWriterCleanArgs : object {
    [CompilerGeneratedAttribute]
private List`1<DateTime> <Dates>k__BackingField;
    [CompilerGeneratedAttribute]
private long <MaxTotalSize>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxFileCount>k__BackingField;
    [CompilerGeneratedAttribute]
private long <SpaceToClean>k__BackingField;
    [CompilerGeneratedAttribute]
private long <FileCountToClean>k__BackingField;
    public List`1<DateTime> Dates { get; }
    public long MaxTotalSize { get; }
    public int MaxFileCount { get; }
    public long SpaceToClean { get; }
    public long FileCountToClean { get; }
    public LogSetWriterCleanArgs(List`1<DateTime> datesList, long maxTotalSize, int maxFileCount, long spaceToClean, long fileCountToClean);
    [CompilerGeneratedAttribute]
public List`1<DateTime> get_Dates();
    [CompilerGeneratedAttribute]
public long get_MaxTotalSize();
    [CompilerGeneratedAttribute]
public int get_MaxFileCount();
    [CompilerGeneratedAttribute]
public long get_SpaceToClean();
    [CompilerGeneratedAttribute]
public long get_FileCountToClean();
}
public class Momentum.Data.PersistentQueueStreamEntry`1 : object {
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private T <Value>k__BackingField;
    public string Id { get; public set; }
    public T Value { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(string value);
    [CompilerGeneratedAttribute]
public T get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(T value);
}
public interface Momentum.Diagnostics.SelfTest.ISelfTest {
    public abstract virtual void CollectTestResult(SelfTestResult result);
}
public static class Momentum.Diagnostics.SelfTest.SelfTestManager : object {
    private static ISelfTest[] tests;
    private static SelfTestManager();
    public static void RegisterSelfTest(ISelfTest selfTest);
    public static SelfTestResult CollectTestResults(SelfTestType testType);
}
public class Momentum.Diagnostics.SelfTest.SelfTestResult : object {
    private List`1<SelfTestResultItem> items;
    [CompilerGeneratedAttribute]
private SelfTestType <TestType>k__BackingField;
    public SelfTestType TestType { get; }
    public SelfTestResult(SelfTestType testType);
    public SelfTestResult(SelfTestResult result);
    [CompilerGeneratedAttribute]
public SelfTestType get_TestType();
    public void Add(SelfTestResultItem item);
    public void Add(SelfTestResult subresult, string checkName);
    public sealed virtual IEnumerator`1<SelfTestResultItem> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class Momentum.Diagnostics.SelfTest.SelfTestResultItem : object {
    [CompilerGeneratedAttribute]
private SelfTestResultItemType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TaskName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Context>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CheckName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ErrorReportManagementUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ErrorReportNumber>k__BackingField;
    public SelfTestResultItemType Type { get; private set; }
    public string TaskName { get; private set; }
    public string Context { get; private set; }
    public string CheckName { get; private set; }
    public string Message { get; private set; }
    public string ErrorReportManagementUrl { get; private set; }
    public string ErrorReportNumber { get; private set; }
    public SelfTestResultItem(SelfTestResultItemType type, string checkName, string message, string taskName, string context, ReportingInfo errorReport);
    public SelfTestResultItem(SelfTestResultItemType type, string checkName, string message, string taskName, string context, string errorReportNumber, string errorReportManagementUrl);
    [CompilerGeneratedAttribute]
public SelfTestResultItemType get_Type();
    [CompilerGeneratedAttribute]
private void set_Type(SelfTestResultItemType value);
    [CompilerGeneratedAttribute]
public string get_TaskName();
    [CompilerGeneratedAttribute]
private void set_TaskName(string value);
    [CompilerGeneratedAttribute]
public string get_Context();
    [CompilerGeneratedAttribute]
private void set_Context(string value);
    [CompilerGeneratedAttribute]
public string get_CheckName();
    [CompilerGeneratedAttribute]
private void set_CheckName(string value);
    [CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
private void set_Message(string value);
    [CompilerGeneratedAttribute]
public string get_ErrorReportManagementUrl();
    [CompilerGeneratedAttribute]
private void set_ErrorReportManagementUrl(string value);
    [CompilerGeneratedAttribute]
public string get_ErrorReportNumber();
    [CompilerGeneratedAttribute]
private void set_ErrorReportNumber(string value);
}
public enum Momentum.Diagnostics.SelfTest.SelfTestResultItemType : Enum {
    public int value__;
    [EnumMemberAttribute]
public static SelfTestResultItemType Error;
    [EnumMemberAttribute]
public static SelfTestResultItemType Success;
}
public enum Momentum.Diagnostics.SelfTest.SelfTestType : Enum {
    public int value__;
    public static SelfTestType Default;
    public static SelfTestType Critical;
}
[DataContractAttribute]
[XmlRootAttribute]
public class Momentum.Diagnostics.Telemetry.Config.TelemetryConfig : object {
    [CompilerGeneratedAttribute]
private List`1<TelemetryConfigProvider> <Provider>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<TelemetryConfigFlag> <Flag>k__BackingField;
    [DataMemberAttribute]
[XmlElementAttribute]
public List`1<TelemetryConfigProvider> Provider { get; public set; }
    [DataMemberAttribute]
[XmlElementAttribute]
public List`1<TelemetryConfigFlag> Flag { get; public set; }
    [CompilerGeneratedAttribute]
public List`1<TelemetryConfigProvider> get_Provider();
    [CompilerGeneratedAttribute]
public void set_Provider(List`1<TelemetryConfigProvider> value);
    [CompilerGeneratedAttribute]
public List`1<TelemetryConfigFlag> get_Flag();
    [CompilerGeneratedAttribute]
public void set_Flag(List`1<TelemetryConfigFlag> value);
}
[DataContractAttribute]
[XmlRootAttribute]
public class Momentum.Diagnostics.Telemetry.Config.TelemetryConfigFlag : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsEnabled>k__BackingField;
    [DataMemberAttribute]
[XmlAttributeAttribute]
public string Name { get; public set; }
    [DataMemberAttribute]
[XmlAttributeAttribute]
public bool IsEnabled { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public bool get_IsEnabled();
    [CompilerGeneratedAttribute]
public void set_IsEnabled(bool value);
}
public class Momentum.Diagnostics.Telemetry.Config.TelemetryConfigManager : object {
    private static Dictionary`2<string, TelemetryFlag> flags;
    private static TelemetryConfigManager();
    internal static void ConfigureTelemetry();
    private static void ReadConfig();
    private static void LoadTelemetryProvider(TelemetryConfigProvider config);
    public static TelemetryFlag[] GetFlagLists();
    public static TelemetryFlag RegisterFlag(string name, string displayName, string description, bool defaultEnabled);
    public static TelemetryFlag SetFlag(string name, bool enable);
}
[DataContractAttribute]
[XmlTypeAttribute]
public class Momentum.Diagnostics.Telemetry.Config.TelemetryConfigProvider : object {
    [CompilerGeneratedAttribute]
private string <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Target>k__BackingField;
    [DataMemberAttribute]
[XmlAttributeAttribute]
public string Type { get; public set; }
    [DataMemberAttribute]
[XmlAttributeAttribute]
public string Target { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(string value);
    [CompilerGeneratedAttribute]
public string get_Target();
    [CompilerGeneratedAttribute]
public void set_Target(string value);
}
public static class Momentum.Diagnostics.Telemetry.Config.TelemetryConfigReader : object {
    private static string FileName;
    private static XmlSerializationHelper`1<TelemetryConfig> serializer;
    private static TelemetryConfigReader();
    public static TelemetryConfig TryRead();
    public static void SaveConfig(TelemetryConfig config);
}
public class Momentum.Diagnostics.Telemetry.DiskTelemetryProvider : object {
    private TelemetryConfigProvider config;
    private LogSetWriter logSetWriter;
    public bool IsEnabled { get; }
    public sealed virtual void Configure(TelemetryConfigProvider config);
    public sealed virtual void WriteTelemetryEntryTask(DateTime startUtc, TimeSpan executionTime, bool success, string exceptionTypeString, string taskName, string rayId, int attempt, string errorReport, Dictionary`2<string, string> context, string message, string technicalData, string errorMessage);
    public sealed virtual void WriteTelemetryEntryEvent(DateTime startUtc, TimeSpan executionTime, bool success, string exceptionTypeString, string eventName, string rayId, string errorReport, Dictionary`2<string, string> context, string message);
    public sealed virtual void WriteTelemetryEntryActivity(DateTime startUtc, string activityName, string rayId, string actorGuid, string actorCategory, string actorDisplayName, string actorEmail, Nullable`1<int> count, Nullable`1<bool> passive, Nullable`1<int> weight, Dictionary`2<string, string> context);
    public sealed virtual void WriteTelemetryEntryError(DateTime startUtc, string userReportGuid, string errorType, string errorMessage, object errorReport, string rayId, string localErrorReportNumber, string remoteErrorReportNumber);
    public sealed virtual void WriteTelemetryEntryServiceRequest(DateTime startUtc, Nullable`1<TimeSpan> executionTime, bool success, string exceptionTypeString, string serviceType, string operation, string apiUserString, string rayId, string errorReport, string remoteHost, string requestAddress, Nullable`1<long> requestLength, string requestData, string actorLoginName, string actorDisplayName, Nullable`1<long> actorLoginLogId, string deviceId);
    public sealed virtual void WriteTelemetryEntryWebRequest(DateTime startUtc, TimeSpan executionTime, bool success, string requestType, string address, long inputLength, string contentType, long outputLength, Uri uri, string rayId, string errorReport, string remoteHost, string requestData, string actorLoginName, string actorDisplayName, Nullable`1<long> actorLoginLogId, string exceptionType, string deviceId, string requestHeaders, string requestQueryString, string responseHeaders, string responseBody, Nullable`1<int> responseStatusCode, string responseStatusDescription, bool passive, string client, string clientVersion, string clientId, string userAgent, string serviceType, string operation, string apiKeyId, string usageType, Nullable`1<decimal> complexityCost, string errorClass, string origin, string referer, UsageContextData usageData);
    public sealed virtual void WriteTelemetryEntryDatabaseAccess(DateTime startUtc, TimeSpan executionTime, string error, bool humanError, string type, string objectName, string commandText, string rayId, Nullable`1<long> responseLength, string deviceId);
    public sealed virtual void WriteTelemetryEntryValue(string valueType, string instance, Nullable`1<decimal> value, object complexValue);
    public sealed virtual void WriteTelemetryEntryGeneric(Object[] data);
    private string EncodeContext(Dictionary`2<string, string> context);
    public sealed virtual void SuggestShip();
    public sealed virtual bool get_IsEnabled();
}
public class Momentum.Diagnostics.Telemetry.IntrumentExecutionResult : object {
    [CompilerGeneratedAttribute]
private Exception <Error>k__BackingField;
    [CompilerGeneratedAttribute]
private ReportingInfo <ErrorReport>k__BackingField;
    public Exception Error { get; internal set; }
    public ReportingInfo ErrorReport { get; internal set; }
    [CompilerGeneratedAttribute]
public Exception get_Error();
    [CompilerGeneratedAttribute]
internal void set_Error(Exception value);
    [CompilerGeneratedAttribute]
public ReportingInfo get_ErrorReport();
    [CompilerGeneratedAttribute]
internal void set_ErrorReport(ReportingInfo value);
}
public interface Momentum.Diagnostics.Telemetry.ITelemetryBackgroundTask {
    public DateTime RegisteredUtc { get; }
    public TelemetryBackgroundTaskRequire Require { get; }
    public TelemetryBackgroundTaskStatus Status { get; }
    public string TaskName { get; }
    public abstract virtual DateTime get_RegisteredUtc();
    public abstract virtual TelemetryBackgroundTaskRequire get_Require();
    public abstract virtual TelemetryBackgroundTaskStatus get_Status();
    public abstract virtual string get_TaskName();
    public abstract virtual void Dispose();
    public abstract virtual void InstrumentExecution(Action action, bool absorbException, Nullable`1<int> delayOnErrorMilliseconds, string reference, Action`2<Exception, ReportingInfo> errorOccurred);
    public abstract virtual Task`1<IntrumentExecutionResult> InstrumentExecutionAsync(Func`1<Task> action, bool absorbException, Nullable`1<int> delayOnErrorMilliseconds, string reference, int attempts, Predicate`1<Exception> reportErrorPredicate, bool writeErrorsToConsoleOnly);
    public abstract virtual void Log(string message, string technicalData, int step, int stepsTotal, object context);
    public abstract virtual void Log(byte detailLevel, string message, string technicalData, int step, int stepsTotal, object context);
    public abstract virtual void LogExecutionCompleteError(Exception error, ReportingInfo errorReport, Nullable`1<TimeSpan> processingTime);
    public abstract virtual void LogExecutionCompleteSuccess(Nullable`1<TimeSpan> processingTime);
    public abstract virtual void LogVerbose(string message, string technicalData, int step, int stepsTotal, object context, bool forcePersist);
    public abstract virtual void LogVerbose(byte detailLevel, string message, string technicalData, int step, int stepsTotal, object context, bool forcePersist);
}
public interface Momentum.Diagnostics.Telemetry.ITelemetryProvider {
    public bool IsEnabled { get; }
    public abstract virtual void Configure(TelemetryConfigProvider config);
    public abstract virtual void WriteTelemetryEntryGeneric(Object[] data);
    public abstract virtual void WriteTelemetryEntryTask(DateTime startUtc, TimeSpan executionTime, bool success, string exceptionTypeString, string taskName, string rayId, int attempt, string errorReport, Dictionary`2<string, string> context, string message, string technicalData, string eerrorMessage);
    public abstract virtual void WriteTelemetryEntryEvent(DateTime startUtc, TimeSpan executionTime, bool success, string exceptionTypeString, string eventName, string rayId, string errorReport, Dictionary`2<string, string> context, string message);
    public abstract virtual void WriteTelemetryEntryActivity(DateTime startUtc, string activityName, string rayId, string actorId, string actorCategory, string actorDisplayName, string actorEmail, Nullable`1<int> count, Nullable`1<bool> passive, Nullable`1<int> weight, Dictionary`2<string, string> context);
    public abstract virtual void WriteTelemetryEntryError(DateTime startUtc, string errorReportGuid, string errorType, string errorMessage, object errorReport, string rayId, string localErrorReportNumber, string remoteErrorReportNumber);
    public abstract virtual void WriteTelemetryEntryServiceRequest(DateTime startUtc, Nullable`1<TimeSpan> executionTime, bool success, string exceptionTypeString, string serviceType, string operation, string apiUserString, string rayId, string errorReport, string remoteHost, string requestAddress, Nullable`1<long> requestLength, string requestData, string actorLoginName, string actorDisplayName, Nullable`1<long> actorLoginLogId, string deviceId);
    public abstract virtual void WriteTelemetryEntryWebRequest(DateTime startUtc, TimeSpan executionTime, bool success, string requestType, string address, long inputLength, string contentType, long outputLength, Uri uri, string rayId, string errorReport, string remoteHost, string requestData, string actorLoginName, string actorDisplayName, Nullable`1<long> actorLoginLogId, string exceptionType, string deviceId, string requestHeaders, string requestQueryString, string responseHeaders, string responseBody, Nullable`1<int> responseStatusCode, string responseStatusDescription, bool passive, string client, string clientVersion, string clientId, string userAgent, string serviceType, string operation, string apiKeyId, string UsageType, Nullable`1<decimal> complexityCost, string errorClass, string origin, string referer, UsageContextData usageData);
    public abstract virtual void WriteTelemetryEntryDatabaseAccess(DateTime startUtc, TimeSpan executionTime, string error, bool humanError, string type, string objectName, string commandText, string rayId, Nullable`1<long> responseLength, string deviceId);
    public abstract virtual void WriteTelemetryEntryValue(string valueType, string instance, Nullable`1<decimal> value, object complexValue);
    public abstract virtual void SuggestShip();
    public abstract virtual bool get_IsEnabled();
}
internal class Momentum.Diagnostics.Telemetry.TelemetryBackgroundExecution : object {
    [CompilerGeneratedAttribute]
private DateTime <StartUtc>k__BackingField;
    [CompilerGeneratedAttribute]
private Stopwatch <Timer>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PreviousRayId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RayId>k__BackingField;
    public DateTime StartUtc { get; }
    public Stopwatch Timer { get; }
    public string PreviousRayId { get; }
    public string RayId { get; }
    public TelemetryBackgroundExecution(Stopwatch timer, string previousRayId, string rayId);
    [CompilerGeneratedAttribute]
public DateTime get_StartUtc();
    [CompilerGeneratedAttribute]
public Stopwatch get_Timer();
    [CompilerGeneratedAttribute]
public string get_PreviousRayId();
    [CompilerGeneratedAttribute]
public string get_RayId();
}
public static class Momentum.Diagnostics.Telemetry.TelemetryBackgroundTask : object {
    private static Dictionary`2<string, TelemetryBackgroundTaskItem> tasks;
    private static TelemetryBackgroundTask();
    public static TelemetryBackgroundTaskItem RegisterTask(string taskName, Nullable`1<int> minDurationBetweenExecutionsSeconds, Nullable`1<int> maxDurationBetweenExecutionsSeconds, int maxExecutionTimeSeconds, bool throwIfRegistered, bool writeTelemetryOnSuccess, bool critical);
    public static TelemetryBackgroundTaskItem[] GetTaskList();
}
public class Momentum.Diagnostics.Telemetry.TelemetryBackgroundTaskItem : object {
    private DateTime registeredUtc;
    private string taskName;
    private TelemetryBackgroundTaskRequire require;
    private TelemetryBackgroundTaskStatus status;
    private bool writeTelemetryOnSuccess;
    private Action disposeHandler;
    public bool WriteTelemetryOnSuccess { get; }
    public DateTime RegisteredUtc { get; }
    public string TaskName { get; }
    public TelemetryBackgroundTaskRequire Require { get; }
    public TelemetryBackgroundTaskStatus Status { get; }
    internal TelemetryBackgroundTaskItem(string taskName, TelemetryBackgroundTaskRequire require, bool writeTelemetryOnSuccess, Action disposeHandler);
    public bool get_WriteTelemetryOnSuccess();
    public sealed virtual void Dispose();
    public sealed virtual void InstrumentExecution(Action action, bool absorbException, Nullable`1<int> delayOnErrorMilliseconds, string reference, Action`2<Exception, ReportingInfo> errorOccurred);
    [AsyncStateMachineAttribute("Momentum.Diagnostics.Telemetry.TelemetryBackgroundTaskItem/<InstrumentExecutionAsync>d__11")]
public sealed virtual Task`1<IntrumentExecutionResult> InstrumentExecutionAsync(Func`1<Task> action, bool absorbException, Nullable`1<int> delayOnErrorMilliseconds, string reference, int attempts, Predicate`1<Exception> reportErrorPredicate, bool writeErrorsToConsoleOnly);
    [DebuggerHiddenAttribute]
private TelemetryBackgroundExecution InstrumentExecutionStart(string reference);
    [DebuggerHiddenAttribute]
private IntrumentExecutionResult InstrumentExecutionEnd(bool absorbException, Exception error, ReportingInfo errorReport, TelemetryBackgroundExecution execution, Nullable`1<int> delayOnError, bool failTaskOnHumanError, int attempt, Dictionary`2<string, string> context);
    public sealed virtual void LogExecutionCompleteSuccess(Nullable`1<TimeSpan> processingTime);
    public sealed virtual void LogExecutionCompleteError(Exception error, ReportingInfo errorReport, Nullable`1<TimeSpan> processingTime);
    private void WriteExecutionReport(Exception error, ReportingInfo errorReport, TelemetryBackgroundExecution execution, bool failTaskOnHumanError, int attempt, Dictionary`2<string, string> context, bool logStop, Nullable`1<TimeSpan> processingTime);
    public sealed virtual void Log(string message, string technicalData, int step, int stepsTotal, object context);
    public sealed virtual void Log(byte detailLevel, string message, string technicalData, int step, int stepsTotal, object context);
    public sealed virtual void LogVerbose(string message, string technicalData, int step, int stepsTotal, object context, bool forcePersist);
    public sealed virtual void LogVerbose(byte detailLevel, string message, string technicalData, int step, int stepsTotal, object context, bool forcePersist);
    public void LogError(string message, string technicalData, int step, int stepsTotal, object context);
    internal void WriteTelemetryEntry(DateTime startUtc, TimeSpan processingTime, bool success, Exception error, string rayId, int attempt, ReportingInfo errorReport, Dictionary`2<string, string> context);
    public sealed virtual DateTime get_RegisteredUtc();
    public sealed virtual string get_TaskName();
    public sealed virtual TelemetryBackgroundTaskRequire get_Require();
    public sealed virtual TelemetryBackgroundTaskStatus get_Status();
}
public class Momentum.Diagnostics.Telemetry.TelemetryBackgroundTaskLogEntry : object {
    [CompilerGeneratedAttribute]
private DateTime <OccuredUtc>k__BackingField;
    [CompilerGeneratedAttribute]
private byte <DetailLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TechnicalData>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Step>k__BackingField;
    [CompilerGeneratedAttribute]
private int <StepsTotal>k__BackingField;
    public DateTime OccuredUtc { get; public set; }
    public byte DetailLevel { get; public set; }
    public string Message { get; public set; }
    public string TechnicalData { get; public set; }
    public int Step { get; public set; }
    public int StepsTotal { get; public set; }
    [CompilerGeneratedAttribute]
public DateTime get_OccuredUtc();
    [CompilerGeneratedAttribute]
public void set_OccuredUtc(DateTime value);
    [CompilerGeneratedAttribute]
public byte get_DetailLevel();
    [CompilerGeneratedAttribute]
public void set_DetailLevel(byte value);
    [CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
public void set_Message(string value);
    [CompilerGeneratedAttribute]
public string get_TechnicalData();
    [CompilerGeneratedAttribute]
public void set_TechnicalData(string value);
    [CompilerGeneratedAttribute]
public int get_Step();
    [CompilerGeneratedAttribute]
public void set_Step(int value);
    [CompilerGeneratedAttribute]
public int get_StepsTotal();
    [CompilerGeneratedAttribute]
public void set_StepsTotal(int value);
    public virtual string ToString();
}
public class Momentum.Diagnostics.Telemetry.TelemetryBackgroundTaskRequire : object {
    private Nullable`1<TimeSpan> minDurationBetweenExecutions;
    private Nullable`1<TimeSpan> maxDurationBetweenExecutions;
    private TimeSpan maxDuration;
    [CompilerGeneratedAttribute]
private bool <Critical>k__BackingField;
    public Nullable`1<TimeSpan> MinDurationBetweenExecutions { get; }
    public Nullable`1<TimeSpan> MaxDurationBetweenExecutions { get; public set; }
    public TimeSpan MaxExecutionTime { get; }
    public bool Critical { get; }
    internal TelemetryBackgroundTaskRequire(Nullable`1<int> minDurationBetweenExecutionsSeconds, Nullable`1<int> maxDurationBetweenExecutionsSeconds, int maxExecutionTimeSeconds, bool critical);
    public Nullable`1<TimeSpan> get_MinDurationBetweenExecutions();
    public Nullable`1<TimeSpan> get_MaxDurationBetweenExecutions();
    public void set_MaxDurationBetweenExecutions(Nullable`1<TimeSpan> value);
    public TimeSpan get_MaxExecutionTime();
    [CompilerGeneratedAttribute]
public bool get_Critical();
}
internal class Momentum.Diagnostics.Telemetry.TelemetryBackgroundTaskSelfTest : object {
    public sealed virtual void CollectTestResult(SelfTestResult result);
}
public class Momentum.Diagnostics.Telemetry.TelemetryBackgroundTaskStatus : object {
    [CompilerGeneratedAttribute]
private bool <IsActive>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <LastStartedUtc>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<TimeSpan> <LastExecutionTime>k__BackingField;
    [CompilerGeneratedAttribute]
private int <NumberOfExecutions>k__BackingField;
    [CompilerGeneratedAttribute]
private Exception <LastError>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <LastCompletedUtc>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <SecondLastCompletedUtc>k__BackingField;
    [CompilerGeneratedAttribute]
private ReportingInfo <LastErrorReport>k__BackingField;
    [CompilerGeneratedAttribute]
private TelemetryBackgroundTaskLogEntry <LastLogEntry>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LastReference>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RayId>k__BackingField;
    public bool IsActive { get; internal set; }
    public Nullable`1<DateTime> LastStartedUtc { get; internal set; }
    public Nullable`1<TimeSpan> LastExecutionTime { get; internal set; }
    public int NumberOfExecutions { get; internal set; }
    public Exception LastError { get; internal set; }
    public Nullable`1<DateTime> LastCompletedUtc { get; internal set; }
    public Nullable`1<DateTime> SecondLastCompletedUtc { get; internal set; }
    public ReportingInfo LastErrorReport { get; public set; }
    public TelemetryBackgroundTaskLogEntry LastLogEntry { get; public set; }
    public string LastReference { get; internal set; }
    public string RayId { get; internal set; }
    [CompilerGeneratedAttribute]
public bool get_IsActive();
    [CompilerGeneratedAttribute]
internal void set_IsActive(bool value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_LastStartedUtc();
    [CompilerGeneratedAttribute]
internal void set_LastStartedUtc(Nullable`1<DateTime> value);
    [CompilerGeneratedAttribute]
public Nullable`1<TimeSpan> get_LastExecutionTime();
    [CompilerGeneratedAttribute]
internal void set_LastExecutionTime(Nullable`1<TimeSpan> value);
    [CompilerGeneratedAttribute]
public int get_NumberOfExecutions();
    [CompilerGeneratedAttribute]
internal void set_NumberOfExecutions(int value);
    [CompilerGeneratedAttribute]
public Exception get_LastError();
    [CompilerGeneratedAttribute]
internal void set_LastError(Exception value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_LastCompletedUtc();
    [CompilerGeneratedAttribute]
internal void set_LastCompletedUtc(Nullable`1<DateTime> value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_SecondLastCompletedUtc();
    [CompilerGeneratedAttribute]
internal void set_SecondLastCompletedUtc(Nullable`1<DateTime> value);
    [CompilerGeneratedAttribute]
public ReportingInfo get_LastErrorReport();
    [CompilerGeneratedAttribute]
public void set_LastErrorReport(ReportingInfo value);
    [CompilerGeneratedAttribute]
public TelemetryBackgroundTaskLogEntry get_LastLogEntry();
    [CompilerGeneratedAttribute]
public void set_LastLogEntry(TelemetryBackgroundTaskLogEntry value);
    [CompilerGeneratedAttribute]
public string get_LastReference();
    [CompilerGeneratedAttribute]
internal void set_LastReference(string value);
    [CompilerGeneratedAttribute]
public string get_RayId();
    [CompilerGeneratedAttribute]
internal void set_RayId(string value);
}
public static class Momentum.Diagnostics.Telemetry.TelemetryConsole : object {
    private static TelemetryConsole();
    [ConsoleActionAttribute("Get telemetry flags")]
public static void Get_TelemetryFlag(ConsoleResult result, string cmd, Object[] args);
    [ConsoleActionAttribute("Set telemetry flag")]
public static void Set_TelemetryFlag(ConsoleResult result, string cmd, Object[] args);
}
public class Momentum.Diagnostics.Telemetry.TelemetryFlag : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DisplayName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsEnabled>k__BackingField;
    public string Name { get; private set; }
    public string DisplayName { get; private set; }
    public string Description { get; private set; }
    public bool IsEnabled { get; private set; }
    public TelemetryFlag(string name, string displayName, string description, bool enabled);
    internal void Update(string name, string displayName, string description);
    internal void SetEnabled(bool enable);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_DisplayName();
    [CompilerGeneratedAttribute]
private void set_DisplayName(string value);
    [CompilerGeneratedAttribute]
public string get_Description();
    [CompilerGeneratedAttribute]
private void set_Description(string value);
    [CompilerGeneratedAttribute]
public bool get_IsEnabled();
    [CompilerGeneratedAttribute]
private void set_IsEnabled(bool value);
}
public class Momentum.Diagnostics.Telemetry.TelemetryLogEventArgs : EventArgs {
}
public static class Momentum.Diagnostics.Telemetry.TelemetryServices : object {
    private static ITelemetryProvider[] providerArray;
    public static bool IsEnabled { get; }
    private static TelemetryServices();
    public static void AddProvider(ITelemetryProvider provider);
    public static void WriteGeneric(Object[] data);
    public static void WriteValue(string valueType, string instance, Nullable`1<decimal> value);
    public static void WriteValue(string valueType, string instance, object complexValue);
    public static void WriteTask(DateTime startUtc, TimeSpan processingTime, bool success, string exceptionTypeString, string taskName, string rayId, int attempt, string errorReport, Dictionary`2<string, string> context, string message, string technicalData, string errorMessage);
    public static void WriteEvent(string eventName, object context, Nullable`1<DateTime> startUtc, TimeSpan processingTime, bool success, string errorReport, string exceptionTypeString, string rayId, string message);
    public static void WriteEventRaw(string eventName, Nullable`1<DateTime> startUtc, TimeSpan processingTime, bool success, string errorReport, string exceptionTypeString, string rayId, Dictionary`2<string, string> context, string message);
    public static void WriteError(string errorReportGuid, string errorType, string errorMessage, object errorReport, string rayId, string localErrorReportNumber, string remoteErrorReportNumber);
    public static void WriteActivity(string activityName, Nullable`1<int> count, Nullable`1<bool> passive, bool personalinformation, Nullable`1<int> weight, object context);
    public static void WriteActivitySystem(string activityName, Nullable`1<int> count, Nullable`1<bool> passive, Nullable`1<int> weight, object context);
    public static void WriteActivityWithPersonalInformation(string activityName, string actorGuid, string actorCategory, string actorDisplayName, string actorEmail, Nullable`1<int> count, Nullable`1<bool> passive, string rayId, Nullable`1<int> weight, object context);
    public static void WriteServiceRequest(DateTime startUtc, Nullable`1<TimeSpan> elapsed, bool success, string exceptionTypeString, string serviceType, string operation, string apiKeyId, string rayId, string errorReport, string remoteHost, string requestAddress, Nullable`1<long> requestLength, string requestData, string actorLoginName, string actorDisplayName, Nullable`1<long> actorLoginLogId, string deviceId);
    public static void WriteWebRequest(DateTime startUtc, TimeSpan executionTime, bool success, string requestType, string address, long inputLength, string contentType, long outputLength, Uri uri, string rayId, string errorReport, string remoteHost, string requestData, string actorLoginName, string actorDisplayName, Nullable`1<long> actorLoginLogId, string exceptionType, string deviceId, string requestHeaders, string requestQueryString, string responseHeaders, string responseBody, Nullable`1<int> responseStatusCode, string responseStatusDescription, bool passive, string client, string clientVersion, string clientId, string userAgent, string serviceType, string operation, string apiKeyId, string usageType, Nullable`1<decimal> complexityCost, string errorClass, string origin, string referer, UsageContextData usageData);
    public static void WriteDatabaseAccess(DateTime startUtc, TimeSpan executionTime, string error, bool humanError, string type, string objectName, string commandText, string rayId, Nullable`1<long> responseLength, string deviceId);
    public static void SuggestShip();
    public static bool get_IsEnabled();
}
public static class Momentum.Exceptions.ErrorClassName : object {
    public static string User;
    public static string Api;
    public static string Client;
    public static string Timeout;
    public static string Other;
    [CompilerGeneratedAttribute]
private static String[] <CommonTypes>k__BackingField;
    public static String[] CommonTypes { get; }
    private static ErrorClassName();
    [CompilerGeneratedAttribute]
public static String[] get_CommonTypes();
    public static string ClassifyError(Exception error);
    public static string ClassifyError(string errorType, string errorMessage);
    public static string ClassifyErrorHttpStatusCode(Nullable`1<int> httpStatusCode);
    public static string ClassifyError(Exception error, Nullable`1<int> httpStatusCode);
}
public class Momentum.Exceptions.ExceptionUtility : object {
    public static bool FailRetry(Exception x, int attempt, int attempts);
}
public class Momentum.ExchangeErrorException : Exception {
    private string tip;
    private string title;
    private string errorReportNumber;
    public string Tip { get; }
    public string Title { get; }
    public string ErrorReportNumber { get; public set; }
    protected ExchangeErrorException(SerializationInfo info, StreamingContext context);
    public ExchangeErrorException(string message);
    public ExchangeErrorException(string message, Exception inner);
    public ExchangeErrorException(string message, string tip);
    public ExchangeErrorException(string message, Exception inner, string tip, string title);
    public ExchangeErrorException(string message, Exception inner, string tip);
    public string get_Tip();
    public string get_Title();
    public string get_ErrorReportNumber();
    public void set_ErrorReportNumber(string value);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
public interface Momentum.Extensibility.IInitializeNamedParameter {
    public abstract virtual void Initialize(NamedParameterCollection parameters);
}
public class Momentum.Hosting.HeaderFilterModule : object {
    public sealed virtual void Init(HttpApplication context);
    public sealed virtual void Dispose();
    private void context_BeginRequest(object sender, EventArgs e);
    private void context_EndRequest(object sender, EventArgs e);
    private void Context_PreSendRequestHeaders(object sender, EventArgs e);
    private static void CleanHeaders(HttpApplication app);
}
public static class Momentum.Hosting.PlatformRid : object {
    public static string WindowsX64;
    public static string LinuxX64;
    public static string LinuxArm64;
    public static string OsxX64;
    public static string OsxArm64;
    public static string GetRunnigId();
    public static bool IsWindows(string rid);
    public static bool IsLinux(string rid);
}
public class Momentum.Hosting.TrimHeadersHttpModule : object {
    private List`1<string> trimHeaders;
    public sealed virtual void Dispose();
    public sealed virtual void Init(HttpApplication context);
    private void OnPreSendRequestHeaders(object sender, EventArgs e);
}
[GeneratedCodeAttribute("System.Web.Services", "4.7.3056.0")]
[DebuggerStepThroughAttribute]
[DesignerCategoryAttribute("code")]
[WebServiceBindingAttribute]
public class Momentum.Hosting.WebService.ExceptionService : SoapHttpClientProtocol {
    private SendOrPostCallback WriteOperationCompleted;
    private bool useDefaultCredentialsSetExplicitly;
    [CompilerGeneratedAttribute]
private WriteCompletedEventHandler WriteCompleted;
    public string Url { get; public set; }
    public bool UseDefaultCredentials { get; public set; }
    public string get_Url();
    public void set_Url(string value);
    public bool get_UseDefaultCredentials();
    public void set_UseDefaultCredentials(bool value);
    [CompilerGeneratedAttribute]
public void add_WriteCompleted(WriteCompletedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_WriteCompleted(WriteCompletedEventHandler value);
    [SoapDocumentMethodAttribute]
public string Write(string applicationName, string serverName, string serverKey, string platformName, string errorTypeName, string errorName, string loginName, string source, string referer, string exceptionSource, string message, string stackTrace, string completeException, string requestForm, string requestHeaders, string queryParams, string cookies, string serverVariables, string additionalInfo, int priority);
    public void WriteAsync(string applicationName, string serverName, string serverKey, string platformName, string errorTypeName, string errorName, string loginName, string source, string referer, string exceptionSource, string message, string stackTrace, string completeException, string requestForm, string requestHeaders, string queryParams, string cookies, string serverVariables, string additionalInfo, int priority);
    public void WriteAsync(string applicationName, string serverName, string serverKey, string platformName, string errorTypeName, string errorName, string loginName, string source, string referer, string exceptionSource, string message, string stackTrace, string completeException, string requestForm, string requestHeaders, string queryParams, string cookies, string serverVariables, string additionalInfo, int priority, object userState);
    private void OnWriteOperationCompleted(object arg);
    public void CancelAsync(object userState);
    private bool IsLocalFileSystemWebService(string url);
}
[GeneratedCodeAttribute("System.Web.Services", "4.7.3056.0")]
[DebuggerStepThroughAttribute]
[DesignerCategoryAttribute("code")]
public class Momentum.Hosting.WebService.WriteCompletedEventArgs : AsyncCompletedEventArgs {
    private Object[] results;
    public string Result { get; }
    internal WriteCompletedEventArgs(Object[] results, Exception exception, bool cancelled, object userState);
    public string get_Result();
}
[GeneratedCodeAttribute("System.Web.Services", "4.7.3056.0")]
public class Momentum.Hosting.WebService.WriteCompletedEventHandler : MulticastDelegate {
    public WriteCompletedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, WriteCompletedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, WriteCompletedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public static class Momentum.IO.PathFormatUtility : object {
    public static string PlatformPath(string path);
    public static string PlatformPath(string path, string platformRid);
    public static string PlatformNaming(string name, string platformRid);
}
[GeneratedCodeAttribute("System.Xml", "4.7.3056.0")]
[DebuggerStepThroughAttribute]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
public class Momentum.Licencing.WebService.LicenceInfo : object {
    private int licenceIdField;
    private int customerIdField;
    private DateTime validFromField;
    private Nullable`1<DateTime> validToField;
    private string messageField;
    private string customerNameField;
    public int LicenceId { get; public set; }
    public int CustomerId { get; public set; }
    public DateTime ValidFrom { get; public set; }
    [XmlElementAttribute]
public Nullable`1<DateTime> ValidTo { get; public set; }
    public string Message { get; public set; }
    public string CustomerName { get; public set; }
    public int get_LicenceId();
    public void set_LicenceId(int value);
    public int get_CustomerId();
    public void set_CustomerId(int value);
    public DateTime get_ValidFrom();
    public void set_ValidFrom(DateTime value);
    public Nullable`1<DateTime> get_ValidTo();
    public void set_ValidTo(Nullable`1<DateTime> value);
    public string get_Message();
    public void set_Message(string value);
    public string get_CustomerName();
    public void set_CustomerName(string value);
}
[GeneratedCodeAttribute("System.Web.Services", "4.7.3056.0")]
[DebuggerStepThroughAttribute]
[DesignerCategoryAttribute("code")]
[WebServiceBindingAttribute]
public class Momentum.Licencing.WebService.LicenceVerificationService : SoapHttpClientProtocol {
    private SendOrPostCallback VerifyLicenceOperationCompleted;
    private bool useDefaultCredentialsSetExplicitly;
    [CompilerGeneratedAttribute]
private VerifyLicenceCompletedEventHandler VerifyLicenceCompleted;
    public string Url { get; public set; }
    public bool UseDefaultCredentials { get; public set; }
    public string get_Url();
    public void set_Url(string value);
    public bool get_UseDefaultCredentials();
    public void set_UseDefaultCredentials(bool value);
    [CompilerGeneratedAttribute]
public void add_VerifyLicenceCompleted(VerifyLicenceCompletedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_VerifyLicenceCompleted(VerifyLicenceCompletedEventHandler value);
    [SoapDocumentMethodAttribute]
public LicenceInfo VerifyLicence(string licenceVerificationPackage);
    public void VerifyLicenceAsync(string licenceVerificationPackage);
    public void VerifyLicenceAsync(string licenceVerificationPackage, object userState);
    private void OnVerifyLicenceOperationCompleted(object arg);
    public void CancelAsync(object userState);
    private bool IsLocalFileSystemWebService(string url);
}
[GeneratedCodeAttribute("System.Web.Services", "4.7.3056.0")]
[DebuggerStepThroughAttribute]
[DesignerCategoryAttribute("code")]
public class Momentum.Licencing.WebService.VerifyLicenceCompletedEventArgs : AsyncCompletedEventArgs {
    private Object[] results;
    public LicenceInfo Result { get; }
    internal VerifyLicenceCompletedEventArgs(Object[] results, Exception exception, bool cancelled, object userState);
    public LicenceInfo get_Result();
}
[GeneratedCodeAttribute("System.Web.Services", "4.7.3056.0")]
public class Momentum.Licencing.WebService.VerifyLicenceCompletedEventHandler : MulticastDelegate {
    public VerifyLicenceCompletedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, VerifyLicenceCompletedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, VerifyLicenceCompletedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[ExtensionAttribute]
public static class Momentum.Linq.LinqExtensions : object {
    [ExtensionAttribute]
public static void ForEach(IEnumerable`1<T> e, Action`1<T> a);
    [AsyncStateMachineAttribute("Momentum.Linq.LinqExtensions/<ForEachAsync>d__1`1")]
[ExtensionAttribute]
public static Task`1<int> ForEachAsync(IEnumerable`1<T> e, Func`2<T, Task> a);
    [ExtensionAttribute]
public static bool In(T source, T[] list);
    [ExtensionAttribute]
public static IEnumerable`1<T> DistinctBy(IEnumerable`1<T> items, Func`2<T, TKey> property);
    [ExtensionAttribute]
public static List`1<T> Process(List`1<T> t, Action`1<List`1<T>> processor);
    [ExtensionAttribute]
public static List`1<T> Concat(List`1<T> t, Func`2<List`1<T>, IEnumerable`1<T>> processor);
    [IteratorStateMachineAttribute("Momentum.Linq.LinqExtensions/<MakeGroupsOf>d__6`1")]
[ExtensionAttribute]
public static IEnumerable`1<IEnumerable`1<T>> MakeGroupsOf(IEnumerable`1<T> source, int count);
}
[GeneratedCodeAttribute("System.Web.Services", "4.7.3056.0")]
public class Momentum.Messaging.WebService.ClearMessageDeliveryWarningCompletedEventHandler : MulticastDelegate {
    public ClearMessageDeliveryWarningCompletedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, AsyncCompletedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, AsyncCompletedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[GeneratedCodeAttribute("System.Web.Services", "4.7.3056.0")]
public class Momentum.Messaging.WebService.ClearPermanentDeliveryFailureCompletedEventHandler : MulticastDelegate {
    public ClearPermanentDeliveryFailureCompletedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, AsyncCompletedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, AsyncCompletedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[GeneratedCodeAttribute("System.Web.Services", "4.7.3056.0")]
[DebuggerStepThroughAttribute]
[DesignerCategoryAttribute("code")]
public class Momentum.Messaging.WebService.GetDeliveryInfoByAddressCompletedEventArgs : AsyncCompletedEventArgs {
    private Object[] results;
    public MessageAddressDeliveryInfo Result { get; }
    internal GetDeliveryInfoByAddressCompletedEventArgs(Object[] results, Exception exception, bool cancelled, object userState);
    public MessageAddressDeliveryInfo get_Result();
}
[GeneratedCodeAttribute("System.Web.Services", "4.7.3056.0")]
public class Momentum.Messaging.WebService.GetDeliveryInfoByAddressCompletedEventHandler : MulticastDelegate {
    public GetDeliveryInfoByAddressCompletedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, GetDeliveryInfoByAddressCompletedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, GetDeliveryInfoByAddressCompletedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[GeneratedCodeAttribute("System.Xml", "4.7.3056.0")]
[DebuggerStepThroughAttribute]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
public class Momentum.Messaging.WebService.MessageAddressDeliveryInfo : object {
    private MessageAddressFailureInfo lastFailureField;
    private MessageDeliveryWarningInfo[] warningsField;
    private string addressField;
    private bool isWhitelistedField;
    private bool hasPermanentDeliveryFailureField;
    public MessageAddressFailureInfo LastFailure { get; public set; }
    public MessageDeliveryWarningInfo[] Warnings { get; public set; }
    public string Address { get; public set; }
    public bool IsWhitelisted { get; public set; }
    public bool HasPermanentDeliveryFailure { get; public set; }
    public MessageAddressFailureInfo get_LastFailure();
    public void set_LastFailure(MessageAddressFailureInfo value);
    public MessageDeliveryWarningInfo[] get_Warnings();
    public void set_Warnings(MessageDeliveryWarningInfo[] value);
    public string get_Address();
    public void set_Address(string value);
    public bool get_IsWhitelisted();
    public void set_IsWhitelisted(bool value);
    public bool get_HasPermanentDeliveryFailure();
    public void set_HasPermanentDeliveryFailure(bool value);
}
[GeneratedCodeAttribute("System.Xml", "4.7.3056.0")]
[DebuggerStepThroughAttribute]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
public class Momentum.Messaging.WebService.MessageAddressFailureInfo : object {
    private DateTime createdField;
    private long receivedMessageIdField;
    private string statusReportingMtaField;
    private string statusDiagnosticCodeField;
    private long deliveryFailureLogIdField;
    private string receivedMessageFromField;
    private string receivedMessageSubjectField;
    private string receivedMessageRemoteMessageIdField;
    private string relatedOutgoingMessageFromField;
    private DateTime relatedOutgoingMessageSentField;
    private string relatedOutgoingMessageSubjectField;
    private long relatedOutgoingMessageIdField;
    private string relatedOutgoingMessageViaField;
    private bool isTemporaryDeliveryFailureField;
    public DateTime Created { get; public set; }
    public long ReceivedMessageId { get; public set; }
    public string StatusReportingMta { get; public set; }
    public string StatusDiagnosticCode { get; public set; }
    public long DeliveryFailureLogId { get; public set; }
    public string ReceivedMessageFrom { get; public set; }
    public string ReceivedMessageSubject { get; public set; }
    public string ReceivedMessageRemoteMessageId { get; public set; }
    public string RelatedOutgoingMessageFrom { get; public set; }
    public DateTime RelatedOutgoingMessageSent { get; public set; }
    public string RelatedOutgoingMessageSubject { get; public set; }
    public long RelatedOutgoingMessageId { get; public set; }
    public string RelatedOutgoingMessageVia { get; public set; }
    public bool IsTemporaryDeliveryFailure { get; public set; }
    public DateTime get_Created();
    public void set_Created(DateTime value);
    public long get_ReceivedMessageId();
    public void set_ReceivedMessageId(long value);
    public string get_StatusReportingMta();
    public void set_StatusReportingMta(string value);
    public string get_StatusDiagnosticCode();
    public void set_StatusDiagnosticCode(string value);
    public long get_DeliveryFailureLogId();
    public void set_DeliveryFailureLogId(long value);
    public string get_ReceivedMessageFrom();
    public void set_ReceivedMessageFrom(string value);
    public string get_ReceivedMessageSubject();
    public void set_ReceivedMessageSubject(string value);
    public string get_ReceivedMessageRemoteMessageId();
    public void set_ReceivedMessageRemoteMessageId(string value);
    public string get_RelatedOutgoingMessageFrom();
    public void set_RelatedOutgoingMessageFrom(string value);
    public DateTime get_RelatedOutgoingMessageSent();
    public void set_RelatedOutgoingMessageSent(DateTime value);
    public string get_RelatedOutgoingMessageSubject();
    public void set_RelatedOutgoingMessageSubject(string value);
    public long get_RelatedOutgoingMessageId();
    public void set_RelatedOutgoingMessageId(long value);
    public string get_RelatedOutgoingMessageVia();
    public void set_RelatedOutgoingMessageVia(string value);
    public bool get_IsTemporaryDeliveryFailure();
    public void set_IsTemporaryDeliveryFailure(bool value);
}
[GeneratedCodeAttribute("System.Xml", "4.7.3056.0")]
[DebuggerStepThroughAttribute]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
public class Momentum.Messaging.WebService.MessageAttachment : object {
    private MessageAttachmentParameter[] parameterField;
    private MessageAttachmentBinderType typeField;
    private string fileNameInEmailField;
    private bool isLinkedResourceField;
    private string encodedParametersField;
    [XmlElementAttribute("Parameter")]
public MessageAttachmentParameter[] Parameter { get; public set; }
    [XmlAttributeAttribute]
public MessageAttachmentBinderType Type { get; public set; }
    [XmlAttributeAttribute]
public string FileNameInEmail { get; public set; }
    [XmlAttributeAttribute]
public bool IsLinkedResource { get; public set; }
    [XmlAttributeAttribute]
public string EncodedParameters { get; public set; }
    public MessageAttachmentParameter[] get_Parameter();
    public void set_Parameter(MessageAttachmentParameter[] value);
    public MessageAttachmentBinderType get_Type();
    public void set_Type(MessageAttachmentBinderType value);
    public string get_FileNameInEmail();
    public void set_FileNameInEmail(string value);
    public bool get_IsLinkedResource();
    public void set_IsLinkedResource(bool value);
    public string get_EncodedParameters();
    public void set_EncodedParameters(string value);
}
[GeneratedCodeAttribute("System.Xml", "4.7.3056.0")]
[XmlTypeAttribute]
public enum Momentum.Messaging.WebService.MessageAttachmentBinderType : Enum {
    public int value__;
    public static MessageAttachmentBinderType Report;
    public static MessageAttachmentBinderType Files;
    public static MessageAttachmentBinderType FileSystem;
    public static MessageAttachmentBinderType Web;
    public static MessageAttachmentBinderType TemporaryAttachment;
}
[GeneratedCodeAttribute("System.Xml", "4.7.3056.0")]
[DebuggerStepThroughAttribute]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
public class Momentum.Messaging.WebService.MessageAttachmentParameter : object {
    private object valueField;
    private string nameField;
    public object Value { get; public set; }
    [XmlAttributeAttribute]
public string Name { get; public set; }
    public object get_Value();
    public void set_Value(object value);
    public string get_Name();
    public void set_Name(string value);
}
[GeneratedCodeAttribute("System.Xml", "4.7.3056.0")]
[DebuggerStepThroughAttribute]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
public class Momentum.Messaging.WebService.MessageDeliveryWarningInfo : object {
    private long deliveryWarningLogIdField;
    private string systemNameField;
    private DateTime createdField;
    private DateTime expiresField;
    private string displayNameField;
    private string messageField;
    private bool showEndUserField;
    private bool showAdministratorField;
    private int existingActiveWarningsField;
    private string relatedOutgoingMessageFromField;
    private DateTime relatedOutgoingMessageSentField;
    private string relatedOutgoingMessageSubjectField;
    private long relatedOutgoingMessageIdField;
    private string relatedOutgoingMessageViaField;
    private string receivedMessageRemoteMessageIdField;
    private long receivedMessageIdField;
    public long DeliveryWarningLogId { get; public set; }
    public string SystemName { get; public set; }
    public DateTime Created { get; public set; }
    public DateTime Expires { get; public set; }
    public string DisplayName { get; public set; }
    public string Message { get; public set; }
    public bool ShowEndUser { get; public set; }
    public bool ShowAdministrator { get; public set; }
    public int ExistingActiveWarnings { get; public set; }
    public string RelatedOutgoingMessageFrom { get; public set; }
    public DateTime RelatedOutgoingMessageSent { get; public set; }
    public string RelatedOutgoingMessageSubject { get; public set; }
    public long RelatedOutgoingMessageId { get; public set; }
    public string RelatedOutgoingMessageVia { get; public set; }
    public string ReceivedMessageRemoteMessageId { get; public set; }
    public long ReceivedMessageId { get; public set; }
    public long get_DeliveryWarningLogId();
    public void set_DeliveryWarningLogId(long value);
    public string get_SystemName();
    public void set_SystemName(string value);
    public DateTime get_Created();
    public void set_Created(DateTime value);
    public DateTime get_Expires();
    public void set_Expires(DateTime value);
    public string get_DisplayName();
    public void set_DisplayName(string value);
    public string get_Message();
    public void set_Message(string value);
    public bool get_ShowEndUser();
    public void set_ShowEndUser(bool value);
    public bool get_ShowAdministrator();
    public void set_ShowAdministrator(bool value);
    public int get_ExistingActiveWarnings();
    public void set_ExistingActiveWarnings(int value);
    public string get_RelatedOutgoingMessageFrom();
    public void set_RelatedOutgoingMessageFrom(string value);
    public DateTime get_RelatedOutgoingMessageSent();
    public void set_RelatedOutgoingMessageSent(DateTime value);
    public string get_RelatedOutgoingMessageSubject();
    public void set_RelatedOutgoingMessageSubject(string value);
    public long get_RelatedOutgoingMessageId();
    public void set_RelatedOutgoingMessageId(long value);
    public string get_RelatedOutgoingMessageVia();
    public void set_RelatedOutgoingMessageVia(string value);
    public string get_ReceivedMessageRemoteMessageId();
    public void set_ReceivedMessageRemoteMessageId(string value);
    public long get_ReceivedMessageId();
    public void set_ReceivedMessageId(long value);
}
[GeneratedCodeAttribute("System.Xml", "4.7.3056.0")]
[XmlTypeAttribute]
public enum Momentum.Messaging.WebService.MessageFormat : Enum {
    public int value__;
    public static MessageFormat Default;
    public static MessageFormat Html;
}
[GeneratedCodeAttribute("System.Xml", "4.7.3056.0")]
[XmlTypeAttribute]
public enum Momentum.Messaging.WebService.MessagePriority : Enum {
    public int value__;
    public static MessagePriority Low;
    public static MessagePriority Normal;
    public static MessagePriority High;
}
[GeneratedCodeAttribute("System.Xml", "4.7.3056.0")]
[DebuggerStepThroughAttribute]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
public class Momentum.Messaging.WebService.MessageTemplateDataNode : object {
    private MessageTemplateDataNode[] nodeField;
    private string nameField;
    private string contentField;
    [XmlElementAttribute("Node")]
public MessageTemplateDataNode[] Node { get; public set; }
    [XmlAttributeAttribute]
public string Name { get; public set; }
    [XmlAttributeAttribute]
public string Content { get; public set; }
    public MessageTemplateDataNode[] get_Node();
    public void set_Node(MessageTemplateDataNode[] value);
    public string get_Name();
    public void set_Name(string value);
    public string get_Content();
    public void set_Content(string value);
}
[GeneratedCodeAttribute("System.Xml", "4.7.3056.0")]
[DebuggerStepThroughAttribute]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
public class Momentum.Messaging.WebService.MessageTemplateSendData : object {
    private MessageTemplateDataNode rootField;
    public MessageTemplateDataNode Root { get; public set; }
    public MessageTemplateDataNode get_Root();
    public void set_Root(MessageTemplateDataNode value);
}
[GeneratedCodeAttribute("System.Xml", "4.7.3056.0")]
[DebuggerStepThroughAttribute]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
public class Momentum.Messaging.WebService.MessageTemplateSendRequest : object {
    private MessageTemplateSendData dataField;
    private MessageTemplateSendTarget[] targetsField;
    private MessageAttachment[] attachmentsField;
    private string applicationField;
    private string templateTypeSystemNameField;
    private string applicationCustomPublicDataField;
    private int lcidField;
    public MessageTemplateSendData Data { get; public set; }
    public MessageTemplateSendTarget[] Targets { get; public set; }
    public MessageAttachment[] Attachments { get; public set; }
    [XmlAttributeAttribute]
public string Application { get; public set; }
    [XmlAttributeAttribute]
public string TemplateTypeSystemName { get; public set; }
    [XmlAttributeAttribute]
public string ApplicationCustomPublicData { get; public set; }
    [XmlAttributeAttribute]
public int Lcid { get; public set; }
    public MessageTemplateSendData get_Data();
    public void set_Data(MessageTemplateSendData value);
    public MessageTemplateSendTarget[] get_Targets();
    public void set_Targets(MessageTemplateSendTarget[] value);
    public MessageAttachment[] get_Attachments();
    public void set_Attachments(MessageAttachment[] value);
    public string get_Application();
    public void set_Application(string value);
    public string get_TemplateTypeSystemName();
    public void set_TemplateTypeSystemName(string value);
    public string get_ApplicationCustomPublicData();
    public void set_ApplicationCustomPublicData(string value);
    public int get_Lcid();
    public void set_Lcid(int value);
}
[GeneratedCodeAttribute("System.Xml", "4.7.3056.0")]
[DebuggerStepThroughAttribute]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
public class Momentum.Messaging.WebService.MessageTemplateSendResponse : object {
    private int enqueuedMessagesField;
    public int EnqueuedMessages { get; public set; }
    public int get_EnqueuedMessages();
    public void set_EnqueuedMessages(int value);
}
[GeneratedCodeAttribute("System.Xml", "4.7.3056.0")]
[DebuggerStepThroughAttribute]
[DesignerCategoryAttribute("code")]
[XmlTypeAttribute]
public class Momentum.Messaging.WebService.MessageTemplateSendTarget : object {
    private string addressField;
    private string displayNameField;
    private MessageType messageTypeField;
    [XmlAttributeAttribute]
public string Address { get; public set; }
    [XmlAttributeAttribute]
public string DisplayName { get; public set; }
    [XmlAttributeAttribute]
public MessageType MessageType { get; public set; }
    public string get_Address();
    public void set_Address(string value);
    public string get_DisplayName();
    public void set_DisplayName(string value);
    public MessageType get_MessageType();
    public void set_MessageType(MessageType value);
}
[GeneratedCodeAttribute("System.Xml", "4.7.3056.0")]
[XmlTypeAttribute]
public enum Momentum.Messaging.WebService.MessageType : Enum {
    public int value__;
    public static MessageType Fax;
    public static MessageType Print;
    public static MessageType Email;
    public static MessageType Sms;
    public static MessageType Letter;
}
[GeneratedCodeAttribute("System.Web.Services", "4.7.3056.0")]
[DebuggerStepThroughAttribute]
[DesignerCategoryAttribute("code")]
[WebServiceBindingAttribute]
public class Momentum.Messaging.WebService.MessagingService : SoapHttpClientProtocol {
    private SendOrPostCallback SaveTemporaryAttachmentFileOperationCompleted;
    private SendOrPostCallback SendOperationCompleted;
    private SendOrPostCallback SendOneWayOperationCompleted;
    private SendOrPostCallback SendTemplateOperationCompleted;
    private SendOrPostCallback RegisterApplicationOperationCompleted;
    private SendOrPostCallback ClearPermanentDeliveryFailureOperationCompleted;
    private SendOrPostCallback ClearMessageDeliveryWarningOperationCompleted;
    private SendOrPostCallback GetDeliveryInfoByAddressOperationCompleted;
    private bool useDefaultCredentialsSetExplicitly;
    [CompilerGeneratedAttribute]
private SaveTemporaryAttachmentFileCompletedEventHandler SaveTemporaryAttachmentFileCompleted;
    [CompilerGeneratedAttribute]
private SendCompletedEventHandler SendCompleted;
    [CompilerGeneratedAttribute]
private SendOneWayCompletedEventHandler SendOneWayCompleted;
    [CompilerGeneratedAttribute]
private SendTemplateCompletedEventHandler SendTemplateCompleted;
    [CompilerGeneratedAttribute]
private RegisterApplicationCompletedEventHandler RegisterApplicationCompleted;
    [CompilerGeneratedAttribute]
private ClearPermanentDeliveryFailureCompletedEventHandler ClearPermanentDeliveryFailureCompleted;
    [CompilerGeneratedAttribute]
private ClearMessageDeliveryWarningCompletedEventHandler ClearMessageDeliveryWarningCompleted;
    [CompilerGeneratedAttribute]
private GetDeliveryInfoByAddressCompletedEventHandler GetDeliveryInfoByAddressCompleted;
    public string Url { get; public set; }
    public bool UseDefaultCredentials { get; public set; }
    public string get_Url();
    public void set_Url(string value);
    public bool get_UseDefaultCredentials();
    public void set_UseDefaultCredentials(bool value);
    [CompilerGeneratedAttribute]
public void add_SaveTemporaryAttachmentFileCompleted(SaveTemporaryAttachmentFileCompletedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_SaveTemporaryAttachmentFileCompleted(SaveTemporaryAttachmentFileCompletedEventHandler value);
    [CompilerGeneratedAttribute]
public void add_SendCompleted(SendCompletedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_SendCompleted(SendCompletedEventHandler value);
    [CompilerGeneratedAttribute]
public void add_SendOneWayCompleted(SendOneWayCompletedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_SendOneWayCompleted(SendOneWayCompletedEventHandler value);
    [CompilerGeneratedAttribute]
public void add_SendTemplateCompleted(SendTemplateCompletedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_SendTemplateCompleted(SendTemplateCompletedEventHandler value);
    [CompilerGeneratedAttribute]
public void add_RegisterApplicationCompleted(RegisterApplicationCompletedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_RegisterApplicationCompleted(RegisterApplicationCompletedEventHandler value);
    [CompilerGeneratedAttribute]
public void add_ClearPermanentDeliveryFailureCompleted(ClearPermanentDeliveryFailureCompletedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_ClearPermanentDeliveryFailureCompleted(ClearPermanentDeliveryFailureCompletedEventHandler value);
    [CompilerGeneratedAttribute]
public void add_ClearMessageDeliveryWarningCompleted(ClearMessageDeliveryWarningCompletedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_ClearMessageDeliveryWarningCompleted(ClearMessageDeliveryWarningCompletedEventHandler value);
    [CompilerGeneratedAttribute]
public void add_GetDeliveryInfoByAddressCompleted(GetDeliveryInfoByAddressCompletedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_GetDeliveryInfoByAddressCompleted(GetDeliveryInfoByAddressCompletedEventHandler value);
    [SoapDocumentMethodAttribute]
public long SaveTemporaryAttachmentFile(string application, string mimeType, Byte[] data);
    public void SaveTemporaryAttachmentFileAsync(string application, string mimeType, Byte[] data);
    public void SaveTemporaryAttachmentFileAsync(string application, string mimeType, Byte[] data, object userState);
    private void OnSaveTemporaryAttachmentFileOperationCompleted(object arg);
    [SoapDocumentMethodAttribute]
public long Send(string application, string from, string to, string subject, string body, MessagePriority messagePriority, string carbonCopy, string blindCarbonCopy, MessageType type, MessageFormat format, QueuePriority queuePriority, Nullable`1<DateTime> storeExpire, MessageAttachment[] attachments, string replyTo, string applicationCustomPublicData, bool test, string receiverGuid);
    public void SendAsync(string application, string from, string to, string subject, string body, MessagePriority messagePriority, string carbonCopy, string blindCarbonCopy, MessageType type, MessageFormat format, QueuePriority queuePriority, Nullable`1<DateTime> storeExpire, MessageAttachment[] attachments, string replyTo, string applicationCustomPublicData, bool test, string receiverGuid);
    public void SendAsync(string application, string from, string to, string subject, string body, MessagePriority messagePriority, string carbonCopy, string blindCarbonCopy, MessageType type, MessageFormat format, QueuePriority queuePriority, Nullable`1<DateTime> storeExpire, MessageAttachment[] attachments, string replyTo, string applicationCustomPublicData, bool test, string receiverGuid, object userState);
    private void OnSendOperationCompleted(object arg);
    [SoapDocumentMethodAttribute]
public long SendOneWay(string application, string from, string to, string subject, string body, MessagePriority messagePriority, string carbonCopy, string blindCarbonCopy, MessageType type, MessageFormat format, QueuePriority queuePriority, Nullable`1<DateTime> storeExpire, MessageAttachment[] attachments, string replyTo, string applicationCustomPublicData, bool test, string receiverGuid);
    public void SendOneWayAsync(string application, string from, string to, string subject, string body, MessagePriority messagePriority, string carbonCopy, string blindCarbonCopy, MessageType type, MessageFormat format, QueuePriority queuePriority, Nullable`1<DateTime> storeExpire, MessageAttachment[] attachments, string replyTo, string applicationCustomPublicData, bool test, string receiverGuid);
    public void SendOneWayAsync(string application, string from, string to, string subject, string body, MessagePriority messagePriority, string carbonCopy, string blindCarbonCopy, MessageType type, MessageFormat format, QueuePriority queuePriority, Nullable`1<DateTime> storeExpire, MessageAttachment[] attachments, string replyTo, string applicationCustomPublicData, bool test, string receiverGuid, object userState);
    private void OnSendOneWayOperationCompleted(object arg);
    [SoapDocumentMethodAttribute]
public MessageTemplateSendResponse SendTemplate(MessageTemplateSendRequest request);
    public void SendTemplateAsync(MessageTemplateSendRequest request);
    public void SendTemplateAsync(MessageTemplateSendRequest request, object userState);
    private void OnSendTemplateOperationCompleted(object arg);
    [SoapDocumentMethodAttribute]
public int RegisterApplication(string systemName, string description, string server);
    public void RegisterApplicationAsync(string systemName, string description, string server);
    public void RegisterApplicationAsync(string systemName, string description, string server, object userState);
    private void OnRegisterApplicationOperationCompleted(object arg);
    [SoapDocumentMethodAttribute]
public void ClearPermanentDeliveryFailure(string address);
    public void ClearPermanentDeliveryFailureAsync(string address);
    public void ClearPermanentDeliveryFailureAsync(string address, object userState);
    private void OnClearPermanentDeliveryFailureOperationCompleted(object arg);
    [SoapDocumentMethodAttribute]
public void ClearMessageDeliveryWarning(string address, string warningTypeSystemName);
    public void ClearMessageDeliveryWarningAsync(string address, string warningTypeSystemName);
    public void ClearMessageDeliveryWarningAsync(string address, string warningTypeSystemName, object userState);
    private void OnClearMessageDeliveryWarningOperationCompleted(object arg);
    [SoapDocumentMethodAttribute]
public MessageAddressDeliveryInfo GetDeliveryInfoByAddress(string address);
    public void GetDeliveryInfoByAddressAsync(string address);
    public void GetDeliveryInfoByAddressAsync(string address, object userState);
    private void OnGetDeliveryInfoByAddressOperationCompleted(object arg);
    public void CancelAsync(object userState);
    private bool IsLocalFileSystemWebService(string url);
}
[GeneratedCodeAttribute("System.Xml", "4.7.3056.0")]
[XmlTypeAttribute]
public enum Momentum.Messaging.WebService.QueuePriority : Enum {
    public int value__;
    public static QueuePriority Low;
    public static QueuePriority Medium;
    public static QueuePriority High;
    public static QueuePriority Instant;
}
[GeneratedCodeAttribute("System.Web.Services", "4.7.3056.0")]
[DebuggerStepThroughAttribute]
[DesignerCategoryAttribute("code")]
public class Momentum.Messaging.WebService.RegisterApplicationCompletedEventArgs : AsyncCompletedEventArgs {
    private Object[] results;
    public int Result { get; }
    internal RegisterApplicationCompletedEventArgs(Object[] results, Exception exception, bool cancelled, object userState);
    public int get_Result();
}
[GeneratedCodeAttribute("System.Web.Services", "4.7.3056.0")]
public class Momentum.Messaging.WebService.RegisterApplicationCompletedEventHandler : MulticastDelegate {
    public RegisterApplicationCompletedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, RegisterApplicationCompletedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, RegisterApplicationCompletedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[GeneratedCodeAttribute("System.Web.Services", "4.7.3056.0")]
[DebuggerStepThroughAttribute]
[DesignerCategoryAttribute("code")]
public class Momentum.Messaging.WebService.SaveTemporaryAttachmentFileCompletedEventArgs : AsyncCompletedEventArgs {
    private Object[] results;
    public long Result { get; }
    internal SaveTemporaryAttachmentFileCompletedEventArgs(Object[] results, Exception exception, bool cancelled, object userState);
    public long get_Result();
}
[GeneratedCodeAttribute("System.Web.Services", "4.7.3056.0")]
public class Momentum.Messaging.WebService.SaveTemporaryAttachmentFileCompletedEventHandler : MulticastDelegate {
    public SaveTemporaryAttachmentFileCompletedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, SaveTemporaryAttachmentFileCompletedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, SaveTemporaryAttachmentFileCompletedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[GeneratedCodeAttribute("System.Web.Services", "4.7.3056.0")]
[DebuggerStepThroughAttribute]
[DesignerCategoryAttribute("code")]
public class Momentum.Messaging.WebService.SendCompletedEventArgs : AsyncCompletedEventArgs {
    private Object[] results;
    public long Result { get; }
    internal SendCompletedEventArgs(Object[] results, Exception exception, bool cancelled, object userState);
    public long get_Result();
}
[GeneratedCodeAttribute("System.Web.Services", "4.7.3056.0")]
public class Momentum.Messaging.WebService.SendCompletedEventHandler : MulticastDelegate {
    public SendCompletedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, SendCompletedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, SendCompletedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[GeneratedCodeAttribute("System.Web.Services", "4.7.3056.0")]
[DebuggerStepThroughAttribute]
[DesignerCategoryAttribute("code")]
public class Momentum.Messaging.WebService.SendOneWayCompletedEventArgs : AsyncCompletedEventArgs {
    private Object[] results;
    public long Result { get; }
    internal SendOneWayCompletedEventArgs(Object[] results, Exception exception, bool cancelled, object userState);
    public long get_Result();
}
[GeneratedCodeAttribute("System.Web.Services", "4.7.3056.0")]
public class Momentum.Messaging.WebService.SendOneWayCompletedEventHandler : MulticastDelegate {
    public SendOneWayCompletedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, SendOneWayCompletedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, SendOneWayCompletedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[GeneratedCodeAttribute("System.Web.Services", "4.7.3056.0")]
[DebuggerStepThroughAttribute]
[DesignerCategoryAttribute("code")]
public class Momentum.Messaging.WebService.SendTemplateCompletedEventArgs : AsyncCompletedEventArgs {
    private Object[] results;
    public MessageTemplateSendResponse Result { get; }
    internal SendTemplateCompletedEventArgs(Object[] results, Exception exception, bool cancelled, object userState);
    public MessageTemplateSendResponse get_Result();
}
[GeneratedCodeAttribute("System.Web.Services", "4.7.3056.0")]
public class Momentum.Messaging.WebService.SendTemplateCompletedEventHandler : MulticastDelegate {
    public SendTemplateCompletedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, SendTemplateCompletedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, SendTemplateCompletedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public abstract class Momentum.OperatingSystem : object {
    public static bool IsWindows();
    public static bool IsLinux();
}
[CompilerGeneratedAttribute]
[GeneratedCodeAttribute("Microsoft.VisualStudio.Editors.SettingsDesigner.SettingsSingleFileGenerator", "15.7.0.0")]
internal class Momentum.Properties.Settings : ApplicationSettingsBase {
    private static Settings defaultInstance;
    public static Settings Default { get; }
    [ApplicationScopedSettingAttribute]
[DebuggerNonUserCodeAttribute]
[SpecialSettingAttribute]
[DefaultSettingValueAttribute("http://legacy-api-holzer.momentum.se/Business/LicenceVerificationService.asmx")]
public string Holzer_Common_WebServices_Licencing_LicenceVerificationService { get; }
    [ApplicationScopedSettingAttribute]
[DebuggerNonUserCodeAttribute]
[SpecialSettingAttribute]
[DefaultSettingValueAttribute("http://dev.holzer.se/Hosting/Services/2004/ExceptionService.asmx")]
public string Holzer_Common_Hosting_WebService_ExceptionService { get; }
    [ApplicationScopedSettingAttribute]
[DebuggerNonUserCodeAttribute]
[SpecialSettingAttribute]
[DefaultSettingValueAttribute("http://hsweb2:21005/Services/Messaging.asmx")]
public string Holzer_Common_Messaging_WebService_MessagingService { get; }
    private static Settings();
    public static Settings get_Default();
    public string get_Holzer_Common_WebServices_Licencing_LicenceVerificationService();
    public string get_Holzer_Common_Hosting_WebService_ExceptionService();
    public string get_Holzer_Common_Messaging_WebService_MessagingService();
}
public class Momentum.Security.Storage.AppProtectedData`1 : object {
    [CompilerGeneratedAttribute]
private string <KeyId>k__BackingField;
    [CompilerGeneratedAttribute]
private T <Result>k__BackingField;
    public string KeyId { get; public set; }
    public T Result { get; public set; }
    public AppProtectedData`1(string keyId, T encryptedData);
    [CompilerGeneratedAttribute]
public string get_KeyId();
    [CompilerGeneratedAttribute]
public void set_KeyId(string value);
    [CompilerGeneratedAttribute]
public T get_Result();
    [CompilerGeneratedAttribute]
public void set_Result(T value);
}
public class Momentum.Security.Storage.AppProtectedStorage : object {
    private ICryptoService cryptoService;
    private IDataProtectionKeys dataProtectionKeys;
    [CompilerGeneratedAttribute]
private static IAppProtectedStorage <Default>k__BackingField;
    public static IAppProtectedStorage Default { get; public set; }
    public AppProtectedStorage(ICryptoService cryptoService, IDataProtectionKeys dataProtectionKeys);
    private static AppProtectedStorage();
    [CompilerGeneratedAttribute]
public static IAppProtectedStorage get_Default();
    [CompilerGeneratedAttribute]
public static void set_Default(IAppProtectedStorage value);
    public sealed virtual bool IsAvailable();
    public sealed virtual AppProtectedData`1<string> ProtectString(CryptoDataType dataType, string data, int plainBytesMaxLength);
    public sealed virtual string UnprotectString(CryptoDataType dataType, string data);
    private static string FromBase64StringWebToString(string v);
    private static string ToBase64StringWeb(string v);
    [CompilerGeneratedAttribute]
private SymmetricCryptoKey <UnprotectString>b__9_0(string kid);
}
public interface Momentum.Security.Storage.IAppProtectedStorage {
    public abstract virtual bool IsAvailable();
    public abstract virtual AppProtectedData`1<string> ProtectString(CryptoDataType dataType, string data, int plainBytesMaxLength);
    public abstract virtual string UnprotectString(CryptoDataType dataType, string data);
}
public interface Momentum.Services.IServiceClientCache`1 {
    public abstract virtual void Invoke(Action`1<ServiceClient`1<TServiceClient>> action);
    public abstract virtual TResult Invoke(Func`2<ServiceClient`1<TServiceClient>, TResult> action);
    public abstract virtual Task InvokeAsync(Func`2<ServiceClient`1<TServiceClient>, Task> action, bool continueOnCapturedContext);
    public abstract virtual Task`1<TResult> InvokeAsync(Func`2<ServiceClient`1<TServiceClient>, Task`1<TResult>> action, bool continueOnCapturedContext);
    public abstract virtual TResult InvokeWithRetry(Func`2<ServiceClient`1<TServiceClient>, TResult> action, int attempts);
    public abstract virtual Task`1<TResult> InvokeWithRetryAsync(Func`2<ServiceClient`1<TServiceClient>, Task`1<TResult>> action, int attempts);
    public abstract virtual void InvokeWithRetry(Action`1<ServiceClient`1<TServiceClient>> action, int attempts);
}
public class Momentum.Services.ServiceClientCache`1 : object {
    private Func`1<ServiceClient`1<TServiceClient>> connector;
    private ServiceClient`1<TServiceClient> cachedClient;
    public ServiceClientCache`1(Func`1<ServiceClient`1<TServiceClient>> connector);
    private void SetConnector(Func`1<ServiceClient`1<TServiceClient>> connector);
    public sealed virtual void Invoke(Action`1<ServiceClient`1<TServiceClient>> action);
    public sealed virtual TResult Invoke(Func`2<ServiceClient`1<TServiceClient>, TResult> action);
    [AsyncStateMachineAttribute("Momentum.Services.ServiceClientCache`1/<InvokeAsync>d__6")]
public sealed virtual Task InvokeAsync(Func`2<ServiceClient`1<TServiceClient>, Task> action, bool continueOnCapturedContext);
    [AsyncStateMachineAttribute("Momentum.Services.ServiceClientCache`1/<InvokeAsync>d__7`1")]
public sealed virtual Task`1<TResult> InvokeAsync(Func`2<ServiceClient`1<TServiceClient>, Task`1<TResult>> action, bool continueOnCapturedContext);
    [DebuggerStepThroughAttribute]
public sealed virtual TResult InvokeWithRetry(Func`2<ServiceClient`1<TServiceClient>, TResult> action, int attempts);
    [AsyncStateMachineAttribute("Momentum.Services.ServiceClientCache`1/<InvokeWithRetryAsync>d__9`1")]
[DebuggerStepThroughAttribute]
public sealed virtual Task`1<TResult> InvokeWithRetryAsync(Func`2<ServiceClient`1<TServiceClient>, Task`1<TResult>> action, int attempts);
    public sealed virtual void InvokeWithRetry(Action`1<ServiceClient`1<TServiceClient>> action, int attempts);
    [AsyncStateMachineAttribute("Momentum.Services.ServiceClientCache`1/<InvokeWithRetryAsync>d__11")]
public Task InvokeWithRetryAsync(Func`2<ServiceClient`1<TServiceClient>, Task> action, int attempts);
    public ServiceClient`1<TServiceClient> GetClient();
    private static bool SafeToRetry(Exception x);
}
public class Momentum.Services.ServiceDirectory.ServiceAddressInfoKeyData : object {
    [CompilerGeneratedAttribute]
private string <Purpose>k__BackingField;
    [CompilerGeneratedAttribute]
private string <KeyId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Data>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Thumbprint>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <NotBefore>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <NotAfter>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <RevokeAfter>k__BackingField;
    public string Purpose { get; public set; }
    public string KeyId { get; public set; }
    public string Type { get; public set; }
    public string Data { get; public set; }
    public string Thumbprint { get; public set; }
    public DateTime NotBefore { get; public set; }
    public DateTime NotAfter { get; public set; }
    public Nullable`1<DateTime> RevokeAfter { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Purpose();
    [CompilerGeneratedAttribute]
public void set_Purpose(string value);
    [CompilerGeneratedAttribute]
public string get_KeyId();
    [CompilerGeneratedAttribute]
public void set_KeyId(string value);
    [CompilerGeneratedAttribute]
public string get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(string value);
    [CompilerGeneratedAttribute]
public string get_Data();
    [CompilerGeneratedAttribute]
public void set_Data(string value);
    [CompilerGeneratedAttribute]
public string get_Thumbprint();
    [CompilerGeneratedAttribute]
public void set_Thumbprint(string value);
    [CompilerGeneratedAttribute]
public DateTime get_NotBefore();
    [CompilerGeneratedAttribute]
public void set_NotBefore(DateTime value);
    [CompilerGeneratedAttribute]
public DateTime get_NotAfter();
    [CompilerGeneratedAttribute]
public void set_NotAfter(DateTime value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_RevokeAfter();
    [CompilerGeneratedAttribute]
public void set_RevokeAfter(Nullable`1<DateTime> value);
}
public class Momentum.Services.ServiceDirectory.ServiceAddressKey : object {
    private string certificateData;
    private X509Certificate2 certificate;
    [CompilerGeneratedAttribute]
private string <Purpose>k__BackingField;
    [CompilerGeneratedAttribute]
private string <KeyId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CertificateThumbprint>k__BackingField;
    public string Purpose { get; }
    public string KeyId { get; }
    public string Type { get; }
    public string CertificateThumbprint { get; }
    public ServiceAddressKey(ServiceAddressInfoKeyData data);
    [CompilerGeneratedAttribute]
public string get_Purpose();
    [CompilerGeneratedAttribute]
public string get_KeyId();
    [CompilerGeneratedAttribute]
public string get_Type();
    public X509Certificate2 GetCertificate();
    [CompilerGeneratedAttribute]
public string get_CertificateThumbprint();
}
public enum Momentum.Text.SerializationDateFormat : Enum {
    public int value__;
    public static SerializationDateFormat TimestampOffset;
    public static SerializationDateFormat Iso8601;
}
[ExtensionAttribute]
public static class Momentum.Text.StringExtensions : object {
    [ExtensionAttribute]
public static string ToUpperFirstChar(string v);
    [ExtensionAttribute]
public static string ToLowerFirstChar(string v);
}
public class Momentum.Threading.Breakers.CircuitBreakerCounter : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Value>k__BackingField;
    public string Name { get; }
    public long Value { get; }
    public CircuitBreakerCounter(string name, long value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public long get_Value();
}
public static class Momentum.Threading.Breakers.CircuitBreakerManager : object {
    private static ConcurrentBag`1<ICircuitBreaker> breakers;
    private static int initialize;
    public static int BreakerCount { get; }
    private static CircuitBreakerManager();
    public static void Register(ICircuitBreaker breaker);
    public static IEnumerable`1<ICircuitBreaker> GetBreakerList();
    public static int get_BreakerCount();
}
internal class Momentum.Threading.Breakers.CircuitBreakerSelfTest : object {
    private static string CheckName;
    public sealed virtual void CollectTestResult(SelfTestResult result);
}
public interface Momentum.Threading.Breakers.ICircuitBreaker {
    public string DisplayName { get; }
    public string SystemName { get; }
    public string Status { get; }
    public bool IsOpen { get; }
    public Exception LastError { get; }
    public abstract virtual string get_DisplayName();
    public abstract virtual string get_SystemName();
    public abstract virtual string get_Status();
    public abstract virtual bool get_IsOpen();
    public abstract virtual Exception get_LastError();
    public abstract virtual IEnumerable`1<CircuitBreakerCounter> GetCounters();
}
public static class Momentum.Threading.StaticRandom : object {
    private static Random global;
    [ThreadStaticAttribute]
private static Random local;
    private static Random Instance { get; }
    private static StaticRandom();
    private static Random get_Instance();
    public static int Next();
    public static int Next(int minValue, int maxValue);
}
[ExtensionAttribute]
public static class System.Runtime.Remoting.Channels.ITransportHeadersExtensions : object {
    [ExtensionAttribute]
public static string GetRemoteHostDataString(ITransportHeaders requestHeaders);
}
[ExtensionAttribute]
public static class System.ServiceModel.OperationContextExtensions : object {
    [ExtensionAttribute]
public static string GetRemoteHostDataString(OperationContext context);
    public static string GetRemoteHostDataString(IDictionary`2<string, object> properties, Func`3<string, string, string> messageHeader);
    [ExtensionAttribute]
public static string GetDeviceIdString(OperationContext context);
    public static string GetDeviceKeyString(IDictionary`2<string, object> properties, Func`3<string, string, string> messageHeader);
    [ExtensionAttribute]
public static string GetTargetDataString(OperationContext context);
}
[ExtensionAttribute]
public static class System.Web.HttpRequestExtensions : object {
    private static string MimeTypeJson;
    private static string Ipv6Ipv4SubnetPrefix;
    [ExtensionAttribute]
public static bool IsJsonRequest(HttpRequestMessage request);
    [ExtensionAttribute]
public static string GetRemoteHostDataString(HttpRequest request);
    [ExtensionAttribute]
public static string GetRemoteHostDataString(HttpRequestBase request);
    [ExtensionAttribute]
public static string GetDeviceKey(HttpRequest request, bool required);
}
