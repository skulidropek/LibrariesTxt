[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
public class MongoDB.Driver.BatchTransformingAsyncCursor`2 : object {
    private bool _disposed;
    private Func`2<IEnumerable`1<TFromDocument>, IEnumerable`1<TToDocument>> _transformer;
    private IAsyncCursor`1<TFromDocument> _wrapped;
    private List`1<TToDocument> _current;
    public IEnumerable`1<TToDocument> Current { get; }
    public BatchTransformingAsyncCursor`2(IAsyncCursor`1<TFromDocument> wrapped, Func`2<IEnumerable`1<TFromDocument>, IEnumerable`1<TToDocument>> transformer);
    public sealed virtual IEnumerable`1<TToDocument> get_Current();
    public sealed virtual bool MoveNext(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MongoDB.Driver.BatchTransformingAsyncCursor`2/<MoveNextAsync>d__8")]
public sealed virtual Task`1<bool> MoveNextAsync(CancellationToken cancellationToken);
    public sealed virtual void Dispose();
    private void ThrowIfDisposed();
}
[BsonSerializerAttribute("MongoDB.Driver.ChangeStreamDocumentSerializer`1")]
public class MongoDB.Driver.ChangeStreamDocument`1 : BsonDocumentBackedClass {
    public BsonDocument BackingDocument { get; }
    public BsonTimestamp ClusterTime { get; }
    public CollectionNamespace CollectionNamespace { get; }
    public Nullable`1<Guid> CollectionUuid { get; }
    public DatabaseNamespace DatabaseNamespace { get; }
    public BsonDocument DisambiguatedPaths { get; }
    public BsonDocument DocumentKey { get; }
    public TDocument FullDocument { get; }
    public TDocument FullDocumentBeforeChange { get; }
    public BsonDocument OperationDescription { get; }
    public ChangeStreamOperationType OperationType { get; }
    public CollectionNamespace RenameTo { get; }
    public BsonDocument ResumeToken { get; }
    public ChangeStreamSplitEvent SplitEvent { get; }
    public ChangeStreamUpdateDescription UpdateDescription { get; }
    public Nullable`1<DateTime> WallTime { get; }
    public ChangeStreamDocument`1(BsonDocument backingDocument, IBsonSerializer`1<TDocument> documentSerializer);
    public BsonDocument get_BackingDocument();
    public BsonTimestamp get_ClusterTime();
    public CollectionNamespace get_CollectionNamespace();
    public Nullable`1<Guid> get_CollectionUuid();
    public DatabaseNamespace get_DatabaseNamespace();
    public BsonDocument get_DisambiguatedPaths();
    public BsonDocument get_DocumentKey();
    public TDocument get_FullDocument();
    public TDocument get_FullDocumentBeforeChange();
    public BsonDocument get_OperationDescription();
    public ChangeStreamOperationType get_OperationType();
    public CollectionNamespace get_RenameTo();
    public BsonDocument get_ResumeToken();
    public ChangeStreamSplitEvent get_SplitEvent();
    public ChangeStreamUpdateDescription get_UpdateDescription();
    public Nullable`1<DateTime> get_WallTime();
}
internal class MongoDB.Driver.ChangeStreamDocumentCollectionNamespaceSerializer : SealedClassSerializerBase`1<CollectionNamespace> {
    private static ChangeStreamDocumentCollectionNamespaceSerializer __instance;
    public static ChangeStreamDocumentCollectionNamespaceSerializer Instance { get; }
    private static ChangeStreamDocumentCollectionNamespaceSerializer();
    public static ChangeStreamDocumentCollectionNamespaceSerializer get_Instance();
    public virtual CollectionNamespace Deserialize(BsonDeserializationContext context, BsonDeserializationArgs args);
    public sealed virtual bool TryGetMemberSerializationInfo(string memberName, BsonSerializationInfo& serializationInfo);
    protected virtual void SerializeValue(BsonSerializationContext context, BsonSerializationArgs args, CollectionNamespace value);
}
internal class MongoDB.Driver.ChangeStreamDocumentDatabaseNamespaceSerializer : SealedClassSerializerBase`1<DatabaseNamespace> {
    private static ChangeStreamDocumentDatabaseNamespaceSerializer __instance;
    public static ChangeStreamDocumentDatabaseNamespaceSerializer Instance { get; }
    private static ChangeStreamDocumentDatabaseNamespaceSerializer();
    public static ChangeStreamDocumentDatabaseNamespaceSerializer get_Instance();
    public virtual DatabaseNamespace Deserialize(BsonDeserializationContext context, BsonDeserializationArgs args);
    public sealed virtual bool TryGetMemberSerializationInfo(string memberName, BsonSerializationInfo& serializationInfo);
    protected virtual void SerializeValue(BsonSerializationContext context, BsonSerializationArgs args, DatabaseNamespace value);
}
public class MongoDB.Driver.ChangeStreamDocumentSerializer`1 : BsonDocumentBackedClassSerializer`1<ChangeStreamDocument`1<TDocument>> {
    private IBsonSerializer`1<TDocument> _documentSerializer;
    public ChangeStreamDocumentSerializer`1(IBsonSerializer`1<TDocument> documentSerializer);
    public virtual ChangeStreamDocument`1<TDocument> Deserialize(BsonDeserializationContext context, BsonDeserializationArgs args);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    protected virtual ChangeStreamDocument`1<TDocument> CreateInstance(BsonDocument backingDocument);
}
public enum MongoDB.Driver.ChangeStreamFullDocumentBeforeChangeOption : Enum {
    public int value__;
    public static ChangeStreamFullDocumentBeforeChangeOption Default;
    public static ChangeStreamFullDocumentBeforeChangeOption Off;
    public static ChangeStreamFullDocumentBeforeChangeOption WhenAvailable;
    public static ChangeStreamFullDocumentBeforeChangeOption Required;
}
public enum MongoDB.Driver.ChangeStreamFullDocumentOption : Enum {
    public int value__;
    public static ChangeStreamFullDocumentOption Default;
    public static ChangeStreamFullDocumentOption UpdateLookup;
    public static ChangeStreamFullDocumentOption WhenAvailable;
    public static ChangeStreamFullDocumentOption Required;
}
public enum MongoDB.Driver.ChangeStreamOperationType : Enum {
    public int value__;
    public static ChangeStreamOperationType Insert;
    public static ChangeStreamOperationType Update;
    public static ChangeStreamOperationType Replace;
    public static ChangeStreamOperationType Delete;
    public static ChangeStreamOperationType Invalidate;
    public static ChangeStreamOperationType Rename;
    public static ChangeStreamOperationType Drop;
    public static ChangeStreamOperationType DropDatabase;
    public static ChangeStreamOperationType CreateIndexes;
    public static ChangeStreamOperationType DropIndexes;
    public static ChangeStreamOperationType Modify;
    public static ChangeStreamOperationType Create;
    public static ChangeStreamOperationType ShardCollection;
    public static ChangeStreamOperationType RefineCollectionShardKey;
    public static ChangeStreamOperationType ReshardCollection;
}
public class MongoDB.Driver.ChangeStreamOperationTypeSerializer : StructSerializerBase`1<ChangeStreamOperationType> {
    private static ChangeStreamOperationTypeSerializer __instance;
    public static ChangeStreamOperationTypeSerializer Instance { get; }
    private static ChangeStreamOperationTypeSerializer();
    public static ChangeStreamOperationTypeSerializer get_Instance();
    public virtual ChangeStreamOperationType Deserialize(BsonDeserializationContext context, BsonDeserializationArgs args);
    public virtual void Serialize(BsonSerializationContext context, BsonSerializationArgs args, ChangeStreamOperationType value);
}
public class MongoDB.Driver.ChangeStreamSplitEvent : object {
    [CompilerGeneratedAttribute]
private int <Fragment>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Of>k__BackingField;
    public int Fragment { get; }
    public int Of { get; }
    public ChangeStreamSplitEvent(int fragment, int of);
    [CompilerGeneratedAttribute]
public int get_Fragment();
    [CompilerGeneratedAttribute]
public int get_Of();
}
internal class MongoDB.Driver.ChangeStreamSplitEventSerializer : SealedClassSerializerBase`1<ChangeStreamSplitEvent> {
    [CompilerGeneratedAttribute]
private static ChangeStreamSplitEventSerializer <Instance>k__BackingField;
    public static ChangeStreamSplitEventSerializer Instance { get; }
    private static ChangeStreamSplitEventSerializer();
    [CompilerGeneratedAttribute]
public static ChangeStreamSplitEventSerializer get_Instance();
    protected virtual ChangeStreamSplitEvent DeserializeValue(BsonDeserializationContext context, BsonDeserializationArgs args);
    protected virtual void SerializeValue(BsonSerializationContext context, BsonSerializationArgs args, ChangeStreamSplitEvent value);
}
public class MongoDB.Driver.ChangeStreamUpdateDescription : object {
    private String[] _removedFields;
    private BsonArray _truncatedArrays;
    private BsonDocument _updatedFields;
    public String[] RemovedFields { get; }
    public BsonArray TruncatedArrays { get; }
    public BsonDocument UpdatedFields { get; }
    public ChangeStreamUpdateDescription(BsonDocument updatedFields, String[] removedFields);
    public ChangeStreamUpdateDescription(BsonDocument updatedFields, String[] removedFields, BsonArray truncatedArrays);
    public String[] get_RemovedFields();
    public BsonArray get_TruncatedArrays();
    public BsonDocument get_UpdatedFields();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class MongoDB.Driver.ChangeStreamUpdateDescriptionSerializer : SealedClassSerializerBase`1<ChangeStreamUpdateDescription> {
    private static ChangeStreamUpdateDescriptionSerializer __instance;
    private static IBsonSerializer`1<String[]> __stringArraySerializer;
    public static ChangeStreamUpdateDescriptionSerializer Instance { get; }
    private static ChangeStreamUpdateDescriptionSerializer();
    public static ChangeStreamUpdateDescriptionSerializer get_Instance();
    protected virtual ChangeStreamUpdateDescription DeserializeValue(BsonDeserializationContext context, BsonDeserializationArgs args);
    protected virtual void SerializeValue(BsonSerializationContext context, BsonSerializationArgs args, ChangeStreamUpdateDescription value);
}
public class MongoDB.Driver.Collation : object {
    private static Collation __simple;
    private Nullable`1<CollationAlternate> _alternate;
    private Nullable`1<bool> _backwards;
    private Nullable`1<CollationCaseFirst> _caseFirst;
    private Nullable`1<bool> _caseLevel;
    private string _locale;
    private Nullable`1<CollationMaxVariable> _maxVariable;
    private Nullable`1<bool> _normalization;
    private Nullable`1<bool> _numericOrdering;
    private Nullable`1<CollationStrength> _strength;
    public static Collation Simple { get; }
    public Nullable`1<CollationAlternate> Alternate { get; }
    public Nullable`1<bool> Backwards { get; }
    public Nullable`1<CollationCaseFirst> CaseFirst { get; }
    public Nullable`1<bool> CaseLevel { get; }
    public string Locale { get; }
    public Nullable`1<CollationMaxVariable> MaxVariable { get; }
    public Nullable`1<bool> Normalization { get; }
    public Nullable`1<bool> NumericOrdering { get; }
    public Nullable`1<CollationStrength> Strength { get; }
    public Collation(string locale, Optional`1<Nullable`1<bool>> caseLevel, Optional`1<Nullable`1<CollationCaseFirst>> caseFirst, Optional`1<Nullable`1<CollationStrength>> strength, Optional`1<Nullable`1<bool>> numericOrdering, Optional`1<Nullable`1<CollationAlternate>> alternate, Optional`1<Nullable`1<CollationMaxVariable>> maxVariable, Optional`1<Nullable`1<bool>> normalization, Optional`1<Nullable`1<bool>> backwards);
    private static Collation();
    public static Collation get_Simple();
    public static Collation FromBsonDocument(BsonDocument document);
    internal static CollationAlternate ToCollationAlternate(string value);
    internal static CollationCaseFirst ToCollationCaseFirst(string value);
    internal static CollationMaxVariable ToCollationMaxVariable(string value);
    internal static CollationStrength ToCollationStrength(int value);
    internal static int ToInt32(CollationStrength strength);
    internal static string ToString(CollationAlternate alternate);
    internal static string ToString(CollationCaseFirst caseFirst);
    internal static string ToString(CollationMaxVariable maxVariable);
    public Nullable`1<CollationAlternate> get_Alternate();
    public Nullable`1<bool> get_Backwards();
    public Nullable`1<CollationCaseFirst> get_CaseFirst();
    public Nullable`1<bool> get_CaseLevel();
    public string get_Locale();
    public Nullable`1<CollationMaxVariable> get_MaxVariable();
    public Nullable`1<bool> get_Normalization();
    public Nullable`1<bool> get_NumericOrdering();
    public Nullable`1<CollationStrength> get_Strength();
    public sealed virtual bool Equals(Collation other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual BsonDocument ToBsonDocument();
    public virtual string ToString();
    public Collation With(Optional`1<string> locale, Optional`1<Nullable`1<bool>> caseLevel, Optional`1<Nullable`1<CollationCaseFirst>> caseFirst, Optional`1<Nullable`1<CollationStrength>> strength, Optional`1<Nullable`1<bool>> numericOrdering, Optional`1<Nullable`1<CollationAlternate>> alternate, Optional`1<Nullable`1<CollationMaxVariable>> maxVariable, Optional`1<Nullable`1<bool>> normalization, Optional`1<Nullable`1<bool>> backwards);
    [CompilerGeneratedAttribute]
private BsonValue <ToBsonDocument>b__43_0();
    [CompilerGeneratedAttribute]
private BsonValue <ToBsonDocument>b__43_1();
    [CompilerGeneratedAttribute]
private BsonValue <ToBsonDocument>b__43_2();
    [CompilerGeneratedAttribute]
private BsonValue <ToBsonDocument>b__43_3();
    [CompilerGeneratedAttribute]
private BsonValue <ToBsonDocument>b__43_4();
    [CompilerGeneratedAttribute]
private BsonValue <ToBsonDocument>b__43_5();
    [CompilerGeneratedAttribute]
private BsonValue <ToBsonDocument>b__43_6();
    [CompilerGeneratedAttribute]
private BsonValue <ToBsonDocument>b__43_7();
}
public enum MongoDB.Driver.CollationAlternate : Enum {
    public int value__;
    public static CollationAlternate NonIgnorable;
    public static CollationAlternate Shifted;
}
public enum MongoDB.Driver.CollationCaseFirst : Enum {
    public int value__;
    public static CollationCaseFirst Off;
    public static CollationCaseFirst Upper;
    public static CollationCaseFirst Lower;
}
public enum MongoDB.Driver.CollationMaxVariable : Enum {
    public int value__;
    public static CollationMaxVariable Punctuation;
    public static CollationMaxVariable Space;
}
public enum MongoDB.Driver.CollationStrength : Enum {
    public int value__;
    public static CollationStrength Primary;
    public static CollationStrength Secondary;
    public static CollationStrength Tertiary;
    public static CollationStrength Quaternary;
    public static CollationStrength Identical;
}
public class MongoDB.Driver.CollectionNamespace : object {
    private string _collectionName;
    private DatabaseNamespace _databaseNamespace;
    private string _fullName;
    public string CollectionName { get; }
    public DatabaseNamespace DatabaseNamespace { get; }
    public string FullName { get; }
    public CollectionNamespace(string databaseName, string collectionName);
    public CollectionNamespace(DatabaseNamespace databaseNamespace, string collectionName);
    public static CollectionNamespace FromFullName(string fullName);
    public static bool IsValid(string collectionName);
    public string get_CollectionName();
    public DatabaseNamespace get_DatabaseNamespace();
    public string get_FullName();
    public sealed virtual bool Equals(CollectionNamespace other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
internal class MongoDB.Driver.Core.Async.AsyncQueue`1 : object {
    private object _lock;
    private Queue`1<T> _queue;
    private Queue`1<TaskCompletionSource`1<T>> _awaiters;
    public int Count { get; }
    public int get_Count();
    [IteratorStateMachineAttribute("MongoDB.Driver.Core.Async.AsyncQueue`1/<DequeueAll>d__5")]
public IEnumerable`1<T> DequeueAll();
    [AsyncStateMachineAttribute("MongoDB.Driver.Core.Async.AsyncQueue`1/<DequeueAsync>d__6")]
public Task`1<T> DequeueAsync(CancellationToken cancellationToken);
    public void Enqueue(T item);
}
internal static class MongoDB.Driver.Core.Authentication.AuthenticationHelper : object {
    public static void Authenticate(IConnection connection, ConnectionDescription description, IReadOnlyList`1<IAuthenticator> authenticators, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MongoDB.Driver.Core.Authentication.AuthenticationHelper/<AuthenticateAsync>d__1")]
public static Task AuthenticateAsync(IConnection connection, ConnectionDescription description, IReadOnlyList`1<IAuthenticator> authenticators, CancellationToken cancellationToken);
    public static string MongoPasswordDigest(string username, SecureString password);
    private static string MongoPasswordDigest(string username, Char[] passwordChars);
    private static string MongoPasswordDigest(string username, Byte[] passwordBytes);
}
public class MongoDB.Driver.Core.Authentication.AuthenticatorFactory : object {
    private Func`1<IAuthenticator> _authenticatorFactoryFunc;
    public AuthenticatorFactory(Func`1<IAuthenticator> authenticatorFactoryFunc);
    public sealed virtual IAuthenticator Create();
}
internal static class MongoDB.Driver.Core.Authentication.AwsSignatureVersion4 : object {
    public static void CreateAuthorizationRequest(DateTime dateTime, string accessKeyId, SecureString secretAccessKey, string sessionToken, Byte[] salt, string host, String& authorizationHeader, String& timestamp);
    private static string GetCanonicalHeaders(SortedDictionary`2<string, string> requestHeaders);
    private static string GetRegion(string host);
    private static SortedDictionary`2<string, string> GetRequestHeaders(string body, string contentType, string host, string timestamp, string sessionToken, Byte[] nonce);
    private static string GetSignature(string stringToSign, SecureString secretAccessKey, string date, string region, string service);
    private static string GetSignedHeaders(SortedDictionary`2<string, string> requestHeaders);
    private static string Hash(string str);
    private static Byte[] Hmac256(Byte[] keyBytes, Byte[] bytes);
}
public class MongoDB.Driver.Core.Authentication.DefaultAuthenticator : object {
    private UsernamePasswordCredential _credential;
    private IRandomStringGenerator _randomStringGenerator;
    private ServerApi _serverApi;
    private IAuthenticator _speculativeAuthenticator;
    public string Name { get; }
    [ObsoleteAttribute("Use the newest overload instead.")]
public DefaultAuthenticator(UsernamePasswordCredential credential);
    public DefaultAuthenticator(UsernamePasswordCredential credential, ServerApi serverApi);
    internal DefaultAuthenticator(UsernamePasswordCredential credential, IRandomStringGenerator randomStringGenerator, ServerApi serverApi);
    public sealed virtual string get_Name();
    public sealed virtual void Authenticate(IConnection connection, ConnectionDescription description, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MongoDB.Driver.Core.Authentication.DefaultAuthenticator/<AuthenticateAsync>d__10")]
public sealed virtual Task AuthenticateAsync(IConnection connection, ConnectionDescription description, CancellationToken cancellationToken);
    public sealed virtual BsonDocument CustomizeInitialHelloCommand(BsonDocument helloCommand, CancellationToken cancellationToken);
    private static BsonDocument CreateSaslSupportedMechsRequest(string authenticationDatabaseName, string userName);
    private IAuthenticator CreateAuthenticator(IConnection connection, ConnectionDescription description);
    private IAuthenticator GetOrCreateAuthenticator(IConnection connection, ConnectionDescription description);
}
internal class MongoDB.Driver.Core.Authentication.External.AwsAuthenticationCredentialsProvider : object {
    private object _lock;
    public sealed virtual void Clear();
    public sealed virtual AwsCredentials CreateCredentialsFromExternalSource(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MongoDB.Driver.Core.Authentication.External.AwsAuthenticationCredentialsProvider/<CreateCredentialsFromExternalSourceAsync>d__3")]
public sealed virtual Task`1<AwsCredentials> CreateCredentialsFromExternalSourceAsync(CancellationToken cancellationToken);
    private AwsCredentials CreateAwsCredentials(ImmutableCredentials immutableCredentials);
}
internal class MongoDB.Driver.Core.Authentication.External.AwsCredentials : object {
    private string _accessKeyId;
    private SecureString _secretAccessKey;
    private string _sessionToken;
    public string AccessKeyId { get; }
    public Nullable`1<DateTime> Expiration { get; }
    public SecureString SecretAccessKey { get; }
    public string SessionToken { get; }
    public bool ShouldBeRefreshed { get; }
    public AwsCredentials(string accessKeyId, string secretAccessKey, string sessionToken);
    public AwsCredentials(string accessKeyId, SecureString secretAccessKey, string sessionToken);
    public string get_AccessKeyId();
    public sealed virtual Nullable`1<DateTime> get_Expiration();
    public SecureString get_SecretAccessKey();
    public string get_SessionToken();
    public sealed virtual bool get_ShouldBeRefreshed();
    public sealed virtual BsonDocument GetKmsCredentials();
}
internal class MongoDB.Driver.Core.Authentication.External.AzureAuthenticationCredentialsProvider : object {
    private AzureHttpClientHelper _azureHttpClientHelper;
    public AzureAuthenticationCredentialsProvider(IHttpClientWrapper httpClientWrapper);
    public sealed virtual AzureCredentials CreateCredentialsFromExternalSource(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MongoDB.Driver.Core.Authentication.External.AzureAuthenticationCredentialsProvider/<CreateCredentialsFromExternalSourceAsync>d__3")]
public sealed virtual Task`1<AzureCredentials> CreateCredentialsFromExternalSourceAsync(CancellationToken cancellationToken);
    private AzureCredentials CreateAzureCredentialsFromAzureIMDSResponse(string azureResponse, DateTime startTime);
}
internal class MongoDB.Driver.Core.Authentication.External.AzureCredentials : object {
    private static TimeSpan __overlapWhereExpired;
    private Nullable`1<DateTime> _expiration;
    private string _accessToken;
    public string AccessToken { get; }
    public Nullable`1<DateTime> Expiration { get; }
    public bool ShouldBeRefreshed { get; }
    public AzureCredentials(string accessToken, Nullable`1<DateTime> expiration);
    private static AzureCredentials();
    public string get_AccessToken();
    public sealed virtual Nullable`1<DateTime> get_Expiration();
    public sealed virtual bool get_ShouldBeRefreshed();
    public sealed virtual BsonDocument GetKmsCredentials();
}
internal class MongoDB.Driver.Core.Authentication.External.CacheableCredentialsProvider`1 : object {
    private TCredentials _cachedCredentials;
    private IExternalAuthenticationCredentialsProvider`1<TCredentials> _provider;
    public TCredentials Credentials { get; }
    public CacheableCredentialsProvider`1(IExternalAuthenticationCredentialsProvider`1<TCredentials> provider);
    public TCredentials get_Credentials();
    public sealed virtual TCredentials CreateCredentialsFromExternalSource(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MongoDB.Driver.Core.Authentication.External.CacheableCredentialsProvider`1/<CreateCredentialsFromExternalSourceAsync>d__6")]
public sealed virtual Task`1<TCredentials> CreateCredentialsFromExternalSourceAsync(CancellationToken cancellationToken);
    private bool IsValidCache(TCredentials credentials);
    public sealed virtual void Clear();
}
internal class MongoDB.Driver.Core.Authentication.External.ExternalCredentialsAuthenticators : object {
    private static Lazy`1<ExternalCredentialsAuthenticators> __instance;
    private IHttpClientWrapper _httpClientWrapper;
    private Lazy`1<IExternalAuthenticationCredentialsProvider`1<AwsCredentials>> _awsExternalAuthenticationCredentialsProvider;
    private Lazy`1<IExternalAuthenticationCredentialsProvider`1<AzureCredentials>> _azureExternalAuthenticationCredentialsProvider;
    private Lazy`1<IExternalAuthenticationCredentialsProvider`1<GcpCredentials>> _gcpExternalAuthenticationCredentialsProvider;
    public static ExternalCredentialsAuthenticators Instance { get; }
    public IExternalAuthenticationCredentialsProvider`1<AwsCredentials> Aws { get; }
    public IExternalAuthenticationCredentialsProvider`1<AzureCredentials> Azure { get; }
    public IExternalAuthenticationCredentialsProvider`1<GcpCredentials> Gcp { get; }
    internal IHttpClientWrapper HttpClientWrapper { get; }
    internal ExternalCredentialsAuthenticators(IHttpClientWrapper httpClientWrapper);
    private static ExternalCredentialsAuthenticators();
    public static ExternalCredentialsAuthenticators get_Instance();
    public IExternalAuthenticationCredentialsProvider`1<AwsCredentials> get_Aws();
    public IExternalAuthenticationCredentialsProvider`1<AzureCredentials> get_Azure();
    public IExternalAuthenticationCredentialsProvider`1<GcpCredentials> get_Gcp();
    internal IHttpClientWrapper get_HttpClientWrapper();
    [CompilerGeneratedAttribute]
private IExternalAuthenticationCredentialsProvider`1<AzureCredentials> <.ctor>b__8_1();
    [CompilerGeneratedAttribute]
private IExternalAuthenticationCredentialsProvider`1<GcpCredentials> <.ctor>b__8_2();
}
internal class MongoDB.Driver.Core.Authentication.External.GcpAuthenticationCredentialsProvider : object {
    private GcpHttpClientHelper _gcpHttpClientHelper;
    public GcpAuthenticationCredentialsProvider(IHttpClientWrapper httpClientWrapper);
    public sealed virtual GcpCredentials CreateCredentialsFromExternalSource(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MongoDB.Driver.Core.Authentication.External.GcpAuthenticationCredentialsProvider/<CreateCredentialsFromExternalSourceAsync>d__3")]
public sealed virtual Task`1<GcpCredentials> CreateCredentialsFromExternalSourceAsync(CancellationToken cancellationToken);
}
internal class MongoDB.Driver.Core.Authentication.External.GcpCredentials : object {
    private string _accessToken;
    public string AccessToken { get; }
    public Nullable`1<DateTime> Expiration { get; }
    public bool ShouldBeRefreshed { get; }
    public GcpCredentials(string accessToken);
    public string get_AccessToken();
    public sealed virtual Nullable`1<DateTime> get_Expiration();
    public sealed virtual bool get_ShouldBeRefreshed();
    public sealed virtual BsonDocument GetKmsCredentials();
}
internal class MongoDB.Driver.Core.Authentication.External.HttpClientWrapper : object {
    private HttpClient _httpClient;
    internal HttpClientWrapper(HttpClient httpClient);
    public static HttpClient CreateHttpClient();
    [AsyncStateMachineAttribute("MongoDB.Driver.Core.Authentication.External.HttpClientWrapper/<GetHttpContentAsync>d__4")]
public sealed virtual Task`1<string> GetHttpContentAsync(HttpRequestMessage request, string exceptionMessage, CancellationToken cancellationToken);
}
internal interface MongoDB.Driver.Core.Authentication.External.ICredentialsCache`1 {
    public abstract virtual void Clear();
}
internal interface MongoDB.Driver.Core.Authentication.External.IExternalAuthenticationCredentialsProvider`1 {
    public abstract virtual TCredentials CreateCredentialsFromExternalSource(CancellationToken cancellationToken);
    public abstract virtual Task`1<TCredentials> CreateCredentialsFromExternalSourceAsync(CancellationToken cancellationToken);
}
internal interface MongoDB.Driver.Core.Authentication.External.IExternalCredentials {
    public Nullable`1<DateTime> Expiration { get; }
    public bool ShouldBeRefreshed { get; }
    public abstract virtual Nullable`1<DateTime> get_Expiration();
    public abstract virtual bool get_ShouldBeRefreshed();
    public abstract virtual BsonDocument GetKmsCredentials();
}
internal interface MongoDB.Driver.Core.Authentication.External.IHttpClientWrapper {
    public abstract virtual Task`1<string> GetHttpContentAsync(HttpRequestMessage request, string exceptionMessage, CancellationToken cancellationToken);
}
public class MongoDB.Driver.Core.Authentication.GssapiAuthenticator : SaslAuthenticator {
    public static string MechanismName;
    public static string DefaultServiceName;
    private static string __canonicalizeHostNamePropertyName;
    private static string __realmPropertyName;
    private static string __serviceNamePropertyName;
    private static string __serviceRealmPropertyName;
    public static string CanonicalizeHostNamePropertyName { get; }
    [ObsoleteAttribute("Use ServiceRealmPropertyName")]
public static string RealmPropertyName { get; }
    public static string ServiceNamePropertyName { get; }
    public static string ServiceRealmPropertyName { get; }
    public string DatabaseName { get; }
    [ObsoleteAttribute("Use the newest overload instead.")]
public GssapiAuthenticator(UsernamePasswordCredential credential, IEnumerable`1<KeyValuePair`2<string, string>> properties);
    public GssapiAuthenticator(UsernamePasswordCredential credential, IEnumerable`1<KeyValuePair`2<string, string>> properties, ServerApi serverApi);
    [ObsoleteAttribute("Use the newest overload instead.")]
public GssapiAuthenticator(string username, IEnumerable`1<KeyValuePair`2<string, string>> properties);
    public GssapiAuthenticator(string username, IEnumerable`1<KeyValuePair`2<string, string>> properties, ServerApi serverApi);
    public static string get_CanonicalizeHostNamePropertyName();
    public static string get_RealmPropertyName();
    public static string get_ServiceNamePropertyName();
    public static string get_ServiceRealmPropertyName();
    public virtual string get_DatabaseName();
    private static GssapiMechanism CreateMechanism(UsernamePasswordCredential credential, IEnumerable`1<KeyValuePair`2<string, string>> properties);
    private static GssapiMechanism CreateMechanism(string username, SecureString password, IEnumerable`1<KeyValuePair`2<string, string>> properties);
}
public class MongoDB.Driver.Core.Authentication.GssapiException : Exception {
    protected GssapiException(string message);
    protected GssapiException(SerializationInfo info, StreamingContext context);
}
public interface MongoDB.Driver.Core.Authentication.IAuthenticator {
    public string Name { get; }
    public abstract virtual string get_Name();
    public abstract virtual void Authenticate(IConnection connection, ConnectionDescription description, CancellationToken cancellationToken);
    public abstract virtual Task AuthenticateAsync(IConnection connection, ConnectionDescription description, CancellationToken cancellationToken);
    public abstract virtual BsonDocument CustomizeInitialHelloCommand(BsonDocument helloCommand, CancellationToken cancellationToken);
}
public interface MongoDB.Driver.Core.Authentication.IAuthenticatorFactory {
    public abstract virtual IAuthenticator Create();
}
public interface MongoDB.Driver.Core.Authentication.ISecurityContext {
    public bool IsInitialized { get; }
    public abstract virtual Byte[] Next(Byte[] challenge);
    public abstract virtual bool get_IsInitialized();
    public abstract virtual Byte[] DecryptMessage(int messageLength, Byte[] encryptedBytes);
    public abstract virtual Byte[] EncryptMessage(Byte[] plainTextBytes);
}
internal static class MongoDB.Driver.Core.Authentication.Libgssapi.Gss : object {
    public static void ThrowIfError(UInt32 majorStatus, UInt32 minorStatus);
}
internal abstract class MongoDB.Driver.Core.Authentication.Libgssapi.GssapiSafeHandle : SafeHandle {
    public bool IsInvalid { get; }
    public virtual bool get_IsInvalid();
}
internal class MongoDB.Driver.Core.Authentication.Libgssapi.GssapiSecurityContext : GssapiSafeHandle {
    private GssapiSecurityCredential _credential;
    private bool _isInitialized;
    private GssapiServicePrincipalName _servicePrincipalName;
    public bool IsInitialized { get; }
    public GssapiSecurityContext(GssapiServicePrincipalName servicePrincipalName, GssapiSecurityCredential credential);
    public sealed virtual bool get_IsInitialized();
    public sealed virtual Byte[] Next(Byte[] challenge);
    public sealed virtual Byte[] DecryptMessage(int messageLength, Byte[] encryptedBytes);
    public sealed virtual Byte[] EncryptMessage(Byte[] plainTextBytes);
    protected virtual bool ReleaseHandle();
    protected virtual void Dispose(bool disposing);
}
internal class MongoDB.Driver.Core.Authentication.Libgssapi.GssapiSecurityCredential : GssapiSafeHandle {
    public static GssapiSecurityCredential Acquire(string username, SecureString password);
    public static GssapiSecurityCredential Acquire(string username);
    protected virtual bool ReleaseHandle();
}
internal class MongoDB.Driver.Core.Authentication.Libgssapi.GssapiServicePrincipalName : GssapiSafeHandle {
    private GssapiServicePrincipalName(IntPtr spnName);
    public static GssapiServicePrincipalName Create(string service, string host, string realm);
    protected virtual bool ReleaseHandle();
}
internal enum MongoDB.Driver.Core.Authentication.Libgssapi.GssCode : Enum {
    public int value__;
    public static GssCode GSS_C_GSS_CODE;
    public static GssCode GSS_C_MECH_CODE;
}
internal enum MongoDB.Driver.Core.Authentication.Libgssapi.GssCredentialUsage : Enum {
    public int value__;
    public static GssCredentialUsage GSS_C_BOTH;
    public static GssCredentialUsage GSS_C_INITIATE;
    public static GssCredentialUsage GSS_C_ACCEPT;
}
[FlagsAttribute]
internal enum MongoDB.Driver.Core.Authentication.Libgssapi.GssFlags : Enum {
    public int value__;
    public static GssFlags GSS_C_MUTUAL_FLAG;
    public static GssFlags GSS_C_SEQUENCE_FLAG;
}
internal class MongoDB.Driver.Core.Authentication.Libgssapi.GssInputBuffer : object {
    [NativeIntegerAttribute]
private UIntPtr _length;
    private IntPtr _value;
    public GssInputBuffer(string inputString);
    public GssInputBuffer(Byte[] inputBytes);
    protected virtual override void Finalize();
    public sealed virtual void Dispose();
    private void Dispose(bool disposing);
}
internal class MongoDB.Driver.Core.Authentication.Libgssapi.GssOutputBuffer : object {
    [NativeIntegerAttribute]
private UIntPtr _length;
    private IntPtr _value;
    public IntPtr Value { get; }
    protected virtual override void Finalize();
    public IntPtr get_Value();
    public Byte[] ToByteArray();
    public sealed virtual void Dispose();
    private void Dispose(bool disposing);
}
internal enum MongoDB.Driver.Core.Authentication.Libgssapi.GssStatus : Enum {
    public UInt32 value__;
    public static GssStatus GSS_S_COMPLETE;
    public static GssStatus GSS_S_CONTINUE_NEEDED;
}
public class MongoDB.Driver.Core.Authentication.Libgssapi.LibgssapiException : GssapiException {
    public LibgssapiException(string message);
    protected LibgssapiException(SerializationInfo info, StreamingContext context);
}
internal static class MongoDB.Driver.Core.Authentication.Libgssapi.NativeMethods : object {
    private static string GSSAPI_LIBRARY;
    public static UInt32 gss_import_name(UInt32& minorStatus, GssInputBuffer name, Oid& nameType, IntPtr& outputName);
    public static UInt32 gss_display_name(UInt32& minorStatus, IntPtr inputName, GssOutputBuffer outputBuffer, Oid& outputNameType);
    public static UInt32 gss_canonicalize_name(UInt32& minorStatus, IntPtr inputName, Oid& mechType, IntPtr& outputName);
    public static UInt32 gss_acquire_cred_with_password(UInt32& minorStatus, IntPtr name, GssInputBuffer password, UInt32 timeRequested, IntPtr desiredMechanisms, GssCredentialUsage credentialUsage, GssapiSecurityCredential& securityCredential, IntPtr actualMechanisms, UInt32& timeReceived);
    public static UInt32 gss_acquire_cred(UInt32& minorStatus, IntPtr name, UInt32 timeRequested, IntPtr desiredMechanisms, GssCredentialUsage credentialUsage, GssapiSecurityCredential& securityCredential, IntPtr actualMechanisms, UInt32& timeReceived);
    public static UInt32 gss_init_sec_context(UInt32& minorStatus, GssapiSecurityCredential securityCredential, IntPtr& securityContextHandle, GssapiServicePrincipalName spnName, IntPtr inputMechType, GssFlags requestFlags, UInt32 timeRequested, IntPtr inputChannelBindings, GssInputBuffer inputToken, IntPtr& actualMechType, GssOutputBuffer outputToken, GssFlags& returnedFlags, UInt32& timeReceived);
    public static UInt32 gss_display_status(UInt32& minorStatus, UInt32 status, GssCode statusType, IntPtr& mechType, UInt32& messageContext, GssOutputBuffer statusString);
    public static UInt32 gss_release_name(UInt32& minorStatus, IntPtr name);
    public static UInt32 gss_release_buffer(UInt32& minorStatus, GssOutputBuffer buffer);
    public static UInt32 gss_release_cred(UInt32& minorStatus, IntPtr credentialHandle);
    public static UInt32 gss_delete_sec_context(UInt32& minorStatus, IntPtr& securityContextHandle, IntPtr outputToken);
    public static UInt32 gss_wrap(UInt32& minorStatus, IntPtr securityContextHandle, int confidentialityRequested, int protectionType, GssInputBuffer inputBuffer, Int32& confidentialityState, GssOutputBuffer outputBuffer);
    public static UInt32 gss_unwrap(UInt32& minorStatus, IntPtr securityContextHandle, GssInputBuffer inputBuffer, GssOutputBuffer outputBuffer, Int32& confidentialityState, Int32& qualityOfProtectionState);
}
internal class MongoDB.Driver.Core.Authentication.Libgssapi.Oid : ValueType {
    public static IntPtr GSS_C_NO_OID;
    public static Oid GSS_C_NT_USER_NAME;
    public static Oid GSS_C_NT_HOSTBASED_SERVICE;
    private UInt32 length;
    private IntPtr elements;
    private static Oid();
    private static Oid Create(Byte[] oidBytes);
}
public class MongoDB.Driver.Core.Authentication.MongoAWSAuthenticator : SaslAuthenticator {
    private static int ClientNonceLength;
    private ICredentialsCache`1<AwsCredentials> _credentialsCache;
    public static string MechanismName { get; }
    public string DatabaseName { get; }
    public MongoAWSAuthenticator(UsernamePasswordCredential credential, IEnumerable`1<KeyValuePair`2<string, string>> properties, ServerApi serverApi);
    public MongoAWSAuthenticator(string username, IEnumerable`1<KeyValuePair`2<string, string>> properties, ServerApi serverApi);
    internal MongoAWSAuthenticator(UsernamePasswordCredential credential, IEnumerable`1<KeyValuePair`2<string, string>> properties, IRandomByteGenerator randomByteGenerator, IExternalAuthenticationCredentialsProvider`1<AwsCredentials> externalAuthenticationCredentialsProvider, IClock clock, ServerApi serverApi);
    internal MongoAWSAuthenticator(string username, IEnumerable`1<KeyValuePair`2<string, string>> properties, IRandomByteGenerator randomByteGenerator, IExternalAuthenticationCredentialsProvider`1<AwsCredentials> externalAuthenticationCredentialsProvider, IClock clock, ServerApi serverApi);
    public static string get_MechanismName();
    private static MongoAWSMechanism CreateMechanism(UsernamePasswordCredential credential, IEnumerable`1<KeyValuePair`2<string, string>> properties, IRandomByteGenerator randomByteGenerator, IExternalAuthenticationCredentialsProvider`1<AwsCredentials> externalAuthenticationCredentialsProvider, IClock clock);
    private static MongoAWSMechanism CreateMechanism(string username, SecureString password, IEnumerable`1<KeyValuePair`2<string, string>> properties, IRandomByteGenerator randomByteGenerator, IExternalAuthenticationCredentialsProvider`1<AwsCredentials> externalAuthenticationCredentialsProvider, IClock clock);
    private static AwsCredentials CreateAwsCredentialsFromMongoCredentials(string username, SecureString password, IEnumerable`1<KeyValuePair`2<string, string>> properties);
    private static string ExtractSessionTokenFromMechanismProperties(IEnumerable`1<KeyValuePair`2<string, string>> properties);
    private static void ValidateMechanismProperties(IEnumerable`1<KeyValuePair`2<string, string>> properties);
    public virtual string get_DatabaseName();
    public virtual void Authenticate(IConnection connection, ConnectionDescription description, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MongoDB.Driver.Core.Authentication.MongoAWSAuthenticator/<AuthenticateAsync>d__16")]
public virtual Task AuthenticateAsync(IConnection connection, ConnectionDescription description, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task <>n__0(IConnection connection, ConnectionDescription description, CancellationToken cancellationToken);
}
[ObsoleteAttribute("This authenticator was replaced by ScramSha1Authenticator in MongoDB 3.0, and is now deprecated.")]
public class MongoDB.Driver.Core.Authentication.MongoDBCRAuthenticator : object {
    private UsernamePasswordCredential _credential;
    private ServerApi _serverApi;
    public static string MechanismName { get; }
    public string Name { get; }
    public MongoDBCRAuthenticator(UsernamePasswordCredential credential);
    public MongoDBCRAuthenticator(UsernamePasswordCredential credential, ServerApi serverApi);
    public static string get_MechanismName();
    public sealed virtual string get_Name();
    public sealed virtual void Authenticate(IConnection connection, ConnectionDescription description, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MongoDB.Driver.Core.Authentication.MongoDBCRAuthenticator/<AuthenticateAsync>d__9")]
public sealed virtual Task AuthenticateAsync(IConnection connection, ConnectionDescription description, CancellationToken cancellationToken);
    public sealed virtual BsonDocument CustomizeInitialHelloCommand(BsonDocument helloCommand, CancellationToken cancellationToken);
    private CommandWireProtocol`1<BsonDocument> CreateAuthenticateProtocol(BsonDocument getNonceReply);
    private MongoAuthenticationException CreateException(IConnection connection, Exception ex);
    private CommandWireProtocol`1<BsonDocument> CreateGetNonceProtocol();
    private string CreateKey(string username, SecureString password, string nonce);
}
public class MongoDB.Driver.Core.Authentication.MongoDBX509Authenticator : object {
    private string _username;
    private ServerApi _serverApi;
    public static string MechanismName { get; }
    public string Name { get; }
    [ObsoleteAttribute("Use the newest overload instead.")]
public MongoDBX509Authenticator(string username);
    public MongoDBX509Authenticator(string username, ServerApi serverApi);
    public static string get_MechanismName();
    public sealed virtual string get_Name();
    public sealed virtual void Authenticate(IConnection connection, ConnectionDescription description, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MongoDB.Driver.Core.Authentication.MongoDBX509Authenticator/<AuthenticateAsync>d__9")]
public sealed virtual Task AuthenticateAsync(IConnection connection, ConnectionDescription description, CancellationToken cancellationToken);
    public sealed virtual BsonDocument CustomizeInitialHelloCommand(BsonDocument helloCommand, CancellationToken cancellationToken);
    private BsonDocument CreateAuthenticateCommand();
    private CommandWireProtocol`1<BsonDocument> CreateAuthenticateProtocol();
    private MongoAuthenticationException CreateException(IConnection connection, Exception ex);
}
internal class MongoDB.Driver.Core.Authentication.NoTransitionClientLastSaslStep : object {
    private Byte[] _bytesToSendToServer;
    public Byte[] BytesToSendToServer { get; }
    public bool IsComplete { get; }
    public NoTransitionClientLastSaslStep(Byte[] bytesToSendToServer);
    public sealed virtual Byte[] get_BytesToSendToServer();
    public sealed virtual bool get_IsComplete();
    public sealed virtual ISaslStep Transition(SaslConversation conversation, Byte[] bytesReceivedFromServer);
    public sealed virtual Task`1<ISaslStep> TransitionAsync(SaslConversation conversation, Byte[] bytesReceivedFromServer, CancellationToken cancellationToken);
}
internal class MongoDB.Driver.Core.Authentication.Oidc.AzureOidcCallback : HttpRequestOidcCallback {
    private string _tokenResource;
    public AzureOidcCallback(string tokenResource);
    protected virtual ValueTuple`2<Uri, ValueTuple`2[]> GetHttpRequestParams(OidcCallbackParameters parameters);
    protected virtual OidcAccessToken ProcessHttpResponse(Stream responseStream);
}
internal class MongoDB.Driver.Core.Authentication.Oidc.FileOidcCallback : object {
    private string _path;
    public FileOidcCallback(string path);
    public static FileOidcCallback CreateFromEnvironmentVariable(string environmentVariableName, IEnvironmentVariableProvider environmentVariableProvider);
    public sealed virtual OidcAccessToken GetOidcAccessToken(OidcCallbackParameters parameters, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MongoDB.Driver.Core.Authentication.Oidc.FileOidcCallback/<GetOidcAccessTokenAsync>d__4")]
public sealed virtual Task`1<OidcAccessToken> GetOidcAccessTokenAsync(OidcCallbackParameters parameters, CancellationToken cancellationToken);
}
internal class MongoDB.Driver.Core.Authentication.Oidc.GcpOidcCallback : HttpRequestOidcCallback {
    private string _tokenResource;
    public GcpOidcCallback(string tokenResource);
    protected virtual ValueTuple`2<Uri, ValueTuple`2[]> GetHttpRequestParams(OidcCallbackParameters parameters);
    protected virtual OidcAccessToken ProcessHttpResponse(Stream responseStream);
}
internal abstract class MongoDB.Driver.Core.Authentication.Oidc.HttpRequestOidcCallback : object {
    public sealed virtual OidcAccessToken GetOidcAccessToken(OidcCallbackParameters parameters, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MongoDB.Driver.Core.Authentication.Oidc.HttpRequestOidcCallback/<GetOidcAccessTokenAsync>d__1")]
public sealed virtual Task`1<OidcAccessToken> GetOidcAccessTokenAsync(OidcCallbackParameters parameters, CancellationToken cancellationToken);
    protected abstract virtual ValueTuple`2<Uri, ValueTuple`2[]> GetHttpRequestParams(OidcCallbackParameters parameters);
    protected abstract virtual OidcAccessToken ProcessHttpResponse(Stream responseStream);
    private HttpWebRequest CreateRequest(OidcCallbackParameters parameters);
    private OidcAccessToken ProcessHttpResponse(HttpWebResponse response);
}
public interface MongoDB.Driver.Core.Authentication.Oidc.IOidcCallback {
    public abstract virtual OidcAccessToken GetOidcAccessToken(OidcCallbackParameters parameters, CancellationToken cancellationToken);
    public abstract virtual Task`1<OidcAccessToken> GetOidcAccessTokenAsync(OidcCallbackParameters parameters, CancellationToken cancellationToken);
}
internal interface MongoDB.Driver.Core.Authentication.Oidc.IOidcCallbackAdapter {
    public OidcCredentials CachedCredentials { get; }
    public abstract virtual OidcCredentials get_CachedCredentials();
    public abstract virtual void InvalidateCachedCredentials(OidcCredentials credentials);
    public abstract virtual OidcCredentials GetCredentials(OidcCallbackParameters parameters, CancellationToken cancellationToken);
    public abstract virtual ValueTask`1<OidcCredentials> GetCredentialsAsync(OidcCallbackParameters parameters, CancellationToken cancellationToken);
}
internal interface MongoDB.Driver.Core.Authentication.Oidc.IOidcCallbackAdapterFactory {
    public abstract virtual IOidcCallbackAdapter Get(OidcConfiguration configuration);
}
internal class MongoDB.Driver.Core.Authentication.Oidc.MongoOidcAuthenticator : SaslAuthenticator {
    public static string MechanismName;
    [CompilerGeneratedAttribute]
private OidcConfiguration <Configuration>k__BackingField;
    [CompilerGeneratedAttribute]
private OidcSaslMechanism <OidcMechanism>k__BackingField;
    public string DatabaseName { get; }
    public OidcConfiguration Configuration { get; }
    private OidcSaslMechanism OidcMechanism { get; }
    private MongoOidcAuthenticator(OidcSaslMechanism mechanism, ServerApi serverApi, OidcConfiguration configuration);
    public static MongoOidcAuthenticator CreateAuthenticator(string source, string principalName, IEnumerable`1<KeyValuePair`2<string, object>> properties, IReadOnlyList`1<EndPoint> endPoints, ServerApi serverApi);
    public static MongoOidcAuthenticator CreateAuthenticator(string source, string principalName, IEnumerable`1<KeyValuePair`2<string, object>> properties, IReadOnlyList`1<EndPoint> endPoints, ServerApi serverApi, IOidcCallbackAdapterFactory callbackAdapterFactory);
    public virtual string get_DatabaseName();
    [CompilerGeneratedAttribute]
public OidcConfiguration get_Configuration();
    [CompilerGeneratedAttribute]
private OidcSaslMechanism get_OidcMechanism();
    public virtual void Authenticate(IConnection connection, ConnectionDescription description, CancellationToken cancellationToken);
    public virtual Task AuthenticateAsync(IConnection connection, ConnectionDescription description, CancellationToken cancellationToken);
    public virtual BsonDocument CustomizeInitialHelloCommand(BsonDocument helloCommand, CancellationToken cancellationToken);
    public void ClearCredentialsCache();
    private static bool IsAuthenticationError(Exception ex);
    private static Exception UnwrapMongoAuthenticationException(Exception ex);
    [CompilerGeneratedAttribute]
private void <Authenticate>g__TryAuthenticate|12_0(bool retryOnFailure, <>c__DisplayClass12_0& );
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task <>n__0(IConnection connection, ConnectionDescription description, CancellationToken cancellationToken);
}
public class MongoDB.Driver.Core.Authentication.Oidc.OidcAccessToken : object {
    [CompilerGeneratedAttribute]
private string <AccessToken>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<TimeSpan> <ExpiresIn>k__BackingField;
    public string AccessToken { get; public set; }
    public Nullable`1<TimeSpan> ExpiresIn { get; public set; }
    public OidcAccessToken(string accessToken, Nullable`1<TimeSpan> expiresIn);
    [CompilerGeneratedAttribute]
public string get_AccessToken();
    [CompilerGeneratedAttribute]
public void set_AccessToken(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<TimeSpan> get_ExpiresIn();
    [CompilerGeneratedAttribute]
public void set_ExpiresIn(Nullable`1<TimeSpan> value);
}
internal class MongoDB.Driver.Core.Authentication.Oidc.OidcCallbackAdapter : object {
    private IClock _clock;
    private IOidcCallback _wrappedCallback;
    private SemaphoreSlim _lock;
    private OidcCredentials _cachedCredentials;
    public OidcCredentials CachedCredentials { get; }
    public OidcCallbackAdapter(IOidcCallback wrappedCallback, IClock clock);
    public sealed virtual void Dispose();
    public sealed virtual OidcCredentials get_CachedCredentials();
    public sealed virtual void InvalidateCachedCredentials(OidcCredentials credentials);
    public sealed virtual OidcCredentials GetCredentials(OidcCallbackParameters parameters, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MongoDB.Driver.Core.Authentication.Oidc.OidcCallbackAdapter/<GetCredentialsAsync>d__10")]
public sealed virtual ValueTask`1<OidcCredentials> GetCredentialsAsync(OidcCallbackParameters parameters, CancellationToken cancellationToken);
}
internal class MongoDB.Driver.Core.Authentication.Oidc.OidcCallbackAdapterCachingFactory : object {
    public static OidcCallbackAdapterCachingFactory Instance;
    private IClock _clock;
    private IEnvironmentVariableProvider _environmentVariableProvider;
    private ConcurrentDictionary`2<OidcConfiguration, IOidcCallbackAdapter> _cache;
    public OidcCallbackAdapterCachingFactory(IClock clock, IEnvironmentVariableProvider environmentVariableProvider);
    private static OidcCallbackAdapterCachingFactory();
    public sealed virtual IOidcCallbackAdapter Get(OidcConfiguration configuration);
    internal void Reset();
    private IOidcCallbackAdapter CreateCallbackAdapter(OidcConfiguration configuration);
}
public class MongoDB.Driver.Core.Authentication.Oidc.OidcCallbackParameters : object {
    [CompilerGeneratedAttribute]
private int <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private string <UserName>k__BackingField;
    public int Version { get; }
    public string UserName { get; }
    public OidcCallbackParameters(int version, string userName);
    [CompilerGeneratedAttribute]
public int get_Version();
    [CompilerGeneratedAttribute]
public string get_UserName();
}
internal class MongoDB.Driver.Core.Authentication.Oidc.OidcConfiguration : object {
    public static string CallbackMechanismPropertyName;
    public static string EnvironmentMechanismPropertyName;
    public static string TokenResourceMechanismPropertyName;
    private static ISet`1<string> __supportedEnvironments;
    private int _hashCode;
    [CompilerGeneratedAttribute]
private IOidcCallback <Callback>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<EndPoint> <EndPoints>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Environment>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PrincipalName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TokenResource>k__BackingField;
    public IOidcCallback Callback { get; }
    public IEnumerable`1<EndPoint> EndPoints { get; }
    public string Environment { get; }
    public string PrincipalName { get; }
    public string TokenResource { get; }
    public OidcConfiguration(IEnumerable`1<EndPoint> endPoints, string principalName, IEnumerable`1<KeyValuePair`2<string, object>> authMechanismProperties);
    private static OidcConfiguration();
    [CompilerGeneratedAttribute]
public IOidcCallback get_Callback();
    [CompilerGeneratedAttribute]
public IEnumerable`1<EndPoint> get_EndPoints();
    [CompilerGeneratedAttribute]
public string get_Environment();
    [CompilerGeneratedAttribute]
public string get_PrincipalName();
    [CompilerGeneratedAttribute]
public string get_TokenResource();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    private int CalculateHashCode();
    private void ValidateOptions();
    [CompilerGeneratedAttribute]
internal static T <.ctor>g__GetProperty|5_0(KeyValuePair`2<string, object> property);
}
internal class MongoDB.Driver.Core.Authentication.Oidc.OidcCredentials : object {
    private IClock _clock;
    [CompilerGeneratedAttribute]
private string <AccessToken>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <Expiration>k__BackingField;
    public string AccessToken { get; }
    public DateTime Expiration { get; }
    public bool IsExpired { get; }
    public OidcCredentials(string accessToken, Nullable`1<TimeSpan> expiration, IClock clock);
    [CompilerGeneratedAttribute]
public string get_AccessToken();
    [CompilerGeneratedAttribute]
public DateTime get_Expiration();
    public bool get_IsExpired();
}
internal class MongoDB.Driver.Core.Authentication.Oidc.OidcSaslMechanism : object {
    private IOidcCallbackAdapter _oidcCallback;
    private string _principalName;
    private OidcCredentials _usedCredentials;
    public string Name { get; }
    public bool HasCachedCredentials { get; }
    public OidcSaslMechanism(IOidcCallbackAdapter oidcCallback, string principalName);
    public sealed virtual string get_Name();
    public bool get_HasCachedCredentials();
    public sealed virtual ISaslStep Initialize(IConnection connection, SaslConversation conversation, ConnectionDescription description, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MongoDB.Driver.Core.Authentication.Oidc.OidcSaslMechanism/<InitializeAsync>d__9")]
public sealed virtual Task`1<ISaslStep> InitializeAsync(IConnection connection, SaslConversation conversation, ConnectionDescription description, CancellationToken cancellationToken);
    public ISaslStep CreateSpeculativeAuthenticationStep(CancellationToken cancellationToken);
    public void ClearCache();
    private ISaslStep CreateNoTransitionClientLastSaslStep(OidcCredentials oidcCredentials);
}
public class MongoDB.Driver.Core.Authentication.PlainAuthenticator : SaslAuthenticator {
    private string _databaseName;
    public static string MechanismName { get; }
    public string DatabaseName { get; }
    [ObsoleteAttribute("Use the newest overload instead.")]
public PlainAuthenticator(UsernamePasswordCredential credential);
    public PlainAuthenticator(UsernamePasswordCredential credential, ServerApi serverApi);
    public static string get_MechanismName();
    public virtual string get_DatabaseName();
}
public abstract class MongoDB.Driver.Core.Authentication.SaslAuthenticator : object {
    public static string SaslStartCommand;
    public static string SaslContinueCommand;
    private protected ISaslMechanism _mechanism;
    private protected ServerApi _serverApi;
    private protected ISaslStep _speculativeFirstStep;
    public string Name { get; }
    public string DatabaseName { get; }
    [ObsoleteAttribute("Use the newest overload instead.")]
protected SaslAuthenticator(ISaslMechanism mechanism);
    protected SaslAuthenticator(ISaslMechanism mechanism, ServerApi serverApi);
    public sealed virtual string get_Name();
    public abstract virtual string get_DatabaseName();
    public virtual void Authenticate(IConnection connection, ConnectionDescription description, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MongoDB.Driver.Core.Authentication.SaslAuthenticator/<AuthenticateAsync>d__12")]
public virtual Task AuthenticateAsync(IConnection connection, ConnectionDescription description, CancellationToken cancellationToken);
    public virtual BsonDocument CustomizeInitialHelloCommand(BsonDocument helloCommand, CancellationToken cancellationToken);
    private protected bool TryGetSpeculativeFirstStep(ConnectionDescription description, ISaslStep& firstStep, BsonDocument& result);
    private protected virtual MongoAuthenticationException CreateException(ConnectionId connectionId, Exception ex, BsonDocument command);
    private CommandWireProtocol`1<BsonDocument> CreateCommandProtocol(BsonDocument command);
    private protected virtual BsonDocument CreateStartCommand(ISaslStep currentStep);
    private BsonDocument CreateContinueCommand(ISaslStep currentStep, int conversationId);
    private bool IsCompleted(ISaslStep currentStep, BsonDocument result);
    private ISaslStep Transition(SaslConversation conversation, ISaslStep currentStep, BsonDocument result);
    [AsyncStateMachineAttribute("MongoDB.Driver.Core.Authentication.SaslAuthenticator/<TransitionAsync>d__21")]
private Task`1<ISaslStep> TransitionAsync(SaslConversation conversation, ISaslStep currentStep, BsonDocument result, CancellationToken cancellationToken);
}
internal static class MongoDB.Driver.Core.Authentication.SaslMapParser : object {
    private static int EOF;
    public static IDictionary`2<char, string> Parse(string text);
    private static KeyValuePair`2<char, string> ReadKeyValue(TextReader reader);
    private static char ReadKey(TextReader reader);
    private static void Read(TextReader reader, char expected);
    private static string ReadValue(TextReader reader);
}
internal static class MongoDB.Driver.Core.Authentication.SaslPrepHelper : object {
    private static int MinCodepoint;
    private static int MaxCodepoint;
    private static int SurrogateMinCodepoint;
    private static int SurrogateMaxCodePoint;
    public static string SaslPrepQuery(string str);
    public static string SaslPrepStored(string str);
    private static string SaslPrep(string str, bool allowUnassigned);
    private static bool AsciiControl(char ch);
    private static bool ChangeDisplayProperties(int codepoint);
    private static int CharCount(int codepoint);
    private static bool InappropriateForCanonical(int codepoint);
    private static bool InappropriateForPlainText(int codepoint);
    private static bool IsDefined(int codepoint);
    private static bool IsLCat(int codepoint);
    private static bool IsRandALcat(int codepoint);
    private static bool IsSurrogateCodepoint(int codepoint);
    private static bool MappedToNothing(char ch);
    private static bool NonAsciiControl(int codepoint);
    private static bool NonAsciiSpace(char ch);
    private static bool NonCharacterCodepoint(int codepoint);
    private static bool PrivateUse(int codepoint);
    private static bool Prohibited(int codepoint);
    private static bool Surrogatecodepoint(int codepoint);
    private static bool Tagging(int codepoint);
}
internal class MongoDB.Driver.Core.Authentication.ScramCache : object {
    private ScramCacheKey _cacheKey;
    private ScramCacheEntry _cachedEntry;
    public bool TryGet(ScramCacheKey key, ScramCacheEntry& entry);
    public void Add(ScramCacheKey key, ScramCacheEntry entry);
}
internal class MongoDB.Driver.Core.Authentication.ScramCacheEntry : object {
    private Byte[] _clientKey;
    private Byte[] _serverKey;
    public Byte[] ClientKey { get; }
    public Byte[] ServerKey { get; }
    public ScramCacheEntry(Byte[] clientKey, Byte[] serverKey);
    public Byte[] get_ClientKey();
    public Byte[] get_ServerKey();
}
internal class MongoDB.Driver.Core.Authentication.ScramCacheKey : object {
    private int _iterationCount;
    private SecureString _password;
    private Byte[] _salt;
    internal ScramCacheKey(SecureString password, Byte[] salt, int iterationCount);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    private bool Equals(SecureString x, SecureString y);
    private bool Equals(Char[] x, Char[] y);
}
public class MongoDB.Driver.Core.Authentication.ScramSha1Authenticator : ScramShaAuthenticator {
    public static string MechanismName { get; }
    [ObsoleteAttribute("Use the newest overload instead.")]
public ScramSha1Authenticator(UsernamePasswordCredential credential);
    public ScramSha1Authenticator(UsernamePasswordCredential credential, ServerApi serverApi);
    internal ScramSha1Authenticator(UsernamePasswordCredential credential, IRandomStringGenerator randomStringGenerator, ServerApi serverApi);
    public static string get_MechanismName();
    private static Byte[] H1(Byte[] data);
    private static Byte[] Hi1(UsernamePasswordCredential credential, Byte[] salt, int iterations);
    private static Byte[] Hmac1(UTF8Encoding encoding, Byte[] data, string key);
}
public class MongoDB.Driver.Core.Authentication.ScramSha256Authenticator : ScramShaAuthenticator {
    public static string MechanismName { get; }
    [ObsoleteAttribute("Use the newest overload instead.")]
public ScramSha256Authenticator(UsernamePasswordCredential credential);
    public ScramSha256Authenticator(UsernamePasswordCredential credential, ServerApi serverApi);
    internal ScramSha256Authenticator(UsernamePasswordCredential credential, IRandomStringGenerator randomStringGenerator, ServerApi serverApi);
    public static string get_MechanismName();
    private static Byte[] H256(Byte[] data);
    private static Byte[] Hi256(UsernamePasswordCredential credential, Byte[] salt, int iterations);
    private static Byte[] Hi256(Char[] passwordChars, Byte[] salt, int iterations);
    private static Byte[] Hmac256(UTF8Encoding encoding, Byte[] data, string key);
}
public abstract class MongoDB.Driver.Core.Authentication.ScramShaAuthenticator : SaslAuthenticator {
    private string _databaseName;
    public string DatabaseName { get; }
    [ObsoleteAttribute("Use the newest overload instead.")]
protected ScramShaAuthenticator(UsernamePasswordCredential credential, HashAlgorithmName hashAlgorithmName, H h, Hi hi, Hmac hmac);
    protected ScramShaAuthenticator(UsernamePasswordCredential credential, HashAlgorithmName hashAlgorithmName, H h, Hi hi, Hmac hmac, ServerApi serverApi);
    internal ScramShaAuthenticator(UsernamePasswordCredential credential, HashAlgorithmName hashAlgorithName, IRandomStringGenerator randomStringGenerator, H h, Hi hi, Hmac hmac, ScramCache cache, ServerApi serverApi);
    public virtual string get_DatabaseName();
    public virtual BsonDocument CustomizeInitialHelloCommand(BsonDocument helloCommand, CancellationToken cancellationToken);
    private protected virtual BsonDocument CreateStartCommand(ISaslStep currentStep);
}
internal static class MongoDB.Driver.Core.Authentication.SecurityContextFactory : object {
    public static ISecurityContext InitializeSecurityContext(string serviceName, string hostname, string realm, string authorizationId, SecureString password);
}
internal class MongoDB.Driver.Core.Authentication.Sspi.AuthIdentity : object {
    public string Username;
    public int UsernameLength;
    public string Domain;
    public int DomainLength;
    public IntPtr Password;
    public int PasswordLength;
    public AuthIdentityFlag Flags;
    public AuthIdentity(string username, SecureString password);
    protected virtual override void Finalize();
    public sealed virtual void Dispose();
    private void Dispose(bool disposing);
}
internal enum MongoDB.Driver.Core.Authentication.Sspi.AuthIdentityFlag : Enum {
    public int value__;
    public static AuthIdentityFlag Ansi;
    public static AuthIdentityFlag Unicode;
}
internal enum MongoDB.Driver.Core.Authentication.Sspi.DataRepresentation : Enum {
    public int value__;
    public static DataRepresentation Network;
    public static DataRepresentation Native;
}
internal enum MongoDB.Driver.Core.Authentication.Sspi.EncryptQualityOfProtection : Enum {
    public UInt32 value__;
    public static EncryptQualityOfProtection WrapNoEncrypt;
}
internal static class MongoDB.Driver.Core.Authentication.Sspi.NativeMethods : object {
    public static int MAX_TOKEN_SIZE;
    public static long SEC_E_OK;
    public static long SEC_E_INSUFFICENT_MEMORY;
    public static long SEC_E_INVALID_HANDLE;
    public static long SEC_E_TARGET_UNKNOWN;
    public static long SEC_E_INTERNAL_ERROR;
    public static long SEC_E_SECPKG_NOT_FOUND;
    public static long SEC_E_INVALID_TOKEN;
    public static long SEC_E_QOP_NOT_SUPPORTED;
    public static long SEC_E_LOGON_DENIED;
    public static long SEC_E_UNKNOWN_CREDENTIALS;
    public static long SEC_E_NO_CREDENTIALS;
    public static long SEC_E_MESSAGE_ALTERED;
    public static long SEC_E_OUT_OF_SEQUENCE;
    public static long SEC_E_NO_AUTHENTICATING_AUTHORITY;
    public static long SEC_E_CONTEXT_EXPIRED;
    public static long SEC_E_INCOMPLETE_MESSAGE;
    public static long SEC_E_BUFFER_TOO_SMALL;
    public static long SEC_E_CRYPTO_SYSTEM_INVALID;
    public static long SEC_I_CONTINUE_NEEDED;
    public static long SEC_I_CONTEXT_EXPIRED;
    public static long SEC_I_RENEGOTIATE;
    public static Win32Exception CreateException(long errorCode, string defaultMessage);
    public static UInt32 AcquireCredentialsHandle(string principal, string package, SecurityCredentialUse credentialUsage, IntPtr logonId, AuthIdentity identity, int keyCallback, IntPtr keyArgument, SspiHandle& credentialHandle, Int64& timestamp);
    public static UInt32 AcquireCredentialsHandle(string principal, string package, SecurityCredentialUse credentialUsage, IntPtr logonId, IntPtr identity, int keyCallback, IntPtr keyArgument, SspiHandle& credentialHandle, Int64& timestamp);
    public static UInt32 DeleteSecurityContext(SspiHandle& context);
    public static UInt32 DecryptMessage(SspiHandle& context, SecurityBufferDescriptor& pMessage, UInt32 sequenceNumber, UInt32& quality);
    public static UInt32 EncryptMessage(SspiHandle& context, EncryptQualityOfProtection quality, SecurityBufferDescriptor& pMessage, UInt32 sequenceNumber);
    public static UInt32 EnumerateSecurityPackages(UInt32& numPackages, IntPtr& securityPackageInfoArray);
    public static UInt32 FreeContextBuffer(IntPtr contextBuffer);
    public static int FreeCredentialsHandle(SspiHandle& sspiHandle);
    public static UInt32 InitializeSecurityContext(SspiHandle& credentialHandle, IntPtr inContextPtr, string targetName, SspiContextFlags flags, int reserved1, DataRepresentation dataRepresentation, IntPtr inputBuffer, int reserved2, SspiHandle& outContextHandle, SecurityBufferDescriptor& outputBuffer, SspiContextFlags& outAttributes, Int64& timestamp);
    public static UInt32 InitializeSecurityContext(SspiHandle& credentialHandle, SspiHandle& inContextHandle, string targetName, SspiContextFlags flags, int reserved1, DataRepresentation dataRepresentation, SecurityBufferDescriptor& inputBuffer, int reserved2, SspiHandle& outContext, SecurityBufferDescriptor& outputBuffer, SspiContextFlags& outAttributes, Int64& timestamp);
    public static UInt32 QueryContextAttributes(SspiHandle& inContextHandle, QueryContextAttributes attribute, SecurityPackageContextSizes& sizes);
}
internal enum MongoDB.Driver.Core.Authentication.Sspi.QueryContextAttributes : Enum {
    public int value__;
    public static QueryContextAttributes Sizes;
}
internal class MongoDB.Driver.Core.Authentication.Sspi.SecurityBuffer : ValueType {
    public int Count;
    public SecurityBufferType BufferType;
    public IntPtr Token;
    public SecurityBuffer(int bufferSize);
    public SecurityBuffer(Byte[] bytes);
    public SecurityBuffer(Byte[] bytes, SecurityBufferType bufferType);
    public void Free();
}
internal class MongoDB.Driver.Core.Authentication.Sspi.SecurityBufferDescriptor : ValueType {
    public SecurityBufferType BufferType;
    public int NumBuffers;
    public IntPtr BufferPtr;
    public SecurityBufferDescriptor(int bufferSize);
    public SecurityBufferDescriptor(Byte[] secBufferBytes);
    public SecurityBufferDescriptor(SecurityBuffer[] buffers);
    public void Free();
    public Byte[] ToByteArray();
}
internal enum MongoDB.Driver.Core.Authentication.Sspi.SecurityBufferType : Enum {
    public int value__;
    public static SecurityBufferType Version;
    public static SecurityBufferType Empty;
    public static SecurityBufferType Data;
    public static SecurityBufferType Token;
    public static SecurityBufferType Padding;
    public static SecurityBufferType Stream;
}
internal enum MongoDB.Driver.Core.Authentication.Sspi.SecurityCredentialUse : Enum {
    public int value__;
    public static SecurityCredentialUse Outbound;
}
internal class MongoDB.Driver.Core.Authentication.Sspi.SecurityPackageContextSizes : ValueType {
    public UInt32 MaxToken;
    public UInt32 MaxSignature;
    public UInt32 BlockSize;
    public UInt32 SecurityTrailer;
}
internal class MongoDB.Driver.Core.Authentication.Sspi.SecurityPackageInfo : ValueType {
    public UInt32 Capabilities;
    public ushort Version;
    public ushort RpcIdentifier;
    public UInt32 MaxTokenSize;
    public string Name;
    public string Comment;
}
[FlagsAttribute]
internal enum MongoDB.Driver.Core.Authentication.Sspi.SspiContextFlags : Enum {
    public int value__;
    public static SspiContextFlags None;
    public static SspiContextFlags MutualAuth;
    public static SspiContextFlags Confidentiality;
    public static SspiContextFlags InitIntegrity;
}
internal class MongoDB.Driver.Core.Authentication.Sspi.SspiHandle : ValueType {
    private IntPtr _hi;
    private IntPtr _low;
    public bool IsZero { get; }
    public bool get_IsZero();
    public void SetToInvalid();
}
internal enum MongoDB.Driver.Core.Authentication.Sspi.SspiPackage : Enum {
    public int value__;
    public static SspiPackage Kerberos;
}
internal class MongoDB.Driver.Core.Authentication.Sspi.SspiSecurityContext : SafeHandle {
    private static int __maxTokenSize;
    private string _servicePrincipalName;
    private SspiSecurityCredential _credential;
    private SspiHandle _sspiHandle;
    private bool _isInitialized;
    private bool _isDisposed;
    public bool IsInitialized { get; }
    public bool IsInvalid { get; }
    private static SspiSecurityContext();
    public SspiSecurityContext(string servicePrincipalName, SspiSecurityCredential credential);
    public sealed virtual bool get_IsInitialized();
    public virtual bool get_IsInvalid();
    public sealed virtual Byte[] DecryptMessage(int messageLength, Byte[] encryptedBytes);
    public sealed virtual Byte[] EncryptMessage(Byte[] plainTextBytes);
    public sealed virtual Byte[] Next(Byte[] challenge);
    protected virtual bool ReleaseHandle();
    protected virtual void Dispose(bool disposing);
    private static int GetMaxTokenSize();
}
internal class MongoDB.Driver.Core.Authentication.Sspi.SspiSecurityCredential : SafeHandle {
    internal SspiHandle _sspiHandle;
    public bool IsInvalid { get; }
    public virtual bool get_IsInvalid();
    public static SspiSecurityCredential Acquire(SspiPackage package, string username, SecureString password);
    protected virtual bool ReleaseHandle();
}
public class MongoDB.Driver.Core.Authentication.Sspi.Win32Exception : GssapiException {
    public Win32Exception(long errorCode);
    public Win32Exception(long errorCode, string message);
    protected Win32Exception(SerializationInfo info, StreamingContext context);
}
public class MongoDB.Driver.Core.Authentication.UsernamePasswordCredential : object {
    private Lazy`1<SecureString> _saslPreppedPassword;
    private string _source;
    private SecureString _password;
    private string _username;
    public SecureString Password { get; }
    public SecureString SaslPreppedPassword { get; }
    public string Source { get; }
    public string Username { get; }
    public UsernamePasswordCredential(string source, string username, string password);
    public UsernamePasswordCredential(string source, string username, SecureString password);
    public SecureString get_Password();
    public SecureString get_SaslPreppedPassword();
    public string get_Source();
    public string get_Username();
    public string GetInsecurePassword();
    [CompilerGeneratedAttribute]
private SecureString <.ctor>b__5_0();
}
[ExtensionAttribute]
internal static class MongoDB.Driver.Core.Authentication.Vendored.CryptographyHelpers : object {
    private static string Cryptography_MissingIV;
    private static CryptographyHelpers();
    [ExtensionAttribute]
public static Byte[] CloneByteArray(Byte[] src);
    [ExtensionAttribute]
public static KeySizes[] CloneKeySizesArray(KeySizes[] src);
    [ExtensionAttribute]
public static bool UsesIv(CipherMode cipherMode);
    [ExtensionAttribute]
public static Byte[] GetCipherIv(CipherMode cipherMode, Byte[] iv);
    [ExtensionAttribute]
public static bool IsLegalSize(int size, KeySizes[] legalSizes);
    public static Byte[] GenerateRandom(int count);
    public static void WriteInt(UInt32 i, Byte[] arr, int offset);
    [ExtensionAttribute]
public static Byte[] FixupKeyParity(Byte[] key);
    internal static void ConvertIntToByteArray(UInt32 value, Byte[] dest);
}
internal class MongoDB.Driver.Core.Authentication.Vendored.Rfc2898DeriveBytes : DeriveBytes {
    private static string Cryptography_PasswordDerivedBytes_FewBytesSalt;
    private static string ArgumentOutOfRange_NeedPosNum;
    private static string Cryptography_HashAlgorithmNameNullOrEmpty;
    private static string ArgumentOutOfRange_NeedNonNegNum;
    private static string Cryptography_UnknownHashAlgorithm;
    private static int MinimumSaltSize;
    private Byte[] _password;
    private Byte[] _salt;
    private UInt32 _iterations;
    private HMAC _hmac;
    private int _blockSize;
    private Byte[] _buffer;
    private UInt32 _block;
    private int _startIndex;
    private int _endIndex;
    [CompilerGeneratedAttribute]
private HashAlgorithmName <HashAlgorithm>k__BackingField;
    public HashAlgorithmName HashAlgorithm { get; }
    public int IterationCount { get; public set; }
    public Byte[] Salt { get; public set; }
    public Rfc2898DeriveBytes(Byte[] password, Byte[] salt, int iterations);
    public Rfc2898DeriveBytes(Byte[] password, Byte[] salt, int iterations, HashAlgorithmName hashAlgorithm);
    public Rfc2898DeriveBytes(string password, Byte[] salt);
    public Rfc2898DeriveBytes(string password, Byte[] salt, int iterations);
    public Rfc2898DeriveBytes(string password, Byte[] salt, int iterations, HashAlgorithmName hashAlgorithm);
    public Rfc2898DeriveBytes(string password, int saltSize);
    public Rfc2898DeriveBytes(string password, int saltSize, int iterations);
    public Rfc2898DeriveBytes(string password, int saltSize, int iterations, HashAlgorithmName hashAlgorithm);
    private static Rfc2898DeriveBytes();
    [CompilerGeneratedAttribute]
public HashAlgorithmName get_HashAlgorithm();
    public int get_IterationCount();
    public void set_IterationCount(int value);
    public Byte[] get_Salt();
    public void set_Salt(Byte[] value);
    protected virtual void Dispose(bool disposing);
    public virtual Byte[] GetBytes(int cb);
    public Byte[] CryptDeriveKey(string algname, string alghashname, int keySize, Byte[] rgbIV);
    public virtual void Reset();
    private static string Format(string resourceFormat, Object[] args);
    private HMAC OpenHmac();
    private void Initialize();
    private Byte[] Func();
}
internal class MongoDB.Driver.Core.Bindings.ChannelChannelSource : object {
    private IChannelHandle _channel;
    private bool _disposed;
    private IServer _server;
    private ICoreSessionHandle _session;
    public IServer Server { get; }
    public ServerDescription ServerDescription { get; }
    public ICoreSessionHandle Session { get; }
    public ChannelChannelSource(IServer server, IChannelHandle channel, ICoreSessionHandle session);
    public sealed virtual IServer get_Server();
    public sealed virtual ServerDescription get_ServerDescription();
    public sealed virtual ICoreSessionHandle get_Session();
    public sealed virtual void Dispose();
    public sealed virtual IChannelHandle GetChannel(CancellationToken cancellationToken);
    public sealed virtual Task`1<IChannelHandle> GetChannelAsync(CancellationToken cancellationToken);
    private IChannelHandle GetChannelHelper();
    private void ThrowIfDisposed();
}
public class MongoDB.Driver.Core.Bindings.ChannelReadBinding : object {
    private IChannelHandle _channel;
    private bool _disposed;
    private ReadPreference _readPreference;
    private IServer _server;
    private ICoreSessionHandle _session;
    public ReadPreference ReadPreference { get; }
    public ICoreSessionHandle Session { get; }
    public ChannelReadBinding(IServer server, IChannelHandle channel, ReadPreference readPreference, ICoreSessionHandle session);
    public sealed virtual ReadPreference get_ReadPreference();
    public sealed virtual ICoreSessionHandle get_Session();
    public sealed virtual void Dispose();
    public sealed virtual IChannelSourceHandle GetReadChannelSource(CancellationToken cancellationToken);
    public sealed virtual Task`1<IChannelSourceHandle> GetReadChannelSourceAsync(CancellationToken cancellationToken);
    public sealed virtual IChannelSourceHandle GetReadChannelSource(IReadOnlyCollection`1<ServerDescription> deprioritizedServers, CancellationToken cancellationToken);
    public sealed virtual Task`1<IChannelSourceHandle> GetReadChannelSourceAsync(IReadOnlyCollection`1<ServerDescription> deprioritizedServers, CancellationToken cancellationToken);
    private IChannelSourceHandle GetReadChannelSourceHelper();
    private void ThrowIfDisposed();
}
public class MongoDB.Driver.Core.Bindings.ChannelReadWriteBinding : object {
    private IChannelHandle _channel;
    private bool _disposed;
    private IServer _server;
    private ICoreSessionHandle _session;
    public ReadPreference ReadPreference { get; }
    public ICoreSessionHandle Session { get; }
    public ChannelReadWriteBinding(IServer server, IChannelHandle channel, ICoreSessionHandle session);
    public sealed virtual ReadPreference get_ReadPreference();
    public sealed virtual ICoreSessionHandle get_Session();
    public sealed virtual void Dispose();
    public sealed virtual IChannelSourceHandle GetReadChannelSource(CancellationToken cancellationToken);
    public sealed virtual Task`1<IChannelSourceHandle> GetReadChannelSourceAsync(CancellationToken cancellationToken);
    public sealed virtual IChannelSourceHandle GetReadChannelSource(IReadOnlyCollection`1<ServerDescription> deprioritizedServers, CancellationToken cancellationToken);
    public sealed virtual Task`1<IChannelSourceHandle> GetReadChannelSourceAsync(IReadOnlyCollection`1<ServerDescription> deprioritizedServers, CancellationToken cancellationToken);
    public sealed virtual IChannelSourceHandle GetWriteChannelSource(CancellationToken cancellationToken);
    public sealed virtual IChannelSourceHandle GetWriteChannelSource(IReadOnlyCollection`1<ServerDescription> deprioritizedServers, CancellationToken cancellationToken);
    public sealed virtual IChannelSourceHandle GetWriteChannelSource(IMayUseSecondaryCriteria mayUseSecondary, CancellationToken cancellationToken);
    public sealed virtual IChannelSourceHandle GetWriteChannelSource(IReadOnlyCollection`1<ServerDescription> deprioritizedServers, IMayUseSecondaryCriteria mayUseSecondary, CancellationToken cancellationToken);
    public sealed virtual Task`1<IChannelSourceHandle> GetWriteChannelSourceAsync(CancellationToken cancellationToken);
    public sealed virtual Task`1<IChannelSourceHandle> GetWriteChannelSourceAsync(IReadOnlyCollection`1<ServerDescription> deprioritizedServers, CancellationToken cancellationToken);
    public sealed virtual Task`1<IChannelSourceHandle> GetWriteChannelSourceAsync(IMayUseSecondaryCriteria mayUseSecondary, CancellationToken cancellationToken);
    public sealed virtual Task`1<IChannelSourceHandle> GetWriteChannelSourceAsync(IReadOnlyCollection`1<ServerDescription> deprioritizedServers, IMayUseSecondaryCriteria mayUseSecondary, CancellationToken cancellationToken);
    private IChannelSourceHandle GetChannelSourceHelper();
    private void ThrowIfDisposed();
}
public class MongoDB.Driver.Core.Bindings.ChannelSourceHandle : object {
    private bool _disposed;
    private ReferenceCounted`1<IChannelSource> _reference;
    public IServer Server { get; }
    public ServerDescription ServerDescription { get; }
    public ICoreSessionHandle Session { get; }
    public ChannelSourceHandle(IChannelSource channelSource);
    private ChannelSourceHandle(ReferenceCounted`1<IChannelSource> reference);
    public sealed virtual IServer get_Server();
    public sealed virtual ServerDescription get_ServerDescription();
    public sealed virtual ICoreSessionHandle get_Session();
    public sealed virtual IChannelHandle GetChannel(CancellationToken cancellationToken);
    public sealed virtual Task`1<IChannelHandle> GetChannelAsync(CancellationToken cancellationToken);
    public sealed virtual void Dispose();
    public sealed virtual IChannelSourceHandle Fork();
    private void ThrowIfDisposed();
}
public class MongoDB.Driver.Core.Bindings.ChannelSourceReadWriteBinding : object {
    private IChannelSourceHandle _channelSource;
    private bool _disposed;
    private ReadPreference _readPreference;
    private ICoreSessionHandle _session;
    public ReadPreference ReadPreference { get; }
    public ICoreSessionHandle Session { get; }
    public ChannelSourceReadWriteBinding(IChannelSourceHandle channelSource, ReadPreference readPreference, ICoreSessionHandle session);
    public sealed virtual ReadPreference get_ReadPreference();
    public sealed virtual ICoreSessionHandle get_Session();
    public sealed virtual IChannelSourceHandle GetReadChannelSource(CancellationToken cancellationToken);
    public sealed virtual Task`1<IChannelSourceHandle> GetReadChannelSourceAsync(CancellationToken cancellationToken);
    public sealed virtual IChannelSourceHandle GetReadChannelSource(IReadOnlyCollection`1<ServerDescription> deprioritizedServers, CancellationToken cancellationToken);
    public sealed virtual Task`1<IChannelSourceHandle> GetReadChannelSourceAsync(IReadOnlyCollection`1<ServerDescription> deprioritizedServers, CancellationToken cancellationToken);
    public sealed virtual IChannelSourceHandle GetWriteChannelSource(CancellationToken cancellationToken);
    public sealed virtual IChannelSourceHandle GetWriteChannelSource(IReadOnlyCollection`1<ServerDescription> deprioritizedServers, CancellationToken cancellationToken);
    public sealed virtual IChannelSourceHandle GetWriteChannelSource(IMayUseSecondaryCriteria mayUseSecondary, CancellationToken cancellationToken);
    public sealed virtual IChannelSourceHandle GetWriteChannelSource(IReadOnlyCollection`1<ServerDescription> deprioritizedServers, IMayUseSecondaryCriteria mayUseSecondary, CancellationToken cancellationToken);
    public sealed virtual Task`1<IChannelSourceHandle> GetWriteChannelSourceAsync(CancellationToken cancellationToken);
    public sealed virtual Task`1<IChannelSourceHandle> GetWriteChannelSourceAsync(IReadOnlyCollection`1<ServerDescription> deprioritizedServers, CancellationToken cancellationToken);
    public sealed virtual Task`1<IChannelSourceHandle> GetWriteChannelSourceAsync(IMayUseSecondaryCriteria mayUseSecondary, CancellationToken cancellationToken);
    public sealed virtual Task`1<IChannelSourceHandle> GetWriteChannelSourceAsync(IReadOnlyCollection`1<ServerDescription> deprioritizedServers, IMayUseSecondaryCriteria mayUseSecondary, CancellationToken cancellationToken);
    public sealed virtual void Dispose();
    private IChannelSourceHandle GetChannelSourceHelper();
    private void ThrowIfDisposed();
}
public class MongoDB.Driver.Core.Bindings.CoreSession : object {
    private ICluster _cluster;
    private IClusterClock _clusterClock;
    private CoreTransaction _currentTransaction;
    private bool _disposed;
    private bool _isCommitTransactionInProgress;
    private IOperationClock _operationClock;
    private CoreSessionOptions _options;
    private Lazy`1<ICoreServerSession> _serverSession;
    private BsonTimestamp _snapshotTime;
    public ICluster Cluster { get; }
    public BsonDocument ClusterTime { get; }
    public CoreTransaction CurrentTransaction { get; }
    public BsonDocument Id { get; }
    public bool IsCausallyConsistent { get; }
    public bool IsDirty { get; }
    public bool IsImplicit { get; }
    public bool IsInTransaction { get; }
    public bool IsSnapshot { get; }
    public BsonTimestamp OperationTime { get; }
    public CoreSessionOptions Options { get; }
    public ICoreServerSession ServerSession { get; }
    public BsonTimestamp SnapshotTime { get; }
    [ObsoleteAttribute("This constructor is deprecated. Avoid using CoreSession directly.")]
public CoreSession(ICluster cluster, ICoreServerSession serverSession, CoreSessionOptions options);
    internal CoreSession(ICluster cluster, ICoreServerSessionPool serverSessionPool, CoreSessionOptions options);
    private CoreSession(ICluster cluster, CoreSessionOptions options);
    public ICluster get_Cluster();
    public sealed virtual BsonDocument get_ClusterTime();
    public sealed virtual CoreTransaction get_CurrentTransaction();
    public sealed virtual BsonDocument get_Id();
    public sealed virtual bool get_IsCausallyConsistent();
    public sealed virtual bool get_IsDirty();
    public sealed virtual bool get_IsImplicit();
    public sealed virtual bool get_IsInTransaction();
    public sealed virtual bool get_IsSnapshot();
    public sealed virtual BsonTimestamp get_OperationTime();
    public sealed virtual CoreSessionOptions get_Options();
    public sealed virtual ICoreServerSession get_ServerSession();
    public sealed virtual BsonTimestamp get_SnapshotTime();
    public sealed virtual void AbortTransaction(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MongoDB.Driver.Core.Bindings.CoreSession/<AbortTransactionAsync>d__39")]
public sealed virtual Task AbortTransactionAsync(CancellationToken cancellationToken);
    public sealed virtual void AboutToSendCommand();
    public sealed virtual void AdvanceClusterTime(BsonDocument newClusterTime);
    public sealed virtual void AdvanceOperationTime(BsonTimestamp newOperationTime);
    public sealed virtual long AdvanceTransactionNumber();
    public sealed virtual void CommitTransaction(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MongoDB.Driver.Core.Bindings.CoreSession/<CommitTransactionAsync>d__45")]
public sealed virtual Task CommitTransactionAsync(CancellationToken cancellationToken);
    public sealed virtual void Dispose();
    public sealed virtual void MarkDirty();
    public sealed virtual void StartTransaction(TransactionOptions transactionOptions);
    public sealed virtual void SetSnapshotTimeIfNeeded(BsonTimestamp snapshotTime);
    public sealed virtual void WasUsed();
    private IReadOperation`1<BsonDocument> CreateAbortTransactionOperation();
    private IReadOperation`1<BsonDocument> CreateCommitTransactionOperation(bool isCommitRetry);
    private void EnsureAbortTransactionCanBeCalled(string methodName);
    private void EnsureCommitTransactionCanBeCalled(string methodName);
    private void EnsureStartTransactionCanBeCalled();
    private void EnsureTransactionsAreSupported();
    private TResult ExecuteEndTransactionOnPrimary(IReadOperation`1<TResult> operation, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MongoDB.Driver.Core.Bindings.CoreSession/<ExecuteEndTransactionOnPrimaryAsync>d__58`1")]
private Task`1<TResult> ExecuteEndTransactionOnPrimaryAsync(IReadOperation`1<TResult> operation, CancellationToken cancellationToken);
    private TransactionOptions GetEffectiveTransactionOptions(TransactionOptions transactionOptions);
    private WriteConcern GetTransactionWriteConcern();
    private WriteConcern GetCommitTransactionWriteConcern(bool isCommitRetry);
    private bool IsFirstCommitAttemptRetry();
    private bool ShouldRetryEndTransactionException(Exception exception);
}
public class MongoDB.Driver.Core.Bindings.CoreSessionHandle : WrappingCoreSession {
    private ReferenceCountedCoreSession _wrapped;
    public CoreSessionHandle(ICoreSession session);
    internal CoreSessionHandle(ReferenceCountedCoreSession wrapped);
    public sealed virtual ICoreSessionHandle Fork();
    protected virtual void Dispose(bool disposing);
}
public class MongoDB.Driver.Core.Bindings.CoreSessionOptions : object {
    private TransactionOptions _defaultTransactionOptions;
    private bool _isCausallyConsistent;
    private bool _isImplicit;
    private bool _isSnapshot;
    public TransactionOptions DefaultTransactionOptions { get; }
    public bool IsCausallyConsistent { get; }
    public bool IsImplicit { get; }
    public bool IsSnapshot { get; }
    public CoreSessionOptions(bool isCausallyConsistent, bool isImplicit, TransactionOptions defaultTransactionOptions, bool isSnapshot);
    public TransactionOptions get_DefaultTransactionOptions();
    public bool get_IsCausallyConsistent();
    public bool get_IsImplicit();
    public bool get_IsSnapshot();
}
public class MongoDB.Driver.Core.Bindings.CoreTransaction : object {
    private bool _isEmpty;
    private IChannelHandle _pinnedChannel;
    private IServer _pinnedServer;
    private BsonDocument _recoveryToken;
    private CoreTransactionState _state;
    private long _transactionNumber;
    private TransactionOptions _transactionOptions;
    private object _lock;
    public bool IsEmpty { get; }
    public CoreTransactionState State { get; }
    public IChannelHandle PinnedChannel { get; }
    public IServer PinnedServer { get; internal set; }
    public long TransactionNumber { get; }
    public TransactionOptions TransactionOptions { get; }
    public BsonDocument RecoveryToken { get; internal set; }
    public CoreTransaction(long transactionNumber, TransactionOptions transactionOptions);
    public bool get_IsEmpty();
    public CoreTransactionState get_State();
    public IChannelHandle get_PinnedChannel();
    public IServer get_PinnedServer();
    internal void set_PinnedServer(IServer value);
    public long get_TransactionNumber();
    public TransactionOptions get_TransactionOptions();
    public BsonDocument get_RecoveryToken();
    internal void set_RecoveryToken(BsonDocument value);
    internal void PinChannel(IChannelHandle channel);
    internal void SetState(CoreTransactionState state);
    internal void UnpinAll();
}
public enum MongoDB.Driver.Core.Bindings.CoreTransactionState : Enum {
    public int value__;
    public static CoreTransactionState Starting;
    public static CoreTransactionState InProgress;
    public static CoreTransactionState Committed;
    public static CoreTransactionState Aborted;
}
public interface MongoDB.Driver.Core.Bindings.IBinding {
    public ICoreSessionHandle Session { get; }
    public abstract virtual ICoreSessionHandle get_Session();
}
public interface MongoDB.Driver.Core.Bindings.IChannel {
    public IConnectionHandle Connection { get; }
    public ConnectionDescription ConnectionDescription { get; }
    public abstract virtual IConnectionHandle get_Connection();
    public abstract virtual ConnectionDescription get_ConnectionDescription();
    public abstract virtual TResult Command(ICoreSession session, ReadPreference readPreference, DatabaseNamespace databaseNamespace, BsonDocument command, IEnumerable`1<Type1CommandMessageSection> commandPayloads, IElementNameValidator commandValidator, BsonDocument additionalOptions, Action`1<IMessageEncoderPostProcessor> postWriteAction, CommandResponseHandling responseHandling, IBsonSerializer`1<TResult> resultSerializer, MessageEncoderSettings messageEncoderSettings, CancellationToken cancellationToken);
    public abstract virtual Task`1<TResult> CommandAsync(ICoreSession session, ReadPreference readPreference, DatabaseNamespace databaseNamespace, BsonDocument command, IEnumerable`1<Type1CommandMessageSection> commandPayloads, IElementNameValidator commandValidator, BsonDocument additionalOptions, Action`1<IMessageEncoderPostProcessor> postWriteAction, CommandResponseHandling responseHandling, IBsonSerializer`1<TResult> resultSerializer, MessageEncoderSettings messageEncoderSettings, CancellationToken cancellationToken);
    public abstract virtual CursorBatch`1<TDocument> Query(CollectionNamespace collectionNamespace, BsonDocument query, BsonDocument fields, IElementNameValidator queryValidator, int skip, int batchSize, bool secondaryOk, bool partialOk, bool noCursorTimeout, bool tailableCursor, bool awaitData, IBsonSerializer`1<TDocument> serializer, MessageEncoderSettings messageEncoderSettings, CancellationToken cancellationToken);
    [ObsoleteAttribute("Use an overload that does not have an oplogReplay parameter instead.")]
public abstract virtual CursorBatch`1<TDocument> Query(CollectionNamespace collectionNamespace, BsonDocument query, BsonDocument fields, IElementNameValidator queryValidator, int skip, int batchSize, bool secondaryOk, bool partialOk, bool noCursorTimeout, bool oplogReplay, bool tailableCursor, bool awaitData, IBsonSerializer`1<TDocument> serializer, MessageEncoderSettings messageEncoderSettings, CancellationToken cancellationToken);
    public abstract virtual Task`1<CursorBatch`1<TDocument>> QueryAsync(CollectionNamespace collectionNamespace, BsonDocument query, BsonDocument fields, IElementNameValidator queryValidator, int skip, int batchSize, bool secondaryOk, bool partialOk, bool noCursorTimeout, bool tailableCursor, bool awaitData, IBsonSerializer`1<TDocument> serializer, MessageEncoderSettings messageEncoderSettings, CancellationToken cancellationToken);
    [ObsoleteAttribute("Use an overload that does not have an oplogReplay parameter instead.")]
public abstract virtual Task`1<CursorBatch`1<TDocument>> QueryAsync(CollectionNamespace collectionNamespace, BsonDocument query, BsonDocument fields, IElementNameValidator queryValidator, int skip, int batchSize, bool secondaryOk, bool partialOk, bool noCursorTimeout, bool oplogReplay, bool tailableCursor, bool awaitData, IBsonSerializer`1<TDocument> serializer, MessageEncoderSettings messageEncoderSettings, CancellationToken cancellationToken);
}
public interface MongoDB.Driver.Core.Bindings.IChannelHandle {
    public abstract virtual IChannelHandle Fork();
}
public interface MongoDB.Driver.Core.Bindings.IChannelSource {
    public IServer Server { get; }
    public ServerDescription ServerDescription { get; }
    public ICoreSessionHandle Session { get; }
    public abstract virtual IServer get_Server();
    public abstract virtual ServerDescription get_ServerDescription();
    public abstract virtual ICoreSessionHandle get_Session();
    public abstract virtual IChannelHandle GetChannel(CancellationToken cancellationToken);
    public abstract virtual Task`1<IChannelHandle> GetChannelAsync(CancellationToken cancellationToken);
}
public interface MongoDB.Driver.Core.Bindings.IChannelSourceHandle {
    public abstract virtual IChannelSourceHandle Fork();
}
public interface MongoDB.Driver.Core.Bindings.ICoreSession {
    public BsonDocument ClusterTime { get; }
    public CoreTransaction CurrentTransaction { get; }
    public BsonDocument Id { get; }
    public bool IsCausallyConsistent { get; }
    public bool IsDirty { get; }
    public bool IsImplicit { get; }
    public bool IsInTransaction { get; }
    public bool IsSnapshot { get; }
    public BsonTimestamp OperationTime { get; }
    public CoreSessionOptions Options { get; }
    public ICoreServerSession ServerSession { get; }
    public BsonTimestamp SnapshotTime { get; }
    public abstract virtual BsonDocument get_ClusterTime();
    public abstract virtual CoreTransaction get_CurrentTransaction();
    public abstract virtual BsonDocument get_Id();
    public abstract virtual bool get_IsCausallyConsistent();
    public abstract virtual bool get_IsDirty();
    public abstract virtual bool get_IsImplicit();
    public abstract virtual bool get_IsInTransaction();
    public abstract virtual bool get_IsSnapshot();
    public abstract virtual BsonTimestamp get_OperationTime();
    public abstract virtual CoreSessionOptions get_Options();
    public abstract virtual ICoreServerSession get_ServerSession();
    public abstract virtual BsonTimestamp get_SnapshotTime();
    public abstract virtual void AbortTransaction(CancellationToken cancellationToken);
    public abstract virtual Task AbortTransactionAsync(CancellationToken cancellationToken);
    public abstract virtual void AboutToSendCommand();
    public abstract virtual void AdvanceClusterTime(BsonDocument newClusterTime);
    public abstract virtual void AdvanceOperationTime(BsonTimestamp newOperationTime);
    public abstract virtual long AdvanceTransactionNumber();
    public abstract virtual void CommitTransaction(CancellationToken cancellationToken);
    public abstract virtual Task CommitTransactionAsync(CancellationToken cancellationToken);
    public abstract virtual void MarkDirty();
    public abstract virtual void StartTransaction(TransactionOptions transactionOptions);
    public abstract virtual void SetSnapshotTimeIfNeeded(BsonTimestamp snapshotTime);
    public abstract virtual void WasUsed();
}
public interface MongoDB.Driver.Core.Bindings.ICoreSessionHandle {
    public abstract virtual ICoreSessionHandle Fork();
}
public interface MongoDB.Driver.Core.Bindings.IMayUseSecondaryCriteria {
    public ReadPreference EffectiveReadPreference { get; public set; }
    public ReadPreference ReadPreference { get; }
    public abstract virtual ReadPreference get_EffectiveReadPreference();
    public abstract virtual void set_EffectiveReadPreference(ReadPreference value);
    public abstract virtual ReadPreference get_ReadPreference();
    public abstract virtual bool CanUseSecondary(ServerDescription server);
}
public interface MongoDB.Driver.Core.Bindings.IReadBinding {
    public ReadPreference ReadPreference { get; }
    public abstract virtual ReadPreference get_ReadPreference();
    public abstract virtual IChannelSourceHandle GetReadChannelSource(CancellationToken cancellationToken);
    public abstract virtual Task`1<IChannelSourceHandle> GetReadChannelSourceAsync(CancellationToken cancellationToken);
    public abstract virtual IChannelSourceHandle GetReadChannelSource(IReadOnlyCollection`1<ServerDescription> deprioritizedServers, CancellationToken cancellationToken);
    public abstract virtual Task`1<IChannelSourceHandle> GetReadChannelSourceAsync(IReadOnlyCollection`1<ServerDescription> deprioritizedServers, CancellationToken cancellationToken);
}
public interface MongoDB.Driver.Core.Bindings.IReadBindingHandle {
    public abstract virtual IReadBindingHandle Fork();
}
public interface MongoDB.Driver.Core.Bindings.IReadWriteBinding {
}
public interface MongoDB.Driver.Core.Bindings.IReadWriteBindingHandle {
    public abstract virtual IReadWriteBindingHandle Fork();
}
public interface MongoDB.Driver.Core.Bindings.IWriteBinding {
    public abstract virtual IChannelSourceHandle GetWriteChannelSource(CancellationToken cancellationToken);
    public abstract virtual IChannelSourceHandle GetWriteChannelSource(IReadOnlyCollection`1<ServerDescription> deprioritizedServers, CancellationToken cancellationToken);
    public abstract virtual IChannelSourceHandle GetWriteChannelSource(IMayUseSecondaryCriteria mayUseSecondary, CancellationToken cancellationToken);
    public abstract virtual IChannelSourceHandle GetWriteChannelSource(IReadOnlyCollection`1<ServerDescription> deprioritizedServers, IMayUseSecondaryCriteria mayUseSecondary, CancellationToken cancellationToken);
    public abstract virtual Task`1<IChannelSourceHandle> GetWriteChannelSourceAsync(CancellationToken cancellationToken);
    public abstract virtual Task`1<IChannelSourceHandle> GetWriteChannelSourceAsync(IReadOnlyCollection`1<ServerDescription> deprioritizedServers, CancellationToken cancellationToken);
    public abstract virtual Task`1<IChannelSourceHandle> GetWriteChannelSourceAsync(IMayUseSecondaryCriteria mayUseSecondary, CancellationToken cancellationToken);
    public abstract virtual Task`1<IChannelSourceHandle> GetWriteChannelSourceAsync(IReadOnlyCollection`1<ServerDescription> deprioritizedServers, IMayUseSecondaryCriteria mayUseSecondary, CancellationToken cancellationToken);
}
public interface MongoDB.Driver.Core.Bindings.IWriteBindingHandle {
    public abstract virtual IWriteBindingHandle Fork();
}
internal class MongoDB.Driver.Core.Bindings.NoCoreServerSession : object {
    private static ICoreServerSession __instance;
    public static ICoreServerSession Instance { get; }
    public BsonDocument Id { get; }
    public bool IsDirty { get; }
    public Nullable`1<DateTime> LastUsedAt { get; }
    private static NoCoreServerSession();
    public static ICoreServerSession get_Instance();
    public sealed virtual BsonDocument get_Id();
    public sealed virtual bool get_IsDirty();
    public sealed virtual Nullable`1<DateTime> get_LastUsedAt();
    public sealed virtual long AdvanceTransactionNumber();
    public sealed virtual void Dispose();
    public sealed virtual void MarkDirty();
    public sealed virtual void WasUsed();
}
public class MongoDB.Driver.Core.Bindings.NoCoreSession : object {
    private static ICoreSession __instance;
    public static ICoreSession Instance { get; }
    public BsonDocument ClusterTime { get; }
    public CoreTransaction CurrentTransaction { get; }
    public BsonDocument Id { get; }
    public bool IsCausallyConsistent { get; }
    public bool IsDirty { get; }
    public bool IsImplicit { get; }
    public bool IsInTransaction { get; }
    public bool IsSnapshot { get; }
    public BsonTimestamp OperationTime { get; }
    public CoreSessionOptions Options { get; }
    public ICoreServerSession ServerSession { get; }
    public BsonTimestamp SnapshotTime { get; }
    private static NoCoreSession();
    public static ICoreSession get_Instance();
    public static ICoreSessionHandle NewHandle();
    public sealed virtual BsonDocument get_ClusterTime();
    public sealed virtual CoreTransaction get_CurrentTransaction();
    public sealed virtual BsonDocument get_Id();
    public sealed virtual bool get_IsCausallyConsistent();
    public sealed virtual bool get_IsDirty();
    public sealed virtual bool get_IsImplicit();
    public sealed virtual bool get_IsInTransaction();
    public sealed virtual bool get_IsSnapshot();
    public sealed virtual BsonTimestamp get_OperationTime();
    public sealed virtual CoreSessionOptions get_Options();
    public sealed virtual ICoreServerSession get_ServerSession();
    public sealed virtual BsonTimestamp get_SnapshotTime();
    public sealed virtual void AbortTransaction(CancellationToken cancellationToken);
    public sealed virtual Task AbortTransactionAsync(CancellationToken cancellationToken);
    public sealed virtual void AboutToSendCommand();
    public sealed virtual void AdvanceClusterTime(BsonDocument newClusterTime);
    public sealed virtual void AdvanceOperationTime(BsonTimestamp newOperationTime);
    public sealed virtual long AdvanceTransactionNumber();
    public sealed virtual void CommitTransaction(CancellationToken cancellationToken);
    public sealed virtual Task CommitTransactionAsync(CancellationToken cancellationToken);
    public sealed virtual void Dispose();
    public sealed virtual void MarkDirty();
    public sealed virtual void StartTransaction(TransactionOptions transactionOptions);
    public sealed virtual void SetSnapshotTimeIfNeeded(BsonTimestamp snapshotTime);
    public sealed virtual void WasUsed();
}
internal class MongoDB.Driver.Core.Bindings.NonDisposingCoreSessionHandle : WrappingCoreSession {
    private ICoreSession _wrapped;
    public NonDisposingCoreSessionHandle(ICoreSession wrapped);
    public sealed virtual ICoreSessionHandle Fork();
    protected virtual void Dispose(bool disposing);
}
public class MongoDB.Driver.Core.Bindings.ReadBindingHandle : object {
    private bool _disposed;
    private ReferenceCounted`1<IReadBinding> _reference;
    public ReadPreference ReadPreference { get; }
    public ICoreSessionHandle Session { get; }
    public ReadBindingHandle(IReadBinding readBinding);
    private ReadBindingHandle(ReferenceCounted`1<IReadBinding> reference);
    public sealed virtual ReadPreference get_ReadPreference();
    public sealed virtual ICoreSessionHandle get_Session();
    public sealed virtual IChannelSourceHandle GetReadChannelSource(CancellationToken cancellationToken);
    public sealed virtual Task`1<IChannelSourceHandle> GetReadChannelSourceAsync(CancellationToken cancellationToken);
    public sealed virtual IChannelSourceHandle GetReadChannelSource(IReadOnlyCollection`1<ServerDescription> deprioritizedServers, CancellationToken cancellationToken);
    public sealed virtual Task`1<IChannelSourceHandle> GetReadChannelSourceAsync(IReadOnlyCollection`1<ServerDescription> deprioritizedServers, CancellationToken cancellationToken);
    public sealed virtual void Dispose();
    public sealed virtual IReadBindingHandle Fork();
    private void ThrowIfDisposed();
}
public class MongoDB.Driver.Core.Bindings.ReadPreferenceBinding : object {
    private ICluster _cluster;
    private bool _disposed;
    private ReadPreference _readPreference;
    private IServerSelector _serverSelector;
    private ICoreSessionHandle _session;
    public ReadPreference ReadPreference { get; }
    public ICoreSessionHandle Session { get; }
    public ReadPreferenceBinding(ICluster cluster, ReadPreference readPreference, ICoreSessionHandle session);
    public sealed virtual ReadPreference get_ReadPreference();
    public sealed virtual ICoreSessionHandle get_Session();
    public sealed virtual IChannelSourceHandle GetReadChannelSource(CancellationToken cancellationToken);
    public sealed virtual Task`1<IChannelSourceHandle> GetReadChannelSourceAsync(CancellationToken cancellationToken);
    public sealed virtual IChannelSourceHandle GetReadChannelSource(IReadOnlyCollection`1<ServerDescription> deprioritizedServers, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MongoDB.Driver.Core.Bindings.ReadPreferenceBinding/<GetReadChannelSourceAsync>d__13")]
public sealed virtual Task`1<IChannelSourceHandle> GetReadChannelSourceAsync(IReadOnlyCollection`1<ServerDescription> deprioritizedServers, CancellationToken cancellationToken);
    private IChannelSourceHandle GetChannelSourceHelper(IServer server);
    public sealed virtual void Dispose();
    private void ThrowIfDisposed();
}
public class MongoDB.Driver.Core.Bindings.ReadWriteBindingHandle : object {
    private bool _disposed;
    private ReferenceCounted`1<IReadWriteBinding> _reference;
    public ReadPreference ReadPreference { get; }
    public ICoreSessionHandle Session { get; }
    public ReadWriteBindingHandle(IReadWriteBinding writeBinding);
    private ReadWriteBindingHandle(ReferenceCounted`1<IReadWriteBinding> reference);
    public sealed virtual ReadPreference get_ReadPreference();
    public sealed virtual ICoreSessionHandle get_Session();
    public sealed virtual IChannelSourceHandle GetReadChannelSource(CancellationToken cancellationToken);
    public sealed virtual Task`1<IChannelSourceHandle> GetReadChannelSourceAsync(CancellationToken cancellationToken);
    public sealed virtual IChannelSourceHandle GetReadChannelSource(IReadOnlyCollection`1<ServerDescription> deprioritizedServers, CancellationToken cancellationToken);
    public sealed virtual Task`1<IChannelSourceHandle> GetReadChannelSourceAsync(IReadOnlyCollection`1<ServerDescription> deprioritizedServers, CancellationToken cancellationToken);
    public sealed virtual IChannelSourceHandle GetWriteChannelSource(CancellationToken cancellationToken);
    public sealed virtual IChannelSourceHandle GetWriteChannelSource(IReadOnlyCollection`1<ServerDescription> deprioritizedServers, CancellationToken cancellationToken);
    public sealed virtual IChannelSourceHandle GetWriteChannelSource(IMayUseSecondaryCriteria mayUseSecondary, CancellationToken cancellationToken);
    public sealed virtual IChannelSourceHandle GetWriteChannelSource(IReadOnlyCollection`1<ServerDescription> deprioritizedServers, IMayUseSecondaryCriteria mayUseSecondary, CancellationToken cancellationToken);
    public sealed virtual Task`1<IChannelSourceHandle> GetWriteChannelSourceAsync(CancellationToken cancellationToken);
    public sealed virtual Task`1<IChannelSourceHandle> GetWriteChannelSourceAsync(IReadOnlyCollection`1<ServerDescription> deprioritizedServers, CancellationToken cancellationToken);
    public sealed virtual Task`1<IChannelSourceHandle> GetWriteChannelSourceAsync(IMayUseSecondaryCriteria mayUseSecondary, CancellationToken cancellationToken);
    public sealed virtual Task`1<IChannelSourceHandle> GetWriteChannelSourceAsync(IReadOnlyCollection`1<ServerDescription> deprioritizedServers, IMayUseSecondaryCriteria mayUseSecondary, CancellationToken cancellationToken);
    public sealed virtual void Dispose();
    public sealed virtual IReadWriteBindingHandle Fork();
    private sealed virtual override IReadBindingHandle MongoDB.Driver.Core.Bindings.IReadBindingHandle.Fork();
    private sealed virtual override IWriteBindingHandle MongoDB.Driver.Core.Bindings.IWriteBindingHandle.Fork();
    private void ThrowIfDisposed();
}
internal class MongoDB.Driver.Core.Bindings.ReferenceCountedCoreSession : WrappingCoreSession {
    private object _lock;
    private int _referenceCount;
    public ReferenceCountedCoreSession(ICoreSession wrapped);
    public void DecrementReferenceCount();
    public void IncrementReferenceCount();
}
public class MongoDB.Driver.Core.Bindings.ServerChannelSource : object {
    private bool _disposed;
    private IServer _server;
    private ICoreSessionHandle _session;
    public IServer Server { get; }
    public ServerDescription ServerDescription { get; }
    public ICoreSessionHandle Session { get; }
    public ServerChannelSource(IServer server, ICoreSessionHandle session);
    public sealed virtual IServer get_Server();
    public sealed virtual ServerDescription get_ServerDescription();
    public sealed virtual ICoreSessionHandle get_Session();
    public sealed virtual void Dispose();
    public sealed virtual IChannelHandle GetChannel(CancellationToken cancellationToken);
    public sealed virtual Task`1<IChannelHandle> GetChannelAsync(CancellationToken cancellationToken);
    private void ThrowIfDisposed();
}
public class MongoDB.Driver.Core.Bindings.SingleServerReadBinding : object {
    private static int SingleServerSelectionTimeoutMS;
    private bool _disposed;
    private ReadPreference _readPreference;
    private IServer _server;
    private ICoreSessionHandle _session;
    public ReadPreference ReadPreference { get; }
    public ICoreSessionHandle Session { get; }
    public SingleServerReadBinding(IServer server, ReadPreference readPreference, ICoreSessionHandle session);
    public sealed virtual ReadPreference get_ReadPreference();
    public sealed virtual ICoreSessionHandle get_Session();
    public sealed virtual IChannelSourceHandle GetReadChannelSource(CancellationToken cancellationToken);
    public sealed virtual Task`1<IChannelSourceHandle> GetReadChannelSourceAsync(CancellationToken cancellationToken);
    public sealed virtual IChannelSourceHandle GetReadChannelSource(IReadOnlyCollection`1<ServerDescription> deprioritizedServers, CancellationToken cancellationToken);
    public sealed virtual Task`1<IChannelSourceHandle> GetReadChannelSourceAsync(IReadOnlyCollection`1<ServerDescription> deprioritizedServers, CancellationToken cancellationToken);
    public sealed virtual void Dispose();
    private IChannelSourceHandle GetChannelSourceHelper();
    private void ThrowIfDisposed();
    [CompilerGeneratedAttribute]
private bool <GetChannelSourceHelper>b__15_0();
}
public class MongoDB.Driver.Core.Bindings.SingleServerReadWriteBinding : object {
    private bool _disposed;
    private IServer _server;
    private ICoreSessionHandle _session;
    public ReadPreference ReadPreference { get; }
    public ICoreSessionHandle Session { get; }
    public SingleServerReadWriteBinding(IServer server, ICoreSessionHandle session);
    public sealed virtual ReadPreference get_ReadPreference();
    public sealed virtual ICoreSessionHandle get_Session();
    public sealed virtual void Dispose();
    public sealed virtual IChannelSourceHandle GetReadChannelSource(CancellationToken cancellationToken);
    public sealed virtual Task`1<IChannelSourceHandle> GetReadChannelSourceAsync(CancellationToken cancellationToken);
    public sealed virtual IChannelSourceHandle GetReadChannelSource(IReadOnlyCollection`1<ServerDescription> deprioritizedServers, CancellationToken cancellationToken);
    public sealed virtual Task`1<IChannelSourceHandle> GetReadChannelSourceAsync(IReadOnlyCollection`1<ServerDescription> deprioritizedServers, CancellationToken cancellationToken);
    public sealed virtual IChannelSourceHandle GetWriteChannelSource(CancellationToken cancellationToken);
    public sealed virtual IChannelSourceHandle GetWriteChannelSource(IReadOnlyCollection`1<ServerDescription> deprioritizedServers, CancellationToken cancellationToken);
    public sealed virtual IChannelSourceHandle GetWriteChannelSource(IMayUseSecondaryCriteria mayUseSecondary, CancellationToken cancellationToken);
    public sealed virtual IChannelSourceHandle GetWriteChannelSource(IReadOnlyCollection`1<ServerDescription> deprioritizedServers, IMayUseSecondaryCriteria mayUseSecondary, CancellationToken cancellationToken);
    public sealed virtual Task`1<IChannelSourceHandle> GetWriteChannelSourceAsync(CancellationToken cancellationToken);
    public sealed virtual Task`1<IChannelSourceHandle> GetWriteChannelSourceAsync(IReadOnlyCollection`1<ServerDescription> deprioritizedServers, CancellationToken cancellationToken);
    public sealed virtual Task`1<IChannelSourceHandle> GetWriteChannelSourceAsync(IMayUseSecondaryCriteria mayUseSecondary, CancellationToken cancellationToken);
    public sealed virtual Task`1<IChannelSourceHandle> GetWriteChannelSourceAsync(IReadOnlyCollection`1<ServerDescription> deprioritizedServers, IMayUseSecondaryCriteria mayUseSecondary, CancellationToken cancellationToken);
    private IChannelSourceHandle GetChannelSourceHelper();
    private void ThrowIfDisposed();
}
public abstract class MongoDB.Driver.Core.Bindings.WrappingCoreSession : object {
    private bool _disposed;
    private bool _ownsWrapped;
    private ICoreSession _wrapped;
    public BsonDocument ClusterTime { get; }
    public CoreTransaction CurrentTransaction { get; }
    public BsonDocument Id { get; }
    public bool IsDirty { get; }
    public bool IsCausallyConsistent { get; }
    public bool IsImplicit { get; }
    public bool IsInTransaction { get; }
    public bool IsSnapshot { get; }
    public BsonTimestamp OperationTime { get; }
    public CoreSessionOptions Options { get; }
    public ICoreServerSession ServerSession { get; }
    public BsonTimestamp SnapshotTime { get; }
    public ICoreSession Wrapped { get; }
    public WrappingCoreSession(ICoreSession wrapped, bool ownsWrapped);
    public virtual BsonDocument get_ClusterTime();
    public virtual CoreTransaction get_CurrentTransaction();
    public virtual BsonDocument get_Id();
    public virtual bool get_IsDirty();
    public virtual bool get_IsCausallyConsistent();
    public virtual bool get_IsImplicit();
    public virtual bool get_IsInTransaction();
    public sealed virtual bool get_IsSnapshot();
    public virtual BsonTimestamp get_OperationTime();
    public virtual CoreSessionOptions get_Options();
    public virtual ICoreServerSession get_ServerSession();
    public sealed virtual BsonTimestamp get_SnapshotTime();
    public ICoreSession get_Wrapped();
    public virtual void AbortTransaction(CancellationToken cancellationToken);
    public virtual Task AbortTransactionAsync(CancellationToken cancellationToken);
    public virtual void AboutToSendCommand();
    public virtual void AdvanceClusterTime(BsonDocument newClusterTime);
    public virtual void AdvanceOperationTime(BsonTimestamp newOperationTime);
    public sealed virtual long AdvanceTransactionNumber();
    public virtual void CommitTransaction(CancellationToken cancellationToken);
    public virtual Task CommitTransactionAsync(CancellationToken cancellationToken);
    public sealed virtual void Dispose();
    public virtual void MarkDirty();
    public virtual void StartTransaction(TransactionOptions transactionOptions);
    public sealed virtual void SetSnapshotTimeIfNeeded(BsonTimestamp snapshotTime);
    public virtual void WasUsed();
    protected virtual void Dispose(bool disposing);
    protected bool IsDisposed();
    protected void ThrowIfDisposed();
}
public class MongoDB.Driver.Core.Bindings.WritableServerBinding : object {
    private ICluster _cluster;
    private bool _disposed;
    private ICoreSessionHandle _session;
    public ReadPreference ReadPreference { get; }
    public ICoreSessionHandle Session { get; }
    public WritableServerBinding(ICluster cluster, ICoreSessionHandle session);
    public sealed virtual ReadPreference get_ReadPreference();
    public sealed virtual ICoreSessionHandle get_Session();
    public sealed virtual IChannelSourceHandle GetReadChannelSource(CancellationToken cancellationToken);
    public sealed virtual Task`1<IChannelSourceHandle> GetReadChannelSourceAsync(CancellationToken cancellationToken);
    public sealed virtual IChannelSourceHandle GetReadChannelSource(IReadOnlyCollection`1<ServerDescription> deprioritizedServers, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MongoDB.Driver.Core.Bindings.WritableServerBinding/<GetReadChannelSourceAsync>d__11")]
public sealed virtual Task`1<IChannelSourceHandle> GetReadChannelSourceAsync(IReadOnlyCollection`1<ServerDescription> deprioritizedServers, CancellationToken cancellationToken);
    public sealed virtual IChannelSourceHandle GetWriteChannelSource(CancellationToken cancellationToken);
    public sealed virtual IChannelSourceHandle GetWriteChannelSource(IReadOnlyCollection`1<ServerDescription> deprioritizedServers, CancellationToken cancellationToken);
    public sealed virtual IChannelSourceHandle GetWriteChannelSource(IMayUseSecondaryCriteria mayUseSecondary, CancellationToken cancellationToken);
    public sealed virtual IChannelSourceHandle GetWriteChannelSource(IReadOnlyCollection`1<ServerDescription> deprioritizedServers, IMayUseSecondaryCriteria mayUseSecondary, CancellationToken cancellationToken);
    public sealed virtual Task`1<IChannelSourceHandle> GetWriteChannelSourceAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MongoDB.Driver.Core.Bindings.WritableServerBinding/<GetWriteChannelSourceAsync>d__17")]
public sealed virtual Task`1<IChannelSourceHandle> GetWriteChannelSourceAsync(IReadOnlyCollection`1<ServerDescription> deprioritizedServers, CancellationToken cancellationToken);
    public sealed virtual Task`1<IChannelSourceHandle> GetWriteChannelSourceAsync(IMayUseSecondaryCriteria mayUseSecondary, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MongoDB.Driver.Core.Bindings.WritableServerBinding/<GetWriteChannelSourceAsync>d__19")]
public sealed virtual Task`1<IChannelSourceHandle> GetWriteChannelSourceAsync(IReadOnlyCollection`1<ServerDescription> deprioritizedServers, IMayUseSecondaryCriteria mayUseSecondary, CancellationToken cancellationToken);
    private IChannelSourceHandle CreateServerChannelSource(IServer server);
    public sealed virtual void Dispose();
    private bool IsSessionPinnedToServer();
    private void ThrowIfDisposed();
}
public static class MongoDB.Driver.Core.ChannelPinningHelper : object {
    public static IReadBindingHandle CreateReadBinding(ICluster cluster, ICoreSessionHandle session, ReadPreference readPreference);
    public static IReadWriteBindingHandle CreateReadWriteBinding(ICluster cluster, ICoreSessionHandle session);
    internal static IChannelSourceHandle CreateGetMoreChannelSource(IChannelSourceHandle channelSource, IChannelHandle channel, long cursorId);
    internal static void PinChannellIfRequired(IChannelSourceHandle channelSource, IChannelHandle channel, ICoreSessionHandle session);
    private static bool IsInLoadBalancedMode(ConnectionDescription connectionDescription);
    private static bool IsInLoadBalancedMode(ServerDescription serverDescription);
    private static bool IsInLoadBalancedMode(ClusterDescription clusterDescription);
    private static bool IsChannelPinned(CoreTransaction coreTransaction);
}
internal abstract class MongoDB.Driver.Core.Clusters.Cluster : object {
    private static TimeSpan __minHeartbeatIntervalDefault;
    private static SemanticVersion __minSupportedServerVersion;
    private static IServerSelector __randomServerSelector;
    private static Range`1<int> __supportedWireVersionRange;
    private TimeSpan _minHeartbeatInterval;
    private IClusterClock _clusterClock;
    private ClusterId _clusterId;
    private CryptClient _cryptClient;
    private ClusterDescription _description;
    private TaskCompletionSource`1<bool> _descriptionChangedTaskCompletionSource;
    private object _descriptionLock;
    private LatencyLimitingServerSelector _latencyLimitingServerSelector;
    protected EventLogger`1<SDAM> _clusterEventLogger;
    protected EventLogger`1<ServerSelection> _serverSelectionEventLogger;
    private Timer _rapidHeartbeatTimer;
    private object _serverSelectionWaitQueueLock;
    private int _serverSelectionWaitQueueSize;
    private IClusterableServerFactory _serverFactory;
    private ICoreServerSessionPool _serverSessionPool;
    private ClusterSettings _settings;
    private InterlockedInt32 _state;
    private InterlockedInt32 _rapidHeartbeatTimerCallbackState;
    [CompilerGeneratedAttribute]
private EventHandler`1<ClusterDescriptionChangedEventArgs> DescriptionChanged;
    public static SemanticVersion MinSupportedServerVersion { get; }
    public static Range`1<int> SupportedWireVersionRange { get; }
    public ClusterId ClusterId { get; }
    public CryptClient CryptClient { get; }
    public ClusterDescription Description { get; }
    public ClusterSettings Settings { get; }
    protected Cluster(ClusterSettings settings, IClusterableServerFactory serverFactory, IEventSubscriber eventSubscriber, ILoggerFactory loggerFactory);
    private static Cluster();
    public static SemanticVersion get_MinSupportedServerVersion();
    public static Range`1<int> get_SupportedWireVersionRange();
    [CompilerGeneratedAttribute]
public sealed virtual void add_DescriptionChanged(EventHandler`1<ClusterDescriptionChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_DescriptionChanged(EventHandler`1<ClusterDescriptionChangedEventArgs> value);
    public sealed virtual ClusterId get_ClusterId();
    public sealed virtual CryptClient get_CryptClient();
    public sealed virtual ClusterDescription get_Description();
    public sealed virtual ClusterSettings get_Settings();
    public sealed virtual ICoreServerSession AcquireServerSession();
    protected IClusterableServer CreateServer(EndPoint endPoint);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    private void EnterServerSelectionWaitQueue(IServerSelector selector, ClusterDescription clusterDescription, Nullable`1<long> operationId, TimeSpan remainingTime);
    private void ExitServerSelectionWaitQueue();
    public virtual void Initialize();
    private void RapidHeartbeatTimerCallback(object args);
    protected abstract virtual void RequestHeartbeat();
    protected void OnDescriptionChanged(ClusterDescription oldDescription, ClusterDescription newDescription, bool shouldClusterDescriptionChangedEventBePublished);
    public sealed virtual IServer SelectServer(IServerSelector selector, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MongoDB.Driver.Core.Clusters.Cluster/<SelectServerAsync>d__49")]
public sealed virtual Task`1<IServer> SelectServerAsync(IServerSelector selector, CancellationToken cancellationToken);
    public sealed virtual ICoreSessionHandle StartSession(CoreSessionOptions options);
    protected abstract virtual bool TryGetServer(EndPoint endPoint, IClusterableServer& server);
    protected void UpdateClusterDescription(ClusterDescription newClusterDescription, bool shouldClusterDescriptionChangedEventBePublished);
    private string BuildTimeoutExceptionMessage(TimeSpan timeout, IServerSelector selector, ClusterDescription clusterDescription);
    private void ThrowIfDisposed();
    private void ThrowIfDisposedOrNotOpen();
    private void WaitForDescriptionChanged(IServerSelector selector, ClusterDescription description, Task descriptionChangedTask, TimeSpan timeout, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MongoDB.Driver.Core.Clusters.Cluster/<WaitForDescriptionChangedAsync>d__57")]
private Task WaitForDescriptionChangedAsync(IServerSelector selector, ClusterDescription description, Task descriptionChangedTask, TimeSpan timeout, CancellationToken cancellationToken);
    private void ThrowTimeoutException(IServerSelector selector, ClusterDescription description);
    [CompilerGeneratedAttribute]
private ClusterDescription <.ctor>g__CreateInitialDescription|26_0();
}
internal class MongoDB.Driver.Core.Clusters.ClusterClock : object {
    private BsonDocument _clusterTime;
    public BsonDocument ClusterTime { get; }
    public static BsonDocument GreaterClusterTime(BsonDocument x, BsonDocument y);
    public sealed virtual BsonDocument get_ClusterTime();
    public sealed virtual void AdvanceClusterTime(BsonDocument newClusterTime);
}
[ObsoleteAttribute("Use DirectConnection instead.")]
public enum MongoDB.Driver.Core.Clusters.ClusterConnectionMode : Enum {
    public int value__;
    public static ClusterConnectionMode Automatic;
    public static ClusterConnectionMode Direct;
    public static ClusterConnectionMode Standalone;
    public static ClusterConnectionMode ReplicaSet;
    public static ClusterConnectionMode Sharded;
}
internal static class MongoDB.Driver.Core.Clusters.ClusterConnectionModeHelper : object {
    public static void EnsureConnectionModeValuesAreValid(ClusterConnectionMode connectionMode, ConnectionModeSwitch connectionModeSwitch, Nullable`1<bool> directConnection);
}
public class MongoDB.Driver.Core.Clusters.ClusterDescription : object {
    private ClusterId _clusterId;
    private ClusterConnectionMode _connectionMode;
    private ConnectionModeSwitch _connectionModeSwitch;
    private Nullable`1<bool> _directConnection;
    private Exception _dnsMonitorException;
    private Nullable`1<TimeSpan> _logicalSessionTimeout;
    private IReadOnlyList`1<ServerDescription> _servers;
    private ClusterType _type;
    public ClusterId ClusterId { get; }
    [ObsoleteAttribute("Use DirectConnection instead.")]
public ClusterConnectionMode ConnectionMode { get; }
    [ObsoleteAttribute("This property will be removed in a later release.")]
public ConnectionModeSwitch ConnectionModeSwitch { get; }
    public Nullable`1<bool> DirectConnection { get; }
    public Exception DnsMonitorException { get; }
    public bool IsCompatibleWithDriver { get; }
    public bool IsDirectConnection { get; }
    public Nullable`1<TimeSpan> LogicalSessionTimeout { get; }
    public IReadOnlyList`1<ServerDescription> Servers { get; }
    public ClusterState State { get; }
    public ClusterType Type { get; }
    [ObsoleteAttribute("Use the constructor that has a directConnection parameter.")]
public ClusterDescription(ClusterId clusterId, ClusterConnectionMode connectionMode, ClusterType type, IEnumerable`1<ServerDescription> servers);
    [ObsoleteAttribute("Use the constructor that has a directConnection parameter.")]
public ClusterDescription(ClusterId clusterId, ClusterConnectionMode connectionMode, Exception dnsMonitorException, ClusterType type, IEnumerable`1<ServerDescription> servers);
    public ClusterDescription(ClusterId clusterId, Nullable`1<bool> directConnection, Exception dnsMonitorException, ClusterType type, IEnumerable`1<ServerDescription> servers);
    internal ClusterDescription(ClusterId clusterId, ClusterConnectionMode connectionMode, ConnectionModeSwitch connectionModeSwitch, Nullable`1<bool> directConnection, Exception dnsMonitorException, ClusterType type, IEnumerable`1<ServerDescription> servers);
    internal static ClusterDescription CreateInitial(ClusterId clusterId, ClusterConnectionMode connectionMode, ConnectionModeSwitch connectionModeSwitch, Nullable`1<bool> directConnection);
    private static Nullable`1<TimeSpan> CalculateLogicalSessionTimeout(ClusterDescription cluster, IEnumerable`1<ServerDescription> servers);
    private static IEnumerable`1<ServerDescription> SelectServersThatDetermineWhetherSessionsAreSupported(ClusterDescription cluster, IEnumerable`1<ServerDescription> servers);
    public ClusterId get_ClusterId();
    public ClusterConnectionMode get_ConnectionMode();
    public ConnectionModeSwitch get_ConnectionModeSwitch();
    public Nullable`1<bool> get_DirectConnection();
    public Exception get_DnsMonitorException();
    public bool get_IsCompatibleWithDriver();
    public bool get_IsDirectConnection();
    public Nullable`1<TimeSpan> get_LogicalSessionTimeout();
    public IReadOnlyList`1<ServerDescription> get_Servers();
    public ClusterState get_State();
    public ClusterType get_Type();
    public sealed virtual bool Equals(ClusterDescription other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public ClusterDescription WithDnsMonitorException(Exception value);
    public ClusterDescription WithServerDescription(ServerDescription value);
    public ClusterDescription WithoutServerDescription(EndPoint endPoint);
    public ClusterDescription WithType(ClusterType value);
    [CompilerGeneratedAttribute]
private string <ToString>g__FormatConnectionMode|40_1();
}
public class MongoDB.Driver.Core.Clusters.ClusterDescriptionChangedEventArgs : EventArgs {
    private ClusterDescription _oldClusterDescription;
    private ClusterDescription _newClusterDescription;
    public ClusterDescription OldClusterDescription { get; }
    public ClusterDescription NewClusterDescription { get; }
    public ClusterDescriptionChangedEventArgs(ClusterDescription oldClusterDescription, ClusterDescription newClusterDescription);
    public ClusterDescription get_OldClusterDescription();
    public ClusterDescription get_NewClusterDescription();
}
internal class MongoDB.Driver.Core.Clusters.ClusterFactory : object {
    private IEventSubscriber _eventSubscriber;
    private ILoggerFactory _loggerFactory;
    private IClusterableServerFactory _serverFactory;
    private ClusterSettings _settings;
    public ClusterFactory(ClusterSettings settings, IClusterableServerFactory serverFactory, IEventSubscriber eventSubscriber, ILoggerFactory loggerFactory);
    public sealed virtual ICluster CreateCluster();
    private MultiServerCluster CreateMultiServerCluster(ClusterSettings settings);
    private SingleServerCluster CreateSingleServerCluster(ClusterSettings settings);
    private LoadBalancedCluster CreateLoadBalancedCluster(ClusterSettings setting);
    private void ProcessClusterEnvironment(ClusterSettings settings);
    [CompilerGeneratedAttribute]
private bool <ProcessClusterEnvironment>g__LogIfCosmosDB|9_0(string host);
    [CompilerGeneratedAttribute]
private bool <ProcessClusterEnvironment>g__LogIfDocumentDB|9_1(string host);
    [CompilerGeneratedAttribute]
private bool <ProcessClusterEnvironment>g__LogIfExternalEnvironment|9_2(string host, string environment, string documentationUrl, String[] suffixes);
}
public class MongoDB.Driver.Core.Clusters.ClusterId : object {
    private int _value;
    public int Value { get; }
    public ClusterId(int value);
    public int get_Value();
    public sealed virtual bool Equals(ClusterId other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public enum MongoDB.Driver.Core.Clusters.ClusterState : Enum {
    public int value__;
    public static ClusterState Disconnected;
    public static ClusterState Connected;
}
public enum MongoDB.Driver.Core.Clusters.ClusterType : Enum {
    public int value__;
    public static ClusterType Unknown;
    public static ClusterType Standalone;
    public static ClusterType ReplicaSet;
    public static ClusterType Sharded;
    public static ClusterType LoadBalanced;
}
[ObsoleteAttribute("This enum will be removed in a later release.")]
public enum MongoDB.Driver.Core.Clusters.ConnectionModeSwitch : Enum {
    public int value__;
    public static ConnectionModeSwitch NotSet;
    public static ConnectionModeSwitch UseConnectionMode;
    public static ConnectionModeSwitch UseDirectConnection;
}
public class MongoDB.Driver.Core.Clusters.CryptClientCreator : object {
    private CryptClientSettings _cryptClientSettings;
    private CryptClientCreator(CryptClientSettings cryptClientSettings);
    public static CryptClient CreateCryptClient(CryptClientSettings cryptClientSettings);
    private CryptClient CreateCryptClient(CryptOptions options);
    private CryptOptions CreateCryptOptions();
    private BsonDocument CreateProviderDocument(string kmsType, IReadOnlyDictionary`2<string, object> data);
    private Byte[] GetBytesFromMap(IReadOnlyDictionary`2<string, BsonDocument> map);
}
internal class MongoDB.Driver.Core.Clusters.DnsMonitor : object {
    private CancellationToken _cancellationToken;
    private IDnsMonitoringCluster _cluster;
    private IDnsResolver _dnsResolver;
    private string _lookupDomainName;
    private bool _processDnsResultHasEverBeenCalled;
    private string _service;
    private DnsMonitorState _state;
    private Exception _unhandledException;
    private EventLogger`1<SDAM> _eventLogger;
    public DnsMonitorState State { get; }
    public Exception UnhandledException { get; }
    public DnsMonitor(IDnsMonitoringCluster cluster, IDnsResolver dnsResolver, string srvServiceName, string lookupDomainName, IEventSubscriber eventSubscriber, ILogger`1<SDAM> logger, CancellationToken cancellationToken);
    private static string EnsureLookupDomainNameIsValid(string lookupDomainName);
    public sealed virtual DnsMonitorState get_State();
    public sealed virtual Exception get_UnhandledException();
    public sealed virtual Thread Start();
    private void ThreadStart();
    private TimeSpan ComputeRescanDelay(List`1<SrvRecord> srvRecords);
    private List`1<DnsEndPoint> GetValidEndPoints(List`1<SrvRecord> srvRecords);
    private bool IsValidHost(DnsEndPoint endPoint);
    private void Monitor();
}
internal class MongoDB.Driver.Core.Clusters.DnsMonitorFactory : object {
    private IEventSubscriber _eventSubscriber;
    private ILoggerFactory _loggerFactory;
    public DnsMonitorFactory(IEventSubscriber eventSubscriber, ILoggerFactory loggerFactory);
    public sealed virtual IDnsMonitor CreateDnsMonitor(IDnsMonitoringCluster cluster, string srvServiceName, string lookupDomainName, CancellationToken cancellationToken);
}
internal enum MongoDB.Driver.Core.Clusters.DnsMonitorState : Enum {
    public int value__;
    public static DnsMonitorState Created;
    public static DnsMonitorState Running;
    public static DnsMonitorState Failed;
    public static DnsMonitorState Stopped;
}
public class MongoDB.Driver.Core.Clusters.ElectionId : object {
    private ObjectId _id;
    public ElectionId(ObjectId id);
    public sealed virtual int CompareTo(ElectionId other);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ElectionId other);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public interface MongoDB.Driver.Core.Clusters.ICluster {
    public ClusterId ClusterId { get; }
    public ClusterDescription Description { get; }
    public ClusterSettings Settings { get; }
    public CryptClient CryptClient { get; }
    [CompilerGeneratedAttribute]
public abstract virtual void add_DescriptionChanged(EventHandler`1<ClusterDescriptionChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_DescriptionChanged(EventHandler`1<ClusterDescriptionChangedEventArgs> value);
    public abstract virtual ClusterId get_ClusterId();
    public abstract virtual ClusterDescription get_Description();
    public abstract virtual ClusterSettings get_Settings();
    public abstract virtual ICoreServerSession AcquireServerSession();
    public abstract virtual CryptClient get_CryptClient();
    public abstract virtual void Initialize();
    public abstract virtual IServer SelectServer(IServerSelector selector, CancellationToken cancellationToken);
    public abstract virtual Task`1<IServer> SelectServerAsync(IServerSelector selector, CancellationToken cancellationToken);
    public abstract virtual ICoreSessionHandle StartSession(CoreSessionOptions options);
}
public interface MongoDB.Driver.Core.Clusters.IClusterClock {
    public BsonDocument ClusterTime { get; }
    public abstract virtual BsonDocument get_ClusterTime();
    public abstract virtual void AdvanceClusterTime(BsonDocument newClusterTime);
}
[ExtensionAttribute]
internal static class MongoDB.Driver.Core.Clusters.IClusterExtensions : object {
    [ExtensionAttribute]
public static IServer SelectServerAndPinIfNeeded(ICluster cluster, ICoreSessionHandle session, IServerSelector selector, IReadOnlyCollection`1<ServerDescription> deprioritizedServers, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MongoDB.Driver.Core.Clusters.IClusterExtensions/<SelectServerAndPinIfNeededAsync>d__1")]
[ExtensionAttribute]
public static Task`1<IServer> SelectServerAndPinIfNeededAsync(ICluster cluster, ICoreSessionHandle session, IServerSelector selector, IReadOnlyCollection`1<ServerDescription> deprioritizedServers, CancellationToken cancellationToken);
    private static void PinServerIfNeeded(ICluster cluster, ICoreSessionHandle session, IServer server);
    private static IServer GetPinnedServerIfValid(ICluster cluster, ICoreSessionHandle session);
}
public interface MongoDB.Driver.Core.Clusters.IClusterFactory {
    public abstract virtual ICluster CreateCluster();
}
internal interface MongoDB.Driver.Core.Clusters.IDnsMonitor {
    public DnsMonitorState State { get; }
    public Exception UnhandledException { get; }
    public abstract virtual DnsMonitorState get_State();
    public abstract virtual Exception get_UnhandledException();
    public abstract virtual Thread Start();
}
internal interface MongoDB.Driver.Core.Clusters.IDnsMonitorFactory {
    public abstract virtual IDnsMonitor CreateDnsMonitor(IDnsMonitoringCluster cluster, string srvServiceName, string lookupDomainName, CancellationToken cancellationToken);
}
internal interface MongoDB.Driver.Core.Clusters.IDnsMonitoringCluster {
    public abstract virtual void ProcessDnsException(Exception exception);
    public abstract virtual void ProcessDnsResults(List`1<DnsEndPoint> endPoints);
    public abstract virtual bool ShouldDnsMonitorStop();
}
internal class MongoDB.Driver.Core.Clusters.LoadBalancedCluster : object {
    private IClusterClock _clusterClock;
    private ClusterId _clusterId;
    private ClusterType _clusterType;
    private CryptClient _cryptClient;
    private ClusterDescription _description;
    private IDnsMonitorFactory _dnsMonitorFactory;
    private Thread _dnsMonitorThread;
    private CancellationTokenSource _dnsMonitorCancellationTokenSource;
    private IClusterableServer _server;
    private IClusterableServerFactory _serverFactory;
    private TaskCompletionSource`1<bool> _serverReadyTaskCompletionSource;
    private ICoreServerSessionPool _serverSessionPool;
    private ClusterSettings _settings;
    private InterlockedInt32 _state;
    private EventLogger`1<SDAM> _eventLogger;
    private EventLogger`1<ServerSelection> _serverSelectionEventLogger;
    [CompilerGeneratedAttribute]
private EventHandler`1<ClusterDescriptionChangedEventArgs> DescriptionChanged;
    public ClusterId ClusterId { get; }
    public CryptClient CryptClient { get; }
    public ClusterDescription Description { get; }
    public ClusterSettings Settings { get; }
    public LoadBalancedCluster(ClusterSettings settings, IClusterableServerFactory serverFactory, IEventSubscriber eventSubscriber, ILoggerFactory loggerFactory);
    public LoadBalancedCluster(ClusterSettings settings, IClusterableServerFactory serverFactory, IEventSubscriber eventSubscriber, ILoggerFactory loggerFactory, IDnsMonitorFactory dnsMonitorFactory);
    public sealed virtual ClusterId get_ClusterId();
    public sealed virtual CryptClient get_CryptClient();
    public sealed virtual ClusterDescription get_Description();
    public sealed virtual ClusterSettings get_Settings();
    [CompilerGeneratedAttribute]
public sealed virtual void add_DescriptionChanged(EventHandler`1<ClusterDescriptionChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_DescriptionChanged(EventHandler`1<ClusterDescriptionChangedEventArgs> value);
    public sealed virtual ICoreServerSession AcquireServerSession();
    public sealed virtual void Dispose();
    private void Dispose(bool disposing);
    public sealed virtual void Initialize();
    public sealed virtual IServer SelectServer(IServerSelector selector, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MongoDB.Driver.Core.Clusters.LoadBalancedCluster/<SelectServerAsync>d__34")]
public sealed virtual Task`1<IServer> SelectServerAsync(IServerSelector selector, CancellationToken cancellationToken);
    public sealed virtual ICoreSessionHandle StartSession(CoreSessionOptions options);
    private void InitializeServer(IClusterableServer server);
    private Exception CreateTimeoutException(ClusterDescription description);
    private void UpdateClusterDescription(ClusterDescription newClusterDescription);
    private void ServerDescriptionChangedHandler(object sender, ServerDescriptionChangedEventArgs e);
    private void ThrowIfDisposed();
    private sealed virtual override void MongoDB.Driver.Core.Clusters.IDnsMonitoringCluster.ProcessDnsException(Exception exception);
    private sealed virtual override void MongoDB.Driver.Core.Clusters.IDnsMonitoringCluster.ProcessDnsResults(List`1<DnsEndPoint> endPoints);
    private sealed virtual override bool MongoDB.Driver.Core.Clusters.IDnsMonitoringCluster.ShouldDnsMonitorStop();
    [CompilerGeneratedAttribute]
private void <UpdateClusterDescription>g__OnClusterDescriptionChanged|38_0(ClusterDescription oldDescription, ClusterDescription newDescription);
}
internal class MongoDB.Driver.Core.Clusters.MultiServerCluster : Cluster {
    private IDnsMonitorFactory _dnsMonitorFactory;
    private Thread _dnsMonitorThread;
    private CancellationTokenSource _monitorServersCancellationTokenSource;
    private ElectionInfo modreq(System.Runtime.CompilerServices.IsVolatile) _maxElectionInfo;
    private String modreq(System.Runtime.CompilerServices.IsVolatile) _replicaSetName;
    private List`1<IClusterableServer> _servers;
    private object _serversLock;
    private InterlockedInt32 _state;
    private object _updateClusterDescriptionLock;
    public MultiServerCluster(ClusterSettings settings, IClusterableServerFactory serverFactory, IEventSubscriber eventSubscriber, ILoggerFactory loggerFactory, IDnsMonitorFactory dnsMonitorFactory);
    protected virtual void Dispose(bool disposing);
    public virtual void Initialize();
    private bool IsServerValidForCluster(ClusterType clusterType, ClusterSettings clusterSettings, ServerType serverType);
    protected virtual void RequestHeartbeat();
    private void ServerDescriptionChangedHandler(object sender, ServerDescriptionChangedEventArgs args);
    private void ProcessServerDescriptionChanged(ServerDescriptionChangedEventArgs args);
    private ClusterDescription ProcessReplicaSetChange(ClusterDescription clusterDescription, ServerDescriptionChangedEventArgs args, List`1<IClusterableServer> newServers);
    private ClusterDescription ProcessShardedChange(ClusterDescription clusterDescription, ServerDescriptionChangedEventArgs args);
    private ClusterDescription ProcessStandaloneChange(ClusterDescription clusterDescription, ServerDescriptionChangedEventArgs args);
    private sealed virtual override void MongoDB.Driver.Core.Clusters.IDnsMonitoringCluster.ProcessDnsException(Exception exception);
    private sealed virtual override void MongoDB.Driver.Core.Clusters.IDnsMonitoringCluster.ProcessDnsResults(List`1<DnsEndPoint> dnsEndPoints);
    private sealed virtual override bool MongoDB.Driver.Core.Clusters.IDnsMonitoringCluster.ShouldDnsMonitorStop();
    private ClusterDescription EnsureServer(ClusterDescription clusterDescription, EndPoint endPoint, List`1<IClusterableServer> newServers);
    private ClusterDescription EnsureServers(ClusterDescription clusterDescription, ServerDescription serverDescription, List`1<IClusterableServer> newServers);
    private ClusterDescription RemoveServer(ClusterDescription clusterDescription, EndPoint endPoint, string reason);
    protected virtual bool TryGetServer(EndPoint endPoint, IClusterableServer& server);
    private void ThrowIfDisposed();
}
internal class MongoDB.Driver.Core.Clusters.NoClusterClock : object {
    public BsonDocument ClusterTime { get; }
    public sealed virtual BsonDocument get_ClusterTime();
    public sealed virtual void AdvanceClusterTime(BsonDocument newClusterTime);
}
public class MongoDB.Driver.Core.Clusters.ReplicaSetConfig : object {
    private List`1<EndPoint> _members;
    private string _name;
    private EndPoint _primary;
    private Nullable`1<int> _version;
    public static ReplicaSetConfig Empty { get; }
    public IReadOnlyList`1<EndPoint> Members { get; }
    public string Name { get; }
    public EndPoint Primary { get; }
    public Nullable`1<int> Version { get; }
    public ReplicaSetConfig(IEnumerable`1<EndPoint> members, string name, EndPoint primary, Nullable`1<int> version);
    public static ReplicaSetConfig get_Empty();
    public IReadOnlyList`1<EndPoint> get_Members();
    public string get_Name();
    public EndPoint get_Primary();
    public Nullable`1<int> get_Version();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ReplicaSetConfig other);
    public virtual int GetHashCode();
}
public class MongoDB.Driver.Core.Clusters.ServerSelectors.CompositeServerSelector : object {
    private IReadOnlyList`1<IServerSelector> _selectors;
    public CompositeServerSelector(IEnumerable`1<IServerSelector> selectors);
    public sealed virtual IEnumerable`1<ServerDescription> SelectServers(ClusterDescription cluster, IEnumerable`1<ServerDescription> servers);
    public virtual string ToString();
}
public class MongoDB.Driver.Core.Clusters.ServerSelectors.DelegateServerSelector : object {
    private Func`3<ClusterDescription, IEnumerable`1<ServerDescription>, IEnumerable`1<ServerDescription>> _selector;
    public DelegateServerSelector(Func`3<ClusterDescription, IEnumerable`1<ServerDescription>, IEnumerable`1<ServerDescription>> selector);
    public sealed virtual IEnumerable`1<ServerDescription> SelectServers(ClusterDescription cluster, IEnumerable`1<ServerDescription> servers);
    public virtual string ToString();
}
public class MongoDB.Driver.Core.Clusters.ServerSelectors.EndPointServerSelector : object {
    private EndPoint _endPoint;
    public EndPointServerSelector(EndPoint endPoint);
    public sealed virtual IEnumerable`1<ServerDescription> SelectServers(ClusterDescription cluster, IEnumerable`1<ServerDescription> servers);
    public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool <SelectServers>b__2_0(ServerDescription server);
}
public interface MongoDB.Driver.Core.Clusters.ServerSelectors.IServerSelector {
    public abstract virtual IEnumerable`1<ServerDescription> SelectServers(ClusterDescription cluster, IEnumerable`1<ServerDescription> servers);
}
public class MongoDB.Driver.Core.Clusters.ServerSelectors.LatencyLimitingServerSelector : object {
    private TimeSpan _allowedLatencyRange;
    public LatencyLimitingServerSelector(TimeSpan allowedLatencyRange);
    public sealed virtual IEnumerable`1<ServerDescription> SelectServers(ClusterDescription cluster, IEnumerable`1<ServerDescription> servers);
    public virtual string ToString();
}
internal class MongoDB.Driver.Core.Clusters.ServerSelectors.OperationsCountServerSelector : object {
    private IEnumerable`1<IClusterableServer> _clusterableServers;
    public OperationsCountServerSelector(IEnumerable`1<IClusterableServer> clusterableServers);
    public sealed virtual IEnumerable`1<ServerDescription> SelectServers(ClusterDescription cluster, IEnumerable`1<ServerDescription> servers);
    public virtual string ToString();
}
public class MongoDB.Driver.Core.Clusters.ServerSelectors.PriorityServerSelector : object {
    private IReadOnlyCollection`1<ServerDescription> _deprioritizedServers;
    public PriorityServerSelector(IReadOnlyCollection`1<ServerDescription> deprioritizedServers);
    public sealed virtual IEnumerable`1<ServerDescription> SelectServers(ClusterDescription cluster, IEnumerable`1<ServerDescription> servers);
    public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool <SelectServers>b__2_0(ServerDescription description);
}
public class MongoDB.Driver.Core.Clusters.ServerSelectors.RandomServerSelector : object {
    public sealed virtual IEnumerable`1<ServerDescription> SelectServers(ClusterDescription cluster, IEnumerable`1<ServerDescription> servers);
    public virtual string ToString();
}
public class MongoDB.Driver.Core.Clusters.ServerSelectors.ReadPreferenceServerSelector : object {
    private static ServerDescription[] __noServers;
    private static ReadPreferenceServerSelector __primary;
    private Nullable`1<TimeSpan> _maxStaleness;
    private ReadPreference _readPreference;
    public static ReadPreferenceServerSelector Primary { get; }
    public ReadPreferenceServerSelector(ReadPreference readPreference);
    private static ReadPreferenceServerSelector();
    public static ReadPreferenceServerSelector get_Primary();
    public sealed virtual IEnumerable`1<ServerDescription> SelectServers(ClusterDescription cluster, IEnumerable`1<ServerDescription> servers);
    public virtual string ToString();
    private IEnumerable`1<ServerDescription> SelectByTagSets(IEnumerable`1<ServerDescription> servers);
    private IEnumerable`1<ServerDescription> SelectForReplicaSet(ClusterDescription cluster, IEnumerable`1<ServerDescription> servers);
    private IEnumerable`1<ServerDescription> SelectForShardedCluster(IEnumerable`1<ServerDescription> servers);
    private IEnumerable`1<ServerDescription> SelectForStandaloneCluster(IEnumerable`1<ServerDescription> servers);
    private IEnumerable`1<ServerDescription> SelectForLoadBalancedCluster(IEnumerable`1<ServerDescription> servers);
    private List`1<ServerDescription> SelectPrimary(IEnumerable`1<ServerDescription> servers);
    private IEnumerable`1<ServerDescription> SelectSecondaries(IEnumerable`1<ServerDescription> servers);
    private IEnumerable`1<ServerDescription> SelectFreshSecondaries(ClusterDescription cluster, IEnumerable`1<ServerDescription> servers);
    private IEnumerable`1<ServerDescription> SelectFreshSecondariesWithNoPrimary(IEnumerable`1<ServerDescription> secondaries);
    private IEnumerable`1<ServerDescription> SelectFreshSecondariesWithPrimary(ServerDescription primary, IEnumerable`1<ServerDescription> secondaries);
    private void EnsureMaxStalenessIsValid(ClusterDescription cluster);
}
public class MongoDB.Driver.Core.Clusters.ServerSelectors.WritableServerSelector : object {
    private static WritableServerSelector __instance;
    private IMayUseSecondaryCriteria _mayUseSecondary;
    public static WritableServerSelector Instance { get; }
    public IMayUseSecondaryCriteria MayUseSecondary { get; }
    public WritableServerSelector(IMayUseSecondaryCriteria mayUseSecondary);
    private static WritableServerSelector();
    public static WritableServerSelector get_Instance();
    public IMayUseSecondaryCriteria get_MayUseSecondary();
    public sealed virtual IEnumerable`1<ServerDescription> SelectServers(ClusterDescription cluster, IEnumerable`1<ServerDescription> servers);
    public virtual string ToString();
    private bool CanUseSecondaries(ClusterDescription cluster, List`1<ServerDescription> servers);
    [CompilerGeneratedAttribute]
private bool <CanUseSecondaries>b__10_0(ServerDescription s);
}
internal class MongoDB.Driver.Core.Clusters.SingleServerCluster : Cluster {
    private IClusterableServer _server;
    private InterlockedInt32 _state;
    private string _replicaSetName;
    internal SingleServerCluster(ClusterSettings settings, IClusterableServerFactory serverFactory, IEventSubscriber eventSubscriber, ILoggerFactory loggerFactory);
    protected virtual void Dispose(bool disposing);
    public virtual void Initialize();
    private bool IsServerValidForCluster(ClusterType clusterType, ClusterSettings clusterSettings, ServerType serverType);
    protected virtual void RequestHeartbeat();
    private void ServerDescriptionChanged(object sender, ServerDescriptionChangedEventArgs args);
    protected virtual bool TryGetServer(EndPoint endPoint, IClusterableServer& server);
    private void ThrowIfDisposed();
    [CompilerGeneratedAttribute]
internal static bool <IsServerValidForCluster>g__IsStandaloneServerValidForCluster|6_0(<>c__DisplayClass6_0& );
    [CompilerGeneratedAttribute]
internal static bool <IsServerValidForCluster>g__IsUnknownServerValidForCluster|6_1(<>c__DisplayClass6_0& );
}
internal class MongoDB.Driver.Core.Compression.CompressorSource : object {
    private IReadOnlyList`1<CompressorConfiguration> _allowedCompressors;
    private ConcurrentDictionary`2<CompressorType, ICompressor> _cache;
    public CompressorSource(IReadOnlyList`1<CompressorConfiguration> allowedCompressors);
    public static bool IsCompressorSupported(CompressorType compressorType);
    public sealed virtual ICompressor Get(CompressorType compressorType);
    private ICompressor CreateCompressor(CompressorConfiguration compressorConfiguration);
    private ICompressor CreateCompressor(CompressorType compressorType);
}
public enum MongoDB.Driver.Core.Compression.CompressorType : Enum {
    public int value__;
    public static CompressorType Noop;
    public static CompressorType Snappy;
    public static CompressorType Zlib;
    public static CompressorType ZStandard;
}
internal static class MongoDB.Driver.Core.Compression.CompressorTypeMapper : object {
    public static string ToServerName(CompressorType compressorType);
    public static bool TryFromServerName(string serverName, CompressorType& compressorType);
}
public interface MongoDB.Driver.Core.Compression.ICompressor {
    public CompressorType Type { get; }
    public abstract virtual CompressorType get_Type();
    public abstract virtual void Compress(Stream input, Stream output);
    public abstract virtual void Decompress(Stream input, Stream output);
}
public interface MongoDB.Driver.Core.Compression.ICompressorSource {
    public abstract virtual ICompressor Get(CompressorType compressorType);
}
internal class MongoDB.Driver.Core.Compression.NoopCompressor : object {
    public CompressorType Type { get; }
    public sealed virtual CompressorType get_Type();
    public sealed virtual void Compress(Stream input, Stream output);
    public sealed virtual void Decompress(Stream input, Stream output);
}
internal class MongoDB.Driver.Core.Compression.SnappyCompressor : object {
    public CompressorType Type { get; }
    public sealed virtual CompressorType get_Type();
    public sealed virtual void Compress(Stream input, Stream output);
    public sealed virtual void Decompress(Stream input, Stream output);
}
internal class MongoDB.Driver.Core.Compression.ZlibCompressor : object {
    private CompressionLevel _compressionLevel;
    public CompressorType Type { get; }
    public ZlibCompressor(Nullable`1<int> compressionLevel);
    public sealed virtual CompressorType get_Type();
    public sealed virtual void Compress(Stream input, Stream output);
    public sealed virtual void Decompress(Stream input, Stream output);
    private static CompressionLevel GetCompressionLevel(Nullable`1<int> compressionLevel);
}
internal class MongoDB.Driver.Core.Compression.ZstandardCompressor : object {
    private static int _defaultCompressionLevel;
    private int _compressionLevel;
    public CompressorType Type { get; }
    public ZstandardCompressor(Optional`1<int> compressionLevel);
    public sealed virtual CompressorType get_Type();
    public sealed virtual void Compress(Stream input, Stream output);
    public sealed virtual void Decompress(Stream input, Stream output);
}
public class MongoDB.Driver.Core.Configuration.ClusterBuilder : object {
    private static string __traceSourceName;
    private EventAggregator _eventAggregator;
    private ClusterSettings _clusterSettings;
    private ConnectionPoolSettings _connectionPoolSettings;
    private ConnectionSettings _connectionSettings;
    private LoggingSettings _loggingSettings;
    private SdamLoggingSettings _sdamLoggingSettings;
    private ServerSettings _serverSettings;
    private SslStreamSettings _sslStreamSettings;
    private Func`2<IStreamFactory, IStreamFactory> _streamFactoryWrapper;
    private TcpStreamSettings _tcpStreamSettings;
    public ICluster BuildCluster();
    public ClusterBuilder ConfigureCluster(Func`2<ClusterSettings, ClusterSettings> configurator);
    public ClusterBuilder ConfigureConnection(Func`2<ConnectionSettings, ConnectionSettings> configurator);
    public ClusterBuilder ConfigureConnectionPool(Func`2<ConnectionPoolSettings, ConnectionPoolSettings> configurator);
    [CLSCompliantAttribute("False")]
public ClusterBuilder ConfigureLoggingSettings(Func`2<LoggingSettings, LoggingSettings> configurator);
    [ObsoleteAttribute("Use ConfigureLoggingSettings instead.")]
public ClusterBuilder ConfigureSdamLogging(Func`2<SdamLoggingSettings, SdamLoggingSettings> configurator);
    public ClusterBuilder ConfigureServer(Func`2<ServerSettings, ServerSettings> configurator);
    public ClusterBuilder ConfigureSsl(Func`2<SslStreamSettings, SslStreamSettings> configurator);
    public ClusterBuilder ConfigureTcp(Func`2<TcpStreamSettings, TcpStreamSettings> configurator);
    public ClusterBuilder RegisterStreamFactory(Func`2<IStreamFactory, IStreamFactory> wrapper);
    public ClusterBuilder Subscribe(Action`1<TEvent> handler);
    public ClusterBuilder Subscribe(IEventSubscriber subscriber);
    private IClusterFactory CreateClusterFactory();
    private IConnectionPoolFactory CreateConnectionPoolFactory();
    private ServerFactory CreateServerFactory();
    private IServerMonitorFactory CreateServerMonitorFactory();
    private IStreamFactory CreateTcpStreamFactory(TcpStreamSettings tcpStreamSettings);
}
[ExtensionAttribute]
public static class MongoDB.Driver.Core.Configuration.ClusterBuilderExtensions : object {
    [ExtensionAttribute]
public static ClusterBuilder ConfigureWithConnectionString(ClusterBuilder builder, string connectionString);
    [ExtensionAttribute]
public static ClusterBuilder ConfigureWithConnectionString(ClusterBuilder builder, string connectionString, ServerApi serverApi);
    [ExtensionAttribute]
public static ClusterBuilder ConfigureWithConnectionString(ClusterBuilder builder, ConnectionString connectionString);
    [ExtensionAttribute]
public static ClusterBuilder ConfigureWithConnectionString(ClusterBuilder builder, ConnectionString connectionString, ServerApi serverApi);
    private static bool AcceptAnySslCertificate(object sender, X509Certificate certificate, X509Chain chain, SslPolicyErrors sslPolicyErrors);
    private static string GetAuthSource(ConnectionString connectionString);
    private static string GetDefaultAuthSource(ConnectionString connectionString);
    private static IAuthenticator CreateAuthenticator(ConnectionString connectionString, ServerApi serverApi);
    [ExtensionAttribute]
public static ClusterBuilder TraceWith(ClusterBuilder builder, TraceSource traceSource);
    [ExtensionAttribute]
public static ClusterBuilder TraceCommandsWith(ClusterBuilder builder, TraceSource traceSource);
}
public class MongoDB.Driver.Core.Configuration.ClusterSettings : object {
    private static IReadOnlyList`1<EndPoint> __defaultEndPoints;
    private ClusterConnectionMode _connectionMode;
    private ConnectionModeSwitch _connectionModeSwitch;
    private CryptClientSettings _cryptClientSettings;
    private Nullable`1<bool> _directConnection;
    private IReadOnlyList`1<EndPoint> _endPoints;
    private bool _loadBalanced;
    private TimeSpan _localThreshold;
    private int _maxServerSelectionWaitQueueSize;
    private string _replicaSetName;
    private ConnectionStringScheme _scheme;
    private ServerApi _serverApi;
    private TimeSpan _serverSelectionTimeout;
    private int _srvMaxHosts;
    private string _srvServiceName;
    private IServerSelector _preServerSelector;
    private IServerSelector _postServerSelector;
    [ObsoleteAttribute("Use DirectConnection instead.")]
public ClusterConnectionMode ConnectionMode { get; }
    [ObsoleteAttribute("This property will be removed in a later release.")]
public ConnectionModeSwitch ConnectionModeSwitch { get; }
    public CryptClientSettings CryptClientSettings { get; }
    public Nullable`1<bool> DirectConnection { get; }
    public IReadOnlyList`1<EndPoint> EndPoints { get; }
    public bool LoadBalanced { get; }
    public TimeSpan LocalThreshold { get; }
    public int MaxServerSelectionWaitQueueSize { get; }
    public string ReplicaSetName { get; }
    public ConnectionStringScheme Scheme { get; }
    public ServerApi ServerApi { get; }
    public TimeSpan ServerSelectionTimeout { get; }
    public int SrvMaxHosts { get; }
    public string SrvServiceName { get; }
    public IServerSelector PreServerSelector { get; }
    public IServerSelector PostServerSelector { get; }
    public ClusterSettings(Optional`1<ClusterConnectionMode> connectionMode, Optional`1<ConnectionModeSwitch> connectionModeSwitch, Optional`1<CryptClientSettings> cryptClientSettings, Optional`1<Nullable`1<bool>> directConnection, Optional`1<IEnumerable`1<EndPoint>> endPoints, Optional`1<bool> loadBalanced, Optional`1<TimeSpan> localThreshold, Optional`1<int> maxServerSelectionWaitQueueSize, Optional`1<string> replicaSetName, Optional`1<ServerApi> serverApi, Optional`1<TimeSpan> serverSelectionTimeout, Optional`1<IServerSelector> preServerSelector, Optional`1<IServerSelector> postServerSelector, Optional`1<ConnectionStringScheme> scheme, Optional`1<int> srvMaxHosts, Optional`1<string> srvServiceName);
    private static ClusterSettings();
    public ClusterConnectionMode get_ConnectionMode();
    public ConnectionModeSwitch get_ConnectionModeSwitch();
    public CryptClientSettings get_CryptClientSettings();
    public Nullable`1<bool> get_DirectConnection();
    public IReadOnlyList`1<EndPoint> get_EndPoints();
    public bool get_LoadBalanced();
    public TimeSpan get_LocalThreshold();
    public int get_MaxServerSelectionWaitQueueSize();
    public string get_ReplicaSetName();
    public ConnectionStringScheme get_Scheme();
    public ServerApi get_ServerApi();
    public TimeSpan get_ServerSelectionTimeout();
    public int get_SrvMaxHosts();
    public string get_SrvServiceName();
    public IServerSelector get_PreServerSelector();
    public IServerSelector get_PostServerSelector();
    public ClusterSettings With(Optional`1<ClusterConnectionMode> connectionMode, Optional`1<ConnectionModeSwitch> connectionModeSwitch, Optional`1<CryptClientSettings> cryptClientSettings, Optional`1<Nullable`1<bool>> directConnection, Optional`1<IEnumerable`1<EndPoint>> endPoints, Optional`1<bool> loadBalanced, Optional`1<TimeSpan> localThreshold, Optional`1<int> maxServerSelectionWaitQueueSize, Optional`1<string> replicaSetName, Optional`1<ServerApi> serverApi, Optional`1<TimeSpan> serverSelectionTimeout, Optional`1<IServerSelector> preServerSelector, Optional`1<IServerSelector> postServerSelector, Optional`1<ConnectionStringScheme> scheme, Optional`1<int> srvMaxHosts, Optional`1<string> srvServiceName);
    internal ClusterType GetInitialClusterType();
}
public class MongoDB.Driver.Core.Configuration.CompressorConfiguration : object {
    private IDictionary`2<string, object> _properties;
    private CompressorType _type;
    public IDictionary`2<string, object> Properties { get; }
    public CompressorType Type { get; }
    public CompressorConfiguration(CompressorType type);
    public IDictionary`2<string, object> get_Properties();
    public CompressorType get_Type();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    private bool IsEquivalentTo(IDictionary`2<string, object> x, IDictionary`2<string, object> y);
}
public class MongoDB.Driver.Core.Configuration.ConnectionPoolSettings : object {
    private TimeSpan _maintenanceInterval;
    private int _maxConnections;
    private int _minConnections;
    private int _waitQueueSize;
    private TimeSpan _waitQueueTimeout;
    private int _maxConnecting;
    private bool _isPausable;
    public TimeSpan MaintenanceInterval { get; }
    public int MaxConnecting { get; }
    public int MaxConnections { get; }
    public int MinConnections { get; }
    [ObsoleteAttribute("This property will be removed in a later release.")]
public int WaitQueueSize { get; }
    public TimeSpan WaitQueueTimeout { get; }
    internal bool IsPausable { get; }
    public ConnectionPoolSettings(Optional`1<TimeSpan> maintenanceInterval, Optional`1<int> maxConnections, Optional`1<int> minConnections, Optional`1<int> waitQueueSize, Optional`1<TimeSpan> waitQueueTimeout, Optional`1<int> maxConnecting);
    private ConnectionPoolSettings(Optional`1<TimeSpan> maintenanceInterval, Optional`1<int> maxConnections, Optional`1<int> minConnections, Optional`1<int> waitQueueSize, Optional`1<TimeSpan> waitQueueTimeout, Optional`1<bool> isPausable, Optional`1<int> maxConnecting);
    public TimeSpan get_MaintenanceInterval();
    public int get_MaxConnecting();
    public int get_MaxConnections();
    public int get_MinConnections();
    public int get_WaitQueueSize();
    public TimeSpan get_WaitQueueTimeout();
    internal bool get_IsPausable();
    public ConnectionPoolSettings With(Optional`1<TimeSpan> maintenanceInterval, Optional`1<int> maxConnections, Optional`1<int> minConnections, Optional`1<int> waitQueueSize, Optional`1<TimeSpan> waitQueueTimeout, Optional`1<int> maxConnecting);
    internal ConnectionPoolSettings WithInternal(Optional`1<bool> isPausable);
}
public class MongoDB.Driver.Core.Configuration.ConnectionSettings : object {
    private string _applicationName;
    private IReadOnlyList`1<IAuthenticatorFactory> _authenticatorFactories;
    private IReadOnlyList`1<CompressorConfiguration> _compressors;
    private LibraryInfo _libraryInfo;
    private bool _loadBalanced;
    private TimeSpan _maxIdleTime;
    private TimeSpan _maxLifeTime;
    public string ApplicationName { get; }
    public IReadOnlyList`1<IAuthenticatorFactory> AuthenticatorFactories { get; }
    public IReadOnlyList`1<CompressorConfiguration> Compressors { get; }
    public LibraryInfo LibraryInfo { get; }
    public bool LoadBalanced { get; }
    public TimeSpan MaxIdleTime { get; }
    public TimeSpan MaxLifeTime { get; }
    public ConnectionSettings(Optional`1<IEnumerable`1<IAuthenticatorFactory>> authenticatorFactories, Optional`1<IEnumerable`1<CompressorConfiguration>> compressors, Optional`1<LibraryInfo> libraryInfo, Optional`1<bool> loadBalanced, Optional`1<TimeSpan> maxIdleTime, Optional`1<TimeSpan> maxLifeTime, Optional`1<string> applicationName);
    public string get_ApplicationName();
    public IReadOnlyList`1<IAuthenticatorFactory> get_AuthenticatorFactories();
    public IReadOnlyList`1<CompressorConfiguration> get_Compressors();
    public LibraryInfo get_LibraryInfo();
    public bool get_LoadBalanced();
    public TimeSpan get_MaxIdleTime();
    public TimeSpan get_MaxLifeTime();
    public ConnectionSettings With(Optional`1<IEnumerable`1<IAuthenticatorFactory>> authenticatorFactories, Optional`1<IEnumerable`1<CompressorConfiguration>> compressors, Optional`1<LibraryInfo> libraryInfo, Optional`1<bool> loadBalanced, Optional`1<TimeSpan> maxIdleTime, Optional`1<TimeSpan> maxLifeTime, Optional`1<string> applicationName);
}
public class MongoDB.Driver.Core.Configuration.ConnectionString : object {
    private static int defaultMongoDBPort;
    private static int defaultSrvPort;
    private string _originalConnectionString;
    private NameValueCollection _allOptions;
    private NameValueCollection _unknownOptions;
    private Dictionary`2<string, string> _authMechanismProperties;
    private CompressorsOptions _compressorsOptions;
    private IDnsResolver _dnsResolver;
    private string _srvPrefix;
    private string _applicationName;
    private string _authMechanism;
    private string _authSource;
    private Nullable`1<ClusterConnectionMode> _connect;
    private ConnectionModeSwitch _connectionModeSwitch;
    private Nullable`1<TimeSpan> _connectTimeout;
    private string _databaseName;
    private Nullable`1<bool> _directConnection;
    private Nullable`1<bool> _fsync;
    private Nullable`1<TimeSpan> _heartbeatInterval;
    private Nullable`1<TimeSpan> _heartbeatTimeout;
    private IReadOnlyList`1<EndPoint> _hosts;
    private Nullable`1<bool> _ipv6;
    private bool _isInternalRepresentation;
    private bool _isResolved;
    private Nullable`1<bool> _journal;
    private bool _loadBalanced;
    private Nullable`1<TimeSpan> _localThreshold;
    private Nullable`1<int> _maxConnecting;
    private Nullable`1<TimeSpan> _maxIdleTime;
    private Nullable`1<TimeSpan> _maxLifeTime;
    private Nullable`1<int> _maxPoolSize;
    private Nullable`1<TimeSpan> _maxStaleness;
    private Nullable`1<int> _minPoolSize;
    private string _password;
    private Nullable`1<ReadConcernLevel> _readConcernLevel;
    private Nullable`1<ReadPreferenceMode> _readPreference;
    private IReadOnlyList`1<TagSet> _readPreferenceTags;
    private string _replicaSet;
    private Nullable`1<bool> _retryReads;
    private Nullable`1<bool> _retryWrites;
    private ConnectionStringScheme _scheme;
    private Nullable`1<ServerMonitoringMode> _serverMonitoringMode;
    private Nullable`1<TimeSpan> _serverSelectionTimeout;
    private Nullable`1<TimeSpan> _socketTimeout;
    private Nullable`1<int> _srvMaxHosts;
    private string _srvServiceName;
    private Nullable`1<bool> _tls;
    private Nullable`1<bool> _tlsDisableCertificateRevocationCheck;
    private Nullable`1<bool> _tlsInsecure;
    private string _username;
    private Nullable`1<GuidRepresentation> _uuidRepresentation;
    private Nullable`1<double> _waitQueueMultiple;
    private Nullable`1<int> _waitQueueSize;
    private Nullable`1<TimeSpan> _waitQueueTimeout;
    private WValue _w;
    private Nullable`1<TimeSpan> _wTimeout;
    public IEnumerable`1<string> AllOptionNames { get; }
    public IEnumerable`1<string> AllUnknownOptionNames { get; }
    public string ApplicationName { get; }
    public string AuthMechanism { get; }
    public IReadOnlyDictionary`2<string, string> AuthMechanismProperties { get; }
    public string AuthSource { get; }
    public IReadOnlyList`1<CompressorConfiguration> Compressors { get; }
    [ObsoleteAttribute("Use DirectConnection instead.")]
public ClusterConnectionMode Connect { get; }
    [ObsoleteAttribute("This property will be removed in a later release.")]
public ConnectionModeSwitch ConnectionModeSwitch { get; }
    public Nullable`1<TimeSpan> ConnectTimeout { get; }
    public string DatabaseName { get; }
    public Nullable`1<bool> DirectConnection { get; }
    public Nullable`1<bool> FSync { get; }
    public Nullable`1<TimeSpan> HeartbeatInterval { get; }
    public Nullable`1<TimeSpan> HeartbeatTimeout { get; }
    public IReadOnlyList`1<EndPoint> Hosts { get; }
    public Nullable`1<bool> Ipv6 { get; }
    public bool IsResolved { get; }
    public Nullable`1<bool> Journal { get; }
    public bool LoadBalanced { get; }
    public Nullable`1<TimeSpan> LocalThreshold { get; }
    public Nullable`1<int> MaxConnecting { get; }
    public Nullable`1<TimeSpan> MaxIdleTime { get; }
    public Nullable`1<TimeSpan> MaxLifeTime { get; }
    public Nullable`1<int> MaxPoolSize { get; }
    public Nullable`1<TimeSpan> MaxStaleness { get; }
    public Nullable`1<int> MinPoolSize { get; }
    public string Password { get; }
    public Nullable`1<ReadConcernLevel> ReadConcernLevel { get; }
    public Nullable`1<ReadPreferenceMode> ReadPreference { get; }
    public string ReplicaSet { get; }
    public IReadOnlyList`1<TagSet> ReadPreferenceTags { get; }
    public Nullable`1<bool> RetryReads { get; }
    public Nullable`1<bool> RetryWrites { get; }
    public ConnectionStringScheme Scheme { get; }
    public Nullable`1<ServerMonitoringMode> ServerMonitoringMode { get; }
    public Nullable`1<TimeSpan> ServerSelectionTimeout { get; }
    public Nullable`1<TimeSpan> SocketTimeout { get; }
    public Nullable`1<int> SrvMaxHosts { get; }
    public string SrvServiceName { get; }
    [ObsoleteAttribute("Use Tls instead.")]
public Nullable`1<bool> Ssl { get; }
    [ObsoleteAttribute("Use TlsInsecure instead.")]
public Nullable`1<bool> SslVerifyCertificate { get; }
    public Nullable`1<bool> Tls { get; }
    public Nullable`1<bool> TlsDisableCertificateRevocationCheck { get; }
    public Nullable`1<bool> TlsInsecure { get; }
    public string Username { get; }
    public Nullable`1<GuidRepresentation> UuidRepresentation { get; }
    [ObsoleteAttribute("This property will be removed in a later release.")]
public Nullable`1<double> WaitQueueMultiple { get; }
    [ObsoleteAttribute("This property will be removed in a later release.")]
public Nullable`1<int> WaitQueueSize { get; }
    public Nullable`1<TimeSpan> WaitQueueTimeout { get; }
    public WValue W { get; }
    public Nullable`1<TimeSpan> WTimeout { get; }
    public ConnectionString(string connectionString);
    internal ConnectionString(string connectionString, bool isInternalRepresentation, IDnsResolver dnsResolver);
    internal ConnectionString(string connectionString, bool isResolved);
    public IEnumerable`1<string> get_AllOptionNames();
    public IEnumerable`1<string> get_AllUnknownOptionNames();
    public string get_ApplicationName();
    public string get_AuthMechanism();
    public IReadOnlyDictionary`2<string, string> get_AuthMechanismProperties();
    public string get_AuthSource();
    public IReadOnlyList`1<CompressorConfiguration> get_Compressors();
    public ClusterConnectionMode get_Connect();
    public ConnectionModeSwitch get_ConnectionModeSwitch();
    public Nullable`1<TimeSpan> get_ConnectTimeout();
    public string get_DatabaseName();
    public Nullable`1<bool> get_DirectConnection();
    public Nullable`1<bool> get_FSync();
    public Nullable`1<TimeSpan> get_HeartbeatInterval();
    public Nullable`1<TimeSpan> get_HeartbeatTimeout();
    public IReadOnlyList`1<EndPoint> get_Hosts();
    public Nullable`1<bool> get_Ipv6();
    public bool get_IsResolved();
    public Nullable`1<bool> get_Journal();
    public bool get_LoadBalanced();
    public Nullable`1<TimeSpan> get_LocalThreshold();
    public Nullable`1<int> get_MaxConnecting();
    public Nullable`1<TimeSpan> get_MaxIdleTime();
    public Nullable`1<TimeSpan> get_MaxLifeTime();
    public Nullable`1<int> get_MaxPoolSize();
    public Nullable`1<TimeSpan> get_MaxStaleness();
    public Nullable`1<int> get_MinPoolSize();
    public string get_Password();
    public Nullable`1<ReadConcernLevel> get_ReadConcernLevel();
    public Nullable`1<ReadPreferenceMode> get_ReadPreference();
    public string get_ReplicaSet();
    public IReadOnlyList`1<TagSet> get_ReadPreferenceTags();
    public Nullable`1<bool> get_RetryReads();
    public Nullable`1<bool> get_RetryWrites();
    public ConnectionStringScheme get_Scheme();
    public Nullable`1<ServerMonitoringMode> get_ServerMonitoringMode();
    public Nullable`1<TimeSpan> get_ServerSelectionTimeout();
    public Nullable`1<TimeSpan> get_SocketTimeout();
    public Nullable`1<int> get_SrvMaxHosts();
    public string get_SrvServiceName();
    public Nullable`1<bool> get_Ssl();
    public Nullable`1<bool> get_SslVerifyCertificate();
    public Nullable`1<bool> get_Tls();
    public Nullable`1<bool> get_TlsDisableCertificateRevocationCheck();
    public Nullable`1<bool> get_TlsInsecure();
    public string get_Username();
    public Nullable`1<GuidRepresentation> get_UuidRepresentation();
    public Nullable`1<double> get_WaitQueueMultiple();
    public Nullable`1<int> get_WaitQueueSize();
    public Nullable`1<TimeSpan> get_WaitQueueTimeout();
    public WValue get_W();
    public Nullable`1<TimeSpan> get_WTimeout();
    public string GetOption(string name);
    public ConnectionString Resolve(CancellationToken cancellationToken);
    public ConnectionString Resolve(bool resolveHosts, CancellationToken cancellationToken);
    public Task`1<ConnectionString> ResolveAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MongoDB.Driver.Core.Configuration.ConnectionString/<ResolveAsync>d__167")]
public Task`1<ConnectionString> ResolveAsync(bool resolveHosts, CancellationToken cancellationToken);
    public virtual string ToString();
    private ConnectionString BuildResolvedConnectionString(ConnectionStringScheme resolvedScheme, List`1<string> resolvedHosts, NameValueCollection resolvedOptions);
    private void ExtractScheme(Match match);
    private void ExtractDatabaseName(Match match);
    private void ExtractHosts(Match match);
    private void ExtractOptions(Match match);
    private void ExtractUsernameAndPassword(Match match);
    private string GetHostNameForDns();
    private void Parse();
    private void ParseOption(string name, string value);
    [IteratorStateMachineAttribute("MongoDB.Driver.Core.Configuration.ConnectionString/<GetAuthMechanismProperties>d__178")]
private static IEnumerable`1<KeyValuePair`2<string, string>> GetAuthMechanismProperties(string name, string value);
    private static bool ParseBoolean(string name, string value);
    internal static double ParseDouble(string name, string value);
    private static TEnum ParseEnum(string name, string value);
    private static ClusterConnectionMode ParseClusterConnectionMode(string name, string value);
    private static int ParseInt32(string name, string value);
    private static TagSet ParseReadPreferenceTagSets(string name, string value);
    private static TimeSpan ParseTimeSpan(string name, string value);
    private bool EnsureTlsDisableCertificateRevocationCheckIsValid(bool value);
    private bool EnsureTlsInsecureIsValid(bool value);
    private List`1<string> GetHostsFromSrvRecords(IEnumerable`1<SrvRecord> srvRecords);
    private NameValueCollection GetResolvedOptionsFromTxtRecords(IReadOnlyCollection`1<TxtRecord> txtRecords);
    private void ValidateResolvedHosts(string original, List`1<string> resolved);
    internal static bool HasValidParentDomain(string original, DnsEndPoint resolvedEndPoint);
    private void ValidateResolvedOptions(IEnumerable`1<string> optionNames);
    [CompilerGeneratedAttribute]
private bool <Parse>g__IsDirectConnection|176_0();
    [CompilerGeneratedAttribute]
internal static string <Parse>g__ProtectConnectionString|176_1(string connectionString);
}
public enum MongoDB.Driver.Core.Configuration.ConnectionStringScheme : Enum {
    public int value__;
    public static ConnectionStringScheme MongoDB;
    public static ConnectionStringScheme MongoDBPlusSrv;
}
public class MongoDB.Driver.Core.Configuration.CryptClientSettings : object {
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <BypassQueryAnalysis>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CryptSharedLibPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CryptSharedLibSearchPath>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<string, BsonDocument> <EncryptedFieldsMap>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <IsCryptSharedLibRequired>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<string, IReadOnlyDictionary`2<string, object>> <KmsProviders>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<string, BsonDocument> <SchemaMap>k__BackingField;
    public Nullable`1<bool> BypassQueryAnalysis { get; }
    public string CryptSharedLibPath { get; }
    public string CryptSharedLibSearchPath { get; }
    public IReadOnlyDictionary`2<string, BsonDocument> EncryptedFieldsMap { get; }
    public Nullable`1<bool> IsCryptSharedLibRequired { get; }
    public IReadOnlyDictionary`2<string, IReadOnlyDictionary`2<string, object>> KmsProviders { get; }
    public IReadOnlyDictionary`2<string, BsonDocument> SchemaMap { get; }
    public CryptClientSettings(Nullable`1<bool> bypassQueryAnalysis, string cryptSharedLibPath, string cryptSharedLibSearchPath, IReadOnlyDictionary`2<string, BsonDocument> encryptedFieldsMap, Nullable`1<bool> isCryptSharedLibRequired, IReadOnlyDictionary`2<string, IReadOnlyDictionary`2<string, object>> kmsProviders, IReadOnlyDictionary`2<string, BsonDocument> schemaMap);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_BypassQueryAnalysis();
    [CompilerGeneratedAttribute]
public string get_CryptSharedLibPath();
    [CompilerGeneratedAttribute]
public string get_CryptSharedLibSearchPath();
    [CompilerGeneratedAttribute]
public IReadOnlyDictionary`2<string, BsonDocument> get_EncryptedFieldsMap();
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_IsCryptSharedLibRequired();
    [CompilerGeneratedAttribute]
public IReadOnlyDictionary`2<string, IReadOnlyDictionary`2<string, object>> get_KmsProviders();
    [CompilerGeneratedAttribute]
public IReadOnlyDictionary`2<string, BsonDocument> get_SchemaMap();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
}
public class MongoDB.Driver.Core.Configuration.LibraryInfo : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Version>k__BackingField;
    public string Name { get; }
    public string Version { get; }
    public LibraryInfo(string name, string version);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public string get_Version();
    public static bool op_Equality(LibraryInfo lhs, LibraryInfo rhs);
    public static bool op_Inequality(LibraryInfo lhs, LibraryInfo rhs);
    public sealed virtual bool Equals(LibraryInfo rhs);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class MongoDB.Driver.Core.Configuration.LoggingSettings : object {
    [CompilerGeneratedAttribute]
private ILoggerFactory <LoggerFactory>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxDocumentSize>k__BackingField;
    [CLSCompliantAttribute("False")]
public ILoggerFactory LoggerFactory { get; }
    public int MaxDocumentSize { get; }
    [CLSCompliantAttribute("False")]
public LoggingSettings(ILoggerFactory loggerFactory, Optional`1<int> maxDocumentSize);
    [CompilerGeneratedAttribute]
public ILoggerFactory get_LoggerFactory();
    [CompilerGeneratedAttribute]
public int get_MaxDocumentSize();
    public static bool op_Equality(LoggingSettings lhs, LoggingSettings rhs);
    public static bool op_Inequality(LoggingSettings lhs, LoggingSettings rhs);
    public sealed virtual bool Equals(LoggingSettings rhs);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[ObsoleteAttribute("Use MongoClientSettings.LoggerFactory instead.")]
public class MongoDB.Driver.Core.Configuration.SdamLoggingSettings : object {
    private string _logFilename;
    public string LogFilename { get; }
    internal bool IsLoggingEnabled { get; }
    internal bool ShouldLogToStdout { get; }
    public SdamLoggingSettings(Optional`1<string> logFilename);
    public string get_LogFilename();
    public SdamLoggingSettings With(Optional`1<string> logFilename);
    internal bool get_IsLoggingEnabled();
    internal bool get_ShouldLogToStdout();
}
public class MongoDB.Driver.Core.Configuration.ServerSettings : object {
    private TimeSpan _heartbeatInterval;
    private TimeSpan _heartbeatTimeout;
    private ServerMonitoringMode _serverMonitoringMode;
    public static TimeSpan DefaultHeartbeatInterval { get; }
    public static TimeSpan DefaultHeartbeatTimeout { get; }
    public static ServerMonitoringMode DefaultServerMonitoringMode { get; }
    public TimeSpan HeartbeatInterval { get; }
    public TimeSpan HeartbeatTimeout { get; }
    public ServerMonitoringMode ServerMonitoringMode { get; }
    public ServerSettings(Optional`1<TimeSpan> heartbeatInterval, Optional`1<TimeSpan> heartbeatTimeout, Optional`1<ServerMonitoringMode> serverMonitoringMode);
    public static TimeSpan get_DefaultHeartbeatInterval();
    public static TimeSpan get_DefaultHeartbeatTimeout();
    public static ServerMonitoringMode get_DefaultServerMonitoringMode();
    public TimeSpan get_HeartbeatInterval();
    public TimeSpan get_HeartbeatTimeout();
    public ServerMonitoringMode get_ServerMonitoringMode();
    public ServerSettings With(Optional`1<TimeSpan> heartbeatInterval, Optional`1<TimeSpan> heartbeatTimeout, Optional`1<ServerMonitoringMode> serverMonitoringMode);
}
public class MongoDB.Driver.Core.Configuration.SslStreamSettings : object {
    private bool _checkCertificateRevocation;
    private IEnumerable`1<X509Certificate> _clientCertificates;
    private LocalCertificateSelectionCallback _clientCertificateSelectionCallback;
    private SslProtocols _enabledSslProtocols;
    private RemoteCertificateValidationCallback _serverCertificateValidationCallback;
    internal static SslProtocols SslProtocolsTls13;
    public bool CheckCertificateRevocation { get; }
    public IEnumerable`1<X509Certificate> ClientCertificates { get; }
    public LocalCertificateSelectionCallback ClientCertificateSelectionCallback { get; }
    public SslProtocols EnabledSslProtocols { get; }
    public RemoteCertificateValidationCallback ServerCertificateValidationCallback { get; }
    public SslStreamSettings(Optional`1<bool> checkCertificateRevocation, Optional`1<IEnumerable`1<X509Certificate>> clientCertificates, Optional`1<LocalCertificateSelectionCallback> clientCertificateSelectionCallback, Optional`1<SslProtocols> enabledProtocols, Optional`1<RemoteCertificateValidationCallback> serverCertificateValidationCallback);
    public bool get_CheckCertificateRevocation();
    public IEnumerable`1<X509Certificate> get_ClientCertificates();
    public LocalCertificateSelectionCallback get_ClientCertificateSelectionCallback();
    public SslProtocols get_EnabledSslProtocols();
    public RemoteCertificateValidationCallback get_ServerCertificateValidationCallback();
    public SslStreamSettings With(Optional`1<bool> checkCertificateRevocation, Optional`1<IEnumerable`1<X509Certificate>> clientCertificates, Optional`1<LocalCertificateSelectionCallback> clientCertificateSelectionCallback, Optional`1<SslProtocols> enabledProtocols, Optional`1<RemoteCertificateValidationCallback> serverCertificateValidationCallback);
}
public class MongoDB.Driver.Core.Configuration.TcpStreamSettings : object {
    private AddressFamily _addressFamily;
    private TimeSpan _connectTimeout;
    private Nullable`1<TimeSpan> _readTimeout;
    private int _receiveBufferSize;
    private int _sendBufferSize;
    private Action`1<Socket> _socketConfigurator;
    private Nullable`1<TimeSpan> _writeTimeout;
    public AddressFamily AddressFamily { get; }
    public TimeSpan ConnectTimeout { get; }
    public Nullable`1<TimeSpan> ReadTimeout { get; }
    public int ReceiveBufferSize { get; }
    public int SendBufferSize { get; }
    public Action`1<Socket> SocketConfigurator { get; }
    public Nullable`1<TimeSpan> WriteTimeout { get; }
    public TcpStreamSettings(Optional`1<AddressFamily> addressFamily, Optional`1<TimeSpan> connectTimeout, Optional`1<Nullable`1<TimeSpan>> readTimeout, Optional`1<int> receiveBufferSize, Optional`1<int> sendBufferSize, Optional`1<Action`1<Socket>> socketConfigurator, Optional`1<Nullable`1<TimeSpan>> writeTimeout);
    internal TcpStreamSettings(TcpStreamSettings other);
    public AddressFamily get_AddressFamily();
    public TimeSpan get_ConnectTimeout();
    public Nullable`1<TimeSpan> get_ReadTimeout();
    public int get_ReceiveBufferSize();
    public int get_SendBufferSize();
    public Action`1<Socket> get_SocketConfigurator();
    public Nullable`1<TimeSpan> get_WriteTimeout();
    public TcpStreamSettings With(Optional`1<AddressFamily> addressFamily, Optional`1<TimeSpan> connectTimeout, Optional`1<Nullable`1<TimeSpan>> readTimeout, Optional`1<int> receiveBufferSize, Optional`1<int> sendBufferSize, Optional`1<Action`1<Socket>> socketConfigurator, Optional`1<Nullable`1<TimeSpan>> writeTimeout);
}
internal enum MongoDB.Driver.Core.ConnectionPools.CheckOutReason : Enum {
    public int value__;
    public static CheckOutReason Cursor;
    public static CheckOutReason Transaction;
}
internal class MongoDB.Driver.Core.ConnectionPools.CheckOutReasonCounter : object {
    public int _cursorCheckOutsCount;
    public int _transactionCheckOutsCount;
    public int GetCheckOutsCount(CheckOutReason reason);
    public void Increment(CheckOutReason reason);
    public void Decrement(Nullable`1<CheckOutReason> reason);
}
internal class MongoDB.Driver.Core.ConnectionPools.ExclusiveConnectionPool : object {
    private CheckOutReasonCounter _checkOutReasonCounter;
    private IConnectionFactory _connectionFactory;
    private ListConnectionHolder _connectionHolder;
    private EndPoint _endPoint;
    private int _generation;
    private MaintenanceHelper _maintenanceHelper;
    private ServerId _serverId;
    private ServiceStates _serviceStates;
    private ConnectionPoolSettings _settings;
    private PoolState _poolState;
    private int _waitQueueFreeSlots;
    private SemaphoreSlimSignalable _maxConnectionsQueue;
    private SemaphoreSlimSignalable _maxConnectingQueue;
    private IConnectionExceptionHandler _connectionExceptionHandler;
    private EventLogger`1<Connection> _eventLogger;
    public int AvailableCount { get; }
    public int CreatedCount { get; }
    public int DormantCount { get; }
    public int Generation { get; }
    public int PendingCount { get; }
    public ServerId ServerId { get; }
    public ConnectionPoolSettings Settings { get; }
    public int UsedCount { get; }
    internal ListConnectionHolder ConnectionHolder { get; }
    public ExclusiveConnectionPool(ServerId serverId, EndPoint endPoint, ConnectionPoolSettings settings, IConnectionFactory connectionFactory, IConnectionExceptionHandler connectionExceptionHandler, EventLogger`1<Connection> eventLogger);
    public int get_AvailableCount();
    public int get_CreatedCount();
    public int get_DormantCount();
    public sealed virtual int get_Generation();
    public int get_PendingCount();
    public sealed virtual ServerId get_ServerId();
    public ConnectionPoolSettings get_Settings();
    public int get_UsedCount();
    internal ListConnectionHolder get_ConnectionHolder();
    public sealed virtual IConnectionHandle AcquireConnection(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MongoDB.Driver.Core.ConnectionPools.ExclusiveConnectionPool/<AcquireConnectionAsync>d__35")]
public sealed virtual Task`1<IConnectionHandle> AcquireConnectionAsync(CancellationToken cancellationToken);
    public sealed virtual void Clear(bool closeInUseConnections);
    public sealed virtual void Clear(ObjectId serviceId);
    private PooledConnection CreateNewConnection();
    public sealed virtual void Initialize();
    public sealed virtual void SetReady();
    public sealed virtual void Dispose();
    public sealed virtual int GetGeneration(Nullable`1<ObjectId> serviceId);
    internal SemaphoreSlimSignalableAwaiter CreateMaxConnectionsAwaiter();
    private void ReleaseConnection(PooledConnection connection);
    private Exception CreateTimeoutException(Stopwatch stopwatch, string message);
}
internal class MongoDB.Driver.Core.ConnectionPools.ExclusiveConnectionPoolFactory : object {
    private IConnectionFactory _connectionFactory;
    private IEventSubscriber _eventSubscriber;
    private ConnectionPoolSettings _settings;
    private ILoggerFactory _loggerFactory;
    public ExclusiveConnectionPoolFactory(ConnectionPoolSettings settings, IConnectionFactory connectionFactory, IEventSubscriber eventSubscriber, ILoggerFactory loggerFactory);
    public sealed virtual IConnectionPool CreateConnectionPool(ServerId serverId, EndPoint endPoint, IConnectionExceptionHandler connectionExceptionHandler);
}
internal interface MongoDB.Driver.Core.ConnectionPools.ICheckOutReasonTracker {
    public Nullable`1<CheckOutReason> CheckOutReason { get; }
    public abstract virtual Nullable`1<CheckOutReason> get_CheckOutReason();
    public abstract virtual void SetCheckOutReasonIfNotAlreadySet(CheckOutReason reason);
}
public interface MongoDB.Driver.Core.ConnectionPools.IConnectionExceptionHandler {
    public abstract virtual void HandleExceptionOnOpen(Exception exception);
}
public interface MongoDB.Driver.Core.ConnectionPools.IConnectionPool {
    public int Generation { get; }
    public ServerId ServerId { get; }
    public abstract virtual int get_Generation();
    public abstract virtual ServerId get_ServerId();
    public abstract virtual IConnectionHandle AcquireConnection(CancellationToken cancellationToken);
    public abstract virtual Task`1<IConnectionHandle> AcquireConnectionAsync(CancellationToken cancellationToken);
    public abstract virtual void Clear(bool closeInUseConnections);
    public abstract virtual void Clear(ObjectId serviceId);
    public abstract virtual int GetGeneration(Nullable`1<ObjectId> serviceId);
    public abstract virtual void SetReady();
    public abstract virtual void Initialize();
}
public interface MongoDB.Driver.Core.ConnectionPools.IConnectionPoolFactory {
    public abstract virtual IConnectionPool CreateConnectionPool(ServerId serverId, EndPoint endPoint, IConnectionExceptionHandler connectionExceptionHandler);
}
internal class MongoDB.Driver.Core.ConnectionPools.MaintenanceExecutingContext : object {
    private AutoResetEvent _autoResetEvent;
    private CancellationToken _cancellationToken;
    private CancellationTokenSource _cancellationTokenSource;
    private TimeSpan _interval;
    private Nullable`1<int> _maxGenerationToReap;
    public CancellationToken CancellationToken { get; }
    public Nullable`1<int> MaxGenerationToReap { get; }
    public MaintenanceExecutingContext(TimeSpan interval, CancellationToken globalCancellationToken);
    public CancellationToken get_CancellationToken();
    public Nullable`1<int> get_MaxGenerationToReap();
    public sealed virtual void Dispose();
    public void Cancel(Nullable`1<int> maxGenerationToReap);
    public void Wait();
}
internal class MongoDB.Driver.Core.ConnectionPools.MaintenanceHelper : object {
    private ExclusiveConnectionPool _connectionPool;
    private CancellationToken _globalCancellationToken;
    private CancellationTokenSource _globalCancellationTokenSource;
    private TimeSpan _interval;
    private MaintenanceExecutingContext _maintenanceExecutingContext;
    private Thread _maintenanceThread;
    public bool IsRunning { get; }
    public MaintenanceHelper(ExclusiveConnectionPool connectionPool, TimeSpan interval);
    public bool get_IsRunning();
    public void Stop(Nullable`1<int> maxGenerationToReap);
    public void Start();
    public sealed virtual void Dispose();
    private void RunMaintenance(MaintenanceExecutingContext maintenanceExecutingContext);
    private void EnsureMinSize(CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
private void <Start>g__ThreadStart|10_0(object maintenanceExecutingContextObj);
}
internal class MongoDB.Driver.Core.ConnectionPools.ServiceStates : object {
    private Dictionary`2<ObjectId, ServiceState> _serviceStates;
    private object _lock;
    public void IncrementConnectionCount(Nullable`1<ObjectId> serviceId);
    public void IncrementGeneration(ObjectId serviceId);
    public void DecrementConnectionCount(Nullable`1<ObjectId> serviceId);
    public bool TryGetGeneration(Nullable`1<ObjectId> serviceId, Int32& generation);
}
internal class MongoDB.Driver.Core.Connections.BinaryConnection : object {
    private CommandEventHelper _commandEventHelper;
    private ICompressorSource _compressorSource;
    private ConnectionId _connectionId;
    private IConnectionInitializer _connectionInitializer;
    private ConnectionInitializerContext _connectionInitializerContext;
    private EndPoint _endPoint;
    private ConnectionDescription _description;
    private Dropbox _dropbox;
    private bool _failedEventHasBeenRaised;
    private DateTime _lastUsedAtUtc;
    private DateTime _openedAtUtc;
    private object _openLock;
    private Task _openTask;
    private SemaphoreSlim _receiveLock;
    private Nullable`1<CompressorType> _sendCompressorType;
    private SemaphoreSlim _sendLock;
    private ConnectionSettings _settings;
    private InterlockedInt32 _state;
    private Stream _stream;
    private IStreamFactory _streamFactory;
    private EventLogger`1<Connection> _eventLogger;
    public ConnectionId ConnectionId { get; }
    public ConnectionDescription Description { get; }
    public EndPoint EndPoint { get; }
    public int Generation { get; }
    public bool IsExpired { get; }
    public ConnectionSettings Settings { get; }
    private bool IsInitializing { get; }
    public BinaryConnection(ServerId serverId, EndPoint endPoint, ConnectionSettings settings, IStreamFactory streamFactory, IConnectionInitializer connectionInitializer, IEventSubscriber eventSubscriber, ILoggerFactory loggerFactory);
    public sealed virtual ConnectionId get_ConnectionId();
    public sealed virtual ConnectionDescription get_Description();
    public sealed virtual EndPoint get_EndPoint();
    public sealed virtual int get_Generation();
    public sealed virtual bool get_IsExpired();
    public sealed virtual ConnectionSettings get_Settings();
    private bool get_IsInitializing();
    private void ConnectionFailed(Exception exception);
    public sealed virtual void Dispose();
    private void Dispose(bool disposing);
    private void EnsureMessageSizeIsValid(int messageSize);
    public sealed virtual void Open(CancellationToken cancellationToken);
    public sealed virtual Task OpenAsync(CancellationToken cancellationToken);
    private void OpenHelper(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MongoDB.Driver.Core.Connections.BinaryConnection/<OpenHelperAsync>d__43")]
private Task OpenHelperAsync(CancellationToken cancellationToken);
    public sealed virtual void Reauthenticate(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MongoDB.Driver.Core.Connections.BinaryConnection/<ReauthenticateAsync>d__45")]
public sealed virtual Task ReauthenticateAsync(CancellationToken cancellationToken);
    private void InvalidateAuthenticators();
    private IByteBuffer ReceiveBuffer(CancellationToken cancellationToken);
    private IByteBuffer ReceiveBuffer(int responseTo, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MongoDB.Driver.Core.Connections.BinaryConnection/<ReceiveBufferAsync>d__49")]
private Task`1<IByteBuffer> ReceiveBufferAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MongoDB.Driver.Core.Connections.BinaryConnection/<ReceiveBufferAsync>d__50")]
private Task`1<IByteBuffer> ReceiveBufferAsync(int responseTo, CancellationToken cancellationToken);
    public sealed virtual ResponseMessage ReceiveMessage(int responseTo, IMessageEncoderSelector encoderSelector, MessageEncoderSettings messageEncoderSettings, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MongoDB.Driver.Core.Connections.BinaryConnection/<ReceiveMessageAsync>d__52")]
public sealed virtual Task`1<ResponseMessage> ReceiveMessageAsync(int responseTo, IMessageEncoderSelector encoderSelector, MessageEncoderSettings messageEncoderSettings, CancellationToken cancellationToken);
    private void SendBuffer(IByteBuffer buffer, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MongoDB.Driver.Core.Connections.BinaryConnection/<SendBufferAsync>d__54")]
private Task SendBufferAsync(IByteBuffer buffer, CancellationToken cancellationToken);
    public sealed virtual void SendMessages(IEnumerable`1<RequestMessage> messages, MessageEncoderSettings messageEncoderSettings, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MongoDB.Driver.Core.Connections.BinaryConnection/<SendMessagesAsync>d__56")]
public sealed virtual Task SendMessagesAsync(IEnumerable`1<RequestMessage> messages, MessageEncoderSettings messageEncoderSettings, CancellationToken cancellationToken);
    public sealed virtual void SetReadTimeout(TimeSpan timeout);
    private bool AnyMessageNeedsToBeCompressed(IEnumerable`1<RequestMessage> messages);
    private Nullable`1<CompressorType> ChooseSendCompressorTypeIfAny(ConnectionDescription connectionDescription);
    private IByteBuffer CompressMessages(IEnumerable`1<RequestMessage> messages, IByteBuffer uncompressedBuffer, MessageEncoderSettings messageEncoderSettings);
    private void CompressMessage(RequestMessage message, ByteBufferStream uncompressedMessageStream, ByteBufferStream compressedStream, MessageEncoderSettings messageEncoderSettings);
    private void ThrowIfCancelledOrDisposed(CancellationToken cancellationToken);
    private void ThrowIfCancelledOrDisposedOrNotOpen(CancellationToken cancellationToken);
    private void ThrowIfDisposed();
    private Exception WrapExceptionIfRequired(Exception ex, string action);
    private void ThrowOperationCanceledExceptionIfRequired(Exception exception);
}
internal class MongoDB.Driver.Core.Connections.BinaryConnectionFactory : object {
    private IConnectionInitializer _connectionInitializer;
    private IEventSubscriber _eventSubscriber;
    private ILoggerFactory _loggerFactory;
    private ConnectionSettings _settings;
    private IStreamFactory _streamFactory;
    public ConnectionSettings ConnectionSettings { get; }
    public BinaryConnectionFactory(ConnectionSettings settings, IStreamFactory streamFactory, IEventSubscriber eventSubscriber, ServerApi serverApi, ILoggerFactory loggerFactory);
    public sealed virtual ConnectionSettings get_ConnectionSettings();
    public sealed virtual IConnection CreateConnection(ServerId serverId, EndPoint endPoint);
}
internal class MongoDB.Driver.Core.Connections.ClientDocumentHelper : object {
    private static Lazy`1<BsonDocument> __driverDocument;
    private static Lazy`1<BsonDocument> __envDocument;
    private static Lazy`1<BsonDocument> __osDocument;
    private static Lazy`1<string> __platformString;
    private static IEnvironmentVariableProvider __environmentVariableProvider;
    private static IFileSystemProvider __fileSystemProvider;
    private static ClientDocumentHelper();
    internal static void Initialize();
    internal static void SetEnvironmentVariableProvider(IEnvironmentVariableProvider environmentVariableProvider);
    internal static void SetFileSystemProvider(IFileSystemProvider fileSystemProvider);
    internal static BsonDocument CreateClientDocument(string applicationName, LibraryInfo libraryInfo);
    internal static BsonDocument CreateClientDocument(string applicationName, BsonDocument driverDocument, BsonDocument osDocument, string platformString, BsonDocument envDocument, LibraryInfo libraryInfo);
    internal static BsonDocument CreateDriverDocument();
    internal static BsonDocument CreateDriverDocument(string driverVersion);
    internal static BsonDocument CreateEnvDocument();
    internal static BsonDocument CreateOSDocument();
    internal static BsonDocument CreateOSDocument(string osType, string osName, string architecture, string osVersion);
    internal static string GetPlatformString();
    internal static BsonDocument RemoveOneOptionalField(BsonDocument clientDocument);
    internal static BsonDocument RemoveOptionalFieldsUntilDocumentIsLessThan512Bytes(BsonDocument clientDocument);
    private static BsonDocument AppendLibraryInfoToDriverDocument(BsonDocument driverDocument, LibraryInfo libraryInfo);
    private static bool TryGetType(string typeName, Type& type);
    private static string GetAssemblyVersion(Assembly assembly);
    [CompilerGeneratedAttribute]
internal static string <CreateEnvDocument>g__GetName|14_0();
    [CompilerGeneratedAttribute]
internal static string <CreateEnvDocument>g__GetRegion|14_1(string name);
    [CompilerGeneratedAttribute]
internal static Nullable`1<int> <CreateEnvDocument>g__GetMemoryMb|14_2(string name);
    [CompilerGeneratedAttribute]
internal static Nullable`1<int> <CreateEnvDocument>g__GetTimeoutSec|14_3(string name);
    [CompilerGeneratedAttribute]
internal static BsonDocument <CreateEnvDocument>g__GetContainerDocument|14_4();
    [CompilerGeneratedAttribute]
internal static Nullable`1<int> <CreateEnvDocument>g__GetIntValue|14_5(string environmentVariable);
    [CompilerGeneratedAttribute]
internal static bool <RemoveOneOptionalField>g__TryRemoveElement|18_0(BsonDocument document, string elementName, bool onlyLeaveElement);
    [CompilerGeneratedAttribute]
internal static void <RemoveOneOptionalField>g__RemoveAll|18_1(BsonDocument document, string protectedField);
}
internal class MongoDB.Driver.Core.Connections.CommandEventHelper : object {
    private EventLogger`1<Command> _eventLogger;
    private ConcurrentDictionary`2<int, CommandState> _state;
    private bool _shouldProcessRequestMessages;
    private bool _shouldTrackState;
    private bool _shouldTrackFailed;
    private bool _shouldTrackSucceeded;
    public bool ShouldCallBeforeSending { get; }
    public bool ShouldCallAfterSending { get; }
    public bool ShouldCallErrorSending { get; }
    public bool ShouldCallAfterReceiving { get; }
    public bool ShouldCallErrorReceiving { get; }
    public CommandEventHelper(EventLogger`1<Command> eventLogger);
    public bool get_ShouldCallBeforeSending();
    public bool get_ShouldCallAfterSending();
    public bool get_ShouldCallErrorSending();
    public bool get_ShouldCallAfterReceiving();
    public bool get_ShouldCallErrorReceiving();
    public void BeforeSending(IEnumerable`1<RequestMessage> messages, ConnectionId connectionId, Nullable`1<ObjectId> serviceId, IByteBuffer buffer, MessageEncoderSettings encoderSettings, Stopwatch stopwatch, bool skipLogging);
    public void AfterSending(IEnumerable`1<RequestMessage> messages, ConnectionId connectionId, Nullable`1<ObjectId> serviceId, bool skipLogging);
    public void ErrorSending(IEnumerable`1<RequestMessage> messages, ConnectionId connectionId, Nullable`1<ObjectId> serviceId, Exception exception, bool skipLogging);
    public void AfterReceiving(ResponseMessage message, IByteBuffer buffer, ConnectionId connectionId, Nullable`1<ObjectId> serviceId, MessageEncoderSettings encoderSettings, bool skipLogging);
    public void ErrorReceiving(int responseTo, ConnectionId connectionId, Nullable`1<ObjectId> serviceId, Exception exception, bool skipLogging);
    public void ConnectionFailed(ConnectionId connectionId, Nullable`1<ObjectId> serviceId, Exception exception, bool skipLogging);
    private void ProcessRequestMessages(Queue`1<RequestMessage> messageQueue, ConnectionId connectionId, Nullable`1<ObjectId> serviceId, Stream stream, MessageEncoderSettings encoderSettings, Stopwatch stopwatch, bool skipLogging);
    private void ProcessCommandRequestMessage(CommandRequestMessage originalMessage, Queue`1<RequestMessage> messageQueue, ConnectionId connectionId, Nullable`1<ObjectId> serviceId, CommandMessageBinaryEncoder encoder, Stopwatch stopwatch, bool skipLogging);
    private void ProcessCommandResponseMessage(CommandState state, CommandResponseMessage message, IByteBuffer buffer, ConnectionId connectionId, Nullable`1<ObjectId> serviceId, MessageEncoderSettings encoderSettings, bool skipLogging);
    private void ProcessQueryMessage(QueryMessage originalMessage, ConnectionId connectionId, QueryMessageBinaryEncoder encoder, Stopwatch stopwatch, bool skipLogging);
    private void ProcessReplyMessage(CommandState state, ResponseMessage message, IByteBuffer buffer, ConnectionId connectionId, MessageEncoderSettings encoderSettings, bool skipLogging);
    private void ProcessCommandReplyMessage(CommandState state, ReplyMessage`1<RawBsonDocument> replyMessage, ConnectionId connectionId, bool skipLogging);
    private void ProcessQueryReplyMessage(CommandState state, ReplyMessage`1<RawBsonDocument> replyMessage, ConnectionId connectionId, bool skipLogging);
    private BsonDocument BuildFindCommandFromQuery(QueryMessage message);
    private static bool IsCommand(CollectionNamespace collectionNamespace);
    private static bool ShouldRedactCommand(BsonDocument command);
}
public class MongoDB.Driver.Core.Connections.ConnectionDescription : object {
    private IReadOnlyList`1<CompressorType> _compressors;
    private ConnectionId _connectionId;
    private HelloResult _helloResult;
    private int _maxBatchCount;
    private int _maxDocumentSize;
    private int _maxMessageSize;
    private int _maxWireVersion;
    private int _minWireVersion;
    private SemanticVersion _serverVersion;
    private Nullable`1<ObjectId> _serviceId;
    public IReadOnlyList`1<CompressorType> AvailableCompressors { get; }
    public ConnectionId ConnectionId { get; }
    public HelloResult HelloResult { get; }
    [ObsoleteAttribute("Use HelloResult instead.")]
public IsMasterResult IsMasterResult { get; }
    public int MaxBatchCount { get; }
    public int MaxDocumentSize { get; }
    public int MaxMessageSize { get; }
    public int MaxWireDocumentSize { get; }
    public int MaxWireVersion { get; }
    public int MinWireVersion { get; }
    [ObsoleteAttribute("Use MaxWireVersion instead.")]
public SemanticVersion ServerVersion { get; }
    public Nullable`1<ObjectId> ServiceId { get; }
    public ConnectionDescription(ConnectionId connectionId, HelloResult helloResult);
    public IReadOnlyList`1<CompressorType> get_AvailableCompressors();
    public ConnectionId get_ConnectionId();
    public HelloResult get_HelloResult();
    public IsMasterResult get_IsMasterResult();
    public int get_MaxBatchCount();
    public int get_MaxDocumentSize();
    public int get_MaxMessageSize();
    public int get_MaxWireDocumentSize();
    public int get_MaxWireVersion();
    public int get_MinWireVersion();
    public SemanticVersion get_ServerVersion();
    public Nullable`1<ObjectId> get_ServiceId();
    public sealed virtual bool Equals(ConnectionDescription other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public ConnectionDescription WithConnectionId(ConnectionId value);
}
[ExtensionAttribute]
internal static class MongoDB.Driver.Core.Connections.ConnectionDescriptionExtensions : object {
    [ExtensionAttribute]
public static bool IsInitialized(ConnectionDescription description);
}
[ExtensionAttribute]
internal static class MongoDB.Driver.Core.Connections.ConnectionExtensions : object {
    [ExtensionAttribute]
public static void SendMessage(IConnection connection, RequestMessage message, MessageEncoderSettings messageEncoderSettings, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task SendMessageAsync(IConnection connection, RequestMessage message, MessageEncoderSettings messageEncoderSettings, CancellationToken cancellationToken);
}
public class MongoDB.Driver.Core.Connections.ConnectionId : object {
    private ServerId _serverId;
    private long _localValue;
    private Nullable`1<long> _serverValue;
    private int _hashCode;
    public ServerId ServerId { get; }
    [ObsoleteAttribute("Use LongLocalValue instead.")]
public int LocalValue { get; }
    public long LongLocalValue { get; }
    [ObsoleteAttribute("Use LongServerValue instead.")]
public Nullable`1<int> ServerValue { get; }
    public Nullable`1<long> LongServerValue { get; }
    public ConnectionId(ServerId serverId);
    public ConnectionId(ServerId serverId, long localValue);
    private ConnectionId(ServerId serverId, long localValue, long serverValue);
    public ServerId get_ServerId();
    public int get_LocalValue();
    public long get_LongLocalValue();
    public Nullable`1<int> get_ServerValue();
    public Nullable`1<long> get_LongServerValue();
    public sealed virtual bool Equals(ConnectionId other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public bool StructurallyEquals(ConnectionId other);
    public virtual string ToString();
    public ConnectionId WithServerValue(long serverValue);
}
internal class MongoDB.Driver.Core.Connections.ConnectionInitializer : object {
    private BsonDocument _clientDocument;
    private IReadOnlyList`1<CompressorConfiguration> _compressors;
    private ServerApi _serverApi;
    public ConnectionInitializer(string applicationName, IReadOnlyList`1<CompressorConfiguration> compressors, ServerApi serverApi, LibraryInfo libraryInfo);
    public sealed virtual ConnectionInitializerContext Authenticate(IConnection connection, ConnectionInitializerContext connectionInitializerContext, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MongoDB.Driver.Core.Connections.ConnectionInitializer/<AuthenticateAsync>d__5")]
public sealed virtual Task`1<ConnectionInitializerContext> AuthenticateAsync(IConnection connection, ConnectionInitializerContext connectionInitializerContext, CancellationToken cancellationToken);
    public sealed virtual ConnectionInitializerContext SendHello(IConnection connection, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MongoDB.Driver.Core.Connections.ConnectionInitializer/<SendHelloAsync>d__7")]
public sealed virtual Task`1<ConnectionInitializerContext> SendHelloAsync(IConnection connection, CancellationToken cancellationToken);
    private CommandWireProtocol`1<BsonDocument> CreateGetLastErrorProtocol(ServerApi serverApi);
    private BsonDocument CreateInitialHelloCommand(IReadOnlyList`1<IAuthenticator> authenticators, bool loadBalanced, CancellationToken cancellationToken);
    private List`1<IAuthenticator> CreateAuthenticators(IConnection connection);
    private ConnectionDescription UpdateConnectionIdWithServerValue(ConnectionDescription description, BsonDocument getLastErrorResult);
    private ConnectionDescription UpdateConnectionIdWithServerValue(ConnectionDescription description, long serverValue);
}
internal class MongoDB.Driver.Core.Connections.ConnectionInitializerContext : object {
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<IAuthenticator> <Authenticators>k__BackingField;
    [CompilerGeneratedAttribute]
private ConnectionDescription <Description>k__BackingField;
    public IReadOnlyList`1<IAuthenticator> Authenticators { get; }
    public ConnectionDescription Description { get; }
    public ConnectionInitializerContext(ConnectionDescription description, IReadOnlyList`1<IAuthenticator> authenticators);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<IAuthenticator> get_Authenticators();
    [CompilerGeneratedAttribute]
public ConnectionDescription get_Description();
}
internal static class MongoDB.Driver.Core.Connections.HelloHelper : object {
    internal static BsonDocument AddClientDocumentToCommand(BsonDocument command, BsonDocument clientDocument);
    internal static BsonDocument AddCompressorsToCommand(BsonDocument command, IEnumerable`1<CompressorConfiguration> compressors);
    internal static BsonDocument CreateCommand(ServerApi serverApi, bool helloOk, TopologyVersion topologyVersion, Nullable`1<TimeSpan> maxAwaitTime, bool loadBalanced);
    internal static BsonDocument CustomizeCommand(BsonDocument command, IReadOnlyList`1<IAuthenticator> authenticators, CancellationToken cancellationToken);
    internal static CommandWireProtocol`1<BsonDocument> CreateProtocol(BsonDocument helloCommand, ServerApi serverApi, CommandResponseHandling commandResponseHandling);
    internal static HelloResult GetResult(IConnection connection, CommandWireProtocol`1<BsonDocument> helloProtocol, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MongoDB.Driver.Core.Connections.HelloHelper/<GetResultAsync>d__6")]
internal static Task`1<HelloResult> GetResultAsync(IConnection connection, CommandWireProtocol`1<BsonDocument> helloProtocol, CancellationToken cancellationToken);
}
public class MongoDB.Driver.Core.Connections.HelloResult : object {
    private BsonDocument _wrapped;
    public IReadOnlyList`1<CompressorType> Compressions { get; }
    public Nullable`1<long> ConnectionIdServerValue { get; }
    public ElectionId ElectionId { get; }
    public bool HasSaslSupportedMechs { get; }
    public bool IsArbiter { get; }
    public bool IsMongocryptd { get; }
    public bool IsReplicaSetMember { get; }
    public Nullable`1<DateTime> LastWriteTimestamp { get; }
    public Nullable`1<TimeSpan> LogicalSessionTimeout { get; }
    public int MaxBatchCount { get; }
    public int MaxDocumentSize { get; }
    public int MaxMessageSize { get; }
    public EndPoint Me { get; }
    public IEnumerable`1<string> SaslSupportedMechs { get; }
    public ServerType ServerType { get; }
    public Nullable`1<ObjectId> ServiceId { get; }
    public BsonDocument SpeculativeAuthenticate { get; }
    public TagSet Tags { get; }
    public TopologyVersion TopologyVersion { get; }
    public int MaxWireVersion { get; }
    public int MinWireVersion { get; }
    public BsonDocument Wrapped { get; }
    public bool HelloOk { get; }
    public HelloResult(BsonDocument wrapped);
    public IReadOnlyList`1<CompressorType> get_Compressions();
    public Nullable`1<long> get_ConnectionIdServerValue();
    public ElectionId get_ElectionId();
    public bool get_HasSaslSupportedMechs();
    public bool get_IsArbiter();
    public bool get_IsMongocryptd();
    public bool get_IsReplicaSetMember();
    public Nullable`1<DateTime> get_LastWriteTimestamp();
    public Nullable`1<TimeSpan> get_LogicalSessionTimeout();
    public int get_MaxBatchCount();
    public int get_MaxDocumentSize();
    public int get_MaxMessageSize();
    public EndPoint get_Me();
    public IEnumerable`1<string> get_SaslSupportedMechs();
    public ServerType get_ServerType();
    public Nullable`1<ObjectId> get_ServiceId();
    public BsonDocument get_SpeculativeAuthenticate();
    public TagSet get_Tags();
    public TopologyVersion get_TopologyVersion();
    public int get_MaxWireVersion();
    public int get_MinWireVersion();
    public BsonDocument get_Wrapped();
    public bool get_HelloOk();
    public sealed virtual bool Equals(HelloResult other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    private List`1<EndPoint> GetMembers();
    private IEnumerable`1<EndPoint> GetMembers(string elementName);
    private EndPoint GetPrimary();
    public ReplicaSetConfig GetReplicaSetConfig();
}
public interface MongoDB.Driver.Core.Connections.IConnection {
    public ConnectionId ConnectionId { get; }
    public ConnectionDescription Description { get; }
    public EndPoint EndPoint { get; }
    public int Generation { get; }
    public bool IsExpired { get; }
    public ConnectionSettings Settings { get; }
    public abstract virtual ConnectionId get_ConnectionId();
    public abstract virtual ConnectionDescription get_Description();
    public abstract virtual EndPoint get_EndPoint();
    public abstract virtual int get_Generation();
    public abstract virtual bool get_IsExpired();
    public abstract virtual ConnectionSettings get_Settings();
    public abstract virtual void SetReadTimeout(TimeSpan timeout);
    public abstract virtual void Open(CancellationToken cancellationToken);
    public abstract virtual Task OpenAsync(CancellationToken cancellationToken);
    public abstract virtual void Reauthenticate(CancellationToken cancellationToken);
    public abstract virtual Task ReauthenticateAsync(CancellationToken cancellationToken);
    public abstract virtual ResponseMessage ReceiveMessage(int responseTo, IMessageEncoderSelector encoderSelector, MessageEncoderSettings messageEncoderSettings, CancellationToken cancellationToken);
    public abstract virtual Task`1<ResponseMessage> ReceiveMessageAsync(int responseTo, IMessageEncoderSelector encoderSelector, MessageEncoderSettings messageEncoderSettings, CancellationToken cancellationToken);
    public abstract virtual void SendMessages(IEnumerable`1<RequestMessage> messages, MessageEncoderSettings messageEncoderSettings, CancellationToken cancellationToken);
    public abstract virtual Task SendMessagesAsync(IEnumerable`1<RequestMessage> messages, MessageEncoderSettings messageEncoderSettings, CancellationToken cancellationToken);
}
public interface MongoDB.Driver.Core.Connections.IConnectionFactory {
    public ConnectionSettings ConnectionSettings { get; }
    public abstract virtual ConnectionSettings get_ConnectionSettings();
    public abstract virtual IConnection CreateConnection(ServerId serverId, EndPoint endPoint);
}
public interface MongoDB.Driver.Core.Connections.IConnectionHandle {
    public abstract virtual IConnectionHandle Fork();
}
internal interface MongoDB.Driver.Core.Connections.IConnectionInitializer {
    public abstract virtual ConnectionInitializerContext Authenticate(IConnection connection, ConnectionInitializerContext connectionInitializerContext, CancellationToken cancellationToken);
    public abstract virtual Task`1<ConnectionInitializerContext> AuthenticateAsync(IConnection connection, ConnectionInitializerContext connectionInitializerContext, CancellationToken cancellationToken);
    public abstract virtual ConnectionInitializerContext SendHello(IConnection connection, CancellationToken cancellationToken);
    public abstract virtual Task`1<ConnectionInitializerContext> SendHelloAsync(IConnection connection, CancellationToken cancellationToken);
}
[ObsoleteAttribute("Use HelloResult instead.")]
public class MongoDB.Driver.Core.Connections.IsMasterResult : HelloResult {
    public IsMasterResult(BsonDocument wrapped);
}
public interface MongoDB.Driver.Core.Connections.IStreamFactory {
    public abstract virtual Stream CreateStream(EndPoint endPoint, CancellationToken cancellationToken);
    public abstract virtual Task`1<Stream> CreateStreamAsync(EndPoint endPoint, CancellationToken cancellationToken);
}
internal class MongoDB.Driver.Core.Connections.KeepAliveValues : ValueType {
    [CompilerGeneratedAttribute]
private UInt32 <OnOff>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <KeepAliveTime>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <KeepAliveInterval>k__BackingField;
    public UInt32 OnOff { get; public set; }
    public UInt32 KeepAliveTime { get; public set; }
    public UInt32 KeepAliveInterval { get; public set; }
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public UInt32 get_OnOff();
    [CompilerGeneratedAttribute]
public void set_OnOff(UInt32 value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public UInt32 get_KeepAliveTime();
    [CompilerGeneratedAttribute]
public void set_KeepAliveTime(UInt32 value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public UInt32 get_KeepAliveInterval();
    [CompilerGeneratedAttribute]
public void set_KeepAliveInterval(UInt32 value);
    public Byte[] ToBytes();
}
internal class MongoDB.Driver.Core.Connections.SslStreamFactory : object {
    private SslStreamSettings _settings;
    private IStreamFactory _wrapped;
    public SslStreamFactory(SslStreamSettings settings, IStreamFactory wrapped);
    public sealed virtual Stream CreateStream(EndPoint endPoint, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MongoDB.Driver.Core.Connections.SslStreamFactory/<CreateStreamAsync>d__4")]
public sealed virtual Task`1<Stream> CreateStreamAsync(EndPoint endPoint, CancellationToken cancellationToken);
    private SslStream CreateSslStream(Stream stream);
    private void DisposeStreamIgnoringExceptions(Stream stream);
    private string GetTargetHost(EndPoint endPoint);
}
internal class MongoDB.Driver.Core.Connections.TcpStreamFactory : object {
    private TcpStreamSettings _settings;
    public TcpStreamFactory(TcpStreamSettings settings);
    public sealed virtual Stream CreateStream(EndPoint endPoint, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MongoDB.Driver.Core.Connections.TcpStreamFactory/<CreateStreamAsync>d__4")]
public sealed virtual Task`1<Stream> CreateStreamAsync(EndPoint endPoint, CancellationToken cancellationToken);
    private void ConfigureConnectedSocket(Socket socket);
    private void Connect(Socket socket, EndPoint endPoint, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MongoDB.Driver.Core.Connections.TcpStreamFactory/<ConnectAsync>d__7")]
private Task ConnectAsync(Socket socket, EndPoint endPoint, CancellationToken cancellationToken);
    private NetworkStream CreateNetworkStream(Socket socket);
    private Socket CreateSocket(EndPoint endPoint);
    private EndPoint[] ResolveEndPoints(EndPoint initial);
    [AsyncStateMachineAttribute("MongoDB.Driver.Core.Connections.TcpStreamFactory/<ResolveEndPointsAsync>d__11")]
private Task`1<EndPoint[]> ResolveEndPointsAsync(EndPoint initial);
}
internal static class MongoDB.Driver.Core.Encryption.KmsProvidersEqualityHelper : object {
    public static bool Equals(IReadOnlyDictionary`2<string, IReadOnlyDictionary`2<string, object>> x, IReadOnlyDictionary`2<string, IReadOnlyDictionary`2<string, object>> y);
    private static bool KmsProviderIsEquivalentTo(IReadOnlyDictionary`2<string, object> x, IReadOnlyDictionary`2<string, object> y);
    private static bool KmsProviderOptionEquals(object x, object y);
}
public class MongoDB.Driver.Core.Events.ClusterAddedServerEvent : ValueType {
    private TimeSpan _duration;
    private ServerId _serverId;
    private DateTime _timestamp;
    public ClusterId ClusterId { get; }
    public TimeSpan Duration { get; }
    public ServerId ServerId { get; }
    public DateTime Timestamp { get; }
    private EventType MongoDB.Driver.Core.Events.IEvent.Type { get; }
    public ClusterAddedServerEvent(ServerId serverId, TimeSpan duration);
    public ClusterId get_ClusterId();
    public TimeSpan get_Duration();
    public ServerId get_ServerId();
    public DateTime get_Timestamp();
    private sealed virtual override EventType MongoDB.Driver.Core.Events.IEvent.get_Type();
}
public class MongoDB.Driver.Core.Events.ClusterAddingServerEvent : ValueType {
    private ClusterId _clusterId;
    private EndPoint _endPoint;
    private DateTime _timestamp;
    public ClusterId ClusterId { get; }
    public EndPoint EndPoint { get; }
    public DateTime Timestamp { get; }
    private EventType MongoDB.Driver.Core.Events.IEvent.Type { get; }
    public ClusterAddingServerEvent(ClusterId clusterId, EndPoint endPoint);
    public ClusterId get_ClusterId();
    public EndPoint get_EndPoint();
    public DateTime get_Timestamp();
    private sealed virtual override EventType MongoDB.Driver.Core.Events.IEvent.get_Type();
}
public class MongoDB.Driver.Core.Events.ClusterClosedEvent : ValueType {
    private ClusterId _clusterId;
    private TimeSpan _duration;
    private DateTime _timestamp;
    public ClusterId ClusterId { get; }
    public TimeSpan Duration { get; }
    public DateTime Timestamp { get; }
    private EventType MongoDB.Driver.Core.Events.IEvent.Type { get; }
    public ClusterClosedEvent(ClusterId clusterId, TimeSpan duration);
    public ClusterId get_ClusterId();
    public TimeSpan get_Duration();
    public DateTime get_Timestamp();
    private sealed virtual override EventType MongoDB.Driver.Core.Events.IEvent.get_Type();
}
public class MongoDB.Driver.Core.Events.ClusterClosingEvent : ValueType {
    private ClusterId _clusterId;
    private DateTime _timestamp;
    public ClusterId ClusterId { get; }
    public DateTime Timestamp { get; }
    private EventType MongoDB.Driver.Core.Events.IEvent.Type { get; }
    public ClusterClosingEvent(ClusterId clusterId);
    public ClusterId get_ClusterId();
    public DateTime get_Timestamp();
    private sealed virtual override EventType MongoDB.Driver.Core.Events.IEvent.get_Type();
}
public class MongoDB.Driver.Core.Events.ClusterDescriptionChangedEvent : ValueType {
    private ClusterDescription _oldDescription;
    private ClusterDescription _newDescription;
    private DateTime _timestamp;
    public ClusterId ClusterId { get; }
    public ClusterDescription OldDescription { get; }
    public ClusterDescription NewDescription { get; }
    public DateTime Timestamp { get; }
    private EventType MongoDB.Driver.Core.Events.IEvent.Type { get; }
    public ClusterDescriptionChangedEvent(ClusterDescription oldDescription, ClusterDescription newDescription);
    public ClusterId get_ClusterId();
    public ClusterDescription get_OldDescription();
    public ClusterDescription get_NewDescription();
    public DateTime get_Timestamp();
    private sealed virtual override EventType MongoDB.Driver.Core.Events.IEvent.get_Type();
}
internal class MongoDB.Driver.Core.Events.ClusterEnteredSelectionQueueEvent : ValueType {
    [CompilerGeneratedAttribute]
private ClusterDescription <ClusterDescription>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <OperationId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OperationName>k__BackingField;
    [CompilerGeneratedAttribute]
private IServerSelector <ServerSelector>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <RemainingTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <Timestamp>k__BackingField;
    public ClusterDescription ClusterDescription { get; }
    public Nullable`1<long> OperationId { get; }
    public string OperationName { get; }
    public IServerSelector ServerSelector { get; }
    public TimeSpan RemainingTimeout { get; }
    public DateTime Timestamp { get; }
    public ClusterId ClusterId { get; }
    private EventType MongoDB.Driver.Core.Events.IEvent.Type { get; }
    public ClusterEnteredSelectionQueueEvent(ClusterDescription clusterDescription, IServerSelector serverSelector, Nullable`1<long> operationId, string operationName, TimeSpan remainingTimeout);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ClusterDescription get_ClusterDescription();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Nullable`1<long> get_OperationId();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_OperationName();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public IServerSelector get_ServerSelector();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public TimeSpan get_RemainingTimeout();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public DateTime get_Timestamp();
    public ClusterId get_ClusterId();
    private sealed virtual override EventType MongoDB.Driver.Core.Events.IEvent.get_Type();
}
public class MongoDB.Driver.Core.Events.ClusterOpenedEvent : ValueType {
    private ClusterId _clusterId;
    private ClusterSettings _clusterSettings;
    private TimeSpan _duration;
    private DateTime _timestamp;
    public ClusterId ClusterId { get; }
    public ClusterSettings ClusterSettings { get; }
    public TimeSpan Duration { get; }
    public DateTime Timestamp { get; }
    private EventType MongoDB.Driver.Core.Events.IEvent.Type { get; }
    public ClusterOpenedEvent(ClusterId clusterId, ClusterSettings clusterSettings, TimeSpan duration);
    public ClusterId get_ClusterId();
    public ClusterSettings get_ClusterSettings();
    public TimeSpan get_Duration();
    public DateTime get_Timestamp();
    private sealed virtual override EventType MongoDB.Driver.Core.Events.IEvent.get_Type();
}
public class MongoDB.Driver.Core.Events.ClusterOpeningEvent : ValueType {
    private ClusterId _clusterId;
    private ClusterSettings _clusterSettings;
    private DateTime _timestamp;
    public ClusterId ClusterId { get; }
    public ClusterSettings ClusterSettings { get; }
    public DateTime Timestamp { get; }
    private EventType MongoDB.Driver.Core.Events.IEvent.Type { get; }
    public ClusterOpeningEvent(ClusterId clusterId, ClusterSettings clusterSettings);
    public ClusterId get_ClusterId();
    public ClusterSettings get_ClusterSettings();
    public DateTime get_Timestamp();
    private sealed virtual override EventType MongoDB.Driver.Core.Events.IEvent.get_Type();
}
public class MongoDB.Driver.Core.Events.ClusterRemovedServerEvent : ValueType {
    private TimeSpan _duration;
    private string _reason;
    private ServerId _serverId;
    private DateTime _timestamp;
    public ClusterId ClusterId { get; }
    public TimeSpan Duration { get; }
    public string Reason { get; }
    public ServerId ServerId { get; }
    public DateTime Timestamp { get; }
    private EventType MongoDB.Driver.Core.Events.IEvent.Type { get; }
    public ClusterRemovedServerEvent(ServerId serverId, string reason, TimeSpan duration);
    public ClusterId get_ClusterId();
    public TimeSpan get_Duration();
    public string get_Reason();
    public ServerId get_ServerId();
    public DateTime get_Timestamp();
    private sealed virtual override EventType MongoDB.Driver.Core.Events.IEvent.get_Type();
}
public class MongoDB.Driver.Core.Events.ClusterRemovingServerEvent : ValueType {
    private string _reason;
    private ServerId _serverId;
    private DateTime _timestamp;
    public ClusterId ClusterId { get; }
    public string Reason { get; }
    public ServerId ServerId { get; }
    public DateTime Timestamp { get; }
    private EventType MongoDB.Driver.Core.Events.IEvent.Type { get; }
    public ClusterRemovingServerEvent(ServerId serverId, string reason);
    public ClusterId get_ClusterId();
    public string get_Reason();
    public ServerId get_ServerId();
    public DateTime get_Timestamp();
    private sealed virtual override EventType MongoDB.Driver.Core.Events.IEvent.get_Type();
}
public class MongoDB.Driver.Core.Events.ClusterSelectedServerEvent : ValueType {
    private ClusterDescription _clusterDescription;
    private TimeSpan _duration;
    private Nullable`1<long> _operationId;
    private string _operationName;
    private IServerSelector _serverSelector;
    private ServerDescription _selectedServer;
    private DateTime _timestamp;
    public ClusterId ClusterId { get; }
    public ClusterDescription ClusterDescription { get; }
    public TimeSpan Duration { get; }
    public Nullable`1<long> OperationId { get; }
    public string OperationName { get; }
    public IServerSelector ServerSelector { get; }
    public ServerDescription SelectedServer { get; }
    public DateTime Timestamp { get; }
    private EventType MongoDB.Driver.Core.Events.IEvent.Type { get; }
    public ClusterSelectedServerEvent(ClusterDescription clusterDescription, IServerSelector serverSelector, ServerDescription selectedServer, TimeSpan duration, Nullable`1<long> operationId, string operationName);
    public ClusterId get_ClusterId();
    public ClusterDescription get_ClusterDescription();
    public TimeSpan get_Duration();
    public Nullable`1<long> get_OperationId();
    public string get_OperationName();
    public IServerSelector get_ServerSelector();
    public ServerDescription get_SelectedServer();
    public DateTime get_Timestamp();
    private sealed virtual override EventType MongoDB.Driver.Core.Events.IEvent.get_Type();
}
public class MongoDB.Driver.Core.Events.ClusterSelectingServerEvent : ValueType {
    private ClusterDescription _clusterDescription;
    private Nullable`1<long> _operationId;
    private string _operationName;
    private IServerSelector _serverSelector;
    private DateTime _timestamp;
    public ClusterId ClusterId { get; }
    public ClusterDescription ClusterDescription { get; }
    public Nullable`1<long> OperationId { get; }
    public string OperationName { get; }
    public IServerSelector ServerSelector { get; }
    public DateTime Timestamp { get; }
    private EventType MongoDB.Driver.Core.Events.IEvent.Type { get; }
    public ClusterSelectingServerEvent(ClusterDescription clusterDescription, IServerSelector serverSelector, Nullable`1<long> operationId, string operationName);
    public ClusterId get_ClusterId();
    public ClusterDescription get_ClusterDescription();
    public Nullable`1<long> get_OperationId();
    public string get_OperationName();
    public IServerSelector get_ServerSelector();
    public DateTime get_Timestamp();
    private sealed virtual override EventType MongoDB.Driver.Core.Events.IEvent.get_Type();
}
public class MongoDB.Driver.Core.Events.ClusterSelectingServerFailedEvent : ValueType {
    private ClusterDescription _clusterDescription;
    private Exception _exception;
    private Nullable`1<long> _operationId;
    private string _operationName;
    private IServerSelector _serverSelector;
    private DateTime _timestamp;
    public ClusterId ClusterId { get; }
    public ClusterDescription ClusterDescription { get; }
    public Exception Exception { get; }
    public Nullable`1<long> OperationId { get; }
    public string OperationName { get; }
    public IServerSelector ServerSelector { get; }
    public DateTime Timestamp { get; }
    private EventType MongoDB.Driver.Core.Events.IEvent.Type { get; }
    public ClusterSelectingServerFailedEvent(ClusterDescription clusterDescription, IServerSelector serverSelector, Exception exception, Nullable`1<long> operationId, string operationName);
    public ClusterId get_ClusterId();
    public ClusterDescription get_ClusterDescription();
    public Exception get_Exception();
    public Nullable`1<long> get_OperationId();
    public string get_OperationName();
    public IServerSelector get_ServerSelector();
    public DateTime get_Timestamp();
    private sealed virtual override EventType MongoDB.Driver.Core.Events.IEvent.get_Type();
}
public class MongoDB.Driver.Core.Events.CommandFailedEvent : ValueType {
    private string _commandName;
    private ConnectionId _connectionId;
    private DatabaseNamespace _databaseNamespace;
    private TimeSpan _duration;
    private Exception _exception;
    private Nullable`1<long> _operationId;
    private int _requestId;
    private Nullable`1<ObjectId> _serviceId;
    private DateTime _timestamp;
    public string CommandName { get; }
    public ConnectionId ConnectionId { get; }
    public DatabaseNamespace DatabaseNamespace { get; }
    public TimeSpan Duration { get; }
    public Exception Failure { get; }
    public Nullable`1<long> OperationId { get; }
    public int RequestId { get; }
    public Nullable`1<ObjectId> ServiceId { get; }
    public DateTime Timestamp { get; }
    private EventType MongoDB.Driver.Core.Events.IEvent.Type { get; }
    public CommandFailedEvent(string commandName, DatabaseNamespace databaseNamespace, Exception exception, Nullable`1<long> operationId, int requestId, ConnectionId connectionId, TimeSpan duration);
    public CommandFailedEvent(string commandName, DatabaseNamespace databaseNamespace, Exception exception, Nullable`1<long> operationId, int requestId, ConnectionId connectionId, Nullable`1<ObjectId> serviceId, TimeSpan duration);
    public string get_CommandName();
    public ConnectionId get_ConnectionId();
    public DatabaseNamespace get_DatabaseNamespace();
    public TimeSpan get_Duration();
    public Exception get_Failure();
    public Nullable`1<long> get_OperationId();
    public int get_RequestId();
    public Nullable`1<ObjectId> get_ServiceId();
    public DateTime get_Timestamp();
    private sealed virtual override EventType MongoDB.Driver.Core.Events.IEvent.get_Type();
}
public class MongoDB.Driver.Core.Events.CommandStartedEvent : ValueType {
    private BsonDocument _command;
    private string _commandName;
    private ConnectionId _connectionId;
    private DatabaseNamespace _databaseNamespace;
    private Nullable`1<long> _operationId;
    private int _requestId;
    private Nullable`1<ObjectId> _serviceId;
    private DateTime _timestamp;
    public BsonDocument Command { get; }
    public string CommandName { get; }
    public ConnectionId ConnectionId { get; }
    public DatabaseNamespace DatabaseNamespace { get; }
    public Nullable`1<long> OperationId { get; }
    public int RequestId { get; }
    public Nullable`1<ObjectId> ServiceId { get; }
    public DateTime Timestamp { get; }
    private EventType MongoDB.Driver.Core.Events.IEvent.Type { get; }
    public CommandStartedEvent(string commandName, BsonDocument command, DatabaseNamespace databaseNamespace, Nullable`1<long> operationId, int requestId, ConnectionId connectionId);
    public CommandStartedEvent(string commandName, BsonDocument command, DatabaseNamespace databaseNamespace, Nullable`1<long> operationId, int requestId, ConnectionId connectionId, Nullable`1<ObjectId> serviceId);
    public BsonDocument get_Command();
    public string get_CommandName();
    public ConnectionId get_ConnectionId();
    public DatabaseNamespace get_DatabaseNamespace();
    public Nullable`1<long> get_OperationId();
    public int get_RequestId();
    public Nullable`1<ObjectId> get_ServiceId();
    public DateTime get_Timestamp();
    private sealed virtual override EventType MongoDB.Driver.Core.Events.IEvent.get_Type();
}
public class MongoDB.Driver.Core.Events.CommandSucceededEvent : ValueType {
    private string _commandName;
    private ConnectionId _connectionId;
    private DatabaseNamespace _databaseNamespace;
    private TimeSpan _duration;
    private Nullable`1<long> _operationId;
    private int _requestId;
    private BsonDocument _reply;
    private Nullable`1<ObjectId> _serviceId;
    private DateTime _timestamp;
    public string CommandName { get; }
    public ConnectionId ConnectionId { get; }
    public DatabaseNamespace DatabaseNamespace { get; }
    public TimeSpan Duration { get; }
    public Nullable`1<long> OperationId { get; }
    public BsonDocument Reply { get; }
    public int RequestId { get; }
    public Nullable`1<ObjectId> ServiceId { get; }
    public DateTime Timestamp { get; }
    private EventType MongoDB.Driver.Core.Events.IEvent.Type { get; }
    public CommandSucceededEvent(string commandName, BsonDocument reply, DatabaseNamespace databaseNamespace, Nullable`1<long> operationId, int requestId, ConnectionId connectionId, TimeSpan duration);
    public CommandSucceededEvent(string commandName, BsonDocument reply, DatabaseNamespace databaseNamespace, Nullable`1<long> operationId, int requestId, ConnectionId connectionId, Nullable`1<ObjectId> serviceId, TimeSpan duration);
    public string get_CommandName();
    public ConnectionId get_ConnectionId();
    public DatabaseNamespace get_DatabaseNamespace();
    public TimeSpan get_Duration();
    public Nullable`1<long> get_OperationId();
    public BsonDocument get_Reply();
    public int get_RequestId();
    public Nullable`1<ObjectId> get_ServiceId();
    public DateTime get_Timestamp();
    private sealed virtual override EventType MongoDB.Driver.Core.Events.IEvent.get_Type();
}
public enum MongoDB.Driver.Core.Events.ConnectionCheckOutFailedReason : Enum {
    public int value__;
    public static ConnectionCheckOutFailedReason PoolClosed;
    public static ConnectionCheckOutFailedReason Timeout;
    public static ConnectionCheckOutFailedReason ConnectionError;
}
public class MongoDB.Driver.Core.Events.ConnectionClosedEvent : ValueType {
    private ConnectionId _connectionId;
    private TimeSpan _duration;
    private Nullable`1<long> _operationId;
    private DateTime _timestamp;
    public ClusterId ClusterId { get; }
    public ConnectionId ConnectionId { get; }
    public TimeSpan Duration { get; }
    public Nullable`1<long> OperationId { get; }
    public ServerId ServerId { get; }
    public DateTime Timestamp { get; }
    private EventType MongoDB.Driver.Core.Events.IEvent.Type { get; }
    public ConnectionClosedEvent(ConnectionId connectionId, TimeSpan duration, Nullable`1<long> operationId);
    public ClusterId get_ClusterId();
    public ConnectionId get_ConnectionId();
    public TimeSpan get_Duration();
    public Nullable`1<long> get_OperationId();
    public ServerId get_ServerId();
    public DateTime get_Timestamp();
    private sealed virtual override EventType MongoDB.Driver.Core.Events.IEvent.get_Type();
}
public enum MongoDB.Driver.Core.Events.ConnectionClosedReason : Enum {
    public int value__;
    public static ConnectionClosedReason Stale;
    public static ConnectionClosedReason Idle;
    public static ConnectionClosedReason Error;
    public static ConnectionClosedReason PoolClosed;
    public static ConnectionClosedReason Unknown;
}
public class MongoDB.Driver.Core.Events.ConnectionClosingEvent : ValueType {
    private ConnectionId _connectionId;
    private Nullable`1<long> _operationId;
    private DateTime _timestamp;
    public ClusterId ClusterId { get; }
    public ConnectionId ConnectionId { get; }
    public Nullable`1<long> OperationId { get; }
    public ServerId ServerId { get; }
    public DateTime Timestamp { get; }
    private EventType MongoDB.Driver.Core.Events.IEvent.Type { get; }
    public ConnectionClosingEvent(ConnectionId connectionId, Nullable`1<long> operationId);
    public ClusterId get_ClusterId();
    public ConnectionId get_ConnectionId();
    public Nullable`1<long> get_OperationId();
    public ServerId get_ServerId();
    public DateTime get_Timestamp();
    private sealed virtual override EventType MongoDB.Driver.Core.Events.IEvent.get_Type();
}
public class MongoDB.Driver.Core.Events.ConnectionCreatedEvent : ValueType {
    private ConnectionId _connectionId;
    private ConnectionSettings _connectionSettings;
    private Nullable`1<long> _operationId;
    private DateTime _timestamp;
    public ClusterId ClusterId { get; }
    public ConnectionId ConnectionId { get; }
    public ConnectionSettings ConnectionSettings { get; }
    public Nullable`1<long> OperationId { get; }
    public ServerId ServerId { get; }
    public DateTime Timestamp { get; }
    private EventType MongoDB.Driver.Core.Events.IEvent.Type { get; }
    public ConnectionCreatedEvent(ConnectionId connectionId, ConnectionSettings connectionSettings, Nullable`1<long> operationId);
    public ClusterId get_ClusterId();
    public ConnectionId get_ConnectionId();
    public ConnectionSettings get_ConnectionSettings();
    public Nullable`1<long> get_OperationId();
    public ServerId get_ServerId();
    public DateTime get_Timestamp();
    private sealed virtual override EventType MongoDB.Driver.Core.Events.IEvent.get_Type();
}
public class MongoDB.Driver.Core.Events.ConnectionFailedEvent : ValueType {
    private ConnectionId _connectionId;
    private Exception _exception;
    private DateTime _timestamp;
    public ClusterId ClusterId { get; }
    public ConnectionId ConnectionId { get; }
    public Exception Exception { get; }
    public ServerId ServerId { get; }
    public DateTime Timestamp { get; }
    private EventType MongoDB.Driver.Core.Events.IEvent.Type { get; }
    public ConnectionFailedEvent(ConnectionId connectionId, Exception exception);
    public ClusterId get_ClusterId();
    public ConnectionId get_ConnectionId();
    public Exception get_Exception();
    public ServerId get_ServerId();
    public DateTime get_Timestamp();
    private sealed virtual override EventType MongoDB.Driver.Core.Events.IEvent.get_Type();
}
public class MongoDB.Driver.Core.Events.ConnectionOpenedEvent : ValueType {
    private ConnectionId _connectionId;
    private ConnectionSettings _connectionSettings;
    private TimeSpan _duration;
    private Nullable`1<long> _operationId;
    private DateTime _timestamp;
    public ClusterId ClusterId { get; }
    public ConnectionId ConnectionId { get; }
    public ConnectionSettings ConnectionSettings { get; }
    public TimeSpan Duration { get; }
    public Nullable`1<long> OperationId { get; }
    public ServerId ServerId { get; }
    public DateTime Timestamp { get; }
    private EventType MongoDB.Driver.Core.Events.IEvent.Type { get; }
    public ConnectionOpenedEvent(ConnectionId connectionId, ConnectionSettings connectionSettings, TimeSpan duration, Nullable`1<long> operationId);
    public ClusterId get_ClusterId();
    public ConnectionId get_ConnectionId();
    public ConnectionSettings get_ConnectionSettings();
    public TimeSpan get_Duration();
    public Nullable`1<long> get_OperationId();
    public ServerId get_ServerId();
    public DateTime get_Timestamp();
    private sealed virtual override EventType MongoDB.Driver.Core.Events.IEvent.get_Type();
}
public class MongoDB.Driver.Core.Events.ConnectionOpeningEvent : ValueType {
    private ConnectionId _connectionId;
    private ConnectionSettings _connectionSettings;
    private Nullable`1<long> _operationId;
    private DateTime _timestamp;
    public ClusterId ClusterId { get; }
    public ConnectionId ConnectionId { get; }
    public ConnectionSettings ConnectionSettings { get; }
    public Nullable`1<long> OperationId { get; }
    public ServerId ServerId { get; }
    public DateTime Timestamp { get; }
    private EventType MongoDB.Driver.Core.Events.IEvent.Type { get; }
    public ConnectionOpeningEvent(ConnectionId connectionId, ConnectionSettings connectionSettings, Nullable`1<long> operationId);
    public ClusterId get_ClusterId();
    public ConnectionId get_ConnectionId();
    public ConnectionSettings get_ConnectionSettings();
    public Nullable`1<long> get_OperationId();
    public ServerId get_ServerId();
    public DateTime get_Timestamp();
    private sealed virtual override EventType MongoDB.Driver.Core.Events.IEvent.get_Type();
}
public class MongoDB.Driver.Core.Events.ConnectionOpeningFailedEvent : ValueType {
    private ConnectionId _connectionId;
    private ConnectionSettings _connectionSettings;
    private Exception _exception;
    private Nullable`1<long> _operationId;
    private DateTime _timestamp;
    public ClusterId ClusterId { get; }
    public ConnectionId ConnectionId { get; }
    public ConnectionSettings ConnectionSettings { get; }
    public Exception Exception { get; }
    public Nullable`1<long> OperationId { get; }
    public ServerId ServerId { get; }
    public DateTime Timestamp { get; }
    private EventType MongoDB.Driver.Core.Events.IEvent.Type { get; }
    public ConnectionOpeningFailedEvent(ConnectionId connectionId, ConnectionSettings connectionSettings, Exception exception, Nullable`1<long> operationId);
    public ClusterId get_ClusterId();
    public ConnectionId get_ConnectionId();
    public ConnectionSettings get_ConnectionSettings();
    public Exception get_Exception();
    public Nullable`1<long> get_OperationId();
    public ServerId get_ServerId();
    public DateTime get_Timestamp();
    private sealed virtual override EventType MongoDB.Driver.Core.Events.IEvent.get_Type();
}
public class MongoDB.Driver.Core.Events.ConnectionPoolAddedConnectionEvent : ValueType {
    private ConnectionId _connectionId;
    private TimeSpan _duration;
    private Nullable`1<long> _operationId;
    private DateTime _timestamp;
    public ClusterId ClusterId { get; }
    public ConnectionId ConnectionId { get; }
    public TimeSpan Duration { get; }
    public Nullable`1<long> OperationId { get; }
    public ServerId ServerId { get; }
    public DateTime Timestamp { get; }
    private EventType MongoDB.Driver.Core.Events.IEvent.Type { get; }
    public ConnectionPoolAddedConnectionEvent(ConnectionId connectionId, TimeSpan duration, Nullable`1<long> operationId);
    public ClusterId get_ClusterId();
    public ConnectionId get_ConnectionId();
    public TimeSpan get_Duration();
    public Nullable`1<long> get_OperationId();
    public ServerId get_ServerId();
    public DateTime get_Timestamp();
    private sealed virtual override EventType MongoDB.Driver.Core.Events.IEvent.get_Type();
}
public class MongoDB.Driver.Core.Events.ConnectionPoolAddingConnectionEvent : ValueType {
    private Nullable`1<long> _operationId;
    private ServerId _serverId;
    private DateTime _timestamp;
    public ClusterId ClusterId { get; }
    public Nullable`1<long> OperationId { get; }
    public ServerId ServerId { get; }
    public DateTime Timestamp { get; }
    private EventType MongoDB.Driver.Core.Events.IEvent.Type { get; }
    public ConnectionPoolAddingConnectionEvent(ServerId serverId, Nullable`1<long> operationId);
    public ClusterId get_ClusterId();
    public Nullable`1<long> get_OperationId();
    public ServerId get_ServerId();
    public DateTime get_Timestamp();
    private sealed virtual override EventType MongoDB.Driver.Core.Events.IEvent.get_Type();
}
public class MongoDB.Driver.Core.Events.ConnectionPoolCheckedInConnectionEvent : ValueType {
    private ConnectionId _connectionId;
    private TimeSpan _duration;
    private Nullable`1<long> _operationId;
    private DateTime _timestamp;
    public ClusterId ClusterId { get; }
    public ConnectionId ConnectionId { get; }
    public TimeSpan Duration { get; }
    public Nullable`1<long> OperationId { get; }
    public ServerId ServerId { get; }
    public DateTime Timestamp { get; }
    private EventType MongoDB.Driver.Core.Events.IEvent.Type { get; }
    public ConnectionPoolCheckedInConnectionEvent(ConnectionId connectionId, TimeSpan duration, Nullable`1<long> operationId);
    public ClusterId get_ClusterId();
    public ConnectionId get_ConnectionId();
    public TimeSpan get_Duration();
    public Nullable`1<long> get_OperationId();
    public ServerId get_ServerId();
    public DateTime get_Timestamp();
    private sealed virtual override EventType MongoDB.Driver.Core.Events.IEvent.get_Type();
}
public class MongoDB.Driver.Core.Events.ConnectionPoolCheckedOutConnectionEvent : ValueType {
    private ConnectionId _connectionId;
    private TimeSpan _duration;
    private Nullable`1<long> _operationId;
    private DateTime _timestamp;
    public ClusterId ClusterId { get; }
    public ConnectionId ConnectionId { get; }
    public TimeSpan Duration { get; }
    public Nullable`1<long> OperationId { get; }
    public ServerId ServerId { get; }
    public DateTime Timestamp { get; }
    private EventType MongoDB.Driver.Core.Events.IEvent.Type { get; }
    public ConnectionPoolCheckedOutConnectionEvent(ConnectionId connectionId, TimeSpan duration, Nullable`1<long> operationId);
    public ClusterId get_ClusterId();
    public ConnectionId get_ConnectionId();
    public TimeSpan get_Duration();
    public Nullable`1<long> get_OperationId();
    public ServerId get_ServerId();
    public DateTime get_Timestamp();
    private sealed virtual override EventType MongoDB.Driver.Core.Events.IEvent.get_Type();
}
public class MongoDB.Driver.Core.Events.ConnectionPoolCheckingInConnectionEvent : ValueType {
    private ConnectionId _connectionId;
    private Nullable`1<long> _operationId;
    private DateTime _timestamp;
    public ClusterId ClusterId { get; }
    public ConnectionId ConnectionId { get; }
    public Nullable`1<long> OperationId { get; }
    public ServerId ServerId { get; }
    public DateTime Timestamp { get; }
    private EventType MongoDB.Driver.Core.Events.IEvent.Type { get; }
    public ConnectionPoolCheckingInConnectionEvent(ConnectionId connectionId, Nullable`1<long> operationId);
    public ClusterId get_ClusterId();
    public ConnectionId get_ConnectionId();
    public Nullable`1<long> get_OperationId();
    public ServerId get_ServerId();
    public DateTime get_Timestamp();
    private sealed virtual override EventType MongoDB.Driver.Core.Events.IEvent.get_Type();
}
public class MongoDB.Driver.Core.Events.ConnectionPoolCheckingOutConnectionEvent : ValueType {
    private Nullable`1<long> _operationId;
    private ServerId _serverId;
    private DateTime _timestamp;
    public ClusterId ClusterId { get; }
    public Nullable`1<long> OperationId { get; }
    public ServerId ServerId { get; }
    public DateTime Timestamp { get; }
    private EventType MongoDB.Driver.Core.Events.IEvent.Type { get; }
    public ConnectionPoolCheckingOutConnectionEvent(ServerId serverId, Nullable`1<long> operationId);
    public ClusterId get_ClusterId();
    public Nullable`1<long> get_OperationId();
    public ServerId get_ServerId();
    public DateTime get_Timestamp();
    private sealed virtual override EventType MongoDB.Driver.Core.Events.IEvent.get_Type();
}
public class MongoDB.Driver.Core.Events.ConnectionPoolCheckingOutConnectionFailedEvent : ValueType {
    private ConnectionCheckOutFailedReason _reason;
    private ServerId _serverId;
    private Exception _exception;
    private Nullable`1<long> _operationId;
    private DateTime _timestamp;
    private TimeSpan _duration;
    public ClusterId ClusterId { get; }
    public Exception Exception { get; }
    public Nullable`1<long> OperationId { get; }
    public ConnectionCheckOutFailedReason Reason { get; }
    public ServerId ServerId { get; }
    public TimeSpan Duration { get; }
    public DateTime Timestamp { get; }
    private EventType MongoDB.Driver.Core.Events.IEvent.Type { get; }
    public ConnectionPoolCheckingOutConnectionFailedEvent(ServerId serverId, Exception exception, Nullable`1<long> operationId, TimeSpan duration, ConnectionCheckOutFailedReason reason);
    public ClusterId get_ClusterId();
    public Exception get_Exception();
    public Nullable`1<long> get_OperationId();
    public ConnectionCheckOutFailedReason get_Reason();
    public ServerId get_ServerId();
    public TimeSpan get_Duration();
    public DateTime get_Timestamp();
    private sealed virtual override EventType MongoDB.Driver.Core.Events.IEvent.get_Type();
}
public class MongoDB.Driver.Core.Events.ConnectionPoolClearedEvent : ValueType {
    private bool _closeInUseConnections;
    private ConnectionPoolSettings _connectionPoolSettings;
    private ServerId _serverId;
    private Nullable`1<ObjectId> _serviceId;
    private DateTime _timestamp;
    public bool CloseInUseConnections { get; }
    public ClusterId ClusterId { get; }
    public ConnectionPoolSettings ConnectionPoolSettings { get; }
    public ServerId ServerId { get; }
    public Nullable`1<ObjectId> ServiceId { get; }
    public DateTime Timestamp { get; }
    private EventType MongoDB.Driver.Core.Events.IEvent.Type { get; }
    public ConnectionPoolClearedEvent(ServerId serverId, ConnectionPoolSettings connectionPoolSettings);
    public ConnectionPoolClearedEvent(ServerId serverId, ConnectionPoolSettings connectionPoolSettings, bool closeInUseConnections);
    public ConnectionPoolClearedEvent(ServerId serverId, ConnectionPoolSettings connectionPoolSettings, Nullable`1<ObjectId> serviceId);
    public ConnectionPoolClearedEvent(ServerId serverId, ConnectionPoolSettings connectionPoolSettings, Nullable`1<ObjectId> serviceId, bool closeInUseConnections);
    public bool get_CloseInUseConnections();
    public ClusterId get_ClusterId();
    public ConnectionPoolSettings get_ConnectionPoolSettings();
    public ServerId get_ServerId();
    public Nullable`1<ObjectId> get_ServiceId();
    public DateTime get_Timestamp();
    private sealed virtual override EventType MongoDB.Driver.Core.Events.IEvent.get_Type();
}
public class MongoDB.Driver.Core.Events.ConnectionPoolClearingEvent : ValueType {
    private bool _closeInUseConnections;
    private ConnectionPoolSettings _connectionPoolSettings;
    private Nullable`1<ObjectId> _serviceId;
    private ServerId _serverId;
    private DateTime _timestamp;
    public bool CloseInUseConnections { get; }
    public ClusterId ClusterId { get; }
    public ConnectionPoolSettings ConnectionPoolSettings { get; }
    public Nullable`1<ObjectId> ServiceId { get; }
    public ServerId ServerId { get; }
    public DateTime Timestamp { get; }
    private EventType MongoDB.Driver.Core.Events.IEvent.Type { get; }
    public ConnectionPoolClearingEvent(ServerId serverId, ConnectionPoolSettings connectionPoolSettings);
    public ConnectionPoolClearingEvent(ServerId serverId, ConnectionPoolSettings connectionPoolSettings, bool closeInUseConnections);
    public ConnectionPoolClearingEvent(ServerId serverId, ConnectionPoolSettings connectionPoolSettings, Nullable`1<ObjectId> serviceId);
    public ConnectionPoolClearingEvent(ServerId serverId, ConnectionPoolSettings connectionPoolSettings, Nullable`1<ObjectId> serviceId, bool closeInUseConnections);
    public bool get_CloseInUseConnections();
    public ClusterId get_ClusterId();
    public ConnectionPoolSettings get_ConnectionPoolSettings();
    public Nullable`1<ObjectId> get_ServiceId();
    public ServerId get_ServerId();
    public DateTime get_Timestamp();
    private sealed virtual override EventType MongoDB.Driver.Core.Events.IEvent.get_Type();
}
public class MongoDB.Driver.Core.Events.ConnectionPoolClosedEvent : ValueType {
    private ServerId _serverId;
    private DateTime _timestamp;
    public ClusterId ClusterId { get; }
    public ServerId ServerId { get; }
    public DateTime Timestamp { get; }
    private EventType MongoDB.Driver.Core.Events.IEvent.Type { get; }
    public ConnectionPoolClosedEvent(ServerId serverId);
    public ClusterId get_ClusterId();
    public ServerId get_ServerId();
    public DateTime get_Timestamp();
    private sealed virtual override EventType MongoDB.Driver.Core.Events.IEvent.get_Type();
}
public class MongoDB.Driver.Core.Events.ConnectionPoolClosingEvent : ValueType {
    private ServerId _serverId;
    private DateTime _timestamp;
    public ClusterId ClusterId { get; }
    public ServerId ServerId { get; }
    public DateTime Timestamp { get; }
    private EventType MongoDB.Driver.Core.Events.IEvent.Type { get; }
    public ConnectionPoolClosingEvent(ServerId serverId);
    public ClusterId get_ClusterId();
    public ServerId get_ServerId();
    public DateTime get_Timestamp();
    private sealed virtual override EventType MongoDB.Driver.Core.Events.IEvent.get_Type();
}
public class MongoDB.Driver.Core.Events.ConnectionPoolOpenedEvent : ValueType {
    private ConnectionPoolSettings _connectionPoolSettings;
    private ServerId _serverId;
    private DateTime _timestamp;
    public ClusterId ClusterId { get; }
    public ConnectionPoolSettings ConnectionPoolSettings { get; }
    public ServerId ServerId { get; }
    public DateTime Timestamp { get; }
    private EventType MongoDB.Driver.Core.Events.IEvent.Type { get; }
    public ConnectionPoolOpenedEvent(ServerId serverId, ConnectionPoolSettings connectionPoolSettings);
    public ClusterId get_ClusterId();
    public ConnectionPoolSettings get_ConnectionPoolSettings();
    public ServerId get_ServerId();
    public DateTime get_Timestamp();
    private sealed virtual override EventType MongoDB.Driver.Core.Events.IEvent.get_Type();
}
public class MongoDB.Driver.Core.Events.ConnectionPoolOpeningEvent : ValueType {
    private ConnectionPoolSettings _connectionPoolSettings;
    private ServerId _serverId;
    private DateTime _timestamp;
    public ClusterId ClusterId { get; }
    public ConnectionPoolSettings ConnectionPoolSettings { get; }
    public ServerId ServerId { get; }
    public DateTime Timestamp { get; }
    private EventType MongoDB.Driver.Core.Events.IEvent.Type { get; }
    public ConnectionPoolOpeningEvent(ServerId serverId, ConnectionPoolSettings connectionPoolSettings);
    public ClusterId get_ClusterId();
    public ConnectionPoolSettings get_ConnectionPoolSettings();
    public ServerId get_ServerId();
    public DateTime get_Timestamp();
    private sealed virtual override EventType MongoDB.Driver.Core.Events.IEvent.get_Type();
}
public class MongoDB.Driver.Core.Events.ConnectionPoolReadyEvent : ValueType {
    private ServerId _serverId;
    private ConnectionPoolSettings _connectionPoolSettings;
    public ClusterId ClusterId { get; }
    public ConnectionPoolSettings ConnectionPoolSettings { get; }
    public ServerId ServerId { get; }
    private EventType MongoDB.Driver.Core.Events.IEvent.Type { get; }
    public ConnectionPoolReadyEvent(ServerId serverId, ConnectionPoolSettings connectionPoolSettings);
    public ClusterId get_ClusterId();
    public ConnectionPoolSettings get_ConnectionPoolSettings();
    public ServerId get_ServerId();
    private sealed virtual override EventType MongoDB.Driver.Core.Events.IEvent.get_Type();
}
public class MongoDB.Driver.Core.Events.ConnectionPoolRemovedConnectionEvent : ValueType {
    private ConnectionId _connectionId;
    private TimeSpan _duration;
    private Nullable`1<long> _operationId;
    private DateTime _timestamp;
    public ClusterId ClusterId { get; }
    public ConnectionId ConnectionId { get; }
    public TimeSpan Duration { get; }
    public Nullable`1<long> OperationId { get; }
    public ServerId ServerId { get; }
    public DateTime Timestamp { get; }
    private EventType MongoDB.Driver.Core.Events.IEvent.Type { get; }
    public ConnectionPoolRemovedConnectionEvent(ConnectionId connectionId, TimeSpan duration, Nullable`1<long> operationId);
    public ClusterId get_ClusterId();
    public ConnectionId get_ConnectionId();
    public TimeSpan get_Duration();
    public Nullable`1<long> get_OperationId();
    public ServerId get_ServerId();
    public DateTime get_Timestamp();
    private sealed virtual override EventType MongoDB.Driver.Core.Events.IEvent.get_Type();
}
public class MongoDB.Driver.Core.Events.ConnectionPoolRemovingConnectionEvent : ValueType {
    private ConnectionId _connectionId;
    private Nullable`1<long> _operationId;
    private DateTime _timestamp;
    public ClusterId ClusterId { get; }
    public ConnectionId ConnectionId { get; }
    public Nullable`1<long> OperationId { get; }
    public ServerId ServerId { get; }
    public DateTime Timestamp { get; }
    private EventType MongoDB.Driver.Core.Events.IEvent.Type { get; }
    public ConnectionPoolRemovingConnectionEvent(ConnectionId connectionId, Nullable`1<long> operationId);
    public ClusterId get_ClusterId();
    public ConnectionId get_ConnectionId();
    public Nullable`1<long> get_OperationId();
    public ServerId get_ServerId();
    public DateTime get_Timestamp();
    private sealed virtual override EventType MongoDB.Driver.Core.Events.IEvent.get_Type();
}
public class MongoDB.Driver.Core.Events.ConnectionReceivedMessageEvent : ValueType {
    private ConnectionId _connectionId;
    private TimeSpan _deserializationDuration;
    private TimeSpan _networkDuration;
    private int _length;
    private Nullable`1<long> _operationId;
    private int _responseTo;
    private DateTime _timestamp;
    public ClusterId ClusterId { get; }
    public ConnectionId ConnectionId { get; }
    public TimeSpan Duration { get; }
    public TimeSpan DeserializationDuration { get; }
    public TimeSpan NetworkDuration { get; }
    public int Length { get; }
    public Nullable`1<long> OperationId { get; }
    public int ResponseTo { get; }
    public ServerId ServerId { get; }
    public DateTime Timestamp { get; }
    private EventType MongoDB.Driver.Core.Events.IEvent.Type { get; }
    public ConnectionReceivedMessageEvent(ConnectionId connectionId, int responseTo, int length, TimeSpan networkDuration, TimeSpan deserializationDuration, Nullable`1<long> operationId);
    public ClusterId get_ClusterId();
    public ConnectionId get_ConnectionId();
    public TimeSpan get_Duration();
    public TimeSpan get_DeserializationDuration();
    public TimeSpan get_NetworkDuration();
    public int get_Length();
    public Nullable`1<long> get_OperationId();
    public int get_ResponseTo();
    public ServerId get_ServerId();
    public DateTime get_Timestamp();
    private sealed virtual override EventType MongoDB.Driver.Core.Events.IEvent.get_Type();
}
public class MongoDB.Driver.Core.Events.ConnectionReceivingMessageEvent : ValueType {
    private ConnectionId _connectionId;
    private Nullable`1<long> _operationId;
    private int _responseTo;
    private DateTime _timestamp;
    public ClusterId ClusterId { get; }
    public ConnectionId ConnectionId { get; }
    public Nullable`1<long> OperationId { get; }
    public int ResponseTo { get; }
    public ServerId ServerId { get; }
    public DateTime Timestamp { get; }
    private EventType MongoDB.Driver.Core.Events.IEvent.Type { get; }
    public ConnectionReceivingMessageEvent(ConnectionId connectionId, int responseTo, Nullable`1<long> operationId);
    public ClusterId get_ClusterId();
    public ConnectionId get_ConnectionId();
    public Nullable`1<long> get_OperationId();
    public int get_ResponseTo();
    public ServerId get_ServerId();
    public DateTime get_Timestamp();
    private sealed virtual override EventType MongoDB.Driver.Core.Events.IEvent.get_Type();
}
public class MongoDB.Driver.Core.Events.ConnectionReceivingMessageFailedEvent : ValueType {
    private ConnectionId _connectionId;
    private Exception _exception;
    private Nullable`1<long> _operationId;
    private int _responseTo;
    private DateTime _timestamp;
    public ClusterId ClusterId { get; }
    public ConnectionId ConnectionId { get; }
    public Exception Exception { get; }
    public Nullable`1<long> OperationId { get; }
    public int ResponseTo { get; }
    public ServerId ServerId { get; }
    public DateTime Timestamp { get; }
    private EventType MongoDB.Driver.Core.Events.IEvent.Type { get; }
    public ConnectionReceivingMessageFailedEvent(ConnectionId connectionId, int responseTo, Exception exception, Nullable`1<long> operationId);
    public ClusterId get_ClusterId();
    public ConnectionId get_ConnectionId();
    public Exception get_Exception();
    public Nullable`1<long> get_OperationId();
    public int get_ResponseTo();
    public ServerId get_ServerId();
    public DateTime get_Timestamp();
    private sealed virtual override EventType MongoDB.Driver.Core.Events.IEvent.get_Type();
}
public class MongoDB.Driver.Core.Events.ConnectionSendingMessagesEvent : ValueType {
    private ConnectionId _connectionId;
    private Nullable`1<long> _operationId;
    private IReadOnlyList`1<int> _requestIds;
    private DateTime _timestamp;
    public ClusterId ClusterId { get; }
    public ConnectionId ConnectionId { get; }
    public IReadOnlyList`1<int> RequestIds { get; }
    public Nullable`1<long> OperationId { get; }
    public ServerId ServerId { get; }
    public DateTime Timestamp { get; }
    private EventType MongoDB.Driver.Core.Events.IEvent.Type { get; }
    public ConnectionSendingMessagesEvent(ConnectionId connectionId, IReadOnlyList`1<int> requestIds, Nullable`1<long> operationId);
    public ClusterId get_ClusterId();
    public ConnectionId get_ConnectionId();
    public IReadOnlyList`1<int> get_RequestIds();
    public Nullable`1<long> get_OperationId();
    public ServerId get_ServerId();
    public DateTime get_Timestamp();
    private sealed virtual override EventType MongoDB.Driver.Core.Events.IEvent.get_Type();
}
public class MongoDB.Driver.Core.Events.ConnectionSendingMessagesFailedEvent : ValueType {
    private ConnectionId _connectionId;
    private Exception _exception;
    private Nullable`1<long> _operationId;
    private IReadOnlyList`1<int> _requestIds;
    private DateTime _timestamp;
    public ClusterId ClusterId { get; }
    public ConnectionId ConnectionId { get; }
    public Exception Exception { get; }
    public Nullable`1<long> OperationId { get; }
    public IReadOnlyList`1<int> RequestIds { get; }
    public ServerId ServerId { get; }
    public DateTime Timestamp { get; }
    private EventType MongoDB.Driver.Core.Events.IEvent.Type { get; }
    public ConnectionSendingMessagesFailedEvent(ConnectionId connectionId, IReadOnlyList`1<int> requestIds, Exception exception, Nullable`1<long> operationId);
    public ClusterId get_ClusterId();
    public ConnectionId get_ConnectionId();
    public Exception get_Exception();
    public Nullable`1<long> get_OperationId();
    public IReadOnlyList`1<int> get_RequestIds();
    public ServerId get_ServerId();
    public DateTime get_Timestamp();
    private sealed virtual override EventType MongoDB.Driver.Core.Events.IEvent.get_Type();
}
public class MongoDB.Driver.Core.Events.ConnectionSentMessagesEvent : ValueType {
    private ConnectionId _connectionId;
    private TimeSpan _networkDuration;
    private TimeSpan _serializationDuration;
    private int _length;
    private Nullable`1<long> _operationId;
    private IReadOnlyList`1<int> _requestIds;
    private DateTime _timestamp;
    public ClusterId ClusterId { get; }
    public ConnectionId ConnectionId { get; }
    public TimeSpan Duration { get; }
    public TimeSpan NetworkDuration { get; }
    public Nullable`1<long> OperationId { get; }
    public TimeSpan SerializationDuration { get; }
    public int Length { get; }
    public IReadOnlyList`1<int> RequestIds { get; }
    public ServerId ServerId { get; }
    public DateTime Timestamp { get; }
    private EventType MongoDB.Driver.Core.Events.IEvent.Type { get; }
    public ConnectionSentMessagesEvent(ConnectionId connectionId, IReadOnlyList`1<int> requestIds, int length, TimeSpan networkDuration, TimeSpan serializationDuration, Nullable`1<long> operationId);
    public ClusterId get_ClusterId();
    public ConnectionId get_ConnectionId();
    public TimeSpan get_Duration();
    public TimeSpan get_NetworkDuration();
    public Nullable`1<long> get_OperationId();
    public TimeSpan get_SerializationDuration();
    public int get_Length();
    public IReadOnlyList`1<int> get_RequestIds();
    public ServerId get_ServerId();
    public DateTime get_Timestamp();
    private sealed virtual override EventType MongoDB.Driver.Core.Events.IEvent.get_Type();
}
public class MongoDB.Driver.Core.Events.Diagnostics.TraceSourceCommandEventSubscriber : object {
    private TraceSource _traceSource;
    private ReflectionEventSubscriber _subscriber;
    public TraceSourceCommandEventSubscriber(TraceSource traceSource);
    public sealed virtual bool TryGetEventHandler(Action`1& handler);
    private void Handle(CommandStartedEvent event);
    private void Handle(CommandSucceededEvent event);
    private void Handle(CommandFailedEvent event);
    private void Debug(int id, string message, Object[] args);
    private void Info(int id, string message, Object[] args);
    private void Error(int id, Exception ex, string message, Object[] args);
}
internal static class MongoDB.Driver.Core.Events.Diagnostics.TraceSourceEventHelper : object {
    public static int CommandIdBase;
    public static int ConnectionIdBase;
    public static int ConnectionPoolIdBase;
    public static int ServerIdBase;
    public static int ClusterIdBase;
    public static string Label(ConnectionId id);
    public static string Label(ServerId serverId);
    public static string Label(ClusterId clusterId);
    public static string Format(ConnectionId id);
    public static string Format(ServerId serverId);
    public static string Format(EndPoint endPoint);
}
public class MongoDB.Driver.Core.Events.Diagnostics.TraceSourceEventSubscriber : object {
    private TraceSource _traceSource;
    private ReflectionEventSubscriber _subscriber;
    public TraceSourceEventSubscriber(TraceSource traceSource);
    public sealed virtual bool TryGetEventHandler(Action`1& handler);
    private void Handle(ClusterOpeningEvent event);
    private void Handle(ClusterOpenedEvent event);
    private void Handle(ClusterClosingEvent event);
    private void Handle(ClusterClosedEvent event);
    private void Handle(ClusterAddingServerEvent event);
    private void Handle(ClusterAddedServerEvent event);
    private void Handle(ClusterRemovingServerEvent event);
    private void Handle(ClusterRemovedServerEvent event);
    private void Handle(ClusterDescriptionChangedEvent event);
    private void Handle(SdamInformationEvent event);
    private void Handle(ServerOpeningEvent event);
    private void Handle(ServerOpenedEvent event);
    private void Handle(ServerClosingEvent event);
    private void Handle(ServerClosedEvent event);
    private void Handle(ServerHeartbeatStartedEvent event);
    private void Handle(ServerHeartbeatSucceededEvent event);
    private void Handle(ServerHeartbeatFailedEvent event);
    private void Handle(ServerDescriptionChangedEvent event);
    private void Handle(ConnectionPoolOpeningEvent event);
    private void Handle(ConnectionPoolOpenedEvent event);
    private void Handle(ConnectionPoolClosingEvent event);
    private void Handle(ConnectionPoolClosedEvent event);
    private void Handle(ConnectionPoolAddingConnectionEvent event);
    private void Handle(ConnectionPoolAddedConnectionEvent event);
    private void Handle(ConnectionPoolRemovingConnectionEvent event);
    private void Handle(ConnectionPoolRemovedConnectionEvent event);
    private void Handle(ConnectionPoolCheckingOutConnectionEvent event);
    private void Handle(ConnectionPoolCheckedOutConnectionEvent event);
    private void Handle(ConnectionPoolCheckingOutConnectionFailedEvent event);
    private void Handle(ConnectionPoolCheckingInConnectionEvent event);
    private void Handle(ConnectionPoolCheckedInConnectionEvent event);
    private void Handle(ConnectionOpeningEvent event);
    private void Handle(ConnectionOpenedEvent event);
    private void Handle(ConnectionOpeningFailedEvent event);
    private void Handle(ConnectionClosingEvent event);
    private void Handle(ConnectionClosedEvent event);
    private void Handle(ConnectionFailedEvent event);
    private void Handle(ConnectionReceivingMessageEvent event);
    private void Handle(ConnectionReceivedMessageEvent event);
    private void Handle(ConnectionReceivingMessageFailedEvent event);
    private void Handle(ConnectionSendingMessagesEvent event);
    private void Handle(ConnectionSentMessagesEvent event);
    private void Handle(ConnectionSendingMessagesFailedEvent event);
    private void Debug(int id, string message, Object[] args);
    private void Info(int id, string message, Object[] args);
    private void Error(int id, Exception ex, string message, Object[] args);
}
public class MongoDB.Driver.Core.Events.Diagnostics.TraceSourceSdamEventSubscriber : object {
    private TraceSource _traceSource;
    private ReflectionEventSubscriber _subscriber;
    public TraceSourceSdamEventSubscriber(TraceSource traceSource);
    public sealed virtual bool TryGetEventHandler(Action`1& handler);
    private void Handle(ClusterOpeningEvent event);
    private void Handle(ClusterOpenedEvent event);
    private void Handle(ClusterClosingEvent event);
    private void Handle(ClusterClosedEvent event);
    private void Handle(ClusterAddingServerEvent event);
    private void Handle(ClusterAddedServerEvent event);
    private void Handle(ClusterRemovingServerEvent event);
    private void Handle(ClusterRemovedServerEvent event);
    private void Handle(ClusterDescriptionChangedEvent event);
    private void Handle(SdamInformationEvent event);
    private void Handle(ServerOpeningEvent event);
    private void Handle(ServerOpenedEvent event);
    private void Handle(ServerClosingEvent event);
    private void Handle(ServerClosedEvent event);
    private void Handle(ServerHeartbeatStartedEvent event);
    private void Handle(ServerHeartbeatSucceededEvent event);
    private void Handle(ServerHeartbeatFailedEvent event);
    private void Handle(ServerDescriptionChangedEvent event);
    private void Debug(int id, string message, Object[] args);
    private void Info(int id, string message, Object[] args);
    private void Error(int id, Exception ex, string message, Object[] args);
}
internal class MongoDB.Driver.Core.Events.EventAggregator : object {
    private List`1<IEventSubscriber> _subscribers;
    public void Subscribe(Action`1<TEvent> handler);
    public void Subscribe(IEventSubscriber subscriber);
    public sealed virtual bool TryGetEventHandler(Action`1& handler);
}
internal static class MongoDB.Driver.Core.Events.EventContext : object {
    private static AsyncLocal`1<Nullable`1<int>> __findOperationBatchSize;
    private static AsyncLocal`1<Nullable`1<int>> __findOperationLimit;
    private static AsyncLocal`1<CollectionNamespace> __killCursorsCollectionNamespace;
    private static AsyncLocal`1<Nullable`1<long>> __operationId;
    private static AsyncLocal`1<string> __operationName;
    public static Nullable`1<int> FindOperationBatchSize { get; private set; }
    public static Nullable`1<int> FindOperationLimit { get; private set; }
    public static CollectionNamespace KillCursorsCollectionNamespace { get; private set; }
    public static Nullable`1<long> OperationId { get; private set; }
    public static string OperationName { get; private set; }
    private static EventContext();
    public static Nullable`1<int> get_FindOperationBatchSize();
    private static void set_FindOperationBatchSize(Nullable`1<int> value);
    public static Nullable`1<int> get_FindOperationLimit();
    private static void set_FindOperationLimit(Nullable`1<int> value);
    public static CollectionNamespace get_KillCursorsCollectionNamespace();
    private static void set_KillCursorsCollectionNamespace(CollectionNamespace value);
    public static Nullable`1<long> get_OperationId();
    private static void set_OperationId(Nullable`1<long> value);
    public static string get_OperationName();
    private static void set_OperationName(string value);
    public static IDisposable BeginFind(Nullable`1<int> batchSize, Nullable`1<int> limit);
    public static IDisposable BeginKillCursors(CollectionNamespace collectionNamespace);
    public static IDisposable BeginOperation();
    public static IDisposable BeginOperation(string commandName);
    public static IDisposable BeginOperation(Nullable`1<long> operationId, string commandName);
}
internal class MongoDB.Driver.Core.Events.EventPublisher : object {
    private static Delegate __eventHandlerNull;
    private static int __eventTypesCount;
    private Delegate[] _eventHandlers;
    private IEventSubscriber _eventSubscriber;
    public EventPublisher(IEventSubscriber eventSubscriber);
    private static EventPublisher();
    public bool IsEventTracked();
    public void Publish(TEvent event);
}
internal enum MongoDB.Driver.Core.Events.EventType : Enum {
    public int value__;
    public static EventType ClusterAddedServer;
    public static EventType ClusterAddingServer;
    public static EventType ClusterClosed;
    public static EventType ClusterClosing;
    public static EventType ClusterDescriptionChanged;
    public static EventType ClusterOpened;
    public static EventType ClusterOpening;
    public static EventType ClusterRemovedServer;
    public static EventType ClusterRemovingServer;
    public static EventType ClusterSelectedServer;
    public static EventType ClusterSelectingServer;
    public static EventType ClusterEnteredSelectionWaitQueue;
    public static EventType ClusterSelectingServerFailed;
    public static EventType CommandFailed;
    public static EventType CommandStarted;
    public static EventType CommandSucceeded;
    public static EventType ConnectionClosed;
    public static EventType ConnectionClosing;
    public static EventType ConnectionCreated;
    public static EventType ConnectionFailed;
    public static EventType ConnectionOpened;
    public static EventType ConnectionOpening;
    public static EventType ConnectionOpeningFailed;
    public static EventType ConnectionPoolAddedConnection;
    public static EventType ConnectionPoolAddingConnection;
    public static EventType ConnectionPoolCheckedInConnection;
    public static EventType ConnectionPoolCheckedOutConnection;
    public static EventType ConnectionPoolCheckingInConnection;
    public static EventType ConnectionPoolCheckingOutConnection;
    public static EventType ConnectionPoolCheckingOutConnectionFailed;
    public static EventType ConnectionPoolCleared;
    public static EventType ConnectionPoolClearing;
    public static EventType ConnectionPoolClosed;
    public static EventType ConnectionPoolClosing;
    public static EventType ConnectionPoolOpened;
    public static EventType ConnectionPoolOpening;
    public static EventType ConnectionPoolReady;
    public static EventType ConnectionPoolRemovedConnection;
    public static EventType ConnectionPoolRemovingConnection;
    public static EventType ConnectionReceivedMessage;
    public static EventType ConnectionReceivingMessage;
    public static EventType ConnectionReceivingMessageFailed;
    public static EventType ConnectionSendingMessages;
    public static EventType ConnectionSendingMessagesFailed;
    public static EventType ConnectionSentMessages;
    public static EventType SdamInformation;
    public static EventType ServerClosed;
    public static EventType ServerClosing;
    public static EventType ServerDescriptionChanged;
    public static EventType ServerHeartbeatFailed;
    public static EventType ServerHeartbeatStarted;
    public static EventType ServerHeartbeatSucceeded;
    public static EventType ServerOpened;
    public static EventType ServerOpening;
}
internal interface MongoDB.Driver.Core.Events.IEvent {
    public EventType Type { get; }
    public abstract virtual EventType get_Type();
}
public interface MongoDB.Driver.Core.Events.IEventSubscriber {
    public abstract virtual bool TryGetEventHandler(Action`1& handler);
}
public class MongoDB.Driver.Core.Events.ReflectionEventSubscriber : object {
    private Dictionary`2<Type, Delegate> _handlers;
    public ReflectionEventSubscriber(object instance, string methodName, BindingFlags bindingFlags);
    public sealed virtual bool TryGetEventHandler(Action`1& handler);
}
public class MongoDB.Driver.Core.Events.SdamInformationEvent : ValueType {
    private object _arg0;
    private Object[] _args;
    private int _argsCount;
    private string _messageFormat;
    private DateTime _timestamp;
    private string _formattedMessage;
    public string Message { get; }
    public DateTime Timestamp { get; }
    private EventType MongoDB.Driver.Core.Events.IEvent.Type { get; }
    public SdamInformationEvent(string messageFormat, object arg0);
    public SdamInformationEvent(string messageFormat, Object[] args);
    private SdamInformationEvent(string messageFormat, int argsCount, object arg0, Object[] args);
    public string get_Message();
    public DateTime get_Timestamp();
    private sealed virtual override EventType MongoDB.Driver.Core.Events.IEvent.get_Type();
    public virtual string ToString();
}
public class MongoDB.Driver.Core.Events.ServerClosedEvent : ValueType {
    private ServerId _serverId;
    private TimeSpan _duration;
    private DateTime _timestamp;
    public ClusterId ClusterId { get; }
    public TimeSpan Duration { get; }
    public ServerId ServerId { get; }
    public DateTime Timestamp { get; }
    private EventType MongoDB.Driver.Core.Events.IEvent.Type { get; }
    public ServerClosedEvent(ServerId serverId, TimeSpan duration);
    public ClusterId get_ClusterId();
    public TimeSpan get_Duration();
    public ServerId get_ServerId();
    public DateTime get_Timestamp();
    private sealed virtual override EventType MongoDB.Driver.Core.Events.IEvent.get_Type();
}
public class MongoDB.Driver.Core.Events.ServerClosingEvent : ValueType {
    private ServerId _serverId;
    private DateTime _timestamp;
    public ClusterId ClusterId { get; }
    public ServerId ServerId { get; }
    public DateTime Timestamp { get; }
    private EventType MongoDB.Driver.Core.Events.IEvent.Type { get; }
    public ServerClosingEvent(ServerId serverId);
    public ClusterId get_ClusterId();
    public ServerId get_ServerId();
    public DateTime get_Timestamp();
    private sealed virtual override EventType MongoDB.Driver.Core.Events.IEvent.get_Type();
}
public class MongoDB.Driver.Core.Events.ServerDescriptionChangedEvent : ValueType {
    private ServerDescription _oldDescription;
    private ServerDescription _newDescription;
    private DateTime _timestamp;
    public ClusterId ClusterId { get; }
    public ServerDescription NewDescription { get; }
    public ServerDescription OldDescription { get; }
    public ServerId ServerId { get; }
    public DateTime Timestamp { get; }
    private EventType MongoDB.Driver.Core.Events.IEvent.Type { get; }
    public ServerDescriptionChangedEvent(ServerDescription oldDescription, ServerDescription newDescription);
    public ClusterId get_ClusterId();
    public ServerDescription get_NewDescription();
    public ServerDescription get_OldDescription();
    public ServerId get_ServerId();
    public DateTime get_Timestamp();
    private sealed virtual override EventType MongoDB.Driver.Core.Events.IEvent.get_Type();
}
public class MongoDB.Driver.Core.Events.ServerHeartbeatFailedEvent : ValueType {
    private bool _awaited;
    private ConnectionId _connectionId;
    private TimeSpan _duration;
    private Exception _exception;
    private DateTime _timestamp;
    public bool Awaited { get; }
    public ClusterId ClusterId { get; }
    public ConnectionId ConnectionId { get; }
    public TimeSpan Duration { get; }
    public Exception Exception { get; }
    public ServerId ServerId { get; }
    public DateTime Timestamp { get; }
    private EventType MongoDB.Driver.Core.Events.IEvent.Type { get; }
    [ObsoleteAttribute("Use the other contstructor instead")]
public ServerHeartbeatFailedEvent(ConnectionId connectionId, Exception exception, bool awaited);
    public ServerHeartbeatFailedEvent(ConnectionId connectionId, TimeSpan duration, Exception exception, bool awaited);
    public bool get_Awaited();
    public ClusterId get_ClusterId();
    public ConnectionId get_ConnectionId();
    public TimeSpan get_Duration();
    public Exception get_Exception();
    public ServerId get_ServerId();
    public DateTime get_Timestamp();
    private sealed virtual override EventType MongoDB.Driver.Core.Events.IEvent.get_Type();
}
public class MongoDB.Driver.Core.Events.ServerHeartbeatStartedEvent : ValueType {
    private bool _awaited;
    private ConnectionId _connectionId;
    private DateTime _timestamp;
    public bool Awaited { get; }
    public ClusterId ClusterId { get; }
    public ConnectionId ConnectionId { get; }
    public ServerId ServerId { get; }
    public DateTime Timestamp { get; }
    private EventType MongoDB.Driver.Core.Events.IEvent.Type { get; }
    public ServerHeartbeatStartedEvent(ConnectionId connectionId, bool awaited);
    public bool get_Awaited();
    public ClusterId get_ClusterId();
    public ConnectionId get_ConnectionId();
    public ServerId get_ServerId();
    public DateTime get_Timestamp();
    private sealed virtual override EventType MongoDB.Driver.Core.Events.IEvent.get_Type();
}
public class MongoDB.Driver.Core.Events.ServerHeartbeatSucceededEvent : ValueType {
    private bool _awaited;
    private ConnectionId _connectionId;
    private TimeSpan _duration;
    private BsonDocument _reply;
    private DateTime _timestamp;
    public bool Awaited { get; }
    public ClusterId ClusterId { get; }
    public ConnectionId ConnectionId { get; }
    public TimeSpan Duration { get; }
    public BsonDocument Reply { get; }
    public ServerId ServerId { get; }
    public DateTime Timestamp { get; }
    private EventType MongoDB.Driver.Core.Events.IEvent.Type { get; }
    public ServerHeartbeatSucceededEvent(ConnectionId connectionId, TimeSpan duration, bool awaited);
    public ServerHeartbeatSucceededEvent(ConnectionId connectionId, TimeSpan duration, bool awaited, BsonDocument reply);
    public bool get_Awaited();
    public ClusterId get_ClusterId();
    public ConnectionId get_ConnectionId();
    public TimeSpan get_Duration();
    public BsonDocument get_Reply();
    public ServerId get_ServerId();
    public DateTime get_Timestamp();
    private sealed virtual override EventType MongoDB.Driver.Core.Events.IEvent.get_Type();
}
public class MongoDB.Driver.Core.Events.ServerOpenedEvent : ValueType {
    private TimeSpan _duration;
    private ServerId _serverId;
    private ServerSettings _serverSettings;
    private DateTime _timestamp;
    public ClusterId ClusterId { get; }
    public TimeSpan Duration { get; }
    public ServerId ServerId { get; }
    public ServerSettings ServerSettings { get; }
    public DateTime Timestamp { get; }
    private EventType MongoDB.Driver.Core.Events.IEvent.Type { get; }
    public ServerOpenedEvent(ServerId serverId, ServerSettings serverSettings, TimeSpan duration);
    public ClusterId get_ClusterId();
    public TimeSpan get_Duration();
    public ServerId get_ServerId();
    public ServerSettings get_ServerSettings();
    public DateTime get_Timestamp();
    private sealed virtual override EventType MongoDB.Driver.Core.Events.IEvent.get_Type();
}
public class MongoDB.Driver.Core.Events.ServerOpeningEvent : ValueType {
    private ServerId _serverId;
    private ServerSettings _serverSettings;
    private DateTime _timestamp;
    public ClusterId ClusterId { get; }
    public ServerId ServerId { get; }
    public ServerSettings ServerSettings { get; }
    public DateTime Timestamp { get; }
    private EventType MongoDB.Driver.Core.Events.IEvent.Type { get; }
    public ServerOpeningEvent(ServerId serverId, ServerSettings serverSettings);
    public ClusterId get_ClusterId();
    public ServerId get_ServerId();
    public ServerSettings get_ServerSettings();
    public DateTime get_Timestamp();
    private sealed virtual override EventType MongoDB.Driver.Core.Events.IEvent.get_Type();
}
public class MongoDB.Driver.Core.Events.SingleEventSubscriber`1 : object {
    private Delegate _handler;
    public SingleEventSubscriber`1(Action`1<TSingleEvent> handler);
    public sealed virtual bool TryGetEventHandler(Action`1& handler);
}
[ExtensionAttribute]
internal static class MongoDB.Driver.Core.IDictionaryExtensions : object {
    [ExtensionAttribute]
public static void AddRange(IDictionary`2<TKey, TValue> dictionary, IEnumerable`1<KeyValuePair`2<TKey, TValue>> values);
}
[ExtensionAttribute]
internal static class MongoDB.Driver.Core.IReadOnlyDictionaryExtensions : object {
    [ExtensionAttribute]
public static bool IsEquivalentTo(IReadOnlyDictionary`2<TKey, TValue> x, IReadOnlyDictionary`2<TKey, TValue> y, Func`3<TValue, TValue, bool> equals);
    [ExtensionAttribute]
public static TValueResult GetValueOrDefault(IReadOnlyDictionary`2<TKey, TValue> dictionary, TKey key);
}
internal class MongoDB.Driver.Core.Logging.EventLogFormattingOptions : object {
    [CompilerGeneratedAttribute]
private int <MaxDocumentSize>k__BackingField;
    public int MaxDocumentSize { get; }
    public EventLogFormattingOptions(int maxCommandDocumentSize);
    [CompilerGeneratedAttribute]
public int get_MaxDocumentSize();
}
internal class MongoDB.Driver.Core.Logging.EventLogger`1 : object {
    private EventPublisher _eventPublisher;
    private ILogger`1<T> _logger;
    private EventLogFormattingOptions _eventLogFormattingOptions;
    [CompilerGeneratedAttribute]
private static EventLogger`1<T> <Empty>k__BackingField;
    public static EventLogger`1<T> Empty { get; }
    public ILogger`1<T> Logger { get; }
    public EventLogger`1(IEventSubscriber eventSubscriber, ILogger`1<T> logger, EventLogFormattingOptions eventLogFormattingOptions);
    private static EventLogger`1();
    [CompilerGeneratedAttribute]
public static EventLogger`1<T> get_Empty();
    public ILogger`1<T> get_Logger();
    public bool IsEventTracked();
    private LogLevel GetEventVerbosity();
    public void LogAndPublish(TEvent event, bool skipLogging);
    public void LogAndPublish(Exception exception, TEvent event, bool skipLogging);
    public void LogAndPublish(TEvent event, TArg arg);
    private void Log(LogLevel logLevel, string template, Exception exception, Object[] params);
}
internal static class MongoDB.Driver.Core.Logging.LogCategories : object {
}
internal static class MongoDB.Driver.Core.Logging.LogCategoryHelper : object {
    private static IDictionary`2<Type, string> __catergories;
    private static String[] __driverNamespaces;
    private static String[] __driverTestsNamespaces;
    private static string __specCategoryPrefix;
    private static string PrefixSpec;
    private static string PrefixInternal;
    private static string PrefixTests;
    private static LogCategoryHelper();
    public static string DecorateCategoryName(string categoryName);
    public static string GetCategoryName();
}
[ExtensionAttribute]
internal static class MongoDB.Driver.Core.Logging.LoggerExtensions : object {
    [ExtensionAttribute]
public static EventLogger`1<T> ToEventLogger(ILogger`1<T> logger, IEventSubscriber eventSubscriber);
    [ExtensionAttribute]
public static EventLogger`1<T> ToEventLogger(IEventSubscriber eventSubscriber);
    [ExtensionAttribute]
public static void LogDebug(ILogger`1<T> logger, ClusterId clusterId, string message);
    [ExtensionAttribute]
public static void LogTrace(ILogger`1<T> logger, ClusterId clusterId, string message);
    [ExtensionAttribute]
public static void LogDebug(ILogger`1<T> logger, string format, ClusterId clusterId, string message, object arg1);
    [ExtensionAttribute]
public static void LogTrace(ILogger`1<T> logger, string format, ClusterId clusterId, string message, object arg1);
    [ExtensionAttribute]
public static void LogDebug(ILogger`1<T> logger, ServerId serverId, string message);
    [ExtensionAttribute]
public static void LogDebug(ILogger`1<T> logger, string format, ServerId serverId, string message, object arg1);
}
internal class MongoDB.Driver.Core.Logging.LoggerFactoryCategoryDecorator : object {
    private ILoggerFactory _loggerFactory;
    private LoggingSettings _loggingSettings;
    public LoggingSettings LoggingSettings { get; }
    public LoggerFactoryCategoryDecorator(ILoggerFactory loggerFactory, LoggingSettings loggingSettings);
    public LoggingSettings get_LoggingSettings();
    public sealed virtual void AddProvider(ILoggerProvider provider);
    public sealed virtual ILogger CreateLogger(string categoryName);
    public sealed virtual void Dispose();
}
[ExtensionAttribute]
internal static class MongoDB.Driver.Core.Logging.LoggerFactoryExtensions : object {
    [ExtensionAttribute]
public static EventLogger`1<T> CreateEventLogger(ILoggerFactory loggerFactory, IEventSubscriber eventSubscriber);
}
[ExtensionAttribute]
internal static class MongoDB.Driver.Core.Logging.LoggingSettingsExtensions : object {
    [ExtensionAttribute]
public static ILoggerFactory ToInternalLoggerFactory(LoggingSettings loggingSettings);
    [ExtensionAttribute]
public static ILogger`1<TCategory> CreateLogger(LoggingSettings loggingSettings);
}
internal static class MongoDB.Driver.Core.Logging.StructuredLogTemplateProviders : object {
    public static string Awaited;
    public static string Command;
    public static string CommandName;
    public static string DatabaseName;
    public static string Description;
    public static string DriverConnectionId;
    public static string DurationMS;
    public static string Failure;
    public static string Error;
    public static string MaxConnecting;
    public static string MaxIdleTimeMS;
    public static string MaxPoolSize;
    public static string Message;
    public static string MinPoolSize;
    public static string NewDescription;
    public static string Operation;
    public static string OperationId;
    public static string PreviousDescription;
    public static string RequestId;
    public static string Reply;
    public static string Reason;
    public static string Selector;
    public static string ServerHost;
    public static string ServerPort;
    public static string ServerConnectionId;
    public static string ServiceId;
    public static string SharedLibraryVersion;
    public static string TopologyDescription;
    public static string TopologyId;
    public static string WaitQueueTimeoutMS;
    public static string WaitQueueSize;
    public static string DriverConnectionId_Message;
    public static string ServerId_Message;
    public static string ServerId_Message_Description;
    public static string TopologyId_Message;
    public static string TopologyId_Message_SharedLibraryVersion;
    private static LogTemplateProvider[] __eventTemplateProviders;
    private static String[] __clusterCommonParams;
    private static String[] __serverSelectionCommonParams;
    private static String[] __cmapCommonParams;
    private static String[] __commandCommonParams;
    private static String[] __connectionCommonParams;
    private static String[] __sdamCommonParams;
    private static StructuredLogTemplateProviders();
    public static LogTemplateProvider GetTemplateProvider(EventType eventType);
    public static Object[] GetParams(ClusterId clusterId, object arg1);
    public static Object[] GetParams(ClusterId clusterId, object arg1, object arg2);
    public static Object[] GetParams(ClusterId clusterId, object message, ClusterDescription oldDescription, ClusterDescription newDescription);
    public static Object[] GetParams(ClusterId clusterId, EndPoint endPoint, object arg1);
    public static Object[] GetParams(ClusterId clusterId, object arg1, object arg2, object arg3, object arg4, object arg5);
    public static Object[] GetParams(ClusterId clusterId, object arg1, object arg2, object arg3, object arg4, object arg5, EndPoint endPoint);
    public static Object[] GetParams(ClusterId clusterId, object arg1, object arg2, object arg3, object arg4, object arg5, object arg6);
    public static Object[] GetParams(ServerId serverId, object arg1);
    public static Object[] GetParams(ServerId serverId, object arg1, object arg2);
    public static Object[] GetParams(ServerId serverId, object arg1, object arg2, object arg3);
    public static Object[] GetParams(ServerId serverId, object arg1, object arg2, object arg3, object arg4);
    public static Object[] GetParams(ServerId serverId, object arg1, object arg2, object arg3, object arg4, object arg5, object arg6);
    public static Object[] GetParams(ServerId serverId, object arg1, object arg2, object arg3, object arg4, object arg5, object arg6, object arg7);
    public static Object[] GetParams(ConnectionId connectionId, object arg1);
    public static Object[] GetParams(ConnectionId connectionId, object arg1, object arg2);
    public static Object[] GetParams(ConnectionId connectionId, object arg1, object arg2, object arg3, object arg4);
    public static Object[] GetParamsOmitNull(ConnectionId connectionId, object arg1, object arg2, object arg3, object arg4, object arg5, object arg6, object ommitableParam);
    public static Object[] GetParamsOmitNull(ConnectionId connectionId, object arg1, object arg2, object arg3, object arg4, object arg5, object arg6, object arg7, object ommitableParam);
    private static void AddTemplateProvider(LogLevel logLevel, string template, Func`3<TEvent, EventLogFormattingOptions, Object[]> extractor);
    private static void AddTemplateProvider(LogLevel logLevel, String[] templates, Func`3<TEvent, EventLogFormattingOptions, Object[]> extractor, Func`3<TEvent, LogTemplateProvider, string> templateExtractor);
    private static void AddTemplate(LogLevel logLevel, string template, Func`4<TEvent, EventLogFormattingOptions, TArg, Object[]> extractor);
    private static void AddTemplateProvider(LogTemplateProvider templateProvider);
    private static string Concat(String[] parameters);
    private static string Concat(String[] parameters, String[] additionalParameters);
    private static string DocumentToString(BsonDocument document, EventLogFormattingOptions eventLogFormattingOptions);
    private static string FormatException(Exception exception, EventLogFormattingOptions eventLogFormattingOptions);
    private static string TruncateIfNeeded(string str, int length);
    private static string ClusterCommonParams(String[] params);
    private static string ServerSelectionCommonParams(String[] params);
    private static void AddClusterTemplates();
    private static string CmapCommonParams(String[] params);
    private static void AddCmapTemplates();
    private static string GetCheckoutFailedReason(ConnectionCheckOutFailedReason connectionCheckOutFailedReason);
    private static String[] CommandCommonParams(String[] params);
    private static void AddCommandTemplates();
    private static string FormatCommandException(Exception exception, EventLogFormattingOptions eventLogFormattingOptions);
    private static string ConnectionCommonParams(String[] params);
    private static void AddConnectionTemplates();
    private static string SdamCommonParams(String[] params);
    private static void AddSdamTemplates();
}
internal static class MongoDB.Driver.Core.Misc.ApplicationNameHelper : object {
    public static string EnsureApplicationNameIsValid(string applicationName, string paramName);
    public static bool IsApplicationNameValid(string applicationName, String& message);
}
public class MongoDB.Driver.Core.Misc.BatchableSource`1 : object {
    private bool _canBeSplit;
    private int _count;
    private IReadOnlyList`1<T> _items;
    private int _offset;
    private int _processedCount;
    public bool AllItemsWereProcessed { get; }
    public bool CanBeSplit { get; }
    public int Count { get; }
    public IReadOnlyList`1<T> Items { get; }
    public int Offset { get; }
    public int ProcessedCount { get; }
    [ObsoleteAttribute("Use one of the other constructors instead.")]
public BatchableSource`1(IEnumerable`1<T> batch);
    [ObsoleteAttribute("Use one of the other constructors instead.")]
public BatchableSource`1(IEnumerator`1<T> enumerator);
    public BatchableSource`1(IReadOnlyList`1<T> items, bool canBeSplit);
    public BatchableSource`1(IReadOnlyList`1<T> items, int offset, int count, bool canBeSplit);
    private static IReadOnlyList`1<T> EnumeratorToList(IEnumerator`1<T> enumerator);
    public sealed virtual bool get_AllItemsWereProcessed();
    public sealed virtual bool get_CanBeSplit();
    public sealed virtual int get_Count();
    public sealed virtual IReadOnlyList`1<T> get_Items();
    public sealed virtual int get_Offset();
    public sealed virtual int get_ProcessedCount();
    public sealed virtual void AdvancePastProcessedItems();
    public sealed virtual IReadOnlyList`1<T> GetBatchItems();
    public sealed virtual IReadOnlyList`1<T> GetProcessedItems();
    public sealed virtual IReadOnlyList`1<T> GetUnprocessedItems();
    public sealed virtual void SetProcessedCount(int value);
}
internal class MongoDB.Driver.Core.Misc.CachedEnumerable`1 : object {
    private IEnumerable`1<T> _enumerable;
    private IReadOnlyList`1<T> _cached;
    public CachedEnumerable`1(IEnumerable`1<T> enumerable);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal static class MongoDB.Driver.Core.Misc.ConnectionStringConversions : object {
    [ObsoleteAttribute("This method will be removed in a later release.")]
public static int GetComputedWaitQueueSize(int effectiveMaxConnections, double multiplier);
    public static int GetEffectiveMaxConnections(int maxConnections);
    public static Nullable`1<int> GetEffectiveMaxConnections(Nullable`1<int> maxConnections);
}
internal class MongoDB.Driver.Core.Misc.DecryptedSecureString : object {
    private Char[] _chars;
    private GCHandle _charsHandle;
    private IntPtr _charsIntPtr;
    private bool _disposed;
    private SecureString _secureString;
    private Byte[] _utf8Bytes;
    private GCHandle _utf8BytesHandle;
    public DecryptedSecureString(SecureString secureString);
    protected virtual override void Finalize();
    public sealed virtual void Dispose();
    public Char[] GetChars();
    public Byte[] GetUtf8Bytes();
    private void Dispose(bool disposing);
}
internal class MongoDB.Driver.Core.Misc.DefaultRandomByteGenerator : object {
    public sealed virtual Byte[] Generate(int length);
}
internal class MongoDB.Driver.Core.Misc.DefaultRandomStringGenerator : object {
    public sealed virtual string Generate(int length, string legalCharacters);
}
internal class MongoDB.Driver.Core.Misc.DnsClientWrapper : object {
    private static IDnsResolver __instance;
    private Lazy`1<LookupClient> _lookupClient;
    public static IDnsResolver Instance { get; }
    private static DnsClientWrapper();
    public static IDnsResolver get_Instance();
    public sealed virtual List`1<SrvRecord> ResolveSrvRecords(string service, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MongoDB.Driver.Core.Misc.DnsClientWrapper/<ResolveSrvRecordsAsync>d__6")]
public sealed virtual Task`1<List`1<SrvRecord>> ResolveSrvRecordsAsync(string service, CancellationToken cancellationToken);
    public sealed virtual List`1<TxtRecord> ResolveTxtRecords(string domainName, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MongoDB.Driver.Core.Misc.DnsClientWrapper/<ResolveTxtRecordsAsync>d__8")]
public sealed virtual Task`1<List`1<TxtRecord>> ResolveTxtRecordsAsync(string domainName, CancellationToken cancellationToken);
    private List`1<SrvRecord> GetSrvRecords(IDnsQueryResponse response);
    private List`1<TxtRecord> GetTxtRecords(IDnsQueryResponse response);
}
[ExtensionAttribute]
public static class MongoDB.Driver.Core.Misc.EndPointHelper : object {
    private static IEqualityComparer`1<EndPoint> __endPointEqualityComparer;
    public static IEqualityComparer`1<EndPoint> EndPointEqualityComparer { get; }
    private static EndPointHelper();
    public static IEqualityComparer`1<EndPoint> get_EndPointEqualityComparer();
    public static bool Contains(IEnumerable`1<EndPoint> endPoints, EndPoint endPoint);
    public static bool Equals(EndPoint a, EndPoint b);
    public static EndPoint FromObjectData(List`1<object> info);
    public static List`1<object> GetObjectData(EndPoint value);
    public static bool SequenceEquals(IEnumerable`1<EndPoint> a, IEnumerable`1<EndPoint> b);
    public static EndPoint Parse(string value);
    [ExtensionAttribute]
internal static ValueTuple`2<string, int> GetHostAndPort(EndPoint endPoint);
    public static string ToString(EndPoint endPoint);
    public static bool TryParse(string value, EndPoint& result);
    internal static bool TryParse(string value, int defaultPort, EndPoint& result);
    private static bool IsValidPort(int port);
}
[DebuggerStepThroughAttribute]
public static class MongoDB.Driver.Core.Misc.Ensure : object {
    public static Nullable`1<T> HasValue(Nullable`1<T> value, string paramName);
    public static T IsBetween(T value, T min, T max, string paramName);
    public static T IsEqualTo(T value, T comparand, string paramName);
    public static T IsGreaterThan(T value, T comparand, string paramName);
    public static T IsGreaterThanOrEqualTo(T value, T comparand, string paramName);
    public static int IsGreaterThanOrEqualToZero(int value, string paramName);
    public static long IsGreaterThanOrEqualToZero(long value, string paramName);
    public static TimeSpan IsGreaterThanOrEqualToZero(TimeSpan value, string paramName);
    public static int IsGreaterThanZero(int value, string paramName);
    public static long IsGreaterThanZero(long value, string paramName);
    public static double IsGreaterThanZero(double value, string paramName);
    public static TimeSpan IsGreaterThanZero(TimeSpan value, string paramName);
    public static TimeSpan IsInfiniteOrGreaterThanOrEqualToZero(TimeSpan value, string paramName);
    public static TimeSpan IsInfiniteOrGreaterThanZero(TimeSpan value, string paramName);
    public static T IsNotNull(T value, string paramName);
    public static IEnumerable`1<T> IsNotNullAndDoesNotContainAnyNulls(IEnumerable`1<T> values, string paramName);
    public static string IsNotNullOrEmpty(string value, string paramName);
    public static IEnumerable`1<T> IsNotNullOrEmpty(IEnumerable`1<T> value, string paramName);
    public static T IsNull(T value, string paramName);
    public static Nullable`1<T> IsNullOrBetween(Nullable`1<T> value, T min, T max, string paramName);
    public static Nullable`1<int> IsNullOrGreaterThanOrEqualToZero(Nullable`1<int> value, string paramName);
    public static Nullable`1<long> IsNullOrGreaterThanOrEqualToZero(Nullable`1<long> value, string paramName);
    public static Nullable`1<int> IsNullOrGreaterThanZero(Nullable`1<int> value, string paramName);
    public static Nullable`1<long> IsNullOrGreaterThanZero(Nullable`1<long> value, string paramName);
    public static Nullable`1<TimeSpan> IsNullOrGreaterThanZero(Nullable`1<TimeSpan> value, string paramName);
    public static Nullable`1<TimeSpan> IsNullOrInfiniteOrGreaterThanOrEqualToZero(Nullable`1<TimeSpan> value, string paramName);
    public static string IsNullOrNotEmpty(string value, string paramName);
    public static Nullable`1<TimeSpan> IsNullOrValidTimeout(Nullable`1<TimeSpan> value, string paramName);
    public static TimeSpan IsValidTimeout(TimeSpan value, string paramName);
    public static void That(bool assertion, string message);
    public static void That(bool assertion, string message, string paramName);
    public static T That(T value, Func`2<T, bool> assertion, string paramName, string message);
}
internal class MongoDB.Driver.Core.Misc.EnvironmentVariableProvider : object {
    private static IEnvironmentVariableProvider __instance;
    public static IEnvironmentVariableProvider Instance { get; }
    private static EnvironmentVariableProvider();
    public static IEnvironmentVariableProvider get_Instance();
    public sealed virtual string GetEnvironmentVariable(string name);
}
internal static class MongoDB.Driver.Core.Misc.ExceptionMapper : object {
    public static Exception Map(ConnectionId connectionId, BsonDocument response);
    public static Exception Map(ConnectionId connectionId, WriteConcernResult writeConcernResult);
    public static Exception MapNotPrimaryOrNodeIsRecovering(ConnectionId connectionId, BsonDocument command, BsonDocument response, string errorMessageFieldName);
    private static Nullable`1<int> GetCode(BsonDocument response);
}
internal class MongoDB.Driver.Core.Misc.ExponentiallyWeightedMovingAverage : object {
    private double _alpha;
    private Nullable`1<TimeSpan> _average;
    public TimeSpan Average { get; }
    public ExponentiallyWeightedMovingAverage(double alpha);
    public TimeSpan get_Average();
    public TimeSpan AddSample(TimeSpan value);
    public void Reset();
}
public class MongoDB.Driver.Core.Misc.Feature : object {
    private static Feature __aggregate;
    private static Feature __aggregateAccumulator;
    private static Feature __aggregateAddFields;
    private static Feature __aggregateAllowDiskUse;
    private static Feature __aggregateBucketStage;
    private static Feature __aggregateComment;
    private static Feature __aggregateCountStage;
    private static Feature __aggregateCursorResult;
    private static Feature __aggregateExplain;
    private static Feature __aggregateFacetStage;
    private static Feature __aggregateFunction;
    private static Feature __aggregateGraphLookupStage;
    private static Feature __aggregateHint;
    private static Feature __aggregateOptionsLet;
    private static Feature __aggregateLet;
    private static Feature __aggregateMerge;
    private static Feature __aggregateOut;
    private static Feature __aggregateOutOnSecondary;
    private static Feature __aggregateOutTimeSeries;
    private static Feature __aggregateOutToDifferentDatabase;
    private static Feature __aggregateToString;
    private static Feature __aggregateUnionWith;
    private static Feature __arrayFilters;
    private static Feature __bitwiseOperators;
    private static Feature __bypassDocumentValidation;
    private static Feature __changeStreamStage;
    private static Feature __changeStreamAllChangesForCluster;
    private static Feature __changeStreamForDatabase;
    private static Feature __changeStreamPostBatchResumeToken;
    private static Feature __changeStreamPrePostImages;
    private static Feature __changeStreamSplitEventStage;
    private static Feature __clientSideEncryption;
    private static Feature __clusteredIndexes;
    private static Feature __collation;
    private static Feature __commandMessage;
    private static Feature __commandsThatWriteAcceptWriteConcern;
    private static Feature __createIndexCommitQuorum;
    private static Feature __createIndexesCommand;
    private static Feature __createIndexesUsingInsertOperations;
    private static Feature __csfleRangeAlgorithm;
    private static Feature __csfle2Qev2RangePreviewAlgorithm;
    private static Feature __csfle2;
    private static Feature __csfle2Qev2;
    private static Feature __currentOpCommand;
    private static Feature __dateFromStringFormatArgument;
    private static Feature __dateOperatorsNewIn50;
    private static Feature __densifyStage;
    private static Feature __documentsStage;
    private static Feature __documentValidation;
    private static Feature __directConnectionSetting;
    private static Feature __electionIdPriorityInSDAM;
    private static Feature __eval;
    private static Feature __explainCommand;
    private static Feature __failPoints;
    private static Feature __failPointsBlockConnection;
    private static Feature __failPointsFailCommand;
    private static Feature __failPointsFailCommandForSharded;
    private static Feature __filterLimit;
    private static Feature __findAllowDiskUse;
    private static Feature __findAndModifyWriteConcern;
    private static Feature __findCommand;
    private static Feature __findProjectionExpressions;
    private static Feature __geoNearCommand;
    private static Feature __getField;
    private static Feature __getMoreComment;
    private static Feature __groupCommand;
    private static Feature __hedgedReads;
    private static Feature __hiddenIndex;
    private static Feature __hintForDeleteOperations;
    private static HintForFindAndModifyFeature __hintForFindAndModifyFeature;
    private static Feature __hintForUpdateAndReplaceOperations;
    private static Feature __keepConnectionPoolWhenNotPrimaryConnectionException;
    private static Feature __keepConnectionPoolWhenReplSetStepDown;
    private static Feature __killAllSessions;
    private static Feature __killCursorsCommand;
    private static Feature __legacyWireProtocol;
    private static Feature __listCollectionsCommand;
    private static Feature __listDatabasesAuthorizedDatabases;
    private static Feature __listDatabasesFilter;
    private static Feature __listDatabasesNameOnlyOption;
    private static Feature __listIndexesCommand;
    private static Feature __loadBalancedMode;
    private static Feature __indexOptionsDefaults;
    private static Feature __maxStaleness;
    private static Feature __maxTime;
    private static Feature __mmapV1StorageEngine;
    private static Feature __partialIndexes;
    private static Feature __pickAccumulatorsNewIn52;
    private static Feature __readConcern;
    private static Feature __regexMatch;
    private static Feature __retryableReads;
    private static Feature __retryableWrites;
    private static Feature __round;
    private static Feature __scramSha1Authentication;
    private static Feature __scramSha256Authentication;
    private static Feature __serverExtractsUsernameFromX509Certificate;
    private static Feature __serverReturnsResumableChangeStreamErrorLabel;
    private static Feature __serverReturnsRetryableWriteErrorLabel;
    private static Feature __setStage;
    private static Feature __setWindowFields;
    private static Feature __setWindowFieldsLocf;
    private static Feature __shardedTransactions;
    private static Feature __snapshotReads;
    private static Feature __sortArrayOperator;
    private static Feature __speculativeAuthentication;
    private static Feature __stableApi;
    private static Feature __streamingHello;
    private static Feature __tailableCursor;
    private static Feature __toConversionOperators;
    private static Feature __trigOperators;
    private static Feature __trimOperator;
    private static Feature __transactions;
    private static Feature __updateWithAggregationPipeline;
    private static Feature __userManagementCommands;
    private static Feature __views;
    private static Feature __wildcardIndexes;
    private static Feature __writeCommands;
    private string _name;
    private int _firstSupportedWireVersion;
    private Nullable`1<int> _supportRemovedWireVersion;
    private string _notSupportedMessage;
    [ObsoleteAttribute("This property will be removed in a later release.")]
public static Feature Aggregate { get; }
    public static Feature AggregateAccumulator { get; }
    [ObsoleteAttribute("This property will be removed in a later release.")]
public static Feature AggregateAddFields { get; }
    [ObsoleteAttribute("This property will be removed in a later release.")]
public static Feature AggregateAllowDiskUse { get; }
    [ObsoleteAttribute("This property will be removed in a later release.")]
public static Feature AggregateBucketStage { get; }
    [ObsoleteAttribute("This property will be removed in a later release.")]
public static Feature AggregateComment { get; }
    [ObsoleteAttribute("This property will be removed in a later release.")]
public static Feature AggregateCountStage { get; }
    [ObsoleteAttribute("This property will be removed in a later release.")]
public static Feature AggregateCursorResult { get; }
    [ObsoleteAttribute("This property will be removed in a later release.")]
public static Feature AggregateExplain { get; }
    [ObsoleteAttribute("This property will be removed in a later release.")]
public static Feature AggregateFacetStage { get; }
    public static Feature AggregateFunction { get; }
    [ObsoleteAttribute("This property will be removed in a later release.")]
public static Feature AggregateGraphLookupStage { get; }
    [ObsoleteAttribute("This property will be removed in a later release.")]
public static Feature AggregateHint { get; }
    public static Feature AggregateOptionsLet { get; }
    [ObsoleteAttribute("This property will be removed in a later release.")]
public static Feature AggregateLet { get; }
    public static Feature AggregateMerge { get; }
    [ObsoleteAttribute("This property will be removed in a later release.")]
public static Feature AggregateOut { get; }
    public static Feature AggregateOutOnSecondary { get; }
    public static Feature AggregateOutTimeSeries { get; }
    public static Feature AggregateOutToDifferentDatabase { get; }
    public static Feature AggregateToString { get; }
    public static Feature AggregateUnionWith { get; }
    [ObsoleteAttribute("This property will be removed in a later release.")]
public static Feature ArrayFilters { get; }
    public static Feature BitwiseOperators { get; }
    [ObsoleteAttribute("This property will be removed in a later release.")]
public static Feature BypassDocumentValidation { get; }
    [ObsoleteAttribute("This property will be removed in a later release.")]
public static Feature ChangeStreamStage { get; }
    public static Feature ChangeStreamAllChangesForCluster { get; }
    public static Feature ChangeStreamForDatabase { get; }
    public static Feature ChangeStreamPostBatchResumeToken { get; }
    public static Feature ChangeStreamPrePostImages { get; }
    public static Feature ChangeStreamSplitEventStage { get; }
    public static Feature ClientSideEncryption { get; }
    public static Feature ClusteredIndexes { get; }
    [ObsoleteAttribute("This property will be removed in a later release.")]
public static Feature Collation { get; }
    [ObsoleteAttribute("This property will be removed in a later release.")]
public static Feature CommandMessage { get; }
    [ObsoleteAttribute("This property will be removed in a later release.")]
public static Feature CommandsThatWriteAcceptWriteConcern { get; }
    public static Feature CreateIndexCommitQuorum { get; }
    [ObsoleteAttribute("This property will be removed in a later release.")]
public static Feature CreateIndexesCommand { get; }
    public static Feature CreateIndexesUsingInsertOperations { get; }
    public static Feature CsfleRangeAlgorithm { get; }
    public static Feature Csfle2 { get; }
    public static Feature Csfle2QEv2 { get; }
    public static Feature Csfle2QEv2RangePreviewAlgorithm { get; }
    [ObsoleteAttribute("This property will be removed in a later release.")]
public static Feature CurrentOpCommand { get; }
    public static Feature DateFromStringFormatArgument { get; }
    public static Feature DateOperatorsNewIn50 { get; }
    public static Feature DensifyStage { get; }
    public static Feature DocumentsStage { get; }
    [ObsoleteAttribute("This property will be removed in a later release.")]
public static Feature DocumentValidation { get; }
    public static Feature DirectConnectionSetting { get; }
    public static Feature ElectionIdPriorityInSDAM { get; }
    public static Feature Eval { get; }
    [ObsoleteAttribute("This property will be removed in a later release.")]
public static Feature ExplainCommand { get; }
    [ObsoleteAttribute("This property will be removed in a later release.")]
public static Feature FailPoints { get; }
    public static Feature FailPointsBlockConnection { get; }
    public static Feature FailPointsFailCommand { get; }
    public static Feature FailPointsFailCommandForSharded { get; }
    public static Feature FilterLimit { get; }
    [ObsoleteAttribute("This property will be removed in a later release.")]
public static Feature FindAllowDiskUse { get; }
    [ObsoleteAttribute("This property will be removed in a later release.")]
public static Feature FindAndModifyWriteConcern { get; }
    [ObsoleteAttribute("This property will be removed in a later release.")]
public static Feature FindCommand { get; }
    public static Feature FindProjectionExpressions { get; }
    public static Feature GeoNearCommand { get; }
    public static Feature GetField { get; }
    public static Feature GetMoreComment { get; }
    public static Feature GroupCommand { get; }
    public static Feature HedgedReads { get; }
    public static Feature HiddenIndex { get; }
    [ObsoleteAttribute("This property will be removed in a later release.")]
public static Feature HintForDeleteOperations { get; }
    public static HintForFindAndModifyFeature HintForFindAndModifyFeature { get; }
    [ObsoleteAttribute("This property will be removed in a later release.")]
public static Feature HintForUpdateAndReplaceOperations { get; }
    public static Feature KeepConnectionPoolWhenNotPrimaryConnectionException { get; }
    [ObsoleteAttribute("Use KeepConnectionPoolWhenNotPrimaryConnectionException instead.")]
public static Feature KeepConnectionPoolWhenNotMasterConnectionException { get; }
    public static Feature KeepConnectionPoolWhenReplSetStepDown { get; }
    [ObsoleteAttribute("This property will be removed in a later release.")]
public static Feature KillAllSessions { get; }
    [ObsoleteAttribute("This property will be removed in a later release.")]
public static Feature KillCursorsCommand { get; }
    [ObsoleteAttribute("This property will be removed in a later release.")]
public static Feature IndexOptionsDefaults { get; }
    public static Feature LegacyWireProtocol { get; }
    public static Feature ListDatabasesAuthorizedDatabases { get; }
    [ObsoleteAttribute("This property will be removed in a later release.")]
public static Feature ListDatabasesFilter { get; }
    [ObsoleteAttribute("This property will be removed in a later release.")]
public static Feature ListDatabasesNameOnlyOption { get; }
    [ObsoleteAttribute("This property will be removed in a later release.")]
public static Feature ListCollectionsCommand { get; }
    [ObsoleteAttribute("This property will be removed in a later release.")]
public static Feature ListIndexesCommand { get; }
    public static Feature LoadBalancedMode { get; }
    [ObsoleteAttribute("This property will be removed in a later release.")]
public static Feature MaxStaleness { get; }
    [ObsoleteAttribute("This property will be removed in a later release.")]
public static Feature MaxTime { get; }
    public static Feature MmapV1StorageEngine { get; }
    [ObsoleteAttribute("This property will be removed in a later release.")]
public static Feature PartialIndexes { get; }
    public static Feature PickAccumulatorsNewIn52 { get; }
    [ObsoleteAttribute("This property will be removed in a later release.")]
public static Feature ReadConcern { get; }
    public static Feature RegexMatch { get; }
    [ObsoleteAttribute("This property will be removed in a later release.")]
public static Feature RetryableReads { get; }
    [ObsoleteAttribute("This property will be removed in a later release.")]
public static Feature RetryableWrites { get; }
    public static Feature Round { get; }
    [ObsoleteAttribute("This property will be removed in a later release.")]
public static Feature ScramSha1Authentication { get; }
    public static Feature ScramSha256Authentication { get; }
    [ObsoleteAttribute("This property will be removed in a later release.")]
public static Feature ServerExtractsUsernameFromX509Certificate { get; }
    public static Feature ServerReturnsResumableChangeStreamErrorLabel { get; }
    public static Feature ServerReturnsRetryableWriteErrorLabel { get; }
    public static Feature SetStage { get; }
    public static Feature SetWindowFields { get; }
    public static Feature SetWindowFieldsLocf { get; }
    public static Feature ShardedTransactions { get; }
    public static Feature SnapshotReads { get; }
    public static Feature SortArrayOperator { get; }
    public static Feature SpeculativeAuthentication { get; }
    public static Feature StableApi { get; }
    public static Feature StreamingHello { get; }
    [ObsoleteAttribute("Use StreamingHello instead.")]
public static Feature StreamingIsMaster { get; }
    [ObsoleteAttribute("This property will be removed in a later release.")]
public static Feature TailableCursor { get; }
    public static Feature ToConversionOperators { get; }
    public static Feature Transactions { get; }
    public static Feature TrigOperators { get; }
    public static Feature TrimOperator { get; }
    [ObsoleteAttribute("This property will be removed in a later release.")]
public static Feature UserManagementCommands { get; }
    public static Feature UpdateWithAggregationPipeline { get; }
    [ObsoleteAttribute("This property will be removed in a later release.")]
public static Feature Views { get; }
    public static Feature WildcardIndexes { get; }
    [ObsoleteAttribute("This property will be removed in a later release.")]
public static Feature WriteCommands { get; }
    public string Name { get; }
    internal int FirstSupportedWireVersion { get; }
    internal int LastNotSupportedWireVersion { get; }
    public string NotSupportedMessage { get; }
    public Feature(string name, int firstSupportedWireVersion, Nullable`1<int> supportRemovedWireVersion, string notSupportedMessage);
    private static Feature();
    public static Feature get_Aggregate();
    public static Feature get_AggregateAccumulator();
    public static Feature get_AggregateAddFields();
    public static Feature get_AggregateAllowDiskUse();
    public static Feature get_AggregateBucketStage();
    public static Feature get_AggregateComment();
    public static Feature get_AggregateCountStage();
    public static Feature get_AggregateCursorResult();
    public static Feature get_AggregateExplain();
    public static Feature get_AggregateFacetStage();
    public static Feature get_AggregateFunction();
    public static Feature get_AggregateGraphLookupStage();
    public static Feature get_AggregateHint();
    public static Feature get_AggregateOptionsLet();
    public static Feature get_AggregateLet();
    public static Feature get_AggregateMerge();
    public static Feature get_AggregateOut();
    public static Feature get_AggregateOutOnSecondary();
    public static Feature get_AggregateOutTimeSeries();
    public static Feature get_AggregateOutToDifferentDatabase();
    public static Feature get_AggregateToString();
    public static Feature get_AggregateUnionWith();
    public static Feature get_ArrayFilters();
    public static Feature get_BitwiseOperators();
    public static Feature get_BypassDocumentValidation();
    public static Feature get_ChangeStreamStage();
    public static Feature get_ChangeStreamAllChangesForCluster();
    public static Feature get_ChangeStreamForDatabase();
    public static Feature get_ChangeStreamPostBatchResumeToken();
    public static Feature get_ChangeStreamPrePostImages();
    public static Feature get_ChangeStreamSplitEventStage();
    public static Feature get_ClientSideEncryption();
    public static Feature get_ClusteredIndexes();
    public static Feature get_Collation();
    public static Feature get_CommandMessage();
    public static Feature get_CommandsThatWriteAcceptWriteConcern();
    public static Feature get_CreateIndexCommitQuorum();
    public static Feature get_CreateIndexesCommand();
    public static Feature get_CreateIndexesUsingInsertOperations();
    public static Feature get_CsfleRangeAlgorithm();
    public static Feature get_Csfle2();
    public static Feature get_Csfle2QEv2();
    public static Feature get_Csfle2QEv2RangePreviewAlgorithm();
    public static Feature get_CurrentOpCommand();
    public static Feature get_DateFromStringFormatArgument();
    public static Feature get_DateOperatorsNewIn50();
    public static Feature get_DensifyStage();
    public static Feature get_DocumentsStage();
    public static Feature get_DocumentValidation();
    public static Feature get_DirectConnectionSetting();
    public static Feature get_ElectionIdPriorityInSDAM();
    public static Feature get_Eval();
    public static Feature get_ExplainCommand();
    public static Feature get_FailPoints();
    public static Feature get_FailPointsBlockConnection();
    public static Feature get_FailPointsFailCommand();
    public static Feature get_FailPointsFailCommandForSharded();
    public static Feature get_FilterLimit();
    public static Feature get_FindAllowDiskUse();
    public static Feature get_FindAndModifyWriteConcern();
    public static Feature get_FindCommand();
    public static Feature get_FindProjectionExpressions();
    public static Feature get_GeoNearCommand();
    public static Feature get_GetField();
    public static Feature get_GetMoreComment();
    public static Feature get_GroupCommand();
    public static Feature get_HedgedReads();
    public static Feature get_HiddenIndex();
    public static Feature get_HintForDeleteOperations();
    public static HintForFindAndModifyFeature get_HintForFindAndModifyFeature();
    public static Feature get_HintForUpdateAndReplaceOperations();
    public static Feature get_KeepConnectionPoolWhenNotPrimaryConnectionException();
    public static Feature get_KeepConnectionPoolWhenNotMasterConnectionException();
    public static Feature get_KeepConnectionPoolWhenReplSetStepDown();
    public static Feature get_KillAllSessions();
    public static Feature get_KillCursorsCommand();
    public static Feature get_IndexOptionsDefaults();
    public static Feature get_LegacyWireProtocol();
    public static Feature get_ListDatabasesAuthorizedDatabases();
    public static Feature get_ListDatabasesFilter();
    public static Feature get_ListDatabasesNameOnlyOption();
    public static Feature get_ListCollectionsCommand();
    public static Feature get_ListIndexesCommand();
    public static Feature get_LoadBalancedMode();
    public static Feature get_MaxStaleness();
    public static Feature get_MaxTime();
    public static Feature get_MmapV1StorageEngine();
    public static Feature get_PartialIndexes();
    public static Feature get_PickAccumulatorsNewIn52();
    public static Feature get_ReadConcern();
    public static Feature get_RegexMatch();
    public static Feature get_RetryableReads();
    public static Feature get_RetryableWrites();
    public static Feature get_Round();
    public static Feature get_ScramSha1Authentication();
    public static Feature get_ScramSha256Authentication();
    public static Feature get_ServerExtractsUsernameFromX509Certificate();
    public static Feature get_ServerReturnsResumableChangeStreamErrorLabel();
    public static Feature get_ServerReturnsRetryableWriteErrorLabel();
    public static Feature get_SetStage();
    public static Feature get_SetWindowFields();
    public static Feature get_SetWindowFieldsLocf();
    public static Feature get_ShardedTransactions();
    public static Feature get_SnapshotReads();
    public static Feature get_SortArrayOperator();
    public static Feature get_SpeculativeAuthentication();
    public static Feature get_StableApi();
    public static Feature get_StreamingHello();
    public static Feature get_StreamingIsMaster();
    public static Feature get_TailableCursor();
    public static Feature get_ToConversionOperators();
    public static Feature get_Transactions();
    public static Feature get_TrigOperators();
    public static Feature get_TrimOperator();
    public static Feature get_UserManagementCommands();
    public static Feature get_UpdateWithAggregationPipeline();
    public static Feature get_Views();
    public static Feature get_WildcardIndexes();
    public static Feature get_WriteCommands();
    public string get_Name();
    internal int get_FirstSupportedWireVersion();
    internal int get_LastNotSupportedWireVersion();
    public string get_NotSupportedMessage();
    internal bool IsSupported(int wireVersion);
    internal void ThrowIfNotSupported(int wireVersion);
    public virtual string ToString();
}
internal class MongoDB.Driver.Core.Misc.FileSystemProvider : object {
    [CompilerGeneratedAttribute]
private static IFileSystemProvider <Instance>k__BackingField;
    [CompilerGeneratedAttribute]
private IFile <File>k__BackingField;
    public static IFileSystemProvider Instance { get; }
    public IFile File { get; }
    private static FileSystemProvider();
    [CompilerGeneratedAttribute]
public static IFileSystemProvider get_Instance();
    [CompilerGeneratedAttribute]
public sealed virtual IFile get_File();
}
internal class MongoDB.Driver.Core.Misc.FileWrapper : object {
    public sealed virtual bool Exists(string name);
}
internal static class MongoDB.Driver.Core.Misc.FisherYatesShuffle : object {
    public static void Shuffle(IList`1<T> list);
}
public class MongoDB.Driver.Core.Misc.FixedCountBatchableSourceSerializer`1 : SerializerBase`1<BatchableSource`1<TItem>> {
    private int _count;
    private IElementNameValidator _itemElementNameValidator;
    private IBsonSerializer`1<TItem> _itemSerializer;
    public FixedCountBatchableSourceSerializer`1(IBsonSerializer`1<TItem> itemSerializer, IElementNameValidator itemElementNameValidator, int count);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual void Serialize(BsonSerializationContext context, BsonSerializationArgs args, BatchableSource`1<TItem> value);
}
public class MongoDB.Driver.Core.Misc.HintForFindAndModifyFeature : Feature {
    private int _firstWireVersionWhereWeRelyOnServerToReturnError;
    public HintForFindAndModifyFeature(string name, int firstSupportedWireVersion);
    public bool DriverMustThrowIfNotSupported(int wireVersion);
}
public interface MongoDB.Driver.Core.Misc.IBatchableSource`1 {
    public bool AllItemsWereProcessed { get; }
    public bool CanBeSplit { get; }
    public int Count { get; }
    public IReadOnlyList`1<T> Items { get; }
    public int Offset { get; }
    public int ProcessedCount { get; }
    public abstract virtual bool get_AllItemsWereProcessed();
    public abstract virtual bool get_CanBeSplit();
    public abstract virtual int get_Count();
    public abstract virtual IReadOnlyList`1<T> get_Items();
    public abstract virtual int get_Offset();
    public abstract virtual int get_ProcessedCount();
    public abstract virtual void AdvancePastProcessedItems();
    public abstract virtual IReadOnlyList`1<T> GetBatchItems();
    public abstract virtual IReadOnlyList`1<T> GetProcessedItems();
    public abstract virtual IReadOnlyList`1<T> GetUnprocessedItems();
    public abstract virtual void SetProcessedCount(int value);
}
internal interface MongoDB.Driver.Core.Misc.IClock {
    public DateTime UtcNow { get; }
    public abstract virtual DateTime get_UtcNow();
}
internal static class MongoDB.Driver.Core.Misc.IdGenerator`1 : object {
    private static int __lastId;
    public static int GetNextId();
}
internal interface MongoDB.Driver.Core.Misc.IDnsResolver {
    public abstract virtual List`1<SrvRecord> ResolveSrvRecords(string service, CancellationToken cancellation);
    public abstract virtual Task`1<List`1<SrvRecord>> ResolveSrvRecordsAsync(string service, CancellationToken cancellation);
    public abstract virtual List`1<TxtRecord> ResolveTxtRecords(string domainName, CancellationToken cancellation);
    public abstract virtual Task`1<List`1<TxtRecord>> ResolveTxtRecordsAsync(string domainName, CancellationToken cancellation);
}
internal interface MongoDB.Driver.Core.Misc.IEnvironmentVariableProvider {
    public abstract virtual string GetEnvironmentVariable(string name);
}
internal interface MongoDB.Driver.Core.Misc.IFile {
    public abstract virtual bool Exists(string name);
}
internal interface MongoDB.Driver.Core.Misc.IFileSystemProvider {
    public IFile File { get; }
    public abstract virtual IFile get_File();
}
internal abstract class MongoDB.Driver.Core.Misc.IndexMap : object {
    private static IndexMap __identityMap;
    public static IndexMap IdentityMap { get; }
    public bool IsIdentityMap { get; }
    private static IndexMap();
    public static IndexMap get_IdentityMap();
    public abstract virtual bool get_IsIdentityMap();
    public abstract virtual IndexMap Add(int index, int originalIndex);
    public abstract virtual int Map(int index);
}
internal class MongoDB.Driver.Core.Misc.InterlockedInt32 : object {
    private int _value;
    public int Value { get; }
    public InterlockedInt32(int initialValue);
    public int get_Value();
    public bool TryChange(int toValue);
    public bool TryChange(int fromValue, int toValue);
}
internal interface MongoDB.Driver.Core.Misc.IRandomByteGenerator {
    public abstract virtual Byte[] Generate(int length);
}
internal interface MongoDB.Driver.Core.Misc.IRandomStringGenerator {
    public abstract virtual string Generate(int length, string legalCharacters);
}
internal static class MongoDB.Driver.Core.Misc.LongIdGenerator`1 : object {
    private static long __lastId;
    public static long GetNextId();
}
internal static class MongoDB.Driver.Core.Misc.MaxTimeHelper : object {
    public static int ToMaxTimeMS(TimeSpan value);
}
internal class MongoDB.Driver.Core.Misc.Metronome : object {
    private IClock _clock;
    private DateTime _nextTick;
    private TimeSpan _period;
    public DateTime NextTick { get; }
    public TimeSpan Period { get; }
    public Metronome(TimeSpan period);
    internal Metronome(TimeSpan period, IClock clock);
    public DateTime get_NextTick();
    public TimeSpan get_Period();
    public TimeSpan GetNextTickDelay();
}
internal static class MongoDB.Driver.Core.Misc.OperatingSystemHelper : object {
    private static Lazy`1<OperatingSystemPlatform> __currentOperatingSystem;
    public static OperatingSystemPlatform CurrentOperatingSystem { get; }
    private static OperatingSystemHelper();
    public static OperatingSystemPlatform get_CurrentOperatingSystem();
    private static OperatingSystemPlatform DetermineOperatingSystemPlatform();
}
internal enum MongoDB.Driver.Core.Misc.OperatingSystemPlatform : Enum {
    public int value__;
    public static OperatingSystemPlatform Windows;
    public static OperatingSystemPlatform Linux;
    public static OperatingSystemPlatform MacOS;
}
internal static class MongoDB.Driver.Core.Misc.OppressiveLanguageConstants : object {
    public static string LegacyHelloCommandName;
    public static string LegacyHelloCommandNameLowerCase;
    public static string LegacyHelloResponseIsWritablePrimaryFieldName;
    public static string LegacyNotPrimaryErrorMessage;
    public static string LegacyNotPrimaryOrSecondaryErrorMessage;
}
public class MongoDB.Driver.Core.Misc.Range`1 : object {
    private T _max;
    private T _min;
    public T Max { get; }
    public T Min { get; }
    public Range`1(T min, T max);
    public T get_Max();
    public T get_Min();
    public sealed virtual bool Equals(Range`1<T> other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public bool Overlaps(Range`1<T> other);
    public virtual string ToString();
}
internal class MongoDB.Driver.Core.Misc.ReadAheadEnumerable`1 : object {
    private IEnumerable`1<T> _wrapped;
    public ReadAheadEnumerable`1(IEnumerable`1<T> wrapped);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal class MongoDB.Driver.Core.Misc.ReferenceCounted`1 : object {
    private T _instance;
    private Action`1<T> _release;
    private int _referenceCount;
    public int ReferenceCount { get; }
    public T Instance { get; }
    public ReferenceCounted`1(T instance);
    public ReferenceCounted`1(T instance, Action`1<T> release);
    public int get_ReferenceCount();
    public T get_Instance();
    public void DecrementReferenceCount();
    public void IncrementReferenceCount();
}
internal static class MongoDB.Driver.Core.Misc.SecureStringHelper : object {
    public static string ToInsecureString(SecureString secureString);
    public static SecureString ToSecureString(string value);
}
public class MongoDB.Driver.Core.Misc.SemanticVersion : object {
    private int _major;
    private int _minor;
    private int _patch;
    private string _preRelease;
    private Nullable`1<int> _preReleaseNumericSuffix;
    private string _preReleasePrefix;
    public int Major { get; }
    public int Minor { get; }
    public int Patch { get; }
    public string PreRelease { get; }
    public SemanticVersion(int major, int minor, int patch);
    public SemanticVersion(int major, int minor, int patch, string preRelease);
    private static void LookForPreReleaseNumericSuffix(string preRelease, String& preReleasePrefix, Nullable`1& preReleaseNumericSuffix);
    public int get_Major();
    public int get_Minor();
    public int get_Patch();
    public string get_PreRelease();
    public sealed virtual int CompareTo(SemanticVersion other);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(SemanticVersion other);
    public virtual int GetHashCode();
    public virtual string ToString();
    public static SemanticVersion Parse(string value);
    public static bool TryParse(string value, SemanticVersion& result);
    public static bool op_Equality(SemanticVersion a, SemanticVersion b);
    public static bool op_Inequality(SemanticVersion a, SemanticVersion b);
    public static bool op_GreaterThan(SemanticVersion a, SemanticVersion b);
    public static bool op_GreaterThanOrEqual(SemanticVersion a, SemanticVersion b);
    public static bool op_LessThan(SemanticVersion a, SemanticVersion b);
    public static bool op_LessThanOrEqual(SemanticVersion a, SemanticVersion b);
    private ServerVersion AsServerVersion();
    private bool IsInternalServerBuild();
    [CompilerGeneratedAttribute]
private int <CompareTo>g__ComparePreReleases|17_0(<>c__DisplayClass17_0& );
}
public class MongoDB.Driver.Core.Misc.SemaphoreSlimRequest : object {
    private CancellationTokenSource _disposeCancellationTokenSource;
    private CancellationTokenSource _linkedCancellationTokenSource;
    private SemaphoreSlim _semaphore;
    private Task _task;
    public Task Task { get; }
    public SemaphoreSlimRequest(SemaphoreSlim semaphore, CancellationToken cancellationToken);
    public Task get_Task();
    public sealed virtual void Dispose();
    [CompilerGeneratedAttribute]
private bool <Dispose>b__7_0();
}
internal class MongoDB.Driver.Core.Misc.SemaphoreSlimSignalable : object {
    private CancellationTokenSource _signalCancellationTokenSource;
    private SemaphoreSlim _semaphore;
    private object _syncRoot;
    public int Count { get; }
    public SemaphoreSlimSignalable(int initialCount);
    public int get_Count();
    public void Signal();
    public void Reset();
    public SemaphoreWaitResult Wait(TimeSpan timeout, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MongoDB.Driver.Core.Misc.SemaphoreSlimSignalable/<WaitAsync>d__12")]
public Task`1<SemaphoreWaitResult> WaitAsync(TimeSpan timeout, CancellationToken cancellationToken);
    public SemaphoreWaitResult WaitSignaled(TimeSpan timeout, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MongoDB.Driver.Core.Misc.SemaphoreSlimSignalable/<WaitSignaledAsync>d__14")]
public Task`1<SemaphoreWaitResult> WaitSignaledAsync(TimeSpan timeout, CancellationToken cancellationToken);
    public SemaphoreSlimSignalableAwaiter CreateAwaiter();
    public void Release();
    public sealed virtual void Dispose();
    private CancellationContext GetCancellationTokenContext(CancellationToken cancellationToken);
    private bool IsSignaled(CancellationTokenSource signalTokenSource, CancellationToken cancellationToken);
}
internal class MongoDB.Driver.Core.Misc.ServerVersion : object {
    private string _commitHash;
    private Nullable`1<int> _commitsAfterRelease;
    private int _major;
    private int _minor;
    private int _patch;
    private string _preRelease;
    private Nullable`1<int> _preReleaseNumericSuffix;
    private string _preReleasePrefix;
    public string CommitHash { get; }
    public Nullable`1<int> CommitsAfterRelease { get; }
    public int Major { get; }
    public int Minor { get; }
    public int Patch { get; }
    public string PreRelease { get; }
    public ServerVersion(int major, int minor, int patch);
    public ServerVersion(int major, int minor, int patch, string preRelease);
    private static void LookForPreReleaseNumericSuffix(string preRelease, String& preReleasePrefix, Nullable`1& preReleaseNumericSuffix);
    private static bool TryParseInternalPrelease(string preReleaseIn, String& preReleaseOut, Nullable`1& commitsAfterRelease, String& commitHash);
    public string get_CommitHash();
    public Nullable`1<int> get_CommitsAfterRelease();
    public int get_Major();
    public int get_Minor();
    public int get_Patch();
    public string get_PreRelease();
    public sealed virtual int CompareTo(ServerVersion other);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ServerVersion other);
    public virtual int GetHashCode();
    public virtual string ToString();
    public static ServerVersion Parse(string value);
    public static bool TryParse(string value, ServerVersion& result);
    public static bool op_Equality(ServerVersion a, ServerVersion b);
    public static bool op_Inequality(ServerVersion a, ServerVersion b);
    public static bool op_GreaterThan(ServerVersion a, ServerVersion b);
    public static bool op_GreaterThanOrEqual(ServerVersion a, ServerVersion b);
    public static bool op_LessThan(ServerVersion a, ServerVersion b);
    public static bool op_LessThanOrEqual(ServerVersion a, ServerVersion b);
    [CompilerGeneratedAttribute]
private int <CompareTo>g__ComparePreReleases|24_0(<>c__DisplayClass24_0& );
    [CompilerGeneratedAttribute]
private int <CompareTo>g__CompareCommitsAfterRelease|24_1(<>c__DisplayClass24_0& );
}
public class MongoDB.Driver.Core.Misc.SizeLimitingBatchableSourceSerializer`1 : SerializerBase`1<BatchableSource`1<TItem>> {
    private IElementNameValidator _itemElementNameValidator;
    private IBsonSerializer`1<TItem> _itemSerializer;
    private int _maxBatchCount;
    private int _maxBatchSize;
    private int _maxItemSize;
    public SizeLimitingBatchableSourceSerializer`1(IBsonSerializer`1<TItem> itemSerializer, IElementNameValidator itemElementNameValidator, int maxBatchCount, int maxItemSize, int maxBatchSize);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual void Serialize(BsonSerializationContext context, BsonSerializationArgs args, BatchableSource`1<TItem> value);
    [CompilerGeneratedAttribute]
private void <Serialize>b__8_0(BsonWriterSettings s);
}
internal class MongoDB.Driver.Core.Misc.SrvRecord : object {
    [CompilerGeneratedAttribute]
private DnsEndPoint <EndPoint>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <TimeToLive>k__BackingField;
    public DnsEndPoint EndPoint { get; }
    public TimeSpan TimeToLive { get; }
    public SrvRecord(DnsEndPoint endPoint, TimeSpan timeToLive);
    [CompilerGeneratedAttribute]
public DnsEndPoint get_EndPoint();
    [CompilerGeneratedAttribute]
public TimeSpan get_TimeToLive();
}
[ExtensionAttribute]
internal static class MongoDB.Driver.Core.Misc.StreamExtensionMethods : object {
    [ExtensionAttribute]
public static void EfficientCopyTo(Stream input, Stream output);
    [AsyncStateMachineAttribute("MongoDB.Driver.Core.Misc.StreamExtensionMethods/<ReadAsync>d__1")]
[ExtensionAttribute]
public static Task`1<int> ReadAsync(Stream stream, Byte[] buffer, int offset, int count, TimeSpan timeout, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static void ReadBytes(Stream stream, Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static void ReadBytes(Stream stream, IByteBuffer buffer, int offset, int count, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MongoDB.Driver.Core.Misc.StreamExtensionMethods/<ReadBytesAsync>d__4")]
[ExtensionAttribute]
public static Task ReadBytesAsync(Stream stream, Byte[] buffer, int offset, int count, TimeSpan timeout, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MongoDB.Driver.Core.Misc.StreamExtensionMethods/<ReadBytesAsync>d__5")]
[ExtensionAttribute]
public static Task ReadBytesAsync(Stream stream, IByteBuffer buffer, int offset, int count, TimeSpan timeout, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MongoDB.Driver.Core.Misc.StreamExtensionMethods/<WriteAsync>d__6")]
[ExtensionAttribute]
public static Task WriteAsync(Stream stream, Byte[] buffer, int offset, int count, TimeSpan timeout, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static void WriteBytes(Stream stream, IByteBuffer buffer, int offset, int count, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MongoDB.Driver.Core.Misc.StreamExtensionMethods/<WriteBytesAsync>d__8")]
[ExtensionAttribute]
public static Task WriteBytesAsync(Stream stream, IByteBuffer buffer, int offset, int count, TimeSpan timeout, CancellationToken cancellationToken);
}
[ExtensionAttribute]
internal static class MongoDB.Driver.Core.Misc.StringBuilderExtensionMethods : object {
    [ExtensionAttribute]
public static StringBuilder AppendIf(StringBuilder sb, bool condition, string value);
    [ExtensionAttribute]
public static StringBuilder AppendFormatIf(StringBuilder sb, bool condition, string format, Object[] args);
}
internal class MongoDB.Driver.Core.Misc.SystemClock : object {
    public static SystemClock Instance;
    public DateTime UtcNow { get; }
    private static SystemClock();
    public sealed virtual DateTime get_UtcNow();
}
[ExtensionAttribute]
internal static class MongoDB.Driver.Core.Misc.TaskExtensions : object {
    [ExtensionAttribute]
public static void IgnoreExceptions(Task task);
    public static YieldNoContextAwaitable YieldNoContext();
}
internal static class MongoDB.Driver.Core.Misc.ThreadHelper : object {
    public static void Sleep(TimeSpan timeout, CancellationToken cancellationToken);
}
internal static class MongoDB.Driver.Core.Misc.ThreadStaticRandom : object {
    [ThreadStaticAttribute]
private static Random __threadStaticRandom;
    public static int Next(int maxValue);
}
internal static class MongoDB.Driver.Core.Misc.TimeSpanParser : object {
    public static string ToString(TimeSpan value);
    public static TimeSpan Parse(string value);
    public static bool TryParse(string value, TimeSpan& result);
}
internal class MongoDB.Driver.Core.Misc.ToStringComparer`1 : object {
    public sealed virtual int Compare(T x, T y);
}
internal class MongoDB.Driver.Core.Misc.TxtRecord : object {
    [CompilerGeneratedAttribute]
private List`1<string> <Strings>k__BackingField;
    public List`1<string> Strings { get; }
    public TxtRecord(List`1<string> strings);
    [CompilerGeneratedAttribute]
public List`1<string> get_Strings();
}
internal static class MongoDB.Driver.Core.Misc.WireVersion : object {
    public static int Zero;
    public static int Server26;
    public static int Server30;
    public static int Server32;
    public static int Server34;
    public static int Server36;
    public static int Server40;
    public static int Server42;
    public static int Server44;
    public static int Server47;
    public static int Server48;
    public static int Server49;
    public static int Server50;
    public static int Server51;
    public static int Server52;
    public static int Server53;
    public static int Server60;
    public static int Server61;
    public static int Server62;
    public static int Server63;
    public static int Server70;
    public static int Server71;
    public static int Server72;
    public static int Server73;
    public static int Server80;
    private static List`1<WireVersionInfo> __knownWireVersions;
    private static Range`1<int> __supportedWireVersionRange;
    public static Range`1<int> SupportedWireVersionRange { get; }
    private static WireVersion();
    private static Range`1<int> CreateSupportedWireVersionRange(int minWireVersion, int maxWireVersion);
    public static Range`1<int> get_SupportedWireVersionRange();
    public static string GetServerVersionForErrorMessage(int wireVersion);
    public static SemanticVersion ToServerVersion(int wireVersion);
}
public class MongoDB.Driver.Core.Operations.AbortTransactionOperation : EndTransactionOperation {
    protected string CommandName { get; }
    public AbortTransactionOperation(BsonDocument recoveryToken, WriteConcern writeConcern);
    public AbortTransactionOperation(WriteConcern writeConcern);
    protected virtual string get_CommandName();
}
public class MongoDB.Driver.Core.Operations.AggregateExplainOperation : object {
    private Nullable`1<bool> _allowDiskUse;
    private Collation _collation;
    private CollectionNamespace _collectionNamespace;
    private string _comment;
    private BsonValue _hint;
    private Nullable`1<TimeSpan> _maxTime;
    private MessageEncoderSettings _messageEncoderSettings;
    private IReadOnlyList`1<BsonDocument> _pipeline;
    public Nullable`1<bool> AllowDiskUse { get; public set; }
    public Collation Collation { get; public set; }
    public CollectionNamespace CollectionNamespace { get; }
    public string Comment { get; public set; }
    public BsonValue Hint { get; public set; }
    public Nullable`1<TimeSpan> MaxTime { get; public set; }
    public MessageEncoderSettings MessageEncoderSettings { get; }
    public IReadOnlyList`1<BsonDocument> Pipeline { get; }
    public AggregateExplainOperation(CollectionNamespace collectionNamespace, IEnumerable`1<BsonDocument> pipeline, MessageEncoderSettings messageEncoderSettings);
    public Nullable`1<bool> get_AllowDiskUse();
    public void set_AllowDiskUse(Nullable`1<bool> value);
    public Collation get_Collation();
    public void set_Collation(Collation value);
    public CollectionNamespace get_CollectionNamespace();
    public string get_Comment();
    public void set_Comment(string value);
    public BsonValue get_Hint();
    public void set_Hint(BsonValue value);
    public Nullable`1<TimeSpan> get_MaxTime();
    public void set_MaxTime(Nullable`1<TimeSpan> value);
    public MessageEncoderSettings get_MessageEncoderSettings();
    public IReadOnlyList`1<BsonDocument> get_Pipeline();
    internal BsonDocument CreateCommand();
    public sealed virtual BsonDocument Execute(IReadBinding binding, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MongoDB.Driver.Core.Operations.AggregateExplainOperation/<ExecuteAsync>d__32")]
public sealed virtual Task`1<BsonDocument> ExecuteAsync(IReadBinding binding, CancellationToken cancellationToken);
    private ReadCommandOperation`1<BsonDocument> CreateOperation();
    [CompilerGeneratedAttribute]
private BsonValue <CreateCommand>b__30_0();
    [CompilerGeneratedAttribute]
private BsonValue <CreateCommand>b__30_1();
    [CompilerGeneratedAttribute]
private BsonValue <CreateCommand>b__30_2();
    [CompilerGeneratedAttribute]
private BsonValue <CreateCommand>b__30_3();
}
public class MongoDB.Driver.Core.Operations.AggregateOperation`1 : object {
    private Nullable`1<bool> _allowDiskUse;
    private Nullable`1<int> _batchSize;
    private Collation _collation;
    private CollectionNamespace _collectionNamespace;
    private BsonValue _comment;
    private DatabaseNamespace _databaseNamespace;
    private BsonValue _hint;
    private BsonDocument _let;
    private Nullable`1<TimeSpan> _maxAwaitTime;
    private Nullable`1<TimeSpan> _maxTime;
    private MessageEncoderSettings _messageEncoderSettings;
    private IReadOnlyList`1<BsonDocument> _pipeline;
    private ReadConcern _readConcern;
    private IBsonSerializer`1<TResult> _resultSerializer;
    private bool _retryRequested;
    private Nullable`1<bool> _useCursor;
    public Nullable`1<bool> AllowDiskUse { get; public set; }
    public Nullable`1<int> BatchSize { get; public set; }
    public Collation Collation { get; public set; }
    public CollectionNamespace CollectionNamespace { get; }
    public BsonValue Comment { get; public set; }
    public DatabaseNamespace DatabaseNamespace { get; }
    public BsonValue Hint { get; public set; }
    public BsonDocument Let { get; public set; }
    public Nullable`1<TimeSpan> MaxAwaitTime { get; public set; }
    public Nullable`1<TimeSpan> MaxTime { get; public set; }
    public MessageEncoderSettings MessageEncoderSettings { get; }
    public IReadOnlyList`1<BsonDocument> Pipeline { get; }
    public ReadConcern ReadConcern { get; public set; }
    public IBsonSerializer`1<TResult> ResultSerializer { get; }
    public bool RetryRequested { get; public set; }
    [ObsoleteAttribute("Server versions 3.6 and newer always use a cursor.")]
public Nullable`1<bool> UseCursor { get; public set; }
    public AggregateOperation`1(DatabaseNamespace databaseNamespace, IEnumerable`1<BsonDocument> pipeline, IBsonSerializer`1<TResult> resultSerializer, MessageEncoderSettings messageEncoderSettings);
    public AggregateOperation`1(CollectionNamespace collectionNamespace, IEnumerable`1<BsonDocument> pipeline, IBsonSerializer`1<TResult> resultSerializer, MessageEncoderSettings messageEncoderSettings);
    private AggregateOperation`1(IEnumerable`1<BsonDocument> pipeline, IBsonSerializer`1<TResult> resultSerializer, MessageEncoderSettings messageEncoderSettings);
    public Nullable`1<bool> get_AllowDiskUse();
    public void set_AllowDiskUse(Nullable`1<bool> value);
    public Nullable`1<int> get_BatchSize();
    public void set_BatchSize(Nullable`1<int> value);
    public Collation get_Collation();
    public void set_Collation(Collation value);
    public CollectionNamespace get_CollectionNamespace();
    public BsonValue get_Comment();
    public void set_Comment(BsonValue value);
    public DatabaseNamespace get_DatabaseNamespace();
    public BsonValue get_Hint();
    public void set_Hint(BsonValue value);
    public BsonDocument get_Let();
    public void set_Let(BsonDocument value);
    public Nullable`1<TimeSpan> get_MaxAwaitTime();
    public void set_MaxAwaitTime(Nullable`1<TimeSpan> value);
    public Nullable`1<TimeSpan> get_MaxTime();
    public void set_MaxTime(Nullable`1<TimeSpan> value);
    public MessageEncoderSettings get_MessageEncoderSettings();
    public IReadOnlyList`1<BsonDocument> get_Pipeline();
    public ReadConcern get_ReadConcern();
    public void set_ReadConcern(ReadConcern value);
    public IBsonSerializer`1<TResult> get_ResultSerializer();
    public bool get_RetryRequested();
    public void set_RetryRequested(bool value);
    public Nullable`1<bool> get_UseCursor();
    public void set_UseCursor(Nullable`1<bool> value);
    public sealed virtual IAsyncCursor`1<TResult> Execute(IReadBinding binding, CancellationToken cancellationToken);
    public sealed virtual IAsyncCursor`1<TResult> Execute(RetryableReadContext context, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MongoDB.Driver.Core.Operations.AggregateOperation`1/<ExecuteAsync>d__64")]
public sealed virtual Task`1<IAsyncCursor`1<TResult>> ExecuteAsync(IReadBinding binding, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MongoDB.Driver.Core.Operations.AggregateOperation`1/<ExecuteAsync>d__65")]
public sealed virtual Task`1<IAsyncCursor`1<TResult>> ExecuteAsync(RetryableReadContext context, CancellationToken cancellationToken);
    public IReadOperation`1<BsonDocument> ToExplainOperation(ExplainVerbosity verbosity);
    internal BsonDocument CreateCommand(ConnectionDescription connectionDescription, ICoreSession session);
    private IDisposable BeginOperation();
    private ReadCommandOperation`1<AggregateResult<TResult>> CreateOperation(RetryableReadContext context);
    private AsyncCursor`1<TResult> CreateCursor(IChannelSourceHandle channelSource, IChannelHandle channel, AggregateResult<TResult> result);
    private AsyncCursor`1<TResult> CreateCursorFromCursorResult(IChannelSourceHandle channelSource, IChannelHandle channel, AggregateResult<TResult> result);
    private AsyncCursor`1<TResult> CreateCursorFromInlineResult(AggregateResult<TResult> result);
    private void EnsureIsReadOnlyPipeline();
    [CompilerGeneratedAttribute]
private BsonValue <CreateCommand>b__67_0();
    [CompilerGeneratedAttribute]
private BsonValue <CreateCommand>b__67_1();
    [CompilerGeneratedAttribute]
private BsonValue <CreateCommand>b__67_2();
    [CompilerGeneratedAttribute]
private BsonValue <CreateCommand>b__67_3();
}
public class MongoDB.Driver.Core.Operations.AggregateToCollectionOperation : object {
    private Nullable`1<bool> _allowDiskUse;
    private Nullable`1<bool> _bypassDocumentValidation;
    private Collation _collation;
    private CollectionNamespace _collectionNamespace;
    private BsonValue _comment;
    private DatabaseNamespace _databaseNamespace;
    private BsonValue _hint;
    private BsonDocument _let;
    private Nullable`1<TimeSpan> _maxTime;
    private MessageEncoderSettings _messageEncoderSettings;
    private IReadOnlyList`1<BsonDocument> _pipeline;
    private ReadConcern _readConcern;
    private ReadPreference _readPreference;
    private WriteConcern _writeConcern;
    public Nullable`1<bool> AllowDiskUse { get; public set; }
    public Nullable`1<bool> BypassDocumentValidation { get; public set; }
    public Collation Collation { get; public set; }
    public CollectionNamespace CollectionNamespace { get; }
    public BsonValue Comment { get; public set; }
    public DatabaseNamespace DatabaseNamespace { get; }
    public BsonValue Hint { get; public set; }
    public BsonDocument Let { get; public set; }
    public Nullable`1<TimeSpan> MaxTime { get; public set; }
    public MessageEncoderSettings MessageEncoderSettings { get; }
    public IReadOnlyList`1<BsonDocument> Pipeline { get; }
    public ReadConcern ReadConcern { get; public set; }
    public ReadPreference ReadPreference { get; public set; }
    public WriteConcern WriteConcern { get; public set; }
    public AggregateToCollectionOperation(DatabaseNamespace databaseNamespace, IEnumerable`1<BsonDocument> pipeline, MessageEncoderSettings messageEncoderSettings);
    public AggregateToCollectionOperation(CollectionNamespace collectionNamespace, IEnumerable`1<BsonDocument> pipeline, MessageEncoderSettings messageEncoderSettings);
    public Nullable`1<bool> get_AllowDiskUse();
    public void set_AllowDiskUse(Nullable`1<bool> value);
    public Nullable`1<bool> get_BypassDocumentValidation();
    public void set_BypassDocumentValidation(Nullable`1<bool> value);
    public Collation get_Collation();
    public void set_Collation(Collation value);
    public CollectionNamespace get_CollectionNamespace();
    public BsonValue get_Comment();
    public void set_Comment(BsonValue value);
    public DatabaseNamespace get_DatabaseNamespace();
    public BsonValue get_Hint();
    public void set_Hint(BsonValue value);
    public BsonDocument get_Let();
    public void set_Let(BsonDocument value);
    public Nullable`1<TimeSpan> get_MaxTime();
    public void set_MaxTime(Nullable`1<TimeSpan> value);
    public MessageEncoderSettings get_MessageEncoderSettings();
    public IReadOnlyList`1<BsonDocument> get_Pipeline();
    public ReadConcern get_ReadConcern();
    public void set_ReadConcern(ReadConcern value);
    public ReadPreference get_ReadPreference();
    public void set_ReadPreference(ReadPreference value);
    public WriteConcern get_WriteConcern();
    public void set_WriteConcern(WriteConcern value);
    public sealed virtual BsonDocument Execute(IWriteBinding binding, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MongoDB.Driver.Core.Operations.AggregateToCollectionOperation/<ExecuteAsync>d__55")]
public sealed virtual Task`1<BsonDocument> ExecuteAsync(IWriteBinding binding, CancellationToken cancellationToken);
    internal BsonDocument CreateCommand(ICoreSessionHandle session, ConnectionDescription connectionDescription);
    private IDisposable BeginOperation();
    private WriteCommandOperation`1<BsonDocument> CreateOperation(ICoreSessionHandle session, ConnectionDescription connectionDescription, ReadPreference effectiveReadPreference);
    private void EnsureIsOutputToCollectionPipeline();
    private IReadOnlyList`1<BsonDocument> SimplifyOutStageIfOutputDatabaseIsSameAsInputDatabase(IReadOnlyList`1<BsonDocument> pipeline);
    [CompilerGeneratedAttribute]
private BsonValue <CreateCommand>b__56_0();
    [CompilerGeneratedAttribute]
private BsonValue <CreateCommand>b__56_1();
    [CompilerGeneratedAttribute]
private BsonValue <CreateCommand>b__56_2();
    [CompilerGeneratedAttribute]
private BsonValue <CreateCommand>b__56_3();
}
public class MongoDB.Driver.Core.Operations.AsyncCursor`1 : object {
    private static IBsonSerializer`1<BsonDocument> __getMoreCommandResultSerializer;
    private Nullable`1<int> _batchSize;
    private CollectionNamespace _collectionNamespace;
    private IChannelSource _channelSource;
    private bool _closed;
    private BsonValue _comment;
    private int _count;
    private IReadOnlyList`1<TDocument> _currentBatch;
    private long _cursorId;
    private bool _disposed;
    private IReadOnlyList`1<TDocument> _firstBatch;
    private Nullable`1<int> _limit;
    private Nullable`1<TimeSpan> _maxTime;
    private MessageEncoderSettings _messageEncoderSettings;
    private Nullable`1<long> _operationId;
    private BsonDocument _postBatchResumeToken;
    private IBsonSerializer`1<TDocument> _serializer;
    private bool _wasFirstBatchEmpty;
    public IEnumerable`1<TDocument> Current { get; }
    public bool WasFirstBatchEmpty { get; }
    public BsonDocument PostBatchResumeToken { get; }
    public AsyncCursor`1(IChannelSource channelSource, CollectionNamespace collectionNamespace, BsonValue comment, IReadOnlyList`1<TDocument> firstBatch, long cursorId, Nullable`1<int> batchSize, Nullable`1<int> limit, IBsonSerializer`1<TDocument> serializer, MessageEncoderSettings messageEncoderSettings, Nullable`1<TimeSpan> maxTime);
    [ObsoleteAttribute("Use overload without query.")]
public AsyncCursor`1(IChannelSource channelSource, CollectionNamespace collectionNamespace, BsonDocument query, IReadOnlyList`1<TDocument> firstBatch, long cursorId, Nullable`1<int> batchSize, Nullable`1<int> limit, IBsonSerializer`1<TDocument> serializer, MessageEncoderSettings messageEncoderSettings, Nullable`1<TimeSpan> maxTime);
    [ObsoleteAttribute("Use overload without query.")]
public AsyncCursor`1(IChannelSource channelSource, CollectionNamespace collectionNamespace, BsonDocument query, IReadOnlyList`1<TDocument> firstBatch, long cursorId, BsonDocument postBatchResumeToken, Nullable`1<int> batchSize, Nullable`1<int> limit, IBsonSerializer`1<TDocument> serializer, MessageEncoderSettings messageEncoderSettings, Nullable`1<TimeSpan> maxTime);
    public AsyncCursor`1(IChannelSource channelSource, CollectionNamespace collectionNamespace, BsonValue comment, IReadOnlyList`1<TDocument> firstBatch, long cursorId, BsonDocument postBatchResumeToken, Nullable`1<int> batchSize, Nullable`1<int> limit, IBsonSerializer`1<TDocument> serializer, MessageEncoderSettings messageEncoderSettings, Nullable`1<TimeSpan> maxTime);
    private static AsyncCursor`1();
    public sealed virtual IEnumerable`1<TDocument> get_Current();
    public sealed virtual bool get_WasFirstBatchEmpty();
    public sealed virtual BsonDocument get_PostBatchResumeToken();
    private int CalculateGetMoreNumberToReturn();
    public void Close(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MongoDB.Driver.Core.Operations.AsyncCursor`1/<CloseAsync>d__30")]
public Task CloseAsync(CancellationToken cancellationToken);
    private CursorBatch`1<TDocument> CreateCursorBatch(BsonDocument result);
    private BsonDocument CreateGetMoreCommand(ConnectionDescription connectionDescription);
    private BsonDocument CreateKillCursorsCommand();
    private CursorBatch`1<TDocument> ExecuteGetMoreCommand(IChannelHandle channel, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MongoDB.Driver.Core.Operations.AsyncCursor`1/<ExecuteGetMoreCommandAsync>d__35")]
private Task`1<CursorBatch`1<TDocument>> ExecuteGetMoreCommandAsync(IChannelHandle channel, CancellationToken cancellationToken);
    private void ExecuteKillCursorsCommand(IChannelHandle channel, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MongoDB.Driver.Core.Operations.AsyncCursor`1/<ExecuteKillCursorsCommandAsync>d__37")]
private Task ExecuteKillCursorsCommandAsync(IChannelHandle channel, CancellationToken cancellationToken);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    private void CloseIfNotAlreadyClosed(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MongoDB.Driver.Core.Operations.AsyncCursor`1/<CloseIfNotAlreadyClosedAsync>d__41")]
private Task CloseIfNotAlreadyClosedAsync(CancellationToken cancellationToken);
    private void CloseIfNotAlreadyClosedFromDispose();
    private void DisposeChannelSourceIfNoLongerNeeded();
    private CursorBatch`1<TDocument> GetNextBatch(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MongoDB.Driver.Core.Operations.AsyncCursor`1/<GetNextBatchAsync>d__45")]
private Task`1<CursorBatch`1<TDocument>> GetNextBatchAsync(CancellationToken cancellationToken);
    private bool IsMongoCursorNotFoundException(MongoCommandException exception);
    private void KillCursors(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MongoDB.Driver.Core.Operations.AsyncCursor`1/<KillCursorsAsync>d__48")]
private Task KillCursorsAsync(CancellationToken cancellationToken);
    public sealed virtual bool MoveNext(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MongoDB.Driver.Core.Operations.AsyncCursor`1/<MoveNextAsync>d__50")]
public sealed virtual Task`1<bool> MoveNextAsync(CancellationToken cancellationToken);
    private void SaveBatch(CursorBatch`1<TDocument> batch);
    private void ThrowIfDisposed();
    private void ThrowIfKillCursorsCommandFailed(BsonDocument commandResult, ConnectionId connectionId);
    private bool TryMoveNext(Boolean& hasMore);
    [CompilerGeneratedAttribute]
private BsonValue <CreateGetMoreCommand>b__32_0();
    [CompilerGeneratedAttribute]
private BsonValue <CreateGetMoreCommand>b__32_1();
}
internal class MongoDB.Driver.Core.Operations.AsyncCursorEnumerableOneTimeAdapter`1 : object {
    private CancellationToken _cancellationToken;
    private IAsyncCursor`1<TDocument> _cursor;
    private bool _hasBeenEnumerated;
    public AsyncCursorEnumerableOneTimeAdapter`1(IAsyncCursor`1<TDocument> cursor, CancellationToken cancellationToken);
    public sealed virtual IEnumerator`1<TDocument> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal class MongoDB.Driver.Core.Operations.AsyncCursorEnumerator`1 : object {
    private IEnumerator`1<TDocument> _batchEnumerator;
    private CancellationToken _cancellationToken;
    private IAsyncCursor`1<TDocument> _cursor;
    private bool _disposed;
    private bool _finished;
    private bool _started;
    public TDocument Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    public AsyncCursorEnumerator`1(IAsyncCursor`1<TDocument> cursor, CancellationToken cancellationToken);
    public sealed virtual TDocument get_Current();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual void Dispose();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
    private void ThrowIfDisposed();
}
internal class MongoDB.Driver.Core.Operations.AsyncCursorSourceEnumerableAdapter`1 : object {
    private CancellationToken _cancellationToken;
    private IAsyncCursorSource`1<TDocument> _source;
    public AsyncCursorSourceEnumerableAdapter`1(IAsyncCursorSource`1<TDocument> source, CancellationToken cancellationToken);
    public sealed virtual IEnumerator`1<TDocument> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal class MongoDB.Driver.Core.Operations.BulkDeleteOperation : BulkUnmixedWriteOperationBase`1<DeleteRequest> {
    private BsonDocument _let;
    public BsonDocument Let { get; public set; }
    public BulkDeleteOperation(CollectionNamespace collectionNamespace, IEnumerable`1<DeleteRequest> requests, MessageEncoderSettings messageEncoderSettings);
    public BsonDocument get_Let();
    public void set_Let(BsonDocument value);
    protected virtual IRetryableWriteOperation`1<BsonDocument> CreateBatchOperation(Batch<DeleteRequest> batch);
    protected virtual bool RequestHasHint(DeleteRequest request);
}
internal class MongoDB.Driver.Core.Operations.BulkInsertOperation : BulkUnmixedWriteOperationBase`1<InsertRequest> {
    public BulkInsertOperation(CollectionNamespace collectionNamespace, IEnumerable`1<InsertRequest> requests, MessageEncoderSettings messageEncoderSettings);
    protected virtual IRetryableWriteOperation`1<BsonDocument> CreateBatchOperation(Batch<InsertRequest> batch);
    protected virtual bool RequestHasHint(InsertRequest request);
}
public class MongoDB.Driver.Core.Operations.BulkMixedWriteOperation : object {
    private Nullable`1<bool> _bypassDocumentValidation;
    private CollectionNamespace _collectionNamespace;
    private BsonValue _comment;
    private bool _isOrdered;
    private BsonDocument _let;
    private Nullable`1<int> _maxBatchCount;
    private Nullable`1<int> _maxBatchLength;
    private Nullable`1<int> _maxDocumentSize;
    private Nullable`1<int> _maxWireDocumentSize;
    private MessageEncoderSettings _messageEncoderSettings;
    private List`1<WriteRequest> _requests;
    private bool _retryRequested;
    private WriteConcern _writeConcern;
    public Nullable`1<bool> BypassDocumentValidation { get; public set; }
    public CollectionNamespace CollectionNamespace { get; }
    public BsonValue Comment { get; public set; }
    public bool IsOrdered { get; public set; }
    public BsonDocument Let { get; public set; }
    public Nullable`1<int> MaxBatchCount { get; public set; }
    public Nullable`1<int> MaxBatchLength { get; public set; }
    public Nullable`1<int> MaxDocumentSize { get; public set; }
    public Nullable`1<int> MaxWireDocumentSize { get; public set; }
    public MessageEncoderSettings MessageEncoderSettings { get; }
    public IEnumerable`1<WriteRequest> Requests { get; }
    public bool RetryRequested { get; public set; }
    public WriteConcern WriteConcern { get; public set; }
    public BulkMixedWriteOperation(CollectionNamespace collectionNamespace, IEnumerable`1<WriteRequest> requests, MessageEncoderSettings messageEncoderSettings);
    public BulkMixedWriteOperation(CollectionNamespace collectionNamespace, List`1<WriteRequest> requests, MessageEncoderSettings messageEncoderSettings);
    public Nullable`1<bool> get_BypassDocumentValidation();
    public void set_BypassDocumentValidation(Nullable`1<bool> value);
    public CollectionNamespace get_CollectionNamespace();
    public BsonValue get_Comment();
    public void set_Comment(BsonValue value);
    public bool get_IsOrdered();
    public void set_IsOrdered(bool value);
    public BsonDocument get_Let();
    public void set_Let(BsonDocument value);
    public Nullable`1<int> get_MaxBatchCount();
    public void set_MaxBatchCount(Nullable`1<int> value);
    public Nullable`1<int> get_MaxBatchLength();
    public void set_MaxBatchLength(Nullable`1<int> value);
    public Nullable`1<int> get_MaxDocumentSize();
    public void set_MaxDocumentSize(Nullable`1<int> value);
    public Nullable`1<int> get_MaxWireDocumentSize();
    public void set_MaxWireDocumentSize(Nullable`1<int> value);
    public MessageEncoderSettings get_MessageEncoderSettings();
    public IEnumerable`1<WriteRequest> get_Requests();
    public bool get_RetryRequested();
    public void set_RetryRequested(bool value);
    public WriteConcern get_WriteConcern();
    public void set_WriteConcern(WriteConcern value);
    public sealed virtual BulkWriteOperationResult Execute(IWriteBinding binding, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MongoDB.Driver.Core.Operations.BulkMixedWriteOperation/<ExecuteAsync>d__52")]
public sealed virtual Task`1<BulkWriteOperationResult> ExecuteAsync(IWriteBinding binding, CancellationToken cancellationToken);
    private IDisposable BeginOperation();
    private IExecutableInRetryableWriteContext`1<BulkWriteOperationResult> CreateBulkDeleteOperation(Batch batch);
    private IExecutableInRetryableWriteContext`1<BulkWriteOperationResult> CreateBulkInsertOperation(Batch batch);
    private IExecutableInRetryableWriteContext`1<BulkWriteOperationResult> CreateBulkUpdateOperation(Batch batch);
    private IExecutableInRetryableWriteContext`1<BulkWriteOperationResult> CreateUnmixedBatchOperation(Batch batch);
    private void EnsureHintIsSupportedIfAnyRequestHasHint();
    private BulkWriteBatchResult ExecuteBatch(RetryableWriteContext context, Batch batch, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MongoDB.Driver.Core.Operations.BulkMixedWriteOperation/<ExecuteBatchAsync>d__60")]
private Task`1<BulkWriteBatchResult> ExecuteBatchAsync(RetryableWriteContext context, Batch batch, CancellationToken cancellationToken);
    private bool RequestHasHint(WriteRequest request);
}
internal abstract class MongoDB.Driver.Core.Operations.BulkUnmixedWriteOperationBase`1 : object {
    private Nullable`1<bool> _bypassDocumentValidation;
    private CollectionNamespace _collectionNamespace;
    private BsonValue _comment;
    private bool _isOrdered;
    private Nullable`1<int> _maxBatchCount;
    private Nullable`1<int> _maxBatchLength;
    private MessageEncoderSettings _messageEncoderSettings;
    private List`1<TWriteRequest> _requests;
    private bool _retryRequested;
    private WriteConcern _writeConcern;
    public Nullable`1<bool> BypassDocumentValidation { get; public set; }
    public CollectionNamespace CollectionNamespace { get; }
    public BsonValue Comment { get; public set; }
    public bool IsOrdered { get; public set; }
    public Nullable`1<int> MaxBatchCount { get; public set; }
    public Nullable`1<int> MaxBatchLength { get; public set; }
    public MessageEncoderSettings MessageEncoderSettings { get; public set; }
    public IEnumerable`1<TWriteRequest> Requests { get; }
    public bool RetryRequested { get; public set; }
    public WriteConcern WriteConcern { get; public set; }
    protected BulkUnmixedWriteOperationBase`1(CollectionNamespace collectionNamespace, IEnumerable`1<TWriteRequest> requests, MessageEncoderSettings messageEncoderSettings);
    protected BulkUnmixedWriteOperationBase`1(CollectionNamespace collectionNamespace, List`1<TWriteRequest> requests, MessageEncoderSettings messageEncoderSettings);
    public Nullable`1<bool> get_BypassDocumentValidation();
    public void set_BypassDocumentValidation(Nullable`1<bool> value);
    public CollectionNamespace get_CollectionNamespace();
    public BsonValue get_Comment();
    public void set_Comment(BsonValue value);
    public bool get_IsOrdered();
    public void set_IsOrdered(bool value);
    public Nullable`1<int> get_MaxBatchCount();
    public void set_MaxBatchCount(Nullable`1<int> value);
    public Nullable`1<int> get_MaxBatchLength();
    public void set_MaxBatchLength(Nullable`1<int> value);
    public MessageEncoderSettings get_MessageEncoderSettings();
    public void set_MessageEncoderSettings(MessageEncoderSettings value);
    public IEnumerable`1<TWriteRequest> get_Requests();
    public bool get_RetryRequested();
    public void set_RetryRequested(bool value);
    public WriteConcern get_WriteConcern();
    public void set_WriteConcern(WriteConcern value);
    public sealed virtual BulkWriteOperationResult Execute(RetryableWriteContext context, CancellationToken cancellationToken);
    public sealed virtual BulkWriteOperationResult Execute(IWriteBinding binding, CancellationToken cancellationToken);
    public sealed virtual Task`1<BulkWriteOperationResult> ExecuteAsync(RetryableWriteContext context, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MongoDB.Driver.Core.Operations.BulkUnmixedWriteOperationBase`1/<ExecuteAsync>d__43")]
public sealed virtual Task`1<BulkWriteOperationResult> ExecuteAsync(IWriteBinding binding, CancellationToken cancellationToken);
    protected abstract virtual IRetryableWriteOperation`1<BsonDocument> CreateBatchOperation(Batch<TWriteRequest> batch);
    protected abstract virtual bool RequestHasHint(TWriteRequest request);
    private IDisposable BeginOperation();
    private BulkWriteBatchResult CreateBatchResult(Batch<TWriteRequest> batch, BsonDocument writeCommandResult, MongoWriteConcernException writeConcernException);
    private void EnsureHintIsSupportedIfAnyRequestHasHint();
    private BulkWriteBatchResult ExecuteBatch(RetryableWriteContext context, Batch<TWriteRequest> batch, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MongoDB.Driver.Core.Operations.BulkUnmixedWriteOperationBase`1/<ExecuteBatchAsync>d__50")]
private Task`1<BulkWriteBatchResult> ExecuteBatchAsync(RetryableWriteContext context, Batch<TWriteRequest> batch, CancellationToken cancellationToken);
    private BulkWriteOperationResult ExecuteBatches(RetryableWriteContext context, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MongoDB.Driver.Core.Operations.BulkUnmixedWriteOperationBase`1/<ExecuteBatchesAsync>d__52")]
private Task`1<BulkWriteOperationResult> ExecuteBatchesAsync(RetryableWriteContext context, CancellationToken cancellationToken);
}
internal class MongoDB.Driver.Core.Operations.BulkUpdateOperation : BulkUnmixedWriteOperationBase`1<UpdateRequest> {
    private BsonDocument _let;
    public BsonDocument Let { get; public set; }
    public BulkUpdateOperation(CollectionNamespace collectionNamespace, IEnumerable`1<UpdateRequest> requests, MessageEncoderSettings messageEncoderSettings);
    public BsonDocument get_Let();
    public void set_Let(BsonDocument value);
    protected virtual IRetryableWriteOperation`1<BsonDocument> CreateBatchOperation(Batch<UpdateRequest> batch);
    protected virtual bool RequestHasHint(UpdateRequest request);
}
internal class MongoDB.Driver.Core.Operations.BulkWriteBatchResult : object {
    private static IReadOnlyList`1<BulkWriteOperationUpsert> __noUpserts;
    private static IReadOnlyList`1<BulkWriteOperationError> __noWriteErrors;
    private static IReadOnlyList`1<WriteRequest> __noWriteRequests;
    private int _batchCount;
    private long _deletedCount;
    private IndexMap _indexMap;
    private long _insertedCount;
    private long _matchedCount;
    private Nullable`1<long> _modifiedCount;
    private IReadOnlyList`1<WriteRequest> _processedRequests;
    private IReadOnlyList`1<WriteRequest> _unprocessedRequests;
    private IReadOnlyList`1<BulkWriteOperationUpsert> _upserts;
    private BulkWriteConcernError _writeConcernError;
    private IReadOnlyList`1<BulkWriteOperationError> _writeErrors;
    public int BatchCount { get; }
    public long DeletedCount { get; }
    public bool HasWriteConcernError { get; }
    public bool HasWriteErrors { get; }
    public IndexMap IndexMap { get; }
    public long InsertedCount { get; }
    public long MatchedCount { get; }
    public Nullable`1<long> ModifiedCount { get; }
    public IReadOnlyList`1<WriteRequest> ProcessedRequests { get; }
    public IReadOnlyList`1<WriteRequest> UnprocessedRequests { get; }
    public IReadOnlyList`1<BulkWriteOperationUpsert> Upserts { get; }
    public BulkWriteConcernError WriteConcernError { get; }
    public IReadOnlyList`1<BulkWriteOperationError> WriteErrors { get; }
    public BulkWriteBatchResult(int batchCount, IReadOnlyList`1<WriteRequest> processedRequests, IReadOnlyList`1<WriteRequest> unprocessedRequests, long matchedCount, long deletedCount, long insertedCount, Nullable`1<long> modifiedCount, IReadOnlyList`1<BulkWriteOperationUpsert> upserts, IReadOnlyList`1<BulkWriteOperationError> writeErrors, BulkWriteConcernError writeConcernError, IndexMap indexMap);
    private static BulkWriteBatchResult();
    public static BulkWriteBatchResult Create(bool isOrdered, IReadOnlyList`1<WriteRequest> requests, BsonDocument writeCommandResponse, IndexMap indexMap, MongoWriteConcernException writeConcernException);
    public static BulkWriteBatchResult Create(BulkWriteOperationResult result, MongoBulkWriteOperationException exception, IndexMap indexMap);
    private static IReadOnlyList`1<WriteRequest> CreateProcessedRequests(IReadOnlyList`1<WriteRequest> requests, IReadOnlyList`1<BulkWriteOperationError> writeErrors, bool isOrdered);
    private static IReadOnlyList`1<WriteRequest> CreateUnprocessedRequests(IReadOnlyList`1<WriteRequest> requests, IReadOnlyList`1<BulkWriteOperationError> writeErrors, bool isOrdered);
    private static IReadOnlyList`1<BulkWriteOperationUpsert> CreateUpserts(BsonDocument writeCommandResponse);
    private static BulkWriteConcernError CreateWriteConcernError(BsonDocument writeCommandResponse, MongoWriteConcernException writeConcernException);
    private static IReadOnlyList`1<BulkWriteOperationError> CreateWriteErrors(BsonDocument writeCommandResponse);
    public int get_BatchCount();
    public long get_DeletedCount();
    public bool get_HasWriteConcernError();
    public bool get_HasWriteErrors();
    public IndexMap get_IndexMap();
    public long get_InsertedCount();
    public long get_MatchedCount();
    public Nullable`1<long> get_ModifiedCount();
    public IReadOnlyList`1<WriteRequest> get_ProcessedRequests();
    public IReadOnlyList`1<WriteRequest> get_UnprocessedRequests();
    public IReadOnlyList`1<BulkWriteOperationUpsert> get_Upserts();
    public BulkWriteConcernError get_WriteConcernError();
    public IReadOnlyList`1<BulkWriteOperationError> get_WriteErrors();
}
internal class MongoDB.Driver.Core.Operations.BulkWriteBatchResultCombiner : object {
    private IReadOnlyList`1<BulkWriteBatchResult> _batchResults;
    private bool _isAcknowledged;
    public BulkWriteBatchResultCombiner(IReadOnlyList`1<BulkWriteBatchResult> batchResults, bool isAcknowledged);
    private int CombineBatchCount();
    private long CombineDeletedCount();
    private long CombineInsertedCount();
    private long CombineMatchedCount();
    private Nullable`1<long> CombineModifiedCount();
    private IReadOnlyList`1<WriteRequest> CombineProcessedRequests();
    private IReadOnlyList`1<WriteRequest> CombineUnprocessedRequests(IReadOnlyList`1<WriteRequest> remainingRequests);
    private IReadOnlyList`1<BulkWriteOperationUpsert> CombineUpserts();
    private BulkWriteConcernError CombineWriteConcernErrors();
    private IReadOnlyList`1<BulkWriteOperationError> CombineWriteErrors();
    private MongoBulkWriteOperationException CreateBulkWriteException(ConnectionId connectionId, IEnumerable`1<WriteRequest> remainingRequests);
    private BulkWriteOperationResult CreateBulkWriteResult(int remainingRequestsCount);
    public BulkWriteOperationResult CreateResultOrThrowIfHasErrors(ConnectionId connectionId, IReadOnlyList`1<WriteRequest> remainingRequests);
}
public class MongoDB.Driver.Core.Operations.BulkWriteConcernError : object {
    private int _code;
    private string _codeName;
    private BsonDocument _details;
    private IEnumerable`1<string> _errorLabels;
    private string _message;
    public int Code { get; }
    public string CodeName { get; }
    public BsonDocument Details { get; }
    public IEnumerable`1<string> ErrorLabels { get; }
    public string Message { get; }
    public BulkWriteConcernError(int code, string message, BsonDocument details);
    public BulkWriteConcernError(int code, string codeName, string message, BsonDocument details);
    public BulkWriteConcernError(int code, string codeName, string message, BsonDocument details, IEnumerable`1<string> errorLabels);
    public int get_Code();
    public string get_CodeName();
    public BsonDocument get_Details();
    public IEnumerable`1<string> get_ErrorLabels();
    public string get_Message();
}
public class MongoDB.Driver.Core.Operations.BulkWriteOperationError : object {
    private int _code;
    private BsonDocument _details;
    private int _index;
    private string _message;
    public ServerErrorCategory Category { get; }
    public int Code { get; }
    public BsonDocument Details { get; }
    public int Index { get; }
    public string Message { get; }
    public BulkWriteOperationError(int index, int code, string message, BsonDocument details);
    public ServerErrorCategory get_Category();
    public int get_Code();
    public BsonDocument get_Details();
    public int get_Index();
    public string get_Message();
    internal BulkWriteOperationError WithMappedIndex(IndexMap indexMap);
}
public abstract class MongoDB.Driver.Core.Operations.BulkWriteOperationResult : object {
    private IReadOnlyList`1<WriteRequest> _processedRequests;
    private int _requestCount;
    public long DeletedCount { get; }
    public long InsertedCount { get; }
    public bool IsAcknowledged { get; }
    public bool IsModifiedCountAvailable { get; }
    public long MatchedCount { get; }
    public long ModifiedCount { get; }
    public IReadOnlyList`1<WriteRequest> ProcessedRequests { get; }
    public int RequestCount { get; }
    public IReadOnlyList`1<BulkWriteOperationUpsert> Upserts { get; }
    protected BulkWriteOperationResult(int requestCount, IReadOnlyList`1<WriteRequest> processedRequests);
    public abstract virtual long get_DeletedCount();
    public abstract virtual long get_InsertedCount();
    public abstract virtual bool get_IsAcknowledged();
    public abstract virtual bool get_IsModifiedCountAvailable();
    public abstract virtual long get_MatchedCount();
    public abstract virtual long get_ModifiedCount();
    public IReadOnlyList`1<WriteRequest> get_ProcessedRequests();
    public int get_RequestCount();
    public abstract virtual IReadOnlyList`1<BulkWriteOperationUpsert> get_Upserts();
}
internal class MongoDB.Driver.Core.Operations.BulkWriteOperationResultConverter : object {
    public Exception ToWriteConcernException(ConnectionId connectionId, MongoBulkWriteOperationException bulkWriteException);
    public WriteConcernResult ToWriteConcernResult(BulkWriteOperationResult bulkWriteResult);
    private WriteConcernResult ToWriteConcernResult(BulkWriteOperationResult bulkWriteResult, MongoBulkWriteOperationException bulkWriteException);
}
public class MongoDB.Driver.Core.Operations.BulkWriteOperationUpsert : object {
    private BsonValue _id;
    private int _index;
    public BsonValue Id { get; }
    public int Index { get; }
    internal BulkWriteOperationUpsert(int index, BsonValue id);
    public BsonValue get_Id();
    public int get_Index();
    internal BulkWriteOperationUpsert WithMappedIndex(IndexMap indexMap);
}
internal class MongoDB.Driver.Core.Operations.ChangeStreamCursor`1 : object {
    private IReadBinding _binding;
    private IChangeStreamOperation`1<TDocument> _changeStreamOperation;
    private IEnumerable`1<TDocument> _current;
    private IAsyncCursor`1<RawBsonDocument> _cursor;
    private bool _disposed;
    private BsonDocument _documentResumeToken;
    private IBsonSerializer`1<TDocument> _documentSerializer;
    private BsonTimestamp _initialOperationTime;
    private BsonDocument _postBatchResumeToken;
    private BsonDocument _initialResumeAfter;
    private BsonDocument _initialStartAfter;
    private BsonTimestamp _initialStartAtOperationTime;
    private int _maxWireVersion;
    public IEnumerable`1<TDocument> Current { get; }
    public ChangeStreamCursor`1(IAsyncCursor`1<RawBsonDocument> cursor, IBsonSerializer`1<TDocument> documentSerializer, IReadBinding binding, IChangeStreamOperation`1<TDocument> changeStreamOperation, BsonDocument aggregatePostBatchResumeToken, BsonTimestamp initialOperationTime, BsonDocument initialStartAfter, BsonDocument initialResumeAfter, BsonTimestamp initialStartAtOperationTime, int maxWireVersion);
    public sealed virtual IEnumerable`1<TDocument> get_Current();
    public sealed virtual void Dispose();
    public sealed virtual BsonDocument GetResumeToken();
    public sealed virtual bool MoveNext(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MongoDB.Driver.Core.Operations.ChangeStreamCursor`1/<MoveNextAsync>d__19")]
public sealed virtual Task`1<bool> MoveNextAsync(CancellationToken cancellationToken);
    private TDocument DeserializeDocument(RawBsonDocument rawDocument);
    private IEnumerable`1<TDocument> DeserializeDocuments(IEnumerable`1<RawBsonDocument> rawDocuments);
    private ResumeValues<TDocument> GetResumeValues();
    private void ProcessBatch(bool hasMore);
    private void ReconfigureOperationResumeValues();
    private IAsyncCursor`1<RawBsonDocument> Resume(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MongoDB.Driver.Core.Operations.ChangeStreamCursor`1/<ResumeAsync>d__26")]
private Task`1<IAsyncCursor`1<RawBsonDocument>> ResumeAsync(CancellationToken cancellationToken);
}
public class MongoDB.Driver.Core.Operations.ChangeStreamOperation`1 : object {
    private Nullable`1<int> _batchSize;
    private Collation _collation;
    private BsonValue _comment;
    private CollectionNamespace _collectionNamespace;
    private DatabaseNamespace _databaseNamespace;
    private ChangeStreamFullDocumentOption _fullDocument;
    private ChangeStreamFullDocumentBeforeChangeOption _fullDocumentBeforeChangeOption;
    private Nullable`1<TimeSpan> _maxAwaitTime;
    private MessageEncoderSettings _messageEncoderSettings;
    private IReadOnlyList`1<BsonDocument> _pipeline;
    private ReadConcern _readConcern;
    private IBsonSerializer`1<TResult> _resultSerializer;
    private BsonDocument _resumeAfter;
    private bool _retryRequested;
    private Nullable`1<bool> _showExpandedEvents;
    private BsonDocument _startAfter;
    private BsonTimestamp _startAtOperationTime;
    public Nullable`1<int> BatchSize { get; public set; }
    public Collation Collation { get; public set; }
    public BsonValue Comment { get; public set; }
    public CollectionNamespace CollectionNamespace { get; }
    public DatabaseNamespace DatabaseNamespace { get; }
    public ChangeStreamFullDocumentOption FullDocument { get; public set; }
    public ChangeStreamFullDocumentBeforeChangeOption FullDocumentBeforeChange { get; public set; }
    public Nullable`1<TimeSpan> MaxAwaitTime { get; public set; }
    public MessageEncoderSettings MessageEncoderSettings { get; }
    public IReadOnlyList`1<BsonDocument> Pipeline { get; }
    public ReadConcern ReadConcern { get; public set; }
    public IBsonSerializer`1<TResult> ResultSerializer { get; }
    public BsonDocument ResumeAfter { get; public set; }
    public bool RetryRequested { get; public set; }
    public Nullable`1<bool> ShowExpandedEvents { get; public set; }
    public BsonDocument StartAfter { get; public set; }
    public BsonTimestamp StartAtOperationTime { get; public set; }
    public ChangeStreamOperation`1(IEnumerable`1<BsonDocument> pipeline, IBsonSerializer`1<TResult> resultSerializer, MessageEncoderSettings messageEncoderSettings);
    public ChangeStreamOperation`1(DatabaseNamespace databaseNamespace, IEnumerable`1<BsonDocument> pipeline, IBsonSerializer`1<TResult> resultSerializer, MessageEncoderSettings messageEncoderSettings);
    public ChangeStreamOperation`1(CollectionNamespace collectionNamespace, IEnumerable`1<BsonDocument> pipeline, IBsonSerializer`1<TResult> resultSerializer, MessageEncoderSettings messageEncoderSettings);
    public Nullable`1<int> get_BatchSize();
    public void set_BatchSize(Nullable`1<int> value);
    public Collation get_Collation();
    public void set_Collation(Collation value);
    public BsonValue get_Comment();
    public void set_Comment(BsonValue value);
    public CollectionNamespace get_CollectionNamespace();
    public DatabaseNamespace get_DatabaseNamespace();
    public ChangeStreamFullDocumentOption get_FullDocument();
    public void set_FullDocument(ChangeStreamFullDocumentOption value);
    public ChangeStreamFullDocumentBeforeChangeOption get_FullDocumentBeforeChange();
    public void set_FullDocumentBeforeChange(ChangeStreamFullDocumentBeforeChangeOption value);
    public Nullable`1<TimeSpan> get_MaxAwaitTime();
    public void set_MaxAwaitTime(Nullable`1<TimeSpan> value);
    public MessageEncoderSettings get_MessageEncoderSettings();
    public IReadOnlyList`1<BsonDocument> get_Pipeline();
    public ReadConcern get_ReadConcern();
    public void set_ReadConcern(ReadConcern value);
    public IBsonSerializer`1<TResult> get_ResultSerializer();
    public sealed virtual BsonDocument get_ResumeAfter();
    public sealed virtual void set_ResumeAfter(BsonDocument value);
    public bool get_RetryRequested();
    public void set_RetryRequested(bool value);
    public sealed virtual Nullable`1<bool> get_ShowExpandedEvents();
    public sealed virtual void set_ShowExpandedEvents(Nullable`1<bool> value);
    public sealed virtual BsonDocument get_StartAfter();
    public sealed virtual void set_StartAfter(BsonDocument value);
    public sealed virtual BsonTimestamp get_StartAtOperationTime();
    public sealed virtual void set_StartAtOperationTime(BsonTimestamp value);
    public sealed virtual IChangeStreamCursor`1<TResult> Execute(IReadBinding binding, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MongoDB.Driver.Core.Operations.ChangeStreamOperation`1/<ExecuteAsync>d__67")]
public sealed virtual Task`1<IChangeStreamCursor`1<TResult>> ExecuteAsync(IReadBinding binding, CancellationToken cancellationToken);
    public sealed virtual IAsyncCursor`1<RawBsonDocument> Resume(IReadBinding binding, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MongoDB.Driver.Core.Operations.ChangeStreamOperation`1/<ResumeAsync>d__69")]
public sealed virtual Task`1<IAsyncCursor`1<RawBsonDocument>> ResumeAsync(IReadBinding binding, CancellationToken cancellationToken);
    private AggregateOperation`1<RawBsonDocument> CreateAggregateOperation();
    private BsonDocument CreateChangeStreamStage();
    private List`1<BsonDocument> CreateCombinedPipeline(BsonDocument changeStreamStage);
    private IAsyncCursor`1<RawBsonDocument> ExecuteAggregateOperation(RetryableReadContext context, CancellationToken cancellationToken);
    private Task`1<IAsyncCursor`1<RawBsonDocument>> ExecuteAggregateOperationAsync(RetryableReadContext context, CancellationToken cancellationToken);
    private BsonDocument GetInitialPostBatchResumeTokenIfRequired(ICursorBatchInfo cursorBatchInfo);
    private BsonTimestamp GetInitialOperationTimeIfRequired(RetryableReadContext context, ICursorBatchInfo cursorBatchInfo);
    private string ToString(ChangeStreamFullDocumentOption fullDocument);
    private string ToString(ChangeStreamFullDocumentBeforeChangeOption fullDocumentBeforeChange);
    [CompilerGeneratedAttribute]
private BsonValue <CreateChangeStreamStage>b__71_0();
    [CompilerGeneratedAttribute]
private BsonValue <CreateChangeStreamStage>b__71_1();
}
public abstract class MongoDB.Driver.Core.Operations.CommandOperationBase`1 : object {
    private BsonDocument _additionalOptions;
    private BsonDocument _command;
    private IElementNameValidator _commandValidator;
    private string _comment;
    private DatabaseNamespace _databaseNamespace;
    private MessageEncoderSettings _messageEncoderSettings;
    private IBsonSerializer`1<TCommandResult> _resultSerializer;
    public BsonDocument AdditionalOptions { get; public set; }
    public BsonDocument Command { get; }
    public IElementNameValidator CommandValidator { get; public set; }
    public string Comment { get; public set; }
    public DatabaseNamespace DatabaseNamespace { get; }
    public MessageEncoderSettings MessageEncoderSettings { get; }
    public IBsonSerializer`1<TCommandResult> ResultSerializer { get; }
    protected CommandOperationBase`1(DatabaseNamespace databaseNamespace, BsonDocument command, IBsonSerializer`1<TCommandResult> resultSerializer, MessageEncoderSettings messageEncoderSettings);
    public BsonDocument get_AdditionalOptions();
    public void set_AdditionalOptions(BsonDocument value);
    public BsonDocument get_Command();
    public IElementNameValidator get_CommandValidator();
    public void set_CommandValidator(IElementNameValidator value);
    public string get_Comment();
    public void set_Comment(string value);
    public DatabaseNamespace get_DatabaseNamespace();
    public MessageEncoderSettings get_MessageEncoderSettings();
    public IBsonSerializer`1<TCommandResult> get_ResultSerializer();
    protected TCommandResult ExecuteProtocol(IChannelHandle channel, ICoreSessionHandle session, ReadPreference readPreference, CancellationToken cancellationToken);
    protected TCommandResult ExecuteProtocol(IChannelSource channelSource, ICoreSessionHandle session, ReadPreference readPreference, CancellationToken cancellationToken);
    protected Task`1<TCommandResult> ExecuteProtocolAsync(IChannelHandle channel, ICoreSessionHandle session, ReadPreference readPreference, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MongoDB.Driver.Core.Operations.CommandOperationBase`1/<ExecuteProtocolAsync>d__28")]
protected Task`1<TCommandResult> ExecuteProtocolAsync(IChannelSource channelSource, ICoreSessionHandle session, ReadPreference readPreference, CancellationToken cancellationToken);
    private BsonDocument GetEffectiveAdditionalOptions();
}
public class MongoDB.Driver.Core.Operations.CommitTransactionOperation : EndTransactionOperation {
    private Nullable`1<TimeSpan> _maxCommitTime;
    public Nullable`1<TimeSpan> MaxCommitTime { get; public set; }
    protected string CommandName { get; }
    public CommitTransactionOperation(WriteConcern writeConcern);
    public CommitTransactionOperation(BsonDocument recoveryToken, WriteConcern writeConcern);
    public Nullable`1<TimeSpan> get_MaxCommitTime();
    public void set_MaxCommitTime(Nullable`1<TimeSpan> value);
    protected virtual string get_CommandName();
    public virtual BsonDocument Execute(IReadBinding binding, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MongoDB.Driver.Core.Operations.CommitTransactionOperation/<ExecuteAsync>d__9")]
public virtual Task`1<BsonDocument> ExecuteAsync(IReadBinding binding, CancellationToken cancellationToken);
    protected virtual BsonDocument CreateCommand();
    private void ReplaceTransientTransactionErrorWithUnknownTransactionCommitResult(MongoException exception);
    private bool ShouldReplaceTransientTransactionErrorWithUnknownTransactionCommitResult(MongoException exception);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task`1<BsonDocument> <>n__0(IReadBinding binding, CancellationToken cancellationToken);
}
internal class MongoDB.Driver.Core.Operations.CompositeWriteOperation`1 : object {
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ValueTuple`2[] _operations;
    public CompositeWriteOperation`1(ValueTuple`2[] operations);
    public sealed virtual TResult Execute(IWriteBinding binding, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MongoDB.Driver.Core.Operations.CompositeWriteOperation`1/<ExecuteAsync>d__3")]
public sealed virtual Task`1<TResult> ExecuteAsync(IWriteBinding binding, CancellationToken cancellationToken);
}
public class MongoDB.Driver.Core.Operations.CountDocumentsOperation : object {
    private Collation _collation;
    private CollectionNamespace _collectionNamespace;
    private BsonValue _comment;
    private BsonDocument _filter;
    private BsonValue _hint;
    private Nullable`1<long> _limit;
    private Nullable`1<TimeSpan> _maxTime;
    private MessageEncoderSettings _messageEncoderSettings;
    private ReadConcern _readConcern;
    private bool _retryRequested;
    private Nullable`1<long> _skip;
    public Collation Collation { get; public set; }
    public BsonValue Comment { get; public set; }
    public CollectionNamespace CollectionNamespace { get; }
    public BsonDocument Filter { get; public set; }
    public BsonValue Hint { get; public set; }
    public Nullable`1<long> Limit { get; public set; }
    public Nullable`1<TimeSpan> MaxTime { get; public set; }
    public MessageEncoderSettings MessageEncoderSettings { get; }
    public ReadConcern ReadConcern { get; public set; }
    public bool RetryRequested { get; public set; }
    public Nullable`1<long> Skip { get; public set; }
    public CountDocumentsOperation(CollectionNamespace collectionNamespace, MessageEncoderSettings messageEncoderSettings);
    public Collation get_Collation();
    public void set_Collation(Collation value);
    public BsonValue get_Comment();
    public void set_Comment(BsonValue value);
    public CollectionNamespace get_CollectionNamespace();
    public BsonDocument get_Filter();
    public void set_Filter(BsonDocument value);
    public BsonValue get_Hint();
    public void set_Hint(BsonValue value);
    public Nullable`1<long> get_Limit();
    public void set_Limit(Nullable`1<long> value);
    public Nullable`1<TimeSpan> get_MaxTime();
    public void set_MaxTime(Nullable`1<TimeSpan> value);
    public MessageEncoderSettings get_MessageEncoderSettings();
    public ReadConcern get_ReadConcern();
    public void set_ReadConcern(ReadConcern value);
    public bool get_RetryRequested();
    public void set_RetryRequested(bool value);
    public Nullable`1<long> get_Skip();
    public void set_Skip(Nullable`1<long> value);
    public sealed virtual long Execute(IReadBinding binding, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MongoDB.Driver.Core.Operations.CountDocumentsOperation/<ExecuteAsync>d__44")]
public sealed virtual Task`1<long> ExecuteAsync(IReadBinding binding, CancellationToken cancellationToken);
    private IDisposable BeginOperation();
    private AggregateOperation`1<BsonDocument> CreateOperation();
    private List`1<BsonDocument> CreatePipeline();
    private long ExtractCountFromResult(List`1<BsonDocument> result);
}
public class MongoDB.Driver.Core.Operations.CountOperation : object {
    private Collation _collation;
    private CollectionNamespace _collectionNamespace;
    private BsonValue _comment;
    private BsonDocument _filter;
    private BsonValue _hint;
    private Nullable`1<long> _limit;
    private Nullable`1<TimeSpan> _maxTime;
    private MessageEncoderSettings _messageEncoderSettings;
    private ReadConcern _readConcern;
    private bool _retryRequested;
    private Nullable`1<long> _skip;
    public Collation Collation { get; public set; }
    public CollectionNamespace CollectionNamespace { get; }
    public BsonValue Comment { get; public set; }
    public BsonDocument Filter { get; public set; }
    public BsonValue Hint { get; public set; }
    public Nullable`1<long> Limit { get; public set; }
    public Nullable`1<TimeSpan> MaxTime { get; public set; }
    public MessageEncoderSettings MessageEncoderSettings { get; }
    public ReadConcern ReadConcern { get; public set; }
    public bool RetryRequested { get; public set; }
    public Nullable`1<long> Skip { get; public set; }
    public CountOperation(CollectionNamespace collectionNamespace, MessageEncoderSettings messageEncoderSettings);
    public Collation get_Collation();
    public void set_Collation(Collation value);
    public CollectionNamespace get_CollectionNamespace();
    public BsonValue get_Comment();
    public void set_Comment(BsonValue value);
    public BsonDocument get_Filter();
    public void set_Filter(BsonDocument value);
    public BsonValue get_Hint();
    public void set_Hint(BsonValue value);
    public Nullable`1<long> get_Limit();
    public void set_Limit(Nullable`1<long> value);
    public Nullable`1<TimeSpan> get_MaxTime();
    public void set_MaxTime(Nullable`1<TimeSpan> value);
    public MessageEncoderSettings get_MessageEncoderSettings();
    public ReadConcern get_ReadConcern();
    public void set_ReadConcern(ReadConcern value);
    public bool get_RetryRequested();
    public void set_RetryRequested(bool value);
    public Nullable`1<long> get_Skip();
    public void set_Skip(Nullable`1<long> value);
    internal BsonDocument CreateCommand(ConnectionDescription connectionDescription, ICoreSession session);
    public sealed virtual long Execute(IReadBinding binding, CancellationToken cancellationToken);
    public sealed virtual long Execute(RetryableReadContext context, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MongoDB.Driver.Core.Operations.CountOperation/<ExecuteAsync>d__46")]
public sealed virtual Task`1<long> ExecuteAsync(IReadBinding binding, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MongoDB.Driver.Core.Operations.CountOperation/<ExecuteAsync>d__47")]
public sealed virtual Task`1<long> ExecuteAsync(RetryableReadContext context, CancellationToken cancellationToken);
    private IDisposable BeginOperation();
    private ReadCommandOperation`1<BsonDocument> CreateOperation(RetryableReadContext context);
    [CompilerGeneratedAttribute]
private BsonValue <CreateCommand>b__43_0();
    [CompilerGeneratedAttribute]
private BsonValue <CreateCommand>b__43_1();
    [CompilerGeneratedAttribute]
private BsonValue <CreateCommand>b__43_2();
    [CompilerGeneratedAttribute]
private BsonValue <CreateCommand>b__43_3();
}
public class MongoDB.Driver.Core.Operations.CreateCollectionOperation : object {
    private Nullable`1<bool> _autoIndexId;
    private Nullable`1<bool> _capped;
    private BsonDocument _changeStreamPreAndPostImages;
    private BsonDocument _clusteredIndex;
    private Collation _collation;
    private CollectionNamespace _collectionNamespace;
    private BsonValue _comment;
    private BsonDocument _encryptedFields;
    private Nullable`1<TimeSpan> _expireAfter;
    private BsonDocument _indexOptionDefaults;
    private Nullable`1<long> _maxDocuments;
    private Nullable`1<long> _maxSize;
    private MessageEncoderSettings _messageEncoderSettings;
    private Nullable`1<bool> _noPadding;
    private BsonDocument _storageEngine;
    private TimeSeriesOptions _timeSeriesOptions;
    private Nullable`1<bool> _usePowerOf2Sizes;
    private Nullable`1<DocumentValidationAction> _validationAction;
    private Nullable`1<DocumentValidationLevel> _validationLevel;
    private BsonDocument _validator;
    private WriteConcern _writeConcern;
    private Feature _supportedFeature;
    [ObsoleteAttribute("AutoIndexId has been deprecated since server version 3.2.")]
public Nullable`1<bool> AutoIndexId { get; public set; }
    public Nullable`1<bool> Capped { get; public set; }
    public BsonDocument ChangeStreamPreAndPostImages { get; public set; }
    public Collation Collation { get; public set; }
    public BsonValue Comment { get; public set; }
    public CollectionNamespace CollectionNamespace { get; }
    internal BsonDocument EncryptedFields { get; private set; }
    public Nullable`1<TimeSpan> ExpireAfter { get; public set; }
    public BsonDocument IndexOptionDefaults { get; public set; }
    public Nullable`1<long> MaxDocuments { get; public set; }
    public Nullable`1<long> MaxSize { get; public set; }
    public MessageEncoderSettings MessageEncoderSettings { get; }
    public Nullable`1<bool> NoPadding { get; public set; }
    public BsonDocument StorageEngine { get; public set; }
    public TimeSeriesOptions TimeSeriesOptions { get; public set; }
    public Nullable`1<bool> UsePowerOf2Sizes { get; public set; }
    public Nullable`1<DocumentValidationAction> ValidationAction { get; public set; }
    public Nullable`1<DocumentValidationLevel> ValidationLevel { get; public set; }
    public BsonDocument Validator { get; public set; }
    public WriteConcern WriteConcern { get; public set; }
    public BsonDocument ClusteredIndex { get; public set; }
    public CreateCollectionOperation(CollectionNamespace collectionNamespace, MessageEncoderSettings messageEncoderSettings);
    private CreateCollectionOperation(CollectionNamespace collectionNamespace, MessageEncoderSettings messageEncoderSettings, Feature supportedFeature);
    internal static IWriteOperation`1<BsonDocument> CreateEncryptedCreateCollectionOperationIfConfigured(CollectionNamespace collectionNamespace, BsonDocument encryptedFields, MessageEncoderSettings messageEncoderSettings, Action`1<CreateCollectionOperation> createCollectionOperationConfigurator);
    public Nullable`1<bool> get_AutoIndexId();
    public void set_AutoIndexId(Nullable`1<bool> value);
    public Nullable`1<bool> get_Capped();
    public void set_Capped(Nullable`1<bool> value);
    public BsonDocument get_ChangeStreamPreAndPostImages();
    public void set_ChangeStreamPreAndPostImages(BsonDocument value);
    public Collation get_Collation();
    public void set_Collation(Collation value);
    public BsonValue get_Comment();
    public void set_Comment(BsonValue value);
    public CollectionNamespace get_CollectionNamespace();
    internal BsonDocument get_EncryptedFields();
    private void set_EncryptedFields(BsonDocument value);
    public Nullable`1<TimeSpan> get_ExpireAfter();
    public void set_ExpireAfter(Nullable`1<TimeSpan> value);
    public BsonDocument get_IndexOptionDefaults();
    public void set_IndexOptionDefaults(BsonDocument value);
    public Nullable`1<long> get_MaxDocuments();
    public void set_MaxDocuments(Nullable`1<long> value);
    public Nullable`1<long> get_MaxSize();
    public void set_MaxSize(Nullable`1<long> value);
    public MessageEncoderSettings get_MessageEncoderSettings();
    public Nullable`1<bool> get_NoPadding();
    public void set_NoPadding(Nullable`1<bool> value);
    public BsonDocument get_StorageEngine();
    public void set_StorageEngine(BsonDocument value);
    public TimeSeriesOptions get_TimeSeriesOptions();
    public void set_TimeSeriesOptions(TimeSeriesOptions value);
    public Nullable`1<bool> get_UsePowerOf2Sizes();
    public void set_UsePowerOf2Sizes(Nullable`1<bool> value);
    public Nullable`1<DocumentValidationAction> get_ValidationAction();
    public void set_ValidationAction(Nullable`1<DocumentValidationAction> value);
    public Nullable`1<DocumentValidationLevel> get_ValidationLevel();
    public void set_ValidationLevel(Nullable`1<DocumentValidationLevel> value);
    public BsonDocument get_Validator();
    public void set_Validator(BsonDocument value);
    public WriteConcern get_WriteConcern();
    public void set_WriteConcern(WriteConcern value);
    public BsonDocument get_ClusteredIndex();
    public void set_ClusteredIndex(BsonDocument value);
    internal BsonDocument CreateCommand(ICoreSessionHandle session);
    private Nullable`1<CreateCollectionFlags> GetFlags();
    public sealed virtual BsonDocument Execute(IWriteBinding binding, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MongoDB.Driver.Core.Operations.CreateCollectionOperation/<ExecuteAsync>d__89")]
public sealed virtual Task`1<BsonDocument> ExecuteAsync(IWriteBinding binding, CancellationToken cancellationToken);
    private IDisposable BeginOperation();
    private WriteCommandOperation`1<BsonDocument> CreateOperation(ICoreSessionHandle session);
    private void EnsureServerIsValid(int maxWireVersion);
    [CompilerGeneratedAttribute]
internal static CreateCollectionOperation <CreateEncryptedCreateCollectionOperationIfConfigured>g__CreateInnerCollectionOperation|0_0(string collectionName, <>c__DisplayClass0_0& );
}
public class MongoDB.Driver.Core.Operations.CreateIndexesOperation : object {
    private CollectionNamespace _collectionNamespace;
    private BsonValue _comment;
    private CreateIndexCommitQuorum _commitQuorum;
    private Nullable`1<TimeSpan> _maxTime;
    private MessageEncoderSettings _messageEncoderSettings;
    private IEnumerable`1<CreateIndexRequest> _requests;
    private WriteConcern _writeConcern;
    public CollectionNamespace CollectionNamespace { get; }
    public BsonValue Comment { get; public set; }
    public CreateIndexCommitQuorum CommitQuorum { get; public set; }
    public MessageEncoderSettings MessageEncoderSettings { get; }
    public IEnumerable`1<CreateIndexRequest> Requests { get; }
    public WriteConcern WriteConcern { get; public set; }
    public Nullable`1<TimeSpan> MaxTime { get; public set; }
    public CreateIndexesOperation(CollectionNamespace collectionNamespace, IEnumerable`1<CreateIndexRequest> requests, MessageEncoderSettings messageEncoderSettings);
    public CollectionNamespace get_CollectionNamespace();
    public BsonValue get_Comment();
    public void set_Comment(BsonValue value);
    public CreateIndexCommitQuorum get_CommitQuorum();
    public void set_CommitQuorum(CreateIndexCommitQuorum value);
    public MessageEncoderSettings get_MessageEncoderSettings();
    public IEnumerable`1<CreateIndexRequest> get_Requests();
    public WriteConcern get_WriteConcern();
    public void set_WriteConcern(WriteConcern value);
    public Nullable`1<TimeSpan> get_MaxTime();
    public void set_MaxTime(Nullable`1<TimeSpan> value);
    public sealed virtual BsonDocument Execute(IWriteBinding binding, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MongoDB.Driver.Core.Operations.CreateIndexesOperation/<ExecuteAsync>d__27")]
public sealed virtual Task`1<BsonDocument> ExecuteAsync(IWriteBinding binding, CancellationToken cancellationToken);
    internal BsonDocument CreateCommand(ICoreSessionHandle session, ConnectionDescription connectionDescription);
    private IDisposable BeginOperation();
    private WriteCommandOperation`1<BsonDocument> CreateOperation(ICoreSessionHandle session, ConnectionDescription connectionDescription);
    [CompilerGeneratedAttribute]
private BsonValue <CreateCommand>b__28_1();
    [CompilerGeneratedAttribute]
private BsonValue <CreateCommand>b__28_2();
}
public class MongoDB.Driver.Core.Operations.CreateIndexRequest : object {
    private BsonDocument _additionalOptions;
    private Nullable`1<bool> _background;
    private Nullable`1<int> _bits;
    private Nullable`1<double> _bucketSize;
    private Collation _collation;
    private string _defaultLanguage;
    private Nullable`1<TimeSpan> _expireAfter;
    private Nullable`1<bool> _hidden;
    private string _languageOverride;
    private BsonDocument _keys;
    private Nullable`1<double> _max;
    private Nullable`1<double> _min;
    private string _name;
    private BsonDocument _partialFilterExpression;
    private Nullable`1<bool> _sparse;
    private Nullable`1<int> _sphereIndexVersion;
    private BsonDocument _storageEngine;
    private Nullable`1<int> _textIndexVersion;
    private Nullable`1<bool> _unique;
    private Nullable`1<int> _version;
    private BsonDocument _weights;
    private BsonDocument _wildcardProjection;
    public BsonDocument AdditionalOptions { get; public set; }
    public Nullable`1<bool> Background { get; public set; }
    public Nullable`1<int> Bits { get; public set; }
    [ObsoleteAttribute("GeoHaystack indexes were deprecated in server version 4.4.")]
public Nullable`1<double> BucketSize { get; public set; }
    public Collation Collation { get; public set; }
    public string DefaultLanguage { get; public set; }
    public Nullable`1<TimeSpan> ExpireAfter { get; public set; }
    public Nullable`1<bool> Hidden { get; public set; }
    public string LanguageOverride { get; public set; }
    public BsonDocument Keys { get; }
    public Nullable`1<double> Max { get; public set; }
    public Nullable`1<double> Min { get; public set; }
    public string Name { get; public set; }
    public BsonDocument PartialFilterExpression { get; public set; }
    public Nullable`1<bool> Sparse { get; public set; }
    public Nullable`1<int> SphereIndexVersion { get; public set; }
    public BsonDocument StorageEngine { get; public set; }
    public Nullable`1<int> TextIndexVersion { get; public set; }
    public Nullable`1<bool> Unique { get; public set; }
    public Nullable`1<int> Version { get; public set; }
    public BsonDocument Weights { get; public set; }
    public BsonDocument WildcardProjection { get; public set; }
    public CreateIndexRequest(BsonDocument keys);
    public BsonDocument get_AdditionalOptions();
    public void set_AdditionalOptions(BsonDocument value);
    public Nullable`1<bool> get_Background();
    public void set_Background(Nullable`1<bool> value);
    public Nullable`1<int> get_Bits();
    public void set_Bits(Nullable`1<int> value);
    public Nullable`1<double> get_BucketSize();
    public void set_BucketSize(Nullable`1<double> value);
    public Collation get_Collation();
    public void set_Collation(Collation value);
    public string get_DefaultLanguage();
    public void set_DefaultLanguage(string value);
    public Nullable`1<TimeSpan> get_ExpireAfter();
    public void set_ExpireAfter(Nullable`1<TimeSpan> value);
    public Nullable`1<bool> get_Hidden();
    public void set_Hidden(Nullable`1<bool> value);
    public string get_LanguageOverride();
    public void set_LanguageOverride(string value);
    public BsonDocument get_Keys();
    public Nullable`1<double> get_Max();
    public void set_Max(Nullable`1<double> value);
    public Nullable`1<double> get_Min();
    public void set_Min(Nullable`1<double> value);
    public string get_Name();
    public void set_Name(string value);
    public BsonDocument get_PartialFilterExpression();
    public void set_PartialFilterExpression(BsonDocument value);
    public Nullable`1<bool> get_Sparse();
    public void set_Sparse(Nullable`1<bool> value);
    public Nullable`1<int> get_SphereIndexVersion();
    public void set_SphereIndexVersion(Nullable`1<int> value);
    public BsonDocument get_StorageEngine();
    public void set_StorageEngine(BsonDocument value);
    public Nullable`1<int> get_TextIndexVersion();
    public void set_TextIndexVersion(Nullable`1<int> value);
    public Nullable`1<bool> get_Unique();
    public void set_Unique(Nullable`1<bool> value);
    public Nullable`1<int> get_Version();
    public void set_Version(Nullable`1<int> value);
    public BsonDocument get_Weights();
    public void set_Weights(BsonDocument value);
    public BsonDocument get_WildcardProjection();
    public void set_WildcardProjection(BsonDocument value);
    public string GetIndexName();
    internal BsonDocument CreateIndexDocument();
    [CompilerGeneratedAttribute]
private BsonValue <CreateIndexDocument>b__89_0();
    [CompilerGeneratedAttribute]
private BsonValue <CreateIndexDocument>b__89_1();
    [CompilerGeneratedAttribute]
private BsonValue <CreateIndexDocument>b__89_2();
    [CompilerGeneratedAttribute]
private BsonValue <CreateIndexDocument>b__89_3();
    [CompilerGeneratedAttribute]
private BsonValue <CreateIndexDocument>b__89_4();
    [CompilerGeneratedAttribute]
private BsonValue <CreateIndexDocument>b__89_5();
    [CompilerGeneratedAttribute]
private BsonValue <CreateIndexDocument>b__89_6();
    [CompilerGeneratedAttribute]
private BsonValue <CreateIndexDocument>b__89_7();
    [CompilerGeneratedAttribute]
private BsonValue <CreateIndexDocument>b__89_8();
    [CompilerGeneratedAttribute]
private BsonValue <CreateIndexDocument>b__89_9();
    [CompilerGeneratedAttribute]
private BsonValue <CreateIndexDocument>b__89_10();
    [CompilerGeneratedAttribute]
private BsonValue <CreateIndexDocument>b__89_11();
    [CompilerGeneratedAttribute]
private BsonValue <CreateIndexDocument>b__89_12();
    [CompilerGeneratedAttribute]
private BsonValue <CreateIndexDocument>b__89_13();
    [CompilerGeneratedAttribute]
private BsonValue <CreateIndexDocument>b__89_14();
    [CompilerGeneratedAttribute]
private BsonValue <CreateIndexDocument>b__89_15();
    [CompilerGeneratedAttribute]
private BsonValue <CreateIndexDocument>b__89_16();
}
internal class MongoDB.Driver.Core.Operations.CreateSearchIndexesOperation : object {
    private CollectionNamespace _collectionNamespace;
    private MessageEncoderSettings _messageEncoderSettings;
    private IEnumerable`1<CreateSearchIndexRequest> _requests;
    public CreateSearchIndexesOperation(CollectionNamespace collectionNamespace, IEnumerable`1<CreateSearchIndexRequest> requests, MessageEncoderSettings messageEncoderSettings);
    public sealed virtual BsonDocument Execute(IWriteBinding binding, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MongoDB.Driver.Core.Operations.CreateSearchIndexesOperation/<ExecuteAsync>d__5")]
public sealed virtual Task`1<BsonDocument> ExecuteAsync(IWriteBinding binding, CancellationToken cancellationToken);
    private WriteCommandOperation`1<BsonDocument> CreateOperation();
}
public class MongoDB.Driver.Core.Operations.CreateSearchIndexRequest : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private BsonDocument <Definition>k__BackingField;
    public string Name { get; }
    public BsonDocument Definition { get; }
    public CreateSearchIndexRequest(string name, BsonDocument definition);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public BsonDocument get_Definition();
    internal BsonDocument CreateIndexDocument();
}
public class MongoDB.Driver.Core.Operations.CreateViewOperation : object {
    private Collation _collation;
    private DatabaseNamespace _databaseNamespace;
    private MessageEncoderSettings _messageEncoderSettings;
    private IReadOnlyList`1<BsonDocument> _pipeline;
    private string _viewName;
    private string _viewOn;
    private WriteConcern _writeConcern;
    public Collation Collation { get; public set; }
    public DatabaseNamespace DatabaseNamespace { get; }
    public MessageEncoderSettings MessageEncoderSettings { get; }
    public IReadOnlyList`1<BsonDocument> Pipeline { get; }
    public string ViewName { get; }
    public string ViewOn { get; }
    public WriteConcern WriteConcern { get; public set; }
    public CreateViewOperation(DatabaseNamespace databaseNamespace, string viewName, string viewOn, IEnumerable`1<BsonDocument> pipeline, MessageEncoderSettings messageEncoderSettings);
    public Collation get_Collation();
    public void set_Collation(Collation value);
    public DatabaseNamespace get_DatabaseNamespace();
    public MessageEncoderSettings get_MessageEncoderSettings();
    public IReadOnlyList`1<BsonDocument> get_Pipeline();
    public string get_ViewName();
    public string get_ViewOn();
    public WriteConcern get_WriteConcern();
    public void set_WriteConcern(WriteConcern value);
    public sealed virtual BsonDocument Execute(IWriteBinding binding, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MongoDB.Driver.Core.Operations.CreateViewOperation/<ExecuteAsync>d__25")]
public sealed virtual Task`1<BsonDocument> ExecuteAsync(IWriteBinding binding, CancellationToken cancellationToken);
    internal BsonDocument CreateCommand(ICoreSessionHandle session, ConnectionDescription connectionDescription);
    private WriteCommandOperation`1<BsonDocument> CreateOperation(ICoreSessionHandle session, ConnectionDescription connectionDescription);
    [CompilerGeneratedAttribute]
private BsonValue <CreateCommand>b__26_0();
}
internal static class MongoDB.Driver.Core.Operations.CursorBatchDeserializationHelper : object {
    public static List`1<TDocument> DeserializeBatch(RawBsonArray batch, IBsonSerializer`1<TDocument> documentSerializer, MessageEncoderSettings messageEncoderSettings);
}
public enum MongoDB.Driver.Core.Operations.CursorType : Enum {
    public int value__;
    public static CursorType NonTailable;
    public static CursorType Tailable;
    public static CursorType TailableAwait;
}
public class MongoDB.Driver.Core.Operations.DatabaseExistsOperation : object {
    private DatabaseNamespace _databaseNamespace;
    private MessageEncoderSettings _messageEncoderSettings;
    private bool _retryRequested;
    public DatabaseNamespace DatabaseNamespace { get; }
    public MessageEncoderSettings MessageEncoderSettings { get; }
    public bool RetryRequested { get; public set; }
    public DatabaseExistsOperation(DatabaseNamespace databaseNamespace, MessageEncoderSettings messageEncoderSettings);
    public DatabaseNamespace get_DatabaseNamespace();
    public MessageEncoderSettings get_MessageEncoderSettings();
    public bool get_RetryRequested();
    public void set_RetryRequested(bool value);
    public sealed virtual bool Execute(IReadBinding binding, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MongoDB.Driver.Core.Operations.DatabaseExistsOperation/<ExecuteAsync>d__12")]
public sealed virtual Task`1<bool> ExecuteAsync(IReadBinding binding, CancellationToken cancellationToken);
    private ListDatabasesOperation CreateOperation();
    [CompilerGeneratedAttribute]
private bool <Execute>b__11_0(BsonDocument x);
    [CompilerGeneratedAttribute]
private bool <ExecuteAsync>b__12_0(BsonDocument x);
}
internal class MongoDB.Driver.Core.Operations.DelayedEvaluationWriteConcernSerializer : SealedClassSerializerBase`1<Func`1<WriteConcern>> {
    protected virtual void SerializeValue(BsonSerializationContext context, BsonSerializationArgs args, Func`1<WriteConcern> value);
}
public class MongoDB.Driver.Core.Operations.DeleteOpcodeOperation : object {
    private CollectionNamespace _collectionNamespace;
    private MessageEncoderSettings _messageEncoderSettings;
    private DeleteRequest _request;
    private bool _retryRequested;
    private WriteConcern _writeConcern;
    public CollectionNamespace CollectionNamespace { get; }
    public DeleteRequest Request { get; }
    public MessageEncoderSettings MessageEncoderSettings { get; }
    public bool RetryRequested { get; public set; }
    public WriteConcern WriteConcern { get; public set; }
    public DeleteOpcodeOperation(CollectionNamespace collectionNamespace, DeleteRequest request, MessageEncoderSettings messageEncoderSettings);
    public CollectionNamespace get_CollectionNamespace();
    public DeleteRequest get_Request();
    public MessageEncoderSettings get_MessageEncoderSettings();
    public bool get_RetryRequested();
    public void set_RetryRequested(bool value);
    public WriteConcern get_WriteConcern();
    public void set_WriteConcern(WriteConcern value);
    public sealed virtual WriteConcernResult Execute(IWriteBinding binding, CancellationToken cancellationToken);
    public sealed virtual WriteConcernResult Execute(RetryableWriteContext context, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MongoDB.Driver.Core.Operations.DeleteOpcodeOperation/<ExecuteAsync>d__20")]
public sealed virtual Task`1<WriteConcernResult> ExecuteAsync(IWriteBinding binding, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MongoDB.Driver.Core.Operations.DeleteOpcodeOperation/<ExecuteAsync>d__21")]
public sealed virtual Task`1<WriteConcernResult> ExecuteAsync(RetryableWriteContext context, CancellationToken cancellationToken);
    private IExecutableInRetryableWriteContext`1<WriteConcernResult> CreateEmulator();
}
internal class MongoDB.Driver.Core.Operations.DeleteOpcodeOperationEmulator : object {
    private CollectionNamespace _collectionNamespace;
    private DeleteRequest _request;
    private MessageEncoderSettings _messageEncoderSettings;
    private bool _retryRequested;
    private WriteConcern _writeConcern;
    public CollectionNamespace CollectionNamespace { get; }
    public DeleteRequest Request { get; }
    public MessageEncoderSettings MessageEncoderSettings { get; }
    public bool RetryRequested { get; public set; }
    public WriteConcern WriteConcern { get; public set; }
    public DeleteOpcodeOperationEmulator(CollectionNamespace collectionNamespace, DeleteRequest request, MessageEncoderSettings messageEncoderSettings);
    public CollectionNamespace get_CollectionNamespace();
    public DeleteRequest get_Request();
    public MessageEncoderSettings get_MessageEncoderSettings();
    public bool get_RetryRequested();
    public void set_RetryRequested(bool value);
    public WriteConcern get_WriteConcern();
    public void set_WriteConcern(WriteConcern value);
    public sealed virtual WriteConcernResult Execute(RetryableWriteContext context, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MongoDB.Driver.Core.Operations.DeleteOpcodeOperationEmulator/<ExecuteAsync>d__19")]
public sealed virtual Task`1<WriteConcernResult> ExecuteAsync(RetryableWriteContext context, CancellationToken cancellationToken);
    private BulkDeleteOperation CreateOperation();
    private WriteConcernResult CreateResultOrThrow(IChannelHandle channel, BulkWriteOperationResult result, MongoBulkWriteOperationException exception);
}
public class MongoDB.Driver.Core.Operations.DeleteRequest : WriteRequest {
    private Collation _collation;
    private BsonDocument _filter;
    private BsonValue _hint;
    private int _limit;
    public Collation Collation { get; public set; }
    public BsonDocument Filter { get; }
    public BsonValue Hint { get; public set; }
    public int Limit { get; public set; }
    public DeleteRequest(BsonDocument filter);
    public Collation get_Collation();
    public void set_Collation(Collation value);
    public BsonDocument get_Filter();
    public BsonValue get_Hint();
    public void set_Hint(BsonValue value);
    public int get_Limit();
    public void set_Limit(int value);
    public virtual bool IsRetryable(ConnectionDescription connectionDescription);
}
public class MongoDB.Driver.Core.Operations.DistinctOperation`1 : object {
    private Collation _collation;
    private CollectionNamespace _collectionNamespace;
    private BsonValue _comment;
    private BsonDocument _filter;
    private string _fieldName;
    private Nullable`1<TimeSpan> _maxTime;
    private MessageEncoderSettings _messageEncoderSettings;
    private ReadConcern _readConcern;
    private bool _retryRequested;
    private IBsonSerializer`1<TValue> _valueSerializer;
    public Collation Collation { get; public set; }
    public BsonValue Comment { get; public set; }
    public CollectionNamespace CollectionNamespace { get; }
    public BsonDocument Filter { get; public set; }
    public string FieldName { get; }
    public Nullable`1<TimeSpan> MaxTime { get; public set; }
    public MessageEncoderSettings MessageEncoderSettings { get; }
    public ReadConcern ReadConcern { get; public set; }
    public bool RetryRequested { get; public set; }
    public IBsonSerializer`1<TValue> ValueSerializer { get; }
    public DistinctOperation`1(CollectionNamespace collectionNamespace, IBsonSerializer`1<TValue> valueSerializer, string fieldName, MessageEncoderSettings messageEncoderSettings);
    public Collation get_Collation();
    public void set_Collation(Collation value);
    public BsonValue get_Comment();
    public void set_Comment(BsonValue value);
    public CollectionNamespace get_CollectionNamespace();
    public BsonDocument get_Filter();
    public void set_Filter(BsonDocument value);
    public string get_FieldName();
    public Nullable`1<TimeSpan> get_MaxTime();
    public void set_MaxTime(Nullable`1<TimeSpan> value);
    public MessageEncoderSettings get_MessageEncoderSettings();
    public ReadConcern get_ReadConcern();
    public void set_ReadConcern(ReadConcern value);
    public bool get_RetryRequested();
    public void set_RetryRequested(bool value);
    public IBsonSerializer`1<TValue> get_ValueSerializer();
    public sealed virtual IAsyncCursor`1<TValue> Execute(IReadBinding binding, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MongoDB.Driver.Core.Operations.DistinctOperation`1/<ExecuteAsync>d__38")]
public sealed virtual Task`1<IAsyncCursor`1<TValue>> ExecuteAsync(IReadBinding binding, CancellationToken cancellationToken);
    internal BsonDocument CreateCommand(ConnectionDescription connectionDescription, ICoreSession session);
    private IDisposable BeginOperation();
    private ReadCommandOperation`1<DistinctResult<TValue>> CreateOperation(RetryableReadContext context);
    [CompilerGeneratedAttribute]
private BsonValue <CreateCommand>b__39_0();
    [CompilerGeneratedAttribute]
private BsonValue <CreateCommand>b__39_1();
}
public class MongoDB.Driver.Core.Operations.DropCollectionOperation : object {
    private CollectionNamespace _collectionNamespace;
    private BsonDocument _encryptedFields;
    private MessageEncoderSettings _messageEncoderSettings;
    private WriteConcern _writeConcern;
    public CollectionNamespace CollectionNamespace { get; }
    internal BsonDocument EncryptedFields { get; private set; }
    public MessageEncoderSettings MessageEncoderSettings { get; }
    public WriteConcern WriteConcern { get; public set; }
    public DropCollectionOperation(CollectionNamespace collectionNamespace, MessageEncoderSettings messageEncoderSettings);
    internal static IWriteOperation`1<BsonDocument> CreateEncryptedDropCollectionOperationIfConfigured(CollectionNamespace collectionNamespace, BsonDocument encryptedFields, MessageEncoderSettings messageEncoderSettings, Action`1<DropCollectionOperation> configureDropCollectionConfigurator);
    public CollectionNamespace get_CollectionNamespace();
    internal BsonDocument get_EncryptedFields();
    private void set_EncryptedFields(BsonDocument value);
    public MessageEncoderSettings get_MessageEncoderSettings();
    public WriteConcern get_WriteConcern();
    public void set_WriteConcern(WriteConcern value);
    public sealed virtual BsonDocument Execute(IWriteBinding binding, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MongoDB.Driver.Core.Operations.DropCollectionOperation/<ExecuteAsync>d__17")]
public sealed virtual Task`1<BsonDocument> ExecuteAsync(IWriteBinding binding, CancellationToken cancellationToken);
    internal BsonDocument CreateCommand(ICoreSessionHandle session);
    private IDisposable BeginOperation();
    private WriteCommandOperation`1<BsonDocument> CreateOperation(ICoreSessionHandle session);
    private bool ShouldIgnoreException(MongoCommandException ex);
    [CompilerGeneratedAttribute]
internal static DropCollectionOperation <CreateEncryptedDropCollectionOperationIfConfigured>g__CreateInnerDropOperation|0_0(string collectionName, <>c__DisplayClass0_0& );
}
public class MongoDB.Driver.Core.Operations.DropDatabaseOperation : object {
    private DatabaseNamespace _databaseNamespace;
    private MessageEncoderSettings _messageEncoderSettings;
    private WriteConcern _writeConcern;
    public DatabaseNamespace DatabaseNamespace { get; }
    public MessageEncoderSettings MessageEncoderSettings { get; }
    public WriteConcern WriteConcern { get; public set; }
    public DropDatabaseOperation(DatabaseNamespace databaseNamespace, MessageEncoderSettings messageEncoderSettings);
    public DatabaseNamespace get_DatabaseNamespace();
    public MessageEncoderSettings get_MessageEncoderSettings();
    public WriteConcern get_WriteConcern();
    public void set_WriteConcern(WriteConcern value);
    public sealed virtual BsonDocument Execute(IWriteBinding binding, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MongoDB.Driver.Core.Operations.DropDatabaseOperation/<ExecuteAsync>d__12")]
public sealed virtual Task`1<BsonDocument> ExecuteAsync(IWriteBinding binding, CancellationToken cancellationToken);
    internal BsonDocument CreateCommand(ICoreSessionHandle session);
    private IDisposable BeginOperation();
    private WriteCommandOperation`1<BsonDocument> CreateOperation(ICoreSessionHandle session);
}
public class MongoDB.Driver.Core.Operations.DropIndexOperation : object {
    private CollectionNamespace _collectionNamespace;
    private BsonValue _comment;
    private string _indexName;
    private Nullable`1<TimeSpan> _maxTime;
    private MessageEncoderSettings _messageEncoderSettings;
    private WriteConcern _writeConcern;
    public CollectionNamespace CollectionNamespace { get; }
    public BsonValue Comment { get; public set; }
    public string IndexName { get; }
    public MessageEncoderSettings MessageEncoderSettings { get; }
    public WriteConcern WriteConcern { get; public set; }
    public Nullable`1<TimeSpan> MaxTime { get; public set; }
    public DropIndexOperation(CollectionNamespace collectionNamespace, BsonDocument keys, MessageEncoderSettings messageEncoderSettings);
    public DropIndexOperation(CollectionNamespace collectionNamespace, string indexName, MessageEncoderSettings messageEncoderSettings);
    public CollectionNamespace get_CollectionNamespace();
    public BsonValue get_Comment();
    public void set_Comment(BsonValue value);
    public string get_IndexName();
    public MessageEncoderSettings get_MessageEncoderSettings();
    public WriteConcern get_WriteConcern();
    public void set_WriteConcern(WriteConcern value);
    public Nullable`1<TimeSpan> get_MaxTime();
    public void set_MaxTime(Nullable`1<TimeSpan> value);
    internal BsonDocument CreateCommand(ICoreSessionHandle session);
    private IDisposable BeginOperation();
    private WriteCommandOperation`1<BsonDocument> CreateOperation(ICoreSessionHandle session);
    public sealed virtual BsonDocument Execute(IWriteBinding binding, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MongoDB.Driver.Core.Operations.DropIndexOperation/<ExecuteAsync>d__27")]
public sealed virtual Task`1<BsonDocument> ExecuteAsync(IWriteBinding binding, CancellationToken cancellationToken);
    private bool ShouldIgnoreException(MongoCommandException ex);
    [CompilerGeneratedAttribute]
private BsonValue <CreateCommand>b__23_0();
}
internal class MongoDB.Driver.Core.Operations.DropSearchIndexOperation : object {
    private CollectionNamespace _collectionNamespace;
    private string _indexName;
    private MessageEncoderSettings _messageEncoderSettings;
    public DropSearchIndexOperation(CollectionNamespace collectionNamespace, string indexName, MessageEncoderSettings messageEncoderSettings);
    private BsonDocument CreateCommand();
    private WriteCommandOperation`1<BsonDocument> CreateOperation();
    public sealed virtual BsonDocument Execute(IWriteBinding binding, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MongoDB.Driver.Core.Operations.DropSearchIndexOperation/<ExecuteAsync>d__7")]
public sealed virtual Task`1<BsonDocument> ExecuteAsync(IWriteBinding binding, CancellationToken cancellationToken);
    private bool ShouldIgnoreException(MongoCommandException ex);
}
internal class MongoDB.Driver.Core.Operations.ElementDeserializer`1 : SerializerBase`1<TValue> {
    private bool _deserializeNull;
    private string _elementName;
    private IBsonSerializer`1<TValue> _valueSerializer;
    public ElementDeserializer`1(string elementName, IBsonSerializer`1<TValue> valueSerializer);
    public ElementDeserializer`1(string elementName, IBsonSerializer`1<TValue> valueSerializer, bool deserializeNull);
    public virtual TValue Deserialize(BsonDeserializationContext context, BsonDeserializationArgs args);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public static class MongoDB.Driver.Core.Operations.ElementNameValidators.ElementNameValidatorFactory : object {
    public static IElementNameValidator ForUpdateType(UpdateType updateType);
}
public class MongoDB.Driver.Core.Operations.ElementNameValidators.ReplacementElementNameValidator : object {
    private static ReplacementElementNameValidator __instance;
    public static ReplacementElementNameValidator Instance { get; }
    private static ReplacementElementNameValidator();
    public static ReplacementElementNameValidator get_Instance();
    public sealed virtual IElementNameValidator GetValidatorForChildContent(string elementName);
    public sealed virtual bool IsValidElementName(string elementName);
}
public class MongoDB.Driver.Core.Operations.ElementNameValidators.UpdateElementNameValidator : object {
    private static UpdateElementNameValidator __instance;
    public static UpdateElementNameValidator Instance { get; }
    private static UpdateElementNameValidator();
    public static UpdateElementNameValidator get_Instance();
    public sealed virtual IElementNameValidator GetValidatorForChildContent(string elementName);
    public sealed virtual bool IsValidElementName(string elementName);
}
public class MongoDB.Driver.Core.Operations.ElementNameValidators.UpdateOrReplacementElementNameValidator : object {
    private IElementNameValidator _chosenValidator;
    public sealed virtual IElementNameValidator GetValidatorForChildContent(string elementName);
    public sealed virtual bool IsValidElementName(string elementName);
}
public abstract class MongoDB.Driver.Core.Operations.EndTransactionOperation : object {
    private MessageEncoderSettings _messageEncoderSettings;
    private BsonDocument _recoveryToken;
    private WriteConcern _writeConcern;
    public MessageEncoderSettings MessageEncoderSettings { get; public set; }
    public WriteConcern WriteConcern { get; }
    protected string CommandName { get; }
    protected EndTransactionOperation(BsonDocument recoveryToken, WriteConcern writeConcern);
    protected EndTransactionOperation(WriteConcern writeConcern);
    public MessageEncoderSettings get_MessageEncoderSettings();
    public void set_MessageEncoderSettings(MessageEncoderSettings value);
    public WriteConcern get_WriteConcern();
    protected abstract virtual string get_CommandName();
    public virtual BsonDocument Execute(IReadBinding binding, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MongoDB.Driver.Core.Operations.EndTransactionOperation/<ExecuteAsync>d__13")]
public virtual Task`1<BsonDocument> ExecuteAsync(IReadBinding binding, CancellationToken cancellationToken);
    protected virtual BsonDocument CreateCommand();
    private IReadOperation`1<BsonDocument> CreateOperation();
    [CompilerGeneratedAttribute]
private BsonValue <CreateCommand>b__14_0();
}
public class MongoDB.Driver.Core.Operations.EstimatedDocumentCountOperation : object {
    private CollectionNamespace _collectionNamespace;
    private BsonValue _comment;
    private Nullable`1<TimeSpan> _maxTime;
    private MessageEncoderSettings _messageEncoderSettings;
    private ReadConcern _readConcern;
    private bool _retryRequested;
    public CollectionNamespace CollectionNamespace { get; }
    public BsonValue Comment { get; public set; }
    public Nullable`1<TimeSpan> MaxTime { get; public set; }
    public MessageEncoderSettings MessageEncoderSettings { get; }
    public ReadConcern ReadConcern { get; public set; }
    public bool RetryRequested { get; public set; }
    public EstimatedDocumentCountOperation(CollectionNamespace collectionNamespace, MessageEncoderSettings messageEncoderSettings);
    public CollectionNamespace get_CollectionNamespace();
    public BsonValue get_Comment();
    public void set_Comment(BsonValue value);
    public Nullable`1<TimeSpan> get_MaxTime();
    public void set_MaxTime(Nullable`1<TimeSpan> value);
    public MessageEncoderSettings get_MessageEncoderSettings();
    public ReadConcern get_ReadConcern();
    public void set_ReadConcern(ReadConcern value);
    public bool get_RetryRequested();
    public void set_RetryRequested(bool value);
    public sealed virtual long Execute(IReadBinding binding, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MongoDB.Driver.Core.Operations.EstimatedDocumentCountOperation/<ExecuteAsync>d__24")]
public sealed virtual Task`1<long> ExecuteAsync(IReadBinding binding, CancellationToken cancellationToken);
    private IDisposable BeginOperation();
    private IExecutableInRetryableReadContext`1<long> CreateCountOperation();
}
public class MongoDB.Driver.Core.Operations.EvalOperation : object {
    private IEnumerable`1<BsonValue> _args;
    private DatabaseNamespace _databaseNamespace;
    private BsonJavaScript _function;
    private Nullable`1<TimeSpan> _maxTime;
    private MessageEncoderSettings _messageEncoderSettings;
    private Nullable`1<bool> _noLock;
    public IEnumerable`1<BsonValue> Args { get; public set; }
    public DatabaseNamespace DatabaseNamespace { get; }
    public BsonJavaScript Function { get; }
    public Nullable`1<TimeSpan> MaxTime { get; public set; }
    public MessageEncoderSettings MessageEncoderSettings { get; }
    public Nullable`1<bool> NoLock { get; public set; }
    public EvalOperation(DatabaseNamespace databaseNamespace, BsonJavaScript function, MessageEncoderSettings messageEncoderSettings);
    public IEnumerable`1<BsonValue> get_Args();
    public void set_Args(IEnumerable`1<BsonValue> value);
    public DatabaseNamespace get_DatabaseNamespace();
    public BsonJavaScript get_Function();
    public Nullable`1<TimeSpan> get_MaxTime();
    public void set_MaxTime(Nullable`1<TimeSpan> value);
    public MessageEncoderSettings get_MessageEncoderSettings();
    public Nullable`1<bool> get_NoLock();
    public void set_NoLock(Nullable`1<bool> value);
    public sealed virtual BsonValue Execute(IWriteBinding binding, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MongoDB.Driver.Core.Operations.EvalOperation/<ExecuteAsync>d__23")]
public sealed virtual Task`1<BsonValue> ExecuteAsync(IWriteBinding binding, CancellationToken cancellationToken);
    internal BsonDocument CreateCommand();
    private WriteCommandOperation`1<BsonDocument> CreateOperation();
    [CompilerGeneratedAttribute]
private BsonValue <CreateCommand>b__24_0();
    [CompilerGeneratedAttribute]
private BsonValue <CreateCommand>b__24_1();
    [CompilerGeneratedAttribute]
private BsonValue <CreateCommand>b__24_2();
}
public class MongoDB.Driver.Core.Operations.ExplainOperation : object {
    private DatabaseNamespace _databaseNamespace;
    private IExplainableOperation _explainableOperation;
    private MessageEncoderSettings _messageEncoderSettings;
    private ExplainVerbosity _verbosity;
    public DatabaseNamespace DatabaseNamespace { get; }
    public IExplainableOperation ExplainableOperation { get; }
    public MessageEncoderSettings MessageEncoderSettings { get; }
    public ExplainVerbosity Verbosity { get; public set; }
    public ExplainOperation(DatabaseNamespace databaseNamespace, IExplainableOperation explainableOperation, MessageEncoderSettings messageEncoderSettings);
    public DatabaseNamespace get_DatabaseNamespace();
    public IExplainableOperation get_ExplainableOperation();
    public MessageEncoderSettings get_MessageEncoderSettings();
    public ExplainVerbosity get_Verbosity();
    public void set_Verbosity(ExplainVerbosity value);
    public sealed virtual BsonDocument Execute(IReadBinding binding, CancellationToken cancellationToken);
    public sealed virtual BsonDocument Execute(IWriteBinding binding, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MongoDB.Driver.Core.Operations.ExplainOperation/<ExecuteAsync>d__16")]
public sealed virtual Task`1<BsonDocument> ExecuteAsync(IReadBinding binding, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MongoDB.Driver.Core.Operations.ExplainOperation/<ExecuteAsync>d__17")]
public sealed virtual Task`1<BsonDocument> ExecuteAsync(IWriteBinding binding, CancellationToken cancellationToken);
    private static string ConvertVerbosityToString(ExplainVerbosity verbosity);
    internal BsonDocument CreateExplainCommand(ConnectionDescription connectionDescription, ICoreSession session);
    private ReadCommandOperation`1<BsonDocument> CreateReadOperation(ConnectionDescription connectionDescription, ICoreSession session);
    private WriteCommandOperation`1<BsonDocument> CreateWriteOperation(ConnectionDescription connectionDescription, ICoreSession session);
}
public enum MongoDB.Driver.Core.Operations.ExplainVerbosity : Enum {
    public int value__;
    public static ExplainVerbosity QueryPlanner;
    public static ExplainVerbosity ExecutionStats;
    public static ExplainVerbosity AllPlansExecution;
}
public abstract class MongoDB.Driver.Core.Operations.FindAndModifyOperationBase`1 : object {
    private Collation _collation;
    private BsonValue _comment;
    private CollectionNamespace _collectionNamespace;
    private MessageEncoderSettings _messageEncoderSettings;
    private IBsonSerializer`1<TResult> _resultSerializer;
    private WriteConcern _writeConcern;
    private bool _retryRequested;
    public Collation Collation { get; public set; }
    public BsonValue Comment { get; public set; }
    public CollectionNamespace CollectionNamespace { get; }
    public MessageEncoderSettings MessageEncoderSettings { get; }
    public IBsonSerializer`1<TResult> ResultSerializer { get; }
    public WriteConcern WriteConcern { get; public set; }
    public bool RetryRequested { get; public set; }
    public FindAndModifyOperationBase`1(CollectionNamespace collectionNamespace, IBsonSerializer`1<TResult> resultSerializer, MessageEncoderSettings messageEncoderSettings);
    public Collation get_Collation();
    public void set_Collation(Collation value);
    public BsonValue get_Comment();
    public void set_Comment(BsonValue value);
    public CollectionNamespace get_CollectionNamespace();
    public MessageEncoderSettings get_MessageEncoderSettings();
    public IBsonSerializer`1<TResult> get_ResultSerializer();
    public sealed virtual WriteConcern get_WriteConcern();
    public void set_WriteConcern(WriteConcern value);
    public bool get_RetryRequested();
    public void set_RetryRequested(bool value);
    public sealed virtual TResult Execute(IWriteBinding binding, CancellationToken cancellationToken);
    public sealed virtual TResult Execute(RetryableWriteContext context, CancellationToken cancellationToken);
    public sealed virtual Task`1<TResult> ExecuteAsync(IWriteBinding binding, CancellationToken cancellationToken);
    public sealed virtual Task`1<TResult> ExecuteAsync(RetryableWriteContext context, CancellationToken cancellationToken);
    public sealed virtual TResult ExecuteAttempt(RetryableWriteContext context, int attempt, Nullable`1<long> transactionNumber, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MongoDB.Driver.Core.Operations.FindAndModifyOperationBase`1/<ExecuteAttemptAsync>d__31")]
public sealed virtual Task`1<TResult> ExecuteAttemptAsync(RetryableWriteContext context, int attempt, Nullable`1<long> transactionNumber, CancellationToken cancellationToken);
    private IDisposable BeginOperation();
    internal abstract virtual BsonDocument CreateCommand(ICoreSessionHandle session, ConnectionDescription connectionDescription, Nullable`1<long> transactionNumber);
    private WriteCommandOperation`1<RawBsonDocument> CreateOperation(ICoreSessionHandle session, ConnectionDescription connectionDescription, Nullable`1<long> transactionNumber);
    protected abstract virtual IElementNameValidator GetCommandValidator();
    private TResult ProcessCommandResult(ConnectionId connectionId, RawBsonDocument rawBsonDocument);
}
public class MongoDB.Driver.Core.Operations.FindAndModifyValueDeserializer`1 : SerializerBase`1<TResult> {
    private IBsonSerializer`1<TResult> _resultSerializer;
    public FindAndModifyValueDeserializer`1(IBsonSerializer`1<TResult> valueSerializer);
    public virtual TResult Deserialize(BsonDeserializationContext context, BsonDeserializationArgs args);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class MongoDB.Driver.Core.Operations.FindOneAndDeleteOperation`1 : FindAndModifyOperationBase`1<TResult> {
    private BsonDocument _filter;
    private BsonValue _hint;
    private BsonDocument _let;
    private Nullable`1<TimeSpan> _maxTime;
    private BsonDocument _projection;
    private BsonDocument _sort;
    public BsonDocument Filter { get; }
    public BsonValue Hint { get; public set; }
    public BsonDocument Let { get; public set; }
    public Nullable`1<TimeSpan> MaxTime { get; public set; }
    public BsonDocument Projection { get; public set; }
    public BsonDocument Sort { get; public set; }
    public FindOneAndDeleteOperation`1(CollectionNamespace collectionNamespace, BsonDocument filter, IBsonSerializer`1<TResult> resultSerializer, MessageEncoderSettings messageEncoderSettings);
    public BsonDocument get_Filter();
    public BsonValue get_Hint();
    public void set_Hint(BsonValue value);
    public BsonDocument get_Let();
    public void set_Let(BsonDocument value);
    public Nullable`1<TimeSpan> get_MaxTime();
    public void set_MaxTime(Nullable`1<TimeSpan> value);
    public BsonDocument get_Projection();
    public void set_Projection(BsonDocument value);
    public BsonDocument get_Sort();
    public void set_Sort(BsonDocument value);
    internal virtual BsonDocument CreateCommand(ICoreSessionHandle session, ConnectionDescription connectionDescription, Nullable`1<long> transactionNumber);
    protected virtual IElementNameValidator GetCommandValidator();
}
public class MongoDB.Driver.Core.Operations.FindOneAndReplaceOperation`1 : FindAndModifyOperationBase`1<TResult> {
    private Nullable`1<bool> _bypassDocumentValidation;
    private BsonDocument _filter;
    private BsonValue _hint;
    private bool _isUpsert;
    private BsonDocument _let;
    private Nullable`1<TimeSpan> _maxTime;
    private BsonDocument _projection;
    private BsonDocument _replacement;
    private ReturnDocument _returnDocument;
    private BsonDocument _sort;
    public Nullable`1<bool> BypassDocumentValidation { get; public set; }
    public BsonDocument Filter { get; }
    public BsonValue Hint { get; public set; }
    public bool IsUpsert { get; public set; }
    public BsonDocument Let { get; public set; }
    public Nullable`1<TimeSpan> MaxTime { get; public set; }
    public BsonDocument Projection { get; public set; }
    public BsonDocument Replacement { get; }
    public ReturnDocument ReturnDocument { get; public set; }
    public BsonDocument Sort { get; public set; }
    public FindOneAndReplaceOperation`1(CollectionNamespace collectionNamespace, BsonDocument filter, BsonDocument replacement, IBsonSerializer`1<TResult> resultSerializer, MessageEncoderSettings messageEncoderSettings);
    public Nullable`1<bool> get_BypassDocumentValidation();
    public void set_BypassDocumentValidation(Nullable`1<bool> value);
    public BsonDocument get_Filter();
    public BsonValue get_Hint();
    public void set_Hint(BsonValue value);
    public bool get_IsUpsert();
    public void set_IsUpsert(bool value);
    public BsonDocument get_Let();
    public void set_Let(BsonDocument value);
    public Nullable`1<TimeSpan> get_MaxTime();
    public void set_MaxTime(Nullable`1<TimeSpan> value);
    public BsonDocument get_Projection();
    public void set_Projection(BsonDocument value);
    public BsonDocument get_Replacement();
    public ReturnDocument get_ReturnDocument();
    public void set_ReturnDocument(ReturnDocument value);
    public BsonDocument get_Sort();
    public void set_Sort(BsonDocument value);
    internal virtual BsonDocument CreateCommand(ICoreSessionHandle session, ConnectionDescription connectionDescription, Nullable`1<long> transactionNumber);
    protected virtual IElementNameValidator GetCommandValidator();
}
public class MongoDB.Driver.Core.Operations.FindOneAndUpdateOperation`1 : FindAndModifyOperationBase`1<TResult> {
    private IEnumerable`1<BsonDocument> _arrayFilters;
    private Nullable`1<bool> _bypassDocumentValidation;
    private BsonDocument _filter;
    private BsonValue _hint;
    private bool _isUpsert;
    private BsonDocument _let;
    private Nullable`1<TimeSpan> _maxTime;
    private BsonDocument _projection;
    private ReturnDocument _returnDocument;
    private BsonDocument _sort;
    private BsonValue _update;
    public IEnumerable`1<BsonDocument> ArrayFilters { get; public set; }
    public Nullable`1<bool> BypassDocumentValidation { get; public set; }
    public BsonDocument Filter { get; }
    public BsonValue Hint { get; public set; }
    public bool IsUpsert { get; public set; }
    public BsonDocument Let { get; public set; }
    public Nullable`1<TimeSpan> MaxTime { get; public set; }
    public BsonDocument Projection { get; public set; }
    public ReturnDocument ReturnDocument { get; public set; }
    public BsonDocument Sort { get; public set; }
    public BsonValue Update { get; }
    public FindOneAndUpdateOperation`1(CollectionNamespace collectionNamespace, BsonDocument filter, BsonValue update, IBsonSerializer`1<TResult> resultSerializer, MessageEncoderSettings messageEncoderSettings);
    public IEnumerable`1<BsonDocument> get_ArrayFilters();
    public void set_ArrayFilters(IEnumerable`1<BsonDocument> value);
    public Nullable`1<bool> get_BypassDocumentValidation();
    public void set_BypassDocumentValidation(Nullable`1<bool> value);
    public BsonDocument get_Filter();
    public BsonValue get_Hint();
    public void set_Hint(BsonValue value);
    public bool get_IsUpsert();
    public void set_IsUpsert(bool value);
    public BsonDocument get_Let();
    public void set_Let(BsonDocument value);
    public Nullable`1<TimeSpan> get_MaxTime();
    public void set_MaxTime(Nullable`1<TimeSpan> value);
    public BsonDocument get_Projection();
    public void set_Projection(BsonDocument value);
    public ReturnDocument get_ReturnDocument();
    public void set_ReturnDocument(ReturnDocument value);
    public BsonDocument get_Sort();
    public void set_Sort(BsonDocument value);
    public BsonValue get_Update();
    internal virtual BsonDocument CreateCommand(ICoreSessionHandle session, ConnectionDescription connectionDescription, Nullable`1<long> transactionNumber);
    protected virtual IElementNameValidator GetCommandValidator();
    private BsonValue EnsureUpdateIsValid(BsonValue update);
}
public class MongoDB.Driver.Core.Operations.FindOperation`1 : object {
    private static IBsonSerializer`1<BsonDocument> __findCommandResultSerializer;
    private Nullable`1<bool> _allowDiskUse;
    private Nullable`1<bool> _allowPartialResults;
    private Nullable`1<int> _batchSize;
    private Collation _collation;
    private CollectionNamespace _collectionNamespace;
    private BsonValue _comment;
    private CursorType _cursorType;
    private BsonDocument _filter;
    private Nullable`1<int> _firstBatchSize;
    private BsonValue _hint;
    private BsonDocument _let;
    private Nullable`1<int> _limit;
    private BsonDocument _max;
    private Nullable`1<TimeSpan> _maxAwaitTime;
    private Nullable`1<int> _maxScan;
    private Nullable`1<TimeSpan> _maxTime;
    private MessageEncoderSettings _messageEncoderSettings;
    private BsonDocument _min;
    private BsonDocument _modifiers;
    private Nullable`1<bool> _noCursorTimeout;
    private Nullable`1<bool> _oplogReplay;
    private BsonDocument _projection;
    private ReadConcern _readConcern;
    private IBsonSerializer`1<TDocument> _resultSerializer;
    private bool _retryRequested;
    private Nullable`1<bool> _returnKey;
    private Nullable`1<bool> _showRecordId;
    private Nullable`1<bool> _singleBatch;
    private Nullable`1<int> _skip;
    private Nullable`1<bool> _snapshot;
    private BsonDocument _sort;
    public Nullable`1<bool> AllowDiskUse { get; public set; }
    public Nullable`1<bool> AllowPartialResults { get; public set; }
    public Nullable`1<int> BatchSize { get; public set; }
    public Collation Collation { get; public set; }
    public CollectionNamespace CollectionNamespace { get; }
    public BsonValue Comment { get; public set; }
    public CursorType CursorType { get; public set; }
    public BsonDocument Filter { get; public set; }
    public Nullable`1<int> FirstBatchSize { get; public set; }
    public BsonValue Hint { get; public set; }
    public BsonDocument Let { get; public set; }
    public Nullable`1<int> Limit { get; public set; }
    public BsonDocument Max { get; public set; }
    public Nullable`1<TimeSpan> MaxAwaitTime { get; public set; }
    [ObsoleteAttribute("MaxScan was deprecated in server version 4.0.")]
public Nullable`1<int> MaxScan { get; public set; }
    public Nullable`1<TimeSpan> MaxTime { get; public set; }
    public MessageEncoderSettings MessageEncoderSettings { get; }
    public BsonDocument Min { get; public set; }
    [ObsoleteAttribute("Use individual properties instead.")]
public BsonDocument Modifiers { get; public set; }
    public Nullable`1<bool> NoCursorTimeout { get; public set; }
    [ObsoleteAttribute("OplogReplay is ignored by server versions 4.4.0 and newer.")]
public Nullable`1<bool> OplogReplay { get; public set; }
    public BsonDocument Projection { get; public set; }
    public ReadConcern ReadConcern { get; public set; }
    public IBsonSerializer`1<TDocument> ResultSerializer { get; }
    public bool RetryRequested { get; public set; }
    public Nullable`1<bool> ReturnKey { get; public set; }
    public Nullable`1<bool> ShowRecordId { get; public set; }
    public Nullable`1<bool> SingleBatch { get; public set; }
    public Nullable`1<int> Skip { get; public set; }
    [ObsoleteAttribute("Snapshot was deprecated in server version 3.7.4.")]
public Nullable`1<bool> Snapshot { get; public set; }
    public BsonDocument Sort { get; public set; }
    public FindOperation`1(CollectionNamespace collectionNamespace, IBsonSerializer`1<TDocument> resultSerializer, MessageEncoderSettings messageEncoderSettings);
    private static FindOperation`1();
    public Nullable`1<bool> get_AllowDiskUse();
    public void set_AllowDiskUse(Nullable`1<bool> value);
    public Nullable`1<bool> get_AllowPartialResults();
    public void set_AllowPartialResults(Nullable`1<bool> value);
    public Nullable`1<int> get_BatchSize();
    public void set_BatchSize(Nullable`1<int> value);
    public Collation get_Collation();
    public void set_Collation(Collation value);
    public CollectionNamespace get_CollectionNamespace();
    public BsonValue get_Comment();
    public void set_Comment(BsonValue value);
    public CursorType get_CursorType();
    public void set_CursorType(CursorType value);
    public BsonDocument get_Filter();
    public void set_Filter(BsonDocument value);
    public Nullable`1<int> get_FirstBatchSize();
    public void set_FirstBatchSize(Nullable`1<int> value);
    public BsonValue get_Hint();
    public void set_Hint(BsonValue value);
    public BsonDocument get_Let();
    public void set_Let(BsonDocument value);
    public Nullable`1<int> get_Limit();
    public void set_Limit(Nullable`1<int> value);
    public BsonDocument get_Max();
    public void set_Max(BsonDocument value);
    public Nullable`1<TimeSpan> get_MaxAwaitTime();
    public void set_MaxAwaitTime(Nullable`1<TimeSpan> value);
    public Nullable`1<int> get_MaxScan();
    public void set_MaxScan(Nullable`1<int> value);
    public Nullable`1<TimeSpan> get_MaxTime();
    public void set_MaxTime(Nullable`1<TimeSpan> value);
    public MessageEncoderSettings get_MessageEncoderSettings();
    public BsonDocument get_Min();
    public void set_Min(BsonDocument value);
    public BsonDocument get_Modifiers();
    public void set_Modifiers(BsonDocument value);
    public Nullable`1<bool> get_NoCursorTimeout();
    public void set_NoCursorTimeout(Nullable`1<bool> value);
    public Nullable`1<bool> get_OplogReplay();
    public void set_OplogReplay(Nullable`1<bool> value);
    public BsonDocument get_Projection();
    public void set_Projection(BsonDocument value);
    public ReadConcern get_ReadConcern();
    public void set_ReadConcern(ReadConcern value);
    public IBsonSerializer`1<TDocument> get_ResultSerializer();
    public bool get_RetryRequested();
    public void set_RetryRequested(bool value);
    public Nullable`1<bool> get_ReturnKey();
    public void set_ReturnKey(Nullable`1<bool> value);
    public Nullable`1<bool> get_ShowRecordId();
    public void set_ShowRecordId(Nullable`1<bool> value);
    public Nullable`1<bool> get_SingleBatch();
    public void set_SingleBatch(Nullable`1<bool> value);
    public Nullable`1<int> get_Skip();
    public void set_Skip(Nullable`1<int> value);
    public Nullable`1<bool> get_Snapshot();
    public void set_Snapshot(Nullable`1<bool> value);
    public BsonDocument get_Sort();
    public void set_Sort(BsonDocument value);
    public sealed virtual BsonDocument CreateCommand(ConnectionDescription connectionDescription, ICoreSession session);
    private AsyncCursor`1<TDocument> CreateCursor(IChannelSourceHandle channelSource, IChannelHandle channel, BsonDocument commandResult);
    private CursorBatch`1<TDocument> CreateFirstCursorBatch(BsonDocument cursorDocument);
    public sealed virtual IAsyncCursor`1<TDocument> Execute(IReadBinding binding, CancellationToken cancellationToken);
    public sealed virtual IAsyncCursor`1<TDocument> Execute(RetryableReadContext context, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MongoDB.Driver.Core.Operations.FindOperation`1/<ExecuteAsync>d__128")]
public sealed virtual Task`1<IAsyncCursor`1<TDocument>> ExecuteAsync(IReadBinding binding, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MongoDB.Driver.Core.Operations.FindOperation`1/<ExecuteAsync>d__129")]
public sealed virtual Task`1<IAsyncCursor`1<TDocument>> ExecuteAsync(RetryableReadContext context, CancellationToken cancellationToken);
    private IDisposable BeginOperation();
    private ReadCommandOperation`1<BsonDocument> CreateOperation(RetryableReadContext context);
}
internal static class MongoDB.Driver.Core.Operations.FindProjectionChecker : object {
    internal static void ThrowIfAggregationExpressionIsUsedWhenNotSupported(BsonDocument projection, int wireVersion);
    [CompilerGeneratedAttribute]
internal static void <ThrowIfAggregationExpressionIsUsedWhenNotSupported>g__ThrowIfAggregationExpressionIsUsed|0_0(BsonElement specification);
    [CompilerGeneratedAttribute]
internal static bool <ThrowIfAggregationExpressionIsUsedWhenNotSupported>g__IsAggregationExpression|0_1(BsonValue value);
}
public class MongoDB.Driver.Core.Operations.GeoNearOperation`1 : object {
    private Collation _collation;
    private CollectionNamespace _collectionNamespace;
    private Nullable`1<double> _distanceMultiplier;
    private BsonDocument _filter;
    private Nullable`1<bool> _includeLocs;
    private Nullable`1<int> _limit;
    private Nullable`1<double> _maxDistance;
    private Nullable`1<TimeSpan> _maxTime;
    private MessageEncoderSettings _messageEncoderSettings;
    private BsonValue _near;
    private ReadConcern _readConcern;
    private IBsonSerializer`1<TResult> _resultSerializer;
    private Nullable`1<bool> _spherical;
    private Nullable`1<bool> _uniqueDocs;
    public Collation Collation { get; public set; }
    public CollectionNamespace CollectionNamespace { get; }
    public Nullable`1<double> DistanceMultiplier { get; public set; }
    public BsonDocument Filter { get; public set; }
    public Nullable`1<bool> IncludeLocs { get; public set; }
    public Nullable`1<int> Limit { get; public set; }
    public Nullable`1<double> MaxDistance { get; public set; }
    public Nullable`1<TimeSpan> MaxTime { get; public set; }
    public MessageEncoderSettings MessageEncoderSettings { get; }
    public BsonValue Near { get; }
    public ReadConcern ReadConcern { get; public set; }
    public IBsonSerializer`1<TResult> ResultSerializer { get; }
    public Nullable`1<bool> Spherical { get; public set; }
    public Nullable`1<bool> UniqueDocs { get; public set; }
    public GeoNearOperation`1(CollectionNamespace collectionNamespace, BsonValue near, IBsonSerializer`1<TResult> resultSerializer, MessageEncoderSettings messageEncoderSettings);
    public Collation get_Collation();
    public void set_Collation(Collation value);
    public CollectionNamespace get_CollectionNamespace();
    public Nullable`1<double> get_DistanceMultiplier();
    public void set_DistanceMultiplier(Nullable`1<double> value);
    public BsonDocument get_Filter();
    public void set_Filter(BsonDocument value);
    public Nullable`1<bool> get_IncludeLocs();
    public void set_IncludeLocs(Nullable`1<bool> value);
    public Nullable`1<int> get_Limit();
    public void set_Limit(Nullable`1<int> value);
    public Nullable`1<double> get_MaxDistance();
    public void set_MaxDistance(Nullable`1<double> value);
    public Nullable`1<TimeSpan> get_MaxTime();
    public void set_MaxTime(Nullable`1<TimeSpan> value);
    public MessageEncoderSettings get_MessageEncoderSettings();
    public BsonValue get_Near();
    public ReadConcern get_ReadConcern();
    public void set_ReadConcern(ReadConcern value);
    public IBsonSerializer`1<TResult> get_ResultSerializer();
    public Nullable`1<bool> get_Spherical();
    public void set_Spherical(Nullable`1<bool> value);
    public Nullable`1<bool> get_UniqueDocs();
    public void set_UniqueDocs(Nullable`1<bool> value);
    public sealed virtual TResult Execute(IReadBinding binding, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MongoDB.Driver.Core.Operations.GeoNearOperation`1/<ExecuteAsync>d__54")]
public sealed virtual Task`1<TResult> ExecuteAsync(IReadBinding binding, CancellationToken cancellationToken);
    internal BsonDocument CreateCommand(ConnectionDescription connectionDescription, ICoreSession session);
    private ReadCommandOperation`1<TResult> CreateOperation(IChannel channel, IBinding binding);
    [CompilerGeneratedAttribute]
private BsonValue <CreateCommand>b__55_0();
    [CompilerGeneratedAttribute]
private BsonValue <CreateCommand>b__55_1();
    [CompilerGeneratedAttribute]
private BsonValue <CreateCommand>b__55_2();
    [CompilerGeneratedAttribute]
private BsonValue <CreateCommand>b__55_3();
    [CompilerGeneratedAttribute]
private BsonValue <CreateCommand>b__55_4();
    [CompilerGeneratedAttribute]
private BsonValue <CreateCommand>b__55_5();
    [CompilerGeneratedAttribute]
private BsonValue <CreateCommand>b__55_6();
    [CompilerGeneratedAttribute]
private BsonValue <CreateCommand>b__55_7();
}
[ObsoleteAttribute("The geoSearch command was deprecated in server version 4.4.")]
public class MongoDB.Driver.Core.Operations.GeoSearchOperation`1 : object {
    private CollectionNamespace _collectionNamespace;
    private Nullable`1<int> _limit;
    private Nullable`1<double> _maxDistance;
    private Nullable`1<TimeSpan> _maxTime;
    private MessageEncoderSettings _messageEncoderSettings;
    private BsonValue _near;
    private ReadConcern _readConcern;
    private IBsonSerializer`1<TResult> _resultSerializer;
    private BsonDocument _search;
    public CollectionNamespace CollectionNamespace { get; }
    public Nullable`1<int> Limit { get; public set; }
    public Nullable`1<double> MaxDistance { get; public set; }
    public Nullable`1<TimeSpan> MaxTime { get; public set; }
    public MessageEncoderSettings MessageEncoderSettings { get; }
    public BsonValue Near { get; }
    public ReadConcern ReadConcern { get; public set; }
    public IBsonSerializer`1<TResult> ResultSerializer { get; }
    public BsonDocument Search { get; public set; }
    public GeoSearchOperation`1(CollectionNamespace collectionNamespace, BsonValue near, IBsonSerializer`1<TResult> resultSerializer, MessageEncoderSettings messageEncoderSettings);
    public CollectionNamespace get_CollectionNamespace();
    public Nullable`1<int> get_Limit();
    public void set_Limit(Nullable`1<int> value);
    public Nullable`1<double> get_MaxDistance();
    public void set_MaxDistance(Nullable`1<double> value);
    public Nullable`1<TimeSpan> get_MaxTime();
    public void set_MaxTime(Nullable`1<TimeSpan> value);
    public MessageEncoderSettings get_MessageEncoderSettings();
    public BsonValue get_Near();
    public ReadConcern get_ReadConcern();
    public void set_ReadConcern(ReadConcern value);
    public IBsonSerializer`1<TResult> get_ResultSerializer();
    public BsonDocument get_Search();
    public void set_Search(BsonDocument value);
    public sealed virtual TResult Execute(IReadBinding binding, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MongoDB.Driver.Core.Operations.GeoSearchOperation`1/<ExecuteAsync>d__34")]
public sealed virtual Task`1<TResult> ExecuteAsync(IReadBinding binding, CancellationToken cancellationToken);
    internal BsonDocument CreateCommand(ConnectionDescription connectionDescription, ICoreSession session);
    private IDisposable BeginOperation();
    private ReadCommandOperation`1<TResult> CreateOperation(IChannel channel, IBinding binding);
    [CompilerGeneratedAttribute]
private BsonValue <CreateCommand>b__35_0();
    [CompilerGeneratedAttribute]
private BsonValue <CreateCommand>b__35_1();
    [CompilerGeneratedAttribute]
private BsonValue <CreateCommand>b__35_2();
}
public class MongoDB.Driver.Core.Operations.GroupOperation`1 : object {
    private Collation _collation;
    private CollectionNamespace _collectionNamespace;
    private BsonDocument _filter;
    private BsonJavaScript _finalizeFunction;
    private BsonDocument _initial;
    private BsonDocument _key;
    private BsonJavaScript _keyFunction;
    private Nullable`1<TimeSpan> _maxTime;
    private MessageEncoderSettings _messageEncoderSettings;
    private BsonJavaScript _reduceFunction;
    private IBsonSerializer`1<TResult> _resultSerializer;
    public Collation Collation { get; public set; }
    public CollectionNamespace CollectionNamespace { get; }
    public BsonDocument Filter { get; }
    public BsonJavaScript FinalizeFunction { get; public set; }
    public BsonDocument Initial { get; }
    public BsonDocument Key { get; }
    public BsonJavaScript KeyFunction { get; }
    public Nullable`1<TimeSpan> MaxTime { get; public set; }
    public MessageEncoderSettings MessageEncoderSettings { get; }
    public BsonJavaScript ReduceFunction { get; }
    public IBsonSerializer`1<TResult> ResultSerializer { get; public set; }
    public GroupOperation`1(CollectionNamespace collectionNamespace, BsonDocument key, BsonDocument initial, BsonJavaScript reduceFunction, BsonDocument filter, MessageEncoderSettings messageEncoderSettings);
    public GroupOperation`1(CollectionNamespace collectionNamespace, BsonJavaScript keyFunction, BsonDocument initial, BsonJavaScript reduceFunction, BsonDocument filter, MessageEncoderSettings messageEncoderSettings);
    public Collation get_Collation();
    public void set_Collation(Collation value);
    public CollectionNamespace get_CollectionNamespace();
    public BsonDocument get_Filter();
    public BsonJavaScript get_FinalizeFunction();
    public void set_FinalizeFunction(BsonJavaScript value);
    public BsonDocument get_Initial();
    public BsonDocument get_Key();
    public BsonJavaScript get_KeyFunction();
    public Nullable`1<TimeSpan> get_MaxTime();
    public void set_MaxTime(Nullable`1<TimeSpan> value);
    public MessageEncoderSettings get_MessageEncoderSettings();
    public BsonJavaScript get_ReduceFunction();
    public IBsonSerializer`1<TResult> get_ResultSerializer();
    public void set_ResultSerializer(IBsonSerializer`1<TResult> value);
    public sealed virtual IEnumerable`1<TResult> Execute(IReadBinding binding, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MongoDB.Driver.Core.Operations.GroupOperation`1/<ExecuteAsync>d__40")]
public sealed virtual Task`1<IEnumerable`1<TResult>> ExecuteAsync(IReadBinding binding, CancellationToken cancellationToken);
    internal BsonDocument CreateCommand();
    private ReadCommandOperation`1<TResult[]> CreateOperation();
    [CompilerGeneratedAttribute]
private BsonValue <CreateCommand>b__41_1();
    [CompilerGeneratedAttribute]
private BsonValue <CreateCommand>b__41_0();
}
public interface MongoDB.Driver.Core.Operations.IChangeStreamOperation`1 {
    public BsonDocument ResumeAfter { get; public set; }
    public Nullable`1<bool> ShowExpandedEvents { get; public set; }
    public BsonDocument StartAfter { get; public set; }
    public BsonTimestamp StartAtOperationTime { get; public set; }
    public abstract virtual BsonDocument get_ResumeAfter();
    public abstract virtual void set_ResumeAfter(BsonDocument value);
    public abstract virtual Nullable`1<bool> get_ShowExpandedEvents();
    public abstract virtual void set_ShowExpandedEvents(Nullable`1<bool> value);
    public abstract virtual BsonDocument get_StartAfter();
    public abstract virtual void set_StartAfter(BsonDocument value);
    public abstract virtual BsonTimestamp get_StartAtOperationTime();
    public abstract virtual void set_StartAtOperationTime(BsonTimestamp value);
    public abstract virtual IAsyncCursor`1<RawBsonDocument> Resume(IReadBinding binding, CancellationToken cancellationToken);
    public abstract virtual Task`1<IAsyncCursor`1<RawBsonDocument>> ResumeAsync(IReadBinding binding, CancellationToken cancellationToken);
}
public interface MongoDB.Driver.Core.Operations.IExecutableInRetryableReadContext`1 {
    public abstract virtual TResult Execute(RetryableReadContext context, CancellationToken cancellationToken);
    public abstract virtual Task`1<TResult> ExecuteAsync(RetryableReadContext context, CancellationToken cancellationToken);
}
public interface MongoDB.Driver.Core.Operations.IExecutableInRetryableWriteContext`1 {
    public abstract virtual TResult Execute(RetryableWriteContext context, CancellationToken cancellationToken);
    public abstract virtual Task`1<TResult> ExecuteAsync(RetryableWriteContext context, CancellationToken cancellationToken);
}
public interface MongoDB.Driver.Core.Operations.IExplainableOperation {
    public abstract virtual BsonDocument CreateCommand(ConnectionDescription connectionDescription, ICoreSession session);
}
public static class MongoDB.Driver.Core.Operations.IndexNameHelper : object {
    public static string GetIndexName(BsonDocument keys);
    public static string GetIndexName(String[] keyNames);
}
public class MongoDB.Driver.Core.Operations.InsertOpcodeOperation`1 : object {
    private Nullable`1<bool> _bypassDocumentValidation;
    private CollectionNamespace _collectionNamespace;
    private bool _continueOnError;
    private IReadOnlyList`1<TDocument> _documents;
    private BatchableSource`1<TDocument> _documentSource;
    private Nullable`1<int> _maxBatchCount;
    private Nullable`1<int> _maxDocumentSize;
    private Nullable`1<int> _maxMessageSize;
    private MessageEncoderSettings _messageEncoderSettings;
    private bool _retryRequested;
    private IBsonSerializer`1<TDocument> _serializer;
    private WriteConcern _writeConcern;
    public Nullable`1<bool> BypassDocumentValidation { get; public set; }
    public CollectionNamespace CollectionNamespace { get; }
    public bool ContinueOnError { get; public set; }
    public IReadOnlyList`1<TDocument> Documents { get; }
    public BatchableSource`1<TDocument> DocumentSource { get; }
    public Nullable`1<int> MaxBatchCount { get; public set; }
    public Nullable`1<int> MaxDocumentSize { get; public set; }
    public Nullable`1<int> MaxMessageSize { get; public set; }
    public MessageEncoderSettings MessageEncoderSettings { get; }
    public bool RetryRequested { get; public set; }
    public IBsonSerializer`1<TDocument> Serializer { get; }
    public WriteConcern WriteConcern { get; public set; }
    public InsertOpcodeOperation`1(CollectionNamespace collectionNamespace, IEnumerable`1<TDocument> documents, IBsonSerializer`1<TDocument> serializer, MessageEncoderSettings messageEncoderSettings);
    [ObsoleteAttribute("Use the constructor that takes an IEnumerable<TDocument> instead of a BatchableSource<TDocument>.")]
public InsertOpcodeOperation`1(CollectionNamespace collectionNamespace, BatchableSource`1<TDocument> documentSource, IBsonSerializer`1<TDocument> serializer, MessageEncoderSettings messageEncoderSettings);
    public Nullable`1<bool> get_BypassDocumentValidation();
    public void set_BypassDocumentValidation(Nullable`1<bool> value);
    public CollectionNamespace get_CollectionNamespace();
    public bool get_ContinueOnError();
    public void set_ContinueOnError(bool value);
    public IReadOnlyList`1<TDocument> get_Documents();
    public BatchableSource`1<TDocument> get_DocumentSource();
    public Nullable`1<int> get_MaxBatchCount();
    public void set_MaxBatchCount(Nullable`1<int> value);
    public Nullable`1<int> get_MaxDocumentSize();
    public void set_MaxDocumentSize(Nullable`1<int> value);
    public Nullable`1<int> get_MaxMessageSize();
    public void set_MaxMessageSize(Nullable`1<int> value);
    public MessageEncoderSettings get_MessageEncoderSettings();
    public bool get_RetryRequested();
    public void set_RetryRequested(bool value);
    public IBsonSerializer`1<TDocument> get_Serializer();
    public WriteConcern get_WriteConcern();
    public void set_WriteConcern(WriteConcern value);
    public sealed virtual IEnumerable`1<WriteConcernResult> Execute(IWriteBinding binding, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MongoDB.Driver.Core.Operations.InsertOpcodeOperation`1/<ExecuteAsync>d__46")]
public sealed virtual Task`1<IEnumerable`1<WriteConcernResult>> ExecuteAsync(IWriteBinding binding, CancellationToken cancellationToken);
    private InsertOpcodeOperationEmulator`1<TDocument> CreateEmulator();
}
internal class MongoDB.Driver.Core.Operations.InsertOpcodeOperationEmulator`1 : object {
    private Nullable`1<bool> _bypassDocumentValidation;
    private CollectionNamespace _collectionNamespace;
    private bool _continueOnError;
    private BatchableSource`1<TDocument> _documentSource;
    private Nullable`1<int> _maxBatchCount;
    private Nullable`1<int> _maxDocumentSize;
    private Nullable`1<int> _maxMessageSize;
    private MessageEncoderSettings _messageEncoderSettings;
    private bool _retryRequested;
    private IBsonSerializer`1<TDocument> _serializer;
    private WriteConcern _writeConcern;
    public Nullable`1<bool> BypassDocumentValidation { get; public set; }
    public CollectionNamespace CollectionNamespace { get; }
    public bool ContinueOnError { get; public set; }
    public BatchableSource`1<TDocument> DocumentSource { get; }
    public Nullable`1<int> MaxBatchCount { get; public set; }
    public Nullable`1<int> MaxDocumentSize { get; public set; }
    public Nullable`1<int> MaxMessageSize { get; public set; }
    public MessageEncoderSettings MessageEncoderSettings { get; }
    public bool RetryRequested { get; public set; }
    public IBsonSerializer`1<TDocument> Serializer { get; }
    public WriteConcern WriteConcern { get; public set; }
    public InsertOpcodeOperationEmulator`1(CollectionNamespace collectionNamespace, IBsonSerializer`1<TDocument> serializer, BatchableSource`1<TDocument> documentSource, MessageEncoderSettings messageEncoderSettings);
    public Nullable`1<bool> get_BypassDocumentValidation();
    public void set_BypassDocumentValidation(Nullable`1<bool> value);
    public CollectionNamespace get_CollectionNamespace();
    public bool get_ContinueOnError();
    public void set_ContinueOnError(bool value);
    public BatchableSource`1<TDocument> get_DocumentSource();
    public Nullable`1<int> get_MaxBatchCount();
    public void set_MaxBatchCount(Nullable`1<int> value);
    public Nullable`1<int> get_MaxDocumentSize();
    public void set_MaxDocumentSize(Nullable`1<int> value);
    public Nullable`1<int> get_MaxMessageSize();
    public void set_MaxMessageSize(Nullable`1<int> value);
    public MessageEncoderSettings get_MessageEncoderSettings();
    public bool get_RetryRequested();
    public void set_RetryRequested(bool value);
    public IBsonSerializer`1<TDocument> get_Serializer();
    public WriteConcern get_WriteConcern();
    public void set_WriteConcern(WriteConcern value);
    public sealed virtual WriteConcernResult Execute(RetryableWriteContext context, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MongoDB.Driver.Core.Operations.InsertOpcodeOperationEmulator`1/<ExecuteAsync>d__42")]
public sealed virtual Task`1<WriteConcernResult> ExecuteAsync(RetryableWriteContext context, CancellationToken cancellationToken);
    private BulkInsertOperation CreateOperation();
    private WriteConcernResult CreateResultOrThrow(IChannel channel, BulkWriteOperationResult result, MongoBulkWriteOperationException exception);
    [CompilerGeneratedAttribute]
private InsertRequest <CreateOperation>b__43_0(TDocument d);
}
public class MongoDB.Driver.Core.Operations.InsertRequest : WriteRequest {
    private BsonDocument _document;
    public BsonDocument Document { get; }
    public InsertRequest(BsonDocument document);
    public BsonDocument get_Document();
    public virtual bool IsRetryable(ConnectionDescription connectionDescription);
}
public interface MongoDB.Driver.Core.Operations.IOperationClock {
    public BsonTimestamp OperationTime { get; }
    public abstract virtual BsonTimestamp get_OperationTime();
    public abstract virtual void AdvanceOperationTime(BsonTimestamp newOperationTime);
}
public interface MongoDB.Driver.Core.Operations.IReadOperation`1 {
    public abstract virtual TResult Execute(IReadBinding binding, CancellationToken cancellationToken);
    public abstract virtual Task`1<TResult> ExecuteAsync(IReadBinding binding, CancellationToken cancellationToken);
}
public interface MongoDB.Driver.Core.Operations.IRetryableReadOperation`1 {
    public abstract virtual TResult ExecuteAttempt(RetryableReadContext context, int attempt, Nullable`1<long> transactionNumber, CancellationToken cancellationToken);
    public abstract virtual Task`1<TResult> ExecuteAttemptAsync(RetryableReadContext context, int attempt, Nullable`1<long> transactionNumber, CancellationToken cancellationToken);
}
public interface MongoDB.Driver.Core.Operations.IRetryableWriteOperation`1 {
    public WriteConcern WriteConcern { get; }
    public abstract virtual WriteConcern get_WriteConcern();
    public abstract virtual TResult ExecuteAttempt(RetryableWriteContext context, int attempt, Nullable`1<long> transactionNumber, CancellationToken cancellationToken);
    public abstract virtual Task`1<TResult> ExecuteAttemptAsync(RetryableWriteContext context, int attempt, Nullable`1<long> transactionNumber, CancellationToken cancellationToken);
}
public interface MongoDB.Driver.Core.Operations.IWriteOperation`1 {
    public abstract virtual TResult Execute(IWriteBinding binding, CancellationToken cancellationToken);
    public abstract virtual Task`1<TResult> ExecuteAsync(IWriteBinding binding, CancellationToken cancellationToken);
}
public class MongoDB.Driver.Core.Operations.ListCollectionsOperation : object {
    private Nullable`1<bool> _authorizedCollections;
    private Nullable`1<int> _batchSize;
    private BsonValue _comment;
    private BsonDocument _filter;
    private DatabaseNamespace _databaseNamespace;
    private MessageEncoderSettings _messageEncoderSettings;
    private Nullable`1<bool> _nameOnly;
    private bool _retryRequested;
    public Nullable`1<bool> AuthorizedCollections { get; public set; }
    public Nullable`1<int> BatchSize { get; public set; }
    public BsonValue Comment { get; public set; }
    public BsonDocument Filter { get; public set; }
    public DatabaseNamespace DatabaseNamespace { get; }
    public MessageEncoderSettings MessageEncoderSettings { get; }
    public Nullable`1<bool> NameOnly { get; public set; }
    public bool RetryRequested { get; public set; }
    public ListCollectionsOperation(DatabaseNamespace databaseNamespace, MessageEncoderSettings messageEncoderSettings);
    public Nullable`1<bool> get_AuthorizedCollections();
    public void set_AuthorizedCollections(Nullable`1<bool> value);
    public Nullable`1<int> get_BatchSize();
    public void set_BatchSize(Nullable`1<int> value);
    public BsonValue get_Comment();
    public void set_Comment(BsonValue value);
    public BsonDocument get_Filter();
    public void set_Filter(BsonDocument value);
    public DatabaseNamespace get_DatabaseNamespace();
    public MessageEncoderSettings get_MessageEncoderSettings();
    public Nullable`1<bool> get_NameOnly();
    public void set_NameOnly(Nullable`1<bool> value);
    public bool get_RetryRequested();
    public void set_RetryRequested(bool value);
    public sealed virtual IAsyncCursor`1<BsonDocument> Execute(IReadBinding binding, CancellationToken cancellationToken);
    public sealed virtual IAsyncCursor`1<BsonDocument> Execute(RetryableReadContext context, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MongoDB.Driver.Core.Operations.ListCollectionsOperation/<ExecuteAsync>d__33")]
public sealed virtual Task`1<IAsyncCursor`1<BsonDocument>> ExecuteAsync(IReadBinding binding, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MongoDB.Driver.Core.Operations.ListCollectionsOperation/<ExecuteAsync>d__34")]
public sealed virtual Task`1<IAsyncCursor`1<BsonDocument>> ExecuteAsync(RetryableReadContext context, CancellationToken cancellationToken);
    private IDisposable BeginOperation();
    private ReadCommandOperation`1<BsonDocument> CreateOperation();
    private IAsyncCursor`1<BsonDocument> CreateCursor(IChannelSourceHandle channelSource, IChannelHandle channel, BsonDocument result);
    [CompilerGeneratedAttribute]
private BsonValue <CreateOperation>b__36_0();
    [CompilerGeneratedAttribute]
private BsonValue <CreateOperation>b__36_1();
    [CompilerGeneratedAttribute]
private BsonValue <CreateOperation>b__36_2();
}
public class MongoDB.Driver.Core.Operations.ListDatabasesOperation : object {
    private Nullable`1<bool> _authorizedDatabases;
    private BsonValue _comment;
    private BsonDocument _filter;
    private MessageEncoderSettings _messageEncoderSettings;
    private Nullable`1<bool> _nameOnly;
    private bool _retryRequested;
    public Nullable`1<bool> AuthorizedDatabases { get; public set; }
    public BsonValue Comment { get; public set; }
    public BsonDocument Filter { get; public set; }
    public MessageEncoderSettings MessageEncoderSettings { get; }
    public Nullable`1<bool> NameOnly { get; public set; }
    public bool RetryRequested { get; public set; }
    public ListDatabasesOperation(MessageEncoderSettings messageEncoderSettings);
    public Nullable`1<bool> get_AuthorizedDatabases();
    public void set_AuthorizedDatabases(Nullable`1<bool> value);
    public BsonValue get_Comment();
    public void set_Comment(BsonValue value);
    public BsonDocument get_Filter();
    public void set_Filter(BsonDocument value);
    public MessageEncoderSettings get_MessageEncoderSettings();
    public Nullable`1<bool> get_NameOnly();
    public void set_NameOnly(Nullable`1<bool> value);
    public bool get_RetryRequested();
    public void set_RetryRequested(bool value);
    public sealed virtual IAsyncCursor`1<BsonDocument> Execute(IReadBinding binding, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MongoDB.Driver.Core.Operations.ListDatabasesOperation/<ExecuteAsync>d__25")]
public sealed virtual Task`1<IAsyncCursor`1<BsonDocument>> ExecuteAsync(IReadBinding binding, CancellationToken cancellationToken);
    internal BsonDocument CreateCommand();
    private IDisposable BeginOperation();
    private IAsyncCursor`1<BsonDocument> CreateCursor(BsonDocument reply);
    private ReadCommandOperation`1<BsonDocument> CreateOperation();
}
public class MongoDB.Driver.Core.Operations.ListIndexesOperation : object {
    private Nullable`1<int> _batchSize;
    private CollectionNamespace _collectionNamespace;
    private BsonValue _comment;
    private MessageEncoderSettings _messageEncoderSettings;
    private bool _retryRequested;
    public Nullable`1<int> BatchSize { get; public set; }
    public CollectionNamespace CollectionNamespace { get; }
    public BsonValue Comment { get; public set; }
    public MessageEncoderSettings MessageEncoderSettings { get; }
    public bool RetryRequested { get; public set; }
    public ListIndexesOperation(CollectionNamespace collectionNamespace, MessageEncoderSettings messageEncoderSettings);
    public Nullable`1<int> get_BatchSize();
    public void set_BatchSize(Nullable`1<int> value);
    public CollectionNamespace get_CollectionNamespace();
    public BsonValue get_Comment();
    public void set_Comment(BsonValue value);
    public MessageEncoderSettings get_MessageEncoderSettings();
    public bool get_RetryRequested();
    public void set_RetryRequested(bool value);
    public sealed virtual IAsyncCursor`1<BsonDocument> Execute(IReadBinding binding, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MongoDB.Driver.Core.Operations.ListIndexesOperation/<ExecuteAsync>d__20")]
public sealed virtual Task`1<IAsyncCursor`1<BsonDocument>> ExecuteAsync(IReadBinding binding, CancellationToken cancellationToken);
    private IDisposable BeginOperation();
    private IExecutableInRetryableReadContext`1<IAsyncCursor`1<BsonDocument>> CreateOperation(IChannel channel);
}
public class MongoDB.Driver.Core.Operations.ListIndexesUsingCommandOperation : object {
    private Nullable`1<int> _batchSize;
    private CollectionNamespace _collectionNamespace;
    private BsonValue _comment;
    private MessageEncoderSettings _messageEncoderSettings;
    private bool _retryRequested;
    public Nullable`1<int> BatchSize { get; public set; }
    public CollectionNamespace CollectionNamespace { get; }
    public BsonValue Comment { get; public set; }
    public MessageEncoderSettings MessageEncoderSettings { get; }
    public bool RetryRequested { get; public set; }
    public ListIndexesUsingCommandOperation(CollectionNamespace collectionNamespace, MessageEncoderSettings messageEncoderSettings);
    public Nullable`1<int> get_BatchSize();
    public void set_BatchSize(Nullable`1<int> value);
    public CollectionNamespace get_CollectionNamespace();
    public BsonValue get_Comment();
    public void set_Comment(BsonValue value);
    public MessageEncoderSettings get_MessageEncoderSettings();
    public bool get_RetryRequested();
    public void set_RetryRequested(bool value);
    public sealed virtual IAsyncCursor`1<BsonDocument> Execute(IReadBinding binding, CancellationToken cancellationToken);
    public sealed virtual IAsyncCursor`1<BsonDocument> Execute(RetryableReadContext context, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MongoDB.Driver.Core.Operations.ListIndexesUsingCommandOperation/<ExecuteAsync>d__21")]
public sealed virtual Task`1<IAsyncCursor`1<BsonDocument>> ExecuteAsync(IReadBinding binding, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MongoDB.Driver.Core.Operations.ListIndexesUsingCommandOperation/<ExecuteAsync>d__22")]
public sealed virtual Task`1<IAsyncCursor`1<BsonDocument>> ExecuteAsync(RetryableReadContext context, CancellationToken cancellationToken);
    private ReadCommandOperation`1<BsonDocument> CreateOperation();
    private IAsyncCursor`1<BsonDocument> CreateCursor(IChannelSourceHandle channelSource, IChannelHandle channel, BsonDocument result);
    private bool IsCollectionNotFoundException(MongoCommandException ex);
    [CompilerGeneratedAttribute]
private BsonValue <CreateOperation>b__23_0();
}
[ObsoleteAttribute("Use Aggregation pipeline instead.")]
public class MongoDB.Driver.Core.Operations.MapReduceLegacyOperation : MapReduceOperationBase {
    private ReadConcern _readConcern;
    public ReadConcern ReadConcern { get; public set; }
    public MapReduceLegacyOperation(CollectionNamespace collectionNamespace, BsonJavaScript mapFunction, BsonJavaScript reduceFunction, MessageEncoderSettings messageEncoderSettings);
    public ReadConcern get_ReadConcern();
    public void set_ReadConcern(ReadConcern value);
    protected virtual BsonDocument CreateOutputOptions();
    public sealed virtual BsonDocument Execute(IReadBinding binding, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MongoDB.Driver.Core.Operations.MapReduceLegacyOperation/<ExecuteAsync>d__7")]
public sealed virtual Task`1<BsonDocument> ExecuteAsync(IReadBinding binding, CancellationToken cancellationToken);
    protected internal virtual BsonDocument CreateCommand(ICoreSessionHandle session, ConnectionDescription connectionDescription);
    private ReadCommandOperation`1<BsonDocument> CreateOperation(ICoreSessionHandle session, ConnectionDescription connectionDescription);
}
[ObsoleteAttribute("Use Aggregation pipeline instead.")]
public class MongoDB.Driver.Core.Operations.MapReduceOperation`1 : MapReduceOperationBase {
    private ReadConcern _readConcern;
    private IBsonSerializer`1<TResult> _resultSerializer;
    public ReadConcern ReadConcern { get; public set; }
    public IBsonSerializer`1<TResult> ResultSerializer { get; }
    public MapReduceOperation`1(CollectionNamespace collectionNamespace, BsonJavaScript mapFunction, BsonJavaScript reduceFunction, IBsonSerializer`1<TResult> resultSerializer, MessageEncoderSettings messageEncoderSettings);
    public ReadConcern get_ReadConcern();
    public void set_ReadConcern(ReadConcern value);
    public IBsonSerializer`1<TResult> get_ResultSerializer();
    protected virtual BsonDocument CreateOutputOptions();
    public sealed virtual IAsyncCursor`1<TResult> Execute(IReadBinding binding, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MongoDB.Driver.Core.Operations.MapReduceOperation`1/<ExecuteAsync>d__10")]
public sealed virtual Task`1<IAsyncCursor`1<TResult>> ExecuteAsync(IReadBinding binding, CancellationToken cancellationToken);
    protected internal virtual BsonDocument CreateCommand(ICoreSessionHandle session, ConnectionDescription connectionDescription);
    private ReadCommandOperation`1<TResult[]> CreateOperation(ICoreSessionHandle session, ConnectionDescription connectionDescription);
}
[ObsoleteAttribute("Use Aggregation pipeline instead.")]
public abstract class MongoDB.Driver.Core.Operations.MapReduceOperationBase : object {
    private Collation _collation;
    private CollectionNamespace _collectionNamespace;
    private BsonDocument _filter;
    private BsonJavaScript _finalizeFunction;
    private Nullable`1<bool> _javaScriptMode;
    private Nullable`1<long> _limit;
    private BsonJavaScript _mapFunction;
    private Nullable`1<TimeSpan> _maxTime;
    private MessageEncoderSettings _messageEncoderSettings;
    private BsonJavaScript _reduceFunction;
    private BsonDocument _scope;
    private BsonDocument _sort;
    private Nullable`1<bool> _verbose;
    public Collation Collation { get; public set; }
    public CollectionNamespace CollectionNamespace { get; }
    public BsonDocument Filter { get; public set; }
    public BsonJavaScript FinalizeFunction { get; public set; }
    [ObsoleteAttribute("JavaScriptMode is ignored by server versions 4.4.0 and newer.")]
public Nullable`1<bool> JavaScriptMode { get; public set; }
    public Nullable`1<long> Limit { get; public set; }
    public BsonJavaScript MapFunction { get; }
    public Nullable`1<TimeSpan> MaxTime { get; public set; }
    public MessageEncoderSettings MessageEncoderSettings { get; }
    public BsonJavaScript ReduceFunction { get; }
    public BsonDocument Scope { get; public set; }
    public BsonDocument Sort { get; public set; }
    public Nullable`1<bool> Verbose { get; public set; }
    protected MapReduceOperationBase(CollectionNamespace collectionNamespace, BsonJavaScript mapFunction, BsonJavaScript reduceFunction, MessageEncoderSettings messageEncoderSettings);
    public Collation get_Collation();
    public void set_Collation(Collation value);
    public CollectionNamespace get_CollectionNamespace();
    public BsonDocument get_Filter();
    public void set_Filter(BsonDocument value);
    public BsonJavaScript get_FinalizeFunction();
    public void set_FinalizeFunction(BsonJavaScript value);
    public Nullable`1<bool> get_JavaScriptMode();
    public void set_JavaScriptMode(Nullable`1<bool> value);
    public Nullable`1<long> get_Limit();
    public void set_Limit(Nullable`1<long> value);
    public BsonJavaScript get_MapFunction();
    public Nullable`1<TimeSpan> get_MaxTime();
    public void set_MaxTime(Nullable`1<TimeSpan> value);
    public MessageEncoderSettings get_MessageEncoderSettings();
    public BsonJavaScript get_ReduceFunction();
    public BsonDocument get_Scope();
    public void set_Scope(BsonDocument value);
    public BsonDocument get_Sort();
    public void set_Sort(BsonDocument value);
    public Nullable`1<bool> get_Verbose();
    public void set_Verbose(Nullable`1<bool> value);
    protected internal virtual BsonDocument CreateCommand(ICoreSessionHandle session, ConnectionDescription connectionDescription);
    protected abstract virtual BsonDocument CreateOutputOptions();
    [CompilerGeneratedAttribute]
private BsonValue <CreateCommand>b__49_0();
    [CompilerGeneratedAttribute]
private BsonValue <CreateCommand>b__49_1();
    [CompilerGeneratedAttribute]
private BsonValue <CreateCommand>b__49_2();
    [CompilerGeneratedAttribute]
private BsonValue <CreateCommand>b__49_3();
    [CompilerGeneratedAttribute]
private BsonValue <CreateCommand>b__49_4();
}
[ObsoleteAttribute("Use Aggregation pipeline instead.")]
public enum MongoDB.Driver.Core.Operations.MapReduceOutputMode : Enum {
    public int value__;
    public static MapReduceOutputMode Replace;
    public static MapReduceOutputMode Merge;
    public static MapReduceOutputMode Reduce;
}
[ObsoleteAttribute("Use Aggregation pipeline instead.")]
public class MongoDB.Driver.Core.Operations.MapReduceOutputToCollectionOperation : MapReduceOperationBase {
    private Nullable`1<bool> _bypassDocumentValidation;
    private Nullable`1<bool> _nonAtomicOutput;
    private CollectionNamespace _outputCollectionNamespace;
    private MapReduceOutputMode _outputMode;
    private Nullable`1<bool> _shardedOutput;
    private WriteConcern _writeConcern;
    public Nullable`1<bool> BypassDocumentValidation { get; public set; }
    [ObsoleteAttribute("NonAtomicOutput is rejected by server versions 4.4.0 and newer.")]
public Nullable`1<bool> NonAtomicOutput { get; public set; }
    public CollectionNamespace OutputCollectionNamespace { get; }
    public MapReduceOutputMode OutputMode { get; public set; }
    [ObsoleteAttribute("ShardedOutput is rejected by server versions 4.4.0 and newer.")]
public Nullable`1<bool> ShardedOutput { get; public set; }
    public WriteConcern WriteConcern { get; public set; }
    public MapReduceOutputToCollectionOperation(CollectionNamespace collectionNamespace, CollectionNamespace outputCollectionNamespace, BsonJavaScript mapFunction, BsonJavaScript reduceFunction, MessageEncoderSettings messageEncoderSettings);
    public Nullable`1<bool> get_BypassDocumentValidation();
    public void set_BypassDocumentValidation(Nullable`1<bool> value);
    public Nullable`1<bool> get_NonAtomicOutput();
    public void set_NonAtomicOutput(Nullable`1<bool> value);
    public CollectionNamespace get_OutputCollectionNamespace();
    public MapReduceOutputMode get_OutputMode();
    public void set_OutputMode(MapReduceOutputMode value);
    public Nullable`1<bool> get_ShardedOutput();
    public void set_ShardedOutput(Nullable`1<bool> value);
    public WriteConcern get_WriteConcern();
    public void set_WriteConcern(WriteConcern value);
    protected internal virtual BsonDocument CreateCommand(ICoreSessionHandle session, ConnectionDescription connectionDescription);
    protected virtual BsonDocument CreateOutputOptions();
    public sealed virtual BsonDocument Execute(IWriteBinding binding, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MongoDB.Driver.Core.Operations.MapReduceOutputToCollectionOperation/<ExecuteAsync>d__27")]
public sealed virtual Task`1<BsonDocument> ExecuteAsync(IWriteBinding binding, CancellationToken cancellationToken);
    private WriteCommandOperation`1<BsonDocument> CreateOperation(ICoreSessionHandle session, ConnectionDescription connectionDescription);
    [CompilerGeneratedAttribute]
private BsonValue <CreateOutputOptions>b__25_0();
    [CompilerGeneratedAttribute]
private BsonValue <CreateOutputOptions>b__25_1();
}
public class MongoDB.Driver.Core.Operations.MongoBulkWriteOperationException : MongoServerException {
    private BulkWriteOperationResult _result;
    private IReadOnlyList`1<WriteRequest> _unprocessedRequests;
    private BulkWriteConcernError _writeConcernError;
    private IReadOnlyList`1<BulkWriteOperationError> _writeErrors;
    public BulkWriteOperationResult Result { get; }
    public IReadOnlyList`1<WriteRequest> UnprocessedRequests { get; }
    public BulkWriteConcernError WriteConcernError { get; }
    public IReadOnlyList`1<BulkWriteOperationError> WriteErrors { get; }
    public MongoBulkWriteOperationException(ConnectionId connectionId, BulkWriteOperationResult result, IReadOnlyList`1<BulkWriteOperationError> writeErrors, BulkWriteConcernError writeConcernError, IReadOnlyList`1<WriteRequest> unprocessedRequests);
    public MongoBulkWriteOperationException(SerializationInfo info, StreamingContext context);
    public BulkWriteOperationResult get_Result();
    public IReadOnlyList`1<WriteRequest> get_UnprocessedRequests();
    public BulkWriteConcernError get_WriteConcernError();
    public IReadOnlyList`1<BulkWriteOperationError> get_WriteErrors();
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    private static string FormatMessage(IReadOnlyList`1<BulkWriteOperationError> writeErrors, BulkWriteConcernError writeConcernError);
}
public class MongoDB.Driver.Core.Operations.NoOperationClock : object {
    public BsonTimestamp OperationTime { get; }
    public sealed virtual BsonTimestamp get_OperationTime();
    public sealed virtual void AdvanceOperationTime(BsonTimestamp newOperationTime);
}
internal class MongoDB.Driver.Core.Operations.OperationClock : object {
    private BsonTimestamp _operationTime;
    public BsonTimestamp OperationTime { get; }
    public static BsonTimestamp GreaterOperationTime(BsonTimestamp x, BsonTimestamp y);
    public sealed virtual BsonTimestamp get_OperationTime();
    public sealed virtual void AdvanceOperationTime(BsonTimestamp newOperationTime);
}
[ExtensionAttribute]
public static class MongoDB.Driver.Core.Operations.OperationExtensionMethods : object {
    [ExtensionAttribute]
public static TResult Execute(IReadOperation`1<TResult> operation, IChannelSourceHandle channelSource, ReadPreference readPreference, ICoreSessionHandle session, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static TResult Execute(IWriteOperation`1<TResult> operation, IChannelSourceHandle channelSource, ICoreSessionHandle session, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MongoDB.Driver.Core.Operations.OperationExtensionMethods/<ExecuteAsync>d__2`1")]
[ExtensionAttribute]
public static Task`1<TResult> ExecuteAsync(IReadOperation`1<TResult> operation, IChannelSourceHandle channelSource, ReadPreference readPreference, ICoreSessionHandle session, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MongoDB.Driver.Core.Operations.OperationExtensionMethods/<ExecuteAsync>d__3`1")]
[ExtensionAttribute]
public static Task`1<TResult> ExecuteAsync(IWriteOperation`1<TResult> operation, IChannelSourceHandle channelSource, ICoreSessionHandle session, CancellationToken cancellationToken);
}
public class MongoDB.Driver.Core.Operations.ParallelScanOperation`1 : object {
    private Nullable`1<int> _batchSize;
    private CollectionNamespace _collectionNamespace;
    private MessageEncoderSettings _messageEncoderSettings;
    private int _numberOfCursors;
    private ReadConcern _readConcern;
    private IBsonSerializer`1<TDocument> _serializer;
    public Nullable`1<int> BatchSize { get; public set; }
    public CollectionNamespace CollectionNamespace { get; }
    public MessageEncoderSettings MessageEncoderSettings { get; }
    public int NumberOfCursors { get; }
    public ReadConcern ReadConcern { get; public set; }
    public IBsonSerializer`1<TDocument> Serializer { get; }
    [ObsoleteAttribute("ParallelScanOperation was deprecated in server version 4.1.")]
public ParallelScanOperation`1(CollectionNamespace collectionNamespace, int numberOfCursors, IBsonSerializer`1<TDocument> serializer, MessageEncoderSettings messageEncoderSettings);
    public Nullable`1<int> get_BatchSize();
    public void set_BatchSize(Nullable`1<int> value);
    public CollectionNamespace get_CollectionNamespace();
    public MessageEncoderSettings get_MessageEncoderSettings();
    public int get_NumberOfCursors();
    public ReadConcern get_ReadConcern();
    public void set_ReadConcern(ReadConcern value);
    public IBsonSerializer`1<TDocument> get_Serializer();
    internal BsonDocument CreateCommand(ConnectionDescription connectionDescription, ICoreSession session);
    private ReadCommandOperation`1<BsonDocument> CreateOperation(IChannel channel, IBinding binding);
    private IReadOnlyList`1<IAsyncCursor`1<TDocument>> CreateCursors(IChannelSourceHandle channelSource, BsonDocument result);
    public sealed virtual IReadOnlyList`1<IAsyncCursor`1<TDocument>> Execute(IReadBinding binding, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MongoDB.Driver.Core.Operations.ParallelScanOperation`1/<ExecuteAsync>d__25")]
public sealed virtual Task`1<IReadOnlyList`1<IAsyncCursor`1<TDocument>>> ExecuteAsync(IReadBinding binding, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
private TDocument <CreateCursors>b__23_1(BsonValue v);
}
public class MongoDB.Driver.Core.Operations.PingOperation : object {
    private MessageEncoderSettings _messageEncoderSettings;
    public MessageEncoderSettings MessageEncoderSettings { get; }
    public PingOperation(MessageEncoderSettings messageEncoderSettings);
    public MessageEncoderSettings get_MessageEncoderSettings();
    internal BsonDocument CreateCommand();
    private ReadCommandOperation`1<BsonDocument> CreateOperation();
    public sealed virtual BsonDocument Execute(IReadBinding binding, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MongoDB.Driver.Core.Operations.PingOperation/<ExecuteAsync>d__7")]
public sealed virtual Task`1<BsonDocument> ExecuteAsync(IReadBinding binding, CancellationToken cancellationToken);
}
internal static class MongoDB.Driver.Core.Operations.QueryHelper : object {
    public static int CalculateFirstBatchSize(Nullable`1<int> limit, Nullable`1<int> batchSize);
    public static BsonDocument CreateReadPreferenceDocument(ServerType serverType, ReadPreference readPreference, Boolean& secondaryOk);
    public static BsonDocument CreateReadPreferenceDocument(ReadPreference readPreference);
}
public class MongoDB.Driver.Core.Operations.ReadCommandOperation`1 : CommandOperationBase`1<TCommandResult> {
    private bool _retryRequested;
    public bool RetryRequested { get; public set; }
    public ReadCommandOperation`1(DatabaseNamespace databaseNamespace, BsonDocument command, IBsonSerializer`1<TCommandResult> resultSerializer, MessageEncoderSettings messageEncoderSettings);
    public bool get_RetryRequested();
    public void set_RetryRequested(bool value);
    public sealed virtual TCommandResult Execute(IReadBinding binding, CancellationToken cancellationToken);
    public sealed virtual TCommandResult Execute(RetryableReadContext context, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MongoDB.Driver.Core.Operations.ReadCommandOperation`1/<ExecuteAsync>d__7")]
public sealed virtual Task`1<TCommandResult> ExecuteAsync(IReadBinding binding, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MongoDB.Driver.Core.Operations.ReadCommandOperation`1/<ExecuteAsync>d__8")]
public sealed virtual Task`1<TCommandResult> ExecuteAsync(RetryableReadContext context, CancellationToken cancellationToken);
    public sealed virtual TCommandResult ExecuteAttempt(RetryableReadContext context, int attempt, Nullable`1<long> transactionNumber, CancellationToken cancellationToken);
    public sealed virtual Task`1<TCommandResult> ExecuteAttemptAsync(RetryableReadContext context, int attempt, Nullable`1<long> transactionNumber, CancellationToken cancellationToken);
}
internal static class MongoDB.Driver.Core.Operations.ReadConcernHelper : object {
    public static BsonDocument GetReadConcernForCommand(ICoreSession session, ConnectionDescription connectionDescription, ReadConcern readConcern);
    public static BsonDocument GetReadConcernForFirstCommandInTransaction(ICoreSession session, ConnectionDescription connectionDescription);
    public static BsonDocument GetReadConcernForSnapshotSession(ICoreSession session, ConnectionDescription connectionDescription);
    private static BsonDocument ToBsonDocument(ICoreSession session, ConnectionDescription connectionDescription, ReadConcern readConcern);
    private static bool AreSessionsSupported(ConnectionDescription connectionDescription);
}
[ObsoleteAttribute("This class will be removed in a later version of the driver.")]
public class MongoDB.Driver.Core.Operations.ReIndexOperation : object {
    private CollectionNamespace _collectionNamespace;
    private MessageEncoderSettings _messageEncoderSettings;
    private WriteConcern _writeConcern;
    public CollectionNamespace CollectionNamespace { get; }
    public MessageEncoderSettings MessageEncoderSettings { get; }
    public WriteConcern WriteConcern { get; public set; }
    public ReIndexOperation(CollectionNamespace collectionNamespace, MessageEncoderSettings messageEncoderSettings);
    public CollectionNamespace get_CollectionNamespace();
    public MessageEncoderSettings get_MessageEncoderSettings();
    public WriteConcern get_WriteConcern();
    public void set_WriteConcern(WriteConcern value);
    public sealed virtual BsonDocument Execute(IWriteBinding binding, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MongoDB.Driver.Core.Operations.ReIndexOperation/<ExecuteAsync>d__12")]
public sealed virtual Task`1<BsonDocument> ExecuteAsync(IWriteBinding binding, CancellationToken cancellationToken);
    internal BsonDocument CreateCommand();
    private WriteCommandOperation`1<BsonDocument> CreateOperation();
}
public class MongoDB.Driver.Core.Operations.RenameCollectionOperation : object {
    private CollectionNamespace _collectionNamespace;
    private Nullable`1<bool> _dropTarget;
    private MessageEncoderSettings _messageEncoderSettings;
    private CollectionNamespace _newCollectionNamespace;
    private WriteConcern _writeConcern;
    public CollectionNamespace CollectionNamespace { get; }
    public Nullable`1<bool> DropTarget { get; public set; }
    public MessageEncoderSettings MessageEncoderSettings { get; }
    public CollectionNamespace NewCollectionNamespace { get; }
    public WriteConcern WriteConcern { get; public set; }
    public RenameCollectionOperation(CollectionNamespace collectionNamespace, CollectionNamespace newCollectionNamespace, MessageEncoderSettings messageEncoderSettings);
    public CollectionNamespace get_CollectionNamespace();
    public Nullable`1<bool> get_DropTarget();
    public void set_DropTarget(Nullable`1<bool> value);
    public MessageEncoderSettings get_MessageEncoderSettings();
    public CollectionNamespace get_NewCollectionNamespace();
    public WriteConcern get_WriteConcern();
    public void set_WriteConcern(WriteConcern value);
    internal BsonDocument CreateCommand(ICoreSessionHandle session, ConnectionDescription connectionDescription);
    private IDisposable BeginOperation();
    private WriteCommandOperation`1<BsonDocument> CreateOperation(ICoreSessionHandle session, ConnectionDescription connectionDescription);
    public sealed virtual BsonDocument Execute(IWriteBinding binding, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MongoDB.Driver.Core.Operations.RenameCollectionOperation/<ExecuteAsync>d__22")]
public sealed virtual Task`1<BsonDocument> ExecuteAsync(IWriteBinding binding, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
private BsonValue <CreateCommand>b__18_0();
}
internal static class MongoDB.Driver.Core.Operations.RetryabilityHelper : object {
    private static string ResumableChangeStreamErrorLabel;
    private static string RetryableWriteErrorLabel;
    private static HashSet`1<ServerErrorCode> __resumableChangeStreamErrorCodes;
    private static HashSet`1<Type> __resumableChangeStreamExceptions;
    private static HashSet`1<Type> __retryableReadExceptions;
    private static HashSet`1<Type> __retryableWriteExceptions;
    private static HashSet`1<ServerErrorCode> __retryableReadErrorCodes;
    private static HashSet`1<ServerErrorCode> __retryableWriteErrorCodes;
    private static HashSet`1<string> __saslCommands;
    private static RetryabilityHelper();
    public static void AddRetryableWriteErrorLabelIfRequired(MongoException exception, ConnectionDescription connectionDescription);
    public static bool IsCommandRetryable(BsonDocument command);
    public static bool IsResumableChangeStreamException(Exception exception, int maxWireVersion);
    public static bool IsReauthenticationRequested(MongoCommandException mongoCommandException, BsonDocument command);
    public static bool IsRetryableReadException(Exception exception);
    public static bool IsRetryableWriteException(Exception exception);
    private static bool IsNetworkException(Exception exception);
    private static bool ShouldRetryableWriteExceptionLabelBeAdded(Exception exception, ConnectionDescription connectionDescription);
}
public class MongoDB.Driver.Core.Operations.RetryableDeleteCommandOperation : RetryableWriteCommandOperationBase {
    private CollectionNamespace _collectionNamespace;
    private BatchableSource`1<DeleteRequest> _deletes;
    private BsonDocument _let;
    public BsonDocument Let { get; public set; }
    public CollectionNamespace CollectionNamespace { get; }
    public BatchableSource`1<DeleteRequest> Deletes { get; }
    public RetryableDeleteCommandOperation(CollectionNamespace collectionNamespace, BatchableSource`1<DeleteRequest> deletes, MessageEncoderSettings messageEncoderSettings);
    public BsonDocument get_Let();
    public void set_Let(BsonDocument value);
    public CollectionNamespace get_CollectionNamespace();
    public BatchableSource`1<DeleteRequest> get_Deletes();
    protected virtual BsonDocument CreateCommand(ICoreSessionHandle session, int attempt, Nullable`1<long> transactionNumber);
    protected virtual IEnumerable`1<Type1CommandMessageSection> CreateCommandPayloads(IChannelHandle channel, int attempt);
}
public class MongoDB.Driver.Core.Operations.RetryableInsertCommandOperation`1 : RetryableWriteCommandOperationBase {
    private Nullable`1<bool> _bypassDocumentValidation;
    private CollectionNamespace _collectionNamespace;
    private BatchableSource`1<TDocument> _documents;
    private IBsonSerializer`1<TDocument> _documentSerializer;
    public Nullable`1<bool> BypassDocumentValidation { get; public set; }
    public CollectionNamespace CollectionNamespace { get; }
    public BatchableSource`1<TDocument> Documents { get; }
    public IBsonSerializer`1<TDocument> DocumentSerializer { get; }
    public RetryableInsertCommandOperation`1(CollectionNamespace collectionNamespace, BatchableSource`1<TDocument> documents, IBsonSerializer`1<TDocument> documentSerializer, MessageEncoderSettings messageEncoderSettings);
    public Nullable`1<bool> get_BypassDocumentValidation();
    public void set_BypassDocumentValidation(Nullable`1<bool> value);
    public CollectionNamespace get_CollectionNamespace();
    public BatchableSource`1<TDocument> get_Documents();
    public IBsonSerializer`1<TDocument> get_DocumentSerializer();
    protected virtual BsonDocument CreateCommand(ICoreSessionHandle session, int attempt, Nullable`1<long> transactionNumber);
    protected virtual IEnumerable`1<Type1CommandMessageSection> CreateCommandPayloads(IChannelHandle channel, int attempt);
}
public class MongoDB.Driver.Core.Operations.RetryableReadContext : object {
    private IReadBinding _binding;
    private IChannelHandle _channel;
    private IChannelSourceHandle _channelSource;
    private bool _disposed;
    private bool _retryRequested;
    public IReadBinding Binding { get; }
    public IChannelHandle Channel { get; }
    public IChannelSourceHandle ChannelSource { get; }
    public bool RetryRequested { get; }
    public RetryableReadContext(IReadBinding binding, bool retryRequested);
    public static RetryableReadContext Create(IReadBinding binding, bool retryRequested, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MongoDB.Driver.Core.Operations.RetryableReadContext/<CreateAsync>d__1")]
public static Task`1<RetryableReadContext> CreateAsync(IReadBinding binding, bool retryRequested, CancellationToken cancellationToken);
    public IReadBinding get_Binding();
    public IChannelHandle get_Channel();
    public IChannelSourceHandle get_ChannelSource();
    public bool get_RetryRequested();
    public sealed virtual void Dispose();
    public void ReplaceChannel(IChannelHandle channel);
    public void ReplaceChannelSource(IChannelSourceHandle channelSource);
    private void Initialize(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MongoDB.Driver.Core.Operations.RetryableReadContext/<InitializeAsync>d__20")]
private Task InitializeAsync(CancellationToken cancellationToken);
}
internal static class MongoDB.Driver.Core.Operations.RetryableReadOperationExecutor : object {
    public static TResult Execute(IRetryableReadOperation`1<TResult> operation, IReadBinding binding, bool retryRequested, CancellationToken cancellationToken);
    public static TResult Execute(IRetryableReadOperation`1<TResult> operation, RetryableReadContext context, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MongoDB.Driver.Core.Operations.RetryableReadOperationExecutor/<ExecuteAsync>d__2`1")]
public static Task`1<TResult> ExecuteAsync(IRetryableReadOperation`1<TResult> operation, IReadBinding binding, bool retryRequested, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MongoDB.Driver.Core.Operations.RetryableReadOperationExecutor/<ExecuteAsync>d__3`1")]
public static Task`1<TResult> ExecuteAsync(IRetryableReadOperation`1<TResult> operation, RetryableReadContext context, CancellationToken cancellationToken);
    public static bool ShouldConnectionAcquireBeRetried(RetryableReadContext context, Exception ex);
    private static bool ShouldReadBeRetried(RetryableReadContext context);
    private static bool ShouldThrowOriginalException(Exception retryException);
}
public class MongoDB.Driver.Core.Operations.RetryableUpdateCommandOperation : RetryableWriteCommandOperationBase {
    private Nullable`1<bool> _bypassDocumentValidation;
    private CollectionNamespace _collectionNamespace;
    private BsonDocument _let;
    private BatchableSource`1<UpdateRequest> _updates;
    public Nullable`1<bool> BypassDocumentValidation { get; public set; }
    public CollectionNamespace CollectionNamespace { get; }
    public BsonDocument Let { get; public set; }
    public BatchableSource`1<UpdateRequest> Updates { get; }
    public RetryableUpdateCommandOperation(CollectionNamespace collectionNamespace, BatchableSource`1<UpdateRequest> updates, MessageEncoderSettings messageEncoderSettings);
    public Nullable`1<bool> get_BypassDocumentValidation();
    public void set_BypassDocumentValidation(Nullable`1<bool> value);
    public CollectionNamespace get_CollectionNamespace();
    public BsonDocument get_Let();
    public void set_Let(BsonDocument value);
    public BatchableSource`1<UpdateRequest> get_Updates();
    protected virtual BsonDocument CreateCommand(ICoreSessionHandle session, int attempt, Nullable`1<long> transactionNumber);
    protected virtual IEnumerable`1<Type1CommandMessageSection> CreateCommandPayloads(IChannelHandle channel, int attempt);
}
public abstract class MongoDB.Driver.Core.Operations.RetryableWriteCommandOperationBase : object {
    private BsonValue _comment;
    private DatabaseNamespace _databaseNamespace;
    private bool _isOrdered;
    private Nullable`1<int> _maxBatchCount;
    private MessageEncoderSettings _messageEncoderSettings;
    private bool _retryRequested;
    private WriteConcern _writeConcern;
    public BsonValue Comment { get; public set; }
    public DatabaseNamespace DatabaseNamespace { get; }
    public bool IsOrdered { get; public set; }
    public Nullable`1<int> MaxBatchCount { get; public set; }
    public MessageEncoderSettings MessageEncoderSettings { get; }
    public bool RetryRequested { get; public set; }
    public WriteConcern WriteConcern { get; public set; }
    public RetryableWriteCommandOperationBase(DatabaseNamespace databaseNamespace, MessageEncoderSettings messageEncoderSettings);
    public BsonValue get_Comment();
    public void set_Comment(BsonValue value);
    public DatabaseNamespace get_DatabaseNamespace();
    public bool get_IsOrdered();
    public void set_IsOrdered(bool value);
    public Nullable`1<int> get_MaxBatchCount();
    public void set_MaxBatchCount(Nullable`1<int> value);
    public MessageEncoderSettings get_MessageEncoderSettings();
    public bool get_RetryRequested();
    public void set_RetryRequested(bool value);
    public sealed virtual WriteConcern get_WriteConcern();
    public void set_WriteConcern(WriteConcern value);
    public virtual BsonDocument Execute(IWriteBinding binding, CancellationToken cancellationToken);
    public virtual BsonDocument Execute(RetryableWriteContext context, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MongoDB.Driver.Core.Operations.RetryableWriteCommandOperationBase/<ExecuteAsync>d__29")]
public virtual Task`1<BsonDocument> ExecuteAsync(IWriteBinding binding, CancellationToken cancellationToken);
    public virtual Task`1<BsonDocument> ExecuteAsync(RetryableWriteContext context, CancellationToken cancellationToken);
    public sealed virtual BsonDocument ExecuteAttempt(RetryableWriteContext context, int attempt, Nullable`1<long> transactionNumber, CancellationToken cancellationToken);
    public sealed virtual Task`1<BsonDocument> ExecuteAttemptAsync(RetryableWriteContext context, int attempt, Nullable`1<long> transactionNumber, CancellationToken cancellationToken);
    protected abstract virtual BsonDocument CreateCommand(ICoreSessionHandle session, int attempt, Nullable`1<long> transactionNumber);
    protected abstract virtual IEnumerable`1<Type1CommandMessageSection> CreateCommandPayloads(IChannelHandle channel, int attempt);
    private MessageEncoderSettings CreateMessageEncoderSettings(IChannelHandle channel);
    private CommandArgs GetCommandArgs(RetryableWriteContext context, int attempt, Nullable`1<long> transactionNumber);
    private Action`1<IMessageEncoderPostProcessor> GetPostWriteAction(List`1<Type1CommandMessageSection> commandPayloads);
    private CommandResponseHandling GetResponseHandling();
}
public class MongoDB.Driver.Core.Operations.RetryableWriteContext : object {
    private IWriteBinding _binding;
    private IChannelHandle _channel;
    private IChannelSourceHandle _channelSource;
    private bool _disposed;
    private bool _retryRequested;
    public IWriteBinding Binding { get; }
    public IChannelHandle Channel { get; }
    public IChannelSourceHandle ChannelSource { get; }
    public bool RetryRequested { get; }
    public RetryableWriteContext(IWriteBinding binding, bool retryRequested);
    public static RetryableWriteContext Create(IWriteBinding binding, bool retryRequested, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MongoDB.Driver.Core.Operations.RetryableWriteContext/<CreateAsync>d__1")]
public static Task`1<RetryableWriteContext> CreateAsync(IWriteBinding binding, bool retryRequested, CancellationToken cancellationToken);
    public IWriteBinding get_Binding();
    public IChannelHandle get_Channel();
    public IChannelSourceHandle get_ChannelSource();
    public bool get_RetryRequested();
    public void DisableRetriesIfAnyWriteRequestIsNotRetryable(IEnumerable`1<WriteRequest> requests);
    public sealed virtual void Dispose();
    public void ReplaceChannel(IChannelHandle channel);
    public void ReplaceChannelSource(IChannelSourceHandle channelSource);
    private void Initialize(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MongoDB.Driver.Core.Operations.RetryableWriteContext/<InitializeAsync>d__21")]
private Task InitializeAsync(CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
private bool <DisableRetriesIfAnyWriteRequestIsNotRetryable>b__16_0(WriteRequest r);
}
internal static class MongoDB.Driver.Core.Operations.RetryableWriteOperationExecutor : object {
    public static TResult Execute(IRetryableWriteOperation`1<TResult> operation, IWriteBinding binding, bool retryRequested, CancellationToken cancellationToken);
    public static TResult Execute(IRetryableWriteOperation`1<TResult> operation, RetryableWriteContext context, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MongoDB.Driver.Core.Operations.RetryableWriteOperationExecutor/<ExecuteAsync>d__2`1")]
public static Task`1<TResult> ExecuteAsync(IRetryableWriteOperation`1<TResult> operation, IWriteBinding binding, bool retryRequested, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MongoDB.Driver.Core.Operations.RetryableWriteOperationExecutor/<ExecuteAsync>d__3`1")]
public static Task`1<TResult> ExecuteAsync(IRetryableWriteOperation`1<TResult> operation, RetryableWriteContext context, CancellationToken cancellationToken);
    public static bool ShouldConnectionAcquireBeRetried(RetryableWriteContext context, ServerDescription serverDescription, Exception exception);
    private static bool AreRetriesAllowed(IRetryableWriteOperation`1<TResult> operation, RetryableWriteContext context);
    private static bool AreRetryableWritesSupported(ConnectionDescription connectionDescription);
    private static bool AreRetryableWritesSupported(ServerDescription serverDescription);
    private static bool DoesContextAllowRetries(RetryableWriteContext context);
    private static bool IsOperationAcknowledged(IRetryableWriteOperation`1<TResult> operation);
    private static bool ShouldThrowOriginalException(Exception retryException);
}
public enum MongoDB.Driver.Core.Operations.ReturnDocument : Enum {
    public int value__;
    public static ReturnDocument Before;
    public static ReturnDocument After;
}
public class MongoDB.Driver.Core.Operations.UpdateOpcodeOperation : object {
    private Nullable`1<bool> _bypassDocumentValidation;
    private CollectionNamespace _collectionNamespace;
    private Nullable`1<int> _maxDocumentSize;
    private MessageEncoderSettings _messageEncoderSettings;
    private UpdateRequest _request;
    private bool _retryRequested;
    private WriteConcern _writeConcern;
    public Nullable`1<bool> BypassDocumentValidation { get; public set; }
    public CollectionNamespace CollectionNamespace { get; }
    public Nullable`1<int> MaxDocumentSize { get; public set; }
    public MessageEncoderSettings MessageEncoderSettings { get; }
    public UpdateRequest Request { get; }
    public bool RetryRequested { get; public set; }
    public WriteConcern WriteConcern { get; public set; }
    public UpdateOpcodeOperation(CollectionNamespace collectionNamespace, UpdateRequest request, MessageEncoderSettings messageEncoderSettings);
    public Nullable`1<bool> get_BypassDocumentValidation();
    public void set_BypassDocumentValidation(Nullable`1<bool> value);
    public CollectionNamespace get_CollectionNamespace();
    public Nullable`1<int> get_MaxDocumentSize();
    public void set_MaxDocumentSize(Nullable`1<int> value);
    public MessageEncoderSettings get_MessageEncoderSettings();
    public UpdateRequest get_Request();
    public bool get_RetryRequested();
    public void set_RetryRequested(bool value);
    public WriteConcern get_WriteConcern();
    public void set_WriteConcern(WriteConcern value);
    public sealed virtual WriteConcernResult Execute(IWriteBinding binding, CancellationToken cancellationToken);
    public sealed virtual WriteConcernResult Execute(RetryableWriteContext context, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MongoDB.Driver.Core.Operations.UpdateOpcodeOperation/<ExecuteAsync>d__28")]
public sealed virtual Task`1<WriteConcernResult> ExecuteAsync(IWriteBinding binding, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MongoDB.Driver.Core.Operations.UpdateOpcodeOperation/<ExecuteAsync>d__29")]
public sealed virtual Task`1<WriteConcernResult> ExecuteAsync(RetryableWriteContext context, CancellationToken cancellationToken);
    private UpdateOpcodeOperationEmulator CreateEmulator();
}
internal class MongoDB.Driver.Core.Operations.UpdateOpcodeOperationEmulator : object {
    private Nullable`1<bool> _bypassDocumentValidation;
    private CollectionNamespace _collectionNamespace;
    private Nullable`1<int> _maxDocumentSize;
    private MessageEncoderSettings _messageEncoderSettings;
    private UpdateRequest _request;
    private bool _retryRequested;
    private WriteConcern _writeConcern;
    public Nullable`1<bool> BypassDocumentValidation { get; public set; }
    public CollectionNamespace CollectionNamespace { get; }
    public Nullable`1<int> MaxDocumentSize { get; public set; }
    public MessageEncoderSettings MessageEncoderSettings { get; }
    public UpdateRequest Request { get; }
    public bool RetryRequested { get; public set; }
    public WriteConcern WriteConcern { get; public set; }
    public UpdateOpcodeOperationEmulator(CollectionNamespace collectionNamespace, UpdateRequest request, MessageEncoderSettings messageEncoderSettings);
    public Nullable`1<bool> get_BypassDocumentValidation();
    public void set_BypassDocumentValidation(Nullable`1<bool> value);
    public CollectionNamespace get_CollectionNamespace();
    public Nullable`1<int> get_MaxDocumentSize();
    public void set_MaxDocumentSize(Nullable`1<int> value);
    public MessageEncoderSettings get_MessageEncoderSettings();
    public UpdateRequest get_Request();
    public bool get_RetryRequested();
    public void set_RetryRequested(bool value);
    public WriteConcern get_WriteConcern();
    public void set_WriteConcern(WriteConcern value);
    public sealed virtual WriteConcernResult Execute(RetryableWriteContext context, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MongoDB.Driver.Core.Operations.UpdateOpcodeOperationEmulator/<ExecuteAsync>d__27")]
public sealed virtual Task`1<WriteConcernResult> ExecuteAsync(RetryableWriteContext context, CancellationToken cancellationToken);
    private BulkUpdateOperation CreateOperation();
    private WriteConcernResult CreateResultOrThrow(IChannelHandle channel, BulkWriteOperationResult result, MongoBulkWriteOperationException exception);
}
public class MongoDB.Driver.Core.Operations.UpdateRequest : WriteRequest {
    private IEnumerable`1<BsonDocument> _arrayFilters;
    private Collation _collation;
    private BsonDocument _filter;
    private BsonValue _hint;
    private bool _isMulti;
    private bool _isUpsert;
    private BsonValue _update;
    private UpdateType _updateType;
    public IEnumerable`1<BsonDocument> ArrayFilters { get; public set; }
    public Collation Collation { get; public set; }
    public BsonDocument Filter { get; }
    public BsonValue Hint { get; public set; }
    public bool IsMulti { get; public set; }
    public bool IsUpsert { get; public set; }
    public BsonValue Update { get; }
    public UpdateType UpdateType { get; }
    public UpdateRequest(UpdateType updateType, BsonDocument filter, BsonValue update);
    public IEnumerable`1<BsonDocument> get_ArrayFilters();
    public void set_ArrayFilters(IEnumerable`1<BsonDocument> value);
    public Collation get_Collation();
    public void set_Collation(Collation value);
    public BsonDocument get_Filter();
    public BsonValue get_Hint();
    public void set_Hint(BsonValue value);
    public bool get_IsMulti();
    public void set_IsMulti(bool value);
    public bool get_IsUpsert();
    public void set_IsUpsert(bool value);
    public BsonValue get_Update();
    public UpdateType get_UpdateType();
    public virtual bool IsRetryable(ConnectionDescription connectionDescription);
    private BsonValue EnsureUpdateIsValid(BsonValue update, UpdateType updateType);
}
internal class MongoDB.Driver.Core.Operations.UpdateSearchIndexOperation : object {
    private CollectionNamespace _collectionNamespace;
    private MessageEncoderSettings _messageEncoderSettings;
    private string _indexName;
    private BsonDocument _defintion;
    public UpdateSearchIndexOperation(CollectionNamespace collectionNamespace, string indexName, BsonDocument defintion, MessageEncoderSettings messageEncoderSettings);
    public sealed virtual BsonDocument Execute(IWriteBinding binding, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MongoDB.Driver.Core.Operations.UpdateSearchIndexOperation/<ExecuteAsync>d__6")]
public sealed virtual Task`1<BsonDocument> ExecuteAsync(IWriteBinding binding, CancellationToken cancellationToken);
    private WriteCommandOperation`1<BsonDocument> CreateOperation();
}
public enum MongoDB.Driver.Core.Operations.UpdateType : Enum {
    public int value__;
    public static UpdateType Unknown;
    public static UpdateType Update;
    public static UpdateType Replacement;
}
public class MongoDB.Driver.Core.Operations.WriteCommandOperation`1 : CommandOperationBase`1<TCommandResult> {
    private ReadPreference _readPreference;
    public ReadPreference ReadPreference { get; public set; }
    public WriteCommandOperation`1(DatabaseNamespace databaseNamespace, BsonDocument command, IBsonSerializer`1<TCommandResult> resultSerializer, MessageEncoderSettings messageEncoderSettings);
    public ReadPreference get_ReadPreference();
    public void set_ReadPreference(ReadPreference value);
    public sealed virtual TCommandResult Execute(IWriteBinding binding, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MongoDB.Driver.Core.Operations.WriteCommandOperation`1/<ExecuteAsync>d__6")]
public sealed virtual Task`1<TCommandResult> ExecuteAsync(IWriteBinding binding, CancellationToken cancellationToken);
}
internal static class MongoDB.Driver.Core.Operations.WriteConcernHelper : object {
    public static BsonDocument GetEffectiveWriteConcern(ICoreSession session, WriteConcern writeConcern);
}
public abstract class MongoDB.Driver.Core.Operations.WriteRequest : object {
    private Nullable`1<int> _correlationId;
    private WriteRequestType _requestType;
    public Nullable`1<int> CorrelationId { get; public set; }
    public WriteRequestType RequestType { get; }
    protected WriteRequest(WriteRequestType requestType);
    public Nullable`1<int> get_CorrelationId();
    public void set_CorrelationId(Nullable`1<int> value);
    public WriteRequestType get_RequestType();
    public abstract virtual bool IsRetryable(ConnectionDescription connectionDescription);
}
public enum MongoDB.Driver.Core.Operations.WriteRequestType : Enum {
    public int value__;
    public static WriteRequestType Delete;
    public static WriteRequestType Insert;
    public static WriteRequestType Update;
}
internal class MongoDB.Driver.Core.Servers.ClusterClockAdvancingCoreSession : WrappingCoreSession {
    private IClusterClock _clusterClock;
    public BsonDocument ClusterTime { get; }
    public ClusterClockAdvancingCoreSession(ICoreSession wrapped, IClusterClock clusterClock);
    public virtual BsonDocument get_ClusterTime();
    public virtual void AdvanceClusterTime(BsonDocument newClusterTime);
}
internal class MongoDB.Driver.Core.Servers.DefaultServer : Server {
    private static List`1<Type> __invalidatingExceptions;
    private ServerDescription _baseDescription;
    private ServerDescription modreq(System.Runtime.CompilerServices.IsVolatile) _currentDescription;
    private IServerMonitor _monitor;
    public ServerDescription Description { get; }
    public DefaultServer(ClusterId clusterId, IClusterClock clusterClock, ClusterConnectionMode clusterConnectionMode, ConnectionModeSwitch connectionModeSwitch, Nullable`1<bool> directConnection, ServerSettings settings, EndPoint endPoint, IConnectionPoolFactory connectionPoolFactory, IServerMonitorFactory monitorFactory, ServerApi serverApi, EventLogger`1<SDAM> eventLogger);
    private static DefaultServer();
    public virtual ServerDescription get_Description();
    public virtual void RequestHeartbeat();
    protected virtual void Dispose(bool disposing);
    protected virtual void HandleBeforeHandshakeCompletesException(Exception ex);
    protected virtual void HandleAfterHandshakeCompletesException(IConnection connection, Exception ex);
    protected virtual void InitializeSubClass();
    protected virtual void Invalidate(string reasonInvalidated, bool clearConnectionPool, TopologyVersion topologyVersion);
    private void OnMonitorDescriptionChanged(object sender, ServerDescriptionChangedEventArgs e);
    private void SetDescription(ServerDescription newDescription, bool forceClearConnectionPool);
    private bool ShouldInvalidateServer(IConnection connection, Exception exception, ServerDescription description, TopologyVersion& invalidatingResponseTopologyVersion);
    [CompilerGeneratedAttribute]
private bool <ShouldInvalidateServer>g__IsStaleStateChangeError|15_0(BsonDocument response, TopologyVersion& nonStaleResponseTopologyVersion, <>c__DisplayClass15_0& );
}
internal class MongoDB.Driver.Core.Servers.HeartbeatDelay : object {
    private DateTime _earlyHeartbeatAt;
    private int _earlyHeartbeatHasBeenRequested;
    private TaskCompletionSource`1<bool> _taskCompletionSource;
    private Timer _timer;
    public Task Task { get; }
    public HeartbeatDelay(TimeSpan heartbeatInterval, TimeSpan minHeartbeatInterval);
    public Task get_Task();
    public sealed virtual void Dispose();
    public void RequestHeartbeat();
    public void Wait(CancellationToken cancellationToken);
    private void TimerCallback(object state);
}
public interface MongoDB.Driver.Core.Servers.IClusterableServer {
    public bool IsInitialized { get; }
    public int OutstandingOperationsCount { get; }
    public abstract virtual bool get_IsInitialized();
    public abstract virtual void Initialize();
    [ObsoleteAttribute("Use Invalidate with TopologyVersion instead.")]
public abstract virtual void Invalidate(string reasonInvalidated);
    public abstract virtual void Invalidate(string reasonInvalidated, TopologyVersion responseTopologyVersion);
    public abstract virtual void RequestHeartbeat();
    public abstract virtual int get_OutstandingOperationsCount();
}
public interface MongoDB.Driver.Core.Servers.IClusterableServerFactory {
    public abstract virtual IClusterableServer CreateServer(ClusterType clusterType, ClusterId clusterId, IClusterClock clusterClock, EndPoint endPoint);
}
internal interface MongoDB.Driver.Core.Servers.IRoundTripTimeMonitor {
    public TimeSpan Average { get; }
    public bool IsStarted { get; }
    public abstract virtual TimeSpan get_Average();
    public abstract virtual bool get_IsStarted();
    public abstract virtual void AddSample(TimeSpan roundTripTime);
    public abstract virtual void Reset();
    public abstract virtual void Start();
}
public interface MongoDB.Driver.Core.Servers.IServer {
    public ServerDescription Description { get; }
    public EndPoint EndPoint { get; }
    public ServerId ServerId { get; }
    [CompilerGeneratedAttribute]
public abstract virtual void add_DescriptionChanged(EventHandler`1<ServerDescriptionChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_DescriptionChanged(EventHandler`1<ServerDescriptionChangedEventArgs> value);
    public abstract virtual ServerDescription get_Description();
    public abstract virtual EndPoint get_EndPoint();
    public abstract virtual ServerId get_ServerId();
    public abstract virtual IChannelHandle GetChannel(CancellationToken cancellationToken);
    public abstract virtual Task`1<IChannelHandle> GetChannelAsync(CancellationToken cancellationToken);
}
internal interface MongoDB.Driver.Core.Servers.IServerMonitor {
    public ServerDescription Description { get; }
    public object Lock { get; }
    public abstract virtual ServerDescription get_Description();
    public abstract virtual object get_Lock();
    public abstract virtual void CancelCurrentCheck();
    [CompilerGeneratedAttribute]
public abstract virtual void add_DescriptionChanged(EventHandler`1<ServerDescriptionChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_DescriptionChanged(EventHandler`1<ServerDescriptionChangedEventArgs> value);
    public abstract virtual void Initialize();
    public abstract virtual void RequestHeartbeat();
}
internal interface MongoDB.Driver.Core.Servers.IServerMonitorFactory {
    public abstract virtual IServerMonitor Create(ServerId serverId, EndPoint endPoint);
}
internal class MongoDB.Driver.Core.Servers.LoadBalancedServer : Server {
    private ServerDescription _baseDescription;
    private ServerDescription _currentDescription;
    private object _connectionPoolLock;
    public ServerDescription Description { get; }
    public LoadBalancedServer(ClusterId clusterId, IClusterClock clusterClock, ServerSettings serverSettings, EndPoint endPoint, IConnectionPoolFactory connectionPoolFactory, ServerApi serverApi, EventLogger`1<SDAM> eventLogger);
    public virtual ServerDescription get_Description();
    protected virtual void Dispose(bool disposing);
    protected virtual void HandleBeforeHandshakeCompletesException(Exception ex);
    protected virtual void HandleAfterHandshakeCompletesException(IConnection connection, Exception ex);
    protected virtual void InitializeSubClass();
    protected virtual void Invalidate(string reasonInvalidated, bool clearConnectionPool, TopologyVersion topologyVersion);
    public virtual void RequestHeartbeat();
}
internal class MongoDB.Driver.Core.Servers.RoundTripTimeMonitor : object {
    private ExponentiallyWeightedMovingAverage _averageRoundTripTimeCalculator;
    private CancellationToken _cancellationToken;
    private CancellationTokenSource _cancellationTokenSource;
    private IConnectionFactory _connectionFactory;
    private bool _disposed;
    private EndPoint _endPoint;
    private TimeSpan _heartbeatInterval;
    private object _lock;
    private IConnection _roundTripTimeConnection;
    private Thread _roundTripTimeMonitorThread;
    private ServerApi _serverApi;
    private ServerId _serverId;
    private ILogger`1<RoundTripTimeMonitor> _logger;
    public TimeSpan Average { get; }
    public bool IsStarted { get; }
    public RoundTripTimeMonitor(IConnectionFactory connectionFactory, ServerId serverId, EndPoint endpoint, TimeSpan heartbeatInterval, ServerApi serverApi, ILogger`1<RoundTripTimeMonitor> logger);
    public sealed virtual TimeSpan get_Average();
    public sealed virtual bool get_IsStarted();
    public sealed virtual void Dispose();
    public sealed virtual void Start();
    private void MonitorServer();
    private void InitializeConnection();
    public sealed virtual void AddSample(TimeSpan roundTripTime);
    public sealed virtual void Reset();
    [CompilerGeneratedAttribute]
private void <Start>g__ThreadStart|19_0();
}
internal abstract class MongoDB.Driver.Core.Servers.Server : object {
    private IClusterClock _clusterClock;
    private ClusterConnectionMode _clusterConnectionMode;
    private ConnectionModeSwitch _connectionModeSwitch;
    private IConnectionPool _connectionPool;
    private Nullable`1<bool> _directConnection;
    private EndPoint _endPoint;
    private ServerId _serverId;
    private ServerSettings _settings;
    private InterlockedInt32 _state;
    private ServerApi _serverApi;
    private EventLogger`1<SDAM> _eventLogger;
    private int _outstandingOperationsCount;
    [CompilerGeneratedAttribute]
private EventHandler`1<ServerDescriptionChangedEventArgs> DescriptionChanged;
    public IClusterClock ClusterClock { get; }
    public IConnectionPool ConnectionPool { get; }
    public ServerDescription Description { get; }
    public EndPoint EndPoint { get; }
    public bool IsInitialized { get; }
    public ServerId ServerId { get; }
    protected EventLogger`1<SDAM> EventLogger { get; }
    private int MongoDB.Driver.Core.Servers.IClusterableServer.OutstandingOperationsCount { get; }
    public Server(ClusterId clusterId, IClusterClock clusterClock, ClusterConnectionMode clusterConnectionMode, ConnectionModeSwitch connectionModeSwitch, Nullable`1<bool> directConnection, ServerSettings settings, EndPoint endPoint, IConnectionPoolFactory connectionPoolFactory, ServerApi serverApi, EventLogger`1<SDAM> eventLogger);
    [CompilerGeneratedAttribute]
public sealed virtual void add_DescriptionChanged(EventHandler`1<ServerDescriptionChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_DescriptionChanged(EventHandler`1<ServerDescriptionChangedEventArgs> value);
    public IClusterClock get_ClusterClock();
    public IConnectionPool get_ConnectionPool();
    public abstract virtual ServerDescription get_Description();
    public sealed virtual EndPoint get_EndPoint();
    public sealed virtual bool get_IsInitialized();
    public sealed virtual ServerId get_ServerId();
    protected EventLogger`1<SDAM> get_EventLogger();
    private sealed virtual override int MongoDB.Driver.Core.Servers.IClusterableServer.get_OutstandingOperationsCount();
    public sealed virtual void Dispose();
    public sealed virtual void HandleExceptionOnOpen(Exception exception);
    public sealed virtual IChannelHandle GetChannel(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MongoDB.Driver.Core.Servers.Server/<GetChannelAsync>d__35")]
public sealed virtual Task`1<IChannelHandle> GetChannelAsync(CancellationToken cancellationToken);
    public sealed virtual void Initialize();
    [ObsoleteAttribute("Use Invalidate with TopologyDescription instead.")]
public sealed virtual void Invalidate(string reasonInvalidated);
    public sealed virtual void Invalidate(string reasonInvalidated, TopologyVersion responseTopologyDescription);
    public abstract virtual void RequestHeartbeat();
    protected abstract virtual void Invalidate(string reasonInvalidated, bool clearConnectionPool, TopologyVersion responseTopologyDescription);
    protected abstract virtual void Dispose(bool disposing);
    protected abstract virtual void HandleBeforeHandshakeCompletesException(Exception ex);
    protected abstract virtual void HandleAfterHandshakeCompletesException(IConnection connection, Exception ex);
    protected abstract virtual void InitializeSubClass();
    protected bool IsDirectConnection();
    protected bool IsStateChangeException(Exception ex);
    protected bool IsShutdownException(Exception ex);
    protected void TriggerServerDescriptionChanged(object sender, ServerDescriptionChangedEventArgs e);
    protected bool ShouldClearConnectionPoolForChannelException(Exception ex, int maxWireVersion);
    private void HandleChannelException(IConnection connection, Exception ex);
    private bool IsOpen();
    private void ThrowIfDisposed();
    private void ThrowIfNotOpen();
    [CompilerGeneratedAttribute]
internal static bool <HandleChannelException>g__ShouldIgnoreException|50_0(Exception ex);
    [CompilerGeneratedAttribute]
internal static Exception <HandleChannelException>g__GetEffectiveException|50_1(Exception ex);
}
public class MongoDB.Driver.Core.Servers.ServerDescription : object {
    private TimeSpan _averageRoundTripTime;
    private EndPoint _canonicalEndPoint;
    private ElectionId _electionId;
    private EndPoint _endPoint;
    private Exception _heartbeatException;
    private TimeSpan _heartbeatInterval;
    private bool _helloOk;
    private Nullable`1<DateTime> _lastHeartbeatTimestamp;
    private DateTime _lastUpdateTimestamp;
    private Nullable`1<DateTime> _lastWriteTimestamp;
    private Nullable`1<TimeSpan> _logicalSessionTimeout;
    private int _maxBatchCount;
    private int _maxDocumentSize;
    private int _maxMessageSize;
    private int _maxWireDocumentSize;
    private string _reasonChanged;
    private ReplicaSetConfig _replicaSetConfig;
    private ServerId _serverId;
    private ServerState _state;
    private TagSet _tags;
    private TopologyVersion _topologyVersion;
    private ServerType _type;
    private SemanticVersion _version;
    private Range`1<int> _wireVersionRange;
    public TimeSpan AverageRoundTripTime { get; }
    public EndPoint CanonicalEndPoint { get; }
    public ElectionId ElectionId { get; }
    public EndPoint EndPoint { get; }
    public Exception HeartbeatException { get; }
    public TimeSpan HeartbeatInterval { get; }
    public bool HelloOk { get; }
    public bool IsCompatibleWithDriver { get; }
    public bool IsDataBearing { get; }
    public Nullable`1<DateTime> LastHeartbeatTimestamp { get; }
    public DateTime LastUpdateTimestamp { get; }
    public Nullable`1<DateTime> LastWriteTimestamp { get; }
    public Nullable`1<TimeSpan> LogicalSessionTimeout { get; }
    public int MaxBatchCount { get; }
    public int MaxDocumentSize { get; }
    public int MaxMessageSize { get; }
    public int MaxWireDocumentSize { get; }
    public int MaxWireVersion { get; }
    public string ReasonChanged { get; }
    public ReplicaSetConfig ReplicaSetConfig { get; }
    public ServerId ServerId { get; }
    public ServerState State { get; }
    public TagSet Tags { get; }
    public ServerType Type { get; }
    public TopologyVersion TopologyVersion { get; }
    [ObsoleteAttribute("This property will be removed in a later release.")]
public SemanticVersion Version { get; }
    public Range`1<int> WireVersionRange { get; }
    public ServerDescription(ServerId serverId, EndPoint endPoint, Optional`1<string> reasonChanged, Optional`1<TimeSpan> averageRoundTripTime, Optional`1<EndPoint> canonicalEndPoint, Optional`1<ElectionId> electionId, Optional`1<Exception> heartbeatException, Optional`1<TimeSpan> heartbeatInterval, Optional`1<bool> helloOk, Optional`1<Nullable`1<DateTime>> lastHeartbeatTimestamp, Optional`1<DateTime> lastUpdateTimestamp, Optional`1<Nullable`1<DateTime>> lastWriteTimestamp, Optional`1<Nullable`1<TimeSpan>> logicalSessionTimeout, Optional`1<int> maxBatchCount, Optional`1<int> maxDocumentSize, Optional`1<int> maxMessageSize, Optional`1<int> maxWireDocumentSize, Optional`1<ReplicaSetConfig> replicaSetConfig, Optional`1<ServerState> state, Optional`1<TagSet> tags, Optional`1<TopologyVersion> topologyVersion, Optional`1<ServerType> type, Optional`1<SemanticVersion> version, Optional`1<Range`1<int>> wireVersionRange);
    private static bool Equals(Exception x, Exception y);
    public TimeSpan get_AverageRoundTripTime();
    public EndPoint get_CanonicalEndPoint();
    public ElectionId get_ElectionId();
    public EndPoint get_EndPoint();
    public Exception get_HeartbeatException();
    public TimeSpan get_HeartbeatInterval();
    public bool get_HelloOk();
    public bool get_IsCompatibleWithDriver();
    public bool get_IsDataBearing();
    public Nullable`1<DateTime> get_LastHeartbeatTimestamp();
    public DateTime get_LastUpdateTimestamp();
    public Nullable`1<DateTime> get_LastWriteTimestamp();
    public Nullable`1<TimeSpan> get_LogicalSessionTimeout();
    public int get_MaxBatchCount();
    public int get_MaxDocumentSize();
    public int get_MaxMessageSize();
    public int get_MaxWireDocumentSize();
    public int get_MaxWireVersion();
    public string get_ReasonChanged();
    public ReplicaSetConfig get_ReplicaSetConfig();
    public ServerId get_ServerId();
    public ServerState get_State();
    public TagSet get_Tags();
    public ServerType get_Type();
    public TopologyVersion get_TopologyVersion();
    public SemanticVersion get_Version();
    public Range`1<int> get_WireVersionRange();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ServerDescription other);
    public virtual int GetHashCode();
    public bool SdamEquals(ServerDescription other);
    public virtual string ToString();
    public ServerDescription With(Optional`1<string> reasonChanged, Optional`1<TimeSpan> averageRoundTripTime, Optional`1<EndPoint> canonicalEndPoint, Optional`1<bool> helloOk, Optional`1<ElectionId> electionId, Optional`1<Exception> heartbeatException, Optional`1<TimeSpan> heartbeatInterval, Optional`1<Nullable`1<DateTime>> lastHeartbeatTimestamp, Optional`1<DateTime> lastUpdateTimestamp, Optional`1<Nullable`1<DateTime>> lastWriteTimestamp, Optional`1<Nullable`1<TimeSpan>> logicalSessionTimeout, Optional`1<int> maxBatchCount, Optional`1<int> maxDocumentSize, Optional`1<int> maxMessageSize, Optional`1<int> maxWireDocumentSize, Optional`1<ReplicaSetConfig> replicaSetConfig, Optional`1<ServerState> state, Optional`1<TagSet> tags, Optional`1<TopologyVersion> topologyVersion, Optional`1<ServerType> type, Optional`1<SemanticVersion> version, Optional`1<Range`1<int>> wireVersionRange);
    public ServerDescription WithHeartbeatException(Exception heartbeatException);
}
public class MongoDB.Driver.Core.Servers.ServerDescriptionChangedEventArgs : EventArgs {
    private ServerDescription _oldServerDescription;
    private ServerDescription _newServerDescription;
    public ServerDescription OldServerDescription { get; }
    public ServerDescription NewServerDescription { get; }
    public ServerDescriptionChangedEventArgs(ServerDescription oldServerDescription, ServerDescription newServerDescription);
    public ServerDescription get_OldServerDescription();
    public ServerDescription get_NewServerDescription();
}
internal class MongoDB.Driver.Core.Servers.ServerFactory : object {
    private ClusterConnectionMode _clusterConnectionMode;
    private ConnectionModeSwitch _connectionModeSwitch;
    private IConnectionPoolFactory _connectionPoolFactory;
    private Nullable`1<bool> _directConnection;
    private IServerMonitorFactory _serverMonitorFactory;
    private IEventSubscriber _eventSubscriber;
    private ServerApi _serverApi;
    private ServerSettings _settings;
    private ILoggerFactory _loggerFactory;
    public ServerFactory(ClusterConnectionMode clusterConnectionMode, ConnectionModeSwitch connectionModeSwitch, Nullable`1<bool> directConnection, ServerSettings settings, IConnectionPoolFactory connectionPoolFactory, IServerMonitorFactory serverMonitoryFactory, IEventSubscriber eventSubscriber, ServerApi serverApi, ILoggerFactory loggerFactory);
    public sealed virtual IClusterableServer CreateServer(ClusterType clusterType, ClusterId clusterId, IClusterClock clusterClock, EndPoint endPoint);
}
public class MongoDB.Driver.Core.Servers.ServerId : object {
    private ClusterId _clusterId;
    private EndPoint _endPoint;
    private int _hashCode;
    public ClusterId ClusterId { get; }
    public EndPoint EndPoint { get; }
    public ServerId(ClusterId clusterId, EndPoint endPoint);
    private ServerId(SerializationInfo info, StreamingContext context);
    public ClusterId get_ClusterId();
    public EndPoint get_EndPoint();
    public sealed virtual bool Equals(ServerId other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
}
internal class MongoDB.Driver.Core.Servers.ServerMonitor : object {
    private ServerDescription _baseDescription;
    private IConnection modreq(System.Runtime.CompilerServices.IsVolatile) _connection;
    private IConnectionFactory _connectionFactory;
    private CancellationTokenSource _heartbeatCancellationTokenSource;
    private ServerDescription _currentDescription;
    private EndPoint _endPoint;
    private HeartbeatDelay _heartbeatDelay;
    private bool _isStreamingEnabled;
    private object _lock;
    private IEnvironmentVariableProvider _environmentVariableProvider;
    private EventLogger`1<SDAM> _eventLoggerSdam;
    private ILogger`1<IServerMonitor> _logger;
    private CancellationToken _monitorCancellationToken;
    private CancellationTokenSource _monitorCancellationTokenSource;
    private IRoundTripTimeMonitor _roundTripTimeMonitor;
    private ServerApi _serverApi;
    private ServerId _serverId;
    private InterlockedInt32 _state;
    private ServerMonitorSettings _serverMonitorSettings;
    private Thread _serverMonitorThread;
    [CompilerGeneratedAttribute]
private EventHandler`1<ServerDescriptionChangedEventArgs> DescriptionChanged;
    public ServerDescription Description { get; }
    public object Lock { get; }
    public ServerMonitor(ServerId serverId, EndPoint endPoint, IConnectionFactory connectionFactory, ServerMonitorSettings serverMonitorSettings, IEventSubscriber eventSubscriber, ServerApi serverApi, ILoggerFactory loggerFactory, IEnvironmentVariableProvider environmentVariableProvider);
    public ServerMonitor(ServerId serverId, EndPoint endPoint, IConnectionFactory connectionFactory, ServerMonitorSettings serverMonitorSettings, IEventSubscriber eventSubscriber, IRoundTripTimeMonitor roundTripTimeMonitor, ServerApi serverApi, ILoggerFactory loggerFactory, IEnvironmentVariableProvider environmentVariableProvider);
    [CompilerGeneratedAttribute]
public sealed virtual void add_DescriptionChanged(EventHandler`1<ServerDescriptionChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_DescriptionChanged(EventHandler`1<ServerDescriptionChangedEventArgs> value);
    public sealed virtual ServerDescription get_Description();
    public sealed virtual object get_Lock();
    public sealed virtual void CancelCurrentCheck();
    public sealed virtual void Dispose();
    public sealed virtual void Initialize();
    public sealed virtual void RequestHeartbeat();
    private IConnection InitializeConnection(CancellationToken cancellationToken);
    private CommandWireProtocol`1<BsonDocument> InitializeHelloProtocol(IConnection connection, bool helloOk);
    private bool IsRunningInFaaS();
    private bool IsUsingStreamingProtocol(HelloResult helloResult);
    private HelloResult GetHelloResult(IConnection connection, CommandWireProtocol`1<BsonDocument> helloProtocol, CancellationToken cancellationToken);
    private void Heartbeat(CancellationToken cancellationToken);
    private void MonitorServer(CancellationToken monitorCancellationToken);
    private void OnDescriptionChanged(ServerDescription oldDescription, ServerDescription newDescription);
    private void SetDescription(ServerDescription newDescription);
    private void SetDescription(ServerDescription oldDescription, ServerDescription newDescription);
    private void ThrowIfDisposed();
    private void ThrowIfNotOpen();
    [CompilerGeneratedAttribute]
private void <Initialize>g__ThreadStart|31_0(object monitorCancellationToken);
    [CompilerGeneratedAttribute]
internal static bool <Heartbeat>g__IsNetworkError|38_0(Exception ex);
}
internal class MongoDB.Driver.Core.Servers.ServerMonitorFactory : object {
    private IConnectionFactory _connectionFactory;
    private IEventSubscriber _eventSubscriber;
    private ILoggerFactory _loggerFactory;
    private ServerMonitorSettings _serverMonitorSettings;
    private ServerApi _serverApi;
    public ServerMonitorFactory(ServerMonitorSettings serverMonitorSettings, IConnectionFactory connectionFactory, IEventSubscriber eventSubscriber, ServerApi serverApi, ILoggerFactory loggerFactory);
    public sealed virtual IServerMonitor Create(ServerId serverId, EndPoint endPoint);
}
public enum MongoDB.Driver.Core.Servers.ServerMonitoringMode : Enum {
    public int value__;
    public static ServerMonitoringMode Auto;
    public static ServerMonitoringMode Poll;
    public static ServerMonitoringMode Stream;
}
internal class MongoDB.Driver.Core.Servers.ServerMonitorSettings : object {
    private TimeSpan _connectTimeout;
    private TimeSpan _heartbeatInterval;
    private TimeSpan _minHeartbeatInterval;
    private ServerMonitoringMode _serverMonitoringMode;
    public TimeSpan ConnectTimeout { get; }
    public TimeSpan HeartbeatInterval { get; }
    public TimeSpan MinHeartbeatInterval { get; }
    public ServerMonitoringMode ServerMonitoringMode { get; }
    public ServerMonitorSettings(TimeSpan connectTimeout, TimeSpan heartbeatInterval, Optional`1<TimeSpan> minHeartbeatInterval, Optional`1<ServerMonitoringMode> serverMonitoringMode);
    public TimeSpan get_ConnectTimeout();
    public TimeSpan get_HeartbeatInterval();
    public TimeSpan get_MinHeartbeatInterval();
    public ServerMonitoringMode get_ServerMonitoringMode();
}
public enum MongoDB.Driver.Core.Servers.ServerState : Enum {
    public int value__;
    public static ServerState Disconnected;
    public static ServerState Connected;
}
public enum MongoDB.Driver.Core.Servers.ServerType : Enum {
    public int value__;
    public static ServerType Unknown;
    public static ServerType Standalone;
    public static ServerType ShardRouter;
    public static ServerType ReplicaSetPrimary;
    public static ServerType ReplicaSetSecondary;
    [ObsoleteAttribute("Passives are treated the same as secondaries.")]
public static ServerType ReplicaSetPassive;
    public static ServerType ReplicaSetArbiter;
    public static ServerType ReplicaSetOther;
    public static ServerType ReplicaSetGhost;
    public static ServerType LoadBalanced;
}
[ExtensionAttribute]
public static class MongoDB.Driver.Core.Servers.ServerTypeExtensions : object {
    [ExtensionAttribute]
public static bool IsReplicaSetMember(ServerType serverType);
    [ExtensionAttribute]
public static bool IsWritable(ServerType serverType);
    [ExtensionAttribute]
public static ClusterType ToClusterType(ServerType serverType);
}
public class MongoDB.Driver.Core.Servers.TopologyVersion : object {
    private long _counter;
    private int _hashCode;
    private ObjectId _processId;
    public long Counter { get; }
    public ObjectId ProcessId { get; }
    public TopologyVersion(ObjectId processId, long counter);
    public static int CompareTopologyVersion(TopologyVersion x, TopologyVersion y);
    public static TopologyVersion FromBsonDocument(BsonDocument document);
    internal static TopologyVersion FromMongoCommandResponse(BsonDocument response);
    internal static TopologyVersion FromMongoCommandException(MongoCommandException commandException);
    public static bool IsFresherThan(TopologyVersion x, TopologyVersion y);
    public static bool IsFresherThanOrEqualTo(TopologyVersion x, TopologyVersion y);
    public static bool IsStalerThan(TopologyVersion x, TopologyVersion y);
    public static bool IsStalerThanOrEqualTo(TopologyVersion x, TopologyVersion y);
    public long get_Counter();
    public ObjectId get_ProcessId();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(TopologyVersion other);
    public virtual int GetHashCode();
    public sealed virtual BsonDocument ToBsonDocument();
    public virtual string ToString();
}
internal static class MongoDB.Driver.Core.TargetFramework : object {
    public static string Moniker { get; }
    public static string get_Moniker();
}
internal static class MongoDB.Driver.Core.TransactionHelper : object {
    internal static void UnpinServerIfNeededOnCommandException(ICoreSession session, Exception exception);
    internal static void UnpinServerIfNeededOnRetryableCommitException(CoreTransaction transaction, Exception exception);
    private static bool ShouldUnpinServerOnCommandException(Exception exception);
    private static bool ShouldUnpinServerOnRetryableCommitException(Exception exception);
}
internal class MongoDB.Driver.Core.WireProtocol.CommandMessageFieldDecryptor : object {
    private IBinaryDocumentFieldDecryptor _documentFieldDecryptor;
    private MessageEncoderSettings _messageEncoderSettings;
    public CommandMessageFieldDecryptor(IBinaryDocumentFieldDecryptor documentFieldDecryptor, MessageEncoderSettings messageEncoderSettings);
    public CommandResponseMessage DecryptFields(CommandResponseMessage encryptedResponseMessage, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MongoDB.Driver.Core.WireProtocol.CommandMessageFieldDecryptor/<DecryptFieldsAsync>d__4")]
public Task`1<CommandResponseMessage> DecryptFieldsAsync(CommandResponseMessage encryptedResponseMessage, CancellationToken cancellationToken);
    private CommandResponseMessage CreateUnencryptedResponseMessage(CommandResponseMessage encryptedResponseMessage, Byte[] unencryptedDocumentBytes);
    private Byte[] GetEncryptedDocumentBytes(CommandResponseMessage encryptedResponseMessage);
}
internal class MongoDB.Driver.Core.WireProtocol.CommandMessageFieldEncryptor : object {
    private Byte[] _buffer;
    private IBinaryCommandFieldEncryptor _commandFieldEncryptor;
    private MessageEncoderSettings _messageEncoderSettings;
    public CommandMessageFieldEncryptor(IBinaryCommandFieldEncryptor commandFieldEncryptor, MessageEncoderSettings messageEncoderSettings);
    public CommandRequestMessage EncryptFields(string databaseName, CommandRequestMessage unencryptedRequestMessage, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MongoDB.Driver.Core.WireProtocol.CommandMessageFieldEncryptor/<EncryptFieldsAsync>d__5")]
public Task`1<CommandRequestMessage> EncryptFieldsAsync(string databaseName, CommandRequestMessage unencryptedRequestMessage, CancellationToken cancellationToken);
    private Byte[] CombineCommandMessageSectionsIntoSingleDocument(Stream stream);
    private void CopyBsonDocument(BsonStream inputStream, BsonStream outputStream);
    private void CopyBytes(BsonStream inputStream, BsonStream outputStream, int count);
    private void CopyType0Section(BsonStream inputStream, BsonStream outputStream);
    private void CopyType1Section(BsonStream inputStream, BsonStream outputStream);
    private CommandRequestMessage CreateEncryptedRequestMessage(CommandRequestMessage unencryptedRequestMessage, Byte[] encryptedDocumentBytes);
    private Byte[] GetUnencryptedCommandBytes(CommandRequestMessage unencryptedRequestMessage);
    private void WriteUnencryptedRequestMessageToStream(Stream stream, CommandRequestMessage unencryptedRequestMessage);
}
public enum MongoDB.Driver.Core.WireProtocol.CommandResponseHandling : Enum {
    public int value__;
    public static CommandResponseHandling Return;
    public static CommandResponseHandling Ignore;
    public static CommandResponseHandling NoResponseExpected;
    public static CommandResponseHandling ExhaustAllowed;
}
internal class MongoDB.Driver.Core.WireProtocol.CommandUsingCommandMessageWireProtocol`1 : object {
    private BsonDocument _additionalOptions;
    private BsonDocument _command;
    private List`1<Type1CommandMessageSection> _commandPayloads;
    private IElementNameValidator _commandValidator;
    private DatabaseNamespace _databaseNamespace;
    private IBinaryDocumentFieldDecryptor _documentFieldDecryptor;
    private IBinaryCommandFieldEncryptor _documentFieldEncryptor;
    private MessageEncoderSettings _messageEncoderSettings;
    private Action`1<IMessageEncoderPostProcessor> _postWriteAction;
    private ReadPreference _readPreference;
    private CommandResponseHandling _responseHandling;
    private IBsonSerializer`1<TCommandResult> _resultSerializer;
    private ServerApi _serverApi;
    private ICoreSession _session;
    private bool _moreToCome;
    private int _previousRequestId;
    public bool MoreToCome { get; }
    public CommandUsingCommandMessageWireProtocol`1(ICoreSession session, ReadPreference readPreference, DatabaseNamespace databaseNamespace, BsonDocument command, IEnumerable`1<Type1CommandMessageSection> commandPayloads, IElementNameValidator commandValidator, BsonDocument additionalOptions, CommandResponseHandling responseHandling, IBsonSerializer`1<TCommandResult> resultSerializer, MessageEncoderSettings messageEncoderSettings, Action`1<IMessageEncoderPostProcessor> postWriteAction, ServerApi serverApi);
    public sealed virtual bool get_MoreToCome();
    public sealed virtual TCommandResult Execute(IConnection connection, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MongoDB.Driver.Core.WireProtocol.CommandUsingCommandMessageWireProtocol`1/<ExecuteAsync>d__20")]
public sealed virtual Task`1<TCommandResult> ExecuteAsync(IConnection connection, CancellationToken cancellationToken);
    private void AddErrorLabelIfRequired(Exception exception, ConnectionDescription connectionDescription);
    private CommandResponseMessage AutoDecryptFieldsIfNecessary(CommandResponseMessage encryptedResponseMessage, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MongoDB.Driver.Core.WireProtocol.CommandUsingCommandMessageWireProtocol`1/<AutoDecryptFieldsIfNecessaryAsync>d__23")]
private Task`1<CommandResponseMessage> AutoDecryptFieldsIfNecessaryAsync(CommandResponseMessage encryptedResponseMessage, CancellationToken cancellationToken);
    private CommandRequestMessage AutoEncryptFieldsIfNecessary(CommandRequestMessage unencryptedRequestMessage, IConnection connection, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MongoDB.Driver.Core.WireProtocol.CommandUsingCommandMessageWireProtocol`1/<AutoEncryptFieldsIfNecessaryAsync>d__25")]
private Task`1<CommandRequestMessage> AutoEncryptFieldsIfNecessaryAsync(CommandRequestMessage unencryptedRequestMessage, IConnection connection, CancellationToken cancellationToken);
    private CommandRequestMessage CreateCommandMessage(ConnectionDescription connectionDescription);
    private IEnumerable`1<CommandMessageSection> CreateSections(ConnectionDescription connectionDescription);
    private Type0CommandMessageSection`1<BsonDocument> CreateType0Section(ConnectionDescription connectionDescription);
    private bool IsRetryableWriteExceptionAndDeploymentDoesNotSupportRetryableWrites(MongoCommandException exception);
    private void MessageWasProbablySent(CommandRequestMessage message);
    private TCommandResult ProcessResponse(ConnectionId connectionId, CommandMessage responseMessage);
    private void SaveResponseInfo(CommandResponseMessage response);
    private TCommandResult SendMessageAndProcessResponse(CommandRequestMessage message, int responseTo, IConnection connection, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MongoDB.Driver.Core.WireProtocol.CommandUsingCommandMessageWireProtocol`1/<SendMessageAndProcessResponseAsync>d__34")]
private Task`1<TCommandResult> SendMessageAndProcessResponseAsync(CommandRequestMessage message, int responseTo, IConnection connection, CancellationToken cancellationToken);
    private bool ShouldAddTransientTransactionError(MongoException exception);
    private MongoException WrapNotSupportedRetryableWriteException(MongoCommandException exception);
    [CompilerGeneratedAttribute]
private void <CreateType0Section>g__AddIfNotAlreadyAdded|28_1(string key, BsonValue value, <>c__DisplayClass28_0& );
    [CompilerGeneratedAttribute]
private bool <CreateType0Section>g__IsSessionAcknowledged|28_2(<>c__DisplayClass28_0& );
}
internal class MongoDB.Driver.Core.WireProtocol.CommandUsingQueryMessageWireProtocol`1 : object {
    private BsonDocument _additionalOptions;
    private BsonDocument _command;
    private List`1<Type1CommandMessageSection> _commandPayloads;
    private IElementNameValidator _commandValidator;
    private DatabaseNamespace _databaseNamespace;
    private Action`1<IMessageEncoderPostProcessor> _postWriteAction;
    private MessageEncoderSettings _messageEncoderSettings;
    private ReadPreference _readPreference;
    private CommandResponseHandling _responseHandling;
    private IBsonSerializer`1<TCommandResult> _resultSerializer;
    private ServerApi _serverApi;
    private ICoreSession _session;
    public bool MoreToCome { get; }
    public CommandUsingQueryMessageWireProtocol`1(ICoreSession session, ReadPreference readPreference, DatabaseNamespace databaseNamespace, BsonDocument command, IEnumerable`1<Type1CommandMessageSection> commandPayloads, IElementNameValidator commandValidator, BsonDocument additionalOptions, CommandResponseHandling responseHandling, IBsonSerializer`1<TCommandResult> resultSerializer, MessageEncoderSettings messageEncoderSettings, Action`1<IMessageEncoderPostProcessor> postWriteAction, ServerApi serverApi);
    public sealed virtual bool get_MoreToCome();
    private QueryMessage CreateMessage(ConnectionDescription connectionDescription, Boolean& messageContainsSessionId);
    public sealed virtual TCommandResult Execute(IConnection connection, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MongoDB.Driver.Core.WireProtocol.CommandUsingQueryMessageWireProtocol`1/<ExecuteAsync>d__17")]
public sealed virtual Task`1<TCommandResult> ExecuteAsync(IConnection connection, CancellationToken cancellationToken);
    private BsonDocument CombineCommandWithPayloads(ConnectionDescription connectionDescription);
    private BsonArray CreatePayloadArray(Type1CommandMessageSection payload, ConnectionDescription connectionDescription);
    private IBsonSerializer CreateFixedCountPayloadSerializer(Type1CommandMessageSection payload);
    private IBsonSerializer CreateSizeLimitingPayloadSerializer(Type1CommandMessageSection payload, ConnectionDescription connectionDescription);
    private void IgnoreResponse(IConnection connection, QueryMessage message, CancellationToken cancellationToken);
    private TCommandResult ProcessReply(ConnectionId connectionId, ReplyMessage`1<RawBsonDocument> reply);
    private BsonDocument WrapCommandForQueryMessage(BsonDocument command, ConnectionDescription connectionDescription, Boolean& messageContainsSessionId, Boolean& secondaryOk);
}
internal class MongoDB.Driver.Core.WireProtocol.CommandWireProtocol`1 : object {
    private BsonDocument _additionalOptions;
    private IWireProtocol`1<TCommandResult> _cachedWireProtocol;
    private ConnectionId _cachedConnectionId;
    private BsonDocument _command;
    private List`1<Type1CommandMessageSection> _commandPayloads;
    private IElementNameValidator _commandValidator;
    private DatabaseNamespace _databaseNamespace;
    private MessageEncoderSettings _messageEncoderSettings;
    private Action`1<IMessageEncoderPostProcessor> _postWriteAction;
    private ReadPreference _readPreference;
    private CommandResponseHandling _responseHandling;
    private IBsonSerializer`1<TCommandResult> _resultSerializer;
    private ServerApi _serverApi;
    private ICoreSession _session;
    public bool MoreToCome { get; }
    public CommandWireProtocol`1(DatabaseNamespace databaseNamespace, BsonDocument command, bool secondaryOk, IBsonSerializer`1<TCommandResult> resultSerializer, MessageEncoderSettings messageEncoderSettings, ServerApi serverApi);
    public CommandWireProtocol`1(DatabaseNamespace databaseNamespace, BsonDocument command, bool secondaryOk, CommandResponseHandling commandResponseHandling, IBsonSerializer`1<TCommandResult> resultSerializer, MessageEncoderSettings messageEncoderSettings, ServerApi serverApi);
    public CommandWireProtocol`1(ICoreSession session, ReadPreference readPreference, DatabaseNamespace databaseNamespace, BsonDocument command, IEnumerable`1<Type1CommandMessageSection> commandPayloads, IElementNameValidator commandValidator, BsonDocument additionalOptions, Action`1<IMessageEncoderPostProcessor> postWriteAction, CommandResponseHandling responseHandling, IBsonSerializer`1<TCommandResult> resultSerializer, MessageEncoderSettings messageEncoderSettings, ServerApi serverApi);
    public sealed virtual bool get_MoreToCome();
    public sealed virtual TCommandResult Execute(IConnection connection, CancellationToken cancellationToken);
    public sealed virtual Task`1<TCommandResult> ExecuteAsync(IConnection connection, CancellationToken cancellationToken);
    private IWireProtocol`1<TCommandResult> CreateCommandUsingCommandMessageWireProtocol();
    private IWireProtocol`1<TCommandResult> CreateCommandUsingQueryMessageWireProtocol();
    private IWireProtocol`1<TCommandResult> CreateSupportedWireProtocol(IConnection connection);
}
public class MongoDB.Driver.Core.WireProtocol.CursorBatch`1 : ValueType {
    private long _cursorId;
    private IReadOnlyList`1<TDocument> _documents;
    private BsonDocument _postBatchResumeToken;
    public long CursorId { get; }
    public IReadOnlyList`1<TDocument> Documents { get; }
    public BsonDocument PostBatchResumeToken { get; }
    public CursorBatch`1(long cursorId, BsonDocument postBatchResumeToken, IReadOnlyList`1<TDocument> documents);
    public CursorBatch`1(long cursorId, IReadOnlyList`1<TDocument> documents);
    public long get_CursorId();
    public IReadOnlyList`1<TDocument> get_Documents();
    public BsonDocument get_PostBatchResumeToken();
}
public interface MongoDB.Driver.Core.WireProtocol.IBinaryCommandFieldEncryptor {
    public abstract virtual Byte[] EncryptFields(string databaseName, Byte[] unencryptedCommandBytes, CancellationToken cancellationToken);
    public abstract virtual Task`1<Byte[]> EncryptFieldsAsync(string databaseName, Byte[] unencryptedCommandBytes, CancellationToken cancellationToken);
}
public interface MongoDB.Driver.Core.WireProtocol.IBinaryDocumentFieldDecryptor {
    public abstract virtual Byte[] DecryptFields(Byte[] encryptedDocumentBytes, CancellationToken cancellationToken);
    public abstract virtual Task`1<Byte[]> DecryptFieldsAsync(Byte[] encryptedDocumentBytes, CancellationToken cancellationToken);
}
internal interface MongoDB.Driver.Core.WireProtocol.IWireProtocol {
    public bool MoreToCome { get; }
    public abstract virtual bool get_MoreToCome();
    public abstract virtual void Execute(IConnection connection, CancellationToken cancellationToken);
    public abstract virtual Task ExecuteAsync(IConnection connection, CancellationToken cancellationToken);
}
internal interface MongoDB.Driver.Core.WireProtocol.IWireProtocol`1 {
    public bool MoreToCome { get; }
    public abstract virtual bool get_MoreToCome();
    public abstract virtual TResult Execute(IConnection connection, CancellationToken cancellationToken);
    public abstract virtual Task`1<TResult> ExecuteAsync(IConnection connection, CancellationToken cancellationToken);
}
public class MongoDB.Driver.Core.WireProtocol.Messages.CommandMessage : MongoDBMessage {
    private static HashSet`1<string> __messagesNotToBeCompressed;
    private bool _exhaustAllowed;
    private bool _moreToCome;
    private Action`1<IMessageEncoderPostProcessor> _postWriteAction;
    private int _requestId;
    private int _responseTo;
    private List`1<CommandMessageSection> _sections;
    public bool ExhaustAllowed { get; public set; }
    public bool MayBeCompressed { get; }
    public MongoDBMessageType MessageType { get; }
    public bool MoreToCome { get; public set; }
    public Action`1<IMessageEncoderPostProcessor> PostWriteAction { get; public set; }
    public int RequestId { get; }
    public bool ResponseExpected { get; }
    public int ResponseTo { get; }
    public IReadOnlyList`1<CommandMessageSection> Sections { get; }
    public CommandMessage(int requestId, int responseTo, IEnumerable`1<CommandMessageSection> sections, bool moreToCome);
    private static CommandMessage();
    public bool get_ExhaustAllowed();
    public void set_ExhaustAllowed(bool value);
    public virtual bool get_MayBeCompressed();
    public virtual MongoDBMessageType get_MessageType();
    public bool get_MoreToCome();
    public void set_MoreToCome(bool value);
    public Action`1<IMessageEncoderPostProcessor> get_PostWriteAction();
    public void set_PostWriteAction(Action`1<IMessageEncoderPostProcessor> value);
    public int get_RequestId();
    public bool get_ResponseExpected();
    public int get_ResponseTo();
    public IReadOnlyList`1<CommandMessageSection> get_Sections();
    public virtual IMessageEncoder GetEncoder(IMessageEncoderFactory encoderFactory);
}
internal class MongoDB.Driver.Core.WireProtocol.Messages.CommandMessageDisposer : object {
    private CommandMessage _message;
    public CommandMessageDisposer(CommandMessage message);
    public sealed virtual void Dispose();
    private void DisposeSection(CommandMessageSection section);
    private void DisposeType0Section(Type0CommandMessageSection`1<RawBsonDocument> section);
    private void DisposeType1Section(Type1CommandMessageSection`1<RawBsonDocument> section);
}
public abstract class MongoDB.Driver.Core.WireProtocol.Messages.CommandMessageSection : object {
    public PayloadType PayloadType { get; }
    public abstract virtual PayloadType get_PayloadType();
}
public class MongoDB.Driver.Core.WireProtocol.Messages.CommandRequestMessage : RequestMessage {
    private CommandMessage _wrappedMessage;
    public bool MayBeCompressed { get; }
    public MongoDBMessageType MessageType { get; }
    public CommandMessage WrappedMessage { get; }
    public CommandRequestMessage(CommandMessage wrappedMessage, Func`1<bool> shouldBeSent);
    public virtual bool get_MayBeCompressed();
    public virtual MongoDBMessageType get_MessageType();
    public CommandMessage get_WrappedMessage();
    public virtual IMessageEncoder GetEncoder(IMessageEncoderFactory encoderFactory);
}
public class MongoDB.Driver.Core.WireProtocol.Messages.CommandResponseMessage : ResponseMessage {
    private CommandMessage _wrappedMessage;
    public MongoDBMessageType MessageType { get; }
    public CommandMessage WrappedMessage { get; }
    public CommandResponseMessage(CommandMessage wrappedMessage);
    public virtual MongoDBMessageType get_MessageType();
    public CommandMessage get_WrappedMessage();
    public virtual IMessageEncoder GetEncoder(IMessageEncoderFactory encoderFactory);
}
public class MongoDB.Driver.Core.WireProtocol.Messages.CompressedMessage : MongoDBMessage {
    private CompressorType _compressorType;
    private MongoDBMessage _originalMessage;
    private BsonStream _originalMessageStream;
    public CompressorType CompressorType { get; }
    public MongoDBMessageType MessageType { get; }
    public MongoDBMessage OriginalMessage { get; }
    public BsonStream OriginalMessageStream { get; }
    public CompressedMessage(MongoDBMessage originalMessage, BsonStream originalMessageStream, CompressorType compressorType);
    public CompressorType get_CompressorType();
    public virtual MongoDBMessageType get_MessageType();
    public MongoDBMessage get_OriginalMessage();
    public BsonStream get_OriginalMessageStream();
    public virtual IMessageEncoder GetEncoder(IMessageEncoderFactory encoderFactory);
}
public class MongoDB.Driver.Core.WireProtocol.Messages.Encoders.BinaryEncoders.BinaryMessageEncoderFactory : object {
    private ICompressorSource _compressorSource;
    private MessageEncoderSettings _encoderSettings;
    private Stream _stream;
    public BinaryMessageEncoderFactory(Stream stream, MessageEncoderSettings encoderSettings, ICompressorSource compressorSource);
    public sealed virtual IMessageEncoder GetCommandMessageEncoder();
    public sealed virtual IMessageEncoder GetCommandRequestMessageEncoder();
    public sealed virtual IMessageEncoder GetCommandResponseMessageEncoder();
    public sealed virtual IMessageEncoder GetCompressedMessageEncoder(IMessageEncoderSelector originalEncoderSelector);
    public sealed virtual IMessageEncoder GetQueryMessageEncoder();
    public sealed virtual IMessageEncoder GetReplyMessageEncoder(IBsonSerializer`1<TDocument> serializer);
}
public class MongoDB.Driver.Core.WireProtocol.Messages.Encoders.BinaryEncoders.CommandMessageBinaryEncoder : MessageBinaryEncoderBase {
    public CommandMessageBinaryEncoder(Stream stream, MessageEncoderSettings encoderSettings);
    public CommandMessage ReadMessage();
    public void WriteMessage(CommandMessage message);
    private sealed virtual override MongoDBMessage MongoDB.Driver.Core.WireProtocol.Messages.Encoders.IMessageEncoder.ReadMessage();
    private sealed virtual override void MongoDB.Driver.Core.WireProtocol.Messages.Encoders.IMessageEncoder.WriteMessage(MongoDBMessage message);
    private OpMsgFlags CreateFlags(CommandMessage message);
    private void EnsureExactlyOneType0SectionIsPresent(List`1<CommandMessageSection> sections);
    private void EnsureFlagsAreValid(OpMsgFlags flags);
    private void EnsureMessageEndedAtEndPosition(BsonStream stream, long messageEndPosition);
    private void EnsureMessageLengthIsValid(int messageLength);
    private void EnsureOpcodeIsValid(Opcode opcode);
    private void EnsurePayloadEndedAtEndPosition(BsonStream stream, long sectionEndPosition);
    private void EnsureType1PayloadLengthIsValid(int sectionLength);
    private CommandMessageSection ReadSection(BsonBinaryReader reader);
    private List`1<CommandMessageSection> ReadSections(BsonBinaryReader reader, long messageEndPosition);
    private Type0CommandMessageSection`1<RawBsonDocument> ReadType0Section(IBsonReader reader);
    private Type1CommandMessageSection`1<RawBsonDocument> ReadType1Section(BsonBinaryReader reader);
    private void WriteSection(BsonBinaryWriter writer, CommandMessageSection section, long messageStartPosition);
    private void WriteSections(BsonBinaryWriter writer, IEnumerable`1<CommandMessageSection> sections, long messageStartPosition);
    private void WriteType0Section(BsonBinaryWriter writer, Type0CommandMessageSection section);
    private void WriteType1Section(BsonBinaryWriter writer, Type1CommandMessageSection section, long messageStartPosition);
}
public class MongoDB.Driver.Core.WireProtocol.Messages.Encoders.BinaryEncoders.CommandRequestMessageBinaryEncoder : object {
    private CommandMessageBinaryEncoder _wrappedEncoder;
    public CommandRequestMessageBinaryEncoder(CommandMessageBinaryEncoder wrappedEncoder);
    public CommandRequestMessage ReadMessage();
    public void WriteMessage(CommandRequestMessage message);
    private sealed virtual override MongoDBMessage MongoDB.Driver.Core.WireProtocol.Messages.Encoders.IMessageEncoder.ReadMessage();
    private sealed virtual override void MongoDB.Driver.Core.WireProtocol.Messages.Encoders.IMessageEncoder.WriteMessage(MongoDBMessage message);
}
public class MongoDB.Driver.Core.WireProtocol.Messages.Encoders.BinaryEncoders.CommandResponseMessageBinaryEncoder : object {
    private CommandMessageBinaryEncoder _wrappedEncoder;
    public CommandResponseMessageBinaryEncoder(CommandMessageBinaryEncoder wrappedEncoder);
    public CommandResponseMessage ReadMessage();
    public void WriteMessage(CommandResponseMessage message);
    private sealed virtual override MongoDBMessage MongoDB.Driver.Core.WireProtocol.Messages.Encoders.IMessageEncoder.ReadMessage();
    private sealed virtual override void MongoDB.Driver.Core.WireProtocol.Messages.Encoders.IMessageEncoder.WriteMessage(MongoDBMessage message);
}
public class MongoDB.Driver.Core.WireProtocol.Messages.Encoders.BinaryEncoders.CompressedMessageBinaryEncoder : MessageBinaryEncoderBase {
    private ICompressorSource _compressorSource;
    private MessageEncoderSettings _encoderSettings;
    private IMessageEncoderSelector _originalEncoderSelector;
    private static int MessageHeaderLength;
    public CompressedMessageBinaryEncoder(Stream stream, IMessageEncoderSelector originalEncoderSelector, ICompressorSource compressorSource, MessageEncoderSettings encoderSettings);
    public CompressedMessage ReadMessage();
    public void WriteMessage(CompressedMessage message);
    private sealed virtual override MongoDBMessage MongoDB.Driver.Core.WireProtocol.Messages.Encoders.IMessageEncoder.ReadMessage();
    private sealed virtual override void MongoDB.Driver.Core.WireProtocol.Messages.Encoders.IMessageEncoder.WriteMessage(MongoDBMessage message);
    private void EnsureMessageLengthIsValid(int messageLength);
    private void EnsureOpcodeIsValid(Opcode opcode);
}
public abstract class MongoDB.Driver.Core.WireProtocol.Messages.Encoders.BinaryEncoders.MessageBinaryEncoderBase : object {
    private MessageEncoderSettings _encoderSettings;
    private Stream _stream;
    protected UTF8Encoding Encoding { get; }
    protected bool IsEncryptionConfigured { get; }
    protected Nullable`1<int> MaxDocumentSize { get; }
    protected Nullable`1<int> MaxMessageSize { get; }
    protected Nullable`1<int> MaxWireDocumentSize { get; }
    protected MessageBinaryEncoderBase(Stream stream, MessageEncoderSettings encoderSettings);
    protected UTF8Encoding get_Encoding();
    protected bool get_IsEncryptionConfigured();
    protected Nullable`1<int> get_MaxDocumentSize();
    protected Nullable`1<int> get_MaxMessageSize();
    protected Nullable`1<int> get_MaxWireDocumentSize();
    public BsonBinaryReader CreateBinaryReader();
    public BsonBinaryWriter CreateBinaryWriter();
}
internal enum MongoDB.Driver.Core.WireProtocol.Messages.Encoders.BinaryEncoders.Opcode : Enum {
    public int value__;
    public static Opcode Reply;
    public static Opcode Message;
    public static Opcode Query;
    public static Opcode Compressed;
    public static Opcode OpMsg;
}
[FlagsAttribute]
internal enum MongoDB.Driver.Core.WireProtocol.Messages.Encoders.BinaryEncoders.OpMsgFlags : Enum {
    public int value__;
    public static OpMsgFlags ChecksumPresent;
    public static OpMsgFlags MoreToCome;
    public static OpMsgFlags ExhaustAllowed;
    public static OpMsgFlags All;
}
public class MongoDB.Driver.Core.WireProtocol.Messages.Encoders.BinaryEncoders.QueryMessageBinaryEncoder : MessageBinaryEncoderBase {
    public QueryMessageBinaryEncoder(Stream stream, MessageEncoderSettings encoderSettings);
    private QueryFlags BuildQueryFlags(QueryMessage message);
    public QueryMessage ReadMessage();
    internal QueryMessage ReadMessage(IBsonSerializer`1<TDocument> serializer);
    public void WriteMessage(QueryMessage message);
    private void EnsureOpcodeIsValid(Opcode opcode);
    private void WriteOptionalFields(BsonBinaryWriter binaryWriter, BsonDocument fields);
    private void WriteQuery(BsonBinaryWriter binaryWriter, BsonDocument query, IElementNameValidator queryValidator);
    private sealed virtual override MongoDBMessage MongoDB.Driver.Core.WireProtocol.Messages.Encoders.IMessageEncoder.ReadMessage();
    private sealed virtual override void MongoDB.Driver.Core.WireProtocol.Messages.Encoders.IMessageEncoder.WriteMessage(MongoDBMessage message);
}
public class MongoDB.Driver.Core.WireProtocol.Messages.Encoders.BinaryEncoders.ReplyMessageBinaryEncoder`1 : MessageBinaryEncoderBase {
    private IBsonSerializer`1<TDocument> _serializer;
    public ReplyMessageBinaryEncoder`1(Stream stream, MessageEncoderSettings encoderSettings, IBsonSerializer`1<TDocument> serializer);
    public ReplyMessage`1<TDocument> ReadMessage();
    public void WriteMessage(ReplyMessage`1<TDocument> message);
    private void EnsureOpcodeIsValid(Opcode opcode);
    private sealed virtual override MongoDBMessage MongoDB.Driver.Core.WireProtocol.Messages.Encoders.IMessageEncoder.ReadMessage();
    private sealed virtual override void MongoDB.Driver.Core.WireProtocol.Messages.Encoders.IMessageEncoder.WriteMessage(MongoDBMessage message);
}
public class MongoDB.Driver.Core.WireProtocol.Messages.Encoders.CommandResponseMessageEncoderSelector : object {
    public sealed virtual IMessageEncoder GetEncoder(IMessageEncoderFactory encoderFactory);
}
public class MongoDB.Driver.Core.WireProtocol.Messages.Encoders.CompressedMessageEncoderSelector : object {
    private IMessageEncoderSelector _originalEncoderSelector;
    public CompressedMessageEncoderSelector(IMessageEncoderSelector originalEncoderSelector);
    public sealed virtual IMessageEncoder GetEncoder(IMessageEncoderFactory encoderFactory);
}
public interface MongoDB.Driver.Core.WireProtocol.Messages.Encoders.IEncodableMessage {
    public abstract virtual IMessageEncoder GetEncoder(IMessageEncoderFactory encoderFactory);
}
public interface MongoDB.Driver.Core.WireProtocol.Messages.Encoders.IMessageEncoder {
    public abstract virtual MongoDBMessage ReadMessage();
    public abstract virtual void WriteMessage(MongoDBMessage message);
}
public interface MongoDB.Driver.Core.WireProtocol.Messages.Encoders.IMessageEncoderFactory {
    public abstract virtual IMessageEncoder GetCommandMessageEncoder();
    public abstract virtual IMessageEncoder GetCommandRequestMessageEncoder();
    public abstract virtual IMessageEncoder GetCommandResponseMessageEncoder();
    public abstract virtual IMessageEncoder GetCompressedMessageEncoder(IMessageEncoderSelector originalEncoderSelector);
    public abstract virtual IMessageEncoder GetQueryMessageEncoder();
    public abstract virtual IMessageEncoder GetReplyMessageEncoder(IBsonSerializer`1<TDocument> serializer);
}
public interface MongoDB.Driver.Core.WireProtocol.Messages.Encoders.IMessageEncoderPostProcessor {
    public abstract virtual void ChangeWriteConcernFromW0ToW1();
}
public interface MongoDB.Driver.Core.WireProtocol.Messages.Encoders.IMessageEncoderSelector {
    public abstract virtual IMessageEncoder GetEncoder(IMessageEncoderFactory encoderFactory);
}
public class MongoDB.Driver.Core.WireProtocol.Messages.Encoders.JsonEncoders.CommandMessageJsonEncoder : MessageJsonEncoderBase {
    public CommandMessageJsonEncoder(TextReader textReader, TextWriter textWriter, MessageEncoderSettings encoderSettings);
    public CommandMessage ReadMessage();
    public void WriteMessage(CommandMessage message);
    private sealed virtual override MongoDBMessage MongoDB.Driver.Core.WireProtocol.Messages.Encoders.IMessageEncoder.ReadMessage();
    private sealed virtual override void MongoDB.Driver.Core.WireProtocol.Messages.Encoders.IMessageEncoder.WriteMessage(MongoDBMessage message);
    private CommandMessageSection ReadSection(BsonDocument sectionDocument);
    private IEnumerable`1<CommandMessageSection> ReadSections(IEnumerable`1<BsonDocument> sectionDocuments);
    private CommandMessageSection ReadType0Section(BsonDocument sectionDocument);
    private CommandMessageSection ReadType1Section(BsonDocument sectionDocument);
    private void WriteSection(IBsonWriter writer, CommandMessageSection section);
    private void WriteSections(IBsonWriter writer, IEnumerable`1<CommandMessageSection> sections);
    private void WriteType0Section(IBsonWriter writer, Type0CommandMessageSection section);
    private void WriteType1Section(IBsonWriter writer, Type1CommandMessageSection section);
}
public class MongoDB.Driver.Core.WireProtocol.Messages.Encoders.JsonEncoders.CommandRequestMessageJsonEncoder : object {
    private CommandMessageJsonEncoder _wrappedEncoder;
    public CommandRequestMessageJsonEncoder(CommandMessageJsonEncoder wrappedEncoder);
    public CommandRequestMessage ReadMessage();
    public void WriteMessage(CommandRequestMessage message);
    private sealed virtual override MongoDBMessage MongoDB.Driver.Core.WireProtocol.Messages.Encoders.IMessageEncoder.ReadMessage();
    private sealed virtual override void MongoDB.Driver.Core.WireProtocol.Messages.Encoders.IMessageEncoder.WriteMessage(MongoDBMessage message);
}
public class MongoDB.Driver.Core.WireProtocol.Messages.Encoders.JsonEncoders.CommandResponseMessageJsonEncoder : object {
    private CommandMessageJsonEncoder _wrappedEncoder;
    public CommandResponseMessageJsonEncoder(CommandMessageJsonEncoder wrappedEncoder);
    public CommandResponseMessage ReadMessage();
    public void WriteMessage(CommandResponseMessage message);
    private sealed virtual override MongoDBMessage MongoDB.Driver.Core.WireProtocol.Messages.Encoders.IMessageEncoder.ReadMessage();
    private sealed virtual override void MongoDB.Driver.Core.WireProtocol.Messages.Encoders.IMessageEncoder.WriteMessage(MongoDBMessage message);
}
public class MongoDB.Driver.Core.WireProtocol.Messages.Encoders.JsonEncoders.CompressedMessageJsonEncoder : MessageJsonEncoderBase {
    private MessageEncoderSettings _encoderSettings;
    private IMessageEncoderSelector _originalEncoderSelector;
    public CompressedMessageJsonEncoder(TextReader textReader, TextWriter textWriter, IMessageEncoderSelector originalEncoderSelector, MessageEncoderSettings encoderSettings);
    public CompressedMessage ReadMessage();
    public void WriteMessage(CompressedMessage message);
    private sealed virtual override MongoDBMessage MongoDB.Driver.Core.WireProtocol.Messages.Encoders.IMessageEncoder.ReadMessage();
    private sealed virtual override void MongoDB.Driver.Core.WireProtocol.Messages.Encoders.IMessageEncoder.WriteMessage(MongoDBMessage message);
}
public class MongoDB.Driver.Core.WireProtocol.Messages.Encoders.JsonEncoders.JsonMessageEncoderFactory : object {
    private MessageEncoderSettings _encoderSettings;
    private TextReader _textReader;
    private TextWriter _textWriter;
    public JsonMessageEncoderFactory(TextReader textReader, MessageEncoderSettings encoderSettings);
    public JsonMessageEncoderFactory(TextWriter textWriter, MessageEncoderSettings encoderSettings);
    public JsonMessageEncoderFactory(TextReader textReader, TextWriter textWriter, MessageEncoderSettings encoderSettings);
    public sealed virtual IMessageEncoder GetCommandMessageEncoder();
    public sealed virtual IMessageEncoder GetCommandRequestMessageEncoder();
    public sealed virtual IMessageEncoder GetCommandResponseMessageEncoder();
    public sealed virtual IMessageEncoder GetCompressedMessageEncoder(IMessageEncoderSelector originalEncoderSelector);
    public sealed virtual IMessageEncoder GetQueryMessageEncoder();
    public sealed virtual IMessageEncoder GetReplyMessageEncoder(IBsonSerializer`1<TDocument> serializer);
}
public abstract class MongoDB.Driver.Core.WireProtocol.Messages.Encoders.JsonEncoders.MessageJsonEncoderBase : object {
    private MessageEncoderSettings _encoderSettings;
    private TextReader _textReader;
    private TextWriter _textWriter;
    protected MessageJsonEncoderBase(TextReader textReader, TextWriter textWriter, MessageEncoderSettings encoderSettings);
    public JsonReader CreateJsonReader();
    public JsonWriter CreateJsonWriter();
}
public class MongoDB.Driver.Core.WireProtocol.Messages.Encoders.JsonEncoders.QueryMessageJsonEncoder : MessageJsonEncoderBase {
    public QueryMessageJsonEncoder(TextReader textReader, TextWriter textWriter, MessageEncoderSettings encoderSettings);
    public QueryMessage ReadMessage();
    public void WriteMessage(QueryMessage message);
    private sealed virtual override MongoDBMessage MongoDB.Driver.Core.WireProtocol.Messages.Encoders.IMessageEncoder.ReadMessage();
    private sealed virtual override void MongoDB.Driver.Core.WireProtocol.Messages.Encoders.IMessageEncoder.WriteMessage(MongoDBMessage message);
}
public class MongoDB.Driver.Core.WireProtocol.Messages.Encoders.JsonEncoders.ReplyMessageJsonEncoder`1 : MessageJsonEncoderBase {
    private IBsonSerializer`1<TDocument> _serializer;
    public ReplyMessageJsonEncoder`1(TextReader textReader, TextWriter textWriter, MessageEncoderSettings encoderSettings, IBsonSerializer`1<TDocument> serializer);
    public ReplyMessage`1<TDocument> ReadMessage();
    public void WriteMessage(ReplyMessage`1<TDocument> message);
    private sealed virtual override MongoDBMessage MongoDB.Driver.Core.WireProtocol.Messages.Encoders.IMessageEncoder.ReadMessage();
    private sealed virtual override void MongoDB.Driver.Core.WireProtocol.Messages.Encoders.IMessageEncoder.WriteMessage(MongoDBMessage message);
}
public class MongoDB.Driver.Core.WireProtocol.Messages.Encoders.MessageEncoderSettings : object {
    private Dictionary`2<string, object> _settings;
    public MessageEncoderSettings Add(string name, T value);
    public MessageEncoderSettings Clone();
    public sealed virtual IEnumerator`1<KeyValuePair`2<string, object>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public T GetOrDefault(string name, T defaultValue);
    public void Set(string name, object value);
}
public static class MongoDB.Driver.Core.WireProtocol.Messages.Encoders.MessageEncoderSettingsName : object {
    public static string BinaryDocumentFieldDecryptor;
    public static string BinaryDocumentFieldEncryptor;
    public static string FixOldBinarySubTypeOnInput;
    public static string FixOldBinarySubTypeOnOutput;
    public static string FixOldDateTimeMaxValueOnInput;
    [ObsoleteAttribute("Configure serializers instead.")]
public static string GuidRepresentation;
    public static string MaxDocumentSize;
    public static string MaxMessageSize;
    public static string MaxSerializationDepth;
    public static string MaxWireDocumentSize;
    public static string ReadEncoding;
    public static string WriteEncoding;
    public static string Indent;
    public static string IndentChars;
    public static string NewLineChars;
    public static string OutputMode;
    public static string ShellVersion;
}
public class MongoDB.Driver.Core.WireProtocol.Messages.Encoders.ReplyMessageEncoderSelector`1 : object {
    private IBsonSerializer`1<TDocument> _documentSerializer;
    public ReplyMessageEncoderSelector`1(IBsonSerializer`1<TDocument> documentSerializer);
    public sealed virtual IMessageEncoder GetEncoder(IMessageEncoderFactory encoderFactory);
}
public abstract class MongoDB.Driver.Core.WireProtocol.Messages.MongoDBMessage : object {
    public bool MayBeCompressed { get; }
    public MongoDBMessageType MessageType { get; }
    public virtual bool get_MayBeCompressed();
    public abstract virtual MongoDBMessageType get_MessageType();
    public abstract virtual IMessageEncoder GetEncoder(IMessageEncoderFactory encoderFactory);
}
public enum MongoDB.Driver.Core.WireProtocol.Messages.MongoDBMessageType : Enum {
    public int value__;
    public static MongoDBMessageType Command;
    public static MongoDBMessageType Compressed;
    public static MongoDBMessageType Query;
    public static MongoDBMessageType Reply;
}
public enum MongoDB.Driver.Core.WireProtocol.Messages.PayloadType : Enum {
    public int value__;
    public static PayloadType Type0;
    public static PayloadType Type1;
}
public class MongoDB.Driver.Core.WireProtocol.Messages.QueryMessage : RequestMessage {
    private bool _awaitData;
    private int _batchSize;
    private CollectionNamespace _collectionNamespace;
    private BsonDocument _fields;
    private bool _noCursorTimeout;
    private bool _oplogReplay;
    private bool _partialOk;
    private Action`1<IMessageEncoderPostProcessor> _postWriteAction;
    private BsonDocument _query;
    private IElementNameValidator _queryValidator;
    private CommandResponseHandling _responseHandling;
    private int _skip;
    private bool _secondaryOk;
    private bool _tailableCursor;
    public bool AwaitData { get; }
    public int BatchSize { get; }
    public CollectionNamespace CollectionNamespace { get; }
    public BsonDocument Fields { get; }
    public MongoDBMessageType MessageType { get; }
    public bool NoCursorTimeout { get; }
    [ObsoleteAttribute("OplogReplay is ignored by server versions 4.4.0 and newer.")]
public bool OplogReplay { get; }
    public bool PartialOk { get; }
    public Action`1<IMessageEncoderPostProcessor> PostWriteAction { get; public set; }
    public BsonDocument Query { get; }
    public IElementNameValidator QueryValidator { get; }
    public CommandResponseHandling ResponseHandling { get; public set; }
    public bool SecondaryOk { get; }
    public int Skip { get; }
    public bool TailableCursor { get; }
    public QueryMessage(int requestId, CollectionNamespace collectionNamespace, BsonDocument query, BsonDocument fields, IElementNameValidator queryValidator, int skip, int batchSize, bool secondaryOk, bool partialOk, bool noCursorTimeout, bool tailableCursor, bool awaitData, Func`1<bool> shouldBeSent);
    [ObsoleteAttribute("Use a constructor that does not have an oplogReplay parameter instead.")]
public QueryMessage(int requestId, CollectionNamespace collectionNamespace, BsonDocument query, BsonDocument fields, IElementNameValidator queryValidator, int skip, int batchSize, bool secondaryOk, bool partialOk, bool noCursorTimeout, bool oplogReplay, bool tailableCursor, bool awaitData, Func`1<bool> shouldBeSent);
    public bool get_AwaitData();
    public int get_BatchSize();
    public CollectionNamespace get_CollectionNamespace();
    public BsonDocument get_Fields();
    public virtual MongoDBMessageType get_MessageType();
    public bool get_NoCursorTimeout();
    public bool get_OplogReplay();
    public bool get_PartialOk();
    public Action`1<IMessageEncoderPostProcessor> get_PostWriteAction();
    public void set_PostWriteAction(Action`1<IMessageEncoderPostProcessor> value);
    public BsonDocument get_Query();
    public IElementNameValidator get_QueryValidator();
    public CommandResponseHandling get_ResponseHandling();
    public void set_ResponseHandling(CommandResponseHandling value);
    public bool get_SecondaryOk();
    public int get_Skip();
    public bool get_TailableCursor();
    public virtual IMessageEncoder GetEncoder(IMessageEncoderFactory encoderFactory);
}
public class MongoDB.Driver.Core.WireProtocol.Messages.ReplyMessage`1 : ResponseMessage {
    private bool _awaitCapable;
    private long _cursorId;
    private bool _cursorNotFound;
    private List`1<TDocument> _documents;
    private int _numberReturned;
    private bool _queryFailure;
    private BsonDocument _queryFailureDocument;
    private IBsonSerializer`1<TDocument> _serializer;
    private int _startingFrom;
    public bool AwaitCapable { get; }
    public long CursorId { get; }
    public bool CursorNotFound { get; }
    public List`1<TDocument> Documents { get; }
    public MongoDBMessageType MessageType { get; }
    public int NumberReturned { get; }
    public bool QueryFailure { get; }
    public BsonDocument QueryFailureDocument { get; }
    public IBsonSerializer`1<TDocument> Serializer { get; }
    public int StartingFrom { get; }
    public ReplyMessage`1(bool awaitCapable, long cursorId, bool cursorNotFound, List`1<TDocument> documents, int numberReturned, bool queryFailure, BsonDocument queryFailureDocument, int requestId, int responseTo, IBsonSerializer`1<TDocument> serializer, int startingFrom);
    public bool get_AwaitCapable();
    public long get_CursorId();
    public bool get_CursorNotFound();
    public List`1<TDocument> get_Documents();
    public virtual MongoDBMessageType get_MessageType();
    public int get_NumberReturned();
    public bool get_QueryFailure();
    public BsonDocument get_QueryFailureDocument();
    public IBsonSerializer`1<TDocument> get_Serializer();
    public int get_StartingFrom();
    public virtual IMessageEncoder GetEncoder(IMessageEncoderFactory encoderFactory);
}
public abstract class MongoDB.Driver.Core.WireProtocol.Messages.RequestMessage : MongoDBMessage {
    private static int __requestId;
    private int _requestId;
    private Func`1<bool> _shouldBeSent;
    private bool _wasSent;
    public static int CurrentGlobalRequestId { get; }
    public int RequestId { get; }
    public Func`1<bool> ShouldBeSent { get; }
    public bool WasSent { get; public set; }
    protected RequestMessage(int requestId, Func`1<bool> shouldBeSent);
    public static int get_CurrentGlobalRequestId();
    public static int GetNextRequestId();
    public int get_RequestId();
    public Func`1<bool> get_ShouldBeSent();
    public bool get_WasSent();
    public void set_WasSent(bool value);
}
public abstract class MongoDB.Driver.Core.WireProtocol.Messages.ResponseMessage : MongoDBMessage {
    private int _requestId;
    private int _responseTo;
    public MongoDBMessageType MessageType { get; }
    public int RequestId { get; }
    public int ResponseTo { get; }
    protected ResponseMessage(int requestId, int responseTo);
    public virtual MongoDBMessageType get_MessageType();
    public int get_RequestId();
    public int get_ResponseTo();
}
public abstract class MongoDB.Driver.Core.WireProtocol.Messages.Type0CommandMessageSection : CommandMessageSection {
    private object _document;
    private IBsonSerializer _documentSerializer;
    public object Document { get; }
    public IBsonSerializer DocumentSerializer { get; }
    public PayloadType PayloadType { get; }
    public Type0CommandMessageSection(object document, IBsonSerializer documentSerializer);
    public object get_Document();
    public IBsonSerializer get_DocumentSerializer();
    public virtual PayloadType get_PayloadType();
}
public class MongoDB.Driver.Core.WireProtocol.Messages.Type0CommandMessageSection`1 : Type0CommandMessageSection {
    private TDocument _document;
    private IBsonSerializer`1<TDocument> _documentSerializer;
    public TDocument Document { get; }
    public IBsonSerializer`1<TDocument> DocumentSerializer { get; }
    public Type0CommandMessageSection`1(TDocument document, IBsonSerializer`1<TDocument> documentSerializer);
    public TDocument get_Document();
    public IBsonSerializer`1<TDocument> get_DocumentSerializer();
}
public abstract class MongoDB.Driver.Core.WireProtocol.Messages.Type1CommandMessageSection : CommandMessageSection {
    private IBatchableSource`1<object> _documents;
    private IBsonSerializer _documentSerializer;
    private IElementNameValidator _elementNameValidator;
    private string _identifier;
    private Nullable`1<int> _maxBatchCount;
    private Nullable`1<int> _maxDocumentSize;
    public IBatchableSource`1<object> Documents { get; }
    public IBsonSerializer DocumentSerializer { get; }
    public Type DocumentType { get; }
    public IElementNameValidator ElementNameValidator { get; }
    public string Identifier { get; }
    public Nullable`1<int> MaxBatchCount { get; }
    public Nullable`1<int> MaxDocumentSize { get; }
    public PayloadType PayloadType { get; }
    public Type1CommandMessageSection(string identifier, IBatchableSource`1<object> documents, IBsonSerializer documentSerializer, IElementNameValidator elementNameValidator, Nullable`1<int> maxBatchCount, Nullable`1<int> maxDocumentSize);
    public IBatchableSource`1<object> get_Documents();
    public IBsonSerializer get_DocumentSerializer();
    public abstract virtual Type get_DocumentType();
    public IElementNameValidator get_ElementNameValidator();
    public string get_Identifier();
    public Nullable`1<int> get_MaxBatchCount();
    public Nullable`1<int> get_MaxDocumentSize();
    public virtual PayloadType get_PayloadType();
}
public class MongoDB.Driver.Core.WireProtocol.Messages.Type1CommandMessageSection`1 : Type1CommandMessageSection {
    private IBatchableSource`1<TDocument> _documents;
    private IBsonSerializer`1<TDocument> _documentSerializer;
    public IBatchableSource`1<TDocument> Documents { get; }
    public IBsonSerializer`1<TDocument> DocumentSerializer { get; }
    public Type DocumentType { get; }
    public Type1CommandMessageSection`1(string identifier, IBatchableSource`1<TDocument> documents, IBsonSerializer`1<TDocument> documentSerializer, IElementNameValidator elementNameValidator, Nullable`1<int> maxBatchCount, Nullable`1<int> maxDocumentSize);
    public IBatchableSource`1<TDocument> get_Documents();
    public IBsonSerializer`1<TDocument> get_DocumentSerializer();
    public virtual Type get_DocumentType();
}
internal class MongoDB.Driver.Core.WireProtocol.QueryWireProtocol`1 : object {
    private bool _awaitData;
    private int _batchSize;
    private CollectionNamespace _collectionNamespace;
    private MessageEncoderSettings _messageEncoderSettings;
    private BsonDocument _fields;
    private bool _noCursorTimeout;
    private bool _oplogReplay;
    private bool _partialOk;
    private BsonDocument _query;
    private IElementNameValidator _queryValidator;
    private IBsonSerializer`1<TDocument> _serializer;
    private int _skip;
    private bool _secondaryOk;
    private bool _tailableCursor;
    public bool MoreToCome { get; }
    public QueryWireProtocol`1(CollectionNamespace collectionNamespace, BsonDocument query, BsonDocument fields, IElementNameValidator queryValidator, int skip, int batchSize, bool secondaryOk, bool partialOk, bool noCursorTimeout, bool tailableCursor, bool awaitData, IBsonSerializer`1<TDocument> serializer, MessageEncoderSettings messageEncoderSettings);
    [ObsoleteAttribute("Use a constructor that does not have an oplogReplay parameter instead.")]
public QueryWireProtocol`1(CollectionNamespace collectionNamespace, BsonDocument query, BsonDocument fields, IElementNameValidator queryValidator, int skip, int batchSize, bool secondaryOk, bool partialOk, bool noCursorTimeout, bool oplogReplay, bool tailableCursor, bool awaitData, IBsonSerializer`1<TDocument> serializer, MessageEncoderSettings messageEncoderSettings);
    public sealed virtual bool get_MoreToCome();
    private QueryMessage CreateMessage();
    public sealed virtual CursorBatch`1<TDocument> Execute(IConnection connection, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MongoDB.Driver.Core.WireProtocol.QueryWireProtocol`1/<ExecuteAsync>d__20")]
public sealed virtual Task`1<CursorBatch`1<TDocument>> ExecuteAsync(IConnection connection, CancellationToken cancellationToken);
    private CursorBatch`1<TDocument> ProcessReply(ConnectionId connectionId, ReplyMessage`1<TDocument> reply);
}
internal abstract class MongoDB.Driver.Core.WireProtocol.WriteWireProtocolBase : object {
    private CollectionNamespace _collectionNamespace;
    private MessageEncoderSettings _messageEncoderSettings;
    private Func`1<bool> _shouldSendGetLastError;
    private WriteConcern _writeConcern;
    protected CollectionNamespace CollectionNamespace { get; }
    protected WriteConcern WriteConcern { get; }
    public bool MoreToCome { get; }
    protected WriteWireProtocolBase(CollectionNamespace collectionNamespace, MessageEncoderSettings messageEncoderSettings, WriteConcern writeConcern, Func`1<bool> shouldSendGetLastError);
    protected CollectionNamespace get_CollectionNamespace();
    protected WriteConcern get_WriteConcern();
    public sealed virtual bool get_MoreToCome();
    private BsonDocument CreateGetLastErrorCommand();
    private QueryMessage CreateGetLastErrorMessage(BsonDocument getLastErrorCommand);
    private List`1<RequestMessage> CreateMessages(IConnection connection, QueryMessage& getLastErrorMessage);
    protected abstract virtual RequestMessage CreateWriteMessage(IConnection connection);
    public sealed virtual WriteConcernResult Execute(IConnection connection, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MongoDB.Driver.Core.WireProtocol.WriteWireProtocolBase/<ExecuteAsync>d__16")]
public sealed virtual Task`1<WriteConcernResult> ExecuteAsync(IConnection connection, CancellationToken cancellationToken);
    private WriteConcernResult ProcessReply(ConnectionId connectionId, BsonDocument getLastErrorCommand, ReplyMessage`1<BsonDocument> reply);
}
internal class MongoDB.Driver.CoreServerSession : object {
    private BsonDocument _id;
    private bool _isDirty;
    private Nullable`1<DateTime> _lastUsedAt;
    private long _transactionNumber;
    public BsonDocument Id { get; }
    public bool IsDirty { get; }
    public Nullable`1<DateTime> LastUsedAt { get; }
    private static BsonDocument GenerateSessionId();
    public sealed virtual BsonDocument get_Id();
    public sealed virtual bool get_IsDirty();
    public sealed virtual Nullable`1<DateTime> get_LastUsedAt();
    public sealed virtual long AdvanceTransactionNumber();
    public sealed virtual void Dispose();
    public sealed virtual void MarkDirty();
    public sealed virtual void WasUsed();
}
internal class MongoDB.Driver.CoreServerSessionPool : object {
    private ICluster _cluster;
    private object _lock;
    private List`1<ICoreServerSession> _pool;
    public CoreServerSessionPool(ICluster cluster);
    public sealed virtual ICoreServerSession AcquireSession();
    public sealed virtual void ReleaseSession(ICoreServerSession session);
    private bool IsAboutToExpire(ICoreServerSession session);
    private bool IsAboutToExpireOrDirty(ICoreServerSession session);
}
public abstract class MongoDB.Driver.CreateIndexCommitQuorum : object {
    private static CreateIndexCommitQuorum __majority;
    private static CreateIndexCommitQuorum __votingMembers;
    public static CreateIndexCommitQuorum Majority { get; }
    public static CreateIndexCommitQuorum VotingMembers { get; }
    private static CreateIndexCommitQuorum();
    public static CreateIndexCommitQuorum get_Majority();
    public static CreateIndexCommitQuorum get_VotingMembers();
    public static CreateIndexCommitQuorum Create(string mode);
    public static CreateIndexCommitQuorum Create(int w);
    public abstract virtual BsonValue ToBsonValue();
}
public class MongoDB.Driver.CreateIndexCommitQuorumWithMode : CreateIndexCommitQuorum {
    private string _mode;
    public string Mode { get; }
    public CreateIndexCommitQuorumWithMode(string mode);
    public string get_Mode();
    public virtual BsonValue ToBsonValue();
}
public class MongoDB.Driver.CreateIndexCommitQuorumWithW : CreateIndexCommitQuorum {
    private int _w;
    public int W { get; }
    public CreateIndexCommitQuorumWithW(int w);
    public int get_W();
    public virtual BsonValue ToBsonValue();
}
public class MongoDB.Driver.DatabaseNamespace : object {
    private static DatabaseNamespace __admin;
    private string _databaseName;
    public static DatabaseNamespace Admin { get; }
    internal CollectionNamespace CommandCollection { get; }
    public string DatabaseName { get; }
    internal CollectionNamespace SystemIndexesCollection { get; }
    internal CollectionNamespace SystemNamespacesCollection { get; }
    public DatabaseNamespace(string databaseName);
    private static DatabaseNamespace();
    public static DatabaseNamespace get_Admin();
    public static bool IsValid(string name);
    internal CollectionNamespace get_CommandCollection();
    public string get_DatabaseName();
    internal CollectionNamespace get_SystemIndexesCollection();
    internal CollectionNamespace get_SystemNamespacesCollection();
    public sealed virtual bool Equals(DatabaseNamespace other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class MongoDB.Driver.DeferredAsyncCursor`1 : object {
    private Func`2<CancellationToken, IAsyncCursor`1<TDocument>> _execute;
    private Func`2<CancellationToken, Task`1<IAsyncCursor`1<TDocument>>> _executeAsync;
    private IAsyncCursor`1<TDocument> _cursor;
    private Action _disposeAction;
    private bool _disposed;
    public IEnumerable`1<TDocument> Current { get; }
    public DeferredAsyncCursor`1(Action disposeAction, Func`2<CancellationToken, IAsyncCursor`1<TDocument>> execute, Func`2<CancellationToken, Task`1<IAsyncCursor`1<TDocument>>> executeAsync);
    public sealed virtual IEnumerable`1<TDocument> get_Current();
    public sealed virtual bool MoveNext(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MongoDB.Driver.DeferredAsyncCursor`1/<MoveNextAsync>d__9")]
public sealed virtual Task`1<bool> MoveNextAsync(CancellationToken cancellationToken);
    public sealed virtual void Dispose();
    private void ThrowIfDisposed();
}
public enum MongoDB.Driver.DocumentValidationAction : Enum {
    public int value__;
    public static DocumentValidationAction Error;
    public static DocumentValidationAction Warn;
}
public enum MongoDB.Driver.DocumentValidationLevel : Enum {
    public int value__;
    public static DocumentValidationLevel Strict;
    public static DocumentValidationLevel Moderate;
    public static DocumentValidationLevel Off;
}
internal static class MongoDB.Driver.Encryption.EncryptedCollectionHelper : object {
    [CompilerGeneratedAttribute]
private static BsonDocument <AdditionalCreateIndexDocument>k__BackingField;
    public static BsonDocument AdditionalCreateIndexDocument { get; }
    private static EncryptedCollectionHelper();
    [CompilerGeneratedAttribute]
public static BsonDocument get_AdditionalCreateIndexDocument();
    public static void EnsureCollectionsValid(IReadOnlyDictionary`2<string, BsonDocument> schemaMap, IReadOnlyDictionary`2<string, BsonDocument> encryptedFieldsMap);
    public static string GetAdditionalCollectionName(BsonDocument encryptedFields, CollectionNamespace mainCollectionNamespace, HelperCollectionForEncryption helperCollection);
    public static bool TryGetEffectiveEncryptedFields(CollectionNamespace collectionNamespace, BsonDocument encryptedFields, IReadOnlyDictionary`2<string, BsonDocument> encryptedFieldsMap, BsonDocument& effectiveEncryptedFields);
    public static BsonDocument GetEffectiveEncryptedFields(CollectionNamespace collectionNamespace, BsonDocument encryptedFields, IReadOnlyDictionary`2<string, BsonDocument> encryptedFieldsMap);
    [IteratorStateMachineAttribute("MongoDB.Driver.Encryption.EncryptedCollectionHelper/<IterateEmptyKeyIds>d__7")]
public static IEnumerable`1<BsonDocument> IterateEmptyKeyIds(CollectionNamespace collectionNamespace, BsonDocument encryptedFields);
    public static void ModifyEncryptedFields(BsonDocument fieldDocument, Guid dataKey);
}
public interface MongoDB.Driver.IAsyncCursor`1 {
    public IEnumerable`1<TDocument> Current { get; }
    public abstract virtual IEnumerable`1<TDocument> get_Current();
    public abstract virtual bool MoveNext(CancellationToken cancellationToken);
    public abstract virtual Task`1<bool> MoveNextAsync(CancellationToken cancellationToken);
}
[ExtensionAttribute]
public static class MongoDB.Driver.IAsyncCursorExtensions : object {
    [ExtensionAttribute]
public static bool Any(IAsyncCursor`1<TDocument> cursor, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MongoDB.Driver.IAsyncCursorExtensions/<AnyAsync>d__1`1")]
[ExtensionAttribute]
public static Task`1<bool> AnyAsync(IAsyncCursor`1<TDocument> cursor, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static TDocument First(IAsyncCursor`1<TDocument> cursor, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MongoDB.Driver.IAsyncCursorExtensions/<FirstAsync>d__3`1")]
[ExtensionAttribute]
public static Task`1<TDocument> FirstAsync(IAsyncCursor`1<TDocument> cursor, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static TDocument FirstOrDefault(IAsyncCursor`1<TDocument> cursor, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MongoDB.Driver.IAsyncCursorExtensions/<FirstOrDefaultAsync>d__5`1")]
[ExtensionAttribute]
public static Task`1<TDocument> FirstOrDefaultAsync(IAsyncCursor`1<TDocument> cursor, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task ForEachAsync(IAsyncCursor`1<TDocument> source, Func`2<TDocument, Task> processor, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MongoDB.Driver.IAsyncCursorExtensions/<ForEachAsync>d__7`1")]
[ExtensionAttribute]
public static Task ForEachAsync(IAsyncCursor`1<TDocument> source, Func`3<TDocument, int, Task> processor, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task ForEachAsync(IAsyncCursor`1<TDocument> source, Action`1<TDocument> processor, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MongoDB.Driver.IAsyncCursorExtensions/<ForEachAsync>d__9`1")]
[ExtensionAttribute]
public static Task ForEachAsync(IAsyncCursor`1<TDocument> source, Action`2<TDocument, int> processor, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static TDocument Single(IAsyncCursor`1<TDocument> cursor, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MongoDB.Driver.IAsyncCursorExtensions/<SingleAsync>d__11`1")]
[ExtensionAttribute]
public static Task`1<TDocument> SingleAsync(IAsyncCursor`1<TDocument> cursor, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static TDocument SingleOrDefault(IAsyncCursor`1<TDocument> cursor, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MongoDB.Driver.IAsyncCursorExtensions/<SingleOrDefaultAsync>d__13`1")]
[ExtensionAttribute]
public static Task`1<TDocument> SingleOrDefaultAsync(IAsyncCursor`1<TDocument> cursor, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static IEnumerable`1<TDocument> ToEnumerable(IAsyncCursor`1<TDocument> cursor, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static List`1<TDocument> ToList(IAsyncCursor`1<TDocument> source, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MongoDB.Driver.IAsyncCursorExtensions/<ToListAsync>d__16`1")]
[ExtensionAttribute]
public static Task`1<List`1<TDocument>> ToListAsync(IAsyncCursor`1<TDocument> source, CancellationToken cancellationToken);
    private static IEnumerable`1<TDocument> GetFirstBatch(IAsyncCursor`1<TDocument> cursor, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MongoDB.Driver.IAsyncCursorExtensions/<GetFirstBatchAsync>d__18`1")]
private static Task`1<IEnumerable`1<TDocument>> GetFirstBatchAsync(IAsyncCursor`1<TDocument> cursor, CancellationToken cancellationToken);
}
public interface MongoDB.Driver.IAsyncCursorSource`1 {
    public abstract virtual IAsyncCursor`1<TDocument> ToCursor(CancellationToken cancellationToken);
    public abstract virtual Task`1<IAsyncCursor`1<TDocument>> ToCursorAsync(CancellationToken cancellationToken);
}
[ExtensionAttribute]
public static class MongoDB.Driver.IAsyncCursorSourceExtensions : object {
    [ExtensionAttribute]
public static bool Any(IAsyncCursorSource`1<TDocument> source, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MongoDB.Driver.IAsyncCursorSourceExtensions/<AnyAsync>d__1`1")]
[ExtensionAttribute]
public static Task`1<bool> AnyAsync(IAsyncCursorSource`1<TDocument> source, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static TDocument First(IAsyncCursorSource`1<TDocument> source, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MongoDB.Driver.IAsyncCursorSourceExtensions/<FirstAsync>d__3`1")]
[ExtensionAttribute]
public static Task`1<TDocument> FirstAsync(IAsyncCursorSource`1<TDocument> source, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static TDocument FirstOrDefault(IAsyncCursorSource`1<TDocument> source, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MongoDB.Driver.IAsyncCursorSourceExtensions/<FirstOrDefaultAsync>d__5`1")]
[ExtensionAttribute]
public static Task`1<TDocument> FirstOrDefaultAsync(IAsyncCursorSource`1<TDocument> source, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MongoDB.Driver.IAsyncCursorSourceExtensions/<ForEachAsync>d__6`1")]
[ExtensionAttribute]
public static Task ForEachAsync(IAsyncCursorSource`1<TDocument> source, Func`2<TDocument, Task> processor, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MongoDB.Driver.IAsyncCursorSourceExtensions/<ForEachAsync>d__7`1")]
[ExtensionAttribute]
public static Task ForEachAsync(IAsyncCursorSource`1<TDocument> source, Func`3<TDocument, int, Task> processor, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MongoDB.Driver.IAsyncCursorSourceExtensions/<ForEachAsync>d__8`1")]
[ExtensionAttribute]
public static Task ForEachAsync(IAsyncCursorSource`1<TDocument> source, Action`1<TDocument> processor, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MongoDB.Driver.IAsyncCursorSourceExtensions/<ForEachAsync>d__9`1")]
[ExtensionAttribute]
public static Task ForEachAsync(IAsyncCursorSource`1<TDocument> source, Action`2<TDocument, int> processor, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static TDocument Single(IAsyncCursorSource`1<TDocument> source, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MongoDB.Driver.IAsyncCursorSourceExtensions/<SingleAsync>d__11`1")]
[ExtensionAttribute]
public static Task`1<TDocument> SingleAsync(IAsyncCursorSource`1<TDocument> source, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static TDocument SingleOrDefault(IAsyncCursorSource`1<TDocument> source, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MongoDB.Driver.IAsyncCursorSourceExtensions/<SingleOrDefaultAsync>d__13`1")]
[ExtensionAttribute]
public static Task`1<TDocument> SingleOrDefaultAsync(IAsyncCursorSource`1<TDocument> source, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static IEnumerable`1<TDocument> ToEnumerable(IAsyncCursorSource`1<TDocument> source, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static List`1<TDocument> ToList(IAsyncCursorSource`1<TDocument> source, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MongoDB.Driver.IAsyncCursorSourceExtensions/<ToListAsync>d__16`1")]
[ExtensionAttribute]
public static Task`1<List`1<TDocument>> ToListAsync(IAsyncCursorSource`1<TDocument> source, CancellationToken cancellationToken);
}
public interface MongoDB.Driver.IChangeStreamCursor`1 {
    public abstract virtual BsonDocument GetResumeToken();
}
public interface MongoDB.Driver.ICoreServerSession {
    public BsonDocument Id { get; }
    public bool IsDirty { get; }
    public Nullable`1<DateTime> LastUsedAt { get; }
    public abstract virtual BsonDocument get_Id();
    public abstract virtual bool get_IsDirty();
    public abstract virtual Nullable`1<DateTime> get_LastUsedAt();
    public abstract virtual long AdvanceTransactionNumber();
    public abstract virtual void MarkDirty();
    public abstract virtual void WasUsed();
}
internal interface MongoDB.Driver.ICoreServerSessionPool {
    public abstract virtual ICoreServerSession AcquireSession();
    public abstract virtual void ReleaseSession(ICoreServerSession serverSession);
}
internal interface MongoDB.Driver.ICursorBatchInfo {
    public BsonDocument PostBatchResumeToken { get; }
    public bool WasFirstBatchEmpty { get; }
    public abstract virtual BsonDocument get_PostBatchResumeToken();
    public abstract virtual bool get_WasFirstBatchEmpty();
}
internal interface MongoDB.Driver.IMongoQueryableForwarder`1 {
    public abstract virtual Task`1<bool> AnyAsync(CancellationToken cancellationToken);
    public abstract virtual Task`1<T> FirstAsync(CancellationToken cancellationToken);
    public abstract virtual Task`1<T> FirstOrDefaultAsync(CancellationToken cancellationToken);
    public abstract virtual Task`1<T> SingleAsync(CancellationToken cancellationToken);
    public abstract virtual Task`1<T> SingleOrDefaultAsync(CancellationToken cancellationToken);
}
public class MongoDB.Driver.MongoAuthenticationException : MongoConnectionException {
    public bool IsNetworkException { get; }
    public MongoAuthenticationException(ConnectionId connectionId, string message);
    public MongoAuthenticationException(ConnectionId connectionId, string message, Exception innerException);
    public MongoAuthenticationException(SerializationInfo info, StreamingContext context);
    public virtual bool get_IsNetworkException();
}
public class MongoDB.Driver.MongoClientException : MongoException {
    public MongoClientException(string message);
    public MongoClientException(string message, Exception innerException);
    public MongoClientException(SerializationInfo info, StreamingContext context);
}
public class MongoDB.Driver.MongoCommandException : MongoServerException {
    private BsonDocument _command;
    private BsonDocument _result;
    public int Code { get; }
    public string CodeName { get; }
    public BsonDocument Command { get; }
    public string ErrorMessage { get; }
    public BsonDocument Result { get; }
    public MongoCommandException(ConnectionId connectionId, string message, BsonDocument command);
    public MongoCommandException(ConnectionId connectionId, string message, BsonDocument command, BsonDocument result);
    public MongoCommandException(ConnectionId connectionId, string message, BsonDocument command, BsonDocument result, Exception innerException);
    protected MongoCommandException(SerializationInfo info, StreamingContext context);
    public int get_Code();
    public string get_CodeName();
    public BsonDocument get_Command();
    public string get_ErrorMessage();
    public BsonDocument get_Result();
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
public class MongoDB.Driver.MongoConfigurationException : MongoClientException {
    public MongoConfigurationException(string message);
    public MongoConfigurationException(string message, Exception innerException);
    protected MongoConfigurationException(SerializationInfo info, StreamingContext context);
}
public class MongoDB.Driver.MongoConnectionClosedException : MongoConnectionException {
    public bool IsNetworkException { get; }
    public MongoConnectionClosedException(ConnectionId connectionId);
    protected MongoConnectionClosedException(SerializationInfo info, StreamingContext context);
    public virtual bool get_IsNetworkException();
}
public class MongoDB.Driver.MongoConnectionException : MongoException {
    private ConnectionId _connectionId;
    private Nullable`1<int> _generation;
    private Nullable`1<ObjectId> _serviceId;
    public ConnectionId ConnectionId { get; }
    [ObsoleteAttribute("Use ContainsTimeoutException instead.")]
public bool ContainsSocketTimeoutException { get; }
    public bool ContainsTimeoutException { get; }
    public bool IsNetworkException { get; }
    internal Nullable`1<int> Generation { get; internal set; }
    internal Nullable`1<ObjectId> ServiceId { get; internal set; }
    public MongoConnectionException(ConnectionId connectionId, string message);
    public MongoConnectionException(ConnectionId connectionId, string message, Exception innerException);
    public MongoConnectionException(SerializationInfo info, StreamingContext context);
    public ConnectionId get_ConnectionId();
    public bool get_ContainsSocketTimeoutException();
    public bool get_ContainsTimeoutException();
    public virtual bool get_IsNetworkException();
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    internal Nullable`1<int> get_Generation();
    internal void set_Generation(Nullable`1<int> value);
    internal Nullable`1<ObjectId> get_ServiceId();
    internal void set_ServiceId(Nullable`1<ObjectId> value);
}
public class MongoDB.Driver.MongoConnectionPoolPausedException : MongoClientException {
    public MongoConnectionPoolPausedException(string message);
    protected MongoConnectionPoolPausedException(SerializationInfo info, StreamingContext context);
    internal static MongoConnectionPoolPausedException ForConnectionPool(string poolIdentifier);
    internal static MongoConnectionPoolPausedException ForConnectionPool(EndPoint endPoint);
}
public class MongoDB.Driver.MongoCursorNotFoundException : MongoQueryException {
    private long _cursorId;
    public long CursorId { get; }
    public MongoCursorNotFoundException(ConnectionId connectionId, long cursorId, BsonDocument query);
    protected MongoCursorNotFoundException(SerializationInfo info, StreamingContext context);
    private static string FormatMessage(ConnectionId connectionId, long cursorId);
    public long get_CursorId();
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
public class MongoDB.Driver.MongoDuplicateKeyException : MongoWriteConcernException {
    public MongoDuplicateKeyException(ConnectionId connectionId, string message, WriteConcernResult commandResult);
    public MongoDuplicateKeyException(SerializationInfo info, StreamingContext context);
}
public class MongoDB.Driver.MongoException : Exception {
    private List`1<string> _errorLabels;
    public IReadOnlyList`1<string> ErrorLabels { get; }
    public MongoException(string message);
    public MongoException(string message, Exception innerException);
    public MongoException(SerializationInfo info, StreamingContext context);
    public IReadOnlyList`1<string> get_ErrorLabels();
    public void AddErrorLabel(string errorLabel);
    public bool HasErrorLabel(string errorLabel);
    public void RemoveErrorLabel(string errorLabel);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
public class MongoDB.Driver.MongoExecutionTimeoutException : MongoServerException {
    private BsonDocument _result;
    public int Code { get; }
    public string CodeName { get; }
    public MongoExecutionTimeoutException(ConnectionId connectionId, string message);
    public MongoExecutionTimeoutException(ConnectionId connectionId, string message, Exception innerException);
    public MongoExecutionTimeoutException(ConnectionId connectionId, string message, BsonDocument result);
    public MongoExecutionTimeoutException(ConnectionId connectionId, string message, Exception innerException, BsonDocument result);
    public MongoExecutionTimeoutException(SerializationInfo info, StreamingContext context);
    public int get_Code();
    public string get_CodeName();
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
public class MongoDB.Driver.MongoIncompatibleDriverException : MongoClientException {
    public MongoIncompatibleDriverException(ClusterDescription clusterDescription);
    protected MongoIncompatibleDriverException(SerializationInfo info, StreamingContext context);
    internal static void ThrowIfNotSupported(ClusterDescription description);
    private static string FormatMessage(ClusterDescription description);
    private static bool IsServerIncompatible(ServerDescription description);
}
internal static class MongoDB.Driver.MongoInternalDefaults : object {
}
public class MongoDB.Driver.MongoInternalException : MongoException {
    public MongoInternalException(string message);
    public MongoInternalException(string message, Exception innerException);
    public MongoInternalException(SerializationInfo info, StreamingContext context);
}
public class MongoDB.Driver.MongoNodeIsRecoveringException : MongoCommandException {
    public bool IsShutdownError { get; }
    public MongoNodeIsRecoveringException(ConnectionId connectionId, BsonDocument command, BsonDocument result);
    protected MongoNodeIsRecoveringException(SerializationInfo info, StreamingContext context);
    private static string CreateMessage(BsonDocument result);
    public bool get_IsShutdownError();
}
public class MongoDB.Driver.MongoNotPrimaryException : MongoCommandException {
    public MongoNotPrimaryException(ConnectionId connectionId, BsonDocument command, BsonDocument result);
    protected MongoNotPrimaryException(SerializationInfo info, StreamingContext context);
}
public class MongoDB.Driver.MongoQueryException : MongoServerException {
    private BsonDocument _query;
    private BsonDocument _queryResult;
    public BsonDocument Query { get; }
    public BsonDocument QueryResult { get; }
    public MongoQueryException(ConnectionId connectionId, string message, BsonDocument query, BsonDocument queryResult);
    protected MongoQueryException(SerializationInfo info, StreamingContext context);
    public BsonDocument get_Query();
    public BsonDocument get_QueryResult();
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
public class MongoDB.Driver.MongoServerException : MongoException {
    private ConnectionId _connectionId;
    public ConnectionId ConnectionId { get; }
    public MongoServerException(ConnectionId connectionId, string message);
    public MongoServerException(ConnectionId connectionId, string message, Exception innerException);
    public MongoServerException(SerializationInfo info, StreamingContext context);
    protected static void AddErrorLabelsFromCommandResult(MongoServerException exception, BsonDocument result);
    public ConnectionId get_ConnectionId();
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
public class MongoDB.Driver.MongoWaitQueueFullException : MongoClientException {
    public MongoWaitQueueFullException(string message);
    protected MongoWaitQueueFullException(SerializationInfo info, StreamingContext context);
    internal static MongoWaitQueueFullException ForConnectionPool(EndPoint endPoint);
    internal static MongoWaitQueueFullException ForServerSelection();
}
public class MongoDB.Driver.MongoWriteConcernException : MongoCommandException {
    private Exception _writeConcernResultException;
    private WriteConcernResult _writeConcernResult;
    public Exception MappedWriteConcernResultException { get; }
    public WriteConcernResult WriteConcernResult { get; }
    public MongoWriteConcernException(ConnectionId connectionId, string message, WriteConcernResult writeConcernResult);
    public MongoWriteConcernException(SerializationInfo info, StreamingContext context);
    private static void AddErrorLabelsFromWriteConcernResult(MongoWriteConcernException exception, WriteConcernResult writeConcernResult);
    private static bool TryMapWriteConcernResultToException(ConnectionId connectionId, WriteConcernResult writeConcernResult, Exception& mappedException);
    public Exception get_MappedWriteConcernResultException();
    public WriteConcernResult get_WriteConcernResult();
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public bool IsWriteConcernErrorOnly();
}
public static class MongoDB.Driver.Optional : object {
    public static Optional`1<T> Create(T value);
    public static Optional`1<IEnumerable`1<TItem>> Enumerable(IEnumerable`1<TItem> value);
}
public class MongoDB.Driver.Optional`1 : ValueType {
    private bool _hasValue;
    private T _value;
    public bool HasValue { get; }
    public T Value { get; }
    public Optional`1(T value);
    public bool get_HasValue();
    public T get_Value();
    public static Optional`1<T> op_Implicit(T value);
    public bool Replaces(T value);
    public T WithDefault(T value);
}
public class MongoDB.Driver.ReadConcern : object {
    private static ReadConcern __available;
    private static ReadConcern __default;
    private static ReadConcern __linearizable;
    private static ReadConcern __local;
    private static ReadConcern __majority;
    private static ReadConcern __snapshot;
    private Nullable`1<ReadConcernLevel> _level;
    public static ReadConcern Available { get; }
    public static ReadConcern Default { get; }
    public static ReadConcern Linearizable { get; }
    public static ReadConcern Local { get; }
    public static ReadConcern Majority { get; }
    public static ReadConcern Snapshot { get; }
    public bool IsServerDefault { get; }
    public Nullable`1<ReadConcernLevel> Level { get; }
    public ReadConcern(Optional`1<Nullable`1<ReadConcernLevel>> level);
    private static ReadConcern();
    public static ReadConcern get_Available();
    public static ReadConcern get_Default();
    public static ReadConcern get_Linearizable();
    public static ReadConcern get_Local();
    public static ReadConcern get_Majority();
    public static ReadConcern get_Snapshot();
    public static ReadConcern FromBsonDocument(BsonDocument document);
    public bool get_IsServerDefault();
    public Nullable`1<ReadConcernLevel> get_Level();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ReadConcern other);
    public virtual int GetHashCode();
    public sealed virtual BsonDocument ToBsonDocument();
    public virtual string ToString();
    public ReadConcern With(Optional`1<Nullable`1<ReadConcernLevel>> level);
}
public enum MongoDB.Driver.ReadConcernLevel : Enum {
    public int value__;
    public static ReadConcernLevel Available;
    public static ReadConcernLevel Local;
    public static ReadConcernLevel Majority;
    public static ReadConcernLevel Linearizable;
    public static ReadConcernLevel Snapshot;
}
public class MongoDB.Driver.ReadPreference : object {
    private static TagSet[] __emptyTagSetsArray;
    private static ReadPreference __nearest;
    private static ReadPreference __primary;
    private static ReadPreference __primaryPreferred;
    private static ReadPreference __secondary;
    private static ReadPreference __secondaryPreferred;
    private ReadPreferenceHedge _hedge;
    private Nullable`1<TimeSpan> _maxStaleness;
    private ReadPreferenceMode _mode;
    private IReadOnlyList`1<TagSet> _tagSets;
    public static ReadPreference Nearest { get; }
    public static ReadPreference Primary { get; }
    public static ReadPreference PrimaryPreferred { get; }
    public static ReadPreference Secondary { get; }
    public static ReadPreference SecondaryPreferred { get; }
    public ReadPreferenceHedge Hedge { get; }
    public Nullable`1<TimeSpan> MaxStaleness { get; }
    public ReadPreferenceMode ReadPreferenceMode { get; }
    public IReadOnlyList`1<TagSet> TagSets { get; }
    public ReadPreference(ReadPreferenceMode mode, IEnumerable`1<TagSet> tagSets, Nullable`1<TimeSpan> maxStaleness, ReadPreferenceHedge hedge);
    private static ReadPreference();
    public static ReadPreference get_Nearest();
    public static ReadPreference get_Primary();
    public static ReadPreference get_PrimaryPreferred();
    public static ReadPreference get_Secondary();
    public static ReadPreference get_SecondaryPreferred();
    public static ReadPreference FromBsonDocument(BsonDocument document);
    public ReadPreferenceHedge get_Hedge();
    public Nullable`1<TimeSpan> get_MaxStaleness();
    public ReadPreferenceMode get_ReadPreferenceMode();
    public IReadOnlyList`1<TagSet> get_TagSets();
    public sealed virtual bool Equals(ReadPreference other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public ReadPreference With(ReadPreferenceHedge hedge);
    public ReadPreference With(ReadPreferenceMode mode);
    public ReadPreference With(IEnumerable`1<TagSet> tagSets);
    public ReadPreference With(Nullable`1<TimeSpan> maxStaleness);
}
public class MongoDB.Driver.ReadPreferenceHedge : object {
    private static ReadPreferenceHedge __disabled;
    private static ReadPreferenceHedge __enabled;
    private bool _isEnabled;
    public static ReadPreferenceHedge Disabled { get; }
    public static ReadPreferenceHedge Enabled { get; }
    public bool IsEnabled { get; }
    public ReadPreferenceHedge(bool isEnabled);
    private static ReadPreferenceHedge();
    public static ReadPreferenceHedge get_Disabled();
    public static ReadPreferenceHedge get_Enabled();
    public bool get_IsEnabled();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ReadPreferenceHedge other);
    public virtual int GetHashCode();
    public BsonDocument ToBsonDocument();
    public virtual string ToString();
}
public enum MongoDB.Driver.ReadPreferenceMode : Enum {
    public int value__;
    public static ReadPreferenceMode Primary;
    public static ReadPreferenceMode PrimaryPreferred;
    public static ReadPreferenceMode Secondary;
    public static ReadPreferenceMode SecondaryPreferred;
    public static ReadPreferenceMode Nearest;
}
public class MongoDB.Driver.ServerApi : object {
    private Nullable`1<bool> _deprecationErrors;
    private Nullable`1<bool> _strict;
    private ServerApiVersion _version;
    public Nullable`1<bool> DeprecationErrors { get; }
    public Nullable`1<bool> Strict { get; }
    public ServerApiVersion Version { get; }
    public ServerApi(ServerApiVersion version, Optional`1<Nullable`1<bool>> strict, Optional`1<Nullable`1<bool>> deprecationErrors);
    public static bool op_Inequality(ServerApi lhs, ServerApi rhs);
    public static bool op_Equality(ServerApi lhs, ServerApi rhs);
    public Nullable`1<bool> get_DeprecationErrors();
    public Nullable`1<bool> get_Strict();
    public ServerApiVersion get_Version();
    public sealed virtual bool Equals(ServerApi other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class MongoDB.Driver.ServerApiVersion : object {
    private static ServerApiVersion __v1;
    private string _versionString;
    public static ServerApiVersion V1 { get; }
    internal ServerApiVersion(string versionString);
    private static ServerApiVersion();
    public static ServerApiVersion get_V1();
    public static bool op_Inequality(ServerApiVersion lhs, ServerApiVersion rhs);
    public static bool op_Equality(ServerApiVersion lhs, ServerApiVersion rhs);
    public sealed virtual bool Equals(ServerApiVersion other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public enum MongoDB.Driver.ServerErrorCategory : Enum {
    public int value__;
    public static ServerErrorCategory Uncategorized;
    public static ServerErrorCategory DuplicateKey;
    public static ServerErrorCategory ExecutionTimeout;
}
internal enum MongoDB.Driver.ServerErrorCode : Enum {
    public int value__;
    public static ServerErrorCode AuthenticationFailed;
    public static ServerErrorCode CappedPositionLost;
    public static ServerErrorCode CommandNotFound;
    public static ServerErrorCode CursorKilled;
    public static ServerErrorCode CursorNotFound;
    public static ServerErrorCode ElectionInProgress;
    public static ServerErrorCode ExceededTimeLimit;
    public static ServerErrorCode FailedToSatisfyReadPreference;
    public static ServerErrorCode HostNotFound;
    public static ServerErrorCode HostUnreachable;
    public static ServerErrorCode DuplicateKey;
    public static ServerErrorCode IllegalOperation;
    public static ServerErrorCode Interrupted;
    public static ServerErrorCode InterruptedAtShutdown;
    public static ServerErrorCode InterruptedDueToReplStateChange;
    public static ServerErrorCode LegacyNotPrimary;
    public static ServerErrorCode MaxTimeMSExpired;
    public static ServerErrorCode NamespaceNotFound;
    public static ServerErrorCode NetworkTimeout;
    public static ServerErrorCode NotWritablePrimary;
    public static ServerErrorCode NotPrimaryNoSecondaryOk;
    public static ServerErrorCode NotPrimaryOrSecondary;
    public static ServerErrorCode PrimarySteppedDown;
    public static ServerErrorCode ReadConcernMajorityNotAvailableYet;
    public static ServerErrorCode ReauthenticationRequired;
    public static ServerErrorCode RetryChangeStream;
    public static ServerErrorCode ShutdownInProgress;
    public static ServerErrorCode SocketException;
    public static ServerErrorCode StaleConfig;
    public static ServerErrorCode StaleEpoch;
    public static ServerErrorCode StaleShardVersion;
    public static ServerErrorCode Unauthorized;
    public static ServerErrorCode UnauthorizedServerless;
    public static ServerErrorCode UnknownReplWriteConcern;
    public static ServerErrorCode UnsatisfiableWriteConcern;
    public static ServerErrorCode WriteConcernFailed;
}
internal class MongoDB.Driver.SingleBatchAsyncCursor`1 : object {
    private bool _disposed;
    private bool _moved;
    private IReadOnlyList`1<T> _current;
    public IEnumerable`1<T> Current { get; }
    public SingleBatchAsyncCursor`1(IReadOnlyList`1<T> current);
    public sealed virtual IEnumerable`1<T> get_Current();
    public sealed virtual bool MoveNext(CancellationToken cancellationToken);
    public sealed virtual Task`1<bool> MoveNextAsync(CancellationToken cancellationToken);
    public sealed virtual void Dispose();
    private void ThrowIfDisposed();
}
public class MongoDB.Driver.Tag : object {
    private string _name;
    private string _value;
    public string Name { get; }
    public string Value { get; }
    public Tag(string name, string value);
    public string get_Name();
    public string get_Value();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(Tag other);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class MongoDB.Driver.TagSet : object {
    private IReadOnlyList`1<Tag> _tags;
    public bool IsEmpty { get; }
    public IReadOnlyList`1<Tag> Tags { get; }
    public TagSet(IEnumerable`1<Tag> tags);
    public bool get_IsEmpty();
    public IReadOnlyList`1<Tag> get_Tags();
    public bool ContainsAll(TagSet required);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(TagSet other);
    public virtual int GetHashCode();
    public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool <ContainsAll>b__7_0(Tag t);
}
public enum MongoDB.Driver.TimeSeriesGranularity : Enum {
    public int value__;
    public static TimeSeriesGranularity Seconds;
    public static TimeSeriesGranularity Minutes;
    public static TimeSeriesGranularity Hours;
}
public class MongoDB.Driver.TimeSeriesOptions : object {
    private Nullable`1<TimeSeriesGranularity> _granularity;
    private string _metaField;
    private string _timeField;
    private Nullable`1<int> _bucketMaxSpanSeconds;
    private Nullable`1<int> _bucketRoundingSeconds;
    public Nullable`1<TimeSeriesGranularity> Granularity { get; }
    public string MetaField { get; }
    public string TimeField { get; }
    public Nullable`1<int> BucketMaxSpanSeconds { get; }
    public Nullable`1<int> BucketRoundingSeconds { get; }
    public TimeSeriesOptions(string timeField, Optional`1<string> metaField, Optional`1<Nullable`1<TimeSeriesGranularity>> granularity, Optional`1<Nullable`1<int>> bucketMaxSpanSeconds, Optional`1<Nullable`1<int>> bucketRoundingSeconds);
    public Nullable`1<TimeSeriesGranularity> get_Granularity();
    public string get_MetaField();
    public string get_TimeField();
    public Nullable`1<int> get_BucketMaxSpanSeconds();
    public Nullable`1<int> get_BucketRoundingSeconds();
    public BsonDocument ToBsonDocument();
    [CompilerGeneratedAttribute]
private BsonValue <ToBsonDocument>b__16_0();
}
public class MongoDB.Driver.TransactionOptions : object {
    private Nullable`1<TimeSpan> _maxCommitTime;
    private ReadConcern _readConcern;
    private ReadPreference _readPreference;
    private WriteConcern _writeConcern;
    public Nullable`1<TimeSpan> MaxCommitTime { get; }
    public ReadConcern ReadConcern { get; }
    public ReadPreference ReadPreference { get; }
    public WriteConcern WriteConcern { get; }
    public TransactionOptions(Optional`1<ReadConcern> readConcern, Optional`1<ReadPreference> readPreference, Optional`1<WriteConcern> writeConcern, Optional`1<Nullable`1<TimeSpan>> maxCommitTime);
    public Nullable`1<TimeSpan> get_MaxCommitTime();
    public ReadConcern get_ReadConcern();
    public ReadPreference get_ReadPreference();
    public WriteConcern get_WriteConcern();
    public TransactionOptions With(Optional`1<ReadConcern> readConcern, Optional`1<ReadPreference> readPreference, Optional`1<WriteConcern> writeConcern, Optional`1<Nullable`1<TimeSpan>> maxCommitTime);
}
internal abstract class MongoDB.Driver.WrappingCoreServerSession : object {
    protected bool _disposed;
    private bool _ownsWrapped;
    private ICoreServerSession _wrapped;
    public BsonDocument Id { get; }
    public bool IsDirty { get; }
    public Nullable`1<DateTime> LastUsedAt { get; }
    public ICoreServerSession Wrapped { get; }
    public WrappingCoreServerSession(ICoreServerSession wrapped, bool ownsWrapped);
    public sealed virtual BsonDocument get_Id();
    public sealed virtual bool get_IsDirty();
    public sealed virtual Nullable`1<DateTime> get_LastUsedAt();
    public ICoreServerSession get_Wrapped();
    public sealed virtual long AdvanceTransactionNumber();
    public sealed virtual void Dispose();
    public sealed virtual void MarkDirty();
    public sealed virtual void WasUsed();
    protected virtual void Dispose(bool disposing);
    protected void ThrowIfDisposed();
}
public class MongoDB.Driver.WriteConcern : object {
    private static WriteConcern __acknowledged;
    private static WriteConcern __unacknowledged;
    private static WriteConcern __w1;
    private static WriteConcern __w2;
    private static WriteConcern __w3;
    private static WriteConcern __wMajority;
    private Nullable`1<bool> _fsync;
    private Nullable`1<bool> _journal;
    private WValue _w;
    private Nullable`1<TimeSpan> _wTimeout;
    public static WriteConcern Acknowledged { get; }
    public static WriteConcern Unacknowledged { get; }
    public static WriteConcern W1 { get; }
    public static WriteConcern W2 { get; }
    public static WriteConcern W3 { get; }
    public static WriteConcern WMajority { get; }
    public Nullable`1<bool> FSync { get; }
    public bool IsAcknowledged { get; }
    public bool IsServerDefault { get; }
    public Nullable`1<bool> Journal { get; }
    public WValue W { get; }
    public Nullable`1<TimeSpan> WTimeout { get; }
    public WriteConcern(int w, Optional`1<Nullable`1<TimeSpan>> wTimeout, Optional`1<Nullable`1<bool>> fsync, Optional`1<Nullable`1<bool>> journal);
    public WriteConcern(string mode, Optional`1<Nullable`1<TimeSpan>> wTimeout, Optional`1<Nullable`1<bool>> fsync, Optional`1<Nullable`1<bool>> journal);
    public WriteConcern(Optional`1<WValue> w, Optional`1<Nullable`1<TimeSpan>> wTimeout, Optional`1<Nullable`1<bool>> fsync, Optional`1<Nullable`1<bool>> journal);
    private static WriteConcern();
    public static WriteConcern get_Acknowledged();
    public static WriteConcern get_Unacknowledged();
    public static WriteConcern get_W1();
    public static WriteConcern get_W2();
    public static WriteConcern get_W3();
    public static WriteConcern get_WMajority();
    public static WriteConcern FromBsonDocument(BsonDocument document);
    public Nullable`1<bool> get_FSync();
    public bool get_IsAcknowledged();
    public bool get_IsServerDefault();
    public Nullable`1<bool> get_Journal();
    public WValue get_W();
    public Nullable`1<TimeSpan> get_WTimeout();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(WriteConcern other);
    public virtual int GetHashCode();
    public sealed virtual BsonDocument ToBsonDocument();
    public virtual string ToString();
    public WriteConcern With(int w, Optional`1<Nullable`1<TimeSpan>> wTimeout, Optional`1<Nullable`1<bool>> fsync, Optional`1<Nullable`1<bool>> journal);
    public WriteConcern With(string mode, Optional`1<Nullable`1<TimeSpan>> wTimeout, Optional`1<Nullable`1<bool>> fsync, Optional`1<Nullable`1<bool>> journal);
    public WriteConcern With(Optional`1<WValue> w, Optional`1<Nullable`1<TimeSpan>> wTimeout, Optional`1<Nullable`1<bool>> fsync, Optional`1<Nullable`1<bool>> journal);
    [CompilerGeneratedAttribute]
private BsonValue <ToBsonDocument>b__41_0();
    [CompilerGeneratedAttribute]
private BsonValue <ToBsonDocument>b__41_1();
    [CompilerGeneratedAttribute]
private BsonValue <ToBsonDocument>b__41_2();
    [CompilerGeneratedAttribute]
private BsonValue <ToBsonDocument>b__41_3();
}
public class MongoDB.Driver.WriteConcernResult : object {
    private BsonDocument _response;
    public long DocumentsAffected { get; }
    public bool HasLastErrorMessage { get; }
    public string LastErrorMessage { get; }
    public BsonValue Upserted { get; }
    public bool UpdatedExisting { get; }
    public BsonDocument Response { get; }
    public WriteConcernResult(BsonDocument response);
    public long get_DocumentsAffected();
    public bool get_HasLastErrorMessage();
    public string get_LastErrorMessage();
    public BsonValue get_Upserted();
    public bool get_UpdatedExisting();
    public BsonDocument get_Response();
}
internal class MongoDB.Shared.Hasher : object {
    private int _hashCode;
    public Hasher(int seed);
    public static int GetHashCode(T obj);
    public virtual int GetHashCode();
    public Hasher Hash(bool obj);
    public Hasher Hash(int obj);
    public Hasher Hash(long obj);
    public Hasher Hash(Nullable`1<T> obj);
    public Hasher Hash(object obj);
    public Hasher HashElements(IEnumerable`1<T> sequence);
    public Hasher HashStructElements(IEnumerable`1<T> sequence);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsReadOnlyAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NativeIntegerAttribute : Attribute {
    public Boolean[] TransformFlags;
    public NativeIntegerAttribute(Boolean[] );
}
