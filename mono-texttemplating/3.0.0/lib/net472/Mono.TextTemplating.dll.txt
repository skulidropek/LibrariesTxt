[ExtensionAttribute]
internal static class HostOptionExtensions : object {
    private static string DisableAlcOptionName;
    [ExtensionAttribute]
private static bool IsOptionTrue(ITextTemplatingEngineHost host, string optionName);
    [ExtensionAttribute]
public static bool IsAssemblyLoadContextDisabled(ITextTemplatingEngineHost host);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
public abstract class Microsoft.VisualStudio.TextTemplating.DirectiveProcessor : object {
    private CompilerErrorCollection errors;
    private CompilerErrorCollection Microsoft.VisualStudio.TextTemplating.IDirectiveProcessor.Errors { get; }
    private bool Microsoft.VisualStudio.TextTemplating.IDirectiveProcessor.RequiresProcessingRunIsHostSpecific { get; }
    public virtual void Initialize(ITextTemplatingEngineHost host);
    public virtual void StartProcessingRun(CodeDomProvider languageProvider, string templateContents, CompilerErrorCollection errors);
    public abstract virtual void FinishProcessingRun();
    public abstract virtual string GetClassCodeForProcessingRun();
    public abstract virtual String[] GetImportsForProcessingRun();
    public abstract virtual string GetPostInitializationCodeForProcessingRun();
    public abstract virtual string GetPreInitializationCodeForProcessingRun();
    public abstract virtual String[] GetReferencesForProcessingRun();
    public abstract virtual bool IsDirectiveSupported(string directiveName);
    public abstract virtual void ProcessDirective(string directiveName, IDictionary`2<string, string> arguments);
    public virtual CodeAttributeDeclarationCollection GetTemplateClassCustomAttributes();
    private sealed virtual override CompilerErrorCollection Microsoft.VisualStudio.TextTemplating.IDirectiveProcessor.get_Errors();
    private sealed virtual override void Microsoft.VisualStudio.TextTemplating.IDirectiveProcessor.SetProcessingRunIsHostSpecific(bool hostSpecific);
    private sealed virtual override bool Microsoft.VisualStudio.TextTemplating.IDirectiveProcessor.get_RequiresProcessingRunIsHostSpecific();
}
public class Microsoft.VisualStudio.TextTemplating.DirectiveProcessorException : Exception {
    public DirectiveProcessorException(string message);
    protected DirectiveProcessorException(SerializationInfo info, StreamingContext context);
    public DirectiveProcessorException(string message, Exception inner);
}
[ObsoleteAttribute("Not implemented")]
public static class Microsoft.VisualStudio.TextTemplating.EncodingHelper : object {
    public static Encoding GetEncoding(string filePath);
}
[ObsoleteAttribute("Use Mono.TextTemplating.TemplatingEngine directly")]
public class Microsoft.VisualStudio.TextTemplating.Engine : object {
    private TemplatingEngine engine;
    public static string CacheAssembliesOptionString;
    public sealed virtual string ProcessTemplate(string content, ITextTemplatingEngineHost host);
    public sealed virtual string PreprocessTemplate(string content, ITextTemplatingEngineHost host, string className, string classNamespace, String& language, String[]& references);
}
public interface Microsoft.VisualStudio.TextTemplating.IDirectiveProcessor {
    public CompilerErrorCollection Errors { get; }
    public bool RequiresProcessingRunIsHostSpecific { get; }
    public abstract virtual CompilerErrorCollection get_Errors();
    public abstract virtual bool get_RequiresProcessingRunIsHostSpecific();
    public abstract virtual void FinishProcessingRun();
    public abstract virtual string GetClassCodeForProcessingRun();
    public abstract virtual String[] GetImportsForProcessingRun();
    public abstract virtual string GetPostInitializationCodeForProcessingRun();
    public abstract virtual string GetPreInitializationCodeForProcessingRun();
    public abstract virtual String[] GetReferencesForProcessingRun();
    public abstract virtual CodeAttributeDeclarationCollection GetTemplateClassCustomAttributes();
    public abstract virtual void Initialize(ITextTemplatingEngineHost host);
    public abstract virtual bool IsDirectiveSupported(string directiveName);
    public abstract virtual void ProcessDirective(string directiveName, IDictionary`2<string, string> arguments);
    public abstract virtual void SetProcessingRunIsHostSpecific(bool hostSpecific);
    public abstract virtual void StartProcessingRun(CodeDomProvider languageProvider, string templateContents, CompilerErrorCollection errors);
}
public interface Microsoft.VisualStudio.TextTemplating.IRecognizeHostSpecific {
    public bool RequiresProcessingRunIsHostSpecific { get; }
    public abstract virtual void SetProcessingRunIsHostSpecific(bool hostSpecific);
    public abstract virtual bool get_RequiresProcessingRunIsHostSpecific();
}
[ObsoleteAttribute("Use Mono.TextTemplating.TemplatingEngine directly")]
public interface Microsoft.VisualStudio.TextTemplating.ITextTemplatingEngine {
    public abstract virtual string ProcessTemplate(string content, ITextTemplatingEngineHost host);
    public abstract virtual string PreprocessTemplate(string content, ITextTemplatingEngineHost host, string className, string classNamespace, String& language, String[]& references);
}
public interface Microsoft.VisualStudio.TextTemplating.ITextTemplatingEngineHost {
    public IList`1<string> StandardAssemblyReferences { get; }
    public IList`1<string> StandardImports { get; }
    public string TemplateFile { get; }
    public abstract virtual object GetHostOption(string optionName);
    public abstract virtual bool LoadIncludeText(string requestFileName, String& content, String& location);
    public abstract virtual void LogErrors(CompilerErrorCollection errors);
    public abstract virtual AppDomain ProvideTemplatingAppDomain(string content);
    public abstract virtual string ResolveAssemblyReference(string assemblyReference);
    public abstract virtual Type ResolveDirectiveProcessor(string processorName);
    public abstract virtual string ResolveParameterValue(string directiveId, string processorName, string parameterName);
    public abstract virtual string ResolvePath(string path);
    public abstract virtual void SetFileExtension(string extension);
    public abstract virtual void SetOutputEncoding(Encoding encoding, bool fromOutputDirective);
    public abstract virtual IList`1<string> get_StandardAssemblyReferences();
    public abstract virtual IList`1<string> get_StandardImports();
    public abstract virtual string get_TemplateFile();
}
public interface Microsoft.VisualStudio.TextTemplating.ITextTemplatingSession {
    public Guid Id { get; }
    public abstract virtual Guid get_Id();
}
public interface Microsoft.VisualStudio.TextTemplating.ITextTemplatingSessionHost {
    public ITextTemplatingSession Session { get; public set; }
    public abstract virtual ITextTemplatingSession CreateSession();
    public abstract virtual ITextTemplatingSession get_Session();
    public abstract virtual void set_Session(ITextTemplatingSession value);
}
public class Microsoft.VisualStudio.TextTemplating.ParameterDirectiveProcessor : DirectiveProcessor {
    private CodeDomProvider provider;
    private bool hostSpecific;
    private List`1<CodeStatement> postStatements;
    private List`1<CodeTypeMember> members;
    private static Dictionary`2<string, string> BuiltinTypesMap;
    [CompilerGeneratedAttribute]
private CodeGenerationOptions <CodeGenerationOptions>k__BackingField;
    public bool RequiresProcessingRunIsHostSpecific { get; }
    private CodeGenerationOptions CodeGenerationOptions { get; private set; }
    private static ParameterDirectiveProcessor();
    public virtual void StartProcessingRun(CodeDomProvider languageProvider, string templateContents, CompilerErrorCollection errors);
    public virtual void FinishProcessingRun();
    public virtual string GetClassCodeForProcessingRun();
    public virtual String[] GetImportsForProcessingRun();
    public virtual string GetPostInitializationCodeForProcessingRun();
    public virtual string GetPreInitializationCodeForProcessingRun();
    private string StatementsToCode(List`1<CodeStatement> statements);
    public virtual String[] GetReferencesForProcessingRun();
    public virtual bool IsDirectiveSupported(string directiveName);
    public static string MapTypeName(string typeName);
    public virtual void ProcessDirective(string directiveName, IDictionary`2<string, string> arguments);
    private sealed virtual override void Microsoft.VisualStudio.TextTemplating.IRecognizeHostSpecific.SetProcessingRunIsHostSpecific(bool hostSpecific);
    private sealed virtual override void Mono.TextTemplating.ISupportCodeGenerationOptions.SetCodeGenerationOptions(CodeGenerationOptions options);
    public sealed virtual bool get_RequiresProcessingRunIsHostSpecific();
    [CompilerGeneratedAttribute]
private CodeGenerationOptions get_CodeGenerationOptions();
    [CompilerGeneratedAttribute]
private void set_CodeGenerationOptions(CodeGenerationOptions value);
}
public abstract class Microsoft.VisualStudio.TextTemplating.RequiresProvidesDirectiveProcessor : DirectiveProcessor {
    private bool isInProcessingRun;
    private ITextTemplatingEngineHost host;
    private StringBuilder preInitBuffer;
    private StringBuilder postInitBuffer;
    private StringBuilder codeBuffer;
    private CodeDomProvider languageProvider;
    protected string FriendlyName { get; }
    protected ITextTemplatingEngineHost Host { get; }
    public virtual void Initialize(ITextTemplatingEngineHost host);
    protected abstract virtual void InitializeProvidesDictionary(string directiveName, IDictionary`2<string, string> providesDictionary);
    protected abstract virtual void InitializeRequiresDictionary(string directiveName, IDictionary`2<string, string> requiresDictionary);
    protected abstract virtual string get_FriendlyName();
    protected abstract virtual void GeneratePostInitializationCode(string directiveName, StringBuilder codeBuffer, CodeDomProvider languageProvider, IDictionary`2<string, string> requiresArguments, IDictionary`2<string, string> providesArguments);
    protected abstract virtual void GeneratePreInitializationCode(string directiveName, StringBuilder codeBuffer, CodeDomProvider languageProvider, IDictionary`2<string, string> requiresArguments, IDictionary`2<string, string> providesArguments);
    protected abstract virtual void GenerateTransformCode(string directiveName, StringBuilder codeBuffer, CodeDomProvider languageProvider, IDictionary`2<string, string> requiresArguments, IDictionary`2<string, string> providesArguments);
    protected virtual void PostProcessArguments(string directiveName, IDictionary`2<string, string> requiresArguments, IDictionary`2<string, string> providesArguments);
    public virtual string GetClassCodeForProcessingRun();
    public virtual String[] GetImportsForProcessingRun();
    public virtual String[] GetReferencesForProcessingRun();
    public virtual string GetPostInitializationCodeForProcessingRun();
    public virtual string GetPreInitializationCodeForProcessingRun();
    public virtual void StartProcessingRun(CodeDomProvider languageProvider, string templateContents, CompilerErrorCollection errors);
    public virtual void FinishProcessingRun();
    private void AssertNotProcessing();
    [IteratorStateMachineAttribute("Microsoft.VisualStudio.TextTemplating.RequiresProvidesDirectiveProcessor/<ParseArgs>d__24")]
private static IEnumerable`1<KeyValuePair`2<string, string>> ParseArgs(string args);
    public virtual void ProcessDirective(string directiveName, IDictionary`2<string, string> arguments);
    protected virtual string ProvideUniqueId(string directiveName, IDictionary`2<string, string> arguments, IDictionary`2<string, string> requiresArguments, IDictionary`2<string, string> providesArguments);
    protected ITextTemplatingEngineHost get_Host();
}
public class Microsoft.VisualStudio.TextTemplating.TextTemplatingSession : Dictionary`2<string, object> {
    [CompilerGeneratedAttribute]
private Guid <Id>k__BackingField;
    public Guid Id { get; private set; }
    private TextTemplatingSession(SerializationInfo info, StreamingContext context);
    public TextTemplatingSession(Guid id);
    [CompilerGeneratedAttribute]
public sealed virtual Guid get_Id();
    [CompilerGeneratedAttribute]
private void set_Id(Guid value);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(Guid other);
    public sealed virtual bool Equals(ITextTemplatingSession other);
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
}
public abstract class Microsoft.VisualStudio.TextTemplating.TextTransformation : object {
    private Stack`1<int> indents;
    private string currentIndent;
    private CompilerErrorCollection errors;
    private StringBuilder builder;
    private bool endsWithNewline;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, object> <Session>k__BackingField;
    public IDictionary`2<string, object> Session { get; public set; }
    protected internal CompilerErrorCollection Errors { get; }
    private Stack`1<int> Indents { get; }
    public string CurrentIndent { get; }
    protected StringBuilder GenerationEnvironment { get; protected set; }
    public virtual void Initialize();
    public abstract virtual string TransformText();
    [CompilerGeneratedAttribute]
public virtual IDictionary`2<string, object> get_Session();
    [CompilerGeneratedAttribute]
public virtual void set_Session(IDictionary`2<string, object> value);
    public void Error(string message);
    public void Warning(string message);
    protected internal CompilerErrorCollection get_Errors();
    private Stack`1<int> get_Indents();
    public string PopIndent();
    public void PushIndent(string indent);
    public void ClearIndent();
    public string get_CurrentIndent();
    protected StringBuilder get_GenerationEnvironment();
    protected void set_GenerationEnvironment(StringBuilder value);
    public void Write(string textToAppend);
    public void Write(string format, Object[] args);
    public void WriteLine(string textToAppend);
    public void WriteLine(string format, Object[] args);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    protected virtual override void Finalize();
}
public static class Microsoft.VisualStudio.TextTemplating.ToStringHelper : object {
    private static Object[] formatProviderAsParameterArray;
    private static IFormatProvider formatProvider;
    public static IFormatProvider FormatProvider { get; public set; }
    private static ToStringHelper();
    public static string ToStringWithCulture(object objectToConvert);
    public static IFormatProvider get_FormatProvider();
    public static void set_FormatProvider(IFormatProvider value);
}
internal static class Mono.TextTemplating.CodeCompilation.AssemblyResolver : object {
    private static Lazy`1<String[]> KnownNet50RefAssemblyNames;
    private static Lazy`1<String[]> Net472DefaultAssemblyRefs;
    private static Lazy`1<String[]> Net472FacadeNames;
    private static AssemblyResolver();
    [IteratorStateMachineAttribute("Mono.TextTemplating.CodeCompilation.AssemblyResolver/<GetResolvedReferences>d__0")]
public static IEnumerable`1<string> GetResolvedReferences(RuntimeInfo runtime, List`1<string> references);
    private static string Resolve(RuntimeInfo runtime, string reference);
}
internal abstract class Mono.TextTemplating.CodeCompilation.CodeCompiler : object {
    public abstract virtual Task`1<CodeCompilerResult> CompileFile(CodeCompilerArguments arguments, TextWriter log, CancellationToken token);
}
internal class Mono.TextTemplating.CodeCompilation.CodeCompilerArguments : object {
    [CompilerGeneratedAttribute]
private List`1<string> <SourceFiles>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <AssemblyReferences>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AdditionalArguments>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Debug>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OutputPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TempDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LangVersion>k__BackingField;
    public List`1<string> SourceFiles { get; }
    public List`1<string> AssemblyReferences { get; }
    public string AdditionalArguments { get; public set; }
    public bool Debug { get; public set; }
    public string OutputPath { get; public set; }
    public string TempDirectory { get; public set; }
    public string LangVersion { get; public set; }
    [CompilerGeneratedAttribute]
public List`1<string> get_SourceFiles();
    [CompilerGeneratedAttribute]
public List`1<string> get_AssemblyReferences();
    [CompilerGeneratedAttribute]
public string get_AdditionalArguments();
    [CompilerGeneratedAttribute]
public void set_AdditionalArguments(string value);
    [CompilerGeneratedAttribute]
public bool get_Debug();
    [CompilerGeneratedAttribute]
public void set_Debug(bool value);
    [CompilerGeneratedAttribute]
public string get_OutputPath();
    [CompilerGeneratedAttribute]
public void set_OutputPath(string value);
    [CompilerGeneratedAttribute]
public string get_TempDirectory();
    [CompilerGeneratedAttribute]
public void set_TempDirectory(string value);
    [CompilerGeneratedAttribute]
public string get_LangVersion();
    [CompilerGeneratedAttribute]
public void set_LangVersion(string value);
}
internal class Mono.TextTemplating.CodeCompilation.CodeCompilerError : object {
    [CompilerGeneratedAttribute]
private string <Origin>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Line>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Column>k__BackingField;
    [CompilerGeneratedAttribute]
private int <EndLine>k__BackingField;
    [CompilerGeneratedAttribute]
private int <EndColumn>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Subcategory>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsError>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Code>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    public string Origin { get; public set; }
    public int Line { get; public set; }
    public int Column { get; public set; }
    public int EndLine { get; public set; }
    public int EndColumn { get; public set; }
    public string Subcategory { get; public set; }
    public bool IsError { get; public set; }
    public string Code { get; public set; }
    public string Message { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Origin();
    [CompilerGeneratedAttribute]
public void set_Origin(string value);
    [CompilerGeneratedAttribute]
public int get_Line();
    [CompilerGeneratedAttribute]
public void set_Line(int value);
    [CompilerGeneratedAttribute]
public int get_Column();
    [CompilerGeneratedAttribute]
public void set_Column(int value);
    [CompilerGeneratedAttribute]
public int get_EndLine();
    [CompilerGeneratedAttribute]
public void set_EndLine(int value);
    [CompilerGeneratedAttribute]
public int get_EndColumn();
    [CompilerGeneratedAttribute]
public void set_EndColumn(int value);
    [CompilerGeneratedAttribute]
public string get_Subcategory();
    [CompilerGeneratedAttribute]
public void set_Subcategory(string value);
    [CompilerGeneratedAttribute]
public bool get_IsError();
    [CompilerGeneratedAttribute]
public void set_IsError(bool value);
    [CompilerGeneratedAttribute]
public string get_Code();
    [CompilerGeneratedAttribute]
public void set_Code(string value);
    [CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
public void set_Message(string value);
}
internal class Mono.TextTemplating.CodeCompilation.CodeCompilerResult : object {
    [CompilerGeneratedAttribute]
private bool <Success>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<CodeCompilerError> <Errors>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ExitCode>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <Output>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ResponseFile>k__BackingField;
    public bool Success { get; internal set; }
    public List`1<CodeCompilerError> Errors { get; internal set; }
    public int ExitCode { get; internal set; }
    public List`1<string> Output { get; internal set; }
    public string ResponseFile { get; internal set; }
    [CompilerGeneratedAttribute]
public bool get_Success();
    [CompilerGeneratedAttribute]
internal void set_Success(bool value);
    [CompilerGeneratedAttribute]
public List`1<CodeCompilerError> get_Errors();
    [CompilerGeneratedAttribute]
internal void set_Errors(List`1<CodeCompilerError> value);
    [CompilerGeneratedAttribute]
public int get_ExitCode();
    [CompilerGeneratedAttribute]
internal void set_ExitCode(int value);
    [CompilerGeneratedAttribute]
public List`1<string> get_Output();
    [CompilerGeneratedAttribute]
internal void set_Output(List`1<string> value);
    [CompilerGeneratedAttribute]
public string get_ResponseFile();
    [CompilerGeneratedAttribute]
internal void set_ResponseFile(string value);
}
internal class Mono.TextTemplating.CodeCompilation.CompiledAssembly : object {
    [CompilerGeneratedAttribute]
private Byte[] <Assembly>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <DebugSymbols>k__BackingField;
    public Byte[] Assembly { get; }
    public Byte[] DebugSymbols { get; }
    public CompiledAssembly(Byte[] assembly, Byte[] debugSymbols);
    [CompilerGeneratedAttribute]
public Byte[] get_Assembly();
    [CompilerGeneratedAttribute]
public Byte[] get_DebugSymbols();
}
internal class Mono.TextTemplating.CodeCompilation.CompiledAssemblyData : object {
    [CompilerGeneratedAttribute]
private Byte[] <Assembly>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <DebugSymbols>k__BackingField;
    public Byte[] Assembly { get; }
    public Byte[] DebugSymbols { get; }
    public CompiledAssemblyData(Byte[] assembly, Byte[] debugSymbols);
    [CompilerGeneratedAttribute]
public Byte[] get_Assembly();
    [CompilerGeneratedAttribute]
public Byte[] get_DebugSymbols();
    public Assembly LoadInCurrentAppDomain();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Mono.TextTemplating.CodeCompilation.CscCodeCompiler : CodeCompiler {
    private RuntimeInfo runtime;
    public CscCodeCompiler(RuntimeInfo runtime);
    private static StreamWriter CreateTempTextFile(string extension, String& path);
    [AsyncStateMachineAttribute("Mono.TextTemplating.CodeCompilation.CscCodeCompiler/<CompileFile>d__3")]
public virtual Task`1<CodeCompilerResult> CompileFile(CodeCompilerArguments arguments, TextWriter log, CancellationToken token);
    [CompilerGeneratedAttribute]
internal static void <CompileFile>g__ConsumeOutput|3_0(string s, <>c__DisplayClass3_0& );
}
internal enum Mono.TextTemplating.CodeCompilation.CSharpLangVersion : Enum {
    public int value__;
    public static CSharpLangVersion v5_0;
    public static CSharpLangVersion v6_0;
    public static CSharpLangVersion v7_0;
    public static CSharpLangVersion v7_1;
    public static CSharpLangVersion v7_2;
    public static CSharpLangVersion v7_3;
    public static CSharpLangVersion v8_0;
    public static CSharpLangVersion v9_0;
    public static CSharpLangVersion v10_0;
    public static CSharpLangVersion v11_0;
    public static CSharpLangVersion v12_0;
    public static CSharpLangVersion v13_0;
    public static CSharpLangVersion Latest;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Mono.TextTemplating.CodeCompilation.CSharpLangVersionHelper : object {
    public static bool HasLangVersionArg(string args);
    public static bool IsLangVersionArg(string arg);
    public static string GetLangVersionArg(CodeCompilerArguments arguments, RuntimeInfo runtime);
    public static CSharpLangVersion FromNetCoreSdkVersion(SemVersion sdkVersion);
    public static string ToString(CSharpLangVersion version);
}
internal static class Mono.TextTemplating.CodeCompilation.MSBuildErrorParser : object {
    public static CodeCompilerError TryParseLine(string line);
    private static bool ParseOrigin(string line, int start, int end, CodeCompilerError result);
    private static bool ParseLineColVal(string str, Int32& val);
    private static bool ParsePosition(string str, int start, int end, CodeCompilerError result);
    private static bool ParseCategory(string line, int start, int end, CodeCompilerError result);
    private static void MoveNextNonSpace(string s, Int32& idx);
    private static void MovePrevNonSpace(string s, Int32& idx, int min);
    private static void MovePrevWordStart(string s, Int32& idx, int min);
}
internal class Mono.TextTemplating.CodeCompilation.ProcessArgumentBuilder : object {
    private StringBuilder sb;
    [CompilerGeneratedAttribute]
private string <ProcessPath>k__BackingField;
    private static string escapeDoubleQuoteCharsStr;
    public string ProcessPath { get; }
    public ProcessArgumentBuilder(string processPath);
    [CompilerGeneratedAttribute]
public string get_ProcessPath();
    public void Add(string argument);
    public void Add(String[] args);
    public void AddQuoted(string argument);
    public void AddQuoted(String[] args);
    public static string Quote(string s);
    public virtual string ToString();
    private static void AppendEscaped(StringBuilder sb, string escapeChars, string s);
    private static string GetArgument(StringBuilder builder, string buf, int startIndex, Int32& endIndex, Exception& ex);
    private static bool TryParse(string commandline, String[]& argv, Exception& ex);
    public static bool TryParse(string commandline, String[]& argv);
    public static String[] Parse(string commandline);
}
internal static class Mono.TextTemplating.CodeCompilation.ProcessUtils : object {
    public static Task`1<int> StartProcess(ProcessStartInfo psi, TextWriter stdout, TextWriter stderr, CancellationToken cancellationToken);
}
internal class Mono.TextTemplating.CodeCompilation.RuntimeInfo : object {
    [CompilerGeneratedAttribute]
private RuntimeKind <Kind>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Error>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RuntimeDir>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CscPath>k__BackingField;
    [CompilerGeneratedAttribute]
private CSharpLangVersion <CscMaxLangVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private CSharpLangVersion <RuntimeLangVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private Version <RuntimeVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RefAssembliesDir>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RuntimeFacadesDir>k__BackingField;
    public RuntimeKind Kind { get; }
    public string Error { get; }
    public string RuntimeDir { get; }
    public string CscPath { get; }
    public CSharpLangVersion CscMaxLangVersion { get; }
    public CSharpLangVersion RuntimeLangVersion { get; }
    public bool IsValid { get; }
    public Version RuntimeVersion { get; }
    public string RefAssembliesDir { get; }
    public string RuntimeFacadesDir { get; }
    private RuntimeInfo(RuntimeKind kind, string error);
    private RuntimeInfo(RuntimeKind kind, string runtimeDir, Version runtimeVersion, string refAssembliesDir, string runtimeFacadesDir, string cscPath, CSharpLangVersion cscMaxLangVersion, CSharpLangVersion runtimeLangVersion);
    private static RuntimeInfo FromError(RuntimeKind kind, string error);
    [CompilerGeneratedAttribute]
public RuntimeKind get_Kind();
    [CompilerGeneratedAttribute]
public string get_Error();
    [CompilerGeneratedAttribute]
public string get_RuntimeDir();
    [CompilerGeneratedAttribute]
public string get_CscPath();
    [CompilerGeneratedAttribute]
public CSharpLangVersion get_CscMaxLangVersion();
    [CompilerGeneratedAttribute]
public CSharpLangVersion get_RuntimeLangVersion();
    public bool get_IsValid();
    [CompilerGeneratedAttribute]
public Version get_RuntimeVersion();
    [CompilerGeneratedAttribute]
public string get_RefAssembliesDir();
    [CompilerGeneratedAttribute]
public string get_RuntimeFacadesDir();
    public static RuntimeInfo GetRuntime();
    private static RuntimeInfo GetMonoRuntime();
    private static RuntimeInfo GetNetFrameworkRuntime();
    private static RuntimeInfo GetDotNetCoreSdk();
    private static string FindHighestVersionedDirectory(string parentFolder, Func`2<string, bool> validate, SemVersion& bestVersion);
    [CompilerGeneratedAttribute]
internal static bool <GetDotNetCoreSdk>g__DotnetRootIsValid|35_0(string root);
    [CompilerGeneratedAttribute]
internal static string <GetDotNetCoreSdk>g__MakeCscPath|35_1(string d);
}
internal enum Mono.TextTemplating.CodeCompilation.RuntimeKind : Enum {
    public int value__;
    public static RuntimeKind NetCore;
    public static RuntimeKind NetFramework;
    public static RuntimeKind Mono;
}
public class Mono.TextTemplating.CodeCompilation.SemVersion : ValueType {
    [CompilerGeneratedAttribute]
private static SemVersion <Zero>k__BackingField;
    private static Regex SemVerRegex;
    [CompilerGeneratedAttribute]
private int <Major>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Minor>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Patch>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PreRelease>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Meta>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsPreRelease>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasMeta>k__BackingField;
    [CompilerGeneratedAttribute]
private string <VersionString>k__BackingField;
    public static SemVersion Zero { get; }
    public int Major { get; }
    public int Minor { get; }
    public int Patch { get; }
    public string PreRelease { get; }
    public string Meta { get; }
    public bool IsPreRelease { get; }
    public bool HasMeta { get; }
    public string VersionString { get; }
    public SemVersion(int major, int minor, int patch, string preRelease, string meta);
    private SemVersion(int major, int minor, int patch, string preRelease, string meta, string versionString);
    private static SemVersion();
    [CompilerGeneratedAttribute]
public static SemVersion get_Zero();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_Major();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_Minor();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_Patch();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_PreRelease();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_Meta();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_IsPreRelease();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_HasMeta();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_VersionString();
    public static bool TryParse(string version, SemVersion& semVersion);
    public sealed virtual bool Equals(SemVersion other);
    public sealed virtual int CompareTo(SemVersion other);
    public sealed virtual int CompareTo(object obj);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public static bool op_GreaterThan(SemVersion left, SemVersion right);
    public static bool op_LessThan(SemVersion left, SemVersion right);
    public static bool op_GreaterThanOrEqual(SemVersion left, SemVersion right);
    public static bool op_LessThanOrEqual(SemVersion left, SemVersion right);
    public static bool op_Equality(SemVersion left, SemVersion right);
    public static bool op_Inequality(SemVersion left, SemVersion right);
}
[ExtensionAttribute]
internal static class Mono.TextTemplating.CodeDomBuilder.CodeDomExtensions : object {
    [ExtensionAttribute]
public static CodeMemberField WithReference(CodeMemberField field, CodeFieldReferenceExpression& reference);
    [ExtensionAttribute]
public static CodeNamespace AddNamespace(CodeCompileUnit ccu, CodeNamespace namespace);
    [ExtensionAttribute]
public static CodeNamespace AddNamespace(CodeCompileUnit ccu, string namespaceName);
    [ExtensionAttribute]
public static CodeNamespaceImport AddImport(CodeNamespace ns, CodeNamespaceImport namespaceToImport);
    [ExtensionAttribute]
public static CodeNamespaceImport AddImport(CodeNamespace ns, string namespaceToImport);
    [ExtensionAttribute]
public static CodeTypeDeclaration AddType(CodeNamespace ns, CodeTypeDeclaration type);
    [ExtensionAttribute]
public static CodeTypeDeclaration AddClass(CodeNamespace ns, string className);
}
[ExtensionAttribute]
internal static class Mono.TextTemplating.CodeDomBuilder.CodeMemberExtensions : object {
    [ExtensionAttribute]
public static T WithMemberAttributesReplaced(T member, MemberAttributes attributes);
    [ExtensionAttribute]
public static T WithMemberAttributesReplaced(T member, MemberAttributes attributesToRemove, MemberAttributes attributesToAdd);
    [ExtensionAttribute]
public static T WithMemberAttributesAdded(T member, MemberAttributes attributesToAdd);
    [ExtensionAttribute]
public static T WithMemberAttributesRemoved(T member, MemberAttributes attrbutesToRemove);
    [ExtensionAttribute]
public static T WithVisibility(T member, MemberAttributes visibilityAttributes);
    [ExtensionAttribute]
public static T AsPrivate(T member);
    [ExtensionAttribute]
public static T AsPublic(T member);
    [ExtensionAttribute]
public static T AsProtected(T member);
    [ExtensionAttribute]
public static T AsInternal(T member);
    [ExtensionAttribute]
public static T AsInternalProtected(T member);
    [ExtensionAttribute]
public static T AsVirtual(T member);
    [ExtensionAttribute]
public static T AsAbstract(T member);
    [ExtensionAttribute]
public static T AsSealed(T member);
    [ExtensionAttribute]
public static T AsNew(T member);
    [ExtensionAttribute]
public static T AsOverride(T member);
    [ExtensionAttribute]
public static T AddTo(T member, CodeTypeDeclaration type);
    [ExtensionAttribute]
public static CodeAttributeDeclaration AddAttribute(T member, CodeAttributeDeclaration attribute);
    [ExtensionAttribute]
public static T WithAttribute(T member, CodeAttributeDeclaration attribute);
    [ExtensionAttribute]
public static T WithAttributes(T member, CodeAttributeDeclaration[] attributes);
    [ExtensionAttribute]
public static T WithAttributes(T member, CodeAttributeDeclarationCollection attributes);
    [ExtensionAttribute]
public static void AddAttributes(T member, CodeAttributeDeclaration[] attributes);
    [ExtensionAttribute]
public static void AddAttributes(T member, CodeAttributeDeclarationCollection attributes);
    [ExtensionAttribute]
public static CodeAttributeDeclaration AddAttribute(T member, CodeTypeReference attributeType);
    [ExtensionAttribute]
public static CodeAttributeDeclaration AddAttribute(T member, CodeTypeReference attributeType, CodeAttributeArgument[] arguments);
    [ExtensionAttribute]
public static CodeAttributeDeclaration WithAttribute(TMember member);
    [ExtensionAttribute]
public static CodeAttributeDeclaration WithAttribute(TMember member, CodeAttributeArgument[] arguments);
    [ExtensionAttribute]
public static void AddTo(CodeAttributeDeclarationCollection attributes, TMember member);
}
[ExtensionAttribute]
internal static class Mono.TextTemplating.CodeDomBuilder.CodeMemberMethodExtensions : object {
    [ExtensionAttribute]
public static CodeMemberMethod Returns(CodeMemberMethod method, CodeTypeReference returnType);
    [ExtensionAttribute]
public static CodeMemberMethod Returns(CodeMemberMethod method);
    [ExtensionAttribute]
public static CodeMemberMethod WithParameter(CodeMemberMethod method, CodeParameterDeclarationExpression parameter);
    [ExtensionAttribute]
public static CodeMemberMethod WithParameters(CodeMemberMethod method, CodeParameterDeclarationExpression[] parameters);
    [ExtensionAttribute]
public static CodeMemberMethod WithParameter(CodeMemberMethod method, CodeParameterDeclarationExpression parameter, CodeArgumentReferenceExpression& parameterRef);
    [ExtensionAttribute]
public static CodeMemberMethod WithParameter(CodeMemberMethod method, string parameterName, CodeTypeReference parameterType, CodeArgumentReferenceExpression& parameterRef);
    [ExtensionAttribute]
public static CodeMemberMethod WithParameter(CodeMemberMethod method, string parameterName, CodeArgumentReferenceExpression& parameterRef);
    [ExtensionAttribute]
public static CodeParameterDeclarationExpression WithAttribute(CodeParameterDeclarationExpression parameter, CodeAttributeDeclaration attribute);
    [ExtensionAttribute]
public static CodeParameterDeclarationExpression Params(CodeParameterDeclarationExpression parameter);
    [ExtensionAttribute]
public static CodeParameterDeclarationExpression WithReference(CodeParameterDeclarationExpression parameter, CodeArgumentReferenceExpression& parameterRef);
    [ExtensionAttribute]
public static CodeMemberMethod WithStatements(CodeMemberMethod method, CodeExpression statement);
    [ExtensionAttribute]
public static CodeMemberMethod WithStatements(CodeMemberMethod method, CodeStatement statement);
    [ExtensionAttribute]
public static CodeMemberMethod WithStatements(CodeMemberMethod method, CodeStatement[] statements);
}
[ExtensionAttribute]
internal static class Mono.TextTemplating.CodeDomBuilder.CodeMemberPropertyExtensions : object {
    [ExtensionAttribute]
public static CodeMemberProperty WithReference(CodeMemberProperty property, CodePropertyReferenceExpression& reference);
    [ExtensionAttribute]
public static CodeMemberProperty WithGet(CodeMemberProperty property, CodeFieldReferenceExpression backingFieldRef);
    [ExtensionAttribute]
public static CodeMemberProperty WithSet(CodeMemberProperty property, CodeExpression backingFieldRef);
    [ExtensionAttribute]
public static CodeMemberProperty WithGetSet(CodeMemberProperty property, CodeFieldReferenceExpression backingFieldRef);
    [ExtensionAttribute]
public static CodeMemberProperty WithGet(CodeMemberProperty property, CodeStatement statement);
    [ExtensionAttribute]
public static CodeMemberProperty WithGet(CodeMemberProperty property, CodeStatement[] statements);
    [ExtensionAttribute]
public static CodeMemberProperty WithSet(CodeMemberProperty property, CodeStatement statement);
    [ExtensionAttribute]
public static CodeMemberProperty WithSet(CodeMemberProperty property, CodeStatement[] statements);
    [ExtensionAttribute]
public static CodeMemberProperty WithGetLazyInitialize(CodeMemberProperty property, CodeMemberField field, CodeExpression init);
    [ExtensionAttribute]
public static CodeMemberProperty WithGetLazyInitialize(CodeMemberProperty property, CodeFieldReferenceExpression fieldRef, CodeExpression init);
    [ExtensionAttribute]
public static CodeMemberProperty WithSetIgnoresNull(CodeMemberProperty property, CodeFieldReferenceExpression fieldRef);
}
[ExtensionAttribute]
internal static class Mono.TextTemplating.CodeDomBuilder.CodeTypeExtensions : object {
    private static string NotValidOnType;
    [ExtensionAttribute]
public static CodeTypeDeclaration WithTypeAttributesReplaced(CodeTypeDeclaration type, TypeAttributes attributes);
    [ExtensionAttribute]
public static CodeTypeDeclaration WithTypeAttributesReplaced(CodeTypeDeclaration type, TypeAttributes attributesToRemove, TypeAttributes attributesToAdd);
    [ExtensionAttribute]
public static CodeTypeDeclaration WithTypeAttributesAdded(CodeTypeDeclaration type, TypeAttributes attributesToAdd);
    [ExtensionAttribute]
public static CodeTypeDeclaration WithTypeAttributesRemoved(CodeTypeDeclaration type, TypeAttributes attributesToRemove);
    [ExtensionAttribute]
public static CodeTypeDeclaration WithVisibility(CodeTypeDeclaration type, TypeAttributes visibility);
    private static CodeTypeDeclaration ThrowNotValid();
    [ExtensionAttribute]
[ObsoleteAttribute("This CodeMemberExtensions extension method is not valid on CodeTypeDeclaration")]
public static CodeTypeDeclaration AsPrivate(CodeTypeDeclaration type);
    [ExtensionAttribute]
public static CodeTypeDeclaration AsPublic(CodeTypeDeclaration type);
    [ExtensionAttribute]
[ObsoleteAttribute("This CodeMemberExtensions extension method is not valid on CodeTypeDeclaration")]
public static CodeTypeDeclaration AsProtected(CodeTypeDeclaration type);
    [ExtensionAttribute]
public static CodeTypeDeclaration AsInternal(CodeTypeDeclaration type);
    [ExtensionAttribute]
[ObsoleteAttribute("This CodeMemberExtensions extension method is not valid on CodeTypeDeclaration")]
public static CodeTypeDeclaration AsInternalProtected(CodeTypeDeclaration type);
    [ExtensionAttribute]
[ObsoleteAttribute("This CodeMemberExtensions extension method is not valid on CodeTypeDeclaration")]
public static CodeTypeDeclaration AsVirtual(CodeTypeDeclaration type);
    [ExtensionAttribute]
public static CodeTypeDeclaration AsAbstract(CodeTypeDeclaration type);
    [ExtensionAttribute]
public static CodeTypeDeclaration AsSealed(CodeTypeDeclaration type);
    [ExtensionAttribute]
public static CodeTypeDeclaration AsNew(CodeTypeDeclaration member);
    [ExtensionAttribute]
[ObsoleteAttribute("This CodeMemberExtensions extension method is not valid on CodeTypeDeclaration")]
public static CodeTypeDeclaration AsOverride(CodeTypeDeclaration type);
    [ExtensionAttribute]
public static CodeTypeDeclaration AsNestedPublic(CodeTypeDeclaration type);
    [ExtensionAttribute]
public static CodeTypeDeclaration AsNestedProtected(CodeTypeDeclaration type);
    [ExtensionAttribute]
public static CodeTypeDeclaration AsNestedProtectedInternal(CodeTypeDeclaration type);
    [ExtensionAttribute]
public static CodeTypeDeclaration AsPartial(CodeTypeDeclaration type);
    [ExtensionAttribute]
public static CodeMemberProperty AddProperty(CodeTypeDeclaration type, string propertyName, CodeTypeReference propertyType);
    [ExtensionAttribute]
public static CodeMemberProperty AddProperty(CodeTypeDeclaration type, string propertyName);
    [ExtensionAttribute]
public static CodeMemberProperty AddPropertyGetSet(CodeTypeDeclaration type, string propertyName, CodeMemberField backingField);
    [ExtensionAttribute]
public static CodeMemberProperty AddPropertyGetOnly(CodeTypeDeclaration type, string propertyName, CodeMemberField backingField);
    [ExtensionAttribute]
public static CodeMemberField AddField(CodeTypeDeclaration type, string fieldName, CodeExpression initExpression);
    [ExtensionAttribute]
public static CodeMemberField AddField(CodeTypeDeclaration type, string fieldName, CodeTypeReference fieldType, CodeExpression init);
    [ExtensionAttribute]
public static CodeMemberMethod AddMethod(CodeTypeDeclaration type, string methodName);
    [ExtensionAttribute]
public static CodeTypeDeclaration WithMember(CodeTypeDeclaration type, T member);
    [ExtensionAttribute]
public static T AddMember(CodeTypeDeclaration type, T member);
    [ExtensionAttribute]
public static CodeSnippetTypeMember AddSnippetMember(CodeTypeDeclaration type, string value, CodeLinePragma location);
    [ExtensionAttribute]
public static CodeTypeDeclaration WithReference(CodeTypeDeclaration typeDeclaration, CodeTypeReference& typeReference);
    [ExtensionAttribute]
public static CodeTypeDeclaration Inherits(CodeTypeDeclaration typeDeclaration, CodeTypeReference baseClass);
}
internal static class Mono.TextTemplating.CodeDomBuilder.Declare : object {
    private static TypeAttributes DefaultTypeAttributes;
    private static MemberAttributes DefaultPropertyAttributes;
    private static MemberAttributes DefaultFieldAttributes;
    private static MemberAttributes DefaultMethodAttributes;
    private static MemberAttributes DefaultEventAttributes;
    public static CodeNamespace Namespace();
    public static CodeNamespace Namespace(string namespaceName);
    public static CodeTypeDeclaration Class(string typeName);
    public static CodeMemberMethod Method(string methodName);
    public static CodeMemberProperty Property(string propertyName);
    public static CodeMemberProperty Property(string propertyName, CodeTypeReference propertyType);
    public static CodeMemberField Field(string fieldName);
    public static CodeMemberField Field(string fieldName, CodeTypeReference fieldType);
    public static CodeMemberEvent Event(string eventName, CodeTypeReference eventType);
    public static CodeMemberEvent Event(string eventName);
    public static CodeParameterDeclarationExpression Parameter(string parameterName, CodeTypeReference parameterType);
    public static CodeParameterDeclarationExpression Parameter(string parameterName);
    public static CodeAttributeDeclaration Attribute(CodeTypeReference attributeType);
    public static CodeAttributeDeclaration Attribute();
    public static CodeAttributeDeclaration Attribute(CodeTypeReference attributeType, CodeAttributeArgument[] arguments);
    public static CodeAttributeDeclaration Attribute(CodeAttributeArgument[] arguments);
    public static CodeVariableDeclarationStatement Variable(string variableName, CodeExpression initExpression, CodeVariableReferenceExpression& variableReference);
    public static CodeVariableDeclarationStatement Variable(string variableName, CodeTypeReference variableType, CodeExpression initExpression, CodeVariableReferenceExpression& variableReference);
}
[ExtensionAttribute]
internal static class Mono.TextTemplating.CodeDomBuilder.Expression : object {
    [CompilerGeneratedAttribute]
private static CodePrimitiveExpression <Null>k__BackingField;
    [CompilerGeneratedAttribute]
private static CodePrimitiveExpression <False>k__BackingField;
    [CompilerGeneratedAttribute]
private static CodePrimitiveExpression <True>k__BackingField;
    [CompilerGeneratedAttribute]
private static CodePropertySetValueReferenceExpression <PropertySetValue>k__BackingField;
    [CompilerGeneratedAttribute]
private static CodeThisReferenceExpression <This>k__BackingField;
    [CompilerGeneratedAttribute]
private static CodeBaseReferenceExpression <Base>k__BackingField;
    [CompilerGeneratedAttribute]
private static CodeFieldReferenceExpression <StringEmpty>k__BackingField;
    public static CodePrimitiveExpression Null { get; }
    public static CodePrimitiveExpression False { get; }
    public static CodePrimitiveExpression True { get; }
    public static CodePropertySetValueReferenceExpression PropertySetValue { get; }
    public static CodeThisReferenceExpression This { get; }
    public static CodeBaseReferenceExpression Base { get; }
    public static CodeFieldReferenceExpression StringEmpty { get; }
    private static Expression();
    [CompilerGeneratedAttribute]
public static CodePrimitiveExpression get_Null();
    [CompilerGeneratedAttribute]
public static CodePrimitiveExpression get_False();
    [CompilerGeneratedAttribute]
public static CodePrimitiveExpression get_True();
    [CompilerGeneratedAttribute]
public static CodePropertySetValueReferenceExpression get_PropertySetValue();
    [CompilerGeneratedAttribute]
public static CodeThisReferenceExpression get_This();
    [CompilerGeneratedAttribute]
public static CodeBaseReferenceExpression get_Base();
    [CompilerGeneratedAttribute]
public static CodeFieldReferenceExpression get_StringEmpty();
    [ExtensionAttribute]
public static CodePrimitiveExpression NameOf(CodeArgumentReferenceExpression argument);
    public static CodePrimitiveExpression Primitive(object value);
    public static CodeVariableReferenceExpression Variable(string variableName);
    [ExtensionAttribute]
public static CodeObjectCreateExpression New(CodeTypeReference createType, CodeExpression[] arguments);
    public static CodeObjectCreateExpression New(CodeExpression[] arguments);
    [ExtensionAttribute]
public static CodeMethodInvokeExpression Invoke(CodeMethodReferenceExpression method, CodeExpression[] arguments);
    [ExtensionAttribute]
public static CodeBinaryOperatorExpression Operate(CodeExpression leftExpr, CodeBinaryOperatorType opType, CodeExpression rightExpr);
    [ExtensionAttribute]
public static CodeIndexerExpression Index(CodeExpression target, CodeExpression[] indices);
    public static CodeTypeReferenceExpression Type();
    public static CodeTypeOfExpression TypeOf(CodeTypeReference type);
    public static CodeTypeOfExpression TypeOf();
    public static CodeTypeOfExpression TypeOf(CodeTypeReference type);
    [ExtensionAttribute]
public static CodeCastExpression Cast(CodeExpression expression);
    public static CodeCastExpression Cast(CodeTypeReference type, CodeExpression expression);
    public static CodeArrayCreateExpression Array(CodeTypeReference type, int size);
    public static CodeArrayCreateExpression Array(CodeTypeReference type, CodeExpression[] initializers);
    public static CodeArrayCreateExpression Array(int size);
    public static CodeArrayCreateExpression Array(CodeExpression[] initializers);
    internal static CodeSnippetExpression Snippet(string expressionText);
}
[ExtensionAttribute]
internal static class Mono.TextTemplating.CodeDomBuilder.ExpressionExtensions : object {
    [ExtensionAttribute]
public static CodeTypeReferenceExpression AsExpression(CodeTypeReference typeReference);
    [ExtensionAttribute]
public static CodeFieldReferenceExpression AsReference(CodeMemberField field, CodeExpression target);
    [ExtensionAttribute]
public static CodePropertyReferenceExpression AsReference(CodeMemberProperty property, CodeExpression target);
    [ExtensionAttribute]
public static CodeMethodReferenceExpression AsReference(CodeMemberMethod method, CodeExpression target);
    [ExtensionAttribute]
public static CodeFieldReferenceExpression OnThis(CodeMemberField field);
    [ExtensionAttribute]
public static CodePropertyReferenceExpression OnThis(CodeMemberProperty property);
    [ExtensionAttribute]
public static CodeMethodReferenceExpression OnThis(CodeMemberMethod method);
    [ExtensionAttribute]
public static CodeArgumentReferenceExpression OnThis(CodeParameterDeclarationExpression parameter);
    [ExtensionAttribute]
public static CodeFieldReferenceExpression Field(CodeExpression target, string fieldName);
    [ExtensionAttribute]
public static CodeFieldReferenceExpression Field(CodeExpression target, CodeMemberField field);
    [ExtensionAttribute]
public static CodeFieldReferenceExpression Field(CodeTypeReference type, string fieldName);
    [ExtensionAttribute]
public static CodeAssignStatement SetField(CodeExpression target, string fieldName, CodeExpression value);
    [ExtensionAttribute]
public static CodeAssignStatement SetField(CodeTypeReference type, string fieldName, CodeExpression value);
    [ExtensionAttribute]
public static CodePropertyReferenceExpression Property(CodeExpression target, string propertyName);
    [ExtensionAttribute]
public static CodePropertyReferenceExpression Property(CodeExpression target, CodeMemberProperty property);
    [ExtensionAttribute]
public static CodePropertyReferenceExpression Property(CodeTypeReference type, string propertyName);
    [ExtensionAttribute]
public static CodeAssignStatement SetProperty(CodeExpression target, string propertyName, CodeExpression value);
    [ExtensionAttribute]
public static CodeAssignStatement SetProperty(CodeTypeReference type, string propertyName, CodeExpression value);
    [ExtensionAttribute]
public static CodeMethodReferenceExpression Method(CodeExpression target, string methodName);
    [ExtensionAttribute]
public static CodeMethodReferenceExpression Method(CodeExpression target, CodeMemberMethod method);
    [ExtensionAttribute]
public static CodeMethodReferenceExpression Method(CodeTypeReference type, string methodName);
    [ExtensionAttribute]
public static CodeMethodInvokeExpression InvokeMethod(CodeExpression target, string methodName, CodeExpression[] arguments);
    [ExtensionAttribute]
public static CodeMethodInvokeExpression InvokeMethod(CodeTypeReference target, string methodName, CodeExpression[] arguments);
    [ExtensionAttribute]
public static CodeBinaryOperatorExpression IsNotNull(CodeExpression reference);
    [ExtensionAttribute]
public static CodeBinaryOperatorExpression IsEqual(CodeExpression reference, CodeExpression value);
    [ExtensionAttribute]
public static CodeBinaryOperatorExpression IsEqualValue(CodeExpression reference, CodeExpression value);
    [ExtensionAttribute]
public static CodeBinaryOperatorExpression IsNull(CodeExpression reference);
    [ExtensionAttribute]
public static CodeBinaryOperatorExpression IsFalse(CodeExpression valueExpression);
    [ExtensionAttribute]
public static CodeBinaryOperatorExpression And(CodeExpression leftExpr, CodeExpression rightExpr);
    [ExtensionAttribute]
public static CodeBinaryOperatorExpression Subtract(CodeExpression leftExpr, CodeExpression rightExpr);
    [ExtensionAttribute]
public static CodeBinaryOperatorExpression Add(CodeExpression leftExpr, CodeExpression rightExpr);
    [ExtensionAttribute]
public static CodeExpressionStatement AsStatement(CodeExpression expression);
    [ExtensionAttribute]
public static CodeCastExpression Cast(CodeExpression expression, CodeTypeReference type);
}
[ExtensionAttribute]
internal static class Mono.TextTemplating.CodeDomBuilder.IndentHelpers : object {
    private static bool useMonoHack;
    private static MethodInfo cgFieldGen;
    private static MethodInfo cgPropGen;
    private static MethodInfo cgMethGen;
    private static Action`3<CodeGenerator, StringWriter, CodeGeneratorOptions> initializeCodeGenerator;
    private static IndentHelpers();
    [ExtensionAttribute]
public static string GenerateIndentedClassCode(CodeDomProvider provider, CodeTypeMember[] members);
    [ExtensionAttribute]
public static string GenerateIndentedClassCode(CodeDomProvider provider, IEnumerable`1<CodeTypeMember> members);
    public static CodeSnippetTypeMember CreateSnippetMember(string value, CodeLinePragma location);
    [ExtensionAttribute]
public static string IndentSnippetText(CodeDomProvider provider, string text, string indent);
    public static string IndentSnippetText(string text, string indent);
    [ExtensionAttribute]
public static void GenerateCodeFromMembers(CodeDomProvider provider, CodeGeneratorOptions options, StringWriter sw, IEnumerable`1<CodeTypeMember> members);
    private static bool InitializeMonoHack();
}
internal static class Mono.TextTemplating.CodeDomBuilder.Reference : object {
    public static CodeTypeReference Type();
}
[ExtensionAttribute]
internal static class Mono.TextTemplating.CodeDomBuilder.Statement : object {
    public static CodeConditionStatement If(CodeExpression condition, CodeStatement[] Then);
    public static CodeConditionStatement If(CodeExpression condition, CodeStatement[] Then, CodeStatement[] Else);
    [ExtensionAttribute]
public static CodeMethodReturnStatement Return(CodeExpression returnExpression);
    [ExtensionAttribute]
public static CodeAssignStatement Assign(CodeExpression target, CodeExpression value);
    public static CodeVariableDeclarationStatement DeclareVariable(CodeTypeReference variableType, string variableName, CodeExpression initExpression, CodeVariableReferenceExpression& variableReference);
    public static CodeVariableDeclarationStatement DeclareVariable(string variableName, CodeExpression initExpression, CodeVariableReferenceExpression& variableReference);
    public static CodeExpressionStatement Expression(CodeExpression expression);
    public static CodeStatement Throw(CodeExpression[] exceptionArgs);
    [ExtensionAttribute]
public static CodeStatement ThrowIfNull(CodeArgumentReferenceExpression argument);
    [ExtensionAttribute]
public static CodeStatement ThrowIfNull(CodeArgumentReferenceExpression argument, string message);
    public static CodeSnippetStatement Snippet(string statementText);
}
internal static class Mono.TextTemplating.CodeDomBuilder.TypeReference : object {
    [CompilerGeneratedAttribute]
private static CodeTypeReference <Void>k__BackingField;
    public static CodeTypeReference String { get; }
    public static CodeTypeReference Void { get; }
    public static CodeTypeReference ParamArrayAttribute { get; }
    private static TypeReference();
    public static CodeTypeReference get_String();
    [CompilerGeneratedAttribute]
public static CodeTypeReference get_Void();
    public static CodeTypeReference get_ParamArrayAttribute();
    public static CodeTypeReference Global();
    public static CodeTypeReference Global(Type type);
    public static CodeTypeReference Global(string type);
    public static CodeTypeReference Default();
    public static CodeTypeReference Default(Type type);
    public static CodeTypeReference Default(string type);
}
internal static class Mono.TextTemplating.CodeDomBuilder.TypeReference`1 : object {
    [CompilerGeneratedAttribute]
private static CodeTypeReference <Global>k__BackingField;
    public static CodeTypeReference Global { get; }
    private static TypeReference`1();
    [CompilerGeneratedAttribute]
public static CodeTypeReference get_Global();
}
internal class Mono.TextTemplating.CodeGenerationOptions : object {
    [CompilerGeneratedAttribute]
private bool <UseRemotingCallContext>k__BackingField;
    public bool UseRemotingCallContext { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_UseRemotingCallContext();
    [CompilerGeneratedAttribute]
public void set_UseRemotingCallContext(bool value);
}
public class Mono.TextTemplating.CompiledTemplate : MarshalByRefObject {
    private ITextTemplatingEngineHost host;
    private CultureInfo culture;
    private string templateClassFullName;
    private CompiledAssemblyData templateAssemblyData;
    private string templateAssemblyFile;
    [CompilerGeneratedAttribute]
private String[] <ReferencedAssemblyFiles>k__BackingField;
    private string templateContentForAppDomain;
    internal String[] ReferencedAssemblyFiles { get; }
    [ObsoleteAttribute("Should not have been public")]
public CompiledTemplate(ITextTemplatingEngineHost host, CompilerResults results, string fullName, CultureInfo culture, String[] assemblyFiles);
    [ObsoleteAttribute("Should not have been public")]
public CompiledTemplate(ITextTemplatingEngineHost host, string templateAssemblyFile, string fullName, CultureInfo culture, String[] referenceAssemblyFiles);
    internal CompiledTemplate(ITextTemplatingEngineHost host, CompiledAssemblyData templateAssemblyData, string fullName, CultureInfo culture, String[] referencedAssemblyFiles);
    private CompiledTemplate(string templateClassFullName, ITextTemplatingEngineHost host, CultureInfo culture, String[] referencedAssemblyFiles);
    [CompilerGeneratedAttribute]
internal String[] get_ReferencedAssemblyFiles();
    internal void SetTemplateContentForAppDomain(string content);
    private TemplateProcessor CreateTemplateProcessor();
    public string Process();
    public sealed virtual void Dispose();
}
public class Mono.TextTemplating.CrossAppDomainAssemblyResolver : object {
    private ParentDomainLookup parent;
    public Assembly Resolve(object sender, ResolveEventArgs args);
}
internal class Mono.TextTemplating.CurrentDomainAssemblyResolver : object {
    private Func`2<string, string> resolveAssemblyReference;
    private String[] assemblyFiles;
    private bool disposed;
    public CurrentDomainAssemblyResolver(String[] assemblyFiles, Func`2<string, string> resolveAssemblyReference);
    private Assembly ResolveReferencedAssemblies(object sender, ResolveEventArgs args);
    public sealed virtual void Dispose();
}
public class Mono.TextTemplating.CustomDirective : object {
    [CompilerGeneratedAttribute]
private string <ProcessorName>k__BackingField;
    [CompilerGeneratedAttribute]
private Directive <Directive>k__BackingField;
    public string ProcessorName { get; public set; }
    public Directive Directive { get; public set; }
    public CustomDirective(string processorName, Directive directive);
    [CompilerGeneratedAttribute]
public string get_ProcessorName();
    [CompilerGeneratedAttribute]
public void set_ProcessorName(string value);
    [CompilerGeneratedAttribute]
public Directive get_Directive();
    [CompilerGeneratedAttribute]
public void set_Directive(Directive value);
}
public class Mono.TextTemplating.Directive : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <Attributes>k__BackingField;
    [CompilerGeneratedAttribute]
private Location <TagStartLocation>k__BackingField;
    [CompilerGeneratedAttribute]
private Location <StartLocation>k__BackingField;
    [CompilerGeneratedAttribute]
private Location <EndLocation>k__BackingField;
    public string Name { get; private set; }
    public Dictionary`2<string, string> Attributes { get; private set; }
    public Location TagStartLocation { get; public set; }
    public Location StartLocation { get; private set; }
    public Location EndLocation { get; public set; }
    public Directive(string name, Location start);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, string> get_Attributes();
    [CompilerGeneratedAttribute]
private void set_Attributes(Dictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public sealed virtual Location get_TagStartLocation();
    [CompilerGeneratedAttribute]
public sealed virtual void set_TagStartLocation(Location value);
    [CompilerGeneratedAttribute]
public sealed virtual Location get_StartLocation();
    [CompilerGeneratedAttribute]
private void set_StartLocation(Location value);
    [CompilerGeneratedAttribute]
public sealed virtual Location get_EndLocation();
    [CompilerGeneratedAttribute]
public sealed virtual void set_EndLocation(Location value);
    public string Extract(string key);
}
internal static class Mono.TextTemplating.FileUtil : object {
    private static string wildcardMarker;
    private static bool isWindows;
    private static FileUtil();
    public static string AbsoluteToRelativePath(string baseDirectoryPath, string absPath);
    private static bool IsSeparator(char ch);
    private static string GetFullPath(string path);
}
public interface Mono.TextTemplating.ISegment {
    public Location StartLocation { get; }
    public Location EndLocation { get; public set; }
    public Location TagStartLocation { get; public set; }
    public abstract virtual Location get_StartLocation();
    public abstract virtual Location get_EndLocation();
    public abstract virtual void set_EndLocation(Location value);
    public abstract virtual Location get_TagStartLocation();
    public abstract virtual void set_TagStartLocation(Location value);
}
internal interface Mono.TextTemplating.ISupportCodeGenerationOptions {
    public abstract virtual void SetCodeGenerationOptions(CodeGenerationOptions options);
}
public class Mono.TextTemplating.Location : ValueType {
    [CompilerGeneratedAttribute]
private int <Line>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Column>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FileName>k__BackingField;
    public int Line { get; private set; }
    public int Column { get; private set; }
    public string FileName { get; private set; }
    public static Location Empty { get; }
    public Location(string fileName, int line, int column);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_Line();
    [CompilerGeneratedAttribute]
private void set_Line(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_Column();
    [CompilerGeneratedAttribute]
private void set_Column(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_FileName();
    [CompilerGeneratedAttribute]
private void set_FileName(string value);
    public static Location get_Empty();
    public Location AddLine();
    public Location AddCol();
    public Location AddCols(int number);
    public virtual string ToString();
    public sealed virtual bool Equals(Location other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(Location left, Location right);
    public static bool op_Inequality(Location left, Location right);
}
public class Mono.TextTemplating.ParsedTemplate : object {
    private List`1<ISegment> importedHelperSegments;
    private string rootFileName;
    [CompilerGeneratedAttribute]
private List`1<ISegment> <RawSegments>k__BackingField;
    [CompilerGeneratedAttribute]
private CompilerErrorCollection <Errors>k__BackingField;
    public List`1<ISegment> RawSegments { get; }
    public IEnumerable`1<Directive> Directives { get; }
    public IEnumerable`1<TemplateSegment> Content { get; }
    public CompilerErrorCollection Errors { get; }
    public ParsedTemplate(string rootFileName);
    [CompilerGeneratedAttribute]
public List`1<ISegment> get_RawSegments();
    [IteratorStateMachineAttribute("Mono.TextTemplating.ParsedTemplate/<get_Directives>d__7")]
public IEnumerable`1<Directive> get_Directives();
    [IteratorStateMachineAttribute("Mono.TextTemplating.ParsedTemplate/<get_Content>d__9")]
public IEnumerable`1<TemplateSegment> get_Content();
    [CompilerGeneratedAttribute]
public CompilerErrorCollection get_Errors();
    [ObsoleteAttribute("Use TemplateGenerator.ParseTemplate")]
public static ParsedTemplate FromText(string content, ITextTemplatingEngineHost host);
    internal static ParsedTemplate FromTextInternal(string content, ITextTemplatingEngineHost host);
    [ObsoleteAttribute("Use TemplateGenerator.ParseTemplate")]
public void Parse(ITextTemplatingEngineHost host, Tokeniser tokeniser);
    [ObsoleteAttribute("Should not have been public")]
public void ParseWithoutIncludes(Tokeniser tokeniser);
    private void Parse(ITextTemplatingEngineHost host, HashSet`1<string> includedFiles, Tokeniser tokeniser, bool parseIncludes);
    private void Parse(ITextTemplatingEngineHost host, HashSet`1<string> includedFiles, Tokeniser tokeniser, bool parseIncludes, bool isImport);
    private static string FixWindowsPath(string path);
    private void Import(ITextTemplatingEngineHost host, HashSet`1<string> includedFiles, Directive includeDirective, string relativeToDirectory);
    private void AppendAnyImportedHelperSegments();
    private void LogError(string message, Location location, bool isWarning);
    public void LogError(string message);
    public void LogWarning(string message);
    public void LogError(string message, Location location);
    public void LogWarning(string message, Location location);
}
public class Mono.TextTemplating.ParserException : Exception {
    [CompilerGeneratedAttribute]
private Location <Location>k__BackingField;
    public Location Location { get; private set; }
    public ParserException(string message, Location location);
    [CompilerGeneratedAttribute]
public Location get_Location();
    [CompilerGeneratedAttribute]
private void set_Location(Location value);
}
public enum Mono.TextTemplating.SegmentType : Enum {
    public int value__;
    public static SegmentType Block;
    public static SegmentType Expression;
    public static SegmentType Content;
    public static SegmentType Helper;
}
public enum Mono.TextTemplating.State : Enum {
    public int value__;
    public static State Content;
    public static State Directive;
    public static State Expression;
    public static State Block;
    public static State Helper;
    public static State DirectiveName;
    public static State DirectiveValue;
    public static State Name;
    public static State EOF;
}
[ExtensionAttribute]
internal static class Mono.TextTemplating.StringUtil : object {
    [ExtensionAttribute]
public static bool Contains(string str, char c);
    [ExtensionAttribute]
public static bool IsNullOrWhiteSpace(string value);
    [ExtensionAttribute]
public static bool IsNullOrEmpty(string value);
    [ExtensionAttribute]
public static string NullIfEmpty(string value);
}
public class Mono.TextTemplating.TemplateGenerator : MarshalByRefObject {
    private static Dictionary`2<string, string> KnownAssemblies;
    private TemplatingEngine engine;
    private Encoding encoding;
    [CompilerGeneratedAttribute]
private CompilerErrorCollection <Errors>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <Refs>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <Imports>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <IncludePaths>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <ReferencePaths>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OutputFile>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TemplateFile>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseRelativeLinePragmas>k__BackingField;
    private Dictionary`2<ParameterKey, string> parameters;
    private Dictionary`2<string, KeyValuePair`2<string, string>> directiveProcessors;
    private ITextTemplatingSession session;
    private static Char[] parameterInitialSplitChars;
    public CompilerErrorCollection Errors { get; }
    public List`1<string> Refs { get; }
    public List`1<string> Imports { get; }
    public List`1<string> IncludePaths { get; }
    public List`1<string> ReferencePaths { get; }
    public string OutputFile { get; protected set; }
    public string TemplateFile { get; protected set; }
    public bool UseRelativeLinePragmas { get; public set; }
    protected internal TemplatingEngine Engine { get; }
    private IList`1<string> Microsoft.VisualStudio.TextTemplating.ITextTemplatingEngineHost.StandardAssemblyReferences { get; }
    private IList`1<string> Microsoft.VisualStudio.TextTemplating.ITextTemplatingEngineHost.StandardImports { get; }
    private ITextTemplatingSession Microsoft.VisualStudio.TextTemplating.ITextTemplatingSessionHost.Session { get; private set; }
    public Type SpecificHostType { get; }
    private static TemplateGenerator();
    [CompilerGeneratedAttribute]
public CompilerErrorCollection get_Errors();
    [CompilerGeneratedAttribute]
public List`1<string> get_Refs();
    [CompilerGeneratedAttribute]
public List`1<string> get_Imports();
    [CompilerGeneratedAttribute]
public List`1<string> get_IncludePaths();
    [CompilerGeneratedAttribute]
public List`1<string> get_ReferencePaths();
    [CompilerGeneratedAttribute]
public string get_OutputFile();
    [CompilerGeneratedAttribute]
protected void set_OutputFile(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_TemplateFile();
    [CompilerGeneratedAttribute]
protected void set_TemplateFile(string value);
    [CompilerGeneratedAttribute]
public bool get_UseRelativeLinePragmas();
    [CompilerGeneratedAttribute]
public void set_UseRelativeLinePragmas(bool value);
    [ObsoleteAttribute("Use CompileTemplateAsync")]
public CompiledTemplate CompileTemplate(string content);
    public Task`1<CompiledTemplate> CompileTemplateAsync(string content, CancellationToken token);
    protected internal TemplatingEngine get_Engine();
    private void InitializeForRun(string inputFileName, string outputFileName, Encoding encoding);
    [ObsoleteAttribute("Use ProcessTemplateAsync")]
public bool ProcessTemplate(string inputFile, string outputFile);
    [AsyncStateMachineAttribute("Mono.TextTemplating.TemplateGenerator/<ProcessTemplateAsync>d__37")]
public Task`1<bool> ProcessTemplateAsync(string inputFile, string outputFile, CancellationToken token);
    [ObsoleteAttribute("Use ProcessTemplateAsync")]
public bool ProcessTemplate(string inputFileName, string inputContent, String& outputFileName, String& outputContent);
    [AsyncStateMachineAttribute("Mono.TextTemplating.TemplateGenerator/<ProcessTemplateAsync>d__39")]
public Task`1<ValueTuple`3<string, string, bool>> ProcessTemplateAsync(string inputFileName, string inputContent, string outputFileName, CancellationToken token);
    public bool PreprocessTemplate(string inputFile, string className, string classNamespace, string outputFile, Encoding encoding, String& language, String[]& references);
    public bool PreprocessTemplate(string inputFileName, string className, string classNamespace, string inputContent, String& language, String[]& references, String& outputContent);
    private CompilerError AddError(string error);
    public ParsedTemplate ParseTemplate(string inputFile, string inputContent);
    [ObsoleteAttribute("Use overload without redundant `language` parameter")]
public string PreprocessTemplate(ParsedTemplate pt, string inputFile, string inputContent, TemplateSettings settings, String& language, String[]& references);
    public string PreprocessTemplate(ParsedTemplate pt, string inputFile, string inputContent, TemplateSettings settings, String[]& references);
    [AsyncStateMachineAttribute("Mono.TextTemplating.TemplateGenerator/<ProcessTemplateAsync>d__46")]
public Task`1<ValueTuple`2<string, string>> ProcessTemplateAsync(ParsedTemplate pt, string inputFileName, string inputContent, string outputFileName, TemplateSettings settings, CancellationToken token);
    public virtual object GetHostOption(string optionName);
    public virtual AppDomain ProvideTemplatingAppDomain(string content);
    protected virtual string ResolveAssemblyReference(string assemblyReference);
    protected virtual string ResolveParameterValue(string directiveId, string processorName, string parameterName);
    protected virtual Type ResolveDirectiveProcessor(string processorName);
    protected virtual string ResolvePath(string path);
    public void AddDirectiveProcessor(string name, string klass, string assembly);
    public void AddParameter(string processorName, string directiveName, string parameterName, string value);
    public bool TryAddParameter(string unparsedParameter);
    internal static bool TryParseParameter(string parameter, String& processor, String& directive, String& name, String& value);
    protected virtual bool LoadIncludeText(string requestFileName, String& content, String& location);
    private sealed virtual override bool Microsoft.VisualStudio.TextTemplating.ITextTemplatingEngineHost.LoadIncludeText(string requestFileName, String& content, String& location);
    private sealed virtual override void Microsoft.VisualStudio.TextTemplating.ITextTemplatingEngineHost.LogErrors(CompilerErrorCollection errors);
    private sealed virtual override string Microsoft.VisualStudio.TextTemplating.ITextTemplatingEngineHost.ResolveAssemblyReference(string assemblyReference);
    private sealed virtual override string Microsoft.VisualStudio.TextTemplating.ITextTemplatingEngineHost.ResolveParameterValue(string directiveId, string processorName, string parameterName);
    private sealed virtual override Type Microsoft.VisualStudio.TextTemplating.ITextTemplatingEngineHost.ResolveDirectiveProcessor(string processorName);
    private sealed virtual override string Microsoft.VisualStudio.TextTemplating.ITextTemplatingEngineHost.ResolvePath(string path);
    private sealed virtual override void Microsoft.VisualStudio.TextTemplating.ITextTemplatingEngineHost.SetFileExtension(string extension);
    private sealed virtual override void Microsoft.VisualStudio.TextTemplating.ITextTemplatingEngineHost.SetOutputEncoding(Encoding encoding, bool fromOutputDirective);
    private sealed virtual override IList`1<string> Microsoft.VisualStudio.TextTemplating.ITextTemplatingEngineHost.get_StandardAssemblyReferences();
    private sealed virtual override IList`1<string> Microsoft.VisualStudio.TextTemplating.ITextTemplatingEngineHost.get_StandardImports();
    public ITextTemplatingSession GetOrCreateSession();
    protected virtual ITextTemplatingSession CreateSession();
    private sealed virtual override ITextTemplatingSession Microsoft.VisualStudio.TextTemplating.ITextTemplatingSessionHost.get_Session();
    private sealed virtual override void Microsoft.VisualStudio.TextTemplating.ITextTemplatingSessionHost.set_Session(ITextTemplatingSession value);
    private sealed virtual override ITextTemplatingSession Microsoft.VisualStudio.TextTemplating.ITextTemplatingSessionHost.CreateSession();
    public void ClearSession();
    public virtual Type get_SpecificHostType();
    [IteratorStateMachineAttribute("Mono.TextTemplating.TemplateGenerator/<GetAdditionalDirectiveProcessors>d__84")]
public virtual IEnumerable`1<IDirectiveProcessor> GetAdditionalDirectiveProcessors();
}
public class Mono.TextTemplating.TemplateSegment : object {
    [CompilerGeneratedAttribute]
private SegmentType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Text>k__BackingField;
    [CompilerGeneratedAttribute]
private Location <TagStartLocation>k__BackingField;
    [CompilerGeneratedAttribute]
private Location <StartLocation>k__BackingField;
    [CompilerGeneratedAttribute]
private Location <EndLocation>k__BackingField;
    public SegmentType Type { get; private set; }
    public string Text { get; private set; }
    public Location TagStartLocation { get; public set; }
    public Location StartLocation { get; private set; }
    public Location EndLocation { get; public set; }
    public TemplateSegment(SegmentType type, string text, Location start);
    [CompilerGeneratedAttribute]
public SegmentType get_Type();
    [CompilerGeneratedAttribute]
private void set_Type(SegmentType value);
    [CompilerGeneratedAttribute]
public string get_Text();
    [CompilerGeneratedAttribute]
private void set_Text(string value);
    [CompilerGeneratedAttribute]
public sealed virtual Location get_TagStartLocation();
    [CompilerGeneratedAttribute]
public sealed virtual void set_TagStartLocation(Location value);
    [CompilerGeneratedAttribute]
public sealed virtual Location get_StartLocation();
    [CompilerGeneratedAttribute]
private void set_StartLocation(Location value);
    [CompilerGeneratedAttribute]
public sealed virtual Location get_EndLocation();
    [CompilerGeneratedAttribute]
public sealed virtual void set_EndLocation(Location value);
}
public class Mono.TextTemplating.TemplateSettings : object {
    [CompilerGeneratedAttribute]
private bool <HostSpecific>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HostPropertyOnBase>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Debug>k__BackingField;
    [CompilerGeneratedAttribute]
private TextWriter <Log>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Inherits>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Namespace>k__BackingField;
    [CompilerGeneratedAttribute]
private HashSet`1<string> <Imports>k__BackingField;
    [CompilerGeneratedAttribute]
private HashSet`1<string> <Assemblies>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeDomProvider <Provider>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Language>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LangVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CompilerOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private Encoding <Encoding>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Extension>k__BackingField;
    [CompilerGeneratedAttribute]
private CultureInfo <Culture>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<CustomDirective> <CustomDirectives>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, IDirectiveProcessor> <DirectiveProcessors>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludePreprocessingHelpers>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsPreprocessed>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RelativeLinePragmas>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <NoLinePragmas>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <InternalVisibility>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <HostType>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeGenerationOptions <CodeGenerationOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RelativeLinePragmasBaseDirectory>k__BackingField;
    public bool HostSpecific { get; public set; }
    public bool HostPropertyOnBase { get; public set; }
    public bool Debug { get; public set; }
    public TextWriter Log { get; public set; }
    public string Inherits { get; public set; }
    public string Name { get; public set; }
    public string Namespace { get; public set; }
    public HashSet`1<string> Imports { get; private set; }
    public HashSet`1<string> Assemblies { get; private set; }
    public CodeDomProvider Provider { get; public set; }
    public string Language { get; public set; }
    public string LangVersion { get; public set; }
    public string CompilerOptions { get; public set; }
    public Encoding Encoding { get; public set; }
    public string Extension { get; public set; }
    public CultureInfo Culture { get; public set; }
    public List`1<CustomDirective> CustomDirectives { get; private set; }
    public Dictionary`2<string, IDirectiveProcessor> DirectiveProcessors { get; private set; }
    public bool IncludePreprocessingHelpers { get; public set; }
    public bool IsPreprocessed { get; public set; }
    public bool RelativeLinePragmas { get; public set; }
    public bool NoLinePragmas { get; public set; }
    public bool InternalVisibility { get; public set; }
    public Type HostType { get; public set; }
    internal CodeGenerationOptions CodeGenerationOptions { get; }
    internal string RelativeLinePragmasBaseDirectory { get; internal set; }
    [CompilerGeneratedAttribute]
public bool get_HostSpecific();
    [CompilerGeneratedAttribute]
public void set_HostSpecific(bool value);
    [CompilerGeneratedAttribute]
public bool get_HostPropertyOnBase();
    [CompilerGeneratedAttribute]
public void set_HostPropertyOnBase(bool value);
    [CompilerGeneratedAttribute]
public bool get_Debug();
    [CompilerGeneratedAttribute]
public void set_Debug(bool value);
    [CompilerGeneratedAttribute]
public TextWriter get_Log();
    [CompilerGeneratedAttribute]
public void set_Log(TextWriter value);
    [CompilerGeneratedAttribute]
public string get_Inherits();
    [CompilerGeneratedAttribute]
public void set_Inherits(string value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_Namespace();
    [CompilerGeneratedAttribute]
public void set_Namespace(string value);
    [CompilerGeneratedAttribute]
public HashSet`1<string> get_Imports();
    [CompilerGeneratedAttribute]
private void set_Imports(HashSet`1<string> value);
    [CompilerGeneratedAttribute]
public HashSet`1<string> get_Assemblies();
    [CompilerGeneratedAttribute]
private void set_Assemblies(HashSet`1<string> value);
    [CompilerGeneratedAttribute]
public CodeDomProvider get_Provider();
    [CompilerGeneratedAttribute]
public void set_Provider(CodeDomProvider value);
    [CompilerGeneratedAttribute]
public string get_Language();
    [CompilerGeneratedAttribute]
public void set_Language(string value);
    [CompilerGeneratedAttribute]
public string get_LangVersion();
    [CompilerGeneratedAttribute]
public void set_LangVersion(string value);
    [CompilerGeneratedAttribute]
public string get_CompilerOptions();
    [CompilerGeneratedAttribute]
public void set_CompilerOptions(string value);
    [CompilerGeneratedAttribute]
public Encoding get_Encoding();
    [CompilerGeneratedAttribute]
public void set_Encoding(Encoding value);
    [CompilerGeneratedAttribute]
public string get_Extension();
    [CompilerGeneratedAttribute]
public void set_Extension(string value);
    [CompilerGeneratedAttribute]
public CultureInfo get_Culture();
    [CompilerGeneratedAttribute]
public void set_Culture(CultureInfo value);
    [CompilerGeneratedAttribute]
public List`1<CustomDirective> get_CustomDirectives();
    [CompilerGeneratedAttribute]
private void set_CustomDirectives(List`1<CustomDirective> value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, IDirectiveProcessor> get_DirectiveProcessors();
    [CompilerGeneratedAttribute]
private void set_DirectiveProcessors(Dictionary`2<string, IDirectiveProcessor> value);
    [CompilerGeneratedAttribute]
public bool get_IncludePreprocessingHelpers();
    [CompilerGeneratedAttribute]
public void set_IncludePreprocessingHelpers(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsPreprocessed();
    [CompilerGeneratedAttribute]
public void set_IsPreprocessed(bool value);
    [CompilerGeneratedAttribute]
public bool get_RelativeLinePragmas();
    [CompilerGeneratedAttribute]
public void set_RelativeLinePragmas(bool value);
    [CompilerGeneratedAttribute]
public bool get_NoLinePragmas();
    [CompilerGeneratedAttribute]
public void set_NoLinePragmas(bool value);
    [CompilerGeneratedAttribute]
public bool get_InternalVisibility();
    [CompilerGeneratedAttribute]
public void set_InternalVisibility(bool value);
    [CompilerGeneratedAttribute]
public Type get_HostType();
    [CompilerGeneratedAttribute]
public void set_HostType(Type value);
    public string GetFullName();
    [CompilerGeneratedAttribute]
internal CodeGenerationOptions get_CodeGenerationOptions();
    [CompilerGeneratedAttribute]
internal string get_RelativeLinePragmasBaseDirectory();
    [CompilerGeneratedAttribute]
internal void set_RelativeLinePragmasBaseDirectory(string value);
}
[ObsoleteAttribute("This was never fully implemented and is outside the scope of this library")]
public class Mono.TextTemplating.TemplatingAppDomainRecycler : object {
    private static int DEFAULT_MAX_USES;
    private string name;
    private object lockObj;
    private RecyclableAppDomain domain;
    public TemplatingAppDomainRecycler(string name);
    public Handle GetHandle();
}
public class Mono.TextTemplating.TemplatingEngine : MarshalByRefObject {
    private Func`2<RuntimeInfo, CodeCompiler> createCompilerFunc;
    private CodeCompiler cachedCompiler;
    [ObsoleteAttribute("Should not have been public")]
public static void GenerateCodeFromMembers(CodeDomProvider provider, CodeGeneratorOptions options, StringWriter sw, IEnumerable`1<CodeTypeMember> members);
    [ObsoleteAttribute("Should not have been public")]
public static string GenerateIndentedClassCode(CodeDomProvider provider, CodeTypeMember[] members);
    [ObsoleteAttribute("Should not have been public")]
public static string GenerateIndentedClassCode(CodeDomProvider provider, IEnumerable`1<CodeTypeMember> members);
    [ObsoleteAttribute("Should not have been public")]
public static string IndentSnippetText(CodeDomProvider provider, string text, string indent);
    [ObsoleteAttribute("Should not have been public")]
public static string IndentSnippetText(string text, string indent);
    public static CodeCompileUnit GenerateCompileUnit(ITextTemplatingEngineHost host, string content, ParsedTemplate pt, TemplateSettings settings);
    private static void GenerateTransformMethod(CodeTypeDeclaration templateType, TemplateSettings settings, ParsedTemplate pt, string templateFile, bool isOverride);
    private static void ProcessDirectives(string content, TemplateSettings settings, CompilerErrorCollection errors);
    private static void GenerateHostProperty(CodeTypeDeclaration type, Type hostType);
    private static void GenerateInitializationMethod(CodeTypeDeclaration type, TemplateSettings settings, bool isOverride);
    internal void SetCompilerFunc(Func`2<RuntimeInfo, CodeCompiler> createCompiler);
    private CodeCompiler GetOrCreateCompiler();
    [ObsoleteAttribute("Use ProcessTemplateAsync")]
public sealed virtual string ProcessTemplate(string content, ITextTemplatingEngineHost host);
    [AsyncStateMachineAttribute("Mono.TextTemplating.TemplatingEngine/<ProcessTemplateAsync>d__15")]
public Task`1<string> ProcessTemplateAsync(string content, ITextTemplatingEngineHost host, CancellationToken token);
    [AsyncStateMachineAttribute("Mono.TextTemplating.TemplatingEngine/<ProcessTemplateAsync>d__16")]
public Task`1<string> ProcessTemplateAsync(ParsedTemplate pt, string content, TemplateSettings settings, ITextTemplatingEngineHost host, CancellationToken token);
    public sealed virtual string PreprocessTemplate(string content, ITextTemplatingEngineHost host, string className, string classNamespace, String& language, String[]& references);
    [ObsoleteAttribute("Use static method")]
public string PreprocessTemplate(ParsedTemplate pt, string content, TemplateSettings settings, ITextTemplatingEngineHost host, String& language, String[]& references);
    [ObsoleteAttribute("Use TemplateGenerator")]
public string PreprocessTemplate(ParsedTemplate pt, string content, ITextTemplatingEngineHost host, string className, string classNamespace, String& language, String[]& references, TemplateSettings settings);
    public static string PreprocessTemplate(ParsedTemplate pt, string content, TemplateSettings settings, ITextTemplatingEngineHost host, String[]& references);
    private static string PreprocessTemplateInternal(ParsedTemplate pt, string content, ITextTemplatingEngineHost host, string className, string classNamespace, String& language, String[]& references, TemplateSettings settings);
    internal static string PreprocessTemplateInternal(ParsedTemplate pt, string content, TemplateSettings settings, ITextTemplatingEngineHost host, String[]& references);
    [ObsoleteAttribute("Use CompileTemplateAsync")]
public CompiledTemplate CompileTemplate(string content, ITextTemplatingEngineHost host);
    [AsyncStateMachineAttribute("Mono.TextTemplating.TemplatingEngine/<CompileTemplateAsync>d__24")]
public Task`1<CompiledTemplate> CompileTemplateAsync(string content, ITextTemplatingEngineHost host, CancellationToken token);
    [ObsoleteAttribute("Use CompileTemplateAsync")]
public CompiledTemplate CompileTemplate(ParsedTemplate pt, string content, ITextTemplatingEngineHost host, TemplateSettings settings);
    [ObsoleteAttribute("Use CompileTemplateAsync")]
public CompiledTemplate CompileTemplate(ParsedTemplate pt, string content, ITextTemplatingEngineHost host, String[]& references, TemplateSettings settings);
    public Task`1<Nullable`1<ValueTuple`2<CompiledTemplate, String[]>>> CompileTemplateAsync(ParsedTemplate pt, string content, ITextTemplatingEngineHost host, TemplateSettings settings, CancellationToken token);
    [AsyncStateMachineAttribute("Mono.TextTemplating.TemplatingEngine/<CompileTemplateInternal>d__28")]
private Task`1<Nullable`1<ValueTuple`2<CompiledTemplate, String[]>>> CompileTemplateInternal(ParsedTemplate pt, string content, ITextTemplatingEngineHost host, TemplateSettings settings, CancellationToken token);
    [AsyncStateMachineAttribute("Mono.TextTemplating.TemplatingEngine/<CompileCode>d__29")]
private Task`1<ValueTuple`2<CompilerResults, CompiledAssemblyData>> CompileCode(IEnumerable`1<string> references, TemplateSettings settings, CodeCompileUnit ccu, CancellationToken token);
    private static String[] ProcessReferences(ITextTemplatingEngineHost host, ParsedTemplate pt, TemplateSettings settings);
    public static TemplateSettings GetSettings(ITextTemplatingEngineHost host, ParsedTemplate pt);
    private static void AddDirective(TemplateSettings settings, ITextTemplatingEngineHost host, string processorName, Directive directive);
    private static bool ComplainExcessAttributes(Directive dt, ParsedTemplate pt);
}
internal class Mono.TextTemplating.TemplatingEngineException : Exception {
    public TemplatingEngineException(string message);
    public TemplatingEngineException(string message, Exception inner);
    protected TemplatingEngineException(SerializationInfo info, StreamingContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Mono.TextTemplating.TempSubdirectoryHelper : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Func`2<string, DirectoryInfo> ClassLibsImpl;
    private static bool isWindows;
    private static Char[] DirectorySeparatorChars;
    private static int MaxShortPath;
    private static int ERROR_ALREADY_EXISTS;
    private static string IO_MaxAttemptsReached;
    private static TempSubdirectoryHelper();
    public static DirectoryInfo Create(string prefix);
    private static string CreateTempSubdirectoryCoreUnix(string prefix);
    [NullableContextAttribute("0")]
private static Byte* libc_mkdtemp(Byte* path);
    private static void Unix_ThrowIOExceptionForLastError();
    private static string CreateTempSubdirectoryCoreWindows(string prefix);
    private static void ThrowExceptionForWin32Error(int error);
    private static int MakeHRFromErrorCode(int errorCode);
}
public class Mono.TextTemplating.Tokeniser : object {
    private string content;
    private int position;
    private string value;
    private State nextState;
    private Location nextStateLocation;
    private Location nextStateTagStartLocation;
    [CompilerGeneratedAttribute]
private State <State>k__BackingField;
    [CompilerGeneratedAttribute]
private Location <Location>k__BackingField;
    [CompilerGeneratedAttribute]
private Location <TagStartLocation>k__BackingField;
    [CompilerGeneratedAttribute]
private Location <TagEndLocation>k__BackingField;
    public State State { get; private set; }
    public int Position { get; }
    public string Content { get; }
    public string Value { get; }
    public Location Location { get; private set; }
    public Location TagStartLocation { get; private set; }
    public Location TagEndLocation { get; private set; }
    public Tokeniser(string fileName, string content);
    public bool Advance();
    private State GetNextStateAndCurrentValue();
    private State GetBlockEnd();
    private State GetDirectiveName();
    private State GetDirectiveValue();
    private State NextStateInContent();
    private int IsNewLine();
    private State NextStateInDirective();
    [CompilerGeneratedAttribute]
public State get_State();
    [CompilerGeneratedAttribute]
private void set_State(State value);
    public int get_Position();
    public string get_Content();
    public string get_Value();
    [CompilerGeneratedAttribute]
public Location get_Location();
    [CompilerGeneratedAttribute]
private void set_Location(Location value);
    [CompilerGeneratedAttribute]
public Location get_TagStartLocation();
    [CompilerGeneratedAttribute]
private void set_TagStartLocation(Location value);
    [CompilerGeneratedAttribute]
public Location get_TagEndLocation();
    [CompilerGeneratedAttribute]
private void set_TagEndLocation(Location value);
}
internal static class Mono.TextTemplating.Utf8 : object {
    public static Encoding BomlessEncoding;
    private static Utf8();
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[GeneratedCodeAttribute("Nerdbank.GitVersioning.Tasks", "3.6.133.12845")]
[ExcludeFromCodeCoverageAttribute]
internal static class ThisAssembly : object {
    internal static string AssemblyConfiguration;
    internal static string AssemblyFileVersion;
    internal static string AssemblyInformationalVersion;
    internal static string AssemblyName;
    internal static string AssemblyTitle;
    internal static string AssemblyVersion;
    internal static DateTime GitCommitDate;
    internal static string GitCommitId;
    internal static bool IsPrerelease;
    internal static bool IsPublicRelease;
    internal static string PublicKey;
    internal static string PublicKeyToken;
    internal static string RootNamespace;
    private static ThisAssembly();
}
