public abstract class Microsoft.VisualStudio.TextTemplating.DirectiveProcessor : object {
    private CompilerErrorCollection errors;
    private CompilerErrorCollection Microsoft.VisualStudio.TextTemplating.IDirectiveProcessor.Errors { get; }
    private bool Microsoft.VisualStudio.TextTemplating.IDirectiveProcessor.RequiresProcessingRunIsHostSpecific { get; }
    public virtual void Initialize(ITextTemplatingEngineHost host);
    public virtual void StartProcessingRun(CodeDomProvider languageProvider, string templateContents, CompilerErrorCollection errors);
    public abstract virtual void FinishProcessingRun();
    public abstract virtual string GetClassCodeForProcessingRun();
    public abstract virtual String[] GetImportsForProcessingRun();
    public abstract virtual string GetPostInitializationCodeForProcessingRun();
    public abstract virtual string GetPreInitializationCodeForProcessingRun();
    public abstract virtual String[] GetReferencesForProcessingRun();
    public abstract virtual bool IsDirectiveSupported(string directiveName);
    public abstract virtual void ProcessDirective(string directiveName, IDictionary`2<string, string> arguments);
    public virtual CodeAttributeDeclarationCollection GetTemplateClassCustomAttributes();
    private sealed virtual override CompilerErrorCollection Microsoft.VisualStudio.TextTemplating.IDirectiveProcessor.get_Errors();
    private sealed virtual override void Microsoft.VisualStudio.TextTemplating.IDirectiveProcessor.SetProcessingRunIsHostSpecific(bool hostSpecific);
    private sealed virtual override bool Microsoft.VisualStudio.TextTemplating.IDirectiveProcessor.get_RequiresProcessingRunIsHostSpecific();
}
public class Microsoft.VisualStudio.TextTemplating.DirectiveProcessorException : Exception {
    public DirectiveProcessorException(string message);
    public DirectiveProcessorException(SerializationInfo info, StreamingContext context);
    public DirectiveProcessorException(string message, Exception inner);
}
[ObsoleteAttribute("Not implemented")]
public static class Microsoft.VisualStudio.TextTemplating.EncodingHelper : object {
    public static Encoding GetEncoding(string filePath);
}
[ObsoleteAttribute("Use Mono.TextTemplating.TemplatingEngine directly")]
public class Microsoft.VisualStudio.TextTemplating.Engine : object {
    private TemplatingEngine engine;
    public static string CacheAssembliesOptionString;
    public sealed virtual string ProcessTemplate(string content, ITextTemplatingEngineHost host);
    public sealed virtual string PreprocessTemplate(string content, ITextTemplatingEngineHost host, string className, string classNamespace, String& language, String[]& references);
}
public interface Microsoft.VisualStudio.TextTemplating.IDirectiveProcessor {
    public CompilerErrorCollection Errors { get; }
    public bool RequiresProcessingRunIsHostSpecific { get; }
    public abstract virtual CompilerErrorCollection get_Errors();
    public abstract virtual bool get_RequiresProcessingRunIsHostSpecific();
    public abstract virtual void FinishProcessingRun();
    public abstract virtual string GetClassCodeForProcessingRun();
    public abstract virtual String[] GetImportsForProcessingRun();
    public abstract virtual string GetPostInitializationCodeForProcessingRun();
    public abstract virtual string GetPreInitializationCodeForProcessingRun();
    public abstract virtual String[] GetReferencesForProcessingRun();
    public abstract virtual CodeAttributeDeclarationCollection GetTemplateClassCustomAttributes();
    public abstract virtual void Initialize(ITextTemplatingEngineHost host);
    public abstract virtual bool IsDirectiveSupported(string directiveName);
    public abstract virtual void ProcessDirective(string directiveName, IDictionary`2<string, string> arguments);
    public abstract virtual void SetProcessingRunIsHostSpecific(bool hostSpecific);
    public abstract virtual void StartProcessingRun(CodeDomProvider languageProvider, string templateContents, CompilerErrorCollection errors);
}
public interface Microsoft.VisualStudio.TextTemplating.IRecognizeHostSpecific {
    public bool RequiresProcessingRunIsHostSpecific { get; }
    public abstract virtual void SetProcessingRunIsHostSpecific(bool hostSpecific);
    public abstract virtual bool get_RequiresProcessingRunIsHostSpecific();
}
[ObsoleteAttribute("Use Mono.TextTemplating.TemplatingEngine directly")]
public interface Microsoft.VisualStudio.TextTemplating.ITextTemplatingEngine {
    public abstract virtual string ProcessTemplate(string content, ITextTemplatingEngineHost host);
    public abstract virtual string PreprocessTemplate(string content, ITextTemplatingEngineHost host, string className, string classNamespace, String& language, String[]& references);
}
public interface Microsoft.VisualStudio.TextTemplating.ITextTemplatingEngineHost {
    public IList`1<string> StandardAssemblyReferences { get; }
    public IList`1<string> StandardImports { get; }
    public string TemplateFile { get; }
    public abstract virtual object GetHostOption(string optionName);
    public abstract virtual bool LoadIncludeText(string requestFileName, String& content, String& location);
    public abstract virtual void LogErrors(CompilerErrorCollection errors);
    public abstract virtual AppDomain ProvideTemplatingAppDomain(string content);
    public abstract virtual string ResolveAssemblyReference(string assemblyReference);
    public abstract virtual Type ResolveDirectiveProcessor(string processorName);
    public abstract virtual string ResolveParameterValue(string directiveId, string processorName, string parameterName);
    public abstract virtual string ResolvePath(string path);
    public abstract virtual void SetFileExtension(string extension);
    public abstract virtual void SetOutputEncoding(Encoding encoding, bool fromOutputDirective);
    public abstract virtual IList`1<string> get_StandardAssemblyReferences();
    public abstract virtual IList`1<string> get_StandardImports();
    public abstract virtual string get_TemplateFile();
}
public interface Microsoft.VisualStudio.TextTemplating.ITextTemplatingSession {
    public Guid Id { get; }
    public abstract virtual Guid get_Id();
}
public interface Microsoft.VisualStudio.TextTemplating.ITextTemplatingSessionHost {
    public ITextTemplatingSession Session { get; public set; }
    public abstract virtual ITextTemplatingSession CreateSession();
    public abstract virtual ITextTemplatingSession get_Session();
    public abstract virtual void set_Session(ITextTemplatingSession value);
}
public class Microsoft.VisualStudio.TextTemplating.ParameterDirectiveProcessor : DirectiveProcessor {
    private CodeDomProvider provider;
    private bool hostSpecific;
    private List`1<CodeStatement> postStatements;
    private List`1<CodeTypeMember> members;
    private static Dictionary`2<string, string> BuiltinTypesMap;
    public bool RequiresProcessingRunIsHostSpecific { get; }
    private static ParameterDirectiveProcessor();
    public virtual void StartProcessingRun(CodeDomProvider languageProvider, string templateContents, CompilerErrorCollection errors);
    public virtual void FinishProcessingRun();
    public virtual string GetClassCodeForProcessingRun();
    public virtual String[] GetImportsForProcessingRun();
    public virtual string GetPostInitializationCodeForProcessingRun();
    public virtual string GetPreInitializationCodeForProcessingRun();
    private string StatementsToCode(List`1<CodeStatement> statements);
    public virtual String[] GetReferencesForProcessingRun();
    public virtual bool IsDirectiveSupported(string directiveName);
    public static string MapTypeName(string typeName);
    public virtual void ProcessDirective(string directiveName, IDictionary`2<string, string> arguments);
    private static CodeBinaryOperatorExpression NotNull(CodeExpression reference);
    private static CodeBinaryOperatorExpression IsFalse(CodeExpression expr);
    private static CodeBinaryOperatorExpression BooleanAnd(CodeExpression expr1, CodeExpression expr2);
    private sealed virtual override void Microsoft.VisualStudio.TextTemplating.IRecognizeHostSpecific.SetProcessingRunIsHostSpecific(bool hostSpecific);
    public sealed virtual bool get_RequiresProcessingRunIsHostSpecific();
}
public abstract class Microsoft.VisualStudio.TextTemplating.RequiresProvidesDirectiveProcessor : DirectiveProcessor {
    private bool isInProcessingRun;
    private ITextTemplatingEngineHost host;
    private StringBuilder preInitBuffer;
    private StringBuilder postInitBuffer;
    private StringBuilder codeBuffer;
    private CodeDomProvider languageProvider;
    protected string FriendlyName { get; }
    protected ITextTemplatingEngineHost Host { get; }
    public virtual void Initialize(ITextTemplatingEngineHost host);
    protected abstract virtual void InitializeProvidesDictionary(string directiveName, IDictionary`2<string, string> providesDictionary);
    protected abstract virtual void InitializeRequiresDictionary(string directiveName, IDictionary`2<string, string> requiresDictionary);
    protected abstract virtual string get_FriendlyName();
    protected abstract virtual void GeneratePostInitializationCode(string directiveName, StringBuilder codeBuffer, CodeDomProvider languageProvider, IDictionary`2<string, string> requiresArguments, IDictionary`2<string, string> providesArguments);
    protected abstract virtual void GeneratePreInitializationCode(string directiveName, StringBuilder codeBuffer, CodeDomProvider languageProvider, IDictionary`2<string, string> requiresArguments, IDictionary`2<string, string> providesArguments);
    protected abstract virtual void GenerateTransformCode(string directiveName, StringBuilder codeBuffer, CodeDomProvider languageProvider, IDictionary`2<string, string> requiresArguments, IDictionary`2<string, string> providesArguments);
    protected virtual void PostProcessArguments(string directiveName, IDictionary`2<string, string> requiresArguments, IDictionary`2<string, string> providesArguments);
    public virtual string GetClassCodeForProcessingRun();
    public virtual String[] GetImportsForProcessingRun();
    public virtual String[] GetReferencesForProcessingRun();
    public virtual string GetPostInitializationCodeForProcessingRun();
    public virtual string GetPreInitializationCodeForProcessingRun();
    public virtual void StartProcessingRun(CodeDomProvider languageProvider, string templateContents, CompilerErrorCollection errors);
    public virtual void FinishProcessingRun();
    private void AssertNotProcessing();
    [IteratorStateMachineAttribute("Microsoft.VisualStudio.TextTemplating.RequiresProvidesDirectiveProcessor/<ParseArgs>d__24")]
private IEnumerable`1<KeyValuePair`2<string, string>> ParseArgs(string args);
    public virtual void ProcessDirective(string directiveName, IDictionary`2<string, string> arguments);
    protected virtual string ProvideUniqueId(string directiveName, IDictionary`2<string, string> arguments, IDictionary`2<string, string> requiresArguments, IDictionary`2<string, string> providesArguments);
    protected ITextTemplatingEngineHost get_Host();
}
public class Microsoft.VisualStudio.TextTemplating.TextTemplatingSession : Dictionary`2<string, object> {
    [CompilerGeneratedAttribute]
private Guid <Id>k__BackingField;
    public Guid Id { get; private set; }
    private TextTemplatingSession(SerializationInfo info, StreamingContext context);
    public TextTemplatingSession(Guid id);
    [CompilerGeneratedAttribute]
public sealed virtual Guid get_Id();
    [CompilerGeneratedAttribute]
private void set_Id(Guid value);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(Guid other);
    public sealed virtual bool Equals(ITextTemplatingSession other);
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
}
public abstract class Microsoft.VisualStudio.TextTemplating.TextTransformation : object {
    private Stack`1<int> indents;
    private string currentIndent;
    private CompilerErrorCollection errors;
    private StringBuilder builder;
    private bool endsWithNewline;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, object> <Session>k__BackingField;
    public IDictionary`2<string, object> Session { get; public set; }
    protected internal CompilerErrorCollection Errors { get; }
    private Stack`1<int> Indents { get; }
    public string CurrentIndent { get; }
    protected StringBuilder GenerationEnvironment { get; protected set; }
    public virtual void Initialize();
    public abstract virtual string TransformText();
    [CompilerGeneratedAttribute]
public virtual IDictionary`2<string, object> get_Session();
    [CompilerGeneratedAttribute]
public virtual void set_Session(IDictionary`2<string, object> value);
    public void Error(string message);
    public void Warning(string message);
    protected internal CompilerErrorCollection get_Errors();
    private Stack`1<int> get_Indents();
    public string PopIndent();
    public void PushIndent(string indent);
    public void ClearIndent();
    public string get_CurrentIndent();
    protected StringBuilder get_GenerationEnvironment();
    protected void set_GenerationEnvironment(StringBuilder value);
    public void Write(string textToAppend);
    public void Write(string format, Object[] args);
    public void WriteLine(string textToAppend);
    public void WriteLine(string format, Object[] args);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    protected virtual override void Finalize();
}
public static class Microsoft.VisualStudio.TextTemplating.ToStringHelper : object {
    private static Object[] formatProviderAsParameterArray;
    private static IFormatProvider formatProvider;
    public static IFormatProvider FormatProvider { get; public set; }
    private static ToStringHelper();
    public static string ToStringWithCulture(object objectToConvert);
    public static IFormatProvider get_FormatProvider();
    public static void set_FormatProvider(IFormatProvider value);
}
internal static class Mono.TextTemplating.CodeCompilation.AssemblyResolver : object {
    private static Lazy`1<String[]> KnownNet50RefAssemblyNames;
    private static Lazy`1<String[]> Net472DefaultAssemblyRefs;
    private static Lazy`1<String[]> Net472FacadeNames;
    private static AssemblyResolver();
    [IteratorStateMachineAttribute("Mono.TextTemplating.CodeCompilation.AssemblyResolver/<GetResolvedReferences>d__0")]
public static IEnumerable`1<string> GetResolvedReferences(RuntimeInfo runtime, List`1<string> references);
    private static string Resolve(RuntimeInfo runtime, string reference);
}
internal abstract class Mono.TextTemplating.CodeCompilation.CodeCompiler : object {
    public abstract virtual Task`1<CodeCompilerResult> CompileFile(CodeCompilerArguments arguments, TextWriter log, CancellationToken token);
}
internal class Mono.TextTemplating.CodeCompilation.CodeCompilerArguments : object {
    [CompilerGeneratedAttribute]
private List`1<string> <SourceFiles>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <AssemblyReferences>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AdditionalArguments>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Debug>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OutputPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TempDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LangVersion>k__BackingField;
    public List`1<string> SourceFiles { get; }
    public List`1<string> AssemblyReferences { get; }
    public string AdditionalArguments { get; public set; }
    public bool Debug { get; public set; }
    public string OutputPath { get; public set; }
    public string TempDirectory { get; public set; }
    public string LangVersion { get; public set; }
    [CompilerGeneratedAttribute]
public List`1<string> get_SourceFiles();
    [CompilerGeneratedAttribute]
public List`1<string> get_AssemblyReferences();
    [CompilerGeneratedAttribute]
public string get_AdditionalArguments();
    [CompilerGeneratedAttribute]
public void set_AdditionalArguments(string value);
    [CompilerGeneratedAttribute]
public bool get_Debug();
    [CompilerGeneratedAttribute]
public void set_Debug(bool value);
    [CompilerGeneratedAttribute]
public string get_OutputPath();
    [CompilerGeneratedAttribute]
public void set_OutputPath(string value);
    [CompilerGeneratedAttribute]
public string get_TempDirectory();
    [CompilerGeneratedAttribute]
public void set_TempDirectory(string value);
    [CompilerGeneratedAttribute]
public string get_LangVersion();
    [CompilerGeneratedAttribute]
public void set_LangVersion(string value);
}
internal class Mono.TextTemplating.CodeCompilation.CodeCompilerError : object {
    [CompilerGeneratedAttribute]
private string <Origin>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Line>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Column>k__BackingField;
    [CompilerGeneratedAttribute]
private int <EndLine>k__BackingField;
    [CompilerGeneratedAttribute]
private int <EndColumn>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Subcategory>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsError>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Code>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    public string Origin { get; public set; }
    public int Line { get; public set; }
    public int Column { get; public set; }
    public int EndLine { get; public set; }
    public int EndColumn { get; public set; }
    public string Subcategory { get; public set; }
    public bool IsError { get; public set; }
    public string Code { get; public set; }
    public string Message { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Origin();
    [CompilerGeneratedAttribute]
public void set_Origin(string value);
    [CompilerGeneratedAttribute]
public int get_Line();
    [CompilerGeneratedAttribute]
public void set_Line(int value);
    [CompilerGeneratedAttribute]
public int get_Column();
    [CompilerGeneratedAttribute]
public void set_Column(int value);
    [CompilerGeneratedAttribute]
public int get_EndLine();
    [CompilerGeneratedAttribute]
public void set_EndLine(int value);
    [CompilerGeneratedAttribute]
public int get_EndColumn();
    [CompilerGeneratedAttribute]
public void set_EndColumn(int value);
    [CompilerGeneratedAttribute]
public string get_Subcategory();
    [CompilerGeneratedAttribute]
public void set_Subcategory(string value);
    [CompilerGeneratedAttribute]
public bool get_IsError();
    [CompilerGeneratedAttribute]
public void set_IsError(bool value);
    [CompilerGeneratedAttribute]
public string get_Code();
    [CompilerGeneratedAttribute]
public void set_Code(string value);
    [CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
public void set_Message(string value);
}
internal class Mono.TextTemplating.CodeCompilation.CodeCompilerResult : object {
    [CompilerGeneratedAttribute]
private bool <Success>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<CodeCompilerError> <Errors>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ExitCode>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <Output>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ResponseFile>k__BackingField;
    public bool Success { get; internal set; }
    public List`1<CodeCompilerError> Errors { get; internal set; }
    public int ExitCode { get; internal set; }
    public List`1<string> Output { get; internal set; }
    public string ResponseFile { get; internal set; }
    [CompilerGeneratedAttribute]
public bool get_Success();
    [CompilerGeneratedAttribute]
internal void set_Success(bool value);
    [CompilerGeneratedAttribute]
public List`1<CodeCompilerError> get_Errors();
    [CompilerGeneratedAttribute]
internal void set_Errors(List`1<CodeCompilerError> value);
    [CompilerGeneratedAttribute]
public int get_ExitCode();
    [CompilerGeneratedAttribute]
internal void set_ExitCode(int value);
    [CompilerGeneratedAttribute]
public List`1<string> get_Output();
    [CompilerGeneratedAttribute]
internal void set_Output(List`1<string> value);
    [CompilerGeneratedAttribute]
public string get_ResponseFile();
    [CompilerGeneratedAttribute]
internal void set_ResponseFile(string value);
}
internal class Mono.TextTemplating.CodeCompilation.CscCodeCompiler : CodeCompiler {
    private RuntimeInfo runtime;
    public CscCodeCompiler(RuntimeInfo runtime);
    private static StreamWriter CreateTempTextFile(string extension, String& path);
    [AsyncStateMachineAttribute("Mono.TextTemplating.CodeCompilation.CscCodeCompiler/<CompileFile>d__3")]
public virtual Task`1<CodeCompilerResult> CompileFile(CodeCompilerArguments arguments, TextWriter log, CancellationToken token);
    [CompilerGeneratedAttribute]
internal static void <CompileFile>g__ConsumeOutput|3_0(string s, <>c__DisplayClass3_0& );
}
internal enum Mono.TextTemplating.CodeCompilation.CSharpLangVersion : Enum {
    public int value__;
    public static CSharpLangVersion v5_0;
    public static CSharpLangVersion v6_0;
    public static CSharpLangVersion v7_0;
    public static CSharpLangVersion v7_1;
    public static CSharpLangVersion v7_2;
    public static CSharpLangVersion v7_3;
    public static CSharpLangVersion v8_0;
    public static CSharpLangVersion v9_0;
    public static CSharpLangVersion Latest;
}
internal static class Mono.TextTemplating.CodeCompilation.CSharpLangVersionHelper : object {
    public static CSharpLangVersion GetBestSupportedLangVersion(RuntimeInfo runtime, Nullable`1<CSharpLangVersion> compilerLangVersion);
    private static bool HasLangVersionArg(string args);
    private static string ToString(CSharpLangVersion v);
    public static string GetLangVersionArg(CodeCompilerArguments arguments, RuntimeInfo runtime);
    public static Nullable`1<CSharpLangVersion> FromRoslynPackageVersion(string roslynPackageVersion);
    public static CSharpLangVersion FromNetCoreSdkVersion(SemVersion sdkVersion);
}
internal static class Mono.TextTemplating.CodeCompilation.MSBuildErrorParser : object {
    public static CodeCompilerError TryParseLine(string line);
    private static bool ParseOrigin(string line, int start, int end, CodeCompilerError result);
    private static bool ParseLineColVal(string str, Int32& val);
    private static bool ParsePosition(string str, int start, int end, CodeCompilerError result);
    private static bool ParseCategory(string line, int start, int end, CodeCompilerError result);
    private static void MoveNextNonSpace(string s, Int32& idx);
    private static void MovePrevNonSpace(string s, Int32& idx, int min);
    private static void MovePrevWordStart(string s, Int32& idx, int min);
}
internal class Mono.TextTemplating.CodeCompilation.ProcessArgumentBuilder : object {
    private StringBuilder sb;
    [CompilerGeneratedAttribute]
private string <ProcessPath>k__BackingField;
    private static string escapeDoubleQuoteCharsStr;
    public string ProcessPath { get; private set; }
    public ProcessArgumentBuilder(string processPath);
    [CompilerGeneratedAttribute]
public string get_ProcessPath();
    [CompilerGeneratedAttribute]
private void set_ProcessPath(string value);
    public void Add(string argument);
    public void Add(String[] args);
    public void AddQuotedFormat(string argumentFormat, Object[] values);
    public void AddQuotedFormat(string argumentFormat, object val0);
    public void AddQuoted(string argument);
    public void AddQuoted(String[] args);
    public static string Quote(string s);
    public virtual string ToString();
    private static void AppendEscaped(StringBuilder sb, string escapeChars, string s);
    private static string GetArgument(StringBuilder builder, string buf, int startIndex, Int32& endIndex, Exception& ex);
    private static bool TryParse(string commandline, String[]& argv, Exception& ex);
    public static bool TryParse(string commandline, String[]& argv);
    public static String[] Parse(string commandline);
}
internal static class Mono.TextTemplating.CodeCompilation.ProcessUtils : object {
    public static Task`1<int> StartProcess(ProcessStartInfo psi, TextWriter stdout, TextWriter stderr, CancellationToken cancellationToken);
}
internal class Mono.TextTemplating.CodeCompilation.RuntimeInfo : object {
    [CompilerGeneratedAttribute]
private RuntimeKind <Kind>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Error>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RuntimeDir>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CscPath>k__BackingField;
    [CompilerGeneratedAttribute]
private Version <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private CSharpLangVersion <MaxSupportedLangVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RefAssembliesDir>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RuntimeFacadesDir>k__BackingField;
    public RuntimeKind Kind { get; private set; }
    public string Error { get; private set; }
    public string RuntimeDir { get; private set; }
    public string CscPath { get; private set; }
    public bool IsValid { get; }
    public Version Version { get; private set; }
    public CSharpLangVersion MaxSupportedLangVersion { get; private set; }
    public string RefAssembliesDir { get; private set; }
    public string RuntimeFacadesDir { get; internal set; }
    private RuntimeInfo(RuntimeKind kind);
    private static RuntimeInfo FromError(RuntimeKind kind, string error);
    [CompilerGeneratedAttribute]
public RuntimeKind get_Kind();
    [CompilerGeneratedAttribute]
private void set_Kind(RuntimeKind value);
    [CompilerGeneratedAttribute]
public string get_Error();
    [CompilerGeneratedAttribute]
private void set_Error(string value);
    [CompilerGeneratedAttribute]
public string get_RuntimeDir();
    [CompilerGeneratedAttribute]
private void set_RuntimeDir(string value);
    [CompilerGeneratedAttribute]
public string get_CscPath();
    [CompilerGeneratedAttribute]
private void set_CscPath(string value);
    public bool get_IsValid();
    [CompilerGeneratedAttribute]
public Version get_Version();
    [CompilerGeneratedAttribute]
private void set_Version(Version value);
    [CompilerGeneratedAttribute]
public CSharpLangVersion get_MaxSupportedLangVersion();
    [CompilerGeneratedAttribute]
private void set_MaxSupportedLangVersion(CSharpLangVersion value);
    [CompilerGeneratedAttribute]
public string get_RefAssembliesDir();
    [CompilerGeneratedAttribute]
private void set_RefAssembliesDir(string value);
    [CompilerGeneratedAttribute]
public string get_RuntimeFacadesDir();
    [CompilerGeneratedAttribute]
internal void set_RuntimeFacadesDir(string value);
    public static RuntimeInfo GetRuntime();
    private static RuntimeInfo GetMonoRuntime();
    private static RuntimeInfo GetNetFrameworkRuntime();
    private static RuntimeInfo GetDotNetCoreSdk();
    private static string FindHighestVersionedDirectory(string parentFolder, Func`2<string, bool> validate, SemVersion& bestVersion);
    [CompilerGeneratedAttribute]
internal static bool <GetDotNetCoreSdk>g__DotnetRootIsValid|39_0(string root);
    [CompilerGeneratedAttribute]
internal static string <GetDotNetCoreSdk>g__MakeCscPath|39_1(string d);
}
internal enum Mono.TextTemplating.CodeCompilation.RuntimeKind : Enum {
    public int value__;
    public static RuntimeKind NetCore;
    public static RuntimeKind NetFramework;
    public static RuntimeKind Mono;
}
public class Mono.TextTemplating.CodeCompilation.SemVersion : ValueType {
    [CompilerGeneratedAttribute]
private static SemVersion <Zero>k__BackingField;
    private static Regex SemVerRegex;
    [CompilerGeneratedAttribute]
private int <Major>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Minor>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Patch>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PreRelease>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Meta>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsPreRelease>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasMeta>k__BackingField;
    [CompilerGeneratedAttribute]
private string <VersionString>k__BackingField;
    public static SemVersion Zero { get; }
    public int Major { get; }
    public int Minor { get; }
    public int Patch { get; }
    public string PreRelease { get; }
    public string Meta { get; }
    public bool IsPreRelease { get; }
    public bool HasMeta { get; }
    public string VersionString { get; }
    public SemVersion(int major, int minor, int patch, string preRelease, string meta);
    private SemVersion(int major, int minor, int patch, string preRelease, string meta, string versionString);
    private static SemVersion();
    [CompilerGeneratedAttribute]
public static SemVersion get_Zero();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_Major();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_Minor();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_Patch();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_PreRelease();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_Meta();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_IsPreRelease();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_HasMeta();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_VersionString();
    public static bool TryParse(string version, SemVersion& semVersion);
    public sealed virtual bool Equals(SemVersion other);
    public sealed virtual int CompareTo(SemVersion other);
    public sealed virtual int CompareTo(object obj);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public static bool op_GreaterThan(SemVersion operand1, SemVersion operand2);
    public static bool op_LessThan(SemVersion operand1, SemVersion operand2);
    public static bool op_GreaterThanOrEqual(SemVersion operand1, SemVersion operand2);
    public static bool op_LessThanOrEqual(SemVersion operand1, SemVersion operand2);
}
public class Mono.TextTemplating.CompiledTemplate : MarshalByRefObject {
    private ITextTemplatingEngineHost host;
    private object textTransformation;
    private CultureInfo culture;
    private String[] assemblyFiles;
    public CompiledTemplate(ITextTemplatingEngineHost host, CompilerResults results, string fullName, CultureInfo culture, String[] assemblyFiles);
    private void Load(CompilerResults results, string fullName);
    public string Process();
    private Assembly ResolveReferencedAssemblies(object sender, ResolveEventArgs args);
    public sealed virtual void Dispose();
}
public class Mono.TextTemplating.CrossAppDomainAssemblyResolver : object {
    private ParentDomainLookup parent;
    public Assembly Resolve(object sender, ResolveEventArgs args);
}
public class Mono.TextTemplating.CustomDirective : object {
    [CompilerGeneratedAttribute]
private string <ProcessorName>k__BackingField;
    [CompilerGeneratedAttribute]
private Directive <Directive>k__BackingField;
    public string ProcessorName { get; public set; }
    public Directive Directive { get; public set; }
    public CustomDirective(string processorName, Directive directive);
    [CompilerGeneratedAttribute]
public string get_ProcessorName();
    [CompilerGeneratedAttribute]
public void set_ProcessorName(string value);
    [CompilerGeneratedAttribute]
public Directive get_Directive();
    [CompilerGeneratedAttribute]
public void set_Directive(Directive value);
}
public class Mono.TextTemplating.Directive : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <Attributes>k__BackingField;
    [CompilerGeneratedAttribute]
private Location <TagStartLocation>k__BackingField;
    [CompilerGeneratedAttribute]
private Location <StartLocation>k__BackingField;
    [CompilerGeneratedAttribute]
private Location <EndLocation>k__BackingField;
    public string Name { get; private set; }
    public Dictionary`2<string, string> Attributes { get; private set; }
    public Location TagStartLocation { get; public set; }
    public Location StartLocation { get; private set; }
    public Location EndLocation { get; public set; }
    public Directive(string name, Location start);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, string> get_Attributes();
    [CompilerGeneratedAttribute]
private void set_Attributes(Dictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public sealed virtual Location get_TagStartLocation();
    [CompilerGeneratedAttribute]
public sealed virtual void set_TagStartLocation(Location value);
    [CompilerGeneratedAttribute]
public sealed virtual Location get_StartLocation();
    [CompilerGeneratedAttribute]
private void set_StartLocation(Location value);
    [CompilerGeneratedAttribute]
public sealed virtual Location get_EndLocation();
    [CompilerGeneratedAttribute]
public sealed virtual void set_EndLocation(Location value);
    public string Extract(string key);
}
internal static class Mono.TextTemplating.FileUtil : object {
    private static string wildcardMarker;
    private static bool isWindows;
    private static FileUtil();
    public static string AbsoluteToRelativePath(string baseDirectoryPath, string absPath);
    private static bool IsSeparator(char ch);
    private static string GetFullPath(string path);
}
public interface Mono.TextTemplating.ISegment {
    public Location StartLocation { get; }
    public Location EndLocation { get; public set; }
    public Location TagStartLocation { get; public set; }
    public abstract virtual Location get_StartLocation();
    public abstract virtual Location get_EndLocation();
    public abstract virtual void set_EndLocation(Location value);
    public abstract virtual Location get_TagStartLocation();
    public abstract virtual void set_TagStartLocation(Location value);
}
public class Mono.TextTemplating.Location : ValueType {
    [CompilerGeneratedAttribute]
private int <Line>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Column>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FileName>k__BackingField;
    public int Line { get; private set; }
    public int Column { get; private set; }
    public string FileName { get; private set; }
    public static Location Empty { get; }
    public Location(string fileName, int line, int column);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_Line();
    [CompilerGeneratedAttribute]
private void set_Line(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_Column();
    [CompilerGeneratedAttribute]
private void set_Column(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_FileName();
    [CompilerGeneratedAttribute]
private void set_FileName(string value);
    public static Location get_Empty();
    public Location AddLine();
    public Location AddCol();
    public Location AddCols(int number);
    public virtual string ToString();
    public sealed virtual bool Equals(Location other);
}
public class Mono.TextTemplating.ParsedTemplate : object {
    private List`1<ISegment> importedHelperSegments;
    private string rootFileName;
    [CompilerGeneratedAttribute]
private List`1<ISegment> <RawSegments>k__BackingField;
    [CompilerGeneratedAttribute]
private CompilerErrorCollection <Errors>k__BackingField;
    public List`1<ISegment> RawSegments { get; }
    public IEnumerable`1<Directive> Directives { get; }
    public IEnumerable`1<TemplateSegment> Content { get; }
    public CompilerErrorCollection Errors { get; }
    public ParsedTemplate(string rootFileName);
    [CompilerGeneratedAttribute]
public List`1<ISegment> get_RawSegments();
    [IteratorStateMachineAttribute("Mono.TextTemplating.ParsedTemplate/<get_Directives>d__7")]
public IEnumerable`1<Directive> get_Directives();
    [IteratorStateMachineAttribute("Mono.TextTemplating.ParsedTemplate/<get_Content>d__9")]
public IEnumerable`1<TemplateSegment> get_Content();
    [CompilerGeneratedAttribute]
public CompilerErrorCollection get_Errors();
    public static ParsedTemplate FromText(string content, ITextTemplatingEngineHost host);
    public void Parse(ITextTemplatingEngineHost host, Tokeniser tokeniser);
    public void ParseWithoutIncludes(Tokeniser tokeniser);
    private void Parse(ITextTemplatingEngineHost host, Tokeniser tokeniser, bool parseIncludes);
    private void Parse(ITextTemplatingEngineHost host, Tokeniser tokeniser, bool parseIncludes, bool isImport);
    private void Import(ITextTemplatingEngineHost host, Directive includeDirective, string relativeToDirectory);
    private void AppendAnyImportedHelperSegments();
    private void LogError(string message, Location location, bool isWarning);
    public void LogError(string message);
    public void LogWarning(string message);
    public void LogError(string message, Location location);
    public void LogWarning(string message, Location location);
}
public class Mono.TextTemplating.ParserException : Exception {
    [CompilerGeneratedAttribute]
private Location <Location>k__BackingField;
    public Location Location { get; private set; }
    public ParserException(string message, Location location);
    [CompilerGeneratedAttribute]
public Location get_Location();
    [CompilerGeneratedAttribute]
private void set_Location(Location value);
}
public enum Mono.TextTemplating.SegmentType : Enum {
    public int value__;
    public static SegmentType Block;
    public static SegmentType Expression;
    public static SegmentType Content;
    public static SegmentType Helper;
}
public enum Mono.TextTemplating.State : Enum {
    public int value__;
    public static State Content;
    public static State Directive;
    public static State Expression;
    public static State Block;
    public static State Helper;
    public static State DirectiveName;
    public static State DirectiveValue;
    public static State Name;
    public static State EOF;
}
internal static class Mono.TextTemplating.StringUtil : object {
    public static bool IsNullOrWhiteSpace(string value);
}
public class Mono.TextTemplating.TemplateGenerator : MarshalByRefObject {
    private static Dictionary`2<string, string> KnownAssemblies;
    private TemplatingEngine engine;
    private Encoding encoding;
    [CompilerGeneratedAttribute]
private CompilerErrorCollection <Errors>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <Refs>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <Imports>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <IncludePaths>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <ReferencePaths>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OutputFile>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TemplateFile>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseRelativeLinePragmas>k__BackingField;
    private Dictionary`2<ParameterKey, string> parameters;
    private Dictionary`2<string, KeyValuePair`2<string, string>> directiveProcessors;
    private ITextTemplatingSession session;
    public CompilerErrorCollection Errors { get; }
    public List`1<string> Refs { get; }
    public List`1<string> Imports { get; }
    public List`1<string> IncludePaths { get; }
    public List`1<string> ReferencePaths { get; }
    public string OutputFile { get; protected set; }
    public string TemplateFile { get; protected set; }
    public bool UseRelativeLinePragmas { get; public set; }
    protected internal TemplatingEngine Engine { get; }
    private IList`1<string> Microsoft.VisualStudio.TextTemplating.ITextTemplatingEngineHost.StandardAssemblyReferences { get; }
    private IList`1<string> Microsoft.VisualStudio.TextTemplating.ITextTemplatingEngineHost.StandardImports { get; }
    private ITextTemplatingSession Microsoft.VisualStudio.TextTemplating.ITextTemplatingSessionHost.Session { get; private set; }
    public Type SpecificHostType { get; }
    private static TemplateGenerator();
    [CompilerGeneratedAttribute]
public CompilerErrorCollection get_Errors();
    [CompilerGeneratedAttribute]
public List`1<string> get_Refs();
    [CompilerGeneratedAttribute]
public List`1<string> get_Imports();
    [CompilerGeneratedAttribute]
public List`1<string> get_IncludePaths();
    [CompilerGeneratedAttribute]
public List`1<string> get_ReferencePaths();
    [CompilerGeneratedAttribute]
public string get_OutputFile();
    [CompilerGeneratedAttribute]
protected void set_OutputFile(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_TemplateFile();
    [CompilerGeneratedAttribute]
protected void set_TemplateFile(string value);
    [CompilerGeneratedAttribute]
public bool get_UseRelativeLinePragmas();
    [CompilerGeneratedAttribute]
public void set_UseRelativeLinePragmas(bool value);
    public CompiledTemplate CompileTemplate(string content);
    protected internal TemplatingEngine get_Engine();
    public bool ProcessTemplate(string inputFile, string outputFile);
    public bool ProcessTemplate(string inputFileName, string inputContent, String& outputFileName, String& outputContent);
    public bool PreprocessTemplate(string inputFile, string className, string classNamespace, string outputFile, Encoding encoding, String& language, String[]& references);
    public bool PreprocessTemplate(string inputFileName, string className, string classNamespace, string inputContent, String& language, String[]& references, String& outputContent);
    private CompilerError AddError(string error);
    public virtual object GetHostOption(string optionName);
    public virtual AppDomain ProvideTemplatingAppDomain(string content);
    protected virtual string ResolveAssemblyReference(string assemblyReference);
    protected virtual string ResolveParameterValue(string directiveId, string processorName, string parameterName);
    protected virtual Type ResolveDirectiveProcessor(string processorName);
    protected virtual string ResolvePath(string path);
    public void AddDirectiveProcessor(string name, string klass, string assembly);
    public void AddParameter(string processorName, string directiveName, string parameterName, string value);
    public bool TryAddParameter(string unparsedParameter);
    internal static bool TryParseParameter(string parameter, String& processor, String& directive, String& name, String& value);
    protected virtual bool LoadIncludeText(string requestFileName, String& content, String& location);
    private sealed virtual override bool Microsoft.VisualStudio.TextTemplating.ITextTemplatingEngineHost.LoadIncludeText(string requestFileName, String& content, String& location);
    private sealed virtual override void Microsoft.VisualStudio.TextTemplating.ITextTemplatingEngineHost.LogErrors(CompilerErrorCollection errors);
    private sealed virtual override string Microsoft.VisualStudio.TextTemplating.ITextTemplatingEngineHost.ResolveAssemblyReference(string assemblyReference);
    private sealed virtual override string Microsoft.VisualStudio.TextTemplating.ITextTemplatingEngineHost.ResolveParameterValue(string directiveId, string processorName, string parameterName);
    private sealed virtual override Type Microsoft.VisualStudio.TextTemplating.ITextTemplatingEngineHost.ResolveDirectiveProcessor(string processorName);
    private sealed virtual override string Microsoft.VisualStudio.TextTemplating.ITextTemplatingEngineHost.ResolvePath(string path);
    private sealed virtual override void Microsoft.VisualStudio.TextTemplating.ITextTemplatingEngineHost.SetFileExtension(string extension);
    private sealed virtual override void Microsoft.VisualStudio.TextTemplating.ITextTemplatingEngineHost.SetOutputEncoding(Encoding encoding, bool fromOutputDirective);
    private sealed virtual override IList`1<string> Microsoft.VisualStudio.TextTemplating.ITextTemplatingEngineHost.get_StandardAssemblyReferences();
    private sealed virtual override IList`1<string> Microsoft.VisualStudio.TextTemplating.ITextTemplatingEngineHost.get_StandardImports();
    public ITextTemplatingSession GetOrCreateSession();
    protected virtual ITextTemplatingSession CreateSession();
    private sealed virtual override ITextTemplatingSession Microsoft.VisualStudio.TextTemplating.ITextTemplatingSessionHost.get_Session();
    private sealed virtual override void Microsoft.VisualStudio.TextTemplating.ITextTemplatingSessionHost.set_Session(ITextTemplatingSession value);
    private sealed virtual override ITextTemplatingSession Microsoft.VisualStudio.TextTemplating.ITextTemplatingSessionHost.CreateSession();
    public virtual Type get_SpecificHostType();
    [IteratorStateMachineAttribute("Mono.TextTemplating.TemplateGenerator/<GetAdditionalDirectiveProcessors>d__74")]
public virtual IEnumerable`1<IDirectiveProcessor> GetAdditionalDirectiveProcessors();
}
public class Mono.TextTemplating.TemplateSegment : object {
    [CompilerGeneratedAttribute]
private SegmentType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Text>k__BackingField;
    [CompilerGeneratedAttribute]
private Location <TagStartLocation>k__BackingField;
    [CompilerGeneratedAttribute]
private Location <StartLocation>k__BackingField;
    [CompilerGeneratedAttribute]
private Location <EndLocation>k__BackingField;
    public SegmentType Type { get; private set; }
    public string Text { get; private set; }
    public Location TagStartLocation { get; public set; }
    public Location StartLocation { get; private set; }
    public Location EndLocation { get; public set; }
    public TemplateSegment(SegmentType type, string text, Location start);
    [CompilerGeneratedAttribute]
public SegmentType get_Type();
    [CompilerGeneratedAttribute]
private void set_Type(SegmentType value);
    [CompilerGeneratedAttribute]
public string get_Text();
    [CompilerGeneratedAttribute]
private void set_Text(string value);
    [CompilerGeneratedAttribute]
public sealed virtual Location get_TagStartLocation();
    [CompilerGeneratedAttribute]
public sealed virtual void set_TagStartLocation(Location value);
    [CompilerGeneratedAttribute]
public sealed virtual Location get_StartLocation();
    [CompilerGeneratedAttribute]
private void set_StartLocation(Location value);
    [CompilerGeneratedAttribute]
public sealed virtual Location get_EndLocation();
    [CompilerGeneratedAttribute]
public sealed virtual void set_EndLocation(Location value);
}
public class Mono.TextTemplating.TemplateSettings : object {
    [CompilerGeneratedAttribute]
private bool <HostSpecific>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HostPropertyOnBase>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Debug>k__BackingField;
    [CompilerGeneratedAttribute]
private TextWriter <Log>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Inherits>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Namespace>k__BackingField;
    [CompilerGeneratedAttribute]
private HashSet`1<string> <Imports>k__BackingField;
    [CompilerGeneratedAttribute]
private HashSet`1<string> <Assemblies>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeDomProvider <Provider>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Language>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LangVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CompilerOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private Encoding <Encoding>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Extension>k__BackingField;
    [CompilerGeneratedAttribute]
private CultureInfo <Culture>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<CustomDirective> <CustomDirectives>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, IDirectiveProcessor> <DirectiveProcessors>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludePreprocessingHelpers>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsPreprocessed>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RelativeLinePragmas>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <NoLinePragmas>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <InternalVisibility>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <HostType>k__BackingField;
    public bool HostSpecific { get; public set; }
    public bool HostPropertyOnBase { get; public set; }
    public bool Debug { get; public set; }
    public TextWriter Log { get; public set; }
    public string Inherits { get; public set; }
    public string Name { get; public set; }
    public string Namespace { get; public set; }
    public HashSet`1<string> Imports { get; private set; }
    public HashSet`1<string> Assemblies { get; private set; }
    public CodeDomProvider Provider { get; public set; }
    public string Language { get; public set; }
    public string LangVersion { get; public set; }
    public string CompilerOptions { get; public set; }
    public Encoding Encoding { get; public set; }
    public string Extension { get; public set; }
    public CultureInfo Culture { get; public set; }
    public List`1<CustomDirective> CustomDirectives { get; private set; }
    public Dictionary`2<string, IDirectiveProcessor> DirectiveProcessors { get; private set; }
    public bool IncludePreprocessingHelpers { get; public set; }
    public bool IsPreprocessed { get; public set; }
    public bool RelativeLinePragmas { get; public set; }
    public bool NoLinePragmas { get; public set; }
    public bool InternalVisibility { get; public set; }
    public Type HostType { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_HostSpecific();
    [CompilerGeneratedAttribute]
public void set_HostSpecific(bool value);
    [CompilerGeneratedAttribute]
public bool get_HostPropertyOnBase();
    [CompilerGeneratedAttribute]
public void set_HostPropertyOnBase(bool value);
    [CompilerGeneratedAttribute]
public bool get_Debug();
    [CompilerGeneratedAttribute]
public void set_Debug(bool value);
    [CompilerGeneratedAttribute]
public TextWriter get_Log();
    [CompilerGeneratedAttribute]
public void set_Log(TextWriter value);
    [CompilerGeneratedAttribute]
public string get_Inherits();
    [CompilerGeneratedAttribute]
public void set_Inherits(string value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_Namespace();
    [CompilerGeneratedAttribute]
public void set_Namespace(string value);
    [CompilerGeneratedAttribute]
public HashSet`1<string> get_Imports();
    [CompilerGeneratedAttribute]
private void set_Imports(HashSet`1<string> value);
    [CompilerGeneratedAttribute]
public HashSet`1<string> get_Assemblies();
    [CompilerGeneratedAttribute]
private void set_Assemblies(HashSet`1<string> value);
    [CompilerGeneratedAttribute]
public CodeDomProvider get_Provider();
    [CompilerGeneratedAttribute]
public void set_Provider(CodeDomProvider value);
    [CompilerGeneratedAttribute]
public string get_Language();
    [CompilerGeneratedAttribute]
public void set_Language(string value);
    [CompilerGeneratedAttribute]
public string get_LangVersion();
    [CompilerGeneratedAttribute]
public void set_LangVersion(string value);
    [CompilerGeneratedAttribute]
public string get_CompilerOptions();
    [CompilerGeneratedAttribute]
public void set_CompilerOptions(string value);
    [CompilerGeneratedAttribute]
public Encoding get_Encoding();
    [CompilerGeneratedAttribute]
public void set_Encoding(Encoding value);
    [CompilerGeneratedAttribute]
public string get_Extension();
    [CompilerGeneratedAttribute]
public void set_Extension(string value);
    [CompilerGeneratedAttribute]
public CultureInfo get_Culture();
    [CompilerGeneratedAttribute]
public void set_Culture(CultureInfo value);
    [CompilerGeneratedAttribute]
public List`1<CustomDirective> get_CustomDirectives();
    [CompilerGeneratedAttribute]
private void set_CustomDirectives(List`1<CustomDirective> value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, IDirectiveProcessor> get_DirectiveProcessors();
    [CompilerGeneratedAttribute]
private void set_DirectiveProcessors(Dictionary`2<string, IDirectiveProcessor> value);
    [CompilerGeneratedAttribute]
public bool get_IncludePreprocessingHelpers();
    [CompilerGeneratedAttribute]
public void set_IncludePreprocessingHelpers(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsPreprocessed();
    [CompilerGeneratedAttribute]
public void set_IsPreprocessed(bool value);
    [CompilerGeneratedAttribute]
public bool get_RelativeLinePragmas();
    [CompilerGeneratedAttribute]
public void set_RelativeLinePragmas(bool value);
    [CompilerGeneratedAttribute]
public bool get_NoLinePragmas();
    [CompilerGeneratedAttribute]
public void set_NoLinePragmas(bool value);
    [CompilerGeneratedAttribute]
public bool get_InternalVisibility();
    [CompilerGeneratedAttribute]
public void set_InternalVisibility(bool value);
    [CompilerGeneratedAttribute]
public Type get_HostType();
    [CompilerGeneratedAttribute]
public void set_HostType(Type value);
    public string GetFullName();
}
public class Mono.TextTemplating.TemplatingAppDomainRecycler : object {
    private static int DEFAULT_TIMEOUT_MS;
    private static int DEFAULT_MAX_USES;
    private string name;
    private object lockObj;
    private RecyclableAppDomain domain;
    public TemplatingAppDomainRecycler(string name);
    public Handle GetHandle();
}
public class Mono.TextTemplating.TemplatingEngine : MarshalByRefObject {
    private Func`2<RuntimeInfo, CodeCompiler> createCompilerFunc;
    private CodeCompiler cachedCompiler;
    private static bool useMonoHack;
    private static MethodInfo cgFieldGen;
    private static MethodInfo cgPropGen;
    private static MethodInfo cgMethGen;
    private static Action`3<CodeGenerator, StringWriter, CodeGeneratorOptions> initializeCodeGenerator;
    private static TemplatingEngine();
    internal void SetCompilerFunc(Func`2<RuntimeInfo, CodeCompiler> createCompiler);
    private CodeCompiler GetOrCreateCompiler();
    public sealed virtual string ProcessTemplate(string content, ITextTemplatingEngineHost host);
    public sealed virtual string PreprocessTemplate(string content, ITextTemplatingEngineHost host, string className, string classNamespace, String& language, String[]& references);
    public string PreprocessTemplate(ParsedTemplate pt, string content, ITextTemplatingEngineHost host, string className, string classNamespace, String& language, String[]& references, TemplateSettings settings);
    private string PreprocessTemplateInternal(ParsedTemplate pt, string content, ITextTemplatingEngineHost host, string className, string classNamespace, String& language, String[]& references, TemplateSettings settings);
    public CompiledTemplate CompileTemplate(string content, ITextTemplatingEngineHost host);
    public CompiledTemplate CompileTemplate(ParsedTemplate pt, string content, ITextTemplatingEngineHost host, TemplateSettings settings);
    private CompiledTemplate CompileTemplateInternal(ParsedTemplate pt, string content, ITextTemplatingEngineHost host, TemplateSettings settings);
    private CompilerResults CompileCode(IEnumerable`1<string> references, TemplateSettings settings, CodeCompileUnit ccu);
    private static String[] ProcessReferences(ITextTemplatingEngineHost host, ParsedTemplate pt, TemplateSettings settings);
    public static TemplateSettings GetSettings(ITextTemplatingEngineHost host, ParsedTemplate pt);
    public static string IndentSnippetText(CodeDomProvider provider, string text, string indent);
    public static string IndentSnippetText(string text, string indent);
    private static void AddDirective(TemplateSettings settings, ITextTemplatingEngineHost host, string processorName, Directive directive);
    private static bool ComplainExcessAttributes(Directive dt, ParsedTemplate pt);
    private static void ProcessDirectives(string content, ParsedTemplate pt, TemplateSettings settings);
    public static CodeCompileUnit GenerateCompileUnit(ITextTemplatingEngineHost host, string content, ParsedTemplate pt, TemplateSettings settings);
    private static CodeSnippetTypeMember CreateSnippetMember(string value, CodeLinePragma location);
    private static void GenerateHostProperty(CodeTypeDeclaration type, Type hostType);
    private static void GenerateInitializationMethod(CodeTypeDeclaration type, TemplateSettings settings);
    private static void GenerateProcessingHelpers(CodeTypeDeclaration type, TemplateSettings settings);
    private static void AddPropertyGetterInitializationIfFieldIsNull(CodeMemberProperty property, CodeFieldReferenceExpression fieldRef, CodeTypeReference typeRef);
    private static CodeConditionStatement FieldInitializationIfNull(CodeExpression fieldRef, CodeTypeReference typeRef);
    private static void AddErrorHelpers(CodeTypeDeclaration type);
    private static void AddIndentHelpers(CodeTypeDeclaration type);
    private static void AddWriteHelpers(CodeTypeDeclaration type);
    private static void AddToStringHelper(CodeTypeDeclaration type, TemplateSettings settings);
    private static CodeTypeReference TypeRef();
    private static CodeMemberProperty GenerateGetterSetterProperty(string propertyName, CodeMemberField field);
    private static CodeMemberProperty GenerateGetterProperty(string propertyName, CodeMemberField field);
    private static void AddSetter(CodeMemberProperty property, CodeFieldReferenceExpression fieldRef);
    private static void AddGetter(CodeMemberProperty property, CodeFieldReferenceExpression fieldRef);
    private static void MakeGetterLazy(CodeMemberProperty property, CodeFieldReferenceExpression fieldRef, CodeExpression initExpression);
    private static void MakeSimpleSetterIgnoreNull(CodeMemberProperty property);
    private static CodeStatement NullCheck(CodeExpression expr, string exceptionMessage);
    private static CodeBinaryOperatorExpression NotNull(CodeExpression reference);
    private static CodeBinaryOperatorExpression IsNull(CodeExpression reference);
    private static CodeBinaryOperatorExpression IsFalse(CodeExpression expr);
    private static CodeBinaryOperatorExpression BooleanAnd(CodeExpression expr1, CodeExpression expr2);
    private static CodeStatement ArgNullCheck(CodeExpression value, CodeExpression[] argNullExcArgs);
    private static CodeMemberField PrivateField(CodeTypeReference typeRef, string name);
    public static void GenerateCodeFromMembers(CodeDomProvider provider, CodeGeneratorOptions options, StringWriter sw, IEnumerable`1<CodeTypeMember> members);
    private static bool InitializeMonoHack();
    public static string GenerateIndentedClassCode(CodeDomProvider provider, CodeTypeMember[] members);
    public static string GenerateIndentedClassCode(CodeDomProvider provider, IEnumerable`1<CodeTypeMember> members);
}
public class Mono.TextTemplating.Tokeniser : object {
    private string content;
    private int position;
    private string value;
    private State nextState;
    private Location nextStateLocation;
    private Location nextStateTagStartLocation;
    [CompilerGeneratedAttribute]
private State <State>k__BackingField;
    [CompilerGeneratedAttribute]
private Location <Location>k__BackingField;
    [CompilerGeneratedAttribute]
private Location <TagStartLocation>k__BackingField;
    [CompilerGeneratedAttribute]
private Location <TagEndLocation>k__BackingField;
    public State State { get; private set; }
    public int Position { get; }
    public string Content { get; }
    public string Value { get; }
    public Location Location { get; private set; }
    public Location TagStartLocation { get; private set; }
    public Location TagEndLocation { get; private set; }
    public Tokeniser(string fileName, string content);
    public bool Advance();
    private State GetNextStateAndCurrentValue();
    private State GetBlockEnd();
    private State GetDirectiveName();
    private State GetDirectiveValue();
    private State NextStateInContent();
    private int IsNewLine();
    private State NextStateInDirective();
    [CompilerGeneratedAttribute]
public State get_State();
    [CompilerGeneratedAttribute]
private void set_State(State value);
    public int get_Position();
    public string get_Content();
    public string get_Value();
    [CompilerGeneratedAttribute]
public Location get_Location();
    [CompilerGeneratedAttribute]
private void set_Location(Location value);
    [CompilerGeneratedAttribute]
public Location get_TagStartLocation();
    [CompilerGeneratedAttribute]
private void set_TagStartLocation(Location value);
    [CompilerGeneratedAttribute]
public Location get_TagEndLocation();
    [CompilerGeneratedAttribute]
private void set_TagEndLocation(Location value);
}
internal static class Mono.TextTemplating.Utf8 : object {
    public static Encoding BomlessEncoding;
    private static Utf8();
}
[GeneratedCodeAttribute("Nerdbank.GitVersioning.Tasks", "3.3.37.35081")]
[ExcludeFromCodeCoverageAttribute]
internal static class ThisAssembly : object {
    internal static string AssemblyVersion;
    internal static string AssemblyFileVersion;
    internal static string AssemblyInformationalVersion;
    internal static string AssemblyName;
    internal static string AssemblyTitle;
    internal static string AssemblyConfiguration;
    internal static string GitCommitId;
    internal static string PublicKey;
    internal static string PublicKeyToken;
    internal static bool IsPublicRelease;
    internal static bool IsPrerelease;
    internal static DateTime GitCommitDate;
    internal static string RootNamespace;
    private static ThisAssembly();
}
