[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Moq.ActionObserver : ExpressionReconstructor {
    public virtual Expression`1<Action`1<T>> ReconstructExpression(Action`1<T> action, Object[] ctorArgs);
    private static IProxy CreateProxy(Type type, Object[] ctorArgs, MatcherObserver matcherObserver, Recorder& recorder);
    [CompilerGeneratedAttribute]
internal static Expression[] <ReconstructExpression>g__GetArgumentExpressions|0_0(Invocation invocation, Match[] matches);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
internal static bool <ReconstructExpression>g__CanDistribute|0_1(int msi, int asi, <>c__DisplayClass0_0`1& );
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Moq.AsInterface`1 : Mock`1<TInterface> {
    private Mock owner;
    internal List`1<Type> AdditionalInterfaces { get; }
    internal Dictionary`2<Type, object> ConfiguredDefaultValues { get; }
    internal Object[] ConstructorArguments { get; }
    internal InvocationCollection MutableInvocations { get; }
    internal bool IsObjectInitialized { get; }
    internal Type MockedType { get; }
    public MockBehavior Behavior { get; }
    public bool CallBase { get; public set; }
    public DefaultValueProvider DefaultValueProvider { get; public set; }
    internal EventHandlerCollection EventHandlers { get; }
    internal Type[] InheritedInterfaces { get; }
    public TInterface Object { get; }
    internal SetupCollection MutableSetups { get; }
    public Switches Switches { get; public set; }
    public AsInterface`1(Mock owner);
    internal virtual List`1<Type> get_AdditionalInterfaces();
    internal virtual Dictionary`2<Type, object> get_ConfiguredDefaultValues();
    internal virtual Object[] get_ConstructorArguments();
    internal virtual InvocationCollection get_MutableInvocations();
    internal virtual bool get_IsObjectInitialized();
    internal virtual Type get_MockedType();
    public virtual MockBehavior get_Behavior();
    public virtual bool get_CallBase();
    public virtual void set_CallBase(bool value);
    public virtual DefaultValueProvider get_DefaultValueProvider();
    public virtual void set_DefaultValueProvider(DefaultValueProvider value);
    internal virtual EventHandlerCollection get_EventHandlers();
    internal virtual Type[] get_InheritedInterfaces();
    public virtual TInterface get_Object();
    internal virtual SetupCollection get_MutableSetups();
    public virtual Switches get_Switches();
    public virtual void set_Switches(Switches value);
    public virtual Mock`1<TNewInterface> As();
    protected virtual object OnGetObject();
    public virtual string ToString();
}
internal static class Moq.Async.Awaitable : object {
    [NullableContextAttribute("1")]
public static object TryGetResultRecursive(object obj);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Moq.Async.AwaitableFactory : object {
    private static Dictionary`2<Type, Func`2<Type, IAwaitableFactory>> Providers;
    private static AwaitableFactory();
    private static IAwaitableFactory Create(Type awaitableFactoryType, Type awaitableType);
    public static IAwaitableFactory TryGet(Type type);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Moq.Async.AwaitableFactory`1 : object {
    private Type Moq.Async.IAwaitableFactory.ResultType { get; }
    private sealed virtual override Type Moq.Async.IAwaitableFactory.get_ResultType();
    public abstract virtual TAwaitable CreateCompleted();
    private sealed virtual override object Moq.Async.IAwaitableFactory.CreateCompleted(object result);
    public abstract virtual TAwaitable CreateFaulted(Exception exception);
    private sealed virtual override object Moq.Async.IAwaitableFactory.CreateFaulted(Exception exception);
    public abstract virtual TAwaitable CreateFaulted(IEnumerable`1<Exception> exceptions);
    private sealed virtual override object Moq.Async.IAwaitableFactory.CreateFaulted(IEnumerable`1<Exception> exceptions);
    private sealed virtual override Expression Moq.Async.IAwaitableFactory.CreateResultExpression(Expression awaitableExpression);
    private sealed virtual override bool Moq.Async.IAwaitableFactory.TryGetResult(object awaitable, Object& result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Moq.Async.AwaitableFactory`2 : object {
    public Type ResultType { get; }
    public sealed virtual Type get_ResultType();
    public abstract virtual TAwaitable CreateCompleted(TResult result);
    private sealed virtual override object Moq.Async.IAwaitableFactory.CreateCompleted(object result);
    public abstract virtual TAwaitable CreateFaulted(Exception exception);
    private sealed virtual override object Moq.Async.IAwaitableFactory.CreateFaulted(Exception exception);
    public abstract virtual TAwaitable CreateFaulted(IEnumerable`1<Exception> exceptions);
    private sealed virtual override object Moq.Async.IAwaitableFactory.CreateFaulted(IEnumerable`1<Exception> exceptions);
    public abstract virtual bool TryGetResult(TAwaitable awaitable, TResult& result);
    public abstract virtual Expression CreateResultExpression(Expression awaitableExpression);
    private sealed virtual override bool Moq.Async.IAwaitableFactory.TryGetResult(object awaitable, Object& result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Moq.Async.AwaitExpression : Expression {
    private IAwaitableFactory awaitableFactory;
    private Expression operand;
    public bool CanReduce { get; }
    public ExpressionType NodeType { get; }
    public Expression Operand { get; }
    public Type Type { get; }
    public AwaitExpression(Expression operand, IAwaitableFactory awaitableFactory);
    public virtual bool get_CanReduce();
    public virtual ExpressionType get_NodeType();
    public Expression get_Operand();
    public virtual Type get_Type();
    public virtual string ToString();
    protected virtual Expression VisitChildren(ExpressionVisitor visitor);
}
[NullableContextAttribute("1")]
internal interface Moq.Async.IAwaitableFactory {
    public Type ResultType { get; }
    public abstract virtual Type get_ResultType();
    public abstract virtual object CreateCompleted(object result);
    public abstract virtual object CreateFaulted(Exception exception);
    public abstract virtual object CreateFaulted(IEnumerable`1<Exception> exceptions);
    public abstract virtual Expression CreateResultExpression(Expression awaitableExpression);
    public abstract virtual bool TryGetResult(object awaitable, Object& result);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Moq.Async.TaskFactory : AwaitableFactory`1<Task> {
    public static TaskFactory Instance;
    private static TaskFactory();
    public virtual Task CreateCompleted();
    public virtual Task CreateFaulted(Exception exception);
    public virtual Task CreateFaulted(IEnumerable`1<Exception> exceptions);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Moq.Async.TaskFactory`1 : AwaitableFactory`2<Task`1<TResult>, TResult> {
    public virtual Task`1<TResult> CreateCompleted(TResult result);
    public virtual Task`1<TResult> CreateFaulted(Exception exception);
    public virtual Task`1<TResult> CreateFaulted(IEnumerable`1<Exception> exceptions);
    public virtual Expression CreateResultExpression(Expression awaitableExpression);
    public virtual bool TryGetResult(Task`1<TResult> task, TResult& result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Moq.Async.ValueTaskFactory : AwaitableFactory`1<ValueTask> {
    public static ValueTaskFactory Instance;
    private static ValueTaskFactory();
    public virtual ValueTask CreateCompleted();
    public virtual ValueTask CreateFaulted(Exception exception);
    public virtual ValueTask CreateFaulted(IEnumerable`1<Exception> exceptions);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Moq.Async.ValueTaskFactory`1 : AwaitableFactory`2<ValueTask`1<TResult>, TResult> {
    public virtual ValueTask`1<TResult> CreateCompleted(TResult result);
    public virtual ValueTask`1<TResult> CreateFaulted(Exception exception);
    public virtual ValueTask`1<TResult> CreateFaulted(IEnumerable`1<Exception> exceptions);
    public virtual Expression CreateResultExpression(Expression awaitableExpression);
    public virtual bool TryGetResult(ValueTask`1<TResult> valueTask, TResult& result);
}
internal abstract class Moq.Behavior : object {
    [NullableContextAttribute("1")]
public abstract virtual void Execute(Invocation invocation);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Moq.Behaviors.Callback : Behavior {
    private Action`1<IInvocation> callback;
    public Callback(Action`1<IInvocation> callback);
    public virtual void Execute(Invocation invocation);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Moq.Behaviors.NoOp : Behavior {
    public static NoOp Instance;
    private static NoOp();
    public virtual void Execute(Invocation invocation);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Moq.Behaviors.RaiseEvent : Behavior {
    private Mock mock;
    private LambdaExpression expression;
    private Delegate eventArgsFunc;
    private Object[] eventArgsParams;
    public RaiseEvent(Mock mock, LambdaExpression expression, Delegate eventArgsFunc, Object[] eventArgsParams);
    public virtual void Execute(Invocation invocation);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Moq.Behaviors.ReturnBase : Behavior {
    public static ReturnBase Instance;
    private static ReturnBase();
    public virtual void Execute(Invocation invocation);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Moq.Behaviors.ReturnBaseOrDefaultValue : Behavior {
    private Mock mock;
    public ReturnBaseOrDefaultValue(Mock mock);
    public virtual void Execute(Invocation invocation);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Moq.Behaviors.ReturnComputedValue : Behavior {
    private Func`2<IInvocation, object> valueFactory;
    public ReturnComputedValue(Func`2<IInvocation, object> valueFactory);
    public virtual void Execute(Invocation invocation);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Moq.Behaviors.ReturnValue : Behavior {
    private object value;
    public object Value { get; }
    public ReturnValue(object value);
    public object get_Value();
    public virtual void Execute(Invocation invocation);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Moq.Behaviors.ThrowComputedException : Behavior {
    private Func`2<IInvocation, Exception> exceptionFactory;
    public ThrowComputedException(Func`2<IInvocation, Exception> exceptionFactory);
    public virtual void Execute(Invocation invocation);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Moq.Behaviors.ThrowException : Behavior {
    private Exception exception;
    public ThrowException(Exception exception);
    public virtual void Execute(Invocation invocation);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Moq.Behaviors.VerifyInvocationCount : Behavior {
    private int count;
    private Times times;
    private MethodCall setup;
    public VerifyInvocationCount(MethodCall setup, Times times);
    public void Reset();
    public virtual void Execute(Invocation invocation);
    public void Verify();
    public void VerifyUpperBound();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class Moq.Capture : object {
    public static T In(ICollection`1<T> collection);
    public static T In(IList`1<T> collection, Expression`1<Func`2<T, bool>> predicate);
    public static T With(CaptureMatch`1<T> match);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Moq.CaptureMatch`1 : Match`1<T> {
    private static Predicate`1<T> matchAllPredicate;
    public CaptureMatch`1(Action`1<T> captureCallback);
    public CaptureMatch`1(Action`1<T> captureCallback, Expression`1<Func`2<T, bool>> predicate);
    private static CaptureMatch`1();
    private static Predicate`1<T> BuildCondition(Expression`1<Func`2<T, bool>> predicateExpression);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Moq.CastleProxyFactory : ProxyFactory {
    private ProxyGenerationOptions generationOptions;
    private ProxyGenerator generator;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ConcurrentDictionary`2<Pair`2<MethodInfo, Type>, MethodInfo> mostSpecificOverrides;
    private static ConcurrentDictionary`2<MethodInfo, Func`3<object, Object[], object>> nonVirtualInvocationThunks;
    private static CastleProxyFactory();
    public virtual object CreateProxy(Type mockType, IInterceptor interceptor, Type[] interfaces, Object[] arguments);
    public virtual bool IsMethodVisible(MethodInfo method, String& messageIfNotVisible);
    public virtual bool IsTypeVisible(Type type);
    public static MethodInfo FindMostSpecificOverride(MethodInfo declaration, Type proxyType);
    public static object DynamicInvokeNonVirtually(MethodInfo method, object instance, Object[] arguments);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Moq.Condition : object {
    private Func`1<bool> condition;
    private Action success;
    public bool IsTrue { get; }
    public Condition(Func`1<bool> condition, Action success);
    public bool get_IsTrue();
    public void SetupEvaluatedSuccessfully();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Moq.DefaultExpressionCompiler : ExpressionCompiler {
    public static DefaultExpressionCompiler Instance;
    private static DefaultExpressionCompiler();
    public virtual Delegate Compile(LambdaExpression expression);
    public virtual TDelegate Compile(Expression`1<TDelegate> expression);
}
public enum Moq.DefaultValue : Enum {
    public int value__;
    public static DefaultValue Empty;
    public static DefaultValue Mock;
    [EditorBrowsableAttribute("2")]
public static DefaultValue Custom;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Moq.DefaultValueProvider : object {
    [CompilerGeneratedAttribute]
private static DefaultValueProvider <Empty>k__BackingField;
    [CompilerGeneratedAttribute]
private static DefaultValueProvider <Mock>k__BackingField;
    public static DefaultValueProvider Empty { get; }
    public static DefaultValueProvider Mock { get; }
    internal DefaultValue Kind { get; }
    private static DefaultValueProvider();
    [CompilerGeneratedAttribute]
public static DefaultValueProvider get_Empty();
    [CompilerGeneratedAttribute]
public static DefaultValueProvider get_Mock();
    internal virtual DefaultValue get_Kind();
    protected internal abstract virtual object GetDefaultValue(Type type, Mock mock);
    protected internal virtual object GetDefaultParameterValue(ParameterInfo parameter, Mock mock);
    protected internal virtual object GetDefaultReturnValue(MethodInfo method, Mock mock);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Moq.EmptyDefaultValueProvider : LookupOrFallbackDefaultValueProvider {
    internal DefaultValue Kind { get; }
    internal virtual DefaultValue get_Kind();
    private static object CreateArray(Type type, Mock mock);
    private static object CreateEnumerable(Type type, Mock mock);
    private static object CreateEnumerableOf(Type type, Mock mock);
    private static object CreateQueryable(Type type, Mock mock);
    private static object CreateQueryableOf(Type type, Mock mock);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Moq.Evaluator : object {
    public static Expression PartialEval(Expression expression, Func`2<Expression, bool> fnCanBeEvaluated);
    public static Expression PartialEval(Expression expression);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Moq.EventHandlerCollection : object {
    private Dictionary`2<EventInfo, Delegate> eventHandlers;
    public void Add(EventInfo event, Delegate eventHandler);
    public void Clear();
    public void Remove(EventInfo event, Delegate eventHandler);
    public bool TryGet(EventInfo event, Delegate& handlers);
    private Delegate TryGet(EventInfo event);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Moq.Expectation : object {
    public LambdaExpression Expression { get; }
    public abstract virtual LambdaExpression get_Expression();
    public virtual bool HasResultExpression(IAwaitableFactory& awaitableFactory);
    public virtual bool Equals(object obj);
    public abstract virtual bool Equals(Expectation other);
    public abstract virtual int GetHashCode();
    public abstract virtual bool IsMatch(Invocation invocation);
    public virtual void SetupEvaluatedSuccessfully(Invocation invocation);
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Moq.ExpressionComparer : object {
    public static ExpressionComparer Default;
    [ThreadStaticAttribute]
private static int quoteDepth;
    private static ExpressionComparer();
    public sealed virtual bool Equals(Expression x, Expression y);
    public sealed virtual int GetHashCode(Expression obj);
    private static bool Equals(ReadOnlyCollection`1<T> x, ReadOnlyCollection`1<T> y, Func`3<T, T, bool> comparer);
    private bool EqualsBinary(BinaryExpression x, BinaryExpression y);
    private bool EqualsConditional(ConditionalExpression x, ConditionalExpression y);
    private static bool EqualsConstant(ConstantExpression x, ConstantExpression y);
    private bool EqualsElementInit(ElementInit x, ElementInit y);
    private bool EqualsIndex(IndexExpression x, IndexExpression y);
    private bool EqualsInvocation(InvocationExpression x, InvocationExpression y);
    private bool EqualsLambda(LambdaExpression x, LambdaExpression y);
    private bool EqualsListInit(ListInitExpression x, ListInitExpression y);
    private bool EqualsMemberAssignment(MemberAssignment x, MemberAssignment y);
    private bool EqualsMemberBinding(MemberBinding x, MemberBinding y);
    private bool EqualsMember(MemberExpression x, MemberExpression y);
    private bool EqualsMemberInit(MemberInitExpression x, MemberInitExpression y);
    private bool EqualsMemberListBinding(MemberListBinding x, MemberListBinding y);
    private bool EqualsMemberMemberBinding(MemberMemberBinding x, MemberMemberBinding y);
    private bool EqualsMethodCall(MethodCallExpression x, MethodCallExpression y);
    private bool EqualsNewArray(NewArrayExpression x, NewArrayExpression y);
    private bool EqualsNew(NewExpression x, NewExpression y);
    private bool EqualsParameter(ParameterExpression x, ParameterExpression y);
    private bool EqualsTypeBinary(TypeBinaryExpression x, TypeBinaryExpression y);
    private bool EqualsUnary(UnaryExpression x, UnaryExpression y);
    private bool EqualsExtension(Expression x, Expression y);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[EditorBrowsableAttribute("2")]
public abstract class Moq.ExpressionCompiler : object {
    private static ExpressionCompiler instance;
    public static ExpressionCompiler Default { get; }
    public static ExpressionCompiler Instance { get; public set; }
    private static ExpressionCompiler();
    public static ExpressionCompiler get_Default();
    public static ExpressionCompiler get_Instance();
    public static void set_Instance(ExpressionCompiler value);
    public abstract virtual Delegate Compile(LambdaExpression expression);
    public abstract virtual TDelegate Compile(Expression`1<TDelegate> expression);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Moq.ExpressionExtensions : object {
    [ExtensionAttribute]
internal static Expression ConvertIfNeeded(Expression expression, Type type);
    [ExtensionAttribute]
internal static Delegate CompileUsingExpressionCompiler(LambdaExpression expression);
    [ExtensionAttribute]
internal static TDelegate CompileUsingExpressionCompiler(Expression`1<TDelegate> expression);
    [ExtensionAttribute]
public static bool IsMatch(Expression expression, Match& match);
    [ExtensionAttribute]
public static bool CanSplit(Expression e);
    [ExtensionAttribute]
internal static Stack`1<MethodExpectation> Split(LambdaExpression expression, bool allowNonOverridableLastProperty);
    [ExtensionAttribute]
internal static PropertyInfo GetReboundProperty(MemberExpression expression);
    [ExtensionAttribute]
public static PropertyInfo ToPropertyInfo(LambdaExpression expression);
    [ExtensionAttribute]
public static bool IsProperty(LambdaExpression expression);
    [ExtensionAttribute]
public static bool IsPropertyIndexer(LambdaExpression expression);
    [ExtensionAttribute]
public static Expression`1<Action`1<TMock>> AssignItIsAny(Expression`1<Func`2<TMock, T>> expression);
    [ExtensionAttribute]
public static Expression PartialEval(Expression expression);
    [ExtensionAttribute]
public static Expression PartialMatcherAwareEval(Expression expression);
    private static bool PartialMatcherAwareEval_ShouldEvaluate(Expression expression);
    [ExtensionAttribute]
public static string ToStringFixed(Expression expression);
    [ExtensionAttribute]
public static Expression Apply(Expression expression, ExpressionVisitor visitor);
    [CompilerGeneratedAttribute]
internal static void <Split>g__Split|5_0(Expression e, Expression& r, MethodExpectation& p, bool assignment, bool allowNonOverridableLastProperty);
    [CompilerGeneratedAttribute]
internal static bool <Split>g__IsResult|5_1(MemberInfo member, IAwaitableFactory& awaitableFactory);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Moq.ExpressionReconstructor : object {
    private static ExpressionReconstructor instance;
    public static ExpressionReconstructor Instance { get; public set; }
    private static ExpressionReconstructor();
    public static ExpressionReconstructor get_Instance();
    public static void set_Instance(ExpressionReconstructor value);
    public abstract virtual Expression`1<Action`1<T>> ReconstructExpression(Action`1<T> action, Object[] ctorArgs);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Moq.Expressions.Visitors.ConstructorCallVisitor : ExpressionVisitor {
    private ConstructorInfo constructor;
    private Object[] arguments;
    public static Object[] ExtractArgumentValues(LambdaExpression newExpression);
    public virtual Expression Visit(Expression node);
    protected virtual Expression VisitNew(NewExpression node);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Moq.Expressions.Visitors.EvaluateCaptures : ExpressionVisitor {
    public static ExpressionVisitor Rewriter;
    private static EvaluateCaptures();
    protected virtual Expression VisitMember(MemberExpression node);
    protected virtual Expression VisitUnary(UnaryExpression node);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Moq.Expressions.Visitors.UpgradePropertyAccessorMethods : ExpressionVisitor {
    public static ExpressionVisitor Rewriter;
    private static UpgradePropertyAccessorMethods();
    protected virtual Expression VisitMethodCall(MethodCallExpression node);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Moq.Extensions : object {
    private static ConcurrentDictionary`2<Tuple`2<Type, Type>, InterfaceMapping> mappingsCache;
    private static Extensions();
    [ExtensionAttribute]
public static bool CanCreateInstance(Type type);
    [ExtensionAttribute]
public static bool CanRead(PropertyInfo property, MethodInfo& getter);
    [ExtensionAttribute]
public static bool CanRead(PropertyInfo property, MethodInfo& getter, PropertyInfo& getterProperty);
    [ExtensionAttribute]
public static bool CanWrite(PropertyInfo property, MethodInfo& setter);
    [ExtensionAttribute]
public static bool CanWrite(PropertyInfo property, MethodInfo& setter, PropertyInfo& setterProperty);
    [ExtensionAttribute]
public static object GetDefaultValue(Type type);
    [ExtensionAttribute]
public static MethodInfo GetImplementingMethod(MethodInfo method, Type proxyType);
    [ExtensionAttribute]
public static object InvokePreserveStack(Delegate del, IReadOnlyList`1<object> args);
    [ExtensionAttribute]
public static bool IsExtensionMethod(MethodInfo method);
    [ExtensionAttribute]
public static bool IsGetAccessor(MethodInfo method);
    [ExtensionAttribute]
public static bool IsSetAccessor(MethodInfo method);
    [ExtensionAttribute]
public static bool IsIndexerAccessor(MethodInfo method);
    [ExtensionAttribute]
public static bool IsPropertyAccessor(MethodInfo method);
    [ExtensionAttribute]
public static bool IsEventAddAccessor(MethodInfo method);
    [ExtensionAttribute]
public static bool IsEventRemoveAccessor(MethodInfo method);
    [ExtensionAttribute]
public static bool IsDelegateType(Type type);
    [ExtensionAttribute]
public static bool IsMockable(Type type);
    [ExtensionAttribute]
public static bool IsTypeMatcher(Type type);
    [ExtensionAttribute]
public static bool IsTypeMatcher(Type type, Type& typeMatcherType);
    [ExtensionAttribute]
public static bool IsOrContainsTypeMatcher(Type type);
    [ExtensionAttribute]
public static bool ImplementsTypeMatcherProtocol(Type type);
    [ExtensionAttribute]
public static bool CanOverride(MethodBase method);
    [ExtensionAttribute]
public static bool CanOverrideGet(PropertyInfo property);
    [ExtensionAttribute]
public static bool CanOverrideSet(PropertyInfo property);
    [ExtensionAttribute]
public static IEnumerable`1<MethodInfo> GetMethods(Type type, string name);
    [ExtensionAttribute]
public static bool CompareTo(TTypes types, TOtherTypes otherTypes, bool exact, bool considerTypeMatchers);
    [ExtensionAttribute]
public static string GetParameterTypeList(MethodInfo method);
    [ExtensionAttribute]
public static ParameterTypes GetParameterTypes(MethodInfo method);
    [ExtensionAttribute]
public static bool CompareParameterTypesTo(Delegate function, TOtherTypes otherTypes);
    private static MethodInfo GetInvokeMethodFromUntypedDelegateCallback(Delegate callback);
    [ExtensionAttribute]
public static Type SubstituteTypeMatchers(Type type, Type other);
    private static InterfaceMapping GetInterfaceMap(Type type, Type interfaceType);
    [ExtensionAttribute]
public static IEnumerable`1<Mock> FindAllInnerMocks(SetupCollection setups);
    [ExtensionAttribute]
public static Mock FindLastInnerMock(SetupCollection setups, Func`2<Setup, bool> predicate);
}
internal static class Moq.FailForStrictMock : object {
    [NullableContextAttribute("1")]
public static void Handle(Invocation invocation, Mock mock);
}
internal static class Moq.FindAndExecuteMatchingSetup : object {
    [NullableContextAttribute("1")]
public static bool Handle(Invocation invocation, Mock mock);
}
[ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static class Moq.GeneratedReturnsExtensions : object {
    [ExtensionAttribute]
public static IReturnsResult`1<TMock> ReturnsAsync(IReturns`2<TMock, Task`1<TResult>> mock, Func`2<T, TResult> valueFunction);
    [ExtensionAttribute]
public static IReturnsResult`1<TMock> ReturnsAsync(IReturns`2<TMock, Task`1<TResult>> mock, Func`3<T1, T2, TResult> valueFunction);
    [ExtensionAttribute]
public static IReturnsResult`1<TMock> ReturnsAsync(IReturns`2<TMock, Task`1<TResult>> mock, Func`4<T1, T2, T3, TResult> valueFunction);
    [ExtensionAttribute]
public static IReturnsResult`1<TMock> ReturnsAsync(IReturns`2<TMock, Task`1<TResult>> mock, Func`5<T1, T2, T3, T4, TResult> valueFunction);
    [ExtensionAttribute]
public static IReturnsResult`1<TMock> ReturnsAsync(IReturns`2<TMock, Task`1<TResult>> mock, Func`6<T1, T2, T3, T4, T5, TResult> valueFunction);
    [ExtensionAttribute]
public static IReturnsResult`1<TMock> ReturnsAsync(IReturns`2<TMock, Task`1<TResult>> mock, Func`7<T1, T2, T3, T4, T5, T6, TResult> valueFunction);
    [ExtensionAttribute]
public static IReturnsResult`1<TMock> ReturnsAsync(IReturns`2<TMock, Task`1<TResult>> mock, Func`8<T1, T2, T3, T4, T5, T6, T7, TResult> valueFunction);
    [ExtensionAttribute]
public static IReturnsResult`1<TMock> ReturnsAsync(IReturns`2<TMock, Task`1<TResult>> mock, Func`9<T1, T2, T3, T4, T5, T6, T7, T8, TResult> valueFunction);
    [ExtensionAttribute]
public static IReturnsResult`1<TMock> ReturnsAsync(IReturns`2<TMock, Task`1<TResult>> mock, Func`10<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult> valueFunction);
    [ExtensionAttribute]
public static IReturnsResult`1<TMock> ReturnsAsync(IReturns`2<TMock, Task`1<TResult>> mock, Func`11<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult> valueFunction);
    [ExtensionAttribute]
public static IReturnsResult`1<TMock> ReturnsAsync(IReturns`2<TMock, Task`1<TResult>> mock, Func`12<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult> valueFunction);
    [ExtensionAttribute]
public static IReturnsResult`1<TMock> ReturnsAsync(IReturns`2<TMock, Task`1<TResult>> mock, Func`13<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult> valueFunction);
    [ExtensionAttribute]
public static IReturnsResult`1<TMock> ReturnsAsync(IReturns`2<TMock, Task`1<TResult>> mock, Func`14<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult> valueFunction);
    [ExtensionAttribute]
public static IReturnsResult`1<TMock> ReturnsAsync(IReturns`2<TMock, Task`1<TResult>> mock, Func`15<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult> valueFunction);
    [ExtensionAttribute]
public static IReturnsResult`1<TMock> ReturnsAsync(IReturns`2<TMock, Task`1<TResult>> mock, Func`16<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult> valueFunction);
    [ExtensionAttribute]
public static IReturnsResult`1<TMock> ReturnsAsync(IReturns`2<TMock, ValueTask`1<TResult>> mock, Func`2<T, TResult> valueFunction);
    [ExtensionAttribute]
public static IReturnsResult`1<TMock> ReturnsAsync(IReturns`2<TMock, ValueTask`1<TResult>> mock, Func`3<T1, T2, TResult> valueFunction);
    [ExtensionAttribute]
public static IReturnsResult`1<TMock> ReturnsAsync(IReturns`2<TMock, ValueTask`1<TResult>> mock, Func`4<T1, T2, T3, TResult> valueFunction);
    [ExtensionAttribute]
public static IReturnsResult`1<TMock> ReturnsAsync(IReturns`2<TMock, ValueTask`1<TResult>> mock, Func`5<T1, T2, T3, T4, TResult> valueFunction);
    [ExtensionAttribute]
public static IReturnsResult`1<TMock> ReturnsAsync(IReturns`2<TMock, ValueTask`1<TResult>> mock, Func`6<T1, T2, T3, T4, T5, TResult> valueFunction);
    [ExtensionAttribute]
public static IReturnsResult`1<TMock> ReturnsAsync(IReturns`2<TMock, ValueTask`1<TResult>> mock, Func`7<T1, T2, T3, T4, T5, T6, TResult> valueFunction);
    [ExtensionAttribute]
public static IReturnsResult`1<TMock> ReturnsAsync(IReturns`2<TMock, ValueTask`1<TResult>> mock, Func`8<T1, T2, T3, T4, T5, T6, T7, TResult> valueFunction);
    [ExtensionAttribute]
public static IReturnsResult`1<TMock> ReturnsAsync(IReturns`2<TMock, ValueTask`1<TResult>> mock, Func`9<T1, T2, T3, T4, T5, T6, T7, T8, TResult> valueFunction);
    [ExtensionAttribute]
public static IReturnsResult`1<TMock> ReturnsAsync(IReturns`2<TMock, ValueTask`1<TResult>> mock, Func`10<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult> valueFunction);
    [ExtensionAttribute]
public static IReturnsResult`1<TMock> ReturnsAsync(IReturns`2<TMock, ValueTask`1<TResult>> mock, Func`11<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult> valueFunction);
    [ExtensionAttribute]
public static IReturnsResult`1<TMock> ReturnsAsync(IReturns`2<TMock, ValueTask`1<TResult>> mock, Func`12<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult> valueFunction);
    [ExtensionAttribute]
public static IReturnsResult`1<TMock> ReturnsAsync(IReturns`2<TMock, ValueTask`1<TResult>> mock, Func`13<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult> valueFunction);
    [ExtensionAttribute]
public static IReturnsResult`1<TMock> ReturnsAsync(IReturns`2<TMock, ValueTask`1<TResult>> mock, Func`14<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult> valueFunction);
    [ExtensionAttribute]
public static IReturnsResult`1<TMock> ReturnsAsync(IReturns`2<TMock, ValueTask`1<TResult>> mock, Func`15<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult> valueFunction);
    [ExtensionAttribute]
public static IReturnsResult`1<TMock> ReturnsAsync(IReturns`2<TMock, ValueTask`1<TResult>> mock, Func`16<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult> valueFunction);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerStepThroughAttribute]
internal static class Moq.Guard : object {
    public static void CanCreateInstance(Type type);
    public static void ImplementsInterface(Type interfaceType, Type type, string paramName);
    public static void ImplementsTypeMatcherProtocol(Type type);
    public static void IsAssignmentToPropertyOrIndexer(LambdaExpression expression, string paramName);
    public static void IsOverridable(MethodInfo method, Expression expression);
    public static void IsVisibleToProxyFactory(MethodInfo method);
    public static void IsEventAdd(LambdaExpression expression, string paramName);
    public static void IsEventRemove(LambdaExpression expression, string paramName);
    public static void NotNull(object value, string paramName);
    public static void NotNullOrEmpty(string value, string paramName);
    public static void NotField(MemberExpression memberAccess);
    public static void IsMockable(Type type);
    public static void Positive(TimeSpan delay);
    public static void CanRead(PropertyInfo property);
    public static void CanWrite(PropertyInfo property);
}
internal static class Moq.HandleEventSubscription : object {
    [NullableContextAttribute("1")]
public static bool Handle(Invocation invocation, Mock mock);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Moq.HandleWellKnownMethods : object {
    private static Dictionary`2<string, Func`3<Invocation, Mock, bool>> specialMethods;
    private static HandleWellKnownMethods();
    public static bool Handle(Invocation invocation, Mock mock);
    private static bool HandleEquals(Invocation invocation, Mock mock);
    private static bool HandleGetHashCode(Invocation invocation, Mock mock);
    private static bool HandleToString(Invocation invocation, Mock mock);
    private static bool HandleMockGetter(Invocation invocation, Mock mock);
    private static bool IsObjectMethodWithoutSetup(Invocation invocation, Mock mock);
}
[EditorBrowsableAttribute("1")]
public interface Moq.IFluentInterface {
    [EditorBrowsableAttribute("1")]
public abstract virtual Type GetType();
    [EditorBrowsableAttribute("1")]
public abstract virtual int GetHashCode();
    [EditorBrowsableAttribute("1")]
public abstract virtual string ToString();
    [EditorBrowsableAttribute("1")]
public abstract virtual bool Equals(object obj);
}
[NullableContextAttribute("1")]
internal interface Moq.IInterceptor {
    public abstract virtual void Intercept(Invocation invocation);
}
[NullableContextAttribute("1")]
public interface Moq.IInvocation {
    public MethodInfo Method { get; }
    public IReadOnlyList`1<object> Arguments { get; }
    public ISetup MatchingSetup { get; }
    public bool IsVerified { get; }
    public object ReturnValue { get; }
    public Exception Exception { get; }
    public abstract virtual MethodInfo get_Method();
    public abstract virtual IReadOnlyList`1<object> get_Arguments();
    public abstract virtual ISetup get_MatchingSetup();
    public abstract virtual bool get_IsVerified();
    public abstract virtual object get_ReturnValue();
    public abstract virtual Exception get_Exception();
}
public interface Moq.IInvocationList {
    public abstract virtual void Clear();
}
[NullableContextAttribute("1")]
internal interface Moq.IMatcher {
    public abstract virtual bool Matches(object argument, Type parameterType);
    public abstract virtual void SetupEvaluatedSuccessfully(object argument, Type parameterType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Moq.ImmutablePopOnlyStack`1 : ValueType {
    private T[] items;
    private int index;
    public bool Empty { get; }
    public ImmutablePopOnlyStack`1(IEnumerable`1<T> items);
    private ImmutablePopOnlyStack`1(T[] items, int index);
    public bool get_Empty();
    public T Pop(ImmutablePopOnlyStack`1& stackBelowTop);
}
[NullableContextAttribute("1")]
public interface Moq.IMock`1 {
    public T Object { get; }
    public MockBehavior Behavior { get; }
    public bool CallBase { get; public set; }
    public DefaultValue DefaultValue { get; public set; }
    public abstract virtual T get_Object();
    public abstract virtual MockBehavior get_Behavior();
    public abstract virtual bool get_CallBase();
    public abstract virtual void set_CallBase(bool value);
    public abstract virtual DefaultValue get_DefaultValue();
    public abstract virtual void set_DefaultValue(DefaultValue value);
}
[NullableContextAttribute("1")]
[EditorBrowsableAttribute("1")]
public interface Moq.IMocked {
    public Mock Mock { get; }
    public abstract virtual Mock get_Mock();
}
[NullableContextAttribute("1")]
[EditorBrowsableAttribute("1")]
public interface Moq.IMocked`1 {
    public Mock`1<T> Mock { get; }
    public abstract virtual Mock`1<T> get_Mock();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Moq.InnerMockSetup : SetupWithOutParameterSupport {
    private object returnValue;
    public IEnumerable`1<Mock> InnerMocks { get; }
    public InnerMockSetup(Expression originalExpression, Mock mock, MethodExpectation expectation, object returnValue);
    [IteratorStateMachineAttribute("Moq.InnerMockSetup/<get_InnerMocks>d__3")]
public virtual IEnumerable`1<Mock> get_InnerMocks();
    protected virtual void ExecuteCore(Invocation invocation);
    protected virtual void ResetCore();
    protected virtual void VerifySelf();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[EditorBrowsableAttribute("1")]
public abstract class Moq.Internals.InterfaceProxy : object {
    private static MethodInfo equalsMethod;
    private static MethodInfo getHashCodeMethod;
    private static MethodInfo toStringMethod;
    private static InterfaceProxy();
    [DebuggerHiddenAttribute]
public sealed virtual bool Equals(object obj);
    [DebuggerHiddenAttribute]
public sealed virtual int GetHashCode();
    [DebuggerHiddenAttribute]
public sealed virtual string ToString();
}
[NullableContextAttribute("1")]
[EditorBrowsableAttribute("1")]
public interface Moq.Internals.IProxy {
    public object Interceptor { get; }
    public abstract virtual object get_Interceptor();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Moq.Invocation : object {
    private Object[] arguments;
    private MethodInfo method;
    private MethodInfo methodImplementation;
    private Type proxyType;
    private object result;
    private Setup matchingSetup;
    private bool verified;
    public MethodInfo Method { get; }
    public MethodInfo MethodImplementation { get; }
    public Object[] Arguments { get; }
    private IReadOnlyList`1<object> Moq.IInvocation.Arguments { get; }
    public ISetup MatchingSetup { get; }
    public Type ProxyType { get; }
    public object ReturnValue { get; public set; }
    public Exception Exception { get; public set; }
    public bool IsVerified { get; }
    protected Invocation(Type proxyType, MethodInfo method, Object[] arguments);
    public sealed virtual MethodInfo get_Method();
    public MethodInfo get_MethodImplementation();
    public Object[] get_Arguments();
    private sealed virtual override IReadOnlyList`1<object> Moq.IInvocation.get_Arguments();
    public sealed virtual ISetup get_MatchingSetup();
    public Type get_ProxyType();
    public sealed virtual object get_ReturnValue();
    public void set_ReturnValue(object value);
    public sealed virtual Exception get_Exception();
    public void set_Exception(Exception value);
    public void ConvertResultToAwaitable(IAwaitableFactory awaitableFactory);
    public sealed virtual bool get_IsVerified();
    protected internal abstract virtual object CallBase();
    internal void MarkAsMatchedBy(Setup setup);
    internal void MarkAsVerified();
    internal void MarkAsVerifiedIfMatchedBy(Func`2<Setup, bool> predicate);
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class Moq.InvocationAction : ValueType {
    internal Action`1<IInvocation> Action;
    public InvocationAction(Action`1<IInvocation> action);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
internal class Moq.InvocationCollection : object {
    private Invocation[] invocations;
    private int capacity;
    private int count;
    private object invocationsLock;
    private Mock owner;
    public int Count { get; }
    public IInvocation Item { get; }
    public InvocationCollection(Mock owner);
    public sealed virtual int get_Count();
    public sealed virtual IInvocation get_Item(int index);
    public void Add(Invocation invocation);
    public sealed virtual void Clear();
    public Invocation[] ToArray();
    public Invocation[] ToArray(Func`2<Invocation, bool> predicate);
    [IteratorStateMachineAttribute("Moq.InvocationCollection/<GetEnumerator>d__14")]
public sealed virtual IEnumerator`1<IInvocation> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class Moq.InvocationFunc : ValueType {
    internal Func`2<IInvocation, object> Func;
    public InvocationFunc(Func`2<IInvocation, object> func);
}
[NullableContextAttribute("1")]
public interface Moq.ISetup {
    public LambdaExpression Expression { get; }
    public Mock InnerMock { get; }
    public bool IsConditional { get; }
    public bool IsMatched { get; }
    public bool IsOverridden { get; }
    public bool IsVerifiable { get; }
    public Mock Mock { get; }
    public Expression OriginalExpression { get; }
    public abstract virtual LambdaExpression get_Expression();
    public abstract virtual Mock get_InnerMock();
    public abstract virtual bool get_IsConditional();
    public abstract virtual bool get_IsMatched();
    public abstract virtual bool get_IsOverridden();
    public abstract virtual bool get_IsVerifiable();
    public abstract virtual Mock get_Mock();
    public abstract virtual Expression get_OriginalExpression();
    public abstract virtual void Verify(bool recursive);
    public abstract virtual void VerifyAll();
}
public interface Moq.ISetupList {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class Moq.It : object {
    private static MethodInfo isAnyMethod;
    private static It();
    public static TValue IsAny();
    internal static MethodCallExpression IsAny(Type genericArgument);
    public static TValue IsNotNull();
    public static TValue Is(Expression`1<Func`2<TValue, bool>> match);
    [EditorBrowsableAttribute("2")]
public static TValue Is(Expression`1<Func`3<object, Type, bool>> match);
    [EditorBrowsableAttribute("2")]
public static TValue Is(TValue value, IEqualityComparer`1<TValue> comparer);
    public static TValue IsInRange(TValue from, TValue to, Range rangeKind);
    public static TValue IsIn(IEnumerable`1<TValue> items);
    public static TValue IsIn(IEnumerable`1<TValue> items, IEqualityComparer`1<TValue> comparer);
    public static TValue IsIn(TValue[] items);
    public static TValue IsNotIn(IEnumerable`1<TValue> items);
    public static TValue IsNotIn(IEnumerable`1<TValue> items, IEqualityComparer`1<TValue> comparer);
    public static TValue IsNotIn(TValue[] items);
    public static string IsRegex(string regex);
    public static string IsRegex(string regex, RegexOptions options);
}
[NullableContextAttribute("1")]
public interface Moq.ITypeMatcher {
    public abstract virtual bool Matches(Type typeArgument);
}
[EditorBrowsableAttribute("1")]
public interface Moq.Language.Flow.ICallbackResult {
}
[EditorBrowsableAttribute("1")]
public interface Moq.Language.Flow.ICallBaseResult {
}
[EditorBrowsableAttribute("1")]
public interface Moq.Language.Flow.IReturnsResult`1 {
}
[EditorBrowsableAttribute("1")]
public interface Moq.Language.Flow.IReturnsThrows`2 {
}
[EditorBrowsableAttribute("1")]
public interface Moq.Language.Flow.IReturnsThrowsGetter`2 {
}
[EditorBrowsableAttribute("1")]
public interface Moq.Language.Flow.ISetup`1 {
}
[EditorBrowsableAttribute("1")]
public interface Moq.Language.Flow.ISetup`2 {
}
[EditorBrowsableAttribute("1")]
public interface Moq.Language.Flow.ISetupGetter`2 {
}
[EditorBrowsableAttribute("1")]
public interface Moq.Language.Flow.ISetupSetter`2 {
}
[EditorBrowsableAttribute("1")]
public interface Moq.Language.Flow.IThrowsResult {
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Moq.Language.Flow.NonVoidSetupPhrase`2 : SetupPhrase {
    [NullableContextAttribute("1")]
public NonVoidSetupPhrase`2(MethodCall setup);
    [NullableContextAttribute("1")]
public sealed virtual IReturnsThrows`2<T, TResult> Callback(InvocationAction action);
    [NullableContextAttribute("1")]
public sealed virtual IReturnsThrows`2<T, TResult> Callback(Delegate callback);
    [NullableContextAttribute("1")]
private sealed virtual override IReturnsThrowsGetter`2<T, TResult> Moq.Language.ICallbackGetter<T,TResult>.Callback(Action callback);
    [NullableContextAttribute("1")]
public sealed virtual IReturnsThrows`2<T, TResult> Callback(Action callback);
    [NullableContextAttribute("1")]
public sealed virtual IReturnsThrows`2<T, TResult> Callback(Action`1<T1> callback);
    [NullableContextAttribute("1")]
public sealed virtual IReturnsThrows`2<T, TResult> Callback(Action`2<T1, T2> callback);
    public sealed virtual IReturnsThrows`2<T, TResult> Callback(Action`3<T1, T2, T3> callback);
    public sealed virtual IReturnsThrows`2<T, TResult> Callback(Action`4<T1, T2, T3, T4> callback);
    public sealed virtual IReturnsThrows`2<T, TResult> Callback(Action`5<T1, T2, T3, T4, T5> callback);
    public sealed virtual IReturnsThrows`2<T, TResult> Callback(Action`6<T1, T2, T3, T4, T5, T6> callback);
    public sealed virtual IReturnsThrows`2<T, TResult> Callback(Action`7<T1, T2, T3, T4, T5, T6, T7> callback);
    public sealed virtual IReturnsThrows`2<T, TResult> Callback(Action`8<T1, T2, T3, T4, T5, T6, T7, T8> callback);
    public sealed virtual IReturnsThrows`2<T, TResult> Callback(Action`9<T1, T2, T3, T4, T5, T6, T7, T8, T9> callback);
    public sealed virtual IReturnsThrows`2<T, TResult> Callback(Action`10<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> callback);
    public sealed virtual IReturnsThrows`2<T, TResult> Callback(Action`11<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> callback);
    public sealed virtual IReturnsThrows`2<T, TResult> Callback(Action`12<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> callback);
    public sealed virtual IReturnsThrows`2<T, TResult> Callback(Action`13<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13> callback);
    public sealed virtual IReturnsThrows`2<T, TResult> Callback(Action`14<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14> callback);
    public sealed virtual IReturnsThrows`2<T, TResult> Callback(Action`15<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15> callback);
    public sealed virtual IReturnsThrows`2<T, TResult> Callback(Action`16<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16> callback);
    [NullableContextAttribute("1")]
public sealed virtual IReturnsResult`1<T> CallBase();
    [NullableContextAttribute("1")]
public sealed virtual IVerifies Raises(Action`1<T> eventExpression, EventArgs args);
    [NullableContextAttribute("1")]
public sealed virtual IVerifies Raises(Action`1<T> eventExpression, Func`1<EventArgs> func);
    [NullableContextAttribute("1")]
public sealed virtual IVerifies Raises(Action`1<T> eventExpression, Object[] args);
    [NullableContextAttribute("1")]
public sealed virtual IVerifies Raises(Action`1<T> eventExpression, Func`2<T1, EventArgs> func);
    [NullableContextAttribute("1")]
public sealed virtual IVerifies Raises(Action`1<T> eventExpression, Func`3<T1, T2, EventArgs> func);
    [NullableContextAttribute("1")]
public sealed virtual IVerifies Raises(Action`1<T> eventExpression, Func`4<T1, T2, T3, EventArgs> func);
    public sealed virtual IVerifies Raises(Action`1<T> eventExpression, Func`5<T1, T2, T3, T4, EventArgs> func);
    public sealed virtual IVerifies Raises(Action`1<T> eventExpression, Func`6<T1, T2, T3, T4, T5, EventArgs> func);
    public sealed virtual IVerifies Raises(Action`1<T> eventExpression, Func`7<T1, T2, T3, T4, T5, T6, EventArgs> func);
    public sealed virtual IVerifies Raises(Action`1<T> eventExpression, Func`8<T1, T2, T3, T4, T5, T6, T7, EventArgs> func);
    public sealed virtual IVerifies Raises(Action`1<T> eventExpression, Func`9<T1, T2, T3, T4, T5, T6, T7, T8, EventArgs> func);
    public sealed virtual IVerifies Raises(Action`1<T> eventExpression, Func`10<T1, T2, T3, T4, T5, T6, T7, T8, T9, EventArgs> func);
    public sealed virtual IVerifies Raises(Action`1<T> eventExpression, Func`11<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, EventArgs> func);
    public sealed virtual IVerifies Raises(Action`1<T> eventExpression, Func`12<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, EventArgs> func);
    public sealed virtual IVerifies Raises(Action`1<T> eventExpression, Func`13<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, EventArgs> func);
    public sealed virtual IVerifies Raises(Action`1<T> eventExpression, Func`14<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, EventArgs> func);
    public sealed virtual IVerifies Raises(Action`1<T> eventExpression, Func`15<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, EventArgs> func);
    public sealed virtual IVerifies Raises(Action`1<T> eventExpression, Func`16<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, EventArgs> func);
    public sealed virtual IVerifies Raises(Action`1<T> eventExpression, Func`17<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, EventArgs> func);
    [NullableContextAttribute("1")]
public sealed virtual IReturnsResult`1<T> Returns(TResult value);
    [NullableContextAttribute("1")]
public sealed virtual IReturnsResult`1<T> Returns(InvocationFunc valueFunction);
    [NullableContextAttribute("1")]
public sealed virtual IReturnsResult`1<T> Returns(Delegate valueFunction);
    [NullableContextAttribute("1")]
public sealed virtual IReturnsResult`1<T> Returns(Func`1<TResult> valueExpression);
    [NullableContextAttribute("1")]
public sealed virtual IReturnsResult`1<T> Returns(Func`2<T1, TResult> valueExpression);
    [NullableContextAttribute("1")]
public sealed virtual IReturnsResult`1<T> Returns(Func`3<T1, T2, TResult> valueExpression);
    public sealed virtual IReturnsResult`1<T> Returns(Func`4<T1, T2, T3, TResult> valueExpression);
    public sealed virtual IReturnsResult`1<T> Returns(Func`5<T1, T2, T3, T4, TResult> valueExpression);
    public sealed virtual IReturnsResult`1<T> Returns(Func`6<T1, T2, T3, T4, T5, TResult> valueExpression);
    public sealed virtual IReturnsResult`1<T> Returns(Func`7<T1, T2, T3, T4, T5, T6, TResult> valueExpression);
    public sealed virtual IReturnsResult`1<T> Returns(Func`8<T1, T2, T3, T4, T5, T6, T7, TResult> valueExpression);
    public sealed virtual IReturnsResult`1<T> Returns(Func`9<T1, T2, T3, T4, T5, T6, T7, T8, TResult> valueExpression);
    public sealed virtual IReturnsResult`1<T> Returns(Func`10<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult> valueExpression);
    public sealed virtual IReturnsResult`1<T> Returns(Func`11<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult> valueExpression);
    public sealed virtual IReturnsResult`1<T> Returns(Func`12<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult> valueExpression);
    public sealed virtual IReturnsResult`1<T> Returns(Func`13<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult> valueExpression);
    public sealed virtual IReturnsResult`1<T> Returns(Func`14<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult> valueExpression);
    public sealed virtual IReturnsResult`1<T> Returns(Func`15<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult> valueExpression);
    public sealed virtual IReturnsResult`1<T> Returns(Func`16<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult> valueExpression);
    public sealed virtual IReturnsResult`1<T> Returns(Func`17<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, TResult> valueExpression);
    private sealed virtual override Type Moq.IFluentInterface.GetType();
}
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Moq.Language.Flow.SetterSetupPhrase`2 : VoidSetupPhrase`1<T> {
    [NullableContextAttribute("1")]
public SetterSetupPhrase`2(MethodCall setup);
    [NullableContextAttribute("1")]
public sealed virtual ICallbackResult Callback(Action`1<TProperty> callback);
    private sealed virtual override Type Moq.IFluentInterface.GetType();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal abstract class Moq.Language.Flow.SetupPhrase : object {
    [NullableAttribute("1")]
private MethodCall setup;
    [NullableAttribute("1")]
public MethodCall Setup { get; }
    [NullableContextAttribute("1")]
protected SetupPhrase(MethodCall setup);
    [NullableContextAttribute("1")]
public MethodCall get_Setup();
    [NullableContextAttribute("1")]
public sealed virtual IVerifies AtMost(int callCount);
    [NullableContextAttribute("1")]
public sealed virtual IVerifies AtMostOnce();
    [NullableContextAttribute("1")]
public sealed virtual ICallbackResult Callback(InvocationAction action);
    [NullableContextAttribute("1")]
public sealed virtual ICallbackResult Callback(Delegate callback);
    [NullableContextAttribute("1")]
public sealed virtual ICallbackResult Callback(Action callback);
    [NullableContextAttribute("1")]
public sealed virtual ICallbackResult Callback(Action`1<T> callback);
    [NullableContextAttribute("1")]
public sealed virtual ICallbackResult Callback(Action`2<T1, T2> callback);
    public sealed virtual ICallbackResult Callback(Action`3<T1, T2, T3> callback);
    public sealed virtual ICallbackResult Callback(Action`4<T1, T2, T3, T4> callback);
    public sealed virtual ICallbackResult Callback(Action`5<T1, T2, T3, T4, T5> callback);
    public sealed virtual ICallbackResult Callback(Action`6<T1, T2, T3, T4, T5, T6> callback);
    public sealed virtual ICallbackResult Callback(Action`7<T1, T2, T3, T4, T5, T6, T7> callback);
    public sealed virtual ICallbackResult Callback(Action`8<T1, T2, T3, T4, T5, T6, T7, T8> callback);
    public sealed virtual ICallbackResult Callback(Action`9<T1, T2, T3, T4, T5, T6, T7, T8, T9> callback);
    public sealed virtual ICallbackResult Callback(Action`10<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> callback);
    public sealed virtual ICallbackResult Callback(Action`11<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> callback);
    public sealed virtual ICallbackResult Callback(Action`12<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> callback);
    public sealed virtual ICallbackResult Callback(Action`13<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13> callback);
    public sealed virtual ICallbackResult Callback(Action`14<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14> callback);
    public sealed virtual ICallbackResult Callback(Action`15<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15> callback);
    public sealed virtual ICallbackResult Callback(Action`16<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16> callback);
    [NullableContextAttribute("1")]
public sealed virtual ICallBaseResult CallBase();
    [NullableContextAttribute("1")]
public sealed virtual IThrowsResult Throws(Exception exception);
    [NullableContextAttribute("1")]
public sealed virtual IThrowsResult Throws();
    [NullableContextAttribute("1")]
public sealed virtual IThrowsResult Throws(Delegate exceptionFunction);
    [NullableContextAttribute("1")]
public sealed virtual IThrowsResult Throws(Func`1<TException> exceptionFunction);
    [NullableContextAttribute("1")]
public sealed virtual IThrowsResult Throws(Func`2<T, TException> exceptionFunction);
    [NullableContextAttribute("1")]
public sealed virtual IThrowsResult Throws(Func`3<T1, T2, TException> exceptionFunction);
    [NullableContextAttribute("1")]
public sealed virtual IThrowsResult Throws(Func`4<T1, T2, T3, TException> exceptionFunction);
    public sealed virtual IThrowsResult Throws(Func`5<T1, T2, T3, T4, TException> exceptionFunction);
    public sealed virtual IThrowsResult Throws(Func`6<T1, T2, T3, T4, T5, TException> exceptionFunction);
    public sealed virtual IThrowsResult Throws(Func`7<T1, T2, T3, T4, T5, T6, TException> exceptionFunction);
    public sealed virtual IThrowsResult Throws(Func`8<T1, T2, T3, T4, T5, T6, T7, TException> exceptionFunction);
    public sealed virtual IThrowsResult Throws(Func`9<T1, T2, T3, T4, T5, T6, T7, T8, TException> exceptionFunction);
    public sealed virtual IThrowsResult Throws(Func`10<T1, T2, T3, T4, T5, T6, T7, T8, T9, TException> exceptionFunction);
    public sealed virtual IThrowsResult Throws(Func`11<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TException> exceptionFunction);
    public sealed virtual IThrowsResult Throws(Func`12<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TException> exceptionFunction);
    public sealed virtual IThrowsResult Throws(Func`13<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TException> exceptionFunction);
    public sealed virtual IThrowsResult Throws(Func`14<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TException> exceptionFunction);
    public sealed virtual IThrowsResult Throws(Func`15<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TException> exceptionFunction);
    public sealed virtual IThrowsResult Throws(Func`16<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TException> exceptionFunction);
    public sealed virtual IThrowsResult Throws(Func`17<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, TException> exceptionFunction);
    public sealed virtual void Verifiable();
    [NullableContextAttribute("1")]
public sealed virtual void Verifiable(string failMessage);
    [NullableContextAttribute("1")]
public sealed virtual void Verifiable(Func`1<Times> times);
    public sealed virtual void Verifiable(Times times);
    [NullableContextAttribute("1")]
public sealed virtual void Verifiable(Func`1<Times> times, string failMessage);
    [NullableContextAttribute("1")]
public sealed virtual void Verifiable(Times times, string failMessage);
    [NullableContextAttribute("1")]
public virtual string ToString();
    private sealed virtual override Type Moq.IFluentInterface.GetType();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[EditorBrowsableAttribute("1")]
internal class Moq.Language.Flow.SetupSequencePhrase : object {
    private SequenceSetup setup;
    public SetupSequencePhrase(SequenceSetup setup);
    public sealed virtual ISetupSequentialAction Pass();
    public sealed virtual ISetupSequentialAction Throws();
    public sealed virtual ISetupSequentialAction Throws(Exception exception);
    public sealed virtual ISetupSequentialAction Throws(Func`1<TException> exceptionFunction);
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Moq.Language.Flow.SetupSequencePhrase`1 : object {
    private SequenceSetup setup;
    public SetupSequencePhrase`1(SequenceSetup setup);
    public sealed virtual ISetupSequentialResult`1<TResult> CallBase();
    public sealed virtual ISetupSequentialResult`1<TResult> Returns(TResult value);
    public sealed virtual ISetupSequentialResult`1<TResult> Returns(Func`1<TResult> valueFunction);
    public sealed virtual ISetupSequentialResult`1<TResult> Throws(Exception exception);
    public sealed virtual ISetupSequentialResult`1<TResult> Throws();
    public sealed virtual ISetupSequentialResult`1<TResult> Throws(Func`1<TException> exceptionFunction);
    public virtual string ToString();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Moq.Language.Flow.VoidSetupPhrase`1 : SetupPhrase {
    [NullableContextAttribute("1")]
public VoidSetupPhrase`1(MethodCall setup);
    [NullableContextAttribute("1")]
public sealed virtual IVerifies Raises(Action`1<T> eventExpression, EventArgs args);
    [NullableContextAttribute("1")]
public sealed virtual IVerifies Raises(Action`1<T> eventExpression, Func`1<EventArgs> func);
    [NullableContextAttribute("1")]
public sealed virtual IVerifies Raises(Action`1<T> eventExpression, Object[] args);
    [NullableContextAttribute("1")]
public sealed virtual IVerifies Raises(Action`1<T> eventExpression, Func`2<T1, EventArgs> func);
    [NullableContextAttribute("1")]
public sealed virtual IVerifies Raises(Action`1<T> eventExpression, Func`3<T1, T2, EventArgs> func);
    [NullableContextAttribute("1")]
public sealed virtual IVerifies Raises(Action`1<T> eventExpression, Func`4<T1, T2, T3, EventArgs> func);
    public sealed virtual IVerifies Raises(Action`1<T> eventExpression, Func`5<T1, T2, T3, T4, EventArgs> func);
    public sealed virtual IVerifies Raises(Action`1<T> eventExpression, Func`6<T1, T2, T3, T4, T5, EventArgs> func);
    public sealed virtual IVerifies Raises(Action`1<T> eventExpression, Func`7<T1, T2, T3, T4, T5, T6, EventArgs> func);
    public sealed virtual IVerifies Raises(Action`1<T> eventExpression, Func`8<T1, T2, T3, T4, T5, T6, T7, EventArgs> func);
    public sealed virtual IVerifies Raises(Action`1<T> eventExpression, Func`9<T1, T2, T3, T4, T5, T6, T7, T8, EventArgs> func);
    public sealed virtual IVerifies Raises(Action`1<T> eventExpression, Func`10<T1, T2, T3, T4, T5, T6, T7, T8, T9, EventArgs> func);
    public sealed virtual IVerifies Raises(Action`1<T> eventExpression, Func`11<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, EventArgs> func);
    public sealed virtual IVerifies Raises(Action`1<T> eventExpression, Func`12<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, EventArgs> func);
    public sealed virtual IVerifies Raises(Action`1<T> eventExpression, Func`13<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, EventArgs> func);
    public sealed virtual IVerifies Raises(Action`1<T> eventExpression, Func`14<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, EventArgs> func);
    public sealed virtual IVerifies Raises(Action`1<T> eventExpression, Func`15<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, EventArgs> func);
    public sealed virtual IVerifies Raises(Action`1<T> eventExpression, Func`16<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, EventArgs> func);
    public sealed virtual IVerifies Raises(Action`1<T> eventExpression, Func`17<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, EventArgs> func);
    private sealed virtual override Type Moq.IFluentInterface.GetType();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Moq.Language.Flow.WhenPhrase`1 : object {
    private Mock`1<T> mock;
    private Condition condition;
    public WhenPhrase`1(Mock`1<T> mock, Condition condition);
    public sealed virtual ISetup`1<T> Setup(Expression`1<Action`1<T>> expression);
    public sealed virtual ISetup`2<T, TResult> Setup(Expression`1<Func`2<T, TResult>> expression);
    public sealed virtual ISetupGetter`2<T, TProperty> SetupGet(Expression`1<Func`2<T, TProperty>> expression);
    public sealed virtual ISetupSetter`2<T, TProperty> SetupSet(Action`1<T> setterExpression);
    public sealed virtual ISetup`1<T> SetupSet(Action`1<T> setterExpression);
}
[EditorBrowsableAttribute("1")]
public interface Moq.Language.ICallback {
    [NullableContextAttribute("1")]
public abstract virtual ICallbackResult Callback(InvocationAction action);
    [NullableContextAttribute("1")]
public abstract virtual ICallbackResult Callback(Delegate callback);
    [NullableContextAttribute("1")]
public abstract virtual ICallbackResult Callback(Action action);
    [NullableContextAttribute("1")]
public abstract virtual ICallbackResult Callback(Action`1<T> action);
    public abstract virtual ICallbackResult Callback(Action`2<T1, T2> action);
    public abstract virtual ICallbackResult Callback(Action`3<T1, T2, T3> action);
    public abstract virtual ICallbackResult Callback(Action`4<T1, T2, T3, T4> action);
    public abstract virtual ICallbackResult Callback(Action`5<T1, T2, T3, T4, T5> action);
    public abstract virtual ICallbackResult Callback(Action`6<T1, T2, T3, T4, T5, T6> action);
    public abstract virtual ICallbackResult Callback(Action`7<T1, T2, T3, T4, T5, T6, T7> action);
    public abstract virtual ICallbackResult Callback(Action`8<T1, T2, T3, T4, T5, T6, T7, T8> action);
    public abstract virtual ICallbackResult Callback(Action`9<T1, T2, T3, T4, T5, T6, T7, T8, T9> action);
    public abstract virtual ICallbackResult Callback(Action`10<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> action);
    public abstract virtual ICallbackResult Callback(Action`11<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> action);
    public abstract virtual ICallbackResult Callback(Action`12<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> action);
    public abstract virtual ICallbackResult Callback(Action`13<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13> action);
    public abstract virtual ICallbackResult Callback(Action`14<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14> action);
    public abstract virtual ICallbackResult Callback(Action`15<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15> action);
    public abstract virtual ICallbackResult Callback(Action`16<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16> action);
}
[EditorBrowsableAttribute("1")]
public interface Moq.Language.ICallback`2 {
    [NullableContextAttribute("1")]
public abstract virtual IReturnsThrows`2<TMock, TResult> Callback(InvocationAction action);
    [NullableContextAttribute("1")]
public abstract virtual IReturnsThrows`2<TMock, TResult> Callback(Delegate callback);
    [NullableContextAttribute("1")]
public abstract virtual IReturnsThrows`2<TMock, TResult> Callback(Action action);
    [NullableContextAttribute("1")]
public abstract virtual IReturnsThrows`2<TMock, TResult> Callback(Action`1<T> action);
    public abstract virtual IReturnsThrows`2<TMock, TResult> Callback(Action`2<T1, T2> action);
    public abstract virtual IReturnsThrows`2<TMock, TResult> Callback(Action`3<T1, T2, T3> action);
    public abstract virtual IReturnsThrows`2<TMock, TResult> Callback(Action`4<T1, T2, T3, T4> action);
    public abstract virtual IReturnsThrows`2<TMock, TResult> Callback(Action`5<T1, T2, T3, T4, T5> action);
    public abstract virtual IReturnsThrows`2<TMock, TResult> Callback(Action`6<T1, T2, T3, T4, T5, T6> action);
    public abstract virtual IReturnsThrows`2<TMock, TResult> Callback(Action`7<T1, T2, T3, T4, T5, T6, T7> action);
    public abstract virtual IReturnsThrows`2<TMock, TResult> Callback(Action`8<T1, T2, T3, T4, T5, T6, T7, T8> action);
    public abstract virtual IReturnsThrows`2<TMock, TResult> Callback(Action`9<T1, T2, T3, T4, T5, T6, T7, T8, T9> action);
    public abstract virtual IReturnsThrows`2<TMock, TResult> Callback(Action`10<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10> action);
    public abstract virtual IReturnsThrows`2<TMock, TResult> Callback(Action`11<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11> action);
    public abstract virtual IReturnsThrows`2<TMock, TResult> Callback(Action`12<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12> action);
    public abstract virtual IReturnsThrows`2<TMock, TResult> Callback(Action`13<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13> action);
    public abstract virtual IReturnsThrows`2<TMock, TResult> Callback(Action`14<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14> action);
    public abstract virtual IReturnsThrows`2<TMock, TResult> Callback(Action`15<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15> action);
    public abstract virtual IReturnsThrows`2<TMock, TResult> Callback(Action`16<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16> action);
}
[NullableContextAttribute("1")]
[EditorBrowsableAttribute("1")]
public interface Moq.Language.ICallbackGetter`2 {
    public abstract virtual IReturnsThrowsGetter`2<TMock, TProperty> Callback(Action action);
}
[EditorBrowsableAttribute("1")]
public interface Moq.Language.ICallbackSetter`1 {
    [NullableContextAttribute("1")]
public abstract virtual ICallbackResult Callback(Action`1<TProperty> action);
}
[EditorBrowsableAttribute("1")]
public interface Moq.Language.ICallBase {
    [NullableContextAttribute("1")]
public abstract virtual ICallBaseResult CallBase();
}
[NullableContextAttribute("1")]
[EditorBrowsableAttribute("1")]
public interface Moq.Language.IOccurrence {
    [ObsoleteAttribute("Use 'mock.Verify(call, Times.AtMostOnce)' or 'setup.Verifiable(Times.AtMostOnce)' instead.")]
[EditorBrowsableAttribute("1")]
public abstract virtual IVerifies AtMostOnce();
    [ObsoleteAttribute("Use 'mock.Verify(call, Times.AtMost(callCount))' or 'setup.Verifiable(Times.AtMost(callCount))' instead.")]
[EditorBrowsableAttribute("1")]
public abstract virtual IVerifies AtMost(int callCount);
}
[EditorBrowsableAttribute("1")]
public interface Moq.Language.IRaise`1 {
    [NullableContextAttribute("1")]
public abstract virtual IVerifies Raises(Action`1<T> eventExpression, EventArgs args);
    [NullableContextAttribute("1")]
public abstract virtual IVerifies Raises(Action`1<T> eventExpression, Func`1<EventArgs> func);
    [NullableContextAttribute("1")]
public abstract virtual IVerifies Raises(Action`1<T> eventExpression, Object[] args);
    public abstract virtual IVerifies Raises(Action`1<T> eventExpression, Func`2<T1, EventArgs> func);
    public abstract virtual IVerifies Raises(Action`1<T> eventExpression, Func`3<T1, T2, EventArgs> func);
    public abstract virtual IVerifies Raises(Action`1<T> eventExpression, Func`4<T1, T2, T3, EventArgs> func);
    public abstract virtual IVerifies Raises(Action`1<T> eventExpression, Func`5<T1, T2, T3, T4, EventArgs> func);
    public abstract virtual IVerifies Raises(Action`1<T> eventExpression, Func`6<T1, T2, T3, T4, T5, EventArgs> func);
    public abstract virtual IVerifies Raises(Action`1<T> eventExpression, Func`7<T1, T2, T3, T4, T5, T6, EventArgs> func);
    public abstract virtual IVerifies Raises(Action`1<T> eventExpression, Func`8<T1, T2, T3, T4, T5, T6, T7, EventArgs> func);
    public abstract virtual IVerifies Raises(Action`1<T> eventExpression, Func`9<T1, T2, T3, T4, T5, T6, T7, T8, EventArgs> func);
    public abstract virtual IVerifies Raises(Action`1<T> eventExpression, Func`10<T1, T2, T3, T4, T5, T6, T7, T8, T9, EventArgs> func);
    public abstract virtual IVerifies Raises(Action`1<T> eventExpression, Func`11<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, EventArgs> func);
    public abstract virtual IVerifies Raises(Action`1<T> eventExpression, Func`12<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, EventArgs> func);
    public abstract virtual IVerifies Raises(Action`1<T> eventExpression, Func`13<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, EventArgs> func);
    public abstract virtual IVerifies Raises(Action`1<T> eventExpression, Func`14<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, EventArgs> func);
    public abstract virtual IVerifies Raises(Action`1<T> eventExpression, Func`15<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, EventArgs> func);
    public abstract virtual IVerifies Raises(Action`1<T> eventExpression, Func`16<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, EventArgs> func);
    public abstract virtual IVerifies Raises(Action`1<T> eventExpression, Func`17<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, EventArgs> func);
}
[EditorBrowsableAttribute("1")]
public interface Moq.Language.IReturns`2 {
    [NullableContextAttribute("1")]
public abstract virtual IReturnsResult`1<TMock> Returns(TResult value);
    [NullableContextAttribute("1")]
public abstract virtual IReturnsResult`1<TMock> Returns(InvocationFunc valueFunction);
    [NullableContextAttribute("1")]
public abstract virtual IReturnsResult`1<TMock> Returns(Delegate valueFunction);
    [NullableContextAttribute("1")]
public abstract virtual IReturnsResult`1<TMock> Returns(Func`1<TResult> valueFunction);
    [NullableContextAttribute("1")]
public abstract virtual IReturnsResult`1<TMock> Returns(Func`2<T, TResult> valueFunction);
    [NullableContextAttribute("1")]
public abstract virtual IReturnsResult`1<TMock> CallBase();
    public abstract virtual IReturnsResult`1<TMock> Returns(Func`3<T1, T2, TResult> valueFunction);
    public abstract virtual IReturnsResult`1<TMock> Returns(Func`4<T1, T2, T3, TResult> valueFunction);
    public abstract virtual IReturnsResult`1<TMock> Returns(Func`5<T1, T2, T3, T4, TResult> valueFunction);
    public abstract virtual IReturnsResult`1<TMock> Returns(Func`6<T1, T2, T3, T4, T5, TResult> valueFunction);
    public abstract virtual IReturnsResult`1<TMock> Returns(Func`7<T1, T2, T3, T4, T5, T6, TResult> valueFunction);
    public abstract virtual IReturnsResult`1<TMock> Returns(Func`8<T1, T2, T3, T4, T5, T6, T7, TResult> valueFunction);
    public abstract virtual IReturnsResult`1<TMock> Returns(Func`9<T1, T2, T3, T4, T5, T6, T7, T8, TResult> valueFunction);
    public abstract virtual IReturnsResult`1<TMock> Returns(Func`10<T1, T2, T3, T4, T5, T6, T7, T8, T9, TResult> valueFunction);
    public abstract virtual IReturnsResult`1<TMock> Returns(Func`11<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TResult> valueFunction);
    public abstract virtual IReturnsResult`1<TMock> Returns(Func`12<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TResult> valueFunction);
    public abstract virtual IReturnsResult`1<TMock> Returns(Func`13<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TResult> valueFunction);
    public abstract virtual IReturnsResult`1<TMock> Returns(Func`14<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TResult> valueFunction);
    public abstract virtual IReturnsResult`1<TMock> Returns(Func`15<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TResult> valueFunction);
    public abstract virtual IReturnsResult`1<TMock> Returns(Func`16<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TResult> valueFunction);
    public abstract virtual IReturnsResult`1<TMock> Returns(Func`17<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, TResult> valueFunction);
}
[NullableContextAttribute("1")]
[EditorBrowsableAttribute("1")]
public interface Moq.Language.IReturnsGetter`2 {
    public abstract virtual IReturnsResult`1<TMock> Returns(TProperty value);
    public abstract virtual IReturnsResult`1<TMock> Returns(Func`1<TProperty> valueFunction);
    public abstract virtual IReturnsResult`1<TMock> CallBase();
}
[NullableContextAttribute("1")]
[EditorBrowsableAttribute("1")]
public interface Moq.Language.ISetupConditionResult`1 {
    public abstract virtual ISetup`1<T> Setup(Expression`1<Action`1<T>> expression);
    public abstract virtual ISetup`2<T, TResult> Setup(Expression`1<Func`2<T, TResult>> expression);
    public abstract virtual ISetupGetter`2<T, TProperty> SetupGet(Expression`1<Func`2<T, TProperty>> expression);
    public abstract virtual ISetupSetter`2<T, TProperty> SetupSet(Action`1<T> setterExpression);
    public abstract virtual ISetup`1<T> SetupSet(Action`1<T> setterExpression);
}
[NullableContextAttribute("1")]
[EditorBrowsableAttribute("1")]
public interface Moq.Language.ISetupSequentialAction {
    public abstract virtual ISetupSequentialAction Pass();
    public abstract virtual ISetupSequentialAction Throws();
    public abstract virtual ISetupSequentialAction Throws(Exception exception);
    public abstract virtual ISetupSequentialAction Throws(Func`1<TException> exceptionFunction);
}
[NullableContextAttribute("1")]
[EditorBrowsableAttribute("1")]
public interface Moq.Language.ISetupSequentialResult`1 {
    public abstract virtual ISetupSequentialResult`1<TResult> Returns(TResult value);
    public abstract virtual ISetupSequentialResult`1<TResult> Returns(Func`1<TResult> valueFunction);
    public abstract virtual ISetupSequentialResult`1<TResult> Throws(Exception exception);
    public abstract virtual ISetupSequentialResult`1<TResult> Throws();
    public abstract virtual ISetupSequentialResult`1<TResult> Throws(Func`1<TException> exceptionFunction);
    public abstract virtual ISetupSequentialResult`1<TResult> CallBase();
}
[EditorBrowsableAttribute("1")]
public interface Moq.Language.IThrows {
    [NullableContextAttribute("1")]
public abstract virtual IThrowsResult Throws(Exception exception);
    [NullableContextAttribute("1")]
public abstract virtual IThrowsResult Throws();
    [NullableContextAttribute("1")]
public abstract virtual IThrowsResult Throws(Delegate exceptionFunction);
    [NullableContextAttribute("1")]
public abstract virtual IThrowsResult Throws(Func`1<TException> exceptionFunction);
    [NullableContextAttribute("1")]
public abstract virtual IThrowsResult Throws(Func`2<T, TException> exceptionFunction);
    public abstract virtual IThrowsResult Throws(Func`3<T1, T2, TException> exceptionFunction);
    public abstract virtual IThrowsResult Throws(Func`4<T1, T2, T3, TException> exceptionFunction);
    public abstract virtual IThrowsResult Throws(Func`5<T1, T2, T3, T4, TException> exceptionFunction);
    public abstract virtual IThrowsResult Throws(Func`6<T1, T2, T3, T4, T5, TException> exceptionFunction);
    public abstract virtual IThrowsResult Throws(Func`7<T1, T2, T3, T4, T5, T6, TException> exceptionFunction);
    public abstract virtual IThrowsResult Throws(Func`8<T1, T2, T3, T4, T5, T6, T7, TException> exceptionFunction);
    public abstract virtual IThrowsResult Throws(Func`9<T1, T2, T3, T4, T5, T6, T7, T8, TException> exceptionFunction);
    public abstract virtual IThrowsResult Throws(Func`10<T1, T2, T3, T4, T5, T6, T7, T8, T9, TException> exceptionFunction);
    public abstract virtual IThrowsResult Throws(Func`11<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TException> exceptionFunction);
    public abstract virtual IThrowsResult Throws(Func`12<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TException> exceptionFunction);
    public abstract virtual IThrowsResult Throws(Func`13<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TException> exceptionFunction);
    public abstract virtual IThrowsResult Throws(Func`14<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TException> exceptionFunction);
    public abstract virtual IThrowsResult Throws(Func`15<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TException> exceptionFunction);
    public abstract virtual IThrowsResult Throws(Func`16<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, TException> exceptionFunction);
    public abstract virtual IThrowsResult Throws(Func`17<T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, TException> exceptionFunction);
}
[NullableContextAttribute("1")]
[EditorBrowsableAttribute("1")]
public interface Moq.Language.IVerifies {
    public abstract virtual void Verifiable();
    public abstract virtual void Verifiable(string failMessage);
    public abstract virtual void Verifiable(Times times);
    public abstract virtual void Verifiable(Func`1<Times> times);
    public abstract virtual void Verifiable(Times times, string failMessage);
    public abstract virtual void Verifiable(Func`1<Times> times, string failMessage);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Moq.Linq.MockQueryable`1 : object {
    private Expression expression;
    public Type ElementType { get; }
    public Expression Expression { get; }
    public IQueryProvider Provider { get; }
    public MockQueryable`1(Expression expression);
    public sealed virtual Type get_ElementType();
    public sealed virtual Expression get_Expression();
    public sealed virtual IQueryProvider get_Provider();
    public sealed virtual IQueryable CreateQuery(Expression expression);
    public sealed virtual IQueryable`1<TElement> CreateQuery(Expression expression);
    public sealed virtual object Execute(Expression expression);
    public sealed virtual TResult Execute(Expression expression);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Moq.Linq.MockSetupsBuilder : ExpressionVisitor {
    private static String[] queryableMethods;
    private static String[] unsupportedMethods;
    private int stackIndex;
    private int quoteDepth;
    private static MockSetupsBuilder();
    protected virtual Expression VisitBinary(BinaryExpression node);
    protected virtual Expression VisitMember(MemberExpression node);
    protected virtual Expression VisitMethodCall(MethodCallExpression node);
    protected virtual Expression VisitUnary(UnaryExpression node);
    private static Expression ConvertToSetup(Expression left, Expression right);
    private static Expression ConvertToSetupReturns(Expression left, Expression right);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[EditorBrowsableAttribute("2")]
public abstract class Moq.LookupOrFallbackDefaultValueProvider : DefaultValueProvider {
    private Dictionary`2<object, Func`3<Type, Mock, object>> factories;
    protected void Deregister(Type factoryKey);
    protected void Register(Type factoryKey, Func`3<Type, Mock, object> factory);
    protected internal sealed virtual object GetDefaultParameterValue(ParameterInfo parameter, Mock mock);
    protected internal sealed virtual object GetDefaultReturnValue(MethodInfo method, Mock mock);
    protected internal sealed virtual object GetDefaultValue(Type type, Mock mock);
    protected virtual object GetFallbackDefaultValue(Type type, Mock mock);
    private object CreateValueTupleOf(Type type, Mock mock);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Moq.Match : object {
    [CompilerGeneratedAttribute]
private Expression <RenderExpression>k__BackingField;
    internal Expression RenderExpression { get; internal set; }
    internal static TValue Matcher();
    internal abstract virtual bool Matches(object argument, Type parameterType);
    internal abstract virtual void SetupEvaluatedSuccessfully(object argument, Type parameterType);
    private sealed virtual override bool Moq.IMatcher.Matches(object argument, Type parameterType);
    private sealed virtual override void Moq.IMatcher.SetupEvaluatedSuccessfully(object value, Type parameterType);
    [CompilerGeneratedAttribute]
internal Expression get_RenderExpression();
    [CompilerGeneratedAttribute]
internal void set_RenderExpression(Expression value);
    public static T Create(Predicate`1<T> condition);
    public static T Create(Predicate`1<T> condition, Expression`1<Func`1<T>> renderExpression);
    public static T Create(Func`3<object, Type, bool> condition, Expression`1<Func`1<T>> renderExpression);
    internal static void Register(Match match);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Moq.Match`1 : Match {
    [CompilerGeneratedAttribute]
private Predicate`1<T> <Condition>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`1<T> <Success>k__BackingField;
    internal Predicate`1<T> Condition { get; internal set; }
    internal Action`1<T> Success { get; internal set; }
    internal Match`1(Predicate`1<T> condition, Expression`1<Func`1<T>> renderExpression, Action`1<T> success);
    [CompilerGeneratedAttribute]
internal Predicate`1<T> get_Condition();
    [CompilerGeneratedAttribute]
internal void set_Condition(Predicate`1<T> value);
    [CompilerGeneratedAttribute]
internal Action`1<T> get_Success();
    [CompilerGeneratedAttribute]
internal void set_Success(Action`1<T> value);
    internal virtual bool Matches(object argument, Type parameterType);
    internal virtual void SetupEvaluatedSuccessfully(object argument, Type parameterType);
    private static bool CanCast(object value);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(Match`1<T> other);
    public virtual int GetHashCode();
}
[AttributeUsageAttribute("64")]
[EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This feature has been deprecated in favor of `Match.Create`.")]
public class Moq.MatcherAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Moq.MatcherFactory : object {
    public static Pair`2<IMatcher[], Expression[]> CreateMatchers(IReadOnlyList`1<Expression> arguments, ParameterInfo[] parameters);
    public static Pair`2<IMatcher, Expression> CreateMatcher(Expression argument, ParameterInfo parameter);
    public static Pair`2<IMatcher, Expression> CreateMatcher(Expression expression);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Moq.MatcherObserver : object {
    [ThreadStaticAttribute]
private static Stack`1<MatcherObserver> activations;
    private int timestamp;
    private List`1<Observation> observations;
    public static MatcherObserver Activate();
    public static bool IsActive(MatcherObserver& observer);
    public sealed virtual void Dispose();
    public int GetNextTimestamp();
    public void OnMatch(Match match);
    public bool TryGetLastMatch(Match& match);
    public IEnumerable`1<Match> GetMatchesBetween(int fromTimestampInclusive, int toTimestampExclusive);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Moq.Matchers.AnyMatcher : object {
    [CompilerGeneratedAttribute]
private static AnyMatcher <Instance>k__BackingField;
    public static AnyMatcher Instance { get; }
    private static AnyMatcher();
    [CompilerGeneratedAttribute]
public static AnyMatcher get_Instance();
    public sealed virtual bool Matches(object argument, Type parameterType);
    public sealed virtual void SetupEvaluatedSuccessfully(object argument, Type parameterType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Moq.Matchers.ConstantMatcher : object {
    private object constantValue;
    public ConstantMatcher(object constantValue);
    public sealed virtual bool Matches(object argument, Type parameterType);
    public sealed virtual void SetupEvaluatedSuccessfully(object argument, Type parameterType);
    private bool MatchesEnumerable(IEnumerable enumerable);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Moq.Matchers.ExpressionMatcher : object {
    private Expression expression;
    public ExpressionMatcher(Expression expression);
    public sealed virtual bool Matches(object argument, Type parameterType);
    public sealed virtual void SetupEvaluatedSuccessfully(object argument, Type parameterType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Moq.Matchers.LazyEvalMatcher : object {
    private Expression expression;
    public LazyEvalMatcher(Expression expression);
    public sealed virtual bool Matches(object argument, Type parameterType);
    public sealed virtual void SetupEvaluatedSuccessfully(object argument, Type parameterType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Moq.Matchers.MatcherAttributeMatcher : object {
    private MethodInfo validatorMethod;
    private MethodCallExpression expression;
    public MatcherAttributeMatcher(MethodCallExpression expression);
    private static MethodInfo ResolveValidatorMethod(MethodCallExpression call);
    public sealed virtual bool Matches(object argument, Type parameterType);
    public sealed virtual void SetupEvaluatedSuccessfully(object argument, Type parameterType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Moq.Matchers.ParamArrayMatcher : object {
    private IMatcher[] matchers;
    public ParamArrayMatcher(IMatcher[] matchers);
    public sealed virtual bool Matches(object argument, Type parameterType);
    public sealed virtual void SetupEvaluatedSuccessfully(object argument, Type parameterType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Moq.Matchers.RefMatcher : object {
    private object reference;
    private bool referenceIsValueType;
    public RefMatcher(object reference);
    public sealed virtual bool Matches(object argument, Type parameterType);
    public sealed virtual void SetupEvaluatedSuccessfully(object value, Type parameterType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Moq.MatchExpression : Expression {
    public Match Match;
    public ExpressionType NodeType { get; }
    public Type Type { get; }
    public bool CanReduce { get; }
    public MatchExpression(Match match);
    public virtual ExpressionType get_NodeType();
    public virtual Type get_Type();
    public virtual bool get_CanReduce();
    protected virtual Expression VisitChildren(ExpressionVisitor visitor);
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Moq.MatchFactory : Match {
    private Func`3<object, Type, bool> condition;
    private static MethodInfo canCastMethod;
    internal MatchFactory(Func`3<object, Type, bool> condition, LambdaExpression renderExpression);
    private static MatchFactory();
    internal virtual bool Matches(object argument, Type parameterType);
    internal virtual void SetupEvaluatedSuccessfully(object argument, Type parameterType);
    private static bool CanCast(object value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Moq.MethodCall : SetupWithOutParameterSupport {
    private VerifyInvocationCount verifyInvocationCount;
    private Behavior callback;
    private Behavior raiseEvent;
    private Behavior returnOrThrow;
    private Behavior afterReturnCallback;
    private Condition condition;
    private string failMessage;
    private string declarationSite;
    public string FailMessage { get; }
    public Condition Condition { get; }
    public IEnumerable`1<Mock> InnerMocks { get; }
    public MethodCall(Expression originalExpression, Mock mock, Condition condition, MethodExpectation expectation);
    public string get_FailMessage();
    public virtual Condition get_Condition();
    [IteratorStateMachineAttribute("Moq.MethodCall/<get_InnerMocks>d__14")]
public virtual IEnumerable`1<Mock> get_InnerMocks();
    private static string GetUserCodeCallSite();
    protected virtual void ExecuteCore(Invocation invocation);
    public void SetCallBaseBehavior();
    public void SetCallbackBehavior(Delegate callback);
    public void SetFailMessage(string failMessage);
    public void SetRaiseEventBehavior(Action`1<TMock> eventExpression, Delegate func);
    public void SetRaiseEventBehavior(Action`1<TMock> eventExpression, Object[] args);
    public void SetReturnValueBehavior(object value);
    public void SetReturnComputedValueBehavior(Delegate valueFactory);
    public void SetThrowExceptionBehavior(Exception exception);
    public void SetThrowComputedExceptionBehavior(Delegate exceptionFactory);
    protected virtual void ResetCore();
    public void SetExpectedInvocationCount(Times times);
    protected virtual void VerifySelf();
    public virtual string ToString();
    private void ValidateNumberOfCallbackParameters(Delegate callback, MethodInfo callbackMethod);
    private void ValidateCallbackReturnType(MethodInfo callbackMethod, Type expectedReturnType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Moq.MethodExpectation : Expectation {
    private static Expression[] noArguments;
    private static IMatcher[] noArgumentMatchers;
    private LambdaExpression expression;
    public MethodInfo Method;
    public IReadOnlyList`1<Expression> Arguments;
    private IMatcher[] argumentMatchers;
    private IAwaitableFactory awaitableFactory;
    private MethodInfo methodImplementation;
    private Expression[] partiallyEvaluatedArguments;
    private bool exactGenericTypeArguments;
    public LambdaExpression Expression { get; }
    public MethodExpectation(LambdaExpression expression, MethodInfo method, IReadOnlyList`1<Expression> arguments, bool exactGenericTypeArguments, bool skipMatcherInitialization, bool allowNonOverridable);
    private static MethodExpectation();
    public static MethodExpectation CreateFrom(Invocation invocation);
    public virtual LambdaExpression get_Expression();
    public void AddResultExpression(Func`2<Expression, Expression> add, IAwaitableFactory awaitableFactory);
    public virtual bool HasResultExpression(IAwaitableFactory& awaitableFactory);
    public void Deconstruct(LambdaExpression& expression, MethodInfo& method, IReadOnlyList`1& arguments);
    public virtual bool IsMatch(Invocation invocation);
    public virtual void SetupEvaluatedSuccessfully(Invocation invocation);
    private bool IsOverride(Invocation invocation);
    public virtual bool Equals(Expectation obj);
    private static Expression[] PartiallyEvaluateArguments(IReadOnlyList`1<Expression> arguments);
    public virtual int GetHashCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Moq.MethodSetup : Setup {
    public MethodInfo Method { get; }
    protected MethodSetup(Expression originalExpression, Mock mock, MethodExpectation expectation);
    public MethodInfo get_Method();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Moq.Mock : object {
    internal static MethodInfo GetMethod;
    internal static MethodInfo SetupReturnsMethod;
    internal List`1<Type> AdditionalInterfaces { get; }
    public MockBehavior Behavior { get; }
    public bool CallBase { get; public set; }
    internal Object[] ConstructorArguments { get; }
    public DefaultValue DefaultValue { get; public set; }
    internal EventHandlerCollection EventHandlers { get; }
    public object Object { get; }
    internal Type[] InheritedInterfaces { get; }
    internal bool IsObjectInitialized { get; }
    public IInvocationList Invocations { get; }
    internal InvocationCollection MutableInvocations { get; }
    internal Type MockedType { get; }
    public DefaultValueProvider DefaultValueProvider { get; public set; }
    internal SetupCollection MutableSetups { get; }
    public ISetupList Setups { get; }
    public Switches Switches { get; public set; }
    internal Dictionary`2<Type, object> ConfiguredDefaultValues { get; }
    private static Mock();
    private sealed virtual override void Moq.IInterceptor.Intercept(Invocation invocation);
    public static T Of();
    public static T Of(MockBehavior behavior);
    public static T Of(Expression`1<Func`2<T, bool>> predicate);
    public static T Of(Expression`1<Func`2<T, bool>> predicate, MockBehavior behavior);
    public static Mock`1<T> Get(T mocked);
    public static void Verify(Mock[] mocks);
    public static void VerifyAll(Mock[] mocks);
    internal abstract virtual List`1<Type> get_AdditionalInterfaces();
    public abstract virtual MockBehavior get_Behavior();
    public abstract virtual bool get_CallBase();
    public abstract virtual void set_CallBase(bool value);
    internal abstract virtual Object[] get_ConstructorArguments();
    public sealed virtual DefaultValue get_DefaultValue();
    public sealed virtual void set_DefaultValue(DefaultValue value);
    internal abstract virtual EventHandlerCollection get_EventHandlers();
    public object get_Object();
    internal abstract virtual Type[] get_InheritedInterfaces();
    internal abstract virtual bool get_IsObjectInitialized();
    public IInvocationList get_Invocations();
    internal abstract virtual InvocationCollection get_MutableInvocations();
    protected abstract virtual object OnGetObject();
    internal abstract virtual Type get_MockedType();
    public abstract virtual DefaultValueProvider get_DefaultValueProvider();
    public abstract virtual void set_DefaultValueProvider(DefaultValueProvider value);
    internal abstract virtual SetupCollection get_MutableSetups();
    public ISetupList get_Setups();
    public abstract virtual Switches get_Switches();
    public abstract virtual void set_Switches(Switches value);
    public void Verify();
    public void VerifyAll();
    internal void Verify(Func`2<ISetup, bool> predicate, HashSet`1<Mock> verifiedMocks);
    internal static void Verify(Mock mock, LambdaExpression expression, Times times, string failMessage);
    internal static void VerifyGet(Mock mock, LambdaExpression expression, Times times, string failMessage);
    internal static void VerifySet(Mock mock, LambdaExpression expression, Times times, string failMessage);
    internal static void VerifyAdd(Mock mock, LambdaExpression expression, Times times, string failMessage);
    internal static void VerifyRemove(Mock mock, LambdaExpression expression, Times times, string failMessage);
    internal static void VerifyNoOtherCalls(Mock mock);
    private static void VerifyNoOtherCalls(Mock mock, HashSet`1<Mock> verifiedMocks);
    private static int GetMatchingInvocationCount(Mock mock, LambdaExpression expression, List`1& invocationsToBeMarkedAsVerified);
    private static int GetMatchingInvocationCount(Mock mock, ImmutablePopOnlyStack`1& parts, HashSet`1<Mock> visitedInnerMocks, List`1<Pair`2<Invocation, MethodExpectation>> invocationsToBeMarkedAsVerified);
    internal static MethodCall Setup(Mock mock, LambdaExpression expression, Condition condition);
    internal static MethodCall SetupGet(Mock mock, LambdaExpression expression, Condition condition);
    internal static MethodCall SetupSet(Mock mock, LambdaExpression expression, Condition condition);
    internal static bool SetupReturns(Mock mock, LambdaExpression expression, object value);
    internal static MethodCall SetupAdd(Mock mock, LambdaExpression expression, Condition condition);
    internal static MethodCall SetupRemove(Mock mock, LambdaExpression expression, Condition condition);
    internal static SequenceSetup SetupSequence(Mock mock, LambdaExpression expression);
    internal static StubbedPropertySetup SetupProperty(Mock mock, LambdaExpression expression, object initialValue);
    private static TSetup SetupRecursive(Mock mock, LambdaExpression expression, Func`4<Mock, Expression, MethodExpectation, TSetup> setupLast, bool allowNonOverridableLastProperty);
    private static TSetup SetupRecursive(Mock mock, LambdaExpression originalExpression, Stack`1<MethodExpectation> parts, Func`4<Mock, Expression, MethodExpectation, TSetup> setupLast);
    internal static void SetupAllProperties(Mock mock);
    internal static void RaiseEvent(Mock mock, Action`1<T> action, Object[] arguments);
    internal static Task RaiseEventAsync(Mock mock, Action`1<T> action, Object[] arguments);
    internal static object RaiseEvent(Mock mock, LambdaExpression expression, Stack`1<MethodExpectation> parts, Object[] arguments);
    public abstract virtual Mock`1<TInterface> As();
    internal bool ImplementsInterface(Type interfaceType);
    internal abstract virtual Dictionary`2<Type, object> get_ConfiguredDefaultValues();
    public void SetReturnsDefault(TReturn value);
    internal object GetDefaultValue(MethodInfo method, Mock& candidateInnerMock, DefaultValueProvider useAlternateProvider);
    private sealed virtual override Type Moq.IFluentInterface.GetType();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Moq.Mock`1 : Mock {
    private static Type[] inheritedInterfaces;
    private static int serialNumberCounter;
    private T instance;
    private List`1<Type> additionalInterfaces;
    private Dictionary`2<Type, object> configuredDefaultValues;
    private Object[] constructorArguments;
    private DefaultValueProvider defaultValueProvider;
    private EventHandlerCollection eventHandlers;
    private InvocationCollection invocations;
    private string name;
    private SetupCollection setups;
    private MockBehavior behavior;
    private bool callBase;
    private Switches switches;
    public MockBehavior Behavior { get; }
    public bool CallBase { get; public set; }
    internal Object[] ConstructorArguments { get; }
    internal Dictionary`2<Type, object> ConfiguredDefaultValues { get; }
    public DefaultValueProvider DefaultValueProvider { get; public set; }
    internal EventHandlerCollection EventHandlers { get; }
    internal List`1<Type> AdditionalInterfaces { get; }
    internal InvocationCollection MutableInvocations { get; }
    internal bool IsObjectInitialized { get; }
    public T Object { get; }
    public string Name { get; public set; }
    internal Type MockedType { get; }
    internal SetupCollection MutableSetups { get; }
    internal Type[] InheritedInterfaces { get; }
    public Switches Switches { get; public set; }
    private static Mock`1();
    internal Mock`1(bool skipInitialize);
    public Mock`1(Object[] args);
    public Mock`1(MockBehavior behavior);
    public Mock`1(MockBehavior behavior, Object[] args);
    public Mock`1(Expression`1<Func`1<T>> newExpression, MockBehavior behavior);
    private static string CreateUniqueDefaultMockName();
    private void CheckParameters();
    public virtual MockBehavior get_Behavior();
    public virtual bool get_CallBase();
    public virtual void set_CallBase(bool value);
    internal virtual Object[] get_ConstructorArguments();
    internal virtual Dictionary`2<Type, object> get_ConfiguredDefaultValues();
    public virtual DefaultValueProvider get_DefaultValueProvider();
    public virtual void set_DefaultValueProvider(DefaultValueProvider value);
    internal virtual EventHandlerCollection get_EventHandlers();
    internal virtual List`1<Type> get_AdditionalInterfaces();
    internal virtual InvocationCollection get_MutableInvocations();
    internal virtual bool get_IsObjectInitialized();
    public virtual T get_Object();
    public string get_Name();
    public void set_Name(string value);
    public virtual string ToString();
    private void InitializeInstance();
    protected virtual object OnGetObject();
    internal virtual Type get_MockedType();
    internal virtual SetupCollection get_MutableSetups();
    internal virtual Type[] get_InheritedInterfaces();
    public virtual Switches get_Switches();
    public virtual void set_Switches(Switches value);
    public virtual Mock`1<TInterface> As();
    public ISetup`1<T> Setup(Expression`1<Action`1<T>> expression);
    public ISetup`2<T, TResult> Setup(Expression`1<Func`2<T, TResult>> expression);
    public ISetupGetter`2<T, TProperty> SetupGet(Expression`1<Func`2<T, TProperty>> expression);
    public ISetupSetter`2<T, TProperty> SetupSet(Action`1<T> setterExpression);
    public ISetup`1<T> SetupSet(Action`1<T> setterExpression);
    public ISetup`1<T> SetupAdd(Action`1<T> addExpression);
    public ISetup`1<T> SetupRemove(Action`1<T> removeExpression);
    public Mock`1<T> SetupProperty(Expression`1<Func`2<T, TProperty>> property);
    public Mock`1<T> SetupProperty(Expression`1<Func`2<T, TProperty>> property, TProperty initialValue);
    public Mock`1<T> SetupAllProperties();
    public ISetupSequentialResult`1<TResult> SetupSequence(Expression`1<Func`2<T, TResult>> expression);
    public ISetupSequentialAction SetupSequence(Expression`1<Action`1<T>> expression);
    public ISetupConditionResult`1<T> When(Func`1<bool> condition);
    public void Verify(Expression`1<Action`1<T>> expression);
    public void Verify(Expression`1<Action`1<T>> expression, Times times);
    public void Verify(Expression`1<Action`1<T>> expression, Func`1<Times> times);
    public void Verify(Expression`1<Action`1<T>> expression, string failMessage);
    public void Verify(Expression`1<Action`1<T>> expression, Times times, string failMessage);
    public void Verify(Expression`1<Action`1<T>> expression, Func`1<Times> times, string failMessage);
    public void Verify(Expression`1<Func`2<T, TResult>> expression);
    public void Verify(Expression`1<Func`2<T, TResult>> expression, Times times);
    public void Verify(Expression`1<Func`2<T, TResult>> expression, Func`1<Times> times);
    public void Verify(Expression`1<Func`2<T, TResult>> expression, Func`1<Times> times, string failMessage);
    public void Verify(Expression`1<Func`2<T, TResult>> expression, string failMessage);
    public void Verify(Expression`1<Func`2<T, TResult>> expression, Times times, string failMessage);
    public void VerifyGet(Expression`1<Func`2<T, TProperty>> expression);
    public void VerifyGet(Expression`1<Func`2<T, TProperty>> expression, Times times);
    public void VerifyGet(Expression`1<Func`2<T, TProperty>> expression, Func`1<Times> times);
    public void VerifyGet(Expression`1<Func`2<T, TProperty>> expression, string failMessage);
    public void VerifyGet(Expression`1<Func`2<T, TProperty>> expression, Times times, string failMessage);
    public void VerifyGet(Expression`1<Func`2<T, TProperty>> expression, Func`1<Times> times, string failMessage);
    public void VerifySet(Action`1<T> setterExpression);
    public void VerifySet(Action`1<T> setterExpression, Times times);
    public void VerifySet(Action`1<T> setterExpression, Func`1<Times> times);
    public void VerifySet(Action`1<T> setterExpression, string failMessage);
    public void VerifySet(Action`1<T> setterExpression, Times times, string failMessage);
    public void VerifySet(Action`1<T> setterExpression, Func`1<Times> times, string failMessage);
    public void VerifyAdd(Action`1<T> addExpression);
    public void VerifyAdd(Action`1<T> addExpression, Times times);
    public void VerifyAdd(Action`1<T> addExpression, Func`1<Times> times);
    public void VerifyAdd(Action`1<T> addExpression, string failMessage);
    public void VerifyAdd(Action`1<T> addExpression, Times times, string failMessage);
    public void VerifyAdd(Action`1<T> addExpression, Func`1<Times> times, string failMessage);
    public void VerifyRemove(Action`1<T> removeExpression);
    public void VerifyRemove(Action`1<T> removeExpression, Times times);
    public void VerifyRemove(Action`1<T> removeExpression, Func`1<Times> times);
    public void VerifyRemove(Action`1<T> removeExpression, string failMessage);
    public void VerifyRemove(Action`1<T> removeExpression, Times times, string failMessage);
    public void VerifyRemove(Action`1<T> removeExpression, Func`1<Times> times, string failMessage);
    public void VerifyNoOtherCalls();
    public void Raise(Action`1<T> eventExpression, EventArgs args);
    public void Raise(Action`1<T> eventExpression, Object[] args);
    public Task RaiseAsync(Action`1<T> eventExpression, Object[] args);
    [ObsoleteAttribute("Expect has been renamed to Setup.", "False")]
[EditorBrowsableAttribute("1")]
public ISetup`1<T> Expect(Expression`1<Action`1<T>> expression);
    [ObsoleteAttribute("Expect has been renamed to Setup.", "False")]
[EditorBrowsableAttribute("1")]
public ISetup`2<T, TResult> Expect(Expression`1<Func`2<T, TResult>> expression);
    [ObsoleteAttribute("ExpectGet has been renamed to SetupGet.", "False")]
[EditorBrowsableAttribute("1")]
public ISetupGetter`2<T, TProperty> ExpectGet(Expression`1<Func`2<T, TProperty>> expression);
    [ObsoleteAttribute("ExpectSet has been renamed to SetupSet.", "False")]
[EditorBrowsableAttribute("1")]
public ISetupSetter`2<T, TProperty> ExpectSet(Expression`1<Func`2<T, TProperty>> expression);
    [ObsoleteAttribute("ExpectSet has been renamed to SetupSet, and the new syntax allows you to pass the value in the expression itself, like f => f.Value = 25.", "True")]
[EditorBrowsableAttribute("1")]
public ISetupSetter`2<T, TProperty> ExpectSet(Expression`1<Func`2<T, TProperty>> expression, TProperty value);
}
public enum Moq.MockBehavior : Enum {
    public int value__;
    public static MockBehavior Strict;
    public static MockBehavior Loose;
    public static MockBehavior Default;
}
internal class Moq.MockDefaultValueProvider : LookupOrFallbackDefaultValueProvider {
    internal DefaultValue Kind { get; }
    internal virtual DefaultValue get_Kind();
    [NullableContextAttribute("1")]
protected virtual object GetFallbackDefaultValue(Type type, Mock mock);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Moq.MockException : Exception {
    private MockExceptionReasons reasons;
    internal MockExceptionReasons Reasons { get; }
    public bool IsVerificationError { get; }
    private MockException(MockExceptionReasons reasons, string message);
    protected MockException(SerializationInfo info, StreamingContext context);
    internal static MockException IncorrectNumberOfCalls(MethodCall setup, Times times, int invocationCount);
    internal static MockException NoMatchingCalls(Mock rootMock, LambdaExpression expression, string failMessage, Times times, int callCount);
    internal static MockException NoSetup(Invocation invocation);
    internal static MockException ReturnValueRequired(Invocation invocation);
    internal static MockException UnmatchedSetup(Setup setup);
    internal static MockException FromInnerMockOf(ISetup setup, MockException error);
    internal static MockException Combined(IEnumerable`1<MockException> errors, string preamble);
    internal static MockException UnverifiedInvocations(Mock mock, IEnumerable`1<Invocation> invocations);
    internal MockExceptionReasons get_Reasons();
    public bool get_IsVerificationError();
    [SecurityCriticalAttribute]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
[FlagsAttribute]
internal enum Moq.MockExceptionReasons : Enum {
    public int value__;
    public static MockExceptionReasons IncorrectNumberOfCalls;
    public static MockExceptionReasons NoMatchingCalls;
    public static MockExceptionReasons NoSetup;
    public static MockExceptionReasons ReturnValueRequired;
    public static MockExceptionReasons UnmatchedSetup;
    public static MockExceptionReasons UnverifiedInvocations;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static class Moq.MockExtensions : object {
    [ExtensionAttribute]
public static void Reset(Mock mock);
    [ExtensionAttribute]
[ObsoleteAttribute("Use `mock.Invocations.Clear()` instead.")]
[EditorBrowsableAttribute("1")]
public static void ResetCalls(Mock mock);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This class has been renamed to MockRepository. MockFactory will be retired in v5.", "False")]
public class Moq.MockFactory : object {
    private List`1<Mock> mocks;
    private MockBehavior defaultBehavior;
    private DefaultValueProvider defaultValueProvider;
    private Switches switches;
    [CompilerGeneratedAttribute]
private bool <CallBase>k__BackingField;
    internal MockBehavior Behavior { get; }
    public bool CallBase { get; public set; }
    public DefaultValue DefaultValue { get; public set; }
    public DefaultValueProvider DefaultValueProvider { get; public set; }
    protected internal IEnumerable`1<Mock> Mocks { get; }
    public Switches Switches { get; public set; }
    public MockFactory(MockBehavior defaultBehavior);
    internal MockBehavior get_Behavior();
    [CompilerGeneratedAttribute]
public bool get_CallBase();
    [CompilerGeneratedAttribute]
public void set_CallBase(bool value);
    public DefaultValue get_DefaultValue();
    public void set_DefaultValue(DefaultValue value);
    public DefaultValueProvider get_DefaultValueProvider();
    public void set_DefaultValueProvider(DefaultValueProvider value);
    protected internal IEnumerable`1<Mock> get_Mocks();
    public Switches get_Switches();
    public void set_Switches(Switches value);
    public Mock`1<T> Create();
    public Mock`1<T> Create(Object[] args);
    public Mock`1<T> Create(MockBehavior behavior);
    public Mock`1<T> Create(MockBehavior behavior, Object[] args);
    public Mock`1<T> Create(Expression`1<Func`1<T>> newExpression, MockBehavior behavior);
    protected virtual Mock`1<T> CreateMock(MockBehavior behavior, Object[] args);
    public virtual void Verify();
    public virtual void VerifyAll();
    public void VerifyNoOtherCalls();
    protected virtual void VerifyMocks(Action`1<Mock> verifyAction);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static class Moq.MockLegacyExtensions : object {
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
[ObsoleteAttribute("The new syntax allows you to pass the value in the expression itself, like f => f.Value = 25.", "True")]
public static ISetupSetter`2<T, TProperty> SetupSet(Mock`1<T> mock, Expression`1<Func`2<T, TProperty>> expression, TProperty value);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use the new syntax, which allows you to pass the value in the expression itself, mock.VerifySet(m => m.Value = 25);", "True")]
public static void VerifySet(Mock`1<T> mock, Expression`1<Func`2<T, TProperty>> expression, TProperty value);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use the new syntax, which allows you to pass the value in the expression itself, mock.VerifySet(m => m.Value = 25, failMessage);", "True")]
public static void VerifySet(Mock`1<T> mock, Expression`1<Func`2<T, TProperty>> expression, TProperty value, string failMessage);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Moq.MockRepository : MockFactory {
    public MockRepository(MockBehavior defaultBehavior);
    public IQueryable`1<T> Of();
    public IQueryable`1<T> Of(MockBehavior behavior);
    public IQueryable`1<T> Of(Expression`1<Func`2<T, bool>> specification);
    public IQueryable`1<T> Of(Expression`1<Func`2<T, bool>> specification, MockBehavior behavior);
    [EditorBrowsableAttribute("1")]
public T OneOf();
    [EditorBrowsableAttribute("1")]
public T OneOf(MockBehavior behavior);
    [EditorBrowsableAttribute("1")]
public T OneOf(Expression`1<Func`2<T, bool>> specification);
    [EditorBrowsableAttribute("1")]
public T OneOf(Expression`1<Func`2<T, bool>> specification, MockBehavior behavior);
    internal IQueryable`1<T> CreateMockQuery(MockBehavior behavior);
    internal IQueryable`1<T> CreateQueryable(MockBehavior behavior);
    [IteratorStateMachineAttribute("Moq.MockRepository/<CreateMocks>d__10`1")]
private IEnumerable`1<T> CreateMocks(MockBehavior behavior);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class Moq.Mocks : object {
    public static IQueryable`1<T> Of();
    public static IQueryable`1<T> Of(MockBehavior behavior);
    public static IQueryable`1<T> Of(Expression`1<Func`2<T, bool>> specification);
    public static IQueryable`1<T> Of(Expression`1<Func`2<T, bool>> specification, MockBehavior behavior);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Moved to Mock.Of<T>, as it's a single one, so no reason to be on Mocks.", "True")]
public static T OneOf();
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Moved to Mock.Of<T>, as it's a single one, so no reason to be on Mocks.", "True")]
public static T OneOf(Expression`1<Func`2<T, bool>> specification);
    internal static IQueryable`1<T> CreateMockQuery(MockBehavior behavior);
    internal static IQueryable`1<T> CreateQueryable(MockBehavior behavior);
    [IteratorStateMachineAttribute("Moq.Mocks/<CreateMocks>d__8`1")]
private static IEnumerable`1<T> CreateMocks(MockBehavior behavior);
}
public class Moq.MockSequence : object {
    private int sequenceStep;
    private int sequenceLength;
    [CompilerGeneratedAttribute]
private bool <Cyclic>k__BackingField;
    public bool Cyclic { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_Cyclic();
    [CompilerGeneratedAttribute]
public void set_Cyclic(bool value);
    private void NextStep();
    [NullableContextAttribute("1")]
internal ISetupConditionResult`1<TMock> For(Mock`1<TMock> mock);
}
[ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static class Moq.MockSequenceHelper : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static ISetupConditionResult`1<TMock> InSequence(Mock`1<TMock> mock, MockSequence sequence);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static class Moq.ObsoleteMockExtensions : object {
    [ExtensionAttribute]
[ObsoleteAttribute("Replaced by SetupSet(Action)")]
public static ISetupSetter`2<T, TProperty> SetupSet(Mock`1<T> mock, Expression`1<Func`2<T, TProperty>> expression);
    [ExtensionAttribute]
[ObsoleteAttribute("Replaced by VerifySet(Action)")]
public static void VerifySet(Mock`1<T> mock, Expression`1<Func`2<T, TProperty>> expression);
    [ExtensionAttribute]
[ObsoleteAttribute("Replaced by  VerifySet(Action, string)")]
public static void VerifySet(Mock`1<T> mock, Expression`1<Func`2<T, TProperty>> expression, string failMessage);
    [ExtensionAttribute]
[ObsoleteAttribute("Replaced by  VerifySet(Action, Times)")]
public static void VerifySet(Mock`1<T> mock, Expression`1<Func`2<T, TProperty>> expression, Times times);
    [ExtensionAttribute]
[ObsoleteAttribute("Replaced by  VerifySet(Action, Times, string)")]
public static void VerifySet(Mock`1<T> mock, Expression`1<Func`2<T, TProperty>> expression, Times times, string failMessage);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Moq.Pair`2 : ValueType {
    public T1 Item1;
    public T2 Item2;
    public Pair`2(T1 item1, T2 item2);
    public void Deconstruct(T1& item1, T2& item2);
    public sealed virtual bool Equals(Pair`2<T1, T2> other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
internal class Moq.ParameterTypes : ValueType {
    private ParameterInfo[] parameters;
    public Type Item { get; }
    public int Count { get; }
    public ParameterTypes(ParameterInfo[] parameters);
    public sealed virtual Type get_Item(int index);
    public sealed virtual int get_Count();
    [IteratorStateMachineAttribute("Moq.ParameterTypes/<GetEnumerator>d__6")]
public sealed virtual IEnumerator`1<Type> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "17.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class Moq.Properties.Resources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string AlreadyInitialized { get; }
    internal static string ArgumentCannotBeEmpty { get; }
    internal static string ArgumentMatcherWillNeverMatch { get; }
    internal static string AsMustBeInterface { get; }
    internal static string CallBaseCannotBeUsedWithDelegateMocks { get; }
    internal static string CantSetReturnValueForVoid { get; }
    internal static string ConstructorArgsForDelegate { get; }
    internal static string ConstructorArgsForInterface { get; }
    internal static string ConstructorNotFound { get; }
    internal static string DelaysMustBeGreaterThanZero { get; }
    internal static string FieldsNotSupported { get; }
    internal static string InvalidCallbackNotADelegateWithReturnTypeVoid { get; }
    internal static string InvalidCallbackParameterCountMismatch { get; }
    internal static string InvalidCallbackParameterMismatch { get; }
    internal static string InvalidCallbackReturnTypeMismatch { get; }
    internal static string InvalidMockGetType { get; }
    internal static string InvalidReturnsCallbackNotADelegateWithReturnType { get; }
    internal static string LastMemberHasNonInterceptableReturnType { get; }
    internal static string LinqBinaryOperatorNotSupported { get; }
    internal static string LinqMethodNotSupported { get; }
    internal static string LinqMethodNotVirtual { get; }
    internal static string MatcherAssignmentFailedDuringExpressionReconstruction { get; }
    internal static string MemberMissing { get; }
    internal static string MethodIsPublic { get; }
    internal static string MethodMissing { get; }
    internal static string MethodNotVisibleToProxyFactory { get; }
    internal static string MinDelayMustBeLessThanMaxDelay { get; }
    internal static string MockExceptionMessage { get; }
    internal static string NextMemberNonInterceptable { get; }
    internal static string NoConstructorCallFound { get; }
    internal static string NoInvocationsPerformed { get; }
    internal static string NoMatchingCallsAtLeast { get; }
    internal static string NoMatchingCallsAtLeastOnce { get; }
    internal static string NoMatchingCallsAtMost { get; }
    internal static string NoMatchingCallsAtMostOnce { get; }
    internal static string NoMatchingCallsBetweenExclusive { get; }
    internal static string NoMatchingCallsBetweenInclusive { get; }
    internal static string NoMatchingCallsExactly { get; }
    internal static string NoMatchingCallsNever { get; }
    internal static string NoMatchingCallsOnce { get; }
    internal static string NoSetup { get; }
    internal static string ObjectInstanceNotMock { get; }
    internal static string OutExpressionMustBeConstantValue { get; }
    internal static string PerformedInvocations { get; }
    internal static string PropertyGetNotFound { get; }
    internal static string PropertySetNotFound { get; }
    internal static string ProtectedMemberNotFound { get; }
    internal static string RefExpressionMustBeConstantValue { get; }
    internal static string ReturnValueRequired { get; }
    internal static string SetupNotEventAdd { get; }
    internal static string SetupNotEventRemove { get; }
    internal static string SetupNotProperty { get; }
    internal static string SetupNotSetter { get; }
    internal static string TypeHasNoDefaultConstructor { get; }
    internal static string TypeMatchersMayNotBeUsedWithCallbacks { get; }
    internal static string TypeNotImplementInterface { get; }
    internal static string TypeNotMockable { get; }
    internal static string UnexpectedPublicProperty { get; }
    internal static string UnexpectedTranslationOfMemberAccess { get; }
    internal static string UnhandledBindingType { get; }
    internal static string UnhandledExpressionType { get; }
    internal static string UnmatchedSetup { get; }
    internal static string UnsupportedExpression { get; }
    internal static string UnsupportedExpressionWithHint { get; }
    internal static string UnsupportedExtensionMethod { get; }
    internal static string UnsupportedMember { get; }
    internal static string UnsupportedNonOverridableMember { get; }
    internal static string UnsupportedStaticMember { get; }
    internal static string UnverifiedInvocations { get; }
    internal static string UseItExprIsNullRatherThanNullArgumentValue { get; }
    internal static string UseItIsOtherOverload { get; }
    internal static string VerificationErrorsOfInnerMock { get; }
    internal static string VerificationErrorsOfMock { get; }
    internal static string VerificationErrorsOfMockRepository { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_AlreadyInitialized();
    internal static string get_ArgumentCannotBeEmpty();
    internal static string get_ArgumentMatcherWillNeverMatch();
    internal static string get_AsMustBeInterface();
    internal static string get_CallBaseCannotBeUsedWithDelegateMocks();
    internal static string get_CantSetReturnValueForVoid();
    internal static string get_ConstructorArgsForDelegate();
    internal static string get_ConstructorArgsForInterface();
    internal static string get_ConstructorNotFound();
    internal static string get_DelaysMustBeGreaterThanZero();
    internal static string get_FieldsNotSupported();
    internal static string get_InvalidCallbackNotADelegateWithReturnTypeVoid();
    internal static string get_InvalidCallbackParameterCountMismatch();
    internal static string get_InvalidCallbackParameterMismatch();
    internal static string get_InvalidCallbackReturnTypeMismatch();
    internal static string get_InvalidMockGetType();
    internal static string get_InvalidReturnsCallbackNotADelegateWithReturnType();
    internal static string get_LastMemberHasNonInterceptableReturnType();
    internal static string get_LinqBinaryOperatorNotSupported();
    internal static string get_LinqMethodNotSupported();
    internal static string get_LinqMethodNotVirtual();
    internal static string get_MatcherAssignmentFailedDuringExpressionReconstruction();
    internal static string get_MemberMissing();
    internal static string get_MethodIsPublic();
    internal static string get_MethodMissing();
    internal static string get_MethodNotVisibleToProxyFactory();
    internal static string get_MinDelayMustBeLessThanMaxDelay();
    internal static string get_MockExceptionMessage();
    internal static string get_NextMemberNonInterceptable();
    internal static string get_NoConstructorCallFound();
    internal static string get_NoInvocationsPerformed();
    internal static string get_NoMatchingCallsAtLeast();
    internal static string get_NoMatchingCallsAtLeastOnce();
    internal static string get_NoMatchingCallsAtMost();
    internal static string get_NoMatchingCallsAtMostOnce();
    internal static string get_NoMatchingCallsBetweenExclusive();
    internal static string get_NoMatchingCallsBetweenInclusive();
    internal static string get_NoMatchingCallsExactly();
    internal static string get_NoMatchingCallsNever();
    internal static string get_NoMatchingCallsOnce();
    internal static string get_NoSetup();
    internal static string get_ObjectInstanceNotMock();
    internal static string get_OutExpressionMustBeConstantValue();
    internal static string get_PerformedInvocations();
    internal static string get_PropertyGetNotFound();
    internal static string get_PropertySetNotFound();
    internal static string get_ProtectedMemberNotFound();
    internal static string get_RefExpressionMustBeConstantValue();
    internal static string get_ReturnValueRequired();
    internal static string get_SetupNotEventAdd();
    internal static string get_SetupNotEventRemove();
    internal static string get_SetupNotProperty();
    internal static string get_SetupNotSetter();
    internal static string get_TypeHasNoDefaultConstructor();
    internal static string get_TypeMatchersMayNotBeUsedWithCallbacks();
    internal static string get_TypeNotImplementInterface();
    internal static string get_TypeNotMockable();
    internal static string get_UnexpectedPublicProperty();
    internal static string get_UnexpectedTranslationOfMemberAccess();
    internal static string get_UnhandledBindingType();
    internal static string get_UnhandledExpressionType();
    internal static string get_UnmatchedSetup();
    internal static string get_UnsupportedExpression();
    internal static string get_UnsupportedExpressionWithHint();
    internal static string get_UnsupportedExtensionMethod();
    internal static string get_UnsupportedMember();
    internal static string get_UnsupportedNonOverridableMember();
    internal static string get_UnsupportedStaticMember();
    internal static string get_UnverifiedInvocations();
    internal static string get_UseItExprIsNullRatherThanNullArgumentValue();
    internal static string get_UseItIsOtherOverload();
    internal static string get_VerificationErrorsOfInnerMock();
    internal static string get_VerificationErrorsOfMock();
    internal static string get_VerificationErrorsOfMockRepository();
}
[NullableContextAttribute("1")]
[EditorBrowsableAttribute("1")]
public interface Moq.Protected.IProtectedAsMock`2 {
    public abstract virtual ISetup`1<T> Setup(Expression`1<Action`1<TAnalog>> expression);
    public abstract virtual ISetup`2<T, TResult> Setup(Expression`1<Func`2<TAnalog, TResult>> expression);
    public abstract virtual ISetupSetter`2<T, TProperty> SetupSet(Action`1<TAnalog> setterExpression);
    public abstract virtual ISetup`1<T> SetupSet(Action`1<TAnalog> setterExpression);
    public abstract virtual ISetupGetter`2<T, TProperty> SetupGet(Expression`1<Func`2<TAnalog, TProperty>> expression);
    public abstract virtual Mock`1<T> SetupProperty(Expression`1<Func`2<TAnalog, TProperty>> expression, TProperty initialValue);
    public abstract virtual ISetupSequentialResult`1<TResult> SetupSequence(Expression`1<Func`2<TAnalog, TResult>> expression);
    public abstract virtual ISetupSequentialAction SetupSequence(Expression`1<Action`1<TAnalog>> expression);
    public abstract virtual void Verify(Expression`1<Action`1<TAnalog>> expression, Nullable`1<Times> times, string failMessage);
    public abstract virtual void Verify(Expression`1<Func`2<TAnalog, TResult>> expression, Nullable`1<Times> times, string failMessage);
    public abstract virtual void VerifySet(Action`1<TAnalog> setterExpression, Nullable`1<Times> times, string failMessage);
    public abstract virtual void VerifyGet(Expression`1<Func`2<TAnalog, TProperty>> expression, Nullable`1<Times> times, string failMessage);
}
[NullableContextAttribute("1")]
[EditorBrowsableAttribute("1")]
public interface Moq.Protected.IProtectedMock`1 {
    public abstract virtual IProtectedAsMock`2<TMock, TAnalog> As();
    public abstract virtual ISetup`1<TMock> Setup(string voidMethodName, Object[] args);
    public abstract virtual ISetup`1<TMock> Setup(string voidMethodName, bool exactParameterMatch, Object[] args);
    public abstract virtual ISetup`1<TMock> Setup(string voidMethodName, Type[] genericTypeArguments, bool exactParameterMatch, Object[] args);
    public abstract virtual ISetup`2<TMock, TResult> Setup(string methodOrPropertyName, Object[] args);
    public abstract virtual ISetup`2<TMock, TResult> Setup(string methodOrPropertyName, bool exactParameterMatch, Object[] args);
    public abstract virtual ISetup`2<TMock, TResult> Setup(string methodOrPropertyName, Type[] genericTypeArguments, bool exactParameterMatch, Object[] args);
    public abstract virtual ISetupGetter`2<TMock, TProperty> SetupGet(string propertyName);
    public abstract virtual ISetupSetter`2<TMock, TProperty> SetupSet(string propertyName, object value);
    public abstract virtual ISetupSequentialAction SetupSequence(string methodOrPropertyName, Object[] args);
    public abstract virtual ISetupSequentialAction SetupSequence(string methodOrPropertyName, bool exactParameterMatch, Object[] args);
    public abstract virtual ISetupSequentialAction SetupSequence(string methodOrPropertyName, Type[] genericTypeArguments, bool exactParameterMatch, Object[] args);
    public abstract virtual ISetupSequentialResult`1<TResult> SetupSequence(string methodOrPropertyName, Object[] args);
    public abstract virtual ISetupSequentialResult`1<TResult> SetupSequence(string methodOrPropertyName, bool exactParameterMatch, Object[] args);
    public abstract virtual ISetupSequentialResult`1<TResult> SetupSequence(string methodOrPropertyName, Type[] genericTypeArguments, bool exactParameterMatch, Object[] args);
    public abstract virtual void Verify(string methodName, Times times, Object[] args);
    public abstract virtual void Verify(string methodName, Type[] genericTypeArguments, Times times, Object[] args);
    public abstract virtual void Verify(string methodName, Times times, bool exactParameterMatch, Object[] args);
    public abstract virtual void Verify(string methodName, Type[] genericTypeArguments, Times times, bool exactParameterMatch, Object[] args);
    public abstract virtual void Verify(string methodName, Times times, Object[] args);
    public abstract virtual void Verify(string methodName, Type[] genericTypeArguments, Times times, Object[] args);
    public abstract virtual void Verify(string methodName, Times times, bool exactParameterMatch, Object[] args);
    public abstract virtual void Verify(string methodName, Type[] genericTypeArguments, Times times, bool exactParameterMatch, Object[] args);
    public abstract virtual void VerifyGet(string propertyName, Times times);
    public abstract virtual void VerifySet(string propertyName, Times times, object value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class Moq.Protected.ItExpr : object {
    public static Expression IsNull();
    public static Expression IsAny();
    public static Expression Is(Expression`1<Func`2<TValue, bool>> match);
    public static Expression IsInRange(TValue from, TValue to, Range rangeKind);
    public static Expression IsRegex(string regex);
    public static Expression IsRegex(string regex, RegexOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Moq.Protected.ProtectedAsMock`2 : object {
    private Mock`1<T> mock;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static DuckReplacer<T, TAnalog> DuckReplacerInstance;
    public ProtectedAsMock`2(Mock`1<T> mock);
    private static ProtectedAsMock`2();
    public sealed virtual ISetup`1<T> Setup(Expression`1<Action`1<TAnalog>> expression);
    public sealed virtual ISetup`2<T, TResult> Setup(Expression`1<Func`2<TAnalog, TResult>> expression);
    public sealed virtual ISetupSetter`2<T, TProperty> SetupSet(Action`1<TAnalog> setterExpression);
    public sealed virtual ISetup`1<T> SetupSet(Action`1<TAnalog> setterExpression);
    public sealed virtual ISetupGetter`2<T, TProperty> SetupGet(Expression`1<Func`2<TAnalog, TProperty>> expression);
    public sealed virtual Mock`1<T> SetupProperty(Expression`1<Func`2<TAnalog, TProperty>> expression, TProperty initialValue);
    public sealed virtual ISetupSequentialResult`1<TResult> SetupSequence(Expression`1<Func`2<TAnalog, TResult>> expression);
    public sealed virtual ISetupSequentialAction SetupSequence(Expression`1<Action`1<TAnalog>> expression);
    public sealed virtual void Verify(Expression`1<Action`1<TAnalog>> expression, Nullable`1<Times> times, string failMessage);
    public sealed virtual void Verify(Expression`1<Func`2<TAnalog, TResult>> expression, Nullable`1<Times> times, string failMessage);
    public sealed virtual void VerifySet(Action`1<TAnalog> setterExpression, Nullable`1<Times> times, string failMessage);
    public sealed virtual void VerifyGet(Expression`1<Func`2<TAnalog, TProperty>> expression, Nullable`1<Times> times, string failMessage);
    private LambdaExpression ReconstructAndReplaceSetter(Action`1<TAnalog> setterExpression);
    private static LambdaExpression ReplaceDuck(LambdaExpression expression);
    private sealed virtual override Type Moq.IFluentInterface.GetType();
}
[ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static class Moq.Protected.ProtectedExtension : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static IProtectedMock`1<T> Protected(Mock`1<T> mock);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Moq.Protected.ProtectedMock`1 : object {
    private Mock`1<T> mock;
    public ProtectedMock`1(Mock`1<T> mock);
    public sealed virtual IProtectedAsMock`2<T, TAnalog> As();
    public sealed virtual ISetup`1<T> Setup(string methodName, Object[] args);
    public sealed virtual ISetup`1<T> Setup(string methodName, bool exactParameterMatch, Object[] args);
    public sealed virtual ISetup`1<T> Setup(string methodName, Type[] genericTypeArguments, bool exactParameterMatch, Object[] args);
    private ISetup`1<T> InternalSetup(string methodName, Type[] genericTypeArguments, bool exactParameterMatch, Object[] args);
    public sealed virtual ISetup`2<T, TResult> Setup(string methodName, Object[] args);
    public sealed virtual ISetup`2<T, TResult> Setup(string methodName, bool exactParameterMatch, Object[] args);
    public sealed virtual ISetup`2<T, TResult> Setup(string methodName, Type[] genericTypeArguments, bool exactParameterMatch, Object[] args);
    private ISetup`2<T, TResult> InternalSetup(string methodName, Type[] genericTypeArguments, bool exactParameterMatch, Object[] args);
    public sealed virtual ISetupGetter`2<T, TProperty> SetupGet(string propertyName);
    public sealed virtual ISetupSetter`2<T, TProperty> SetupSet(string propertyName, object value);
    public sealed virtual ISetupSequentialAction SetupSequence(string methodOrPropertyName, Object[] args);
    public sealed virtual ISetupSequentialAction SetupSequence(string methodOrPropertyName, bool exactParameterMatch, Object[] args);
    public sealed virtual ISetupSequentialAction SetupSequence(string methodOrPropertyName, Type[] genericTypeArguments, bool exactParameterMatch, Object[] args);
    private ISetupSequentialAction InternalSetupSequence(string methodOrPropertyName, Type[] genericTypeArguments, bool exactParameterMatch, Object[] args);
    public sealed virtual ISetupSequentialResult`1<TResult> SetupSequence(string methodOrPropertyName, Object[] args);
    public sealed virtual ISetupSequentialResult`1<TResult> SetupSequence(string methodOrPropertyName, bool exactParameterMatch, Object[] args);
    public sealed virtual ISetupSequentialResult`1<TResult> SetupSequence(string methodOrPropertyName, Type[] genericTypeArguments, bool exactParameterMatch, Object[] args);
    private ISetupSequentialResult`1<TResult> InternalSetupSequence(string methodOrPropertyName, Type[] genericTypeArguments, bool exactParameterMatch, Object[] args);
    public sealed virtual void Verify(string methodName, Times times, Object[] args);
    public sealed virtual void Verify(string methodName, Type[] genericTypeArguments, Times times, Object[] args);
    public sealed virtual void Verify(string methodName, Times times, bool exactParameterMatch, Object[] args);
    public sealed virtual void Verify(string methodName, Type[] genericTypeArguments, Times times, bool exactParameterMatch, Object[] args);
    private void InternalVerify(string methodName, Type[] genericTypeArguments, Times times, bool exactParameterMatch, Object[] args);
    public sealed virtual void Verify(string methodName, Times times, Object[] args);
    public sealed virtual void Verify(string methodName, Type[] genericTypeArguments, Times times, Object[] args);
    public sealed virtual void Verify(string methodName, Times times, bool exactParameterMatch, Object[] args);
    public sealed virtual void Verify(string methodName, Type[] genericTypeArguments, Times times, bool exactParameterMatch, Object[] args);
    private void InternalVerify(string methodName, Type[] genericTypeArguments, Times times, bool exactParameterMatch, Object[] args);
    public sealed virtual void VerifyGet(string propertyName, Times times);
    public sealed virtual void VerifySet(string propertyName, Times times, object value);
    private static Expression`1<Func`2<T, TResult>> GetMemberAccess(PropertyInfo property);
    private static MethodInfo GetMethod(string methodName, Type[] genericTypeArguments, bool exact, Object[] args);
    private static Expression`1<Func`2<T, TResult>> GetMethodCall(MethodInfo method, Object[] args);
    private static Expression`1<Action`1<T>> GetMethodCall(MethodInfo method, Object[] args);
    private static PropertyInfo GetProperty(string propertyName);
    private static Expression`1<Action`1<T>> GetSetterExpression(PropertyInfo property, Expression value);
    private static void ThrowIfMemberMissing(string memberName, MemberInfo member);
    private static void ThrowIfMethodMissing(string methodName, MethodInfo method, Object[] args);
    private static void ThrowIfPublicMethod(MethodInfo method, string reflectedTypeName);
    private static void ThrowIfPublicGetter(PropertyInfo property, string reflectedTypeName);
    private static void ThrowIfPublicSetter(PropertyInfo property, string reflectedTypeName);
    private static void ThrowIfVoidMethod(MethodInfo method);
    private static Type[] ToArgTypes(Object[] args);
    private static bool IsItRefAny(Expression expression);
    private static FieldInfo ItRefAnyField(Expression expr);
    private static Expression ToExpressionArg(Type type, object arg);
    [IteratorStateMachineAttribute("Moq.Protected.ProtectedMock`1/<ToExpressionArgs>d__49")]
private static IEnumerable`1<Expression> ToExpressionArgs(MethodInfo method, Object[] args);
    private sealed virtual override Type Moq.IFluentInterface.GetType();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Moq.ProxyFactory : object {
    [CompilerGeneratedAttribute]
private static ProxyFactory <Instance>k__BackingField;
    public static ProxyFactory Instance { get; }
    private static ProxyFactory();
    [CompilerGeneratedAttribute]
public static ProxyFactory get_Instance();
    public abstract virtual object CreateProxy(Type mockType, IInterceptor interceptor, Type[] interfaces, Object[] arguments);
    public abstract virtual bool IsMethodVisible(MethodInfo method, String& messageIfNotVisible);
    public abstract virtual bool IsTypeVisible(Type type);
}
public enum Moq.Range : Enum {
    public int value__;
    public static Range Inclusive;
    public static Range Exclusive;
}
internal static class Moq.RecordInvocation : object {
    [NullableContextAttribute("1")]
public static void Handle(Invocation invocation, Mock mock);
}
internal static class Moq.Return : object {
    [NullableContextAttribute("1")]
public static void Handle(Invocation invocation, Mock mock);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static class Moq.ReturnsExtensions : object {
    private static Random Random;
    private static ReturnsExtensions();
    [ExtensionAttribute]
public static IReturnsResult`1<TMock> ReturnsAsync(IReturns`2<TMock, Task`1<TResult>> mock, TResult value);
    [ExtensionAttribute]
public static IReturnsResult`1<TMock> ReturnsAsync(IReturns`2<TMock, ValueTask`1<TResult>> mock, TResult value);
    [ExtensionAttribute]
public static IReturnsResult`1<TMock> ReturnsAsync(IReturns`2<TMock, Task`1<TResult>> mock, Func`1<TResult> valueFunction);
    [ExtensionAttribute]
public static IReturnsResult`1<TMock> ReturnsAsync(IReturns`2<TMock, ValueTask`1<TResult>> mock, Func`1<TResult> valueFunction);
    [ExtensionAttribute]
public static IReturnsResult`1<TMock> ThrowsAsync(IReturns`2<TMock, Task> mock, Exception exception);
    [ExtensionAttribute]
public static IReturnsResult`1<TMock> ThrowsAsync(IReturns`2<TMock, ValueTask> mock, Exception exception);
    [ExtensionAttribute]
public static IReturnsResult`1<TMock> ThrowsAsync(IReturns`2<TMock, Task`1<TResult>> mock, Exception exception);
    [ExtensionAttribute]
public static IReturnsResult`1<TMock> ThrowsAsync(IReturns`2<TMock, ValueTask`1<TResult>> mock, Exception exception);
    [ExtensionAttribute]
public static IReturnsResult`1<TMock> ReturnsAsync(IReturns`2<TMock, Task`1<TResult>> mock, TResult value, TimeSpan delay);
    [ExtensionAttribute]
public static IReturnsResult`1<TMock> ReturnsAsync(IReturns`2<TMock, ValueTask`1<TResult>> mock, TResult value, TimeSpan delay);
    [ExtensionAttribute]
public static IReturnsResult`1<TMock> ReturnsAsync(IReturns`2<TMock, Task`1<TResult>> mock, TResult value, TimeSpan minDelay, TimeSpan maxDelay);
    [ExtensionAttribute]
public static IReturnsResult`1<TMock> ReturnsAsync(IReturns`2<TMock, ValueTask`1<TResult>> mock, TResult value, TimeSpan minDelay, TimeSpan maxDelay);
    [ExtensionAttribute]
public static IReturnsResult`1<TMock> ReturnsAsync(IReturns`2<TMock, Task`1<TResult>> mock, TResult value, TimeSpan minDelay, TimeSpan maxDelay, Random random);
    [ExtensionAttribute]
public static IReturnsResult`1<TMock> ReturnsAsync(IReturns`2<TMock, ValueTask`1<TResult>> mock, TResult value, TimeSpan minDelay, TimeSpan maxDelay, Random random);
    [ExtensionAttribute]
public static IReturnsResult`1<TMock> ThrowsAsync(IReturns`2<TMock, Task`1<TResult>> mock, Exception exception, TimeSpan delay);
    [ExtensionAttribute]
public static IReturnsResult`1<TMock> ThrowsAsync(IReturns`2<TMock, ValueTask`1<TResult>> mock, Exception exception, TimeSpan delay);
    [ExtensionAttribute]
public static IReturnsResult`1<TMock> ThrowsAsync(IReturns`2<TMock, Task`1<TResult>> mock, Exception exception, TimeSpan minDelay, TimeSpan maxDelay);
    [ExtensionAttribute]
public static IReturnsResult`1<TMock> ThrowsAsync(IReturns`2<TMock, ValueTask`1<TResult>> mock, Exception exception, TimeSpan minDelay, TimeSpan maxDelay);
    [ExtensionAttribute]
public static IReturnsResult`1<TMock> ThrowsAsync(IReturns`2<TMock, Task`1<TResult>> mock, Exception exception, TimeSpan minDelay, TimeSpan maxDelay, Random random);
    [ExtensionAttribute]
public static IReturnsResult`1<TMock> ThrowsAsync(IReturns`2<TMock, ValueTask`1<TResult>> mock, Exception exception, TimeSpan minDelay, TimeSpan maxDelay, Random random);
    internal static bool IsNullResult(Delegate valueFunction, Type resultType);
    private static TimeSpan GetDelay(TimeSpan minDelay, TimeSpan maxDelay, Random random);
    private static IReturnsResult`1<TMock> DelayedResult(IReturns`2<TMock, Task`1<TResult>> mock, TResult value, TimeSpan delay);
    private static IReturnsResult`1<TMock> DelayedResult(IReturns`2<TMock, ValueTask`1<TResult>> mock, TResult value, TimeSpan delay);
    private static IReturnsResult`1<TMock> DelayedException(IReturns`2<TMock, Task`1<TResult>> mock, Exception exception, TimeSpan delay);
    private static IReturnsResult`1<TMock> DelayedException(IReturns`2<TMock, ValueTask`1<TResult>> mock, Exception exception, TimeSpan delay);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static class Moq.SequenceExtensions : object {
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Please use instance method Mock<T>.SetupSequence instead.")]
public static ISetupSequentialResult`1<TResult> SetupSequence(Mock`1<TMock> mock, Expression`1<Func`2<TMock, TResult>> expression);
    [ExtensionAttribute]
[EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Please use instance method Mock<T>.SetupSequence instead.")]
public static ISetupSequentialAction SetupSequence(Mock`1<TMock> mock, Expression`1<Action`1<TMock>> expression);
    [ExtensionAttribute]
public static ISetupSequentialResult`1<Task`1<TResult>> ReturnsAsync(ISetupSequentialResult`1<Task`1<TResult>> setup, TResult value);
    [ExtensionAttribute]
public static ISetupSequentialResult`1<Task`1<TResult>> ReturnsAsync(ISetupSequentialResult`1<Task`1<TResult>> setup, Func`1<TResult> valueFunction);
    [ExtensionAttribute]
public static ISetupSequentialResult`1<ValueTask`1<TResult>> ReturnsAsync(ISetupSequentialResult`1<ValueTask`1<TResult>> setup, TResult value);
    [ExtensionAttribute]
public static ISetupSequentialResult`1<ValueTask`1<TResult>> ReturnsAsync(ISetupSequentialResult`1<ValueTask`1<TResult>> setup, Func`1<TResult> valueFunction);
    [ExtensionAttribute]
public static ISetupSequentialResult`1<Task> PassAsync(ISetupSequentialResult`1<Task> setup);
    [ExtensionAttribute]
public static ISetupSequentialResult`1<ValueTask> PassAsync(ISetupSequentialResult`1<ValueTask> setup);
    [ExtensionAttribute]
public static ISetupSequentialResult`1<Task`1<TResult>> ThrowsAsync(ISetupSequentialResult`1<Task`1<TResult>> setup, Exception exception);
    [ExtensionAttribute]
public static ISetupSequentialResult`1<ValueTask`1<TResult>> ThrowsAsync(ISetupSequentialResult`1<ValueTask`1<TResult>> setup, Exception exception);
    [ExtensionAttribute]
public static ISetupSequentialResult`1<Task> ThrowsAsync(ISetupSequentialResult`1<Task> setup, Exception exception);
    [ExtensionAttribute]
public static ISetupSequentialResult`1<ValueTask> ThrowsAsync(ISetupSequentialResult`1<ValueTask> setup, Exception exception);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Moq.SequenceSetup : SetupWithOutParameterSupport {
    private ConcurrentQueue`1<Behavior> behaviors;
    public SequenceSetup(Expression originalExpression, Mock mock, MethodExpectation expectation);
    public void AddBehavior(Behavior behavior);
    protected virtual void ExecuteCore(Invocation invocation);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Moq.Setup : object {
    private Expectation expectation;
    private Expression originalExpression;
    private Mock mock;
    private Flags flags;
    public Condition Condition { get; }
    public Expectation Expectation { get; }
    public LambdaExpression Expression { get; }
    private Mock Moq.ISetup.InnerMock { get; }
    public IEnumerable`1<Mock> InnerMocks { get; }
    public bool IsConditional { get; }
    public bool IsOverridden { get; }
    public bool IsVerifiable { get; }
    public Mock Mock { get; }
    public Expression OriginalExpression { get; }
    public bool IsMatched { get; }
    protected Setup(Expression originalExpression, Mock mock, Expectation expectation);
    public virtual Condition get_Condition();
    public Expectation get_Expectation();
    public sealed virtual LambdaExpression get_Expression();
    private sealed virtual override Mock Moq.ISetup.get_InnerMock();
    public virtual IEnumerable`1<Mock> get_InnerMocks();
    public sealed virtual bool get_IsConditional();
    public sealed virtual bool get_IsOverridden();
    public sealed virtual bool get_IsVerifiable();
    public sealed virtual Mock get_Mock();
    public sealed virtual Expression get_OriginalExpression();
    public sealed virtual bool get_IsMatched();
    public void Execute(Invocation invocation);
    protected abstract virtual void ExecuteCore(Invocation invocation);
    public void MarkAsOverridden();
    public void MarkAsVerifiable();
    public bool Matches(Invocation invocation);
    public bool Matches(MethodExpectation expectation);
    public virtual void SetOutParameters(Invocation invocation);
    public virtual string ToString();
    internal void Verify(bool recursive, Func`2<ISetup, bool> predicate, HashSet`1<Mock> verifiedMocks);
    protected virtual void VerifySelf();
    public void Reset();
    protected virtual void ResetCore();
    public sealed virtual void Verify(bool recursive);
    public sealed virtual void VerifyAll();
    private void Verify(bool recursive, Func`2<ISetup, bool> predicate);
    protected static Mock TryGetInnerMockFrom(object returnValue);
    [CompilerGeneratedAttribute]
private bool <Verify>b__41_0(Setup setup);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
internal class Moq.SetupCollection : object {
    private List`1<Setup> setups;
    private HashSet`1<Expectation> activeSetups;
    public int Count { get; }
    public ISetup Item { get; }
    public sealed virtual int get_Count();
    public sealed virtual ISetup get_Item(int index);
    public void Add(Setup setup);
    private void MarkOverriddenSetups();
    public void Clear();
    public List`1<Setup> FindAll(Func`2<Setup, bool> predicate);
    public Setup FindLast(Func`2<Setup, bool> predicate);
    public void Reset();
    public sealed virtual IEnumerator`1<ISetup> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Moq.SetupWithOutParameterSupport : MethodSetup {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<KeyValuePair`2<int, object>> outValues;
    protected SetupWithOutParameterSupport(Expression originalExpression, Mock mock, MethodExpectation expectation);
    public sealed virtual void SetOutParameters(Invocation invocation);
    private static List`1<KeyValuePair`2<int, object>> GetOutValues(IReadOnlyList`1<Expression> arguments, ParameterInfo[] parameters);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Moq.StringBuilderExtensions : object {
    [ExtensionAttribute]
public static StringBuilder AppendExpression(StringBuilder builder, Expression expression);
    [ExtensionAttribute]
private static StringBuilder AppendElementInit(StringBuilder builder, ElementInit initializer);
    [ExtensionAttribute]
private static StringBuilder AppendExpression(StringBuilder builder, UnaryExpression expression);
    [ExtensionAttribute]
private static StringBuilder AppendExpression(StringBuilder builder, BinaryExpression expression);
    [ExtensionAttribute]
private static StringBuilder AppendExpression(StringBuilder builder, TypeBinaryExpression expression);
    [ExtensionAttribute]
private static StringBuilder AppendExpression(StringBuilder builder, ConditionalExpression expression);
    [ExtensionAttribute]
private static StringBuilder AppendExpression(StringBuilder builder, ParameterExpression expression);
    [ExtensionAttribute]
private static StringBuilder AppendExpression(StringBuilder builder, MemberExpression expression);
    [ExtensionAttribute]
private static StringBuilder AppendExpression(StringBuilder builder, MethodCallExpression expression);
    [ExtensionAttribute]
private static StringBuilder AppendExpression(StringBuilder builder, IndexExpression expression);
    [ExtensionAttribute]
private static StringBuilder AppendExpression(StringBuilder builder, LambdaExpression expression);
    [ExtensionAttribute]
private static StringBuilder AppendExpression(StringBuilder builder, NewExpression expression);
    [ExtensionAttribute]
private static StringBuilder AppendExpression(StringBuilder builder, NewArrayExpression expression);
    [ExtensionAttribute]
private static StringBuilder AppendExpression(StringBuilder builder, InvocationExpression expression);
    [ExtensionAttribute]
private static StringBuilder AppendExpression(StringBuilder builder, MemberInitExpression expression);
    [ExtensionAttribute]
private static StringBuilder AppendExpression(StringBuilder builder, ListInitExpression expression);
    [ExtensionAttribute]
private static StringBuilder AppendExpression(StringBuilder builder, MatchExpression expression);
    [ExtensionAttribute]
public static StringBuilder Append(StringBuilder stringBuilder, string str, int startIndex);
    [ExtensionAttribute]
public static StringBuilder AppendCommaSeparated(StringBuilder stringBuilder, string prefix, IEnumerable`1<T> source, Func`3<StringBuilder, T, StringBuilder> append, string suffix);
    [ExtensionAttribute]
public static StringBuilder AppendCommaSeparated(StringBuilder stringBuilder, IEnumerable`1<T> source, Func`3<StringBuilder, T, StringBuilder> append);
    [ExtensionAttribute]
public static StringBuilder AppendIndented(StringBuilder stringBuilder, string str, int count, char indentChar);
    [ExtensionAttribute]
public static StringBuilder AppendNameOf(StringBuilder stringBuilder, MethodBase method, bool includeGenericArgumentList);
    [ExtensionAttribute]
public static StringBuilder AppendNameOf(StringBuilder stringBuilder, Type type);
    [ExtensionAttribute]
public static StringBuilder AppendParameterType(StringBuilder stringBuilder, ParameterInfo parameter);
    [ExtensionAttribute]
public static StringBuilder AppendValueOf(StringBuilder stringBuilder, object obj);
    [ExtensionAttribute]
public static StringBuilder TrimEnd(StringBuilder stringBuilder);
    [CompilerGeneratedAttribute]
internal static void <AppendExpression>g__AppendMaybeParenthesized|3_0(Expression operand, StringBuilder b);
    [CompilerGeneratedAttribute]
internal static string <AppendExpression>g__GetOperator|3_1(ExpressionType nodeType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Moq.StubbedPropertiesSetup : Setup {
    private ConcurrentDictionary`2<string, object> values;
    private DefaultValueProvider defaultValueProvider;
    public DefaultValueProvider DefaultValueProvider { get; }
    public IEnumerable`1<Mock> InnerMocks { get; }
    public StubbedPropertiesSetup(Mock mock, DefaultValueProvider defaultValueProvider);
    public DefaultValueProvider get_DefaultValueProvider();
    [IteratorStateMachineAttribute("Moq.StubbedPropertiesSetup/<get_InnerMocks>d__6")]
public virtual IEnumerable`1<Mock> get_InnerMocks();
    public void SetProperty(string propertyName, object value);
    protected virtual void ExecuteCore(Invocation invocation);
    protected virtual void VerifySelf();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Moq.StubbedPropertySetup : Setup {
    private object value;
    public IEnumerable`1<Mock> InnerMocks { get; }
    public StubbedPropertySetup(Mock mock, LambdaExpression expression, MethodInfo getter, MethodInfo setter, object initialValue);
    [IteratorStateMachineAttribute("Moq.StubbedPropertySetup/<get_InnerMocks>d__3")]
public virtual IEnumerable`1<Mock> get_InnerMocks();
    protected virtual void ExecuteCore(Invocation invocation);
    public virtual string ToString();
    protected virtual void VerifySelf();
}
[FlagsAttribute]
public enum Moq.Switches : Enum {
    public int value__;
    public static Switches Default;
    public static Switches CollectDiagnosticFileInfoForSetups;
}
[IsReadOnlyAttribute]
public class Moq.Times : ValueType {
    private int from;
    private int to;
    private Kind kind;
    private Times(Kind kind, int from, int to);
    [EditorBrowsableAttribute("2")]
public void Deconstruct(Int32& from, Int32& to);
    public static Times AtLeast(int callCount);
    public static Times AtLeastOnce();
    public static Times AtMost(int callCount);
    public static Times AtMostOnce();
    public static Times Between(int callCountFrom, int callCountTo, Range rangeKind);
    public static Times Exactly(int callCount);
    public static Times Never();
    public static Times Once();
    public sealed virtual bool Equals(Times other);
    [NullableContextAttribute("1")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(Times left, Times right);
    public static bool op_Inequality(Times left, Times right);
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("1")]
internal string GetExceptionMessage(int callCount);
    public bool Validate(int count);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("5148")]
public class Moq.TypeMatcherAttribute : Attribute {
    private Type type;
    internal Type Type { get; }
    public TypeMatcherAttribute(Type type);
    internal Type get_Type();
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
[GeneratedCodeAttribute("TypeNameFormatter", "1.1.1")]
[DebuggerNonUserCodeAttribute]
[EditorBrowsableAttribute("1")]
internal static class TypeNameFormatter.TypeName : object {
    private static Dictionary`2<Type, string> typeKeywords;
    private static TypeName();
    [ExtensionAttribute]
public static StringBuilder AppendFormattedName(StringBuilder stringBuilder, Type type, TypeNameFormatOptions options);
    [ExtensionAttribute]
public static string GetFormattedName(Type type, TypeNameFormatOptions options);
    [ExtensionAttribute]
private static void AppendFormattedName(StringBuilder stringBuilder, Type type, TypeNameFormatOptions options, Type typeWithGenericTypeArgs);
    private static bool IsSet(TypeNameFormatOptions option, TypeNameFormatOptions options);
    private static IEnumerable`1<PropertyInfo> GetDeclaredProperties(Type type);
    private static Type[] GetGenericTypeArguments(Type type);
    private static bool IsGenericType(Type type);
    private static bool IsConstructedGenericType(Type type);
    [CompilerGeneratedAttribute]
internal static void <AppendFormattedName>g__HandleArrayElementType|4_0(Type et, Queue`1<int> r, <>c__DisplayClass4_0& );
}
[FlagsAttribute]
internal enum TypeNameFormatter.TypeNameFormatOptions : Enum {
    public int value__;
    public static TypeNameFormatOptions Default;
    public static TypeNameFormatOptions Namespaces;
    public static TypeNameFormatOptions NoAnonymousTypes;
    public static TypeNameFormatOptions NoGenericParameterNames;
    public static TypeNameFormatOptions NoKeywords;
    public static TypeNameFormatOptions NoNullableQuestionMark;
    public static TypeNameFormatOptions NoTuple;
}
