public class DotUtils.StreamUtils.ChunkedBufferStream : Stream {
    private Stream _stream;
    private Byte[] _buffer;
    private int _position;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    private Exception UnsupportedException { get; }
    public ChunkedBufferStream(Stream stream, int bufferSize);
    public virtual void Flush();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void WriteByte(byte value);
    [AsyncStateMachineAttribute("DotUtils.StreamUtils.ChunkedBufferStream/<WriteAsync>d__10")]
public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Close();
    private Exception get_UnsupportedException();
}
[IsReadOnlyAttribute]
internal class DotUtils.StreamUtils.CleanupScope : ValueType {
    private Action _disposeAction;
    public CleanupScope(Action disposeAction);
    public sealed virtual void Dispose();
}
public class DotUtils.StreamUtils.ConcatenatedReadStream : Stream {
    private Queue`1<Stream> _streams;
    private long _position;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public ConcatenatedReadStream(IEnumerable`1<Stream> streams);
    public ConcatenatedReadStream(Stream[] streams);
    private static Queue`1<Stream> EnsureStreamsAreReadable(IEnumerable`1<Stream> streams);
    public virtual void Flush();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual int ReadByte();
    [AsyncStateMachineAttribute("DotUtils.StreamUtils.ConcatenatedReadStream/<ReadAsync>d__8")]
public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
}
[ExtensionAttribute]
public static class DotUtils.StreamUtils.StreamExtensions : object {
    [ExtensionAttribute]
public static int ReadAtLeast(Stream stream, Byte[] buffer, int offset, int minimumBytes, bool throwOnEndOfStream);
    [ExtensionAttribute]
public static long SkipBytes(Stream stream);
    [ExtensionAttribute]
public static long SkipBytes(Stream stream, long bytesCount);
    private static bool CheckIsSkipNeeded(long bytesCount);
    [ExtensionAttribute]
public static int SkipBytes(Stream stream, long bytesCount, bool throwOnEndOfStream);
    [ExtensionAttribute]
public static int SkipBytes(Stream stream, long bytesCount, bool throwOnEndOfStream, Byte[] buffer);
    [ExtensionAttribute]
public static Byte[] ReadToEnd(Stream stream);
    [ExtensionAttribute]
public static bool TryGetLength(Stream stream, Int64& length);
    [ExtensionAttribute]
public static Stream ToReadableSeekableStream(Stream stream);
    [ExtensionAttribute]
public static Stream Slice(Stream stream, long length);
    [ExtensionAttribute]
public static Stream Concat(Stream stream, Stream other);
}
public class DotUtils.StreamUtils.SubStream : Stream {
    private Stream _stream;
    private long _length;
    private long _position;
    public bool IsAtEnd { get; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public SubStream(Stream stream, long length);
    public bool get_IsAtEnd();
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Flush();
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual int ReadByte();
    [AsyncStateMachineAttribute("DotUtils.StreamUtils.SubStream/<ReadAsync>d__21")]
public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
}
public class DotUtils.StreamUtils.TransparentReadStream : Stream {
    private Stream _stream;
    private long _position;
    private long _maxAllowedPosition;
    unknown Nullable`1<int> BytesCountAllowedToRead {public set; }
    public int BytesCountAllowedToReadRemaining { get; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    private TransparentReadStream(Stream stream);
    public static Stream EnsureSeekableStream(Stream stream);
    public static TransparentReadStream EnsureTransparentReadStream(Stream stream);
    public void set_BytesCountAllowedToRead(Nullable`1<int> value);
    public int get_BytesCountAllowedToReadRemaining();
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Flush();
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual int ReadByte();
    [AsyncStateMachineAttribute("DotUtils.StreamUtils.TransparentReadStream/<ReadAsync>d__25")]
public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void Close();
}
internal class Microsoft.Build.BackEnd.ItemGroupLoggingHelper : object {
    internal static TaskParameterEventArgs CreateTaskParameterEventArgs(BuildEventContext buildEventContext, TaskParameterMessageKind messageKind, string parameterName, string propertyName, string itemType, IList items, bool logItemMetadata, DateTime timestamp, int line, int column);
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.Build.Collections.ArrayDictionary`2 : object {
    private TKey[] keys;
    private TValue[] values;
    private int count;
    private bool sorted;
    public TValue Item { get; public set; }
    private object System.Collections.IDictionary.Item { get; private set; }
    public TKey[] KeyArray { get; }
    public TValue[] ValueArray { get; }
    public ICollection`1<TKey> Keys { get; }
    private ICollection System.Collections.IDictionary.Keys { get; }
    public ICollection`1<TValue> Values { get; }
    private ICollection System.Collections.IDictionary.Values { get; }
    private IEqualityComparer`1<TKey> KeyComparer { get; }
    private IEqualityComparer`1<TValue> ValueComparer { get; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    private bool System.Collections.IDictionary.IsFixedSize { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    public ArrayDictionary`2(int capacity);
    public static IDictionary`2<TKey, TValue> Create(int capacity);
    public sealed virtual TValue get_Item(TKey key);
    public sealed virtual void set_Item(TKey key, TValue value);
    private sealed virtual override object System.Collections.IDictionary.get_Item(object key);
    private sealed virtual override void System.Collections.IDictionary.set_Item(object key, object value);
    public TKey[] get_KeyArray();
    public TValue[] get_ValueArray();
    public sealed virtual ICollection`1<TKey> get_Keys();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Keys();
    public sealed virtual ICollection`1<TValue> get_Values();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Values();
    private IEqualityComparer`1<TKey> get_KeyComparer();
    private IEqualityComparer`1<TValue> get_ValueComparer();
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    private sealed virtual override bool System.Collections.IDictionary.get_IsFixedSize();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    public sealed virtual void Add(TKey key, TValue value);
    public sealed virtual void Add(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual bool ContainsKey(TKey key);
    public sealed virtual void CopyTo(KeyValuePair`2[] array, int arrayIndex);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public sealed virtual IEnumerator`1<KeyValuePair`2<TKey, TValue>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator();
    public sealed virtual bool Remove(TKey key);
    public sealed virtual bool Remove(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual bool TryGetValue(TKey key, TValue& value);
    private sealed virtual override bool System.Collections.IDictionary.Contains(object key);
    private sealed virtual override void System.Collections.IDictionary.Add(object key, object value);
    private sealed virtual override void System.Collections.IDictionary.Remove(object key);
    public void Sort();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Microsoft.Build.Framework.AssemblyLoadBuildEventArgs : BuildMessageEventArgs {
    [NullableAttribute("0")]
private static string DefaultAppDomainDescriptor;
    [CompilerGeneratedAttribute]
private AssemblyLoadingContext <LoadingContext>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LoadingInitiator>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AssemblyName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AssemblyPath>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <MVID>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AppDomainDescriptor>k__BackingField;
    public AssemblyLoadingContext LoadingContext { get; private set; }
    public string LoadingInitiator { get; private set; }
    public string AssemblyName { get; private set; }
    public string AssemblyPath { get; private set; }
    public Guid MVID { get; private set; }
    public string AppDomainDescriptor { get; private set; }
    [NullableAttribute("0")]
public string Message { get; }
    public AssemblyLoadBuildEventArgs(AssemblyLoadingContext loadingContext, string loadingInitiator, string assemblyName, string assemblyPath, Guid mvid, string customAppDomainDescriptor, MessageImportance importance);
    [CompilerGeneratedAttribute]
public AssemblyLoadingContext get_LoadingContext();
    [CompilerGeneratedAttribute]
private void set_LoadingContext(AssemblyLoadingContext value);
    [CompilerGeneratedAttribute]
public string get_LoadingInitiator();
    [CompilerGeneratedAttribute]
private void set_LoadingInitiator(string value);
    [CompilerGeneratedAttribute]
public string get_AssemblyName();
    [CompilerGeneratedAttribute]
private void set_AssemblyName(string value);
    [CompilerGeneratedAttribute]
public string get_AssemblyPath();
    [CompilerGeneratedAttribute]
private void set_AssemblyPath(string value);
    [CompilerGeneratedAttribute]
public Guid get_MVID();
    [CompilerGeneratedAttribute]
private void set_MVID(Guid value);
    [CompilerGeneratedAttribute]
public string get_AppDomainDescriptor();
    [CompilerGeneratedAttribute]
private void set_AppDomainDescriptor(string value);
    [NullableContextAttribute("0")]
public virtual string get_Message();
}
internal enum Microsoft.Build.Framework.AssemblyLoadingContext : Enum {
    public int value__;
    public static AssemblyLoadingContext TaskRun;
    public static AssemblyLoadingContext Evaluation;
    public static AssemblyLoadingContext SdkResolution;
    public static AssemblyLoadingContext LoggerInitialization;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Microsoft.Build.Framework.ExtendedBuildErrorEventArgs : BuildErrorEventArgs {
    [NullableAttribute("0")]
[CompilerGeneratedAttribute]
private string <ExtendedType>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private IDictionary`2<string, string> <ExtendedMetadata>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ExtendedData>k__BackingField;
    [NullableAttribute("0")]
public string ExtendedType { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IDictionary`2<string, string> ExtendedMetadata { get; public set; }
    public string ExtendedData { get; public set; }
    [NullableContextAttribute("0")]
public ExtendedBuildErrorEventArgs(string type);
    public ExtendedBuildErrorEventArgs(string type, string subcategory, string code, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string helpKeyword, string senderName);
    public ExtendedBuildErrorEventArgs(string type, string subcategory, string code, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string helpKeyword, string senderName, DateTime eventTimestamp);
    public ExtendedBuildErrorEventArgs(string type, string subcategory, string code, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string helpKeyword, string senderName, DateTime eventTimestamp, Object[] messageArgs);
    public ExtendedBuildErrorEventArgs(string type, string subcategory, string code, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string helpKeyword, string senderName, string helpLink, DateTime eventTimestamp, Object[] messageArgs);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public sealed virtual string get_ExtendedType();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public sealed virtual void set_ExtendedType(string value);
    [CompilerGeneratedAttribute]
public sealed virtual IDictionary`2<string, string> get_ExtendedMetadata();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ExtendedMetadata(IDictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_ExtendedData();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ExtendedData(string value);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Microsoft.Build.Framework.ExtendedBuildMessageEventArgs : BuildMessageEventArgs {
    [NullableAttribute("0")]
[CompilerGeneratedAttribute]
private string <ExtendedType>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private IDictionary`2<string, string> <ExtendedMetadata>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ExtendedData>k__BackingField;
    [NullableAttribute("0")]
public string ExtendedType { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IDictionary`2<string, string> ExtendedMetadata { get; public set; }
    public string ExtendedData { get; public set; }
    [NullableContextAttribute("0")]
public ExtendedBuildMessageEventArgs(string type);
    public ExtendedBuildMessageEventArgs(string type, string message, string helpKeyword, string senderName, MessageImportance importance);
    public ExtendedBuildMessageEventArgs(string type, string message, string helpKeyword, string senderName, MessageImportance importance, DateTime eventTimestamp);
    public ExtendedBuildMessageEventArgs(string type, string message, string helpKeyword, string senderName, MessageImportance importance, DateTime eventTimestamp, Object[] messageArgs);
    public ExtendedBuildMessageEventArgs(string type, string subcategory, string code, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string helpKeyword, string senderName, MessageImportance importance);
    public ExtendedBuildMessageEventArgs(string type, string subcategory, string code, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string helpKeyword, string senderName, MessageImportance importance, DateTime eventTimestamp);
    public ExtendedBuildMessageEventArgs(string type, string subcategory, string code, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string helpKeyword, string senderName, MessageImportance importance, DateTime eventTimestamp, Object[] messageArgs);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public sealed virtual string get_ExtendedType();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public sealed virtual void set_ExtendedType(string value);
    [CompilerGeneratedAttribute]
public sealed virtual IDictionary`2<string, string> get_ExtendedMetadata();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ExtendedMetadata(IDictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_ExtendedData();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ExtendedData(string value);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Microsoft.Build.Framework.ExtendedBuildWarningEventArgs : BuildWarningEventArgs {
    [NullableAttribute("0")]
[CompilerGeneratedAttribute]
private string <ExtendedType>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private IDictionary`2<string, string> <ExtendedMetadata>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ExtendedData>k__BackingField;
    [NullableAttribute("0")]
public string ExtendedType { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IDictionary`2<string, string> ExtendedMetadata { get; public set; }
    public string ExtendedData { get; public set; }
    [NullableContextAttribute("0")]
public ExtendedBuildWarningEventArgs(string type);
    public ExtendedBuildWarningEventArgs(string type, string subcategory, string code, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string helpKeyword, string senderName);
    public ExtendedBuildWarningEventArgs(string type, string subcategory, string code, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string helpKeyword, string senderName, DateTime eventTimestamp);
    public ExtendedBuildWarningEventArgs(string type, string subcategory, string code, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string helpKeyword, string senderName, DateTime eventTimestamp, Object[] messageArgs);
    public ExtendedBuildWarningEventArgs(string type, string subcategory, string code, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string helpKeyword, string senderName, string helpLink, DateTime eventTimestamp, Object[] messageArgs);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public sealed virtual string get_ExtendedType();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public sealed virtual void set_ExtendedType(string value);
    [CompilerGeneratedAttribute]
public sealed virtual IDictionary`2<string, string> get_ExtendedMetadata();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ExtendedMetadata(IDictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_ExtendedData();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ExtendedData(string value);
}
public class Microsoft.Build.Framework.ExtendedCriticalBuildMessageEventArgs : CriticalBuildMessageEventArgs {
    [CompilerGeneratedAttribute]
private string <ExtendedType>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private IDictionary`2<string, string> <ExtendedMetadata>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <ExtendedData>k__BackingField;
    public string ExtendedType { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IDictionary`2<string, string> ExtendedMetadata { get; public set; }
    [NullableAttribute("2")]
public string ExtendedData { get; public set; }
    [NullableContextAttribute("2")]
public ExtendedCriticalBuildMessageEventArgs(string type, string subcategory, string code, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string helpKeyword, string senderName);
    [NullableContextAttribute("2")]
public ExtendedCriticalBuildMessageEventArgs(string type, string subcategory, string code, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string helpKeyword, string senderName, DateTime eventTimestamp);
    [NullableContextAttribute("2")]
public ExtendedCriticalBuildMessageEventArgs(string type, string subcategory, string code, string file, int lineNumber, int columnNumber, int endLineNumber, int endColumnNumber, string message, string helpKeyword, string senderName, DateTime eventTimestamp, Object[] messageArgs);
    public ExtendedCriticalBuildMessageEventArgs(string type);
    [CompilerGeneratedAttribute]
public sealed virtual string get_ExtendedType();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ExtendedType(string value);
    [CompilerGeneratedAttribute]
public sealed virtual IDictionary`2<string, string> get_ExtendedMetadata();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ExtendedMetadata(IDictionary`2<string, string> value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual string get_ExtendedData();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual void set_ExtendedData(string value);
}
public class Microsoft.Build.Framework.ExtendedCustomBuildEventArgs : CustomBuildEventArgs {
    [CompilerGeneratedAttribute]
private string <ExtendedType>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private IDictionary`2<string, string> <ExtendedMetadata>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <ExtendedData>k__BackingField;
    public string ExtendedType { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IDictionary`2<string, string> ExtendedMetadata { get; public set; }
    [NullableAttribute("2")]
public string ExtendedData { get; public set; }
    public ExtendedCustomBuildEventArgs(string type);
    [NullableContextAttribute("2")]
public ExtendedCustomBuildEventArgs(string type, string message, string helpKeyword, string senderName);
    [NullableContextAttribute("2")]
public ExtendedCustomBuildEventArgs(string type, string message, string helpKeyword, string senderName, DateTime eventTimestamp);
    [NullableContextAttribute("2")]
public ExtendedCustomBuildEventArgs(string type, string message, string helpKeyword, string senderName, DateTime eventTimestamp, Object[] messageArgs);
    [CompilerGeneratedAttribute]
public sealed virtual string get_ExtendedType();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ExtendedType(string value);
    [CompilerGeneratedAttribute]
public sealed virtual IDictionary`2<string, string> get_ExtendedMetadata();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ExtendedMetadata(IDictionary`2<string, string> value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual string get_ExtendedData();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual void set_ExtendedData(string value);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Microsoft.Build.Framework.FileUsedEventArgs : BuildMessageEventArgs {
    [CompilerGeneratedAttribute]
private string <FilePath>k__BackingField;
    public string FilePath { get; public set; }
    [NullableContextAttribute("0")]
public FileUsedEventArgs(string responseFilePath);
    [CompilerGeneratedAttribute]
public void set_FilePath(string value);
    [CompilerGeneratedAttribute]
public string get_FilePath();
}
public interface Microsoft.Build.Framework.IExtendedBuildEventArgs {
    public string ExtendedType { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IDictionary`2<string, string> ExtendedMetadata { get; public set; }
    [NullableAttribute("2")]
public string ExtendedData { get; public set; }
    public abstract virtual string get_ExtendedType();
    public abstract virtual void set_ExtendedType(string value);
    public abstract virtual IDictionary`2<string, string> get_ExtendedMetadata();
    public abstract virtual void set_ExtendedMetadata(IDictionary`2<string, string> value);
    [NullableContextAttribute("2")]
public abstract virtual string get_ExtendedData();
    [NullableContextAttribute("2")]
public abstract virtual void set_ExtendedData(string value);
}
internal class Microsoft.Build.Framework.TaskItemData : object {
    private static Dictionary`2<string, string> _emptyMetadata;
    [CompilerGeneratedAttribute]
private string <ItemSpec>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <Metadata>k__BackingField;
    public string ItemSpec { get; public set; }
    public IDictionary`2<string, string> Metadata { get; }
    public int MetadataCount { get; }
    public ICollection MetadataNames { get; }
    public TaskItemData(string itemSpec, IDictionary`2<string, string> metadata);
    private static TaskItemData();
    [CompilerGeneratedAttribute]
public sealed virtual string get_ItemSpec();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ItemSpec(string value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_Metadata();
    public sealed virtual int get_MetadataCount();
    public sealed virtual ICollection get_MetadataNames();
    public sealed virtual IDictionary CloneCustomMetadata();
    public sealed virtual void CopyMetadataTo(ITaskItem destinationItem);
    public sealed virtual string GetMetadata(string metadataName);
    public sealed virtual void RemoveMetadata(string metadataName);
    public sealed virtual void SetMetadata(string metadataName, string metadataValue);
    public virtual string ToString();
}
public class Microsoft.Build.Framework.TaskParameterEventArgs2 : TaskParameterEventArgs {
    [CompilerGeneratedAttribute]
private string <ParameterName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PropertyName>k__BackingField;
    [CompilerGeneratedAttribute]
private int <LineNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ColumnNumber>k__BackingField;
    public string ParameterName { get; public set; }
    public string PropertyName { get; public set; }
    public int LineNumber { get; public set; }
    public int ColumnNumber { get; public set; }
    public TaskParameterEventArgs2(TaskParameterMessageKind kind, string parameterName, string propertyName, string itemType, IList items, bool logItemMetadata, DateTime eventTimestamp);
    [CompilerGeneratedAttribute]
public string get_ParameterName();
    [CompilerGeneratedAttribute]
public void set_ParameterName(string value);
    [CompilerGeneratedAttribute]
public string get_PropertyName();
    [CompilerGeneratedAttribute]
public void set_PropertyName(string value);
    [CompilerGeneratedAttribute]
public int get_LineNumber();
    [CompilerGeneratedAttribute]
public void set_LineNumber(int value);
    [CompilerGeneratedAttribute]
public int get_ColumnNumber();
    [CompilerGeneratedAttribute]
public void set_ColumnNumber(int value);
}
public class Microsoft.Build.Framework.TaskStartedEventArgs2 : TaskStartedEventArgs {
    [CompilerGeneratedAttribute]
private int <LineNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ColumnNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TaskAssemblyLocation>k__BackingField;
    public int LineNumber { get; public set; }
    public int ColumnNumber { get; public set; }
    public string TaskAssemblyLocation { get; public set; }
    public TaskStartedEventArgs2(string message, string helpKeyword, string projectFile, string taskFile, string taskName, DateTime eventTimestamp);
    [CompilerGeneratedAttribute]
public int get_LineNumber();
    [CompilerGeneratedAttribute]
public void set_LineNumber(int value);
    [CompilerGeneratedAttribute]
public int get_ColumnNumber();
    [CompilerGeneratedAttribute]
public void set_ColumnNumber(int value);
    [CompilerGeneratedAttribute]
public string get_TaskAssemblyLocation();
    [CompilerGeneratedAttribute]
public void set_TaskAssemblyLocation(string value);
}
[ExtensionAttribute]
internal static class Microsoft.Build.Internal.Utilities : object {
    public static void EnumerateProperties(IEnumerable properties, Action`1<KeyValuePair`2<string, string>> callback);
    public static void EnumerateItems(IEnumerable items, Action`1<DictionaryEntry> callback);
    [ExtensionAttribute]
public static IEnumerable`1<KeyValuePair`2<string, string>> EnumerateMetadata(ITaskItem taskItem);
    [ExtensionAttribute]
public static bool EqualTo(BuildEventContext buildEventContext, BuildEventContext other);
}
[FlagsAttribute]
internal enum Microsoft.Build.Logging.BuildEventArgsFieldFlags : Enum {
    public int value__;
    public static BuildEventArgsFieldFlags None;
    public static BuildEventArgsFieldFlags BuildEventContext;
    public static BuildEventArgsFieldFlags HelpKeyword;
    public static BuildEventArgsFieldFlags Message;
    public static BuildEventArgsFieldFlags SenderName;
    public static BuildEventArgsFieldFlags ThreadId;
    public static BuildEventArgsFieldFlags Timestamp;
    public static BuildEventArgsFieldFlags Subcategory;
    public static BuildEventArgsFieldFlags Code;
    public static BuildEventArgsFieldFlags File;
    public static BuildEventArgsFieldFlags ProjectFile;
    public static BuildEventArgsFieldFlags LineNumber;
    public static BuildEventArgsFieldFlags ColumnNumber;
    public static BuildEventArgsFieldFlags EndLineNumber;
    public static BuildEventArgsFieldFlags EndColumnNumber;
    public static BuildEventArgsFieldFlags Arguments;
    public static BuildEventArgsFieldFlags Importance;
    public static BuildEventArgsFieldFlags Extended;
}
internal class Microsoft.Build.Logging.BuildEventArgsFields : object {
    [CompilerGeneratedAttribute]
private BuildEventArgsFieldFlags <Flags>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private Object[] <Arguments>k__BackingField;
    [CompilerGeneratedAttribute]
private BuildEventContext <BuildEventContext>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ThreadId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HelpKeyword>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SenderName>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <Timestamp>k__BackingField;
    [CompilerGeneratedAttribute]
private MessageImportance <Importance>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Subcategory>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Code>k__BackingField;
    [CompilerGeneratedAttribute]
private string <File>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProjectFile>k__BackingField;
    [CompilerGeneratedAttribute]
private int <LineNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ColumnNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private int <EndLineNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private int <EndColumnNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private ExtendedDataFields <Extended>k__BackingField;
    public BuildEventArgsFieldFlags Flags { get; public set; }
    public string Message { get; public set; }
    public Object[] Arguments { get; public set; }
    public BuildEventContext BuildEventContext { get; public set; }
    public int ThreadId { get; public set; }
    public string HelpKeyword { get; public set; }
    public string SenderName { get; public set; }
    public DateTime Timestamp { get; public set; }
    public MessageImportance Importance { get; public set; }
    public string Subcategory { get; public set; }
    public string Code { get; public set; }
    public string File { get; public set; }
    public string ProjectFile { get; public set; }
    public int LineNumber { get; public set; }
    public int ColumnNumber { get; public set; }
    public int EndLineNumber { get; public set; }
    public int EndColumnNumber { get; public set; }
    public ExtendedDataFields Extended { get; public set; }
    [CompilerGeneratedAttribute]
public BuildEventArgsFieldFlags get_Flags();
    [CompilerGeneratedAttribute]
public void set_Flags(BuildEventArgsFieldFlags value);
    [CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
public void set_Message(string value);
    [CompilerGeneratedAttribute]
public Object[] get_Arguments();
    [CompilerGeneratedAttribute]
public void set_Arguments(Object[] value);
    [CompilerGeneratedAttribute]
public BuildEventContext get_BuildEventContext();
    [CompilerGeneratedAttribute]
public void set_BuildEventContext(BuildEventContext value);
    [CompilerGeneratedAttribute]
public int get_ThreadId();
    [CompilerGeneratedAttribute]
public void set_ThreadId(int value);
    [CompilerGeneratedAttribute]
public string get_HelpKeyword();
    [CompilerGeneratedAttribute]
public void set_HelpKeyword(string value);
    [CompilerGeneratedAttribute]
public string get_SenderName();
    [CompilerGeneratedAttribute]
public void set_SenderName(string value);
    [CompilerGeneratedAttribute]
public DateTime get_Timestamp();
    [CompilerGeneratedAttribute]
public void set_Timestamp(DateTime value);
    [CompilerGeneratedAttribute]
public MessageImportance get_Importance();
    [CompilerGeneratedAttribute]
public void set_Importance(MessageImportance value);
    [CompilerGeneratedAttribute]
public string get_Subcategory();
    [CompilerGeneratedAttribute]
public void set_Subcategory(string value);
    [CompilerGeneratedAttribute]
public string get_Code();
    [CompilerGeneratedAttribute]
public void set_Code(string value);
    [CompilerGeneratedAttribute]
public string get_File();
    [CompilerGeneratedAttribute]
public void set_File(string value);
    [CompilerGeneratedAttribute]
public string get_ProjectFile();
    [CompilerGeneratedAttribute]
public void set_ProjectFile(string value);
    [CompilerGeneratedAttribute]
public int get_LineNumber();
    [CompilerGeneratedAttribute]
public void set_LineNumber(int value);
    [CompilerGeneratedAttribute]
public int get_ColumnNumber();
    [CompilerGeneratedAttribute]
public void set_ColumnNumber(int value);
    [CompilerGeneratedAttribute]
public int get_EndLineNumber();
    [CompilerGeneratedAttribute]
public void set_EndLineNumber(int value);
    [CompilerGeneratedAttribute]
public int get_EndColumnNumber();
    [CompilerGeneratedAttribute]
public void set_EndColumnNumber(int value);
    [CompilerGeneratedAttribute]
public ExtendedDataFields get_Extended();
    [CompilerGeneratedAttribute]
public void set_Extended(ExtendedDataFields value);
}
internal class Microsoft.Build.Logging.ExtendedDataFields : object {
    [CompilerGeneratedAttribute]
private string <ExtendedType>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <ExtendedMetadata>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ExtendedData>k__BackingField;
    public string ExtendedType { get; public set; }
    public IDictionary`2<string, string> ExtendedMetadata { get; public set; }
    public string ExtendedData { get; public set; }
    [CompilerGeneratedAttribute]
public string get_ExtendedType();
    [CompilerGeneratedAttribute]
public void set_ExtendedType(string value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_ExtendedMetadata();
    [CompilerGeneratedAttribute]
public void set_ExtendedMetadata(IDictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public string get_ExtendedData();
    [CompilerGeneratedAttribute]
public void set_ExtendedData(string value);
}
internal class Microsoft.Build.Logging.ProjectImportsCollector : object {
    private Stream _fileStream;
    private ZipArchive _zipArchive;
    private string _archiveFilePath;
    private bool _runOnBackground;
    private static string DefaultSourcesArchiveExtension;
    private HashSet`1<string> _processedFiles;
    private Task _currentTask;
    public ProjectImportsCollector(string logFilePath, bool createFile, string sourcesArchiveExtension, bool runOnBackground);
    internal static void FlushBlobToFile(string logFilePath, Stream contentStream);
    private static string GetArchiveFilePath(string logFilePath, string sourcesArchiveExtension);
    private static string GetCacheDirectory();
    [NullableContextAttribute("2")]
public void AddFile(string filePath);
    public void AddFileFromMemory(string filePath, string data, Nullable`1<DateTimeOffset> entryCreationStamp, bool makePathAbsolute);
    public void AddFileFromMemory(string filePath, Stream data, Nullable`1<DateTimeOffset> entryCreationStamp, bool makePathAbsolute);
    private void AddFileHelper(string filePath, Action`1<string> addFileWorker);
    private void AddFileCore(string filePath);
    private void AddFileFromMemoryCore(string filePath, string data, bool makePathAbsolute, Nullable`1<DateTimeOffset> entryCreationStamp);
    private void AddFileFromMemoryCore(string filePath, Stream data, bool makePathAbsolute, Nullable`1<DateTimeOffset> entryCreationStamp);
    private void AddFileData(string filePath, Stream data, Nullable`1<DateTimeOffset> entryCreationStamp);
    private bool ShouldAddFile(String& filePath, bool checkFileExistence, bool makeAbsolute);
    private Stream OpenArchiveEntry(string filePath, Nullable`1<DateTimeOffset> entryCreationStamp);
    private static string CalculateArchivePath(string filePath);
    public void ProcessResult(Action`1<Stream> consumeStream, Action`1<string> onError);
    public void Close();
    public void DeleteArchive();
}
[ExtensionAttribute]
internal static class Microsoft.Build.Logging.ProjectImportsCollectorExtensions : object {
    [ExtensionAttribute]
public static void IncludeSourceFiles(ProjectImportsCollector projectImportsCollector, BuildEventArgs e);
}
public class Microsoft.Build.Logging.Record : object {
    public BinaryLogRecordKind Kind;
    public Byte[] Bytes;
    public BuildEventArgs Args;
    public long Start;
    public long Length;
}
[IsReadOnlyAttribute]
public class Microsoft.Build.Logging.RecordInfo : ValueType {
    [CompilerGeneratedAttribute]
private BinaryLogRecordKind <Kind>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Start>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Length>k__BackingField;
    public BinaryLogRecordKind Kind { get; public set; }
    public long Start { get; public set; }
    public long Length { get; public set; }
    public RecordInfo(BinaryLogRecordKind Kind, long Start, long Length);
    [CompilerGeneratedAttribute]
public BinaryLogRecordKind get_Kind();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Kind(BinaryLogRecordKind value);
    [CompilerGeneratedAttribute]
public long get_Start();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Start(long value);
    [CompilerGeneratedAttribute]
public long get_Length();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Length(long value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(RecordInfo left, RecordInfo right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(RecordInfo left, RecordInfo right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(RecordInfo other);
    [CompilerGeneratedAttribute]
public void Deconstruct(BinaryLogRecordKind& Kind, Int64& Start, Int64& Length);
}
public class Microsoft.Build.Logging.StructuredLogger.AbstractDiagnostic : TextNode {
    [CompilerGeneratedAttribute]
private DateTime <Timestamp>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Code>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ColumnNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private int <EndColumnNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private int <EndLineNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private string <File>k__BackingField;
    [CompilerGeneratedAttribute]
private int <LineNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProjectFile>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Subcategory>k__BackingField;
    public DateTime Timestamp { get; public set; }
    public string Code { get; public set; }
    public int ColumnNumber { get; public set; }
    public int EndColumnNumber { get; public set; }
    public int EndLineNumber { get; public set; }
    public string File { get; public set; }
    public int LineNumber { get; public set; }
    public string ProjectFile { get; public set; }
    public string Subcategory { get; public set; }
    private string Microsoft.Build.Logging.StructuredLogger.IHasSourceFile.SourceFilePath { get; }
    public string TypeName { get; }
    [CompilerGeneratedAttribute]
public DateTime get_Timestamp();
    [CompilerGeneratedAttribute]
public void set_Timestamp(DateTime value);
    [CompilerGeneratedAttribute]
public string get_Code();
    [CompilerGeneratedAttribute]
public void set_Code(string value);
    [CompilerGeneratedAttribute]
public int get_ColumnNumber();
    [CompilerGeneratedAttribute]
public void set_ColumnNumber(int value);
    [CompilerGeneratedAttribute]
public int get_EndColumnNumber();
    [CompilerGeneratedAttribute]
public void set_EndColumnNumber(int value);
    [CompilerGeneratedAttribute]
public int get_EndLineNumber();
    [CompilerGeneratedAttribute]
public void set_EndLineNumber(int value);
    [CompilerGeneratedAttribute]
public string get_File();
    [CompilerGeneratedAttribute]
public void set_File(string value);
    [CompilerGeneratedAttribute]
public int get_LineNumber();
    [CompilerGeneratedAttribute]
public void set_LineNumber(int value);
    [CompilerGeneratedAttribute]
public string get_ProjectFile();
    [CompilerGeneratedAttribute]
public void set_ProjectFile(string value);
    [CompilerGeneratedAttribute]
public string get_Subcategory();
    [CompilerGeneratedAttribute]
public void set_Subcategory(string value);
    private sealed virtual override string Microsoft.Build.Logging.StructuredLogger.IHasSourceFile.get_SourceFilePath();
    public virtual string get_TypeName();
    public virtual string ToString();
}
public class Microsoft.Build.Logging.StructuredLogger.AddItem : NamedNode {
    [CompilerGeneratedAttribute]
private Nullable`1<int> <LineNumber>k__BackingField;
    public string TypeName { get; }
    public Nullable`1<int> LineNumber { get; public set; }
    public virtual string get_TypeName();
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<int> get_LineNumber();
    [CompilerGeneratedAttribute]
public void set_LineNumber(Nullable`1<int> value);
}
public class Microsoft.Build.Logging.StructuredLogger.ArchiveFile : object {
    [CompilerGeneratedAttribute]
private string <FullPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Text>k__BackingField;
    public string FullPath { get; }
    public string Text { get; }
    public ArchiveFile(string fullPath, string text);
    [CompilerGeneratedAttribute]
public string get_FullPath();
    [CompilerGeneratedAttribute]
public string get_Text();
    public static ArchiveFile From(ZipArchiveEntry entry);
    public static ArchiveFile From(ZipArchiveEntry entry, bool adjustPath);
    public static string GetText(ZipArchiveEntry entry);
    public static string CalculateArchivePath(string filePath);
}
public class Microsoft.Build.Logging.StructuredLogger.ArchiveFileEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private ArchiveFile <ArchiveFile>k__BackingField;
    public ArchiveFile ArchiveFile { get; public set; }
    public ArchiveFileEventArgs(ArchiveFile archiveFile);
    [CompilerGeneratedAttribute]
public ArchiveFile get_ArchiveFile();
    [CompilerGeneratedAttribute]
public void set_ArchiveFile(ArchiveFile value);
}
[ExtensionAttribute]
public static class Microsoft.Build.Logging.StructuredLogger.ArchiveFileEventArgsExtensions : object {
    [ExtensionAttribute]
public static Action`1<ArchiveFileEventArgs> ToArchiveFileHandler(Action`1<StringReadEventArgs> stringHandler);
}
public enum Microsoft.Build.Logging.StructuredLogger.AttributeNames : Enum {
    public int value__;
    public static AttributeNames Name;
    public static AttributeNames IsLowRelevance;
    public static AttributeNames Text;
    public static AttributeNames ProjectFile;
    public static AttributeNames DependsOnTargets;
    public static AttributeNames FromAssembly;
    public static AttributeNames CommandLineArguments;
    public static AttributeNames Code;
    public static AttributeNames File;
    public static AttributeNames LineNumber;
    public static AttributeNames ColumnNumber;
    public static AttributeNames EndLineNumber;
    public static AttributeNames EndColumnNumber;
    public static AttributeNames StartTime;
    public static AttributeNames EndTime;
    public static AttributeNames Succeeded;
    public static AttributeNames Timestamp;
    public static AttributeNames IsAnalyzed;
    public static AttributeNames NodeId;
}
public abstract class Microsoft.Build.Logging.StructuredLogger.BaseNode : ObservableObject {
    private TreeNode parent;
    private NodeFlags flags;
    private static BaseNode selectedNode;
    public TreeNode Parent { get; public set; }
    public string TypeName { get; }
    public string Title { get; }
    private static BaseNode SelectedNode { get; private set; }
    public bool IsSelected { get; public set; }
    protected bool IsSelectable { get; }
    public bool IsSearchResult { get; public set; }
    public bool ContainsSearchResult { get; public set; }
    public TreeNode get_Parent();
    public void set_Parent(TreeNode value);
    public virtual string get_TypeName();
    public virtual string get_Title();
    private static BaseNode get_SelectedNode();
    private static void set_SelectedNode(BaseNode value);
    private void InvalidateRelevance();
    public static void ClearSelectedNode();
    public bool get_IsSelected();
    public void set_IsSelected(bool value);
    protected virtual bool get_IsSelectable();
    public bool get_IsSearchResult();
    public void set_IsSearchResult(bool value);
    public bool get_ContainsSearchResult();
    public void set_ContainsSearchResult(bool value);
    public void ResetSearchResultStatus();
    private protected bool HasFlag(NodeFlags flag);
    private protected void SetFlag(NodeFlags flag, bool isSet, string propertyName);
    public BaseNode GetRoot();
    public IEnumerable`1<BaseNode> GetParentChainExcludingThis();
    public IEnumerable`1<BaseNode> GetParentChainIncludingThis();
    public T GetNearestParent(Predicate`1<T> predicate);
    public T GetNearestParentOrSelf();
    [IteratorStateMachineAttribute("Microsoft.Build.Logging.StructuredLogger.BaseNode/<EnumerateSiblingsCycle>d__34")]
public IEnumerable`1<BaseNode> EnumerateSiblingsCycle();
}
public class Microsoft.Build.Logging.StructuredLogger.BatchBlockingCollection`1 : object {
    private Rental`1<Batch<T>> rental;
    private Batch<T> currentBatch;
    private BlockingCollection`1<Batch<T>> queue;
    private int BatchSize;
    [CompilerGeneratedAttribute]
private Action`1<T> ProcessItem;
    public Task Completion;
    public int Count { get; }
    public BatchBlockingCollection`1(int batchSize, int boundedCapacity);
    [CompilerGeneratedAttribute]
public void add_ProcessItem(Action`1<T> value);
    [CompilerGeneratedAttribute]
public void remove_ProcessItem(Action`1<T> value);
    public int get_Count();
    public void Add(T item);
    public void CompleteAdding();
}
public class Microsoft.Build.Logging.StructuredLogger.BetterBinaryReader : BinaryReader {
    public BetterBinaryReader(Stream input);
    public virtual int ReadInt32();
}
public class Microsoft.Build.Logging.StructuredLogger.BetterBinaryWriter : BinaryWriter {
    public BetterBinaryWriter(Stream output);
    public virtual void Write(int value);
}
public class Microsoft.Build.Logging.StructuredLogger.BinaryLog : object {
    public static IEnumerable`1<Record> ReadRecords(string binLogFilePath);
    public static IEnumerable`1<Record> ReadRecords(Stream binlogStream);
    public static IEnumerable`1<Record> ReadRecords(Byte[] binlogBytes);
    public static Build ReadBuild(string filePath);
    public static Build ReadBuild(string filePath, Progress progress);
    public static Build ReadBuild(string filePath, ReaderSettings readerSettings);
    public static Build ReadBuild(string filePath, Progress progress, ReaderSettings readerSettings);
    public static Build ReadBuild(Stream stream, Byte[] projectImportsArchive);
    public static Build ReadBuild(Stream stream, Progress progress, Byte[] projectImportsArchive);
    public static Build ReadBuild(Stream stream, Progress progress, Byte[] projectImportsArchive, ReaderSettings readerSettings);
}
public class Microsoft.Build.Logging.StructuredLogger.BinaryLogger : object {
    internal static int ForwardCompatibilityMinimalVersion;
    internal static int FileFormatVersion;
    internal static int MinimumReaderVersion;
    [CompilerGeneratedAttribute]
private static bool <IsNewerVersionAvailable>k__BackingField;
    private Stream stream;
    private BinaryWriter binaryWriter;
    private BuildEventArgsWriter eventArgsWriter;
    private ProjectImportsCollector projectImportsCollector;
    private string _initialTargetOutputLogging;
    private string _initialLogImports;
    [CompilerGeneratedAttribute]
private ProjectImportsCollectionMode <CollectProjectImports>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FilePath>k__BackingField;
    [CompilerGeneratedAttribute]
private LoggerVerbosity <Verbosity>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Parameters>k__BackingField;
    public static bool IsNewerVersionAvailable { get; public set; }
    public ProjectImportsCollectionMode CollectProjectImports { get; public set; }
    private string FilePath { get; private set; }
    public LoggerVerbosity Verbosity { get; public set; }
    public string Parameters { get; public set; }
    [CompilerGeneratedAttribute]
public static bool get_IsNewerVersionAvailable();
    [CompilerGeneratedAttribute]
public static void set_IsNewerVersionAvailable(bool value);
    [CompilerGeneratedAttribute]
public ProjectImportsCollectionMode get_CollectProjectImports();
    [CompilerGeneratedAttribute]
public void set_CollectProjectImports(ProjectImportsCollectionMode value);
    [CompilerGeneratedAttribute]
private string get_FilePath();
    [CompilerGeneratedAttribute]
private void set_FilePath(string value);
    [CompilerGeneratedAttribute]
public sealed virtual LoggerVerbosity get_Verbosity();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Verbosity(LoggerVerbosity value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Parameters();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Parameters(string value);
    public sealed virtual void Initialize(IEventSource eventSource);
    private void EventArgsWriter_EmbedFile(string filePath);
    private void LogInitialInfo();
    private void LogMessage(string text);
    public sealed virtual void Shutdown();
    private void RawEvents_LogDataSliceReceived(BinaryLogRecordKind recordKind, Stream stream);
    private void EventSource_AnyEventRaised(object sender, BuildEventArgs e);
    private void Write(BuildEventArgs e);
    private void CollectImports(BuildEventArgs e);
    private void ProcessParameters(Boolean& omitInitialInfo);
    [CompilerGeneratedAttribute]
private void <Shutdown>b__34_0(Stream streamToEmbed);
}
public class Microsoft.Build.Logging.StructuredLogger.BinaryLogReaderErrorEventArgs : EventArgs {
    private FormatErrorMessage _formatErrorMessage;
    [CompilerGeneratedAttribute]
private ReaderErrorType <ErrorType>k__BackingField;
    [CompilerGeneratedAttribute]
private BinaryLogRecordKind <RecordKind>k__BackingField;
    public ReaderErrorType ErrorType { get; }
    public BinaryLogRecordKind RecordKind { get; }
    internal BinaryLogReaderErrorEventArgs(ReaderErrorType errorType, BinaryLogRecordKind recordKind, FormatErrorMessage formatErrorMessage);
    [CompilerGeneratedAttribute]
public ReaderErrorType get_ErrorType();
    [CompilerGeneratedAttribute]
public BinaryLogRecordKind get_RecordKind();
    public string GetFormattedMessage();
}
public enum Microsoft.Build.Logging.StructuredLogger.BinaryLogRecordKind : Enum {
    public int value__;
    public static BinaryLogRecordKind EndOfFile;
    public static BinaryLogRecordKind BuildStarted;
    public static BinaryLogRecordKind BuildFinished;
    public static BinaryLogRecordKind ProjectStarted;
    public static BinaryLogRecordKind ProjectFinished;
    public static BinaryLogRecordKind TargetStarted;
    public static BinaryLogRecordKind TargetFinished;
    public static BinaryLogRecordKind TaskStarted;
    public static BinaryLogRecordKind TaskFinished;
    public static BinaryLogRecordKind Error;
    public static BinaryLogRecordKind Warning;
    public static BinaryLogRecordKind Message;
    public static BinaryLogRecordKind TaskCommandLine;
    public static BinaryLogRecordKind CriticalBuildMessage;
    public static BinaryLogRecordKind ProjectEvaluationStarted;
    public static BinaryLogRecordKind ProjectEvaluationFinished;
    public static BinaryLogRecordKind ProjectImported;
    public static BinaryLogRecordKind ProjectImportArchive;
    public static BinaryLogRecordKind TargetSkipped;
    public static BinaryLogRecordKind PropertyReassignment;
    public static BinaryLogRecordKind UninitializedPropertyRead;
    public static BinaryLogRecordKind EnvironmentVariableRead;
    public static BinaryLogRecordKind PropertyInitialValueSet;
    public static BinaryLogRecordKind NameValueList;
    public static BinaryLogRecordKind String;
    public static BinaryLogRecordKind TaskParameter;
    public static BinaryLogRecordKind FileUsed;
    public static BinaryLogRecordKind AssemblyLoad;
    public static BinaryLogRecordKind BuildCheckMessage;
    public static BinaryLogRecordKind BuildCheckWarning;
    public static BinaryLogRecordKind BuildCheckError;
    public static BinaryLogRecordKind BuildCheckTracing;
    public static BinaryLogRecordKind BuildCheckAcquisition;
    public static BinaryLogRecordKind BuildSubmissionStarted;
}
internal class Microsoft.Build.Logging.StructuredLogger.BinaryLogReplayEventSource : EventArgsDispatcher {
    private Nullable`1<int> _fileFormatVersion;
    private Nullable`1<int> _minimumReaderVersion;
    [CompilerGeneratedAttribute]
private bool <AllowForwardCompatibility>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Action`1<BinaryLogReaderErrorEventArgs> RecoverableReadError;
    [NullableAttribute("2")]
private Action _onRawReadingPossible;
    [NullableAttribute("2")]
private Action _onStructuredReadingOnly;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Action`1<EmbeddedContentEventArgs> _embeddedContentRead;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Action`1<ArchiveFileEventArgs> _archiveFileEncountered;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Action`1<StringReadEventArgs> _stringReadDone;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Action`2<BinaryLogRecordKind, Stream> _rawLogRecordReceived;
    public int FileFormatVersion { get; }
    public int MinimumReaderVersion { get; }
    private bool AllowForwardCompatibility { get; public set; }
    public sealed virtual int get_FileFormatVersion();
    public sealed virtual int get_MinimumReaderVersion();
    [CompilerGeneratedAttribute]
private bool get_AllowForwardCompatibility();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_AllowForwardCompatibility(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_RecoverableReadError(Action`1<BinaryLogReaderErrorEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_RecoverableReadError(Action`1<BinaryLogReaderErrorEventArgs> value);
    public void Replay(string sourceFilePath);
    public void Replay(Stream sourceFileStream, CancellationToken cancellationToken);
    public static BinaryReader OpenReader(string sourceFilePath);
    public static BinaryReader OpenReader(Stream sourceFileStream);
    public static BuildEventArgsReader OpenBuildEventsReader(BinaryReader binaryReader, bool closeInput, bool allowForwardCompatibility);
    public static BuildEventArgsReader OpenBuildEventsReader(string sourceFilePath);
    public void Replay(string sourceFilePath, CancellationToken cancellationToken);
    public void Replay(BinaryReader binaryReader, CancellationToken cancellationToken);
    public void Replay(BinaryReader binaryReader, bool closeInput, CancellationToken cancellationToken);
    public void Replay(BuildEventArgsReader reader, CancellationToken cancellationToken);
    private sealed virtual override void Microsoft.Build.Logging.StructuredLogger.IBinaryLogReplaySource.DeferredInitialize(Action onRawReadingPossible, Action onStructuredReadingOnly);
    private sealed virtual override void Microsoft.Build.Logging.StructuredLogger.IBinaryLogReplaySource.add_EmbeddedContentRead(Action`1<EmbeddedContentEventArgs> value);
    private sealed virtual override void Microsoft.Build.Logging.StructuredLogger.IBinaryLogReplaySource.remove_EmbeddedContentRead(Action`1<EmbeddedContentEventArgs> value);
    private sealed virtual override void Microsoft.Build.Logging.StructuredLogger.IBuildEventArgsReaderNotifications.add_ArchiveFileEncountered(Action`1<ArchiveFileEventArgs> value);
    private sealed virtual override void Microsoft.Build.Logging.StructuredLogger.IBuildEventArgsReaderNotifications.remove_ArchiveFileEncountered(Action`1<ArchiveFileEventArgs> value);
    private sealed virtual override void Microsoft.Build.Logging.StructuredLogger.IBuildEventArgsReaderNotifications.add_StringReadDone(Action`1<StringReadEventArgs> value);
    private sealed virtual override void Microsoft.Build.Logging.StructuredLogger.IBuildEventArgsReaderNotifications.remove_StringReadDone(Action`1<StringReadEventArgs> value);
    private sealed virtual override void Microsoft.Build.Logging.StructuredLogger.IBinaryLogReplaySource.add_RawLogRecordReceived(Action`2<BinaryLogRecordKind, Stream> value);
    private sealed virtual override void Microsoft.Build.Logging.StructuredLogger.IBinaryLogReplaySource.remove_RawLogRecordReceived(Action`2<BinaryLogRecordKind, Stream> value);
}
public class Microsoft.Build.Logging.StructuredLogger.BinLogReader : EventArgsDispatcher {
    [CompilerGeneratedAttribute]
private Action`2<BinaryLogRecordKind, Byte[]> OnBlobRead;
    [CompilerGeneratedAttribute]
private Action`2<string, long> OnStringRead;
    [CompilerGeneratedAttribute]
private Action`2<IDictionary`2<string, string>, long> OnNameValueListRead;
    [CompilerGeneratedAttribute]
private Action`1<int> OnFileFormatVersionRead;
    [CompilerGeneratedAttribute]
private Action`1<IEnumerable`1<string>> OnStringDictionaryComplete;
    [CompilerGeneratedAttribute]
private Action`1<Exception> OnException;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Action`1<BinaryLogReaderErrorEventArgs> RecoverableReadError;
    [CompilerGeneratedAttribute]
public void add_OnBlobRead(Action`2<BinaryLogRecordKind, Byte[]> value);
    [CompilerGeneratedAttribute]
public void remove_OnBlobRead(Action`2<BinaryLogRecordKind, Byte[]> value);
    [CompilerGeneratedAttribute]
public void add_OnStringRead(Action`2<string, long> value);
    [CompilerGeneratedAttribute]
public void remove_OnStringRead(Action`2<string, long> value);
    [CompilerGeneratedAttribute]
public void add_OnNameValueListRead(Action`2<IDictionary`2<string, string>, long> value);
    [CompilerGeneratedAttribute]
public void remove_OnNameValueListRead(Action`2<IDictionary`2<string, string>, long> value);
    [CompilerGeneratedAttribute]
public void add_OnFileFormatVersionRead(Action`1<int> value);
    [CompilerGeneratedAttribute]
public void remove_OnFileFormatVersionRead(Action`1<int> value);
    [CompilerGeneratedAttribute]
public void add_OnStringDictionaryComplete(Action`1<IEnumerable`1<string>> value);
    [CompilerGeneratedAttribute]
public void remove_OnStringDictionaryComplete(Action`1<IEnumerable`1<string>> value);
    [CompilerGeneratedAttribute]
public void add_OnException(Action`1<Exception> value);
    [CompilerGeneratedAttribute]
public void remove_OnException(Action`1<Exception> value);
    [CompilerGeneratedAttribute]
public void add_RecoverableReadError(Action`1<BinaryLogReaderErrorEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_RecoverableReadError(Action`1<BinaryLogReaderErrorEventArgs> value);
    public void Replay(string sourceFilePath);
    public void Replay(string sourceFilePath, Progress progress);
    public void Replay(Stream stream);
    public void Replay(Stream stream, Progress progress);
    private BuildEventArgsReader OpenReader(BinaryReader binaryReader);
    private void EnsureFileFormatVersionKnown(int fileFormatVersion, int minimumReaderVersion);
    public IEnumerable`1<Record> ReadRecords(string logFilePath);
    public IEnumerable`1<RecordInfo> ChunkBinlog(string logFilePath);
    public IEnumerable`1<Record> ReadRecords(Byte[] bytes);
    public IEnumerable`1<Record> ReadRecords(Stream binaryLogStream);
    private static Stream GetDecompressedStream(Stream binaryLogStream);
    private IEnumerable`1<RecordInfo> ChunkBinlogFromDecompressedStream(Stream decompressedStream);
    [IteratorStateMachineAttribute("Microsoft.Build.Logging.StructuredLogger.BinLogReader/<ChunkBinlogWithOffsets>d__34")]
private IEnumerable`1<RecordInfo> ChunkBinlogWithOffsets(BuildEventArgsReader reader);
    public static BinaryLogRecordKind ToBinaryLogRecordKind(BuildEventArgs args);
    public IEnumerable`1<Record> ReadRecordsFromDecompressedStream(Stream decompressedStream);
    public IEnumerable`1<Record> ReadRecordsFromDecompressedStream(Stream decompressedStream, bool includeAuxiliaryRecords);
    [IteratorStateMachineAttribute("Microsoft.Build.Logging.StructuredLogger.BinLogReader/<ReadRecordsFromDecompressedStream>d__38")]
internal IEnumerable`1<Record> ReadRecordsFromDecompressedStream(BuildEventArgsReader reader, bool includeAuxiliaryRecords);
}
public class Microsoft.Build.Logging.StructuredLogger.BinlogStats : object {
    private static bool TrackStrings;
    private static bool Sort;
    public long FileSize;
    public long UncompressedStreamSize;
    public long RecordCount;
    public int NameValueListCount;
    public long NameValueListTotalSize;
    public int NameValueListLargest;
    public int StringCount;
    public long StringTotalSize;
    public int StringLargest;
    public int BlobCount;
    public int BlobTotalSize;
    public int BlobLargest;
    public List`1<int> StringSizes;
    public List`1<string> AllStrings;
    [CompilerGeneratedAttribute]
private RecordsByType <CategorizedRecords>k__BackingField;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<ValueTuple`2<int, int>, string> targetNamesById;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<ValueTuple`2<int, int>, string> taskNamesById;
    public RecordsByType CategorizedRecords { get; private set; }
    private static BinlogStats();
    public static BinlogStats Calculate(string binlogFilePath);
    private void OnNameValueListRead(IDictionary`2<string, string> list, long recordLengthBytes);
    private void OnStringRead(string text, long lengthInBytes);
    private void OnBlobRead(BinaryLogRecordKind kind, Byte[] bytes);
    [CompilerGeneratedAttribute]
public RecordsByType get_CategorizedRecords();
    [CompilerGeneratedAttribute]
private void set_CategorizedRecords(RecordsByType value);
    public static string GetString(string name, long total, int count, int largest);
    private void Process(IEnumerable`1<Record> records);
    private string GetSubType(string message, BuildEventArgs args);
    private string GetTaskParameterSubType(string message, TaskParameterEventArgs args);
    private static string GetMessageSubType(string message, BuildEventArgs args);
}
public class Microsoft.Build.Logging.StructuredLogger.Build : TimedNode {
    [CompilerGeneratedAttribute]
private StringCache <StringTable>k__BackingField;
    [CompilerGeneratedAttribute]
private SearchIndex <SearchIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<ISearchExtension> <SearchExtensions>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsAnalyzed>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Succeeded>k__BackingField;
    [CompilerGeneratedAttribute]
private Error <FirstError>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LogFilePath>k__BackingField;
    [CompilerGeneratedAttribute]
private int <FileFormatVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <SourceFilesArchive>k__BackingField;
    private List`1<Task> backgroundTasks;
    private IReadOnlyList`1<ArchiveFile> sourceFiles;
    private string msbuildVersion;
    private string msbuildExecutablePath;
    private Version version;
    private NamedNode evaluationFolder;
    private Folder environmentFolder;
    [CompilerGeneratedAttribute]
private static string <IgnoreEmbeddedFiles>k__BackingField;
    [CompilerGeneratedAttribute]
private BuildStatistics <Statistics>k__BackingField;
    [CompilerGeneratedAttribute]
private FileCopyMap <FileCopyMap>k__BackingField;
    [CompilerGeneratedAttribute]
private ProjectReferenceGraph <ProjectReferenceGraph>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, HashSet`1<string>> <TaskAssemblies>k__BackingField;
    private Dictionary`2<int, ProjectEvaluation> evaluationById;
    public StringCache StringTable { get; }
    public SearchIndex SearchIndex { get; public set; }
    public IList`1<ISearchExtension> SearchExtensions { get; }
    public bool IsAnalyzed { get; public set; }
    public bool Succeeded { get; public set; }
    public Error FirstError { get; public set; }
    public string LogFilePath { get; public set; }
    public int FileFormatVersion { get; public set; }
    public Byte[] SourceFilesArchive { get; public set; }
    public IReadOnlyList`1<ArchiveFile> SourceFiles { get; }
    public string MSBuildVersion { get; public set; }
    public string MSBuildExecutablePath { get; public set; }
    public NamedNode EvaluationFolder { get; }
    public Folder EnvironmentFolder { get; }
    public static string IgnoreEmbeddedFiles { get; public set; }
    public BuildStatistics Statistics { get; public set; }
    public FileCopyMap FileCopyMap { get; public set; }
    public ProjectReferenceGraph ProjectReferenceGraph { get; public set; }
    public Dictionary`2<string, HashSet`1<string>> TaskAssemblies { get; }
    public string TypeName { get; }
    [CompilerGeneratedAttribute]
public StringCache get_StringTable();
    [CompilerGeneratedAttribute]
public SearchIndex get_SearchIndex();
    [CompilerGeneratedAttribute]
public void set_SearchIndex(SearchIndex value);
    [CompilerGeneratedAttribute]
public IList`1<ISearchExtension> get_SearchExtensions();
    [CompilerGeneratedAttribute]
public bool get_IsAnalyzed();
    [CompilerGeneratedAttribute]
public void set_IsAnalyzed(bool value);
    [CompilerGeneratedAttribute]
public bool get_Succeeded();
    [CompilerGeneratedAttribute]
public void set_Succeeded(bool value);
    [CompilerGeneratedAttribute]
public Error get_FirstError();
    [CompilerGeneratedAttribute]
public void set_FirstError(Error value);
    [CompilerGeneratedAttribute]
public string get_LogFilePath();
    [CompilerGeneratedAttribute]
public void set_LogFilePath(string value);
    [CompilerGeneratedAttribute]
public int get_FileFormatVersion();
    [CompilerGeneratedAttribute]
public void set_FileFormatVersion(int value);
    [CompilerGeneratedAttribute]
public Byte[] get_SourceFilesArchive();
    [CompilerGeneratedAttribute]
public void set_SourceFilesArchive(Byte[] value);
    public IReadOnlyList`1<ArchiveFile> get_SourceFiles();
    public string get_MSBuildVersion();
    public void set_MSBuildVersion(string value);
    public string get_MSBuildExecutablePath();
    public void set_MSBuildExecutablePath(string value);
    private void ParseMSBuildVersion();
    public bool IsMSBuildVersionAtLeast(int major, int minor);
    public NamedNode get_EvaluationFolder();
    public Folder get_EnvironmentFolder();
    public static IReadOnlyList`1<ArchiveFile> ReadSourceFiles(Byte[] sourceFilesArchive);
    public static IReadOnlyList`1<ArchiveFile> ReadSourceFiles(string zipFullPath);
    [CompilerGeneratedAttribute]
public static string get_IgnoreEmbeddedFiles();
    [CompilerGeneratedAttribute]
public static void set_IgnoreEmbeddedFiles(string value);
    public static IReadOnlyList`1<ArchiveFile> ReadSourceFiles(Stream stream);
    [CompilerGeneratedAttribute]
public BuildStatistics get_Statistics();
    [CompilerGeneratedAttribute]
public void set_Statistics(BuildStatistics value);
    [CompilerGeneratedAttribute]
public FileCopyMap get_FileCopyMap();
    [CompilerGeneratedAttribute]
public void set_FileCopyMap(FileCopyMap value);
    [CompilerGeneratedAttribute]
public ProjectReferenceGraph get_ProjectReferenceGraph();
    [CompilerGeneratedAttribute]
public void set_ProjectReferenceGraph(ProjectReferenceGraph value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, HashSet`1<string>> get_TaskAssemblies();
    public void RegisterTask(Task task);
    public virtual string get_TypeName();
    public virtual string ToString();
    public TreeNode FindDescendant(int index);
    public ProjectEvaluation FindEvaluation(int id);
    public void RunInBackground(Action action);
    public void WaitForBackgroundTasks();
}
public class Microsoft.Build.Logging.StructuredLogger.BuildAnalyzer : object {
    private Build build;
    private DoubleWritesAnalyzer doubleWritesAnalyzer;
    private FileCopyMap fileCopyMap;
    private ProjectReferenceGraph projectReferenceGraph;
    private ResolveAssemblyReferenceAnalyzer resolveAssemblyReferenceAnalyzer;
    private CppAnalyzer cppAnalyzer;
    private Dictionary`2<string, TaskStatistic> taskDurations;
    private List`1<Folder> analyzerReports;
    private List`1<Folder> generatorReports;
    private int index;
    public BuildAnalyzer(Build build);
    public static void AnalyzeBuild(Build build);
    private static void SealAndCalculateIndices(Build build);
    private void Analyze();
    private void Visit(TreeNode node);
    private void ProcessBeforeChildrenVisited(TreeNode node);
    private void ProcessAfterChildrenVisited(TreeNode node);
    private void AnalyzeEnvironment(NamedNode folder);
    private void AnalyzeEvaluation(NamedNode folder);
    private void PostAnalyzeBuild(Build build);
    private void PostAnalyzeProject(Project project);
    private void AnalyzeTask(Task task);
    private void CollapseMessagesToSubfolder(Task task);
    private void UpdateTaskDurations(Task task);
    private void AnalyzeTarget(Target target);
    private static void AddDependsOnTargets(Target target);
    private void MarkAsLowRelevanceIfNeeded(Target target);
    public IEnumerable`1<Project> GetProjectsSortedTopologically(Build build);
    private void Visit(Project project, List`1<Project> list, HashSet`1<string> visited);
    [CompilerGeneratedAttribute]
internal static string <PostAnalyzeBuild>g__Intern|21_0(string text);
}
public class Microsoft.Build.Logging.StructuredLogger.BuildError : Error {
    public string TypeName { get; }
    public virtual string get_TypeName();
}
internal class Microsoft.Build.Logging.StructuredLogger.BuildEventArgsReader : object {
    private BinaryReader _binaryReader;
    private TransparentReadStream _readStream;
    private int _fileFormatVersion;
    private long _recordNumber;
    private bool _skipUnknownEvents;
    private bool _skipUnknownEventParts;
    private List`1<object> stringRecords;
    private List`1<NameValueRecord> nameValueListRecords;
    private StringStorage stringStorage;
    [CompilerGeneratedAttribute]
private bool <CloseInput>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Action`1<BinaryLogReaderErrorEventArgs> RecoverableReadError;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Action`1<StringReadEventArgs> StringReadDone;
    [CompilerGeneratedAttribute]
private int <MinimumReaderVersion>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Action`1<EmbeddedContentEventArgs> EmbeddedContentRead;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Action`1<ArchiveFileEventArgs> ArchiveFileEncountered;
    [CompilerGeneratedAttribute]
private Action`2<BinaryLogRecordKind, Byte[]> OnBlobRead;
    [NullableAttribute("2")]
private SubStream _lastSubStream;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<ValueTuple`2<int, int>> nameValues;
    private BuildEventArgsFields fields;
    private StringReadEventArgs stringReadEventArgs;
    [CompilerGeneratedAttribute]
private Action`1<string> OnStringRead;
    [CompilerGeneratedAttribute]
private Action`1<IDictionary`2<string, string>> OnNameValueListRead;
    private Dictionary`2<ValueTuple`4<string, string, string, string>, string> propertyReassignmentCache;
    private bool sawCulture;
    private bool CloseInput { get; public set; }
    public long Position { get; }
    unknown bool SkipUnknownEvents {public set; }
    unknown bool SkipUnknownEventParts {public set; }
    internal int FileFormatVersion { get; }
    internal int MinimumReaderVersion { get; internal set; }
    public BuildEventArgsReader(BinaryReader binaryReader, int fileFormatVersion);
    [CompilerGeneratedAttribute]
private bool get_CloseInput();
    [CompilerGeneratedAttribute]
public void set_CloseInput(bool value);
    public long get_Position();
    public void set_SkipUnknownEvents(bool value);
    public void set_SkipUnknownEventParts(bool value);
    private void EnsureForwardCompatibleReadingSupported();
    [CompilerGeneratedAttribute]
public sealed virtual void add_RecoverableReadError(Action`1<BinaryLogReaderErrorEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_RecoverableReadError(Action`1<BinaryLogReaderErrorEventArgs> value);
    public sealed virtual void Dispose();
    [CompilerGeneratedAttribute]
public sealed virtual void add_StringReadDone(Action`1<StringReadEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_StringReadDone(Action`1<StringReadEventArgs> value);
    internal int get_FileFormatVersion();
    [CompilerGeneratedAttribute]
internal int get_MinimumReaderVersion();
    [CompilerGeneratedAttribute]
internal void set_MinimumReaderVersion(int value);
    [CompilerGeneratedAttribute]
internal void add_EmbeddedContentRead(Action`1<EmbeddedContentEventArgs> value);
    [CompilerGeneratedAttribute]
internal void remove_EmbeddedContentRead(Action`1<EmbeddedContentEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_ArchiveFileEncountered(Action`1<ArchiveFileEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_ArchiveFileEncountered(Action`1<ArchiveFileEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_OnBlobRead(Action`2<BinaryLogRecordKind, Byte[]> value);
    [CompilerGeneratedAttribute]
public void remove_OnBlobRead(Action`2<BinaryLogRecordKind, Byte[]> value);
    internal RawRecord ReadRaw();
    internal RawRecord ReadRaw(bool decodeTextualRecords);
    private void CheckErrorsSubscribed();
    [NullableContextAttribute("2")]
public BuildEventArgs Read();
    [NullableContextAttribute("2")]
private BuildEventArgs ReadBuildEventArgs(BinaryLogRecordKind recordKind);
    private void SkipBytes(int count);
    private BinaryLogRecordKind PreprocessRecordsTillNextEvent(Func`2<BinaryLogRecordKind, bool> isPreprocessRecord);
    private static bool IsAuxiliaryRecord(BinaryLogRecordKind recordKind);
    private static bool IsTextualDataRecord(BinaryLogRecordKind recordKind);
    private void ReadEmbeddedContent(BinaryLogRecordKind kind);
    private void InvokeEmbeddedDataListeners(BinaryLogRecordKind kind, Stream embeddedStream);
    private Stream SliceOfEmdeddedContent(bool canHaveCorruptedSize);
    private void ReadNameValueList();
    private IDictionary`2<string, string> GetNameValueList(int id);
    private void ReadStringRecord();
    private BuildEventArgs ReadProjectImportedEventArgs();
    private BuildEventArgs ReadTargetSkippedEventArgs();
    private BuildEventArgs ReadBuildStartedEventArgs();
    private BuildEventArgs ReadBuildFinishedEventArgs();
    private BuildEventArgs ReadProjectEvaluationStartedEventArgs();
    private BuildEventArgs ReadProjectEvaluationFinishedEventArgs();
    private BuildEventArgs ReadProjectStartedEventArgs();
    private BuildEventArgs ReadProjectFinishedEventArgs();
    private BuildEventArgs ReadTargetStartedEventArgs();
    private BuildEventArgs ReadTargetFinishedEventArgs();
    private BuildEventArgs ReadTaskStartedEventArgs();
    private BuildEventArgs ReadTaskFinishedEventArgs();
    private BuildEventArgs ReadBuildErrorEventArgs();
    private BuildEventArgs ReadBuildWarningEventArgs();
    private BuildEventArgs ReadBuildCheckMessageEventArgs();
    private BuildEventArgs ReadBuildMessageEventArgs();
    private BuildEventArgs ReadTaskCommandLineEventArgs();
    private BuildEventArgs ReadTaskParameterEventArgs();
    private BuildEventArgs ReadCriticalBuildMessageEventArgs();
    private BuildEventArgs ReadEnvironmentVariableReadEventArgs();
    private BuildEventArgs ReadBuildCheckTracingEventArgs();
    private BuildEventArgs ReadBuildCheckAcquisitionEventArgs();
    private BuildEventArgs ReadBuildSubmissionStartedEventArgs();
    private BuildEventArgs ReadFileUsedEventArgs();
    private BuildEventArgs ReadAssemblyLoadEventArgs();
    private BuildEventArgs ReadPropertyReassignmentEventArgs();
    private BuildEventArgs ReadUninitializedPropertyReadEventArgs();
    private BuildEventArgs ReadPropertyInitialValueSetEventArgs();
    private void ReadDiagnosticFields(BuildEventArgsFields fields);
    [NullableContextAttribute("2")]
private ExtendedDataFields ReadExtendedDataFields();
    private BuildEventArgsFields ReadBuildEventArgsFields(bool readImportance);
    private void SetCommonFields(BuildEventArgs buildEventArgs, BuildEventArgsFields fields);
    private IDictionary`2<string, string> ReadPropertyList();
    private BuildEventContext ReadBuildEventContext();
    private IDictionary`2<string, string> ReadStringDictionary();
    private Dictionary`2<string, string> ReadLegacyStringDictionary();
    private ITaskItem ReadTaskItem();
    private IList`1<DictionaryEntry> ReadProjectItems();
    private String[] ReadStringList();
    private ITaskItem[] ReadTaskItemList();
    private string ReadString();
    private string ReadOptionalString();
    private string ReadDeduplicatedString();
    private string GetStringFromRecord(int index);
    private int ReadInt32();
    private long ReadInt64();
    private bool ReadBoolean();
    private Guid ReadGuid();
    private DateTime ReadDateTime();
    private TimeSpan ReadTimeSpan();
    private ProfiledLocation ReadProfiledLocation();
    private EvaluationLocation ReadEvaluationLocation();
    [CompilerGeneratedAttribute]
public void add_OnStringRead(Action`1<string> value);
    [CompilerGeneratedAttribute]
public void remove_OnStringRead(Action`1<string> value);
    [CompilerGeneratedAttribute]
public void add_OnNameValueListRead(Action`1<IDictionary`2<string, string>> value);
    [CompilerGeneratedAttribute]
public void remove_OnNameValueListRead(Action`1<IDictionary`2<string, string>> value);
    public IEnumerable`1<string> GetStrings();
    private ArrayDictionary`2<string, string> CreateDictionary(List`1<ValueTuple`2<int, int>> list);
    private string GetProjectStartedMessage(string projectFile, string targetNames);
    private string GetProjectFinishedMessage(bool succeeded, string projectFile);
    private string GetPropertyReassignmentMessage(string propertyName, string newValue, string previousValue, string location);
    private BuildEventArgs SynthesizePropertyReassignment(BuildEventArgsFields fields);
    private void OnMessageRead(BuildMessageEventArgs args);
    private string GetTargetStartedMessage(string projectFile, string targetFile, string parentTarget, string targetName);
    private string GetTargetFinishedMessage(string projectFile, string targetName, bool succeeded);
    private string GetTargetSkippedMessage(TargetSkipReason skipReason, string targetName, string condition, string evaluatedCondition, bool originallySucceeded);
    private string GetTaskStartedMessage(string taskName);
    private string GetTaskFinishedMessage(bool succeeded, string taskName);
    internal static string FormatResourceStringIgnoreCodeAndKeyword(string resource, string arg0);
    internal static string FormatResourceStringIgnoreCodeAndKeyword(string resource, string arg0, string arg1);
    internal static string FormatResourceStringIgnoreCodeAndKeyword(string resource, string arg0, string arg1, string arg2);
    internal static string FormatResourceStringIgnoreCodeAndKeyword(string resource, String[] arguments);
    [CompilerGeneratedAttribute]
private void <Read>g__HandleError|48_0(FormatErrorMessage msgFactory, bool noThrow, ReaderErrorType readerErrorType, BinaryLogRecordKind recordKind, Exception innerException);
}
internal class Microsoft.Build.Logging.StructuredLogger.BuildEventArgsWriter : object {
    private Stream originalStream;
    private MemoryStream currentRecordStream;
    private MemoryStream nameValueListStream;
    private BinaryWriter originalBinaryWriter;
    private BinaryWriter currentRecordWriter;
    private BinaryWriter binaryWriter;
    private Dictionary`2<HashKey, int> stringHashes;
    private Dictionary`2<HashKey, int> nameValueListHashes;
    internal static int StringStartIndex;
    internal static int NameValueRecordStartIndex;
    private int stringRecordId;
    private int nameValueRecordId;
    private List`1<KeyValuePair`2<string, string>> nameValueListBuffer;
    private List`1<KeyValuePair`2<int, int>> nameValueIndexListBuffer;
    [CompilerGeneratedAttribute]
private Action`1<string> EmbedFile;
    private List`1<object> reusableItemsList;
    private List`1<object> reusableProjectItemList;
    public BuildEventArgsWriter(BinaryWriter binaryWriter);
    [CompilerGeneratedAttribute]
public void add_EmbedFile(Action`1<string> value);
    [CompilerGeneratedAttribute]
public void remove_EmbedFile(Action`1<string> value);
    public void Write(BuildEventArgs e);
    private void FlushRecordToFinalStream(BinaryLogRecordKind recordKind, MemoryStream recordStream);
    private BinaryLogRecordKind WriteCore(BuildEventArgs e);
    public void WriteBlob(BinaryLogRecordKind kind, Stream stream);
    private IDisposable RedirectWritesToOriginalWriter();
    private IDisposable RedirectWritesToDifferentWriter(BinaryWriter inScopeWriter, BinaryWriter afterScopeWriter);
    private BinaryLogRecordKind Write(BuildStartedEventArgs e);
    private static bool IsWellKnownEnvironmentDerivedProperty(string propertyName);
    private BinaryLogRecordKind Write(BuildFinishedEventArgs e);
    private BinaryLogRecordKind Write(ProjectEvaluationStartedEventArgs e);
    private BinaryLogRecordKind Write(BuildCheckTracingEventArgs e);
    private BinaryLogRecordKind Write(BuildCheckAcquisitionEventArgs e);
    private BinaryLogRecordKind Write(BuildSubmissionStartedEvent e);
    private BinaryLogRecordKind Write(ProjectEvaluationFinishedEventArgs e);
    private BinaryLogRecordKind Write(ProjectStartedEventArgs e);
    private BinaryLogRecordKind Write(ProjectFinishedEventArgs e);
    private BinaryLogRecordKind Write(TargetStartedEventArgs e);
    private BinaryLogRecordKind Write(TargetFinishedEventArgs e);
    private BinaryLogRecordKind Write(TaskStartedEventArgs e);
    private BinaryLogRecordKind Write(TaskFinishedEventArgs e);
    private BinaryLogRecordKind Write(BuildErrorEventArgs e);
    private BinaryLogRecordKind Write(BuildWarningEventArgs e);
    private BinaryLogRecordKind Write(BuildMessageEventArgs e);
    private BinaryLogRecordKind Write(ProjectImportedEventArgs e);
    private BinaryLogRecordKind Write(TargetSkippedEventArgs e);
    private BinaryLogRecordKind Write(AssemblyLoadBuildEventArgs e);
    private BinaryLogRecordKind Write(CriticalBuildMessageEventArgs e);
    private BinaryLogRecordKind Write(PropertyReassignmentEventArgs e);
    private BinaryLogRecordKind Write(UninitializedPropertyReadEventArgs e);
    private BinaryLogRecordKind Write(PropertyInitialValueSetEventArgs e);
    private BinaryLogRecordKind Write(EnvironmentVariableReadEventArgs e);
    private BinaryLogRecordKind Write(FileUsedEventArgs e);
    private BinaryLogRecordKind Write(TaskCommandLineEventArgs e);
    private BinaryLogRecordKind Write(TaskParameterEventArgs e);
    private void WriteBuildEventArgsFields(BuildEventArgs e, bool writeMessage, bool writeLineAndColumn);
    private void WriteBaseFields(BuildEventArgs e, BuildEventArgsFieldFlags flags);
    private void WriteMessageFields(BuildMessageEventArgs e, bool writeMessage, bool writeImportance);
    private void WriteArguments(Object[] arguments);
    private static BuildEventArgsFieldFlags GetMessageFlags(BuildMessageEventArgs e, BuildEventArgsFieldFlags flags, bool writeImportance);
    private static BuildEventArgsFieldFlags GetBuildEventArgsFieldFlags(BuildEventArgs e, bool writeMessage);
    private void WriteTaskItemList(IEnumerable items, bool writeMetadata);
    private void WriteProjectItems(IEnumerable items);
    private void CheckForFilesToEmbed(string itemType, object itemList);
    private void Write(ITaskItem item, bool writeMetadata);
    private void WriteProperties(IEnumerable properties);
    private void Write(BuildEventContext buildEventContext);
    private void Write(IEnumerable`1<KeyValuePair`2<string, string>> keyValuePairs);
    private void WriteNameValueList();
    private void WriteNameValueListRecord();
    private HashKey HashAllStrings(List`1<KeyValuePair`2<string, string>> nameValueList);
    internal void Write(BinaryLogRecordKind kind);
    private void Write(int value);
    private void Write(long value);
    private void Write(Byte[] bytes);
    private void WriteStringList(IEnumerable`1<string> items);
    private void WriteToOriginalStream(Stream stream);
    private void Write(byte b);
    private void Write(bool boolean);
    private void Write(Guid guid);
    private void WriteDeduplicatedString(string text);
    private ValueTuple`2<int, HashKey> HashString(string text);
    internal void WriteStringRecord(string text);
    private void Write(DateTime timestamp);
    private void Write(TimeSpan timeSpan);
    private void Write(EvaluationLocation item);
    private void Write(ProfiledLocation e);
    private void Write(IExtendedBuildEventArgs extendedData);
    [CompilerGeneratedAttribute]
private void <WriteProjectItems>g__WriteItems|61_0(string itemType, object itemList);
    [CompilerGeneratedAttribute]
private void <WriteProperties>b__64_0(KeyValuePair`2<string, string> kvp);
}
public class Microsoft.Build.Logging.StructuredLogger.BuildLogReader : object {
    private TreeBinaryReader reader;
    private Queue`1<string> attributes;
    private bool formatSupportsSourceFiles;
    private bool formatSupportsEmbeddedProjectImportsArchive;
    private bool formatSupportsTimedNodeId;
    private bool formatIsValid;
    private BuildLogReader(string filePath);
    private BuildLogReader(Stream stream, Version version);
    public static Build Read(string filePath);
    public static Build Read(Stream stream, Byte[] projectImportsArchive);
    public static Build Read(Stream stream, Byte[] projectImportsArchive, Version version);
    private BaseNode ReadNode();
    private string Dequeue();
    private void SetAttributes(BaseNode node);
    public sealed virtual void Dispose();
}
public class Microsoft.Build.Logging.StructuredLogger.BuildLogWriter : object {
    private string filePath;
    private TreeBinaryWriter writer;
    private BuildLogWriter(string filePath);
    public static void Write(Build build, string filePath);
    private void WriteNode(BaseNode node);
    private void WriteChildren(BaseNode node);
    private void WriteAttributes(BaseNode node);
    private void SetString(string name, string value);
    private void AddStartAndEndTime(TimedNode node);
    private string ToString(DateTime time);
    public sealed virtual void Dispose();
}
public class Microsoft.Build.Logging.StructuredLogger.BuildStatistics : object {
    public int Tasks;
    public Dictionary`2<string, List`1<string>> TaskParameterMessagesByTask;
    public Dictionary`2<string, List`1<string>> OutputItemMessagesByTask;
    [CompilerGeneratedAttribute]
private int <TimedNodeCount>k__BackingField;
    public int TimedNodeCount { get; public set; }
    [CompilerGeneratedAttribute]
public int get_TimedNodeCount();
    [CompilerGeneratedAttribute]
public void set_TimedNodeCount(int value);
    public void ReportTaskParameterMessage(Task task, string message);
    public void ReportOutputItemMessage(Task task, string message);
    public void Add(string key, string value, Dictionary`2<string, List`1<string>> dictionary);
}
public class Microsoft.Build.Logging.StructuredLogger.CacheByNameChildrenList : ChildrenList {
    private Dictionary`2<ChildrenCacheKey, BaseNode> childrenCache;
    public CacheByNameChildrenList(int capacity);
    public CacheByNameChildrenList(IEnumerable`1<BaseNode> children);
    public virtual T FindNode(string name);
    private void EnsureCacheCreated();
}
public class Microsoft.Build.Logging.StructuredLogger.ChildrenList : List`1<BaseNode> {
    [CompilerGeneratedAttribute]
private NotifyCollectionChangedEventHandler CollectionChanged;
    public ChildrenList(int capacity);
    public ChildrenList(IEnumerable`1<BaseNode> children);
    [CompilerGeneratedAttribute]
public sealed virtual void add_CollectionChanged(NotifyCollectionChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_CollectionChanged(NotifyCollectionChangedEventHandler value);
    public void RaiseCollectionChanged();
    public virtual T FindNode(string name);
    public void EnsureCapacity(int capacity);
}
public class Microsoft.Build.Logging.StructuredLogger.ChunkedList`1 : object {
    [CompilerGeneratedAttribute]
private int <ChunkSize>k__BackingField;
    private List`1<List`1<T>> chunks;
    public int ChunkSize { get; }
    public int Count { get; }
    public IList`1<List`1<T>> Chunks { get; }
    public ChunkedList`1(int chunkSize);
    [CompilerGeneratedAttribute]
public int get_ChunkSize();
    public void Add(T item);
    private void AddChunk();
    public int get_Count();
    public IList`1<List`1<T>> get_Chunks();
    public virtual string ToString();
}
[IsReadOnlyAttribute]
public class Microsoft.Build.Logging.StructuredLogger.CompilationWrites : ValueType {
    [CompilerGeneratedAttribute]
private string <Assembly>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RefAssembly>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Pdb>k__BackingField;
    [CompilerGeneratedAttribute]
private string <XmlDocumentation>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SourceLink>k__BackingField;
    public string Assembly { get; }
    public string RefAssembly { get; }
    public string Pdb { get; }
    public string XmlDocumentation { get; }
    public string SourceLink { get; }
    public string AssemblyOrRefAssembly { get; }
    public CompilationWrites(string assembly, string refAssembly, string pdb, string xmlDocumentation, string sourceLink);
    [CompilerGeneratedAttribute]
public string get_Assembly();
    [CompilerGeneratedAttribute]
public string get_RefAssembly();
    [CompilerGeneratedAttribute]
public string get_Pdb();
    [CompilerGeneratedAttribute]
public string get_XmlDocumentation();
    [CompilerGeneratedAttribute]
public string get_SourceLink();
    public string get_AssemblyOrRefAssembly();
    internal static Nullable`1<CompilationWrites> TryParse(Task task);
    public virtual string ToString();
}
public class Microsoft.Build.Logging.StructuredLogger.CompilerInvocation : object {
    public static string CSharp;
    public static string FSharp;
    public static string TypeScript;
    public static string VisualBasic;
    [CompilerGeneratedAttribute]
private string <Language>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CommandLineArguments>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProjectFilePath>k__BackingField;
    public string Language { get; public set; }
    public string CommandLineArguments { get; public set; }
    public string ProjectFilePath { get; public set; }
    public string ProjectDirectory { get; }
    [CompilerGeneratedAttribute]
public string get_Language();
    [CompilerGeneratedAttribute]
public void set_Language(string value);
    [CompilerGeneratedAttribute]
public string get_CommandLineArguments();
    [CompilerGeneratedAttribute]
public void set_CommandLineArguments(string value);
    [CompilerGeneratedAttribute]
public string get_ProjectFilePath();
    [CompilerGeneratedAttribute]
public void set_ProjectFilePath(string value);
    public string get_ProjectDirectory();
    public virtual string ToString();
}
public class Microsoft.Build.Logging.StructuredLogger.CompilerInvocationsReader : object {
    public static IEnumerable`1<CompilerInvocation> ReadInvocations(string binLogFilePath);
    public static IEnumerable`1<CompilerInvocation> ReadInvocations(Build build);
    public IEnumerable`1<CompilerInvocation> Read(string binLogFilePath);
    public IEnumerable`1<CompilerInvocation> Read(Build build);
    public IEnumerable`1<CompilerInvocation> ReadBuildLogFormat(string buildLogFilePath);
    public CompilerInvocation TryGetInvocationFromRecord(BuildEventArgs args, Dictionary`2<ValueTuple`2<int, int>, CompilerInvocation> taskIdToInvocationMap);
    public string GetCommandLineFromEventArgs(TaskCommandLineEventArgs task, String& language);
    public CompilerInvocation TryGetInvocationFromTask(Task task);
    public static string TrimCompilerExeFromCommandLine(string commandLine, string language);
    public static string GetLanguageFromTaskName(string name);
    [CompilerGeneratedAttribute]
internal static bool <TrimCompilerExeFromCommandLine>g__TryParse|8_0(string compilerName, <>c__DisplayClass8_0& );
}
public class Microsoft.Build.Logging.StructuredLogger.Construction : object {
    [CompilerGeneratedAttribute]
private Build <Build>k__BackingField;
    private ConcurrentDictionary`2<int, Project> _projectIdToProjectMap;
    private Dictionary`2<string, string> _taskToAssemblyMap;
    private object syncLock;
    private MessageProcessor messageProcessor;
    private StringCache stringTable;
    [CompilerGeneratedAttribute]
private bool <IsLargeBinlog>k__BackingField;
    private HashSet`1<string> environmentVariablesUsed;
    private static HashSet`1<string> ignoreAssemblyForTasks;
    public Build Build { get; private set; }
    public StringCache StringTable { get; }
    public NamedNode EvaluationFolder { get; }
    public NamedNode EnvironmentFolder { get; }
    public bool IsLargeBinlog { get; public set; }
    private static Construction();
    [CompilerGeneratedAttribute]
public Build get_Build();
    [CompilerGeneratedAttribute]
private void set_Build(Build value);
    public StringCache get_StringTable();
    public NamedNode get_EvaluationFolder();
    public NamedNode get_EnvironmentFolder();
    [CompilerGeneratedAttribute]
public bool get_IsLargeBinlog();
    [CompilerGeneratedAttribute]
public void set_IsLargeBinlog(bool value);
    public void Shutdown();
    private string Intern(string text);
    private string SoftIntern(string text);
    public void AddEnvironmentVariable(string environmentVariableName, string environmentVariableValue);
    public void BuildStarted(object sender, BuildStartedEventArgs args);
    public void BuildFinished(object sender, BuildFinishedEventArgs args);
    public void ProjectStarted(object sender, ProjectStartedEventArgs args);
    public void ProjectFinished(object sender, ProjectFinishedEventArgs args);
    public void TargetStarted(object sender, TargetStartedEventArgs args);
    private Target AddTargetCore(BuildEventArgs args, string targetName, string parentTargetName, string targetFile, TargetBuiltReason targetBuiltReason);
    public void TargetFinished(object sender, TargetFinishedEventArgs args);
    public void TargetSkipped(TargetSkippedEventArgs args);
    public void TaskStarted(object sender, TaskStartedEventArgs args);
    public void TaskFinished(object sender, TaskFinishedEventArgs args);
    public void MessageRaised(object sender, BuildMessageEventArgs args);
    public void CustomEventRaised(object sender, CustomBuildEventArgs args);
    public void StatusEventRaised(object sender, BuildStatusEventArgs e);
    private static string GetEvaluationProjectName(int evaluationId, string projectName);
    private void ConstructProfilerResult(ProjectEvaluation projectEvaluation, ProfilerResult profilerResult);
    private static double GetRatio(double parentDuration, double duration);
    public void WarningRaised(object sender, BuildWarningEventArgs args);
    private TreeNode FindParent(BuildEventContext buildEventContext);
    public void ErrorRaised(object sender, BuildErrorEventArgs args);
    private void Populate(AbstractDiagnostic message, BuildWarningEventArgs args, string text);
    private void Populate(AbstractDiagnostic message, BuildErrorEventArgs args);
    internal static void PopulateWithExtendedData(TreeNode node, BuildEventArgs args);
    private void HandleException(Exception ex);
    public static Project CreateProject(int id);
    public Project GetOrAddProject(ProjectStartedEventArgs args, Project parentProject);
    public Project GetOrAddProject(int projectId);
    public Project GetProject(int projectId);
    public Target GetTarget(int projectId, int targetId);
    public void UpdateProject(Project project, ProjectStartedEventArgs args);
    public void AddMetadata(ITaskItem item, Item itemNode);
    public void AddItems(Folder itemsNode, IEnumerable itemList);
    private void AddPropertiesSorted(Folder propertiesFolder, TreeNode project, IEnumerable properties);
    private Task CreateTask(TaskStartedEventArgs taskStartedEventArgs);
    public string GetTaskAssembly(string taskName);
    public void SetTaskAssembly(string taskName, string assembly);
    private Folder GetOrCreateGlobalPropertiesFolder(TreeNode project, IEnumerable globalProperties);
    private static void AddEntryTargets(Folder targetsNode, Project project);
    private void AddProperties(TreeNode parent, IEnumerable`1<KeyValuePair`2<string, string>> properties, int count, IProjectOrEvaluation project);
}
public class Microsoft.Build.Logging.StructuredLogger.CopyTask : Task {
    private IEnumerable`1<FileCopyOperation> fileCopyOperations;
    public IEnumerable`1<FileCopyOperation> FileCopyOperations { get; }
    public IEnumerable`1<FileCopyOperation> get_FileCopyOperations();
    protected virtual IEnumerable`1<FileCopyOperation> GetFileCopyOperations();
    protected static FileCopyOperation ParseCopyingFileFrom(Match match, bool copied);
}
public class Microsoft.Build.Logging.StructuredLogger.CppAnalyzer : object {
    private static string regexStartupPhase;
    private Regex startupPhase;
    private static string regexCleanupPhase;
    private Regex cleanupPhase;
    private static string regexTaskTime;
    private Regex TaskTime;
    private static string regexBTPlus;
    private Regex BTPlus;
    private static string regexLibFinalTime;
    private Regex libFinalTime;
    private static string regexLinkTotalTime;
    private Regex linkTotalTime;
    private static string MultiToolTaskName;
    private static string CLTaskName;
    private static string LinkTaskName;
    private static string LibTaskName;
    private static string filenameRegexMatchName;
    private static string startTimeRegexMatchName;
    private static string endTimeRegexMatchName;
    private static string msTimeRegexMatchName;
    private static string btplusKeyword;
    private static string mttKeyword;
    private static string mttCleanUpKeyword;
    private static string mttStartUpKeyword;
    private static string libKeyword;
    private static string linkKeyword;
    private bool globalBtplus;
    private bool globalLibTime;
    private bool globalLinkTime;
    private TimeSpan oneMilliSecond;
    private List`1<CppTimedNode> resultTimedNode;
    public void AnalyzeEnvironment(NamedNode node);
    public void AppendCppAnalyzer(Build build);
    public IEnumerable`1<CppTimedNode> GetAnalyzedTimedNode();
    public void AnalyzeTask(CppTask cppTask);
    [CompilerGeneratedAttribute]
private void <AnalyzeEnvironment>b__35_0(Property envProperty);
}
public class Microsoft.Build.Logging.StructuredLogger.CriticalBuildMessage : AbstractDiagnostic {
    public string TypeName { get; }
    public virtual string get_TypeName();
}
public class Microsoft.Build.Logging.StructuredLogger.CscTask : ManagedCompilerTask {
}
public class Microsoft.Build.Logging.StructuredLogger.CscTaskAnalyzer : object {
    public static ValueTuple`2<Folder, Folder> Analyze(Task task);
    public static void CreateMergedReport(Folder destination, Folder[] analyzerReports);
}
public class Microsoft.Build.Logging.StructuredLogger.DirectoryData : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private DirectoryData <Parent>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<FileData> <Files>k__BackingField;
    public string Name { get; public set; }
    public DirectoryData Parent { get; public set; }
    public List`1<FileData> Files { get; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public DirectoryData get_Parent();
    [CompilerGeneratedAttribute]
public void set_Parent(DirectoryData value);
    [CompilerGeneratedAttribute]
public List`1<FileData> get_Files();
    public virtual string ToString();
}
public class Microsoft.Build.Logging.StructuredLogger.DoubleWritesAnalyzer : object {
    private Dictionary`2<string, HashSet`1<string>> fileCopySourcesForDestination;
    public static IEnumerable`1<KeyValuePair`2<string, HashSet`1<string>>> GetDoubleWrites(Build build);
    public IEnumerable`1<KeyValuePair`2<string, HashSet`1<string>>> GetDoubleWrites();
    public void AppendDoubleWritesFolder(Build build);
    public void AnalyzeTask(Task task);
    private void AnalyzeCopyTask(CopyTask copyTask);
    private void AnalyzeCompilationWrites(CompilationWrites writes);
    private void ProcessCopy(string source, string destination);
    private static bool IsDoubleWrite(KeyValuePair`2<string, HashSet`1<string>> bucket);
    private static string GetFullPath(string filePath);
    [CompilerGeneratedAttribute]
private void <AnalyzeCompilationWrites>g__process|6_0(string destination, <>c__DisplayClass6_0& );
}
internal class Microsoft.Build.Logging.StructuredLogger.EmbeddedContentEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private BinaryLogRecordKind <ContentKind>k__BackingField;
    [CompilerGeneratedAttribute]
private Stream <ContentStream>k__BackingField;
    public BinaryLogRecordKind ContentKind { get; }
    public Stream ContentStream { get; }
    public EmbeddedContentEventArgs(BinaryLogRecordKind contentKind, Stream contentStream);
    [CompilerGeneratedAttribute]
public BinaryLogRecordKind get_ContentKind();
    [CompilerGeneratedAttribute]
public Stream get_ContentStream();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Microsoft.Build.Logging.StructuredLogger.EntryTarget : NamedNode {
    private Project project;
    private Target target;
    [NullableAttribute("1")]
public string TypeName { get; }
    private Project Project { get; }
    public Target Target { get; }
    public bool IsLowRelevance { get; }
    public string DurationText { get; }
    [NullableContextAttribute("1")]
public virtual string get_TypeName();
    private Project get_Project();
    public Target get_Target();
    public sealed virtual bool get_IsLowRelevance();
    public string get_DurationText();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private bool <get_Target>b__7_0(Target t);
}
public class Microsoft.Build.Logging.StructuredLogger.Error : AbstractDiagnostic {
    public string TypeName { get; }
    public virtual string get_TypeName();
}
public class Microsoft.Build.Logging.StructuredLogger.ErrorReporting : object {
    private static string logFilePath;
    public static string LogFilePath { get; }
    private static ErrorReporting();
    public static string get_LogFilePath();
    public static void ReportException(Exception ex);
}
internal static class Microsoft.Build.Logging.StructuredLogger.EvaluationIdProvider : object {
    private static long _sAssignedId;
    private static long ProcessId;
    private static EvaluationIdProvider();
    public static long GetNextId();
}
public class Microsoft.Build.Logging.StructuredLogger.EvaluationProfileEntry : TreeNode {
    [CompilerGeneratedAttribute]
private string <ElementName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ElementDescription>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EvaluationPassDescription>k__BackingField;
    [CompilerGeneratedAttribute]
private EvaluationLocationKind <Kind>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SourceFilePath>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <LineNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private ProfiledLocation <ProfiledLocation>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Value>k__BackingField;
    public string ElementName { get; public set; }
    public string ElementDescription { get; public set; }
    public string EvaluationPassDescription { get; public set; }
    public EvaluationLocationKind Kind { get; public set; }
    public string SourceFilePath { get; public set; }
    public Nullable`1<int> LineNumber { get; public set; }
    public string NumberOfHits { get; }
    public string TypeName { get; }
    public ProfiledLocation ProfiledLocation { get; private set; }
    public string DurationText { get; }
    public string FileName { get; }
    public string Title { get; }
    public string ShortenedElementDescription { get; }
    public double Value { get; public set; }
    [CompilerGeneratedAttribute]
public string get_ElementName();
    [CompilerGeneratedAttribute]
public void set_ElementName(string value);
    [CompilerGeneratedAttribute]
public string get_ElementDescription();
    [CompilerGeneratedAttribute]
public void set_ElementDescription(string value);
    [CompilerGeneratedAttribute]
public string get_EvaluationPassDescription();
    [CompilerGeneratedAttribute]
public void set_EvaluationPassDescription(string value);
    [CompilerGeneratedAttribute]
public EvaluationLocationKind get_Kind();
    [CompilerGeneratedAttribute]
public void set_Kind(EvaluationLocationKind value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_SourceFilePath();
    [CompilerGeneratedAttribute]
public void set_SourceFilePath(string value);
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<int> get_LineNumber();
    [CompilerGeneratedAttribute]
public void set_LineNumber(Nullable`1<int> value);
    public string get_NumberOfHits();
    public virtual string get_TypeName();
    [CompilerGeneratedAttribute]
public ProfiledLocation get_ProfiledLocation();
    [CompilerGeneratedAttribute]
private void set_ProfiledLocation(ProfiledLocation value);
    public void AddEntry(ProfiledLocation result);
    public string get_DurationText();
    public string get_FileName();
    public virtual string get_Title();
    public string get_ShortenedElementDescription();
    [CompilerGeneratedAttribute]
public double get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(double value);
    public virtual string ToString();
}
public class Microsoft.Build.Logging.StructuredLogger.EventArgsDispatcher : object {
    [CompilerGeneratedAttribute]
private AnyEventHandler AnyEventRaised;
    [CompilerGeneratedAttribute]
private BuildStatusEventHandler StatusEventRaised;
    [CompilerGeneratedAttribute]
private CustomBuildEventHandler CustomEventRaised;
    [CompilerGeneratedAttribute]
private BuildStartedEventHandler BuildStarted;
    [CompilerGeneratedAttribute]
private BuildFinishedEventHandler BuildFinished;
    [CompilerGeneratedAttribute]
private ProjectStartedEventHandler ProjectStarted;
    [CompilerGeneratedAttribute]
private ProjectFinishedEventHandler ProjectFinished;
    [CompilerGeneratedAttribute]
private TargetStartedEventHandler TargetStarted;
    [CompilerGeneratedAttribute]
private TargetFinishedEventHandler TargetFinished;
    [CompilerGeneratedAttribute]
private TaskStartedEventHandler TaskStarted;
    [CompilerGeneratedAttribute]
private TaskFinishedEventHandler TaskFinished;
    [CompilerGeneratedAttribute]
private BuildErrorEventHandler ErrorRaised;
    [CompilerGeneratedAttribute]
private BuildWarningEventHandler WarningRaised;
    [CompilerGeneratedAttribute]
private BuildMessageEventHandler MessageRaised;
    internal bool HasStructuredEventsSubscribers { get; }
    [CompilerGeneratedAttribute]
public sealed virtual void add_AnyEventRaised(AnyEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_AnyEventRaised(AnyEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_StatusEventRaised(BuildStatusEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_StatusEventRaised(BuildStatusEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_CustomEventRaised(CustomBuildEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_CustomEventRaised(CustomBuildEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_BuildStarted(BuildStartedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_BuildStarted(BuildStartedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_BuildFinished(BuildFinishedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_BuildFinished(BuildFinishedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_ProjectStarted(ProjectStartedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_ProjectStarted(ProjectStartedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_ProjectFinished(ProjectFinishedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_ProjectFinished(ProjectFinishedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_TargetStarted(TargetStartedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_TargetStarted(TargetStartedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_TargetFinished(TargetFinishedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_TargetFinished(TargetFinishedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_TaskStarted(TaskStartedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_TaskStarted(TaskStartedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_TaskFinished(TaskFinishedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_TaskFinished(TaskFinishedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_ErrorRaised(BuildErrorEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_ErrorRaised(BuildErrorEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_WarningRaised(BuildWarningEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_WarningRaised(BuildWarningEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_MessageRaised(BuildMessageEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_MessageRaised(BuildMessageEventHandler value);
    internal bool get_HasStructuredEventsSubscribers();
    public void Dispatch(BuildEventArgs buildEvent);
}
public class Microsoft.Build.Logging.StructuredLogger.FileCopy : Item {
    [CompilerGeneratedAttribute]
private string <Kind>k__BackingField;
    public string Kind { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Kind();
    [CompilerGeneratedAttribute]
public void set_Kind(string value);
}
public class Microsoft.Build.Logging.StructuredLogger.FileCopyInfo : object {
    [CompilerGeneratedAttribute]
private FileCopyOperation <FileCopyOperation>k__BackingField;
    [CompilerGeneratedAttribute]
private Task <Task>k__BackingField;
    [CompilerGeneratedAttribute]
private Target <Target>k__BackingField;
    [CompilerGeneratedAttribute]
private Project <Project>k__BackingField;
    public FileCopyOperation FileCopyOperation { get; public set; }
    public Task Task { get; public set; }
    public Target Target { get; public set; }
    public Project Project { get; public set; }
    [CompilerGeneratedAttribute]
public FileCopyOperation get_FileCopyOperation();
    [CompilerGeneratedAttribute]
public void set_FileCopyOperation(FileCopyOperation value);
    [CompilerGeneratedAttribute]
public Task get_Task();
    [CompilerGeneratedAttribute]
public void set_Task(Task value);
    [CompilerGeneratedAttribute]
public Target get_Target();
    [CompilerGeneratedAttribute]
public void set_Target(Target value);
    [CompilerGeneratedAttribute]
public Project get_Project();
    [CompilerGeneratedAttribute]
public void set_Project(Project value);
    public virtual string ToString();
}
public class Microsoft.Build.Logging.StructuredLogger.FileCopyMap : object {
    private static Char[] separators;
    private static string DirectorySeparator;
    private static string AltDirectorySeparator;
    private Dictionary`2<string, DirectoryData> directories;
    [CompilerGeneratedAttribute]
private Action`2<FileData, IList`1<SearchResult>> FoundSingleFileCopy;
    private static FileCopyMap();
    [CompilerGeneratedAttribute]
public void add_FoundSingleFileCopy(Action`2<FileData, IList`1<SearchResult>> value);
    [CompilerGeneratedAttribute]
public void remove_FoundSingleFileCopy(Action`2<FileData, IList`1<SearchResult>> value);
    public void AnalyzeTask(Task task);
    private void AnalyzeCopyTask(CopyTask copyTask);
    private void AnalyzeCopyOperation(FileCopyOperation copyOperation, Task task);
    public FileData GetFile(string filePath, bool create);
    public DirectoryData GetDirectory(string path, bool create);
    public sealed virtual bool TryGetResults(NodeQueryMatcher matcher, IList`1<SearchResult> resultSet, int maxResults);
    private void TryExplainSingleFileCopy(Project project, string filePath, IList`1<SearchResult> resultSet);
    private void TryExplainSingleFileCopy(FileData fileData, IList`1<SearchResult> resultSet);
    private static void FindCopyToOutputDirectoryItem(IList`1<SearchResult> resultSet, NamedNode itemsFolder, string fileName, string itemName);
    private void TryGetFiles(string text, IList`1<SearchResult> resultSet, NodeQueryMatcher matcher, int maxResults);
    private bool FileMatches(FileData file, NodeQueryMatcher matcher);
    private bool FileCopyMatches(FileCopyInfo fileCopyInfo, NodeQueryMatcher matcher);
    private void GetResults(FileData fileData, IList`1<SearchResult> resultSet, NodeQueryMatcher matcher, int maxResults, string matchText);
    private void GetResults(DirectoryData directoryData, IList`1<SearchResult> resultSet, NodeQueryMatcher matcher, int maxResults);
    private object TryGetDirectoryOrFile(string text);
}
public class Microsoft.Build.Logging.StructuredLogger.FileCopyOperation : object {
    [CompilerGeneratedAttribute]
private string <Source>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Destination>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Copied>k__BackingField;
    [CompilerGeneratedAttribute]
private Message <Message>k__BackingField;
    public string Source { get; public set; }
    public string Destination { get; public set; }
    public bool Copied { get; public set; }
    public Message Message { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Source();
    [CompilerGeneratedAttribute]
public void set_Source(string value);
    [CompilerGeneratedAttribute]
public string get_Destination();
    [CompilerGeneratedAttribute]
public void set_Destination(string value);
    [CompilerGeneratedAttribute]
public bool get_Copied();
    [CompilerGeneratedAttribute]
public void set_Copied(bool value);
    [CompilerGeneratedAttribute]
public Message get_Message();
    [CompilerGeneratedAttribute]
public void set_Message(Message value);
    public virtual string ToString();
}
public class Microsoft.Build.Logging.StructuredLogger.FileData : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FilePath>k__BackingField;
    [CompilerGeneratedAttribute]
private DirectoryData <Directory>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<FileCopyInfo> <Incoming>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<FileCopyInfo> <Outgoing>k__BackingField;
    public string Name { get; public set; }
    public string FilePath { get; public set; }
    public DirectoryData Directory { get; public set; }
    public List`1<FileCopyInfo> Incoming { get; }
    public List`1<FileCopyInfo> Outgoing { get; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_FilePath();
    [CompilerGeneratedAttribute]
public void set_FilePath(string value);
    [CompilerGeneratedAttribute]
public DirectoryData get_Directory();
    [CompilerGeneratedAttribute]
public void set_Directory(DirectoryData value);
    [CompilerGeneratedAttribute]
public List`1<FileCopyInfo> get_Incoming();
    [CompilerGeneratedAttribute]
public List`1<FileCopyInfo> get_Outgoing();
    public sealed virtual int CompareTo(FileData other);
    public virtual string ToString();
}
public class Microsoft.Build.Logging.StructuredLogger.Folder : NamedNode {
    public bool IsLowRelevance { get; public set; }
    public string TypeName { get; }
    public sealed virtual bool get_IsLowRelevance();
    public void set_IsLowRelevance(bool value);
    public virtual string get_TypeName();
}
internal class Microsoft.Build.Logging.StructuredLogger.FormatErrorMessage : MulticastDelegate {
    public FormatErrorMessage(object object, IntPtr method);
    public virtual string Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual string EndInvoke(IAsyncResult result);
}
public class Microsoft.Build.Logging.StructuredLogger.FscTask : ManagedCompilerTask {
}
public class Microsoft.Build.Logging.StructuredLogger.HighlightedText : object {
    [CompilerGeneratedAttribute]
private string <Text>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Style>k__BackingField;
    public string Text { get; public set; }
    public string Style { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Text();
    [CompilerGeneratedAttribute]
public void set_Text(string value);
    [CompilerGeneratedAttribute]
public string get_Style();
    [CompilerGeneratedAttribute]
public void set_Style(string value);
    public virtual string ToString();
}
internal interface Microsoft.Build.Logging.StructuredLogger.IBinaryLogReplaySource {
    public int FileFormatVersion { get; }
    public int MinimumReaderVersion { get; }
    [CompilerGeneratedAttribute]
public abstract virtual void add_RawLogRecordReceived(Action`2<BinaryLogRecordKind, Stream> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_RawLogRecordReceived(Action`2<BinaryLogRecordKind, Stream> value);
    public abstract virtual void DeferredInitialize(Action onRawReadingPossible, Action onStructuredReadingOnly);
    public abstract virtual int get_FileFormatVersion();
    public abstract virtual int get_MinimumReaderVersion();
    [CompilerGeneratedAttribute]
public abstract virtual void add_EmbeddedContentRead(Action`1<EmbeddedContentEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_EmbeddedContentRead(Action`1<EmbeddedContentEventArgs> value);
}
public interface Microsoft.Build.Logging.StructuredLogger.IBuildEventArgsReaderNotifications {
    [CompilerGeneratedAttribute]
public abstract virtual void add_StringReadDone(Action`1<StringReadEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_StringReadDone(Action`1<StringReadEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_ArchiveFileEncountered(Action`1<ArchiveFileEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_ArchiveFileEncountered(Action`1<ArchiveFileEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_RecoverableReadError(Action`1<BinaryLogReaderErrorEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_RecoverableReadError(Action`1<BinaryLogReaderErrorEventArgs> value);
}
public interface Microsoft.Build.Logging.StructuredLogger.IHasExtendedData {
    public string ExtendedType { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IDictionary`2<string, string> ExtendedMetadata { get; }
    [NullableAttribute("2")]
public string ExtendedData { get; }
    public abstract virtual string get_ExtendedType();
    public abstract virtual IDictionary`2<string, string> get_ExtendedMetadata();
    [NullableContextAttribute("2")]
public abstract virtual string get_ExtendedData();
}
public interface Microsoft.Build.Logging.StructuredLogger.IHasLineNumber {
    public Nullable`1<int> LineNumber { get; }
    public abstract virtual Nullable`1<int> get_LineNumber();
}
public interface Microsoft.Build.Logging.StructuredLogger.IHasRelevance {
    public bool IsLowRelevance { get; }
    public abstract virtual bool get_IsLowRelevance();
}
public interface Microsoft.Build.Logging.StructuredLogger.IHasSourceFile {
    public string SourceFilePath { get; }
    public abstract virtual string get_SourceFilePath();
}
public class Microsoft.Build.Logging.StructuredLogger.Import : TextNode {
    [CompilerGeneratedAttribute]
private string <ProjectFilePath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ImportedProjectFilePath>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Line>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Column>k__BackingField;
    public string ProjectFilePath { get; public set; }
    public string ImportedProjectFilePath { get; public set; }
    public int Line { get; public set; }
    public int Column { get; public set; }
    public string Location { get; }
    public string TypeName { get; }
    public bool IsLowRelevance { get; public set; }
    private string Microsoft.Build.Logging.StructuredLogger.IPreprocessable.RootFilePath { get; }
    private string Microsoft.Build.Logging.StructuredLogger.IHasSourceFile.SourceFilePath { get; }
    private Nullable`1<int> Microsoft.Build.Logging.StructuredLogger.IHasLineNumber.LineNumber { get; }
    public Import(string projectFilePath, string importedProjectFilePath, int line, int column);
    [CompilerGeneratedAttribute]
public string get_ProjectFilePath();
    [CompilerGeneratedAttribute]
public void set_ProjectFilePath(string value);
    [CompilerGeneratedAttribute]
public string get_ImportedProjectFilePath();
    [CompilerGeneratedAttribute]
public void set_ImportedProjectFilePath(string value);
    [CompilerGeneratedAttribute]
public int get_Line();
    [CompilerGeneratedAttribute]
public void set_Line(int value);
    [CompilerGeneratedAttribute]
public int get_Column();
    [CompilerGeneratedAttribute]
public void set_Column(int value);
    public string get_Location();
    public virtual string get_TypeName();
    public sealed virtual bool get_IsLowRelevance();
    public void set_IsLowRelevance(bool value);
    private sealed virtual override string Microsoft.Build.Logging.StructuredLogger.IPreprocessable.get_RootFilePath();
    private sealed virtual override string Microsoft.Build.Logging.StructuredLogger.IHasSourceFile.get_SourceFilePath();
    private sealed virtual override Nullable`1<int> Microsoft.Build.Logging.StructuredLogger.IHasLineNumber.get_LineNumber();
    public virtual string ToString();
}
public class Microsoft.Build.Logging.StructuredLogger.ImportTreeAnalyzer : object {
    private StringCache stringTable;
    private Dictionary`2<ValueTuple`2<string, string>, string> falseConditionStrings;
    private static NumberFormatInfo currentNumberFormatInfo;
    public ImportTreeAnalyzer(StringCache stringTable);
    private static ImportTreeAnalyzer();
    public TextNode TryGetImportOrNoImport(ProjectImportedEventArgs args);
    private string GetFalseCondition(string condition, string evaluated);
    private static string GetNoImportReason(string message);
    public static TextNode TryGetImportOrNoImport(string text, StringCache stringTable);
    private static int ParseInt(object arg);
}
public interface Microsoft.Build.Logging.StructuredLogger.IPreprocessable {
    public string RootFilePath { get; }
    public abstract virtual string get_RootFilePath();
}
public interface Microsoft.Build.Logging.StructuredLogger.IProjectOrEvaluation {
    public string ProjectFile { get; public set; }
    public string TargetFramework { get; public set; }
    public string Platform { get; public set; }
    public string Configuration { get; public set; }
    public abstract virtual string get_ProjectFile();
    public abstract virtual void set_ProjectFile(string value);
    public abstract virtual string get_TargetFramework();
    public abstract virtual void set_TargetFramework(string value);
    public abstract virtual string get_Platform();
    public abstract virtual void set_Platform(string value);
    public abstract virtual string get_Configuration();
    public abstract virtual void set_Configuration(string value);
}
public interface Microsoft.Build.Logging.StructuredLogger.ISearchExtension {
    public abstract virtual bool TryGetResults(NodeQueryMatcher nodeQueryMatcher, IList`1<SearchResult> resultCollector, int maxResults);
}
public class Microsoft.Build.Logging.StructuredLogger.Item : NamedNode {
    public string TypeName { get; }
    public string Text { get; public set; }
    public virtual string get_TypeName();
    public string get_Text();
    public void set_Text(string value);
}
public static class Microsoft.Build.Logging.StructuredLogger.ItemGroupParser : object {
    [ThreadStaticAttribute]
private static List`1<Span> lineSpans;
    public static BaseNode ParsePropertyOrItemList(string message, string prefix, StringCache stringTable, bool isOutputItem);
    public static void ParseThereWasAConflict(TreeNode parent, string message, StringCache stringTable);
    [CompilerGeneratedAttribute]
internal static Item <ParseThereWasAConflict>g__Add|2_0(TreeNode parent, string text, Span span, int spaces, StringCache stringTable);
}
public class Microsoft.Build.Logging.StructuredLogger.ManagedCompilerTask : Task {
    private Nullable`1<CompilationWrites> compilationWrites;
    public Nullable`1<CompilationWrites> CompilationWrites { get; }
    public Nullable`1<CompilationWrites> get_CompilationWrites();
}
public class Microsoft.Build.Logging.StructuredLogger.Message : TextNode {
    public DateTime Timestamp { get; public set; }
    public string TypeName { get; }
    public bool IsLowRelevance { get; public set; }
    public string SourceFilePath { get; }
    public Nullable`1<int> LineNumber { get; }
    public virtual DateTime get_Timestamp();
    public virtual void set_Timestamp(DateTime value);
    public virtual string get_TypeName();
    public sealed virtual bool get_IsLowRelevance();
    public void set_IsLowRelevance(bool value);
    public virtual string get_SourceFilePath();
    private Match GetSourceFileMatch();
    public virtual Nullable`1<int> get_LineNumber();
}
public class Microsoft.Build.Logging.StructuredLogger.MessageProcessor : object {
    private Construction construction;
    private StringCache stringTable;
    private ImportTreeAnalyzer importTreeAnalyzer;
    private int fileFormatVersion;
    [CompilerGeneratedAttribute]
private StringBuilder <DetailedSummary>k__BackingField;
    private BuildEventContext lastTaskBuildEventContext;
    private Task lastTask;
    private HashSet`1<string> evaluationMessagesAlreadySeen;
    private static Char[] space;
    private Folder lastMmpFolder;
    private String[] mmpTerminalPrefixes;
    public StringBuilder DetailedSummary { get; }
    public MessageProcessor(Construction construction, StringCache stringTable);
    private static MessageProcessor();
    [CompilerGeneratedAttribute]
public StringBuilder get_DetailedSummary();
    private string Intern(string text);
    public void Process(BuildMessageEventArgs args);
    private void ProcessProjectImported(ProjectImportedEventArgs args);
    private void ProcessTaskParameter(TaskParameterEventArgs args);
    private BaseNode CreateParameterNode(string itemName, IEnumerable items, bool isOutput, string parameterName);
    private void AddItems(IEnumerable items, TreeNode parent);
    private void AddItemsCore(IEnumerable items, TreeNode parent);
    private bool IgnoreParameters(Task task);
    private Task GetTask(BuildEventArgs args);
    private Task GetTask(BuildEventContext buildEventContext);
    private Target GetTarget(BuildEventArgs args);
    private Target GetTarget(BuildEventContext buildEventContext);
    public void AddPropertyGroup(BuildMessageEventArgs args, string message, string prefix);
    public void AddItemGroup(BuildMessageEventArgs args, string message, string prefix, NamedNode containerNode);
    public void AddMessage(LazyFormattedBuildEventArgs args, string message);
    private bool ProcessRAR(ResolveAssemblyReferenceTask task, TreeNode& node, string message);
    private bool ProcessMSBuildTask(Task task, TreeNode& node, BaseNode& nodeToAdd, string message);
    private bool ProcessRestoreTask(Task task, TreeNode& node, string message);
    private bool ProcessMmp(Task task, TreeNode& node, string message);
    public static void HandleThereWasAConflict(Parameter parameter, string message, StringCache stringTable);
    public bool AddCommandLine(TaskCommandLineEventArgs args);
    [CompilerGeneratedAttribute]
private Folder <ProcessRestoreTask>g__CreateFolder|29_0(TreeNode node, string name);
    [CompilerGeneratedAttribute]
private Folder <ProcessMmp>g__CreateFolder|32_0(TreeNode node, string name);
    [CompilerGeneratedAttribute]
internal static void <HandleThereWasAConflict>g__Add|33_0(TreeNode parent, string text, int spaces, <>c__DisplayClass33_0& );
}
public class Microsoft.Build.Logging.StructuredLogger.MessageTaskAnalyzer : object {
    public static void Analyze(Task task);
}
public class Microsoft.Build.Logging.StructuredLogger.MessageWithLocation : Message {
    [CompilerGeneratedAttribute]
private string <FilePath>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Line>k__BackingField;
    public string FilePath { get; public set; }
    public int Line { get; public set; }
    public string SourceFilePath { get; }
    public Nullable`1<int> LineNumber { get; }
    public string TypeName { get; }
    [CompilerGeneratedAttribute]
public string get_FilePath();
    [CompilerGeneratedAttribute]
public void set_FilePath(string value);
    [CompilerGeneratedAttribute]
public int get_Line();
    [CompilerGeneratedAttribute]
public void set_Line(int value);
    public virtual string get_SourceFilePath();
    public virtual Nullable`1<int> get_LineNumber();
    public virtual string get_TypeName();
}
public class Microsoft.Build.Logging.StructuredLogger.Metadata : NameValueNode {
    public string TypeName { get; }
    public virtual string get_TypeName();
}
public class Microsoft.Build.Logging.StructuredLogger.MSBuildTask : Task {
}
public class Microsoft.Build.Logging.StructuredLogger.NamedNode : TreeNode {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public string Name { get; public set; }
    public string ShortenedName { get; }
    public bool IsNameShortened { get; }
    public string TypeName { get; }
    public string Title { get; }
    [CompilerGeneratedAttribute]
public virtual string get_Name();
    [CompilerGeneratedAttribute]
public virtual void set_Name(string value);
    public string get_ShortenedName();
    public bool get_IsNameShortened();
    public virtual string get_TypeName();
    public virtual string get_Title();
    public virtual string ToString();
}
public class Microsoft.Build.Logging.StructuredLogger.NameValueNode : BaseNode {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    public string Name { get; public set; }
    public string Value { get; public set; }
    public string NameAndEquals { get; }
    public string ShortenedValue { get; }
    public bool IsValueShortened { get; }
    public string TypeName { get; }
    public string Title { get; }
    public bool IsVisible { get; public set; }
    public bool IsExpanded { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(string value);
    public string get_NameAndEquals();
    public string get_ShortenedValue();
    public bool get_IsValueShortened();
    public virtual string get_TypeName();
    public virtual string get_Title();
    public virtual string ToString();
    public bool get_IsVisible();
    public void set_IsVisible(bool value);
    public bool get_IsExpanded();
    public void set_IsExpanded(bool value);
}
[DefaultMemberAttribute("Item")]
public class Microsoft.Build.Logging.StructuredLogger.NodeEntry : object {
    public BaseNode Node;
    public int Field1;
    public int Item { get; }
    public int get_Item(int index);
    public virtual int GetField(int index);
}
public class Microsoft.Build.Logging.StructuredLogger.NodeEntry2 : NodeEntry {
    public int Field2;
    public virtual int GetField(int index);
}
public class Microsoft.Build.Logging.StructuredLogger.NodeEntry3 : NodeEntry2 {
    public int Field3;
    public virtual int GetField(int index);
}
public class Microsoft.Build.Logging.StructuredLogger.NodeEntry4 : NodeEntry3 {
    public int Field4;
    public virtual int GetField(int index);
}
public class Microsoft.Build.Logging.StructuredLogger.NodeEntry5 : NodeEntry4 {
    public int Field5;
    public virtual int GetField(int index);
}
public class Microsoft.Build.Logging.StructuredLogger.NodeEntry6 : NodeEntry5 {
    public int Field6;
    public virtual int GetField(int index);
}
[FlagsAttribute]
internal enum Microsoft.Build.Logging.StructuredLogger.NodeFlags : Enum {
    public byte value__;
    public static NodeFlags None;
    public static NodeFlags Hidden;
    public static NodeFlags Expanded;
    public static NodeFlags SearchResult;
    public static NodeFlags ContainsSearchResult;
    public static NodeFlags LowRelevance;
    public static NodeFlags DisableChildrenCache;
}
public class Microsoft.Build.Logging.StructuredLogger.NoImport : TextNode {
    [CompilerGeneratedAttribute]
private string <ProjectFilePath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ImportedFileSpec>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Reason>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Line>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Column>k__BackingField;
    public string ProjectFilePath { get; public set; }
    public string ImportedFileSpec { get; public set; }
    public string Reason { get; public set; }
    public int Line { get; public set; }
    public int Column { get; public set; }
    public string TypeName { get; }
    public string Location { get; }
    public bool IsLowRelevance { get; public set; }
    private string Microsoft.Build.Logging.StructuredLogger.IHasSourceFile.SourceFilePath { get; }
    private Nullable`1<int> Microsoft.Build.Logging.StructuredLogger.IHasLineNumber.LineNumber { get; }
    public NoImport(string projectFilePath, string importedFileSpec, int line, int column, string reason);
    [CompilerGeneratedAttribute]
public string get_ProjectFilePath();
    [CompilerGeneratedAttribute]
public void set_ProjectFilePath(string value);
    [CompilerGeneratedAttribute]
public string get_ImportedFileSpec();
    [CompilerGeneratedAttribute]
public void set_ImportedFileSpec(string value);
    [CompilerGeneratedAttribute]
public string get_Reason();
    [CompilerGeneratedAttribute]
public void set_Reason(string value);
    [CompilerGeneratedAttribute]
public int get_Line();
    [CompilerGeneratedAttribute]
public void set_Line(int value);
    [CompilerGeneratedAttribute]
public int get_Column();
    [CompilerGeneratedAttribute]
public void set_Column(int value);
    public virtual string get_TypeName();
    public string get_Location();
    public sealed virtual bool get_IsLowRelevance();
    public void set_IsLowRelevance(bool value);
    private sealed virtual override string Microsoft.Build.Logging.StructuredLogger.IHasSourceFile.get_SourceFilePath();
    private sealed virtual override Nullable`1<int> Microsoft.Build.Logging.StructuredLogger.IHasLineNumber.get_LineNumber();
    public virtual string ToString();
}
public class Microsoft.Build.Logging.StructuredLogger.Note : TextNode {
    protected bool IsSelectable { get; }
    public string TypeName { get; }
    protected virtual bool get_IsSelectable();
    public virtual string get_TypeName();
}
public abstract class Microsoft.Build.Logging.StructuredLogger.ObservableObject : object {
    [CompilerGeneratedAttribute]
private PropertyChangedEventHandler PropertyChanged;
    [CompilerGeneratedAttribute]
public sealed virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
    protected bool SetField(TField& field, TField newValue, string propertyName);
    protected void RaisePropertyChanged(string propertyName);
}
public class Microsoft.Build.Logging.StructuredLogger.Package : NamedNode {
    [CompilerGeneratedAttribute]
private string <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private string <VersionSpec>k__BackingField;
    public string TypeName { get; }
    public string Version { get; public set; }
    public string VersionSpec { get; public set; }
    public virtual string get_TypeName();
    [CompilerGeneratedAttribute]
public string get_Version();
    [CompilerGeneratedAttribute]
public void set_Version(string value);
    [CompilerGeneratedAttribute]
public string get_VersionSpec();
    [CompilerGeneratedAttribute]
public void set_VersionSpec(string value);
    public virtual string ToString();
}
public class Microsoft.Build.Logging.StructuredLogger.Parameter : NamedNode {
    [CompilerGeneratedAttribute]
private string <ParameterName>k__BackingField;
    public string TypeName { get; }
    public string ParameterName { get; public set; }
    public virtual string get_TypeName();
    [CompilerGeneratedAttribute]
public string get_ParameterName();
    [CompilerGeneratedAttribute]
public void set_ParameterName(string value);
}
public static class Microsoft.Build.Logging.StructuredLogger.PathUtils : object {
    public static string RootPath;
    public static string TempPath;
    internal static string ExtendedPathPrefix;
    internal static string UncPathPrefix;
    internal static string UncExtendedPrefixToInsert;
    internal static string UncExtendedPathPrefix;
    internal static string DevicePathPrefix;
    internal static int DevicePrefixLength;
    internal static int MaxShortPath;
    internal static int MaxShortDirectoryPath;
    private static PathUtils();
    private static string GetRootPath();
    internal static bool IsExtended(string path);
    public static bool HasInvalidVolumeSeparator(string path);
    internal static bool IsDirectorySeparator(char c);
    internal static bool IsValidDriveChar(char value);
    internal static int PathStartSkip(string path);
}
public class Microsoft.Build.Logging.StructuredLogger.PlatformUtilities : object {
    private static bool _isBrowser;
    private static bool _isWasi;
    public static bool HasThreads { get; }
    public static bool HasTempStorage { get; }
    public static bool HasColor { get; }
    private static PlatformUtilities();
    public static bool get_HasThreads();
    public static bool get_HasTempStorage();
    public static bool get_HasColor();
}
public class Microsoft.Build.Logging.StructuredLogger.Progress : object {
    [CompilerGeneratedAttribute]
private CancellationToken <CancellationToken>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`1<ProgressUpdate> Updated;
    public CancellationToken CancellationToken { get; public set; }
    [CompilerGeneratedAttribute]
public virtual CancellationToken get_CancellationToken();
    [CompilerGeneratedAttribute]
public virtual void set_CancellationToken(CancellationToken value);
    [CompilerGeneratedAttribute]
public void add_Updated(Action`1<ProgressUpdate> value);
    [CompilerGeneratedAttribute]
public void remove_Updated(Action`1<ProgressUpdate> value);
    public virtual void Report(double ratio);
    public virtual void Report(ProgressUpdate progressUpdate);
}
public class Microsoft.Build.Logging.StructuredLogger.ProgressUpdate : ValueType {
    public double Ratio;
    public int BufferLength;
}
public class Microsoft.Build.Logging.StructuredLogger.Project : TimedNode {
    [CompilerGeneratedAttribute]
private string <ProjectFile>k__BackingField;
    private Dictionary`2<int, Target> targetsById;
    private Dictionary`2<int, Task> tasksById;
    private int unparentedTargetIndex;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<string> <EntryTargets>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TargetsText>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TargetFramework>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Platform>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Configuration>k__BackingField;
    [CompilerGeneratedAttribute]
private int <EvaluationId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EvaluationText>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <GlobalProperties>k__BackingField;
    public string ProjectFile { get; public set; }
    public string ProjectFileExtension { get; }
    public string ProjectDirectory { get; }
    public string SourceFilePath { get; }
    private string Microsoft.Build.Logging.StructuredLogger.IPreprocessable.RootFilePath { get; }
    public string TypeName { get; }
    public bool IsLowRelevance { get; public set; }
    public IReadOnlyList`1<string> EntryTargets { get; public set; }
    public string TargetsText { get; public set; }
    public string TargetsDisplayText { get; }
    public string AdornmentString { get; }
    public string TargetFramework { get; public set; }
    public string Platform { get; public set; }
    public string Configuration { get; public set; }
    public int EvaluationId { get; public set; }
    public string EvaluationText { get; public set; }
    public IDictionary`2<string, string> GlobalProperties { get; public set; }
    public string ToolTip { get; }
    [CompilerGeneratedAttribute]
public sealed virtual string get_ProjectFile();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ProjectFile(string value);
    public string get_ProjectFileExtension();
    public string get_ProjectDirectory();
    public sealed virtual string get_SourceFilePath();
    private sealed virtual override string Microsoft.Build.Logging.StructuredLogger.IPreprocessable.get_RootFilePath();
    public virtual string get_TypeName();
    public virtual string ToString();
    public Target GetTargetById(int id);
    public Target CreateTarget(string name, int id);
    private Target CreateTargetInstance(string name);
    public sealed virtual bool get_IsLowRelevance();
    public void set_IsLowRelevance(bool value);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<string> get_EntryTargets();
    [CompilerGeneratedAttribute]
public void set_EntryTargets(IReadOnlyList`1<string> value);
    [CompilerGeneratedAttribute]
public string get_TargetsText();
    [CompilerGeneratedAttribute]
public void set_TargetsText(string value);
    public string get_TargetsDisplayText();
    public string get_AdornmentString();
    [CompilerGeneratedAttribute]
public sealed virtual string get_TargetFramework();
    [CompilerGeneratedAttribute]
public sealed virtual void set_TargetFramework(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Platform();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Platform(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Configuration();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Configuration(string value);
    [CompilerGeneratedAttribute]
public int get_EvaluationId();
    [CompilerGeneratedAttribute]
public void set_EvaluationId(int value);
    [CompilerGeneratedAttribute]
public string get_EvaluationText();
    [CompilerGeneratedAttribute]
public void set_EvaluationText(string value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_GlobalProperties();
    [CompilerGeneratedAttribute]
public void set_GlobalProperties(IDictionary`2<string, string> value);
    public virtual string get_ToolTip();
    public void OnTaskAdded(Task task);
    public Task GetTaskById(int id);
    public Target FindTarget(string targetName);
}
public class Microsoft.Build.Logging.StructuredLogger.ProjectEvaluation : TimedNode {
    [CompilerGeneratedAttribute]
private string <ProjectFile>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EvaluationText>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TargetFramework>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Platform>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Configuration>k__BackingField;
    [CompilerGeneratedAttribute]
private double <RelativeDuration>k__BackingField;
    [CompilerGeneratedAttribute]
private HashSet`1<string> <MessageTexts>k__BackingField;
    private TimedNode importsFolder;
    private TimedNode propertyReassignmentFolder;
    private Dictionary`2<string, Import> importsMap;
    public string ProjectFile { get; public set; }
    public string SourceFilePath { get; }
    private string Microsoft.Build.Logging.StructuredLogger.IPreprocessable.RootFilePath { get; }
    public string ProjectFileExtension { get; }
    public string EvaluationText { get; public set; }
    public string AdornmentString { get; }
    public string TargetFramework { get; public set; }
    public string Platform { get; public set; }
    public string Configuration { get; public set; }
    public double RelativeDuration { get; public set; }
    public string TypeName { get; }
    public HashSet`1<string> MessageTexts { get; }
    public bool IsLowRelevance { get; public set; }
    public string ToolTip { get; }
    public TimedNode ImportsFolder { get; }
    public TimedNode PropertyReassignmentFolder { get; }
    [CompilerGeneratedAttribute]
public sealed virtual string get_ProjectFile();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ProjectFile(string value);
    public sealed virtual string get_SourceFilePath();
    private sealed virtual override string Microsoft.Build.Logging.StructuredLogger.IPreprocessable.get_RootFilePath();
    public string get_ProjectFileExtension();
    [CompilerGeneratedAttribute]
public string get_EvaluationText();
    [CompilerGeneratedAttribute]
public void set_EvaluationText(string value);
    public string get_AdornmentString();
    [CompilerGeneratedAttribute]
public sealed virtual string get_TargetFramework();
    [CompilerGeneratedAttribute]
public sealed virtual void set_TargetFramework(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Platform();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Platform(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Configuration();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Configuration(string value);
    [CompilerGeneratedAttribute]
public double get_RelativeDuration();
    [CompilerGeneratedAttribute]
public void set_RelativeDuration(double value);
    public virtual string get_TypeName();
    [CompilerGeneratedAttribute]
public HashSet`1<string> get_MessageTexts();
    public sealed virtual bool get_IsLowRelevance();
    public void set_IsLowRelevance(bool value);
    public virtual string ToString();
    public virtual string get_ToolTip();
    public TimedNode get_ImportsFolder();
    public TimedNode get_PropertyReassignmentFolder();
    public void AddImport(TextNode textNode);
    public IEnumerable`1<Import> GetAllImportsTransitive();
}
[ExtensionAttribute]
public static class Microsoft.Build.Logging.StructuredLogger.ProjectOrEvaluationHelper : object {
    private static string separator;
    private static Dictionary`2<ValueTuple`3<string, string, string>, string> AdornmentStringCache;
    public static bool ShowConfigurationAndPlatform;
    [ThreadStaticAttribute]
private static List`1<string> strings;
    private static ProjectOrEvaluationHelper();
    private static ValueTuple`3<string, string, string> GetKey(IProjectOrEvaluation p);
    public static void ClearCache();
    [ExtensionAttribute]
public static string GetAdornmentString(IProjectOrEvaluation project);
    private static string CreateAdornment(IProjectOrEvaluation project);
}
public class Microsoft.Build.Logging.StructuredLogger.ProjectReferenceGraph : object {
    private Dictionary`2<string, ICollection`1<string>> references;
    private Dictionary`2<string, int> projectHeights;
    private int maxProjectHeight;
    public ProjectReferenceGraph(Build build);
    private int CalculateHeight(string project);
    public sealed virtual bool TryGetResults(NodeQueryMatcher matcher, IList`1<SearchResult> resultSet, int maxResults);
    private void GetProjectHeightResults(NodeQueryMatcher matcher, IList`1<SearchResult> resultSet, int maxResults);
    private bool GetProjectsOfHeight(int height);
    private Project CreateProject(string project);
    [CompilerGeneratedAttribute]
private TreeNode <TryGetResults>g__PopulateReferences|5_0(string path, <>c__DisplayClass5_0& );
}
public class Microsoft.Build.Logging.StructuredLogger.Property : NameValueNode {
    public string TypeName { get; }
    public virtual string get_TypeName();
}
public class Microsoft.Build.Logging.StructuredLogger.ProxyNode : TextNode {
    private BaseNode original;
    [CompilerGeneratedAttribute]
private SearchResult <SearchResult>k__BackingField;
    private List`1<object> highlights;
    public BaseNode Original { get; public set; }
    public SearchResult SearchResult { get; public set; }
    public List`1<object> Highlights { get; }
    public string OriginalType { get; }
    public string ProjectExtension { get; }
    public string TypeName { get; }
    public bool IsLowRelevance { get; public set; }
    public BaseNode get_Original();
    public void set_Original(BaseNode value);
    [CompilerGeneratedAttribute]
public SearchResult get_SearchResult();
    [CompilerGeneratedAttribute]
public void set_SearchResult(SearchResult value);
    public List`1<object> get_Highlights();
    public static string GetNodeText(BaseNode node, bool includeType);
    public void Populate(SearchResult result);
    private object GetNodeDifferentiator(BaseNode node);
    private void AddDuration(SearchResult result);
    public string get_OriginalType();
    public string get_ProjectExtension();
    private string GetProjectFileExtension();
    public virtual string get_TypeName();
    public sealed virtual bool get_IsLowRelevance();
    public void set_IsLowRelevance(bool value);
    public virtual string ToString();
}
public enum Microsoft.Build.Logging.StructuredLogger.ReaderErrorType : Enum {
    public int value__;
    public static ReaderErrorType UnknownEventType;
    public static ReaderErrorType UnknownEventData;
    public static ReaderErrorType UnknownFormatOfEventData;
}
public class Microsoft.Build.Logging.StructuredLogger.ReaderSettings : object {
    [CompilerGeneratedAttribute]
private static ReaderSettings <Default>k__BackingField;
    [CompilerGeneratedAttribute]
private UnknownDataBehavior <UnknownDataBehavior>k__BackingField;
    public static ReaderSettings Default { get; }
    public UnknownDataBehavior UnknownDataBehavior { get; public set; }
    private static ReaderSettings();
    [CompilerGeneratedAttribute]
public static ReaderSettings get_Default();
    [CompilerGeneratedAttribute]
public UnknownDataBehavior get_UnknownDataBehavior();
    [CompilerGeneratedAttribute]
public void set_UnknownDataBehavior(UnknownDataBehavior value);
}
public class Microsoft.Build.Logging.StructuredLogger.Reflector : object {
    private static Func`2<LazyFormattedBuildEventArgs, Object[]> argumentsGetter;
    private static Func`2<LazyFormattedBuildEventArgs, object> argumentsOrFormattedMessageGetter;
    private static Func`2<LazyFormattedBuildEventArgs, Object[]> lazyFormattedBuildEventArgs_RawArgumentsGetter;
    private static Func`2<BuildEventArgs, string> messageGetter;
    private static Action`2<BuildEventArgs, string> senderNameSetter;
    private static Action`2<BuildEventArgs, DateTime> timeStampSetter;
    private static MethodInfo enumerateItemsPerType;
    private static Reflector();
    public static Object[] GetArguments(LazyFormattedBuildEventArgs args);
    public static string GetMessage(BuildEventArgs args);
    public static void SetSenderName(BuildEventArgs args, string senderName);
    public static void SetTimestamp(BuildEventArgs args, DateTime timestamp);
    private static Func`2<T, R> GetFieldAccessor(string fieldName);
    private static Action`2<T, R> GetFieldSetter(string fieldName);
    public static MethodInfo GetEnumerateItemsPerTypeMethod(Type itemDictionary);
}
public class Microsoft.Build.Logging.StructuredLogger.RemoveItem : NamedNode {
    [CompilerGeneratedAttribute]
private Nullable`1<int> <LineNumber>k__BackingField;
    public string TypeName { get; }
    public Nullable`1<int> LineNumber { get; public set; }
    public virtual string get_TypeName();
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<int> get_LineNumber();
    [CompilerGeneratedAttribute]
public void set_LineNumber(Nullable`1<int> value);
}
public class Microsoft.Build.Logging.StructuredLogger.Rental`1 : object {
    private Queue`1<T> queue;
    private Func`1<T> Factory;
    public Rental`1(Func`1<T> factory);
    public T Get();
    public void Return(T item);
}
public class Microsoft.Build.Logging.StructuredLogger.ResolveAssemblyReferenceAnalyzer : object {
    public TimeSpan TotalRARDuration;
    private StringCache stringTable;
    [CompilerGeneratedAttribute]
private HashSet`1<string> <UsedLocations>k__BackingField;
    [CompilerGeneratedAttribute]
private HashSet`1<string> <UnusedLocations>k__BackingField;
    private HashSet`1<string> currentUsedLocations;
    public HashSet`1<string> UsedLocations { get; }
    public HashSet`1<string> UnusedLocations { get; }
    [CompilerGeneratedAttribute]
public HashSet`1<string> get_UsedLocations();
    [CompilerGeneratedAttribute]
public HashSet`1<string> get_UnusedLocations();
    public void AnalyzeResolveAssemblyReference(Task rar);
    private string ParseReferenceName(string name);
    public void AppendFinalReport(Build build);
}
public class Microsoft.Build.Logging.StructuredLogger.ResolveAssemblyReferenceTask : Task {
    [CompilerGeneratedAttribute]
private Folder <Inputs>k__BackingField;
    [CompilerGeneratedAttribute]
private Folder <Results>k__BackingField;
    public Folder Inputs { get; public set; }
    public Folder Results { get; public set; }
    [CompilerGeneratedAttribute]
public Folder get_Inputs();
    [CompilerGeneratedAttribute]
public void set_Inputs(Folder value);
    [CompilerGeneratedAttribute]
public Folder get_Results();
    [CompilerGeneratedAttribute]
public void set_Results(Folder value);
}
public class Microsoft.Build.Logging.StructuredLogger.RobocopyTask : CopyTask {
    protected virtual IEnumerable`1<FileCopyOperation> GetFileCopyOperations();
}
public class Microsoft.Build.Logging.StructuredLogger.SearchableItem : Item {
    private string _searchText;
    public string SearchText { get; public set; }
    public string get_SearchText();
    public void set_SearchText(string value);
}
public class Microsoft.Build.Logging.StructuredLogger.SearchIndex : object {
    private int stringCount;
    private String[] strings;
    private Byte[] bitVector;
    private ChunkedList`1<NodeEntry> nodeEntries;
    private Dictionary`2<string, int> stringToIndexMap;
    private int taskString;
    private int typeKeyword;
    [CompilerGeneratedAttribute]
private int <MaxResults>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <MarkResultsInTree>k__BackingField;
    public TimeSpan PrecalculationDuration;
    private bool hasThreads;
    private Build build;
    public static int BufferSize;
    public int MaxResults { get; public set; }
    public bool MarkResultsInTree { get; public set; }
    public String[] Strings { get; }
    public int NodeCount { get; }
    public SearchIndex(Build build);
    [CompilerGeneratedAttribute]
public int get_MaxResults();
    [CompilerGeneratedAttribute]
public void set_MaxResults(int value);
    [CompilerGeneratedAttribute]
public bool get_MarkResultsInTree();
    [CompilerGeneratedAttribute]
public void set_MarkResultsInTree(bool value);
    public String[] get_Strings();
    public int get_NodeCount();
    private void PopulateEntriesInParallel(Build build);
    private void AddNodes(BaseNode node, Action`1<BaseNode> collector);
    private int GetStringIndex(string text);
    private void Visit(BaseNode node);
    private NodeEntry GetEntry(BaseNode node);
    public IEnumerable`1<SearchResult> FindNodes(string query, CancellationToken cancellationToken);
    private bool SearchChunk(List`1<SearchResult> results, NodeQueryMatcher matcher, Term[] terms, bool searching, List`1<NodeEntry> chunk);
    private void ComputeBits(Term[] terms, int stringIndex, string typeString);
    public SearchResult IsMatch(NodeQueryMatcher matcher, NodeEntry entry, Term[] terms);
}
[ExtensionAttribute]
public static class Microsoft.Build.Logging.StructuredLogger.Serialization : object {
    public static string FileDialogFilter;
    public static string BinlogFileDialogFilter;
    public static string OpenFileDialogFilter;
    public static XName[] AttributeNameList;
    public static String[] AttributeLocalNameList;
    private static Dictionary`2<string, Type> objectModelTypes;
    public static Dictionary`2<string, Type> ObjectModelTypes { get; }
    private static Serialization();
    public static Dictionary`2<string, Type> get_ObjectModelTypes();
    public static Build ReadXmlLog(Stream stream);
    public static Build ReadBuildLog(Stream stream, Byte[] projectImportsArchive);
    public static Build ReadBinLog(Stream stream, Byte[] projectImportsArchive);
    public static Build Read(string filePath);
    public static Build Read(string filePath, Progress progress);
    public static Build Read(string filePath, Progress progress, ReaderSettings readerSettings);
    private static Build ReadOld1_2FormatBuild(string filePath);
    public static string DetectLogFormat(string filePath);
    public static void Write(Build build, string filePath);
    public static string GetNodeName(BaseNode node);
    public static bool IsValidXmlElementName(string name);
    public static BaseNode CreateNode(string name);
    public static bool GetBoolean(string text);
    public static DateTime GetDateTime(string text);
    public static int GetInteger(string text);
    [ExtensionAttribute]
public static int Read7BitEncodedInt(BinaryReader reader);
    [ExtensionAttribute]
public static void Write7BitEncodedInt(BinaryWriter writer, int value);
    public static void WriteStringsToFile(string outputFilePath, String[] strings);
    public static IReadOnlyList`1<string> ReadStringsFromFile(string filePath);
}
public class Microsoft.Build.Logging.StructuredLogger.SourceFile : NamedNode {
    [CompilerGeneratedAttribute]
private string <SourceFilePath>k__BackingField;
    public string SourceFilePath { get; public set; }
    public string TypeName { get; }
    [CompilerGeneratedAttribute]
public sealed virtual string get_SourceFilePath();
    [CompilerGeneratedAttribute]
public void set_SourceFilePath(string value);
    public virtual string get_TypeName();
}
public class Microsoft.Build.Logging.StructuredLogger.SourceFileLine : TreeNode {
    [CompilerGeneratedAttribute]
private int <LineNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LineText>k__BackingField;
    public int LineNumber { get; public set; }
    public string LineText { get; public set; }
    public string TypeName { get; }
    [CompilerGeneratedAttribute]
public int get_LineNumber();
    [CompilerGeneratedAttribute]
public void set_LineNumber(int value);
    [CompilerGeneratedAttribute]
public string get_LineText();
    [CompilerGeneratedAttribute]
public void set_LineText(string value);
    public virtual string get_TypeName();
    public virtual string ToString();
}
public class Microsoft.Build.Logging.StructuredLogger.Span : ValueType {
    public int Start;
    public int Length;
    public static Span Empty;
    public int End { get; }
    public Span(int start, int length);
    private static Span();
    public int get_End();
    public virtual string ToString();
    public Span Skip(int length);
    public bool ContainsEndInclusive(int position);
    public bool Contains(int position);
}
public class Microsoft.Build.Logging.StructuredLogger.StreamChunkOverReadException : Exception {
    public StreamChunkOverReadException(string message);
    public StreamChunkOverReadException(string message, Exception inner);
}
public class Microsoft.Build.Logging.StructuredLogger.StringCache : object {
    private Dictionary`2<string, string> deduplicationMap;
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <Instances>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DisableDeduplication>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <NormalizeLineEndings>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasDeduplicatedStrings>k__BackingField;
    public IEnumerable`1<string> Instances { get; public set; }
    public bool DisableDeduplication { get; public set; }
    public bool NormalizeLineEndings { get; public set; }
    public bool HasDeduplicatedStrings { get; public set; }
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_Instances();
    [CompilerGeneratedAttribute]
public void set_Instances(IEnumerable`1<string> value);
    public void Seal();
    public void SetStrings(IEnumerable`1<string> strings);
    public void Intern(IEnumerable`1<string> strings);
    [CompilerGeneratedAttribute]
public bool get_DisableDeduplication();
    [CompilerGeneratedAttribute]
public void set_DisableDeduplication(bool value);
    [CompilerGeneratedAttribute]
public bool get_NormalizeLineEndings();
    [CompilerGeneratedAttribute]
public void set_NormalizeLineEndings(bool value);
    [CompilerGeneratedAttribute]
public bool get_HasDeduplicatedStrings();
    [CompilerGeneratedAttribute]
public void set_HasDeduplicatedStrings(bool value);
    public string SoftIntern(string text);
    public string Intern(string text);
    public bool Contains(string text);
    public IDictionary`2<string, string> InternStringDictionary(IDictionary`2<string, string> inputDictionary);
    public IReadOnlyList`1<string> InternList(IReadOnlyList`1<string> inputList);
}
public class Microsoft.Build.Logging.StructuredLogger.StringReadEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private string <OriginalString>k__BackingField;
    [CompilerGeneratedAttribute]
private string <StringToBeUsed>k__BackingField;
    public string OriginalString { get; private set; }
    public string StringToBeUsed { get; public set; }
    public StringReadEventArgs(string str);
    [CompilerGeneratedAttribute]
public string get_OriginalString();
    [CompilerGeneratedAttribute]
private void set_OriginalString(string value);
    [CompilerGeneratedAttribute]
public string get_StringToBeUsed();
    [CompilerGeneratedAttribute]
public void set_StringToBeUsed(string value);
    internal void Reuse(string newValue);
}
public class Microsoft.Build.Logging.StructuredLogger.Strings : object {
    private static object locker;
    [CompilerGeneratedAttribute]
private static StringsSet <ResourceSet>k__BackingField;
    [CompilerGeneratedAttribute]
private static Regex <RemovingProjectProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private static Regex <DuplicateImport>k__BackingField;
    [CompilerGeneratedAttribute]
private static Regex <SearchPathsForMSBuildExtensionsPath>k__BackingField;
    [CompilerGeneratedAttribute]
private static Regex <OverridingTarget>k__BackingField;
    [CompilerGeneratedAttribute]
private static Regex <TryingExtensionsPath>k__BackingField;
    [CompilerGeneratedAttribute]
private static Regex <ProjectImportedRegex>k__BackingField;
    [CompilerGeneratedAttribute]
private static Regex <BuildingWithToolsVersionPrefix>k__BackingField;
    [CompilerGeneratedAttribute]
private static Regex <ForSearchPathPrefix>k__BackingField;
    [CompilerGeneratedAttribute]
private static Regex <ProjectImportSkippedMissingFileRegex>k__BackingField;
    [CompilerGeneratedAttribute]
private static Regex <ProjectImportSkippedInvalidFileRegex>k__BackingField;
    [CompilerGeneratedAttribute]
private static Regex <ProjectImportSkippedEmptyFileRegex>k__BackingField;
    [CompilerGeneratedAttribute]
private static Regex <ProjectImportSkippedFalseConditionRegex>k__BackingField;
    [CompilerGeneratedAttribute]
private static Regex <ProjectImportSkippedExpressionEvaluatedToEmptyRegex>k__BackingField;
    [CompilerGeneratedAttribute]
private static Regex <ProjectImportSkippedNoMatchesRegex>k__BackingField;
    [CompilerGeneratedAttribute]
private static Regex <PropertyReassignmentRegex>k__BackingField;
    [CompilerGeneratedAttribute]
private static Regex <DeferredResponseFileRegex>k__BackingField;
    [CompilerGeneratedAttribute]
private static Regex <MessageMetaprojectGenerated>k__BackingField;
    [CompilerGeneratedAttribute]
private static Regex <UnifiedPrimaryReferencePrefix>k__BackingField;
    [CompilerGeneratedAttribute]
private static Regex <PrimaryReferencePrefix>k__BackingField;
    [CompilerGeneratedAttribute]
private static Regex <DependencyPrefix>k__BackingField;
    [CompilerGeneratedAttribute]
private static Regex <UnifiedDependencyPrefix>k__BackingField;
    [CompilerGeneratedAttribute]
private static Regex <AssemblyFoldersExLocation>k__BackingField;
    [CompilerGeneratedAttribute]
private static Regex <ConflictReferenceSameSDK>k__BackingField;
    [CompilerGeneratedAttribute]
private static Regex <ConflictRedistDifferentSDK>k__BackingField;
    [CompilerGeneratedAttribute]
private static Regex <ConflictFoundRegex>k__BackingField;
    [CompilerGeneratedAttribute]
private static Regex <FoundConflictsRegex>k__BackingField;
    [CompilerGeneratedAttribute]
private static Regex <ConflictReferenceDifferentSDK>k__BackingField;
    [CompilerGeneratedAttribute]
private static Regex <AdditionalPropertiesPrefix>k__BackingField;
    [CompilerGeneratedAttribute]
private static Regex <OverridingGlobalPropertiesPrefix>k__BackingField;
    [CompilerGeneratedAttribute]
private static Regex <CopyingFileFromRegex>k__BackingField;
    [CompilerGeneratedAttribute]
private static Regex <CreatingHardLinkRegex>k__BackingField;
    [CompilerGeneratedAttribute]
private static Regex <DidNotCopyRegex>k__BackingField;
    [CompilerGeneratedAttribute]
private static Regex <RobocopyFileCopiedRegex>k__BackingField;
    [CompilerGeneratedAttribute]
private static Regex <RobocopyFileSkippedRegex>k__BackingField;
    [CompilerGeneratedAttribute]
private static Regex <RobocopyFileSkippedAsDuplicateRegex>k__BackingField;
    [CompilerGeneratedAttribute]
private static Regex <RobocopyFileFailedRegex>k__BackingField;
    [CompilerGeneratedAttribute]
private static Regex <TargetDoesNotExistBeforeTargetMessage>k__BackingField;
    [CompilerGeneratedAttribute]
private static Regex <TargetAlreadyCompleteSuccessRegex>k__BackingField;
    [CompilerGeneratedAttribute]
private static Regex <TargetAlreadyCompleteFailureRegex>k__BackingField;
    [CompilerGeneratedAttribute]
private static Regex <TargetSkippedFalseConditionRegex>k__BackingField;
    [CompilerGeneratedAttribute]
private static Regex <TaskSkippedFalseConditionRegex>k__BackingField;
    [CompilerGeneratedAttribute]
private static Regex <TargetSkippedWhenSkipNonexistentTargets>k__BackingField;
    [CompilerGeneratedAttribute]
private static Regex <SkipTargetBecauseOutputsUpToDateRegex>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <TaskFoundFromFactory>k__BackingField;
    [CompilerGeneratedAttribute]
private static Regex <TaskFoundFromFactoryRegex>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <TaskFound>k__BackingField;
    [CompilerGeneratedAttribute]
private static Regex <TaskFoundRegex>k__BackingField;
    [CompilerGeneratedAttribute]
private static Regex <CouldNotResolveSdkRegex>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <TargetSkippedFalseCondition>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <TargetAlreadyCompleteSuccess>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <TargetAlreadyCompleteFailure>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <ProjectImported>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <ProjectImportSkippedFalseCondition>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <CouldNotResolveSdk>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <ProjectImportSkippedExpressionEvaluatedToEmpty>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <PropertyReassignment>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <ProjectImportSkippedNoMatches>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <ProjectImportSkippedMissingFile>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <ProjectImportSkippedInvalidFile>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <ProjectImportSkippedEmptyFile>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <TaskSkippedFalseCondition>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <MetaprojectGenerated>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <PropertyGroupMessagePrefix>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <OutputPropertyMessagePrefix>k__BackingField;
    public static string UnusedLocations;
    [CompilerGeneratedAttribute]
private static string <TaskParameterMessagePrefix>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <OutputItemsMessagePrefix>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <ItemGroupIncludeMessagePrefix>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <ItemGroupRemoveMessagePrefix>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <GlobalPropertiesPrefix>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <RemovingPropertiesPrefix>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <EvaluationStarted>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <EvaluationFinished>k__BackingField;
    public static string RestoreTask_CheckingCompatibilityFor;
    public static string RestoreTask_CheckingCompatibilityOfPackages;
    public static string RestoreTask_AcquiringLockForTheInstallation;
    public static string RestoreTask_AcquiredLockForTheInstallation;
    public static string RestoreTask_CompletedInstallationOf;
    public static string RestoreTask_ResolvingConflictsFor;
    public static string RestoreTask_AllPackagesAndProjectsAreCompatible;
    public static string RestoreTask_Committing;
    public static string Items;
    public static string Statistics;
    public static string Folder;
    public static string Warnings;
    public static string NodesReusal;
    public static string NodesManagementNode;
    public static string NoImportEmptyExpression;
    public static string NoImportNoMatches;
    public static string NoImportMissingFile;
    public static string NoImportInvalidFile;
    public static string Errors;
    public static string Task;
    private static string RobocopyFileCopiedMessage;
    private static string RobocopyFileSkippedMessage;
    private static string RobocopyFileSkippedAsDuplicateMessage;
    private static string RobocopyFileFailedMessage;
    public static StringsSet ResourceSet { get; private set; }
    public static string Culture { get; }
    public static Regex RemovingProjectProperties { get; public set; }
    public static Regex DuplicateImport { get; public set; }
    public static Regex SearchPathsForMSBuildExtensionsPath { get; public set; }
    public static Regex OverridingTarget { get; public set; }
    public static Regex TryingExtensionsPath { get; public set; }
    public static Regex ProjectImportedRegex { get; public set; }
    public static Regex BuildingWithToolsVersionPrefix { get; public set; }
    public static Regex ForSearchPathPrefix { get; public set; }
    public static Regex ProjectImportSkippedMissingFileRegex { get; public set; }
    public static Regex ProjectImportSkippedInvalidFileRegex { get; public set; }
    public static Regex ProjectImportSkippedEmptyFileRegex { get; public set; }
    public static Regex ProjectImportSkippedFalseConditionRegex { get; public set; }
    public static Regex ProjectImportSkippedExpressionEvaluatedToEmptyRegex { get; public set; }
    public static Regex ProjectImportSkippedNoMatchesRegex { get; public set; }
    public static Regex PropertyReassignmentRegex { get; public set; }
    public static Regex DeferredResponseFileRegex { get; public set; }
    public static Regex MessageMetaprojectGenerated { get; public set; }
    public static Regex UnifiedPrimaryReferencePrefix { get; public set; }
    public static Regex PrimaryReferencePrefix { get; public set; }
    public static Regex DependencyPrefix { get; public set; }
    public static Regex UnifiedDependencyPrefix { get; public set; }
    public static Regex AssemblyFoldersExLocation { get; public set; }
    public static Regex ConflictReferenceSameSDK { get; public set; }
    public static Regex ConflictRedistDifferentSDK { get; public set; }
    public static Regex ConflictFoundRegex { get; public set; }
    public static Regex FoundConflictsRegex { get; public set; }
    public static Regex ConflictReferenceDifferentSDK { get; public set; }
    public static Regex AdditionalPropertiesPrefix { get; public set; }
    public static Regex OverridingGlobalPropertiesPrefix { get; public set; }
    public static Regex CopyingFileFromRegex { get; public set; }
    public static Regex CreatingHardLinkRegex { get; public set; }
    public static Regex DidNotCopyRegex { get; public set; }
    public static Regex RobocopyFileCopiedRegex { get; public set; }
    public static Regex RobocopyFileSkippedRegex { get; public set; }
    public static Regex RobocopyFileSkippedAsDuplicateRegex { get; public set; }
    public static Regex RobocopyFileFailedRegex { get; public set; }
    public static Regex TargetDoesNotExistBeforeTargetMessage { get; public set; }
    public static Regex TargetAlreadyCompleteSuccessRegex { get; public set; }
    public static Regex TargetAlreadyCompleteFailureRegex { get; public set; }
    public static Regex TargetSkippedFalseConditionRegex { get; public set; }
    public static Regex TaskSkippedFalseConditionRegex { get; public set; }
    public static Regex TargetSkippedWhenSkipNonexistentTargets { get; public set; }
    public static Regex SkipTargetBecauseOutputsUpToDateRegex { get; public set; }
    public static string TaskFoundFromFactory { get; public set; }
    public static Regex TaskFoundFromFactoryRegex { get; public set; }
    public static string TaskFound { get; public set; }
    public static Regex TaskFoundRegex { get; public set; }
    public static Regex CouldNotResolveSdkRegex { get; public set; }
    public static string TargetSkippedFalseCondition { get; public set; }
    public static string TargetAlreadyCompleteSuccess { get; public set; }
    public static string TargetAlreadyCompleteFailure { get; public set; }
    public static string ProjectImported { get; public set; }
    public static string ProjectImportSkippedFalseCondition { get; public set; }
    public static string CouldNotResolveSdk { get; public set; }
    public static string ProjectImportSkippedExpressionEvaluatedToEmpty { get; public set; }
    public static string PropertyReassignment { get; public set; }
    public static string ProjectImportSkippedNoMatches { get; public set; }
    public static string ProjectImportSkippedMissingFile { get; public set; }
    public static string ProjectImportSkippedInvalidFile { get; public set; }
    public static string ProjectImportSkippedEmptyFile { get; public set; }
    public static string TaskSkippedFalseCondition { get; public set; }
    public static string MetaprojectGenerated { get; public set; }
    public static string PropertyGroupMessagePrefix { get; public set; }
    public static string OutputPropertyMessagePrefix { get; public set; }
    public static string UsedAssemblySearchPathsLocations { get; }
    public static string UnusedAssemblySearchPathsLocations { get; }
    public static string UsedLocations { get; }
    public static string TaskParameterMessagePrefix { get; public set; }
    public static string OutputItemsMessagePrefix { get; public set; }
    public static string ItemGroupIncludeMessagePrefix { get; public set; }
    public static string ItemGroupRemoveMessagePrefix { get; public set; }
    public static string GlobalPropertiesPrefix { get; public set; }
    public static string RemovingPropertiesPrefix { get; public set; }
    public static string EvaluationStarted { get; public set; }
    public static string EvaluationFinished { get; public set; }
    public static string To { get; }
    public static string ToFile { get; }
    public static string TotalAnalyzerExecutionTime { get; }
    public static string TotalGeneratorExecutionTime { get; }
    public static string Evaluation { get; }
    public static string Environment { get; }
    public static string TruncatedEnvironment { get; }
    public static string Imports { get; }
    public static string Messages { get; }
    public static string DetailedSummary { get; }
    public static string Parameters { get; }
    public static string Results { get; }
    public static string SearchPaths { get; }
    public static string Assemblies { get; }
    public static string TargetOutputs { get; }
    public static string AnalyzerReport { get; }
    public static string GeneratorReport { get; }
    public static string Properties { get; }
    public static string PropertyReassignmentFolder { get; }
    public static string Global { get; }
    public static string EntryTargets { get; }
    public static string TargetFramework { get; }
    public static string Platform { get; }
    public static string Configuration { get; }
    public static string TargetFrameworks { get; }
    public static string TargetFrameworkVersion { get; }
    public static string AdditionalProperties { get; }
    public static string OutputItems { get; }
    public static string OutputProperties { get; }
    public static string Inputs { get; }
    public static string Outputs { get; }
    public static string Assembly { get; }
    public static string CommandLineArguments { get; }
    public static string Item { get; }
    public static string AddItem { get; }
    public static string RemoveItem { get; }
    public static string Metadata { get; }
    public static string Property { get; }
    public static string Duration { get; }
    public static string Note { get; }
    public static string DoubleWrites { get; }
    public static string MSBuildVersionPrefix { get; }
    public static string MSBuildExecutablePathPrefix { get; }
    private static Strings();
    [CompilerGeneratedAttribute]
public static StringsSet get_ResourceSet();
    [CompilerGeneratedAttribute]
private static void set_ResourceSet(StringsSet value);
    public static void Initialize(string culture);
    public static string get_Culture();
    public static string GetString(string key);
    public static string Escape(string text);
    private static void InitializeRegex();
    private static string GetEmptyConditionText();
    private static string GetSkippedFalseConditionText();
    private static string GetSkippedNoMatchesText();
    private static string GetSkippedEmptyFileText();
    private static string GetProjectImportedText();
    private static string GetPropertyReassignmentText();
    public static Regex CreateRegex(string text, int replacePlaceholders, RegexOptions options, bool capture);
    [CompilerGeneratedAttribute]
public static Regex get_RemovingProjectProperties();
    [CompilerGeneratedAttribute]
public static void set_RemovingProjectProperties(Regex value);
    [CompilerGeneratedAttribute]
public static Regex get_DuplicateImport();
    [CompilerGeneratedAttribute]
public static void set_DuplicateImport(Regex value);
    [CompilerGeneratedAttribute]
public static Regex get_SearchPathsForMSBuildExtensionsPath();
    [CompilerGeneratedAttribute]
public static void set_SearchPathsForMSBuildExtensionsPath(Regex value);
    [CompilerGeneratedAttribute]
public static Regex get_OverridingTarget();
    [CompilerGeneratedAttribute]
public static void set_OverridingTarget(Regex value);
    [CompilerGeneratedAttribute]
public static Regex get_TryingExtensionsPath();
    [CompilerGeneratedAttribute]
public static void set_TryingExtensionsPath(Regex value);
    [CompilerGeneratedAttribute]
public static Regex get_ProjectImportedRegex();
    [CompilerGeneratedAttribute]
public static void set_ProjectImportedRegex(Regex value);
    [CompilerGeneratedAttribute]
public static Regex get_BuildingWithToolsVersionPrefix();
    [CompilerGeneratedAttribute]
public static void set_BuildingWithToolsVersionPrefix(Regex value);
    [CompilerGeneratedAttribute]
public static Regex get_ForSearchPathPrefix();
    [CompilerGeneratedAttribute]
public static void set_ForSearchPathPrefix(Regex value);
    [CompilerGeneratedAttribute]
public static Regex get_ProjectImportSkippedMissingFileRegex();
    [CompilerGeneratedAttribute]
public static void set_ProjectImportSkippedMissingFileRegex(Regex value);
    [CompilerGeneratedAttribute]
public static Regex get_ProjectImportSkippedInvalidFileRegex();
    [CompilerGeneratedAttribute]
public static void set_ProjectImportSkippedInvalidFileRegex(Regex value);
    [CompilerGeneratedAttribute]
public static Regex get_ProjectImportSkippedEmptyFileRegex();
    [CompilerGeneratedAttribute]
public static void set_ProjectImportSkippedEmptyFileRegex(Regex value);
    [CompilerGeneratedAttribute]
public static Regex get_ProjectImportSkippedFalseConditionRegex();
    [CompilerGeneratedAttribute]
public static void set_ProjectImportSkippedFalseConditionRegex(Regex value);
    [CompilerGeneratedAttribute]
public static Regex get_ProjectImportSkippedExpressionEvaluatedToEmptyRegex();
    [CompilerGeneratedAttribute]
public static void set_ProjectImportSkippedExpressionEvaluatedToEmptyRegex(Regex value);
    [CompilerGeneratedAttribute]
public static Regex get_ProjectImportSkippedNoMatchesRegex();
    [CompilerGeneratedAttribute]
public static void set_ProjectImportSkippedNoMatchesRegex(Regex value);
    [CompilerGeneratedAttribute]
public static Regex get_PropertyReassignmentRegex();
    [CompilerGeneratedAttribute]
public static void set_PropertyReassignmentRegex(Regex value);
    [CompilerGeneratedAttribute]
public static Regex get_DeferredResponseFileRegex();
    [CompilerGeneratedAttribute]
public static void set_DeferredResponseFileRegex(Regex value);
    [CompilerGeneratedAttribute]
public static Regex get_MessageMetaprojectGenerated();
    [CompilerGeneratedAttribute]
public static void set_MessageMetaprojectGenerated(Regex value);
    [CompilerGeneratedAttribute]
public static Regex get_UnifiedPrimaryReferencePrefix();
    [CompilerGeneratedAttribute]
public static void set_UnifiedPrimaryReferencePrefix(Regex value);
    [CompilerGeneratedAttribute]
public static Regex get_PrimaryReferencePrefix();
    [CompilerGeneratedAttribute]
public static void set_PrimaryReferencePrefix(Regex value);
    [CompilerGeneratedAttribute]
public static Regex get_DependencyPrefix();
    [CompilerGeneratedAttribute]
public static void set_DependencyPrefix(Regex value);
    [CompilerGeneratedAttribute]
public static Regex get_UnifiedDependencyPrefix();
    [CompilerGeneratedAttribute]
public static void set_UnifiedDependencyPrefix(Regex value);
    [CompilerGeneratedAttribute]
public static Regex get_AssemblyFoldersExLocation();
    [CompilerGeneratedAttribute]
public static void set_AssemblyFoldersExLocation(Regex value);
    [CompilerGeneratedAttribute]
public static Regex get_ConflictReferenceSameSDK();
    [CompilerGeneratedAttribute]
public static void set_ConflictReferenceSameSDK(Regex value);
    [CompilerGeneratedAttribute]
public static Regex get_ConflictRedistDifferentSDK();
    [CompilerGeneratedAttribute]
public static void set_ConflictRedistDifferentSDK(Regex value);
    [CompilerGeneratedAttribute]
public static Regex get_ConflictFoundRegex();
    [CompilerGeneratedAttribute]
public static void set_ConflictFoundRegex(Regex value);
    [CompilerGeneratedAttribute]
public static Regex get_FoundConflictsRegex();
    [CompilerGeneratedAttribute]
public static void set_FoundConflictsRegex(Regex value);
    [CompilerGeneratedAttribute]
public static Regex get_ConflictReferenceDifferentSDK();
    [CompilerGeneratedAttribute]
public static void set_ConflictReferenceDifferentSDK(Regex value);
    [CompilerGeneratedAttribute]
public static Regex get_AdditionalPropertiesPrefix();
    [CompilerGeneratedAttribute]
public static void set_AdditionalPropertiesPrefix(Regex value);
    [CompilerGeneratedAttribute]
public static Regex get_OverridingGlobalPropertiesPrefix();
    [CompilerGeneratedAttribute]
public static void set_OverridingGlobalPropertiesPrefix(Regex value);
    [CompilerGeneratedAttribute]
public static Regex get_CopyingFileFromRegex();
    [CompilerGeneratedAttribute]
public static void set_CopyingFileFromRegex(Regex value);
    [CompilerGeneratedAttribute]
public static Regex get_CreatingHardLinkRegex();
    [CompilerGeneratedAttribute]
public static void set_CreatingHardLinkRegex(Regex value);
    [CompilerGeneratedAttribute]
public static Regex get_DidNotCopyRegex();
    [CompilerGeneratedAttribute]
public static void set_DidNotCopyRegex(Regex value);
    [CompilerGeneratedAttribute]
public static Regex get_RobocopyFileCopiedRegex();
    [CompilerGeneratedAttribute]
public static void set_RobocopyFileCopiedRegex(Regex value);
    [CompilerGeneratedAttribute]
public static Regex get_RobocopyFileSkippedRegex();
    [CompilerGeneratedAttribute]
public static void set_RobocopyFileSkippedRegex(Regex value);
    [CompilerGeneratedAttribute]
public static Regex get_RobocopyFileSkippedAsDuplicateRegex();
    [CompilerGeneratedAttribute]
public static void set_RobocopyFileSkippedAsDuplicateRegex(Regex value);
    [CompilerGeneratedAttribute]
public static Regex get_RobocopyFileFailedRegex();
    [CompilerGeneratedAttribute]
public static void set_RobocopyFileFailedRegex(Regex value);
    [CompilerGeneratedAttribute]
public static Regex get_TargetDoesNotExistBeforeTargetMessage();
    [CompilerGeneratedAttribute]
public static void set_TargetDoesNotExistBeforeTargetMessage(Regex value);
    [CompilerGeneratedAttribute]
public static Regex get_TargetAlreadyCompleteSuccessRegex();
    [CompilerGeneratedAttribute]
public static void set_TargetAlreadyCompleteSuccessRegex(Regex value);
    [CompilerGeneratedAttribute]
public static Regex get_TargetAlreadyCompleteFailureRegex();
    [CompilerGeneratedAttribute]
public static void set_TargetAlreadyCompleteFailureRegex(Regex value);
    [CompilerGeneratedAttribute]
public static Regex get_TargetSkippedFalseConditionRegex();
    [CompilerGeneratedAttribute]
public static void set_TargetSkippedFalseConditionRegex(Regex value);
    [CompilerGeneratedAttribute]
public static Regex get_TaskSkippedFalseConditionRegex();
    [CompilerGeneratedAttribute]
public static void set_TaskSkippedFalseConditionRegex(Regex value);
    [CompilerGeneratedAttribute]
public static Regex get_TargetSkippedWhenSkipNonexistentTargets();
    [CompilerGeneratedAttribute]
public static void set_TargetSkippedWhenSkipNonexistentTargets(Regex value);
    [CompilerGeneratedAttribute]
public static Regex get_SkipTargetBecauseOutputsUpToDateRegex();
    [CompilerGeneratedAttribute]
public static void set_SkipTargetBecauseOutputsUpToDateRegex(Regex value);
    [CompilerGeneratedAttribute]
public static string get_TaskFoundFromFactory();
    [CompilerGeneratedAttribute]
public static void set_TaskFoundFromFactory(string value);
    [CompilerGeneratedAttribute]
public static Regex get_TaskFoundFromFactoryRegex();
    [CompilerGeneratedAttribute]
public static void set_TaskFoundFromFactoryRegex(Regex value);
    [CompilerGeneratedAttribute]
public static string get_TaskFound();
    [CompilerGeneratedAttribute]
public static void set_TaskFound(string value);
    [CompilerGeneratedAttribute]
public static Regex get_TaskFoundRegex();
    [CompilerGeneratedAttribute]
public static void set_TaskFoundRegex(Regex value);
    [CompilerGeneratedAttribute]
public static Regex get_CouldNotResolveSdkRegex();
    [CompilerGeneratedAttribute]
public static void set_CouldNotResolveSdkRegex(Regex value);
    [CompilerGeneratedAttribute]
public static string get_TargetSkippedFalseCondition();
    [CompilerGeneratedAttribute]
public static void set_TargetSkippedFalseCondition(string value);
    [CompilerGeneratedAttribute]
public static string get_TargetAlreadyCompleteSuccess();
    [CompilerGeneratedAttribute]
public static void set_TargetAlreadyCompleteSuccess(string value);
    [CompilerGeneratedAttribute]
public static string get_TargetAlreadyCompleteFailure();
    [CompilerGeneratedAttribute]
public static void set_TargetAlreadyCompleteFailure(string value);
    [CompilerGeneratedAttribute]
public static string get_ProjectImported();
    [CompilerGeneratedAttribute]
public static void set_ProjectImported(string value);
    [CompilerGeneratedAttribute]
public static string get_ProjectImportSkippedFalseCondition();
    [CompilerGeneratedAttribute]
public static void set_ProjectImportSkippedFalseCondition(string value);
    [CompilerGeneratedAttribute]
public static string get_CouldNotResolveSdk();
    [CompilerGeneratedAttribute]
public static void set_CouldNotResolveSdk(string value);
    [CompilerGeneratedAttribute]
public static string get_ProjectImportSkippedExpressionEvaluatedToEmpty();
    [CompilerGeneratedAttribute]
public static void set_ProjectImportSkippedExpressionEvaluatedToEmpty(string value);
    [CompilerGeneratedAttribute]
public static string get_PropertyReassignment();
    [CompilerGeneratedAttribute]
public static void set_PropertyReassignment(string value);
    [CompilerGeneratedAttribute]
public static string get_ProjectImportSkippedNoMatches();
    [CompilerGeneratedAttribute]
public static void set_ProjectImportSkippedNoMatches(string value);
    [CompilerGeneratedAttribute]
public static string get_ProjectImportSkippedMissingFile();
    [CompilerGeneratedAttribute]
public static void set_ProjectImportSkippedMissingFile(string value);
    [CompilerGeneratedAttribute]
public static string get_ProjectImportSkippedInvalidFile();
    [CompilerGeneratedAttribute]
public static void set_ProjectImportSkippedInvalidFile(string value);
    [CompilerGeneratedAttribute]
public static string get_ProjectImportSkippedEmptyFile();
    [CompilerGeneratedAttribute]
public static void set_ProjectImportSkippedEmptyFile(string value);
    [CompilerGeneratedAttribute]
public static string get_TaskSkippedFalseCondition();
    [CompilerGeneratedAttribute]
public static void set_TaskSkippedFalseCondition(string value);
    [CompilerGeneratedAttribute]
public static string get_MetaprojectGenerated();
    [CompilerGeneratedAttribute]
public static void set_MetaprojectGenerated(string value);
    public static Match UsingTask(string message, string rawMessage);
    public static TargetSkipReason GetTargetSkipReason(string message);
    public static bool IsTargetDoesNotExistAndWillBeSkipped(string message);
    public static Match ProjectWasNotImportedRegex(string message, String& reason);
    public static bool IsThereWasAConflictPrefix(string message);
    public static Match IsFoundConflicts(string text);
    [CompilerGeneratedAttribute]
public static string get_PropertyGroupMessagePrefix();
    [CompilerGeneratedAttribute]
public static void set_PropertyGroupMessagePrefix(string value);
    [CompilerGeneratedAttribute]
public static string get_OutputPropertyMessagePrefix();
    [CompilerGeneratedAttribute]
public static void set_OutputPropertyMessagePrefix(string value);
    public static string get_UsedAssemblySearchPathsLocations();
    public static string get_UnusedAssemblySearchPathsLocations();
    public static string get_UsedLocations();
    [CompilerGeneratedAttribute]
public static string get_TaskParameterMessagePrefix();
    [CompilerGeneratedAttribute]
public static void set_TaskParameterMessagePrefix(string value);
    [CompilerGeneratedAttribute]
public static string get_OutputItemsMessagePrefix();
    [CompilerGeneratedAttribute]
public static void set_OutputItemsMessagePrefix(string value);
    [CompilerGeneratedAttribute]
public static string get_ItemGroupIncludeMessagePrefix();
    [CompilerGeneratedAttribute]
public static void set_ItemGroupIncludeMessagePrefix(string value);
    [CompilerGeneratedAttribute]
public static string get_ItemGroupRemoveMessagePrefix();
    [CompilerGeneratedAttribute]
public static void set_ItemGroupRemoveMessagePrefix(string value);
    [CompilerGeneratedAttribute]
public static string get_GlobalPropertiesPrefix();
    [CompilerGeneratedAttribute]
public static void set_GlobalPropertiesPrefix(string value);
    [CompilerGeneratedAttribute]
public static string get_RemovingPropertiesPrefix();
    [CompilerGeneratedAttribute]
public static void set_RemovingPropertiesPrefix(string value);
    [CompilerGeneratedAttribute]
public static string get_EvaluationStarted();
    [CompilerGeneratedAttribute]
public static void set_EvaluationStarted(string value);
    [CompilerGeneratedAttribute]
public static string get_EvaluationFinished();
    [CompilerGeneratedAttribute]
public static void set_EvaluationFinished(string value);
    public static string get_To();
    public static string get_ToFile();
    public static string get_TotalAnalyzerExecutionTime();
    public static string get_TotalGeneratorExecutionTime();
    public static string get_Evaluation();
    public static string get_Environment();
    public static string get_TruncatedEnvironment();
    public static string get_Imports();
    public static string get_Messages();
    public static string get_DetailedSummary();
    public static string get_Parameters();
    public static string get_Results();
    public static string get_SearchPaths();
    public static string get_Assemblies();
    public static string get_TargetOutputs();
    public static string get_AnalyzerReport();
    public static string get_GeneratorReport();
    public static string get_Properties();
    public static string get_PropertyReassignmentFolder();
    public static string get_Global();
    public static string get_EntryTargets();
    public static string get_TargetFramework();
    public static string get_Platform();
    public static string get_Configuration();
    public static string get_TargetFrameworks();
    public static string get_TargetFrameworkVersion();
    public static string get_AdditionalProperties();
    public static string get_OutputItems();
    public static string get_OutputProperties();
    public static string get_Inputs();
    public static string get_Outputs();
    public static string get_Assembly();
    public static string get_CommandLineArguments();
    public static string get_Item();
    public static string get_AddItem();
    public static string get_RemoveItem();
    public static string get_Metadata();
    public static string get_Property();
    public static string get_Duration();
    public static string get_Note();
    public static string get_DoubleWrites();
    public static string get_MSBuildVersionPrefix();
    public static string get_MSBuildExecutablePathPrefix();
    public static string GetPropertyName(string message);
    public static bool IsEvaluationMessage(string message);
}
public class Microsoft.Build.Logging.StructuredLogger.StringsSet : object {
    private Dictionary`2<string, string> currentSet;
    [CompilerGeneratedAttribute]
private string <Culture>k__BackingField;
    private static object lockObject;
    private static Dictionary`2<string, Dictionary`2<string, string>> resourcesCollection;
    public string Culture { get; public set; }
    public static Dictionary`2<string, Dictionary`2<string, string>> ResourcesCollection { get; }
    public StringsSet(string culture);
    private static StringsSet();
    [CompilerGeneratedAttribute]
public string get_Culture();
    [CompilerGeneratedAttribute]
public void set_Culture(string value);
    public static Dictionary`2<string, Dictionary`2<string, string>> get_ResourcesCollection();
    public string GetString(string key);
}
internal class Microsoft.Build.Logging.StructuredLogger.StringWrapper : ValueType {
    public string StringInstance;
    public StringWrapper(string instance);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(StringWrapper other);
    public virtual string ToString();
}
public class Microsoft.Build.Logging.StructuredLogger.StringWriter : object {
    public static int MaxStringLength;
    private static StringWriter();
    public static string GetString(BaseNode rootNode);
    private static void WriteNode(BaseNode rootNode, StringBuilder sb, int indent);
    private static void Indent(StringBuilder sb, int indent);
}
public class Microsoft.Build.Logging.StructuredLogger.StructuredLogger : Logger {
    private Construction construction;
    private string _logFile;
    private ProjectImportsCollector projectImportsCollector;
    [CompilerGeneratedAttribute]
private static Build <CurrentBuild>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <SaveLogToDisk>k__BackingField;
    public Construction Construction { get; }
    public static Build CurrentBuild { get; public set; }
    public static bool SaveLogToDisk { get; public set; }
    private static StructuredLogger();
    public Construction get_Construction();
    [CompilerGeneratedAttribute]
public static Build get_CurrentBuild();
    [CompilerGeneratedAttribute]
public static void set_CurrentBuild(Build value);
    [CompilerGeneratedAttribute]
public static bool get_SaveLogToDisk();
    [CompilerGeneratedAttribute]
public static void set_SaveLogToDisk(bool value);
    public virtual void Initialize(IEventSource eventSource);
    private void EventSource_AnyEventRaised(object sender, BuildEventArgs e);
    public virtual void Shutdown();
    private void ProcessParameters();
    [CompilerGeneratedAttribute]
private void <Shutdown>b__15_0(Stream streamToEmbed);
}
public class Microsoft.Build.Logging.StructuredLogger.Target : TimedNode {
    [CompilerGeneratedAttribute]
private bool <Succeeded>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DependsOnTargets>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SourceFilePath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ParentTarget>k__BackingField;
    [CompilerGeneratedAttribute]
private TargetBuiltReason <TargetBuiltReason>k__BackingField;
    [CompilerGeneratedAttribute]
private TimedNode <OriginalNode>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Skipped>k__BackingField;
    private Dictionary`2<int, Task> tasksById;
    public bool Succeeded { get; internal set; }
    public string DependsOnTargets { get; public set; }
    public Project Project { get; }
    public string SourceFilePath { get; public set; }
    public string ParentTarget { get; public set; }
    public TargetBuiltReason TargetBuiltReason { get; public set; }
    public TimedNode OriginalNode { get; public set; }
    public bool Skipped { get; public set; }
    public string TypeName { get; }
    public string ParentTargetTooltip { get; }
    public string ParentTargetText { get; }
    public bool IsLowRelevance { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_Succeeded();
    [CompilerGeneratedAttribute]
internal void set_Succeeded(bool value);
    [CompilerGeneratedAttribute]
public string get_DependsOnTargets();
    [CompilerGeneratedAttribute]
public void set_DependsOnTargets(string value);
    public Project get_Project();
    [CompilerGeneratedAttribute]
public sealed virtual string get_SourceFilePath();
    [CompilerGeneratedAttribute]
public void set_SourceFilePath(string value);
    [CompilerGeneratedAttribute]
public string get_ParentTarget();
    [CompilerGeneratedAttribute]
public void set_ParentTarget(string value);
    [CompilerGeneratedAttribute]
public TargetBuiltReason get_TargetBuiltReason();
    [CompilerGeneratedAttribute]
public void set_TargetBuiltReason(TargetBuiltReason value);
    [CompilerGeneratedAttribute]
public TimedNode get_OriginalNode();
    [CompilerGeneratedAttribute]
public void set_OriginalNode(TimedNode value);
    [CompilerGeneratedAttribute]
public bool get_Skipped();
    [CompilerGeneratedAttribute]
public void set_Skipped(bool value);
    public virtual string get_TypeName();
    public string get_ParentTargetTooltip();
    public string get_ParentTargetText();
    public void TryAddTarget(Target target);
    public Task GetTaskById(int taskId);
    public virtual string ToString();
    public sealed virtual bool get_IsLowRelevance();
    public void set_IsLowRelevance(bool value);
}
public class Microsoft.Build.Logging.StructuredLogger.Task : TimedNode {
    [CompilerGeneratedAttribute]
private string <FromAssembly>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CommandLineArguments>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SourceFilePath>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <LineNumber>k__BackingField;
    public string FromAssembly { get; public set; }
    public string CommandLineArguments { get; public set; }
    public string SourceFilePath { get; public set; }
    public string TypeName { get; }
    public bool IsDerivedTask { get; }
    public Nullable`1<int> LineNumber { get; public set; }
    [CompilerGeneratedAttribute]
public string get_FromAssembly();
    [CompilerGeneratedAttribute]
public void set_FromAssembly(string value);
    [CompilerGeneratedAttribute]
public string get_CommandLineArguments();
    [CompilerGeneratedAttribute]
public void set_CommandLineArguments(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_SourceFilePath();
    [CompilerGeneratedAttribute]
public void set_SourceFilePath(string value);
    public virtual string get_TypeName();
    public virtual bool get_IsDerivedTask();
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<int> get_LineNumber();
    [CompilerGeneratedAttribute]
public void set_LineNumber(Nullable`1<int> value);
    public IReadOnlyList`1<Message> GetMessages();
}
public class Microsoft.Build.Logging.StructuredLogger.TaskParameterItem : AddItem {
    [CompilerGeneratedAttribute]
private string <ParameterName>k__BackingField;
    public string ParameterName { get; public set; }
    [CompilerGeneratedAttribute]
public string get_ParameterName();
    [CompilerGeneratedAttribute]
public void set_ParameterName(string value);
}
public class Microsoft.Build.Logging.StructuredLogger.TaskParameterProperty : Property {
    [CompilerGeneratedAttribute]
private string <ParameterName>k__BackingField;
    public string ParameterName { get; public set; }
    [CompilerGeneratedAttribute]
public string get_ParameterName();
    [CompilerGeneratedAttribute]
public void set_ParameterName(string value);
}
public class Microsoft.Build.Logging.StructuredLogger.TextNode : TreeNode {
    [CompilerGeneratedAttribute]
private string <Text>k__BackingField;
    public string Text { get; public set; }
    public string ShortenedText { get; }
    public bool IsTextShortened { get; }
    public string TypeName { get; }
    public string Title { get; }
    [CompilerGeneratedAttribute]
public string get_Text();
    [CompilerGeneratedAttribute]
public void set_Text(string value);
    public string get_ShortenedText();
    public bool get_IsTextShortened();
    public virtual string get_TypeName();
    public virtual string get_Title();
    public virtual string ToString();
}
[ExtensionAttribute]
public static class Microsoft.Build.Logging.StructuredLogger.TextUtilities : object {
    private static IReadOnlyList`1<Span> Empty;
    private static Char[] semicolonCharArray;
    public static int MaxDisplayedValueLength;
    private static string TrimPrompt;
    private static HashSet`1<char> invalidFileNameChars;
    private static TextUtilities();
    public static IReadOnlyList`1<string> SplitSemicolonDelimitedList(string list);
    [ExtensionAttribute]
public static void CollectLineSpans(string text, ICollection`1<Span> spans, bool includeLineBreakInSpan);
    [ExtensionAttribute]
public static IReadOnlyList`1<Span> GetLineSpans(string text, bool includeLineBreakInSpan);
    [ExtensionAttribute]
public static IReadOnlyList`1<string> GetLines(string text, bool includeLineBreak);
    [ExtensionAttribute]
public static string GetFirstLine(string text);
    [ExtensionAttribute]
public static IReadOnlyList`1<string> Tokenize(string text);
    [ExtensionAttribute]
public static string Substring(string text, Span span);
    [ExtensionAttribute]
public static bool Contains(string text, Span span, char ch);
    [ExtensionAttribute]
public static int IndexOf(string text, Span span, char ch);
    [ExtensionAttribute]
public static bool IsLineBreakChar(char c);
    [ExtensionAttribute]
public static string NormalizeLineBreaks(string text);
    [ExtensionAttribute]
public static string TrimQuotes(string word);
    [ExtensionAttribute]
public static string QuoteIfNeeded(string text);
    public static bool ContainsLineBreak(string text);
    public static int GetShortenLength(string text, int maxChars);
    public static string ShortenValue(string text, string trimPrompt, int maxChars);
    [ExtensionAttribute]
public static int IndexOfFirstLineBreak(string text);
    public static KeyValuePair`2<string, string> ParseNameValue(string largeText, Span span);
    public static KeyValuePair`2<string, string> ParseNameValueWithEqualsPosition(string largeText, Span span, int equals);
    public static KeyValuePair`2<string, string> ParseNameValue(string nameEqualsValue, int trimFromStart);
    public static KeyValuePair`2<string, string> ParseNameValue(string nameEqualsValue, int trimFromStart, int equals);
    public static KeyValuePair`2<string, string> ParseNameValueWithEqualsPosition(string nameEqualsValue, int equals);
    [ExtensionAttribute]
public static ValueTuple`2<string, string> GetFirstAndRest(string text, char separator);
    public static int GetNumberOfLeadingSpaces(string line);
    public static bool IsWhitespace(string text, Span span);
    public static int GetNumberOfLeadingSpaces(string text, Span span);
    public static string ParseQuotedSubstring(string text);
    public static string DisplayDuration(TimeSpan span, bool showZero);
    public static string Display(DateTime time, bool displayDate, bool fullPrecision);
    public static string SanitizeFileName(string text);
    public static string NormalizeFilePath(string text);
    public static IReadOnlyList`1<Span> GetHighlightedSpansInText(string text, IEnumerable`1<string> searchTerms);
    public static IReadOnlyList`1<Span> NormalizeSpans(IReadOnlyList`1<Span> spans);
    public static IReadOnlyList`1<string> SplitIntoParenthesizedSpans(string text, string openParen, string closeParen);
    [CompilerGeneratedAttribute]
internal static void <SplitIntoParenthesizedSpans>g__Add|38_0(int start, int end, <>c__DisplayClass38_0& );
}
public class Microsoft.Build.Logging.StructuredLogger.TimedMessage : Message {
    [CompilerGeneratedAttribute]
private DateTime <Timestamp>k__BackingField;
    public DateTime Timestamp { get; public set; }
    public string TypeName { get; }
    [CompilerGeneratedAttribute]
public virtual DateTime get_Timestamp();
    [CompilerGeneratedAttribute]
public virtual void set_Timestamp(DateTime value);
    public virtual string get_TypeName();
}
public class Microsoft.Build.Logging.StructuredLogger.TimedNode : NamedNode {
    [CompilerGeneratedAttribute]
private int <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private int <NodeId>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Index>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <StartTime>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <EndTime>k__BackingField;
    public int Id { get; public set; }
    public int NodeId { get; public set; }
    public int Index { get; public set; }
    public DateTime StartTime { get; public set; }
    public DateTime EndTime { get; public set; }
    public TimeSpan Duration { get; }
    public string DurationText { get; }
    public string TypeName { get; }
    public string ToolTip { get; }
    [CompilerGeneratedAttribute]
public int get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(int value);
    [CompilerGeneratedAttribute]
public int get_NodeId();
    [CompilerGeneratedAttribute]
public void set_NodeId(int value);
    [CompilerGeneratedAttribute]
public int get_Index();
    [CompilerGeneratedAttribute]
public void set_Index(int value);
    [CompilerGeneratedAttribute]
public DateTime get_StartTime();
    [CompilerGeneratedAttribute]
public void set_StartTime(DateTime value);
    [CompilerGeneratedAttribute]
public DateTime get_EndTime();
    [CompilerGeneratedAttribute]
public void set_EndTime(DateTime value);
    public TimeSpan get_Duration();
    public string get_DurationText();
    public virtual string get_TypeName();
    public string GetTimeAndDurationText(bool fullPrecision);
    public virtual string get_ToolTip();
}
public class Microsoft.Build.Logging.StructuredLogger.TreeBinaryReader : object {
    private BinaryReader binaryReader;
    private Stream fileStream;
    private GZipStream gzipStream;
    private String[] stringTable;
    [CompilerGeneratedAttribute]
private Version <Version>k__BackingField;
    public Version Version { get; private set; }
    public String[] StringTable { get; }
    public TreeBinaryReader(string filePath);
    public TreeBinaryReader(Stream stream);
    public TreeBinaryReader(Stream stream, Version version);
    private void Initialize(Stream stream, Version version);
    public bool IsValid();
    [CompilerGeneratedAttribute]
public Version get_Version();
    [CompilerGeneratedAttribute]
private void set_Version(Version value);
    public String[] get_StringTable();
    public Byte[] ReadByteArray();
    public void ReadStringArray(Queue`1<string> array);
    public string ReadString();
    public int ReadInt32();
    private string GetString(int index);
    public sealed virtual void Dispose();
}
public class Microsoft.Build.Logging.StructuredLogger.TreeBinaryWriter : object {
    private string filePath;
    private BinaryWriter binaryWriter;
    private BetterBinaryWriter treeNodesStreamBinaryWriter;
    private FileStream fileStream;
    private GZipStream gzipStream;
    private MemoryStream treeNodesStream;
    private Dictionary`2<string, int> stringTable;
    private List`1<string> attributes;
    private Stream DestinationStream { get; }
    public TreeBinaryWriter(string filePath);
    private void WriteVersion();
    public void WriteNode(string name);
    public void WriteAttributeValue(string value);
    public void WriteEndAttributes();
    public void WriteChildrenCount(int count);
    private int GetStringIndex(string text);
    private void WriteStringTable();
    public void WriteByteArray(Byte[] bytes);
    private Stream get_DestinationStream();
    public sealed virtual void Dispose();
}
public abstract class Microsoft.Build.Logging.StructuredLogger.TreeNode : BaseNode {
    private IList`1<BaseNode> children;
    public bool IsVisible { get; public set; }
    public bool IsExpanded { get; public set; }
    public bool DisableChildrenCache { get; public set; }
    public string ToolTip { get; }
    public bool HasChildren { get; }
    public IList`1<BaseNode> Children { get; }
    public BaseNode FirstChild { get; }
    public BaseNode LastChild { get; }
    public bool get_IsVisible();
    public void set_IsVisible(bool value);
    public bool get_IsExpanded();
    public void set_IsExpanded(bool value);
    public bool get_DisableChildrenCache();
    public void set_DisableChildrenCache(bool value);
    public virtual string get_ToolTip();
    public bool get_HasChildren();
    public IList`1<BaseNode> get_Children();
    protected ChildrenList CreateChildrenList();
    protected ChildrenList CreateChildrenList(int capacity);
    protected ChildrenList CreateChildrenList(IEnumerable`1<BaseNode> children);
    public void EnsureChildrenCapacity(int capacity);
    private static int CompareByToString(BaseNode o1, BaseNode o2);
    public void SortChildren(Comparison`1<BaseNode> comparison);
    public void MakeChildrenObservable();
    public void AddChildAtBeginning(BaseNode child);
    public virtual void AddChild(BaseNode child);
    public T GetOrCreateNodeWithText(string text, bool addAtBeginning);
    public T GetOrCreateNodeWithName(string name, bool addAtBeginning);
    public virtual T FindChild(string name);
    public virtual T FindChild(Predicate`1<T> predicate);
    public virtual T FindChild(Func`3<T, TState, bool> predicate, TState state);
    public virtual T FindFirstInSubtreeIncludingSelf(Predicate`1<T> predicate);
    public virtual T FindFirstChild(Predicate`1<T> predicate);
    public virtual T FindFirstDescendant(Predicate`1<T> predicate);
    public virtual T FindLastInSubtreeIncludingSelf(Predicate`1<T> predicate);
    public virtual T FindLastChild(Predicate`1<T> predicate);
    public virtual T FindLastChild(Func`3<T, TState, bool> predicate, TState state);
    public BaseNode get_FirstChild();
    public BaseNode get_LastChild();
    public virtual T FindLastDescendant(Predicate`1<T> predicate);
    public int FindChildIndex(BaseNode child);
    public T FindPreviousChild(BaseNode currentChild, Predicate`1<T> predicate);
    public T FindNextChild(BaseNode currentChild, Predicate`1<T> predicate);
    public T FindPreviousInTraversalOrder(Predicate`1<T> predicate);
    public T FindNextInTraversalOrder(Predicate`1<T> predicate);
    public IReadOnlyList`1<T> FindChildrenRecursive(Predicate`1<T> predicate);
    public void ParallelVisitAllChildren(Action`1<T> processor, CancellationToken cancellationToken, bool takeChildrenSnapshot);
    public void VisitAllChildren(Action`1<T> processor, CancellationToken cancellationToken, bool takeChildrenSnapshot);
    public IReadOnlyList`1<T> FindImmediateChildrenOfType();
}
public enum Microsoft.Build.Logging.StructuredLogger.UnknownDataBehavior : Enum {
    public int value__;
    public static UnknownDataBehavior Error;
    public static UnknownDataBehavior Warning;
    public static UnknownDataBehavior Message;
    public static UnknownDataBehavior Ignore;
    public static UnknownDataBehavior ThrowException;
}
[ExtensionAttribute]
public static class Microsoft.Build.Logging.StructuredLogger.Utilities : object {
    [ExtensionAttribute]
public static int BinarySearch(IList`1<T> list, C item, Func`2<T, C> comparableSelector);
}
public class Microsoft.Build.Logging.StructuredLogger.VbcTask : ManagedCompilerTask {
}
public class Microsoft.Build.Logging.StructuredLogger.Warning : AbstractDiagnostic {
    public string TypeName { get; }
    public virtual string get_TypeName();
}
public class Microsoft.Build.Logging.StructuredLogger.XlinqLogReader : object {
    private StringCache stringTable;
    public static Build ReadFromXml(string xmlFilePath, Action`1<string> statusUpdate);
    private BaseNode ReadNode(XElement element);
    private string ReadTextContent(XElement element);
    private void ReadAttributes(BaseNode node, XElement element);
    private void AddStartAndEndTime(XElement element, TimedNode node);
    private bool GetBoolean(XElement element, AttributeNames attributeIndex);
    private DateTime GetDateTime(XElement element, AttributeNames attributeIndex);
    private int GetInteger(XElement element, AttributeNames attributeIndex);
    private string GetString(XElement element, AttributeNames attributeIndex);
}
public class Microsoft.Build.Logging.StructuredLogger.XmlLogReader : object {
    private StringCache stringTable;
    private XmlReader reader;
    private List`1<KeyValuePair`2<string, string>> attributes;
    public static Build ReadFromXml(string xmlFilePath);
    public static Build ReadFromXml(Stream stream);
    public Build Read(string filePath);
    public Build Read(Stream stream);
    private void SetElementValue(BaseNode valueNode, string value);
    private string GetCurrentValue();
    private BaseNode ReadNode();
    private void PopulateAttributes(BaseNode node);
    private void ReadAttributes();
    private void AddStartAndEndTime(TimedNode node);
    private bool GetBoolean(AttributeNames attributeIndex);
    private DateTime GetDateTime(AttributeNames attributeIndex);
    private int GetInteger(AttributeNames attributeIndex);
    private string GetString(AttributeNames attributeIndex);
}
public class Microsoft.Build.Logging.StructuredLogger.XmlLogWriter : object {
    private XmlWriter xmlWriter;
    public static void WriteToXml(Build build, string logFile);
    public void Write(Build build, string logFile);
    private void WriteNode(BaseNode node);
    private void WriteContent(string value);
    private void WriteAttributes(TreeNode node);
    private void SetString(string name, string value);
    private void AddStartAndEndTime(TimedNode node);
    private string ToString(DateTime time);
}
public class Microsoft.Build.Logging.TaskItem : object {
    [CompilerGeneratedAttribute]
private string <ItemSpec>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <Metadata>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EvaluatedIncludeEscaped>k__BackingField;
    public string ItemSpec { get; public set; }
    public Dictionary`2<string, string> Metadata { get; }
    public string EvaluatedIncludeEscaped { get; public set; }
    public int MetadataCount { get; }
    public ICollection MetadataNames { get; }
    public TaskItem(string itemSpec);
    [CompilerGeneratedAttribute]
public sealed virtual string get_ItemSpec();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ItemSpec(string value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, string> get_Metadata();
    [CompilerGeneratedAttribute]
public sealed virtual string get_EvaluatedIncludeEscaped();
    [CompilerGeneratedAttribute]
public sealed virtual void set_EvaluatedIncludeEscaped(string value);
    public sealed virtual int get_MetadataCount();
    public sealed virtual ICollection get_MetadataNames();
    public sealed virtual IDictionary CloneCustomMetadata();
    public sealed virtual IDictionary CloneCustomMetadataEscaped();
    public sealed virtual void CopyMetadataTo(ITaskItem destinationItem);
    public sealed virtual string GetMetadata(string metadataName);
    public sealed virtual string GetMetadataValueEscaped(string metadataName);
    public sealed virtual void RemoveMetadata(string metadataName);
    public sealed virtual void SetMetadata(string metadataName, string metadataValue);
    public sealed virtual void SetMetadataValueLiteral(string metadataName, string metadataValue);
    public virtual string ToString();
}
[ExtensionAttribute]
internal static class Microsoft.Build.Shared.BinaryReaderExtensions : object {
    [ExtensionAttribute]
public static string ReadOptionalString(BinaryReader reader);
    [ExtensionAttribute]
public static int Read7BitEncodedInt(BinaryReader reader);
    [ExtensionAttribute]
public static DateTime ReadTimestamp(BinaryReader reader);
    [ExtensionAttribute]
public static BuildEventContext ReadOptionalBuildEventContext(BinaryReader reader);
    [ExtensionAttribute]
public static BuildEventContext ReadBuildEventContext(BinaryReader reader);
}
[ExtensionAttribute]
internal static class Microsoft.Build.Shared.BinaryWriterExtensions : object {
    [ExtensionAttribute]
public static void WriteOptionalString(BinaryWriter writer, string value);
    [ExtensionAttribute]
public static void WriteTimestamp(BinaryWriter writer, DateTime timestamp);
    [ExtensionAttribute]
public static void Write7BitEncodedInt(BinaryWriter writer, int value);
    [ExtensionAttribute]
public static void WriteOptionalBuildEventContext(BinaryWriter writer, BuildEventContext context);
    [ExtensionAttribute]
public static void WriteBuildEventContext(BinaryWriter writer, BuildEventContext context);
}
internal static class Microsoft.Build.Shared.ItemTypeNames : object {
    internal static string ProjectReference;
    internal static string ProjectReferenceTargets;
    internal static string GraphIsolationExemptReference;
    internal static string ProjectCachePlugin;
    internal static string EmbedInBinlog;
}
internal static class Microsoft.Build.Shared.MSBuildConstants : object {
    internal static string ToolsPath;
    internal static string ToolsPath64;
    internal static string SdksPath;
    internal static string TreatWarningsAsErrors;
    internal static string WarningsAsErrors;
    internal static string WarningsAsMessages;
    internal static string NuGetAssemblyPathEnvironmentVariableName;
    internal static string RestoreTargetName;
    internal static string CurrentVisualStudioVersion;
    internal static string CurrentToolsVersion;
    internal static string MSBuildDummyGlobalPropertyHeader;
    internal static string CurrentAssemblyVersion;
    internal static string CurrentProductVersion;
    internal static string DefaultTargetsMarker;
    internal static string ProjectReferenceTargetsOrDefaultTargetsMarker;
    internal static Char[] SemicolonChar;
    internal static Char[] SpaceChar;
    internal static Char[] SingleQuoteChar;
    internal static Char[] EqualsChar;
    internal static Char[] ColonChar;
    internal static Char[] BackslashChar;
    internal static Char[] NewlineChar;
    internal static Char[] CrLf;
    internal static Char[] ForwardSlash;
    internal static Char[] ForwardSlashBackslash;
    internal static Char[] WildcardChars;
    internal static String[] CharactersForExpansion;
    internal static Char[] CommaChar;
    internal static Char[] HyphenChar;
    internal static Char[] DirectorySeparatorChar;
    internal static Char[] DotChar;
    internal static String[] EnvironmentNewLine;
    internal static Char[] PipeChar;
    internal static Char[] PathSeparatorChar;
    private static MSBuildConstants();
}
internal class Microsoft.Build.Shared.ResourceUtilities : object {
    internal static string FormatResourceString(String& errorCode, String& helpKeyword, string text, string filePath, string message);
    internal static string FormatResourceStringStripCodeAndKeyword(String& errorCode, String& helpKeyword, string text, string filePath, string message);
    internal static string FormatResourceString(string v1, string v2);
    internal static string FormatResourceStringStripCodeAndKeyword(string v1, string v2);
    internal static string GetResourceString(string s);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
internal class StructuredLogger.BinaryLogger.BuildCheckAcquisitionEventArgs : BuildCheckEventArgs {
    [CompilerGeneratedAttribute]
private string <AcquisitionPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProjectPath>k__BackingField;
    public string AcquisitionPath { get; private set; }
    public string ProjectPath { get; private set; }
    public BuildCheckAcquisitionEventArgs(string acquisitionPath, string projectPath);
    [CompilerGeneratedAttribute]
public string get_AcquisitionPath();
    [CompilerGeneratedAttribute]
private void set_AcquisitionPath(string value);
    [CompilerGeneratedAttribute]
public string get_ProjectPath();
    [CompilerGeneratedAttribute]
private void set_ProjectPath(string value);
}
internal abstract class StructuredLogger.BinaryLogger.BuildCheckEventArgs : BuildEventArgs {
}
internal class StructuredLogger.BinaryLogger.BuildCheckResultMessage : BuildMessageEventArgs {
    public BuildCheckResultMessage(string message);
}
internal class StructuredLogger.BinaryLogger.BuildCheckTracingEventArgs : BuildCheckEventArgs {
    [CompilerGeneratedAttribute]
private Dictionary`2<string, TimeSpan> <TracingData>k__BackingField;
    public Dictionary`2<string, TimeSpan> TracingData { get; private set; }
    public BuildCheckTracingEventArgs(Dictionary`2<string, TimeSpan> tracingData);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, TimeSpan> get_TracingData();
    [CompilerGeneratedAttribute]
private void set_TracingData(Dictionary`2<string, TimeSpan> value);
}
public enum StructuredLogger.BinaryLogger.BuildRequestDataFlags : Enum {
    public int value__;
    public static BuildRequestDataFlags None;
    public static BuildRequestDataFlags ReplaceExistingProjectInstance;
    public static BuildRequestDataFlags ProvideProjectStateAfterBuild;
    public static BuildRequestDataFlags IgnoreExistingProjectState;
    public static BuildRequestDataFlags ClearCachesAfterBuild;
    public static BuildRequestDataFlags SkipNonexistentTargets;
    public static BuildRequestDataFlags ProvideSubsetOfStateAfterBuild;
    public static BuildRequestDataFlags IgnoreMissingEmptyAndInvalidImports;
    public static BuildRequestDataFlags FailOnUnresolvedSdk;
}
internal class StructuredLogger.BinaryLogger.BuildSubmissionStartedEvent : BuildStatusEventArgs {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private IDictionary`2<string, string> <GlobalProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <EntryProjectsFullPath>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <TargetNames>k__BackingField;
    [CompilerGeneratedAttribute]
private BuildRequestDataFlags <Flags>k__BackingField;
    [CompilerGeneratedAttribute]
private int <SubmissionId>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IDictionary`2<string, string> GlobalProperties { get; public set; }
    public IEnumerable`1<string> EntryProjectsFullPath { get; public set; }
    public IEnumerable`1<string> TargetNames { get; public set; }
    public BuildRequestDataFlags Flags { get; public set; }
    public int SubmissionId { get; public set; }
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_GlobalProperties();
    [CompilerGeneratedAttribute]
public void set_GlobalProperties(IDictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_EntryProjectsFullPath();
    [CompilerGeneratedAttribute]
public void set_EntryProjectsFullPath(IEnumerable`1<string> value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_TargetNames();
    [CompilerGeneratedAttribute]
public void set_TargetNames(IEnumerable`1<string> value);
    [CompilerGeneratedAttribute]
public BuildRequestDataFlags get_Flags();
    [CompilerGeneratedAttribute]
public void set_Flags(BuildRequestDataFlags value);
    [CompilerGeneratedAttribute]
public int get_SubmissionId();
    [CompilerGeneratedAttribute]
public void set_SubmissionId(int value);
}
public class StructuredLogger.BinaryLogger.EnvironmentVariableReadEventArgs2 : EnvironmentVariableReadEventArgs {
    [CompilerGeneratedAttribute]
private int <LineNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ColumnNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private string <File>k__BackingField;
    public int LineNumber { get; public set; }
    public int ColumnNumber { get; public set; }
    public string File { get; public set; }
    public EnvironmentVariableReadEventArgs2(string environmentVarName, string environmentVarValue, string file, int line, int column);
    [CompilerGeneratedAttribute]
public int get_LineNumber();
    [CompilerGeneratedAttribute]
public void set_LineNumber(int value);
    [CompilerGeneratedAttribute]
public int get_ColumnNumber();
    [CompilerGeneratedAttribute]
public void set_ColumnNumber(int value);
    [CompilerGeneratedAttribute]
public string get_File();
    [CompilerGeneratedAttribute]
public void set_File(string value);
}
[DebuggerDisplayAttribute("{Level}> {Result} : {Text}")]
public class StructuredLogViewer.ConditionNode : object {
    public bool Result;
    public int Level;
    public ConditionOperator Operator;
    public string Text;
    public ConditionNode Parent;
    public List`1<ConditionNode> Children;
    private static String[] SpecialFunctions;
    private static ConditionNode();
    public static ConditionNode ParseAndProcess(string unevaluated, string evaluated);
    public static ConditionNode Process(ConditionNode unevaluatedNode, ConditionNode evaluatedNode);
    public static ConditionNode Parse(string text, bool doEvaluate);
    private static void ComputeGroupResult(ConditionNode group);
    private static ConditionOperator IsAndOrToken(string text, int index, Int32& newIndex);
    private static bool IsSpecialFunction(string text, int index, Int32& newIndex);
    private static int FindMatchingParam(string text, int index);
    private static int FindMatchingQuote(string text, int index);
    [IteratorStateMachineAttribute("StructuredLogViewer.ConditionNode/<GetEnumerator>d__18")]
public sealed virtual IEnumerator`1<ConditionNode> GetEnumerator();
    [IteratorStateMachineAttribute("StructuredLogViewer.ConditionNode/<System-Collections-IEnumerable-GetEnumerator>d__19")]
private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class StructuredLogViewer.NodeQueryMatcher : object {
    [CompilerGeneratedAttribute]
private string <Query>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<Term> <Terms>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TypeKeyword>k__BackingField;
    [CompilerGeneratedAttribute]
private int <NodeIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private HashSet`1[] <MatchesInStrings>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludeDuration>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludeStart>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludeEnd>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <PrecalculationDuration>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsProjectMatcher>k__BackingField;
    [CompilerGeneratedAttribute]
private int <NameTermIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ValueTermIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <Skipped>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Height>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <StartBefore>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <StartAfter>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <EndBefore>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <EndAfter>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasTimeIntervalConstraints>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<NodeQueryMatcher> <IncludeMatchers>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<NodeQueryMatcher> <ExcludeMatchers>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<NodeQueryMatcher> <NotMatchers>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<NodeQueryMatcher> <ProjectMatchers>k__BackingField;
    [ThreadStaticAttribute]
private static String[] searchFieldsThreadStatic;
    public static int MaxArraySize;
    public string Query { get; private set; }
    public List`1<Term> Terms { get; private set; }
    public string TypeKeyword { get; private set; }
    public int NodeIndex { get; private set; }
    private HashSet`1[] MatchesInStrings { get; private set; }
    public bool IncludeDuration { get; public set; }
    public bool IncludeStart { get; public set; }
    public bool IncludeEnd { get; public set; }
    public TimeSpan PrecalculationDuration { get; public set; }
    public bool IsProjectMatcher { get; public set; }
    public int NameTermIndex { get; public set; }
    public int ValueTermIndex { get; public set; }
    public Nullable`1<bool> Skipped { get; public set; }
    public int Height { get; public set; }
    public DateTime StartBefore { get; public set; }
    public DateTime StartAfter { get; public set; }
    public DateTime EndBefore { get; public set; }
    public DateTime EndAfter { get; public set; }
    public bool HasTimeIntervalConstraints { get; public set; }
    public IList`1<NodeQueryMatcher> IncludeMatchers { get; }
    public IList`1<NodeQueryMatcher> ExcludeMatchers { get; }
    public IList`1<NodeQueryMatcher> NotMatchers { get; }
    public IList`1<NodeQueryMatcher> ProjectMatchers { get; }
    public NodeQueryMatcher(string query);
    [CompilerGeneratedAttribute]
public string get_Query();
    [CompilerGeneratedAttribute]
private void set_Query(string value);
    [CompilerGeneratedAttribute]
public List`1<Term> get_Terms();
    [CompilerGeneratedAttribute]
private void set_Terms(List`1<Term> value);
    [CompilerGeneratedAttribute]
public string get_TypeKeyword();
    [CompilerGeneratedAttribute]
private void set_TypeKeyword(string value);
    [CompilerGeneratedAttribute]
public int get_NodeIndex();
    [CompilerGeneratedAttribute]
private void set_NodeIndex(int value);
    [CompilerGeneratedAttribute]
private HashSet`1[] get_MatchesInStrings();
    [CompilerGeneratedAttribute]
private void set_MatchesInStrings(HashSet`1[] value);
    [CompilerGeneratedAttribute]
public bool get_IncludeDuration();
    [CompilerGeneratedAttribute]
public void set_IncludeDuration(bool value);
    [CompilerGeneratedAttribute]
public bool get_IncludeStart();
    [CompilerGeneratedAttribute]
public void set_IncludeStart(bool value);
    [CompilerGeneratedAttribute]
public bool get_IncludeEnd();
    [CompilerGeneratedAttribute]
public void set_IncludeEnd(bool value);
    [CompilerGeneratedAttribute]
public TimeSpan get_PrecalculationDuration();
    [CompilerGeneratedAttribute]
public void set_PrecalculationDuration(TimeSpan value);
    [CompilerGeneratedAttribute]
public bool get_IsProjectMatcher();
    [CompilerGeneratedAttribute]
public void set_IsProjectMatcher(bool value);
    [CompilerGeneratedAttribute]
public int get_NameTermIndex();
    [CompilerGeneratedAttribute]
public void set_NameTermIndex(int value);
    [CompilerGeneratedAttribute]
public int get_ValueTermIndex();
    [CompilerGeneratedAttribute]
public void set_ValueTermIndex(int value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_Skipped();
    [CompilerGeneratedAttribute]
public void set_Skipped(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public int get_Height();
    [CompilerGeneratedAttribute]
public void set_Height(int value);
    [CompilerGeneratedAttribute]
public DateTime get_StartBefore();
    [CompilerGeneratedAttribute]
public void set_StartBefore(DateTime value);
    [CompilerGeneratedAttribute]
public DateTime get_StartAfter();
    [CompilerGeneratedAttribute]
public void set_StartAfter(DateTime value);
    [CompilerGeneratedAttribute]
public DateTime get_EndBefore();
    [CompilerGeneratedAttribute]
public void set_EndBefore(DateTime value);
    [CompilerGeneratedAttribute]
public DateTime get_EndAfter();
    [CompilerGeneratedAttribute]
public void set_EndAfter(DateTime value);
    [CompilerGeneratedAttribute]
public bool get_HasTimeIntervalConstraints();
    [CompilerGeneratedAttribute]
public void set_HasTimeIntervalConstraints(bool value);
    [CompilerGeneratedAttribute]
public IList`1<NodeQueryMatcher> get_IncludeMatchers();
    [CompilerGeneratedAttribute]
public IList`1<NodeQueryMatcher> get_ExcludeMatchers();
    [CompilerGeneratedAttribute]
public IList`1<NodeQueryMatcher> get_NotMatchers();
    [CompilerGeneratedAttribute]
public IList`1<NodeQueryMatcher> get_ProjectMatchers();
    public void Initialize(IEnumerable`1<string> stringTable, CancellationToken cancellationToken);
    private void ParseTerms();
    private string PreprocessQuery(string query);
    public static HashSet`1[] PrecomputeMatchesInStrings(IEnumerable`1<string> stringTable, IList`1<Term> terms, CancellationToken cancellationToken);
    public static ValueTuple`2<String[], int> PopulateSearchFields(BaseNode node);
    public SearchResult IsMatch(BaseNode node);
    public SearchResult IsMatch(string field);
    public SearchResult IsMatch(String[] fields);
    public bool IsTimeIntervalMatch(BaseNode node);
    public static bool IsUnder(NodeQueryMatcher matcher, BaseNode node);
}
public class StructuredLogViewer.PropertiesAndItemsSearch : object {
    public IEnumerable`1<SearchResult> Search(TimedNode context, string searchText, int maxResults, bool markResultsInTree, CancellationToken cancellationToken);
    private void CollectStrings(BaseNode root, StringCache strings);
    [CompilerGeneratedAttribute]
internal static void <Search>g__AddPropertiesAndItems|0_0(TimedNode root, List`1<TreeNode> roots);
}
public class StructuredLogViewer.ResultTree : object {
    public static Folder BuildResultTree(object resultsObject, TimeSpan elapsed, TimeSpan precalculationDuration, bool addDuration, Func`1<BaseNode> addWhenNoResults);
    private static TreeNode InsertParent(Dictionary`2<BaseNode, BaseNode> map, TreeNode parent, NamedNode actualParent, string name, Func`2<ProxyNode, bool> existingNodeFinder);
}
public class StructuredLogViewer.Search : object {
    public static int DefaultMaxResults;
    private IEnumerable`1<TreeNode> roots;
    private IEnumerable`1<string> strings;
    private int maxResults;
    private int resultCount;
    private bool markResultsInTree;
    private bool useMultithreading;
    public TimeSpan PrecalculationDuration;
    public Search(IEnumerable`1<TreeNode> roots, IEnumerable`1<string> strings, int maxResults, bool markResultsInTree);
    public IEnumerable`1<SearchResult> FindNodes(string query, CancellationToken cancellationToken);
    public static void ClearSearchResults(Build build, bool markResultsInTree);
    private bool Visit(BaseNode node, NodeQueryMatcher matcher, List`1<SearchResult> results, CancellationToken cancellationToken);
}
public class StructuredLogViewer.SearchResult : object {
    [CompilerGeneratedAttribute]
private BaseNode <Node>k__BackingField;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public List`1<ValueTuple`2<string, string>> WordsInFields;
    [CompilerGeneratedAttribute]
private IList`1<string> <FieldsToDisplay>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <MatchedByType>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <Duration>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <StartTime>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <EndTime>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RootFolder>k__BackingField;
    [CompilerGeneratedAttribute]
private FileCopyInfo <AssociatedFileCopy>k__BackingField;
    [CompilerGeneratedAttribute]
private static SearchResult <EmptyQueryMatch>k__BackingField;
    public BaseNode Node { get; }
    public IList`1<string> FieldsToDisplay { get; public set; }
    public bool MatchedByType { get; private set; }
    public TimeSpan Duration { get; public set; }
    public DateTime StartTime { get; public set; }
    public DateTime EndTime { get; public set; }
    public string RootFolder { get; public set; }
    public FileCopyInfo AssociatedFileCopy { get; public set; }
    public static SearchResult EmptyQueryMatch { get; }
    public SearchResult(BaseNode node, bool includeDuration, bool includeStart, bool includeEnd);
    private static SearchResult();
    [CompilerGeneratedAttribute]
public BaseNode get_Node();
    [CompilerGeneratedAttribute]
public IList`1<string> get_FieldsToDisplay();
    [CompilerGeneratedAttribute]
public void set_FieldsToDisplay(IList`1<string> value);
    [CompilerGeneratedAttribute]
public bool get_MatchedByType();
    [CompilerGeneratedAttribute]
private void set_MatchedByType(bool value);
    [CompilerGeneratedAttribute]
public TimeSpan get_Duration();
    [CompilerGeneratedAttribute]
public void set_Duration(TimeSpan value);
    [CompilerGeneratedAttribute]
public DateTime get_StartTime();
    [CompilerGeneratedAttribute]
public void set_StartTime(DateTime value);
    [CompilerGeneratedAttribute]
public DateTime get_EndTime();
    [CompilerGeneratedAttribute]
public void set_EndTime(DateTime value);
    [CompilerGeneratedAttribute]
public string get_RootFolder();
    [CompilerGeneratedAttribute]
public void set_RootFolder(string value);
    [CompilerGeneratedAttribute]
public FileCopyInfo get_AssociatedFileCopy();
    [CompilerGeneratedAttribute]
public void set_AssociatedFileCopy(FileCopyInfo value);
    [CompilerGeneratedAttribute]
public static SearchResult get_EmptyQueryMatch();
    public void AddMatch(string field, string word, bool addAtBeginning);
    public void AddMatchByNodeType();
    public virtual string ToString();
}
public class StructuredLogViewer.Term : ValueType {
    public string Word;
    public bool Quotes;
    public Term(string word, bool quotes);
    public static Term Get(string input);
    public bool IsMatch(string field, HashSet`1<string> superstrings);
    public bool IsMatch(string field);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual bool Equals(Term other);
    public static bool op_Equality(Term left, Term right);
    public static bool op_Inequality(Term left, Term right);
    public virtual string ToString();
}
public class System.IO.AsyncBufferedReadStream : Stream {
    private Stream stream;
    private Byte[] buffer;
    private int bufferSize;
    private static int DefaultBufferSize;
    private int readPosition;
    private int readLength;
    private Byte[] prefetchBuffer;
    private Task prefetchTask;
    private int prefetchReadbytes;
    private bool NeedsRefill { get; }
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public bool CanSeek { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public AsyncBufferedReadStream(Stream stream);
    public AsyncBufferedReadStream(Stream stream, int bufferSize);
    private int ReadFromBuffer(Byte[] array, int offset, int count);
    public virtual int Read(Byte[] array, int offset, int count);
    public virtual int ReadByte();
    private bool get_NeedsRefill();
    private bool RefillBufferIfNeeded();
    private void RefillBuffer();
    private void PrefetchNextBuffer();
    public virtual bool get_CanRead();
    public virtual bool get_CanWrite();
    public virtual bool get_CanSeek();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    protected virtual void Dispose(bool disposing);
    public virtual void Flush();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    [CompilerGeneratedAttribute]
private void <PrefetchNextBuffer>b__18_0();
}
internal static class System.Runtime.CompilerServices.IsExternalInit : object {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsReadOnlyAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
[GeneratedCodeAttribute("Nerdbank.GitVersioning.Tasks", "3.6.141.978")]
[ExcludeFromCodeCoverageAttribute]
internal static class ThisAssembly : object {
    internal static string AssemblyConfiguration;
    internal static string AssemblyFileVersion;
    internal static string AssemblyInformationalVersion;
    internal static string AssemblyName;
    internal static string AssemblyTitle;
    internal static string AssemblyVersion;
    internal static DateTime GitCommitDate;
    internal static string GitCommitId;
    internal static bool IsPrerelease;
    internal static bool IsPublicRelease;
    internal static string PublicKey;
    internal static string PublicKeyToken;
    internal static string RootNamespace;
    private static ThisAssembly();
}
[ExtensionAttribute]
public static class TinyJson.JSONParser : object {
    [ThreadStaticAttribute]
private static Stack`1<List`1<string>> splitArrayPool;
    [ThreadStaticAttribute]
private static StringBuilder stringBuilder;
    [ThreadStaticAttribute]
private static Dictionary`2<Type, Dictionary`2<string, FieldInfo>> fieldInfoCache;
    [ThreadStaticAttribute]
private static Dictionary`2<Type, Dictionary`2<string, PropertyInfo>> propertyInfoCache;
    [ExtensionAttribute]
public static T FromJson(string json);
    private static int AppendUntilStringEnd(bool appendEscapeCharacter, int startIdx, string json);
    private static List`1<string> Split(string json);
    internal static object ParseValue(Type type, string json);
    private static object ParseAnonymousValue(string json);
    private static Dictionary`2<string, T> CreateMemberNameDictionary(T[] members);
    private static object ParseObject(Type type, string json);
}
