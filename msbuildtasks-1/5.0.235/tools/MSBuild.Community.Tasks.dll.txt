internal class Ionic.AttributesCriterion : SelectionCriterion {
    private FileAttributes _Attributes;
    internal ComparisonOperator Operator;
    internal string AttributeString { get; internal set; }
    internal string get_AttributeString();
    internal void set_AttributeString(string value);
    public virtual string ToString();
    private bool _EvaluateOne(FileAttributes fileAttrs, FileAttributes criterionAttrs);
    internal virtual bool Evaluate(string filename);
    private bool _Evaluate(FileAttributes fileAttrs);
    internal virtual bool Evaluate(ZipEntry entry);
}
internal class Ionic.BZip2.BitWriter : object {
    private UInt32 accumulator;
    private int nAccumulatedBits;
    private Stream output;
    private int totalBytesWrittenOut;
    public byte RemainingBits { get; }
    public int NumRemainingBits { get; }
    public int TotalBytesWrittenOut { get; }
    public BitWriter(Stream s);
    public byte get_RemainingBits();
    public int get_NumRemainingBits();
    public int get_TotalBytesWrittenOut();
    public void Reset();
    public void WriteBits(int nbits, UInt32 value);
    public void WriteByte(byte b);
    public void WriteInt(UInt32 u);
    public void Flush();
    public void FinishAndPad();
}
internal static class Ionic.BZip2.BZip2 : object {
    public static int BlockSizeMultiple;
    public static int MinBlockSize;
    public static int MaxBlockSize;
    public static int MaxAlphaSize;
    public static int MaxCodeLength;
    public static char RUNA;
    public static char RUNB;
    public static int NGroups;
    public static int G_SIZE;
    public static int N_ITERS;
    public static int MaxSelectors;
    public static int NUM_OVERSHOOT_BYTES;
    internal static int QSORT_STACK_SIZE;
    private static BZip2();
    internal static T[][] InitRectangularArray(int d1, int d2);
}
internal class Ionic.BZip2.BZip2Compressor : object {
    private int blockSize100k;
    private int currentByte;
    private int runLength;
    private int last;
    private int outBlockFillThreshold;
    private CompressionState cstate;
    private CRC32 crc;
    private BitWriter bw;
    private int runs;
    private int workDone;
    private int workLimit;
    private bool firstAttempt;
    private bool blockRandomised;
    private int origPtr;
    private int nInUse;
    private int nMTF;
    private static int SETMASK;
    private static int CLEARMASK;
    private static byte GREATER_ICOST;
    private static byte LESSER_ICOST;
    private static int SMALL_THRESH;
    private static int DEPTH_THRESH;
    private static int WORK_FACTOR;
    private static Int32[] increments;
    [CompilerGeneratedAttribute]
private UInt32 <Crc32>k__BackingField;
    [CompilerGeneratedAttribute]
private int <AvailableBytesOut>k__BackingField;
    public int BlockSize { get; }
    public UInt32 Crc32 { get; private set; }
    public int AvailableBytesOut { get; private set; }
    public int UncompressedBytes { get; }
    public BZip2Compressor(BitWriter writer);
    public BZip2Compressor(BitWriter writer, int blockSize);
    private static BZip2Compressor();
    private void Reset();
    public int get_BlockSize();
    [CompilerGeneratedAttribute]
public UInt32 get_Crc32();
    [CompilerGeneratedAttribute]
private void set_Crc32(UInt32 value);
    [CompilerGeneratedAttribute]
public int get_AvailableBytesOut();
    [CompilerGeneratedAttribute]
private void set_AvailableBytesOut(int value);
    public int get_UncompressedBytes();
    public int Fill(Byte[] buffer, int offset, int count);
    private int write0(byte b);
    private bool AddRunToOutputBlock(bool final);
    public void CompressAndWrite();
    private void randomiseBlock();
    private void mainSort();
    private void blockSort();
    private bool mainSimpleSort(CompressionState dataShadow, int lo, int hi, int d);
    private static void vswap(Int32[] fmap, int p1, int p2, int n);
    private static byte med3(byte a, byte b, byte c);
    private void mainQSort3(CompressionState dataShadow, int loSt, int hiSt, int dSt);
    private void generateMTFValues();
    private static void hbAssignCodes(Int32[] code, Byte[] length, int minLen, int maxLen, int alphaSize);
    private void sendMTFValues();
    private void sendMTFValues0(int nGroups, int alphaSize);
    private static void hbMakeCodeLengths(Byte[] len, Int32[] freq, CompressionState state1, int alphaSize, int maxLen);
    private int sendMTFValues1(int nGroups, int alphaSize);
    private void sendMTFValues2(int nGroups, int nSelectors);
    private void sendMTFValues3(int nGroups, int alphaSize);
    private void sendMTFValues4();
    private void sendMTFValues5(int nGroups, int nSelectors);
    private void sendMTFValues6(int nGroups, int alphaSize);
    private void sendMTFValues7(int nSelectors);
    private void moveToFrontCodeAndSend();
}
internal class Ionic.BZip2.BZip2InputStream : Stream {
    private bool _disposed;
    private bool _leaveOpen;
    private long totalBytesRead;
    private int last;
    private int origPtr;
    private int blockSize100k;
    private bool blockRandomised;
    private int bsBuff;
    private int bsLive;
    private CRC32 crc;
    private int nInUse;
    private Stream input;
    private int currentChar;
    private CState currentState;
    private UInt32 storedBlockCRC;
    private UInt32 storedCombinedCRC;
    private UInt32 computedBlockCRC;
    private UInt32 computedCombinedCRC;
    private int su_count;
    private int su_ch2;
    private int su_chPrev;
    private int su_i2;
    private int su_j2;
    private int su_rNToGo;
    private int su_rTPos;
    private int su_tPos;
    private char su_z;
    private DecompressionState data;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public BZip2InputStream(Stream input);
    public BZip2InputStream(Stream input, bool leaveOpen);
    public virtual int Read(Byte[] buffer, int offset, int count);
    private void MakeMaps();
    public virtual int ReadByte();
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual void Flush();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    protected virtual void Dispose(bool disposing);
    private void init();
    private void CheckMagicChar(char expected, int position);
    private void InitBlock();
    private void EndBlock();
    private void complete();
    public virtual void Close();
    private int GetBits(int n);
    private bool bsGetBit();
    private char bsGetUByte();
    private UInt32 bsGetInt();
    private static void hbCreateDecodeTables(Int32[] limit, Int32[] bbase, Int32[] perm, Char[] length, int minLen, int maxLen, int alphaSize);
    private void recvDecodingTables();
    private void createHuffmanDecodingTables(int alphaSize, int nGroups);
    private void getAndMoveToFrontDecode();
    private int getAndMoveToFrontDecode0(int groupNo);
    private void SetupBlock();
    private void SetupRandPartA();
    private void SetupNoRandPartA();
    private void SetupRandPartB();
    private void SetupRandPartC();
    private void SetupNoRandPartB();
    private void SetupNoRandPartC();
}
internal class Ionic.BZip2.BZip2OutputStream : Stream {
    private int totalBytesWrittenIn;
    private bool leaveOpen;
    private BZip2Compressor compressor;
    private UInt32 combinedCRC;
    private Stream output;
    private BitWriter bw;
    private int blockSize100k;
    private TraceBits desiredTrace;
    public int BlockSize { get; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public BZip2OutputStream(Stream output);
    public BZip2OutputStream(Stream output, int blockSize);
    public BZip2OutputStream(Stream output, bool leaveOpen);
    public BZip2OutputStream(Stream output, int blockSize, bool leaveOpen);
    public virtual void Close();
    public virtual void Flush();
    private void EmitHeader();
    private void EmitTrailer();
    private void Finish();
    public int get_BlockSize();
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual int Read(Byte[] buffer, int offset, int count);
    [ConditionalAttribute("Trace")]
private void TraceOutput(TraceBits bits, string format, Object[] varParams);
}
internal class Ionic.BZip2.ParallelBZip2OutputStream : Stream {
    private static int BufferPairsPerCore;
    private int _maxWorkers;
    private bool firstWriteDone;
    private int lastFilled;
    private int lastWritten;
    private int latestCompressed;
    private int currentlyFilling;
    private Exception modreq(System.Runtime.CompilerServices.IsVolatile) pendingException;
    private bool handlingException;
    private bool emitting;
    private Queue`1<int> toWrite;
    private Queue`1<int> toFill;
    private List`1<WorkItem> pool;
    private object latestLock;
    private object eLock;
    private object outputLock;
    private AutoResetEvent newlyCompressedBlob;
    private long totalBytesWrittenIn;
    private long totalBytesWrittenOut;
    private bool leaveOpen;
    private UInt32 combinedCRC;
    private Stream output;
    private BitWriter bw;
    private int blockSize100k;
    private TraceBits desiredTrace;
    public int MaxWorkers { get; public set; }
    public int BlockSize { get; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public long BytesWrittenOut { get; }
    public ParallelBZip2OutputStream(Stream output);
    public ParallelBZip2OutputStream(Stream output, int blockSize);
    public ParallelBZip2OutputStream(Stream output, bool leaveOpen);
    public ParallelBZip2OutputStream(Stream output, int blockSize, bool leaveOpen);
    private static ParallelBZip2OutputStream();
    private void InitializePoolOfWorkItems();
    public int get_MaxWorkers();
    public void set_MaxWorkers(int value);
    public virtual void Close();
    private void FlushOutput(bool lastInput);
    public virtual void Flush();
    private void EmitHeader();
    private void EmitTrailer();
    public int get_BlockSize();
    public virtual void Write(Byte[] buffer, int offset, int count);
    private void EmitPendingBuffers(bool doAll, bool mustWait);
    private void CompressOne(object wi);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public long get_BytesWrittenOut();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual int Read(Byte[] buffer, int offset, int count);
    [ConditionalAttribute("Trace")]
private void TraceOutput(TraceBits bits, string format, Object[] varParams);
}
internal static class Ionic.BZip2.Rand : object {
    private static Int32[] RNUMS;
    private static Rand();
    internal static int Rnums(int i);
}
internal class Ionic.BZip2.WorkItem : object {
    public int index;
    [CompilerGeneratedAttribute]
private BZip2Compressor <Compressor>k__BackingField;
    public MemoryStream ms;
    public int ordinal;
    public BitWriter bw;
    public BZip2Compressor Compressor { get; private set; }
    public WorkItem(int ix, int blockSize);
    [CompilerGeneratedAttribute]
public BZip2Compressor get_Compressor();
    [CompilerGeneratedAttribute]
private void set_Compressor(BZip2Compressor value);
}
internal enum Ionic.ComparisonOperator : Enum {
    public int value__;
    [DescriptionAttribute(">")]
public static ComparisonOperator GreaterThan;
    [DescriptionAttribute(">=")]
public static ComparisonOperator GreaterThanOrEqualTo;
    [DescriptionAttribute("<")]
public static ComparisonOperator LesserThan;
    [DescriptionAttribute("<=")]
public static ComparisonOperator LesserThanOrEqualTo;
    [DescriptionAttribute("=")]
public static ComparisonOperator EqualTo;
    [DescriptionAttribute("!=")]
public static ComparisonOperator NotEqualTo;
}
internal class Ionic.CompoundCriterion : SelectionCriterion {
    internal LogicalConjunction Conjunction;
    internal SelectionCriterion Left;
    private SelectionCriterion _Right;
    internal SelectionCriterion Right { get; internal set; }
    internal SelectionCriterion get_Right();
    internal void set_Right(SelectionCriterion value);
    internal virtual bool Evaluate(string filename);
    public virtual string ToString();
    internal virtual bool Evaluate(ZipEntry entry);
}
[ClassInterfaceAttribute("1")]
[ComVisibleAttribute("True")]
[GuidAttribute("ebc25cf6-9120-4283-b972-0e5520d0000C")]
internal class Ionic.Crc.CRC32 : object {
    private UInt32 dwPolynomial;
    private long _TotalBytesRead;
    private bool reverseBits;
    private UInt32[] crc32Table;
    private static int BUFFER_SIZE;
    private UInt32 _register;
    public long TotalBytesRead { get; }
    public int Crc32Result { get; }
    public CRC32(bool reverseBits);
    public CRC32(int polynomial, bool reverseBits);
    public long get_TotalBytesRead();
    public int get_Crc32Result();
    public int GetCrc32(Stream input);
    public int GetCrc32AndCopy(Stream input, Stream output);
    public int ComputeCrc32(int W, byte B);
    internal int _InternalComputeCrc32(UInt32 W, byte B);
    public void SlurpBlock(Byte[] block, int offset, int count);
    public void UpdateCRC(byte b);
    public void UpdateCRC(byte b, int n);
    private static UInt32 ReverseBits(UInt32 data);
    private static byte ReverseBits(byte data);
    private void GenerateLookupTable();
    private UInt32 gf2_matrix_times(UInt32[] matrix, UInt32 vec);
    private void gf2_matrix_square(UInt32[] square, UInt32[] mat);
    public void Combine(int crc, int length);
    public void Reset();
}
internal class Ionic.Crc.CrcCalculatorStream : Stream {
    private static long UnsetLengthLimit;
    private Stream _innerStream;
    private CRC32 _crc32;
    private long _lengthLimit;
    private bool _leaveOpen;
    public long TotalBytesSlurped { get; }
    public int Crc { get; }
    public bool LeaveOpen { get; public set; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public CrcCalculatorStream(Stream stream);
    public CrcCalculatorStream(Stream stream, bool leaveOpen);
    public CrcCalculatorStream(Stream stream, long length);
    public CrcCalculatorStream(Stream stream, long length, bool leaveOpen);
    public CrcCalculatorStream(Stream stream, long length, bool leaveOpen, CRC32 crc32);
    private CrcCalculatorStream(bool leaveOpen, long length, Stream stream, CRC32 crc32);
    private static CrcCalculatorStream();
    public long get_TotalBytesSlurped();
    public int get_Crc();
    public bool get_LeaveOpen();
    public void set_LeaveOpen(bool value);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual void Flush();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    private sealed virtual override void System.IDisposable.Dispose();
    private void InnerClose();
    public virtual void Close();
}
internal class Ionic.EnumUtil : object {
    internal static string GetDescription(Enum value);
    internal static object Parse(Type enumType, string stringRepresentation);
    internal static object Parse(Type enumType, string stringRepresentation, bool ignoreCase);
}
internal class Ionic.FileSelector : object {
    internal SelectionCriterion _Criterion;
    [CompilerGeneratedAttribute]
private bool <TraverseReparsePoints>k__BackingField;
    public string SelectionCriteria { get; public set; }
    public bool TraverseReparsePoints { get; public set; }
    public FileSelector(string selectionCriteria);
    public FileSelector(string selectionCriteria, bool traverseDirectoryReparsePoints);
    public string get_SelectionCriteria();
    public void set_SelectionCriteria(string value);
    [CompilerGeneratedAttribute]
public bool get_TraverseReparsePoints();
    [CompilerGeneratedAttribute]
public void set_TraverseReparsePoints(bool value);
    private static string NormalizeCriteriaExpression(string source);
    private static SelectionCriterion _ParseCriterion(string s);
    public virtual string ToString();
    private bool Evaluate(string filename);
    [ConditionalAttribute("SelectorTrace")]
private void SelectorTrace(string format, Object[] args);
    public ICollection`1<string> SelectFiles(string directory);
    public ReadOnlyCollection`1<string> SelectFiles(string directory, bool recurseDirectories);
    private bool Evaluate(ZipEntry entry);
    public ICollection`1<ZipEntry> SelectEntries(ZipFile zip);
    public ICollection`1<ZipEntry> SelectEntries(ZipFile zip, string directoryPathInArchive);
}
internal enum Ionic.LogicalConjunction : Enum {
    public int value__;
    public static LogicalConjunction NONE;
    public static LogicalConjunction AND;
    public static LogicalConjunction OR;
    public static LogicalConjunction XOR;
}
internal class Ionic.NameCriterion : SelectionCriterion {
    private Regex _re;
    private string _regexString;
    internal ComparisonOperator Operator;
    private string _MatchingFileSpec;
    unknown string MatchingFileSpec {internal set; }
    internal virtual void set_MatchingFileSpec(string value);
    public virtual string ToString();
    internal virtual bool Evaluate(string filename);
    private bool _Evaluate(string fullpath);
    internal virtual bool Evaluate(ZipEntry entry);
}
internal abstract class Ionic.SelectionCriterion : object {
    [CompilerGeneratedAttribute]
private bool <Verbose>k__BackingField;
    internal bool Verbose { get; internal set; }
    [CompilerGeneratedAttribute]
internal virtual bool get_Verbose();
    [CompilerGeneratedAttribute]
internal virtual void set_Verbose(bool value);
    internal abstract virtual bool Evaluate(string filename);
    [ConditionalAttribute("SelectorTrace")]
protected static void CriterionTrace(string format, Object[] args);
    internal abstract virtual bool Evaluate(ZipEntry entry);
}
internal class Ionic.SizeCriterion : SelectionCriterion {
    internal ComparisonOperator Operator;
    internal long Size;
    public virtual string ToString();
    internal virtual bool Evaluate(string filename);
    private bool _Evaluate(long Length);
    internal virtual bool Evaluate(ZipEntry entry);
}
internal class Ionic.TimeCriterion : SelectionCriterion {
    internal ComparisonOperator Operator;
    internal WhichTime Which;
    internal DateTime Time;
    public virtual string ToString();
    internal virtual bool Evaluate(string filename);
    private bool _Evaluate(DateTime x);
    internal virtual bool Evaluate(ZipEntry entry);
}
internal class Ionic.TypeCriterion : SelectionCriterion {
    private char ObjectType;
    internal ComparisonOperator Operator;
    internal string AttributeString { get; internal set; }
    internal string get_AttributeString();
    internal void set_AttributeString(string value);
    public virtual string ToString();
    internal virtual bool Evaluate(string filename);
    internal virtual bool Evaluate(ZipEntry entry);
}
internal enum Ionic.WhichTime : Enum {
    public int value__;
    public static WhichTime atime;
    public static WhichTime mtime;
    public static WhichTime ctime;
}
internal enum Ionic.Zip.AddOrUpdateAction : Enum {
    public int value__;
    public static AddOrUpdateAction AddOnly;
    public static AddOrUpdateAction AddOrUpdate;
}
internal class Ionic.Zip.AddProgressEventArgs : ZipProgressEventArgs {
    private AddProgressEventArgs(string archiveName, ZipProgressEventType flavor);
    internal static AddProgressEventArgs AfterEntry(string archiveName, ZipEntry entry, int entriesTotal);
    internal static AddProgressEventArgs Started(string archiveName);
    internal static AddProgressEventArgs Completed(string archiveName);
}
[GuidAttribute("ebc25cf6-9120-4283-b972-0e5520d00009")]
internal class Ionic.Zip.BadCrcException : ZipException {
    public BadCrcException(string message);
    protected BadCrcException(SerializationInfo info, StreamingContext context);
}
[GuidAttribute("ebc25cf6-9120-4283-b972-0e5520d0000B")]
internal class Ionic.Zip.BadPasswordException : ZipException {
    public BadPasswordException(string message);
    public BadPasswordException(string message, Exception innerException);
    protected BadPasswordException(SerializationInfo info, StreamingContext context);
}
[GuidAttribute("ebc25cf6-9120-4283-b972-0e5520d0000A")]
internal class Ionic.Zip.BadReadException : ZipException {
    public BadReadException(string message);
    public BadReadException(string message, Exception innerException);
    protected BadReadException(SerializationInfo info, StreamingContext context);
}
[GuidAttribute("ebc25cf6-9120-4283-b972-0e5520d00007")]
internal class Ionic.Zip.BadStateException : ZipException {
    public BadStateException(string message);
    public BadStateException(string message, Exception innerException);
    protected BadStateException(SerializationInfo info, StreamingContext context);
}
internal class Ionic.Zip.CloseDelegate : MulticastDelegate {
    public CloseDelegate(object object, IntPtr method);
    public virtual void Invoke(string entryName, Stream stream);
    public virtual IAsyncResult BeginInvoke(string entryName, Stream stream, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[ClassInterfaceAttribute("1")]
[ComVisibleAttribute("True")]
[GuidAttribute("ebc25cf6-9120-4283-b972-0e5520d0000F")]
internal class Ionic.Zip.ComHelper : object {
    public bool IsZipFile(string filename);
    public bool IsZipFileWithExtract(string filename);
    public bool CheckZip(string filename);
    public bool CheckZipPassword(string filename, string password);
    public void FixZipDirectory(string filename);
    public string GetZipLibraryVersion();
}
internal enum Ionic.Zip.CompressionMethod : Enum {
    public int value__;
    public static CompressionMethod None;
    public static CompressionMethod Deflate;
    public static CompressionMethod BZip2;
}
internal class Ionic.Zip.CountingStream : Stream {
    private Stream _s;
    private long _bytesWritten;
    private long _bytesRead;
    private long _initialOffset;
    public Stream WrappedStream { get; }
    public long BytesWritten { get; }
    public long BytesRead { get; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long ComputedPosition { get; }
    public long Position { get; public set; }
    public CountingStream(Stream stream);
    public Stream get_WrappedStream();
    public long get_BytesWritten();
    public long get_BytesRead();
    public void Adjust(long delta);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual void Flush();
    public virtual long get_Length();
    public long get_ComputedPosition();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
}
internal enum Ionic.Zip.CryptoMode : Enum {
    public int value__;
    public static CryptoMode Encrypt;
    public static CryptoMode Decrypt;
}
internal enum Ionic.Zip.EncryptionAlgorithm : Enum {
    public int value__;
    public static EncryptionAlgorithm None;
    public static EncryptionAlgorithm PkzipWeak;
    public static EncryptionAlgorithm WinZipAes128;
    public static EncryptionAlgorithm WinZipAes256;
    public static EncryptionAlgorithm Unsupported;
}
internal enum Ionic.Zip.ExtractExistingFileAction : Enum {
    public int value__;
    public static ExtractExistingFileAction Throw;
    public static ExtractExistingFileAction OverwriteSilently;
    public static ExtractExistingFileAction DoNotOverwrite;
    public static ExtractExistingFileAction InvokeExtractProgressEvent;
}
internal class Ionic.Zip.ExtractProgressEventArgs : ZipProgressEventArgs {
    private int _entriesExtracted;
    private string _target;
    public int EntriesExtracted { get; }
    public string ExtractLocation { get; }
    internal ExtractProgressEventArgs(string archiveName, bool before, int entriesTotal, int entriesExtracted, ZipEntry entry, string extractLocation);
    internal ExtractProgressEventArgs(string archiveName, ZipProgressEventType flavor);
    internal static ExtractProgressEventArgs BeforeExtractEntry(string archiveName, ZipEntry entry, string extractLocation);
    internal static ExtractProgressEventArgs ExtractExisting(string archiveName, ZipEntry entry, string extractLocation);
    internal static ExtractProgressEventArgs AfterExtractEntry(string archiveName, ZipEntry entry, string extractLocation);
    internal static ExtractProgressEventArgs ExtractAllStarted(string archiveName, string extractLocation);
    internal static ExtractProgressEventArgs ExtractAllCompleted(string archiveName, string extractLocation);
    internal static ExtractProgressEventArgs ByteUpdate(string archiveName, ZipEntry entry, long bytesWritten, long totalBytes);
    public int get_EntriesExtracted();
    public string get_ExtractLocation();
}
internal class Ionic.Zip.OffsetStream : Stream {
    private long _originalPosition;
    private Stream _innerStream;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public OffsetStream(Stream s);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual void Flush();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    private sealed virtual override void System.IDisposable.Dispose();
    public virtual void Close();
}
internal class Ionic.Zip.OpenDelegate : MulticastDelegate {
    public OpenDelegate(object object, IntPtr method);
    public virtual Stream Invoke(string entryName);
    public virtual IAsyncResult BeginInvoke(string entryName, AsyncCallback callback, object object);
    public virtual Stream EndInvoke(IAsyncResult result);
}
internal class Ionic.Zip.ReadOptions : object {
    [CompilerGeneratedAttribute]
private EventHandler`1<ReadProgressEventArgs> <ReadProgress>k__BackingField;
    [CompilerGeneratedAttribute]
private TextWriter <StatusMessageWriter>k__BackingField;
    [CompilerGeneratedAttribute]
private Encoding <Encoding>k__BackingField;
    public EventHandler`1<ReadProgressEventArgs> ReadProgress { get; public set; }
    public TextWriter StatusMessageWriter { get; public set; }
    public Encoding Encoding { get; public set; }
    [CompilerGeneratedAttribute]
public EventHandler`1<ReadProgressEventArgs> get_ReadProgress();
    [CompilerGeneratedAttribute]
public void set_ReadProgress(EventHandler`1<ReadProgressEventArgs> value);
    [CompilerGeneratedAttribute]
public TextWriter get_StatusMessageWriter();
    [CompilerGeneratedAttribute]
public void set_StatusMessageWriter(TextWriter value);
    [CompilerGeneratedAttribute]
public Encoding get_Encoding();
    [CompilerGeneratedAttribute]
public void set_Encoding(Encoding value);
}
internal class Ionic.Zip.ReadProgressEventArgs : ZipProgressEventArgs {
    private ReadProgressEventArgs(string archiveName, ZipProgressEventType flavor);
    internal static ReadProgressEventArgs Before(string archiveName, int entriesTotal);
    internal static ReadProgressEventArgs After(string archiveName, ZipEntry entry, int entriesTotal);
    internal static ReadProgressEventArgs Started(string archiveName);
    internal static ReadProgressEventArgs ByteUpdate(string archiveName, ZipEntry entry, long bytesXferred, long totalBytes);
    internal static ReadProgressEventArgs Completed(string archiveName);
}
internal class Ionic.Zip.SaveProgressEventArgs : ZipProgressEventArgs {
    private int _entriesSaved;
    public int EntriesSaved { get; }
    internal SaveProgressEventArgs(string archiveName, bool before, int entriesTotal, int entriesSaved, ZipEntry entry);
    internal SaveProgressEventArgs(string archiveName, ZipProgressEventType flavor);
    internal static SaveProgressEventArgs ByteUpdate(string archiveName, ZipEntry entry, long bytesXferred, long totalBytes);
    internal static SaveProgressEventArgs Started(string archiveName);
    internal static SaveProgressEventArgs Completed(string archiveName);
    public int get_EntriesSaved();
}
internal enum Ionic.Zip.SelfExtractorFlavor : Enum {
    public int value__;
    public static SelfExtractorFlavor ConsoleApplication;
    public static SelfExtractorFlavor WinFormsApplication;
}
internal class Ionic.Zip.SelfExtractorSaveOptions : object {
    [CompilerGeneratedAttribute]
private SelfExtractorFlavor <Flavor>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PostExtractCommandLine>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DefaultExtractDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private string <IconFile>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Quiet>k__BackingField;
    [CompilerGeneratedAttribute]
private ExtractExistingFileAction <ExtractExistingFile>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RemoveUnpackedFilesAfterExecute>k__BackingField;
    [CompilerGeneratedAttribute]
private Version <FileVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProductVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Copyright>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProductName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SfxExeWindowTitle>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AdditionalCompilerSwitches>k__BackingField;
    public SelfExtractorFlavor Flavor { get; public set; }
    public string PostExtractCommandLine { get; public set; }
    public string DefaultExtractDirectory { get; public set; }
    public string IconFile { get; public set; }
    public bool Quiet { get; public set; }
    public ExtractExistingFileAction ExtractExistingFile { get; public set; }
    public bool RemoveUnpackedFilesAfterExecute { get; public set; }
    public Version FileVersion { get; public set; }
    public string ProductVersion { get; public set; }
    public string Copyright { get; public set; }
    public string Description { get; public set; }
    public string ProductName { get; public set; }
    public string SfxExeWindowTitle { get; public set; }
    public string AdditionalCompilerSwitches { get; public set; }
    [CompilerGeneratedAttribute]
public SelfExtractorFlavor get_Flavor();
    [CompilerGeneratedAttribute]
public void set_Flavor(SelfExtractorFlavor value);
    [CompilerGeneratedAttribute]
public string get_PostExtractCommandLine();
    [CompilerGeneratedAttribute]
public void set_PostExtractCommandLine(string value);
    [CompilerGeneratedAttribute]
public string get_DefaultExtractDirectory();
    [CompilerGeneratedAttribute]
public void set_DefaultExtractDirectory(string value);
    [CompilerGeneratedAttribute]
public string get_IconFile();
    [CompilerGeneratedAttribute]
public void set_IconFile(string value);
    [CompilerGeneratedAttribute]
public bool get_Quiet();
    [CompilerGeneratedAttribute]
public void set_Quiet(bool value);
    [CompilerGeneratedAttribute]
public ExtractExistingFileAction get_ExtractExistingFile();
    [CompilerGeneratedAttribute]
public void set_ExtractExistingFile(ExtractExistingFileAction value);
    [CompilerGeneratedAttribute]
public bool get_RemoveUnpackedFilesAfterExecute();
    [CompilerGeneratedAttribute]
public void set_RemoveUnpackedFilesAfterExecute(bool value);
    [CompilerGeneratedAttribute]
public Version get_FileVersion();
    [CompilerGeneratedAttribute]
public void set_FileVersion(Version value);
    [CompilerGeneratedAttribute]
public string get_ProductVersion();
    [CompilerGeneratedAttribute]
public void set_ProductVersion(string value);
    [CompilerGeneratedAttribute]
public string get_Copyright();
    [CompilerGeneratedAttribute]
public void set_Copyright(string value);
    [CompilerGeneratedAttribute]
public string get_Description();
    [CompilerGeneratedAttribute]
public void set_Description(string value);
    [CompilerGeneratedAttribute]
public string get_ProductName();
    [CompilerGeneratedAttribute]
public void set_ProductName(string value);
    [CompilerGeneratedAttribute]
public string get_SfxExeWindowTitle();
    [CompilerGeneratedAttribute]
public void set_SfxExeWindowTitle(string value);
    [CompilerGeneratedAttribute]
public string get_AdditionalCompilerSwitches();
    [CompilerGeneratedAttribute]
public void set_AdditionalCompilerSwitches(string value);
}
internal class Ionic.Zip.SetCompressionCallback : MulticastDelegate {
    public SetCompressionCallback(object object, IntPtr method);
    public virtual CompressionLevel Invoke(string localFileName, string fileNameInArchive);
    public virtual IAsyncResult BeginInvoke(string localFileName, string fileNameInArchive, AsyncCallback callback, object object);
    public virtual CompressionLevel EndInvoke(IAsyncResult result);
}
[GuidAttribute("ebc25cf6-9120-4283-b972-0e5520d00008")]
internal class Ionic.Zip.SfxGenerationException : ZipException {
    public SfxGenerationException(string message);
    protected SfxGenerationException(SerializationInfo info, StreamingContext context);
}
internal static class Ionic.Zip.SharedUtilities : object {
    private static Regex doubleDotRegex1;
    private static Encoding ibm437;
    private static Encoding utf8;
    private static SharedUtilities();
    public static long GetFileLength(string fileName);
    [ConditionalAttribute("NETCF")]
public static void Workaround_Ladybug318918(Stream s);
    private static string SimplifyFwdSlashPath(string path);
    public static string NormalizePathForUseInZipFile(string pathName);
    internal static Byte[] StringToByteArray(string value, Encoding encoding);
    internal static Byte[] StringToByteArray(string value);
    internal static string Utf8StringFromBuffer(Byte[] buf);
    internal static string StringFromBuffer(Byte[] buf, Encoding encoding);
    internal static int ReadSignature(Stream s);
    internal static int ReadEntrySignature(Stream s);
    internal static int ReadInt(Stream s);
    private static int _ReadFourBytes(Stream s, string message);
    internal static long FindSignature(Stream stream, int SignatureToFind);
    internal static DateTime AdjustTime_Reverse(DateTime time);
    internal static DateTime PackedToDateTime(int packedDateTime);
    internal static int DateTimeToPacked(DateTime time);
    public static void CreateAndOpenUniqueTempFile(string dir, Stream& fs, String& filename);
    public static string InternalGetTempFileName();
    internal static int ReadWithRetry(Stream s, Byte[] buffer, int offset, int count, string FileName);
    private static UInt32 _HRForException(Exception ex1);
}
internal class Ionic.Zip.WinZipAesCipherStream : Stream {
    private WinZipAesCrypto _params;
    private Stream _s;
    private CryptoMode _mode;
    private int _nonce;
    private bool _finalBlock;
    internal HMACSHA1 _mac;
    internal RijndaelManaged _aesCipher;
    internal ICryptoTransform _xform;
    private static int BLOCK_SIZE_IN_BYTES;
    private Byte[] counter;
    private Byte[] counterOut;
    private long _length;
    private long _totalBytesXferred;
    private Byte[] _PendingWriteBlock;
    private int _pendingCount;
    private Byte[] _iobuf;
    private object _outputLock;
    public Byte[] FinalAuthentication { get; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    internal WinZipAesCipherStream(Stream s, WinZipAesCrypto cryptoParams, long length, CryptoMode mode);
    internal WinZipAesCipherStream(Stream s, WinZipAesCrypto cryptoParams, CryptoMode mode);
    private void XorInPlace(Byte[] buffer, int offset, int count);
    private void WriteTransformOneBlock(Byte[] buffer, int offset);
    private void WriteTransformBlocks(Byte[] buffer, int offset, int count);
    private void WriteTransformFinalBlock();
    private int ReadTransformOneBlock(Byte[] buffer, int offset, int last);
    private void ReadTransformBlocks(Byte[] buffer, int offset, int count);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public Byte[] get_FinalAuthentication();
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void Close();
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual void Flush();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    [ConditionalAttribute("Trace")]
private void TraceOutput(string format, Object[] varParams);
}
internal class Ionic.Zip.WinZipAesCrypto : object {
    internal Byte[] _Salt;
    internal Byte[] _providedPv;
    internal Byte[] _generatedPv;
    internal int _KeyStrengthInBits;
    private Byte[] _MacInitializationVector;
    private Byte[] _StoredMac;
    private Byte[] _keyBytes;
    private short PasswordVerificationStored;
    private short PasswordVerificationGenerated;
    private int Rfc2898KeygenIterations;
    private string _Password;
    private bool _cryptoGenerated;
    public Byte[] CalculatedMac;
    public Byte[] GeneratedPV { get; }
    public Byte[] Salt { get; }
    private int _KeyStrengthInBytes { get; }
    public int SizeOfEncryptionMetadata { get; }
    private string Password { get; public set; }
    public Byte[] KeyBytes { get; }
    public Byte[] MacIv { get; }
    private WinZipAesCrypto(string password, int KeyStrengthInBits);
    public static WinZipAesCrypto Generate(string password, int KeyStrengthInBits);
    public static WinZipAesCrypto ReadFromStream(string password, int KeyStrengthInBits, Stream s);
    public Byte[] get_GeneratedPV();
    public Byte[] get_Salt();
    private int get__KeyStrengthInBytes();
    public int get_SizeOfEncryptionMetadata();
    public void set_Password(string value);
    private string get_Password();
    private void _GenerateCryptoBytes();
    public Byte[] get_KeyBytes();
    public Byte[] get_MacIv();
    public void ReadAndVerifyMac(Stream s);
}
internal class Ionic.Zip.WriteDelegate : MulticastDelegate {
    public WriteDelegate(object object, IntPtr method);
    public virtual void Invoke(string entryName, Stream stream);
    public virtual IAsyncResult BeginInvoke(string entryName, Stream stream, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal enum Ionic.Zip.Zip64Option : Enum {
    public int value__;
    public static Zip64Option Default;
    public static Zip64Option Never;
    public static Zip64Option AsNecessary;
    public static Zip64Option Always;
}
internal class Ionic.Zip.ZipCipherStream : Stream {
    private ZipCrypto _cipher;
    private Stream _s;
    private CryptoMode _mode;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public ZipCipherStream(Stream s, ZipCrypto cipher, CryptoMode mode);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual void Flush();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
}
internal static class Ionic.Zip.ZipConstants : object {
    public static UInt32 PackedToRemovableMedia;
    public static UInt32 Zip64EndOfCentralDirectoryRecordSignature;
    public static UInt32 Zip64EndOfCentralDirectoryLocatorSignature;
    public static UInt32 EndOfCentralDirectorySignature;
    public static int ZipEntrySignature;
    public static int ZipEntryDataDescriptorSignature;
    public static int SplitArchiveSignature;
    public static int ZipDirEntrySignature;
    public static int AesKeySize;
    public static int AesBlockSize;
    public static ushort AesAlgId128;
    public static ushort AesAlgId192;
    public static ushort AesAlgId256;
}
internal class Ionic.Zip.ZipContainer : object {
    private ZipFile _zf;
    private ZipOutputStream _zos;
    private ZipInputStream _zis;
    public ZipFile ZipFile { get; }
    public ZipOutputStream ZipOutputStream { get; }
    public string Name { get; }
    public string Password { get; }
    public Zip64Option Zip64 { get; }
    public int BufferSize { get; }
    public ParallelDeflateOutputStream ParallelDeflater { get; public set; }
    public long ParallelDeflateThreshold { get; }
    public int ParallelDeflateMaxBufferPairs { get; }
    public int CodecBufferSize { get; }
    public CompressionStrategy Strategy { get; }
    public Zip64Option UseZip64WhenSaving { get; }
    public Encoding AlternateEncoding { get; }
    public Encoding DefaultEncoding { get; }
    public ZipOption AlternateEncodingUsage { get; }
    public Stream ReadStream { get; }
    public ZipContainer(object o);
    public ZipFile get_ZipFile();
    public ZipOutputStream get_ZipOutputStream();
    public string get_Name();
    public string get_Password();
    public Zip64Option get_Zip64();
    public int get_BufferSize();
    public ParallelDeflateOutputStream get_ParallelDeflater();
    public void set_ParallelDeflater(ParallelDeflateOutputStream value);
    public long get_ParallelDeflateThreshold();
    public int get_ParallelDeflateMaxBufferPairs();
    public int get_CodecBufferSize();
    public CompressionStrategy get_Strategy();
    public Zip64Option get_UseZip64WhenSaving();
    public Encoding get_AlternateEncoding();
    public Encoding get_DefaultEncoding();
    public ZipOption get_AlternateEncodingUsage();
    public Stream get_ReadStream();
}
internal class Ionic.Zip.ZipCrypto : object {
    private UInt32[] _Keys;
    private CRC32 crc32;
    private byte MagicByte { get; }
    public static ZipCrypto ForWrite(string password);
    public static ZipCrypto ForRead(string password, ZipEntry e);
    private byte get_MagicByte();
    public Byte[] DecryptMessage(Byte[] cipherText, int length);
    public Byte[] EncryptMessage(Byte[] plainText, int length);
    public void InitCipher(string passphrase);
    private void UpdateKeys(byte byteValue);
}
[ClassInterfaceAttribute("1")]
[ComVisibleAttribute("True")]
[GuidAttribute("ebc25cf6-9120-4283-b972-0e5520d00004")]
internal class Ionic.Zip.ZipEntry : object {
    private short _VersionMadeBy;
    private short _InternalFileAttrs;
    private int _ExternalFileAttrs;
    private short _filenameLength;
    private short _extraFieldLength;
    private short _commentLength;
    [CompilerGeneratedAttribute]
private ExtractExistingFileAction <ExtractExistingFile>k__BackingField;
    [CompilerGeneratedAttribute]
private ZipErrorAction <ZipErrorAction>k__BackingField;
    [CompilerGeneratedAttribute]
private SetCompressionCallback <SetCompression>k__BackingField;
    [CompilerGeneratedAttribute]
private Encoding <ProvisionalAlternateEncoding>k__BackingField;
    [CompilerGeneratedAttribute]
private Encoding <AlternateEncoding>k__BackingField;
    [CompilerGeneratedAttribute]
private ZipOption <AlternateEncodingUsage>k__BackingField;
    private ZipCrypto _zipCrypto_forExtract;
    private ZipCrypto _zipCrypto_forWrite;
    private WinZipAesCrypto _aesCrypto_forExtract;
    private WinZipAesCrypto _aesCrypto_forWrite;
    private short _WinZipAesMethod;
    internal DateTime _LastModified;
    private DateTime _Mtime;
    private DateTime _Atime;
    private DateTime _Ctime;
    private bool _ntfsTimesAreSet;
    private bool _emitNtfsTimes;
    private bool _emitUnixTimes;
    private bool _TrimVolumeFromFullyQualifiedPaths;
    internal string _LocalFileName;
    private string _FileNameInArchive;
    internal short _VersionNeeded;
    internal short _BitField;
    internal short _CompressionMethod;
    private short _CompressionMethod_FromZipFile;
    private CompressionLevel _CompressionLevel;
    internal string _Comment;
    private bool _IsDirectory;
    private Byte[] _CommentBytes;
    internal long _CompressedSize;
    internal long _CompressedFileDataSize;
    internal long _UncompressedSize;
    internal int _TimeBlob;
    private bool _crcCalculated;
    internal int _Crc32;
    internal Byte[] _Extra;
    private bool _metadataChanged;
    private bool _restreamRequiredOnSave;
    private bool _sourceIsEncrypted;
    private bool _skippedDuringSave;
    private UInt32 _diskNumber;
    private static Encoding ibm437;
    private Encoding _actualEncoding;
    internal ZipContainer _container;
    private long __FileDataPosition;
    private Byte[] _EntryHeader;
    internal long _RelativeOffsetOfLocalHeader;
    private long _future_ROLH;
    private long _TotalEntrySize;
    private int _LengthOfHeader;
    private int _LengthOfTrailer;
    internal bool _InputUsesZip64;
    private UInt32 _UnsupportedAlgorithmId;
    internal string _Password;
    internal ZipEntrySource _Source;
    internal EncryptionAlgorithm _Encryption;
    internal EncryptionAlgorithm _Encryption_FromZipFile;
    internal Byte[] _WeakEncryptionHeader;
    internal Stream _archiveStream;
    private Stream _sourceStream;
    private Nullable`1<long> _sourceStreamOriginalPosition;
    private bool _sourceWasJitProvided;
    private bool _ioOperationCanceled;
    private bool _presumeZip64;
    private Nullable`1<bool> _entryRequiresZip64;
    private Nullable`1<bool> _OutputUsesZip64;
    private bool _IsText;
    private ZipEntryTimestamp _timestamp;
    private static DateTime _unixEpoch;
    private static DateTime _win32Epoch;
    private static DateTime _zeroHour;
    private WriteDelegate _WriteDelegate;
    private OpenDelegate _OpenDelegate;
    private CloseDelegate _CloseDelegate;
    private Stream _inputDecryptorStream;
    private int _readExtraDepth;
    private object _outputLock;
    internal bool AttributesIndicateDirectory { get; }
    public string Info { get; }
    public DateTime LastModified { get; public set; }
    private int BufferSize { get; }
    public DateTime ModifiedTime { get; public set; }
    public DateTime AccessedTime { get; public set; }
    public DateTime CreationTime { get; public set; }
    public bool EmitTimesInWindowsFormatWhenSaving { get; public set; }
    public bool EmitTimesInUnixFormatWhenSaving { get; public set; }
    public ZipEntryTimestamp Timestamp { get; }
    public FileAttributes Attributes { get; public set; }
    internal string LocalFileName { get; }
    public string FileName { get; public set; }
    public Stream InputStream { get; public set; }
    public bool InputStreamWasJitProvided { get; }
    public ZipEntrySource Source { get; }
    public short VersionNeeded { get; }
    public string Comment { get; public set; }
    public Nullable`1<bool> RequiresZip64 { get; }
    public Nullable`1<bool> OutputUsedZip64 { get; }
    public short BitField { get; }
    public CompressionMethod CompressionMethod { get; public set; }
    public CompressionLevel CompressionLevel { get; public set; }
    public long CompressedSize { get; }
    public long UncompressedSize { get; }
    public double CompressionRatio { get; }
    public int Crc { get; }
    public bool IsDirectory { get; }
    public bool UsesEncryption { get; }
    public EncryptionAlgorithm Encryption { get; public set; }
    private string Password { get; public set; }
    internal bool IsChanged { get; }
    public ExtractExistingFileAction ExtractExistingFile { get; public set; }
    public ZipErrorAction ZipErrorAction { get; public set; }
    public bool IncludedInMostRecentSave { get; }
    public SetCompressionCallback SetCompression { get; public set; }
    [ObsoleteAttribute("Beginning with v1.9.1.6 of DotNetZip, this property is obsolete.  It will be removed in a future version of the library. Your applications should  use AlternateEncoding and AlternateEncodingUsage instead.")]
public bool UseUnicodeAsNecessary { get; public set; }
    [ObsoleteAttribute("This property is obsolete since v1.9.1.6. Use AlternateEncoding and AlternateEncodingUsage instead.", "True")]
public Encoding ProvisionalAlternateEncoding { get; public set; }
    public Encoding AlternateEncoding { get; public set; }
    public ZipOption AlternateEncodingUsage { get; public set; }
    public bool IsText { get; public set; }
    internal Stream ArchiveStream { get; }
    internal long FileDataPosition { get; }
    private int LengthOfHeader { get; }
    private static ZipEntry();
    internal bool get_AttributesIndicateDirectory();
    internal void ResetDirEntry();
    public string get_Info();
    internal static ZipEntry ReadDirEntry(ZipFile zf, Dictionary`2<string, object> previouslySeen);
    internal static bool IsNotValidZipDirEntrySig(int signature);
    public DateTime get_LastModified();
    public void set_LastModified(DateTime value);
    private int get_BufferSize();
    public DateTime get_ModifiedTime();
    public void set_ModifiedTime(DateTime value);
    public DateTime get_AccessedTime();
    public void set_AccessedTime(DateTime value);
    public DateTime get_CreationTime();
    public void set_CreationTime(DateTime value);
    public void SetEntryTimes(DateTime created, DateTime accessed, DateTime modified);
    public bool get_EmitTimesInWindowsFormatWhenSaving();
    public void set_EmitTimesInWindowsFormatWhenSaving(bool value);
    public bool get_EmitTimesInUnixFormatWhenSaving();
    public void set_EmitTimesInUnixFormatWhenSaving(bool value);
    public ZipEntryTimestamp get_Timestamp();
    public FileAttributes get_Attributes();
    public void set_Attributes(FileAttributes value);
    internal string get_LocalFileName();
    public string get_FileName();
    public void set_FileName(string value);
    public Stream get_InputStream();
    public void set_InputStream(Stream value);
    public bool get_InputStreamWasJitProvided();
    public ZipEntrySource get_Source();
    public short get_VersionNeeded();
    public string get_Comment();
    public void set_Comment(string value);
    public Nullable`1<bool> get_RequiresZip64();
    public Nullable`1<bool> get_OutputUsedZip64();
    public short get_BitField();
    public CompressionMethod get_CompressionMethod();
    public void set_CompressionMethod(CompressionMethod value);
    public CompressionLevel get_CompressionLevel();
    public void set_CompressionLevel(CompressionLevel value);
    public long get_CompressedSize();
    public long get_UncompressedSize();
    public double get_CompressionRatio();
    public int get_Crc();
    public bool get_IsDirectory();
    public bool get_UsesEncryption();
    public EncryptionAlgorithm get_Encryption();
    public void set_Encryption(EncryptionAlgorithm value);
    public void set_Password(string value);
    private string get_Password();
    internal bool get_IsChanged();
    [CompilerGeneratedAttribute]
public ExtractExistingFileAction get_ExtractExistingFile();
    [CompilerGeneratedAttribute]
public void set_ExtractExistingFile(ExtractExistingFileAction value);
    [CompilerGeneratedAttribute]
public ZipErrorAction get_ZipErrorAction();
    [CompilerGeneratedAttribute]
public void set_ZipErrorAction(ZipErrorAction value);
    public bool get_IncludedInMostRecentSave();
    [CompilerGeneratedAttribute]
public SetCompressionCallback get_SetCompression();
    [CompilerGeneratedAttribute]
public void set_SetCompression(SetCompressionCallback value);
    public bool get_UseUnicodeAsNecessary();
    public void set_UseUnicodeAsNecessary(bool value);
    [CompilerGeneratedAttribute]
public Encoding get_ProvisionalAlternateEncoding();
    [CompilerGeneratedAttribute]
public void set_ProvisionalAlternateEncoding(Encoding value);
    [CompilerGeneratedAttribute]
public Encoding get_AlternateEncoding();
    [CompilerGeneratedAttribute]
public void set_AlternateEncoding(Encoding value);
    [CompilerGeneratedAttribute]
public ZipOption get_AlternateEncodingUsage();
    [CompilerGeneratedAttribute]
public void set_AlternateEncodingUsage(ZipOption value);
    internal static string NameInArchive(string filename, string directoryPathInArchive);
    internal static ZipEntry CreateFromNothing(string nameInArchive);
    internal static ZipEntry CreateFromFile(string filename, string nameInArchive);
    internal static ZipEntry CreateForStream(string entryName, Stream s);
    internal static ZipEntry CreateForWriter(string entryName, WriteDelegate d);
    internal static ZipEntry CreateForJitStreamProvider(string nameInArchive, OpenDelegate opener, CloseDelegate closer);
    internal static ZipEntry CreateForZipOutputStream(string nameInArchive);
    private static ZipEntry Create(string nameInArchive, ZipEntrySource source, object arg1, object arg2);
    internal void MarkAsDirectory();
    public bool get_IsText();
    public void set_IsText(bool value);
    public virtual string ToString();
    internal Stream get_ArchiveStream();
    private void SetFdpLoh();
    private static int GetKeyStrengthInBits(EncryptionAlgorithm a);
    internal static int GetLengthOfCryptoHeaderBytes(EncryptionAlgorithm a);
    internal long get_FileDataPosition();
    private int get_LengthOfHeader();
    public void Extract();
    public void Extract(ExtractExistingFileAction extractExistingFile);
    public void Extract(Stream stream);
    public void Extract(string baseDirectory);
    public void Extract(string baseDirectory, ExtractExistingFileAction extractExistingFile);
    public void ExtractWithPassword(string password);
    public void ExtractWithPassword(string baseDirectory, string password);
    public void ExtractWithPassword(ExtractExistingFileAction extractExistingFile, string password);
    public void ExtractWithPassword(string baseDirectory, ExtractExistingFileAction extractExistingFile, string password);
    public void ExtractWithPassword(Stream stream, string password);
    public CrcCalculatorStream OpenReader();
    public CrcCalculatorStream OpenReader(string password);
    internal CrcCalculatorStream InternalOpenReader(string password);
    private void OnExtractProgress(long bytesWritten, long totalBytesToWrite);
    private static void OnBeforeExtract(ZipEntry zipEntryInstance, string path, ZipFile zipFile);
    private void OnAfterExtract(string path);
    private void OnExtractExisting(string path);
    private static void ReallyDelete(string fileName);
    private void WriteStatus(string format, Object[] args);
    private void InternalExtractToBaseDir(string baseDir, string password, ZipContainer zipContainer, ZipEntrySource zipEntrySource, string fileName);
    private void InternalExtractToStream(Stream outStream, string password, ZipContainer zipContainer, ZipEntrySource zipEntrySource, string fileName);
    private bool ExtractToStream(Stream archiveStream, Stream output, EncryptionAlgorithm encryptionAlgorithm, int expectedCrc32);
    private void MoveFileInPlace(bool fileExistsBeforeExtraction, string targetFileName, string tmpPath, bool checkLaterForResetDirTimes);
    private void EnsurePassword(string password);
    private Stream OpenFileStream(string tmpPath, Boolean& checkLaterForResetDirTimes);
    internal void VerifyCrcAfterExtract(int calculatedCrc32, EncryptionAlgorithm encryptionAlgorithm, int expectedCrc32, Stream archiveStream, long uncompressedSize);
    private int CheckExtractExistingFile(string baseDir, string targetFileName);
    private void _CheckRead(int nbytes);
    private int ExtractAndCrc(Stream archiveStream, Stream targetOutput, short compressionMethod, long compressedFileDataSize, long uncompressedSize);
    private Stream GetExtractDecompressor(Stream input2);
    private Stream GetExtractDecryptor(Stream input);
    internal void _SetTimes(string fileOrDirectory, bool isFile);
    private static string GetUnsupportedAlgorithm(UInt32 unsupportedAlgorithmId);
    private static string GetUnsupportedCompressionMethod(short compressionMethod);
    private static void ValidateEncryption(EncryptionAlgorithm encryptionAlgorithm, string fileName, UInt32 unsupportedAlgorithmId);
    private static void ValidateCompression(short compressionMethod, string fileName, string compressionMethodName);
    private void SetupCryptoForExtract(string password);
    private bool IsDoneWithOutputToBaseDir(string baseDir, String& outFileName);
    private bool IsDoneWithOutputToStream();
    private void ReadExtraField();
    private static bool ReadHeader(ZipEntry ze, Encoding defaultEncoding);
    internal static int ReadWeakEncryptionHeader(Stream s, Byte[] buffer);
    private static bool IsNotValidSig(int signature);
    internal static ZipEntry ReadEntry(ZipContainer zc, bool first);
    internal static void HandlePK00Prefix(Stream s);
    private static void HandleUnexpectedDataDescriptor(ZipEntry entry);
    internal static int FindExtraFieldSegment(Byte[] extra, int offx, ushort targetHeaderId);
    internal int ProcessExtraField(Stream s, short extraFieldLength);
    private int ProcessExtraFieldPkwareStrongEncryption(Byte[] Buffer, int j);
    private int ProcessExtraFieldWinZipAes(Byte[] buffer, int j, ushort dataSize, long posn);
    private int ProcessExtraFieldZip64(Byte[] buffer, int j, ushort dataSize, long posn);
    private int ProcessExtraFieldInfoZipTimes(Byte[] buffer, int j, ushort dataSize, long posn);
    private int ProcessExtraFieldUnixTimes(Byte[] buffer, int j, ushort dataSize, long posn);
    private int ProcessExtraFieldWindowsTimes(Byte[] buffer, int j, ushort dataSize, long posn);
    internal void WriteCentralDirectoryEntry(Stream s);
    private Byte[] ConstructExtraField(bool forCentralDirectory);
    private string NormalizeFileName();
    private Byte[] GetEncodedFileNameBytes();
    private bool WantReadAgain();
    private void MaybeUnsetCompressionMethodForWriting(int cycle);
    internal void WriteHeader(Stream s, int cycle);
    private int FigureCrc32();
    private void PrepSourceStream();
    internal void CopyMetaData(ZipEntry source);
    private void OnWriteBlock(long bytesXferred, long totalBytesToXfer);
    private void _WriteEntryData(Stream s);
    private long SetInputAndFigureFileLength(Stream& input);
    internal void FinishOutputStream(Stream s, CountingStream entryCounter, Stream encryptor, Stream compressor, CrcCalculatorStream output);
    internal void PostProcessOutput(Stream s);
    private void SetZip64Flags();
    internal void PrepOutputStream(Stream s, long streamLength, CountingStream& outputCounter, Stream& encryptor, Stream& compressor, CrcCalculatorStream& output);
    private Stream MaybeApplyCompression(Stream s, long streamLength);
    private Stream MaybeApplyEncryption(Stream s);
    private void OnZipErrorWhileSaving(Exception e);
    internal void Write(Stream s);
    internal void StoreRelativeOffset();
    internal void NotifySaveComplete();
    internal void WriteSecurityMetadata(Stream outstream);
    private void CopyThroughOneEntry(Stream outStream);
    private void CopyThroughWithRecompute(Stream outstream);
    private void CopyThroughWithNoChange(Stream outstream);
    [ConditionalAttribute("Trace")]
private void TraceWriteLine(string format, Object[] varParams);
}
internal enum Ionic.Zip.ZipEntrySource : Enum {
    public int value__;
    public static ZipEntrySource None;
    public static ZipEntrySource FileSystem;
    public static ZipEntrySource Stream;
    public static ZipEntrySource ZipFile;
    public static ZipEntrySource WriteDelegate;
    public static ZipEntrySource JitStream;
    public static ZipEntrySource ZipOutputStream;
}
[FlagsAttribute]
internal enum Ionic.Zip.ZipEntryTimestamp : Enum {
    public int value__;
    public static ZipEntryTimestamp None;
    public static ZipEntryTimestamp DOS;
    public static ZipEntryTimestamp Windows;
    public static ZipEntryTimestamp Unix;
    public static ZipEntryTimestamp InfoZip1;
}
internal enum Ionic.Zip.ZipErrorAction : Enum {
    public int value__;
    public static ZipErrorAction Throw;
    public static ZipErrorAction Skip;
    public static ZipErrorAction Retry;
    public static ZipErrorAction InvokeErrorEvent;
}
internal class Ionic.Zip.ZipErrorEventArgs : ZipProgressEventArgs {
    private Exception _exc;
    public Exception Exception { get; }
    public string FileName { get; }
    internal static ZipErrorEventArgs Saving(string archiveName, ZipEntry entry, Exception exception);
    public Exception get_Exception();
    public string get_FileName();
}
[GuidAttribute("ebc25cf6-9120-4283-b972-0e5520d00006")]
internal class Ionic.Zip.ZipException : Exception {
    public ZipException(string message);
    public ZipException(string message, Exception innerException);
    protected ZipException(SerializationInfo info, StreamingContext context);
}
[GuidAttribute("ebc25cf6-9120-4283-b972-0e5520d00005")]
[ClassInterfaceAttribute("1")]
[ComVisibleAttribute("True")]
[DefaultMemberAttribute("Item")]
internal class Ionic.Zip.ZipFile : object {
    private static ExtractorSettings[] SettingsList;
    [CompilerGeneratedAttribute]
private bool <FullScan>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SortEntriesBeforeSaving>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AddDirectoryWillTraverseReparsePoints>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CodecBufferSize>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <FlattenFoldersOnExtract>k__BackingField;
    [CompilerGeneratedAttribute]
private CompressionLevel <CompressionLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private ExtractExistingFileAction <ExtractExistingFile>k__BackingField;
    [CompilerGeneratedAttribute]
private SetCompressionCallback <SetCompression>k__BackingField;
    private TextWriter _StatusMessageTextWriter;
    private bool _CaseSensitiveRetrieval;
    private bool _IgnoreDuplicateFiles;
    private Stream _readstream;
    private Stream _writestream;
    private ushort _versionMadeBy;
    private ushort _versionNeededToExtract;
    private UInt32 _diskNumberWithCd;
    private int _maxOutputSegmentSize;
    private UInt32 _numberOfSegmentsForMostRecentSave;
    private ZipErrorAction _zipErrorAction;
    private bool _disposed;
    private Dictionary`2<string, ZipEntry> _entries;
    private Dictionary`2<string, ZipEntry> _entriesInsensitive;
    private List`1<ZipEntry> _zipEntriesAsList;
    private string _name;
    private string _readName;
    private string _Comment;
    internal string _Password;
    private bool _emitNtfsTimes;
    private bool _emitUnixTimes;
    private CompressionStrategy _Strategy;
    private CompressionMethod _compressionMethod;
    private bool _fileAlreadyExists;
    private string _temporaryFileName;
    private bool _contentsChanged;
    private bool _hasBeenSaved;
    private string _TempFileFolder;
    private bool _ReadStreamIsOurs;
    private object LOCK;
    private bool _saveOperationCanceled;
    private bool _extractOperationCanceled;
    private bool _addOperationCanceled;
    private EncryptionAlgorithm _Encryption;
    private bool _JustSaved;
    private long _locEndOfCDS;
    private UInt32 _OffsetOfCentralDirectory;
    private long _OffsetOfCentralDirectory64;
    private Nullable`1<bool> _OutputUsesZip64;
    internal bool _inExtractAll;
    private Encoding _alternateEncoding;
    private ZipOption _alternateEncodingUsage;
    private static Encoding _defaultEncoding;
    private int _BufferSize;
    internal ParallelDeflateOutputStream ParallelDeflater;
    private long _ParallelDeflateThreshold;
    private int _maxBufferPairs;
    internal Zip64Option _zip64;
    private bool _SavingSfx;
    public static int BufferSizeDefault;
    [CompilerGeneratedAttribute]
private EventHandler`1<SaveProgressEventArgs> SaveProgress;
    [CompilerGeneratedAttribute]
private EventHandler`1<ReadProgressEventArgs> ReadProgress;
    private long _lengthOfReadStream;
    [CompilerGeneratedAttribute]
private EventHandler`1<ExtractProgressEventArgs> ExtractProgress;
    [CompilerGeneratedAttribute]
private EventHandler`1<AddProgressEventArgs> AddProgress;
    [CompilerGeneratedAttribute]
private EventHandler`1<ZipErrorEventArgs> ZipError;
    public string Info { get; }
    public bool FullScan { get; public set; }
    public bool SortEntriesBeforeSaving { get; public set; }
    public bool AddDirectoryWillTraverseReparsePoints { get; public set; }
    public int BufferSize { get; public set; }
    public int CodecBufferSize { get; public set; }
    public bool FlattenFoldersOnExtract { get; public set; }
    public CompressionStrategy Strategy { get; public set; }
    public string Name { get; public set; }
    public CompressionLevel CompressionLevel { get; public set; }
    public CompressionMethod CompressionMethod { get; public set; }
    public string Comment { get; public set; }
    public bool EmitTimesInWindowsFormatWhenSaving { get; public set; }
    public bool EmitTimesInUnixFormatWhenSaving { get; public set; }
    internal bool Verbose { get; }
    public bool CaseSensitiveRetrieval { get; public set; }
    private Dictionary`2<string, ZipEntry> RetrievalEntries { get; }
    public bool IgnoreDuplicateFiles { get; public set; }
    [ObsoleteAttribute("Beginning with v1.9.1.6 of DotNetZip, this property is obsolete.  It will be removed in a future version of the library. Your applications should  use AlternateEncoding and AlternateEncodingUsage instead.")]
public bool UseUnicodeAsNecessary { get; public set; }
    public Zip64Option UseZip64WhenSaving { get; public set; }
    public Nullable`1<bool> RequiresZip64 { get; }
    public Nullable`1<bool> OutputUsedZip64 { get; }
    public Nullable`1<bool> InputUsesZip64 { get; }
    [ObsoleteAttribute("use AlternateEncoding instead.")]
public Encoding ProvisionalAlternateEncoding { get; public set; }
    public Encoding AlternateEncoding { get; public set; }
    public ZipOption AlternateEncodingUsage { get; public set; }
    public static Encoding DefaultEncoding { get; }
    public TextWriter StatusMessageTextWriter { get; public set; }
    public string TempFileFolder { get; public set; }
    private string Password { get; public set; }
    public ExtractExistingFileAction ExtractExistingFile { get; public set; }
    public ZipErrorAction ZipErrorAction { get; public set; }
    public EncryptionAlgorithm Encryption { get; public set; }
    public SetCompressionCallback SetCompression { get; public set; }
    public int MaxOutputSegmentSize { get; public set; }
    public int NumberOfSegmentsForMostRecentSave { get; }
    public long ParallelDeflateThreshold { get; public set; }
    public int ParallelDeflateMaxBufferPairs { get; public set; }
    public static Version LibraryVersion { get; }
    private List`1<ZipEntry> ZipEntriesAsList { get; }
    public ZipEntry Item { get; }
    public ZipEntry Item { get; }
    public ICollection`1<string> EntryFileNames { get; }
    public ICollection`1<ZipEntry> Entries { get; }
    public ICollection`1<ZipEntry> EntriesSorted { get; }
    public int Count { get; }
    internal Stream ReadStream { get; }
    private Stream WriteStream { get; private set; }
    private string ArchiveNameForEvent { get; }
    private long LengthOfReadStream { get; }
    public ZipFile(string fileName);
    public ZipFile(string fileName, Encoding encoding);
    public ZipFile(Encoding encoding);
    public ZipFile(string fileName, TextWriter statusMessageWriter);
    public ZipFile(string fileName, TextWriter statusMessageWriter, Encoding encoding);
    private static ZipFile();
    public void SaveSelfExtractor(string exeToGenerate, SelfExtractorFlavor flavor);
    public void SaveSelfExtractor(string exeToGenerate, SelfExtractorSaveOptions options);
    private static void ExtractResourceToFile(Assembly a, string resourceName, string filename);
    private void _SaveSfxStub(string exeToGenerate, SelfExtractorSaveOptions options);
    internal static string GenerateTempPathname(string dir, string extension);
    public ZipEntry AddItem(string fileOrDirectoryName);
    public ZipEntry AddItem(string fileOrDirectoryName, string directoryPathInArchive);
    public ZipEntry AddFile(string fileName);
    public ZipEntry AddFile(string fileName, string directoryPathInArchive);
    public void RemoveEntries(ICollection`1<ZipEntry> entriesToRemove);
    public void RemoveEntries(ICollection`1<string> entriesToRemove);
    public void AddFiles(IEnumerable`1<string> fileNames);
    public void UpdateFiles(IEnumerable`1<string> fileNames);
    public void AddFiles(IEnumerable`1<string> fileNames, string directoryPathInArchive);
    public void AddFiles(IEnumerable`1<string> fileNames, bool preserveDirHierarchy, string directoryPathInArchive);
    public void UpdateFiles(IEnumerable`1<string> fileNames, string directoryPathInArchive);
    public ZipEntry UpdateFile(string fileName);
    public ZipEntry UpdateFile(string fileName, string directoryPathInArchive);
    public ZipEntry UpdateDirectory(string directoryName);
    public ZipEntry UpdateDirectory(string directoryName, string directoryPathInArchive);
    public void UpdateItem(string itemName);
    public void UpdateItem(string itemName, string directoryPathInArchive);
    public ZipEntry AddEntry(string entryName, string content);
    public ZipEntry AddEntry(string entryName, string content, Encoding encoding);
    public ZipEntry AddEntry(string entryName, Stream stream);
    public ZipEntry AddEntry(string entryName, WriteDelegate writer);
    public ZipEntry AddEntry(string entryName, OpenDelegate opener, CloseDelegate closer);
    private ZipEntry _InternalAddEntry(ZipEntry ze);
    public ZipEntry UpdateEntry(string entryName, string content);
    public ZipEntry UpdateEntry(string entryName, string content, Encoding encoding);
    public ZipEntry UpdateEntry(string entryName, WriteDelegate writer);
    public ZipEntry UpdateEntry(string entryName, OpenDelegate opener, CloseDelegate closer);
    public ZipEntry UpdateEntry(string entryName, Stream stream);
    private void RemoveEntryForUpdate(string entryName);
    public ZipEntry AddEntry(string entryName, Byte[] byteContent);
    public ZipEntry UpdateEntry(string entryName, Byte[] byteContent);
    public ZipEntry AddDirectory(string directoryName);
    public ZipEntry AddDirectory(string directoryName, string directoryPathInArchive);
    public ZipEntry AddDirectoryByName(string directoryNameInArchive);
    private ZipEntry AddOrUpdateDirectoryImpl(string directoryName, string rootDirectoryPathInArchive, AddOrUpdateAction action);
    internal void InternalAddEntry(string name, ZipEntry entry);
    private ZipEntry AddOrUpdateDirectoryImpl(string directoryName, string rootDirectoryPathInArchive, AddOrUpdateAction action, bool recurse, int level);
    public static bool CheckZip(string zipFileName);
    public static bool CheckZip(string zipFileName, bool fixIfNecessary, TextWriter writer);
    public static void FixZipDirectory(string zipFileName);
    public static bool CheckZipPassword(string zipFileName, string password);
    public string get_Info();
    [CompilerGeneratedAttribute]
public bool get_FullScan();
    [CompilerGeneratedAttribute]
public void set_FullScan(bool value);
    [CompilerGeneratedAttribute]
public bool get_SortEntriesBeforeSaving();
    [CompilerGeneratedAttribute]
public void set_SortEntriesBeforeSaving(bool value);
    [CompilerGeneratedAttribute]
public bool get_AddDirectoryWillTraverseReparsePoints();
    [CompilerGeneratedAttribute]
public void set_AddDirectoryWillTraverseReparsePoints(bool value);
    public int get_BufferSize();
    public void set_BufferSize(int value);
    [CompilerGeneratedAttribute]
public int get_CodecBufferSize();
    [CompilerGeneratedAttribute]
public void set_CodecBufferSize(int value);
    [CompilerGeneratedAttribute]
public bool get_FlattenFoldersOnExtract();
    [CompilerGeneratedAttribute]
public void set_FlattenFoldersOnExtract(bool value);
    public CompressionStrategy get_Strategy();
    public void set_Strategy(CompressionStrategy value);
    public string get_Name();
    public void set_Name(string value);
    [CompilerGeneratedAttribute]
public CompressionLevel get_CompressionLevel();
    [CompilerGeneratedAttribute]
public void set_CompressionLevel(CompressionLevel value);
    public CompressionMethod get_CompressionMethod();
    public void set_CompressionMethod(CompressionMethod value);
    public string get_Comment();
    public void set_Comment(string value);
    public bool get_EmitTimesInWindowsFormatWhenSaving();
    public void set_EmitTimesInWindowsFormatWhenSaving(bool value);
    public bool get_EmitTimesInUnixFormatWhenSaving();
    public void set_EmitTimesInUnixFormatWhenSaving(bool value);
    internal bool get_Verbose();
    public bool ContainsEntry(string name);
    public bool get_CaseSensitiveRetrieval();
    public void set_CaseSensitiveRetrieval(bool value);
    private Dictionary`2<string, ZipEntry> get_RetrievalEntries();
    public bool get_IgnoreDuplicateFiles();
    public void set_IgnoreDuplicateFiles(bool value);
    public bool get_UseUnicodeAsNecessary();
    public void set_UseUnicodeAsNecessary(bool value);
    public Zip64Option get_UseZip64WhenSaving();
    public void set_UseZip64WhenSaving(Zip64Option value);
    public Nullable`1<bool> get_RequiresZip64();
    public Nullable`1<bool> get_OutputUsedZip64();
    public Nullable`1<bool> get_InputUsesZip64();
    public Encoding get_ProvisionalAlternateEncoding();
    public void set_ProvisionalAlternateEncoding(Encoding value);
    public Encoding get_AlternateEncoding();
    public void set_AlternateEncoding(Encoding value);
    public ZipOption get_AlternateEncodingUsage();
    public void set_AlternateEncodingUsage(ZipOption value);
    public static Encoding get_DefaultEncoding();
    public TextWriter get_StatusMessageTextWriter();
    public void set_StatusMessageTextWriter(TextWriter value);
    public string get_TempFileFolder();
    public void set_TempFileFolder(string value);
    public void set_Password(string value);
    private string get_Password();
    [CompilerGeneratedAttribute]
public ExtractExistingFileAction get_ExtractExistingFile();
    [CompilerGeneratedAttribute]
public void set_ExtractExistingFile(ExtractExistingFileAction value);
    public ZipErrorAction get_ZipErrorAction();
    public void set_ZipErrorAction(ZipErrorAction value);
    public EncryptionAlgorithm get_Encryption();
    public void set_Encryption(EncryptionAlgorithm value);
    [CompilerGeneratedAttribute]
public SetCompressionCallback get_SetCompression();
    [CompilerGeneratedAttribute]
public void set_SetCompression(SetCompressionCallback value);
    public int get_MaxOutputSegmentSize();
    public void set_MaxOutputSegmentSize(int value);
    public int get_NumberOfSegmentsForMostRecentSave();
    public void set_ParallelDeflateThreshold(long value);
    public long get_ParallelDeflateThreshold();
    public int get_ParallelDeflateMaxBufferPairs();
    public void set_ParallelDeflateMaxBufferPairs(int value);
    public virtual string ToString();
    public static Version get_LibraryVersion();
    internal void NotifyEntryChanged();
    internal Stream StreamForDiskNumber(UInt32 diskNumber);
    internal void Reset(bool whileSaving);
    public void Initialize(string fileName);
    private void _InitInstance(string zipFileName, TextWriter statusMessageWriter);
    private List`1<ZipEntry> get_ZipEntriesAsList();
    public ZipEntry get_Item(int ix);
    public ZipEntry get_Item(string fileName);
    public ICollection`1<string> get_EntryFileNames();
    public ICollection`1<ZipEntry> get_Entries();
    public ICollection`1<ZipEntry> get_EntriesSorted();
    public int get_Count();
    public void RemoveEntry(ZipEntry entry);
    private bool AnyCaseInsensitiveMatches(string path);
    public void RemoveEntry(string fileName);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposeManagedResources);
    internal Stream get_ReadStream();
    private Stream get_WriteStream();
    private void set_WriteStream(Stream value);
    private string get_ArchiveNameForEvent();
    [CompilerGeneratedAttribute]
public void add_SaveProgress(EventHandler`1<SaveProgressEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_SaveProgress(EventHandler`1<SaveProgressEventArgs> value);
    internal bool OnSaveBlock(ZipEntry entry, long bytesXferred, long totalBytesToXfer);
    private void OnSaveEntry(int current, ZipEntry entry, bool before);
    private void OnSaveEvent(ZipProgressEventType eventFlavor);
    private void OnSaveStarted();
    private void OnSaveCompleted();
    [CompilerGeneratedAttribute]
public void add_ReadProgress(EventHandler`1<ReadProgressEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_ReadProgress(EventHandler`1<ReadProgressEventArgs> value);
    private void OnReadStarted();
    private void OnReadCompleted();
    internal void OnReadBytes(ZipEntry entry);
    internal void OnReadEntry(bool before, ZipEntry entry);
    private long get_LengthOfReadStream();
    [CompilerGeneratedAttribute]
public void add_ExtractProgress(EventHandler`1<ExtractProgressEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_ExtractProgress(EventHandler`1<ExtractProgressEventArgs> value);
    private void OnExtractEntry(int current, bool before, ZipEntry currentEntry, string path);
    internal bool OnExtractBlock(ZipEntry entry, long bytesWritten, long totalBytesToWrite);
    internal bool OnSingleEntryExtract(ZipEntry entry, string path, bool before);
    internal bool OnExtractExisting(ZipEntry entry, string path);
    private void OnExtractAllCompleted(string path);
    private void OnExtractAllStarted(string path);
    [CompilerGeneratedAttribute]
public void add_AddProgress(EventHandler`1<AddProgressEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_AddProgress(EventHandler`1<AddProgressEventArgs> value);
    private void OnAddStarted();
    private void OnAddCompleted();
    internal void AfterAddEntry(ZipEntry entry);
    [CompilerGeneratedAttribute]
public void add_ZipError(EventHandler`1<ZipErrorEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_ZipError(EventHandler`1<ZipErrorEventArgs> value);
    internal bool OnZipErrorSaving(ZipEntry entry, Exception exc);
    public void ExtractAll(string path);
    public void ExtractAll(string path, ExtractExistingFileAction extractExistingFile);
    private void _InternalExtractAll(string path, bool overrideExtractExistingProperty);
    public static ZipFile Read(string fileName);
    public static ZipFile Read(string fileName, ReadOptions options);
    private static ZipFile Read(string fileName, TextWriter statusMessageWriter, Encoding encoding, EventHandler`1<ReadProgressEventArgs> readProgress);
    public static ZipFile Read(Stream zipStream);
    public static ZipFile Read(Stream zipStream, ReadOptions options);
    private static ZipFile Read(Stream zipStream, TextWriter statusMessageWriter, Encoding encoding, EventHandler`1<ReadProgressEventArgs> readProgress);
    private static void ReadIntoInstance(ZipFile zf);
    private static void Zip64SeekToCentralDirectory(ZipFile zf);
    private static UInt32 ReadFirstFourBytes(Stream s);
    private static void ReadCentralDirectory(ZipFile zf);
    private static void ReadIntoInstance_Orig(ZipFile zf);
    private static void ReadCentralDirectoryFooter(ZipFile zf);
    private static void ReadZipFileComment(ZipFile zf);
    public static bool IsZipFile(string fileName);
    public static bool IsZipFile(string fileName, bool testExtract);
    public static bool IsZipFile(Stream stream, bool testExtract);
    private void DeleteFileWithRetry(string filename);
    public void Save();
    private static void NotifyEntriesSaveComplete(ICollection`1<ZipEntry> c);
    private void RemoveTempFile();
    private void CleanupAfterSaveOperation();
    public void Save(string fileName);
    public void Save(Stream outputStream);
    public void AddSelectedFiles(string selectionCriteria);
    public void AddSelectedFiles(string selectionCriteria, bool recurseDirectories);
    public void AddSelectedFiles(string selectionCriteria, string directoryOnDisk);
    public void AddSelectedFiles(string selectionCriteria, string directoryOnDisk, bool recurseDirectories);
    public void AddSelectedFiles(string selectionCriteria, string directoryOnDisk, string directoryPathInArchive);
    public void AddSelectedFiles(string selectionCriteria, string directoryOnDisk, string directoryPathInArchive, bool recurseDirectories);
    public void UpdateSelectedFiles(string selectionCriteria, string directoryOnDisk, string directoryPathInArchive, bool recurseDirectories);
    private string EnsureendInSlash(string s);
    private void _AddOrUpdateSelectedFiles(string selectionCriteria, string directoryOnDisk, string directoryPathInArchive, bool recurseDirectories, bool wantUpdate);
    private static string ReplaceLeadingDirectory(string original, string pattern, string replacement);
    public ICollection`1<ZipEntry> SelectEntries(string selectionCriteria);
    public ICollection`1<ZipEntry> SelectEntries(string selectionCriteria, string directoryPathInArchive);
    public int RemoveSelectedEntries(string selectionCriteria);
    public int RemoveSelectedEntries(string selectionCriteria, string directoryPathInArchive);
    public void ExtractSelectedEntries(string selectionCriteria);
    public void ExtractSelectedEntries(string selectionCriteria, ExtractExistingFileAction extractExistingFile);
    public void ExtractSelectedEntries(string selectionCriteria, string directoryPathInArchive);
    public void ExtractSelectedEntries(string selectionCriteria, string directoryInArchive, string extractDirectory);
    public void ExtractSelectedEntries(string selectionCriteria, string directoryPathInArchive, string extractDirectory, ExtractExistingFileAction extractExistingFile);
    public sealed virtual IEnumerator`1<ZipEntry> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [DispIdAttribute("-4")]
public IEnumerator GetNewEnum();
}
internal class Ionic.Zip.ZipInputStream : Stream {
    [CompilerGeneratedAttribute]
private int <CodecBufferSize>k__BackingField;
    private Stream _inputStream;
    private Encoding _provisionalAlternateEncoding;
    private ZipEntry _currentEntry;
    private bool _firstEntry;
    private bool _needSetup;
    private ZipContainer _container;
    private CrcCalculatorStream _crcStream;
    private long _LeftToRead;
    internal string _Password;
    private long _endOfEntry;
    private string _name;
    private bool _leaveUnderlyingStreamOpen;
    private bool _closed;
    private bool _findRequired;
    private bool _exceptionPending;
    public Encoding ProvisionalAlternateEncoding { get; public set; }
    public int CodecBufferSize { get; public set; }
    unknown string Password {public set; }
    internal Stream ReadStream { get; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public ZipInputStream(Stream stream);
    public ZipInputStream(string fileName);
    public ZipInputStream(Stream stream, bool leaveOpen);
    private void _Init(Stream stream, bool leaveOpen, string name);
    public virtual string ToString();
    public Encoding get_ProvisionalAlternateEncoding();
    public void set_ProvisionalAlternateEncoding(Encoding value);
    [CompilerGeneratedAttribute]
public int get_CodecBufferSize();
    [CompilerGeneratedAttribute]
public void set_CodecBufferSize(int value);
    public void set_Password(string value);
    private void SetupStream();
    internal Stream get_ReadStream();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public ZipEntry GetNextEntry();
    protected virtual void Dispose(bool disposing);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Flush();
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
}
internal enum Ionic.Zip.ZipOption : Enum {
    public int value__;
    public static ZipOption Default;
    public static ZipOption Never;
    public static ZipOption AsNecessary;
    public static ZipOption Always;
}
internal static class Ionic.Zip.ZipOutput : object {
    public static bool WriteCentralDirectoryStructure(Stream s, ICollection`1<ZipEntry> entries, UInt32 numSegments, Zip64Option zip64, string comment, ZipContainer container);
    private static Encoding GetEncoding(ZipContainer container, string t);
    private static Byte[] GenCentralDirectoryFooter(long StartOfCentralDirectory, long EndOfCentralDirectory, Zip64Option zip64, int entryCount, string comment, ZipContainer container);
    private static Byte[] GenZip64EndOfCentralDirectory(long StartOfCentralDirectory, long EndOfCentralDirectory, int entryCount, UInt32 numSegments);
    private static int CountEntries(ICollection`1<ZipEntry> _entries);
}
internal class Ionic.Zip.ZipOutputStream : Stream {
    [CompilerGeneratedAttribute]
private int <CodecBufferSize>k__BackingField;
    [CompilerGeneratedAttribute]
private CompressionStrategy <Strategy>k__BackingField;
    [CompilerGeneratedAttribute]
private CompressionLevel <CompressionLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private CompressionMethod <CompressionMethod>k__BackingField;
    private EncryptionAlgorithm _encryption;
    private ZipEntryTimestamp _timestamp;
    internal string _password;
    private string _comment;
    private Stream _outputStream;
    private ZipEntry _currentEntry;
    internal Zip64Option _zip64;
    private Dictionary`2<string, ZipEntry> _entriesWritten;
    private int _entryCount;
    private ZipOption _alternateEncodingUsage;
    private Encoding _alternateEncoding;
    private bool _leaveUnderlyingStreamOpen;
    private bool _disposed;
    private bool _exceptionPending;
    private bool _anyEntriesUsedZip64;
    private bool _directoryNeededZip64;
    private CountingStream _outputCounter;
    private Stream _encryptor;
    private Stream _deflater;
    private CrcCalculatorStream _entryOutputStream;
    private bool _needToWriteEntryHeader;
    private string _name;
    private bool _DontIgnoreCase;
    internal ParallelDeflateOutputStream ParallelDeflater;
    private long _ParallelDeflateThreshold;
    private int _maxBufferPairs;
    unknown string Password {public set; }
    public EncryptionAlgorithm Encryption { get; public set; }
    public int CodecBufferSize { get; public set; }
    public CompressionStrategy Strategy { get; public set; }
    public ZipEntryTimestamp Timestamp { get; public set; }
    public CompressionLevel CompressionLevel { get; public set; }
    public CompressionMethod CompressionMethod { get; public set; }
    public string Comment { get; public set; }
    public Zip64Option EnableZip64 { get; public set; }
    public bool OutputUsedZip64 { get; }
    public bool IgnoreCase { get; public set; }
    [ObsoleteAttribute("Beginning with v1.9.1.6 of DotNetZip, this property is obsolete. It will be removed in a future version of the library. Use AlternateEncoding and AlternateEncodingUsage instead.")]
public bool UseUnicodeAsNecessary { get; public set; }
    [ObsoleteAttribute("use AlternateEncoding and AlternateEncodingUsage instead.")]
public Encoding ProvisionalAlternateEncoding { get; public set; }
    public Encoding AlternateEncoding { get; public set; }
    public ZipOption AlternateEncodingUsage { get; public set; }
    public static Encoding DefaultEncoding { get; }
    public long ParallelDeflateThreshold { get; public set; }
    public int ParallelDeflateMaxBufferPairs { get; public set; }
    internal Stream OutputStream { get; }
    internal string Name { get; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public ZipOutputStream(Stream stream);
    public ZipOutputStream(string fileName);
    public ZipOutputStream(Stream stream, bool leaveOpen);
    private void _Init(Stream stream, bool leaveOpen, string name);
    public virtual string ToString();
    public void set_Password(string value);
    public EncryptionAlgorithm get_Encryption();
    public void set_Encryption(EncryptionAlgorithm value);
    [CompilerGeneratedAttribute]
public int get_CodecBufferSize();
    [CompilerGeneratedAttribute]
public void set_CodecBufferSize(int value);
    [CompilerGeneratedAttribute]
public CompressionStrategy get_Strategy();
    [CompilerGeneratedAttribute]
public void set_Strategy(CompressionStrategy value);
    public ZipEntryTimestamp get_Timestamp();
    public void set_Timestamp(ZipEntryTimestamp value);
    [CompilerGeneratedAttribute]
public CompressionLevel get_CompressionLevel();
    [CompilerGeneratedAttribute]
public void set_CompressionLevel(CompressionLevel value);
    [CompilerGeneratedAttribute]
public CompressionMethod get_CompressionMethod();
    [CompilerGeneratedAttribute]
public void set_CompressionMethod(CompressionMethod value);
    public string get_Comment();
    public void set_Comment(string value);
    public Zip64Option get_EnableZip64();
    public void set_EnableZip64(Zip64Option value);
    public bool get_OutputUsedZip64();
    public bool get_IgnoreCase();
    public void set_IgnoreCase(bool value);
    public bool get_UseUnicodeAsNecessary();
    public void set_UseUnicodeAsNecessary(bool value);
    public Encoding get_ProvisionalAlternateEncoding();
    public void set_ProvisionalAlternateEncoding(Encoding value);
    public Encoding get_AlternateEncoding();
    public void set_AlternateEncoding(Encoding value);
    public ZipOption get_AlternateEncodingUsage();
    public void set_AlternateEncodingUsage(ZipOption value);
    public static Encoding get_DefaultEncoding();
    public void set_ParallelDeflateThreshold(long value);
    public long get_ParallelDeflateThreshold();
    public int get_ParallelDeflateMaxBufferPairs();
    public void set_ParallelDeflateMaxBufferPairs(int value);
    private void InsureUniqueEntry(ZipEntry ze1);
    internal Stream get_OutputStream();
    internal string get_Name();
    public bool ContainsEntry(string name);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public ZipEntry PutNextEntry(string entryName);
    private void _InitiateCurrentEntry(bool finishing);
    private void _FinishCurrentEntry();
    protected virtual void Dispose(bool disposing);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Flush();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
}
internal class Ionic.Zip.ZipProgressEventArgs : EventArgs {
    private int _entriesTotal;
    private bool _cancel;
    private ZipEntry _latestEntry;
    private ZipProgressEventType _flavor;
    private string _archiveName;
    private long _bytesTransferred;
    private long _totalBytesToTransfer;
    public int EntriesTotal { get; public set; }
    public ZipEntry CurrentEntry { get; public set; }
    public bool Cancel { get; public set; }
    public ZipProgressEventType EventType { get; public set; }
    public string ArchiveName { get; public set; }
    public long BytesTransferred { get; public set; }
    public long TotalBytesToTransfer { get; public set; }
    internal ZipProgressEventArgs(string archiveName, ZipProgressEventType flavor);
    public int get_EntriesTotal();
    public void set_EntriesTotal(int value);
    public ZipEntry get_CurrentEntry();
    public void set_CurrentEntry(ZipEntry value);
    public bool get_Cancel();
    public void set_Cancel(bool value);
    public ZipProgressEventType get_EventType();
    public void set_EventType(ZipProgressEventType value);
    public string get_ArchiveName();
    public void set_ArchiveName(string value);
    public long get_BytesTransferred();
    public void set_BytesTransferred(long value);
    public long get_TotalBytesToTransfer();
    public void set_TotalBytesToTransfer(long value);
}
internal enum Ionic.Zip.ZipProgressEventType : Enum {
    public int value__;
    public static ZipProgressEventType Adding_Started;
    public static ZipProgressEventType Adding_AfterAddEntry;
    public static ZipProgressEventType Adding_Completed;
    public static ZipProgressEventType Reading_Started;
    public static ZipProgressEventType Reading_BeforeReadEntry;
    public static ZipProgressEventType Reading_AfterReadEntry;
    public static ZipProgressEventType Reading_Completed;
    public static ZipProgressEventType Reading_ArchiveBytesRead;
    public static ZipProgressEventType Saving_Started;
    public static ZipProgressEventType Saving_BeforeWriteEntry;
    public static ZipProgressEventType Saving_AfterWriteEntry;
    public static ZipProgressEventType Saving_Completed;
    public static ZipProgressEventType Saving_AfterSaveTempArchive;
    public static ZipProgressEventType Saving_BeforeRenameTempArchive;
    public static ZipProgressEventType Saving_AfterRenameTempArchive;
    public static ZipProgressEventType Saving_AfterCompileSelfExtractor;
    public static ZipProgressEventType Saving_EntryBytesRead;
    public static ZipProgressEventType Extracting_BeforeExtractEntry;
    public static ZipProgressEventType Extracting_AfterExtractEntry;
    public static ZipProgressEventType Extracting_ExtractEntryWouldOverwrite;
    public static ZipProgressEventType Extracting_EntryBytesWritten;
    public static ZipProgressEventType Extracting_BeforeExtractAll;
    public static ZipProgressEventType Extracting_AfterExtractAll;
    public static ZipProgressEventType Error_Saving;
}
internal class Ionic.Zip.ZipSegmentedStream : Stream {
    private RwMode rwMode;
    private bool _exceptionPending;
    private string _baseName;
    private string _baseDir;
    private string _currentName;
    private string _currentTempName;
    private UInt32 _currentDiskNumber;
    private UInt32 _maxDiskNumber;
    private int _maxSegmentSize;
    private Stream _innerStream;
    [CompilerGeneratedAttribute]
private bool <ContiguousWrite>k__BackingField;
    public bool ContiguousWrite { get; public set; }
    public UInt32 CurrentSegment { get; private set; }
    public string CurrentName { get; }
    public string CurrentTempName { get; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public static ZipSegmentedStream ForReading(string name, UInt32 initialDiskNumber, UInt32 maxDiskNumber);
    public static ZipSegmentedStream ForWriting(string name, int maxSegmentSize);
    public static Stream ForUpdate(string name, UInt32 diskNumber);
    [CompilerGeneratedAttribute]
public bool get_ContiguousWrite();
    [CompilerGeneratedAttribute]
public void set_ContiguousWrite(bool value);
    public UInt32 get_CurrentSegment();
    private void set_CurrentSegment(UInt32 value);
    public string get_CurrentName();
    public string get_CurrentTempName();
    private string _NameForSegment(UInt32 diskNumber);
    public UInt32 ComputeSegment(int length);
    public virtual string ToString();
    private void _SetReadStream();
    public virtual int Read(Byte[] buffer, int offset, int count);
    private void _SetWriteStream(UInt32 increment);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public long TruncateBackward(UInt32 diskNumber, long offset);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual void Flush();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    protected virtual void Dispose(bool disposing);
}
internal class Ionic.Zlib.Adler : object {
    private static UInt32 BASE;
    private static int NMAX;
    private static Adler();
    public static UInt32 Adler32(UInt32 adler, Byte[] buf, int index, int len);
}
internal enum Ionic.Zlib.BlockState : Enum {
    public int value__;
    public static BlockState NeedMore;
    public static BlockState BlockDone;
    public static BlockState FinishStarted;
    public static BlockState FinishDone;
}
internal enum Ionic.Zlib.CompressionLevel : Enum {
    public int value__;
    public static CompressionLevel None;
    public static CompressionLevel Level0;
    public static CompressionLevel BestSpeed;
    public static CompressionLevel Level1;
    public static CompressionLevel Level2;
    public static CompressionLevel Level3;
    public static CompressionLevel Level4;
    public static CompressionLevel Level5;
    public static CompressionLevel Default;
    public static CompressionLevel Level6;
    public static CompressionLevel Level7;
    public static CompressionLevel Level8;
    public static CompressionLevel BestCompression;
    public static CompressionLevel Level9;
}
internal enum Ionic.Zlib.CompressionMode : Enum {
    public int value__;
    public static CompressionMode Compress;
    public static CompressionMode Decompress;
}
internal enum Ionic.Zlib.CompressionStrategy : Enum {
    public int value__;
    public static CompressionStrategy Default;
    public static CompressionStrategy Filtered;
    public static CompressionStrategy HuffmanOnly;
}
internal enum Ionic.Zlib.DeflateFlavor : Enum {
    public int value__;
    public static DeflateFlavor Store;
    public static DeflateFlavor Fast;
    public static DeflateFlavor Slow;
}
internal class Ionic.Zlib.DeflateManager : object {
    private static int MEM_LEVEL_MAX;
    private static int MEM_LEVEL_DEFAULT;
    private CompressFunc DeflateFunction;
    private static String[] _ErrorMessage;
    private static int PRESET_DICT;
    private static int INIT_STATE;
    private static int BUSY_STATE;
    private static int FINISH_STATE;
    private static int Z_DEFLATED;
    private static int STORED_BLOCK;
    private static int STATIC_TREES;
    private static int DYN_TREES;
    private static int Z_BINARY;
    private static int Z_ASCII;
    private static int Z_UNKNOWN;
    private static int Buf_size;
    private static int MIN_MATCH;
    private static int MAX_MATCH;
    private static int MIN_LOOKAHEAD;
    private static int HEAP_SIZE;
    private static int END_BLOCK;
    internal ZlibCodec _codec;
    internal int status;
    internal Byte[] pending;
    internal int nextPending;
    internal int pendingCount;
    internal sbyte data_type;
    internal int last_flush;
    internal int w_size;
    internal int w_bits;
    internal int w_mask;
    internal Byte[] window;
    internal int window_size;
    internal Int16[] prev;
    internal Int16[] head;
    internal int ins_h;
    internal int hash_size;
    internal int hash_bits;
    internal int hash_mask;
    internal int hash_shift;
    internal int block_start;
    private Config config;
    internal int match_length;
    internal int prev_match;
    internal int match_available;
    internal int strstart;
    internal int match_start;
    internal int lookahead;
    internal int prev_length;
    internal CompressionLevel compressionLevel;
    internal CompressionStrategy compressionStrategy;
    internal Int16[] dyn_ltree;
    internal Int16[] dyn_dtree;
    internal Int16[] bl_tree;
    internal Tree treeLiterals;
    internal Tree treeDistances;
    internal Tree treeBitLengths;
    internal Int16[] bl_count;
    internal Int32[] heap;
    internal int heap_len;
    internal int heap_max;
    internal SByte[] depth;
    internal int _lengthOffset;
    internal int lit_bufsize;
    internal int last_lit;
    internal int _distanceOffset;
    internal int opt_len;
    internal int static_len;
    internal int matches;
    internal int last_eob_len;
    internal short bi_buf;
    internal int bi_valid;
    private bool Rfc1950BytesEmitted;
    private bool _WantRfc1950HeaderBytes;
    internal bool WantRfc1950HeaderBytes { get; internal set; }
    private static DeflateManager();
    private void _InitializeLazyMatch();
    private void _InitializeTreeData();
    internal void _InitializeBlocks();
    internal void pqdownheap(Int16[] tree, int k);
    internal static bool _IsSmaller(Int16[] tree, int n, int m, SByte[] depth);
    internal void scan_tree(Int16[] tree, int max_code);
    internal int build_bl_tree();
    internal void send_all_trees(int lcodes, int dcodes, int blcodes);
    internal void send_tree(Int16[] tree, int max_code);
    private void put_bytes(Byte[] p, int start, int len);
    internal void send_code(int c, Int16[] tree);
    internal void send_bits(int value, int length);
    internal void _tr_align();
    internal bool _tr_tally(int dist, int lc);
    internal void send_compressed_block(Int16[] ltree, Int16[] dtree);
    internal void set_data_type();
    internal void bi_flush();
    internal void bi_windup();
    internal void copy_block(int buf, int len, bool header);
    internal void flush_block_only(bool eof);
    internal BlockState DeflateNone(FlushType flush);
    internal void _tr_stored_block(int buf, int stored_len, bool eof);
    internal void _tr_flush_block(int buf, int stored_len, bool eof);
    private void _fillWindow();
    internal BlockState DeflateFast(FlushType flush);
    internal BlockState DeflateSlow(FlushType flush);
    internal int longest_match(int cur_match);
    internal bool get_WantRfc1950HeaderBytes();
    internal void set_WantRfc1950HeaderBytes(bool value);
    internal int Initialize(ZlibCodec codec, CompressionLevel level);
    internal int Initialize(ZlibCodec codec, CompressionLevel level, int bits);
    internal int Initialize(ZlibCodec codec, CompressionLevel level, int bits, CompressionStrategy compressionStrategy);
    internal int Initialize(ZlibCodec codec, CompressionLevel level, int windowBits, int memLevel, CompressionStrategy strategy);
    internal void Reset();
    internal int End();
    private void SetDeflater();
    internal int SetParams(CompressionLevel level, CompressionStrategy strategy);
    internal int SetDictionary(Byte[] dictionary);
    internal int Deflate(FlushType flush);
}
internal class Ionic.Zlib.DeflateStream : Stream {
    internal ZlibBaseStream _baseStream;
    internal Stream _innerStream;
    private bool _disposed;
    public FlushType FlushMode { get; public set; }
    public int BufferSize { get; public set; }
    public CompressionStrategy Strategy { get; public set; }
    public long TotalIn { get; }
    public long TotalOut { get; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public DeflateStream(Stream stream, CompressionMode mode);
    public DeflateStream(Stream stream, CompressionMode mode, CompressionLevel level);
    public DeflateStream(Stream stream, CompressionMode mode, bool leaveOpen);
    public DeflateStream(Stream stream, CompressionMode mode, CompressionLevel level, bool leaveOpen);
    public virtual FlushType get_FlushMode();
    public virtual void set_FlushMode(FlushType value);
    public int get_BufferSize();
    public void set_BufferSize(int value);
    public CompressionStrategy get_Strategy();
    public void set_Strategy(CompressionStrategy value);
    public virtual long get_TotalIn();
    public virtual long get_TotalOut();
    protected virtual void Dispose(bool disposing);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual void Flush();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public static Byte[] CompressString(string s);
    public static Byte[] CompressBuffer(Byte[] b);
    public static string UncompressString(Byte[] compressed);
    public static Byte[] UncompressBuffer(Byte[] compressed);
}
internal enum Ionic.Zlib.FlushType : Enum {
    public int value__;
    public static FlushType None;
    public static FlushType Partial;
    public static FlushType Sync;
    public static FlushType Full;
    public static FlushType Finish;
}
internal class Ionic.Zlib.GZipStream : Stream {
    public Nullable`1<DateTime> LastModified;
    private int _headerByteCount;
    internal ZlibBaseStream _baseStream;
    private bool _disposed;
    private bool _firstReadDone;
    private string _FileName;
    private string _Comment;
    private int _Crc32;
    internal static DateTime _unixEpoch;
    internal static Encoding iso8859dash1;
    public string Comment { get; public set; }
    public string FileName { get; public set; }
    public int Crc32 { get; }
    public FlushType FlushMode { get; public set; }
    public int BufferSize { get; public set; }
    public long TotalIn { get; }
    public long TotalOut { get; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public GZipStream(Stream stream, CompressionMode mode);
    public GZipStream(Stream stream, CompressionMode mode, CompressionLevel level);
    public GZipStream(Stream stream, CompressionMode mode, bool leaveOpen);
    public GZipStream(Stream stream, CompressionMode mode, CompressionLevel level, bool leaveOpen);
    private static GZipStream();
    public string get_Comment();
    public void set_Comment(string value);
    public string get_FileName();
    public void set_FileName(string value);
    public int get_Crc32();
    public virtual FlushType get_FlushMode();
    public virtual void set_FlushMode(FlushType value);
    public int get_BufferSize();
    public void set_BufferSize(int value);
    public virtual long get_TotalIn();
    public virtual long get_TotalOut();
    protected virtual void Dispose(bool disposing);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual void Flush();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    private int EmitHeader();
    public static Byte[] CompressString(string s);
    public static Byte[] CompressBuffer(Byte[] b);
    public static string UncompressString(Byte[] compressed);
    public static Byte[] UncompressBuffer(Byte[] compressed);
}
internal class Ionic.Zlib.InflateBlocks : object {
    private static int MANY;
    internal static Int32[] border;
    private InflateBlockMode mode;
    internal int left;
    internal int table;
    internal int index;
    internal Int32[] blens;
    internal Int32[] bb;
    internal Int32[] tb;
    internal InflateCodes codes;
    internal int last;
    internal ZlibCodec _codec;
    internal int bitk;
    internal int bitb;
    internal Int32[] hufts;
    internal Byte[] window;
    internal int end;
    internal int readAt;
    internal int writeAt;
    internal object checkfn;
    internal UInt32 check;
    internal InfTree inftree;
    internal InflateBlocks(ZlibCodec codec, object checkfn, int w);
    private static InflateBlocks();
    internal UInt32 Reset();
    internal int Process(int r);
    internal void Free();
    internal void SetDictionary(Byte[] d, int start, int n);
    internal int SyncPoint();
    internal int Flush(int r);
}
internal class Ionic.Zlib.InflateCodes : object {
    private static int START;
    private static int LEN;
    private static int LENEXT;
    private static int DIST;
    private static int DISTEXT;
    private static int COPY;
    private static int LIT;
    private static int WASH;
    private static int END;
    private static int BADCODE;
    internal int mode;
    internal int len;
    internal Int32[] tree;
    internal int tree_index;
    internal int need;
    internal int lit;
    internal int bitsToGet;
    internal int dist;
    internal byte lbits;
    internal byte dbits;
    internal Int32[] ltree;
    internal int ltree_index;
    internal Int32[] dtree;
    internal int dtree_index;
    internal void Init(int bl, int bd, Int32[] tl, int tl_index, Int32[] td, int td_index);
    internal int Process(InflateBlocks blocks, int r);
    internal int InflateFast(int bl, int bd, Int32[] tl, int tl_index, Int32[] td, int td_index, InflateBlocks s, ZlibCodec z);
}
internal class Ionic.Zlib.InflateManager : object {
    private static int PRESET_DICT;
    private static int Z_DEFLATED;
    private InflateManagerMode mode;
    internal ZlibCodec _codec;
    internal int method;
    internal UInt32 computedCheck;
    internal UInt32 expectedCheck;
    internal int marker;
    private bool _handleRfc1950HeaderBytes;
    internal int wbits;
    internal InflateBlocks blocks;
    private static Byte[] mark;
    internal bool HandleRfc1950HeaderBytes { get; internal set; }
    public InflateManager(bool expectRfc1950HeaderBytes);
    private static InflateManager();
    internal bool get_HandleRfc1950HeaderBytes();
    internal void set_HandleRfc1950HeaderBytes(bool value);
    internal int Reset();
    internal int End();
    internal int Initialize(ZlibCodec codec, int w);
    internal int Inflate(FlushType flush);
    internal int SetDictionary(Byte[] dictionary);
    internal int Sync();
    internal int SyncPoint(ZlibCodec z);
}
internal class Ionic.Zlib.InfTree : object {
    private static int MANY;
    private static int Z_OK;
    private static int Z_STREAM_END;
    private static int Z_NEED_DICT;
    private static int Z_ERRNO;
    private static int Z_STREAM_ERROR;
    private static int Z_DATA_ERROR;
    private static int Z_MEM_ERROR;
    private static int Z_BUF_ERROR;
    private static int Z_VERSION_ERROR;
    internal static int fixed_bl;
    internal static int fixed_bd;
    internal static Int32[] fixed_tl;
    internal static Int32[] fixed_td;
    internal static Int32[] cplens;
    internal static Int32[] cplext;
    internal static Int32[] cpdist;
    internal static Int32[] cpdext;
    internal static int BMAX;
    internal Int32[] hn;
    internal Int32[] v;
    internal Int32[] c;
    internal Int32[] r;
    internal Int32[] u;
    internal Int32[] x;
    private static InfTree();
    private int huft_build(Int32[] b, int bindex, int n, int s, Int32[] d, Int32[] e, Int32[] t, Int32[] m, Int32[] hp, Int32[] hn, Int32[] v);
    internal int inflate_trees_bits(Int32[] c, Int32[] bb, Int32[] tb, Int32[] hp, ZlibCodec z);
    internal int inflate_trees_dynamic(int nl, int nd, Int32[] c, Int32[] bl, Int32[] bd, Int32[] tl, Int32[] td, Int32[] hp, ZlibCodec z);
    internal static int inflate_trees_fixed(Int32[] bl, Int32[] bd, Int32[][] tl, Int32[][] td, ZlibCodec z);
    private void initWorkArea(int vsize);
}
internal static class Ionic.Zlib.InternalConstants : object {
    internal static int MAX_BITS;
    internal static int BL_CODES;
    internal static int D_CODES;
    internal static int LITERALS;
    internal static int LENGTH_CODES;
    internal static int L_CODES;
    internal static int MAX_BL_BITS;
    internal static int REP_3_6;
    internal static int REPZ_3_10;
    internal static int REPZ_11_138;
    private static InternalConstants();
}
internal static class Ionic.Zlib.InternalInflateConstants : object {
    internal static Int32[] InflateMask;
    private static InternalInflateConstants();
}
internal class Ionic.Zlib.ParallelDeflateOutputStream : Stream {
    private static int IO_BUFFER_SIZE_DEFAULT;
    private static int BufferPairsPerCore;
    private List`1<WorkItem> _pool;
    private bool _leaveOpen;
    private bool emitting;
    private Stream _outStream;
    private int _maxBufferPairs;
    private int _bufferSize;
    private AutoResetEvent _newlyCompressedBlob;
    private object _outputLock;
    private bool _isClosed;
    private bool _firstWriteDone;
    private int _currentlyFilling;
    private int _lastFilled;
    private int _lastWritten;
    private int _latestCompressed;
    private int _Crc32;
    private CRC32 _runningCrc;
    private object _latestLock;
    private Queue`1<int> _toWrite;
    private Queue`1<int> _toFill;
    private long _totalBytesProcessed;
    private CompressionLevel _compressLevel;
    private Exception modreq(System.Runtime.CompilerServices.IsVolatile) _pendingException;
    private bool _handlingException;
    private object _eLock;
    private TraceBits _DesiredTrace;
    [CompilerGeneratedAttribute]
private CompressionStrategy <Strategy>k__BackingField;
    public CompressionStrategy Strategy { get; private set; }
    public int MaxBufferPairs { get; public set; }
    public int BufferSize { get; public set; }
    public int Crc32 { get; }
    public long BytesProcessed { get; }
    public bool CanSeek { get; }
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public ParallelDeflateOutputStream(Stream stream);
    public ParallelDeflateOutputStream(Stream stream, CompressionLevel level);
    public ParallelDeflateOutputStream(Stream stream, bool leaveOpen);
    public ParallelDeflateOutputStream(Stream stream, CompressionLevel level, bool leaveOpen);
    public ParallelDeflateOutputStream(Stream stream, CompressionLevel level, CompressionStrategy strategy, bool leaveOpen);
    private static ParallelDeflateOutputStream();
    [CompilerGeneratedAttribute]
public CompressionStrategy get_Strategy();
    [CompilerGeneratedAttribute]
private void set_Strategy(CompressionStrategy value);
    public int get_MaxBufferPairs();
    public void set_MaxBufferPairs(int value);
    public int get_BufferSize();
    public void set_BufferSize(int value);
    public int get_Crc32();
    public long get_BytesProcessed();
    private void _InitializePoolOfWorkItems();
    public virtual void Write(Byte[] buffer, int offset, int count);
    private void _FlushFinish();
    private void _Flush(bool lastInput);
    public virtual void Flush();
    public virtual void Close();
    private void InnerClose();
    public void Dispose();
    protected virtual void Dispose(bool disposing);
    public void Reset(Stream stream);
    private void EmitPendingBuffers(bool doAll, bool mustWait);
    private void _DeflateOne(object wi);
    private bool DeflateOneSegment(WorkItem workitem);
    [ConditionalAttribute("Trace")]
private void TraceOutput(TraceBits bits, string format, Object[] varParams);
    public virtual bool get_CanSeek();
    public virtual bool get_CanRead();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
}
internal class Ionic.Zlib.SharedUtils : object {
    public static int URShift(int number, int bits);
    public static int ReadInput(TextReader sourceTextReader, Byte[] target, int start, int count);
    internal static Byte[] ToByteArray(string sourceString);
    internal static Char[] ToCharArray(Byte[] byteArray);
}
internal class Ionic.Zlib.StaticTree : object {
    internal static Int16[] lengthAndLiteralsTreeCodes;
    internal static Int16[] distTreeCodes;
    internal static StaticTree Literals;
    internal static StaticTree Distances;
    internal static StaticTree BitLengths;
    internal Int16[] treeCodes;
    internal Int32[] extraBits;
    internal int extraBase;
    internal int elems;
    internal int maxLength;
    private StaticTree(Int16[] treeCodes, Int32[] extraBits, int extraBase, int elems, int maxLength);
    private static StaticTree();
}
internal class Ionic.Zlib.Tree : object {
    private static int HEAP_SIZE;
    internal static Int32[] ExtraLengthBits;
    internal static Int32[] ExtraDistanceBits;
    internal static Int32[] extra_blbits;
    internal static SByte[] bl_order;
    internal static int Buf_size;
    private static SByte[] _dist_code;
    internal static SByte[] LengthCode;
    internal static Int32[] LengthBase;
    internal static Int32[] DistanceBase;
    internal Int16[] dyn_tree;
    internal int max_code;
    internal StaticTree staticTree;
    private static Tree();
    internal static int DistanceCode(int dist);
    internal void gen_bitlen(DeflateManager s);
    internal void build_tree(DeflateManager s);
    internal static void gen_codes(Int16[] tree, int max_code, Int16[] bl_count);
    internal static int bi_reverse(int code, int len);
}
internal class Ionic.Zlib.WorkItem : object {
    public Byte[] buffer;
    public Byte[] compressed;
    public int crc;
    public int index;
    public int ordinal;
    public int inputBytesAvailable;
    public int compressedBytesAvailable;
    public ZlibCodec compressor;
    public WorkItem(int size, CompressionLevel compressLevel, CompressionStrategy strategy, int ix);
}
internal class Ionic.Zlib.ZlibBaseStream : Stream {
    protected internal ZlibCodec _z;
    protected internal StreamMode _streamMode;
    protected internal FlushType _flushMode;
    protected internal ZlibStreamFlavor _flavor;
    protected internal CompressionMode _compressionMode;
    protected internal CompressionLevel _level;
    protected internal bool _leaveOpen;
    protected internal Byte[] _workingBuffer;
    protected internal int _bufferSize;
    protected internal Byte[] _buf1;
    protected internal Stream _stream;
    protected internal CompressionStrategy Strategy;
    private CRC32 crc;
    protected internal string _GzipFileName;
    protected internal string _GzipComment;
    protected internal DateTime _GzipMtime;
    protected internal int _gzipHeaderByteCount;
    private bool nomoreinput;
    internal int Crc32 { get; }
    protected internal bool _wantCompress { get; }
    private ZlibCodec z { get; }
    private Byte[] workingBuffer { get; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public ZlibBaseStream(Stream stream, CompressionMode compressionMode, CompressionLevel level, ZlibStreamFlavor flavor, bool leaveOpen);
    internal int get_Crc32();
    protected internal bool get__wantCompress();
    private ZlibCodec get_z();
    private Byte[] get_workingBuffer();
    public virtual void Write(Byte[] buffer, int offset, int count);
    private void finish();
    private void end();
    protected virtual void Dispose(bool disposing);
    public virtual void Flush();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    private string ReadZeroTerminatedString();
    private int _ReadAndValidateGzipHeader();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public static void CompressString(string s, Stream compressor);
    public static void CompressBuffer(Byte[] b, Stream compressor);
    public static string UncompressString(Byte[] compressed, Stream decompressor);
    public static Byte[] UncompressBuffer(Byte[] compressed, Stream decompressor);
}
[GuidAttribute("ebc25cf6-9120-4283-b972-0e5520d0000D")]
[ClassInterfaceAttribute("1")]
[ComVisibleAttribute("True")]
internal class Ionic.Zlib.ZlibCodec : object {
    public Byte[] InputBuffer;
    public int NextIn;
    public int AvailableBytesIn;
    public long TotalBytesIn;
    public Byte[] OutputBuffer;
    public int NextOut;
    public int AvailableBytesOut;
    public long TotalBytesOut;
    public string Message;
    internal DeflateManager dstate;
    internal InflateManager istate;
    internal UInt32 _Adler32;
    public CompressionLevel CompressLevel;
    public int WindowBits;
    public CompressionStrategy Strategy;
    public int Adler32 { get; }
    public ZlibCodec(CompressionMode mode);
    public int get_Adler32();
    public int InitializeInflate();
    public int InitializeInflate(bool expectRfc1950Header);
    public int InitializeInflate(int windowBits);
    public int InitializeInflate(int windowBits, bool expectRfc1950Header);
    public int Inflate(FlushType flush);
    public int EndInflate();
    public int SyncInflate();
    public int InitializeDeflate();
    public int InitializeDeflate(CompressionLevel level);
    public int InitializeDeflate(CompressionLevel level, bool wantRfc1950Header);
    public int InitializeDeflate(CompressionLevel level, int bits);
    public int InitializeDeflate(CompressionLevel level, int bits, bool wantRfc1950Header);
    private int _InternalInitializeDeflate(bool wantRfc1950Header);
    public int Deflate(FlushType flush);
    public int EndDeflate();
    public void ResetDeflate();
    public int SetDeflateParams(CompressionLevel level, CompressionStrategy strategy);
    public int SetDictionary(Byte[] dictionary);
    internal void flush_pending();
    internal int read_buf(Byte[] buf, int start, int size);
}
internal static class Ionic.Zlib.ZlibConstants : object {
    public static int WindowBitsMax;
    public static int WindowBitsDefault;
    public static int Z_OK;
    public static int Z_STREAM_END;
    public static int Z_NEED_DICT;
    public static int Z_STREAM_ERROR;
    public static int Z_DATA_ERROR;
    public static int Z_BUF_ERROR;
    public static int WorkingBufferSizeDefault;
    public static int WorkingBufferSizeMin;
}
[GuidAttribute("ebc25cf6-9120-4283-b972-0e5520d0000E")]
internal class Ionic.Zlib.ZlibException : Exception {
    public ZlibException(string s);
}
internal class Ionic.Zlib.ZlibStream : Stream {
    internal ZlibBaseStream _baseStream;
    private bool _disposed;
    public FlushType FlushMode { get; public set; }
    public int BufferSize { get; public set; }
    public long TotalIn { get; }
    public long TotalOut { get; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public ZlibStream(Stream stream, CompressionMode mode);
    public ZlibStream(Stream stream, CompressionMode mode, CompressionLevel level);
    public ZlibStream(Stream stream, CompressionMode mode, bool leaveOpen);
    public ZlibStream(Stream stream, CompressionMode mode, CompressionLevel level, bool leaveOpen);
    public virtual FlushType get_FlushMode();
    public virtual void set_FlushMode(FlushType value);
    public int get_BufferSize();
    public void set_BufferSize(int value);
    public virtual long get_TotalIn();
    public virtual long get_TotalOut();
    protected virtual void Dispose(bool disposing);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual void Flush();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public static Byte[] CompressString(string s);
    public static Byte[] CompressBuffer(Byte[] b);
    public static string UncompressString(Byte[] compressed);
    public static Byte[] UncompressBuffer(Byte[] compressed);
}
internal enum Ionic.Zlib.ZlibStreamFlavor : Enum {
    public int value__;
    public static ZlibStreamFlavor ZLIB;
    public static ZlibStreamFlavor DEFLATE;
    public static ZlibStreamFlavor GZIP;
}
public class MSBuild.Community.Tasks.AspNet.InstallAspNet : ToolTask {
    private bool validArguments;
    private TargetDotNetFrameworkVersion version;
    private ScriptMapScenarios applyScriptMaps;
    private bool clientScriptsOnly;
    private string path;
    private bool recursive;
    public string Version { get; public set; }
    public string ApplyScriptMaps { get; public set; }
    public bool ClientScriptsOnly { get; public set; }
    public string Path { get; public set; }
    public bool Recursive { get; public set; }
    protected string ToolName { get; }
    public string get_Version();
    public void set_Version(string value);
    public string get_ApplyScriptMaps();
    public void set_ApplyScriptMaps(string value);
    public bool get_ClientScriptsOnly();
    public void set_ClientScriptsOnly(bool value);
    public string get_Path();
    public void set_Path(string value);
    public bool get_Recursive();
    public void set_Recursive(bool value);
    protected virtual string GenerateFullPathToTool();
    protected virtual string get_ToolName();
    protected virtual string GenerateCommandLineCommands();
    public virtual bool Execute();
    public bool IsValidPropertyCombinations();
}
public class MSBuild.Community.Tasks.AssemblyInfo : Task {
    public static string DEFAULT_OUTPUT_FILE;
    private static string CSharp;
    private static string VisualBasic;
    private static string CPP;
    private static string CppCodeProviderAssembly;
    private static string CppCodeProviderType;
    private static string CLSCompliantName;
    private static string ComVisibleName;
    private static string GuidName;
    private static string AssemblyTitleName;
    private static string AssemblyDescriptionName;
    private static string AssemblyConfigurationName;
    private static string AssemblyCompanyName;
    private static string AssemblyProductName;
    private static string AssemblyCopyrightName;
    private static string AssemblyTrademarkName;
    private static string AssemblyCultureName;
    private static string AssemblyVersionName;
    private static string AssemblyFileVersionName;
    private static string AssemblyInformationalVersionName;
    private static string AssemblyKeyFileName;
    private static string AssemblyKeyNameName;
    private static string AssemblyDelaySignName;
    private static string SkipVerificationName;
    private static string UnmanagedCodeName;
    private static string InternalsVisibleToName;
    private static string AllowPartiallyTrustedCallersName;
    private static Dictionary`2<string, string> _codeLangMapping;
    private static Dictionary`2<string, string> _attributeNamespaces;
    private static String[] booleanAttributes;
    private static String[] securityAttributes;
    private static String[] nonGeneratedClassAttributes;
    private static String[] markerAttributes;
    private Dictionary`2<string, string> _attributes;
    private string _outputFile;
    [CompilerGeneratedAttribute]
private string <CodeLanguage>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <GenerateClass>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NeutralResourcesLanguage>k__BackingField;
    [CompilerGeneratedAttribute]
private string <UltimateResourceFallbackLocation>k__BackingField;
    [RequiredAttribute]
public string CodeLanguage { get; public set; }
    public bool ComVisible { get; public set; }
    public bool CLSCompliant { get; public set; }
    public string Guid { get; public set; }
    public string AssemblyTitle { get; public set; }
    public string AssemblyDescription { get; public set; }
    public string AssemblyConfiguration { get; public set; }
    public string AssemblyCompany { get; public set; }
    public string AssemblyProduct { get; public set; }
    public string AssemblyCopyright { get; public set; }
    public string AssemblyTrademark { get; public set; }
    public string AssemblyCulture { get; public set; }
    public string AssemblyVersion { get; public set; }
    public string AssemblyFileVersion { get; public set; }
    public string AssemblyInformationalVersion { get; public set; }
    public string AssemblyKeyFile { get; public set; }
    public string AssemblyKeyName { get; public set; }
    public bool AssemblyDelaySign { get; public set; }
    public bool SkipVerification { get; public set; }
    public bool UnmanagedCode { get; public set; }
    public bool GenerateClass { get; public set; }
    public string NeutralResourcesLanguage { get; public set; }
    public string UltimateResourceFallbackLocation { get; public set; }
    public string InternalsVisibleTo { get; public set; }
    public bool AllowPartiallyTrustedCallers { get; public set; }
    [OutputAttribute]
public string OutputFile { get; public set; }
    private static AssemblyInfo();
    [CompilerGeneratedAttribute]
public string get_CodeLanguage();
    [CompilerGeneratedAttribute]
public void set_CodeLanguage(string value);
    public bool get_ComVisible();
    public void set_ComVisible(bool value);
    public bool get_CLSCompliant();
    public void set_CLSCompliant(bool value);
    public string get_Guid();
    public void set_Guid(string value);
    public string get_AssemblyTitle();
    public void set_AssemblyTitle(string value);
    public string get_AssemblyDescription();
    public void set_AssemblyDescription(string value);
    public string get_AssemblyConfiguration();
    public void set_AssemblyConfiguration(string value);
    public string get_AssemblyCompany();
    public void set_AssemblyCompany(string value);
    public string get_AssemblyProduct();
    public void set_AssemblyProduct(string value);
    public string get_AssemblyCopyright();
    public void set_AssemblyCopyright(string value);
    public string get_AssemblyTrademark();
    public void set_AssemblyTrademark(string value);
    public string get_AssemblyCulture();
    public void set_AssemblyCulture(string value);
    public string get_AssemblyVersion();
    public void set_AssemblyVersion(string value);
    public string get_AssemblyFileVersion();
    public void set_AssemblyFileVersion(string value);
    public string get_AssemblyInformationalVersion();
    public void set_AssemblyInformationalVersion(string value);
    public string get_AssemblyKeyFile();
    public void set_AssemblyKeyFile(string value);
    public string get_AssemblyKeyName();
    public void set_AssemblyKeyName(string value);
    public bool get_AssemblyDelaySign();
    public void set_AssemblyDelaySign(bool value);
    public bool get_SkipVerification();
    public void set_SkipVerification(bool value);
    public bool get_UnmanagedCode();
    public void set_UnmanagedCode(bool value);
    [CompilerGeneratedAttribute]
public bool get_GenerateClass();
    [CompilerGeneratedAttribute]
public void set_GenerateClass(bool value);
    [CompilerGeneratedAttribute]
public string get_NeutralResourcesLanguage();
    [CompilerGeneratedAttribute]
public void set_NeutralResourcesLanguage(string value);
    [CompilerGeneratedAttribute]
public string get_UltimateResourceFallbackLocation();
    [CompilerGeneratedAttribute]
public void set_UltimateResourceFallbackLocation(string value);
    public string get_InternalsVisibleTo();
    public void set_InternalsVisibleTo(string value);
    public bool get_AllowPartiallyTrustedCallers();
    public void set_AllowPartiallyTrustedCallers(bool value);
    public string get_OutputFile();
    public void set_OutputFile(string value);
    public virtual bool Execute();
    private void GenerateFile(TextWriter writer);
    private CodeDomProvider GetProviderAndSetExtension(string codeLanguage, String& outputFile);
    private void SetDefaultsForLanguage(string codeLanguage);
    private static void AddAttributeToCodeDom(CodeCompileUnit codeCompileUnit, string name, object value);
    private static void AddMarkerAttributeToCodeDom(CodeCompileUnit codeCompileUnit, string name);
    private static void AddBooleanAssemblyAttribute(CodeCompileUnit codeCompileUnit, string name, string value);
    private static void AddSecurityPermissionAssemblyAttribute(CodeCompileUnit codeCompileUnit, string name, string value);
    private static void AddMarkerAssemblyAttribute(CodeCompileUnit codeCompileUnit, string name, string value);
    private void AddAssemblyLanguageCodeAttribute(CodeCompileUnit codeCompileUnit);
    private void GenerateThisAssemblyClass(CodeNamespace codeNamespace);
    private string ReadAttribute(string key);
    private bool ReadBooleanAttribute(string key);
}
public class MSBuild.Community.Tasks.Attrib : Task {
    private Dictionary`2<string, bool> attributeBag;
    private ITaskItem[] _files;
    private ITaskItem[] _directories;
    public ITaskItem[] Files { get; public set; }
    public ITaskItem[] Directories { get; public set; }
    public bool Archive { get; public set; }
    public bool Compressed { get; public set; }
    public bool Encrypted { get; public set; }
    public bool Hidden { get; public set; }
    public bool Normal { get; public set; }
    public bool ReadOnly { get; public set; }
    public bool System { get; public set; }
    public ITaskItem[] get_Files();
    public void set_Files(ITaskItem[] value);
    public ITaskItem[] get_Directories();
    public void set_Directories(ITaskItem[] value);
    public bool get_Archive();
    public void set_Archive(bool value);
    public bool get_Compressed();
    public void set_Compressed(bool value);
    public bool get_Encrypted();
    public void set_Encrypted(bool value);
    public bool get_Hidden();
    public void set_Hidden(bool value);
    public bool get_Normal();
    public void set_Normal(bool value);
    public bool get_ReadOnly();
    public void set_ReadOnly(bool value);
    public bool get_System();
    public void set_System(bool value);
    public virtual bool Execute();
    private FileAttributes UpdateAttributes(FileAttributes flags);
}
public class MSBuild.Community.Tasks.Beep : Task {
    private int frequency;
    private int duration;
    public int Frequency { get; public set; }
    public int Duration { get; public set; }
    public int get_Frequency();
    public void set_Frequency(int value);
    public int get_Duration();
    public void set_Duration(int value);
    public virtual bool Execute();
}
internal static class MSBuild.Community.Tasks.ByteDescriptions : object {
    public static string FormatByte(long bytes, int rounding);
    public static string FormatBytesPerSecond(long bytes, double secounds, int rounding);
}
public class MSBuild.Community.Tasks.Checksum : Task {
    private string algorithm;
    [CompilerGeneratedAttribute]
private ITaskItem[] <Files>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Algorithm>k__BackingField;
    [RequiredAttribute]
public ITaskItem[] Files { get; public set; }
    public string Algorithm { get; public set; }
    [CompilerGeneratedAttribute]
public ITaskItem[] get_Files();
    [CompilerGeneratedAttribute]
public void set_Files(ITaskItem[] value);
    [CompilerGeneratedAttribute]
public string get_Algorithm();
    [CompilerGeneratedAttribute]
public void set_Algorithm(string value);
    public virtual bool Execute();
    private string ByteArrayToHexString(Byte[] array);
}
public class MSBuild.Community.Tasks.Computer : Task {
    private string _name;
    private string _ipAddress;
    private string _ipAddressV4;
    private string _osPlatform;
    private string _osVersion;
    [OutputAttribute]
public string Name { get; }
    [OutputAttribute]
public string IPAddress { get; }
    [OutputAttribute]
public string IPAddressV4 { get; }
    [OutputAttribute]
public string OSPlatform { get; }
    [OutputAttribute]
public string OSVersion { get; }
    public string get_Name();
    public string get_IPAddress();
    public string get_IPAddressV4();
    public string get_OSPlatform();
    public string get_OSVersion();
    public virtual bool Execute();
}
public class MSBuild.Community.Tasks.DeleteTree : Task {
    private static string recursiveDirectoryMatch;
    private static Char[] wildcardCharacters;
    private static Char[] directorySeparatorCharacters;
    private static string recursiveRegex;
    private static string anyCharRegex;
    private static string singleCharRegex;
    [CompilerGeneratedAttribute]
private ITaskItem[] <Directories>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Recursive>k__BackingField;
    private List`1<ITaskItem> _deletedDirectories;
    [RequiredAttribute]
public ITaskItem[] Directories { get; public set; }
    public bool Recursive { get; public set; }
    [OutputAttribute]
public ITaskItem[] DeletedDirectories { get; }
    private static DeleteTree();
    [CompilerGeneratedAttribute]
public ITaskItem[] get_Directories();
    [CompilerGeneratedAttribute]
public void set_Directories(ITaskItem[] value);
    [CompilerGeneratedAttribute]
public bool get_Recursive();
    [CompilerGeneratedAttribute]
public void set_Recursive(bool value);
    public ITaskItem[] get_DeletedDirectories();
    public virtual bool Execute();
    internal static IList`1<string> MatchDirectories(string pattern);
    private static string FindRootPath(String[] parts, Int32& pathIndex);
}
public class MSBuild.Community.Tasks.DependencyGraph.AssemblyReference : BaseReference {
    [CompilerGeneratedAttribute]
private string <Include>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HintPath>k__BackingField;
    public string Include { get; private set; }
    public string HintPath { get; private set; }
    public AssemblyReference(string include, string hintPath);
    [CompilerGeneratedAttribute]
public string get_Include();
    [CompilerGeneratedAttribute]
private void set_Include(string value);
    [CompilerGeneratedAttribute]
public string get_HintPath();
    [CompilerGeneratedAttribute]
private void set_HintPath(string value);
    private static string MakeDisplayName(string include);
}
public class MSBuild.Community.Tasks.DependencyGraph.BaseReference : object {
    [CompilerGeneratedAttribute]
private string <DisplayName>k__BackingField;
    public string DisplayName { get; protected set; }
    protected BaseReference(string displayName);
    [CompilerGeneratedAttribute]
public string get_DisplayName();
    [CompilerGeneratedAttribute]
protected void set_DisplayName(string value);
    public virtual string ToString();
}
public class MSBuild.Community.Tasks.DependencyGraph.DependencyGraph : Task {
    private static Regex[] EmptyRegexBuffer;
    private Dictionary`2<string, ProjectReference> _storage;
    private Dictionary`2<ProjectReference, List`1<BaseReference>> _dependencies;
    private Regex[] _excludeRegex;
    private Regex[] _excludeReferencesRegex;
    private Regex[] _excludeProjectReferencesRegex;
    [CompilerGeneratedAttribute]
private ITaskItem[] <InputFiles>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OutputFile>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem[] <Exclude>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem[] <ExcludeReferences>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem[] <ExcludeProjectReferences>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsIncludeProjectDependecies>k__BackingField;
    [RequiredAttribute]
public ITaskItem[] InputFiles { get; public set; }
    public string OutputFile { get; public set; }
    public ITaskItem[] Exclude { get; public set; }
    public ITaskItem[] ExcludeReferences { get; public set; }
    public ITaskItem[] ExcludeProjectReferences { get; public set; }
    public bool IsIncludeProjectDependecies { get; public set; }
    private Regex[] ExcludeRegex { get; }
    private Regex[] ExcludeReferencesRegex { get; }
    private Regex[] ExcludeProjectReferencesRegex { get; }
    private static DependencyGraph();
    [CompilerGeneratedAttribute]
public ITaskItem[] get_InputFiles();
    [CompilerGeneratedAttribute]
public void set_InputFiles(ITaskItem[] value);
    [CompilerGeneratedAttribute]
public string get_OutputFile();
    [CompilerGeneratedAttribute]
public void set_OutputFile(string value);
    [CompilerGeneratedAttribute]
public ITaskItem[] get_Exclude();
    [CompilerGeneratedAttribute]
public void set_Exclude(ITaskItem[] value);
    [CompilerGeneratedAttribute]
public ITaskItem[] get_ExcludeReferences();
    [CompilerGeneratedAttribute]
public void set_ExcludeReferences(ITaskItem[] value);
    [CompilerGeneratedAttribute]
public ITaskItem[] get_ExcludeProjectReferences();
    [CompilerGeneratedAttribute]
public void set_ExcludeProjectReferences(ITaskItem[] value);
    [CompilerGeneratedAttribute]
public bool get_IsIncludeProjectDependecies();
    [CompilerGeneratedAttribute]
public void set_IsIncludeProjectDependecies(bool value);
    private Regex[] get_ExcludeRegex();
    private Regex[] get_ExcludeReferencesRegex();
    private Regex[] get_ExcludeProjectReferencesRegex();
    public virtual bool Execute();
    private void Process(ProjectReference parent, ProjectReference projectReference, Stack`1<ReferenceBundle> processStack);
    private void AddParentDependency(ProjectReference parent, ProjectReference projectReference);
    private void AddDependency(ProjectReference projectReference, BaseReference baseReference);
    private List`1<BaseReference> MakeDependencyList(ProjectReference projectReference);
    private ProjectFileParser CreateParser(string fileName);
    private Stream GenerateGraphVizOutput();
    private void LogToFile(Stream s);
    private void CopyStream(Stream input, Stream output);
    private void LogToConsole(Stream s);
    private static Regex[] MakeFilterRegex(Regex[]& buffer, IEnumerable`1<ITaskItem> items);
    private static bool IsApplicable(Regex[] filters, string name);
    [CompilerGeneratedAttribute]
private bool <Process>b__38_0(AssemblyReference reference);
}
public class MSBuild.Community.Tasks.DependencyGraph.ProjectFileParser : object {
    private XmlDocument _xml;
    private XmlElement DocumentElement { get; }
    public ProjectFileParser(Stream stream);
    private XmlElement get_DocumentElement();
    private void ParseXml(Stream stream);
    public string GetAssemblyName();
    public string GetGuid();
    private string GetProperty(string name);
    public IEnumerable`1<AssemblyReference> GetAssemblyReferences();
    public IEnumerable`1<ProjectReference> GetProjectReferences();
    private IEnumerable`1<T> GetReference(string referenceName, Func`2<XmlNode, T> converter);
    private AssemblyReference NodeToAssemblyReference(XmlNode node);
    private ProjectReference NodeToProjectReference(XmlNode node);
    private string SafeAttributeValue(XmlNode parentNode, string attrName);
    private string SafeNodeValue(XmlNode parentNode, string nodeName);
    public static string GetAssemblyNameFromFullName(string fullAssemblyName);
}
public class MSBuild.Community.Tasks.DependencyGraph.ProjectReference : BaseReference {
    private string _assemblyName;
    [CompilerGeneratedAttribute]
private string <Include>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Project>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProjectGuid>k__BackingField;
    public string Include { get; private set; }
    public string Project { get; private set; }
    public string Name { get; private set; }
    public string ProjectGuid { get; private set; }
    public string AssemblyName { get; private set; }
    public ProjectReference(string include, string project, string name);
    [CompilerGeneratedAttribute]
public string get_Include();
    [CompilerGeneratedAttribute]
private void set_Include(string value);
    [CompilerGeneratedAttribute]
public string get_Project();
    [CompilerGeneratedAttribute]
private void set_Project(string value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_ProjectGuid();
    [CompilerGeneratedAttribute]
private void set_ProjectGuid(string value);
    public string get_AssemblyName();
    private void set_AssemblyName(string value);
    public void UpdateInclude(string baseFolder);
    public void Update(ProjectFileParser parser);
}
public class MSBuild.Community.Tasks.EmbedNativeResource : Task {
    [CompilerGeneratedAttribute]
private string <TargetAssemblyPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ResourcePath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ResourceName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ResourceType>k__BackingField;
    [RequiredAttribute]
public string TargetAssemblyPath { get; public set; }
    [RequiredAttribute]
public string ResourcePath { get; public set; }
    public string ResourceName { get; public set; }
    public string ResourceType { get; public set; }
    [CompilerGeneratedAttribute]
public string get_TargetAssemblyPath();
    [CompilerGeneratedAttribute]
public void set_TargetAssemblyPath(string value);
    [CompilerGeneratedAttribute]
public string get_ResourcePath();
    [CompilerGeneratedAttribute]
public void set_ResourcePath(string value);
    [CompilerGeneratedAttribute]
public string get_ResourceName();
    [CompilerGeneratedAttribute]
public void set_ResourceName(string value);
    [CompilerGeneratedAttribute]
public string get_ResourceType();
    [CompilerGeneratedAttribute]
public void set_ResourceType(string value);
    public virtual bool Execute();
    private static bool UpdateResource(IntPtr hUpdate, string lpType, string lpName, ushort wLanguage, IntPtr lpData, UInt32 cbData);
    private static IntPtr BeginUpdateResource(string pFileName, bool bDeleteExistingResources);
    private static bool EndUpdateResource(IntPtr hUpdate, bool fDiscard);
    private bool ExecuteCore();
    private void SetDefaults();
}
public class MSBuild.Community.Tasks.FileUpdate : Task {
    private ITaskItem[] _files;
    private string _regex;
    private bool _ignoreCase;
    private bool _multiline;
    private bool _singleline;
    private int _replacementCount;
    private bool _replacementTextEmpty;
    private string _replacementText;
    private bool _useDefaultEncoding;
    private Encoding _encoding;
    private bool _warnOnNoUpdate;
    [CompilerGeneratedAttribute]
private ITaskItem[] <ItemsNotUpdated>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllItemsUpdated>k__BackingField;
    public ITaskItem[] Files { get; public set; }
    public string Regex { get; public set; }
    public bool IgnoreCase { get; public set; }
    public bool Multiline { get; public set; }
    public bool Singleline { get; public set; }
    public int ReplacementCount { get; public set; }
    public bool ReplacementTextEmpty { get; public set; }
    public string ReplacementText { get; public set; }
    public string Encoding { get; public set; }
    public bool WarnOnNoUpdate { get; public set; }
    [OutputAttribute]
public ITaskItem[] ItemsNotUpdated { get; public set; }
    [OutputAttribute]
public bool AllItemsUpdated { get; public set; }
    public ITaskItem[] get_Files();
    public void set_Files(ITaskItem[] value);
    public string get_Regex();
    public void set_Regex(string value);
    public bool get_IgnoreCase();
    public void set_IgnoreCase(bool value);
    public bool get_Multiline();
    public void set_Multiline(bool value);
    public bool get_Singleline();
    public void set_Singleline(bool value);
    public int get_ReplacementCount();
    public void set_ReplacementCount(int value);
    public bool get_ReplacementTextEmpty();
    public void set_ReplacementTextEmpty(bool value);
    public string get_ReplacementText();
    public void set_ReplacementText(string value);
    public string get_Encoding();
    public void set_Encoding(string value);
    public bool get_WarnOnNoUpdate();
    public void set_WarnOnNoUpdate(bool value);
    [CompilerGeneratedAttribute]
public ITaskItem[] get_ItemsNotUpdated();
    [CompilerGeneratedAttribute]
public void set_ItemsNotUpdated(ITaskItem[] value);
    [CompilerGeneratedAttribute]
public bool get_AllItemsUpdated();
    [CompilerGeneratedAttribute]
public void set_AllItemsUpdated(bool value);
    public virtual bool Execute();
}
public abstract class MSBuild.Community.Tasks.Ftp.FtpClientTaskBase : Task {
    private Socket _clientSocket;
    private int _bufferSize;
    private FtpReply _lastReply;
    private bool _logFtpMessageConversation;
    private string _password;
    private int _port;
    private string _serverhost;
    private string _username;
    [RequiredAttribute]
public string ServerHost { get; public set; }
    public int Port { get; public set; }
    protected Socket ClientSocket { get; }
    protected bool Connected { get; }
    private static Encoding ConversationEncoding { get; }
    public FtpReply LastReply { get; public set; }
    public string Username { get; public set; }
    public string Password { get; public set; }
    private bool LogFtpMessageConversation { get; private set; }
    public int BufferSize { get; public set; }
    public string get_ServerHost();
    public void set_ServerHost(string value);
    public int get_Port();
    public void set_Port(int value);
    protected Socket get_ClientSocket();
    protected bool get_Connected();
    private static Encoding get_ConversationEncoding();
    public FtpReply get_LastReply();
    public void set_LastReply(FtpReply value);
    public string get_Username();
    public void set_Username(string value);
    public string get_Password();
    public void set_Password(string value);
    private bool get_LogFtpMessageConversation();
    private void set_LogFtpMessageConversation(bool value);
    public int get_BufferSize();
    public void set_BufferSize(int value);
    public void Connect();
    public void Login();
    public void SetFileTransferType(string mode);
    public void ChangeWorkingDirectory(string remoteDirectory);
    public string GetWorkingDirectory();
    public void CdUp();
    public bool FileExists(string remoteFile);
    public bool DirectoryExists(string remoteDirectory);
    public void RemoveDirectory(string directoryName);
    public void MakeDirectory(string directoryName);
    public void Close();
    public void Store(string localFile, string remoteFileName);
    protected void SendCommand(string command, string value);
    protected void SendCommand(string rawCommand);
    protected FtpReply SendCommandAndReadResponse(string command, string value);
    protected FtpReply SendCommandAndReadResponse(string rawCommand);
    public FtpEntry[] GetDirectoryDetails();
    public Stream CreateDataStreamAndSendCommand(string rawCommand);
    private static IPEndPoint ParseDataEndPointFromMessage(string message);
    public FtpEntry[] GetDirectoryDetails(string remoteDirectory);
    protected FtpReply ReadResponse();
    private string ReadResponseString();
    private void CloseAndTrowException(Exception exception);
}
public class MSBuild.Community.Tasks.Ftp.FtpCreateRemoteDirectory : FtpClientTaskBase {
    private string _remoteDirectory;
    [RequiredAttribute]
public string RemoteDirectory { get; public set; }
    public string get_RemoteDirectory();
    public void set_RemoteDirectory(string value);
    public virtual bool Execute();
}
public class MSBuild.Community.Tasks.Ftp.FtpDirectoryExists : FtpClientTaskBase {
    private string _remoteDirectory;
    private bool _exists;
    [RequiredAttribute]
public string RemoteDirectory { get; public set; }
    [OutputAttribute]
public bool Exists { get; }
    public string get_RemoteDirectory();
    public void set_RemoteDirectory(string value);
    public bool get_Exists();
    public virtual bool Execute();
}
public class MSBuild.Community.Tasks.Ftp.FtpEntry : object {
    private bool _isDirectory;
    private string _name;
    public bool IsDirectory { get; public set; }
    public string Name { get; public set; }
    public FtpEntry(bool isDirectory, string name);
    public bool get_IsDirectory();
    public void set_IsDirectory(bool value);
    public string get_Name();
    public void set_Name(string value);
    private static FtpEntry ParseDosDirLine(string entryLine);
    private static FtpEntry ParseUnixDirLine(string entryLine);
    public static FtpEntry[] ParseDirList(String[] entryLines);
}
public class MSBuild.Community.Tasks.Ftp.FtpException : Exception {
    public FtpException(string message);
    public FtpException(string message, Exception innerException);
}
public class MSBuild.Community.Tasks.Ftp.FtpReply : object {
    private int _resultCode;
    private string _message;
    public int ResultCode { get; public set; }
    public string Message { get; public set; }
    public FtpReply(int resultCode, string message);
    public int get_ResultCode();
    public void set_ResultCode(int value);
    public string get_Message();
    public void set_Message(string value);
}
public class MSBuild.Community.Tasks.Ftp.FtpUploadDirectoryContent : FtpClientTaskBase {
    private string _localDirectory;
    private string _remoteDirectory;
    private string _filesTransferType;
    private bool _recursive;
    public string LocalDirectory { get; public set; }
    public string RemoteDirectory { get; public set; }
    public string FilesTransferType { get; public set; }
    public bool Recursive { get; public set; }
    public string get_LocalDirectory();
    public void set_LocalDirectory(string value);
    public string get_RemoteDirectory();
    public void set_RemoteDirectory(string value);
    public string get_FilesTransferType();
    public void set_FilesTransferType(string value);
    public bool get_Recursive();
    public void set_Recursive(bool value);
    public virtual bool Execute();
    protected void UploadDirectory(string localPath, bool recurse);
    protected void UploadDirectory(string localPath, string mask, bool recursive);
}
public class MSBuild.Community.Tasks.FtpUpload : Task {
    private IFtpWebRequestCreator _requestCreator;
    private ITaskItem[] _localFiles;
    private ITaskItem[] _remoteFiles;
    private string _remoteUri;
    private string _username;
    private string _password;
    private bool _usePassive;
    private bool _keepAlive;
    private int _timeout;
    private static Char[] PathSeparators;
    public string LocalFile { get; public set; }
    public ITaskItem[] LocalFiles { get; public set; }
    [RequiredAttribute]
public ITaskItem[] RemoteFiles { get; public set; }
    [RequiredAttribute]
public string RemoteUri { get; public set; }
    public string Username { get; public set; }
    public string Password { get; public set; }
    public bool UsePassive { get; public set; }
    public bool KeepAlive { get; public set; }
    public int Timeout { get; public set; }
    public FtpUpload(IFtpWebRequestCreator requestCreator);
    private static FtpUpload();
    public string get_LocalFile();
    public void set_LocalFile(string value);
    public ITaskItem[] get_LocalFiles();
    public void set_LocalFiles(ITaskItem[] value);
    public ITaskItem[] get_RemoteFiles();
    public void set_RemoteFiles(ITaskItem[] value);
    public string get_RemoteUri();
    public void set_RemoteUri(string value);
    public string get_Username();
    public void set_Username(string value);
    public string get_Password();
    public void set_Password(string value);
    public bool get_UsePassive();
    public void set_UsePassive(bool value);
    public bool get_KeepAlive();
    public void set_KeepAlive(bool value);
    public int get_Timeout();
    public void set_Timeout(int value);
    public virtual bool Execute();
    private void EnsureDirectoriesCreated();
    private void CreateDirectory(string dir);
    private bool DirectoryExists(Dictionary`2<string, List`1<string>> directoryCache, string dirString);
    private Uri FtpPath(string dir);
    private List`1<string> GetUniqueDirectories(ITaskItem[] files);
    private string ParentPath(string path);
    private string NamePath(string path);
    private bool UploadFile(string localFilePath, string remoteFilePath, bool errorOnFailure);
    private IFtpWebRequest CreateRequest(Uri uri, string method);
    private sealed virtual override IFtpWebRequest MSBuild.Community.Tasks.IFtpWebRequestCreator.Create(Uri uri, string method);
}
internal class MSBuild.Community.Tasks.Fusion.AssemblyInfo : ValueType {
    public UInt32 cbAssemblyInfo;
    public UInt32 dwAssemblyFlags;
    public ulong uliAssemblySizeInKB;
    public string pszCurrentAssemblyPathBuf;
    public UInt32 cchBuf;
}
[FlagsAttribute]
internal enum MSBuild.Community.Tasks.Fusion.CacheFlags : Enum {
    public int value__;
    public static CacheFlags None;
    public static CacheFlags Zap;
    public static CacheFlags Gac;
    public static CacheFlags Download;
}
[FlagsAttribute]
internal enum MSBuild.Community.Tasks.Fusion.CommitFlags : Enum {
    public int value__;
    public static CommitFlags None;
    public static CommitFlags Refresh;
    public static CommitFlags Force;
}
public static class MSBuild.Community.Tasks.Fusion.FusionWrapper : object {
    private static object _lock;
    private static String[] proccessors;
    private static string _currentProcessorArchitecture;
    internal static string CurrentProcessorArchitecture { get; }
    private static FusionWrapper();
    internal static string get_CurrentProcessorArchitecture();
    public static void InstallAssembly(string assemblyPath, bool force);
    public static bool UninstallAssembly(string assemblyName, bool force);
    public static bool UninstallAssembly(string assemblyName, bool force, UninstallStatus& result);
    public static string GetAssemblyPath(string assemblyName);
    internal static string GetAssemblyPath(string assemblyName, String& fullName);
    public static AssemblyName GetAssemblyName(string assemblyName);
    private static void ThrowOnError(int hr);
    internal static string AppendProccessor(string fullName);
    internal static string AppendProccessor(string fullName, ProcessorArchitecture targetProcessor);
    internal static string AppendProccessor(string fullName, string targetProcessor);
    private static bool HasProcessorArchitecture(string fullName);
    private static string GetProcessorArchitecture();
}
[GuidAttribute("e707dcde-d1cd-11d2-bab9-00c04f8eceae")]
[InterfaceTypeAttribute("1")]
internal interface MSBuild.Community.Tasks.Fusion.IAssemblyCache {
    public abstract virtual int UninstallAssembly(int flags, string assemblyName, InstallReference[] references, UninstallStatus& disposition);
    public abstract virtual int QueryAssemblyInfo(int flags, string assemblyName, AssemblyInfo& assemblyInfo);
    public abstract virtual int CreateAssemblyCacheItem(int flags, IntPtr reserved, IAssemblyCacheItem& assemblyCacheItem, string assemblyName);
    public abstract virtual int CreateAssemblyScavenger(Object& assemblyScavenger);
    public abstract virtual int InstallAssembly(int flags, string manifestFilePath, InstallReference[] references);
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("9E3AAEB4-D1CD-11D2-BAB9-00C04F8ECEAE")]
internal interface MSBuild.Community.Tasks.Fusion.IAssemblyCacheItem {
    public abstract virtual int CreateStream(UInt32 flags, string streamName, UInt32 format, UInt32 formatFlags, IStream& stream, Int64& maxSize);
    public abstract virtual int Commit(UInt32 flags, Int64& disposition);
    public abstract virtual int AbortItem();
}
internal class MSBuild.Community.Tasks.Fusion.InstallReference : ValueType {
    public UInt32 Size;
    public UInt32 Flags;
    public Guid Scheme;
    public string Identifier;
    public string NonCannonicalData;
}
internal static class MSBuild.Community.Tasks.Fusion.NativeMethods : object {
    public static int CreateAssemblyCache(IAssemblyCache& assemblyCache, UInt32 reserved);
    public static int GetCachePath(CacheFlags assemblyCacheFlags, StringBuilder cachePath, Int32& cachePathSize);
    internal static void GetSystemInfo(SYSTEM_INFO& lpSystemInfo);
}
[FlagsAttribute]
internal enum MSBuild.Community.Tasks.Fusion.QueryFlags : Enum {
    public int value__;
    public static QueryFlags None;
    public static QueryFlags Validate;
    public static QueryFlags GetSize;
}
internal class MSBuild.Community.Tasks.Fusion.SYSTEM_INFO : ValueType {
    public ushort wProcessorArchitecture;
    public ushort wReserved;
    public UInt32 dwPageSize;
    public IntPtr lpMinimumApplicationAddress;
    public IntPtr lpMaximumApplicationAddress;
    public UIntPtr dwActiveProcessorMask;
    public UInt32 dwNumberOfProcessors;
    public UInt32 dwProcessorType;
    public UInt32 dwAllocationGranularity;
    public ushort wProcessorLevel;
    public ushort wProcessorRevision;
}
public enum MSBuild.Community.Tasks.Fusion.UninstallStatus : Enum {
    public int value__;
    public static UninstallStatus None;
    public static UninstallStatus Uninstalled;
    public static UninstallStatus StillInUse;
    public static UninstallStatus AlreadyUninstalled;
    public static UninstallStatus DeletePending;
    public static UninstallStatus HasInstallReferences;
    public static UninstallStatus ReferenceNotFound;
}
public class MSBuild.Community.Tasks.FxCop : ToolTask {
    private bool _searchGac;
    private bool _applyOutXsl;
    private bool _directOutputToConsole;
    private ITaskItem[] _dependencyDirectories;
    private ITaskItem[] _targetAssemblies;
    private string _consoleXslFileName;
    private ITaskItem[] _importFiles;
    private string _customDictionary;
    private ITaskItem[] _ruleLibraries;
    private ITaskItem[] _rules;
    [CompilerGeneratedAttribute]
private string <RuleSet>k__BackingField;
    private string _analysisReportFileName;
    private string _outputXslFileName;
    private string _platformDirectory;
    private string _projectFile;
    private bool _includeSummaryReport;
    private string _typeList;
    private bool _saveResults;
    private string _workingDirectory;
    private bool _verbose;
    private bool _failOnError;
    private bool _ignoreGeneratedCode;
    public bool SearchGac { get; public set; }
    public bool ApplyOutXsl { get; public set; }
    public bool DirectOutputToConsole { get; public set; }
    public ITaskItem[] DependencyDirectories { get; public set; }
    public ITaskItem[] TargetAssemblies { get; public set; }
    public string ConsoleXslFileName { get; public set; }
    public ITaskItem[] ImportFiles { get; public set; }
    public string CustomDictionary { get; public set; }
    public ITaskItem[] RuleLibraries { get; public set; }
    public ITaskItem[] Rules { get; public set; }
    public string RuleSet { get; public set; }
    public string AnalysisReportFileName { get; public set; }
    public string OutputXslFileName { get; public set; }
    public string PlatformDirectory { get; public set; }
    public string ProjectFile { get; public set; }
    public bool IncludeSummaryReport { get; public set; }
    public string TypeList { get; public set; }
    public bool SaveResults { get; public set; }
    public string WorkingDirectory { get; public set; }
    public bool Verbose { get; public set; }
    public bool FailOnError { get; public set; }
    public bool IgnoreGeneratedCode { get; public set; }
    protected string ToolName { get; }
    public bool get_SearchGac();
    public void set_SearchGac(bool value);
    public bool get_ApplyOutXsl();
    public void set_ApplyOutXsl(bool value);
    public bool get_DirectOutputToConsole();
    public void set_DirectOutputToConsole(bool value);
    public ITaskItem[] get_DependencyDirectories();
    public void set_DependencyDirectories(ITaskItem[] value);
    public ITaskItem[] get_TargetAssemblies();
    public void set_TargetAssemblies(ITaskItem[] value);
    public string get_ConsoleXslFileName();
    public void set_ConsoleXslFileName(string value);
    public ITaskItem[] get_ImportFiles();
    public void set_ImportFiles(ITaskItem[] value);
    public string get_CustomDictionary();
    public void set_CustomDictionary(string value);
    public ITaskItem[] get_RuleLibraries();
    public void set_RuleLibraries(ITaskItem[] value);
    public ITaskItem[] get_Rules();
    public void set_Rules(ITaskItem[] value);
    [CompilerGeneratedAttribute]
public string get_RuleSet();
    [CompilerGeneratedAttribute]
public void set_RuleSet(string value);
    public string get_AnalysisReportFileName();
    public void set_AnalysisReportFileName(string value);
    public string get_OutputXslFileName();
    public void set_OutputXslFileName(string value);
    public string get_PlatformDirectory();
    public void set_PlatformDirectory(string value);
    public string get_ProjectFile();
    public void set_ProjectFile(string value);
    public bool get_IncludeSummaryReport();
    public void set_IncludeSummaryReport(bool value);
    public string get_TypeList();
    public void set_TypeList(string value);
    public bool get_SaveResults();
    public void set_SaveResults(bool value);
    public string get_WorkingDirectory();
    public void set_WorkingDirectory(string value);
    public bool get_Verbose();
    public void set_Verbose(bool value);
    public bool get_FailOnError();
    public void set_FailOnError(bool value);
    public bool get_IgnoreGeneratedCode();
    public void set_IgnoreGeneratedCode(bool value);
    public virtual bool Execute();
    protected virtual string GenerateFullPathToTool();
    protected virtual string GenerateCommandLineCommands();
    protected virtual string get_ToolName();
    protected virtual bool ValidateParameters();
    protected virtual string GetWorkingDirectory();
}
public class MSBuild.Community.Tasks.GacUtil : Task {
    private GacUtilCommands _command;
    private String[] _relatedFileExtensions;
    private bool _includeRelatedFiles;
    private bool _quiet;
    private bool _force;
    private String[] _assemblies;
    private List`1<ITaskItem> _installedPaths;
    private List`1<string> _installedNames;
    private int _successful;
    private int _failed;
    private int _skipped;
    public string Command { get; public set; }
    public String[] RelatedFileExtensions { get; public set; }
    public bool IncludeRelatedFiles { get; public set; }
    public bool Quiet { get; public set; }
    public bool Force { get; public set; }
    [RequiredAttribute]
public String[] Assemblies { get; public set; }
    [OutputAttribute]
public ITaskItem[] InstalledPaths { get; }
    [OutputAttribute]
public String[] InstalledNames { get; }
    [OutputAttribute]
public int Successful { get; }
    [OutputAttribute]
public int Failed { get; }
    [OutputAttribute]
public int Skipped { get; }
    public string get_Command();
    public void set_Command(string value);
    public String[] get_RelatedFileExtensions();
    public void set_RelatedFileExtensions(String[] value);
    public bool get_IncludeRelatedFiles();
    public void set_IncludeRelatedFiles(bool value);
    public bool get_Quiet();
    public void set_Quiet(bool value);
    public bool get_Force();
    public void set_Force(bool value);
    public String[] get_Assemblies();
    public void set_Assemblies(String[] value);
    public ITaskItem[] get_InstalledPaths();
    public String[] get_InstalledNames();
    public int get_Successful();
    public int get_Failed();
    public int get_Skipped();
    public virtual bool Execute();
    private void Uninstall();
    private void UnintallAssembly(string name);
    private void Install();
    private void InstallFile(string file);
    private void CopyRelatedFiles(string sourceAssembly, string targetDirectory);
}
public enum MSBuild.Community.Tasks.GacUtilCommands : Enum {
    public int value__;
    public static GacUtilCommands Install;
    public static GacUtilCommands Uninstall;
}
public class MSBuild.Community.Tasks.GetSolutionProjects : Task {
    private static string SolutionFolderProjectType;
    private static string ExtractProjectsFromSolutionRegex;
    private string solutionFile;
    private ITaskItem[] output;
    [OutputAttribute]
public ITaskItem[] Output { get; public set; }
    [RequiredAttribute]
public string Solution { get; public set; }
    public ITaskItem[] get_Output();
    public void set_Output(ITaskItem[] value);
    public string get_Solution();
    public void set_Solution(string value);
    public virtual bool Execute();
}
public class MSBuild.Community.Tasks.Git.GitBranch : GitClient {
    [CompilerGeneratedAttribute]
private string <Branch>k__BackingField;
    [OutputAttribute]
public string Branch { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Branch();
    [CompilerGeneratedAttribute]
public void set_Branch(string value);
    protected virtual void LogEventsFromTextOutput(string singleLine, MessageImportance messageImportance);
    public bool IsBranchStatusLine(string singleLine);
    public string ParseStatusLineOutput(string singleLine);
    protected virtual void GenerateArguments(CommandLineBuilder builder);
}
public class MSBuild.Community.Tasks.Git.GitClient : ToolTask {
    private string _initialToolPath;
    private List`1<ITaskItem> _consoleOut;
    [CompilerGeneratedAttribute]
private string <Command>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Arguments>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LocalPath>k__BackingField;
    public string Command { get; public set; }
    public string Arguments { get; public set; }
    public string LocalPath { get; public set; }
    [OutputAttribute]
public ITaskItem[] ConsoleOutput { get; public set; }
    protected MessageImportance StandardOutputLoggingImportance { get; }
    protected MessageImportance StandardErrorLoggingImportance { get; }
    protected string ToolName { get; }
    [CompilerGeneratedAttribute]
public string get_Command();
    [CompilerGeneratedAttribute]
public void set_Command(string value);
    [CompilerGeneratedAttribute]
public string get_Arguments();
    [CompilerGeneratedAttribute]
public void set_Arguments(string value);
    [CompilerGeneratedAttribute]
public string get_LocalPath();
    [CompilerGeneratedAttribute]
public void set_LocalPath(string value);
    public ITaskItem[] get_ConsoleOutput();
    public void set_ConsoleOutput(ITaskItem[] value);
    private string FindToolPath(string toolName);
    protected virtual string GenerateCommandLineCommands();
    protected virtual void GenerateCommand(CommandLineBuilder builder);
    protected virtual void GenerateArguments(CommandLineBuilder builder);
    protected virtual string GenerateFullPathToTool();
    protected virtual void LogToolCommand(string message);
    protected virtual MessageImportance get_StandardOutputLoggingImportance();
    protected virtual MessageImportance get_StandardErrorLoggingImportance();
    protected virtual string get_ToolName();
    protected virtual bool ValidateParameters();
    protected virtual string GetWorkingDirectory();
    protected virtual void LogEventsFromTextOutput(string singleLine, MessageImportance messageImportance);
}
public class MSBuild.Community.Tasks.Git.GitCommitDate : GitClient {
    [CompilerGeneratedAttribute]
private string <Revision>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Format>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CommitDate>k__BackingField;
    public string Revision { get; public set; }
    public string Format { get; public set; }
    [OutputAttribute]
public string CommitDate { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Revision();
    [CompilerGeneratedAttribute]
public void set_Revision(string value);
    [CompilerGeneratedAttribute]
public string get_Format();
    [CompilerGeneratedAttribute]
public void set_Format(string value);
    [CompilerGeneratedAttribute]
public string get_CommitDate();
    [CompilerGeneratedAttribute]
public void set_CommitDate(string value);
    protected virtual void GenerateArguments(CommandLineBuilder builder);
    public virtual bool Execute();
    private void Parse();
}
public class MSBuild.Community.Tasks.Git.GitCommits : GitClient {
    [CompilerGeneratedAttribute]
private string <Revision>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CommitsCount>k__BackingField;
    public string Revision { get; public set; }
    [OutputAttribute]
public string CommitsCount { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Revision();
    [CompilerGeneratedAttribute]
public void set_Revision(string value);
    [CompilerGeneratedAttribute]
public string get_CommitsCount();
    [CompilerGeneratedAttribute]
public void set_CommitsCount(string value);
    protected virtual void GenerateArguments(CommandLineBuilder builder);
    protected virtual void LogEventsFromTextOutput(string singleLine, MessageImportance messageImportance);
}
public class MSBuild.Community.Tasks.Git.GitDescribe : GitClient {
    [CompilerGeneratedAttribute]
private int <CommitCount>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CommitHash>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Tag>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ErrorMessage>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SoftErrorMode>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <LightWeight>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Match>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Always>k__BackingField;
    [OutputAttribute]
public int CommitCount { get; public set; }
    [OutputAttribute]
public string CommitHash { get; public set; }
    [OutputAttribute]
public string Tag { get; public set; }
    [OutputAttribute]
public string ErrorMessage { get; public set; }
    public bool SoftErrorMode { get; public set; }
    public bool LightWeight { get; public set; }
    public string Match { get; public set; }
    public bool Always { get; public set; }
    [CompilerGeneratedAttribute]
public int get_CommitCount();
    [CompilerGeneratedAttribute]
public void set_CommitCount(int value);
    [CompilerGeneratedAttribute]
public string get_CommitHash();
    [CompilerGeneratedAttribute]
public void set_CommitHash(string value);
    [CompilerGeneratedAttribute]
public string get_Tag();
    [CompilerGeneratedAttribute]
public void set_Tag(string value);
    [CompilerGeneratedAttribute]
public string get_ErrorMessage();
    [CompilerGeneratedAttribute]
public void set_ErrorMessage(string value);
    [CompilerGeneratedAttribute]
public bool get_SoftErrorMode();
    [CompilerGeneratedAttribute]
public void set_SoftErrorMode(bool value);
    [CompilerGeneratedAttribute]
public bool get_LightWeight();
    [CompilerGeneratedAttribute]
public void set_LightWeight(bool value);
    [CompilerGeneratedAttribute]
public string get_Match();
    [CompilerGeneratedAttribute]
public void set_Match(string value);
    [CompilerGeneratedAttribute]
public bool get_Always();
    [CompilerGeneratedAttribute]
public void set_Always(bool value);
    protected virtual void GenerateArguments(CommandLineBuilder builder);
    protected virtual void LogEventsFromTextOutput(string singleLine, MessageImportance messageImportance);
}
public class MSBuild.Community.Tasks.Git.GitPendingChanges : GitClient {
    [CompilerGeneratedAttribute]
private bool <HasPendingChanges>k__BackingField;
    [OutputAttribute]
public bool HasPendingChanges { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_HasPendingChanges();
    [CompilerGeneratedAttribute]
public void set_HasPendingChanges(bool value);
    protected virtual void GenerateArguments(CommandLineBuilder builder);
    protected virtual void LogEventsFromTextOutput(string singleLine, MessageImportance messageImportance);
}
public class MSBuild.Community.Tasks.Git.GitVersion : GitClient {
    [CompilerGeneratedAttribute]
private string <Revision>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CommitHash>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Short>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ShortLength>k__BackingField;
    public string Revision { get; public set; }
    [OutputAttribute]
public string CommitHash { get; public set; }
    public bool Short { get; public set; }
    public int ShortLength { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Revision();
    [CompilerGeneratedAttribute]
public void set_Revision(string value);
    [CompilerGeneratedAttribute]
public string get_CommitHash();
    [CompilerGeneratedAttribute]
public void set_CommitHash(string value);
    [CompilerGeneratedAttribute]
public bool get_Short();
    [CompilerGeneratedAttribute]
public void set_Short(bool value);
    [CompilerGeneratedAttribute]
public int get_ShortLength();
    [CompilerGeneratedAttribute]
public void set_ShortLength(int value);
    protected virtual void GenerateArguments(CommandLineBuilder builder);
    protected virtual void LogEventsFromTextOutput(string singleLine, MessageImportance messageImportance);
}
public class MSBuild.Community.Tasks.HtmlHelp.ChmCompiler : ToolTask {
    private ITaskItem _projectFilePath;
    [RequiredAttribute]
public ITaskItem ProjectFile { get; public set; }
    protected string ToolName { get; }
    protected MessageImportance StandardOutputLoggingImportance { get; }
    public ITaskItem get_ProjectFile();
    public void set_ProjectFile(ITaskItem value);
    protected virtual string GenerateFullPathToTool();
    protected virtual string get_ToolName();
    protected virtual void LogToolCommand(string message);
    protected virtual MessageImportance get_StandardOutputLoggingImportance();
    protected virtual string GenerateCommandLineCommands();
    protected virtual bool HandleTaskExecutionErrors();
}
public class MSBuild.Community.Tasks.HtmlHelp.HxCompiler : ToolTask {
    private ITaskItem _projectFile;
    private string _logFile;
    private string _projectRoot;
    private ITaskItem _outputFile;
    private bool _noInfoMessages;
    private bool _noWarningMessages;
    private bool _noErrorMessages;
    private bool _quiteMode;
    private ITaskItem _uncompileFile;
    private string _uncompileDirectory;
    [RequiredAttribute]
public ITaskItem ProjectFile { get; public set; }
    public string LogFile { get; public set; }
    public string ProjectRoot { get; public set; }
    public ITaskItem OutputFile { get; public set; }
    public bool NoInfoMessages { get; public set; }
    public bool NoWarningMessages { get; public set; }
    public bool NoErrorMessages { get; public set; }
    public bool QuiteMode { get; public set; }
    public ITaskItem UncompileFile { get; public set; }
    public string UncompileDirectory { get; public set; }
    protected string ToolName { get; }
    protected MessageImportance StandardOutputLoggingImportance { get; }
    public ITaskItem get_ProjectFile();
    public void set_ProjectFile(ITaskItem value);
    public string get_LogFile();
    public void set_LogFile(string value);
    public string get_ProjectRoot();
    public void set_ProjectRoot(string value);
    public ITaskItem get_OutputFile();
    public void set_OutputFile(ITaskItem value);
    public bool get_NoInfoMessages();
    public void set_NoInfoMessages(bool value);
    public bool get_NoWarningMessages();
    public void set_NoWarningMessages(bool value);
    public bool get_NoErrorMessages();
    public void set_NoErrorMessages(bool value);
    public bool get_QuiteMode();
    public void set_QuiteMode(bool value);
    public ITaskItem get_UncompileFile();
    public void set_UncompileFile(ITaskItem value);
    public string get_UncompileDirectory();
    public void set_UncompileDirectory(string value);
    protected virtual string GenerateFullPathToTool();
    protected virtual string get_ToolName();
    protected virtual void LogToolCommand(string message);
    protected virtual MessageImportance get_StandardOutputLoggingImportance();
    protected virtual string GenerateCommandLineCommands();
    protected virtual bool HandleTaskExecutionErrors();
}
public interface MSBuild.Community.Tasks.IFtpWebRequest {
    public abstract virtual void SetContentLength(long length);
    public abstract virtual Stream GetRequestStream();
    public abstract virtual string GetStatusDescriptionAndCloseResponse();
    public abstract virtual void GetAndCloseResponse();
    public abstract virtual Stream GetResponseStream();
}
public interface MSBuild.Community.Tasks.IFtpWebRequestCreator {
    public abstract virtual IFtpWebRequest Create(Uri uri, string method);
}
public class MSBuild.Community.Tasks.IIS.AppPoolController : WebBase {
    private string mAppPoolName;
    private string mAction;
    [RequiredAttribute]
public string ApplicationPoolName { get; public set; }
    [RequiredAttribute]
public string Action { get; public set; }
    public string get_ApplicationPoolName();
    public void set_ApplicationPoolName(string value);
    public string get_Action();
    public void set_Action(string value);
    public virtual bool Execute();
    private bool ControlApplicationPool();
    private void ExecuteAppPoolAction(string scopePath, string path);
    private IIS7ApplicationPoolState GetAppPoolState(ManagementObject managementObject);
    private string GetActionFinish();
    private string GetActionInProgress();
}
public enum MSBuild.Community.Tasks.IIS.AppPoolControllerActions : Enum {
    public int value__;
    public static AppPoolControllerActions Start;
    public static AppPoolControllerActions Stop;
    public static AppPoolControllerActions Restart;
    public static AppPoolControllerActions Recycle;
}
public class MSBuild.Community.Tasks.IIS.AppPoolCreate : WebBase {
    private string mAppPoolName;
    private bool mAppPoolAutoStart;
    private int mAppPoolIdentityType;
    private int mAppPoolQueueLength;
    private string mAutoShutdownAppPoolExe;
    private string mAutoShutdownAppPoolParams;
    private int mCPUAction;
    private int mCPULimit;
    private int mCPUResetInterval;
    private bool mDisallowOverlappingRotation;
    private bool mDisallowRotationOnConfigChange;
    private int mIdleTimeout;
    private int mLoadBalancerCapabilities;
    private int mLogEventOnRecycle;
    private int mLogonMethod;
    private int mMaxProcesses;
    private string mOrphanActionExe;
    private string mOrphanActionParams;
    private bool mOrphanWorkerProcess;
    private int mPeriodicRestartMemory;
    private int mPeriodicRestartPrivateMemory;
    private int mPeriodicRestartRequests;
    private String[] mRestartSchedule;
    private string mPeriodicRestartSchedule;
    private int mPeriodicRestartTime;
    private bool mPingingEnabled;
    private int mPingInterval;
    private int mPingResponseTime;
    private bool mRapidFailProtection;
    private int mRapidFailProtectionInterval;
    private int mRapidFailProtectionMaxCrashes;
    private int mShutdownTimeLimit;
    private bool mSMPAffinitized;
    private long mSMPProcessorAffinityMask;
    private int mStartupTimeLimit;
    private string mWAMUserName;
    private string mWAMUserPass;
    [RequiredAttribute]
public string ApplicationPoolName { get; public set; }
    public bool AppPoolAutoStart { get; public set; }
    public int AppPoolIdentityType { get; public set; }
    public int AppPoolQueueLength { get; public set; }
    public string AutoShutdownAppPoolExe { get; public set; }
    public string AutoShutdownAppPoolParams { get; public set; }
    public int CPUAction { get; public set; }
    public int CPULimit { get; public set; }
    public int CPUResetInterval { get; public set; }
    public bool DisallowOverlappingRotation { get; public set; }
    public bool DisallowRotationOnConfigChange { get; public set; }
    public int IdleTimeout { get; public set; }
    public int LoadBalancerCapabilities { get; public set; }
    public int LogEventOnRecycle { get; public set; }
    public int LogonMethod { get; public set; }
    public int MaxProcesses { get; public set; }
    public string OrphanActionExe { get; public set; }
    public string OrphanActionParams { get; public set; }
    public bool OrphanWorkerProcess { get; public set; }
    public int PeriodicRestartMemory { get; public set; }
    public int PeriodicRestartPrivateMemory { get; public set; }
    public int PeriodicRestartRequests { get; public set; }
    public string PeriodicRestartSchedule { get; public set; }
    public int PeriodicRestartTime { get; public set; }
    public bool PingingEnabled { get; public set; }
    public int PingInterval { get; public set; }
    public int PingResponseTime { get; public set; }
    public bool RapidFailProtection { get; public set; }
    public int RapidFailProtectionInterval { get; public set; }
    public int RapidFailProtectionMaxCrashes { get; public set; }
    public int ShutdownTimeLimit { get; public set; }
    public bool SMPAffinitized { get; public set; }
    public long SMPProcessorAffinityMask { get; public set; }
    public int StartupTimeLimit { get; public set; }
    public string WAMUserName { get; public set; }
    public string WAMUserPass { get; public set; }
    public string get_ApplicationPoolName();
    public void set_ApplicationPoolName(string value);
    public bool get_AppPoolAutoStart();
    public void set_AppPoolAutoStart(bool value);
    public int get_AppPoolIdentityType();
    public void set_AppPoolIdentityType(int value);
    public int get_AppPoolQueueLength();
    public void set_AppPoolQueueLength(int value);
    public string get_AutoShutdownAppPoolExe();
    public void set_AutoShutdownAppPoolExe(string value);
    public string get_AutoShutdownAppPoolParams();
    public void set_AutoShutdownAppPoolParams(string value);
    public int get_CPUAction();
    public void set_CPUAction(int value);
    public int get_CPULimit();
    public void set_CPULimit(int value);
    public int get_CPUResetInterval();
    public void set_CPUResetInterval(int value);
    public bool get_DisallowOverlappingRotation();
    public void set_DisallowOverlappingRotation(bool value);
    public bool get_DisallowRotationOnConfigChange();
    public void set_DisallowRotationOnConfigChange(bool value);
    public int get_IdleTimeout();
    public void set_IdleTimeout(int value);
    public int get_LoadBalancerCapabilities();
    public void set_LoadBalancerCapabilities(int value);
    public int get_LogEventOnRecycle();
    public void set_LogEventOnRecycle(int value);
    public int get_LogonMethod();
    public void set_LogonMethod(int value);
    public int get_MaxProcesses();
    public void set_MaxProcesses(int value);
    public string get_OrphanActionExe();
    public void set_OrphanActionExe(string value);
    public string get_OrphanActionParams();
    public void set_OrphanActionParams(string value);
    public bool get_OrphanWorkerProcess();
    public void set_OrphanWorkerProcess(bool value);
    public int get_PeriodicRestartMemory();
    public void set_PeriodicRestartMemory(int value);
    public int get_PeriodicRestartPrivateMemory();
    public void set_PeriodicRestartPrivateMemory(int value);
    public int get_PeriodicRestartRequests();
    public void set_PeriodicRestartRequests(int value);
    public string get_PeriodicRestartSchedule();
    public void set_PeriodicRestartSchedule(string value);
    public int get_PeriodicRestartTime();
    public void set_PeriodicRestartTime(int value);
    public bool get_PingingEnabled();
    public void set_PingingEnabled(bool value);
    public int get_PingInterval();
    public void set_PingInterval(int value);
    public int get_PingResponseTime();
    public void set_PingResponseTime(int value);
    public bool get_RapidFailProtection();
    public void set_RapidFailProtection(bool value);
    public int get_RapidFailProtectionInterval();
    public void set_RapidFailProtectionInterval(int value);
    public int get_RapidFailProtectionMaxCrashes();
    public void set_RapidFailProtectionMaxCrashes(int value);
    public int get_ShutdownTimeLimit();
    public void set_ShutdownTimeLimit(int value);
    public bool get_SMPAffinitized();
    public void set_SMPAffinitized(bool value);
    public long get_SMPProcessorAffinityMask();
    public void set_SMPProcessorAffinityMask(long value);
    public int get_StartupTimeLimit();
    public void set_StartupTimeLimit(int value);
    public string get_WAMUserName();
    public void set_WAMUserName(string value);
    public string get_WAMUserPass();
    public void set_WAMUserPass(string value);
    public virtual bool Execute();
    private bool CreateAppPool();
}
public class MSBuild.Community.Tasks.IIS.AppPoolDelete : WebBase {
    private string mAppPoolName;
    [RequiredAttribute]
public string ApplicationPoolName { get; public set; }
    public string get_ApplicationPoolName();
    public void set_ApplicationPoolName(string value);
    public virtual bool Execute();
    private bool DeleteAppPool();
}
public abstract class MSBuild.Community.Tasks.IIS.WebBase : Task {
    protected IISVersion mIISVersion;
    private string mServerName;
    private int mServerPort;
    private string mServerInstance;
    private string mIISServerPath;
    private string mIISSiteHostHeaderName;
    private string mIISApplicationPath;
    private string mIISAppPoolPath;
    private string mUsername;
    private string mPassword;
    public string ServerName { get; public set; }
    public string HostHeaderName { get; public set; }
    public int ServerPort { get; public set; }
    protected string IISServerPath { get; protected set; }
    protected string IISApplicationPath { get; protected set; }
    protected string IISAppPoolPath { get; protected set; }
    public string Username { get; public set; }
    public string Password { get; public set; }
    public string get_ServerName();
    public void set_ServerName(string value);
    public string get_HostHeaderName();
    public void set_HostHeaderName(string value);
    public int get_ServerPort();
    public void set_ServerPort(int value);
    protected string get_IISServerPath();
    protected void set_IISServerPath(string value);
    protected string get_IISApplicationPath();
    protected void set_IISApplicationPath(string value);
    protected string get_IISAppPoolPath();
    protected void set_IISAppPoolPath(string value);
    public string get_Username();
    public void set_Username(string value);
    public string get_Password();
    public void set_Password(string value);
    protected IISVersion GetIISVersion();
    protected Version GetRemoteOSVersion();
    protected void VerifyIISRoot();
    private bool VerifySiteHostHeaderExists(DirectoryEntry site);
    private bool VerifyServerPortExists(DirectoryEntry site);
    private void SetIISPrimitives(string serverInstance);
}
public class MSBuild.Community.Tasks.IIS.WebDirectoryCreate : WebBase {
    private string mVirtualDirectoryName;
    private string mVirtualDirectoryPhysicalPath;
    private bool mAccessExecute;
    private bool mAccessNoRemoteExecute;
    private bool mAccessNoRemoteRead;
    private bool mAccessNoRemoteScript;
    private bool mAccessNoRemoteWrite;
    private bool mAccessRead;
    private bool mAccessSource;
    private bool mAccessScript;
    private bool mAccessSsl;
    private bool mAccessSsl128;
    private bool mAccessSslMapCert;
    private bool mAccessSslNegotiateCert;
    private bool mAccessSslRequireCert;
    private bool mAccessWrite;
    private bool mAnonymousPasswordSync;
    private bool mAppAllowClientDebug;
    private bool mAppAllowDebugging;
    private bool mAspAllowSessionState;
    private bool mAspBufferingOn;
    private bool mAspEnableApplicationRestart;
    private bool mAspEnableAspHtmlFallback;
    private bool mAspEnableChunkedEncoding;
    private bool mAspErrorsToNTLog;
    private bool mAspEnableParentPaths;
    private bool mAspEnableTypelibCache;
    private bool mAspExceptionCatchEnable;
    private bool mAspLogErrorRequests;
    private bool mAspScriptErrorSentToBrowser;
    private bool mAspTrackThreadingModel;
    private bool mAuthAnonymous;
    private bool mAuthBasic;
    private bool mAuthNtlm;
    private bool mAuthPersistSingleRequest;
    private bool mAuthPersistSingleRequestIfProxy;
    private bool mAuthPersistSingleRequestAlwaysIfProxy;
    private bool mCacheControlNoCache;
    private bool mCacheIsapi;
    private bool mContentIndexed;
    private bool mCpuAppEnabled;
    private bool mCpuCgiEnabled;
    private bool mCreateCgiWithNewConsole;
    private bool mCreateProcessAsUser;
    private bool mDirBrowseShowDate;
    private bool mDirBrowseShowExtension;
    private bool mDirBrowseShowLongDate;
    private bool mDirBrowseShowSize;
    private bool mDirBrowseShowTime;
    private bool mDontLog;
    private bool mEnableDefaultDoc;
    private bool mEnableDirBrowsing;
    private bool mEnableDocFooter;
    private bool mEnableReverseDns;
    private bool mSsiExecDisable;
    private bool mUncAuthenticationPassthrough;
    private string mAspScriptErrorMessage;
    private string mDefaultDoc;
    [RequiredAttribute]
public string VirtualDirectoryName { get; public set; }
    [RequiredAttribute]
public string VirtualDirectoryPhysicalPath { get; public set; }
    public bool AccessExecute { get; public set; }
    public bool AccessNoRemoteExecute { get; public set; }
    public bool AccessNoRemoteRead { get; public set; }
    public bool AccessNoRemoteScript { get; public set; }
    public bool AccessNoRemoteWrite { get; public set; }
    public bool AccessRead { get; public set; }
    public bool AccessSource { get; public set; }
    public bool AccessScript { get; public set; }
    public bool AccessSsl { get; public set; }
    public bool AccessSsl128 { get; public set; }
    public bool AccessSslMapCert { get; public set; }
    public bool AccessSslNegotiateCert { get; public set; }
    public bool AccessSslRequireCert { get; public set; }
    public bool AccessWrite { get; public set; }
    public bool AnonymousPasswordSync { get; public set; }
    public bool AppAllowClientDebug { get; public set; }
    public bool AppAllowDebugging { get; public set; }
    public bool AspAllowSessionState { get; public set; }
    public bool AspBufferingOn { get; public set; }
    public bool AspEnableApplicationRestart { get; public set; }
    public bool AspEnableAspHtmlFallback { get; public set; }
    public bool AspEnableChunkedEncoding { get; public set; }
    public bool AspErrorsToNTLog { get; public set; }
    public bool AspEnableParentPaths { get; public set; }
    public bool AspEnableTypelibCache { get; public set; }
    public bool AspExceptionCatchEnable { get; public set; }
    public bool AspLogErrorRequests { get; public set; }
    public bool AspScriptErrorSentToBrowser { get; public set; }
    public bool AspTrackThreadingModel { get; public set; }
    public bool AuthAnonymous { get; public set; }
    public bool AuthBasic { get; public set; }
    public bool AuthNtlm { get; public set; }
    public bool AuthPersistSingleRequest { get; public set; }
    public bool AuthPersistSingleRequestIfProxy { get; public set; }
    public bool AuthPersistSingleRequestAlwaysIfProxy { get; public set; }
    public bool CacheControlNoCache { get; public set; }
    public bool CacheIsapi { get; public set; }
    public bool ContentIndexed { get; public set; }
    public bool CpuAppEnabled { get; public set; }
    public bool CpuCgiEnabled { get; public set; }
    public bool CreateCgiWithNewConsole { get; public set; }
    public bool CreateProcessAsUser { get; public set; }
    public bool DirBrowseShowDate { get; public set; }
    public bool DirBrowseShowExtension { get; public set; }
    public bool DirBrowseShowLongDate { get; public set; }
    public bool DirBrowseShowSize { get; public set; }
    public bool DirBrowseShowTime { get; public set; }
    public bool DontLog { get; public set; }
    public bool EnableDefaultDoc { get; public set; }
    public bool EnableDirBrowsing { get; public set; }
    public bool EnableDocFooter { get; public set; }
    public bool EnableReverseDns { get; public set; }
    public bool SsiExecDisable { get; public set; }
    public bool UncAuthenticationPassthrough { get; public set; }
    public string AspScriptErrorMessage { get; public set; }
    public string DefaultDoc { get; public set; }
    public string get_VirtualDirectoryName();
    public void set_VirtualDirectoryName(string value);
    public string get_VirtualDirectoryPhysicalPath();
    public void set_VirtualDirectoryPhysicalPath(string value);
    public bool get_AccessExecute();
    public void set_AccessExecute(bool value);
    public bool get_AccessNoRemoteExecute();
    public void set_AccessNoRemoteExecute(bool value);
    public bool get_AccessNoRemoteRead();
    public void set_AccessNoRemoteRead(bool value);
    public bool get_AccessNoRemoteScript();
    public void set_AccessNoRemoteScript(bool value);
    public bool get_AccessNoRemoteWrite();
    public void set_AccessNoRemoteWrite(bool value);
    public bool get_AccessRead();
    public void set_AccessRead(bool value);
    public bool get_AccessSource();
    public void set_AccessSource(bool value);
    public bool get_AccessScript();
    public void set_AccessScript(bool value);
    public bool get_AccessSsl();
    public void set_AccessSsl(bool value);
    public bool get_AccessSsl128();
    public void set_AccessSsl128(bool value);
    public bool get_AccessSslMapCert();
    public void set_AccessSslMapCert(bool value);
    public bool get_AccessSslNegotiateCert();
    public void set_AccessSslNegotiateCert(bool value);
    public bool get_AccessSslRequireCert();
    public void set_AccessSslRequireCert(bool value);
    public bool get_AccessWrite();
    public void set_AccessWrite(bool value);
    public bool get_AnonymousPasswordSync();
    public void set_AnonymousPasswordSync(bool value);
    public bool get_AppAllowClientDebug();
    public void set_AppAllowClientDebug(bool value);
    public bool get_AppAllowDebugging();
    public void set_AppAllowDebugging(bool value);
    public bool get_AspAllowSessionState();
    public void set_AspAllowSessionState(bool value);
    public bool get_AspBufferingOn();
    public void set_AspBufferingOn(bool value);
    public bool get_AspEnableApplicationRestart();
    public void set_AspEnableApplicationRestart(bool value);
    public bool get_AspEnableAspHtmlFallback();
    public void set_AspEnableAspHtmlFallback(bool value);
    public bool get_AspEnableChunkedEncoding();
    public void set_AspEnableChunkedEncoding(bool value);
    public bool get_AspErrorsToNTLog();
    public void set_AspErrorsToNTLog(bool value);
    public bool get_AspEnableParentPaths();
    public void set_AspEnableParentPaths(bool value);
    public bool get_AspEnableTypelibCache();
    public void set_AspEnableTypelibCache(bool value);
    public bool get_AspExceptionCatchEnable();
    public void set_AspExceptionCatchEnable(bool value);
    public bool get_AspLogErrorRequests();
    public void set_AspLogErrorRequests(bool value);
    public bool get_AspScriptErrorSentToBrowser();
    public void set_AspScriptErrorSentToBrowser(bool value);
    public bool get_AspTrackThreadingModel();
    public void set_AspTrackThreadingModel(bool value);
    public bool get_AuthAnonymous();
    public void set_AuthAnonymous(bool value);
    public bool get_AuthBasic();
    public void set_AuthBasic(bool value);
    public bool get_AuthNtlm();
    public void set_AuthNtlm(bool value);
    public bool get_AuthPersistSingleRequest();
    public void set_AuthPersistSingleRequest(bool value);
    public bool get_AuthPersistSingleRequestIfProxy();
    public void set_AuthPersistSingleRequestIfProxy(bool value);
    public bool get_AuthPersistSingleRequestAlwaysIfProxy();
    public void set_AuthPersistSingleRequestAlwaysIfProxy(bool value);
    public bool get_CacheControlNoCache();
    public void set_CacheControlNoCache(bool value);
    public bool get_CacheIsapi();
    public void set_CacheIsapi(bool value);
    public bool get_ContentIndexed();
    public void set_ContentIndexed(bool value);
    public bool get_CpuAppEnabled();
    public void set_CpuAppEnabled(bool value);
    public bool get_CpuCgiEnabled();
    public void set_CpuCgiEnabled(bool value);
    public bool get_CreateCgiWithNewConsole();
    public void set_CreateCgiWithNewConsole(bool value);
    public bool get_CreateProcessAsUser();
    public void set_CreateProcessAsUser(bool value);
    public bool get_DirBrowseShowDate();
    public void set_DirBrowseShowDate(bool value);
    public bool get_DirBrowseShowExtension();
    public void set_DirBrowseShowExtension(bool value);
    public bool get_DirBrowseShowLongDate();
    public void set_DirBrowseShowLongDate(bool value);
    public bool get_DirBrowseShowSize();
    public void set_DirBrowseShowSize(bool value);
    public bool get_DirBrowseShowTime();
    public void set_DirBrowseShowTime(bool value);
    public bool get_DontLog();
    public void set_DontLog(bool value);
    public bool get_EnableDefaultDoc();
    public void set_EnableDefaultDoc(bool value);
    public bool get_EnableDirBrowsing();
    public void set_EnableDirBrowsing(bool value);
    public bool get_EnableDocFooter();
    public void set_EnableDocFooter(bool value);
    public bool get_EnableReverseDns();
    public void set_EnableReverseDns(bool value);
    public bool get_SsiExecDisable();
    public void set_SsiExecDisable(bool value);
    public bool get_UncAuthenticationPassthrough();
    public void set_UncAuthenticationPassthrough(bool value);
    public string get_AspScriptErrorMessage();
    public void set_AspScriptErrorMessage(string value);
    public string get_DefaultDoc();
    public void set_DefaultDoc(string value);
    public virtual bool Execute();
    private bool CreateVirtualDirectory();
}
public class MSBuild.Community.Tasks.IIS.WebDirectoryDelete : WebBase {
    private string mVirtualDirectoryName;
    [RequiredAttribute]
public string VirtualDirectoryName { get; public set; }
    public string get_VirtualDirectoryName();
    public void set_VirtualDirectoryName(string value);
    public virtual bool Execute();
    private bool DeleteVirtualDirectory();
}
public class MSBuild.Community.Tasks.IIS.WebDirectoryScriptMap : WebBase {
    private string mVirtualDirectoryName;
    private string extension;
    private string executablePath;
    private bool mapToAspNet;
    private string verbs;
    private bool enableScriptEngine;
    private bool verifyFileExists;
    [RequiredAttribute]
public string VirtualDirectoryName { get; public set; }
    [RequiredAttribute]
public string Extension { get; public set; }
    public string ExecutablePath { get; public set; }
    public bool MapToAspNet { get; public set; }
    public string Verbs { get; public set; }
    public bool EnableScriptEngine { get; public set; }
    public bool VerifyFileExists { get; public set; }
    public string get_VirtualDirectoryName();
    public void set_VirtualDirectoryName(string value);
    public string get_Extension();
    public void set_Extension(string value);
    public string get_ExecutablePath();
    public void set_ExecutablePath(string value);
    public bool get_MapToAspNet();
    public void set_MapToAspNet(bool value);
    public string get_Verbs();
    public void set_Verbs(string value);
    public bool get_EnableScriptEngine();
    public void set_EnableScriptEngine(bool value);
    public bool get_VerifyFileExists();
    public void set_VerifyFileExists(bool value);
    public virtual bool Execute();
}
public class MSBuild.Community.Tasks.IIS.WebDirectorySetting : WebBase {
    private string mVirtualDirectoryName;
    private string settingName;
    private string settingValue;
    [RequiredAttribute]
public string VirtualDirectoryName { get; public set; }
    [RequiredAttribute]
public string SettingName { get; public set; }
    [OutputAttribute]
public string SettingValue { get; public set; }
    public string get_VirtualDirectoryName();
    public void set_VirtualDirectoryName(string value);
    public string get_SettingName();
    public void set_SettingName(string value);
    public string get_SettingValue();
    public void set_SettingValue(string value);
    public virtual bool Execute();
}
public class MSBuild.Community.Tasks.ILMerge : ToolTask {
    [CompilerGeneratedAttribute]
private ITaskItem[] <AllowDuplicateTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowZeroPeKind>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem <AttributeFile>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Closed>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CopyAttributes>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowDuplicateAttributes>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DebugInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DelaySign>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem <ExcludeFile>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem[] <InputAssemblies>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Internalize>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem <KeyFile>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem <LogFile>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem <OutputFile>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PublicKeyTokens>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem[] <SearchDirectories>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TargetPlatformVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem <TargetPlatformDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TargetKind>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <XmlDocumentation>k__BackingField;
    public ITaskItem[] AllowDuplicateTypes { get; public set; }
    public bool AllowZeroPeKind { get; public set; }
    public ITaskItem AttributeFile { get; public set; }
    public bool Closed { get; public set; }
    public bool CopyAttributes { get; public set; }
    public bool AllowDuplicateAttributes { get; public set; }
    public bool DebugInfo { get; public set; }
    public bool DelaySign { get; public set; }
    public ITaskItem ExcludeFile { get; public set; }
    [RequiredAttribute]
public ITaskItem[] InputAssemblies { get; public set; }
    public bool Internalize { get; public set; }
    public ITaskItem KeyFile { get; public set; }
    public ITaskItem LogFile { get; public set; }
    [RequiredAttribute]
public ITaskItem OutputFile { get; public set; }
    public bool PublicKeyTokens { get; public set; }
    public ITaskItem[] SearchDirectories { get; public set; }
    public string TargetPlatformVersion { get; public set; }
    public ITaskItem TargetPlatformDirectory { get; public set; }
    public string TargetKind { get; public set; }
    public string Version { get; public set; }
    public bool XmlDocumentation { get; public set; }
    protected string ToolName { get; }
    protected MessageImportance StandardOutputLoggingImportance { get; }
    protected MessageImportance StandardErrorLoggingImportance { get; }
    [CompilerGeneratedAttribute]
public ITaskItem[] get_AllowDuplicateTypes();
    [CompilerGeneratedAttribute]
public void set_AllowDuplicateTypes(ITaskItem[] value);
    [CompilerGeneratedAttribute]
public bool get_AllowZeroPeKind();
    [CompilerGeneratedAttribute]
public void set_AllowZeroPeKind(bool value);
    [CompilerGeneratedAttribute]
public ITaskItem get_AttributeFile();
    [CompilerGeneratedAttribute]
public void set_AttributeFile(ITaskItem value);
    [CompilerGeneratedAttribute]
public bool get_Closed();
    [CompilerGeneratedAttribute]
public void set_Closed(bool value);
    [CompilerGeneratedAttribute]
public bool get_CopyAttributes();
    [CompilerGeneratedAttribute]
public void set_CopyAttributes(bool value);
    [CompilerGeneratedAttribute]
public bool get_AllowDuplicateAttributes();
    [CompilerGeneratedAttribute]
public void set_AllowDuplicateAttributes(bool value);
    [CompilerGeneratedAttribute]
public bool get_DebugInfo();
    [CompilerGeneratedAttribute]
public void set_DebugInfo(bool value);
    [CompilerGeneratedAttribute]
public bool get_DelaySign();
    [CompilerGeneratedAttribute]
public void set_DelaySign(bool value);
    [CompilerGeneratedAttribute]
public ITaskItem get_ExcludeFile();
    [CompilerGeneratedAttribute]
public void set_ExcludeFile(ITaskItem value);
    [CompilerGeneratedAttribute]
public ITaskItem[] get_InputAssemblies();
    [CompilerGeneratedAttribute]
public void set_InputAssemblies(ITaskItem[] value);
    [CompilerGeneratedAttribute]
public bool get_Internalize();
    [CompilerGeneratedAttribute]
public void set_Internalize(bool value);
    [CompilerGeneratedAttribute]
public ITaskItem get_KeyFile();
    [CompilerGeneratedAttribute]
public void set_KeyFile(ITaskItem value);
    [CompilerGeneratedAttribute]
public ITaskItem get_LogFile();
    [CompilerGeneratedAttribute]
public void set_LogFile(ITaskItem value);
    [CompilerGeneratedAttribute]
public ITaskItem get_OutputFile();
    [CompilerGeneratedAttribute]
public void set_OutputFile(ITaskItem value);
    [CompilerGeneratedAttribute]
public bool get_PublicKeyTokens();
    [CompilerGeneratedAttribute]
public void set_PublicKeyTokens(bool value);
    [CompilerGeneratedAttribute]
public ITaskItem[] get_SearchDirectories();
    [CompilerGeneratedAttribute]
public void set_SearchDirectories(ITaskItem[] value);
    [CompilerGeneratedAttribute]
public string get_TargetPlatformVersion();
    [CompilerGeneratedAttribute]
public void set_TargetPlatformVersion(string value);
    [CompilerGeneratedAttribute]
public ITaskItem get_TargetPlatformDirectory();
    [CompilerGeneratedAttribute]
public void set_TargetPlatformDirectory(ITaskItem value);
    [CompilerGeneratedAttribute]
public string get_TargetKind();
    [CompilerGeneratedAttribute]
public void set_TargetKind(string value);
    [CompilerGeneratedAttribute]
public string get_Version();
    [CompilerGeneratedAttribute]
public void set_Version(string value);
    [CompilerGeneratedAttribute]
public bool get_XmlDocumentation();
    [CompilerGeneratedAttribute]
public void set_XmlDocumentation(bool value);
    protected virtual string get_ToolName();
    protected virtual string GenerateFullPathToTool();
    protected virtual string GenerateCommandLineCommands();
    protected virtual MessageImportance get_StandardOutputLoggingImportance();
    protected virtual MessageImportance get_StandardErrorLoggingImportance();
}
public class MSBuild.Community.Tasks.InnoSetup : ToolTask {
    private string _scriptFile;
    private string _outputFileName;
    private string _outputPath;
    private string _quiet;
    [RequiredAttribute]
public string ScriptFile { get; public set; }
    public string OutputFileName { get; public set; }
    public string OutputPath { get; public set; }
    public string Quiet { get; public set; }
    protected string ToolName { get; }
    protected MessageImportance StandardOutputLoggingImportance { get; }
    public string get_ScriptFile();
    public void set_ScriptFile(string value);
    public string get_OutputFileName();
    public void set_OutputFileName(string value);
    public string get_OutputPath();
    public void set_OutputPath(string value);
    public string get_Quiet();
    public void set_Quiet(string value);
    protected virtual string GenerateFullPathToTool();
    protected virtual string get_ToolName();
    protected virtual void LogToolCommand(string message);
    protected virtual MessageImportance get_StandardOutputLoggingImportance();
    protected virtual string GenerateCommandLineCommands();
    public virtual bool Execute();
}
public class MSBuild.Community.Tasks.Install.InstallAssembly : ToolTask {
    private Hashtable bag;
    private bool showCallStack;
    public ITaskItem[] AssemblyNames { get; public set; }
    public ITaskItem[] AssemblyFiles { get; public set; }
    public string LogFile { get; public set; }
    public bool ShowCallStack { get; public set; }
    protected bool IsUninstall { get; }
    protected string ToolName { get; }
    public ITaskItem[] get_AssemblyNames();
    public void set_AssemblyNames(ITaskItem[] value);
    public ITaskItem[] get_AssemblyFiles();
    public void set_AssemblyFiles(ITaskItem[] value);
    public string get_LogFile();
    public void set_LogFile(string value);
    public bool get_ShowCallStack();
    public void set_ShowCallStack(bool value);
    protected virtual bool get_IsUninstall();
    protected virtual string GenerateFullPathToTool();
    protected virtual string get_ToolName();
    protected virtual string GenerateCommandLineCommands();
}
public class MSBuild.Community.Tasks.Install.UninstallAssembly : InstallAssembly {
    protected bool IsUninstall { get; }
    protected virtual bool get_IsUninstall();
}
public class MSBuild.Community.Tasks.JavaScript.CssCompress : Task {
    private ITaskItem[] compressedFiles;
    private ITaskItem[] destinationFiles;
    private ITaskItem destinationFolder;
    private ITaskItem[] sourceFiles;
    [OutputAttribute]
public ITaskItem[] CompressedFiles { get; }
    [OutputAttribute]
public ITaskItem[] DestinationFiles { get; public set; }
    public ITaskItem DestinationFolder { get; public set; }
    [RequiredAttribute]
public ITaskItem[] SourceFiles { get; public set; }
    public ITaskItem[] get_CompressedFiles();
    public ITaskItem[] get_DestinationFiles();
    public void set_DestinationFiles(ITaskItem[] value);
    public ITaskItem get_DestinationFolder();
    public void set_DestinationFolder(ITaskItem value);
    public ITaskItem[] get_SourceFiles();
    public void set_SourceFiles(ITaskItem[] value);
    public virtual bool Execute();
    private string Compress(string source);
}
internal class MSBuild.Community.Tasks.JavaScript.CssCompressor : object {
    private string cssContent;
    public CssCompressor(string css);
    public static string Compress(string source);
    public static void Compress(TextReader reader, TextWriter writer);
    public string Compress();
    private void RemoveComments();
    private void Rgb2Hex();
    private void LongColorToHex();
    private void LongHexToColor();
    private void RemoveZeroMeasurements();
    private void SortCss();
    private void FontWeightTextToNumbers();
    private void ParseRules();
    private void RemoveSpace();
    private void CombineIdenticalSelectors();
    private void RemoveOverwrittenProperties();
    private void CombinePropsList();
    private void CombineProps();
    private void ReduceProp();
    private void ShortHex();
    private void CompressPaddingAndMargins();
    private void RemoveEmptyRules();
    private void CombineIdenticalRules();
}
internal class MSBuild.Community.Tasks.JavaScript.JavaScriptCompressor : object {
    private int aa;
    private int bb;
    private int lookahead;
    private TextReader reader;
    private TextWriter writer;
    private static int eof;
    private JavaScriptCompressor(TextReader reader, TextWriter writer);
    public static string Compress(string source);
    public static void Compress(TextReader reader, TextWriter writer);
    private void Compress();
    private int Get();
    private int Peek();
    private int Next();
    private void Action(int d);
    private void Write(int ch);
    private static bool IsAlphanum(int ch);
}
public class MSBuild.Community.Tasks.JavaScript.JSCompress : Task {
    private ITaskItem[] files;
    private string encodingName;
    private ITaskItem[] compressedFiles;
    [RequiredAttribute]
public ITaskItem[] Files { get; public set; }
    public string Encoding { get; public set; }
    [OutputAttribute]
public ITaskItem[] CompressedFiles { get; }
    public ITaskItem[] get_Files();
    public void set_Files(ITaskItem[] value);
    public string get_Encoding();
    public void set_Encoding(string value);
    public ITaskItem[] get_CompressedFiles();
    public virtual bool Execute();
}
public class MSBuild.Community.Tasks.Mail : Task {
    private String[] _attachments;
    private String[] _bcc;
    private String[] _cc;
    private string _body;
    private string _from;
    private bool _isBodyHtml;
    private string _priority;
    private string _subject;
    private string _smtpServer;
    private String[] _to;
    private string _username;
    private string _password;
    private bool _enableSsl;
    public String[] Attachments { get; public set; }
    public String[] Bcc { get; public set; }
    public String[] CC { get; public set; }
    public string Body { get; public set; }
    [RequiredAttribute]
public string From { get; public set; }
    public bool IsBodyHtml { get; public set; }
    public string Priority { get; public set; }
    [RequiredAttribute]
public string Subject { get; public set; }
    [RequiredAttribute]
public string SmtpServer { get; public set; }
    [RequiredAttribute]
public String[] To { get; public set; }
    public string Username { get; public set; }
    public string Password { get; public set; }
    public bool EnableSsl { get; public set; }
    public String[] get_Attachments();
    public void set_Attachments(String[] value);
    public String[] get_Bcc();
    public void set_Bcc(String[] value);
    public String[] get_CC();
    public void set_CC(String[] value);
    public string get_Body();
    public void set_Body(string value);
    public string get_From();
    public void set_From(string value);
    public bool get_IsBodyHtml();
    public void set_IsBodyHtml(bool value);
    public string get_Priority();
    public void set_Priority(string value);
    public string get_Subject();
    public void set_Subject(string value);
    public string get_SmtpServer();
    public void set_SmtpServer(string value);
    public String[] get_To();
    public void set_To(String[] value);
    public string get_Username();
    public void set_Username(string value);
    public string get_Password();
    public void set_Password(string value);
    public bool get_EnableSsl();
    public void set_EnableSsl(bool value);
    public virtual bool Execute();
}
public class MSBuild.Community.Tasks.Math.Add : MathBase {
    public virtual bool Execute();
}
public class MSBuild.Community.Tasks.Math.Divide : MathBase {
    private bool truncateResult;
    public bool TruncateResult { get; public set; }
    public bool get_TruncateResult();
    public void set_TruncateResult(bool value);
    public virtual bool Execute();
}
public abstract class MSBuild.Community.Tasks.Math.MathBase : Task {
    private String[] _numbers;
    private string _result;
    private string _numericFormat;
    [RequiredAttribute]
public String[] Numbers { get; public set; }
    [OutputAttribute]
public string Result { get; public set; }
    public string NumericFormat { get; public set; }
    public String[] get_Numbers();
    public void set_Numbers(String[] value);
    public string get_Result();
    public void set_Result(string value);
    public string get_NumericFormat();
    public void set_NumericFormat(string value);
    public virtual bool Execute();
    protected Decimal[] StringArrayToDecimalArray(String[] numbers);
}
public class MSBuild.Community.Tasks.Math.Modulo : MathBase {
    public virtual bool Execute();
}
public class MSBuild.Community.Tasks.Math.Multiple : MathBase {
    public virtual bool Execute();
}
public class MSBuild.Community.Tasks.Math.Subtract : MathBase {
    public virtual bool Execute();
}
public class MSBuild.Community.Tasks.Merge : Task {
    private static int bufferSize;
    private MergeModes mode;
    private ITaskItem[] sourceFiles;
    private ITaskItem destinationFile;
    public string Mode { get; public set; }
    [RequiredAttribute]
public ITaskItem[] SourceFiles { get; public set; }
    [RequiredAttribute]
public ITaskItem DestinationFile { get; public set; }
    public string get_Mode();
    public void set_Mode(string value);
    public ITaskItem[] get_SourceFiles();
    public void set_SourceFiles(ITaskItem[] value);
    public ITaskItem get_DestinationFile();
    public void set_DestinationFile(ITaskItem value);
    public virtual bool Execute();
    private void BinaryMerge();
    private void TextMerge();
    private void TextLineMerge();
}
public enum MSBuild.Community.Tasks.MergeModes : Enum {
    public int value__;
    public static MergeModes Binary;
    public static MergeModes Text;
    public static MergeModes TextLine;
}
public class MSBuild.Community.Tasks.MV : Task {
    private ITaskItem[] movedFiles;
    private ITaskItem[] destinationFiles;
    private ITaskItem destinationFolder;
    private ITaskItem[] sourceFiles;
    [OutputAttribute]
public ITaskItem[] MovedFiles { get; }
    [OutputAttribute]
public ITaskItem[] DestinationFiles { get; public set; }
    public ITaskItem DestinationFolder { get; public set; }
    [RequiredAttribute]
public ITaskItem[] SourceFiles { get; public set; }
    public ITaskItem[] get_MovedFiles();
    public ITaskItem[] get_DestinationFiles();
    public void set_DestinationFiles(ITaskItem[] value);
    public ITaskItem get_DestinationFolder();
    public void set_DestinationFolder(ITaskItem value);
    public ITaskItem[] get_SourceFiles();
    public void set_SourceFiles(ITaskItem[] value);
    public virtual bool Execute();
    private bool MoveFile(string sourceFile, string destinationFile);
    private bool PathsAreIdentical(string source, string destination);
}
public class MSBuild.Community.Tasks.NDoc : ToolTask {
    private string _documenter;
    private string _projectFilePath;
    private bool _verbose;
    private string _workingDirectory;
    [RequiredAttribute]
public string Documenter { get; public set; }
    [RequiredAttribute]
public string ProjectFilePath { get; public set; }
    public bool Verbose { get; public set; }
    public string WorkingDirectory { get; public set; }
    protected string ToolName { get; }
    protected MessageImportance StandardOutputLoggingImportance { get; }
    public string get_Documenter();
    public void set_Documenter(string value);
    public string get_ProjectFilePath();
    public void set_ProjectFilePath(string value);
    public bool get_Verbose();
    public void set_Verbose(bool value);
    public string get_WorkingDirectory();
    public void set_WorkingDirectory(string value);
    protected virtual string GenerateCommandLineCommands();
    private void CheckToolPath();
    protected virtual string GenerateFullPathToTool();
    protected virtual void LogToolCommand(string message);
    protected virtual string get_ToolName();
    protected virtual MessageImportance get_StandardOutputLoggingImportance();
    protected virtual string GetWorkingDirectory();
}
public class MSBuild.Community.Tasks.Net.HttpRequest : Task {
    [CompilerGeneratedAttribute]
private string <Url>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EnsureResponseContains>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <FailOnNon2xxResponse>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Method>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Username>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Password>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ReadRequestFrom>k__BackingField;
    [CompilerGeneratedAttribute]
private string <WriteResponseTo>k__BackingField;
    [RequiredAttribute]
public string Url { get; public set; }
    public string EnsureResponseContains { get; public set; }
    public bool FailOnNon2xxResponse { get; public set; }
    public string Method { get; public set; }
    public string Username { get; public set; }
    public string Password { get; public set; }
    public string ReadRequestFrom { get; public set; }
    public string WriteResponseTo { get; public set; }
    private bool CheckResponseContents { get; }
    private bool ReadRequestFromFile { get; }
    private bool WriteResponseToFile { get; }
    [CompilerGeneratedAttribute]
public string get_Url();
    [CompilerGeneratedAttribute]
public void set_Url(string value);
    [CompilerGeneratedAttribute]
public string get_EnsureResponseContains();
    [CompilerGeneratedAttribute]
public void set_EnsureResponseContains(string value);
    [CompilerGeneratedAttribute]
public bool get_FailOnNon2xxResponse();
    [CompilerGeneratedAttribute]
public void set_FailOnNon2xxResponse(bool value);
    [CompilerGeneratedAttribute]
public string get_Method();
    [CompilerGeneratedAttribute]
public void set_Method(string value);
    [CompilerGeneratedAttribute]
public string get_Username();
    [CompilerGeneratedAttribute]
public void set_Username(string value);
    [CompilerGeneratedAttribute]
public string get_Password();
    [CompilerGeneratedAttribute]
public void set_Password(string value);
    [CompilerGeneratedAttribute]
public string get_ReadRequestFrom();
    [CompilerGeneratedAttribute]
public void set_ReadRequestFrom(string value);
    [CompilerGeneratedAttribute]
public string get_WriteResponseTo();
    [CompilerGeneratedAttribute]
public void set_WriteResponseTo(string value);
    private bool get_CheckResponseContents();
    private bool get_ReadRequestFromFile();
    private bool get_WriteResponseToFile();
    public virtual bool Execute();
}
public abstract class MSBuild.Community.Tasks.NuGet.NuGetBase : ToolTask {
    [CompilerGeneratedAttribute]
private string <WorkingDirectory>k__BackingField;
    public string WorkingDirectory { get; public set; }
    protected string ToolName { get; }
    protected MessageImportance StandardOutputLoggingImportance { get; }
    protected MessageImportance StandardErrorLoggingImportance { get; }
    [CompilerGeneratedAttribute]
public string get_WorkingDirectory();
    [CompilerGeneratedAttribute]
public void set_WorkingDirectory(string value);
    protected virtual string GenerateFullPathToTool();
    protected virtual string get_ToolName();
    protected virtual MessageImportance get_StandardOutputLoggingImportance();
    protected virtual MessageImportance get_StandardErrorLoggingImportance();
    protected virtual string GetWorkingDirectory();
}
public class MSBuild.Community.Tasks.NuGet.NuGetDelete : NuGetBase {
    [CompilerGeneratedAttribute]
private string <Package>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Source>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ApiKey>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ConfigFile>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Verbosity>k__BackingField;
    [RequiredAttribute]
public string Package { get; public set; }
    [RequiredAttribute]
public string Version { get; public set; }
    public string Source { get; public set; }
    public string ApiKey { get; public set; }
    public string ConfigFile { get; public set; }
    public string Verbosity { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Package();
    [CompilerGeneratedAttribute]
public void set_Package(string value);
    [CompilerGeneratedAttribute]
public string get_Version();
    [CompilerGeneratedAttribute]
public void set_Version(string value);
    [CompilerGeneratedAttribute]
public string get_Source();
    [CompilerGeneratedAttribute]
public void set_Source(string value);
    [CompilerGeneratedAttribute]
public string get_ApiKey();
    [CompilerGeneratedAttribute]
public void set_ApiKey(string value);
    [CompilerGeneratedAttribute]
public string get_ConfigFile();
    [CompilerGeneratedAttribute]
public void set_ConfigFile(string value);
    [CompilerGeneratedAttribute]
public string get_Verbosity();
    [CompilerGeneratedAttribute]
public void set_Verbosity(string value);
    protected virtual string GenerateCommandLineCommands();
}
public class MSBuild.Community.Tasks.NuGet.NuGetInstall : NuGetBase {
    [CompilerGeneratedAttribute]
private string <Package>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Source>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OutputDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ExcludeVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Prerelease>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <NoCache>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SolutionDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ConfigFile>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Verbosity>k__BackingField;
    [RequiredAttribute]
public string Package { get; public set; }
    public string Source { get; public set; }
    public string OutputDirectory { get; public set; }
    public string Version { get; public set; }
    public bool ExcludeVersion { get; public set; }
    public bool Prerelease { get; public set; }
    public bool NoCache { get; public set; }
    public string SolutionDirectory { get; public set; }
    public string ConfigFile { get; public set; }
    public string Verbosity { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Package();
    [CompilerGeneratedAttribute]
public void set_Package(string value);
    [CompilerGeneratedAttribute]
public string get_Source();
    [CompilerGeneratedAttribute]
public void set_Source(string value);
    [CompilerGeneratedAttribute]
public string get_OutputDirectory();
    [CompilerGeneratedAttribute]
public void set_OutputDirectory(string value);
    [CompilerGeneratedAttribute]
public string get_Version();
    [CompilerGeneratedAttribute]
public void set_Version(string value);
    [CompilerGeneratedAttribute]
public bool get_ExcludeVersion();
    [CompilerGeneratedAttribute]
public void set_ExcludeVersion(bool value);
    [CompilerGeneratedAttribute]
public bool get_Prerelease();
    [CompilerGeneratedAttribute]
public void set_Prerelease(bool value);
    [CompilerGeneratedAttribute]
public bool get_NoCache();
    [CompilerGeneratedAttribute]
public void set_NoCache(bool value);
    [CompilerGeneratedAttribute]
public string get_SolutionDirectory();
    [CompilerGeneratedAttribute]
public void set_SolutionDirectory(string value);
    [CompilerGeneratedAttribute]
public string get_ConfigFile();
    [CompilerGeneratedAttribute]
public void set_ConfigFile(string value);
    [CompilerGeneratedAttribute]
public string get_Verbosity();
    [CompilerGeneratedAttribute]
public void set_Verbosity(string value);
    protected virtual string GenerateCommandLineCommands();
}
public class MSBuild.Community.Tasks.NuGet.NuGetPack : NuGetBase {
    private static Regex _outputFilePathParse;
    [CompilerGeneratedAttribute]
private ITaskItem <File>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OutputDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Suffix>k__BackingField;
    [CompilerGeneratedAttribute]
private string <BasePath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Exclude>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ExcludeEmptyDirectories>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Verbose>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Verbosity>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Build>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Tool>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Symbols>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Properties>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <NoDefaultExcludes>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <NoPackageAnalysis>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludeReferencedProjects>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MinClientVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ForceEnglishOutput>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OutputFilePath>k__BackingField;
    [RequiredAttribute]
public ITaskItem File { get; public set; }
    public string OutputDirectory { get; public set; }
    public string Version { get; public set; }
    public string Suffix { get; public set; }
    public string BasePath { get; public set; }
    public string Exclude { get; public set; }
    public bool ExcludeEmptyDirectories { get; public set; }
    public bool Verbose { get; public set; }
    public string Verbosity { get; public set; }
    public bool Build { get; public set; }
    public bool Tool { get; public set; }
    public bool Symbols { get; public set; }
    public string Properties { get; public set; }
    public bool NoDefaultExcludes { get; public set; }
    public bool NoPackageAnalysis { get; public set; }
    public bool IncludeReferencedProjects { get; public set; }
    public string MinClientVersion { get; public set; }
    public bool ForceEnglishOutput { get; public set; }
    [OutputAttribute]
public string OutputFilePath { get; public set; }
    private static NuGetPack();
    [CompilerGeneratedAttribute]
public ITaskItem get_File();
    [CompilerGeneratedAttribute]
public void set_File(ITaskItem value);
    [CompilerGeneratedAttribute]
public string get_OutputDirectory();
    [CompilerGeneratedAttribute]
public void set_OutputDirectory(string value);
    [CompilerGeneratedAttribute]
public string get_Version();
    [CompilerGeneratedAttribute]
public void set_Version(string value);
    [CompilerGeneratedAttribute]
public string get_Suffix();
    [CompilerGeneratedAttribute]
public void set_Suffix(string value);
    [CompilerGeneratedAttribute]
public string get_BasePath();
    [CompilerGeneratedAttribute]
public void set_BasePath(string value);
    [CompilerGeneratedAttribute]
public string get_Exclude();
    [CompilerGeneratedAttribute]
public void set_Exclude(string value);
    [CompilerGeneratedAttribute]
public bool get_ExcludeEmptyDirectories();
    [CompilerGeneratedAttribute]
public void set_ExcludeEmptyDirectories(bool value);
    [CompilerGeneratedAttribute]
public bool get_Verbose();
    [CompilerGeneratedAttribute]
public void set_Verbose(bool value);
    [CompilerGeneratedAttribute]
public string get_Verbosity();
    [CompilerGeneratedAttribute]
public void set_Verbosity(string value);
    [CompilerGeneratedAttribute]
public bool get_Build();
    [CompilerGeneratedAttribute]
public void set_Build(bool value);
    [CompilerGeneratedAttribute]
public bool get_Tool();
    [CompilerGeneratedAttribute]
public void set_Tool(bool value);
    [CompilerGeneratedAttribute]
public bool get_Symbols();
    [CompilerGeneratedAttribute]
public void set_Symbols(bool value);
    [CompilerGeneratedAttribute]
public string get_Properties();
    [CompilerGeneratedAttribute]
public void set_Properties(string value);
    [CompilerGeneratedAttribute]
public bool get_NoDefaultExcludes();
    [CompilerGeneratedAttribute]
public void set_NoDefaultExcludes(bool value);
    [CompilerGeneratedAttribute]
public bool get_NoPackageAnalysis();
    [CompilerGeneratedAttribute]
public void set_NoPackageAnalysis(bool value);
    [CompilerGeneratedAttribute]
public bool get_IncludeReferencedProjects();
    [CompilerGeneratedAttribute]
public void set_IncludeReferencedProjects(bool value);
    [CompilerGeneratedAttribute]
public string get_MinClientVersion();
    [CompilerGeneratedAttribute]
public void set_MinClientVersion(string value);
    [CompilerGeneratedAttribute]
public bool get_ForceEnglishOutput();
    [CompilerGeneratedAttribute]
public void set_ForceEnglishOutput(bool value);
    [CompilerGeneratedAttribute]
public string get_OutputFilePath();
    [CompilerGeneratedAttribute]
public void set_OutputFilePath(string value);
    protected virtual string GenerateCommandLineCommands();
    protected virtual void LogEventsFromTextOutput(string singleLine, MessageImportance messageImportance);
}
public class MSBuild.Community.Tasks.NuGet.NuGetPush : NuGetBase {
    [CompilerGeneratedAttribute]
private ITaskItem <File>k__BackingField;
    [CompilerGeneratedAttribute]
private string <APIKey>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ConfigFile>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Source>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CreateOnly>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Verbosity>k__BackingField;
    [RequiredAttribute]
public ITaskItem File { get; public set; }
    public string APIKey { get; public set; }
    public string ConfigFile { get; public set; }
    public string Source { get; public set; }
    public bool CreateOnly { get; public set; }
    public string Verbosity { get; public set; }
    [CompilerGeneratedAttribute]
public ITaskItem get_File();
    [CompilerGeneratedAttribute]
public void set_File(ITaskItem value);
    [CompilerGeneratedAttribute]
public string get_APIKey();
    [CompilerGeneratedAttribute]
public void set_APIKey(string value);
    [CompilerGeneratedAttribute]
public string get_ConfigFile();
    [CompilerGeneratedAttribute]
public void set_ConfigFile(string value);
    [CompilerGeneratedAttribute]
public string get_Source();
    [CompilerGeneratedAttribute]
public void set_Source(string value);
    [CompilerGeneratedAttribute]
public bool get_CreateOnly();
    [CompilerGeneratedAttribute]
public void set_CreateOnly(bool value);
    [CompilerGeneratedAttribute]
public string get_Verbosity();
    [CompilerGeneratedAttribute]
public void set_Verbosity(string value);
    protected virtual string GenerateCommandLineCommands();
}
public class MSBuild.Community.Tasks.NuGet.NuGetRestore : NuGetBase {
    [CompilerGeneratedAttribute]
private string <Solution>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Source>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PackagesDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DisableParallelProcessing>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <NoCache>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SolutionDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ConfigFile>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Verbosity>k__BackingField;
    [RequiredAttribute]
public string Solution { get; public set; }
    public string Source { get; public set; }
    public string PackagesDirectory { get; public set; }
    public bool DisableParallelProcessing { get; public set; }
    public bool NoCache { get; public set; }
    public string SolutionDirectory { get; public set; }
    public string ConfigFile { get; public set; }
    public string Verbosity { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Solution();
    [CompilerGeneratedAttribute]
public void set_Solution(string value);
    [CompilerGeneratedAttribute]
public string get_Source();
    [CompilerGeneratedAttribute]
public void set_Source(string value);
    [CompilerGeneratedAttribute]
public string get_PackagesDirectory();
    [CompilerGeneratedAttribute]
public void set_PackagesDirectory(string value);
    [CompilerGeneratedAttribute]
public bool get_DisableParallelProcessing();
    [CompilerGeneratedAttribute]
public void set_DisableParallelProcessing(bool value);
    [CompilerGeneratedAttribute]
public bool get_NoCache();
    [CompilerGeneratedAttribute]
public void set_NoCache(bool value);
    [CompilerGeneratedAttribute]
public string get_SolutionDirectory();
    [CompilerGeneratedAttribute]
public void set_SolutionDirectory(string value);
    [CompilerGeneratedAttribute]
public string get_ConfigFile();
    [CompilerGeneratedAttribute]
public void set_ConfigFile(string value);
    [CompilerGeneratedAttribute]
public string get_Verbosity();
    [CompilerGeneratedAttribute]
public void set_Verbosity(string value);
    protected virtual string GenerateCommandLineCommands();
}
public class MSBuild.Community.Tasks.NuGet.NuGetUpdate : NuGetBase {
    [CompilerGeneratedAttribute]
private string <Package>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Source>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OutputDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RepositoryPath>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Safe>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Self>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Prerelease>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ConfigFile>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FileConflictAction>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Verbosity>k__BackingField;
    [RequiredAttribute]
public string Package { get; public set; }
    public string Version { get; public set; }
    public string Source { get; public set; }
    public string OutputDirectory { get; public set; }
    public string RepositoryPath { get; public set; }
    public bool Safe { get; public set; }
    public bool Self { get; public set; }
    public bool Prerelease { get; public set; }
    public string ConfigFile { get; public set; }
    public string FileConflictAction { get; public set; }
    public string Verbosity { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Package();
    [CompilerGeneratedAttribute]
public void set_Package(string value);
    [CompilerGeneratedAttribute]
public string get_Version();
    [CompilerGeneratedAttribute]
public void set_Version(string value);
    [CompilerGeneratedAttribute]
public string get_Source();
    [CompilerGeneratedAttribute]
public void set_Source(string value);
    [CompilerGeneratedAttribute]
public string get_OutputDirectory();
    [CompilerGeneratedAttribute]
public void set_OutputDirectory(string value);
    [CompilerGeneratedAttribute]
public string get_RepositoryPath();
    [CompilerGeneratedAttribute]
public void set_RepositoryPath(string value);
    [CompilerGeneratedAttribute]
public bool get_Safe();
    [CompilerGeneratedAttribute]
public void set_Safe(bool value);
    [CompilerGeneratedAttribute]
public bool get_Self();
    [CompilerGeneratedAttribute]
public void set_Self(bool value);
    [CompilerGeneratedAttribute]
public bool get_Prerelease();
    [CompilerGeneratedAttribute]
public void set_Prerelease(bool value);
    [CompilerGeneratedAttribute]
public string get_ConfigFile();
    [CompilerGeneratedAttribute]
public void set_ConfigFile(string value);
    [CompilerGeneratedAttribute]
public string get_FileConflictAction();
    [CompilerGeneratedAttribute]
public void set_FileConflictAction(string value);
    [CompilerGeneratedAttribute]
public string get_Verbosity();
    [CompilerGeneratedAttribute]
public void set_Verbosity(string value);
    protected virtual string GenerateCommandLineCommands();
}
public class MSBuild.Community.Tasks.NUnit : ToolTask {
    public static string DEFAULT_NUNIT_DIRECTORY;
    private static string InstallDirKey;
    private ITaskItem[] _assemblies;
    private string _includeCategory;
    private string _excludeCategory;
    private string _fixture;
    private string _xsltTransformFile;
    private string _outputXmlFile;
    private string _errorOutputFile;
    private string _textOutputFile;
    private string _workingDirectory;
    private bool _disableShadowCopy;
    private string _projectConfiguration;
    private Nullable`1<bool> _testInNewThread;
    private bool _force32Bit;
    private string _framework;
    private bool _showLabels;
    private string _process;
    private string _domain;
    private string _apartment;
    [RequiredAttribute]
public ITaskItem[] Assemblies { get; public set; }
    public string IncludeCategory { get; public set; }
    public string ExcludeCategory { get; public set; }
    public string Fixture { get; public set; }
    public string XsltTransformFile { get; public set; }
    public string OutputXmlFile { get; public set; }
    public string ErrorOutputFile { get; public set; }
    public string TextOutputFile { get; public set; }
    public string WorkingDirectory { get; public set; }
    public bool DisableShadowCopy { get; public set; }
    public string ProjectConfiguration { get; public set; }
    public bool TestInNewThread { get; public set; }
    public bool Force32Bit { get; public set; }
    public string Framework { get; public set; }
    public bool ShowLabels { get; public set; }
    public string Process { get; public set; }
    public string Domain { get; public set; }
    public string Apartment { get; public set; }
    protected string ToolName { get; }
    protected MessageImportance StandardOutputLoggingImportance { get; }
    public ITaskItem[] get_Assemblies();
    public void set_Assemblies(ITaskItem[] value);
    public string get_IncludeCategory();
    public void set_IncludeCategory(string value);
    public string get_ExcludeCategory();
    public void set_ExcludeCategory(string value);
    public string get_Fixture();
    public void set_Fixture(string value);
    public string get_XsltTransformFile();
    public void set_XsltTransformFile(string value);
    public string get_OutputXmlFile();
    public void set_OutputXmlFile(string value);
    public string get_ErrorOutputFile();
    public void set_ErrorOutputFile(string value);
    public string get_TextOutputFile();
    public void set_TextOutputFile(string value);
    public string get_WorkingDirectory();
    public void set_WorkingDirectory(string value);
    public bool get_DisableShadowCopy();
    public void set_DisableShadowCopy(bool value);
    public string get_ProjectConfiguration();
    public void set_ProjectConfiguration(string value);
    public bool get_TestInNewThread();
    public void set_TestInNewThread(bool value);
    public bool get_Force32Bit();
    public void set_Force32Bit(bool value);
    public string get_Framework();
    public void set_Framework(string value);
    public bool get_ShowLabels();
    public void set_ShowLabels(bool value);
    public string get_Process();
    public void set_Process(string value);
    public string get_Domain();
    public void set_Domain(string value);
    public string get_Apartment();
    public void set_Apartment(string value);
    protected virtual string GenerateCommandLineCommands();
    private void CheckToolPath();
    protected virtual string GenerateFullPathToTool();
    protected virtual void LogToolCommand(string message);
    protected virtual string get_ToolName();
    protected virtual MessageImportance get_StandardOutputLoggingImportance();
    protected virtual string GetWorkingDirectory();
}
public class MSBuild.Community.Tasks.NUnit3 : ToolTask {
    public static string DEFAULT_NUNIT_DIRECTORY;
    private static string InstallDirKey;
    private ITaskItem[] _assemblies;
    private string _outputXmlFile;
    private string _errorOutputFile;
    private string _textOutputFile;
    private string _workingDirectory;
    private bool _enableShadowCopy;
    private string _projectConfiguration;
    private Nullable`1<bool> _testInNewThread;
    private bool _force32Bit;
    private string _framework;
    private string _showLabels;
    private string _process;
    private string _domain;
    private string _apartment;
    private string _where;
    private string _timeout;
    private string _workers;
    private string _trace;
    private bool _noHeader;
    private bool _noColor;
    private bool _verbose;
    [RequiredAttribute]
public ITaskItem[] Assemblies { get; public set; }
    public string OutputXmlFile { get; public set; }
    public string ErrorOutputFile { get; public set; }
    public string TextOutputFile { get; public set; }
    public string WorkingDirectory { get; public set; }
    public bool EnableShadowCopy { get; public set; }
    public string ProjectConfiguration { get; public set; }
    public bool TestInNewThread { get; public set; }
    public bool Force32Bit { get; public set; }
    public string Framework { get; public set; }
    public string ShowLabels { get; public set; }
    public string Process { get; public set; }
    public string Domain { get; public set; }
    public string Apartment { get; public set; }
    public string Where { get; public set; }
    public string TestTimeout { get; public set; }
    public string Workers { get; public set; }
    public string InternalTrace { get; public set; }
    public bool NoHeader { get; public set; }
    public bool NoColor { get; public set; }
    public bool Verbose { get; public set; }
    protected string ToolName { get; }
    protected MessageImportance StandardOutputLoggingImportance { get; }
    public ITaskItem[] get_Assemblies();
    public void set_Assemblies(ITaskItem[] value);
    public string get_OutputXmlFile();
    public void set_OutputXmlFile(string value);
    public string get_ErrorOutputFile();
    public void set_ErrorOutputFile(string value);
    public string get_TextOutputFile();
    public void set_TextOutputFile(string value);
    public string get_WorkingDirectory();
    public void set_WorkingDirectory(string value);
    public bool get_EnableShadowCopy();
    public void set_EnableShadowCopy(bool value);
    public string get_ProjectConfiguration();
    public void set_ProjectConfiguration(string value);
    public bool get_TestInNewThread();
    public void set_TestInNewThread(bool value);
    public bool get_Force32Bit();
    public void set_Force32Bit(bool value);
    public string get_Framework();
    public void set_Framework(string value);
    public string get_ShowLabels();
    public void set_ShowLabels(string value);
    public string get_Process();
    public void set_Process(string value);
    public string get_Domain();
    public void set_Domain(string value);
    public string get_Apartment();
    public void set_Apartment(string value);
    public string get_Where();
    public void set_Where(string value);
    public string get_TestTimeout();
    public void set_TestTimeout(string value);
    public string get_Workers();
    public void set_Workers(string value);
    public string get_InternalTrace();
    public void set_InternalTrace(string value);
    public bool get_NoHeader();
    public void set_NoHeader(bool value);
    public bool get_NoColor();
    public void set_NoColor(bool value);
    public bool get_Verbose();
    public void set_Verbose(bool value);
    protected virtual string GenerateCommandLineCommands();
    private void CheckToolPath();
    protected virtual string GenerateFullPathToTool();
    protected virtual void LogToolCommand(string message);
    protected virtual string get_ToolName();
    protected virtual MessageImportance get_StandardOutputLoggingImportance();
    protected virtual string GetWorkingDirectory();
}
public class MSBuild.Community.Tasks.Oracle.AddTnsName : Task {
    private IRegistry registry;
    private IFilesSystem fileSystem;
    private static string ORACLE_REGISTRY;
    private static string ORACLE_HOME;
    private static string TNSNAMES_PATH;
    private string tnsNamesFile;
    private string originalFileText;
    private string modifiedFile;
    private string entryName;
    private string modifiedFileText;
    private string entryText;
    private bool allowUpdates;
    unknown string TnsNamesFile {public set; }
    [OutputAttribute]
public string OriginalFileText { get; }
    [OutputAttribute]
public string ModifiedFile { get; }
    [RequiredAttribute]
unknown string EntryName {public set; }
    [OutputAttribute]
public string ModifiedFileText { get; }
    unknown string EntryText {public set; }
    unknown bool AllowUpdates {public set; }
    public AddTnsName(IRegistry registry, IFilesSystem fileSystem);
    public virtual bool Execute();
    public void set_TnsNamesFile(string value);
    public string get_OriginalFileText();
    public string get_ModifiedFile();
    public void set_EntryName(string value);
    public string get_ModifiedFileText();
    public void set_EntryText(string value);
    public void set_AllowUpdates(bool value);
    public string GetEffectivePathToTnsNamesFile();
}
public class MSBuild.Community.Tasks.Oracle.TnsEntry : object {
    private int startPosition;
    private int length;
    public int StartPosition { get; }
    public int Length { get; }
    public TnsEntry(int startPosition, int length);
    public int get_StartPosition();
    public int get_Length();
}
public class MSBuild.Community.Tasks.Oracle.TnsParser : object {
    private string content;
    private static string FIND_ENTRY_REGEX_FORMAT;
    public TnsParser(string content);
    public TnsEntry FindEntry(string name);
}
internal static class MSBuild.Community.Tasks.PathUtil : object {
    private static Char[] _invalidPathChars;
    private static Char[] _invalidFileChars;
    private static PathUtil();
    public static string RelativePathTo(string fromDirectory, string toPath);
    public static bool IsPathValid(string path);
}
public class MSBuild.Community.Tasks.Prompt : Task {
    private string text;
    private string userInput;
    public string Text { get; public set; }
    [OutputAttribute]
public string UserInput { get; }
    public string get_Text();
    public void set_Text(string value);
    public string get_UserInput();
    public virtual bool Execute();
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class MSBuild.Community.Tasks.Properties.Resources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string ActiveDirectoryLookupException { get; }
    internal static string AttribDirectory { get; }
    internal static string AttribFile { get; }
    internal static string CouldNotConnectToRemoteServer { get; }
    internal static string CouldNotResolveServerHostName { get; }
    internal static string CreatingDirectory { get; }
    internal static string ExactlyOneTypeOfDestination { get; }
    internal static string FileNotFound { get; }
    internal static string FtpLocalNotFound { get; }
    internal static string FtpPercentComplete { get; }
    internal static string FtpTransfered { get; }
    internal static string FtpUploadComplete { get; }
    internal static string FtpUploading { get; }
    internal static string FtpUriInvalid { get; }
    internal static string JSCompressCompressed { get; }
    internal static string JSCompressCompressing { get; }
    internal static string JSCompressWriting { get; }
    internal static string MailEmailing { get; }
    internal static string MathNotNumber { get; }
    internal static string MergeComplete { get; }
    internal static string MergeCompleteNoSourceFiles { get; }
    internal static string MergingFile { get; }
    internal static string MoveError { get; }
    internal static string MoveFileComment { get; }
    internal static string NUnitNotFound { get; }
    internal static string OracleHomeCheck { get; }
    internal static string ParameterNotUsed { get; }
    internal static string ParameterRequired { get; }
    internal static string RegistryRead { get; }
    internal static string RegistryWrite { get; }
    internal static string ServiceCannotContinue { get; }
    internal static string ServiceCannotPause { get; }
    internal static string ServiceCannotStop { get; }
    internal static string ServiceContinued { get; }
    internal static string ServiceContinuing { get; }
    internal static string ServiceNotFound { get; }
    internal static string ServiceNotPaused { get; }
    internal static string ServiceNotStarted { get; }
    internal static string ServicePaused { get; }
    internal static string ServicePausing { get; }
    internal static string ServiceStarted { get; }
    internal static string ServiceStarting { get; }
    internal static string ServiceStatus { get; }
    internal static string ServiceStopped { get; }
    internal static string ServiceStopping { get; }
    internal static string SolutionNotFound { get; }
    internal static string SvnLocalPathNotWorkCopy { get; }
    internal static string TaskDestinationIsDirectory { get; }
    internal static string TaskNeedsDestination { get; }
    internal static string TaskSourceIsDirectory { get; }
    internal static string TimeFormatException { get; }
    internal static string TimeGettingCurrentDate { get; }
    internal static string TnsnameAdded { get; }
    internal static string TnsNamesFileCheck { get; }
    internal static string TnsNamesFileNotFound { get; }
    internal static string TnsnameUpdateAborted { get; }
    internal static string TnsnameUpdated { get; }
    internal static string TwoVectorsMustHaveSameLength { get; }
    internal static string UnzipExtracted { get; }
    internal static string UnzipFileToDirectory { get; }
    internal static string UnzipSuccessfully { get; }
    internal static string VaultAddFileCommitFailed { get; }
    internal static string VaultAddFileCommitSucceeded { get; }
    internal static string VaultAddFilesException { get; }
    internal static string VaultCheckinFileException { get; }
    internal static string VaultCheckinFileNotFoundException { get; }
    internal static string VaultCheckinFolderException { get; }
    internal static string VaultCheckinSuccessful { get; }
    internal static string VaultCheckoutSuccessful { get; }
    internal static string VaultDiskFileDoesNotExist { get; }
    internal static string VaultFileAddedToChangeSet { get; }
    internal static string VaultFolderAddedToChangeSet { get; }
    internal static string VaultIncorrectParameters { get; }
    internal static string VaultLoginFailed { get; }
    internal static string VaultPathValidationException { get; }
    internal static string VaultRepositorySelectionFailure { get; }
    internal static string VaultResourceNotFound { get; }
    internal static string VaultSetNewWorkingFolder { get; }
    internal static string VaultTreeCacheFailure { get; }
    internal static string VaultUndoCheckoutSuccessful { get; }
    internal static string VaultUrlRequired { get; }
    internal static string VaultUsernameRequired { get; }
    internal static string VaultWorkingFolderCleared { get; }
    internal static string VaultWorkingFolderRestored { get; }
    internal static string VersionFileNotFound { get; }
    internal static string VersionModifiedValue { get; }
    internal static string VersionOriginalValue { get; }
    internal static string VersionRead { get; }
    internal static string VersionReadException { get; }
    internal static string VersionWriteException { get; }
    internal static string VersionWrote { get; }
    internal static string WebDirectoryInvalidDirectory { get; }
    internal static string WebDirectoryScriptMapUpdate { get; }
    internal static string WebDirectorySettingInvalidSetting { get; }
    internal static string WebDirectorySettingStatusRead { get; }
    internal static string WebDirectorySettingStatusSet { get; }
    internal static string XmlReadDocument { get; }
    internal static string XmlReadNodes { get; }
    internal static string XmlReadResult { get; }
    internal static string XmlUpdateDocument { get; }
    internal static string XmlUpdateNodes { get; }
    internal static string XmlUpdateResult { get; }
    internal static string XsltAddingParameter { get; }
    internal static string XsltAddingRootAttribute { get; }
    internal static string XsltCreatingRootTag { get; }
    internal static string XsltNoInputFiles { get; }
    internal static string XsltNoRootTag { get; }
    internal static string ZipAdded { get; }
    internal static string ZipCreating { get; }
    internal static string ZipFileNotFound { get; }
    internal static string ZipSuccessfully { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_ActiveDirectoryLookupException();
    internal static string get_AttribDirectory();
    internal static string get_AttribFile();
    internal static string get_CouldNotConnectToRemoteServer();
    internal static string get_CouldNotResolveServerHostName();
    internal static string get_CreatingDirectory();
    internal static string get_ExactlyOneTypeOfDestination();
    internal static string get_FileNotFound();
    internal static string get_FtpLocalNotFound();
    internal static string get_FtpPercentComplete();
    internal static string get_FtpTransfered();
    internal static string get_FtpUploadComplete();
    internal static string get_FtpUploading();
    internal static string get_FtpUriInvalid();
    internal static string get_JSCompressCompressed();
    internal static string get_JSCompressCompressing();
    internal static string get_JSCompressWriting();
    internal static string get_MailEmailing();
    internal static string get_MathNotNumber();
    internal static string get_MergeComplete();
    internal static string get_MergeCompleteNoSourceFiles();
    internal static string get_MergingFile();
    internal static string get_MoveError();
    internal static string get_MoveFileComment();
    internal static string get_NUnitNotFound();
    internal static string get_OracleHomeCheck();
    internal static string get_ParameterNotUsed();
    internal static string get_ParameterRequired();
    internal static string get_RegistryRead();
    internal static string get_RegistryWrite();
    internal static string get_ServiceCannotContinue();
    internal static string get_ServiceCannotPause();
    internal static string get_ServiceCannotStop();
    internal static string get_ServiceContinued();
    internal static string get_ServiceContinuing();
    internal static string get_ServiceNotFound();
    internal static string get_ServiceNotPaused();
    internal static string get_ServiceNotStarted();
    internal static string get_ServicePaused();
    internal static string get_ServicePausing();
    internal static string get_ServiceStarted();
    internal static string get_ServiceStarting();
    internal static string get_ServiceStatus();
    internal static string get_ServiceStopped();
    internal static string get_ServiceStopping();
    internal static string get_SolutionNotFound();
    internal static string get_SvnLocalPathNotWorkCopy();
    internal static string get_TaskDestinationIsDirectory();
    internal static string get_TaskNeedsDestination();
    internal static string get_TaskSourceIsDirectory();
    internal static string get_TimeFormatException();
    internal static string get_TimeGettingCurrentDate();
    internal static string get_TnsnameAdded();
    internal static string get_TnsNamesFileCheck();
    internal static string get_TnsNamesFileNotFound();
    internal static string get_TnsnameUpdateAborted();
    internal static string get_TnsnameUpdated();
    internal static string get_TwoVectorsMustHaveSameLength();
    internal static string get_UnzipExtracted();
    internal static string get_UnzipFileToDirectory();
    internal static string get_UnzipSuccessfully();
    internal static string get_VaultAddFileCommitFailed();
    internal static string get_VaultAddFileCommitSucceeded();
    internal static string get_VaultAddFilesException();
    internal static string get_VaultCheckinFileException();
    internal static string get_VaultCheckinFileNotFoundException();
    internal static string get_VaultCheckinFolderException();
    internal static string get_VaultCheckinSuccessful();
    internal static string get_VaultCheckoutSuccessful();
    internal static string get_VaultDiskFileDoesNotExist();
    internal static string get_VaultFileAddedToChangeSet();
    internal static string get_VaultFolderAddedToChangeSet();
    internal static string get_VaultIncorrectParameters();
    internal static string get_VaultLoginFailed();
    internal static string get_VaultPathValidationException();
    internal static string get_VaultRepositorySelectionFailure();
    internal static string get_VaultResourceNotFound();
    internal static string get_VaultSetNewWorkingFolder();
    internal static string get_VaultTreeCacheFailure();
    internal static string get_VaultUndoCheckoutSuccessful();
    internal static string get_VaultUrlRequired();
    internal static string get_VaultUsernameRequired();
    internal static string get_VaultWorkingFolderCleared();
    internal static string get_VaultWorkingFolderRestored();
    internal static string get_VersionFileNotFound();
    internal static string get_VersionModifiedValue();
    internal static string get_VersionOriginalValue();
    internal static string get_VersionRead();
    internal static string get_VersionReadException();
    internal static string get_VersionWriteException();
    internal static string get_VersionWrote();
    internal static string get_WebDirectoryInvalidDirectory();
    internal static string get_WebDirectoryScriptMapUpdate();
    internal static string get_WebDirectorySettingInvalidSetting();
    internal static string get_WebDirectorySettingStatusRead();
    internal static string get_WebDirectorySettingStatusSet();
    internal static string get_XmlReadDocument();
    internal static string get_XmlReadNodes();
    internal static string get_XmlReadResult();
    internal static string get_XmlUpdateDocument();
    internal static string get_XmlUpdateNodes();
    internal static string get_XmlUpdateResult();
    internal static string get_XsltAddingParameter();
    internal static string get_XsltAddingRootAttribute();
    internal static string get_XsltCreatingRootTag();
    internal static string get_XsltNoInputFiles();
    internal static string get_XsltNoRootTag();
    internal static string get_ZipAdded();
    internal static string get_ZipCreating();
    internal static string get_ZipFileNotFound();
    internal static string get_ZipSuccessfully();
}
internal class MSBuild.Community.Tasks.RealFtpWebRequest : object {
    private FtpWebRequest realRequest;
    public RealFtpWebRequest(FtpWebRequest realRequest);
    public sealed virtual void SetContentLength(long length);
    public sealed virtual Stream GetRequestStream();
    public sealed virtual string GetStatusDescriptionAndCloseResponse();
    public sealed virtual void GetAndCloseResponse();
    public sealed virtual Stream GetResponseStream();
}
public abstract class MSBuild.Community.Tasks.RegexBase : Task {
    private ITaskItem[] input;
    private ITaskItem expression;
    private ITaskItem[] options;
    private RegexOptions expressionOptions;
    private ITaskItem[] output;
    [RequiredAttribute]
public ITaskItem Expression { get; public set; }
    [RequiredAttribute]
public ITaskItem[] Input { get; public set; }
    public ITaskItem[] Options { get; public set; }
    [OutputAttribute]
public ITaskItem[] Output { get; public set; }
    protected RegexOptions ExpressionOptions { get; }
    public ITaskItem get_Expression();
    public void set_Expression(ITaskItem value);
    public ITaskItem[] get_Input();
    public void set_Input(ITaskItem[] value);
    public ITaskItem[] get_Options();
    public void set_Options(ITaskItem[] value);
    public void set_Output(ITaskItem[] value);
    public ITaskItem[] get_Output();
    protected RegexOptions get_ExpressionOptions();
}
public class MSBuild.Community.Tasks.RegexCompiler : Task {
    [CompilerGeneratedAttribute]
private string <AssemblyName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AssemblyTitle>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AssemblyDescription>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AssemblyCompany>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AssemblyProduct>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AssemblyCopyright>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AssemblyCulture>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AssemblyVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AssemblyFileVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AssemblyInformationalVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AssemblyKeyFile>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OutputDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem <OutputFile>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem[] <RegularExpressions>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem <RegularExpressionsFile>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsPublic>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Namespace>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Options>k__BackingField;
    [RequiredAttribute]
public string AssemblyName { get; public set; }
    public string AssemblyTitle { get; public set; }
    public string AssemblyDescription { get; public set; }
    public string AssemblyCompany { get; public set; }
    public string AssemblyProduct { get; public set; }
    public string AssemblyCopyright { get; public set; }
    public string AssemblyCulture { get; public set; }
    public string AssemblyVersion { get; public set; }
    public string AssemblyFileVersion { get; public set; }
    public string AssemblyInformationalVersion { get; public set; }
    public string AssemblyKeyFile { get; public set; }
    [RequiredAttribute]
public string OutputDirectory { get; public set; }
    [OutputAttribute]
public ITaskItem OutputFile { get; public set; }
    public ITaskItem[] RegularExpressions { get; public set; }
    public ITaskItem RegularExpressionsFile { get; public set; }
    public bool IsPublic { get; public set; }
    public string Namespace { get; public set; }
    public string Options { get; public set; }
    [CompilerGeneratedAttribute]
public string get_AssemblyName();
    [CompilerGeneratedAttribute]
public void set_AssemblyName(string value);
    [CompilerGeneratedAttribute]
public string get_AssemblyTitle();
    [CompilerGeneratedAttribute]
public void set_AssemblyTitle(string value);
    [CompilerGeneratedAttribute]
public string get_AssemblyDescription();
    [CompilerGeneratedAttribute]
public void set_AssemblyDescription(string value);
    [CompilerGeneratedAttribute]
public string get_AssemblyCompany();
    [CompilerGeneratedAttribute]
public void set_AssemblyCompany(string value);
    [CompilerGeneratedAttribute]
public string get_AssemblyProduct();
    [CompilerGeneratedAttribute]
public void set_AssemblyProduct(string value);
    [CompilerGeneratedAttribute]
public string get_AssemblyCopyright();
    [CompilerGeneratedAttribute]
public void set_AssemblyCopyright(string value);
    [CompilerGeneratedAttribute]
public string get_AssemblyCulture();
    [CompilerGeneratedAttribute]
public void set_AssemblyCulture(string value);
    [CompilerGeneratedAttribute]
public string get_AssemblyVersion();
    [CompilerGeneratedAttribute]
public void set_AssemblyVersion(string value);
    [CompilerGeneratedAttribute]
public string get_AssemblyFileVersion();
    [CompilerGeneratedAttribute]
public void set_AssemblyFileVersion(string value);
    [CompilerGeneratedAttribute]
public string get_AssemblyInformationalVersion();
    [CompilerGeneratedAttribute]
public void set_AssemblyInformationalVersion(string value);
    [CompilerGeneratedAttribute]
public string get_AssemblyKeyFile();
    [CompilerGeneratedAttribute]
public void set_AssemblyKeyFile(string value);
    [CompilerGeneratedAttribute]
public string get_OutputDirectory();
    [CompilerGeneratedAttribute]
public void set_OutputDirectory(string value);
    [CompilerGeneratedAttribute]
public ITaskItem get_OutputFile();
    [CompilerGeneratedAttribute]
public void set_OutputFile(ITaskItem value);
    [CompilerGeneratedAttribute]
public ITaskItem[] get_RegularExpressions();
    [CompilerGeneratedAttribute]
public void set_RegularExpressions(ITaskItem[] value);
    [CompilerGeneratedAttribute]
public ITaskItem get_RegularExpressionsFile();
    [CompilerGeneratedAttribute]
public void set_RegularExpressionsFile(ITaskItem value);
    [CompilerGeneratedAttribute]
public void set_IsPublic(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsPublic();
    [CompilerGeneratedAttribute]
public void set_Namespace(string value);
    [CompilerGeneratedAttribute]
public string get_Namespace();
    [CompilerGeneratedAttribute]
public void set_Options(string value);
    [CompilerGeneratedAttribute]
public string get_Options();
    public virtual bool Execute();
    private void Validate();
    private string ValidateVersion(string version, string defaultVersion);
    private AssemblyName GetAssemblyName();
    private static CustomAttributeBuilder GetAttribute(string value);
    private CustomAttributeBuilder[] GetAttributes();
    private List`1<RegexCompilationInfo> GetRegexCompilation();
    private List`1<RegexCompilationInfo> GetRegexCompilationFile();
    private RegexOptions GetRegexOptions(string options);
}
public class MSBuild.Community.Tasks.RegexMatch : RegexBase {
    public virtual bool Execute();
}
public class MSBuild.Community.Tasks.RegexReplace : RegexBase {
    private ITaskItem replacement;
    private int count;
    private int startat;
    public ITaskItem Replacement { get; public set; }
    public ITaskItem Count { get; public set; }
    public ITaskItem StartAt { get; public set; }
    public ITaskItem get_Replacement();
    public void set_Replacement(ITaskItem value);
    public ITaskItem get_Count();
    public void set_Count(ITaskItem value);
    public ITaskItem get_StartAt();
    public void set_StartAt(ITaskItem value);
    public virtual bool Execute();
}
public class MSBuild.Community.Tasks.RegistryRead : Task {
    private string _keyName;
    private string _valueName;
    private string _defaultValue;
    private string _value;
    [RequiredAttribute]
public string KeyName { get; public set; }
    public string ValueName { get; public set; }
    public string DefaultValue { get; public set; }
    [OutputAttribute]
public string Value { get; }
    public string get_KeyName();
    public void set_KeyName(string value);
    public string get_ValueName();
    public void set_ValueName(string value);
    public string get_DefaultValue();
    public void set_DefaultValue(string value);
    public string get_Value();
    public virtual bool Execute();
}
public class MSBuild.Community.Tasks.RegistryWrite : Task {
    private string _keyName;
    private string _valueName;
    private string _value;
    [RequiredAttribute]
public string KeyName { get; public set; }
    public string ValueName { get; public set; }
    [RequiredAttribute]
public string Value { get; public set; }
    public string get_KeyName();
    public void set_KeyName(string value);
    public string get_ValueName();
    public void set_ValueName(string value);
    public string get_Value();
    public void set_Value(string value);
    public virtual bool Execute();
}
public class MSBuild.Community.Tasks.RoboCopy : ToolTask {
    private string _sourceFolder;
    private String[] _sourceFiles;
    private string _destinationFolder;
    private bool _subdirectories;
    private bool _allSubdirectories;
    private bool _restartableMode;
    private bool _backupMode;
    private string _copyFlags;
    private bool _copyAll;
    private bool _noCopy;
    private bool _security;
    private bool _moveFiles;
    private bool _move;
    private bool _purge;
    private bool _mirror;
    private bool _create;
    private bool _fatFileNames;
    private bool _fatFileTimes;
    private string _includeAttributes;
    private string _excluedAttributes;
    private bool _includeArchive;
    private bool _includeArchiveClear;
    private bool _excludeJunctions;
    private String[] _excludeFiles;
    private String[] _excludeFolders;
    private bool _verbose;
    private bool _noFileLogging;
    private bool _noFolderLogging;
    private bool _noJobHeader;
    private bool _noJobSummary;
    private bool _noProgress;
    private string _logFile;
    private string _appendLogFile;
    private String[] _options;
    [RequiredAttribute]
public string SourceFolder { get; public set; }
    public String[] SourceFiles { get; public set; }
    [RequiredAttribute]
public string DestinationFolder { get; public set; }
    public bool Subdirectories { get; public set; }
    public bool AllSubdirectories { get; public set; }
    public bool RestartableMode { get; public set; }
    public bool BackupMode { get; public set; }
    public string CopyFlags { get; public set; }
    public bool CopyAll { get; public set; }
    public bool NoCopy { get; public set; }
    public bool Security { get; public set; }
    public bool MoveFiles { get; public set; }
    public bool Move { get; public set; }
    public bool Purge { get; public set; }
    public bool Mirror { get; public set; }
    public bool Create { get; public set; }
    public bool FatFileNames { get; public set; }
    public bool FatFileTimes { get; public set; }
    public string IncludeAttributes { get; public set; }
    public string ExcluedAttributes { get; public set; }
    public bool IncludeArchive { get; public set; }
    public bool IncludeArchiveClear { get; public set; }
    public bool ExcludeJunctions { get; public set; }
    public String[] ExcludeFiles { get; public set; }
    public String[] ExcludeFolders { get; public set; }
    public bool Verbose { get; public set; }
    public bool NoFileLogging { get; public set; }
    public bool NoFolderLogging { get; public set; }
    public bool NoJobHeader { get; public set; }
    public bool NoJobSummary { get; public set; }
    public bool NoProgress { get; public set; }
    public string LogFile { get; public set; }
    public string AppendLogFile { get; public set; }
    public String[] Options { get; public set; }
    protected string ToolName { get; }
    protected MessageImportance StandardOutputLoggingImportance { get; }
    public string get_SourceFolder();
    public void set_SourceFolder(string value);
    public String[] get_SourceFiles();
    public void set_SourceFiles(String[] value);
    public string get_DestinationFolder();
    public void set_DestinationFolder(string value);
    public bool get_Subdirectories();
    public void set_Subdirectories(bool value);
    public bool get_AllSubdirectories();
    public void set_AllSubdirectories(bool value);
    public bool get_RestartableMode();
    public void set_RestartableMode(bool value);
    public bool get_BackupMode();
    public void set_BackupMode(bool value);
    public string get_CopyFlags();
    public void set_CopyFlags(string value);
    public bool get_CopyAll();
    public void set_CopyAll(bool value);
    public bool get_NoCopy();
    public void set_NoCopy(bool value);
    public bool get_Security();
    public void set_Security(bool value);
    public bool get_MoveFiles();
    public void set_MoveFiles(bool value);
    public bool get_Move();
    public void set_Move(bool value);
    public bool get_Purge();
    public void set_Purge(bool value);
    public bool get_Mirror();
    public void set_Mirror(bool value);
    public bool get_Create();
    public void set_Create(bool value);
    public bool get_FatFileNames();
    public void set_FatFileNames(bool value);
    public bool get_FatFileTimes();
    public void set_FatFileTimes(bool value);
    public string get_IncludeAttributes();
    public void set_IncludeAttributes(string value);
    public string get_ExcluedAttributes();
    public void set_ExcluedAttributes(string value);
    public bool get_IncludeArchive();
    public void set_IncludeArchive(bool value);
    public bool get_IncludeArchiveClear();
    public void set_IncludeArchiveClear(bool value);
    public bool get_ExcludeJunctions();
    public void set_ExcludeJunctions(bool value);
    public String[] get_ExcludeFiles();
    public void set_ExcludeFiles(String[] value);
    public String[] get_ExcludeFolders();
    public void set_ExcludeFolders(String[] value);
    public bool get_Verbose();
    public void set_Verbose(bool value);
    public bool get_NoFileLogging();
    public void set_NoFileLogging(bool value);
    public bool get_NoFolderLogging();
    public void set_NoFolderLogging(bool value);
    public bool get_NoJobHeader();
    public void set_NoJobHeader(bool value);
    public bool get_NoJobSummary();
    public void set_NoJobSummary(bool value);
    public bool get_NoProgress();
    public void set_NoProgress(bool value);
    public string get_LogFile();
    public void set_LogFile(string value);
    public string get_AppendLogFile();
    public void set_AppendLogFile(string value);
    public String[] get_Options();
    public void set_Options(String[] value);
    protected virtual bool HandleTaskExecutionErrors();
    protected virtual string GenerateCommandLineCommands();
    protected virtual string GenerateFullPathToTool();
    protected virtual void LogToolCommand(string message);
    protected virtual string get_ToolName();
    protected virtual MessageImportance get_StandardOutputLoggingImportance();
}
public class MSBuild.Community.Tasks.Sandcastle.BuildAssembler : SandcastleToolBase {
    [CompilerGeneratedAttribute]
private ITaskItem <ConfigFile>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem <ManifestFile>k__BackingField;
    [RequiredAttribute]
public ITaskItem ConfigFile { get; public set; }
    [RequiredAttribute]
public ITaskItem ManifestFile { get; public set; }
    protected string ToolName { get; }
    [CompilerGeneratedAttribute]
public ITaskItem get_ConfigFile();
    [CompilerGeneratedAttribute]
public void set_ConfigFile(ITaskItem value);
    [CompilerGeneratedAttribute]
public ITaskItem get_ManifestFile();
    [CompilerGeneratedAttribute]
public void set_ManifestFile(ITaskItem value);
    protected virtual string get_ToolName();
    protected virtual string GenerateCommandLineCommands();
}
public class MSBuild.Community.Tasks.Sandcastle.ChmBuilder : SandcastleToolBase {
    [CompilerGeneratedAttribute]
private string <HtmlDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProjectName>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem <TocFile>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OutputDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Metadata>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LanguageId>k__BackingField;
    public string HtmlDirectory { get; public set; }
    public string ProjectName { get; public set; }
    public ITaskItem TocFile { get; public set; }
    public string OutputDirectory { get; public set; }
    public bool Metadata { get; public set; }
    public string LanguageId { get; public set; }
    protected string ToolName { get; }
    [CompilerGeneratedAttribute]
public string get_HtmlDirectory();
    [CompilerGeneratedAttribute]
public void set_HtmlDirectory(string value);
    [CompilerGeneratedAttribute]
public string get_ProjectName();
    [CompilerGeneratedAttribute]
public void set_ProjectName(string value);
    [CompilerGeneratedAttribute]
public ITaskItem get_TocFile();
    [CompilerGeneratedAttribute]
public void set_TocFile(ITaskItem value);
    [CompilerGeneratedAttribute]
public string get_OutputDirectory();
    [CompilerGeneratedAttribute]
public void set_OutputDirectory(string value);
    [CompilerGeneratedAttribute]
public bool get_Metadata();
    [CompilerGeneratedAttribute]
public void set_Metadata(bool value);
    [CompilerGeneratedAttribute]
public string get_LanguageId();
    [CompilerGeneratedAttribute]
public void set_LanguageId(string value);
    protected virtual string get_ToolName();
    protected virtual string GenerateCommandLineCommands();
}
public class MSBuild.Community.Tasks.Sandcastle.DBCSFix : SandcastleToolBase {
    [CompilerGeneratedAttribute]
private string <ChmDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LanguageId>k__BackingField;
    public string ChmDirectory { get; public set; }
    public string LanguageId { get; public set; }
    protected string ToolName { get; }
    [CompilerGeneratedAttribute]
public string get_ChmDirectory();
    [CompilerGeneratedAttribute]
public void set_ChmDirectory(string value);
    [CompilerGeneratedAttribute]
public string get_LanguageId();
    [CompilerGeneratedAttribute]
public void set_LanguageId(string value);
    protected virtual string get_ToolName();
    protected virtual string GenerateCommandLineCommands();
}
public class MSBuild.Community.Tasks.Sandcastle.MRefBuilder : SandcastleToolBase {
    [CompilerGeneratedAttribute]
private ITaskItem <OutputFile>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem <ConfigFile>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem[] <References>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem[] <Assemblies>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludeInternal>k__BackingField;
    [RequiredAttribute]
public ITaskItem OutputFile { get; public set; }
    public ITaskItem ConfigFile { get; public set; }
    public ITaskItem[] References { get; public set; }
    [RequiredAttribute]
public ITaskItem[] Assemblies { get; public set; }
    public bool IncludeInternal { get; public set; }
    protected string ToolName { get; }
    [CompilerGeneratedAttribute]
public ITaskItem get_OutputFile();
    [CompilerGeneratedAttribute]
public void set_OutputFile(ITaskItem value);
    [CompilerGeneratedAttribute]
public ITaskItem get_ConfigFile();
    [CompilerGeneratedAttribute]
public void set_ConfigFile(ITaskItem value);
    [CompilerGeneratedAttribute]
public ITaskItem[] get_References();
    [CompilerGeneratedAttribute]
public void set_References(ITaskItem[] value);
    [CompilerGeneratedAttribute]
public ITaskItem[] get_Assemblies();
    [CompilerGeneratedAttribute]
public void set_Assemblies(ITaskItem[] value);
    [CompilerGeneratedAttribute]
public bool get_IncludeInternal();
    [CompilerGeneratedAttribute]
public void set_IncludeInternal(bool value);
    protected virtual string get_ToolName();
    protected virtual string GenerateCommandLineCommands();
}
public class MSBuild.Community.Tasks.Sandcastle.Sandcastle : Task {
    private static String[] outputDirectories;
    private static String[] topicStyles;
    [CompilerGeneratedAttribute]
private ITaskItem[] <WorkingReferences>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem[] <WorkingAssemblies>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem[] <WorkingComments>k__BackingField;
    [CompilerGeneratedAttribute]
private SandcastleEnviroment <SandcastleEnviroment>k__BackingField;
    [CompilerGeneratedAttribute]
private string <WorkingDirectory>k__BackingField;
    private string _topicStyle;
    [CompilerGeneratedAttribute]
private bool <Clean>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem[] <References>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem[] <Assemblies>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem[] <Comments>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem <SandcastleConfig>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ChmName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LanguageId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HxName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <NoInfoMessages>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <NoWarnMessages>k__BackingField;
    internal string AssemblyDirectory { get; }
    internal string DependencyDirectory { get; }
    internal string CommentsDirectory { get; }
    internal string TopicStyleDirectory { get; }
    internal string OutputDirectory { get; }
    internal string ChmDirectory { get; }
    internal string ReflectionFile { get; }
    internal string ManifestFile { get; }
    internal string TocFile { get; }
    internal ITaskItem[] WorkingReferences { get; internal set; }
    internal ITaskItem[] WorkingAssemblies { get; internal set; }
    internal ITaskItem[] WorkingComments { get; internal set; }
    internal SandcastleEnviroment SandcastleEnviroment { get; internal set; }
    public string SandcastleRoot { get; public set; }
    public string WorkingDirectory { get; public set; }
    public string TopicStyle { get; public set; }
    public bool Clean { get; public set; }
    public ITaskItem[] References { get; public set; }
    [RequiredAttribute]
public ITaskItem[] Assemblies { get; public set; }
    [RequiredAttribute]
public ITaskItem[] Comments { get; public set; }
    public ITaskItem SandcastleConfig { get; public set; }
    public string ChmName { get; public set; }
    public string LanguageId { get; public set; }
    public string HxName { get; public set; }
    public bool NoInfoMessages { get; public set; }
    public bool NoWarnMessages { get; public set; }
    private static Sandcastle();
    internal string get_AssemblyDirectory();
    internal string get_DependencyDirectory();
    internal string get_CommentsDirectory();
    internal string get_TopicStyleDirectory();
    internal string get_OutputDirectory();
    internal string get_ChmDirectory();
    internal string get_ReflectionFile();
    internal string get_ManifestFile();
    internal string get_TocFile();
    [CompilerGeneratedAttribute]
internal ITaskItem[] get_WorkingReferences();
    [CompilerGeneratedAttribute]
internal void set_WorkingReferences(ITaskItem[] value);
    [CompilerGeneratedAttribute]
internal ITaskItem[] get_WorkingAssemblies();
    [CompilerGeneratedAttribute]
internal void set_WorkingAssemblies(ITaskItem[] value);
    [CompilerGeneratedAttribute]
internal ITaskItem[] get_WorkingComments();
    [CompilerGeneratedAttribute]
internal void set_WorkingComments(ITaskItem[] value);
    [CompilerGeneratedAttribute]
internal SandcastleEnviroment get_SandcastleEnviroment();
    [CompilerGeneratedAttribute]
internal void set_SandcastleEnviroment(SandcastleEnviroment value);
    public string get_SandcastleRoot();
    public void set_SandcastleRoot(string value);
    [CompilerGeneratedAttribute]
public string get_WorkingDirectory();
    [CompilerGeneratedAttribute]
public void set_WorkingDirectory(string value);
    public string get_TopicStyle();
    public void set_TopicStyle(string value);
    [CompilerGeneratedAttribute]
public bool get_Clean();
    [CompilerGeneratedAttribute]
public void set_Clean(bool value);
    [CompilerGeneratedAttribute]
public ITaskItem[] get_References();
    [CompilerGeneratedAttribute]
public void set_References(ITaskItem[] value);
    [CompilerGeneratedAttribute]
public ITaskItem[] get_Assemblies();
    [CompilerGeneratedAttribute]
public void set_Assemblies(ITaskItem[] value);
    [CompilerGeneratedAttribute]
public ITaskItem[] get_Comments();
    [CompilerGeneratedAttribute]
public void set_Comments(ITaskItem[] value);
    [CompilerGeneratedAttribute]
public ITaskItem get_SandcastleConfig();
    [CompilerGeneratedAttribute]
public void set_SandcastleConfig(ITaskItem value);
    [CompilerGeneratedAttribute]
public string get_ChmName();
    [CompilerGeneratedAttribute]
public void set_ChmName(string value);
    [CompilerGeneratedAttribute]
public string get_LanguageId();
    [CompilerGeneratedAttribute]
public void set_LanguageId(string value);
    [CompilerGeneratedAttribute]
public string get_HxName();
    [CompilerGeneratedAttribute]
public void set_HxName(string value);
    [CompilerGeneratedAttribute]
public bool get_NoInfoMessages();
    [CompilerGeneratedAttribute]
public void set_NoInfoMessages(bool value);
    [CompilerGeneratedAttribute]
public bool get_NoWarnMessages();
    [CompilerGeneratedAttribute]
public void set_NoWarnMessages(bool value);
    public virtual bool Execute();
    private void CreateWorkDirectories();
    private void CopySourceFiles();
    private bool Reflection();
    private void CopyOutputFiles();
    private bool Manifest();
    private bool OutputHtml();
    private bool Toc();
    private bool CreateChm();
    private bool CreateHx();
    private void CopyDirectoryItems(string sourceDirectory, string targetDirectory);
    private ITaskItem[] CopyItems(ITaskItem[] items, string targetDirectory);
    private void CopyBuildEngine(SandcastleToolBase task);
    private void CopyBuildEngine(ITask task);
    private string GetBuildAssemblerConfig();
}
public class MSBuild.Community.Tasks.Sandcastle.SandcastleEnviroment : object {
    internal static string DefaultLocation;
    private string _sandcastleRoot;
    private string _toolsDirectory;
    private string _transformsDirectory;
    private string _presentationDirectory;
    public string SandcastleRoot { get; public set; }
    public string ToolsDirectory { get; public set; }
    public string TransformsDirectory { get; public set; }
    public string PresentationDirectory { get; public set; }
    private static SandcastleEnviroment();
    public SandcastleEnviroment(string sandcastleRoot);
    public string get_SandcastleRoot();
    public void set_SandcastleRoot(string value);
    public string get_ToolsDirectory();
    public void set_ToolsDirectory(string value);
    public string get_TransformsDirectory();
    public void set_TransformsDirectory(string value);
    public string get_PresentationDirectory();
    public void set_PresentationDirectory(string value);
}
public abstract class MSBuild.Community.Tasks.Sandcastle.SandcastleToolBase : ToolTask {
    [CompilerGeneratedAttribute]
private SandcastleEnviroment <SandcastleEnviroment>k__BackingField;
    [CompilerGeneratedAttribute]
private StringDictionary <EnviromentVariables>k__BackingField;
    private bool _noInfoMessages;
    private bool _noWarnMessages;
    internal SandcastleEnviroment SandcastleEnviroment { get; internal set; }
    internal StringDictionary EnviromentVariables { get; internal set; }
    public string SandcastleRoot { get; public set; }
    public bool NoInfoMessages { get; public set; }
    public bool NoWarnMessages { get; public set; }
    protected MessageImportance StandardOutputLoggingImportance { get; }
    protected MessageImportance StandardErrorLoggingImportance { get; }
    protected StringDictionary EnvironmentOverride { get; }
    [CompilerGeneratedAttribute]
internal SandcastleEnviroment get_SandcastleEnviroment();
    [CompilerGeneratedAttribute]
internal void set_SandcastleEnviroment(SandcastleEnviroment value);
    [CompilerGeneratedAttribute]
internal StringDictionary get_EnviromentVariables();
    [CompilerGeneratedAttribute]
internal void set_EnviromentVariables(StringDictionary value);
    public string get_SandcastleRoot();
    public void set_SandcastleRoot(string value);
    public bool get_NoInfoMessages();
    public void set_NoInfoMessages(bool value);
    public bool get_NoWarnMessages();
    public void set_NoWarnMessages(bool value);
    protected virtual string GenerateFullPathToTool();
    protected virtual void LogToolCommand(string message);
    protected virtual MessageImportance get_StandardOutputLoggingImportance();
    protected virtual MessageImportance get_StandardErrorLoggingImportance();
    protected virtual StringDictionary get_EnvironmentOverride();
    protected virtual void LogEventsFromTextOutput(string singleLine, MessageImportance messageImportance);
}
public class MSBuild.Community.Tasks.Sandcastle.XslTransform : SandcastleToolBase {
    [CompilerGeneratedAttribute]
private ITaskItem <OutputFile>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem[] <XsltFiles>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem <XmlFile>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Arguments>k__BackingField;
    [RequiredAttribute]
public ITaskItem OutputFile { get; public set; }
    public ITaskItem[] XsltFiles { get; public set; }
    public ITaskItem XmlFile { get; public set; }
    public String[] Arguments { get; public set; }
    protected string ToolName { get; }
    [CompilerGeneratedAttribute]
public ITaskItem get_OutputFile();
    [CompilerGeneratedAttribute]
public void set_OutputFile(ITaskItem value);
    [CompilerGeneratedAttribute]
public ITaskItem[] get_XsltFiles();
    [CompilerGeneratedAttribute]
public void set_XsltFiles(ITaskItem[] value);
    [CompilerGeneratedAttribute]
public ITaskItem get_XmlFile();
    [CompilerGeneratedAttribute]
public void set_XmlFile(ITaskItem value);
    [CompilerGeneratedAttribute]
public String[] get_Arguments();
    [CompilerGeneratedAttribute]
public void set_Arguments(String[] value);
    protected virtual string get_ToolName();
    protected virtual string GenerateCommandLineCommands();
}
internal class MSBuild.Community.Tasks.Schema.DocumentationLoader : object {
    private Dictionary`2<Assembly, XmlDocument> assemblyDocumentations;
    public Dictionary`2<Assembly, XmlDocument> AssemblyDocumentations { get; }
    public Dictionary`2<Assembly, XmlDocument> get_AssemblyDocumentations();
    public bool HasDocumentation(Assembly assembly);
    public XmlDocument GetDocumentation(Assembly assembly);
    public XmlElement GetTypeDocumentation(Type type);
    public XmlElement GetPropertyDocumentation(PropertyInfo propertyInfo);
    public XmlElement GetFieldDocumentation(FieldInfo fieldInfo);
    private XmlElement GetDocumentationElement(Assembly assembly, string typeFullName, char nodeType);
    public string GetTypeSummary(Type type);
    public string GetPropertySummary(PropertyInfo propertyInfo);
    public string GetFieldSummary(FieldInfo fieldInfo);
    private string GetDocumentationSummary(Assembly assembly, string typeFullName, char nodeType);
    public Type GetEnumType(PropertyInfo property);
}
internal static class MSBuild.Community.Tasks.Schema.ReflectionHelper : object {
    public static T GetAttribute(ICustomAttributeProvider t);
    public static bool HasAttribute(ICustomAttributeProvider t);
    public static bool IsOutput(ICustomAttributeProvider t);
    public static bool IsRequired(ICustomAttributeProvider t);
    public static Assembly LoadAssembly(TaskLoggingHelper logger, ITaskItem assemblyItem);
}
public enum MSBuild.Community.Tasks.Schema.TaskListAssemblyFormatType : Enum {
    public int value__;
    public static TaskListAssemblyFormatType AssemblyFileName;
    public static TaskListAssemblyFormatType AssemblyFileFullPath;
    public static TaskListAssemblyFormatType AssemblyName;
    public static TaskListAssemblyFormatType AssemblyFullName;
}
public class MSBuild.Community.Tasks.Schema.TaskSchema : AppDomainIsolatedTask {
    private ITaskItem[] assemblies;
    private ITaskItem[] schemas;
    private ITaskItem[] taskLists;
    private string outputPath;
    private bool createTaskList;
    private bool ignoreDocumentation;
    private string taskListAssemblyFormat;
    private bool ignoreMsBuildSchema;
    private ITaskItem[] includes;
    [RequiredAttribute]
public ITaskItem[] Assemblies { get; public set; }
    public string OutputPath { get; public set; }
    [OutputAttribute]
public ITaskItem[] Schemas { get; }
    public bool CreateTaskList { get; public set; }
    public string TaskListAssemblyFormat { get; public set; }
    public bool IgnoreDocumentation { get; public set; }
    [OutputAttribute]
public ITaskItem[] TaskLists { get; }
    public bool IgnoreMsBuildSchema { get; public set; }
    public ITaskItem[] Includes { get; public set; }
    public ITaskItem[] get_Assemblies();
    public void set_Assemblies(ITaskItem[] value);
    public string get_OutputPath();
    public void set_OutputPath(string value);
    public ITaskItem[] get_Schemas();
    public bool get_CreateTaskList();
    public void set_CreateTaskList(bool value);
    public string get_TaskListAssemblyFormat();
    public void set_TaskListAssemblyFormat(string value);
    public bool get_IgnoreDocumentation();
    public void set_IgnoreDocumentation(bool value);
    public ITaskItem[] get_TaskLists();
    public bool get_IgnoreMsBuildSchema();
    public void set_IgnoreMsBuildSchema(bool value);
    public ITaskItem[] get_Includes();
    public void set_Includes(ITaskItem[] value);
    private string GetTaskListName(Assembly taskAssembly);
    private string GetSchemaFileName(Assembly taskAssembly);
    public virtual bool Execute();
    private bool AnalyseAssembly(ITaskItem taskAssemblyFile, int i);
}
internal class MSBuild.Community.Tasks.Schema.TaskSchemaAnalyser : TaskVisitorBase`1<TaskSchema> {
    private DocumentationLoader documentationLoader;
    private XmlSchema schema;
    private XmlSchemaType taskSchemaType;
    private XmlQualifiedName taskQualifiedName;
    private Dictionary`2<Type, XmlSchemaSimpleType> enumTypes;
    private XmlDocument usingDocument;
    public XmlSchema Schema { get; }
    public XmlDocument UsingDocument { get; }
    public TaskSchemaAnalyser(TaskSchema parent, Assembly taskAssembly);
    public XmlSchema get_Schema();
    public XmlDocument get_UsingDocument();
    public void CreateSchema();
    private void AddMsBuildInclude();
    private void AddInclude(string path);
    private void AddIncludes();
    private void SetAssemblyInUsingTask(XmlElement el);
    public void CreateUsingDocument();
    private void CreateTaskElement(Type taskType);
    private void AddEnumRestriction(XmlSchemaAttribute attribute, Type enumType);
    private void AnnotateFacet(Type enumType, string enumValue, XmlDocument enumDocumentation, XmlSchemaFacet facet);
    private void AnnotateTaskElement(Type taskType, XmlSchemaAnnotated taskElement);
    private void AnnotateTaskAttribute(PropertyInfo property, XmlSchemaAttribute taskAttribute);
    public ITaskItem WriteSchema(string schemaFileName);
    public ITaskItem WriteUsingDocument(string usingDocumentName);
    private void SetTypeQualifiedName(XmlSchemaAttribute attribute, Type type);
}
internal abstract class MSBuild.Community.Tasks.Schema.TaskVisitorBase`1 : object {
    private T parent;
    private Assembly taskAssembly;
    public T Parent { get; }
    public Assembly TaskAssembly { get; public set; }
    public TaskVisitorBase`1(T parent, Assembly taskAssembly);
    public T get_Parent();
    public Assembly get_TaskAssembly();
    public void set_TaskAssembly(Assembly value);
    protected IEnumerable`1<Type> GetTaskTypes();
    protected IEnumerable`1<PropertyInfo> GetProperties(Type taskType);
    private static int CompareType(Type x, Type y);
    private static int ComparePropertyInfo(PropertyInfo x, PropertyInfo y);
}
public class MSBuild.Community.Tasks.Script : Task {
    private static String[] _defaultNamespaces;
    private string _rootClassName;
    private ITaskItem[] _references;
    private ITaskItem[] _imports;
    private string _language;
    private string _mainClass;
    private string _code;
    private string _returnValue;
    public ITaskItem[] References { get; public set; }
    public ITaskItem[] Imports { get; public set; }
    [RequiredAttribute]
public string Language { get; public set; }
    public string MainClass { get; public set; }
    public string Code { get; public set; }
    [OutputAttribute]
public string ReturnValue { get; }
    private static Script();
    public ITaskItem[] get_References();
    public void set_References(ITaskItem[] value);
    public ITaskItem[] get_Imports();
    public void set_Imports(ITaskItem[] value);
    public string get_Language();
    public void set_Language(string value);
    public string get_MainClass();
    public void set_MainClass(string value);
    public string get_Code();
    public void set_Code(string value);
    public string get_ReturnValue();
    public virtual bool Execute();
    private static bool isAssemblyFilePath(string assemblyFile);
    private static CodeDomProvider CreateCodeDomProvider(string typeName, string assemblyName);
    private static CodeDomProvider CreateCodeDomProvider(string assemblyQualifiedTypeName);
    private static CodeDomProvider CreateCodeDomProvider(Type providerType);
    private CompilerInfo CreateCompilerInfo(string language);
}
public enum MSBuild.Community.Tasks.ServiceActions : Enum {
    public int value__;
    public static ServiceActions Start;
    public static ServiceActions Stop;
    public static ServiceActions Restart;
    public static ServiceActions Pause;
    public static ServiceActions Continue;
}
public class MSBuild.Community.Tasks.ServiceController : ServiceQuery {
    private ServiceActions _action;
    private double _timeout;
    [RequiredAttribute]
public string Action { get; public set; }
    public double Timeout { get; public set; }
    public string get_Action();
    public void set_Action(string value);
    public double get_Timeout();
    public void set_Timeout(double value);
    public virtual bool Execute();
    private ServiceControllerStatus DetermineDesiredStatus();
    private bool StartService(ServiceController serviceController);
    private bool StopService(ServiceController serviceController);
    private bool RestartService(ServiceController serviceController);
    private bool PauseService(ServiceController serviceController);
    private bool ContinueService(ServiceController serviceController);
}
public class MSBuild.Community.Tasks.ServiceQuery : Task {
    public static string UNKNOWN_STATUS;
    private string _serviceName;
    private string _machineName;
    private string _status;
    private bool _canPauseAndContinue;
    private bool _canShutdown;
    private bool _canStop;
    private string _displayName;
    private bool _exists;
    [RequiredAttribute]
public string ServiceName { get; public set; }
    public string MachineName { get; public set; }
    [OutputAttribute]
public string Status { get; public set; }
    [OutputAttribute]
public bool CanPauseAndContinue { get; }
    [OutputAttribute]
public bool CanShutdown { get; }
    [OutputAttribute]
public bool CanStop { get; }
    [OutputAttribute]
public string DisplayName { get; }
    [OutputAttribute]
public bool Exists { get; }
    public string get_ServiceName();
    public void set_ServiceName(string value);
    public string get_MachineName();
    public void set_MachineName(string value);
    public string get_Status();
    public void set_Status(string value);
    public bool get_CanPauseAndContinue();
    public bool get_CanShutdown();
    public bool get_CanStop();
    public string get_DisplayName();
    public bool get_Exists();
    public virtual bool Execute();
    protected ServiceController GetServiceController();
}
public class MSBuild.Community.Tasks.Services.FileSystem : object {
    public sealed virtual bool FileExists(string path);
    public sealed virtual string ReadTextFromFile(string fileName);
    public sealed virtual void WriteTextToFile(string fileName, string contents);
}
public interface MSBuild.Community.Tasks.Services.IFilesSystem {
    public abstract virtual bool FileExists(string path);
    public abstract virtual string ReadTextFromFile(string fileName);
    public abstract virtual void WriteTextToFile(string fileName, string contents);
}
public interface MSBuild.Community.Tasks.Services.IRegistry {
    public abstract virtual String[] GetSubKeys(RegistryHive hive, string key);
    public abstract virtual object GetValue(string key, string valueName);
}
public class MSBuild.Community.Tasks.Services.Win32Registry : object {
    public sealed virtual String[] GetSubKeys(RegistryHive hive, string key);
    private static RegistryKey getHiveKey(RegistryHive hive);
    public sealed virtual object GetValue(string key, string valueName);
}
public class MSBuild.Community.Tasks.Sleep : Task {
    private int _milliseconds;
    private int _seconds;
    private int _minutes;
    private int _hours;
    public int Milliseconds { get; public set; }
    public int Seconds { get; public set; }
    public int Minutes { get; public set; }
    public int Hours { get; public set; }
    public int get_Milliseconds();
    public void set_Milliseconds(int value);
    public int get_Seconds();
    public void set_Seconds(int value);
    public int get_Minutes();
    public void set_Minutes(int value);
    public int get_Hours();
    public void set_Hours(int value);
    public virtual bool Execute();
    private int GetSleepTime();
}
public class MSBuild.Community.Tasks.Sound : Task {
    private SoundPlayer soundPlayer;
    private bool sync;
    public string SoundLocation { get; public set; }
    unknown string SystemSoundFile {public set; }
    unknown string MyMusicFile {public set; }
    public int LoadTimeout { get; public set; }
    public bool Synchron { get; public set; }
    public string get_SoundLocation();
    public void set_SoundLocation(string value);
    public void set_SystemSoundFile(string value);
    public void set_MyMusicFile(string value);
    public int get_LoadTimeout();
    public void set_LoadTimeout(int value);
    public bool get_Synchron();
    public void set_Synchron(bool value);
    public virtual bool Execute();
}
public class MSBuild.Community.Tasks.SourceServer.FileBase : object {
    [CompilerGeneratedAttribute]
private FileInfo <File>k__BackingField;
    public FileInfo File { get; private set; }
    public FileBase(string fileName);
    public FileBase(FileInfo fileInfo);
    [CompilerGeneratedAttribute]
public FileInfo get_File();
    [CompilerGeneratedAttribute]
private void set_File(FileInfo value);
    public virtual string ToString();
    public static string op_Implicit(FileBase file);
}
public class MSBuild.Community.Tasks.SourceServer.PdbStr : ToolTask {
    [CompilerGeneratedAttribute]
private ITaskItem <PdbFile>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem <StreamFile>k__BackingField;
    [CompilerGeneratedAttribute]
private string <StreamName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Command>k__BackingField;
    public ITaskItem PdbFile { get; public set; }
    public ITaskItem StreamFile { get; public set; }
    public string StreamName { get; public set; }
    public string Command { get; public set; }
    protected string ToolName { get; }
    [CompilerGeneratedAttribute]
public ITaskItem get_PdbFile();
    [CompilerGeneratedAttribute]
public void set_PdbFile(ITaskItem value);
    [CompilerGeneratedAttribute]
public ITaskItem get_StreamFile();
    [CompilerGeneratedAttribute]
public void set_StreamFile(ITaskItem value);
    [CompilerGeneratedAttribute]
public string get_StreamName();
    [CompilerGeneratedAttribute]
public void set_StreamName(string value);
    [CompilerGeneratedAttribute]
public string get_Command();
    [CompilerGeneratedAttribute]
public void set_Command(string value);
    protected virtual string GenerateCommandLineCommands();
    protected virtual string GenerateFullPathToTool();
    protected virtual string get_ToolName();
}
public enum MSBuild.Community.Tasks.SourceServer.PdbStrCommands : Enum {
    public int value__;
    public static PdbStrCommands read;
    public static PdbStrCommands write;
}
public class MSBuild.Community.Tasks.SourceServer.SourceFile : FileBase {
    [CompilerGeneratedAttribute]
private IDictionary`2<string, object> <Properties>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsResolved>k__BackingField;
    public IDictionary`2<string, object> Properties { get; private set; }
    public bool IsResolved { get; public set; }
    public SourceFile(string fileName);
    public SourceFile(FileInfo fileInfo);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, object> get_Properties();
    [CompilerGeneratedAttribute]
private void set_Properties(IDictionary`2<string, object> value);
    [CompilerGeneratedAttribute]
public bool get_IsResolved();
    [CompilerGeneratedAttribute]
public void set_IsResolved(bool value);
    public string ToSourceString(string format);
}
public abstract class MSBuild.Community.Tasks.SourceServer.SourceIndexBase : Task {
    protected int Successful;
    protected int Failed;
    protected int Skipped;
    private string sourceServerSdkPath;
    [CompilerGeneratedAttribute]
private ITaskItem[] <SymbolFiles>k__BackingField;
    private static String[] CandidateSdkPath;
    [CompilerGeneratedAttribute]
private string <SourceCommandFormat>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SourceTargetFormat>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <FailOnNoSourceInformationFound>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <NoSourceInformationInPdb>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <KeepTempFileForDebugging>k__BackingField;
    [RequiredAttribute]
public ITaskItem[] SymbolFiles { get; public set; }
    public string SourceServerSdkPath { get; public set; }
    public string SourceCommandFormat { get; public set; }
    public string SourceTargetFormat { get; public set; }
    public bool FailOnNoSourceInformationFound { get; public set; }
    public bool NoSourceInformationInPdb { get; private set; }
    public bool KeepTempFileForDebugging { get; public set; }
    private static SourceIndexBase();
    [CompilerGeneratedAttribute]
public ITaskItem[] get_SymbolFiles();
    [CompilerGeneratedAttribute]
public void set_SymbolFiles(ITaskItem[] value);
    public string get_SourceServerSdkPath();
    public void set_SourceServerSdkPath(string value);
    [CompilerGeneratedAttribute]
public string get_SourceCommandFormat();
    [CompilerGeneratedAttribute]
public void set_SourceCommandFormat(string value);
    [CompilerGeneratedAttribute]
public string get_SourceTargetFormat();
    [CompilerGeneratedAttribute]
public void set_SourceTargetFormat(string value);
    [CompilerGeneratedAttribute]
public bool get_FailOnNoSourceInformationFound();
    [CompilerGeneratedAttribute]
public void set_FailOnNoSourceInformationFound(bool value);
    [CompilerGeneratedAttribute]
public bool get_NoSourceInformationInPdb();
    [CompilerGeneratedAttribute]
private void set_NoSourceInformationInPdb(bool value);
    public virtual bool Execute();
    protected bool IndexSymbolFile(ITaskItem item);
    [CompilerGeneratedAttribute]
public bool get_KeepTempFileForDebugging();
    [CompilerGeneratedAttribute]
public void set_KeepTempFileForDebugging(bool value);
    protected virtual SymbolFile CreateSymbolFile(ITaskItem item);
    protected abstract virtual bool AddSourceProperties(SymbolFile symbolFile);
    protected abstract virtual bool CreateSourceIndexFile(SymbolFile symbolFile, string sourceIndexFile);
    protected virtual bool WriteSourceIndex(SymbolFile symbolFile, string sourceIndexFile);
    protected void CopyBuildEngine(ITask task);
}
public class MSBuild.Community.Tasks.SourceServer.SrcTool : ToolTask {
    [CompilerGeneratedAttribute]
private ITaskItem <PdbFile>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SourceOnly>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Filter>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Extract>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ExtractDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CountOnly>k__BackingField;
    private int _sourceCount;
    private List`1<string> _sourceFiles;
    private List`1<string> _extractedFiles;
    private static Regex _sourceCountRegex;
    public ITaskItem PdbFile { get; public set; }
    public bool SourceOnly { get; public set; }
    public string Filter { get; public set; }
    public bool Extract { get; public set; }
    public string ExtractDirectory { get; public set; }
    public bool CountOnly { get; public set; }
    [OutputAttribute]
public int SourceCount { get; public set; }
    [OutputAttribute]
public String[] SourceFiles { get; }
    [OutputAttribute]
public String[] ExtractedFiles { get; }
    protected string ToolName { get; }
    protected MessageImportance StandardOutputLoggingImportance { get; }
    private static SrcTool();
    [CompilerGeneratedAttribute]
public ITaskItem get_PdbFile();
    [CompilerGeneratedAttribute]
public void set_PdbFile(ITaskItem value);
    [CompilerGeneratedAttribute]
public bool get_SourceOnly();
    [CompilerGeneratedAttribute]
public void set_SourceOnly(bool value);
    [CompilerGeneratedAttribute]
public string get_Filter();
    [CompilerGeneratedAttribute]
public void set_Filter(string value);
    [CompilerGeneratedAttribute]
public bool get_Extract();
    [CompilerGeneratedAttribute]
public void set_Extract(bool value);
    [CompilerGeneratedAttribute]
public string get_ExtractDirectory();
    [CompilerGeneratedAttribute]
public void set_ExtractDirectory(string value);
    [CompilerGeneratedAttribute]
public bool get_CountOnly();
    [CompilerGeneratedAttribute]
public void set_CountOnly(bool value);
    public int get_SourceCount();
    public void set_SourceCount(int value);
    public String[] get_SourceFiles();
    public String[] get_ExtractedFiles();
    protected virtual string GenerateCommandLineCommands();
    protected virtual void LogEventsFromTextOutput(string singleLine, MessageImportance messageImportance);
    private void ParseCount(string line);
    protected virtual bool HandleTaskExecutionErrors();
    protected virtual string GenerateFullPathToTool();
    protected virtual string get_ToolName();
    protected virtual void LogToolCommand(string message);
    protected virtual MessageImportance get_StandardOutputLoggingImportance();
}
public class MSBuild.Community.Tasks.SourceServer.SvnSourceIndex : SourceIndexBase {
    private XmlSerializer _infoSerializer;
    [CompilerGeneratedAttribute]
private string <SourceServerName>k__BackingField;
    [RequiredAttribute]
public string SourceServerName { get; public set; }
    [CompilerGeneratedAttribute]
public string get_SourceServerName();
    [CompilerGeneratedAttribute]
public void set_SourceServerName(string value);
    protected virtual bool AddSourceProperties(SymbolFile symbolFile);
    private bool ConvertOutput(string output, Info& info);
    private bool GetSourceInfomation(IList`1<SourceFile> sourceFiles, String& output);
    private void AddProperties(SourceFile sourceFile, Entry entry);
    protected virtual bool CreateSourceIndexFile(SymbolFile symbolFile, string sourceIndexFile);
}
public class MSBuild.Community.Tasks.SourceServer.SymbolFile : FileBase {
    [CompilerGeneratedAttribute]
private IList`1<SourceFile> <SourceFiles>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsIndexed>k__BackingField;
    public IList`1<SourceFile> SourceFiles { get; private set; }
    public bool IsIndexed { get; public set; }
    public SymbolFile(string fileName);
    public SymbolFile(FileInfo fileInfo);
    [CompilerGeneratedAttribute]
public IList`1<SourceFile> get_SourceFiles();
    [CompilerGeneratedAttribute]
private void set_SourceFiles(IList`1<SourceFile> value);
    [CompilerGeneratedAttribute]
public bool get_IsIndexed();
    [CompilerGeneratedAttribute]
public void set_IsIndexed(bool value);
    public void AddSourceFiles(IEnumerable`1<string> files);
}
public class MSBuild.Community.Tasks.SourceServer.TfsSourceIndex : SourceIndexBase {
    [CompilerGeneratedAttribute]
private string <TeamProjectCollectionUri>k__BackingField;
    [CompilerGeneratedAttribute]
private string <WorkspaceDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Collection>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ChangesetVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TeamProjectRootDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TeamProjectName>k__BackingField;
    [RequiredAttribute]
public string TeamProjectCollectionUri { get; public set; }
    public string WorkspaceDirectory { get; public set; }
    public string Collection { get; public set; }
    public string ChangesetVersion { get; public set; }
    [RequiredAttribute]
public string TeamProjectRootDirectory { get; public set; }
    [RequiredAttribute]
public string TeamProjectName { get; public set; }
    public bool ServerMode { get; }
    [CompilerGeneratedAttribute]
public string get_TeamProjectCollectionUri();
    [CompilerGeneratedAttribute]
public void set_TeamProjectCollectionUri(string value);
    [CompilerGeneratedAttribute]
public string get_WorkspaceDirectory();
    [CompilerGeneratedAttribute]
public void set_WorkspaceDirectory(string value);
    [CompilerGeneratedAttribute]
public string get_Collection();
    [CompilerGeneratedAttribute]
public void set_Collection(string value);
    [CompilerGeneratedAttribute]
public string get_ChangesetVersion();
    [CompilerGeneratedAttribute]
public void set_ChangesetVersion(string value);
    [CompilerGeneratedAttribute]
public string get_TeamProjectRootDirectory();
    [CompilerGeneratedAttribute]
public void set_TeamProjectRootDirectory(string value);
    [CompilerGeneratedAttribute]
public string get_TeamProjectName();
    [CompilerGeneratedAttribute]
public void set_TeamProjectName(string value);
    public virtual bool Execute();
    protected virtual bool AddSourceProperties(SymbolFile symbolFile);
    protected virtual bool CreateSourceIndexFile(SymbolFile symbolFile, string sourceIndexFile);
    public bool get_ServerMode();
    private Dictionary`2<string, IItemInformation> GetItemInformation(IEnumerable`1<ITaskItem> files);
    private ITaskItem[] GetItemSpecs(IEnumerable`1<ITaskItem> files);
    private string GetItemSpec(string value, bool serverMode);
    public static string ReplaceString(string value, string oldValue, string newValue, StringComparison comparison);
    [CompilerGeneratedAttribute]
private TaskItem <GetItemSpecs>b__30_0(ITaskItem item);
}
public class MSBuild.Community.Tasks.SqlExecute : Task {
    private static string NONQUERY;
    private static string SCALAR;
    private static string SCALARXML;
    private string _conStr;
    private string _cmd;
    private string _mode;
    private int _result;
    private string _output;
    private int _commandTimeout;
    [RequiredAttribute]
public string ConnectionString { get; public set; }
    [RequiredAttribute]
public string Command { get; public set; }
    [DefaultValueAttribute("30")]
public int CommandTimeout { get; public set; }
    public string SelectMode { get; public set; }
    public string OutputFile { get; public set; }
    [OutputAttribute]
public int Result { get; }
    public virtual bool Execute();
    public string get_ConnectionString();
    public void set_ConnectionString(string value);
    public string get_Command();
    public void set_Command(string value);
    public int get_CommandTimeout();
    public void set_CommandTimeout(int value);
    public string get_SelectMode();
    public void set_SelectMode(string value);
    public string get_OutputFile();
    public void set_OutputFile(string value);
    private bool IsOutputFileSpecified(string selectionMode);
    public int get_Result();
}
public class MSBuild.Community.Tasks.SqlServer.ExecuteDDL : Task {
    private string _batchSeparator;
    private int _statementTimeout;
    private ServerConnectionWrapper _conn;
    private string _connStr;
    private ITaskItem[] _files;
    private List`1<int> _results;
    [RequiredAttribute]
public string ConnectionString { get; public set; }
    [RequiredAttribute]
public ITaskItem[] Files { get; public set; }
    [OutputAttribute]
public Int32[] Results { get; }
    public int StatementTimeout { get; public set; }
    private ServerConnectionWrapper Connection { get; }
    public string BatchSeparator { get; public set; }
    public string get_ConnectionString();
    public void set_ConnectionString(string value);
    public ITaskItem[] get_Files();
    public void set_Files(ITaskItem[] value);
    public Int32[] get_Results();
    public int get_StatementTimeout();
    public void set_StatementTimeout(int value);
    private ServerConnectionWrapper get_Connection();
    public virtual bool Execute();
    private bool ExecuteSql(string sql);
    private void InfoMessage(object sender, SqlInfoMessageEventArgs e);
    private string ReadFile(string path);
    public string get_BatchSeparator();
    public void set_BatchSeparator(string value);
}
internal class MSBuild.Community.Tasks.SqlServer.ServerConnectionWrapper : object {
    public static String[] AssemblyNames;
    private static Assembly modreq(System.Runtime.CompilerServices.IsVolatile) _assembly;
    private static object _lock;
    private Type _type;
    private object _instance;
    public string ConnectionString { get; public set; }
    public string BatchSeparator { get; public set; }
    public int StatementTimeout { get; public set; }
    private static ServerConnectionWrapper();
    private static void LoadAssembly();
    public string get_ConnectionString();
    public void set_ConnectionString(string value);
    public string get_BatchSeparator();
    public void set_BatchSeparator(string value);
    public int get_StatementTimeout();
    public void set_StatementTimeout(int value);
    public void add_InfoMessage(SqlInfoMessageEventHandler value);
    public void remove_InfoMessage(SqlInfoMessageEventHandler value);
    public void Connect();
    public void Disconnect();
    public int ExecuteNonQuery(string command);
    private T InternalInvoke(string name, Object[] args);
    private static object CreateInstance(Type type, Object[] args);
    private static void HandleReflectionException(TargetInvocationException e);
}
public enum MSBuild.Community.Tasks.SqlServer.SqlPubCommands : Enum {
    public int value__;
    public static SqlPubCommands Script;
    public static SqlPubCommands Publish;
}
public class MSBuild.Community.Tasks.SqlServer.SqlPubWiz : ToolTask {
    private static string InstallPathKey;
    private SqlPubCommands _command;
    private string _connectionString;
    private string _database;
    private string _username;
    private string _password;
    private string _server;
    private ITaskItem _output;
    private bool _schemaOnly;
    private bool _dataOnly;
    private string _targetServer;
    private bool _noSchemaQualify;
    private bool _noDropExisting;
    private bool _quiet;
    private string _hosterName;
    private string _webServiceAddress;
    private string _serviceUsername;
    private string _servicePassword;
    private string _serviceDatabaseServer;
    private string _serviceDatabase;
    private bool _noTransaction;
    public string Command { get; public set; }
    public string ConnectionString { get; public set; }
    public string Database { get; public set; }
    public string Username { get; public set; }
    public string Password { get; public set; }
    public string Server { get; public set; }
    public ITaskItem Output { get; public set; }
    public bool SchemaOnly { get; public set; }
    public bool DataOnly { get; public set; }
    public string TargetServer { get; public set; }
    public bool NoSchemaQualify { get; public set; }
    public bool NoDropExisting { get; public set; }
    public bool Quiet { get; public set; }
    public string HosterName { get; public set; }
    public string WebServiceAddress { get; public set; }
    public string ServiceUsername { get; public set; }
    public string ServicePassword { get; public set; }
    public string ServiceDatabaseServer { get; public set; }
    public string ServiceDatabase { get; public set; }
    public bool NoTransaction { get; public set; }
    protected string ToolName { get; }
    protected MessageImportance StandardOutputLoggingImportance { get; }
    public string get_Command();
    public void set_Command(string value);
    public string get_ConnectionString();
    public void set_ConnectionString(string value);
    public string get_Database();
    public void set_Database(string value);
    public string get_Username();
    public void set_Username(string value);
    public string get_Password();
    public void set_Password(string value);
    public string get_Server();
    public void set_Server(string value);
    public ITaskItem get_Output();
    public void set_Output(ITaskItem value);
    public bool get_SchemaOnly();
    public void set_SchemaOnly(bool value);
    public bool get_DataOnly();
    public void set_DataOnly(bool value);
    public string get_TargetServer();
    public void set_TargetServer(string value);
    public bool get_NoSchemaQualify();
    public void set_NoSchemaQualify(bool value);
    public bool get_NoDropExisting();
    public void set_NoDropExisting(bool value);
    public bool get_Quiet();
    public void set_Quiet(bool value);
    public string get_HosterName();
    public void set_HosterName(string value);
    public string get_WebServiceAddress();
    public void set_WebServiceAddress(string value);
    public string get_ServiceUsername();
    public void set_ServiceUsername(string value);
    public string get_ServicePassword();
    public void set_ServicePassword(string value);
    public string get_ServiceDatabaseServer();
    public void set_ServiceDatabaseServer(string value);
    public string get_ServiceDatabase();
    public void set_ServiceDatabase(string value);
    public bool get_NoTransaction();
    public void set_NoTransaction(bool value);
    protected virtual string GenerateFullPathToTool();
    protected virtual string get_ToolName();
    protected virtual string GenerateCommandLineCommands();
    protected virtual void LogToolCommand(string message);
    protected virtual MessageImportance get_StandardOutputLoggingImportance();
    private void AppendPublishCommands(CommandLineBuilder builder);
    private void AppendScriptCommands(CommandLineBuilder builder);
}
[DebuggerDisplayAttribute("Path: {Path}")]
[XmlTypeAttribute]
public class MSBuild.Community.Tasks.Subversion.Entry : object {
    [CompilerGeneratedAttribute]
private string <Url>k__BackingField;
    [CompilerGeneratedAttribute]
private Repository <Repository>k__BackingField;
    [CompilerGeneratedAttribute]
private WorkingCopy <WorkingCopy>k__BackingField;
    [CompilerGeneratedAttribute]
private LastCommit <Commit>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Kind>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Revision>k__BackingField;
    [XmlElementAttribute("url")]
public string Url { get; public set; }
    [XmlElementAttribute("repository")]
public Repository Repository { get; public set; }
    [XmlElementAttribute("wc-info")]
public WorkingCopy WorkingCopy { get; public set; }
    [XmlElementAttribute("commit")]
public LastCommit Commit { get; public set; }
    [XmlAttributeAttribute("kind")]
public string Kind { get; public set; }
    [XmlAttributeAttribute("path")]
public string Path { get; public set; }
    [XmlAttributeAttribute("revision")]
public long Revision { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Url();
    [CompilerGeneratedAttribute]
public void set_Url(string value);
    [CompilerGeneratedAttribute]
public Repository get_Repository();
    [CompilerGeneratedAttribute]
public void set_Repository(Repository value);
    [CompilerGeneratedAttribute]
public WorkingCopy get_WorkingCopy();
    [CompilerGeneratedAttribute]
public void set_WorkingCopy(WorkingCopy value);
    [CompilerGeneratedAttribute]
public LastCommit get_Commit();
    [CompilerGeneratedAttribute]
public void set_Commit(LastCommit value);
    [CompilerGeneratedAttribute]
public string get_Kind();
    [CompilerGeneratedAttribute]
public void set_Kind(string value);
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
public void set_Path(string value);
    [CompilerGeneratedAttribute]
public long get_Revision();
    [CompilerGeneratedAttribute]
public void set_Revision(long value);
}
public class MSBuild.Community.Tasks.Subversion.EntryCollection : KeyedCollection`2<string, Entry> {
    protected virtual string GetKeyForItem(Entry item);
}
[XmlRootAttribute("info")]
[XmlTypeAttribute]
public class MSBuild.Community.Tasks.Subversion.Info : object {
    [CompilerGeneratedAttribute]
private EntryCollection <Entries>k__BackingField;
    [XmlElementAttribute("entry")]
public EntryCollection Entries { get; public set; }
    [CompilerGeneratedAttribute]
public EntryCollection get_Entries();
    [CompilerGeneratedAttribute]
public void set_Entries(EntryCollection value);
}
[DebuggerDisplayAttribute("Revision: {Revision} Date: {Date}")]
[XmlTypeAttribute]
public class MSBuild.Community.Tasks.Subversion.LastCommit : object {
    [CompilerGeneratedAttribute]
private string <Author>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <Date>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DateSpecified>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Revision>k__BackingField;
    [XmlElementAttribute("author")]
public string Author { get; public set; }
    [XmlElementAttribute("date")]
public DateTime Date { get; public set; }
    [XmlIgnoreAttribute]
public bool DateSpecified { get; public set; }
    [XmlAttributeAttribute("revision")]
public long Revision { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Author();
    [CompilerGeneratedAttribute]
public void set_Author(string value);
    [CompilerGeneratedAttribute]
public DateTime get_Date();
    [CompilerGeneratedAttribute]
public void set_Date(DateTime value);
    [CompilerGeneratedAttribute]
public bool get_DateSpecified();
    [CompilerGeneratedAttribute]
public void set_DateSpecified(bool value);
    [CompilerGeneratedAttribute]
public long get_Revision();
    [CompilerGeneratedAttribute]
public void set_Revision(long value);
}
public enum MSBuild.Community.Tasks.Subversion.NodeKind : Enum {
    public int value__;
    public static NodeKind file;
    public static NodeKind dir;
    public static NodeKind unknown;
}
[DebuggerDisplayAttribute("Root: {Root}")]
[XmlTypeAttribute]
public class MSBuild.Community.Tasks.Subversion.Repository : object {
    [CompilerGeneratedAttribute]
private string <Root>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Uuid>k__BackingField;
    [XmlElementAttribute("root")]
public string Root { get; public set; }
    [XmlElementAttribute("uuid")]
public string Uuid { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Root();
    [CompilerGeneratedAttribute]
public void set_Root(string value);
    [CompilerGeneratedAttribute]
public string get_Uuid();
    [CompilerGeneratedAttribute]
public void set_Uuid(string value);
}
public enum MSBuild.Community.Tasks.Subversion.Schedule : Enum {
    public int value__;
    public static Schedule normal;
    public static Schedule unknown;
}
public class MSBuild.Community.Tasks.Subversion.SvnCheckout : SvnClient {
    protected virtual bool ValidateParameters();
}
public class MSBuild.Community.Tasks.Subversion.SvnClient : ToolTask {
    private static string _switchBooleanFormat;
    private static string _switchStringFormat;
    private static string _switchValueFormat;
    private static Regex _revisionParse;
    private StringBuilder _outputBuffer;
    private StringBuilder _errorBuffer;
    private static string _sanitizedPasswordArgument;
    private string _passwordArgument;
    private string _command;
    private string _arguments;
    private string _username;
    private string _password;
    private bool _sanitizePassword;
    private bool _verbose;
    private bool _force;
    private string _message;
    private string _messageFile;
    private string _repositoryPath;
    private string _localPath;
    private string _targetFile;
    private ITaskItem[] _targets;
    private bool _nonInteractive;
    private bool _noAuthCache;
    private bool _trustServerCert;
    private bool _xml;
    private int _revision;
    public string Command { get; public set; }
    public string Arguments { get; public set; }
    public string Username { get; public set; }
    public string Password { get; public set; }
    public bool SanitizePassword { get; public set; }
    public bool Verbose { get; public set; }
    public bool Force { get; public set; }
    public string Message { get; public set; }
    public string MessageFile { get; public set; }
    [OutputAttribute]
public string RepositoryPath { get; public set; }
    public string LocalPath { get; public set; }
    public string TargetFile { get; public set; }
    public ITaskItem[] Targets { get; public set; }
    public bool NonInteractive { get; public set; }
    public bool NoAuthCache { get; public set; }
    public bool TrustServerCert { get; public set; }
    public bool Xml { get; public set; }
    [OutputAttribute]
public int Revision { get; public set; }
    [OutputAttribute]
public string StandardOutput { get; }
    [OutputAttribute]
public string StandardError { get; }
    protected MessageImportance StandardOutputLoggingImportance { get; }
    protected MessageImportance StandardErrorLoggingImportance { get; }
    protected string ToolName { get; }
    private static SvnClient();
    public string get_Command();
    public void set_Command(string value);
    public string get_Arguments();
    public void set_Arguments(string value);
    public string get_Username();
    public void set_Username(string value);
    public string get_Password();
    public void set_Password(string value);
    public bool get_SanitizePassword();
    public void set_SanitizePassword(bool value);
    public bool get_Verbose();
    public void set_Verbose(bool value);
    public bool get_Force();
    public void set_Force(bool value);
    public string get_Message();
    public void set_Message(string value);
    public string get_MessageFile();
    public void set_MessageFile(string value);
    public string get_RepositoryPath();
    public void set_RepositoryPath(string value);
    public string get_LocalPath();
    public void set_LocalPath(string value);
    public string get_TargetFile();
    public void set_TargetFile(string value);
    public ITaskItem[] get_Targets();
    public void set_Targets(ITaskItem[] value);
    public bool get_NonInteractive();
    public void set_NonInteractive(bool value);
    public bool get_NoAuthCache();
    public void set_NoAuthCache(bool value);
    public bool get_TrustServerCert();
    public void set_TrustServerCert(bool value);
    public bool get_Xml();
    public void set_Xml(bool value);
    public int get_Revision();
    public void set_Revision(int value);
    public string get_StandardOutput();
    public string get_StandardError();
    protected virtual string GenerateSvnCommand();
    protected virtual string GenerateSvnArguments();
    public virtual bool Execute();
    protected virtual string GenerateCommandLineCommands();
    protected virtual bool ValidateParameters();
    protected virtual void LogEventsFromTextOutput(string singleLine, MessageImportance messageImportance);
    protected virtual string GenerateFullPathToTool();
    public static string FindToolPath(string toolName);
    protected virtual void LogToolCommand(string message);
    protected virtual MessageImportance get_StandardOutputLoggingImportance();
    protected virtual MessageImportance get_StandardErrorLoggingImportance();
    protected virtual string get_ToolName();
}
public class MSBuild.Community.Tasks.Subversion.SvnCommit : SvnClient {
    protected virtual bool ValidateParameters();
}
public class MSBuild.Community.Tasks.Subversion.SvnCopy : SvnClient {
    private string sourcePath;
    private string destinationPath;
    private bool buildTree;
    public string SourcePath { get; public set; }
    public string DestinationPath { get; public set; }
    public bool BuildTree { get; public set; }
    public string get_SourcePath();
    public void set_SourcePath(string value);
    public string get_DestinationPath();
    public void set_DestinationPath(string value);
    public bool get_BuildTree();
    public void set_BuildTree(bool value);
    protected virtual string GenerateSvnCommand();
    protected virtual bool ValidateParameters();
}
public class MSBuild.Community.Tasks.Subversion.SvnExport : SvnClient {
    protected virtual bool ValidateParameters();
}
public class MSBuild.Community.Tasks.Subversion.SvnInfo : SvnClient {
    [CompilerGeneratedAttribute]
private string <RepositoryRoot>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RepositoryUuid>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NodeKind>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LastChangedAuthor>k__BackingField;
    [CompilerGeneratedAttribute]
private int <LastChangedRevision>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <LastChangedDate>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Schedule>k__BackingField;
    [OutputAttribute]
public string RepositoryRoot { get; private set; }
    [OutputAttribute]
public string RepositoryUuid { get; private set; }
    [OutputAttribute]
public string NodeKind { get; private set; }
    [OutputAttribute]
public string LastChangedAuthor { get; private set; }
    [OutputAttribute]
public int LastChangedRevision { get; private set; }
    [OutputAttribute]
public DateTime LastChangedDate { get; private set; }
    [OutputAttribute]
public string Schedule { get; private set; }
    [CompilerGeneratedAttribute]
public string get_RepositoryRoot();
    [CompilerGeneratedAttribute]
private void set_RepositoryRoot(string value);
    [CompilerGeneratedAttribute]
public string get_RepositoryUuid();
    [CompilerGeneratedAttribute]
private void set_RepositoryUuid(string value);
    [CompilerGeneratedAttribute]
public string get_NodeKind();
    [CompilerGeneratedAttribute]
private void set_NodeKind(string value);
    [CompilerGeneratedAttribute]
public string get_LastChangedAuthor();
    [CompilerGeneratedAttribute]
private void set_LastChangedAuthor(string value);
    [CompilerGeneratedAttribute]
public int get_LastChangedRevision();
    [CompilerGeneratedAttribute]
private void set_LastChangedRevision(int value);
    [CompilerGeneratedAttribute]
public DateTime get_LastChangedDate();
    [CompilerGeneratedAttribute]
private void set_LastChangedDate(DateTime value);
    [CompilerGeneratedAttribute]
public string get_Schedule();
    [CompilerGeneratedAttribute]
private void set_Schedule(string value);
    private void ResetMemberVariables();
    public virtual bool Execute();
    private void Parse();
}
public class MSBuild.Community.Tasks.Subversion.SvnStatus : SvnClient {
    private List`1<ITaskItem> _modified;
    [OutputAttribute]
public ITaskItem[] Entries { get; public set; }
    public virtual bool Execute();
    private void Parse();
    public ITaskItem[] get_Entries();
    public void set_Entries(ITaskItem[] value);
}
public class MSBuild.Community.Tasks.Subversion.SvnUpdate : SvnClient {
    protected virtual bool ValidateParameters();
}
public class MSBuild.Community.Tasks.Subversion.SvnVersion : ToolTask {
    private static Regex _numberRegex;
    private StringBuilder _outputBuffer;
    private string _localPath;
    private bool _useLastCommittedRevision;
    private int _highRevision;
    private int _lowRevision;
    private bool _modifications;
    private bool _switched;
    private bool _exported;
    [RequiredAttribute]
public string LocalPath { get; public set; }
    public bool UseLastCommittedRevision { get; public set; }
    [OutputAttribute]
public int Revision { get; public set; }
    [OutputAttribute]
public int HighRevision { get; public set; }
    [OutputAttribute]
public int LowRevision { get; public set; }
    [OutputAttribute]
public bool Modifications { get; public set; }
    [OutputAttribute]
public bool Switched { get; public set; }
    [OutputAttribute]
public bool Exported { get; public set; }
    protected MessageImportance StandardOutputLoggingImportance { get; }
    protected string ToolName { get; }
    private static SvnVersion();
    public string get_LocalPath();
    public void set_LocalPath(string value);
    public bool get_UseLastCommittedRevision();
    public void set_UseLastCommittedRevision(bool value);
    public int get_Revision();
    public void set_Revision(int value);
    public int get_HighRevision();
    public void set_HighRevision(int value);
    public int get_LowRevision();
    public void set_LowRevision(int value);
    public bool get_Modifications();
    public void set_Modifications(bool value);
    public bool get_Switched();
    public void set_Switched(bool value);
    public bool get_Exported();
    public void set_Exported(bool value);
    protected virtual string GenerateFullPathToTool();
    protected virtual void LogToolCommand(string message);
    protected virtual MessageImportance get_StandardOutputLoggingImportance();
    protected virtual string get_ToolName();
    protected virtual string GenerateCommandLineCommands();
    public virtual bool Execute();
    protected virtual void LogEventsFromTextOutput(string singleLine, MessageImportance messageImportance);
    private void ParseOutput();
}
[DebuggerDisplayAttribute("Schedule: {Schedule}")]
[XmlTypeAttribute]
public class MSBuild.Community.Tasks.Subversion.WorkingCopy : object {
    [CompilerGeneratedAttribute]
private string <Schedule>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Depth>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <TextUpdated>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <TextUpdatedSpecified>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Checksum>k__BackingField;
    [XmlElementAttribute("schedule")]
public string Schedule { get; public set; }
    [XmlElementAttribute("depth")]
public string Depth { get; public set; }
    [XmlElementAttribute("text-updated")]
public DateTime TextUpdated { get; public set; }
    [XmlIgnoreAttribute]
public bool TextUpdatedSpecified { get; public set; }
    [XmlElementAttribute("checksum")]
public string Checksum { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Schedule();
    [CompilerGeneratedAttribute]
public void set_Schedule(string value);
    [CompilerGeneratedAttribute]
public string get_Depth();
    [CompilerGeneratedAttribute]
public void set_Depth(string value);
    [CompilerGeneratedAttribute]
public DateTime get_TextUpdated();
    [CompilerGeneratedAttribute]
public void set_TextUpdated(DateTime value);
    [CompilerGeneratedAttribute]
public bool get_TextUpdatedSpecified();
    [CompilerGeneratedAttribute]
public void set_TextUpdatedSpecified(bool value);
    [CompilerGeneratedAttribute]
public string get_Checksum();
    [CompilerGeneratedAttribute]
public void set_Checksum(string value);
}
public class MSBuild.Community.Tasks.SymbolServer.SymStore : ToolTask {
    [CompilerGeneratedAttribute]
private string <Command>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Append>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Comment>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Compress>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LogFile>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Files>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Share>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ID>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Local>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Verbose>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Pointer>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Recursive>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Store>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Product>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Relative>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <NoReference>k__BackingField;
    [CompilerGeneratedAttribute]
private string <WriteIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ReadIndex>k__BackingField;
    public string Command { get; public set; }
    public bool Append { get; public set; }
    public string Comment { get; public set; }
    public bool Compress { get; public set; }
    public string LogFile { get; public set; }
    public string Files { get; public set; }
    public string Share { get; public set; }
    public string ID { get; public set; }
    public bool Local { get; public set; }
    public bool Verbose { get; public set; }
    public bool Pointer { get; public set; }
    public bool Recursive { get; public set; }
    public string Store { get; public set; }
    public string Product { get; public set; }
    public string Version { get; public set; }
    public string Message { get; public set; }
    public bool Relative { get; public set; }
    public bool NoReference { get; public set; }
    public string WriteIndex { get; public set; }
    public string ReadIndex { get; public set; }
    protected string ToolName { get; }
    protected MessageImportance StandardOutputLoggingImportance { get; }
    [CompilerGeneratedAttribute]
public string get_Command();
    [CompilerGeneratedAttribute]
public void set_Command(string value);
    [CompilerGeneratedAttribute]
public bool get_Append();
    [CompilerGeneratedAttribute]
public void set_Append(bool value);
    [CompilerGeneratedAttribute]
public string get_Comment();
    [CompilerGeneratedAttribute]
public void set_Comment(string value);
    [CompilerGeneratedAttribute]
public bool get_Compress();
    [CompilerGeneratedAttribute]
public void set_Compress(bool value);
    [CompilerGeneratedAttribute]
public string get_LogFile();
    [CompilerGeneratedAttribute]
public void set_LogFile(string value);
    [CompilerGeneratedAttribute]
public string get_Files();
    [CompilerGeneratedAttribute]
public void set_Files(string value);
    [CompilerGeneratedAttribute]
public string get_Share();
    [CompilerGeneratedAttribute]
public void set_Share(string value);
    [CompilerGeneratedAttribute]
public string get_ID();
    [CompilerGeneratedAttribute]
public void set_ID(string value);
    [CompilerGeneratedAttribute]
public bool get_Local();
    [CompilerGeneratedAttribute]
public void set_Local(bool value);
    [CompilerGeneratedAttribute]
public bool get_Verbose();
    [CompilerGeneratedAttribute]
public void set_Verbose(bool value);
    [CompilerGeneratedAttribute]
public bool get_Pointer();
    [CompilerGeneratedAttribute]
public void set_Pointer(bool value);
    [CompilerGeneratedAttribute]
public bool get_Recursive();
    [CompilerGeneratedAttribute]
public void set_Recursive(bool value);
    [CompilerGeneratedAttribute]
public string get_Store();
    [CompilerGeneratedAttribute]
public void set_Store(string value);
    [CompilerGeneratedAttribute]
public string get_Product();
    [CompilerGeneratedAttribute]
public void set_Product(string value);
    [CompilerGeneratedAttribute]
public string get_Version();
    [CompilerGeneratedAttribute]
public void set_Version(string value);
    [CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
public void set_Message(string value);
    [CompilerGeneratedAttribute]
public bool get_Relative();
    [CompilerGeneratedAttribute]
public void set_Relative(bool value);
    [CompilerGeneratedAttribute]
public bool get_NoReference();
    [CompilerGeneratedAttribute]
public void set_NoReference(bool value);
    [CompilerGeneratedAttribute]
public string get_WriteIndex();
    [CompilerGeneratedAttribute]
public void set_WriteIndex(string value);
    [CompilerGeneratedAttribute]
public string get_ReadIndex();
    [CompilerGeneratedAttribute]
public void set_ReadIndex(string value);
    protected virtual string GenerateCommandLineCommands();
    protected virtual string GenerateFullPathToTool();
    protected virtual string get_ToolName();
    protected virtual void LogToolCommand(string message);
    protected virtual MessageImportance get_StandardOutputLoggingImportance();
}
public enum MSBuild.Community.Tasks.SymbolServer.SymStoreCommands : Enum {
    public int value__;
    public static SymStoreCommands add;
    public static SymStoreCommands query;
    public static SymStoreCommands delete;
}
public class MSBuild.Community.Tasks.TemplateFile : Task {
    public static string MetadataValueTag;
    private ITaskItem _outputFile;
    private string _outputFilename;
    private Regex _regex;
    private ITaskItem _templateFile;
    private Dictionary`2<string, string> _tokenPairs;
    private ITaskItem[] _tokens;
    private static string DefaultExt;
    [OutputAttribute]
public ITaskItem OutputFile { get; public set; }
    public string OutputFilename { get; public set; }
    [RequiredAttribute]
public ITaskItem Template { get; public set; }
    public ITaskItem[] Tokens { get; public set; }
    private static TemplateFile();
    public ITaskItem get_OutputFile();
    public void set_OutputFile(ITaskItem value);
    public string get_OutputFilename();
    public void set_OutputFilename(string value);
    public ITaskItem get_Template();
    public void set_Template(ITaskItem value);
    public ITaskItem[] get_Tokens();
    public void set_Tokens(ITaskItem[] value);
    public virtual bool Execute();
    private string GetOutputFilename();
    private string MatchEval(Match match);
    private void ParseTokens();
}
public interface MSBuild.Community.Tasks.Tfs.IItemInformation {
    public string ServerPath { get; public set; }
    public string Changeset { get; public set; }
    public abstract virtual string get_ServerPath();
    public abstract virtual void set_ServerPath(string value);
    public abstract virtual string get_Changeset();
    public abstract virtual void set_Changeset(string value);
}
public class MSBuild.Community.Tasks.Tfs.InfoCommandResponse : object {
    [CompilerGeneratedAttribute]
private Dictionary`2<string, IItemInformation> <LocalInformation>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, IItemInformation> <ServerInformation>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Response>k__BackingField;
    public Dictionary`2<string, IItemInformation> LocalInformation { get; public set; }
    public Dictionary`2<string, IItemInformation> ServerInformation { get; public set; }
    public string Response { get; public set; }
    public InfoCommandResponse(string output);
    private void Parse();
    private string GetValue(string line);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, IItemInformation> get_LocalInformation();
    [CompilerGeneratedAttribute]
public void set_LocalInformation(Dictionary`2<string, IItemInformation> value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, IItemInformation> get_ServerInformation();
    [CompilerGeneratedAttribute]
public void set_ServerInformation(Dictionary`2<string, IItemInformation> value);
    [CompilerGeneratedAttribute]
public string get_Response();
    [CompilerGeneratedAttribute]
public void set_Response(string value);
}
public class MSBuild.Community.Tasks.Tfs.LocalInformation : object {
    [CompilerGeneratedAttribute]
private string <LocalPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ServerPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Changeset>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Change>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Type>k__BackingField;
    public string LocalPath { get; public set; }
    public string ServerPath { get; public set; }
    public string Changeset { get; public set; }
    public string Change { get; public set; }
    public string Type { get; public set; }
    [CompilerGeneratedAttribute]
public string get_LocalPath();
    [CompilerGeneratedAttribute]
public void set_LocalPath(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_ServerPath();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ServerPath(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Changeset();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Changeset(string value);
    [CompilerGeneratedAttribute]
public string get_Change();
    [CompilerGeneratedAttribute]
public void set_Change(string value);
    [CompilerGeneratedAttribute]
public string get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(string value);
}
public class MSBuild.Community.Tasks.Tfs.ServerInformation : object {
    [CompilerGeneratedAttribute]
private string <ServerPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Changeset>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DeletionID>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Lock>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LockOwner>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LastModified>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FileType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Size>k__BackingField;
    public string ServerPath { get; public set; }
    public string Changeset { get; public set; }
    public string DeletionID { get; public set; }
    public string Lock { get; public set; }
    public string LockOwner { get; public set; }
    public string LastModified { get; public set; }
    public string Type { get; public set; }
    public string FileType { get; public set; }
    public string Size { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual string get_ServerPath();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ServerPath(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Changeset();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Changeset(string value);
    [CompilerGeneratedAttribute]
public string get_DeletionID();
    [CompilerGeneratedAttribute]
public void set_DeletionID(string value);
    [CompilerGeneratedAttribute]
public string get_Lock();
    [CompilerGeneratedAttribute]
public void set_Lock(string value);
    [CompilerGeneratedAttribute]
public string get_LockOwner();
    [CompilerGeneratedAttribute]
public void set_LockOwner(string value);
    [CompilerGeneratedAttribute]
public string get_LastModified();
    [CompilerGeneratedAttribute]
public void set_LastModified(string value);
    [CompilerGeneratedAttribute]
public string get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(string value);
    [CompilerGeneratedAttribute]
public string get_FileType();
    [CompilerGeneratedAttribute]
public void set_FileType(string value);
    [CompilerGeneratedAttribute]
public string get_Size();
    [CompilerGeneratedAttribute]
public void set_Size(string value);
}
public class MSBuild.Community.Tasks.Tfs.TfsClient : ToolTask {
    [CompilerGeneratedAttribute]
private string <Command>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem[] <Files>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Recursive>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <All>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Overwrite>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Force>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Preview>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Remap>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Silent>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Saved>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Validate>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Bypass>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Comment>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Lock>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Author>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Notes>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Format>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Collection>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Override>k__BackingField;
    [CompilerGeneratedAttribute]
private string <UserName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Password>k__BackingField;
    [CompilerGeneratedAttribute]
private string <WorkspaceName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <WorkspaceOwner>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ShelveSetName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ShelveSetOwner>k__BackingField;
    [CompilerGeneratedAttribute]
private StringBuilder <Output>k__BackingField;
    [CompilerGeneratedAttribute]
private string <WorkingDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Changeset>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ChangesetVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ServerPath>k__BackingField;
    private static String[] candidatePaths;
    private static int MaxCommandlineLength;
    private Nullable`1<bool> batchRequired;
    public string Command { get; public set; }
    public ITaskItem[] Files { get; public set; }
    public bool Recursive { get; public set; }
    public bool All { get; public set; }
    public bool Overwrite { get; public set; }
    public bool Force { get; public set; }
    public bool Preview { get; public set; }
    public bool Remap { get; public set; }
    public bool Silent { get; public set; }
    public bool Saved { get; public set; }
    public bool Validate { get; public set; }
    public bool Bypass { get; public set; }
    public string Comment { get; public set; }
    public string Version { get; public set; }
    public string Lock { get; public set; }
    public string Type { get; public set; }
    public string Author { get; public set; }
    public string Notes { get; public set; }
    public string Format { get; public set; }
    public string Collection { get; public set; }
    public string Override { get; public set; }
    public string UserName { get; public set; }
    public string Password { get; public set; }
    public string WorkspaceName { get; public set; }
    public string WorkspaceOwner { get; public set; }
    public string ShelveSetName { get; public set; }
    public string ShelveSetOwner { get; public set; }
    public StringBuilder Output { get; private set; }
    public string WorkingDirectory { get; public set; }
    [OutputAttribute]
public string Changeset { get; public set; }
    public string ChangesetVersion { get; public set; }
    [OutputAttribute]
public string ServerPath { get; public set; }
    protected MessageImportance StandardOutputLoggingImportance { get; }
    protected MessageImportance StandardErrorLoggingImportance { get; }
    protected string ToolName { get; }
    public Nullable`1<bool> BatchRequired { get; private set; }
    private static TfsClient();
    [CompilerGeneratedAttribute]
public string get_Command();
    [CompilerGeneratedAttribute]
public void set_Command(string value);
    [CompilerGeneratedAttribute]
public ITaskItem[] get_Files();
    [CompilerGeneratedAttribute]
public void set_Files(ITaskItem[] value);
    [CompilerGeneratedAttribute]
public bool get_Recursive();
    [CompilerGeneratedAttribute]
public void set_Recursive(bool value);
    [CompilerGeneratedAttribute]
public bool get_All();
    [CompilerGeneratedAttribute]
public void set_All(bool value);
    [CompilerGeneratedAttribute]
public bool get_Overwrite();
    [CompilerGeneratedAttribute]
public void set_Overwrite(bool value);
    [CompilerGeneratedAttribute]
public bool get_Force();
    [CompilerGeneratedAttribute]
public void set_Force(bool value);
    [CompilerGeneratedAttribute]
public bool get_Preview();
    [CompilerGeneratedAttribute]
public void set_Preview(bool value);
    [CompilerGeneratedAttribute]
public bool get_Remap();
    [CompilerGeneratedAttribute]
public void set_Remap(bool value);
    [CompilerGeneratedAttribute]
public bool get_Silent();
    [CompilerGeneratedAttribute]
public void set_Silent(bool value);
    [CompilerGeneratedAttribute]
public bool get_Saved();
    [CompilerGeneratedAttribute]
public void set_Saved(bool value);
    [CompilerGeneratedAttribute]
public bool get_Validate();
    [CompilerGeneratedAttribute]
public void set_Validate(bool value);
    [CompilerGeneratedAttribute]
public bool get_Bypass();
    [CompilerGeneratedAttribute]
public void set_Bypass(bool value);
    [CompilerGeneratedAttribute]
public string get_Comment();
    [CompilerGeneratedAttribute]
public void set_Comment(string value);
    [CompilerGeneratedAttribute]
public string get_Version();
    [CompilerGeneratedAttribute]
public void set_Version(string value);
    [CompilerGeneratedAttribute]
public string get_Lock();
    [CompilerGeneratedAttribute]
public void set_Lock(string value);
    [CompilerGeneratedAttribute]
public string get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(string value);
    [CompilerGeneratedAttribute]
public string get_Author();
    [CompilerGeneratedAttribute]
public void set_Author(string value);
    [CompilerGeneratedAttribute]
public string get_Notes();
    [CompilerGeneratedAttribute]
public void set_Notes(string value);
    [CompilerGeneratedAttribute]
public string get_Format();
    [CompilerGeneratedAttribute]
public void set_Format(string value);
    [CompilerGeneratedAttribute]
public string get_Collection();
    [CompilerGeneratedAttribute]
public void set_Collection(string value);
    [CompilerGeneratedAttribute]
public string get_Override();
    [CompilerGeneratedAttribute]
public void set_Override(string value);
    [CompilerGeneratedAttribute]
public string get_UserName();
    [CompilerGeneratedAttribute]
public void set_UserName(string value);
    [CompilerGeneratedAttribute]
public string get_Password();
    [CompilerGeneratedAttribute]
public void set_Password(string value);
    [CompilerGeneratedAttribute]
public string get_WorkspaceName();
    [CompilerGeneratedAttribute]
public void set_WorkspaceName(string value);
    [CompilerGeneratedAttribute]
public string get_WorkspaceOwner();
    [CompilerGeneratedAttribute]
public void set_WorkspaceOwner(string value);
    [CompilerGeneratedAttribute]
public string get_ShelveSetName();
    [CompilerGeneratedAttribute]
public void set_ShelveSetName(string value);
    [CompilerGeneratedAttribute]
public string get_ShelveSetOwner();
    [CompilerGeneratedAttribute]
public void set_ShelveSetOwner(string value);
    [CompilerGeneratedAttribute]
public StringBuilder get_Output();
    [CompilerGeneratedAttribute]
private void set_Output(StringBuilder value);
    [CompilerGeneratedAttribute]
public string get_WorkingDirectory();
    [CompilerGeneratedAttribute]
public void set_WorkingDirectory(string value);
    [CompilerGeneratedAttribute]
public string get_Changeset();
    [CompilerGeneratedAttribute]
public void set_Changeset(string value);
    [CompilerGeneratedAttribute]
public string get_ChangesetVersion();
    [CompilerGeneratedAttribute]
public void set_ChangesetVersion(string value);
    [CompilerGeneratedAttribute]
public string get_ServerPath();
    [CompilerGeneratedAttribute]
public void set_ServerPath(string value);
    private string FindToolPath(string toolName);
    protected virtual string GetWorkingDirectory();
    protected virtual void GenerateCommand(CommandLineBuilder builder);
    protected virtual void GenerateArguments(CommandLineBuilder builder);
    protected virtual string GenerateFullPathToTool();
    protected virtual void LogToolCommand(string message);
    protected virtual MessageImportance get_StandardOutputLoggingImportance();
    protected virtual MessageImportance get_StandardErrorLoggingImportance();
    protected virtual string get_ToolName();
    protected virtual string GenerateCommandLineCommands();
    protected virtual void LogEventsFromTextOutput(string singleLine, MessageImportance messageImportance);
    public virtual bool Execute();
    private bool ExecuteBatchMode();
    private void GetNextBatch(int indexOffSet, ITaskItem[] originalFiles, List`1<ITaskItem> batchFiles);
    public Nullable`1<bool> get_BatchRequired();
    private void set_BatchRequired(Nullable`1<bool> value);
    private void ParseOutput(string singleLine);
    protected virtual bool ValidateParameters();
}
public class MSBuild.Community.Tasks.Time : Task {
    private DateTime mDate;
    private DateTimeKind dateTimeKind;
    private string format;
    private string mMonth;
    private string mDay;
    private string mYear;
    private string mHour;
    private string mMinute;
    private string mSecond;
    private string mMillisecond;
    private string mTicks;
    private string mKind;
    private string mTimeOfDay;
    private string mDayOfYear;
    private string mDayOfWeek;
    private string mFormattedTime;
    private string mShortDate;
    private string mLongDate;
    private string mShortTime;
    private string mLongTime;
    public string Format { get; public set; }
    [OutputAttribute]
public string Month { get; }
    [OutputAttribute]
public string Day { get; }
    [OutputAttribute]
public string Year { get; }
    [OutputAttribute]
public string Hour { get; }
    [OutputAttribute]
public string Minute { get; }
    [OutputAttribute]
public string Second { get; }
    [OutputAttribute]
public string Millisecond { get; }
    [OutputAttribute]
public string Ticks { get; }
    [OutputAttribute]
public string Kind { get; public set; }
    [OutputAttribute]
public string TimeOfDay { get; }
    [OutputAttribute]
public string DayOfYear { get; }
    [OutputAttribute]
public string DayOfWeek { get; }
    [OutputAttribute]
public string FormattedTime { get; }
    [OutputAttribute]
public string ShortDate { get; }
    [OutputAttribute]
public string LongDate { get; }
    [OutputAttribute]
public string ShortTime { get; }
    [OutputAttribute]
public string LongTime { get; }
    public DateTime DateTimeValue { get; }
    public string get_Format();
    public void set_Format(string value);
    public string get_Month();
    public string get_Day();
    public string get_Year();
    public string get_Hour();
    public string get_Minute();
    public string get_Second();
    public string get_Millisecond();
    public string get_Ticks();
    public string get_Kind();
    public void set_Kind(string value);
    public string get_TimeOfDay();
    public string get_DayOfYear();
    public string get_DayOfWeek();
    public string get_FormattedTime();
    public string get_ShortDate();
    public string get_LongDate();
    public string get_ShortTime();
    public string get_LongTime();
    public DateTime get_DateTimeValue();
    public virtual bool Execute();
    private void GetDate();
}
internal static class MSBuild.Community.Tasks.ToolPathUtil : object {
    public static bool SafeFileExists(string path, string toolName);
    public static bool SafeFileExists(string file);
    public static string MakeToolName(string name);
    public static string FindInRegistry(string toolName);
    public static string FindInPath(string toolName);
    public static string FindInProgramFiles(string toolName, String[] commonLocations);
    public static string FindInLocalPath(string toolName, string localPath);
}
public class MSBuild.Community.Tasks.Unzip : Task {
    private List`1<ITaskItem> _files;
    [CompilerGeneratedAttribute]
private string <ZipFileName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TargetDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Overwrite>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Quiet>k__BackingField;
    [RequiredAttribute]
public string ZipFileName { get; public set; }
    [RequiredAttribute]
public string TargetDirectory { get; public set; }
    [DefaultValueAttribute("True")]
public bool Overwrite { get; public set; }
    [DefaultValueAttribute("False")]
public bool Quiet { get; public set; }
    [OutputAttribute]
public ITaskItem[] ExtractedFiles { get; }
    [CompilerGeneratedAttribute]
public string get_ZipFileName();
    [CompilerGeneratedAttribute]
public void set_ZipFileName(string value);
    [CompilerGeneratedAttribute]
public string get_TargetDirectory();
    [CompilerGeneratedAttribute]
public void set_TargetDirectory(string value);
    [CompilerGeneratedAttribute]
public bool get_Overwrite();
    [CompilerGeneratedAttribute]
public void set_Overwrite(bool value);
    [CompilerGeneratedAttribute]
public bool get_Quiet();
    [CompilerGeneratedAttribute]
public void set_Quiet(bool value);
    public ITaskItem[] get_ExtractedFiles();
    public virtual bool Execute();
    private void OnExtractProgress(object sender, ExtractProgressEventArgs e);
}
public class MSBuild.Community.Tasks.User : Task {
    private string _userName;
    private string _domainName;
    private string _firstName;
    private string _lastName;
    private string _middleInitial;
    private string _email;
    private string _phone;
    [OutputAttribute]
public string UserName { get; }
    [OutputAttribute]
public string DomainName { get; }
    [OutputAttribute]
public string FirstName { get; }
    [OutputAttribute]
public string LastName { get; }
    [OutputAttribute]
public string MiddleInitial { get; }
    [OutputAttribute]
public string Email { get; }
    [OutputAttribute]
public string Phone { get; }
    [OutputAttribute]
public string UserNameWithDomain { get; }
    [OutputAttribute]
public string FullName { get; }
    public string get_UserName();
    public string get_DomainName();
    public string get_FirstName();
    public string get_LastName();
    public string get_MiddleInitial();
    public string get_Email();
    public string get_Phone();
    public string get_UserNameWithDomain();
    public string get_FullName();
    public virtual bool Execute();
}
public class MSBuild.Community.Tasks.Version : Task {
    private Version _originalValues;
    private int _major;
    private int _minor;
    private int _build;
    private int _revision;
    private string _versionFile;
    private MajorTypeEnum _majorTypeEnum;
    private MinorTypeEnum _minorTypeEnum;
    private BuildTypeEnum _buildTypeEnum;
    private bool validParameters;
    private RevisionTypeEnum _revisionTypeEnum;
    private DateTime _startDate;
    [OutputAttribute]
public int Major { get; public set; }
    [OutputAttribute]
public int Minor { get; public set; }
    [OutputAttribute]
public int Build { get; public set; }
    [OutputAttribute]
public int Revision { get; public set; }
    public string VersionFile { get; public set; }
    public string MajorType { get; public set; }
    public string MinorType { get; public set; }
    public string BuildType { get; public set; }
    public string RevisionType { get; public set; }
    public string StartDate { get; public set; }
    public int get_Major();
    public void set_Major(int value);
    public int get_Minor();
    public void set_Minor(int value);
    public int get_Build();
    public void set_Build(int value);
    public int get_Revision();
    public void set_Revision(int value);
    public string get_VersionFile();
    public void set_VersionFile(string value);
    public string get_MajorType();
    public void set_MajorType(string value);
    public string get_MinorType();
    public void set_MinorType(string value);
    public string get_BuildType();
    public void set_BuildType(string value);
    private bool attemptedUseOfObsoleteBuildType(string buildType);
    private bool EnumTryParse(string propertyName, Type enumType, string valueToParse, Object& parsedValue);
    public string get_RevisionType();
    public void set_RevisionType(string value);
    public string get_StartDate();
    public void set_StartDate(string value);
    public virtual bool Execute();
    private bool ReadVersionFromFile();
    private bool WriteVersionToFile();
    private void CalculateMajorNumber();
    private void CalculateMinorNumber();
    private void CalculateBuildNumber();
    private int CalculateDaysSinceStartDate();
    private void CalculateRevisionNumber();
    private int CalculateFractionalPartOfDay();
    private int CalculateBuildIncrementRevision();
    private bool FileWouldChange();
    private bool VersionChanged();
}
public class MSBuild.Community.Tasks.WebDownload : Task {
    private string _fileName;
    private string _fileUri;
    private bool useDefaultCredentials;
    private string username;
    private string password;
    private string domain;
    [RequiredAttribute]
public string FileName { get; public set; }
    [RequiredAttribute]
public string FileUri { get; public set; }
    public bool UseDefaultCredentials { get; public set; }
    public string Username { get; public set; }
    public string Password { get; public set; }
    public string Domain { get; public set; }
    public string get_FileName();
    public void set_FileName(string value);
    public string get_FileUri();
    public void set_FileUri(string value);
    public bool get_UseDefaultCredentials();
    public void set_UseDefaultCredentials(bool value);
    public string get_Username();
    public void set_Username(string value);
    public string get_Password();
    public void set_Password(string value);
    public string get_Domain();
    public void set_Domain(string value);
    public virtual bool Execute();
    public ICredentials GetConfiguredCredentials();
}
public class MSBuild.Community.Tasks.WebUpload : Task {
    [CompilerGeneratedAttribute]
private string <FileName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RemoteUri>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Method>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseDefaultCredentials>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Username>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Password>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Domain>k__BackingField;
    [RequiredAttribute]
public string FileName { get; public set; }
    [RequiredAttribute]
public string RemoteUri { get; public set; }
    public string Method { get; public set; }
    public bool UseDefaultCredentials { get; public set; }
    public string Username { get; public set; }
    public string Password { get; public set; }
    public string Domain { get; public set; }
    [CompilerGeneratedAttribute]
public string get_FileName();
    [CompilerGeneratedAttribute]
public void set_FileName(string value);
    [CompilerGeneratedAttribute]
public string get_RemoteUri();
    [CompilerGeneratedAttribute]
public void set_RemoteUri(string value);
    [CompilerGeneratedAttribute]
public string get_Method();
    [CompilerGeneratedAttribute]
public void set_Method(string value);
    [CompilerGeneratedAttribute]
public bool get_UseDefaultCredentials();
    [CompilerGeneratedAttribute]
public void set_UseDefaultCredentials(bool value);
    [CompilerGeneratedAttribute]
public string get_Username();
    [CompilerGeneratedAttribute]
public void set_Username(string value);
    [CompilerGeneratedAttribute]
public string get_Password();
    [CompilerGeneratedAttribute]
public void set_Password(string value);
    [CompilerGeneratedAttribute]
public string get_Domain();
    [CompilerGeneratedAttribute]
public void set_Domain(string value);
    public virtual bool Execute();
    public ICredentials GetConfiguredCredentials();
}
public class MSBuild.Community.Tasks.Xml.XmlMassUpdate : Task {
    private ITaskItem contentFile;
    private ITaskItem substitutionsFile;
    private ITaskItem mergedFile;
    private string substitutionsRoot;
    private string contentRoot;
    private ITaskItem[] namespaceDefinitions;
    private XmlNamespaceManager namespaceManager;
    private bool ignoreMissingSubstitutionsRoot;
    private string contentPathUsedByTask;
    private string substitutionsPathUsedByTask;
    private string mergedPathUsedByTask;
    private static string updateControlNamespace;
    [RequiredAttribute]
public ITaskItem ContentFile { get; public set; }
    public ITaskItem SubstitutionsFile { get; public set; }
    public ITaskItem MergedFile { get; public set; }
    public string SubstitutionsRoot { get; public set; }
    public string ContentRoot { get; public set; }
    public ITaskItem[] NamespaceDefinitions { get; public set; }
    public bool IgnoreMissingSubstitutionsRoot { get; public set; }
    [OutputAttribute]
public string ContentPathUsedByTask { get; }
    [OutputAttribute]
public string SubstitutionsPathUsedByTask { get; }
    [OutputAttribute]
public string MergedPathUsedByTask { get; }
    public string UpdateControlNamespace { get; }
    public ITaskItem get_ContentFile();
    public void set_ContentFile(ITaskItem value);
    public ITaskItem get_SubstitutionsFile();
    public void set_SubstitutionsFile(ITaskItem value);
    public ITaskItem get_MergedFile();
    public void set_MergedFile(ITaskItem value);
    public string get_SubstitutionsRoot();
    public void set_SubstitutionsRoot(string value);
    public string get_ContentRoot();
    public void set_ContentRoot(string value);
    public ITaskItem[] get_NamespaceDefinitions();
    public void set_NamespaceDefinitions(ITaskItem[] value);
    public bool get_IgnoreMissingSubstitutionsRoot();
    public void set_IgnoreMissingSubstitutionsRoot(bool value);
    public string get_ContentPathUsedByTask();
    public string get_SubstitutionsPathUsedByTask();
    public string get_MergedPathUsedByTask();
    public virtual bool Execute();
    private void setContentPath();
    private void setSubstitutionsPath();
    private void setMergedPath();
    protected virtual XmlDocument LoadSubstitutionsDocument();
    protected virtual XmlDocument LoadContentDocument();
    protected virtual bool SaveMergedDocument(XmlDocument mergedDocument);
    private void addAllChildNodes(XmlDocument mergedDocument, XmlNode contentParentNode, XmlNode substitutionsParentNode);
    private void removeChildNode(XmlDocument mergedDocument, XmlNode contentParentNode, XmlNode substitutionNode);
    private XmlNode addChildNode(XmlDocument mergedDocument, XmlNode destinationParentNode, XmlNode nodeToAdd);
    private static bool isUpdateControlAttribute(XmlAttribute attribute);
    private bool shouldDeleteElement(XmlNode sourceNode);
    private void setAttributeValue(XmlDocument mergedDocument, XmlNode modifiedNode, string attributeName, string attributeValue);
    private string getFullPathOfNode(XmlNode node);
    public string get_UpdateControlNamespace();
    private XmlNode modifyNode(XmlDocument mergedDocument, XmlNode destinationParentNode, XmlNode nodeToModify);
    private XmlNode modifyNode(XmlDocument mergedDocument, XmlNode destinationParentNode, XmlNode nodeToModify, bool remove);
    private XmlNode locateTargetNode(XmlNode parentNode, XmlNode nodeToFind, XmlAttribute keyAttribute);
    private XmlAttribute getKeyAttribute(XmlNode sourceNode);
    private string getActionAttribute(XmlNode sourceNode);
}
public class MSBuild.Community.Tasks.Xml.XmlNodeTaskItem : object {
    private Dictionary`2<string, string> metaData;
    private string ReservedMetaDataPrefix;
    private string itemSpec;
    public string ItemSpec { get; public set; }
    public int MetadataCount { get; }
    public ICollection MetadataNames { get; }
    public XmlNodeTaskItem(XPathNavigator xpathNavigator, string reservedMetaDataPrefix);
    public virtual string ToString();
    public static string op_Explicit(XmlNodeTaskItem taskItemToCast);
    public sealed virtual IDictionary CloneCustomMetadata();
    public sealed virtual void CopyMetadataTo(ITaskItem destinationItem);
    public sealed virtual string GetMetadata(string metadataName);
    public sealed virtual string get_ItemSpec();
    public sealed virtual void set_ItemSpec(string value);
    public sealed virtual int get_MetadataCount();
    public sealed virtual ICollection get_MetadataNames();
    public sealed virtual void RemoveMetadata(string metadataName);
    public sealed virtual void SetMetadata(string metadataName, string metadataValue);
}
public class MSBuild.Community.Tasks.Xml.XmlQuery : Task {
    private ITaskItem[] lines;
    private string xmlFileName;
    private ITaskItem[] namespaceDefinitions;
    private string xpath;
    private List`1<ITaskItem> values;
    private string reservedMetaDataPrefix;
    public ITaskItem[] Lines { get; public set; }
    public string XmlFileName { get; public set; }
    public ITaskItem[] NamespaceDefinitions { get; public set; }
    [RequiredAttribute]
public string XPath { get; public set; }
    [OutputAttribute]
public ITaskItem[] Values { get; }
    [OutputAttribute]
public int ValuesCount { get; }
    public string ReservedMetaDataPrefix { get; public set; }
    public ITaskItem[] get_Lines();
    public void set_Lines(ITaskItem[] value);
    public string get_XmlFileName();
    public void set_XmlFileName(string value);
    public ITaskItem[] get_NamespaceDefinitions();
    public void set_NamespaceDefinitions(ITaskItem[] value);
    public string get_XPath();
    public void set_XPath(string value);
    public ITaskItem[] get_Values();
    public int get_ValuesCount();
    public string get_ReservedMetaDataPrefix();
    public void set_ReservedMetaDataPrefix(string value);
    public virtual bool Execute();
    private XPathDocument loadXmlContent();
    private bool validParameters();
}
public class MSBuild.Community.Tasks.Xml.XmlTaskHelper : object {
    public static string JoinItems(ITaskItem[] items);
    public static void LoadNamespaceDefinitionItems(XmlNamespaceManager namespaceManager, ITaskItem[] definitions);
}
public class MSBuild.Community.Tasks.XmlRead : Task {
    private string _xmlFileName;
    private string _xpath;
    private string _value;
    private string _namespace;
    private string _prefix;
    [RequiredAttribute]
public string XmlFileName { get; public set; }
    [RequiredAttribute]
public string XPath { get; public set; }
    [OutputAttribute]
public string Value { get; }
    public string Namespace { get; public set; }
    public string Prefix { get; public set; }
    public string get_XmlFileName();
    public void set_XmlFileName(string value);
    public string get_XPath();
    public void set_XPath(string value);
    public string get_Value();
    public string get_Namespace();
    public void set_Namespace(string value);
    public string get_Prefix();
    public void set_Prefix(string value);
    public virtual bool Execute();
}
public class MSBuild.Community.Tasks.XmlUpdate : Task {
    private string _xmlFileName;
    private string _xpath;
    private string _value;
    private bool _delete;
    private string _namespace;
    private string _prefix;
    [RequiredAttribute]
public string XmlFileName { get; public set; }
    [RequiredAttribute]
public string XPath { get; public set; }
    public string Value { get; public set; }
    public bool Delete { get; public set; }
    public string Namespace { get; public set; }
    public string Prefix { get; public set; }
    public string get_XmlFileName();
    public void set_XmlFileName(string value);
    public string get_XPath();
    public void set_XPath(string value);
    public string get_Value();
    public void set_Value(string value);
    public bool get_Delete();
    public void set_Delete(bool value);
    public string get_Namespace();
    public void set_Namespace(string value);
    public string get_Prefix();
    public void set_Prefix(string value);
    public virtual bool Execute();
}
public class MSBuild.Community.Tasks.Xslt : Task {
    public static string CreatedAttributeName;
    public static string InputMetadataArgumentPrefix;
    private ITaskItem[] inputs;
    private string rootTag;
    private string rootAttributes;
    private bool useTrusted;
    private ITaskItem xsl;
    private string output;
    [RequiredAttribute]
public ITaskItem[] Inputs { get; public set; }
    public string RootTag { get; public set; }
    public string RootAttributes { get; public set; }
    public bool UseTrusted { get; public set; }
    [RequiredAttribute]
public ITaskItem Xsl { get; public set; }
    [RequiredAttribute]
public string Output { get; public set; }
    public ITaskItem[] get_Inputs();
    public void set_Inputs(ITaskItem[] value);
    public string get_RootTag();
    public void set_RootTag(string value);
    public string get_RootAttributes();
    public void set_RootAttributes(string value);
    public bool get_UseTrusted();
    public void set_UseTrusted(bool value);
    public ITaskItem get_Xsl();
    public void set_Xsl(ITaskItem value);
    public string get_Output();
    public void set_Output(string value);
    public virtual bool Execute();
    private void CreateRootNode(XmlDocument doc);
    private bool AddParameter(string name, string value, XsltArgumentList parameters);
}
public class MSBuild.Community.Tasks.Zip : Task {
    [CompilerGeneratedAttribute]
private string <ZipFileName>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ZipLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Zip64>k__BackingField;
    [CompilerGeneratedAttribute]
private ITaskItem[] <Files>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Flatten>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Comment>k__BackingField;
    [CompilerGeneratedAttribute]
private string <WorkingDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Password>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Encryption>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ParallelCompression>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CodecBufferSize>k__BackingField;
    [CompilerGeneratedAttribute]
private int <BufferSize>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Quiet>k__BackingField;
    [RequiredAttribute]
public string ZipFileName { get; public set; }
    public int ZipLevel { get; public set; }
    public bool Zip64 { get; public set; }
    [RequiredAttribute]
public ITaskItem[] Files { get; public set; }
    public bool Flatten { get; public set; }
    public string Comment { get; public set; }
    public string WorkingDirectory { get; public set; }
    public string Password { get; public set; }
    public string Encryption { get; public set; }
    public bool ParallelCompression { get; public set; }
    [DefaultValueAttribute("0")]
public int CodecBufferSize { get; public set; }
    [DefaultValueAttribute("0")]
public int BufferSize { get; public set; }
    [ObsoleteAttribute("Obsolete, Use Quiet instead.")]
public bool MinimalLogging { get; public set; }
    [DefaultValueAttribute("False")]
public bool Quiet { get; public set; }
    [CompilerGeneratedAttribute]
public string get_ZipFileName();
    [CompilerGeneratedAttribute]
public void set_ZipFileName(string value);
    [CompilerGeneratedAttribute]
public int get_ZipLevel();
    [CompilerGeneratedAttribute]
public void set_ZipLevel(int value);
    [CompilerGeneratedAttribute]
public bool get_Zip64();
    [CompilerGeneratedAttribute]
public void set_Zip64(bool value);
    [CompilerGeneratedAttribute]
public ITaskItem[] get_Files();
    [CompilerGeneratedAttribute]
public void set_Files(ITaskItem[] value);
    [CompilerGeneratedAttribute]
public bool get_Flatten();
    [CompilerGeneratedAttribute]
public void set_Flatten(bool value);
    [CompilerGeneratedAttribute]
public string get_Comment();
    [CompilerGeneratedAttribute]
public void set_Comment(string value);
    [CompilerGeneratedAttribute]
public string get_WorkingDirectory();
    [CompilerGeneratedAttribute]
public void set_WorkingDirectory(string value);
    [CompilerGeneratedAttribute]
public string get_Password();
    [CompilerGeneratedAttribute]
public void set_Password(string value);
    [CompilerGeneratedAttribute]
public string get_Encryption();
    [CompilerGeneratedAttribute]
public void set_Encryption(string value);
    [CompilerGeneratedAttribute]
public bool get_ParallelCompression();
    [CompilerGeneratedAttribute]
public void set_ParallelCompression(bool value);
    [CompilerGeneratedAttribute]
public int get_CodecBufferSize();
    [CompilerGeneratedAttribute]
public void set_CodecBufferSize(int value);
    [CompilerGeneratedAttribute]
public int get_BufferSize();
    [CompilerGeneratedAttribute]
public void set_BufferSize(int value);
    public bool get_MinimalLogging();
    public void set_MinimalLogging(bool value);
    [CompilerGeneratedAttribute]
public bool get_Quiet();
    [CompilerGeneratedAttribute]
public void set_Quiet(bool value);
    public virtual bool Execute();
    private bool ZipFiles();
    private static string GetPath(string originalPath, string rootDirectory);
}
internal class ThisAssembly : object {
    internal static string AssemblyProduct;
    internal static string AssemblyCompany;
    internal static string AssemblyCopyright;
    internal static string AssemblyConfiguration;
    internal static string AssemblyVersion;
    internal static string AssemblyFileVersion;
    internal static string AssemblyInformationalVersion;
}
