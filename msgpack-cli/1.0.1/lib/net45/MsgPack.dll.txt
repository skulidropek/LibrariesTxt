public static class MsgPack.AsyncReadResult : object {
    public static AsyncReadResult`1<T> Success(T returnValue);
    public static AsyncReadResult`1<T> Fail();
    internal static AsyncReadResult`1<Int32OffsetValue`1<T>> Success(T returnValue, int offset);
    internal static AsyncReadResult`1<Int64OffsetValue`1<T>> Success(T returnValue, long offset);
}
public class MsgPack.AsyncReadResult`1 : ValueType {
    private bool _success;
    private T _value;
    public bool Success { get; }
    public T Value { get; }
    internal AsyncReadResult`1(T value, bool success);
    public bool get_Success();
    public T get_Value();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(AsyncReadResult`1<T> other);
    public virtual int GetHashCode();
    public virtual string ToString();
    public static bool op_Equality(AsyncReadResult`1<T> left, AsyncReadResult`1<T> right);
    public static bool op_Inequality(AsyncReadResult`1<T> left, AsyncReadResult`1<T> right);
}
internal static class MsgPack.BigEndianBinary : object {
    public static sbyte ToSByte(Byte[] buffer, int offset);
    public static short ToInt16(Byte[] buffer, int offset);
    public static int ToInt32(Byte[] buffer, int offset);
    public static long ToInt64(Byte[] buffer, int offset);
    public static byte ToByte(Byte[] buffer, int offset);
    public static ushort ToUInt16(Byte[] buffer, int offset);
    public static UInt32 ToUInt32(Byte[] buffer, int offset);
    public static ulong ToUInt64(Byte[] buffer, int offset);
    public static float ToSingle(Byte[] buffer, int offset);
    public static double ToDouble(Byte[] buffer, int offset);
}
internal static class MsgPack.Binary : object {
    public static Byte[] Empty;
    private static Binary();
    public static string ToHexString(Byte[] blob);
    public static string ToHexString(Byte[] blob, bool withPrefix);
    public static void ToHexString(Byte[] blob, StringBuilder buffer);
    private static void ToHexStringCore(Byte[] blob, StringBuilder buffer, bool withPrefix);
    private static char ToHexChar(int b);
    public static int ToBits(float value);
    public static long ToBits(double value);
}
internal static class MsgPack.BufferManager : object {
    private static int MaxByteBufferSize;
    private static int MaxCharBufferSize;
    public static Byte[] NewByteBuffer(int size);
    public static Char[] NewCharBuffer(int size);
}
public abstract class MsgPack.ByteArrayPacker : Packer {
    public int BytesUsed { get; }
    public int InitialBufferOffset { get; }
    protected ByteArrayPacker(PackerCompatibilityOptions compatibilityOptions);
    public abstract virtual int get_BytesUsed();
    public abstract virtual int get_InitialBufferOffset();
    public ArraySegment`1<byte> GetResultBytes();
    public abstract virtual Byte[] GetFinalBuffer();
}
public abstract class MsgPack.ByteArrayUnpacker : Unpacker {
    public int Offset { get; }
    public abstract virtual int get_Offset();
}
internal abstract class MsgPack.ByteBufferAllocator : object {
    public abstract virtual bool TryAllocate(Byte[] oldBuffer, int requestSize, Byte[]& newBuffer);
}
internal class MsgPack.CollectionDebuggerProxy`1 : object {
    private ICollection`1<T> _collection;
    [DebuggerBrowsableAttribute("3")]
public T[] Items { get; }
    public CollectionDebuggerProxy`1(ICollection`1<T> target);
    public T[] get_Items();
}
internal static class MsgPack.CollectionOperation : object {
    public static void CopyTo(IEnumerable`1<T> source, int sourceCount, int index, T[] array, int arrayIndex, int count);
    public static void CopyTo(IEnumerable`1<TSource> source, int sourceCount, int index, TDestination[] array, int arrayIndex, int count, Func`2<TSource, TDestination> converter);
    private static void ValidateCopyToArguments(int sourceCount, int index, T[] array, int arrayIndex, int count);
    public static void CopyTo(IEnumerable`1<T> source, int sourceCount, Array array, int arrayIndex);
}
internal enum MsgPack.CollectionType : Enum {
    public int value__;
    public static CollectionType None;
    public static CollectionType Array;
    public static CollectionType Map;
}
internal class MsgPack.CollectionValidatingByteArrayUnpacker : MessagePackByteArrayUnpacker {
    private bool _isSubtreeReading;
    public CollectionValidatingByteArrayUnpacker(Byte[] source, int startOffset);
    internal virtual Unpacker InternalReadSubtree();
    protected virtual Unpacker ReadSubtreeCore();
    protected internal virtual void EndReadSubtree();
    internal virtual void EnsureNotInSubtreeMode();
    internal virtual void BeginSkipCore();
}
internal class MsgPack.CollectionValidatingStreamUnpacker : MessagePackStreamUnpacker {
    private bool _isSubtreeReading;
    public CollectionValidatingStreamUnpacker(Stream stream, PackerUnpackerStreamOptions streamOptions);
    internal virtual Unpacker InternalReadSubtree();
    protected virtual Unpacker ReadSubtreeCore();
    protected internal virtual void EndReadSubtree();
    internal virtual void EnsureNotInSubtreeMode();
    internal virtual void BeginSkipCore();
}
internal class MsgPack.DictionaryDebuggerProxy`2 : object {
    private IDictionary`2<TKey, TValue> _dictionary;
    [DebuggerBrowsableAttribute("3")]
public KeyValuePair`2[] Items { get; }
    public DictionaryDebuggerProxy`2(IDictionary`2<TKey, TValue> target);
    public KeyValuePair`2[] get_Items();
}
[ExtensionAttribute]
internal static class MsgPack.EncodingExtensions : object {
    [ExtensionAttribute]
[SecuritySafeCriticalAttribute]
public static bool EncodeString(Encoder source, Char* pChar, int charsLength, Byte* pBuffer, int bufferCount, Int32& charsUsed, Int32& bytesUsed);
    [ExtensionAttribute]
public static bool DecodeString(Decoder source, Byte[] bytes, int bytesOffset, int bytesLength, Char[] buffer, StringBuilder result);
}
internal class MsgPack.FastByteArrayUnpacker : MessagePackByteArrayUnpacker {
    public FastByteArrayUnpacker(Byte[] source, int startOffset);
    protected virtual Unpacker ReadSubtreeCore();
}
internal class MsgPack.FastStreamUnpacker : MessagePackStreamUnpacker {
    public FastStreamUnpacker(Stream stream, PackerUnpackerStreamOptions streamOptions);
    protected virtual Unpacker ReadSubtreeCore();
}
internal class MsgPack.FixedArrayBufferAllocator : ByteBufferAllocator {
    public static ByteBufferAllocator Instance;
    private static FixedArrayBufferAllocator();
    public virtual bool TryAllocate(Byte[] oldBuffer, int requestSize, Byte[]& newBuffer);
}
internal class MsgPack.Float32Bits : ValueType {
    public float Value;
    public byte Byte0;
    public byte Byte1;
    public byte Byte2;
    public byte Byte3;
    public Float32Bits(float value);
    public Float32Bits(Byte[] bigEndianBytes, int offset);
}
internal class MsgPack.Float64Bits : ValueType {
    public double Value;
    public byte Byte0;
    public byte Byte1;
    public byte Byte2;
    public byte Byte3;
    public byte Byte4;
    public byte Byte5;
    public byte Byte6;
    public byte Byte7;
    public Float64Bits(Byte[] bigEndianBytes, int offset);
}
public interface MsgPack.IAsyncPackable {
    public abstract virtual Task PackToMessageAsync(Packer packer, PackingOptions options, CancellationToken cancellationToken);
}
public interface MsgPack.IAsyncUnpackable {
    public abstract virtual Task UnpackFromMessageAsync(Unpacker unpacker, CancellationToken cancellationToken);
}
internal class MsgPack.Int32OffsetValue`1 : ValueType {
    public int Offset;
    public T Result;
    public Int32OffsetValue`1(T result, int offset);
}
internal class MsgPack.Int64OffsetValue`1 : ValueType {
    public long Offset;
    public T Result;
    public Int64OffsetValue`1(T result, long offset);
}
public class MsgPack.InvalidMessagePackStreamException : Exception {
    public InvalidMessagePackStreamException(string message);
    public InvalidMessagePackStreamException(string message, Exception inner);
    private InvalidMessagePackStreamException(SerializationInfo info, StreamingContext context);
}
public interface MsgPack.IPackable {
    public abstract virtual void PackToMessage(Packer packer, PackingOptions options);
}
internal interface MsgPack.IRootUnpacker {
    public CollectionType CollectionType { get; }
    public Nullable`1<MessagePackObject> Data { get; public set; }
    public MessagePackObject LastReadData { get; public set; }
    public abstract virtual CollectionType get_CollectionType();
    public abstract virtual Nullable`1<MessagePackObject> get_Data();
    public abstract virtual void set_Data(Nullable`1<MessagePackObject> value);
    public abstract virtual MessagePackObject get_LastReadData();
    public abstract virtual void set_LastReadData(MessagePackObject value);
    public abstract virtual bool ReadObject(bool isDeep, MessagePackObject& result);
}
public interface MsgPack.IUnpackable {
    public abstract virtual void UnpackFromMessage(Unpacker unpacker);
}
public static class MsgPack.KnownExtTypeCode : object {
    public static byte Timestamp { get; }
    public static byte MultidimensionalArray { get; }
    public static byte get_Timestamp();
    public static byte get_MultidimensionalArray();
}
public static class MsgPack.KnownExtTypeName : object {
    public static string Timestamp { get; }
    public static string MultidimensionalArray { get; }
    public static string get_Timestamp();
    public static string get_MultidimensionalArray();
}
public class MsgPack.MessageNotSupportedException : Exception {
    public MessageNotSupportedException(string message);
    public MessageNotSupportedException(string message, Exception inner);
    private MessageNotSupportedException(SerializationInfo info, StreamingContext context);
}
internal class MsgPack.MessagePackByteArrayPacker : ByteArrayPacker {
    private static int MaximumUtf8Length;
    private Byte[] _buffer;
    private int _offset;
    private int _initialOffset;
    private ByteBufferAllocator _allocator;
    public int BytesUsed { get; }
    public int InitialBufferOffset { get; }
    public MessagePackByteArrayPacker(Byte[] buffer, ByteBufferAllocator allocator, PackerCompatibilityOptions compatibilityOptions);
    public MessagePackByteArrayPacker(Byte[] buffer, int startOffset, ByteBufferAllocator allocator, PackerCompatibilityOptions compatibilityOptions);
    public virtual int get_BytesUsed();
    public virtual int get_InitialBufferOffset();
    public virtual Byte[] GetFinalBuffer();
    protected virtual void WriteBytes(ICollection`1<byte> value);
    protected virtual void WriteBytes(Byte[] value, bool isImmutable);
    protected virtual Task WriteBytesAsync(ICollection`1<byte> value, CancellationToken cancellationToken);
    protected virtual Task WriteBytesAsync(Byte[] value, bool isImmutable, CancellationToken cancellationToken);
    protected virtual void WriteByte(byte value);
    private void WriteBytes(Byte[] value, int startIndex, int count);
    private void WriteBytes(Byte[] value);
    protected virtual Task WriteByteAsync(byte value, CancellationToken cancellationToken);
    private Task WriteBytesAsync(Byte[] value, CancellationToken cancellationToken);
    private void ThrowEofException(int requiredSize);
    private void ThrowEofExceptionForString(int requiredCharCount);
    protected virtual void PackCore(bool value);
    protected virtual void PackCore(byte value);
    protected virtual void PackCore(sbyte value);
    protected virtual void PackCore(short value);
    protected virtual void PackCore(ushort value);
    protected virtual void PackCore(int value);
    protected virtual void PackCore(UInt32 value);
    protected virtual void PackCore(long value);
    protected virtual void PackCore(ulong value);
    protected virtual void PackCore(float value);
    protected virtual void PackCore(double value);
    protected virtual void PackArrayHeaderCore(int length);
    protected virtual void PackMapHeaderCore(int length);
    protected virtual void PackStringHeaderCore(int length);
    protected virtual void PackBinaryHeaderCore(int length);
    protected virtual void PackRawCore(string value);
    protected virtual void PackRawCore(Byte[] value);
    protected virtual void PackBinaryCore(Byte[] value);
    protected virtual void PackExtendedTypeValueCore(byte typeCode, Byte[] body);
    [AsyncStateMachineAttribute("MsgPack.MessagePackByteArrayPacker/<PackAsyncCore>d__42")]
protected virtual Task PackAsyncCore(bool value, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.MessagePackByteArrayPacker/<PackAsyncCore>d__43")]
protected virtual Task PackAsyncCore(byte value, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.MessagePackByteArrayPacker/<PackAsyncCore>d__44")]
protected virtual Task PackAsyncCore(sbyte value, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.MessagePackByteArrayPacker/<PackAsyncCore>d__45")]
protected virtual Task PackAsyncCore(short value, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.MessagePackByteArrayPacker/<PackAsyncCore>d__46")]
protected virtual Task PackAsyncCore(ushort value, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.MessagePackByteArrayPacker/<PackAsyncCore>d__47")]
protected virtual Task PackAsyncCore(int value, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.MessagePackByteArrayPacker/<PackAsyncCore>d__48")]
protected virtual Task PackAsyncCore(UInt32 value, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.MessagePackByteArrayPacker/<PackAsyncCore>d__49")]
protected virtual Task PackAsyncCore(long value, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.MessagePackByteArrayPacker/<PackAsyncCore>d__50")]
protected virtual Task PackAsyncCore(ulong value, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.MessagePackByteArrayPacker/<PackAsyncCore>d__51")]
protected virtual Task PackAsyncCore(float value, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.MessagePackByteArrayPacker/<PackAsyncCore>d__52")]
protected virtual Task PackAsyncCore(double value, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.MessagePackByteArrayPacker/<PackArrayHeaderAsyncCore>d__53")]
protected virtual Task PackArrayHeaderAsyncCore(int length, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.MessagePackByteArrayPacker/<PackMapHeaderAsyncCore>d__54")]
protected virtual Task PackMapHeaderAsyncCore(int length, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.MessagePackByteArrayPacker/<PackStringHeaderAsyncCore>d__55")]
protected virtual Task PackStringHeaderAsyncCore(int length, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.MessagePackByteArrayPacker/<PackBinaryHeaderAsyncCore>d__56")]
protected virtual Task PackBinaryHeaderAsyncCore(int length, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.MessagePackByteArrayPacker/<PackRawAsyncCore>d__57")]
protected virtual Task PackRawAsyncCore(string value, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.MessagePackByteArrayPacker/<PackRawAsyncCore>d__58")]
protected virtual Task PackRawAsyncCore(Byte[] value, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.MessagePackByteArrayPacker/<PackBinaryAsyncCore>d__59")]
protected virtual Task PackBinaryAsyncCore(Byte[] value, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.MessagePackByteArrayPacker/<PackExtendedTypeValueAsyncCore>d__60")]
protected virtual Task PackExtendedTypeValueAsyncCore(byte typeCode, Byte[] body, CancellationToken cancellationToken);
    private void WriteStringHeader(int bytesLength, bool allowStr8);
    private void WriteBytes(byte header, byte value);
    private void WriteBytes(byte header, ushort value);
    private void WriteBytes(byte header, UInt32 value);
    private void WriteBytes(byte header, ulong value);
    private void WriteBytes(byte header, float value);
    private void WriteBytes(byte header, double value);
    private void WriteBytes(string value, bool allowStr8);
    private Task WriteBytesAsync(byte header, byte value, CancellationToken cancellationToken);
    private Task WriteBytesAsync(byte header, ushort value, CancellationToken cancellationToken);
    private Task WriteBytesAsync(byte header, UInt32 value, CancellationToken cancellationToken);
    private Task WriteBytesAsync(byte header, ulong value, CancellationToken cancellationToken);
    private Task WriteBytesAsync(byte header, float value, CancellationToken cancellationToken);
    private Task WriteBytesAsync(byte header, double value, CancellationToken cancellationToken);
    private Task WriteBytesAsync(string value, bool allowStr8, CancellationToken cancellationToken);
}
internal abstract class MsgPack.MessagePackByteArrayUnpacker : ByteArrayUnpacker {
    private Byte[] _source;
    private int _offset;
    private Byte[] _scalarBuffer;
    private CollectionType _collectionType;
    private MessagePackObject _data;
    public int Offset { get; }
    public Nullable`1<MessagePackObject> Data { get; protected set; }
    public MessagePackObject LastReadData { get; protected set; }
    public bool IsArrayHeader { get; }
    public bool IsMapHeader { get; }
    public bool IsCollectionHeader { get; }
    public long ItemsCount { get; }
    private CollectionType MsgPack.IRootUnpacker.CollectionType { get; }
    private Nullable`1<MessagePackObject> MsgPack.IRootUnpacker.Data { get; private set; }
    private MessagePackObject MsgPack.IRootUnpacker.LastReadData { get; private set; }
    public MessagePackByteArrayUnpacker(Byte[] source, int startOffset);
    public sealed virtual int get_Offset();
    public sealed virtual Nullable`1<MessagePackObject> get_Data();
    protected sealed virtual void set_Data(Nullable`1<MessagePackObject> value);
    public sealed virtual MessagePackObject get_LastReadData();
    protected sealed virtual void set_LastReadData(MessagePackObject value);
    public sealed virtual bool get_IsArrayHeader();
    public sealed virtual bool get_IsMapHeader();
    public sealed virtual bool get_IsCollectionHeader();
    public sealed virtual long get_ItemsCount();
    private sealed virtual override CollectionType MsgPack.IRootUnpacker.get_CollectionType();
    private sealed virtual override Nullable`1<MessagePackObject> MsgPack.IRootUnpacker.get_Data();
    private sealed virtual override void MsgPack.IRootUnpacker.set_Data(Nullable`1<MessagePackObject> value);
    private sealed virtual override MessagePackObject MsgPack.IRootUnpacker.get_LastReadData();
    private sealed virtual override void MsgPack.IRootUnpacker.set_LastReadData(MessagePackObject value);
    internal virtual bool GetPreviousPosition(Int64& offsetOrPosition);
    private bool ReadBinaryCore(int length, Int32& offset, Byte[]& result);
    private Task`1<AsyncReadResult`1<Int32OffsetValue`1<Byte[]>>> ReadBinaryCoreAsync(int length, int offset, CancellationToken cancellationToken);
    private bool ReadStringCore(int length, Int32& offset, String& result);
    private Task`1<AsyncReadResult`1<Int32OffsetValue`1<string>>> ReadStringCoreAsync(int length, int offset, CancellationToken cancellationToken);
    private bool ReadRawStringCore(int length, Int32& offset, MessagePackString& result);
    private Task`1<AsyncReadResult`1<Int32OffsetValue`1<MessagePackString>>> ReadRawStringCoreAsync(int length, int offset, CancellationToken cancellationToken);
    private bool Drain(UInt32 size);
    private Task`1<bool> DrainAsync(UInt32 size, CancellationToken cancellationToken);
    private sealed virtual override bool MsgPack.IRootUnpacker.ReadObject(bool isDeep, MessagePackObject& result);
    public sealed virtual bool ReadByte(Byte& result);
    private bool ReadByteSlow(ReadValueResult header, Byte[] source, Int32& offset, Byte& result);
    public sealed virtual bool ReadNullableByte(Nullable`1& result);
    private bool ReadNullableByteSlow(ReadValueResult header, Byte[] source, Int32& offset, Nullable`1& result);
    public sealed virtual Task`1<AsyncReadResult`1<byte>> ReadByteAsync(CancellationToken cancellationToken);
    public sealed virtual Task`1<AsyncReadResult`1<Nullable`1<byte>>> ReadNullableByteAsync(CancellationToken cancellationToken);
    public sealed virtual bool ReadSByte(SByte& result);
    private bool ReadSByteSlow(ReadValueResult header, Byte[] source, Int32& offset, SByte& result);
    public sealed virtual bool ReadNullableSByte(Nullable`1& result);
    private bool ReadNullableSByteSlow(ReadValueResult header, Byte[] source, Int32& offset, Nullable`1& result);
    public sealed virtual Task`1<AsyncReadResult`1<sbyte>> ReadSByteAsync(CancellationToken cancellationToken);
    public sealed virtual Task`1<AsyncReadResult`1<Nullable`1<sbyte>>> ReadNullableSByteAsync(CancellationToken cancellationToken);
    public sealed virtual bool ReadInt16(Int16& result);
    private bool ReadInt16Slow(ReadValueResult header, Byte[] source, Int32& offset, Int16& result);
    public sealed virtual bool ReadNullableInt16(Nullable`1& result);
    private bool ReadNullableInt16Slow(ReadValueResult header, Byte[] source, Int32& offset, Nullable`1& result);
    public sealed virtual Task`1<AsyncReadResult`1<short>> ReadInt16Async(CancellationToken cancellationToken);
    public sealed virtual Task`1<AsyncReadResult`1<Nullable`1<short>>> ReadNullableInt16Async(CancellationToken cancellationToken);
    public sealed virtual bool ReadUInt16(UInt16& result);
    private bool ReadUInt16Slow(ReadValueResult header, Byte[] source, Int32& offset, UInt16& result);
    public sealed virtual bool ReadNullableUInt16(Nullable`1& result);
    private bool ReadNullableUInt16Slow(ReadValueResult header, Byte[] source, Int32& offset, Nullable`1& result);
    public sealed virtual Task`1<AsyncReadResult`1<ushort>> ReadUInt16Async(CancellationToken cancellationToken);
    public sealed virtual Task`1<AsyncReadResult`1<Nullable`1<ushort>>> ReadNullableUInt16Async(CancellationToken cancellationToken);
    public sealed virtual bool ReadInt32(Int32& result);
    private bool ReadInt32Slow(ReadValueResult header, Byte[] source, Int32& offset, Int32& result);
    public sealed virtual bool ReadNullableInt32(Nullable`1& result);
    private bool ReadNullableInt32Slow(ReadValueResult header, Byte[] source, Int32& offset, Nullable`1& result);
    public sealed virtual Task`1<AsyncReadResult`1<int>> ReadInt32Async(CancellationToken cancellationToken);
    public sealed virtual Task`1<AsyncReadResult`1<Nullable`1<int>>> ReadNullableInt32Async(CancellationToken cancellationToken);
    public sealed virtual bool ReadUInt32(UInt32& result);
    private bool ReadUInt32Slow(ReadValueResult header, Byte[] source, Int32& offset, UInt32& result);
    public sealed virtual bool ReadNullableUInt32(Nullable`1& result);
    private bool ReadNullableUInt32Slow(ReadValueResult header, Byte[] source, Int32& offset, Nullable`1& result);
    public sealed virtual Task`1<AsyncReadResult`1<UInt32>> ReadUInt32Async(CancellationToken cancellationToken);
    public sealed virtual Task`1<AsyncReadResult`1<Nullable`1<UInt32>>> ReadNullableUInt32Async(CancellationToken cancellationToken);
    public sealed virtual bool ReadInt64(Int64& result);
    private bool ReadInt64Slow(ReadValueResult header, Byte[] source, Int32& offset, Int64& result);
    public sealed virtual bool ReadNullableInt64(Nullable`1& result);
    private bool ReadNullableInt64Slow(ReadValueResult header, Byte[] source, Int32& offset, Nullable`1& result);
    public sealed virtual Task`1<AsyncReadResult`1<long>> ReadInt64Async(CancellationToken cancellationToken);
    public sealed virtual Task`1<AsyncReadResult`1<Nullable`1<long>>> ReadNullableInt64Async(CancellationToken cancellationToken);
    public sealed virtual bool ReadUInt64(UInt64& result);
    private bool ReadUInt64Slow(ReadValueResult header, Byte[] source, Int32& offset, UInt64& result);
    public sealed virtual bool ReadNullableUInt64(Nullable`1& result);
    private bool ReadNullableUInt64Slow(ReadValueResult header, Byte[] source, Int32& offset, Nullable`1& result);
    public sealed virtual Task`1<AsyncReadResult`1<ulong>> ReadUInt64Async(CancellationToken cancellationToken);
    public sealed virtual Task`1<AsyncReadResult`1<Nullable`1<ulong>>> ReadNullableUInt64Async(CancellationToken cancellationToken);
    public sealed virtual bool ReadSingle(Single& result);
    private bool ReadSingleSlow(ReadValueResult header, Byte[] source, Int32& offset, Single& result);
    public sealed virtual bool ReadNullableSingle(Nullable`1& result);
    private bool ReadNullableSingleSlow(ReadValueResult header, Byte[] source, Int32& offset, Nullable`1& result);
    public sealed virtual Task`1<AsyncReadResult`1<float>> ReadSingleAsync(CancellationToken cancellationToken);
    public sealed virtual Task`1<AsyncReadResult`1<Nullable`1<float>>> ReadNullableSingleAsync(CancellationToken cancellationToken);
    public sealed virtual bool ReadDouble(Double& result);
    private bool ReadDoubleSlow(ReadValueResult header, Byte[] source, Int32& offset, Double& result);
    public sealed virtual bool ReadNullableDouble(Nullable`1& result);
    private bool ReadNullableDoubleSlow(ReadValueResult header, Byte[] source, Int32& offset, Nullable`1& result);
    public sealed virtual Task`1<AsyncReadResult`1<double>> ReadDoubleAsync(CancellationToken cancellationToken);
    public sealed virtual Task`1<AsyncReadResult`1<Nullable`1<double>>> ReadNullableDoubleAsync(CancellationToken cancellationToken);
    public sealed virtual bool ReadBoolean(Boolean& result);
    public sealed virtual bool ReadNullableBoolean(Nullable`1& result);
    public sealed virtual Task`1<AsyncReadResult`1<bool>> ReadBooleanAsync(CancellationToken cancellationToken);
    public sealed virtual Task`1<AsyncReadResult`1<Nullable`1<bool>>> ReadNullableBooleanAsync(CancellationToken cancellationToken);
    public sealed virtual bool ReadBinary(Byte[]& result);
    public sealed virtual Task`1<AsyncReadResult`1<Byte[]>> ReadBinaryAsync(CancellationToken cancellationToken);
    public sealed virtual bool ReadString(String& result);
    public sealed virtual Task`1<AsyncReadResult`1<string>> ReadStringAsync(CancellationToken cancellationToken);
    private bool ReadObject(bool isDeep, MessagePackObject& result);
    private bool ReadObjectCore(bool isDeep, Byte[] source, Int32& offset, MessagePackObject& result);
    private bool ReadObjectSlow(ReadValueResult header, Byte[] source, Int32& offset, MessagePackObject& result);
    private bool ReadItems(int count, bool isMap, Byte[] source, Int32& offset, MessagePackObject& result);
    private Task`1<AsyncReadResult`1<MessagePackObject>> ReadObjectAsync(bool isDeep, CancellationToken cancellationToken);
    public sealed virtual bool ReadArrayLength(Int64& result);
    public sealed virtual Task`1<AsyncReadResult`1<long>> ReadArrayLengthAsync(CancellationToken cancellationToken);
    public sealed virtual bool ReadMapLength(Int64& result);
    public sealed virtual Task`1<AsyncReadResult`1<long>> ReadMapLengthAsync(CancellationToken cancellationToken);
    public sealed virtual bool ReadMessagePackExtendedTypeObject(MessagePackExtendedTypeObject& result);
    private bool ReadMessagePackExtendedTypeObjectCore(int length, Byte[] source, Int32& offset, MessagePackExtendedTypeObject& result);
    public sealed virtual bool ReadNullableMessagePackExtendedTypeObject(Nullable`1& result);
    public sealed virtual Task`1<AsyncReadResult`1<MessagePackExtendedTypeObject>> ReadMessagePackExtendedTypeObjectAsync(CancellationToken cancellationToken);
    public sealed virtual Task`1<AsyncReadResult`1<Nullable`1<MessagePackExtendedTypeObject>>> ReadNullableMessagePackExtendedTypeObjectAsync(CancellationToken cancellationToken);
    protected sealed virtual Nullable`1<long> SkipCore();
    [AsyncStateMachineAttribute("MsgPack.MessagePackByteArrayUnpacker/<SkipAsyncCore>d__123")]
protected sealed virtual Task`1<Nullable`1<long>> SkipAsyncCore(CancellationToken cancellationToken);
    public sealed virtual bool ReadObject(MessagePackObject& result);
    public sealed virtual Task`1<AsyncReadResult`1<MessagePackObject>> ReadObjectAsync(CancellationToken cancellationToken);
    protected sealed virtual bool ReadCore();
    [AsyncStateMachineAttribute("MsgPack.MessagePackByteArrayUnpacker/<ReadAsyncCore>d__127")]
protected sealed virtual Task`1<bool> ReadAsyncCore(CancellationToken cancellationToken);
    private void ThrowUnassignedMessageTypeException(int header);
    private void CheckLength(UInt32 length, ReadValueResult type);
    private void ThrowTooLongLengthException(UInt32 length, ReadValueResult type);
    private void ThrowTypeException(string type, ReadValueResult header);
    private void ThrowTypeException(Type type, ReadValueResult header);
}
internal static class MsgPack.MessagePackCode : object {
    public static int NilValue;
    public static int TrueValue;
    public static int FalseValue;
    public static int SignedInt8;
    public static int UnsignedInt8;
    public static int SignedInt16;
    public static int UnsignedInt16;
    public static int SignedInt32;
    public static int UnsignedInt32;
    public static int SignedInt64;
    public static int UnsignedInt64;
    public static int Real32;
    public static int Real64;
    public static int MinimumFixedArray;
    public static int MaximumFixedArray;
    public static int Array16;
    public static int Array32;
    public static int MinimumFixedMap;
    public static int MaximumFixedMap;
    public static int Map16;
    public static int Map32;
    public static int MinimumFixedRaw;
    public static int MaximumFixedRaw;
    public static int Str8;
    public static int Raw16;
    public static int Raw32;
    public static int Str16;
    public static int Str32;
    public static int Bin8;
    public static int Bin16;
    public static int Bin32;
    public static int Ext8;
    public static int Ext16;
    public static int Ext32;
    public static int FixExt1;
    public static int FixExt2;
    public static int FixExt4;
    public static int FixExt8;
    public static int FixExt16;
    public static string ToString(int code);
}
public static class MsgPack.MessagePackConvert : object {
    private static Encoding _utf8NonBomStrict;
    private static Encoding _utf8NonBom;
    private static long _ticksToMilliseconds;
    private static DateTime _unixEpocUtc;
    internal static Encoding Utf8NonBom { get; }
    internal static Encoding Utf8NonBomStrict { get; }
    private static MessagePackConvert();
    internal static Encoding get_Utf8NonBom();
    internal static Encoding get_Utf8NonBomStrict();
    public static Byte[] EncodeString(string value);
    public static string DecodeStringStrict(Byte[] value);
    public static DateTimeOffset ToDateTimeOffset(long value);
    public static DateTime ToDateTime(long value);
    public static long FromDateTimeOffset(DateTimeOffset value);
    public static long FromDateTime(DateTime value);
}
public class MsgPack.MessagePackExtendedTypeObject : ValueType {
    private byte _typeCode;
    private Byte[] _body;
    public byte TypeCode { get; }
    internal Byte[] Body { get; }
    public bool IsValid { get; }
    private MessagePackExtendedTypeObject(Byte[] body, byte unpackedTypeCode);
    public MessagePackExtendedTypeObject(byte typeCode, Byte[] body);
    public byte get_TypeCode();
    internal Byte[] get_Body();
    public Byte[] GetBody();
    public bool get_IsValid();
    public static MessagePackExtendedTypeObject Unpack(byte typeCode, Byte[] body);
    public virtual string ToString();
    internal void ToString(StringBuilder buffer, bool isJson);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(MessagePackExtendedTypeObject other);
    public static bool op_Equality(MessagePackExtendedTypeObject left, MessagePackExtendedTypeObject right);
    public static bool op_Inequality(MessagePackExtendedTypeObject left, MessagePackExtendedTypeObject right);
}
public class MsgPack.MessagePackObject : ValueType {
    private static ValueTypeCode _sbyteTypeCode;
    private static ValueTypeCode _byteTypeCode;
    private static ValueTypeCode _int16TypeCode;
    private static ValueTypeCode _uint16TypeCode;
    private static ValueTypeCode _int32TypeCode;
    private static ValueTypeCode _uint32TypeCode;
    private static ValueTypeCode _int64TypeCode;
    private static ValueTypeCode _uint64TypeCode;
    private static ValueTypeCode _singleTypeCode;
    private static ValueTypeCode _doubleTypeCode;
    private static ValueTypeCode _booleanTypeCode;
    public static MessagePackObject Nil;
    private object _handleOrTypeCode;
    private ulong _value;
    public bool IsNil { get; }
    public bool IsRaw { get; }
    public bool IsList { get; }
    public bool IsArray { get; }
    public bool IsDictionary { get; }
    public bool IsMap { get; }
    public Type UnderlyingType { get; }
    public MessagePackObject(bool value);
    public MessagePackObject(byte value);
    [CLSCompliantAttribute("False")]
public MessagePackObject(sbyte value);
    public MessagePackObject(short value);
    [CLSCompliantAttribute("False")]
public MessagePackObject(ushort value);
    public MessagePackObject(int value);
    [CLSCompliantAttribute("False")]
public MessagePackObject(UInt32 value);
    public MessagePackObject(long value);
    [CLSCompliantAttribute("False")]
public MessagePackObject(ulong value);
    public MessagePackObject(float value);
    public MessagePackObject(double value);
    public MessagePackObject(string value);
    public MessagePackObject(Byte[] value);
    public MessagePackObject(Byte[] value, bool isBinary);
    public MessagePackObject(MessagePackExtendedTypeObject value);
    public MessagePackObject(IList`1<MessagePackObject> value);
    public MessagePackObject(IList`1<MessagePackObject> value, bool isImmutable);
    public MessagePackObject(MessagePackObjectDictionary value);
    public MessagePackObject(MessagePackObjectDictionary value, bool isImmutable);
    internal MessagePackObject(MessagePackString messagePackString);
    private static MessagePackObject();
    public bool AsBoolean();
    public byte AsByte();
    [CLSCompliantAttribute("False")]
public sbyte AsSByte();
    public short AsInt16();
    [CLSCompliantAttribute("False")]
public ushort AsUInt16();
    public int AsInt32();
    [CLSCompliantAttribute("False")]
public UInt32 AsUInt32();
    public long AsInt64();
    [CLSCompliantAttribute("False")]
public ulong AsUInt64();
    public float AsSingle();
    public double AsDouble();
    public string AsString();
    public Byte[] AsBinary();
    public MessagePackExtendedTypeObject AsMessagePackExtendedTypeObject();
    public static MessagePackObject op_Implicit(bool value);
    public static MessagePackObject op_Implicit(byte value);
    [CLSCompliantAttribute("False")]
public static MessagePackObject op_Implicit(sbyte value);
    public static MessagePackObject op_Implicit(short value);
    [CLSCompliantAttribute("False")]
public static MessagePackObject op_Implicit(ushort value);
    public static MessagePackObject op_Implicit(int value);
    [CLSCompliantAttribute("False")]
public static MessagePackObject op_Implicit(UInt32 value);
    public static MessagePackObject op_Implicit(long value);
    [CLSCompliantAttribute("False")]
public static MessagePackObject op_Implicit(ulong value);
    public static MessagePackObject op_Implicit(float value);
    public static MessagePackObject op_Implicit(double value);
    public static MessagePackObject op_Implicit(string value);
    public static MessagePackObject op_Implicit(Byte[] value);
    public static MessagePackObject op_Implicit(MessagePackExtendedTypeObject value);
    public static bool op_Explicit(MessagePackObject value);
    public static byte op_Explicit(MessagePackObject value);
    [CLSCompliantAttribute("False")]
public static sbyte op_Explicit(MessagePackObject value);
    public static short op_Explicit(MessagePackObject value);
    [CLSCompliantAttribute("False")]
public static ushort op_Explicit(MessagePackObject value);
    public static int op_Explicit(MessagePackObject value);
    [CLSCompliantAttribute("False")]
public static UInt32 op_Explicit(MessagePackObject value);
    public static long op_Explicit(MessagePackObject value);
    [CLSCompliantAttribute("False")]
public static ulong op_Explicit(MessagePackObject value);
    public static float op_Explicit(MessagePackObject value);
    public static double op_Explicit(MessagePackObject value);
    public static string op_Explicit(MessagePackObject value);
    public static Byte[] op_Explicit(MessagePackObject value);
    public static MessagePackExtendedTypeObject op_Explicit(MessagePackObject value);
    public bool get_IsNil();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(MessagePackObject other);
    private bool EqualsWhenValueType(MessagePackObject other, ValueTypeCode valueTypeCode, ValueTypeCode otherValuetypeCode);
    private static bool IntegerIntegerEquals(ulong left, ValueTypeCode leftTypeCode, ulong right, ValueTypeCode rightTypeCode);
    private static bool IntegerSingleEquals(MessagePackObject integer, MessagePackObject real);
    private static bool IntegerDoubleEquals(MessagePackObject integer, MessagePackObject real);
    public virtual int GetHashCode();
    public virtual string ToString();
    private void ToString(StringBuilder buffer, bool isJson);
    private static void ToStringBinary(StringBuilder buffer, bool isJson, MessagePackString asBinary);
    public Nullable`1<bool> IsTypeOf();
    public Nullable`1<bool> IsTypeOf(Type type);
    public bool get_IsRaw();
    public bool get_IsList();
    public bool get_IsArray();
    public bool get_IsDictionary();
    public bool get_IsMap();
    public Type get_UnderlyingType();
    public sealed virtual void PackToMessage(Packer packer, PackingOptions options);
    [AsyncStateMachineAttribute("MsgPack.MessagePackObject/<PackToMessageAsync>d__103")]
public sealed virtual Task PackToMessageAsync(Packer packer, PackingOptions options, CancellationToken cancellationToken);
    public string AsString(Encoding encoding);
    public string AsStringUtf8();
    public string AsStringUtf16();
    public Char[] AsCharArray();
    public IEnumerable`1<MessagePackObject> AsEnumerable();
    public IList`1<MessagePackObject> AsList();
    public MessagePackObjectDictionary AsDictionary();
    private static void VerifyUnderlyingType(MessagePackObject instance, string parameterName);
    private static void VerifyUnderlyingRawType(MessagePackObject instance, string parameterName);
    private static void ThrowCannotBeNilAs();
    private static void ThrowInvalidTypeAs(MessagePackObject instance);
    public static MessagePackObject FromObject(object boxedValue);
    public object ToObject();
    public Timestamp AsTimestamp();
    public static bool op_Equality(MessagePackObject left, MessagePackObject right);
    public static bool op_Inequality(MessagePackObject left, MessagePackObject right);
    public static MessagePackObject op_Implicit(MessagePackObject[] value);
}
[DefaultMemberAttribute("Item")]
[DebuggerTypeProxyAttribute("MsgPack.DictionaryDebuggerProxy`2")]
public class MsgPack.MessagePackObjectDictionary : object {
    private static int Threashold;
    private static int ListInitialCapacity;
    private static int DictionaryInitialCapacity;
    private List`1<MessagePackObject> _keys;
    private List`1<MessagePackObject> _values;
    private Dictionary`2<MessagePackObject, MessagePackObject> _dictionary;
    private int _version;
    private bool _isFrozen;
    public bool IsFrozen { get; }
    public int Count { get; }
    public MessagePackObject Item { get; public set; }
    public KeySet Keys { get; }
    public ValueCollection Values { get; }
    private ICollection`1<MessagePackObject> System.Collections.Generic.IDictionary<MsgPack.MessagePackObject,MsgPack.MessagePackObject>.Keys { get; }
    private ICollection`1<MessagePackObject> System.Collections.Generic.IDictionary<MsgPack.MessagePackObject,MsgPack.MessagePackObject>.Values { get; }
    private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<MsgPack.MessagePackObject,MsgPack.MessagePackObject>>.IsReadOnly { get; }
    private bool System.Collections.IDictionary.IsFixedSize { get; }
    private bool System.Collections.IDictionary.IsReadOnly { get; }
    private ICollection System.Collections.IDictionary.Keys { get; }
    private ICollection System.Collections.IDictionary.Values { get; }
    private object System.Collections.IDictionary.Item { get; private set; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public MessagePackObjectDictionary(int initialCapacity);
    public MessagePackObjectDictionary(IDictionary`2<MessagePackObject, MessagePackObject> dictionary);
    public bool get_IsFrozen();
    public sealed virtual int get_Count();
    public sealed virtual MessagePackObject get_Item(MessagePackObject key);
    public sealed virtual void set_Item(MessagePackObject key, MessagePackObject value);
    public KeySet get_Keys();
    public ValueCollection get_Values();
    private sealed virtual override ICollection`1<MessagePackObject> System.Collections.Generic.IDictionary<MsgPack.MessagePackObject,MsgPack.MessagePackObject>.get_Keys();
    private sealed virtual override ICollection`1<MessagePackObject> System.Collections.Generic.IDictionary<MsgPack.MessagePackObject,MsgPack.MessagePackObject>.get_Values();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<MsgPack.MessagePackObject,MsgPack.MessagePackObject>>.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IDictionary.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IDictionary.get_IsReadOnly();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Keys();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Values();
    private sealed virtual override object System.Collections.IDictionary.get_Item(object key);
    private sealed virtual override void System.Collections.IDictionary.set_Item(object key, object value);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private static void ThrowKeyNotNilException(string parameterName);
    private static void ThrowDuplicatedKeyException(MessagePackObject key, string parameterName);
    private void VerifyIsNotFrozen();
    [ConditionalAttribute("DEBUG")]
private void AssertInvariant();
    private static MessagePackObject ValidateObjectArgument(object obj, string parameterName);
    private static Nullable`1<MessagePackObject> TryValidateObjectArgument(object value);
    public sealed virtual bool ContainsKey(MessagePackObject key);
    public bool ContainsValue(MessagePackObject value);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<MsgPack.MessagePackObject,MsgPack.MessagePackObject>>.Contains(KeyValuePair`2<MessagePackObject, MessagePackObject> item);
    private sealed virtual override bool System.Collections.IDictionary.Contains(object key);
    public sealed virtual bool TryGetValue(MessagePackObject key, MessagePackObject& value);
    public sealed virtual void Add(MessagePackObject key, MessagePackObject value);
    private void AddCore(MessagePackObject key, MessagePackObject value, bool allowOverwrite);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<MsgPack.MessagePackObject,MsgPack.MessagePackObject>>.Add(KeyValuePair`2<MessagePackObject, MessagePackObject> item);
    private sealed virtual override void System.Collections.IDictionary.Add(object key, object value);
    public sealed virtual bool Remove(MessagePackObject key);
    private bool RemoveCore(MessagePackObject key, MessagePackObject value, bool checkValue);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<MsgPack.MessagePackObject,MsgPack.MessagePackObject>>.Remove(KeyValuePair`2<MessagePackObject, MessagePackObject> item);
    private sealed virtual override void System.Collections.IDictionary.Remove(object key);
    public sealed virtual void Clear();
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<MsgPack.MessagePackObject,MsgPack.MessagePackObject>>.CopyTo(KeyValuePair`2[] array, int arrayIndex);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public Enumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<KeyValuePair`2<MessagePackObject, MessagePackObject>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<MsgPack.MessagePackObject,MsgPack.MessagePackObject>>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator();
    public MessagePackObjectDictionary Freeze();
    public MessagePackObjectDictionary AsFrozen();
}
internal class MsgPack.MessagePackObjectEqualityComparer : object {
    private static MessagePackObjectEqualityComparer _instance;
    internal static MessagePackObjectEqualityComparer Instance { get; }
    private static MessagePackObjectEqualityComparer();
    internal static MessagePackObjectEqualityComparer get_Instance();
    public sealed virtual bool Equals(MessagePackObject x, MessagePackObject y);
    public sealed virtual int GetHashCode(MessagePackObject obj);
}
internal class MsgPack.MessagePackStreamPacker : Packer {
    private Stream _destination;
    private Byte[] _scalarBuffer;
    private bool _ownsStream;
    public MessagePackStreamPacker(Stream stream, PackerUnpackerStreamOptions streamOptions, PackerCompatibilityOptions compatibilityOptions);
    protected virtual void Dispose(bool disposing);
    public virtual void Flush();
    protected virtual void WriteByte(byte value);
    protected virtual void WriteBytes(Byte[] value, bool isImmutable);
    protected virtual void WriteBytes(ICollection`1<byte> value);
    private void WriteBytes(Byte[] value);
    private void WriteBytes(Byte[] value, int startIndex, int count);
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    protected virtual Task WriteByteAsync(byte value, CancellationToken cancellationToken);
    protected virtual Task WriteBytesAsync(Byte[] value, bool isImmutable, CancellationToken cancellationToken);
    protected virtual Task WriteBytesAsync(ICollection`1<byte> value, CancellationToken cancellationToken);
    private Task WriteBytesAsync(Byte[] value, CancellationToken cancellationToken);
    private Task WriteBytesAsync(Byte[] value, int startIndex, int count, CancellationToken cancellationToken);
    protected virtual void PackCore(bool value);
    protected virtual void PackCore(byte value);
    protected virtual void PackCore(sbyte value);
    protected virtual void PackCore(short value);
    protected virtual void PackCore(ushort value);
    protected virtual void PackCore(int value);
    protected virtual void PackCore(UInt32 value);
    protected virtual void PackCore(long value);
    protected virtual void PackCore(ulong value);
    protected virtual void PackCore(float value);
    protected virtual void PackCore(double value);
    protected virtual void PackArrayHeaderCore(int length);
    protected virtual void PackMapHeaderCore(int length);
    protected virtual void PackStringHeaderCore(int length);
    protected virtual void PackBinaryHeaderCore(int length);
    protected virtual void PackRawCore(string value);
    protected virtual void PackRawCore(Byte[] value);
    protected virtual void PackBinaryCore(Byte[] value);
    protected virtual void PackExtendedTypeValueCore(byte typeCode, Byte[] body);
    [AsyncStateMachineAttribute("MsgPack.MessagePackStreamPacker/<PackAsyncCore>d__36")]
protected virtual Task PackAsyncCore(bool value, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.MessagePackStreamPacker/<PackAsyncCore>d__37")]
protected virtual Task PackAsyncCore(byte value, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.MessagePackStreamPacker/<PackAsyncCore>d__38")]
protected virtual Task PackAsyncCore(sbyte value, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.MessagePackStreamPacker/<PackAsyncCore>d__39")]
protected virtual Task PackAsyncCore(short value, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.MessagePackStreamPacker/<PackAsyncCore>d__40")]
protected virtual Task PackAsyncCore(ushort value, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.MessagePackStreamPacker/<PackAsyncCore>d__41")]
protected virtual Task PackAsyncCore(int value, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.MessagePackStreamPacker/<PackAsyncCore>d__42")]
protected virtual Task PackAsyncCore(UInt32 value, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.MessagePackStreamPacker/<PackAsyncCore>d__43")]
protected virtual Task PackAsyncCore(long value, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.MessagePackStreamPacker/<PackAsyncCore>d__44")]
protected virtual Task PackAsyncCore(ulong value, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.MessagePackStreamPacker/<PackAsyncCore>d__45")]
protected virtual Task PackAsyncCore(float value, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.MessagePackStreamPacker/<PackAsyncCore>d__46")]
protected virtual Task PackAsyncCore(double value, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.MessagePackStreamPacker/<PackArrayHeaderAsyncCore>d__47")]
protected virtual Task PackArrayHeaderAsyncCore(int length, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.MessagePackStreamPacker/<PackMapHeaderAsyncCore>d__48")]
protected virtual Task PackMapHeaderAsyncCore(int length, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.MessagePackStreamPacker/<PackStringHeaderAsyncCore>d__49")]
protected virtual Task PackStringHeaderAsyncCore(int length, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.MessagePackStreamPacker/<PackBinaryHeaderAsyncCore>d__50")]
protected virtual Task PackBinaryHeaderAsyncCore(int length, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.MessagePackStreamPacker/<PackRawAsyncCore>d__51")]
protected virtual Task PackRawAsyncCore(string value, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.MessagePackStreamPacker/<PackRawAsyncCore>d__52")]
protected virtual Task PackRawAsyncCore(Byte[] value, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.MessagePackStreamPacker/<PackBinaryAsyncCore>d__53")]
protected virtual Task PackBinaryAsyncCore(Byte[] value, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.MessagePackStreamPacker/<PackExtendedTypeValueAsyncCore>d__54")]
protected virtual Task PackExtendedTypeValueAsyncCore(byte typeCode, Byte[] body, CancellationToken cancellationToken);
    private void WriteStringHeader(int bytesLength, bool allowStr8);
    [AsyncStateMachineAttribute("MsgPack.MessagePackStreamPacker/<WriteStringHeaderAsync>d__56")]
private Task WriteStringHeaderAsync(int bytesLength, bool allowStr8, CancellationToken cancellationToken);
    private void WriteBytes(byte header, byte value);
    private void WriteBytes(byte header, ushort value);
    private void WriteBytes(byte header, UInt32 value);
    private void WriteBytes(byte header, ulong value);
    private void WriteBytes(byte header, float value);
    private void WriteBytes(byte header, double value);
    private void WriteBytes(string value, bool allowStr8);
    private void WriteStringBody(string value);
    [AsyncStateMachineAttribute("MsgPack.MessagePackStreamPacker/<WriteBytesAsync>d__65")]
private Task WriteBytesAsync(byte header, byte value, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.MessagePackStreamPacker/<WriteBytesAsync>d__66")]
private Task WriteBytesAsync(byte header, ushort value, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.MessagePackStreamPacker/<WriteBytesAsync>d__67")]
private Task WriteBytesAsync(byte header, UInt32 value, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.MessagePackStreamPacker/<WriteBytesAsync>d__68")]
private Task WriteBytesAsync(byte header, ulong value, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.MessagePackStreamPacker/<WriteBytesAsync>d__69")]
private Task WriteBytesAsync(byte header, float value, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.MessagePackStreamPacker/<WriteBytesAsync>d__70")]
private Task WriteBytesAsync(byte header, double value, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.MessagePackStreamPacker/<WriteBytesAsync>d__71")]
private Task WriteBytesAsync(string value, bool allowStr8, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.MessagePackStreamPacker/<WriteStringBodyAsync>d__72")]
private Task WriteStringBodyAsync(string value, CancellationToken cancellationToken);
    private static bool EncodeString(Encoder encoder, string value, int startOffset, int count, Byte[] buffer, Int32& charsUsed, Int32& bytesUsed);
}
internal abstract class MsgPack.MessagePackStreamUnpacker : Unpacker {
    private Byte[] _oneByteBuffer;
    private Byte[] _scalarBuffer;
    private Stream _source;
    private bool _useStreamPosition;
    private bool _ownsStream;
    private CollectionType _collectionType;
    private MessagePackObject _data;
    private int _subtreeCount;
    private long _offset;
    private long _lastOffset;
    public Nullable`1<MessagePackObject> Data { get; protected set; }
    public MessagePackObject LastReadData { get; protected set; }
    public bool IsArrayHeader { get; }
    public bool IsMapHeader { get; }
    public long ItemsCount { get; }
    public bool IsCollectionHeader { get; }
    private CollectionType MsgPack.IRootUnpacker.CollectionType { get; }
    private Nullable`1<MessagePackObject> MsgPack.IRootUnpacker.Data { get; private set; }
    private MessagePackObject MsgPack.IRootUnpacker.LastReadData { get; private set; }
    public MessagePackStreamUnpacker(Stream stream, PackerUnpackerStreamOptions streamOptions);
    public sealed virtual Nullable`1<MessagePackObject> get_Data();
    protected sealed virtual void set_Data(Nullable`1<MessagePackObject> value);
    public sealed virtual MessagePackObject get_LastReadData();
    protected sealed virtual void set_LastReadData(MessagePackObject value);
    public sealed virtual bool get_IsArrayHeader();
    public sealed virtual bool get_IsMapHeader();
    public sealed virtual long get_ItemsCount();
    public sealed virtual bool get_IsCollectionHeader();
    private sealed virtual override CollectionType MsgPack.IRootUnpacker.get_CollectionType();
    private sealed virtual override Nullable`1<MessagePackObject> MsgPack.IRootUnpacker.get_Data();
    private sealed virtual override void MsgPack.IRootUnpacker.set_Data(Nullable`1<MessagePackObject> value);
    private sealed virtual override MessagePackObject MsgPack.IRootUnpacker.get_LastReadData();
    private sealed virtual override void MsgPack.IRootUnpacker.set_LastReadData(MessagePackObject value);
    internal virtual bool GetPreviousPosition(Int64& offsetOrPosition);
    protected virtual void Dispose(bool disposing);
    protected void BeginReadSubtree();
    protected internal virtual void EndReadSubtree();
    private bool ReadBinaryCore(int length, Int64& offset, Byte[]& result);
    [AsyncStateMachineAttribute("MsgPack.MessagePackStreamUnpacker/<ReadBinaryCoreAsync>d__38")]
private Task`1<AsyncReadResult`1<Int64OffsetValue`1<Byte[]>>> ReadBinaryCoreAsync(int length, long offset, CancellationToken cancellationToken);
    private bool ReadStringCore(int length, Int64& offset, String& result);
    [AsyncStateMachineAttribute("MsgPack.MessagePackStreamUnpacker/<ReadStringCoreAsync>d__40")]
private Task`1<AsyncReadResult`1<Int64OffsetValue`1<string>>> ReadStringCoreAsync(int length, long offset, CancellationToken cancellationToken);
    private bool ReadRawStringCore(int length, Int64& offset, MessagePackString& result);
    [AsyncStateMachineAttribute("MsgPack.MessagePackStreamUnpacker/<ReadRawStringCoreAsync>d__42")]
private Task`1<AsyncReadResult`1<Int64OffsetValue`1<MessagePackString>>> ReadRawStringCoreAsync(int length, long offset, CancellationToken cancellationToken);
    private bool Drain(UInt32 size);
    [AsyncStateMachineAttribute("MsgPack.MessagePackStreamUnpacker/<DrainAsync>d__44")]
private Task`1<bool> DrainAsync(UInt32 size, CancellationToken cancellationToken);
    private sealed virtual override bool MsgPack.IRootUnpacker.ReadObject(bool isDeep, MessagePackObject& result);
    private void ThrowEofException(long reading);
    public sealed virtual bool ReadByte(Byte& result);
    private bool ReadByteSlow(ReadValueResult header, Byte[] buffer, Int64& offset, Byte& result);
    public sealed virtual bool ReadNullableByte(Nullable`1& result);
    private bool ReadNullableByteSlow(ReadValueResult header, Byte[] buffer, Int64& offset, Nullable`1& result);
    [AsyncStateMachineAttribute("MsgPack.MessagePackStreamUnpacker/<ReadByteAsync>d__51")]
public sealed virtual Task`1<AsyncReadResult`1<byte>> ReadByteAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.MessagePackStreamUnpacker/<ReadByteSlowAsync>d__52")]
private Task`1<AsyncReadResult`1<Int64OffsetValue`1<byte>>> ReadByteSlowAsync(ReadValueResult header, Byte[] buffer, long offset, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.MessagePackStreamUnpacker/<ReadNullableByteAsync>d__53")]
public sealed virtual Task`1<AsyncReadResult`1<Nullable`1<byte>>> ReadNullableByteAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.MessagePackStreamUnpacker/<ReadNullableByteSlowAsync>d__54")]
private Task`1<AsyncReadResult`1<Int64OffsetValue`1<Nullable`1<byte>>>> ReadNullableByteSlowAsync(ReadValueResult header, Byte[] buffer, long offset, CancellationToken cancellationToken);
    public sealed virtual bool ReadSByte(SByte& result);
    private bool ReadSByteSlow(ReadValueResult header, Byte[] buffer, Int64& offset, SByte& result);
    public sealed virtual bool ReadNullableSByte(Nullable`1& result);
    private bool ReadNullableSByteSlow(ReadValueResult header, Byte[] buffer, Int64& offset, Nullable`1& result);
    [AsyncStateMachineAttribute("MsgPack.MessagePackStreamUnpacker/<ReadSByteAsync>d__59")]
public sealed virtual Task`1<AsyncReadResult`1<sbyte>> ReadSByteAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.MessagePackStreamUnpacker/<ReadSByteSlowAsync>d__60")]
private Task`1<AsyncReadResult`1<Int64OffsetValue`1<sbyte>>> ReadSByteSlowAsync(ReadValueResult header, Byte[] buffer, long offset, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.MessagePackStreamUnpacker/<ReadNullableSByteAsync>d__61")]
public sealed virtual Task`1<AsyncReadResult`1<Nullable`1<sbyte>>> ReadNullableSByteAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.MessagePackStreamUnpacker/<ReadNullableSByteSlowAsync>d__62")]
private Task`1<AsyncReadResult`1<Int64OffsetValue`1<Nullable`1<sbyte>>>> ReadNullableSByteSlowAsync(ReadValueResult header, Byte[] buffer, long offset, CancellationToken cancellationToken);
    public sealed virtual bool ReadInt16(Int16& result);
    private bool ReadInt16Slow(ReadValueResult header, Byte[] buffer, Int64& offset, Int16& result);
    public sealed virtual bool ReadNullableInt16(Nullable`1& result);
    private bool ReadNullableInt16Slow(ReadValueResult header, Byte[] buffer, Int64& offset, Nullable`1& result);
    [AsyncStateMachineAttribute("MsgPack.MessagePackStreamUnpacker/<ReadInt16Async>d__67")]
public sealed virtual Task`1<AsyncReadResult`1<short>> ReadInt16Async(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.MessagePackStreamUnpacker/<ReadInt16SlowAsync>d__68")]
private Task`1<AsyncReadResult`1<Int64OffsetValue`1<short>>> ReadInt16SlowAsync(ReadValueResult header, Byte[] buffer, long offset, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.MessagePackStreamUnpacker/<ReadNullableInt16Async>d__69")]
public sealed virtual Task`1<AsyncReadResult`1<Nullable`1<short>>> ReadNullableInt16Async(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.MessagePackStreamUnpacker/<ReadNullableInt16SlowAsync>d__70")]
private Task`1<AsyncReadResult`1<Int64OffsetValue`1<Nullable`1<short>>>> ReadNullableInt16SlowAsync(ReadValueResult header, Byte[] buffer, long offset, CancellationToken cancellationToken);
    public sealed virtual bool ReadUInt16(UInt16& result);
    private bool ReadUInt16Slow(ReadValueResult header, Byte[] buffer, Int64& offset, UInt16& result);
    public sealed virtual bool ReadNullableUInt16(Nullable`1& result);
    private bool ReadNullableUInt16Slow(ReadValueResult header, Byte[] buffer, Int64& offset, Nullable`1& result);
    [AsyncStateMachineAttribute("MsgPack.MessagePackStreamUnpacker/<ReadUInt16Async>d__75")]
public sealed virtual Task`1<AsyncReadResult`1<ushort>> ReadUInt16Async(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.MessagePackStreamUnpacker/<ReadUInt16SlowAsync>d__76")]
private Task`1<AsyncReadResult`1<Int64OffsetValue`1<ushort>>> ReadUInt16SlowAsync(ReadValueResult header, Byte[] buffer, long offset, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.MessagePackStreamUnpacker/<ReadNullableUInt16Async>d__77")]
public sealed virtual Task`1<AsyncReadResult`1<Nullable`1<ushort>>> ReadNullableUInt16Async(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.MessagePackStreamUnpacker/<ReadNullableUInt16SlowAsync>d__78")]
private Task`1<AsyncReadResult`1<Int64OffsetValue`1<Nullable`1<ushort>>>> ReadNullableUInt16SlowAsync(ReadValueResult header, Byte[] buffer, long offset, CancellationToken cancellationToken);
    public sealed virtual bool ReadInt32(Int32& result);
    private bool ReadInt32Slow(ReadValueResult header, Byte[] buffer, Int64& offset, Int32& result);
    public sealed virtual bool ReadNullableInt32(Nullable`1& result);
    private bool ReadNullableInt32Slow(ReadValueResult header, Byte[] buffer, Int64& offset, Nullable`1& result);
    [AsyncStateMachineAttribute("MsgPack.MessagePackStreamUnpacker/<ReadInt32Async>d__83")]
public sealed virtual Task`1<AsyncReadResult`1<int>> ReadInt32Async(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.MessagePackStreamUnpacker/<ReadInt32SlowAsync>d__84")]
private Task`1<AsyncReadResult`1<Int64OffsetValue`1<int>>> ReadInt32SlowAsync(ReadValueResult header, Byte[] buffer, long offset, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.MessagePackStreamUnpacker/<ReadNullableInt32Async>d__85")]
public sealed virtual Task`1<AsyncReadResult`1<Nullable`1<int>>> ReadNullableInt32Async(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.MessagePackStreamUnpacker/<ReadNullableInt32SlowAsync>d__86")]
private Task`1<AsyncReadResult`1<Int64OffsetValue`1<Nullable`1<int>>>> ReadNullableInt32SlowAsync(ReadValueResult header, Byte[] buffer, long offset, CancellationToken cancellationToken);
    public sealed virtual bool ReadUInt32(UInt32& result);
    private bool ReadUInt32Slow(ReadValueResult header, Byte[] buffer, Int64& offset, UInt32& result);
    public sealed virtual bool ReadNullableUInt32(Nullable`1& result);
    private bool ReadNullableUInt32Slow(ReadValueResult header, Byte[] buffer, Int64& offset, Nullable`1& result);
    [AsyncStateMachineAttribute("MsgPack.MessagePackStreamUnpacker/<ReadUInt32Async>d__91")]
public sealed virtual Task`1<AsyncReadResult`1<UInt32>> ReadUInt32Async(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.MessagePackStreamUnpacker/<ReadUInt32SlowAsync>d__92")]
private Task`1<AsyncReadResult`1<Int64OffsetValue`1<UInt32>>> ReadUInt32SlowAsync(ReadValueResult header, Byte[] buffer, long offset, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.MessagePackStreamUnpacker/<ReadNullableUInt32Async>d__93")]
public sealed virtual Task`1<AsyncReadResult`1<Nullable`1<UInt32>>> ReadNullableUInt32Async(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.MessagePackStreamUnpacker/<ReadNullableUInt32SlowAsync>d__94")]
private Task`1<AsyncReadResult`1<Int64OffsetValue`1<Nullable`1<UInt32>>>> ReadNullableUInt32SlowAsync(ReadValueResult header, Byte[] buffer, long offset, CancellationToken cancellationToken);
    public sealed virtual bool ReadInt64(Int64& result);
    private bool ReadInt64Slow(ReadValueResult header, Byte[] buffer, Int64& offset, Int64& result);
    public sealed virtual bool ReadNullableInt64(Nullable`1& result);
    private bool ReadNullableInt64Slow(ReadValueResult header, Byte[] buffer, Int64& offset, Nullable`1& result);
    [AsyncStateMachineAttribute("MsgPack.MessagePackStreamUnpacker/<ReadInt64Async>d__99")]
public sealed virtual Task`1<AsyncReadResult`1<long>> ReadInt64Async(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.MessagePackStreamUnpacker/<ReadInt64SlowAsync>d__100")]
private Task`1<AsyncReadResult`1<Int64OffsetValue`1<long>>> ReadInt64SlowAsync(ReadValueResult header, Byte[] buffer, long offset, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.MessagePackStreamUnpacker/<ReadNullableInt64Async>d__101")]
public sealed virtual Task`1<AsyncReadResult`1<Nullable`1<long>>> ReadNullableInt64Async(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.MessagePackStreamUnpacker/<ReadNullableInt64SlowAsync>d__102")]
private Task`1<AsyncReadResult`1<Int64OffsetValue`1<Nullable`1<long>>>> ReadNullableInt64SlowAsync(ReadValueResult header, Byte[] buffer, long offset, CancellationToken cancellationToken);
    public sealed virtual bool ReadUInt64(UInt64& result);
    private bool ReadUInt64Slow(ReadValueResult header, Byte[] buffer, Int64& offset, UInt64& result);
    public sealed virtual bool ReadNullableUInt64(Nullable`1& result);
    private bool ReadNullableUInt64Slow(ReadValueResult header, Byte[] buffer, Int64& offset, Nullable`1& result);
    [AsyncStateMachineAttribute("MsgPack.MessagePackStreamUnpacker/<ReadUInt64Async>d__107")]
public sealed virtual Task`1<AsyncReadResult`1<ulong>> ReadUInt64Async(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.MessagePackStreamUnpacker/<ReadUInt64SlowAsync>d__108")]
private Task`1<AsyncReadResult`1<Int64OffsetValue`1<ulong>>> ReadUInt64SlowAsync(ReadValueResult header, Byte[] buffer, long offset, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.MessagePackStreamUnpacker/<ReadNullableUInt64Async>d__109")]
public sealed virtual Task`1<AsyncReadResult`1<Nullable`1<ulong>>> ReadNullableUInt64Async(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.MessagePackStreamUnpacker/<ReadNullableUInt64SlowAsync>d__110")]
private Task`1<AsyncReadResult`1<Int64OffsetValue`1<Nullable`1<ulong>>>> ReadNullableUInt64SlowAsync(ReadValueResult header, Byte[] buffer, long offset, CancellationToken cancellationToken);
    public sealed virtual bool ReadSingle(Single& result);
    private bool ReadSingleSlow(ReadValueResult header, Byte[] buffer, Int64& offset, Single& result);
    public sealed virtual bool ReadNullableSingle(Nullable`1& result);
    private bool ReadNullableSingleSlow(ReadValueResult header, Byte[] buffer, Int64& offset, Nullable`1& result);
    [AsyncStateMachineAttribute("MsgPack.MessagePackStreamUnpacker/<ReadSingleAsync>d__115")]
public sealed virtual Task`1<AsyncReadResult`1<float>> ReadSingleAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.MessagePackStreamUnpacker/<ReadSingleSlowAsync>d__116")]
private Task`1<AsyncReadResult`1<Int64OffsetValue`1<float>>> ReadSingleSlowAsync(ReadValueResult header, Byte[] buffer, long offset, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.MessagePackStreamUnpacker/<ReadNullableSingleAsync>d__117")]
public sealed virtual Task`1<AsyncReadResult`1<Nullable`1<float>>> ReadNullableSingleAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.MessagePackStreamUnpacker/<ReadNullableSingleSlowAsync>d__118")]
private Task`1<AsyncReadResult`1<Int64OffsetValue`1<Nullable`1<float>>>> ReadNullableSingleSlowAsync(ReadValueResult header, Byte[] buffer, long offset, CancellationToken cancellationToken);
    public sealed virtual bool ReadDouble(Double& result);
    private bool ReadDoubleSlow(ReadValueResult header, Byte[] buffer, Int64& offset, Double& result);
    public sealed virtual bool ReadNullableDouble(Nullable`1& result);
    private bool ReadNullableDoubleSlow(ReadValueResult header, Byte[] buffer, Int64& offset, Nullable`1& result);
    [AsyncStateMachineAttribute("MsgPack.MessagePackStreamUnpacker/<ReadDoubleAsync>d__123")]
public sealed virtual Task`1<AsyncReadResult`1<double>> ReadDoubleAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.MessagePackStreamUnpacker/<ReadDoubleSlowAsync>d__124")]
private Task`1<AsyncReadResult`1<Int64OffsetValue`1<double>>> ReadDoubleSlowAsync(ReadValueResult header, Byte[] buffer, long offset, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.MessagePackStreamUnpacker/<ReadNullableDoubleAsync>d__125")]
public sealed virtual Task`1<AsyncReadResult`1<Nullable`1<double>>> ReadNullableDoubleAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.MessagePackStreamUnpacker/<ReadNullableDoubleSlowAsync>d__126")]
private Task`1<AsyncReadResult`1<Int64OffsetValue`1<Nullable`1<double>>>> ReadNullableDoubleSlowAsync(ReadValueResult header, Byte[] buffer, long offset, CancellationToken cancellationToken);
    public sealed virtual bool ReadBoolean(Boolean& result);
    public sealed virtual bool ReadNullableBoolean(Nullable`1& result);
    [AsyncStateMachineAttribute("MsgPack.MessagePackStreamUnpacker/<ReadBooleanAsync>d__129")]
public sealed virtual Task`1<AsyncReadResult`1<bool>> ReadBooleanAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.MessagePackStreamUnpacker/<ReadNullableBooleanAsync>d__130")]
public sealed virtual Task`1<AsyncReadResult`1<Nullable`1<bool>>> ReadNullableBooleanAsync(CancellationToken cancellationToken);
    public sealed virtual bool ReadBinary(Byte[]& result);
    [AsyncStateMachineAttribute("MsgPack.MessagePackStreamUnpacker/<ReadBinaryAsync>d__132")]
public sealed virtual Task`1<AsyncReadResult`1<Byte[]>> ReadBinaryAsync(CancellationToken cancellationToken);
    public sealed virtual bool ReadString(String& result);
    [AsyncStateMachineAttribute("MsgPack.MessagePackStreamUnpacker/<ReadStringAsync>d__134")]
public sealed virtual Task`1<AsyncReadResult`1<string>> ReadStringAsync(CancellationToken cancellationToken);
    private bool ReadObject(bool isDeep, MessagePackObject& result);
    private bool ReadObjectCore(bool isDeep, Byte[] buffer, Int64& offset, MessagePackObject& result);
    private bool ReadObjectSlow(ReadValueResult header, Byte[] buffer, Int64& offset, MessagePackObject& result);
    private bool ReadItems(int count, bool isMap, Byte[] buffer, Int64& offset, MessagePackObject& result);
    [AsyncStateMachineAttribute("MsgPack.MessagePackStreamUnpacker/<ReadObjectAsync>d__139")]
private Task`1<AsyncReadResult`1<MessagePackObject>> ReadObjectAsync(bool isDeep, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.MessagePackStreamUnpacker/<ReadObjectCoreAsync>d__140")]
private Task`1<AsyncReadResult`1<Int64OffsetValue`1<MessagePackObject>>> ReadObjectCoreAsync(bool isDeep, Byte[] buffer, long offset, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.MessagePackStreamUnpacker/<ReadObjectSlowAsync>d__141")]
private Task`1<AsyncReadResult`1<Int64OffsetValue`1<MessagePackObject>>> ReadObjectSlowAsync(ReadValueResult header, Byte[] buffer, long offset, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.MessagePackStreamUnpacker/<ReadItemsAsync>d__142")]
private Task`1<AsyncReadResult`1<Int64OffsetValue`1<MessagePackObject>>> ReadItemsAsync(int count, bool isMap, Byte[] buffer, long offset, CancellationToken cancellationToken);
    public sealed virtual bool ReadArrayLength(Int64& result);
    [AsyncStateMachineAttribute("MsgPack.MessagePackStreamUnpacker/<ReadArrayLengthAsync>d__144")]
public sealed virtual Task`1<AsyncReadResult`1<long>> ReadArrayLengthAsync(CancellationToken cancellationToken);
    public sealed virtual bool ReadMapLength(Int64& result);
    [AsyncStateMachineAttribute("MsgPack.MessagePackStreamUnpacker/<ReadMapLengthAsync>d__146")]
public sealed virtual Task`1<AsyncReadResult`1<long>> ReadMapLengthAsync(CancellationToken cancellationToken);
    public sealed virtual bool ReadMessagePackExtendedTypeObject(MessagePackExtendedTypeObject& result);
    private bool ReadMessagePackExtendedTypeObjectCore(int length, Byte[] buffer, Int64& offset, MessagePackExtendedTypeObject& result);
    public sealed virtual bool ReadNullableMessagePackExtendedTypeObject(Nullable`1& result);
    [AsyncStateMachineAttribute("MsgPack.MessagePackStreamUnpacker/<ReadMessagePackExtendedTypeObjectAsync>d__150")]
public sealed virtual Task`1<AsyncReadResult`1<MessagePackExtendedTypeObject>> ReadMessagePackExtendedTypeObjectAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.MessagePackStreamUnpacker/<ReadMessagePackExtendedTypeObjectCoreAsync>d__151")]
private Task`1<AsyncReadResult`1<Int64OffsetValue`1<MessagePackExtendedTypeObject>>> ReadMessagePackExtendedTypeObjectCoreAsync(int length, Byte[] buffer, long offset, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.MessagePackStreamUnpacker/<ReadNullableMessagePackExtendedTypeObjectAsync>d__152")]
public sealed virtual Task`1<AsyncReadResult`1<Nullable`1<MessagePackExtendedTypeObject>>> ReadNullableMessagePackExtendedTypeObjectAsync(CancellationToken cancellationToken);
    protected sealed virtual Nullable`1<long> SkipCore();
    [AsyncStateMachineAttribute("MsgPack.MessagePackStreamUnpacker/<SkipAsyncCore>d__154")]
protected sealed virtual Task`1<Nullable`1<long>> SkipAsyncCore(CancellationToken cancellationToken);
    public sealed virtual bool ReadObject(MessagePackObject& result);
    public sealed virtual Task`1<AsyncReadResult`1<MessagePackObject>> ReadObjectAsync(CancellationToken cancellationToken);
    protected sealed virtual bool ReadCore();
    [AsyncStateMachineAttribute("MsgPack.MessagePackStreamUnpacker/<ReadAsyncCore>d__158")]
protected sealed virtual Task`1<bool> ReadAsyncCore(CancellationToken cancellationToken);
    private void ThrowUnassignedMessageTypeException(int header);
    private void CheckLength(UInt32 length, ReadValueResult type);
    private void ThrowTooLongLengthException(UInt32 length, ReadValueResult type);
    private void ThrowTypeException(string type, ReadValueResult header);
    private void ThrowTypeException(Type type, ReadValueResult header);
}
[SecuritySafeCriticalAttribute]
[DebuggerDisplayAttribute("{DebuggerDisplayString}")]
[DebuggerTypeProxyAttribute("MsgPack.MessagePackString/MessagePackStringDebuggerProxy")]
internal class MsgPack.MessagePackString : object {
    private static DecoderFallbackException IsBinary;
    private Byte[] _encoded;
    private string _decoded;
    private DecoderFallbackException _decodingError;
    private BinaryType _type;
    private static int _isFastEqualsDisabled;
    private string DebuggerDisplayString { get; }
    public MessagePackString(string decoded);
    public MessagePackString(Byte[] encoded, bool isBinary);
    private MessagePackString(MessagePackString other);
    private static MessagePackString();
    private string get_DebuggerDisplayString();
    private void EncodeIfNeeded();
    private void DecodeIfNeeded();
    public string TryGetString();
    public string GetString();
    public Byte[] UnsafeGetBuffer();
    public string UnsafeGetString();
    public Byte[] GetBytes();
    public Type GetUnderlyingType();
    public virtual string ToString();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    private static bool EqualsEncoded(MessagePackString left, MessagePackString right);
    private static bool SlowEquals(Byte[] x, Byte[] y);
    [SecuritySafeCriticalAttribute]
private static bool UnsafeFastEquals(Byte[] x, Byte[] y);
}
public class MsgPack.MessageTypeException : Exception {
    public MessageTypeException(string message);
    public MessageTypeException(string message, Exception inner);
    protected MessageTypeException(SerializationInfo info, StreamingContext context);
}
public abstract class MsgPack.Packer : object {
    private static Int32 modreq(System.Runtime.CompilerServices.IsVolatile) _defaultCompatibilityOptions;
    private bool _isDisposed;
    private PackerCompatibilityOptions _compatibilityOptions;
    public static PackerCompatibilityOptions DefaultCompatibilityOptions { get; public set; }
    public bool CanSeek { get; }
    public long Position { get; }
    public PackerCompatibilityOptions CompatibilityOptions { get; }
    protected Packer(PackerCompatibilityOptions compatibilityOptions);
    private static Packer();
    public static PackerCompatibilityOptions get_DefaultCompatibilityOptions();
    public static void set_DefaultCompatibilityOptions(PackerCompatibilityOptions value);
    public virtual bool get_CanSeek();
    public virtual long get_Position();
    public PackerCompatibilityOptions get_CompatibilityOptions();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    private void VerifyNotDisposed();
    private void ThrowObjectDisposedException();
    public virtual void Flush();
    public Task FlushAsync();
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    protected virtual void SeekTo(long offset);
    protected abstract virtual void WriteByte(byte value);
    protected Task WriteByteAsync(byte value);
    protected virtual Task WriteByteAsync(byte value, CancellationToken cancellationToken);
    protected virtual void WriteBytes(ICollection`1<byte> value);
    protected Task WriteBytesAsync(ICollection`1<byte> value);
    [AsyncStateMachineAttribute("MsgPack.Packer/<WriteBytesAsync>d__27")]
protected virtual Task WriteBytesAsync(ICollection`1<byte> value, CancellationToken cancellationToken);
    protected virtual void WriteBytes(Byte[] value, bool isImmutable);
    protected Task WriteBytesAsync(Byte[] value, bool isImmutable);
    [AsyncStateMachineAttribute("MsgPack.Packer/<WriteBytesAsync>d__30")]
protected virtual Task WriteBytesAsync(Byte[] value, bool isImmutable, CancellationToken cancellationToken);
    [CLSCompliantAttribute("False")]
public Packer Pack(sbyte value);
    [CLSCompliantAttribute("False")]
public Task PackAsync(sbyte value);
    [CLSCompliantAttribute("False")]
public Task PackAsync(sbyte value, CancellationToken cancellationToken);
    [CLSCompliantAttribute("False")]
protected virtual void PackCore(sbyte value);
    [AsyncStateMachineAttribute("MsgPack.Packer/<PackAsyncCore>d__35")]
[CLSCompliantAttribute("False")]
protected virtual Task PackAsyncCore(sbyte value, CancellationToken cancellationToken);
    protected bool TryPackInt8(long value);
    protected Task`1<bool> TryPackInt8Async(long value);
    [AsyncStateMachineAttribute("MsgPack.Packer/<TryPackInt8Async>d__38")]
protected Task`1<bool> TryPackInt8Async(long value, CancellationToken cancellationToken);
    public Packer Pack(byte value);
    public Task PackAsync(byte value);
    public Task PackAsync(byte value, CancellationToken cancellationToken);
    protected virtual void PackCore(byte value);
    protected virtual Task PackAsyncCore(byte value, CancellationToken cancellationToken);
    [CLSCompliantAttribute("False")]
protected bool TryPackUInt8(ulong value);
    [CLSCompliantAttribute("False")]
protected Task`1<bool> TryPackUInt8Async(ulong value);
    [AsyncStateMachineAttribute("MsgPack.Packer/<TryPackUInt8Async>d__46")]
[CLSCompliantAttribute("False")]
protected Task`1<bool> TryPackUInt8Async(ulong value, CancellationToken cancellationToken);
    public Packer Pack(bool value);
    public Task PackAsync(bool value);
    public Task PackAsync(bool value, CancellationToken cancellationToken);
    protected virtual void PackCore(bool value);
    [AsyncStateMachineAttribute("MsgPack.Packer/<PackAsyncCore>d__51")]
protected virtual Task PackAsyncCore(bool value, CancellationToken cancellationToken);
    protected bool TryPackTinySignedInteger(long value);
    protected Task`1<bool> TryPackTinySignedIntegerAsync(long value);
    [AsyncStateMachineAttribute("MsgPack.Packer/<TryPackTinySignedIntegerAsync>d__54")]
protected Task`1<bool> TryPackTinySignedIntegerAsync(long value, CancellationToken cancellationToken);
    [CLSCompliantAttribute("False")]
protected bool TryPackTinyUnsignedInteger(ulong value);
    [CLSCompliantAttribute("False")]
protected Task`1<bool> TryPackTinyUnsignedIntegerAsync(ulong value);
    [AsyncStateMachineAttribute("MsgPack.Packer/<TryPackTinyUnsignedIntegerAsync>d__57")]
[CLSCompliantAttribute("False")]
protected Task`1<bool> TryPackTinyUnsignedIntegerAsync(ulong value, CancellationToken cancellationToken);
    public Packer PackNull();
    public Task PackNullAsync();
    [AsyncStateMachineAttribute("MsgPack.Packer/<PackNullAsync>d__60")]
public Task PackNullAsync(CancellationToken cancellationToken);
    private void PrivatePackNullCore();
    [AsyncStateMachineAttribute("MsgPack.Packer/<PrivatePackNullAsyncCore>d__62")]
private Task PrivatePackNullAsyncCore(CancellationToken cancellationToken);
    private static void ThrowArgumentNullException(string parameterName);
    private static void ThrowCannotBeNegativeException(string parameterName);
    private static void ThrowMissingBodyOfExtTypeValueException(string parameterName);
    private static void ThrowExtTypeIsProhibitedException();
    public static Packer Create(Stream stream);
    public static Packer Create(Stream stream, PackerCompatibilityOptions compatibilityOptions);
    public static Packer Create(Stream stream, bool ownsStream);
    public static Packer Create(Stream stream, PackerCompatibilityOptions compatibilityOptions, bool ownsStream);
    public static Packer Create(Stream stream, PackerCompatibilityOptions compatibilityOptions, PackerUnpackerStreamOptions streamOptions);
    public static ByteArrayPacker Create(Byte[] buffer);
    public static ByteArrayPacker Create(Byte[] buffer, int startOffset);
    public static ByteArrayPacker Create(Byte[] buffer, bool allowsBufferExpansion, PackerCompatibilityOptions compatibilityOptions);
    public static ByteArrayPacker Create(Byte[] buffer, int startOffset, bool allowsBufferExpansion, PackerCompatibilityOptions compatibilityOptions);
    public static ByteArrayPacker Create(Byte[] buffer, Func`3<Byte[], int, Byte[]> allocator, PackerCompatibilityOptions compatibilityOptions);
    public static ByteArrayPacker Create(Byte[] buffer, int startOffset, Func`3<Byte[], int, Byte[]> allocator, PackerCompatibilityOptions compatibilityOptions);
    [CLSCompliantAttribute("False")]
public Packer Pack(Nullable`1<sbyte> value);
    [CLSCompliantAttribute("False")]
public Task PackAsync(Nullable`1<sbyte> value);
    [CLSCompliantAttribute("False")]
public Task PackAsync(Nullable`1<sbyte> value, CancellationToken cancellationToken);
    public Packer Pack(Nullable`1<byte> value);
    public Task PackAsync(Nullable`1<byte> value);
    public Task PackAsync(Nullable`1<byte> value, CancellationToken cancellationToken);
    public Packer Pack(Nullable`1<short> value);
    public Task PackAsync(Nullable`1<short> value);
    public Task PackAsync(Nullable`1<short> value, CancellationToken cancellationToken);
    [CLSCompliantAttribute("False")]
public Packer Pack(Nullable`1<ushort> value);
    [CLSCompliantAttribute("False")]
public Task PackAsync(Nullable`1<ushort> value);
    [CLSCompliantAttribute("False")]
public Task PackAsync(Nullable`1<ushort> value, CancellationToken cancellationToken);
    public Packer Pack(Nullable`1<int> value);
    public Task PackAsync(Nullable`1<int> value);
    public Task PackAsync(Nullable`1<int> value, CancellationToken cancellationToken);
    [CLSCompliantAttribute("False")]
public Packer Pack(Nullable`1<UInt32> value);
    [CLSCompliantAttribute("False")]
public Task PackAsync(Nullable`1<UInt32> value);
    [CLSCompliantAttribute("False")]
public Task PackAsync(Nullable`1<UInt32> value, CancellationToken cancellationToken);
    public Packer Pack(Nullable`1<long> value);
    public Task PackAsync(Nullable`1<long> value);
    public Task PackAsync(Nullable`1<long> value, CancellationToken cancellationToken);
    [CLSCompliantAttribute("False")]
public Packer Pack(Nullable`1<ulong> value);
    [CLSCompliantAttribute("False")]
public Task PackAsync(Nullable`1<ulong> value);
    [CLSCompliantAttribute("False")]
public Task PackAsync(Nullable`1<ulong> value, CancellationToken cancellationToken);
    public Packer Pack(Nullable`1<float> value);
    public Task PackAsync(Nullable`1<float> value);
    public Task PackAsync(Nullable`1<float> value, CancellationToken cancellationToken);
    public Packer Pack(Nullable`1<double> value);
    public Task PackAsync(Nullable`1<double> value);
    public Task PackAsync(Nullable`1<double> value, CancellationToken cancellationToken);
    public Packer Pack(Nullable`1<bool> value);
    public Task PackAsync(Nullable`1<bool> value);
    public Task PackAsync(Nullable`1<bool> value, CancellationToken cancellationToken);
    public Packer Pack(short value);
    protected virtual void PackCore(short value);
    protected bool TryPackInt16(long value);
    public Task PackAsync(short value);
    public Task PackAsync(short value, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.Packer/<PackAsyncCore>d__116")]
protected virtual Task PackAsyncCore(short value, CancellationToken cancellationToken);
    protected Task`1<bool> TryPackInt16Async(long value);
    [AsyncStateMachineAttribute("MsgPack.Packer/<TryPackInt16Async>d__118")]
protected Task`1<bool> TryPackInt16Async(long value, CancellationToken cancellationToken);
    [CLSCompliantAttribute("False")]
public Packer Pack(ushort value);
    [CLSCompliantAttribute("False")]
protected virtual void PackCore(ushort value);
    [CLSCompliantAttribute("False")]
protected bool TryPackUInt16(ulong value);
    [CLSCompliantAttribute("False")]
public Task PackAsync(ushort value);
    [CLSCompliantAttribute("False")]
public Task PackAsync(ushort value, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.Packer/<PackAsyncCore>d__124")]
[CLSCompliantAttribute("False")]
protected virtual Task PackAsyncCore(ushort value, CancellationToken cancellationToken);
    [CLSCompliantAttribute("False")]
protected Task`1<bool> TryPackUInt16Async(ulong value);
    [AsyncStateMachineAttribute("MsgPack.Packer/<TryPackUInt16Async>d__126")]
[CLSCompliantAttribute("False")]
protected Task`1<bool> TryPackUInt16Async(ulong value, CancellationToken cancellationToken);
    public Packer Pack(int value);
    protected virtual void PackCore(int value);
    protected bool TryPackInt32(long value);
    public Task PackAsync(int value);
    public Task PackAsync(int value, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.Packer/<PackAsyncCore>d__132")]
protected virtual Task PackAsyncCore(int value, CancellationToken cancellationToken);
    protected Task`1<bool> TryPackInt32Async(long value);
    [AsyncStateMachineAttribute("MsgPack.Packer/<TryPackInt32Async>d__134")]
protected Task`1<bool> TryPackInt32Async(long value, CancellationToken cancellationToken);
    [CLSCompliantAttribute("False")]
public Packer Pack(UInt32 value);
    [CLSCompliantAttribute("False")]
protected virtual void PackCore(UInt32 value);
    [CLSCompliantAttribute("False")]
protected bool TryPackUInt32(ulong value);
    [CLSCompliantAttribute("False")]
public Task PackAsync(UInt32 value);
    [CLSCompliantAttribute("False")]
public Task PackAsync(UInt32 value, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.Packer/<PackAsyncCore>d__140")]
[CLSCompliantAttribute("False")]
protected virtual Task PackAsyncCore(UInt32 value, CancellationToken cancellationToken);
    [CLSCompliantAttribute("False")]
protected Task`1<bool> TryPackUInt32Async(ulong value);
    [AsyncStateMachineAttribute("MsgPack.Packer/<TryPackUInt32Async>d__142")]
[CLSCompliantAttribute("False")]
protected Task`1<bool> TryPackUInt32Async(ulong value, CancellationToken cancellationToken);
    public Packer Pack(long value);
    protected virtual void PackCore(long value);
    protected bool TryPackInt64(long value);
    public Task PackAsync(long value);
    public Task PackAsync(long value, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.Packer/<PackAsyncCore>d__148")]
protected virtual Task PackAsyncCore(long value, CancellationToken cancellationToken);
    protected Task`1<bool> TryPackInt64Async(long value);
    [AsyncStateMachineAttribute("MsgPack.Packer/<TryPackInt64Async>d__150")]
protected Task`1<bool> TryPackInt64Async(long value, CancellationToken cancellationToken);
    [CLSCompliantAttribute("False")]
public Packer Pack(ulong value);
    [CLSCompliantAttribute("False")]
protected virtual void PackCore(ulong value);
    [CLSCompliantAttribute("False")]
protected bool TryPackUInt64(ulong value);
    [CLSCompliantAttribute("False")]
public Task PackAsync(ulong value);
    [CLSCompliantAttribute("False")]
public Task PackAsync(ulong value, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.Packer/<PackAsyncCore>d__156")]
[CLSCompliantAttribute("False")]
protected virtual Task PackAsyncCore(ulong value, CancellationToken cancellationToken);
    [CLSCompliantAttribute("False")]
protected Task`1<bool> TryPackUInt64Async(ulong value);
    [AsyncStateMachineAttribute("MsgPack.Packer/<TryPackUInt64Async>d__158")]
[CLSCompliantAttribute("False")]
protected Task`1<bool> TryPackUInt64Async(ulong value, CancellationToken cancellationToken);
    public Packer Pack(float value);
    protected virtual void PackCore(float value);
    public Task PackAsync(float value);
    public Task PackAsync(float value, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.Packer/<PackAsyncCore>d__163")]
protected virtual Task PackAsyncCore(float value, CancellationToken cancellationToken);
    public Packer Pack(double value);
    protected virtual void PackCore(double value);
    public Task PackAsync(double value);
    public Task PackAsync(double value, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.Packer/<PackAsyncCore>d__168")]
protected virtual Task PackAsyncCore(double value, CancellationToken cancellationToken);
    public Packer PackArrayHeader(int count);
    protected virtual void PackArrayHeaderCore(int count);
    public Task PackArrayHeaderAsync(int count);
    protected Task PackArrayHeaderAsyncCore(int count);
    public Task PackArrayHeaderAsync(int count, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.Packer/<PackArrayHeaderAsyncCore>d__174")]
protected virtual Task PackArrayHeaderAsyncCore(int count, CancellationToken cancellationToken);
    public Packer PackMapHeader(int count);
    protected virtual void PackMapHeaderCore(int count);
    public Task PackMapHeaderAsync(int count);
    protected Task PackMapHeaderAsyncCore(int count);
    public Task PackMapHeaderAsync(int count, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.Packer/<PackMapHeaderAsyncCore>d__180")]
protected virtual Task PackMapHeaderAsyncCore(int count, CancellationToken cancellationToken);
    [ObsoleteAttribute("Use PackStringHeader(Int32) or Use PackBinaryHeader(Int32) instead.")]
public Packer PackRawHeader(int length);
    [ObsoleteAttribute("Use PackStringHeader(Int32) or Use PackBinaryHeader(Int32) instead.")]
public Task PackRawHeaderAsync(int length);
    [ObsoleteAttribute("Use PackStringHeader(Int32) or Use PackBinaryHeader(Int32) instead.")]
public Task PackRawHeaderAsync(int length, CancellationToken cancellationToken);
    public Packer PackStringHeader(int length);
    public Task PackStringHeaderAsync(int length);
    public Task PackStringHeaderAsync(int length, CancellationToken cancellationToken);
    public Packer PackBinaryHeader(int length);
    public Task PackBinaryHeaderAsync(int length);
    public Task PackBinaryHeaderAsync(int length, CancellationToken cancellationToken);
    [ObsoleteAttribute("Use PackStringHeaderCore(Int32) or Use PackBinaryHeaderCore(Int32) instead.")]
protected void PackRawHeaderCore(int length);
    [ObsoleteAttribute("Use PackStringHeaderCore(Int32) or Use PackBinaryHeaderCore(Int32) instead.")]
protected Task PackRawHeaderAsyncCore(int length);
    [ObsoleteAttribute("Use PackStringHeaderCore(Int32) or Use PackBinaryHeaderCore(Int32) instead.")]
protected Task PackRawHeaderAsyncCore(int length, CancellationToken cancellationToken);
    protected virtual void PackStringHeaderCore(int length);
    protected Task PackStringHeaderAsyncCore(int length);
    [AsyncStateMachineAttribute("MsgPack.Packer/<PackStringHeaderAsyncCore>d__195")]
protected virtual Task PackStringHeaderAsyncCore(int length, CancellationToken cancellationToken);
    protected virtual void PackBinaryHeaderCore(int length);
    protected Task PackBinaryHeaderAsyncCore(int length);
    [AsyncStateMachineAttribute("MsgPack.Packer/<PackBinaryHeaderAsyncCore>d__198")]
protected virtual Task PackBinaryHeaderAsyncCore(int length, CancellationToken cancellationToken);
    public Packer PackRaw(IEnumerable`1<byte> value);
    public Packer PackRaw(IList`1<byte> value);
    public Packer PackRaw(Byte[] value);
    protected virtual void PackRawCore(Byte[] value);
    public Task PackRawAsync(IEnumerable`1<byte> value);
    public Task PackRawAsync(IEnumerable`1<byte> value, CancellationToken cancellationToken);
    public Task PackRawAsync(IList`1<byte> value);
    public Task PackRawAsync(IList`1<byte> value, CancellationToken cancellationToken);
    public Task PackRawAsync(Byte[] value);
    public Task PackRawAsync(Byte[] value, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.Packer/<PackRawAsyncCore>d__209")]
protected virtual Task PackRawAsyncCore(Byte[] value, CancellationToken cancellationToken);
    public Packer PackBinary(IEnumerable`1<byte> value);
    public Packer PackBinary(IList`1<byte> value);
    public Packer PackBinary(Byte[] value);
    protected virtual void PackBinaryCore(Byte[] value);
    public Task PackBinaryAsync(IEnumerable`1<byte> value);
    public Task PackBinaryAsync(IEnumerable`1<byte> value, CancellationToken cancellationToken);
    public Task PackBinaryAsync(IList`1<byte> value);
    public Task PackBinaryAsync(IList`1<byte> value, CancellationToken cancellationToken);
    public Task PackBinaryAsync(Byte[] value);
    public Task PackBinaryAsync(Byte[] value, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.Packer/<PackBinaryAsyncCore>d__220")]
protected virtual Task PackBinaryAsyncCore(Byte[] value, CancellationToken cancellationToken);
    public Packer PackString(IEnumerable`1<char> value);
    public Packer PackString(IEnumerable`1<char> value, Encoding encoding);
    protected virtual void PackStringCore(IEnumerable`1<char> value, Encoding encoding);
    public Task PackStringAsync(IEnumerable`1<char> value);
    public Task PackStringAsync(IEnumerable`1<char> value, Encoding encoding);
    protected Task PackStringAsyncCore(IEnumerable`1<char> value, Encoding encoding);
    public Task PackStringAsync(IEnumerable`1<char> value, CancellationToken cancellationToken);
    public Task PackStringAsync(IEnumerable`1<char> value, Encoding encoding, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.Packer/<PackStringAsyncCore>d__229")]
protected virtual Task PackStringAsyncCore(IEnumerable`1<char> value, Encoding encoding, CancellationToken cancellationToken);
    public Packer PackString(string value);
    public Packer PackString(string value, Encoding encoding);
    protected virtual void PackStringCore(string value, Encoding encoding);
    public Task PackStringAsync(string value);
    public Task PackStringAsync(string value, Encoding encoding);
    protected Task PackStringAsyncCore(string value, Encoding encoding);
    public Task PackStringAsync(string value, CancellationToken cancellationToken);
    public Task PackStringAsync(string value, Encoding encoding, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.Packer/<PackStringAsyncCore>d__238")]
protected virtual Task PackStringAsyncCore(string value, Encoding encoding, CancellationToken cancellationToken);
    protected virtual void PackRawCore(string value);
    private void PackRawCore(IEnumerable`1<char> value);
    protected virtual Task PackRawAsyncCore(string value, CancellationToken cancellationToken);
    private Task PackRawAsyncCore(IEnumerable`1<char> value, CancellationToken cancellationToken);
    public Packer PackRawBody(Byte[] value);
    public Packer PackRawBody(IEnumerable`1<byte> value);
    private int PrivatePackRawBodyCore(IEnumerable`1<byte> value);
    private int PrivatePackRawBodyCore(ICollection`1<byte> value, bool isImmutable);
    public Task PackRawBodyAsync(Byte[] value);
    public Task PackRawBodyAsync(IEnumerable`1<byte> value);
    public Task PackRawBodyAsync(Byte[] value, CancellationToken cancellationToken);
    public Task PackRawBodyAsync(IEnumerable`1<byte> value, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.Packer/<PrivatePackRawBodyAsyncCore>d__251")]
private Task`1<int> PrivatePackRawBodyAsyncCore(IEnumerable`1<byte> value, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.Packer/<PrivatePackRawBodyAsyncCore>d__252")]
private Task`1<int> PrivatePackRawBodyAsyncCore(ICollection`1<byte> value, bool isImmutable, CancellationToken cancellationToken);
    public Packer PackArrayHeader(IList`1<TItem> array);
    public Task PackArrayHeaderAsync(IList`1<TItem> array);
    public Task PackArrayHeaderAsync(IList`1<TItem> array, CancellationToken cancellationToken);
    public Packer PackMapHeader(IDictionary`2<TKey, TValue> map);
    public Task PackMapHeaderAsync(IDictionary`2<TKey, TValue> map);
    public Task PackMapHeaderAsync(IDictionary`2<TKey, TValue> map, CancellationToken cancellationToken);
    public Packer PackExtendedTypeValue(byte typeCode, Byte[] body);
    public Packer PackExtendedTypeValue(MessagePackExtendedTypeObject mpeto);
    protected virtual void PackExtendedTypeValueCore(byte typeCode, Byte[] body);
    public Task PackExtendedTypeValueAsync(byte typeCode, Byte[] body);
    public Task PackExtendedTypeValueAsync(MessagePackExtendedTypeObject mpeto);
    public Task PackExtendedTypeValueAsync(byte typeCode, Byte[] body, CancellationToken cancellationToken);
    public Task PackExtendedTypeValueAsync(MessagePackExtendedTypeObject mpeto, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.Packer/<PackExtendedTypeValueAsyncCore>d__266")]
protected virtual Task PackExtendedTypeValueAsyncCore(byte typeCode, Byte[] body, CancellationToken cancellationToken);
    private void StreamWrite(IEnumerable`1<TItem> value, Action`2<IEnumerable`1<TItem>, PackingOptions> writeBody, PackingOptions options);
    [AsyncStateMachineAttribute("MsgPack.Packer/<StreamWriteAsync>d__268`1")]
private Task StreamWriteAsync(IEnumerable`1<TItem> value, Func`4<IEnumerable`1<TItem>, PackingOptions, CancellationToken, Task> writeBody, PackingOptions options, CancellationToken cancellationToken);
}
[FlagsAttribute]
public enum MsgPack.PackerCompatibilityOptions : Enum {
    public int value__;
    public static PackerCompatibilityOptions None;
    public static PackerCompatibilityOptions PackBinaryAsRaw;
    public static PackerCompatibilityOptions ProhibitExtendedTypeObjects;
    public static PackerCompatibilityOptions Classic;
}
[ExtensionAttribute]
public static class MsgPack.PackerUnpackerExtensions : object {
    [ExtensionAttribute]
public static Packer Pack(Packer source, T value);
    [ExtensionAttribute]
public static Packer Pack(Packer source, T value, SerializationContext context);
    private static void PackCore(Packer source, T value, SerializationContext context);
    [ExtensionAttribute]
public static Task PackAsync(Packer source, T value);
    [ExtensionAttribute]
public static Task PackAsync(Packer source, T value, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task PackAsync(Packer source, T value, SerializationContext context);
    [ExtensionAttribute]
public static Task PackAsync(Packer source, T value, SerializationContext context, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.PackerUnpackerExtensions/<PackAsyncCore>d__7`1")]
private static Task PackAsyncCore(Packer source, T value, SerializationContext context, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Packer PackArray(Packer source, IEnumerable`1<T> collection);
    [ExtensionAttribute]
public static Packer PackArray(Packer source, IEnumerable`1<T> collection, SerializationContext context);
    [ExtensionAttribute]
public static Packer PackCollection(Packer source, IEnumerable`1<T> collection);
    [ExtensionAttribute]
public static Packer PackCollection(Packer source, IEnumerable`1<T> collection, SerializationContext context);
    private static void PackCollectionCore(Packer source, IEnumerable`1<T> collection, SerializationContext context);
    internal static void PackCollectionCore(Packer source, IEnumerable`1<T> collection, MessagePackSerializer`1<T> itemSerializer);
    [ExtensionAttribute]
public static Task PackArrayAsync(Packer source, IEnumerable`1<T> collection);
    [ExtensionAttribute]
public static Task PackArrayAsync(Packer source, IEnumerable`1<T> collection, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task PackArrayAsync(Packer source, IEnumerable`1<T> collection, SerializationContext context);
    [ExtensionAttribute]
public static Task PackArrayAsync(Packer source, IEnumerable`1<T> collection, SerializationContext context, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task PackCollectionAsync(Packer source, IEnumerable`1<T> collection);
    [ExtensionAttribute]
public static Task PackCollectionAsync(Packer source, IEnumerable`1<T> collection, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task PackCollectionAsync(Packer source, IEnumerable`1<T> collection, SerializationContext context);
    [ExtensionAttribute]
public static Task PackCollectionAsync(Packer source, IEnumerable`1<T> collection, SerializationContext context, CancellationToken cancellationToken);
    private static Task PackCollectionAsyncCore(Packer source, IEnumerable`1<T> collection, SerializationContext context, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.PackerUnpackerExtensions/<PackCollectionAsyncCore>d__23`1")]
internal static Task PackCollectionAsyncCore(Packer source, IEnumerable`1<T> collection, MessagePackSerializer`1<T> itemSerializer, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Packer PackMap(Packer source, IDictionary`2<TKey, TValue> dictionary);
    [ExtensionAttribute]
public static Packer PackMap(Packer source, IDictionary`2<TKey, TValue> dictionary, SerializationContext context);
    [ExtensionAttribute]
public static Packer PackDictionary(Packer source, IDictionary`2<TKey, TValue> dictionary);
    [ExtensionAttribute]
public static Packer PackDictionary(Packer source, IDictionary`2<TKey, TValue> dictionary, SerializationContext context);
    private static void PackDictionaryCore(Packer source, IDictionary`2<TKey, TValue> dictionary, SerializationContext context);
    internal static void PackDictionaryCore(Packer source, IDictionary`2<TKey, TValue> dictionary, MessagePackSerializer`1<TKey> keySerializer, MessagePackSerializer`1<TValue> valueSerializer);
    [ExtensionAttribute]
public static Task PackMapAsync(Packer source, IDictionary`2<TKey, TValue> dictionary);
    [ExtensionAttribute]
public static Task PackMapAsync(Packer source, IDictionary`2<TKey, TValue> dictionary, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task PackMapAsync(Packer source, IDictionary`2<TKey, TValue> dictionary, SerializationContext context);
    [ExtensionAttribute]
public static Task PackMapAsync(Packer source, IDictionary`2<TKey, TValue> dictionary, SerializationContext context, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task PackDictionaryAsync(Packer source, IDictionary`2<TKey, TValue> dictionary);
    [ExtensionAttribute]
public static Task PackDictionaryAsync(Packer source, IDictionary`2<TKey, TValue> dictionary, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task PackDictionaryAsync(Packer source, IDictionary`2<TKey, TValue> dictionary, SerializationContext context);
    [ExtensionAttribute]
public static Task PackDictionaryAsync(Packer source, IDictionary`2<TKey, TValue> dictionary, SerializationContext context, CancellationToken cancellationToken);
    private static Task PackDictionaryAsyncCore(Packer source, IDictionary`2<TKey, TValue> dictionary, SerializationContext context, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.PackerUnpackerExtensions/<PackDictionaryAsyncCore>d__39`2")]
internal static Task PackDictionaryAsyncCore(Packer source, IDictionary`2<TKey, TValue> dictionary, MessagePackSerializer`1<TKey> keySerializer, MessagePackSerializer`1<TValue> valueSerializer, CancellationToken cancellationToken);
    [ExtensionAttribute]
[ObsoleteAttribute("Use PackArray<T>, PackCollection<T>, PackMap<TKey, TValue>, or PackDictionary<TKey, TValue> instead.")]
public static Packer Pack(Packer source, IEnumerable`1<T> items);
    [ExtensionAttribute]
[ObsoleteAttribute("Use PackArray<T>, PackCollection<T>, PackMap<TKey, TValue>, or PackDictionary<TKey, TValue> instead.")]
public static Packer Pack(Packer source, IEnumerable`1<T> items, SerializationContext context);
    [ExtensionAttribute]
public static Packer PackObject(Packer source, object value);
    [ExtensionAttribute]
public static Packer PackObject(Packer source, object value, SerializationContext context);
    private static void PackObjectCore(Packer source, object value, SerializationContext context);
    [ExtensionAttribute]
public static Task PackObjectAsync(Packer source, object value);
    [ExtensionAttribute]
public static Task PackObjectAsync(Packer source, object value, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task PackObjectAsync(Packer source, object value, SerializationContext context);
    [ExtensionAttribute]
public static Task PackObjectAsync(Packer source, object value, SerializationContext context, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.PackerUnpackerExtensions/<PackObjectAsyncCore>d__49")]
private static Task PackObjectAsyncCore(Packer source, object value, SerializationContext context, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static T Unpack(Unpacker source);
    [ExtensionAttribute]
public static T Unpack(Unpacker source, SerializationContext context);
    private static T UnpackCore(Unpacker source, SerializationContext context);
    [ExtensionAttribute]
public static Task`1<T> UnpackAsync(Unpacker source);
    [ExtensionAttribute]
public static Task`1<T> UnpackAsync(Unpacker source, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<T> UnpackAsync(Unpacker source, SerializationContext context);
    [ExtensionAttribute]
public static Task`1<T> UnpackAsync(Unpacker source, SerializationContext context, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.PackerUnpackerExtensions/<UnpackAsyncCore>d__57`1")]
private static Task`1<T> UnpackAsyncCore(Unpacker source, SerializationContext context, CancellationToken cancellationToken);
}
public class MsgPack.PackerUnpackerStreamOptions : object {
    private static HashSet`1<string> _knownMemoryOrBufferingStreams;
    internal static PackerUnpackerStreamOptions SingletonOwnsStream;
    internal static PackerUnpackerStreamOptions SingletonForAsync;
    internal static PackerUnpackerStreamOptions None;
    [CompilerGeneratedAttribute]
private bool <WithBuffering>k__BackingField;
    private int _bufferSize;
    [CompilerGeneratedAttribute]
private bool <OwnsStream>k__BackingField;
    public bool WithBuffering { get; public set; }
    public int BufferSize { get; public set; }
    public bool OwnsStream { get; public set; }
    private static PackerUnpackerStreamOptions();
    private static bool ShouldWrapStream(Stream stream);
    [CompilerGeneratedAttribute]
public bool get_WithBuffering();
    [CompilerGeneratedAttribute]
public void set_WithBuffering(bool value);
    public int get_BufferSize();
    public void set_BufferSize(int value);
    [CompilerGeneratedAttribute]
public bool get_OwnsStream();
    [CompilerGeneratedAttribute]
public void set_OwnsStream(bool value);
    internal Stream WrapStream(Stream stream);
}
public class MsgPack.PackingOptions : object {
    private Encoding _stringEncoding;
    public Encoding StringEncoding { get; public set; }
    public Encoding get_StringEncoding();
    public void set_StringEncoding(Encoding value);
}
internal class MsgPack.PreserveAttribute : Attribute {
    public bool AllMembers;
    public bool Conditional;
}
internal enum MsgPack.ReadValueResult : Enum {
    public int value__;
    public static ReadValueResult UInt8Type;
    public static ReadValueResult UInt16Type;
    public static ReadValueResult UInt32Type;
    public static ReadValueResult UInt64Type;
    public static ReadValueResult Int8Type;
    public static ReadValueResult Int16Type;
    public static ReadValueResult Int32Type;
    public static ReadValueResult Int64Type;
    public static ReadValueResult Real32Type;
    public static ReadValueResult Real64Type;
    public static ReadValueResult Bin8Type;
    public static ReadValueResult Bin16Type;
    public static ReadValueResult Bin32Type;
    public static ReadValueResult FixExtType;
    public static ReadValueResult Ext8Type;
    public static ReadValueResult Ext16Type;
    public static ReadValueResult Ext32Type;
    public static ReadValueResult FixArrayType;
    public static ReadValueResult Array16Type;
    public static ReadValueResult Array32Type;
    public static ReadValueResult FixMapType;
    public static ReadValueResult Map16Type;
    public static ReadValueResult Map32Type;
    public static ReadValueResult FixStrType;
    public static ReadValueResult Str8Type;
    public static ReadValueResult Str16Type;
    public static ReadValueResult Str32Type;
    public static ReadValueResult Nil;
    public static ReadValueResult False;
    public static ReadValueResult True;
    public static ReadValueResult InvalidCode;
    public static ReadValueResult EoF;
    public static ReadValueResult Unexpected;
    public static ReadValueResult NonScalarBitMask;
    public static ReadValueResult ArrayTypeMask;
    public static ReadValueResult MapTypeMask;
    public static ReadValueResult BinTypeMask;
    public static ReadValueResult RawTypeMask;
    public static ReadValueResult ExtTypeMask;
    public static ReadValueResult LengthOfLengthMask;
    public static ReadValueResult ValueOrLengthMask;
    public static ReadValueResult TypeCodeMask;
    public static ReadValueResult FlagsMask;
    public static ReadValueResult FlagsAndTypeCodeMask;
    public static ReadValueResult FlagsAndLengthOfLengthMask;
}
[ExtensionAttribute]
internal static class MsgPack.ReadValueResults : object {
    public static ReadValueResult[] EncodedTypes;
    public static Boolean[] HasConstantObject;
    public static MessagePackObject[] ContantObject;
    public static CollectionType[] CollectionType;
    private static ReadValueResults();
    [ExtensionAttribute]
public static byte ToByte(ReadValueResult source);
}
[ExtensionAttribute]
internal static class MsgPack.ReflectionAbstractions : object {
    public static char TypeDelimiter;
    public static Type[] EmptyTypes;
    private static ReflectionAbstractions();
    [ExtensionAttribute]
public static bool GetIsValueType(Type source);
    [ExtensionAttribute]
public static bool GetIsEnum(Type source);
    [ExtensionAttribute]
public static bool GetIsInterface(Type source);
    [ExtensionAttribute]
public static bool GetIsAbstract(Type source);
    [ExtensionAttribute]
public static bool GetIsGenericType(Type source);
    [ExtensionAttribute]
public static bool GetIsGenericTypeDefinition(Type source);
    [ExtensionAttribute]
public static Assembly GetAssembly(Type source);
    [ExtensionAttribute]
public static bool GetIsVisible(Type source);
    [ExtensionAttribute]
public static bool GetIsPublic(Type source);
    [ExtensionAttribute]
public static bool GetIsNestedPublic(Type source);
    [ExtensionAttribute]
public static Type GetBaseType(Type source);
    [ExtensionAttribute]
public static MethodBase GetDeclaringMethod(Type source);
    [ExtensionAttribute]
public static Type[] GetGenericTypeParameters(Type source);
    [ExtensionAttribute]
public static MethodInfo GetRuntimeMethod(Type source, string name);
    [ExtensionAttribute]
public static MethodInfo GetRuntimeMethod(Type source, string name, Type[] parameters);
    [ExtensionAttribute]
public static IEnumerable`1<MethodInfo> GetRuntimeMethods(Type source);
    [ExtensionAttribute]
public static PropertyInfo GetRuntimeProperty(Type source, string name);
    [ExtensionAttribute]
public static ConstructorInfo GetRuntimeConstructor(Type source, Type[] parameters);
    [ExtensionAttribute]
public static T GetCustomAttribute(MemberInfo source);
    [ExtensionAttribute]
public static Type GetAttributeType(CustomAttributeData source);
    [ExtensionAttribute]
public static string GetMemberName(CustomAttributeNamedArgument source);
    [ExtensionAttribute]
public static string GetCultureName(AssemblyName source);
    [ExtensionAttribute]
public static IList`1<CustomAttributeTypedArgument> GetConstructorArguments(CustomAttributeData source);
    [ExtensionAttribute]
public static IEnumerable`1<CustomAttributeNamedArgument> GetNamedArguments(CustomAttributeData source);
    [ExtensionAttribute]
public static CustomAttributeTypedArgument GetTypedValue(CustomAttributeNamedArgument source);
    [ExtensionAttribute]
public static bool GetHasDefaultValue(ParameterInfo source);
}
internal enum MsgPack.Serialization.AbstractSerializers.ActionType : Enum {
    public int value__;
    public static ActionType PackToArray;
    public static ActionType PackToMap;
    public static ActionType UnpackFromArray;
    public static ActionType UnpackFromMap;
    public static ActionType UnpackTo;
    public static ActionType IsNull;
}
internal class MsgPack.Serialization.AbstractSerializers.CachedDelegateInfo : ValueType {
    public bool IsThisInstance;
    public MethodDefinition TargetMethod;
    public FieldDefinition BackingField;
    public CachedDelegateInfo(bool isThisInstance, MethodDefinition targetMethod, FieldDefinition backingField);
}
internal class MsgPack.Serialization.AbstractSerializers.ConstructorDefinition : object {
    private ConstructorInfo _runtimeConstructor;
    public TypeDefinition DeclaringType;
    public TypeDefinition[] ParameterTypes;
    public ConstructorDefinition(TypeDefinition declaringType, TypeDefinition[] parameterTypes);
    public ConstructorDefinition(ConstructorInfo runtimeConstructor);
    public ConstructorDefinition(ConstructorInfo runtimeConstructor, IEnumerable`1<TypeDefinition> parameterTypes);
    public ConstructorInfo ResolveRuntimeConstructor();
    public virtual string ToString();
    public static ConstructorDefinition op_Implicit(ConstructorInfo constructor);
    [CompilerGeneratedAttribute]
private bool <ResolveRuntimeConstructor>b__1_0(ConstructorInfo c);
}
internal enum MsgPack.Serialization.AbstractSerializers.EnumSerializerMethod : Enum {
    public int value__;
    public static EnumSerializerMethod PackUnderlyingValueTo;
    public static EnumSerializerMethod UnpackFromUnderlyingValue;
}
internal class MsgPack.Serialization.AbstractSerializers.FieldDefinition : object {
    private FieldInfo _runtimeField;
    public TypeDefinition DeclaringType;
    public string FieldName;
    public TypeDefinition FieldType;
    public FieldDefinition(TypeDefinition declaringType, string fieldName, TypeDefinition fieldType);
    public FieldDefinition(FieldInfo runtimeField);
    public FieldInfo ResolveRuntimeField();
    public virtual string ToString();
    public static FieldDefinition op_Implicit(FieldInfo field);
}
internal static class MsgPack.Serialization.AbstractSerializers.FieldName : object {
    public static string PackOperationList;
    public static string PackOperationTable;
    public static string NullCheckersTable;
    public static string UnpackOperationList;
    public static string UnpackOperationTable;
    public static string UnpackTo;
    public static string MemberNames;
}
internal interface MsgPack.Serialization.AbstractSerializers.ICodeConstruct {
    public TypeDefinition ContextType { get; }
    public abstract virtual TypeDefinition get_ContextType();
}
internal interface MsgPack.Serialization.AbstractSerializers.ISerializerBuilder {
    public abstract virtual MessagePackSerializer BuildSerializerInstance(SerializationContext context, Type concreteType, PolymorphismSchema schema);
}
internal interface MsgPack.Serialization.AbstractSerializers.ISerializerCodeGenerationContext {
    public SerializationContext SerializationContext { get; }
    [SecuritySafeCriticalAttribute]
public abstract virtual IEnumerable`1<SerializerCodeGenerationResult> Generate();
    [SecuritySafeCriticalAttribute]
public abstract virtual SerializationContext get_SerializationContext();
}
internal interface MsgPack.Serialization.AbstractSerializers.ISerializerCodeGenerator {
    public abstract virtual void BuildSerializerCode(ISerializerCodeGenerationContext context, Type concreteType, PolymorphismSchema itemSchema);
}
internal class MsgPack.Serialization.AbstractSerializers.MethodDefinition : object {
    public string MethodName;
    private MethodInfo _runtimeMethod;
    private MethodInfo _resoolvedMethod;
    private TypeDefinition[] _genericArguments;
    public Type Interface;
    public TypeDefinition DeclaringType;
    public TypeDefinition ReturnType;
    public TypeDefinition[] ParameterTypes;
    public bool IsStatic;
    public MethodDefinition(string name, TypeDefinition[] genericArguments, TypeDefinition declaringType, bool isStatic, TypeDefinition returnType, TypeDefinition[] parameterTypes);
    public MethodDefinition(MethodInfo runtimeMethod);
    public MethodDefinition(MethodInfo runtimeMethod, Type interface);
    public MethodDefinition(MethodInfo runtimeMethod, Type interface, IEnumerable`1<TypeDefinition> parameterTypes);
    public MethodInfo TryGetRuntimeMethod();
    public MethodInfo ResolveRuntimeMethod();
    private MethodInfo ResolveRuntimeMethodCore(bool throws);
    public virtual string ToString();
    public static MethodDefinition op_Implicit(MethodInfo method);
    [CompilerGeneratedAttribute]
private bool <ResolveRuntimeMethodCore>b__7_1(MethodInfo m);
}
internal static class MsgPack.Serialization.AbstractSerializers.MethodName : object {
    public static string PackToCore;
    public static string UnpackFromCore;
    public static string UnpackToCore;
    public static string PackToAsyncCore;
    public static string UnpackFromAsyncCore;
    public static string UnpackToAsyncCore;
    public static string PackUnderlyingValueTo;
    public static string UnpackFromUnderlyingValue;
    public static string PackUnderlyingValueToAsync;
    public static string CreateInstance;
    public static string AddItem;
    public static string RestoreSchema;
    public static string PackMemberPlaceHolder;
    public static string UnpackMemberPlaceHolder;
    public static string CreateObjectFromContext;
    public static string UnpackCollectionItem;
    public static string AppendUnpackedItem;
    public static string PackToArray;
    public static string UnpackFromArray;
}
internal static class MsgPack.Serialization.AbstractSerializers.MethodNamePrefix : object {
    public static string PackValue;
    public static string UnpackValue;
    public static string UnpackFrom;
    public static string SetUnpackedValueOf;
}
internal abstract class MsgPack.Serialization.AbstractSerializers.SerializerBuilder`2 : object {
    private static TConstruct[] NoConstructs;
    private SerializerBuilderNilImplicationHandler<TContext, TConstruct> _nilImplicationHandler;
    [CompilerGeneratedAttribute]
private Type <TargetType>k__BackingField;
    [CompilerGeneratedAttribute]
private CollectionTraits <CollectionTraits>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <BaseClass>k__BackingField;
    protected internal Type TargetType { get; private set; }
    protected CollectionTraits CollectionTraits { get; private set; }
    protected Type BaseClass { get; private set; }
    protected SerializerBuilder`2(Type targetType, CollectionTraits collectionTraits);
    private static SerializerBuilder`2();
    private void BuildCollectionSerializer(TContext context, Type concreteType, PolymorphismSchema schema, SerializationTarget& targetInfo);
    private void DetermineSerializationStrategy(TContext context, Type concreteType, SerializationTarget& targetInfo, Boolean& isUnpackFromRequired, Boolean& isAddItemRequired);
    private TConstruct GetUnpackableCollectionInstantiation(TContext context);
    private void BuildCollectionAddItem(TContext context, CollectionTraits traits);
    private void BuildCollectionAddItemNotImplemented(TContext context);
    private void BuildCollectionUnpackFromCore(TContext context, Type concreteType, PolymorphismSchema schema, bool canDeserialize, bool isAsync);
    [IteratorStateMachineAttribute("MsgPack.Serialization.AbstractSerializers.SerializerBuilder`2/<EmitCollectionUnpackFromStatements>d__6")]
private IEnumerable`1<TConstruct> EmitCollectionUnpackFromStatements(TContext context, Type instanceType, PolymorphismSchema schema, bool isAsync);
    private TConstruct EmitGetItemsCountExpression(TContext context, TConstruct unpacker);
    private void BuildCollectionCreateInstance(TContext context, ConstructorInfo collectionConstructor, bool canDeserialize);
    private void BuildRestoreSchema(TContext context, PolymorphismSchema schema);
    protected internal TConstruct EmitUnpackToInitialization(TContext context);
    private TConstruct MakeDefaultParameterValueLiteral(TContext context, TConstruct targetVariable, Type literalType, object literal, bool hasDefault);
    private TConstruct MakeDecimalLiteral(TContext context, TConstruct targetVariable, decimal constant);
    protected abstract virtual TConstruct MakeNullLiteral(TContext context, TypeDefinition contextType);
    protected abstract virtual TConstruct MakeByteLiteral(TContext context, byte constant);
    protected abstract virtual TConstruct MakeSByteLiteral(TContext context, sbyte constant);
    protected abstract virtual TConstruct MakeInt16Literal(TContext context, short constant);
    protected abstract virtual TConstruct MakeUInt16Literal(TContext context, ushort constant);
    protected abstract virtual TConstruct MakeInt32Literal(TContext context, int constant);
    protected abstract virtual TConstruct MakeUInt32Literal(TContext context, UInt32 constant);
    protected abstract virtual TConstruct MakeInt64Literal(TContext context, long constant);
    protected abstract virtual TConstruct MakeUInt64Literal(TContext context, ulong constant);
    protected abstract virtual TConstruct MakeReal32Literal(TContext context, float constant);
    protected abstract virtual TConstruct MakeReal64Literal(TContext context, double constant);
    protected abstract virtual TConstruct MakeBooleanLiteral(TContext context, bool constant);
    protected abstract virtual TConstruct MakeCharLiteral(TContext context, char constant);
    protected abstract virtual TConstruct MakeStringLiteral(TContext context, string constant);
    protected abstract virtual TConstruct MakeEnumLiteral(TContext context, TypeDefinition type, object constant);
    protected abstract virtual TConstruct MakeDefaultLiteral(TContext context, TypeDefinition type);
    protected abstract virtual TConstruct EmitThisReferenceExpression(TContext context);
    protected abstract virtual TConstruct EmitBoxExpression(TContext context, TypeDefinition valueType, TConstruct value);
    protected abstract virtual TConstruct EmitUnboxAnyExpression(TContext context, TypeDefinition targetType, TConstruct value);
    private TConstruct BoxIfRequired(TContext context, TConstruct instance);
    protected abstract virtual TConstruct EmitNotExpression(TContext context, TConstruct booleanExpression);
    protected abstract virtual TConstruct EmitEqualsExpression(TContext context, TConstruct left, TConstruct right);
    protected virtual TConstruct EmitNotEqualsExpression(TContext context, TConstruct left, TConstruct right);
    protected abstract virtual TConstruct EmitGreaterThanExpression(TContext context, TConstruct left, TConstruct right);
    protected abstract virtual TConstruct EmitLessThanExpression(TContext context, TConstruct left, TConstruct right);
    protected abstract virtual TConstruct EmitIncrement(TContext context, TConstruct int32Value);
    protected abstract virtual TConstruct EmitTypeOfExpression(TContext context, TypeDefinition type);
    protected abstract virtual TConstruct EmitMethodOfExpression(TContext context, MethodBase method);
    protected abstract virtual TConstruct EmitFieldOfExpression(TContext context, FieldInfo field);
    protected abstract virtual TConstruct EmitThrowStatement(TContext context, TConstruct exception);
    protected TConstruct EmitSequentialStatements(TContext context, TypeDefinition contextType, TConstruct[] statements);
    protected abstract virtual TConstruct EmitSequentialStatements(TContext context, TypeDefinition contextType, IEnumerable`1<TConstruct> statements);
    protected abstract virtual TConstruct ReferArgument(TContext context, TypeDefinition type, string name, int index);
    protected abstract virtual TConstruct DeclareLocal(TContext context, TypeDefinition type, string name);
    protected abstract virtual TConstruct EmitLoadVariableExpression(TContext context, TConstruct variable);
    protected abstract virtual TConstruct EmitStoreVariableStatement(TContext context, TConstruct variable, TConstruct value);
    protected abstract virtual TConstruct EmitMakeRef(TContext context, TConstruct target);
    protected abstract virtual TConstruct EmitCreateNewObjectExpression(TContext context, TConstruct variable, ConstructorDefinition constructor, TConstruct[] arguments);
    protected abstract virtual TConstruct EmitCreateNewArrayExpression(TContext context, TypeDefinition elementType, int length);
    protected abstract virtual TConstruct EmitCreateNewArrayExpression(TContext context, TypeDefinition elementType, int length, IEnumerable`1<TConstruct> initialElements);
    protected abstract virtual TConstruct EmitGetArrayElementExpression(TContext context, TConstruct array, TConstruct index);
    protected abstract virtual TConstruct EmitSetArrayElementStatement(TContext context, TConstruct array, TConstruct index, TConstruct value);
    protected abstract virtual TConstruct EmitConditionalExpression(TContext context, TConstruct conditionExpression, TConstruct thenExpression, TConstruct elseExpression);
    protected abstract virtual TConstruct EmitAndConditionalExpression(TContext context, IList`1<TConstruct> conditionExpressions, TConstruct thenExpression, TConstruct elseExpression);
    protected virtual TConstruct EmitRetrunStatement(TContext context, TConstruct expression);
    protected abstract virtual TConstruct EmitTryFinally(TContext context, TConstruct tryStatement, TConstruct finallyStatement);
    protected abstract virtual TConstruct EmitForEachLoop(TContext context, CollectionTraits collectionTraits, TConstruct collection, Func`2<TConstruct, TConstruct> loopBodyEmitter);
    protected abstract virtual TConstruct EmitInvokeVoidMethod(TContext context, TConstruct instance, MethodDefinition method, TConstruct[] arguments);
    protected TConstruct EmitInvokeMethodExpression(TContext context, TConstruct instance, MethodDefinition method, TConstruct[] arguments);
    protected abstract virtual TConstruct EmitInvokeMethodExpression(TContext context, TConstruct instance, MethodDefinition method, IEnumerable`1<TConstruct> arguments);
    protected abstract virtual TConstruct EmitInvokeDelegateExpression(TContext context, TypeDefinition delegateReturnType, TConstruct delegate, TConstruct[] arguments);
    private TConstruct ExtractPrivateMethod(TContext context, string name, bool isStatic, TypeDefinition returnType, Func`1<TConstruct> bodyFactory, TConstruct[] parameters);
    private static MethodDefinition DefinePrivateMethod(TContext context, string name, bool isStatic, TypeDefinition returnType, Func`1<TConstruct> bodyFactory, TConstruct[] parameters);
    protected virtual TConstruct EmitGetPrivateMethodDelegateExpression(TContext context, MethodDefinition method);
    protected abstract virtual TConstruct EmitNewPrivateMethodDelegateExpression(TContext context, MethodDefinition method);
    protected virtual TConstruct EmitGetStaticDelegateExpression(TContext context, MethodDefinition method);
    private TConstruct EmitGetMemberValueExpression(TContext context, TConstruct instance, MemberInfo member);
    private TConstruct EmitGetProperty(TContext context, TConstruct instance, PropertyInfo property, bool withReflection);
    protected abstract virtual TConstruct EmitGetPropertyExpression(TContext context, TConstruct instance, PropertyInfo property);
    private TConstruct EmitGetField(TContext context, TConstruct instance, FieldDefinition field, bool withReflection);
    protected abstract virtual TConstruct EmitGetFieldExpression(TContext context, TConstruct instance, FieldDefinition field);
    private TConstruct EmitSetMemberValueStatement(TContext context, TConstruct instance, MemberInfo member, TConstruct value);
    private TConstruct EmitStoreCollectionItemsEmitSetCollectionMemberIfNullAndSettable(TContext context, TConstruct instance, TConstruct collection, TConstruct existent, TypeDefinition collectionType, FieldInfo asField, PropertyInfo asProperty, TConstruct storeCollectionItems);
    private TConstruct EmitSetProperty(TContext context, TConstruct instance, PropertyInfo property, TConstruct value, bool withReflection);
    protected abstract virtual TConstruct EmitSetProperty(TContext context, TConstruct instance, PropertyInfo property, TConstruct value);
    protected abstract virtual TConstruct EmitSetIndexedProperty(TContext context, TConstruct instance, TypeDefinition declaringType, string proeprtyName, TConstruct key, TConstruct value);
    private TConstruct EmitSetField(TContext context, TConstruct instance, FieldDefinition field, TConstruct value, bool withReflection);
    private TConstruct EmitSetFieldOnReferenceType(TContext context, TConstruct instance, FieldDefinition field, TConstruct value);
    private TConstruct EmitSetFieldOnValueType(TContext context, TConstruct instance, FieldDefinition field, TConstruct value);
    protected abstract virtual TConstruct EmitSetField(TContext context, TConstruct instance, FieldDefinition field, TConstruct value);
    protected abstract virtual TConstruct EmitSetField(TContext context, TConstruct instance, TypeDefinition nestedType, string fieldName, TConstruct value);
    [IteratorStateMachineAttribute("MsgPack.Serialization.AbstractSerializers.SerializerBuilder`2/<EmitPackItemStatements>d__85")]
private IEnumerable`1<TConstruct> EmitPackItemStatements(TContext context, TConstruct packer, Type itemType, NilImplication nilImplication, string memberName, TConstruct item, Nullable`1<SerializingMember> memberInfo, PolymorphismSchema itemsSchema, bool isAsync);
    private TConstruct EmitSerializeItemExpressionCore(TContext context, TConstruct packer, Type itemType, TConstruct item, Nullable`1<SerializingMember> memberInfo, PolymorphismSchema itemsSchema, bool isAsync);
    private TConstruct EmitUnpackItemValueStatement(TContext context, Type memberType, TConstruct memberName, NilImplication nilImplication, Nullable`1<SerializingMember> memberInfo, PolymorphismSchema itemsSchema, TConstruct unpacker, TConstruct unpackingContext, TConstruct indexOfItem, TConstruct countOfItem, TConstruct setterDelegate, bool isAsync);
    private static Type DetermineUnpackHelperMethodParameterTypeDefinition(TypeKind<TContext, TConstruct> typeKind, bool isAsync);
    private TConstruct EmitAppendCollectionItem(TContext context, MemberInfo member, CollectionTraits traits, TConstruct collection, TConstruct unpackedItem);
    private TConstruct EmitAppendDictionaryItem(TContext context, CollectionTraits traits, TConstruct dictionary, Type keyType, TConstruct key, Type valueType, TConstruct value, bool withBoxing);
    private TConstruct EmitThrowCannotUnpackFrom(TContext context);
    private TConstruct EmitThrowCannotCreateInstance(TContext context);
    private TConstruct EmitInvariantStringFormat(TContext context, string format, TConstruct[] arguments);
    protected virtual TConstruct EmitGetSerializerExpression(TContext context, Type targetType, Nullable`1<SerializingMember> memberInfo, PolymorphismSchema itemsSchema);
    private static void GetDictionaryKeyValueType(Type elementType, Type& keyType, Type& valueType);
    private ConstructorInfo GetDefaultConstructor(Type instanceType);
    [IteratorStateMachineAttribute("MsgPack.Serialization.AbstractSerializers.SerializerBuilder`2/<CreatePackUnpackHelperArgumentInitialization>d__97")]
private IEnumerable`1<TConstruct> CreatePackUnpackHelperArgumentInitialization(TContext context, TConstruct helperArguments, IDictionary`2<string, TConstruct> arguments);
    private TConstruct[] DetermineCollectionConstructorArguments(TContext context, ConstructorInfo constructor);
    private TConstruct GetConstructorArgument(TContext context, ParameterInfo parameter);
    private TConstruct EmitGetEqualityComparer(TContext context);
    [IteratorStateMachineAttribute("MsgPack.Serialization.AbstractSerializers.SerializerBuilder`2/<EmitConstructPolymorphismSchema>d__101")]
protected IEnumerable`1<TConstruct> EmitConstructPolymorphismSchema(TContext context, TConstruct storage, PolymorphismSchema schema);
    [IteratorStateMachineAttribute("MsgPack.Serialization.AbstractSerializers.SerializerBuilder`2/<EmitConstructLeafPolymorphismSchema>d__102")]
private IEnumerable`1<TConstruct> EmitConstructLeafPolymorphismSchema(TContext context, TConstruct storage, PolymorphismSchema currentSchema, string prefix);
    [IteratorStateMachineAttribute("MsgPack.Serialization.AbstractSerializers.SerializerBuilder`2/<EmitConstructTypeCodeMappingForPolymorphismSchema>d__103")]
private IEnumerable`1<TConstruct> EmitConstructTypeCodeMappingForPolymorphismSchema(TContext context, PolymorphismSchema currentSchema, TConstruct typeMap);
    private TConstruct EmitCheckIsArrayHeaderExpression(TContext context, TConstruct unpacker);
    private TConstruct EmitCheckIsMapHeaderExpression(TContext context, TConstruct unpacker);
    private static string AdjustName(string methodName, bool isAsync);
    protected virtual bool WithAsync(TContext context);
    private TConstruct ReferCancellationToken(TContext context, int index);
    [CompilerGeneratedAttribute]
protected internal Type get_TargetType();
    [CompilerGeneratedAttribute]
private void set_TargetType(Type value);
    [CompilerGeneratedAttribute]
protected CollectionTraits get_CollectionTraits();
    [CompilerGeneratedAttribute]
private void set_CollectionTraits(CollectionTraits value);
    [CompilerGeneratedAttribute]
protected Type get_BaseClass();
    [CompilerGeneratedAttribute]
private void set_BaseClass(Type value);
    private static Type DetermineBaseClass(Type targetType, CollectionTraits traits);
    public sealed virtual MessagePackSerializer BuildSerializerInstance(SerializationContext context, Type concreteType, PolymorphismSchema schema);
    protected abstract virtual TContext CreateCodeGenerationContextForSerializerCreation(SerializationContext context);
    protected void BuildSerializer(TContext context, Type concreteType, PolymorphismSchema schema, SerializationTarget& targetInfo);
    protected abstract virtual Func`2<SerializationContext, MessagePackSerializer> CreateSerializerConstructor(TContext codeGenerationContext, SerializationTarget targetInfo, PolymorphismSchema schema, Nullable`1<SerializerCapabilities> capabilities);
    protected abstract virtual Func`2<SerializationContext, MessagePackSerializer> CreateEnumSerializerConstructor(TContext codeGenerationContext);
    public sealed virtual void BuildSerializerCode(ISerializerCodeGenerationContext context, Type concreteType, PolymorphismSchema itemSchema);
    protected virtual void BuildSerializerCodeCore(ISerializerCodeGenerationContext context, Type concreteType, PolymorphismSchema itemSchema);
    protected void BuildEnumSerializer(TContext context);
    private void BuildPackUnderlyingValueTo(TContext context, Type underlyingType, bool isAsync);
    private void BuildUnpackFromUnderlyingValue(TContext context, Type underlyingType);
    protected abstract virtual TConstruct EmitEnumToUnderlyingCastExpression(TContext context, Type underlyingType, TConstruct enumValue);
    protected abstract virtual TConstruct EmitEnumFromUnderlyingCastExpression(TContext context, Type enumType, TConstruct underlyingValue);
    private void BuildNullableSerializer(TContext context, Type underlyingType);
    private void BuildNullablePackTo(TContext context, Type underlyingType, bool isAsync);
    private void BuildNullableUnpackFrom(TContext context, Type underlyingType, bool isAsync);
    private SerializationTarget BuildObjectSerializer(TContext context);
    private void BuildIPackablePackTo(TContext context);
    private void BuildIAsyncPackablePackTo(TContext context);
    private TConstruct BuildIPackablePackToCore(TContext context, Type interface);
    private void BuildObjectPackTo(TContext context, SerializationTarget targetInfo, bool isAsync);
    [IteratorStateMachineAttribute("MsgPack.Serialization.AbstractSerializers.SerializerBuilder`2/<BuildObjectPackToCore>d__149")]
private IEnumerable`1<TConstruct> BuildObjectPackToCore(TContext context, IList`1<SerializingMember> entries, bool isAsync);
    [IteratorStateMachineAttribute("MsgPack.Serialization.AbstractSerializers.SerializerBuilder`2/<EmitHasValueCore>d__150")]
private IEnumerable`1<TConstruct> EmitHasValueCore(TContext context, TConstruct nullCheckTarget, Type itemType);
    protected internal TConstruct EmitPackOperationListInitialization(TContext context, SerializationTarget targetInfo, bool isAsync);
    protected internal TConstruct EmitPackOperationTableInitialization(TContext context, SerializationTarget targetInfo, bool isAsync);
    protected virtual TypeDefinition GetPackOperationType(TContext context, bool isAsync);
    [IteratorStateMachineAttribute("MsgPack.Serialization.AbstractSerializers.SerializerBuilder`2/<EmitPackActionCollectionCore>d__154")]
private IEnumerable`1<TConstruct> EmitPackActionCollectionCore(TContext context, SerializationTarget targetInfo, TypeDefinition actionType, TConstruct actionCollection, SerializationMethod method, bool isAsync);
    protected internal TConstruct EmitPackNullCheckerTableInitialization(TContext context, SerializationTarget targetInfo);
    [IteratorStateMachineAttribute("MsgPack.Serialization.AbstractSerializers.SerializerBuilder`2/<EmitPackNullCheckerTableInitializationCore>d__156")]
private IEnumerable`1<TConstruct> EmitPackNullCheckerTableInitializationCore(TContext context, SerializationTarget targetInfo, TConstruct actionCollection);
    private static string GetPackValueMethodName(SerializingMember member, bool isAsync);
    private static string GetCheckNullMethodName(SerializingMember member);
    private void BuildIUnpackableUnpackFrom(TContext context, TConstruct objectCreation, bool canDeserialize);
    private TConstruct GetUnpackableObjectInstantiation(TContext context);
    private void BuildIAsyncUnpackableUnpackFrom(TContext context, TConstruct objectCreation, bool canDeserialize);
    [IteratorStateMachineAttribute("MsgPack.Serialization.AbstractSerializers.SerializerBuilder`2/<BuildIUnpackableUnpackFromCore>d__162")]
private IEnumerable`1<TConstruct> BuildIUnpackableUnpackFromCore(TContext context, Type interface, TConstruct objectCreation);
    private void BuildObjectUnpackFrom(TContext context, SerializationTarget targetInfo, bool isAsync);
    [IteratorStateMachineAttribute("MsgPack.Serialization.AbstractSerializers.SerializerBuilder`2/<EmitObjectUnpackFromCore>d__164")]
private IEnumerable`1<TConstruct> EmitObjectUnpackFromCore(TContext context, SerializationTarget targetInfo, bool isAsync);
    private TConstruct EmitObjectUnpackFromCore(TContext context, SerializationTarget targetInfo, UnpackingContextInfo<TContext, TConstruct> unpackingContext, SerializationMethod method, bool isAsync);
    private UnpackingContextInfo<TContext, TConstruct> EmitObjectUnpackingContextInitialization(TContext context, SerializationTarget targetInfo);
    private UnpackingContextInfo<TContext, TConstruct> EmitObjectUnpackingContextInitialization(TContext context, KeyValuePair`2[] contextFields, IList`1<TConstruct> constructorArguments, HashSet`1<string> mappableConstructorArguments, IEnumerable`1<TConstruct> argumentInitializers);
    [IteratorStateMachineAttribute("MsgPack.Serialization.AbstractSerializers.SerializerBuilder`2/<EmitCreateObjectFromContextCore>d__168")]
private IEnumerable`1<TConstruct> EmitCreateObjectFromContextCore(TContext context, SerializationTarget targetInfo, UnpackingContextInfo<TContext, TConstruct> unpackingContext, KeyValuePair`2[] fields);
    private MethodDefinition GetCreateObjectFromContextMethod(UnpackingContextInfo<TContext, TConstruct> unpackingContext);
    protected internal TConstruct EmitUnpackOperationListInitialization(TContext context, SerializationTarget targetInfo, bool isAsync);
    protected internal TConstruct EmitUnpackOperationTableInitialization(TContext context, SerializationTarget targetInfo, bool isAsync);
    protected virtual TypeDefinition GetUnpackOperationType(TContext context, bool isAsync);
    private static string GetUnpackValueMethodName(SerializingMember member, bool isAsync);
    [IteratorStateMachineAttribute("MsgPack.Serialization.AbstractSerializers.SerializerBuilder`2/<EmitUnpackActionCollectionInitializationCore>d__174")]
private IEnumerable`1<TConstruct> EmitUnpackActionCollectionInitializationCore(TContext context, SerializationTarget targetInfo, TypeDefinition actionType, TConstruct actionCollection, SerializationMethod method, bool isAsync);
    [IteratorStateMachineAttribute("MsgPack.Serialization.AbstractSerializers.SerializerBuilder`2/<InitializeConstructorArgumentInitializationStatements>d__175")]
private IEnumerable`1<TConstruct> InitializeConstructorArgumentInitializationStatements(TContext context, SerializationTarget target, ParameterInfo[] constructorParameters, List`1<TConstruct> constructorArguments, HashSet`1<string> mappableConstructorArguments);
    [IteratorStateMachineAttribute("MsgPack.Serialization.AbstractSerializers.SerializerBuilder`2/<InitializeConstructorArgumentInitializationStatements>d__176")]
private IEnumerable`1<TConstruct> InitializeConstructorArgumentInitializationStatements(TContext context, KeyValuePair`2[] contextFields, List`1<TConstruct> constructorArguments);
    private TConstruct EmitInvokeDeserializationConstructorStatement(TContext context, ConstructorInfo constructor, TConstruct unpackingContext, IList`1<KeyValuePair`2<string, TypeDefinition>> fields);
    [IteratorStateMachineAttribute("MsgPack.Serialization.AbstractSerializers.SerializerBuilder`2/<EmitInvokeDeserializationConstructorStatementsCore>d__178")]
private IEnumerable`1<TConstruct> EmitInvokeDeserializationConstructorStatementsCore(TContext context, ConstructorInfo constructor, TConstruct unpackingContext, IList`1<KeyValuePair`2<string, TypeDefinition>> fields);
    protected internal TConstruct EmitMemberListInitialization(TContext context, SerializationTarget targetInfo);
    protected abstract virtual TConstruct EmitGetMemberNamesExpression(TContext context);
    protected abstract virtual TConstruct EmitGetActionsExpression(TContext context, ActionType actionType, bool isAsync);
    protected abstract virtual TConstruct EmitFinishFieldInitializationStatement(TContext context, string name, TConstruct value);
    private TConstruct EmitNewPrivateMethodDelegateExpressionWithCreation(TContext context, MethodDefinition method, Func`1<TConstruct> bodyFactory, TConstruct[] privateMethodParameters);
    private static KeyValuePair`2[] GetKnownActions(TContext context, SerializationTarget targetInfo, SerializationMethod method, Func`3<SerializingMember, bool, string> nameFactory, bool isAsync);
    private static KeyValuePair`2[] GetDeclaredKnownActions(TContext context, SerializationTarget targetInfo, Func`2<SerializingMember, string> nameFactory);
    private void BuildTupleSerializer(TContext context, IList`1<PolymorphismSchema> itemSchemaList, SerializationTarget& targetInfo);
    private void BuildTuplePackTo(TContext context, IList`1<Type> itemTypes, IList`1<PolymorphismSchema> itemSchemaList, bool isValueTuple, bool isAsync);
    private IEnumerable`1<TConstruct> BuildTuplePackToCore(TContext context, IList`1<Type> itemTypes, IList`1<PolymorphismSchema> itemSchemaList, bool isValueTuple, bool isAsync);
    [IteratorStateMachineAttribute("MsgPack.Serialization.AbstractSerializers.SerializerBuilder`2/<BuildTuplePackToCore>d__189`1")]
private IEnumerable`1<TConstruct> BuildTuplePackToCore(TContext context, IList`1<Type> itemTypes, IList`1<PolymorphismSchema> itemSchemaList, Func`3<Type, string, TInfo> memberFactory, Func`4<TContext, TConstruct, TInfo, TConstruct> chainConstructFactory, bool isAsync);
    private IEnumerable`1<TConstruct> EmitPackTupleItemStatements(TContext context, Type itemType, TConstruct currentPacker, TConstruct tuple, IEnumerable`1<TInfo> memberInvocationChain, PolymorphismSchema itemsSchema, Func`4<TContext, TConstruct, TInfo, TConstruct> chainConstructFactory, bool isAsync);
    private void BuildTupleUnpackFrom(TContext context, IList`1<Type> itemTypes, IList`1<PolymorphismSchema> itemSchemaList, bool isValueTuple, bool isAsync);
    private IEnumerable`1<TConstruct> BuildTupleUnpackFromCore(TContext context, IList`1<Type> itemTypes, IList`1<PolymorphismSchema> itemSchemaList, bool isValueTuple, bool isAsync);
    [IteratorStateMachineAttribute("MsgPack.Serialization.AbstractSerializers.SerializerBuilder`2/<BuildTupleUnpackFromCore>d__193`1")]
private IEnumerable`1<TConstruct> BuildTupleUnpackFromCore(TContext context, IList`1<Type> itemTypes, IList`1<PolymorphismSchema> itemSchemaList, Func`3<Type, string, TInfo> memberFactory, bool isAsync);
    private UnpackingContextInfo<TContext, TConstruct> GetTupleUnpackingContextInfo(TContext context, IList`1<Type> itemTypes);
    private TConstruct EmitCheckTupleCardinarityExpression(TContext context, TConstruct unpacker, int cardinarity);
    [CompilerGeneratedAttribute]
private TConstruct <BuildTuplePackToCore>b__188_1(TContext c, TConstruct s, FieldInfo m);
    [CompilerGeneratedAttribute]
private TConstruct <BuildTuplePackToCore>b__188_3(TContext c, TConstruct s, PropertyInfo m);
}
internal static class MsgPack.Serialization.AbstractSerializers.SerializerBuilderHelper : object {
    public static KeyValuePair`2[] EmptyParameters;
    public static Type[] UnpackFromAsyncParameterTypes;
    public static string UnpackingContextTypeName;
    private static SerializerBuilderHelper();
    internal static Type GetResolvedDelegateType(TypeDefinition returnType, TypeDefinition[] parameterTypes);
    internal static TypeDefinition GetDelegateTypeDefinition(TypeDefinition returnType, TypeDefinition[] parameterTypes);
    public static Type FindDelegateType(TypeDefinition returnType, TypeDefinition[] parameterTypes);
}
internal class MsgPack.Serialization.AbstractSerializers.SerializerFieldKey : object {
    public RuntimeTypeHandle TypeHandle;
    public EnumMemberSerializationMethod EnumSerializationMethod;
    public DateTimeMemberConversionMethod DateTimeConversionMethod;
    private ComparablePolymorphismSchema _schema;
    public PolymorphismSchema PolymorphismSchema { get; }
    public SerializerFieldKey(Type targetType, EnumMemberSerializationMethod enumMemberSerializationMethod, DateTimeMemberConversionMethod dateTimeConversionMethod, PolymorphismSchema polymorphismSchema);
    public PolymorphismSchema get_PolymorphismSchema();
    public sealed virtual bool Equals(SerializerFieldKey other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal abstract class MsgPack.Serialization.AbstractSerializers.SerializerGenerationContext`1 : object {
    [CompilerGeneratedAttribute]
private SerializationContext <SerializationContext>k__BackingField;
    [CompilerGeneratedAttribute]
private TConstruct <Packer>k__BackingField;
    [CompilerGeneratedAttribute]
private TConstruct <PackToTarget>k__BackingField;
    [CompilerGeneratedAttribute]
private TConstruct <NullCheckTarget>k__BackingField;
    [CompilerGeneratedAttribute]
private TConstruct <Unpacker>k__BackingField;
    [CompilerGeneratedAttribute]
private TConstruct <UnpackToTarget>k__BackingField;
    [CompilerGeneratedAttribute]
private TConstruct <CollectionToBeAdded>k__BackingField;
    [CompilerGeneratedAttribute]
private TConstruct <ItemToAdd>k__BackingField;
    [CompilerGeneratedAttribute]
private TConstruct <KeyToAdd>k__BackingField;
    [CompilerGeneratedAttribute]
private TConstruct <ValueToAdd>k__BackingField;
    [CompilerGeneratedAttribute]
private TConstruct <InitialCapacity>k__BackingField;
    [CompilerGeneratedAttribute]
private TConstruct <UnpackingContextInUnpackValueMethods>k__BackingField;
    [CompilerGeneratedAttribute]
private TConstruct <UnpackingContextInSetValueMethods>k__BackingField;
    [CompilerGeneratedAttribute]
private TConstruct <UnpackingContextInCreateObjectFromContext>k__BackingField;
    [CompilerGeneratedAttribute]
private TConstruct <IndexOfItem>k__BackingField;
    [CompilerGeneratedAttribute]
private TConstruct <ItemsCount>k__BackingField;
    [CompilerGeneratedAttribute]
private NilImplication <CollectionItemNilImplication>k__BackingField;
    [CompilerGeneratedAttribute]
private NilImplication <DictionaryKeyNilImplication>k__BackingField;
    [CompilerGeneratedAttribute]
private NilImplication <TupleItemNilImplication>k__BackingField;
    private IDictionary`2<string, MethodDefinition> _declaredMethods;
    private IDictionary`2<string, FieldDefinition> _declaredFields;
    private IDictionary`2<string, CachedDelegateInfo> _cachedDelegateInfos;
    private KeyValuePair`2<TypeDefinition, ConstructorDefinition> _unpackingContextDefinition;
    [CompilerGeneratedAttribute]
private bool <IsUnpackToUsed>k__BackingField;
    public TConstruct Context { get; }
    public SerializationContext SerializationContext { get; private set; }
    public TConstruct Packer { get; protected set; }
    public TConstruct PackToTarget { get; protected set; }
    public TConstruct NullCheckTarget { get; protected set; }
    public TConstruct Unpacker { get; protected set; }
    public TConstruct UnpackToTarget { get; protected set; }
    public TConstruct CollectionToBeAdded { get; protected set; }
    public TConstruct ItemToAdd { get; protected set; }
    public TConstruct KeyToAdd { get; protected set; }
    public TConstruct ValueToAdd { get; protected set; }
    public TConstruct InitialCapacity { get; protected set; }
    public TConstruct UnpackingContextInUnpackValueMethods { get; private set; }
    public TConstruct UnpackingContextInSetValueMethods { get; private set; }
    public TConstruct UnpackingContextInCreateObjectFromContext { get; private set; }
    public TConstruct IndexOfItem { get; protected set; }
    public TConstruct ItemsCount { get; protected set; }
    public NilImplication CollectionItemNilImplication { get; private set; }
    public NilImplication DictionaryKeyNilImplication { get; private set; }
    public NilImplication TupleItemNilImplication { get; private set; }
    public TypeDefinition UnpackingContextType { get; }
    public bool IsUnpackToUsed { get; public set; }
    protected SerializerGenerationContext`1(SerializationContext context);
    public virtual TConstruct get_Context();
    [CompilerGeneratedAttribute]
public sealed virtual SerializationContext get_SerializationContext();
    [CompilerGeneratedAttribute]
private void set_SerializationContext(SerializationContext value);
    [CompilerGeneratedAttribute]
public TConstruct get_Packer();
    [CompilerGeneratedAttribute]
protected void set_Packer(TConstruct value);
    [CompilerGeneratedAttribute]
public TConstruct get_PackToTarget();
    [CompilerGeneratedAttribute]
protected void set_PackToTarget(TConstruct value);
    [CompilerGeneratedAttribute]
public TConstruct get_NullCheckTarget();
    [CompilerGeneratedAttribute]
protected void set_NullCheckTarget(TConstruct value);
    [CompilerGeneratedAttribute]
public TConstruct get_Unpacker();
    [CompilerGeneratedAttribute]
protected void set_Unpacker(TConstruct value);
    [CompilerGeneratedAttribute]
public TConstruct get_UnpackToTarget();
    [CompilerGeneratedAttribute]
protected void set_UnpackToTarget(TConstruct value);
    [CompilerGeneratedAttribute]
public TConstruct get_CollectionToBeAdded();
    [CompilerGeneratedAttribute]
protected void set_CollectionToBeAdded(TConstruct value);
    [CompilerGeneratedAttribute]
public TConstruct get_ItemToAdd();
    [CompilerGeneratedAttribute]
protected void set_ItemToAdd(TConstruct value);
    [CompilerGeneratedAttribute]
public TConstruct get_KeyToAdd();
    [CompilerGeneratedAttribute]
protected void set_KeyToAdd(TConstruct value);
    [CompilerGeneratedAttribute]
public TConstruct get_ValueToAdd();
    [CompilerGeneratedAttribute]
protected void set_ValueToAdd(TConstruct value);
    [CompilerGeneratedAttribute]
public TConstruct get_InitialCapacity();
    [CompilerGeneratedAttribute]
protected void set_InitialCapacity(TConstruct value);
    [CompilerGeneratedAttribute]
public TConstruct get_UnpackingContextInUnpackValueMethods();
    [CompilerGeneratedAttribute]
private void set_UnpackingContextInUnpackValueMethods(TConstruct value);
    [CompilerGeneratedAttribute]
public TConstruct get_UnpackingContextInSetValueMethods();
    [CompilerGeneratedAttribute]
private void set_UnpackingContextInSetValueMethods(TConstruct value);
    [CompilerGeneratedAttribute]
public TConstruct get_UnpackingContextInCreateObjectFromContext();
    [CompilerGeneratedAttribute]
private void set_UnpackingContextInCreateObjectFromContext(TConstruct value);
    [CompilerGeneratedAttribute]
public TConstruct get_IndexOfItem();
    [CompilerGeneratedAttribute]
protected void set_IndexOfItem(TConstruct value);
    [CompilerGeneratedAttribute]
public TConstruct get_ItemsCount();
    [CompilerGeneratedAttribute]
protected void set_ItemsCount(TConstruct value);
    [CompilerGeneratedAttribute]
public NilImplication get_CollectionItemNilImplication();
    [CompilerGeneratedAttribute]
private void set_CollectionItemNilImplication(NilImplication value);
    [CompilerGeneratedAttribute]
public NilImplication get_DictionaryKeyNilImplication();
    [CompilerGeneratedAttribute]
private void set_DictionaryKeyNilImplication(NilImplication value);
    [CompilerGeneratedAttribute]
public NilImplication get_TupleItemNilImplication();
    [CompilerGeneratedAttribute]
private void set_TupleItemNilImplication(NilImplication value);
    public MethodDefinition GetDeclaredMethod(string name);
    public MethodDefinition TryGetDeclaredMethod(string name);
    public bool IsDeclaredMethod(string name);
    public FieldDefinition GetDeclaredField(string name);
    public FieldDefinition GetCachedPrivateMethodDelegate(MethodDefinition method, TypeDefinition delegateType);
    public FieldDefinition GetCachedStaticMethodDelegate(MethodDefinition method, TypeDefinition delegateType);
    private FieldDefinition GetCachedDelegateCore(MethodDefinition method, TypeDefinition delegateType, string prefix, bool isThis);
    public IEnumerable`1<CachedDelegateInfo> GetCachedDelegateInfos();
    public TypeDefinition get_UnpackingContextType();
    [CompilerGeneratedAttribute]
public bool get_IsUnpackToUsed();
    [CompilerGeneratedAttribute]
public void set_IsUnpackToUsed(bool value);
    public void Reset(Type targetType, Type baseClass);
    protected abstract virtual void ResetCore(Type targetType, Type baseClass);
    public virtual string GetUniqueVariableName(string prefix);
    public abstract virtual void BeginMethodOverride(string name);
    public MethodDefinition EndMethodOverride(string name, TConstruct body);
    protected abstract virtual MethodDefinition EndMethodOverrideCore(string name, TConstruct body);
    public abstract virtual void BeginPrivateMethod(string name, bool isStatic, TypeDefinition returnType, TConstruct[] parameters);
    public MethodDefinition EndPrivateMethod(string name, TConstruct body);
    protected abstract virtual MethodDefinition EndPrivateMethodCore(string name, TConstruct body);
    public FieldDefinition DeclarePrivateField(string name, TypeDefinition type);
    protected abstract virtual FieldDefinition DeclarePrivateFieldCore(string name, TypeDefinition type);
    public void DefineUnpackingContext(KeyValuePair`2[] fields, TypeDefinition& type, ConstructorDefinition& constructor);
    protected abstract virtual void DefineUnpackingContextCore(IList`1<KeyValuePair`2<string, TypeDefinition>> fields, TypeDefinition& type, ConstructorDefinition& constructor, TConstruct& parameterInUnpackValueMethods, TConstruct& parameterInSetValueMethods, TConstruct& parameterInCreateObjectFromContext);
    public TypeDefinition DefineUnpackingContextWithResultObject();
    protected abstract virtual void DefineUnpackingContextWithResultObjectCore(TypeDefinition& type, TConstruct& parameterInUnpackValueMethods, TConstruct& parameterInSetValueMethods, TConstruct& parameterInCreateObjectFromContext);
    public abstract virtual TConstruct DefineUnpackedItemParameterInSetValueMethods(TypeDefinition itemType);
}
internal class MsgPack.Serialization.AbstractSerializers.SerializerSpecification : object {
    [CompilerGeneratedAttribute]
private Type <TargetType>k__BackingField;
    [CompilerGeneratedAttribute]
private CollectionTraits <TargetCollectionTraits>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SerializerTypeFullName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SerializerTypeName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SerializerTypeNamespace>k__BackingField;
    public Type TargetType { get; private set; }
    public CollectionTraits TargetCollectionTraits { get; private set; }
    public string SerializerTypeFullName { get; private set; }
    public string SerializerTypeName { get; private set; }
    public string SerializerTypeNamespace { get; private set; }
    public SerializerSpecification(Type targetType, CollectionTraits targetCollectionTraits, string serializerTypeName, string serializerTypeNamespace);
    [CompilerGeneratedAttribute]
public Type get_TargetType();
    [CompilerGeneratedAttribute]
private void set_TargetType(Type value);
    [CompilerGeneratedAttribute]
public CollectionTraits get_TargetCollectionTraits();
    [CompilerGeneratedAttribute]
private void set_TargetCollectionTraits(CollectionTraits value);
    [CompilerGeneratedAttribute]
public string get_SerializerTypeFullName();
    [CompilerGeneratedAttribute]
private void set_SerializerTypeFullName(string value);
    [CompilerGeneratedAttribute]
public string get_SerializerTypeName();
    [CompilerGeneratedAttribute]
private void set_SerializerTypeName(string value);
    [CompilerGeneratedAttribute]
public string get_SerializerTypeNamespace();
    [CompilerGeneratedAttribute]
private void set_SerializerTypeNamespace(string value);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(SerializerSpecification other);
    public virtual int GetHashCode();
    public static bool Equals(SerializerSpecification left, SerializerSpecification right);
    public static bool op_Equality(SerializerSpecification left, SerializerSpecification right);
    public static bool op_Inequality(SerializerSpecification left, SerializerSpecification right);
}
internal class MsgPack.Serialization.AbstractSerializers.TypeDefinition : object {
    private static TypeDefinition[] EmptyArray;
    public static TypeDefinition ObjectType;
    public static TypeDefinition ByteType;
    public static TypeDefinition SByteType;
    public static TypeDefinition Int16Type;
    public static TypeDefinition UInt16Type;
    public static TypeDefinition Int32Type;
    public static TypeDefinition UInt32Type;
    public static TypeDefinition Int64Type;
    public static TypeDefinition UInt64Type;
    public static TypeDefinition SingleType;
    public static TypeDefinition DoubleType;
    public static TypeDefinition BooleanType;
    public static TypeDefinition CharType;
    public static TypeDefinition StringType;
    public static TypeDefinition VoidType;
    public static TypeDefinition ObjectArrayType;
    public static TypeDefinition TypeType;
    public static TypeDefinition MethodBaseType;
    public static TypeDefinition FieldInfoType;
    public static TypeDefinition IListOfStringType;
    public static TypeDefinition DictionaryOfStringAndTypeType;
    public static TypeDefinition MessagePackObjectType;
    public static TypeDefinition PackerType;
    public static TypeDefinition UnpackerType;
    public static TypeDefinition PackHelpersType;
    public static TypeDefinition UnpackHelpersType;
    public static TypeDefinition NilImplicationType;
    public static TypeDefinition SerializationMethodType;
    public static TypeDefinition EnumSerializationMethodType;
    public static TypeDefinition EnumMemberSerializationMethodType;
    public static TypeDefinition DateTimeConversionMethodType;
    public static TypeDefinition DateTimeMemberConversionMethodType;
    public static TypeDefinition PackingOptionsType;
    public static TypeDefinition PolymorphismSchemaType;
    public static TypeDefinition PolymorphismSchemaArrayType;
    public static TypeDefinition CancellationTokenType;
    public static TypeDefinition TaskType;
    private Flags _flags;
    public string TypeName;
    private Type _runtimeType;
    private Type _resolvedType;
    public TypeDefinition[] GenericArguments;
    public TypeDefinition ElementType;
    public bool IsArray { get; }
    public bool IsValueType { get; }
    private TypeDefinition(Type runtimeType, string name, TypeDefinition elementType, Flags flags, TypeDefinition[] genericArguments);
    private static TypeDefinition();
    public bool get_IsArray();
    public bool get_IsValueType();
    public Type TryGetRuntimeType();
    public bool HasRuntimeTypeFully();
    public Type ResolveRuntimeType();
    private Type ResolveRuntimeType(bool throws);
    public static TypeDefinition Object(Type type);
    public static TypeDefinition Object(string name);
    public static TypeDefinition GenericValueType(Type definition, TypeDefinition[] arguments);
    public static TypeDefinition GenericReferenceType(Type definition, TypeDefinition[] arguments);
    private static TypeDefinition Generic(bool isValueType, Type definition, TypeDefinition[] arguments);
    public static TypeDefinition Array(TypeDefinition elementType);
    public static TypeDefinition ManagedReference(TypeDefinition elementType);
    public virtual string ToString();
    public static TypeDefinition op_Implicit(Type type);
}
internal class MsgPack.Serialization.CodeDomSerializers.CodeDomConstruct : object {
    private TypeDefinition _contextType;
    public TypeDefinition ContextType { get; }
    public bool IsArgument { get; }
    public bool IsExpression { get; }
    public bool IsStatement { get; }
    protected CodeDomConstruct(TypeDefinition contextType);
    public sealed virtual TypeDefinition get_ContextType();
    public virtual bool get_IsArgument();
    public virtual bool get_IsExpression();
    public virtual bool get_IsStatement();
    public virtual CodeParameterDeclarationExpression AsParameter();
    public virtual CodeArgumentReferenceExpression AsArgument();
    public virtual CodeExpression AsExpression();
    public virtual IEnumerable`1<CodeStatement> AsStatements();
    public virtual void AddStatements(CodeStatementCollection collection);
    public static ParameterCodeDomConstruct Parameter(TypeDefinition type, string name);
    public static StatementCodeDomConstruct Statement(CodeStatement[] statement);
    public static StatementCodeDomConstruct Statement(IEnumerable`1<CodeStatement> statements);
    public static ExpressionCodeDomConstruct Expression(TypeDefinition contextType, CodeExpression expression);
    public static CodeDomConstruct Variable(TypeDefinition type, string name);
}
internal class MsgPack.Serialization.CodeDomSerializers.CodeDomContext : SerializerGenerationContext`1<CodeDomConstruct> {
    public static CodeCatchClause[] EmptyCatches;
    public static string ConditionalExpressionHelperMethodName;
    public static string ConditionalExpressionHelperConditionParameterName;
    public static string ConditionalExpressionHelperWhenTrueParameterName;
    public static string ConditionalExpressionHelperWhenFalseParameterName;
    private Dictionary`2<SerializerFieldKey, string> _dependentSerializers;
    private Dictionary`2<RuntimeFieldHandle, CachedFieldInfo> _cachedTargetFields;
    private Dictionary`2<RuntimeMethodHandle, CachedMethodBase> _cachedPropertyAccessors;
    private Dictionary`2<Type, CodeTypeDeclaration> _declaringTypes;
    private SerializerCodeGenerationConfiguration _configuration;
    private Type _targetType;
    private CodeTypeDeclaration _buildingType;
    private Stack`1<MethodContext> _methodContextStack;
    [CompilerGeneratedAttribute]
private bool <IsConditionalExpressionUsed>k__BackingField;
    private bool IsDictionary { get; }
    public CodeTypeDeclaration DeclaringType { get; }
    public bool IsInternalToMsgPackLibrary { get; }
    public bool IsConditionalExpressionUsed { get; public set; }
    public CodeDomContext(SerializationContext context, SerializerCodeGenerationConfiguration configuration);
    private static CodeDomContext();
    private bool get_IsDictionary();
    public CodeTypeDeclaration get_DeclaringType();
    public string RegisterSerializer(Type targetType, EnumMemberSerializationMethod enumSerializationMethod, DateTimeMemberConversionMethod dateTimeConversionMethod, PolymorphismSchema polymorphismSchema);
    public Dictionary`2<SerializerFieldKey, string> GetDependentSerializers();
    public string RegisterCachedFieldInfo(FieldInfo field);
    protected virtual FieldDefinition DeclarePrivateFieldCore(string name, TypeDefinition type);
    public Dictionary`2<RuntimeFieldHandle, CachedFieldInfo> GetCachedFieldInfos();
    public string RegisterCachedMethodBase(MethodBase method);
    public Dictionary`2<RuntimeMethodHandle, CachedMethodBase> GetCachedMethodBases();
    public virtual string GetUniqueVariableName(string prefix);
    public bool get_IsInternalToMsgPackLibrary();
    [CompilerGeneratedAttribute]
public bool get_IsConditionalExpressionUsed();
    [CompilerGeneratedAttribute]
public void set_IsConditionalExpressionUsed(bool value);
    protected virtual void ResetCore(Type targetType, Type baseClass);
    public virtual void BeginMethodOverride(string name);
    public virtual void BeginPrivateMethod(string name, bool isStatic, TypeDefinition returnType, CodeDomConstruct[] parameters);
    protected virtual MethodDefinition EndMethodOverrideCore(string name, CodeDomConstruct body);
    private static CodeParameterDeclarationExpression CreateCancellationTokenParameter();
    protected virtual MethodDefinition EndPrivateMethodCore(string name, CodeDomConstruct body);
    public void BeginConstructor();
    public void EndConstructor();
    protected virtual void DefineUnpackingContextCore(IList`1<KeyValuePair`2<string, TypeDefinition>> fields, TypeDefinition& type, ConstructorDefinition& constructor, CodeDomConstruct& parameterInUnpackValueMethods, CodeDomConstruct& parameterInSetValueMethods, CodeDomConstruct& parameterInCreateObjectFromContext);
    protected virtual void DefineUnpackingContextWithResultObjectCore(TypeDefinition& type, CodeDomConstruct& parameterInUnpackValueMethods, CodeDomConstruct& parameterInSetValueMethods, CodeDomConstruct& parameterInCreateObjectFromContext);
    private static void DefineUnpackValueMethodArguments(TypeDefinition type, CodeDomConstruct& parameterInUnpackValueMethods, CodeDomConstruct& parameterInSetValueMethods, CodeDomConstruct& parameterInCreateObjectFromContext);
    public virtual CodeDomConstruct DefineUnpackedItemParameterInSetValueMethods(TypeDefinition itemType);
    [SecuritySafeCriticalAttribute]
public sealed virtual IEnumerable`1<SerializerCodeGenerationResult> Generate();
}
internal class MsgPack.Serialization.CodeDomSerializers.CodeDomSerializerBuilder : SerializerBuilder`2<CodeDomContext, CodeDomConstruct> {
    private static CodeTypeReference[] EmptyGenericArguments;
    public CodeDomSerializerBuilder(Type targetType, CollectionTraits collectionTraits);
    private static CodeDomSerializerBuilder();
    internal static CodeTypeReference ToCodeTypeReference(TypeDefinition type);
    private static string GetGenericTypeBaseName(TypeDefinition genericType);
    private static CodeTypeReferenceExpression ToCodeTypeReferenceExpression(TypeDefinition type);
    protected virtual CodeDomConstruct MakeNullLiteral(CodeDomContext context, TypeDefinition contextType);
    protected virtual CodeDomConstruct MakeByteLiteral(CodeDomContext context, byte constant);
    protected virtual CodeDomConstruct MakeSByteLiteral(CodeDomContext context, sbyte constant);
    protected virtual CodeDomConstruct MakeInt16Literal(CodeDomContext context, short constant);
    protected virtual CodeDomConstruct MakeUInt16Literal(CodeDomContext context, ushort constant);
    protected virtual CodeDomConstruct MakeInt32Literal(CodeDomContext context, int constant);
    protected virtual CodeDomConstruct MakeUInt32Literal(CodeDomContext context, UInt32 constant);
    protected virtual CodeDomConstruct MakeInt64Literal(CodeDomContext context, long constant);
    protected virtual CodeDomConstruct MakeUInt64Literal(CodeDomContext context, ulong constant);
    protected virtual CodeDomConstruct MakeReal32Literal(CodeDomContext context, float constant);
    protected virtual CodeDomConstruct MakeReal64Literal(CodeDomContext context, double constant);
    protected virtual CodeDomConstruct MakeBooleanLiteral(CodeDomContext context, bool constant);
    protected virtual CodeDomConstruct MakeCharLiteral(CodeDomContext context, char constant);
    protected virtual CodeDomConstruct MakeEnumLiteral(CodeDomContext context, TypeDefinition type, object constant);
    protected virtual CodeDomConstruct MakeDefaultLiteral(CodeDomContext context, TypeDefinition type);
    protected virtual CodeDomConstruct MakeStringLiteral(CodeDomContext context, string constant);
    protected virtual CodeDomConstruct EmitThisReferenceExpression(CodeDomContext context);
    protected virtual CodeDomConstruct EmitBoxExpression(CodeDomContext context, TypeDefinition valueType, CodeDomConstruct value);
    protected virtual CodeDomConstruct EmitUnboxAnyExpression(CodeDomContext context, TypeDefinition targetType, CodeDomConstruct value);
    protected virtual CodeDomConstruct EmitNotExpression(CodeDomContext context, CodeDomConstruct booleanExpression);
    protected virtual CodeDomConstruct EmitEqualsExpression(CodeDomContext context, CodeDomConstruct left, CodeDomConstruct right);
    protected virtual CodeDomConstruct EmitGreaterThanExpression(CodeDomContext context, CodeDomConstruct left, CodeDomConstruct right);
    protected virtual CodeDomConstruct EmitLessThanExpression(CodeDomContext context, CodeDomConstruct left, CodeDomConstruct right);
    protected virtual CodeDomConstruct EmitIncrement(CodeDomContext context, CodeDomConstruct int32Value);
    protected virtual CodeDomConstruct EmitTypeOfExpression(CodeDomContext context, TypeDefinition type);
    protected virtual CodeDomConstruct EmitFieldOfExpression(CodeDomContext context, FieldInfo field);
    protected virtual CodeDomConstruct EmitMethodOfExpression(CodeDomContext context, MethodBase method);
    protected virtual CodeDomConstruct EmitThrowStatement(CodeDomContext context, CodeDomConstruct exception);
    protected virtual CodeDomConstruct EmitSequentialStatements(CodeDomContext context, TypeDefinition contextType, IEnumerable`1<CodeDomConstruct> statements);
    protected virtual CodeDomConstruct DeclareLocal(CodeDomContext context, TypeDefinition nestedType, string name);
    protected virtual CodeDomConstruct ReferArgument(CodeDomContext context, TypeDefinition type, string name, int index);
    protected virtual CodeDomConstruct EmitCreateNewObjectExpression(CodeDomContext context, CodeDomConstruct variable, ConstructorDefinition constructor, CodeDomConstruct[] arguments);
    protected virtual CodeDomConstruct EmitMakeRef(CodeDomContext context, CodeDomConstruct target);
    protected virtual CodeDomConstruct EmitInvokeVoidMethod(CodeDomContext context, CodeDomConstruct instance, MethodDefinition method, CodeDomConstruct[] arguments);
    protected virtual CodeDomConstruct EmitInvokeMethodExpression(CodeDomContext context, CodeDomConstruct instance, MethodDefinition method, IEnumerable`1<CodeDomConstruct> arguments);
    private static CodeMethodInvokeExpression CreateMethodInvocation(MethodDefinition method, CodeDomConstruct instance, IEnumerable`1<CodeDomConstruct> arguments);
    protected virtual CodeDomConstruct EmitInvokeDelegateExpression(CodeDomContext context, TypeDefinition delegateReturnType, CodeDomConstruct delegate, CodeDomConstruct[] arguments);
    protected virtual CodeDomConstruct EmitGetPropertyExpression(CodeDomContext context, CodeDomConstruct instance, PropertyInfo property);
    protected virtual CodeDomConstruct EmitGetFieldExpression(CodeDomContext context, CodeDomConstruct instance, FieldDefinition field);
    protected virtual CodeDomConstruct EmitSetProperty(CodeDomContext context, CodeDomConstruct instance, PropertyInfo property, CodeDomConstruct value);
    protected virtual CodeDomConstruct EmitSetIndexedProperty(CodeDomContext context, CodeDomConstruct instance, TypeDefinition declaringType, string proeprtyName, CodeDomConstruct key, CodeDomConstruct value);
    protected virtual CodeDomConstruct EmitSetField(CodeDomContext context, CodeDomConstruct instance, FieldDefinition field, CodeDomConstruct value);
    protected virtual CodeDomConstruct EmitSetField(CodeDomContext context, CodeDomConstruct instance, TypeDefinition nestedType, string fieldName, CodeDomConstruct value);
    protected virtual CodeDomConstruct EmitLoadVariableExpression(CodeDomContext context, CodeDomConstruct variable);
    protected virtual CodeDomConstruct EmitStoreVariableStatement(CodeDomContext context, CodeDomConstruct variable, CodeDomConstruct value);
    protected virtual CodeDomConstruct EmitTryFinally(CodeDomContext context, CodeDomConstruct tryStatement, CodeDomConstruct finallyStatement);
    protected virtual CodeDomConstruct EmitCreateNewArrayExpression(CodeDomContext context, TypeDefinition elementType, int length);
    protected virtual CodeDomConstruct EmitCreateNewArrayExpression(CodeDomContext context, TypeDefinition elementType, int length, IEnumerable`1<CodeDomConstruct> initialElements);
    protected virtual CodeDomConstruct EmitGetArrayElementExpression(CodeDomContext context, CodeDomConstruct array, CodeDomConstruct index);
    protected virtual CodeDomConstruct EmitSetArrayElementStatement(CodeDomContext context, CodeDomConstruct array, CodeDomConstruct index, CodeDomConstruct value);
    protected virtual CodeDomConstruct EmitGetSerializerExpression(CodeDomContext context, Type targetType, Nullable`1<SerializingMember> memberInfo, PolymorphismSchema itemsSchema);
    protected virtual CodeDomConstruct EmitGetActionsExpression(CodeDomContext context, ActionType actionType, bool isAsync);
    protected virtual CodeDomConstruct EmitGetMemberNamesExpression(CodeDomContext context);
    protected virtual CodeDomConstruct EmitFinishFieldInitializationStatement(CodeDomContext context, string name, CodeDomConstruct value);
    protected virtual CodeDomConstruct EmitConditionalExpression(CodeDomContext context, CodeDomConstruct conditionExpression, CodeDomConstruct thenExpression, CodeDomConstruct elseExpression);
    private static CodeDomConstruct CreateConditionalExpression(CodeDomContext context, CodeDomConstruct conditionExpression, CodeDomConstruct thenExpression, CodeDomConstruct elseExpression);
    protected virtual CodeDomConstruct EmitAndConditionalExpression(CodeDomContext context, IList`1<CodeDomConstruct> conditionExpressions, CodeDomConstruct thenExpression, CodeDomConstruct elseExpression);
    protected virtual CodeDomConstruct EmitRetrunStatement(CodeDomContext context, CodeDomConstruct expression);
    protected virtual CodeDomConstruct EmitForEachLoop(CodeDomContext context, CollectionTraits collectionTraits, CodeDomConstruct collection, Func`2<CodeDomConstruct, CodeDomConstruct> loopBodyEmitter);
    protected virtual CodeDomConstruct EmitEnumFromUnderlyingCastExpression(CodeDomContext context, Type enumType, CodeDomConstruct underlyingValue);
    protected virtual CodeDomConstruct EmitEnumToUnderlyingCastExpression(CodeDomContext context, Type underlyingType, CodeDomConstruct enumValue);
    protected virtual CodeDomConstruct EmitNewPrivateMethodDelegateExpression(CodeDomContext context, MethodDefinition method);
    protected virtual void BuildSerializerCodeCore(ISerializerCodeGenerationContext context, Type concreteType, PolymorphismSchema itemSchema);
    protected virtual Func`2<SerializationContext, MessagePackSerializer> CreateSerializerConstructor(CodeDomContext codeGenerationContext, SerializationTarget targetInfo, PolymorphismSchema schema, Nullable`1<SerializerCapabilities> capabilities);
    protected virtual Func`2<SerializationContext, MessagePackSerializer> CreateEnumSerializerConstructor(CodeDomContext codeGenerationContext);
    private void Finish(CodeDomContext context, SerializationTarget targetInfo, bool isEnum, Nullable`1<SerializerCapabilities> capabilities);
    private static CodeExpression BuildCapabilitiesExpression(CodeExpression expression, SerializerCapabilities capabilities, SerializerCapabilities value);
    protected virtual CodeDomContext CreateCodeGenerationContextForSerializerCreation(SerializationContext context);
}
internal class MsgPack.Serialization.CodeDomSerializers.ExpressionCodeDomConstruct : CodeDomConstruct {
    private CodeExpression _dom;
    public bool IsExpression { get; }
    public bool IsStatement { get; }
    public ExpressionCodeDomConstruct(TypeDefinition contextType, CodeExpression dom);
    public virtual bool get_IsExpression();
    public virtual bool get_IsStatement();
    public virtual CodeExpression AsExpression();
    [IteratorStateMachineAttribute("MsgPack.Serialization.CodeDomSerializers.ExpressionCodeDomConstruct/<AsStatements>d__6")]
public virtual IEnumerable`1<CodeStatement> AsStatements();
    public virtual void AddStatements(CodeStatementCollection collection);
}
internal class MsgPack.Serialization.CodeDomSerializers.ParameterCodeDomConstruct : CodeDomConstruct {
    private CodeTypeReference _type;
    private string _name;
    public CodeParameterDeclarationExpression Declaration { get; }
    public CodeArgumentReferenceExpression Reference { get; }
    public bool IsArgument { get; }
    public bool IsExpression { get; }
    public ParameterCodeDomConstruct(TypeDefinition type, string name);
    public CodeParameterDeclarationExpression get_Declaration();
    public CodeArgumentReferenceExpression get_Reference();
    public virtual bool get_IsArgument();
    public virtual CodeParameterDeclarationExpression AsParameter();
    public virtual CodeArgumentReferenceExpression AsArgument();
    public virtual bool get_IsExpression();
    public virtual CodeExpression AsExpression();
}
internal class MsgPack.Serialization.CodeDomSerializers.StatementCodeDomConstruct : CodeDomConstruct {
    private CodeStatement[] _statements;
    public bool IsStatement { get; }
    public StatementCodeDomConstruct(IEnumerable`1<CodeStatement> statements);
    public virtual bool get_IsStatement();
    public virtual IEnumerable`1<CodeStatement> AsStatements();
    public virtual void AddStatements(CodeStatementCollection collection);
}
internal class MsgPack.Serialization.CodeDomSerializers.VariableCodeDomConstruct : CodeDomConstruct {
    private CodeTypeReference _type;
    private string _name;
    public CodeVariableDeclarationStatement Declaration { get; }
    public CodeVariableReferenceExpression Reference { get; }
    public bool IsStatement { get; }
    public bool IsExpression { get; }
    public VariableCodeDomConstruct(TypeDefinition type, string name);
    public CodeVariableDeclarationStatement get_Declaration();
    public CodeVariableReferenceExpression get_Reference();
    public virtual bool get_IsStatement();
    [IteratorStateMachineAttribute("MsgPack.Serialization.CodeDomSerializers.VariableCodeDomConstruct/<AsStatements>d__8")]
public virtual IEnumerable`1<CodeStatement> AsStatements();
    public virtual void AddStatements(CodeStatementCollection collection);
    public virtual bool get_IsExpression();
    public virtual CodeExpression AsExpression();
}
public abstract class MsgPack.Serialization.CodeGenerationSink : object {
    public void AssignTextWriter(SerializerCodeInformation codeInformation);
    protected abstract virtual void AssignTextWriterCore(SerializerCodeInformation codeInformation);
    public static CodeGenerationSink ForIndividualFile();
    public static CodeGenerationSink ForSpecifiedTextWriter(TextWriter writer);
}
internal enum MsgPack.Serialization.CollectionDetailedKind : Enum {
    public int value__;
    public static CollectionDetailedKind NotCollection;
    public static CollectionDetailedKind Array;
    public static CollectionDetailedKind GenericList;
    public static CollectionDetailedKind NonGenericList;
    public static CollectionDetailedKind GenericDictionary;
    public static CollectionDetailedKind NonGenericDictionary;
    public static CollectionDetailedKind GenericSet;
    public static CollectionDetailedKind GenericCollection;
    public static CollectionDetailedKind NonGenericCollection;
    public static CollectionDetailedKind GenericEnumerable;
    public static CollectionDetailedKind NonGenericEnumerable;
    public static CollectionDetailedKind GenericReadOnlyList;
    public static CollectionDetailedKind GenericReadOnlyCollection;
    public static CollectionDetailedKind GenericReadOnlyDictionary;
    public static CollectionDetailedKind Unserializable;
}
internal enum MsgPack.Serialization.CollectionKind : Enum {
    public int value__;
    public static CollectionKind NotCollection;
    public static CollectionKind Array;
    public static CollectionKind Map;
    public static CollectionKind Unserializable;
}
public abstract class MsgPack.Serialization.CollectionSerializers.CollectionMessagePackSerializer`2 : CollectionMessagePackSerializerBase`2<TCollection, TItem> {
    protected CollectionMessagePackSerializer`2(SerializationContext ownerContext, PolymorphismSchema schema);
    protected CollectionMessagePackSerializer`2(SerializationContext ownerContext, PolymorphismSchema schema, SerializerCapabilities capabilities);
    protected virtual int GetCount(TCollection collection);
    protected virtual void AddItem(TCollection collection, TItem item);
}
public abstract class MsgPack.Serialization.CollectionSerializers.CollectionMessagePackSerializerBase`2 : EnumerableMessagePackSerializerBase`2<TCollection, TItem> {
    protected CollectionMessagePackSerializerBase`2(SerializationContext ownerContext, PolymorphismSchema schema);
    protected CollectionMessagePackSerializerBase`2(SerializationContext ownerContext, PolymorphismSchema schema, SerializerCapabilities capabilities);
    protected internal virtual void PackToCore(Packer packer, TCollection objectTree);
    [AsyncStateMachineAttribute("MsgPack.Serialization.CollectionSerializers.CollectionMessagePackSerializerBase`2/<PackToAsyncCore>d__3")]
protected internal virtual Task PackToAsyncCore(Packer packer, TCollection objectTree, CancellationToken cancellationToken);
    protected abstract virtual int GetCount(TCollection collection);
    protected internal virtual TCollection UnpackFromCore(Unpacker unpacker);
    internal virtual TCollection InternalUnpackFromCore(Unpacker unpacker);
    protected internal virtual Task`1<TCollection> UnpackFromAsyncCore(Unpacker unpacker, CancellationToken cancellationToken);
    internal virtual Task`1<TCollection> InternalUnpackFromAsyncCore(Unpacker unpacker, CancellationToken cancellationToken);
}
internal static class MsgPack.Serialization.CollectionSerializers.CollectionSerializerHelpers : object {
    public static Type[] CollectionConstructorTypes;
    private static CollectionSerializerHelpers();
}
public abstract class MsgPack.Serialization.CollectionSerializers.DictionaryMessagePackSerializer`3 : DictionaryMessagePackSerializerBase`3<TDictionary, TKey, TValue> {
    protected DictionaryMessagePackSerializer`3(SerializationContext ownerContext, PolymorphismSchema schema);
    protected DictionaryMessagePackSerializer`3(SerializationContext ownerContext, PolymorphismSchema schema, SerializerCapabilities capabilities);
    protected virtual int GetCount(TDictionary dictionary);
    protected virtual void AddItem(TDictionary dictionary, TKey key, TValue value);
}
public abstract class MsgPack.Serialization.CollectionSerializers.DictionaryMessagePackSerializerBase`3 : MessagePackSerializer`1<TDictionary> {
    private MessagePackSerializer`1<TKey> _keySerializer;
    private MessagePackSerializer`1<TValue> _valueSerializer;
    protected DictionaryMessagePackSerializerBase`3(SerializationContext ownerContext, PolymorphismSchema schema);
    protected DictionaryMessagePackSerializerBase`3(SerializationContext ownerContext, PolymorphismSchema schema, SerializerCapabilities capabilities);
    protected internal virtual void PackToCore(Packer packer, TDictionary objectTree);
    [AsyncStateMachineAttribute("MsgPack.Serialization.CollectionSerializers.DictionaryMessagePackSerializerBase`3/<PackToAsyncCore>d__5")]
protected internal virtual Task PackToAsyncCore(Packer packer, TDictionary objectTree, CancellationToken cancellationToken);
    protected abstract virtual int GetCount(TDictionary dictionary);
    protected internal virtual TDictionary UnpackFromCore(Unpacker unpacker);
    internal virtual TDictionary InternalUnpackFromCore(Unpacker unpacker);
    protected internal virtual Task`1<TDictionary> UnpackFromAsyncCore(Unpacker unpacker, CancellationToken cancellationToken);
    internal virtual Task`1<TDictionary> InternalUnpackFromAsyncCore(Unpacker unpacker, CancellationToken cancellationToken);
    protected abstract virtual TDictionary CreateInstance(int initialCapacity);
    private sealed virtual override object MsgPack.Serialization.CollectionSerializers.ICollectionInstanceFactory.CreateInstance(int initialCapacity);
    protected internal virtual void UnpackToCore(Unpacker unpacker, TDictionary collection);
    private void UnpackToCore(Unpacker unpacker, TDictionary collection, int itemsCount);
    protected internal virtual Task UnpackToAsyncCore(Unpacker unpacker, TDictionary collection, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.Serialization.CollectionSerializers.DictionaryMessagePackSerializerBase`3/<UnpackToAsyncCore>d__16")]
private Task`1<TDictionary> UnpackToAsyncCore(Unpacker unpacker, TDictionary collection, int itemsCount, CancellationToken cancellationToken);
    protected virtual void AddItem(TDictionary dictionary, TKey key, TValue value);
}
public abstract class MsgPack.Serialization.CollectionSerializers.EnumerableMessagePackSerializer`2 : EnumerableMessagePackSerializerBase`2<TCollection, TItem> {
    protected EnumerableMessagePackSerializer`2(SerializationContext ownerContext, PolymorphismSchema schema);
    protected EnumerableMessagePackSerializer`2(SerializationContext ownerContext, PolymorphismSchema schema, SerializerCapabilities capabilities);
    protected internal virtual void PackToCore(Packer packer, TCollection objectTree);
    [AsyncStateMachineAttribute("MsgPack.Serialization.CollectionSerializers.EnumerableMessagePackSerializer`2/<PackToAsyncCore>d__3")]
protected internal virtual Task PackToAsyncCore(Packer packer, TCollection objectTree, CancellationToken cancellationToken);
}
public abstract class MsgPack.Serialization.CollectionSerializers.EnumerableMessagePackSerializerBase`2 : MessagePackSerializer`1<TCollection> {
    private MessagePackSerializer`1<TItem> _itemSerializer;
    internal MessagePackSerializer`1<TItem> ItemSerializer { get; }
    protected EnumerableMessagePackSerializerBase`2(SerializationContext ownerContext, PolymorphismSchema schema);
    protected EnumerableMessagePackSerializerBase`2(SerializationContext ownerContext, PolymorphismSchema schema, SerializerCapabilities capabilities);
    internal MessagePackSerializer`1<TItem> get_ItemSerializer();
    protected abstract virtual TCollection CreateInstance(int initialCapacity);
    private sealed virtual override object MsgPack.Serialization.CollectionSerializers.ICollectionInstanceFactory.CreateInstance(int initialCapacity);
    protected internal virtual void UnpackToCore(Unpacker unpacker, TCollection collection);
    protected internal void UnpackToCore(Unpacker unpacker, TCollection collection, int itemsCount);
    protected internal virtual Task UnpackToAsyncCore(Unpacker unpacker, TCollection collection, CancellationToken cancellationToken);
    protected internal Task UnpackToAsyncCore(Unpacker unpacker, TCollection collection, int itemsCount, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.Serialization.CollectionSerializers.EnumerableMessagePackSerializerBase`2/<InternalUnpackToAsyncCore>d__11")]
internal Task`1<TCollection> InternalUnpackToAsyncCore(Unpacker unpacker, TCollection collection, int itemsCount, CancellationToken cancellationToken);
    protected virtual void AddItem(TCollection collection, TItem item);
}
public interface MsgPack.Serialization.CollectionSerializers.ICollectionInstanceFactory {
    public abstract virtual object CreateInstance(int initialCapacity);
}
public abstract class MsgPack.Serialization.CollectionSerializers.NonGenericCollectionMessagePackSerializer`1 : NonGenericEnumerableMessagePackSerializerBase`1<TCollection> {
    protected NonGenericCollectionMessagePackSerializer`1(SerializationContext ownerContext, PolymorphismSchema schema);
    protected NonGenericCollectionMessagePackSerializer`1(SerializationContext ownerContext, PolymorphismSchema schema, SerializerCapabilities capabilities);
    protected internal virtual void PackToCore(Packer packer, TCollection objectTree);
    [AsyncStateMachineAttribute("MsgPack.Serialization.CollectionSerializers.NonGenericCollectionMessagePackSerializer`1/<PackToAsyncCore>d__3")]
protected internal virtual Task PackToAsyncCore(Packer packer, TCollection objectTree, CancellationToken cancellationToken);
}
public abstract class MsgPack.Serialization.CollectionSerializers.NonGenericDictionaryMessagePackSerializer`1 : MessagePackSerializer`1<TDictionary> {
    private MessagePackSerializer _keySerializer;
    private MessagePackSerializer _valueSerializer;
    protected NonGenericDictionaryMessagePackSerializer`1(SerializationContext ownerContext, PolymorphismSchema schema);
    protected NonGenericDictionaryMessagePackSerializer`1(SerializationContext ownerContext, PolymorphismSchema schema, SerializerCapabilities capabilities);
    protected internal virtual void PackToCore(Packer packer, TDictionary objectTree);
    [AsyncStateMachineAttribute("MsgPack.Serialization.CollectionSerializers.NonGenericDictionaryMessagePackSerializer`1/<PackToAsyncCore>d__5")]
protected internal virtual Task PackToAsyncCore(Packer packer, TDictionary objectTree, CancellationToken cancellationToken);
    protected internal virtual TDictionary UnpackFromCore(Unpacker unpacker);
    internal virtual TDictionary InternalUnpackFromCore(Unpacker unpacker);
    protected internal virtual Task`1<TDictionary> UnpackFromAsyncCore(Unpacker unpacker, CancellationToken cancellationToken);
    internal virtual Task`1<TDictionary> InternalUnpackFromAsyncCore(Unpacker unpacker, CancellationToken cancellationToken);
    protected abstract virtual TDictionary CreateInstance(int initialCapacity);
    private sealed virtual override object MsgPack.Serialization.CollectionSerializers.ICollectionInstanceFactory.CreateInstance(int initialCapacity);
    protected internal virtual void UnpackToCore(Unpacker unpacker, TDictionary collection);
    private void UnpackToCore(Unpacker unpacker, TDictionary collection, int itemsCount);
    protected internal virtual Task UnpackToAsyncCore(Unpacker unpacker, TDictionary collection, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.Serialization.CollectionSerializers.NonGenericDictionaryMessagePackSerializer`1/<UnpackToAsyncCore>d__15")]
private Task`1<TDictionary> UnpackToAsyncCore(Unpacker unpacker, TDictionary collection, int itemsCount, CancellationToken cancellationToken);
}
public abstract class MsgPack.Serialization.CollectionSerializers.NonGenericEnumerableMessagePackSerializer`1 : NonGenericEnumerableMessagePackSerializerBase`1<TCollection> {
    protected NonGenericEnumerableMessagePackSerializer`1(SerializationContext ownerContext, PolymorphismSchema schema);
    protected NonGenericEnumerableMessagePackSerializer`1(SerializationContext ownerContext, PolymorphismSchema schema, SerializerCapabilities capabilities);
    protected internal virtual void PackToCore(Packer packer, TCollection objectTree);
    [AsyncStateMachineAttribute("MsgPack.Serialization.CollectionSerializers.NonGenericEnumerableMessagePackSerializer`1/<PackToAsyncCore>d__3")]
protected internal virtual Task PackToAsyncCore(Packer packer, TCollection objectTree, CancellationToken cancellationToken);
}
public abstract class MsgPack.Serialization.CollectionSerializers.NonGenericEnumerableMessagePackSerializerBase`1 : MessagePackSerializer`1<TCollection> {
    private MessagePackSerializer _itemSerializer;
    internal MessagePackSerializer ItemSerializer { get; }
    protected NonGenericEnumerableMessagePackSerializerBase`1(SerializationContext ownerContext, PolymorphismSchema schema);
    protected NonGenericEnumerableMessagePackSerializerBase`1(SerializationContext ownerContext, PolymorphismSchema schema, SerializerCapabilities capabilities);
    internal MessagePackSerializer get_ItemSerializer();
    protected abstract virtual TCollection CreateInstance(int initialCapacity);
    private sealed virtual override object MsgPack.Serialization.CollectionSerializers.ICollectionInstanceFactory.CreateInstance(int initialCapacity);
    protected internal virtual void UnpackToCore(Unpacker unpacker, TCollection collection);
    protected internal void UnpackToCore(Unpacker unpacker, TCollection collection, int itemsCount);
    protected internal virtual Task UnpackToAsyncCore(Unpacker unpacker, TCollection collection, CancellationToken cancellationToken);
    protected internal Task UnpackToAsyncCore(Unpacker unpacker, TCollection collection, int itemsCount, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.Serialization.CollectionSerializers.NonGenericEnumerableMessagePackSerializerBase`1/<InternalUnpackToAsyncCore>d__11")]
internal Task`1<TCollection> InternalUnpackToAsyncCore(Unpacker unpacker, TCollection collection, int itemsCount, CancellationToken cancellationToken);
    protected virtual void AddItem(TCollection collection, object item);
}
public abstract class MsgPack.Serialization.CollectionSerializers.NonGenericListMessagePackSerializer`1 : NonGenericCollectionMessagePackSerializer`1<TList> {
    protected NonGenericListMessagePackSerializer`1(SerializationContext ownerContext, PolymorphismSchema schema);
    protected NonGenericListMessagePackSerializer`1(SerializationContext ownerContext, PolymorphismSchema schema, SerializerCapabilities capabilities);
    protected internal virtual TList UnpackFromCore(Unpacker unpacker);
    internal virtual TList InternalUnpackFromCore(Unpacker unpacker);
    protected internal virtual Task`1<TList> UnpackFromAsyncCore(Unpacker unpacker, CancellationToken cancellationToken);
    internal virtual Task`1<TList> InternalUnpackFromAsyncCore(Unpacker unpacker, CancellationToken cancellationToken);
    protected virtual void AddItem(TList collection, object item);
}
public abstract class MsgPack.Serialization.CollectionSerializers.ReadOnlyCollectionMessagePackSerializer`2 : CollectionMessagePackSerializerBase`2<TCollection, TItem> {
    protected ReadOnlyCollectionMessagePackSerializer`2(SerializationContext ownerContext, PolymorphismSchema schema);
    protected ReadOnlyCollectionMessagePackSerializer`2(SerializationContext ownerContext, PolymorphismSchema schema, SerializerCapabilities capabilities);
    protected virtual int GetCount(TCollection collection);
}
public abstract class MsgPack.Serialization.CollectionSerializers.ReadOnlyDictionaryMessagePackSerializer`3 : DictionaryMessagePackSerializerBase`3<TDictionary, TKey, TValue> {
    protected ReadOnlyDictionaryMessagePackSerializer`3(SerializationContext ownerContext, PolymorphismSchema schema);
    protected ReadOnlyDictionaryMessagePackSerializer`3(SerializationContext ownerContext, PolymorphismSchema schema, SerializerCapabilities capabilities);
    protected virtual int GetCount(TDictionary dictionary);
}
[FlagsAttribute]
internal enum MsgPack.Serialization.CollectionTraitOptions : Enum {
    public int value__;
    public static CollectionTraitOptions None;
    public static CollectionTraitOptions WithAddMethod;
    public static CollectionTraitOptions WithCountPropertyGetter;
    public static CollectionTraitOptions WithGetEnumeratorMethod;
    public static CollectionTraitOptions AllowNonCollectionEnumerableTypes;
    public static CollectionTraitOptions Full;
}
internal class MsgPack.Serialization.CollectionTraits : ValueType {
    public static CollectionTraits NotCollection;
    public static CollectionTraits Unserializable;
    public Type ElementType;
    public CollectionDetailedKind DetailedCollectionType;
    public MethodInfo GetEnumeratorMethod;
    public MethodInfo AddMethod;
    public MethodInfo CountPropertyGetter;
    public CollectionKind CollectionType { get; }
    public CollectionTraits(CollectionDetailedKind type, Type elementType, MethodInfo getEnumeratorMethod, MethodInfo addMethod, MethodInfo countPropertyGetter);
    private static CollectionTraits();
    public CollectionKind get_CollectionType();
}
internal class MsgPack.Serialization.DataMemberContract : ValueType {
    internal static int UnspecifiedId;
    private string _name;
    private int _id;
    private NilImplication _nilImplication;
    public string Name { get; }
    public int Id { get; }
    public NilImplication NilImplication { get; }
    public DataMemberContract(MemberInfo member);
    public DataMemberContract(MemberInfo member, string name, NilImplication nilImplication, Nullable`1<int> id);
    public DataMemberContract(MemberInfo member, MessagePackMemberAttribute attribute);
    public string get_Name();
    public int get_Id();
    public NilImplication get_NilImplication();
}
public enum MsgPack.Serialization.DateTimeConversionMethod : Enum {
    public int value__;
    public static DateTimeConversionMethod Native;
    public static DateTimeConversionMethod UnixEpoc;
    public static DateTimeConversionMethod Timestamp;
}
public enum MsgPack.Serialization.DateTimeMemberConversionMethod : Enum {
    public int value__;
    public static DateTimeMemberConversionMethod Default;
    public static DateTimeMemberConversionMethod Native;
    public static DateTimeMemberConversionMethod UnixEpoc;
    public static DateTimeMemberConversionMethod Timestamp;
}
[EditorBrowsableAttribute("1")]
public static class MsgPack.Serialization.DateTimeMessagePackSerializerHelpers : object {
    [EditorBrowsableAttribute("1")]
public static DateTimeConversionMethod DetermineDateTimeConversionMethod(SerializationContext context, DateTimeMemberConversionMethod dateTimeMemberConversionMethod);
    internal static bool IsDateTime(Type dateTimeType);
}
public class MsgPack.Serialization.DefaultConcreteTypeRepository : object {
    private TypeKeyRepository _defaultCollectionTypes;
    public Type Get(Type abstractCollectionType);
    internal Type GetConcreteType(Type abstractCollectionType);
    public void Register(Type abstractCollectionType, Type defaultCollectionType);
    private static bool IsAnscestorType(Type mayBeAncestor, Type mayBeDescendant);
    public bool Unregister(Type abstractCollectionType);
}
internal static class MsgPack.Serialization.DefaultSerializerNameResolver : object {
    private static int _serializerNameSequence;
    public static void ResolveTypeName(bool useSequence, Type targetType, string namespace, String& serializerTypeName, String& serializerTypeNamespace);
}
internal class MsgPack.Serialization.DefaultSerializers.AbstractCollectionMessagePackSerializer`2 : CollectionMessagePackSerializer`2<TCollection, TItem> {
    private ICollectionInstanceFactory _concreteCollectionInstanceFactory;
    private IPolymorphicDeserializer _polymorphicDeserializer;
    public AbstractCollectionMessagePackSerializer`2(SerializationContext ownerContext, Type targetType, PolymorphismSchema schema);
    internal virtual TCollection InternalUnpackFromCore(Unpacker unpacker);
    internal virtual Task`1<TCollection> InternalUnpackFromAsyncCore(Unpacker unpacker, CancellationToken cancellationToken);
    protected virtual TCollection CreateInstance(int initialCapacity);
}
internal static class MsgPack.Serialization.DefaultSerializers.AbstractCollectionSerializerHelper : object {
    public static void GetConcreteSerializer(SerializationContext context, PolymorphismSchema schema, Type abstractType, Type targetType, Type exampleType, ICollectionInstanceFactory& factory, MessagePackSerializer& serializer);
}
internal class MsgPack.Serialization.DefaultSerializers.AbstractDictionaryMessagePackSerializer`3 : DictionaryMessagePackSerializer`3<TDictionary, TKey, TValue> {
    private ICollectionInstanceFactory _concreteCollectionInstanceFactory;
    private IPolymorphicDeserializer _polymorphicDeserializer;
    public AbstractDictionaryMessagePackSerializer`3(SerializationContext ownerContext, Type targetType, PolymorphismSchema schema);
    internal virtual TDictionary InternalUnpackFromCore(Unpacker unpacker);
    internal virtual Task`1<TDictionary> InternalUnpackFromAsyncCore(Unpacker unpacker, CancellationToken cancellationToken);
    protected virtual TDictionary CreateInstance(int initialCapacity);
}
internal class MsgPack.Serialization.DefaultSerializers.AbstractEnumerableMessagePackSerializer`2 : EnumerableMessagePackSerializer`2<TCollection, TItem> {
    private ICollectionInstanceFactory _concreteCollectionInstanceFactory;
    private MessagePackSerializer _concreteSerializer;
    public AbstractEnumerableMessagePackSerializer`2(SerializationContext ownerContext, Type targetType, PolymorphismSchema schema);
    internal virtual SerializerCapabilities InternalGetCapabilities();
    protected internal virtual TCollection UnpackFromCore(Unpacker unpacker);
    [AsyncStateMachineAttribute("MsgPack.Serialization.DefaultSerializers.AbstractEnumerableMessagePackSerializer`2/<UnpackFromAsyncCore>d__5")]
protected internal virtual Task`1<TCollection> UnpackFromAsyncCore(Unpacker unpacker, CancellationToken cancellationToken);
    protected virtual TCollection CreateInstance(int initialCapacity);
}
internal class MsgPack.Serialization.DefaultSerializers.AbstractNonGenericCollectionMessagePackSerializer`1 : NonGenericCollectionMessagePackSerializer`1<TCollection> {
    private ICollectionInstanceFactory _concreteCollectionInstanceFactory;
    private MessagePackSerializer _concreteSerializer;
    public AbstractNonGenericCollectionMessagePackSerializer`1(SerializationContext ownerContext, Type targetType, PolymorphismSchema schema);
    internal virtual SerializerCapabilities InternalGetCapabilities();
    protected internal virtual TCollection UnpackFromCore(Unpacker unpacker);
    [AsyncStateMachineAttribute("MsgPack.Serialization.DefaultSerializers.AbstractNonGenericCollectionMessagePackSerializer`1/<UnpackFromAsyncCore>d__5")]
protected internal virtual Task`1<TCollection> UnpackFromAsyncCore(Unpacker unpacker, CancellationToken cancellationToken);
    protected virtual TCollection CreateInstance(int initialCapacity);
}
internal class MsgPack.Serialization.DefaultSerializers.AbstractNonGenericDictionaryMessagePackSerializer`1 : NonGenericDictionaryMessagePackSerializer`1<TDictionary> {
    private ICollectionInstanceFactory _concreteCollectionInstanceFactory;
    private IPolymorphicDeserializer _polymorphicDeserializer;
    public AbstractNonGenericDictionaryMessagePackSerializer`1(SerializationContext ownerContext, Type targetType, PolymorphismSchema schema);
    internal virtual TDictionary InternalUnpackFromCore(Unpacker unpacker);
    internal virtual Task`1<TDictionary> InternalUnpackFromAsyncCore(Unpacker unpacker, CancellationToken cancellationToken);
    protected virtual TDictionary CreateInstance(int initialCapacity);
}
internal class MsgPack.Serialization.DefaultSerializers.AbstractNonGenericEnumerableMessagePackSerializer`1 : NonGenericEnumerableMessagePackSerializer`1<TCollection> {
    private ICollectionInstanceFactory _concreteCollectionInstanceFactory;
    private MessagePackSerializer _concreteSerializer;
    public AbstractNonGenericEnumerableMessagePackSerializer`1(SerializationContext ownerContext, Type targetType, PolymorphismSchema schema);
    internal virtual SerializerCapabilities InternalGetCapabilities();
    protected internal virtual TCollection UnpackFromCore(Unpacker unpacker);
    [AsyncStateMachineAttribute("MsgPack.Serialization.DefaultSerializers.AbstractNonGenericEnumerableMessagePackSerializer`1/<UnpackFromAsyncCore>d__5")]
protected internal virtual Task`1<TCollection> UnpackFromAsyncCore(Unpacker unpacker, CancellationToken cancellationToken);
    protected virtual TCollection CreateInstance(int initialCapacity);
}
internal class MsgPack.Serialization.DefaultSerializers.AbstractNonGenericListMessagePackSerializer`1 : NonGenericListMessagePackSerializer`1<TCollection> {
    private ICollectionInstanceFactory _concreteCollectionInstanceFactory;
    private IPolymorphicDeserializer _polymorphicDeserializer;
    public AbstractNonGenericListMessagePackSerializer`1(SerializationContext ownerContext, Type targetType, PolymorphismSchema schema);
    internal virtual TCollection InternalUnpackFromCore(Unpacker unpacker);
    internal virtual Task`1<TCollection> InternalUnpackFromAsyncCore(Unpacker unpacker, CancellationToken cancellationToken);
    protected virtual TCollection CreateInstance(int initialCapacity);
}
internal class MsgPack.Serialization.DefaultSerializers.AbstractReadOnlyCollectionMessagePackSerializer`2 : ReadOnlyCollectionMessagePackSerializer`2<TCollection, TItem> {
    private ICollectionInstanceFactory _concreteCollectionInstanceFactory;
    private IPolymorphicDeserializer _polymorphicDeserializer;
    private MessagePackSerializer _concreteDeserializer;
    public AbstractReadOnlyCollectionMessagePackSerializer`2(SerializationContext ownerContext, Type targetType, PolymorphismSchema schema);
    internal virtual SerializerCapabilities InternalGetCapabilities();
    internal virtual TCollection InternalUnpackFromCore(Unpacker unpacker);
    internal virtual Task`1<TCollection> InternalUnpackFromAsyncCore(Unpacker unpacker, CancellationToken cancellationToken);
    protected virtual TCollection CreateInstance(int initialCapacity);
}
internal class MsgPack.Serialization.DefaultSerializers.AbstractReadOnlyDictionaryMessagePackSerializer`3 : ReadOnlyDictionaryMessagePackSerializer`3<TDictionary, TKey, TValue> {
    private ICollectionInstanceFactory _concreteCollectionInstanceFactory;
    private IPolymorphicDeserializer _polymorphicDeserializer;
    private MessagePackSerializer _concreteDeserializer;
    public AbstractReadOnlyDictionaryMessagePackSerializer`3(SerializationContext ownerContext, Type targetType, PolymorphismSchema schema);
    internal virtual SerializerCapabilities InternalGetCapabilities();
    internal virtual TDictionary InternalUnpackFromCore(Unpacker unpacker);
    internal virtual Task`1<TDictionary> InternalUnpackFromAsyncCore(Unpacker unpacker, CancellationToken cancellationToken);
    protected virtual TDictionary CreateInstance(int initialCapacity);
}
internal static class MsgPack.Serialization.DefaultSerializers.ArraySegmentMessageSerializer : object {
    public static void PackByteArraySegmentTo(Packer packer, ArraySegment`1<byte> objectTree, MessagePackSerializer`1<byte> itemSerializer);
    public static void PackCharArraySegmentTo(Packer packer, ArraySegment`1<char> objectTree, MessagePackSerializer`1<char> itemSerializer);
    public static void PackGenericArraySegmentTo(Packer packer, ArraySegment`1<T> objectTree, MessagePackSerializer`1<T> itemSerializer);
    public static ArraySegment`1<byte> UnpackByteArraySegmentFrom(Unpacker unpacker, MessagePackSerializer`1<byte> itemSerializer);
    public static ArraySegment`1<char> UnpackCharArraySegmentFrom(Unpacker unpacker, MessagePackSerializer`1<char> itemSerializer);
    public static ArraySegment`1<T> UnpackGenericArraySegmentFrom(Unpacker unpacker, MessagePackSerializer`1<T> itemSerializer);
    [AsyncStateMachineAttribute("MsgPack.Serialization.DefaultSerializers.ArraySegmentMessageSerializer/<PackByteArraySegmentToAsync>d__6")]
public static Task PackByteArraySegmentToAsync(Packer packer, ArraySegment`1<byte> objectTree, MessagePackSerializer`1<byte> itemSerializer, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.Serialization.DefaultSerializers.ArraySegmentMessageSerializer/<PackCharArraySegmentToAsync>d__7")]
public static Task PackCharArraySegmentToAsync(Packer packer, ArraySegment`1<char> objectTree, MessagePackSerializer`1<char> itemSerializer, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.Serialization.DefaultSerializers.ArraySegmentMessageSerializer/<PackGenericArraySegmentToAsync>d__8`1")]
public static Task PackGenericArraySegmentToAsync(Packer packer, ArraySegment`1<T> objectTree, MessagePackSerializer`1<T> itemSerializer, CancellationToken cancellationToken);
    public static Task`1<ArraySegment`1<byte>> UnpackByteArraySegmentFromAsync(Unpacker unpacker, MessagePackSerializer`1<byte> itemSerializer, CancellationToken cancellationToken);
    public static Task`1<ArraySegment`1<char>> UnpackCharArraySegmentFromAsync(Unpacker unpacker, MessagePackSerializer`1<char> itemSerializer, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.Serialization.DefaultSerializers.ArraySegmentMessageSerializer/<UnpackGenericArraySegmentFromAsync>d__11`1")]
public static Task`1<ArraySegment`1<T>> UnpackGenericArraySegmentFromAsync(Unpacker unpacker, MessagePackSerializer`1<T> itemSerializer, CancellationToken cancellationToken);
}
internal static class MsgPack.Serialization.DefaultSerializers.ArraySerializer : object {
    private static Dictionary`2<Type, Func`2<SerializationContext, object>> _arraySerializerFactories;
    private static ArraySerializer();
    public static MessagePackSerializer`1<T> Create(SerializationContext context, PolymorphismSchema itemsSchema);
    public static MessagePackSerializer Create(SerializationContext context, Type targetType, PolymorphismSchema itemsSchema);
    private static object GetPrimitiveArraySerializer(SerializationContext context, Type targetType);
    private static Dictionary`2<Type, Func`2<SerializationContext, object>> InitializeArraySerializerFactories();
}
[PreserveAttribute]
internal class MsgPack.Serialization.DefaultSerializers.ArraySerializer`1 : MessagePackSerializer`1<T[]> {
    private MessagePackSerializer`1<T> _itemSerializer;
    public ArraySerializer`1(SerializationContext ownerContext, PolymorphismSchema itemsSchema);
    protected internal virtual void PackToCore(Packer packer, T[] objectTree);
    protected internal virtual T[] UnpackFromCore(Unpacker unpacker);
    protected internal virtual void UnpackToCore(Unpacker unpacker, T[] collection);
    private void UnpackToCore(Unpacker unpacker, T[] collection, int count);
    [AsyncStateMachineAttribute("MsgPack.Serialization.DefaultSerializers.ArraySerializer`1/<PackToAsyncCore>d__6")]
protected internal virtual Task PackToAsyncCore(Packer packer, T[] objectTree, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.Serialization.DefaultSerializers.ArraySerializer`1/<UnpackFromAsyncCore>d__7")]
protected internal virtual Task`1<T[]> UnpackFromAsyncCore(Unpacker unpacker, CancellationToken cancellationToken);
    protected internal virtual Task UnpackToAsyncCore(Unpacker unpacker, T[] collection, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.Serialization.DefaultSerializers.ArraySerializer`1/<UnpackToAsyncCore>d__9")]
private Task UnpackToAsyncCore(Unpacker unpacker, T[] collection, int count, CancellationToken cancellationToken);
}
[PreserveAttribute]
internal class MsgPack.Serialization.DefaultSerializers.BinaryArraySerializer : MessagePackSerializer`1<Byte[][]> {
    public BinaryArraySerializer(SerializationContext ownerContext);
    protected internal virtual void PackToCore(Packer packer, Byte[][] objectTree);
    protected internal virtual Byte[][] UnpackFromCore(Unpacker unpacker);
    protected internal virtual void UnpackToCore(Unpacker unpacker, Byte[][] collection);
    private static void UnpackToCore(Unpacker unpacker, Byte[][] collection, int count);
    [AsyncStateMachineAttribute("MsgPack.Serialization.DefaultSerializers.BinaryArraySerializer/<PackToAsyncCore>d__5")]
protected internal virtual Task PackToAsyncCore(Packer packer, Byte[][] objectTree, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.Serialization.DefaultSerializers.BinaryArraySerializer/<UnpackFromAsyncCore>d__6")]
protected internal virtual Task`1<Byte[][]> UnpackFromAsyncCore(Unpacker unpacker, CancellationToken cancellationToken);
    protected internal virtual Task UnpackToAsyncCore(Unpacker unpacker, Byte[][] collection, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.Serialization.DefaultSerializers.BinaryArraySerializer/<UnpackToAsyncCore>d__8")]
private static Task UnpackToAsyncCore(Unpacker unpacker, Byte[][] collection, int count, CancellationToken cancellationToken);
}
[PreserveAttribute]
internal class MsgPack.Serialization.DefaultSerializers.BooleanArraySerializer : MessagePackSerializer`1<Boolean[]> {
    public BooleanArraySerializer(SerializationContext ownerContext);
    protected internal virtual void PackToCore(Packer packer, Boolean[] objectTree);
    protected internal virtual Boolean[] UnpackFromCore(Unpacker unpacker);
    protected internal virtual void UnpackToCore(Unpacker unpacker, Boolean[] collection);
    private static void UnpackToCore(Unpacker unpacker, Boolean[] collection, int count);
    [AsyncStateMachineAttribute("MsgPack.Serialization.DefaultSerializers.BooleanArraySerializer/<PackToAsyncCore>d__5")]
protected internal virtual Task PackToAsyncCore(Packer packer, Boolean[] objectTree, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.Serialization.DefaultSerializers.BooleanArraySerializer/<UnpackFromAsyncCore>d__6")]
protected internal virtual Task`1<Boolean[]> UnpackFromAsyncCore(Unpacker unpacker, CancellationToken cancellationToken);
    protected internal virtual Task UnpackToAsyncCore(Unpacker unpacker, Boolean[] collection, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.Serialization.DefaultSerializers.BooleanArraySerializer/<UnpackToAsyncCore>d__8")]
private static Task UnpackToAsyncCore(Unpacker unpacker, Boolean[] collection, int count, CancellationToken cancellationToken);
}
[PreserveAttribute]
internal class MsgPack.Serialization.DefaultSerializers.ByteArraySerializer : MessagePackSerializer`1<Byte[]> {
    public ByteArraySerializer(SerializationContext ownerContext);
    protected internal virtual void PackToCore(Packer packer, Byte[] objectTree);
    protected internal virtual Byte[] UnpackFromCore(Unpacker unpacker);
    protected internal virtual void UnpackToCore(Unpacker unpacker, Byte[] collection);
    private static void UnpackToCore(Unpacker unpacker, Byte[] collection, int count);
    [AsyncStateMachineAttribute("MsgPack.Serialization.DefaultSerializers.ByteArraySerializer/<PackToAsyncCore>d__5")]
protected internal virtual Task PackToAsyncCore(Packer packer, Byte[] objectTree, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.Serialization.DefaultSerializers.ByteArraySerializer/<UnpackFromAsyncCore>d__6")]
protected internal virtual Task`1<Byte[]> UnpackFromAsyncCore(Unpacker unpacker, CancellationToken cancellationToken);
    protected internal virtual Task UnpackToAsyncCore(Unpacker unpacker, Byte[] collection, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.Serialization.DefaultSerializers.ByteArraySerializer/<UnpackToAsyncCore>d__8")]
private static Task UnpackToAsyncCore(Unpacker unpacker, Byte[] collection, int count, CancellationToken cancellationToken);
}
internal class MsgPack.Serialization.DefaultSerializers.DateTimeMessagePackSerializerProvider : MessagePackSerializerProvider {
    private MessagePackSerializer _unixEpoc;
    private MessagePackSerializer _native;
    private MessagePackSerializer _timestamp;
    public DateTimeMessagePackSerializerProvider(SerializationContext context, bool isNullable);
    public virtual object Get(SerializationContext context, object providerParameter);
}
internal class MsgPack.Serialization.DefaultSerializers.DateTimeOffsetMessagePackSerializer : MessagePackSerializer`1<DateTimeOffset> {
    private DateTimeConversionMethod _conversion;
    public DateTimeOffsetMessagePackSerializer(SerializationContext ownerContext, DateTimeConversionMethod conversion);
    protected internal virtual void PackToCore(Packer packer, DateTimeOffset objectTree);
    protected internal virtual DateTimeOffset UnpackFromCore(Unpacker unpacker);
    [AsyncStateMachineAttribute("MsgPack.Serialization.DefaultSerializers.DateTimeOffsetMessagePackSerializer/<PackToAsyncCore>d__4")]
protected internal virtual Task PackToAsyncCore(Packer packer, DateTimeOffset objectTree, CancellationToken cancellationToken);
    protected internal virtual Task`1<DateTimeOffset> UnpackFromAsyncCore(Unpacker unpacker, CancellationToken cancellationToken);
}
internal class MsgPack.Serialization.DefaultSerializers.DateTimeOffsetMessagePackSerializerProvider : MessagePackSerializerProvider {
    private MessagePackSerializer _unixEpoc;
    private MessagePackSerializer _native;
    private MessagePackSerializer _timestamp;
    public DateTimeOffsetMessagePackSerializerProvider(SerializationContext context, bool isNullable);
    public virtual object Get(SerializationContext context, object providerParameter);
}
[PreserveAttribute]
internal class MsgPack.Serialization.DefaultSerializers.DoubleArraySerializer : MessagePackSerializer`1<Double[]> {
    public DoubleArraySerializer(SerializationContext ownerContext);
    protected internal virtual void PackToCore(Packer packer, Double[] objectTree);
    protected internal virtual Double[] UnpackFromCore(Unpacker unpacker);
    protected internal virtual void UnpackToCore(Unpacker unpacker, Double[] collection);
    private static void UnpackToCore(Unpacker unpacker, Double[] collection, int count);
    [AsyncStateMachineAttribute("MsgPack.Serialization.DefaultSerializers.DoubleArraySerializer/<PackToAsyncCore>d__5")]
protected internal virtual Task PackToAsyncCore(Packer packer, Double[] objectTree, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.Serialization.DefaultSerializers.DoubleArraySerializer/<UnpackFromAsyncCore>d__6")]
protected internal virtual Task`1<Double[]> UnpackFromAsyncCore(Unpacker unpacker, CancellationToken cancellationToken);
    protected internal virtual Task UnpackToAsyncCore(Unpacker unpacker, Double[] collection, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.Serialization.DefaultSerializers.DoubleArraySerializer/<UnpackToAsyncCore>d__8")]
private static Task UnpackToAsyncCore(Unpacker unpacker, Double[] collection, int count, CancellationToken cancellationToken);
}
internal class MsgPack.Serialization.DefaultSerializers.FileTimeMessagePackSerializerProvider : MessagePackSerializerProvider {
    private MessagePackSerializer _unixEpoc;
    private MessagePackSerializer _native;
    private MessagePackSerializer _timestamp;
    public FileTimeMessagePackSerializerProvider(SerializationContext context, bool isNullable);
    public virtual object Get(SerializationContext context, object providerParameter);
}
[PreserveAttribute]
internal class MsgPack.Serialization.DefaultSerializers.FSharpCollectionSerializer`2 : MessagePackSerializer`1<T> {
    private Func`2<TItem[], T> _factory;
    private MessagePackSerializer`1<TItem> _itemSerializer;
    public FSharpCollectionSerializer`2(SerializationContext ownerContext, PolymorphismSchema itemsSchema, string factoryTypeName);
    private static Func`2<TItem[], T> FindFactory(string factoryTypeName);
    protected internal virtual void PackToCore(Packer packer, T objectTree);
    protected internal virtual T UnpackFromCore(Unpacker unpacker);
    protected internal virtual void UnpackToCore(Unpacker unpacker, T collection);
    [AsyncStateMachineAttribute("MsgPack.Serialization.DefaultSerializers.FSharpCollectionSerializer`2/<PackToAsyncCore>d__7")]
protected internal virtual Task PackToAsyncCore(Packer packer, T objectTree, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.Serialization.DefaultSerializers.FSharpCollectionSerializer`2/<UnpackFromAsyncCore>d__8")]
protected internal virtual Task`1<T> UnpackFromAsyncCore(Unpacker unpacker, CancellationToken cancellationToken);
    protected internal virtual Task UnpackToAsyncCore(Unpacker unpacker, T collection, CancellationToken cancellationToken);
}
[PreserveAttribute]
internal class MsgPack.Serialization.DefaultSerializers.FSharpMapSerializer`3 : MessagePackSerializer`1<T> {
    private Func`2<IEnumerable`1<Tuple`2<TKey, TValue>>, T> _factory;
    private MessagePackSerializer`1<TKey> _keySerializer;
    private MessagePackSerializer`1<TValue> _valueSerializer;
    public FSharpMapSerializer`3(SerializationContext ownerContext, PolymorphismSchema keysSchema, PolymorphismSchema valuesSchema);
    private static Func`2<IEnumerable`1<Tuple`2<TKey, TValue>>, T> FindFactory();
    protected internal virtual void PackToCore(Packer packer, T objectTree);
    protected internal virtual T UnpackFromCore(Unpacker unpacker);
    protected internal virtual void UnpackToCore(Unpacker unpacker, T collection);
    [AsyncStateMachineAttribute("MsgPack.Serialization.DefaultSerializers.FSharpMapSerializer`3/<PackToAsyncCore>d__8")]
protected internal virtual Task PackToAsyncCore(Packer packer, T objectTree, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.Serialization.DefaultSerializers.FSharpMapSerializer`3/<UnpackFromAsyncCore>d__9")]
protected internal virtual Task`1<T> UnpackFromAsyncCore(Unpacker unpacker, CancellationToken cancellationToken);
    protected internal virtual Task UnpackToAsyncCore(Unpacker unpacker, T collection, CancellationToken cancellationToken);
}
internal static class MsgPack.Serialization.DefaultSerializers.GenericSerializer : object {
    public static MessagePackSerializer`1<T> Create(SerializationContext context, PolymorphismSchema schema);
    public static MessagePackSerializer Create(SerializationContext context, Type targetType, PolymorphismSchema schema);
    private static MessagePackSerializer CreateArraySerializer(SerializationContext context, Type targetType, PolymorphismSchema itemsSchema);
    private static MessagePackSerializer CreateNullableSerializer(SerializationContext context, Type underlyingType, PolymorphismSchema schema);
    private static MessagePackSerializer CreateListSerializer(SerializationContext context, Type itemType, PolymorphismSchema schema);
    private static MessagePackSerializer CreateDictionarySerializer(SerializationContext context, Type keyType, Type valueType, PolymorphismSchema schema);
    private static MessagePackSerializer TryCreateImmutableCollectionSerializer(SerializationContext context, Type targetType, PolymorphismSchema schema);
    private static ImmutableCollectionType DetermineImmutableCollectionType(Type targetType);
    public static MessagePackSerializer TryCreateAbstractCollectionSerializer(SerializationContext context, Type abstractType, Type concreteType, PolymorphismSchema schema);
    internal static MessagePackSerializer TryCreateAbstractCollectionSerializer(SerializationContext context, Type abstractType, Type concreteType, PolymorphismSchema schema, CollectionTraits traits);
    internal static bool IsSupported(Type type, CollectionTraits traits, bool preferReflectionBasedSerializer);
}
[PreserveAttribute]
internal class MsgPack.Serialization.DefaultSerializers.ImmutableCollectionSerializer`2 : MessagePackSerializer`1<T> {
    protected Func`2<TItem[], T> Factory;
    protected MessagePackSerializer`1<TItem> ItemSerializer;
    public ImmutableCollectionSerializer`2(SerializationContext ownerContext, PolymorphismSchema itemsSchema);
    private static Func`2<TItem[], T> FindFactory();
    protected internal virtual void PackToCore(Packer packer, T objectTree);
    protected internal virtual T UnpackFromCore(Unpacker unpacker);
    protected internal virtual void UnpackToCore(Unpacker unpacker, T collection);
    [AsyncStateMachineAttribute("MsgPack.Serialization.DefaultSerializers.ImmutableCollectionSerializer`2/<PackToAsyncCore>d__7")]
protected internal virtual Task PackToAsyncCore(Packer packer, T objectTree, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.Serialization.DefaultSerializers.ImmutableCollectionSerializer`2/<UnpackFromAsyncCore>d__8")]
protected internal virtual Task`1<T> UnpackFromAsyncCore(Unpacker unpacker, CancellationToken cancellationToken);
    protected internal virtual Task UnpackToAsyncCore(Unpacker unpacker, T collection, CancellationToken cancellationToken);
}
[PreserveAttribute]
internal class MsgPack.Serialization.DefaultSerializers.ImmutableDictionarySerializer`3 : MessagePackSerializer`1<T> {
    private Func`2<KeyValuePair`2[], T> _factory;
    private MessagePackSerializer`1<TKey> _keySerializer;
    private MessagePackSerializer`1<TValue> _valueSerializer;
    public ImmutableDictionarySerializer`3(SerializationContext ownerContext, PolymorphismSchema keysSchema, PolymorphismSchema valuesSchema);
    private static Func`2<KeyValuePair`2[], T> FindFactory();
    protected internal virtual void PackToCore(Packer packer, T objectTree);
    protected internal virtual T UnpackFromCore(Unpacker unpacker);
    protected internal virtual void UnpackToCore(Unpacker unpacker, T collection);
    [AsyncStateMachineAttribute("MsgPack.Serialization.DefaultSerializers.ImmutableDictionarySerializer`3/<PackToAsyncCore>d__8")]
protected internal virtual Task PackToAsyncCore(Packer packer, T objectTree, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.Serialization.DefaultSerializers.ImmutableDictionarySerializer`3/<UnpackFromAsyncCore>d__9")]
protected internal virtual Task`1<T> UnpackFromAsyncCore(Unpacker unpacker, CancellationToken cancellationToken);
    protected internal virtual Task UnpackToAsyncCore(Unpacker unpacker, T collection, CancellationToken cancellationToken);
}
[PreserveAttribute]
internal class MsgPack.Serialization.DefaultSerializers.ImmutableStackSerializer`2 : ImmutableCollectionSerializer`2<T, TItem> {
    public ImmutableStackSerializer`2(SerializationContext ownerContext, PolymorphismSchema itemsSchema);
    protected internal virtual T UnpackFromCore(Unpacker unpacker);
    [AsyncStateMachineAttribute("MsgPack.Serialization.DefaultSerializers.ImmutableStackSerializer`2/<UnpackFromAsyncCore>d__2")]
protected internal virtual Task`1<T> UnpackFromAsyncCore(Unpacker unpacker, CancellationToken cancellationToken);
}
[PreserveAttribute]
internal class MsgPack.Serialization.DefaultSerializers.Int16ArraySerializer : MessagePackSerializer`1<Int16[]> {
    public Int16ArraySerializer(SerializationContext ownerContext);
    protected internal virtual void PackToCore(Packer packer, Int16[] objectTree);
    protected internal virtual Int16[] UnpackFromCore(Unpacker unpacker);
    protected internal virtual void UnpackToCore(Unpacker unpacker, Int16[] collection);
    private static void UnpackToCore(Unpacker unpacker, Int16[] collection, int count);
    [AsyncStateMachineAttribute("MsgPack.Serialization.DefaultSerializers.Int16ArraySerializer/<PackToAsyncCore>d__5")]
protected internal virtual Task PackToAsyncCore(Packer packer, Int16[] objectTree, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.Serialization.DefaultSerializers.Int16ArraySerializer/<UnpackFromAsyncCore>d__6")]
protected internal virtual Task`1<Int16[]> UnpackFromAsyncCore(Unpacker unpacker, CancellationToken cancellationToken);
    protected internal virtual Task UnpackToAsyncCore(Unpacker unpacker, Int16[] collection, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.Serialization.DefaultSerializers.Int16ArraySerializer/<UnpackToAsyncCore>d__8")]
private static Task UnpackToAsyncCore(Unpacker unpacker, Int16[] collection, int count, CancellationToken cancellationToken);
}
[PreserveAttribute]
internal class MsgPack.Serialization.DefaultSerializers.Int32ArraySerializer : MessagePackSerializer`1<Int32[]> {
    public Int32ArraySerializer(SerializationContext ownerContext);
    protected internal virtual void PackToCore(Packer packer, Int32[] objectTree);
    protected internal virtual Int32[] UnpackFromCore(Unpacker unpacker);
    protected internal virtual void UnpackToCore(Unpacker unpacker, Int32[] collection);
    private static void UnpackToCore(Unpacker unpacker, Int32[] collection, int count);
    [AsyncStateMachineAttribute("MsgPack.Serialization.DefaultSerializers.Int32ArraySerializer/<PackToAsyncCore>d__5")]
protected internal virtual Task PackToAsyncCore(Packer packer, Int32[] objectTree, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.Serialization.DefaultSerializers.Int32ArraySerializer/<UnpackFromAsyncCore>d__6")]
protected internal virtual Task`1<Int32[]> UnpackFromAsyncCore(Unpacker unpacker, CancellationToken cancellationToken);
    protected internal virtual Task UnpackToAsyncCore(Unpacker unpacker, Int32[] collection, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.Serialization.DefaultSerializers.Int32ArraySerializer/<UnpackToAsyncCore>d__8")]
private static Task UnpackToAsyncCore(Unpacker unpacker, Int32[] collection, int count, CancellationToken cancellationToken);
}
[PreserveAttribute]
internal class MsgPack.Serialization.DefaultSerializers.Int64ArraySerializer : MessagePackSerializer`1<Int64[]> {
    public Int64ArraySerializer(SerializationContext ownerContext);
    protected internal virtual void PackToCore(Packer packer, Int64[] objectTree);
    protected internal virtual Int64[] UnpackFromCore(Unpacker unpacker);
    protected internal virtual void UnpackToCore(Unpacker unpacker, Int64[] collection);
    private static void UnpackToCore(Unpacker unpacker, Int64[] collection, int count);
    [AsyncStateMachineAttribute("MsgPack.Serialization.DefaultSerializers.Int64ArraySerializer/<PackToAsyncCore>d__5")]
protected internal virtual Task PackToAsyncCore(Packer packer, Int64[] objectTree, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.Serialization.DefaultSerializers.Int64ArraySerializer/<UnpackFromAsyncCore>d__6")]
protected internal virtual Task`1<Int64[]> UnpackFromAsyncCore(Unpacker unpacker, CancellationToken cancellationToken);
    protected internal virtual Task UnpackToAsyncCore(Unpacker unpacker, Int64[] collection, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.Serialization.DefaultSerializers.Int64ArraySerializer/<UnpackToAsyncCore>d__8")]
private static Task UnpackToAsyncCore(Unpacker unpacker, Int64[] collection, int count, CancellationToken cancellationToken);
}
[ExtensionAttribute]
internal static class MsgPack.Serialization.DefaultSerializers.InternalDateTimeExtensions : object {
    private static DateTime _fileTimeEpocUtc;
    private static InternalDateTimeExtensions();
    [ExtensionAttribute]
public static DateTime ToDateTime(FILETIME source);
    [ExtensionAttribute]
public static FILETIME ToWin32FileTimeUtc(DateTime source);
}
[PreserveAttribute]
internal class MsgPack.Serialization.DefaultSerializers.MessagePackObjectArraySerializer : MessagePackSerializer`1<MessagePackObject[]> {
    public MessagePackObjectArraySerializer(SerializationContext ownerContext);
    protected internal virtual void PackToCore(Packer packer, MessagePackObject[] objectTree);
    protected internal virtual MessagePackObject[] UnpackFromCore(Unpacker unpacker);
    protected internal virtual void UnpackToCore(Unpacker unpacker, MessagePackObject[] collection);
    private static void UnpackToCore(Unpacker unpacker, MessagePackObject[] collection, int count);
    [AsyncStateMachineAttribute("MsgPack.Serialization.DefaultSerializers.MessagePackObjectArraySerializer/<PackToAsyncCore>d__5")]
protected internal virtual Task PackToAsyncCore(Packer packer, MessagePackObject[] objectTree, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.Serialization.DefaultSerializers.MessagePackObjectArraySerializer/<UnpackFromAsyncCore>d__6")]
protected internal virtual Task`1<MessagePackObject[]> UnpackFromAsyncCore(Unpacker unpacker, CancellationToken cancellationToken);
    protected internal virtual Task UnpackToAsyncCore(Unpacker unpacker, MessagePackObject[] collection, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.Serialization.DefaultSerializers.MessagePackObjectArraySerializer/<UnpackToAsyncCore>d__8")]
private static Task UnpackToAsyncCore(Unpacker unpacker, MessagePackObject[] collection, int count, CancellationToken cancellationToken);
}
[ExtensionAttribute]
internal static class MsgPack.Serialization.DefaultSerializers.MessagePackObjectExtensions : object {
    [ExtensionAttribute]
public static long DeserializeAsInt64(MessagePackObject source);
    [ExtensionAttribute]
public static string DeserializeAsString(MessagePackObject source);
    [ExtensionAttribute]
public static MessagePackExtendedTypeObject DeserializeAsMessagePackExtendedTypeObject(MessagePackObject source);
}
internal class MsgPack.Serialization.DefaultSerializers.MsgPack_MessagePackExtendedTypeObjectMessagePackSerializer : MessagePackSerializer`1<MessagePackExtendedTypeObject> {
    public MsgPack_MessagePackExtendedTypeObjectMessagePackSerializer(SerializationContext ownerContext);
    protected internal virtual void PackToCore(Packer packer, MessagePackExtendedTypeObject value);
    protected internal virtual MessagePackExtendedTypeObject UnpackFromCore(Unpacker unpacker);
    protected internal virtual Task PackToAsyncCore(Packer packer, MessagePackExtendedTypeObject objectTree, CancellationToken cancellationToken);
    protected internal virtual Task`1<MessagePackExtendedTypeObject> UnpackFromAsyncCore(Unpacker unpacker, CancellationToken cancellationToken);
}
internal class MsgPack.Serialization.DefaultSerializers.MsgPack_MessagePackObjectDictionaryMessagePackSerializer : MessagePackSerializer`1<MessagePackObjectDictionary> {
    public MsgPack_MessagePackObjectDictionaryMessagePackSerializer(SerializationContext ownerContext);
    protected internal virtual void PackToCore(Packer packer, MessagePackObjectDictionary objectTree);
    protected internal virtual MessagePackObjectDictionary UnpackFromCore(Unpacker unpacker);
    protected internal virtual void UnpackToCore(Unpacker unpacker, MessagePackObjectDictionary collection);
    private static void UnpackToCore(Unpacker unpacker, int count, MessagePackObjectDictionary collection);
    public sealed virtual object CreateInstance(int initialCapacity);
    [AsyncStateMachineAttribute("MsgPack.Serialization.DefaultSerializers.MsgPack_MessagePackObjectDictionaryMessagePackSerializer/<PackToAsyncCore>d__6")]
protected internal virtual Task PackToAsyncCore(Packer packer, MessagePackObjectDictionary objectTree, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.Serialization.DefaultSerializers.MsgPack_MessagePackObjectDictionaryMessagePackSerializer/<UnpackFromAsyncCore>d__7")]
protected internal virtual Task`1<MessagePackObjectDictionary> UnpackFromAsyncCore(Unpacker unpacker, CancellationToken cancellationToken);
    protected internal virtual Task UnpackToAsyncCore(Unpacker unpacker, MessagePackObjectDictionary collection, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.Serialization.DefaultSerializers.MsgPack_MessagePackObjectDictionaryMessagePackSerializer/<UnpackToAsyncCore>d__9")]
private static Task UnpackToAsyncCore(Unpacker unpacker, int count, MessagePackObjectDictionary collection, CancellationToken cancellationToken);
}
internal class MsgPack.Serialization.DefaultSerializers.MsgPack_MessagePackObjectMessagePackSerializer : MessagePackSerializer`1<MessagePackObject> {
    public MsgPack_MessagePackObjectMessagePackSerializer(SerializationContext ownerContext);
    protected internal virtual void PackToCore(Packer packer, MessagePackObject value);
    protected internal virtual MessagePackObject UnpackFromCore(Unpacker unpacker);
    protected internal virtual Task PackToAsyncCore(Packer packer, MessagePackObject objectTree, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.Serialization.DefaultSerializers.MsgPack_MessagePackObjectMessagePackSerializer/<UnpackFromAsyncCore>d__4")]
protected internal virtual Task`1<MessagePackObject> UnpackFromAsyncCore(Unpacker unpacker, CancellationToken cancellationToken);
}
[PreserveAttribute]
internal class MsgPack.Serialization.DefaultSerializers.MultidimensionalArraySerializer`2 : MessagePackSerializer`1<TArray> {
    private MessagePackSerializer`1<TItem> _itemSerializer;
    private MessagePackSerializer`1<Int32[]> _int32ArraySerializer;
    public MultidimensionalArraySerializer`2(SerializationContext ownerContext, PolymorphismSchema itemsSchema);
    protected internal virtual void PackToCore(Packer packer, TArray objectTree);
    private void PackArrayCore(Packer packer, Array array);
    private static void GetArrayMetadata(Array array, Int32[]& lengths, Int32[]& lowerBounds);
    protected internal virtual TArray UnpackFromCore(Unpacker unpacker);
    private void ReadArrayMetadata(Unpacker metadataUnpacker, Int32[]& lengths, Int32[]& lowerBounds);
    protected internal virtual Task PackToAsyncCore(Packer packer, TArray objectTree, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.Serialization.DefaultSerializers.MultidimensionalArraySerializer`2/<PackArrayAsyncCore>d__9")]
private Task PackArrayAsyncCore(Packer packer, Array array, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.Serialization.DefaultSerializers.MultidimensionalArraySerializer`2/<UnpackFromAsyncCore>d__10")]
protected internal virtual Task`1<TArray> UnpackFromAsyncCore(Unpacker unpacker, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.Serialization.DefaultSerializers.MultidimensionalArraySerializer`2/<ReadArrayMetadataAsync>d__11")]
private Task`1<Tuple`2<Int32[], Int32[]>> ReadArrayMetadataAsync(Unpacker metadataUnpacker, CancellationToken cancellationToken);
    private static void ForEach(Array array, int totalLength, Int32[] lowerBounds, Int32[] lengths, Action`1<Int32[]> action);
    [AsyncStateMachineAttribute("MsgPack.Serialization.DefaultSerializers.MultidimensionalArraySerializer`2/<ForEachAsync>d__13")]
private static Task ForEachAsync(Array array, int totalLength, Int32[] lowerBounds, Int32[] lengths, Func`2<Int32[], Task> action);
}
internal class MsgPack.Serialization.DefaultSerializers.NativeDateTimeMessagePackSerializer : MessagePackSerializer`1<DateTime> {
    public NativeDateTimeMessagePackSerializer(SerializationContext ownerContext);
    protected internal virtual void PackToCore(Packer packer, DateTime objectTree);
    protected internal virtual DateTime UnpackFromCore(Unpacker unpacker);
    protected internal virtual Task PackToAsyncCore(Packer packer, DateTime objectTree, CancellationToken cancellationToken);
    protected internal virtual Task`1<DateTime> UnpackFromAsyncCore(Unpacker unpacker, CancellationToken cancellationToken);
}
internal class MsgPack.Serialization.DefaultSerializers.NativeFileTimeMessagePackSerializer : MessagePackSerializer`1<FILETIME> {
    public NativeFileTimeMessagePackSerializer(SerializationContext ownerContext);
    protected internal virtual void PackToCore(Packer packer, FILETIME objectTree);
    protected internal virtual FILETIME UnpackFromCore(Unpacker unpacker);
    protected internal virtual Task PackToAsyncCore(Packer packer, FILETIME objectTree, CancellationToken cancellationToken);
    protected internal virtual Task`1<FILETIME> UnpackFromAsyncCore(Unpacker unpacker, CancellationToken cancellationToken);
}
[PreserveAttribute]
internal class MsgPack.Serialization.DefaultSerializers.NullableBooleanArraySerializer : MessagePackSerializer`1<Nullable`1[]> {
    public NullableBooleanArraySerializer(SerializationContext ownerContext);
    protected internal virtual void PackToCore(Packer packer, Nullable`1[] objectTree);
    protected internal virtual Nullable`1[] UnpackFromCore(Unpacker unpacker);
    protected internal virtual void UnpackToCore(Unpacker unpacker, Nullable`1[] collection);
    private static void UnpackToCore(Unpacker unpacker, Nullable`1[] collection, int count);
    [AsyncStateMachineAttribute("MsgPack.Serialization.DefaultSerializers.NullableBooleanArraySerializer/<PackToAsyncCore>d__5")]
protected internal virtual Task PackToAsyncCore(Packer packer, Nullable`1[] objectTree, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.Serialization.DefaultSerializers.NullableBooleanArraySerializer/<UnpackFromAsyncCore>d__6")]
protected internal virtual Task`1<Nullable`1[]> UnpackFromAsyncCore(Unpacker unpacker, CancellationToken cancellationToken);
    protected internal virtual Task UnpackToAsyncCore(Unpacker unpacker, Nullable`1[] collection, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.Serialization.DefaultSerializers.NullableBooleanArraySerializer/<UnpackToAsyncCore>d__8")]
private static Task UnpackToAsyncCore(Unpacker unpacker, Nullable`1[] collection, int count, CancellationToken cancellationToken);
}
[PreserveAttribute]
internal class MsgPack.Serialization.DefaultSerializers.NullableByteArraySerializer : MessagePackSerializer`1<Nullable`1[]> {
    public NullableByteArraySerializer(SerializationContext ownerContext);
    protected internal virtual void PackToCore(Packer packer, Nullable`1[] objectTree);
    protected internal virtual Nullable`1[] UnpackFromCore(Unpacker unpacker);
    protected internal virtual void UnpackToCore(Unpacker unpacker, Nullable`1[] collection);
    private static void UnpackToCore(Unpacker unpacker, Nullable`1[] collection, int count);
    [AsyncStateMachineAttribute("MsgPack.Serialization.DefaultSerializers.NullableByteArraySerializer/<PackToAsyncCore>d__5")]
protected internal virtual Task PackToAsyncCore(Packer packer, Nullable`1[] objectTree, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.Serialization.DefaultSerializers.NullableByteArraySerializer/<UnpackFromAsyncCore>d__6")]
protected internal virtual Task`1<Nullable`1[]> UnpackFromAsyncCore(Unpacker unpacker, CancellationToken cancellationToken);
    protected internal virtual Task UnpackToAsyncCore(Unpacker unpacker, Nullable`1[] collection, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.Serialization.DefaultSerializers.NullableByteArraySerializer/<UnpackToAsyncCore>d__8")]
private static Task UnpackToAsyncCore(Unpacker unpacker, Nullable`1[] collection, int count, CancellationToken cancellationToken);
}
[PreserveAttribute]
internal class MsgPack.Serialization.DefaultSerializers.NullableDoubleArraySerializer : MessagePackSerializer`1<Nullable`1[]> {
    public NullableDoubleArraySerializer(SerializationContext ownerContext);
    protected internal virtual void PackToCore(Packer packer, Nullable`1[] objectTree);
    protected internal virtual Nullable`1[] UnpackFromCore(Unpacker unpacker);
    protected internal virtual void UnpackToCore(Unpacker unpacker, Nullable`1[] collection);
    private static void UnpackToCore(Unpacker unpacker, Nullable`1[] collection, int count);
    [AsyncStateMachineAttribute("MsgPack.Serialization.DefaultSerializers.NullableDoubleArraySerializer/<PackToAsyncCore>d__5")]
protected internal virtual Task PackToAsyncCore(Packer packer, Nullable`1[] objectTree, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.Serialization.DefaultSerializers.NullableDoubleArraySerializer/<UnpackFromAsyncCore>d__6")]
protected internal virtual Task`1<Nullable`1[]> UnpackFromAsyncCore(Unpacker unpacker, CancellationToken cancellationToken);
    protected internal virtual Task UnpackToAsyncCore(Unpacker unpacker, Nullable`1[] collection, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.Serialization.DefaultSerializers.NullableDoubleArraySerializer/<UnpackToAsyncCore>d__8")]
private static Task UnpackToAsyncCore(Unpacker unpacker, Nullable`1[] collection, int count, CancellationToken cancellationToken);
}
[PreserveAttribute]
internal class MsgPack.Serialization.DefaultSerializers.NullableInt16ArraySerializer : MessagePackSerializer`1<Nullable`1[]> {
    public NullableInt16ArraySerializer(SerializationContext ownerContext);
    protected internal virtual void PackToCore(Packer packer, Nullable`1[] objectTree);
    protected internal virtual Nullable`1[] UnpackFromCore(Unpacker unpacker);
    protected internal virtual void UnpackToCore(Unpacker unpacker, Nullable`1[] collection);
    private static void UnpackToCore(Unpacker unpacker, Nullable`1[] collection, int count);
    [AsyncStateMachineAttribute("MsgPack.Serialization.DefaultSerializers.NullableInt16ArraySerializer/<PackToAsyncCore>d__5")]
protected internal virtual Task PackToAsyncCore(Packer packer, Nullable`1[] objectTree, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.Serialization.DefaultSerializers.NullableInt16ArraySerializer/<UnpackFromAsyncCore>d__6")]
protected internal virtual Task`1<Nullable`1[]> UnpackFromAsyncCore(Unpacker unpacker, CancellationToken cancellationToken);
    protected internal virtual Task UnpackToAsyncCore(Unpacker unpacker, Nullable`1[] collection, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.Serialization.DefaultSerializers.NullableInt16ArraySerializer/<UnpackToAsyncCore>d__8")]
private static Task UnpackToAsyncCore(Unpacker unpacker, Nullable`1[] collection, int count, CancellationToken cancellationToken);
}
[PreserveAttribute]
internal class MsgPack.Serialization.DefaultSerializers.NullableInt32ArraySerializer : MessagePackSerializer`1<Nullable`1[]> {
    public NullableInt32ArraySerializer(SerializationContext ownerContext);
    protected internal virtual void PackToCore(Packer packer, Nullable`1[] objectTree);
    protected internal virtual Nullable`1[] UnpackFromCore(Unpacker unpacker);
    protected internal virtual void UnpackToCore(Unpacker unpacker, Nullable`1[] collection);
    private static void UnpackToCore(Unpacker unpacker, Nullable`1[] collection, int count);
    [AsyncStateMachineAttribute("MsgPack.Serialization.DefaultSerializers.NullableInt32ArraySerializer/<PackToAsyncCore>d__5")]
protected internal virtual Task PackToAsyncCore(Packer packer, Nullable`1[] objectTree, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.Serialization.DefaultSerializers.NullableInt32ArraySerializer/<UnpackFromAsyncCore>d__6")]
protected internal virtual Task`1<Nullable`1[]> UnpackFromAsyncCore(Unpacker unpacker, CancellationToken cancellationToken);
    protected internal virtual Task UnpackToAsyncCore(Unpacker unpacker, Nullable`1[] collection, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.Serialization.DefaultSerializers.NullableInt32ArraySerializer/<UnpackToAsyncCore>d__8")]
private static Task UnpackToAsyncCore(Unpacker unpacker, Nullable`1[] collection, int count, CancellationToken cancellationToken);
}
[PreserveAttribute]
internal class MsgPack.Serialization.DefaultSerializers.NullableInt64ArraySerializer : MessagePackSerializer`1<Nullable`1[]> {
    public NullableInt64ArraySerializer(SerializationContext ownerContext);
    protected internal virtual void PackToCore(Packer packer, Nullable`1[] objectTree);
    protected internal virtual Nullable`1[] UnpackFromCore(Unpacker unpacker);
    protected internal virtual void UnpackToCore(Unpacker unpacker, Nullable`1[] collection);
    private static void UnpackToCore(Unpacker unpacker, Nullable`1[] collection, int count);
    [AsyncStateMachineAttribute("MsgPack.Serialization.DefaultSerializers.NullableInt64ArraySerializer/<PackToAsyncCore>d__5")]
protected internal virtual Task PackToAsyncCore(Packer packer, Nullable`1[] objectTree, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.Serialization.DefaultSerializers.NullableInt64ArraySerializer/<UnpackFromAsyncCore>d__6")]
protected internal virtual Task`1<Nullable`1[]> UnpackFromAsyncCore(Unpacker unpacker, CancellationToken cancellationToken);
    protected internal virtual Task UnpackToAsyncCore(Unpacker unpacker, Nullable`1[] collection, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.Serialization.DefaultSerializers.NullableInt64ArraySerializer/<UnpackToAsyncCore>d__8")]
private static Task UnpackToAsyncCore(Unpacker unpacker, Nullable`1[] collection, int count, CancellationToken cancellationToken);
}
[PreserveAttribute]
internal class MsgPack.Serialization.DefaultSerializers.NullableMessagePackSerializer`1 : MessagePackSerializer`1<Nullable`1<T>> {
    private MessagePackSerializer`1<T> _valueSerializer;
    public NullableMessagePackSerializer`1(SerializationContext ownerContext);
    public NullableMessagePackSerializer`1(SerializationContext ownerContext, MessagePackSerializer`1<T> valueSerializer);
    protected internal virtual void PackToCore(Packer packer, Nullable`1<T> objectTree);
    protected internal virtual Nullable`1<T> UnpackFromCore(Unpacker unpacker);
    protected internal virtual Task PackToAsyncCore(Packer packer, Nullable`1<T> objectTree, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.Serialization.DefaultSerializers.NullableMessagePackSerializer`1/<UnpackFromAsyncCore>d__6")]
protected internal virtual Task`1<Nullable`1<T>> UnpackFromAsyncCore(Unpacker unpacker, CancellationToken cancellationToken);
}
[PreserveAttribute]
internal class MsgPack.Serialization.DefaultSerializers.NullableSByteArraySerializer : MessagePackSerializer`1<Nullable`1[]> {
    public NullableSByteArraySerializer(SerializationContext ownerContext);
    protected internal virtual void PackToCore(Packer packer, Nullable`1[] objectTree);
    protected internal virtual Nullable`1[] UnpackFromCore(Unpacker unpacker);
    protected internal virtual void UnpackToCore(Unpacker unpacker, Nullable`1[] collection);
    private static void UnpackToCore(Unpacker unpacker, Nullable`1[] collection, int count);
    [AsyncStateMachineAttribute("MsgPack.Serialization.DefaultSerializers.NullableSByteArraySerializer/<PackToAsyncCore>d__5")]
protected internal virtual Task PackToAsyncCore(Packer packer, Nullable`1[] objectTree, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.Serialization.DefaultSerializers.NullableSByteArraySerializer/<UnpackFromAsyncCore>d__6")]
protected internal virtual Task`1<Nullable`1[]> UnpackFromAsyncCore(Unpacker unpacker, CancellationToken cancellationToken);
    protected internal virtual Task UnpackToAsyncCore(Unpacker unpacker, Nullable`1[] collection, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.Serialization.DefaultSerializers.NullableSByteArraySerializer/<UnpackToAsyncCore>d__8")]
private static Task UnpackToAsyncCore(Unpacker unpacker, Nullable`1[] collection, int count, CancellationToken cancellationToken);
}
[PreserveAttribute]
internal class MsgPack.Serialization.DefaultSerializers.NullableSingleArraySerializer : MessagePackSerializer`1<Nullable`1[]> {
    public NullableSingleArraySerializer(SerializationContext ownerContext);
    protected internal virtual void PackToCore(Packer packer, Nullable`1[] objectTree);
    protected internal virtual Nullable`1[] UnpackFromCore(Unpacker unpacker);
    protected internal virtual void UnpackToCore(Unpacker unpacker, Nullable`1[] collection);
    private static void UnpackToCore(Unpacker unpacker, Nullable`1[] collection, int count);
    [AsyncStateMachineAttribute("MsgPack.Serialization.DefaultSerializers.NullableSingleArraySerializer/<PackToAsyncCore>d__5")]
protected internal virtual Task PackToAsyncCore(Packer packer, Nullable`1[] objectTree, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.Serialization.DefaultSerializers.NullableSingleArraySerializer/<UnpackFromAsyncCore>d__6")]
protected internal virtual Task`1<Nullable`1[]> UnpackFromAsyncCore(Unpacker unpacker, CancellationToken cancellationToken);
    protected internal virtual Task UnpackToAsyncCore(Unpacker unpacker, Nullable`1[] collection, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.Serialization.DefaultSerializers.NullableSingleArraySerializer/<UnpackToAsyncCore>d__8")]
private static Task UnpackToAsyncCore(Unpacker unpacker, Nullable`1[] collection, int count, CancellationToken cancellationToken);
}
[PreserveAttribute]
internal class MsgPack.Serialization.DefaultSerializers.NullableUInt16ArraySerializer : MessagePackSerializer`1<Nullable`1[]> {
    public NullableUInt16ArraySerializer(SerializationContext ownerContext);
    protected internal virtual void PackToCore(Packer packer, Nullable`1[] objectTree);
    protected internal virtual Nullable`1[] UnpackFromCore(Unpacker unpacker);
    protected internal virtual void UnpackToCore(Unpacker unpacker, Nullable`1[] collection);
    private static void UnpackToCore(Unpacker unpacker, Nullable`1[] collection, int count);
    [AsyncStateMachineAttribute("MsgPack.Serialization.DefaultSerializers.NullableUInt16ArraySerializer/<PackToAsyncCore>d__5")]
protected internal virtual Task PackToAsyncCore(Packer packer, Nullable`1[] objectTree, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.Serialization.DefaultSerializers.NullableUInt16ArraySerializer/<UnpackFromAsyncCore>d__6")]
protected internal virtual Task`1<Nullable`1[]> UnpackFromAsyncCore(Unpacker unpacker, CancellationToken cancellationToken);
    protected internal virtual Task UnpackToAsyncCore(Unpacker unpacker, Nullable`1[] collection, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.Serialization.DefaultSerializers.NullableUInt16ArraySerializer/<UnpackToAsyncCore>d__8")]
private static Task UnpackToAsyncCore(Unpacker unpacker, Nullable`1[] collection, int count, CancellationToken cancellationToken);
}
[PreserveAttribute]
internal class MsgPack.Serialization.DefaultSerializers.NullableUInt32ArraySerializer : MessagePackSerializer`1<Nullable`1[]> {
    public NullableUInt32ArraySerializer(SerializationContext ownerContext);
    protected internal virtual void PackToCore(Packer packer, Nullable`1[] objectTree);
    protected internal virtual Nullable`1[] UnpackFromCore(Unpacker unpacker);
    protected internal virtual void UnpackToCore(Unpacker unpacker, Nullable`1[] collection);
    private static void UnpackToCore(Unpacker unpacker, Nullable`1[] collection, int count);
    [AsyncStateMachineAttribute("MsgPack.Serialization.DefaultSerializers.NullableUInt32ArraySerializer/<PackToAsyncCore>d__5")]
protected internal virtual Task PackToAsyncCore(Packer packer, Nullable`1[] objectTree, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.Serialization.DefaultSerializers.NullableUInt32ArraySerializer/<UnpackFromAsyncCore>d__6")]
protected internal virtual Task`1<Nullable`1[]> UnpackFromAsyncCore(Unpacker unpacker, CancellationToken cancellationToken);
    protected internal virtual Task UnpackToAsyncCore(Unpacker unpacker, Nullable`1[] collection, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.Serialization.DefaultSerializers.NullableUInt32ArraySerializer/<UnpackToAsyncCore>d__8")]
private static Task UnpackToAsyncCore(Unpacker unpacker, Nullable`1[] collection, int count, CancellationToken cancellationToken);
}
[PreserveAttribute]
internal class MsgPack.Serialization.DefaultSerializers.NullableUInt64ArraySerializer : MessagePackSerializer`1<Nullable`1[]> {
    public NullableUInt64ArraySerializer(SerializationContext ownerContext);
    protected internal virtual void PackToCore(Packer packer, Nullable`1[] objectTree);
    protected internal virtual Nullable`1[] UnpackFromCore(Unpacker unpacker);
    protected internal virtual void UnpackToCore(Unpacker unpacker, Nullable`1[] collection);
    private static void UnpackToCore(Unpacker unpacker, Nullable`1[] collection, int count);
    [AsyncStateMachineAttribute("MsgPack.Serialization.DefaultSerializers.NullableUInt64ArraySerializer/<PackToAsyncCore>d__5")]
protected internal virtual Task PackToAsyncCore(Packer packer, Nullable`1[] objectTree, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.Serialization.DefaultSerializers.NullableUInt64ArraySerializer/<UnpackFromAsyncCore>d__6")]
protected internal virtual Task`1<Nullable`1[]> UnpackFromAsyncCore(Unpacker unpacker, CancellationToken cancellationToken);
    protected internal virtual Task UnpackToAsyncCore(Unpacker unpacker, Nullable`1[] collection, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.Serialization.DefaultSerializers.NullableUInt64ArraySerializer/<UnpackToAsyncCore>d__8")]
private static Task UnpackToAsyncCore(Unpacker unpacker, Nullable`1[] collection, int count, CancellationToken cancellationToken);
}
[PreserveAttribute]
internal class MsgPack.Serialization.DefaultSerializers.SByteArraySerializer : MessagePackSerializer`1<SByte[]> {
    public SByteArraySerializer(SerializationContext ownerContext);
    protected internal virtual void PackToCore(Packer packer, SByte[] objectTree);
    protected internal virtual SByte[] UnpackFromCore(Unpacker unpacker);
    protected internal virtual void UnpackToCore(Unpacker unpacker, SByte[] collection);
    private static void UnpackToCore(Unpacker unpacker, SByte[] collection, int count);
    [AsyncStateMachineAttribute("MsgPack.Serialization.DefaultSerializers.SByteArraySerializer/<PackToAsyncCore>d__5")]
protected internal virtual Task PackToAsyncCore(Packer packer, SByte[] objectTree, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.Serialization.DefaultSerializers.SByteArraySerializer/<UnpackFromAsyncCore>d__6")]
protected internal virtual Task`1<SByte[]> UnpackFromAsyncCore(Unpacker unpacker, CancellationToken cancellationToken);
    protected internal virtual Task UnpackToAsyncCore(Unpacker unpacker, SByte[] collection, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.Serialization.DefaultSerializers.SByteArraySerializer/<UnpackToAsyncCore>d__8")]
private static Task UnpackToAsyncCore(Unpacker unpacker, SByte[] collection, int count, CancellationToken cancellationToken);
}
[PreserveAttribute]
internal class MsgPack.Serialization.DefaultSerializers.SingleArraySerializer : MessagePackSerializer`1<Single[]> {
    public SingleArraySerializer(SerializationContext ownerContext);
    protected internal virtual void PackToCore(Packer packer, Single[] objectTree);
    protected internal virtual Single[] UnpackFromCore(Unpacker unpacker);
    protected internal virtual void UnpackToCore(Unpacker unpacker, Single[] collection);
    private static void UnpackToCore(Unpacker unpacker, Single[] collection, int count);
    [AsyncStateMachineAttribute("MsgPack.Serialization.DefaultSerializers.SingleArraySerializer/<PackToAsyncCore>d__5")]
protected internal virtual Task PackToAsyncCore(Packer packer, Single[] objectTree, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.Serialization.DefaultSerializers.SingleArraySerializer/<UnpackFromAsyncCore>d__6")]
protected internal virtual Task`1<Single[]> UnpackFromAsyncCore(Unpacker unpacker, CancellationToken cancellationToken);
    protected internal virtual Task UnpackToAsyncCore(Unpacker unpacker, Single[] collection, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.Serialization.DefaultSerializers.SingleArraySerializer/<UnpackToAsyncCore>d__8")]
private static Task UnpackToAsyncCore(Unpacker unpacker, Single[] collection, int count, CancellationToken cancellationToken);
}
[PreserveAttribute]
internal class MsgPack.Serialization.DefaultSerializers.StringArraySerializer : MessagePackSerializer`1<String[]> {
    public StringArraySerializer(SerializationContext ownerContext);
    protected internal virtual void PackToCore(Packer packer, String[] objectTree);
    protected internal virtual String[] UnpackFromCore(Unpacker unpacker);
    protected internal virtual void UnpackToCore(Unpacker unpacker, String[] collection);
    private static void UnpackToCore(Unpacker unpacker, String[] collection, int count);
    [AsyncStateMachineAttribute("MsgPack.Serialization.DefaultSerializers.StringArraySerializer/<PackToAsyncCore>d__5")]
protected internal virtual Task PackToAsyncCore(Packer packer, String[] objectTree, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.Serialization.DefaultSerializers.StringArraySerializer/<UnpackFromAsyncCore>d__6")]
protected internal virtual Task`1<String[]> UnpackFromAsyncCore(Unpacker unpacker, CancellationToken cancellationToken);
    protected internal virtual Task UnpackToAsyncCore(Unpacker unpacker, String[] collection, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.Serialization.DefaultSerializers.StringArraySerializer/<UnpackToAsyncCore>d__8")]
private static Task UnpackToAsyncCore(Unpacker unpacker, String[] collection, int count, CancellationToken cancellationToken);
}
[PreserveAttribute]
internal class MsgPack.Serialization.DefaultSerializers.System_ArraySegment_1MessagePackSerializer`1 : MessagePackSerializer`1<ArraySegment`1<T>> {
    private static Action`3<Packer, ArraySegment`1<T>, MessagePackSerializer`1<T>> _packing;
    private static Func`3<Unpacker, MessagePackSerializer`1<T>, ArraySegment`1<T>> _unpacking;
    private static Func`5<Packer, ArraySegment`1<T>, MessagePackSerializer`1<T>, CancellationToken, Task> _asyncPacking;
    private static Func`4<Unpacker, MessagePackSerializer`1<T>, CancellationToken, Task`1<ArraySegment`1<T>>> _asyncUnpacking;
    private MessagePackSerializer`1<T> _itemSerializer;
    public System_ArraySegment_1MessagePackSerializer`1(SerializationContext ownerContext);
    private static System_ArraySegment_1MessagePackSerializer`1();
    private static Action`3<Packer, ArraySegment`1<T>, MessagePackSerializer`1<T>> InitializePacking();
    private static Func`3<Unpacker, MessagePackSerializer`1<T>, ArraySegment`1<T>> InitializeUnpacking();
    private static Func`5<Packer, ArraySegment`1<T>, MessagePackSerializer`1<T>, CancellationToken, Task> InitializeAsyncPacking();
    private static Func`4<Unpacker, MessagePackSerializer`1<T>, CancellationToken, Task`1<ArraySegment`1<T>>> InitializeAsyncUnpacking();
    protected internal sealed virtual void PackToCore(Packer packer, ArraySegment`1<T> objectTree);
    protected internal sealed virtual ArraySegment`1<T> UnpackFromCore(Unpacker unpacker);
    protected internal virtual Task PackToAsyncCore(Packer packer, ArraySegment`1<T> objectTree, CancellationToken cancellationToken);
    protected internal virtual Task`1<ArraySegment`1<T>> UnpackFromAsyncCore(Unpacker unpacker, CancellationToken cancellationToken);
}
internal class MsgPack.Serialization.DefaultSerializers.System_BooleanMessagePackSerializer : MessagePackSerializer`1<bool> {
    public System_BooleanMessagePackSerializer(SerializationContext ownerContext);
    protected internal virtual void PackToCore(Packer packer, bool value);
    protected internal virtual bool UnpackFromCore(Unpacker unpacker);
    [AsyncStateMachineAttribute("MsgPack.Serialization.DefaultSerializers.System_BooleanMessagePackSerializer/<PackToAsyncCore>d__3")]
protected internal virtual Task PackToAsyncCore(Packer packer, bool value, CancellationToken cancellationToken);
    protected internal virtual Task`1<bool> UnpackFromAsyncCore(Unpacker unpacker, CancellationToken cancellationToken);
}
internal class MsgPack.Serialization.DefaultSerializers.System_ByteArrayMessagePackSerializer : MessagePackSerializer`1<Byte[]> {
    public System_ByteArrayMessagePackSerializer(SerializationContext ownerContext);
    protected internal virtual void PackToCore(Packer packer, Byte[] value);
    protected internal virtual Byte[] UnpackFromCore(Unpacker unpacker);
    protected internal virtual Task PackToAsyncCore(Packer packer, Byte[] objectTree, CancellationToken cancellationToken);
    protected internal virtual Task`1<Byte[]> UnpackFromAsyncCore(Unpacker unpacker, CancellationToken cancellationToken);
}
internal class MsgPack.Serialization.DefaultSerializers.System_ByteMessagePackSerializer : MessagePackSerializer`1<byte> {
    public System_ByteMessagePackSerializer(SerializationContext ownerContext);
    protected internal virtual void PackToCore(Packer packer, byte value);
    protected internal virtual byte UnpackFromCore(Unpacker unpacker);
    [AsyncStateMachineAttribute("MsgPack.Serialization.DefaultSerializers.System_ByteMessagePackSerializer/<PackToAsyncCore>d__3")]
protected internal virtual Task PackToAsyncCore(Packer packer, byte value, CancellationToken cancellationToken);
    protected internal virtual Task`1<byte> UnpackFromAsyncCore(Unpacker unpacker, CancellationToken cancellationToken);
}
internal class MsgPack.Serialization.DefaultSerializers.System_CharArrayMessagePackSerializer : MessagePackSerializer`1<Char[]> {
    public System_CharArrayMessagePackSerializer(SerializationContext ownerContext);
    protected internal virtual void PackToCore(Packer packer, Char[] value);
    protected internal virtual Char[] UnpackFromCore(Unpacker unpacker);
    protected internal virtual Task PackToAsyncCore(Packer packer, Char[] objectTree, CancellationToken cancellationToken);
    protected internal virtual Task`1<Char[]> UnpackFromAsyncCore(Unpacker unpacker, CancellationToken cancellationToken);
}
internal class MsgPack.Serialization.DefaultSerializers.System_CharMessagePackSerializer : MessagePackSerializer`1<char> {
    public System_CharMessagePackSerializer(SerializationContext ownerContext);
    protected internal virtual void PackToCore(Packer packer, char value);
    protected internal virtual char UnpackFromCore(Unpacker unpacker);
    [AsyncStateMachineAttribute("MsgPack.Serialization.DefaultSerializers.System_CharMessagePackSerializer/<PackToAsyncCore>d__3")]
protected internal virtual Task PackToAsyncCore(Packer packer, char value, CancellationToken cancellationToken);
    protected internal virtual Task`1<char> UnpackFromAsyncCore(Unpacker unpacker, CancellationToken cancellationToken);
}
[PreserveAttribute]
internal class MsgPack.Serialization.DefaultSerializers.System_Collections_DictionaryEntryMessagePackSerializer : MessagePackSerializer`1<DictionaryEntry> {
    public System_Collections_DictionaryEntryMessagePackSerializer(SerializationContext ownerContext);
    protected internal virtual void PackToCore(Packer packer, DictionaryEntry objectTree);
    private static MessagePackObject EnsureMessagePackObject(object obj);
    protected internal virtual DictionaryEntry UnpackFromCore(Unpacker unpacker);
    [AsyncStateMachineAttribute("MsgPack.Serialization.DefaultSerializers.System_Collections_DictionaryEntryMessagePackSerializer/<PackToAsyncCore>d__4")]
protected internal virtual Task PackToAsyncCore(Packer packer, DictionaryEntry objectTree, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.Serialization.DefaultSerializers.System_Collections_DictionaryEntryMessagePackSerializer/<UnpackFromAsyncCore>d__5")]
protected internal virtual Task`1<DictionaryEntry> UnpackFromAsyncCore(Unpacker unpacker, CancellationToken cancellationToken);
}
[PreserveAttribute]
internal class MsgPack.Serialization.DefaultSerializers.System_Collections_Generic_Dictionary_2MessagePackSerializer`2 : MessagePackSerializer`1<Dictionary`2<TKey, TValue>> {
    private MessagePackSerializer`1<TKey> _keySerializer;
    private MessagePackSerializer`1<TValue> _valueSerializer;
    public System_Collections_Generic_Dictionary_2MessagePackSerializer`2(SerializationContext ownerContext, PolymorphismSchema keysSchema, PolymorphismSchema valuesSchema);
    protected internal virtual void PackToCore(Packer packer, Dictionary`2<TKey, TValue> objectTree);
    protected internal virtual Dictionary`2<TKey, TValue> UnpackFromCore(Unpacker unpacker);
    protected internal virtual void UnpackToCore(Unpacker unpacker, Dictionary`2<TKey, TValue> collection);
    private void UnpackToCore(Unpacker unpacker, Dictionary`2<TKey, TValue> collection, int count);
    public sealed virtual object CreateInstance(int initialCapacity);
    protected internal virtual Task PackToAsyncCore(Packer packer, Dictionary`2<TKey, TValue> objectTree, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.Serialization.DefaultSerializers.System_Collections_Generic_Dictionary_2MessagePackSerializer`2/<UnpackFromAsyncCore>d__9")]
protected internal virtual Task`1<Dictionary`2<TKey, TValue>> UnpackFromAsyncCore(Unpacker unpacker, CancellationToken cancellationToken);
    protected internal virtual Task UnpackToAsyncCore(Unpacker unpacker, Dictionary`2<TKey, TValue> collection, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.Serialization.DefaultSerializers.System_Collections_Generic_Dictionary_2MessagePackSerializer`2/<UnpackToAsyncCore>d__11")]
private Task UnpackToAsyncCore(Unpacker unpacker, Dictionary`2<TKey, TValue> collection, int count, CancellationToken cancellationToken);
}
[PreserveAttribute]
internal class MsgPack.Serialization.DefaultSerializers.System_Collections_Generic_KeyValuePair_2MessagePackSerializer`2 : MessagePackSerializer`1<KeyValuePair`2<TKey, TValue>> {
    private MessagePackSerializer`1<TKey> _keySerializer;
    private MessagePackSerializer`1<TValue> _valueSerializer;
    public System_Collections_Generic_KeyValuePair_2MessagePackSerializer`2(SerializationContext ownerContext);
    protected internal virtual void PackToCore(Packer packer, KeyValuePair`2<TKey, TValue> objectTree);
    protected internal virtual KeyValuePair`2<TKey, TValue> UnpackFromCore(Unpacker unpacker);
    [AsyncStateMachineAttribute("MsgPack.Serialization.DefaultSerializers.System_Collections_Generic_KeyValuePair_2MessagePackSerializer`2/<PackToAsyncCore>d__5")]
protected internal virtual Task PackToAsyncCore(Packer packer, KeyValuePair`2<TKey, TValue> objectTree, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.Serialization.DefaultSerializers.System_Collections_Generic_KeyValuePair_2MessagePackSerializer`2/<UnpackFromAsyncCore>d__6")]
protected internal virtual Task`1<KeyValuePair`2<TKey, TValue>> UnpackFromAsyncCore(Unpacker unpacker, CancellationToken cancellationToken);
}
[PreserveAttribute]
internal class MsgPack.Serialization.DefaultSerializers.System_Collections_Generic_List_1MessagePackSerializer`1 : MessagePackSerializer`1<List`1<T>> {
    private MessagePackSerializer`1<T> _itemSerializer;
    public System_Collections_Generic_List_1MessagePackSerializer`1(SerializationContext ownerContext, PolymorphismSchema itemsSchema);
    protected internal virtual void PackToCore(Packer packer, List`1<T> objectTree);
    protected internal virtual List`1<T> UnpackFromCore(Unpacker unpacker);
    protected internal virtual void UnpackToCore(Unpacker unpacker, List`1<T> collection);
    private void UnpackToCore(Unpacker unpacker, List`1<T> collection, int count);
    public sealed virtual object CreateInstance(int initialCapacity);
    protected internal virtual Task PackToAsyncCore(Packer packer, List`1<T> objectTree, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.Serialization.DefaultSerializers.System_Collections_Generic_List_1MessagePackSerializer`1/<UnpackFromAsyncCore>d__8")]
protected internal virtual Task`1<List`1<T>> UnpackFromAsyncCore(Unpacker unpacker, CancellationToken cancellationToken);
    protected internal virtual Task UnpackToAsyncCore(Unpacker unpacker, List`1<T> collection, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.Serialization.DefaultSerializers.System_Collections_Generic_List_1MessagePackSerializer`1/<UnpackToAsyncCore>d__10")]
private Task UnpackToAsyncCore(Unpacker unpacker, List`1<T> collection, int count, CancellationToken cancellationToken);
}
internal class MsgPack.Serialization.DefaultSerializers.System_Collections_Generic_ListOfMessagePackObjectMessagePackSerializer : MessagePackSerializer`1<List`1<MessagePackObject>> {
    public System_Collections_Generic_ListOfMessagePackObjectMessagePackSerializer(SerializationContext ownerContext);
    protected internal virtual void PackToCore(Packer packer, List`1<MessagePackObject> objectTree);
    protected internal virtual List`1<MessagePackObject> UnpackFromCore(Unpacker unpacker);
    protected internal virtual void UnpackToCore(Unpacker unpacker, List`1<MessagePackObject> collection);
    private static void UnpackToCore(Unpacker unpacker, List`1<MessagePackObject> collection, int count);
    public sealed virtual object CreateInstance(int initialCapacity);
    [AsyncStateMachineAttribute("MsgPack.Serialization.DefaultSerializers.System_Collections_Generic_ListOfMessagePackObjectMessagePackSerializer/<PackToAsyncCore>d__6")]
protected internal virtual Task PackToAsyncCore(Packer packer, List`1<MessagePackObject> objectTree, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.Serialization.DefaultSerializers.System_Collections_Generic_ListOfMessagePackObjectMessagePackSerializer/<UnpackFromAsyncCore>d__7")]
protected internal virtual Task`1<List`1<MessagePackObject>> UnpackFromAsyncCore(Unpacker unpacker, CancellationToken cancellationToken);
    protected internal virtual Task UnpackToAsyncCore(Unpacker unpacker, List`1<MessagePackObject> collection, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.Serialization.DefaultSerializers.System_Collections_Generic_ListOfMessagePackObjectMessagePackSerializer/<UnpackToAsyncCore>d__9")]
private static Task UnpackToAsyncCore(Unpacker unpacker, List`1<MessagePackObject> collection, int count, CancellationToken cancellationToken);
}
[PreserveAttribute]
internal class MsgPack.Serialization.DefaultSerializers.System_Collections_Generic_Queue_1MessagePackSerializer`1 : MessagePackSerializer`1<Queue`1<TItem>> {
    private MessagePackSerializer`1<TItem> _itemSerializer;
    public System_Collections_Generic_Queue_1MessagePackSerializer`1(SerializationContext ownerContext);
    protected internal virtual void PackToCore(Packer packer, Queue`1<TItem> objectTree);
    protected internal virtual Queue`1<TItem> UnpackFromCore(Unpacker unpacker);
    protected internal virtual void UnpackToCore(Unpacker unpacker, Queue`1<TItem> collection);
    public sealed virtual object CreateInstance(int initialCapacity);
    [AsyncStateMachineAttribute("MsgPack.Serialization.DefaultSerializers.System_Collections_Generic_Queue_1MessagePackSerializer`1/<PackToAsyncCore>d__6")]
protected internal virtual Task PackToAsyncCore(Packer packer, Queue`1<TItem> objectTree, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.Serialization.DefaultSerializers.System_Collections_Generic_Queue_1MessagePackSerializer`1/<UnpackFromAsyncCore>d__7")]
protected internal virtual Task`1<Queue`1<TItem>> UnpackFromAsyncCore(Unpacker unpacker, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.Serialization.DefaultSerializers.System_Collections_Generic_Queue_1MessagePackSerializer`1/<UnpackToAsyncCore>d__8")]
protected internal virtual Task UnpackToAsyncCore(Unpacker unpacker, Queue`1<TItem> collection, CancellationToken cancellationToken);
}
[PreserveAttribute]
internal class MsgPack.Serialization.DefaultSerializers.System_Collections_Generic_Stack_1MessagePackSerializer`1 : MessagePackSerializer`1<Stack`1<TItem>> {
    private MessagePackSerializer`1<TItem> _itemSerializer;
    public System_Collections_Generic_Stack_1MessagePackSerializer`1(SerializationContext ownerContext);
    protected internal virtual void PackToCore(Packer packer, Stack`1<TItem> objectTree);
    protected internal virtual Stack`1<TItem> UnpackFromCore(Unpacker unpacker);
    protected internal virtual void UnpackToCore(Unpacker unpacker, Stack`1<TItem> collection);
    private IEnumerable`1<TItem> UnpackItemsInReverseOrder(Unpacker unpacker, int count);
    public sealed virtual object CreateInstance(int initialCapacity);
    [AsyncStateMachineAttribute("MsgPack.Serialization.DefaultSerializers.System_Collections_Generic_Stack_1MessagePackSerializer`1/<PackToAsyncCore>d__7")]
protected internal virtual Task PackToAsyncCore(Packer packer, Stack`1<TItem> objectTree, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.Serialization.DefaultSerializers.System_Collections_Generic_Stack_1MessagePackSerializer`1/<UnpackFromAsyncCore>d__8")]
protected internal virtual Task`1<Stack`1<TItem>> UnpackFromAsyncCore(Unpacker unpacker, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.Serialization.DefaultSerializers.System_Collections_Generic_Stack_1MessagePackSerializer`1/<UnpackToAsyncCore>d__9")]
protected internal virtual Task UnpackToAsyncCore(Unpacker unpacker, Stack`1<TItem> collection, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.Serialization.DefaultSerializers.System_Collections_Generic_Stack_1MessagePackSerializer`1/<UnpackItemsInReverseOrderAsync>d__10")]
private Task`1<IEnumerable`1<TItem>> UnpackItemsInReverseOrderAsync(Unpacker unpacker, int count, CancellationToken cancellationToken);
}
internal class MsgPack.Serialization.DefaultSerializers.System_Collections_QueueMessagePackSerializer : MessagePackSerializer`1<Queue> {
    public System_Collections_QueueMessagePackSerializer(SerializationContext ownerContext);
    protected internal virtual void PackToCore(Packer packer, Queue objectTree);
    protected internal virtual Queue UnpackFromCore(Unpacker unpacker);
    protected internal virtual void UnpackToCore(Unpacker unpacker, Queue collection);
    public sealed virtual object CreateInstance(int initialCapacity);
    [AsyncStateMachineAttribute("MsgPack.Serialization.DefaultSerializers.System_Collections_QueueMessagePackSerializer/<PackToAsyncCore>d__5")]
protected internal virtual Task PackToAsyncCore(Packer packer, Queue objectTree, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.Serialization.DefaultSerializers.System_Collections_QueueMessagePackSerializer/<UnpackFromAsyncCore>d__6")]
protected internal virtual Task`1<Queue> UnpackFromAsyncCore(Unpacker unpacker, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.Serialization.DefaultSerializers.System_Collections_QueueMessagePackSerializer/<UnpackToAsyncCore>d__7")]
protected internal virtual Task UnpackToAsyncCore(Unpacker unpacker, Queue collection, CancellationToken cancellationToken);
}
internal class MsgPack.Serialization.DefaultSerializers.System_Collections_Specialized_BitVector32MessagePackSerializer : MessagePackSerializer`1<BitVector32> {
    public System_Collections_Specialized_BitVector32MessagePackSerializer(SerializationContext ownerContext);
    protected internal virtual void PackToCore(Packer packer, BitVector32 value);
    protected internal virtual BitVector32 UnpackFromCore(Unpacker unpacker);
    [AsyncStateMachineAttribute("MsgPack.Serialization.DefaultSerializers.System_Collections_Specialized_BitVector32MessagePackSerializer/<PackToAsyncCore>d__3")]
protected internal virtual Task PackToAsyncCore(Packer packer, BitVector32 value, CancellationToken cancellationToken);
    protected internal virtual Task`1<BitVector32> UnpackFromAsyncCore(Unpacker unpacker, CancellationToken cancellationToken);
}
internal class MsgPack.Serialization.DefaultSerializers.System_Collections_Specialized_NameValueCollectionMessagePackSerializer : MessagePackSerializer`1<NameValueCollection> {
    public System_Collections_Specialized_NameValueCollectionMessagePackSerializer(SerializationContext ownerContext);
    protected internal virtual void PackToCore(Packer packer, NameValueCollection objectTree);
    protected internal virtual NameValueCollection UnpackFromCore(Unpacker unpacker);
    protected internal virtual void UnpackToCore(Unpacker unpacker, NameValueCollection collection);
    private static void UnpackToCore(Unpacker unpacker, NameValueCollection collection, int keyCount);
    public sealed virtual object CreateInstance(int initialCapacity);
    [AsyncStateMachineAttribute("MsgPack.Serialization.DefaultSerializers.System_Collections_Specialized_NameValueCollectionMessagePackSerializer/<PackToAsyncCore>d__6")]
protected internal virtual Task PackToAsyncCore(Packer packer, NameValueCollection objectTree, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.Serialization.DefaultSerializers.System_Collections_Specialized_NameValueCollectionMessagePackSerializer/<UnpackFromAsyncCore>d__7")]
protected internal virtual Task`1<NameValueCollection> UnpackFromAsyncCore(Unpacker unpacker, CancellationToken cancellationToken);
    protected internal virtual Task UnpackToAsyncCore(Unpacker unpacker, NameValueCollection collection, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.Serialization.DefaultSerializers.System_Collections_Specialized_NameValueCollectionMessagePackSerializer/<UnpackToAsyncCore>d__9")]
private static Task UnpackToAsyncCore(Unpacker unpacker, NameValueCollection collection, int keyCount, CancellationToken cancellationToken);
}
internal class MsgPack.Serialization.DefaultSerializers.System_Collections_StackMessagePackSerializer : MessagePackSerializer`1<Stack> {
    public System_Collections_StackMessagePackSerializer(SerializationContext ownerContext);
    protected internal virtual void PackToCore(Packer packer, Stack objectTree);
    protected internal virtual Stack UnpackFromCore(Unpacker unpacker);
    protected internal virtual void UnpackToCore(Unpacker unpacker, Stack collection);
    private static ICollection UnpackItemsInReverseOrder(Unpacker unpacker, int count);
    public sealed virtual object CreateInstance(int initialCapacity);
    [AsyncStateMachineAttribute("MsgPack.Serialization.DefaultSerializers.System_Collections_StackMessagePackSerializer/<PackToAsyncCore>d__6")]
protected internal virtual Task PackToAsyncCore(Packer packer, Stack objectTree, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.Serialization.DefaultSerializers.System_Collections_StackMessagePackSerializer/<UnpackFromAsyncCore>d__7")]
protected internal virtual Task`1<Stack> UnpackFromAsyncCore(Unpacker unpacker, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.Serialization.DefaultSerializers.System_Collections_StackMessagePackSerializer/<UnpackToAsyncCore>d__8")]
protected internal virtual Task UnpackToAsyncCore(Unpacker unpacker, Stack collection, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.Serialization.DefaultSerializers.System_Collections_StackMessagePackSerializer/<UnpackItemsInReverseOrderAsync>d__9")]
private static Task`1<ICollection> UnpackItemsInReverseOrderAsync(Unpacker unpacker, int count, CancellationToken cancellationToken);
}
internal class MsgPack.Serialization.DefaultSerializers.System_DBNullMessagePackSerializer : MessagePackSerializer`1<DBNull> {
    public System_DBNullMessagePackSerializer(SerializationContext ownerContext);
    protected internal virtual void PackToCore(Packer packer, DBNull objectTree);
    protected internal virtual DBNull UnpackFromCore(Unpacker unpacker);
    protected internal virtual DBNull UnpackNil();
    protected internal virtual Task PackToAsyncCore(Packer packer, DBNull objectTree, CancellationToken cancellationToken);
    protected internal virtual Task`1<DBNull> UnpackFromAsyncCore(Unpacker unpacker, CancellationToken cancellationToken);
}
internal class MsgPack.Serialization.DefaultSerializers.System_DecimalMessagePackSerializer : MessagePackSerializer`1<decimal> {
    public System_DecimalMessagePackSerializer(SerializationContext ownerContext);
    protected internal virtual void PackToCore(Packer packer, decimal value);
    protected internal virtual decimal UnpackFromCore(Unpacker unpacker);
    [AsyncStateMachineAttribute("MsgPack.Serialization.DefaultSerializers.System_DecimalMessagePackSerializer/<PackToAsyncCore>d__3")]
protected internal virtual Task PackToAsyncCore(Packer packer, decimal value, CancellationToken cancellationToken);
    protected internal virtual Task`1<decimal> UnpackFromAsyncCore(Unpacker unpacker, CancellationToken cancellationToken);
}
internal class MsgPack.Serialization.DefaultSerializers.System_DoubleMessagePackSerializer : MessagePackSerializer`1<double> {
    public System_DoubleMessagePackSerializer(SerializationContext ownerContext);
    protected internal virtual void PackToCore(Packer packer, double value);
    protected internal virtual double UnpackFromCore(Unpacker unpacker);
    [AsyncStateMachineAttribute("MsgPack.Serialization.DefaultSerializers.System_DoubleMessagePackSerializer/<PackToAsyncCore>d__3")]
protected internal virtual Task PackToAsyncCore(Packer packer, double value, CancellationToken cancellationToken);
    protected internal virtual Task`1<double> UnpackFromAsyncCore(Unpacker unpacker, CancellationToken cancellationToken);
}
internal class MsgPack.Serialization.DefaultSerializers.System_Globalization_CultureInfoMessagePackSerializer : MessagePackSerializer`1<CultureInfo> {
    public System_Globalization_CultureInfoMessagePackSerializer(SerializationContext ownerContext);
    protected internal virtual void PackToCore(Packer packer, CultureInfo objectTree);
    protected internal virtual CultureInfo UnpackFromCore(Unpacker unpacker);
    protected internal virtual Task PackToAsyncCore(Packer packer, CultureInfo objectTree, CancellationToken cancellationToken);
    protected internal virtual Task`1<CultureInfo> UnpackFromAsyncCore(Unpacker unpacker, CancellationToken cancellationToken);
}
internal class MsgPack.Serialization.DefaultSerializers.System_GuidMessagePackSerializer : MessagePackSerializer`1<Guid> {
    public System_GuidMessagePackSerializer(SerializationContext ownerContext);
    protected internal virtual void PackToCore(Packer packer, Guid value);
    protected internal virtual Guid UnpackFromCore(Unpacker unpacker);
    [AsyncStateMachineAttribute("MsgPack.Serialization.DefaultSerializers.System_GuidMessagePackSerializer/<PackToAsyncCore>d__3")]
protected internal virtual Task PackToAsyncCore(Packer packer, Guid value, CancellationToken cancellationToken);
    protected internal virtual Task`1<Guid> UnpackFromAsyncCore(Unpacker unpacker, CancellationToken cancellationToken);
}
internal class MsgPack.Serialization.DefaultSerializers.System_Int16MessagePackSerializer : MessagePackSerializer`1<short> {
    public System_Int16MessagePackSerializer(SerializationContext ownerContext);
    protected internal virtual void PackToCore(Packer packer, short value);
    protected internal virtual short UnpackFromCore(Unpacker unpacker);
    [AsyncStateMachineAttribute("MsgPack.Serialization.DefaultSerializers.System_Int16MessagePackSerializer/<PackToAsyncCore>d__3")]
protected internal virtual Task PackToAsyncCore(Packer packer, short value, CancellationToken cancellationToken);
    protected internal virtual Task`1<short> UnpackFromAsyncCore(Unpacker unpacker, CancellationToken cancellationToken);
}
internal class MsgPack.Serialization.DefaultSerializers.System_Int32MessagePackSerializer : MessagePackSerializer`1<int> {
    public System_Int32MessagePackSerializer(SerializationContext ownerContext);
    protected internal virtual void PackToCore(Packer packer, int value);
    protected internal virtual int UnpackFromCore(Unpacker unpacker);
    [AsyncStateMachineAttribute("MsgPack.Serialization.DefaultSerializers.System_Int32MessagePackSerializer/<PackToAsyncCore>d__3")]
protected internal virtual Task PackToAsyncCore(Packer packer, int value, CancellationToken cancellationToken);
    protected internal virtual Task`1<int> UnpackFromAsyncCore(Unpacker unpacker, CancellationToken cancellationToken);
}
internal class MsgPack.Serialization.DefaultSerializers.System_Int64MessagePackSerializer : MessagePackSerializer`1<long> {
    public System_Int64MessagePackSerializer(SerializationContext ownerContext);
    protected internal virtual void PackToCore(Packer packer, long value);
    protected internal virtual long UnpackFromCore(Unpacker unpacker);
    [AsyncStateMachineAttribute("MsgPack.Serialization.DefaultSerializers.System_Int64MessagePackSerializer/<PackToAsyncCore>d__3")]
protected internal virtual Task PackToAsyncCore(Packer packer, long value, CancellationToken cancellationToken);
    protected internal virtual Task`1<long> UnpackFromAsyncCore(Unpacker unpacker, CancellationToken cancellationToken);
}
internal class MsgPack.Serialization.DefaultSerializers.System_Numerics_BigIntegerMessagePackSerializer : MessagePackSerializer`1<BigInteger> {
    public System_Numerics_BigIntegerMessagePackSerializer(SerializationContext ownerContext);
    protected internal virtual void PackToCore(Packer packer, BigInteger value);
    protected internal virtual BigInteger UnpackFromCore(Unpacker unpacker);
    [AsyncStateMachineAttribute("MsgPack.Serialization.DefaultSerializers.System_Numerics_BigIntegerMessagePackSerializer/<PackToAsyncCore>d__3")]
protected internal virtual Task PackToAsyncCore(Packer packer, BigInteger value, CancellationToken cancellationToken);
    protected internal virtual Task`1<BigInteger> UnpackFromAsyncCore(Unpacker unpacker, CancellationToken cancellationToken);
}
internal class MsgPack.Serialization.DefaultSerializers.System_Numerics_ComplexMessagePackSerializer : MessagePackSerializer`1<Complex> {
    public System_Numerics_ComplexMessagePackSerializer(SerializationContext ownerContext);
    protected internal virtual void PackToCore(Packer packer, Complex objectTree);
    protected internal virtual Complex UnpackFromCore(Unpacker unpacker);
    [AsyncStateMachineAttribute("MsgPack.Serialization.DefaultSerializers.System_Numerics_ComplexMessagePackSerializer/<PackToAsyncCore>d__3")]
protected internal virtual Task PackToAsyncCore(Packer packer, Complex objectTree, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.Serialization.DefaultSerializers.System_Numerics_ComplexMessagePackSerializer/<UnpackFromAsyncCore>d__4")]
protected internal virtual Task`1<Complex> UnpackFromAsyncCore(Unpacker unpacker, CancellationToken cancellationToken);
}
internal class MsgPack.Serialization.DefaultSerializers.System_ObjectMessagePackSerializer : MessagePackSerializer`1<object> {
    public System_ObjectMessagePackSerializer(SerializationContext ownerContext);
    protected internal virtual void PackToCore(Packer packer, object value);
    protected internal virtual object UnpackFromCore(Unpacker unpacker);
    protected internal virtual Task PackToAsyncCore(Packer packer, object objectTree, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.Serialization.DefaultSerializers.System_ObjectMessagePackSerializer/<UnpackFromAsyncCore>d__4")]
protected internal virtual Task`1<object> UnpackFromAsyncCore(Unpacker unpacker, CancellationToken cancellationToken);
}
internal class MsgPack.Serialization.DefaultSerializers.System_SByteMessagePackSerializer : MessagePackSerializer`1<sbyte> {
    public System_SByteMessagePackSerializer(SerializationContext ownerContext);
    protected internal virtual void PackToCore(Packer packer, sbyte value);
    protected internal virtual sbyte UnpackFromCore(Unpacker unpacker);
    [AsyncStateMachineAttribute("MsgPack.Serialization.DefaultSerializers.System_SByteMessagePackSerializer/<PackToAsyncCore>d__3")]
protected internal virtual Task PackToAsyncCore(Packer packer, sbyte value, CancellationToken cancellationToken);
    protected internal virtual Task`1<sbyte> UnpackFromAsyncCore(Unpacker unpacker, CancellationToken cancellationToken);
}
internal class MsgPack.Serialization.DefaultSerializers.System_SingleMessagePackSerializer : MessagePackSerializer`1<float> {
    public System_SingleMessagePackSerializer(SerializationContext ownerContext);
    protected internal virtual void PackToCore(Packer packer, float value);
    protected internal virtual float UnpackFromCore(Unpacker unpacker);
    [AsyncStateMachineAttribute("MsgPack.Serialization.DefaultSerializers.System_SingleMessagePackSerializer/<PackToAsyncCore>d__3")]
protected internal virtual Task PackToAsyncCore(Packer packer, float value, CancellationToken cancellationToken);
    protected internal virtual Task`1<float> UnpackFromAsyncCore(Unpacker unpacker, CancellationToken cancellationToken);
}
internal class MsgPack.Serialization.DefaultSerializers.System_StringMessagePackSerializer : MessagePackSerializer`1<string> {
    public System_StringMessagePackSerializer(SerializationContext ownerContext);
    protected internal virtual void PackToCore(Packer packer, string value);
    protected internal virtual string UnpackFromCore(Unpacker unpacker);
    protected internal virtual Task PackToAsyncCore(Packer packer, string objectTree, CancellationToken cancellationToken);
    protected internal virtual Task`1<string> UnpackFromAsyncCore(Unpacker unpacker, CancellationToken cancellationToken);
}
internal class MsgPack.Serialization.DefaultSerializers.System_Text_StringBuilderMessagePackSerializer : MessagePackSerializer`1<StringBuilder> {
    public System_Text_StringBuilderMessagePackSerializer(SerializationContext ownerContext);
    protected internal virtual void PackToCore(Packer packer, StringBuilder value);
    protected internal virtual StringBuilder UnpackFromCore(Unpacker unpacker);
    protected internal virtual void UnpackToCore(Unpacker unpacker, StringBuilder collection);
    protected internal virtual Task PackToAsyncCore(Packer packer, StringBuilder objectTree, CancellationToken cancellationToken);
    protected internal virtual Task`1<StringBuilder> UnpackFromAsyncCore(Unpacker unpacker, CancellationToken cancellationToken);
    protected internal virtual Task UnpackToAsyncCore(Unpacker unpacker, StringBuilder collection, CancellationToken cancellationToken);
}
internal class MsgPack.Serialization.DefaultSerializers.System_TimeSpanMessagePackSerializer : MessagePackSerializer`1<TimeSpan> {
    public System_TimeSpanMessagePackSerializer(SerializationContext ownerContext);
    protected internal virtual void PackToCore(Packer packer, TimeSpan value);
    protected internal virtual TimeSpan UnpackFromCore(Unpacker unpacker);
    [AsyncStateMachineAttribute("MsgPack.Serialization.DefaultSerializers.System_TimeSpanMessagePackSerializer/<PackToAsyncCore>d__3")]
protected internal virtual Task PackToAsyncCore(Packer packer, TimeSpan value, CancellationToken cancellationToken);
    protected internal virtual Task`1<TimeSpan> UnpackFromAsyncCore(Unpacker unpacker, CancellationToken cancellationToken);
}
internal class MsgPack.Serialization.DefaultSerializers.System_UInt16MessagePackSerializer : MessagePackSerializer`1<ushort> {
    public System_UInt16MessagePackSerializer(SerializationContext ownerContext);
    protected internal virtual void PackToCore(Packer packer, ushort value);
    protected internal virtual ushort UnpackFromCore(Unpacker unpacker);
    [AsyncStateMachineAttribute("MsgPack.Serialization.DefaultSerializers.System_UInt16MessagePackSerializer/<PackToAsyncCore>d__3")]
protected internal virtual Task PackToAsyncCore(Packer packer, ushort value, CancellationToken cancellationToken);
    protected internal virtual Task`1<ushort> UnpackFromAsyncCore(Unpacker unpacker, CancellationToken cancellationToken);
}
internal class MsgPack.Serialization.DefaultSerializers.System_UInt32MessagePackSerializer : MessagePackSerializer`1<UInt32> {
    public System_UInt32MessagePackSerializer(SerializationContext ownerContext);
    protected internal virtual void PackToCore(Packer packer, UInt32 value);
    protected internal virtual UInt32 UnpackFromCore(Unpacker unpacker);
    [AsyncStateMachineAttribute("MsgPack.Serialization.DefaultSerializers.System_UInt32MessagePackSerializer/<PackToAsyncCore>d__3")]
protected internal virtual Task PackToAsyncCore(Packer packer, UInt32 value, CancellationToken cancellationToken);
    protected internal virtual Task`1<UInt32> UnpackFromAsyncCore(Unpacker unpacker, CancellationToken cancellationToken);
}
internal class MsgPack.Serialization.DefaultSerializers.System_UInt64MessagePackSerializer : MessagePackSerializer`1<ulong> {
    public System_UInt64MessagePackSerializer(SerializationContext ownerContext);
    protected internal virtual void PackToCore(Packer packer, ulong value);
    protected internal virtual ulong UnpackFromCore(Unpacker unpacker);
    [AsyncStateMachineAttribute("MsgPack.Serialization.DefaultSerializers.System_UInt64MessagePackSerializer/<PackToAsyncCore>d__3")]
protected internal virtual Task PackToAsyncCore(Packer packer, ulong value, CancellationToken cancellationToken);
    protected internal virtual Task`1<ulong> UnpackFromAsyncCore(Unpacker unpacker, CancellationToken cancellationToken);
}
internal class MsgPack.Serialization.DefaultSerializers.System_UriMessagePackSerializer : MessagePackSerializer`1<Uri> {
    public System_UriMessagePackSerializer(SerializationContext ownerContext);
    protected internal virtual void PackToCore(Packer packer, Uri objectTree);
    protected internal virtual Uri UnpackFromCore(Unpacker unpacker);
    protected internal virtual Task PackToAsyncCore(Packer packer, Uri objectTree, CancellationToken cancellationToken);
    protected internal virtual Task`1<Uri> UnpackFromAsyncCore(Unpacker unpacker, CancellationToken cancellationToken);
}
internal class MsgPack.Serialization.DefaultSerializers.System_VersionMessagePackSerializer : MessagePackSerializer`1<Version> {
    public System_VersionMessagePackSerializer(SerializationContext ownerContext);
    protected internal virtual void PackToCore(Packer packer, Version objectTree);
    protected internal virtual Version UnpackFromCore(Unpacker unpacker);
    [AsyncStateMachineAttribute("MsgPack.Serialization.DefaultSerializers.System_VersionMessagePackSerializer/<PackToAsyncCore>d__3")]
protected internal virtual Task PackToAsyncCore(Packer packer, Version objectTree, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.Serialization.DefaultSerializers.System_VersionMessagePackSerializer/<UnpackFromAsyncCore>d__4")]
protected internal virtual Task`1<Version> UnpackFromAsyncCore(Unpacker unpacker, CancellationToken cancellationToken);
}
internal class MsgPack.Serialization.DefaultSerializers.TimestampDateTimeMessagePackSerializer : MessagePackSerializer`1<DateTime> {
    public TimestampDateTimeMessagePackSerializer(SerializationContext ownerContext);
    protected internal virtual void PackToCore(Packer packer, DateTime objectTree);
    protected internal virtual DateTime UnpackFromCore(Unpacker unpacker);
    protected internal virtual Task PackToAsyncCore(Packer packer, DateTime objectTree, CancellationToken cancellationToken);
    protected internal virtual Task`1<DateTime> UnpackFromAsyncCore(Unpacker unpacker, CancellationToken cancellationToken);
}
internal class MsgPack.Serialization.DefaultSerializers.TimestampFileTimeMessagePackSerializer : MessagePackSerializer`1<FILETIME> {
    public TimestampFileTimeMessagePackSerializer(SerializationContext ownerContext);
    protected internal virtual void PackToCore(Packer packer, FILETIME objectTree);
    protected internal virtual FILETIME UnpackFromCore(Unpacker unpacker);
    protected internal virtual Task PackToAsyncCore(Packer packer, FILETIME objectTree, CancellationToken cancellationToken);
    protected internal virtual Task`1<FILETIME> UnpackFromAsyncCore(Unpacker unpacker, CancellationToken cancellationToken);
}
internal class MsgPack.Serialization.DefaultSerializers.TimestampMessagePackSerializer : MessagePackSerializer`1<Timestamp> {
    private DateTimeConversionMethod _conversion;
    public TimestampMessagePackSerializer(SerializationContext ownerContext, DateTimeConversionMethod conversion);
    protected internal virtual void PackToCore(Packer packer, Timestamp objectTree);
    protected internal virtual Timestamp UnpackFromCore(Unpacker unpacker);
    [AsyncStateMachineAttribute("MsgPack.Serialization.DefaultSerializers.TimestampMessagePackSerializer/<PackToAsyncCore>d__4")]
protected internal virtual Task PackToAsyncCore(Packer packer, Timestamp objectTree, CancellationToken cancellationToken);
    protected internal virtual Task`1<Timestamp> UnpackFromAsyncCore(Unpacker unpacker, CancellationToken cancellationToken);
}
internal class MsgPack.Serialization.DefaultSerializers.TimestampMessagePackSerializerProvider : MessagePackSerializerProvider {
    private MessagePackSerializer _unixEpoc;
    private MessagePackSerializer _native;
    private MessagePackSerializer _timestamp;
    public TimestampMessagePackSerializerProvider(SerializationContext context, bool isNullable);
    public virtual object Get(SerializationContext context, object providerParameter);
}
[PreserveAttribute]
internal class MsgPack.Serialization.DefaultSerializers.UInt16ArraySerializer : MessagePackSerializer`1<UInt16[]> {
    public UInt16ArraySerializer(SerializationContext ownerContext);
    protected internal virtual void PackToCore(Packer packer, UInt16[] objectTree);
    protected internal virtual UInt16[] UnpackFromCore(Unpacker unpacker);
    protected internal virtual void UnpackToCore(Unpacker unpacker, UInt16[] collection);
    private static void UnpackToCore(Unpacker unpacker, UInt16[] collection, int count);
    [AsyncStateMachineAttribute("MsgPack.Serialization.DefaultSerializers.UInt16ArraySerializer/<PackToAsyncCore>d__5")]
protected internal virtual Task PackToAsyncCore(Packer packer, UInt16[] objectTree, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.Serialization.DefaultSerializers.UInt16ArraySerializer/<UnpackFromAsyncCore>d__6")]
protected internal virtual Task`1<UInt16[]> UnpackFromAsyncCore(Unpacker unpacker, CancellationToken cancellationToken);
    protected internal virtual Task UnpackToAsyncCore(Unpacker unpacker, UInt16[] collection, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.Serialization.DefaultSerializers.UInt16ArraySerializer/<UnpackToAsyncCore>d__8")]
private static Task UnpackToAsyncCore(Unpacker unpacker, UInt16[] collection, int count, CancellationToken cancellationToken);
}
[PreserveAttribute]
internal class MsgPack.Serialization.DefaultSerializers.UInt32ArraySerializer : MessagePackSerializer`1<UInt32[]> {
    public UInt32ArraySerializer(SerializationContext ownerContext);
    protected internal virtual void PackToCore(Packer packer, UInt32[] objectTree);
    protected internal virtual UInt32[] UnpackFromCore(Unpacker unpacker);
    protected internal virtual void UnpackToCore(Unpacker unpacker, UInt32[] collection);
    private static void UnpackToCore(Unpacker unpacker, UInt32[] collection, int count);
    [AsyncStateMachineAttribute("MsgPack.Serialization.DefaultSerializers.UInt32ArraySerializer/<PackToAsyncCore>d__5")]
protected internal virtual Task PackToAsyncCore(Packer packer, UInt32[] objectTree, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.Serialization.DefaultSerializers.UInt32ArraySerializer/<UnpackFromAsyncCore>d__6")]
protected internal virtual Task`1<UInt32[]> UnpackFromAsyncCore(Unpacker unpacker, CancellationToken cancellationToken);
    protected internal virtual Task UnpackToAsyncCore(Unpacker unpacker, UInt32[] collection, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.Serialization.DefaultSerializers.UInt32ArraySerializer/<UnpackToAsyncCore>d__8")]
private static Task UnpackToAsyncCore(Unpacker unpacker, UInt32[] collection, int count, CancellationToken cancellationToken);
}
[PreserveAttribute]
internal class MsgPack.Serialization.DefaultSerializers.UInt64ArraySerializer : MessagePackSerializer`1<UInt64[]> {
    public UInt64ArraySerializer(SerializationContext ownerContext);
    protected internal virtual void PackToCore(Packer packer, UInt64[] objectTree);
    protected internal virtual UInt64[] UnpackFromCore(Unpacker unpacker);
    protected internal virtual void UnpackToCore(Unpacker unpacker, UInt64[] collection);
    private static void UnpackToCore(Unpacker unpacker, UInt64[] collection, int count);
    [AsyncStateMachineAttribute("MsgPack.Serialization.DefaultSerializers.UInt64ArraySerializer/<PackToAsyncCore>d__5")]
protected internal virtual Task PackToAsyncCore(Packer packer, UInt64[] objectTree, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.Serialization.DefaultSerializers.UInt64ArraySerializer/<UnpackFromAsyncCore>d__6")]
protected internal virtual Task`1<UInt64[]> UnpackFromAsyncCore(Unpacker unpacker, CancellationToken cancellationToken);
    protected internal virtual Task UnpackToAsyncCore(Unpacker unpacker, UInt64[] collection, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.Serialization.DefaultSerializers.UInt64ArraySerializer/<UnpackToAsyncCore>d__8")]
private static Task UnpackToAsyncCore(Unpacker unpacker, UInt64[] collection, int count, CancellationToken cancellationToken);
}
internal class MsgPack.Serialization.DefaultSerializers.UnixEpocDateTimeMessagePackSerializer : MessagePackSerializer`1<DateTime> {
    public UnixEpocDateTimeMessagePackSerializer(SerializationContext ownerContext);
    protected internal virtual void PackToCore(Packer packer, DateTime objectTree);
    protected internal virtual DateTime UnpackFromCore(Unpacker unpacker);
    protected internal virtual Task PackToAsyncCore(Packer packer, DateTime objectTree, CancellationToken cancellationToken);
    protected internal virtual Task`1<DateTime> UnpackFromAsyncCore(Unpacker unpacker, CancellationToken cancellationToken);
}
internal class MsgPack.Serialization.DefaultSerializers.UnixEpocFileTimeMessagePackSerializer : MessagePackSerializer`1<FILETIME> {
    public UnixEpocFileTimeMessagePackSerializer(SerializationContext ownerContext);
    protected internal virtual void PackToCore(Packer packer, FILETIME objectTree);
    protected internal virtual FILETIME UnpackFromCore(Unpacker unpacker);
    protected internal virtual Task PackToAsyncCore(Packer packer, FILETIME objectTree, CancellationToken cancellationToken);
    protected internal virtual Task`1<FILETIME> UnpackFromAsyncCore(Unpacker unpacker, CancellationToken cancellationToken);
}
public static class MsgPack.Serialization.DictionaryKeyTransformers : object {
    private static Func`2<string, string> _lowerCamel;
    public static Func`2<string, string> LowerCamel { get; }
    private static DictionaryKeyTransformers();
    public static Func`2<string, string> get_LowerCamel();
}
public class MsgPack.Serialization.DictionarySerlaizationOptions : object {
    private bool _omitNullEntry;
    private Func`2<string, string> _keyTransformer;
    public bool OmitNullEntry { get; public set; }
    public Func`2<string, string> KeyTransformer { get; public set; }
    internal Func`2<string, string> SafeKeyTransformer { get; }
    public bool get_OmitNullEntry();
    public void set_OmitNullEntry(bool value);
    public Func`2<string, string> get_KeyTransformer();
    public void set_KeyTransformer(Func`2<string, string> value);
    internal Func`2<string, string> get_SafeKeyTransformer();
}
internal enum MsgPack.Serialization.EmitterFlavor : Enum {
    public int value__;
    public static EmitterFlavor FieldBased;
    public static EmitterFlavor CodeDomBased;
    public static EmitterFlavor ReflectionBased;
}
internal class MsgPack.Serialization.EmittingSerializers.AndConditionILConstruct : ILConstruct {
    private IList`1<ILConstruct> _expressions;
    public AndConditionILConstruct(IList`1<ILConstruct> expressions);
    public virtual void Evaluate(TracingILGenerator il);
    public virtual void LoadValue(TracingILGenerator il, bool shouldBeAddress);
    private void EvaluateCore(TracingILGenerator il);
    public virtual void Branch(TracingILGenerator il, Label else);
    public virtual string ToString();
}
internal class MsgPack.Serialization.EmittingSerializers.AssemblyBuilderCodeGenerationContext : object {
    private SerializationContext _context;
    private SerializationMethodGeneratorManager _generatorManager;
    private AssemblyBuilder _assemblyBuilder;
    private string _directory;
    private string _namespace;
    private List`1<SerializerSpecification> _generatedSerializers;
    public SerializationContext SerializationContext { get; }
    public AssemblyBuilderCodeGenerationContext(SerializationContext context, AssemblyBuilder assemblyBuilder, SerializerAssemblyGenerationConfiguration configuration);
    public sealed virtual SerializationContext get_SerializationContext();
    public AssemblyBuilderEmittingContext CreateEmittingContext(Type targetType, CollectionTraits targetTypeCollectionTraits, Type serializerBaseClass);
    public sealed virtual IEnumerable`1<SerializerCodeGenerationResult> Generate();
}
internal class MsgPack.Serialization.EmittingSerializers.AssemblyBuilderEmittingContext : SerializerGenerationContext`1<ILConstruct> {
    private Type _targetType;
    private Func`1<SerializerEmitter> _emitterFactory;
    private Stack`1<ILMethodConctext> _ilGeneratorStack;
    private SerializerEmitter _emitter;
    internal TracingILGenerator IL { get; }
    internal SerializerEmitter Emitter { get; }
    public AssemblyBuilderEmittingContext(SerializationContext context, Type targetType, Func`1<SerializerEmitter> emitterFactory);
    internal TracingILGenerator get_IL();
    internal SerializerEmitter get_Emitter();
    public Type GetSerializerType(Type targetType);
    protected sealed virtual void ResetCore(Type targetType, Type baseClass);
    public virtual void BeginMethodOverride(string name);
    public virtual void BeginPrivateMethod(string name, bool isStatic, TypeDefinition returnType, ILConstruct[] parameters);
    protected virtual MethodDefinition EndPrivateMethodCore(string name, ILConstruct body);
    protected virtual MethodDefinition EndMethodOverrideCore(string name, ILConstruct body);
    private MethodDefinition EndMethod(ILConstruct body);
    protected virtual FieldDefinition DeclarePrivateFieldCore(string name, TypeDefinition type);
    protected virtual void DefineUnpackingContextCore(IList`1<KeyValuePair`2<string, TypeDefinition>> fields, TypeDefinition& type, ConstructorDefinition& constructor, ILConstruct& parameterInUnpackValueMethods, ILConstruct& parameterInSetValueMethods, ILConstruct& parameterInCreateObjectFromContext);
    protected virtual void DefineUnpackingContextWithResultObjectCore(TypeDefinition& type, ILConstruct& parameterInUnpackValueMethods, ILConstruct& parameterInSetValueMethods, ILConstruct& parameterInCreateObjectFromContext);
    private static void DefineUnpackValueMethodArguments(TypeDefinition type, ILConstruct& parameterInUnpackValueMethods, ILConstruct& parameterInSetValueMethods, ILConstruct& parameterInCreateObjectFromContext);
    public virtual ILConstruct DefineUnpackedItemParameterInSetValueMethods(TypeDefinition itemType);
}
internal class MsgPack.Serialization.EmittingSerializers.AssemblyBuilderSerializerBuilder : SerializerBuilder`2<AssemblyBuilderEmittingContext, ILConstruct> {
    public AssemblyBuilderSerializerBuilder(Type targetType, CollectionTraits collectionTraits);
    protected virtual ILConstruct EmitSequentialStatements(AssemblyBuilderEmittingContext context, TypeDefinition contextType, IEnumerable`1<ILConstruct> statements);
    protected virtual ILConstruct MakeNullLiteral(AssemblyBuilderEmittingContext context, TypeDefinition contextType);
    protected virtual ILConstruct MakeByteLiteral(AssemblyBuilderEmittingContext context, byte constant);
    protected virtual ILConstruct MakeSByteLiteral(AssemblyBuilderEmittingContext context, sbyte constant);
    protected virtual ILConstruct MakeInt16Literal(AssemblyBuilderEmittingContext context, short constant);
    protected virtual ILConstruct MakeUInt16Literal(AssemblyBuilderEmittingContext context, ushort constant);
    protected virtual ILConstruct MakeInt32Literal(AssemblyBuilderEmittingContext context, int constant);
    protected virtual ILConstruct MakeUInt32Literal(AssemblyBuilderEmittingContext context, UInt32 constant);
    private static ILConstruct MakeIntegerLiteral(TypeDefinition contextType, int constant);
    protected virtual ILConstruct MakeInt64Literal(AssemblyBuilderEmittingContext context, long constant);
    protected virtual ILConstruct MakeUInt64Literal(AssemblyBuilderEmittingContext context, ulong constant);
    protected virtual ILConstruct MakeReal32Literal(AssemblyBuilderEmittingContext context, float constant);
    protected virtual ILConstruct MakeReal64Literal(AssemblyBuilderEmittingContext context, double constant);
    protected virtual ILConstruct MakeBooleanLiteral(AssemblyBuilderEmittingContext context, bool constant);
    protected virtual ILConstruct MakeCharLiteral(AssemblyBuilderEmittingContext context, char constant);
    protected virtual ILConstruct MakeStringLiteral(AssemblyBuilderEmittingContext context, string constant);
    protected virtual ILConstruct MakeEnumLiteral(AssemblyBuilderEmittingContext context, TypeDefinition type, object constant);
    protected virtual ILConstruct MakeDefaultLiteral(AssemblyBuilderEmittingContext context, TypeDefinition type);
    protected virtual ILConstruct EmitThisReferenceExpression(AssemblyBuilderEmittingContext context);
    protected virtual ILConstruct EmitBoxExpression(AssemblyBuilderEmittingContext context, TypeDefinition valueType, ILConstruct value);
    protected virtual ILConstruct EmitUnboxAnyExpression(AssemblyBuilderEmittingContext context, TypeDefinition targetType, ILConstruct value);
    protected virtual ILConstruct EmitNotExpression(AssemblyBuilderEmittingContext context, ILConstruct booleanExpression);
    protected virtual ILConstruct EmitEqualsExpression(AssemblyBuilderEmittingContext context, ILConstruct left, ILConstruct right);
    protected virtual ILConstruct EmitGreaterThanExpression(AssemblyBuilderEmittingContext context, ILConstruct left, ILConstruct right);
    protected virtual ILConstruct EmitLessThanExpression(AssemblyBuilderEmittingContext context, ILConstruct left, ILConstruct right);
    protected virtual ILConstruct EmitIncrement(AssemblyBuilderEmittingContext context, ILConstruct int32Value);
    protected virtual ILConstruct EmitTypeOfExpression(AssemblyBuilderEmittingContext context, TypeDefinition type);
    protected virtual ILConstruct EmitMethodOfExpression(AssemblyBuilderEmittingContext context, MethodBase method);
    protected virtual ILConstruct EmitFieldOfExpression(AssemblyBuilderEmittingContext context, FieldInfo field);
    protected virtual ILConstruct EmitThrowStatement(AssemblyBuilderEmittingContext context, ILConstruct exception);
    protected virtual ILConstruct DeclareLocal(AssemblyBuilderEmittingContext context, TypeDefinition nestedType, string name);
    protected virtual ILConstruct ReferArgument(AssemblyBuilderEmittingContext context, TypeDefinition type, string name, int index);
    protected virtual ILConstruct EmitInvokeVoidMethod(AssemblyBuilderEmittingContext context, ILConstruct instance, MethodDefinition method, ILConstruct[] arguments);
    protected virtual ILConstruct EmitCreateNewObjectExpression(AssemblyBuilderEmittingContext context, ILConstruct variable, ConstructorDefinition constructor, ILConstruct[] arguments);
    protected virtual ILConstruct EmitMakeRef(AssemblyBuilderEmittingContext context, ILConstruct target);
    protected virtual ILConstruct EmitCreateNewArrayExpression(AssemblyBuilderEmittingContext context, TypeDefinition elementType, int length);
    protected virtual ILConstruct EmitCreateNewArrayExpression(AssemblyBuilderEmittingContext context, TypeDefinition elementType, int length, IEnumerable`1<ILConstruct> initialElements);
    protected virtual ILConstruct EmitGetArrayElementExpression(AssemblyBuilderEmittingContext context, ILConstruct array, ILConstruct index);
    protected virtual ILConstruct EmitSetArrayElementStatement(AssemblyBuilderEmittingContext context, ILConstruct array, ILConstruct index, ILConstruct value);
    protected virtual ILConstruct EmitInvokeMethodExpression(AssemblyBuilderEmittingContext context, ILConstruct instance, MethodDefinition method, IEnumerable`1<ILConstruct> arguments);
    protected virtual ILConstruct EmitInvokeDelegateExpression(AssemblyBuilderEmittingContext context, TypeDefinition delegateReturnType, ILConstruct delegate, ILConstruct[] arguments);
    protected virtual ILConstruct EmitGetPropertyExpression(AssemblyBuilderEmittingContext context, ILConstruct instance, PropertyInfo property);
    protected virtual ILConstruct EmitGetFieldExpression(AssemblyBuilderEmittingContext context, ILConstruct instance, FieldDefinition field);
    protected virtual ILConstruct EmitSetProperty(AssemblyBuilderEmittingContext context, ILConstruct instance, PropertyInfo property, ILConstruct value);
    protected virtual ILConstruct EmitSetIndexedProperty(AssemblyBuilderEmittingContext context, ILConstruct instance, TypeDefinition declaringType, string proeprtyName, ILConstruct key, ILConstruct value);
    protected virtual ILConstruct EmitSetField(AssemblyBuilderEmittingContext context, ILConstruct instance, FieldDefinition field, ILConstruct value);
    protected virtual ILConstruct EmitSetField(AssemblyBuilderEmittingContext context, ILConstruct instance, TypeDefinition nestedType, string fieldName, ILConstruct value);
    protected virtual ILConstruct EmitLoadVariableExpression(AssemblyBuilderEmittingContext context, ILConstruct variable);
    protected virtual ILConstruct EmitStoreVariableStatement(AssemblyBuilderEmittingContext context, ILConstruct variable, ILConstruct value);
    protected virtual ILConstruct EmitTryFinally(AssemblyBuilderEmittingContext context, ILConstruct tryStatement, ILConstruct finallyStatement);
    protected virtual ILConstruct EmitConditionalExpression(AssemblyBuilderEmittingContext context, ILConstruct conditionExpression, ILConstruct thenExpression, ILConstruct elseExpression);
    protected virtual ILConstruct EmitAndConditionalExpression(AssemblyBuilderEmittingContext context, IList`1<ILConstruct> conditionExpressions, ILConstruct thenExpression, ILConstruct elseExpression);
    protected virtual ILConstruct EmitForEachLoop(AssemblyBuilderEmittingContext context, CollectionTraits traits, ILConstruct collection, Func`2<ILConstruct, ILConstruct> loopBodyEmitter);
    protected virtual ILConstruct EmitEnumFromUnderlyingCastExpression(AssemblyBuilderEmittingContext context, Type enumType, ILConstruct underlyingValue);
    protected virtual ILConstruct EmitEnumToUnderlyingCastExpression(AssemblyBuilderEmittingContext context, Type underlyingType, ILConstruct enumValue);
    protected virtual Func`2<SerializationContext, MessagePackSerializer> CreateSerializerConstructor(AssemblyBuilderEmittingContext codeGenerationContext, SerializationTarget targetInfo, PolymorphismSchema schema, Nullable`1<SerializerCapabilities> capabilities);
    protected virtual Func`2<SerializationContext, MessagePackSerializer> CreateEnumSerializerConstructor(AssemblyBuilderEmittingContext codeGenerationContext);
    protected virtual ILConstruct EmitGetSerializerExpression(AssemblyBuilderEmittingContext context, Type targetType, Nullable`1<SerializingMember> memberInfo, PolymorphismSchema itemsSchema);
    [IteratorStateMachineAttribute("MsgPack.Serialization.EmittingSerializers.AssemblyBuilderSerializerBuilder/<EmitConstructPolymorphismSchema>d__59")]
private IEnumerable`1<ILConstruct> EmitConstructPolymorphismSchema(AssemblyBuilderEmittingContext context, PolymorphismSchema currentSchema);
    protected virtual ILConstruct EmitGetActionsExpression(AssemblyBuilderEmittingContext context, ActionType actionType, bool isAsync);
    protected virtual ILConstruct EmitGetMemberNamesExpression(AssemblyBuilderEmittingContext context);
    protected virtual ILConstruct EmitFinishFieldInitializationStatement(AssemblyBuilderEmittingContext context, string name, ILConstruct value);
    protected virtual AssemblyBuilderEmittingContext CreateCodeGenerationContextForSerializerCreation(SerializationContext context);
    protected virtual void BuildSerializerCodeCore(ISerializerCodeGenerationContext context, Type concreteType, PolymorphismSchema itemSchema);
    protected virtual ILConstruct EmitNewPrivateMethodDelegateExpression(AssemblyBuilderEmittingContext context, MethodDefinition method);
}
internal class MsgPack.Serialization.EmittingSerializers.BinaryOperatorILConstruct : ContextfulILConstruct {
    private string _operator;
    private ILConstruct _left;
    private ILConstruct _right;
    private Action`3<TracingILGenerator, ILConstruct, ILConstruct> _operation;
    private Action`4<TracingILGenerator, ILConstruct, ILConstruct, Label> _branchOperation;
    public BinaryOperatorILConstruct(string operator, TypeDefinition resultType, ILConstruct left, ILConstruct right, Action`3<TracingILGenerator, ILConstruct, ILConstruct> operation, Action`4<TracingILGenerator, ILConstruct, ILConstruct, Label> branchOperation);
    public virtual void Evaluate(TracingILGenerator il);
    public virtual void LoadValue(TracingILGenerator il, bool shouldBeAddress);
    protected virtual void BranchCore(TracingILGenerator il, Label else);
    public virtual string ToString();
}
internal class MsgPack.Serialization.EmittingSerializers.ConditionalILConstruct : ILConstruct {
    private ILConstruct _condition;
    private ILConstruct _thenExpression;
    private ILConstruct _elseExpression;
    public ConditionalILConstruct(ILConstruct condition, ILConstruct thenExpression, ILConstruct elseExpression);
    public virtual void Evaluate(TracingILGenerator il);
    public virtual void LoadValue(TracingILGenerator il, bool shouldBeAddress);
    public virtual void StoreValue(TracingILGenerator il);
    private void DoConditionalInstruction(TracingILGenerator il, Action onThen, Action onElse);
    public virtual string ToString();
}
internal abstract class MsgPack.Serialization.EmittingSerializers.ContextfulILConstruct : ILConstruct {
    protected ContextfulILConstruct(TypeDefinition contextType);
    public sealed virtual void Branch(TracingILGenerator il, Label else);
    protected virtual void BranchCore(TracingILGenerator il, Label else);
}
internal abstract class MsgPack.Serialization.EmittingSerializers.ILConstruct : object {
    public static ILConstruct[] NoArguments;
    private TypeDefinition _contextType;
    public TypeDefinition ContextType { get; }
    public bool IsTerminating { get; }
    protected ILConstruct(TypeDefinition contextType);
    private static ILConstruct();
    public sealed virtual TypeDefinition get_ContextType();
    public virtual bool get_IsTerminating();
    public virtual void Evaluate(TracingILGenerator il);
    public virtual void LoadValue(TracingILGenerator il, bool shouldBeAddress);
    public virtual void StoreValue(TracingILGenerator il);
    public virtual void Branch(TracingILGenerator il, Label else);
    public static ILConstruct LoadField(ILConstruct instance, FieldInfo field);
    public static ILConstruct StoreField(ILConstruct instance, FieldInfo field, ILConstruct value);
    public static ILConstruct StoreLocal(ILConstruct variable, ILConstruct value);
    public static ILConstruct Instruction(string description, TypeDefinition contextType, bool isTerminating, Action`1<TracingILGenerator> instructions);
    public static ILConstruct Argument(int index, TypeDefinition type, string name);
    public static ILConstruct IfThenElse(ILConstruct conditionExpression, ILConstruct thenExpression, ILConstruct elseExpression);
    public static ILConstruct AndCondition(IList`1<ILConstruct> conditionExpressions);
    public static ILConstruct UnaryOperator(string operator, ILConstruct input, Action`2<TracingILGenerator, ILConstruct> operation);
    public static ILConstruct UnaryOperator(string operator, ILConstruct input, Action`2<TracingILGenerator, ILConstruct> operation, Action`3<TracingILGenerator, ILConstruct, Label> branchOperation);
    public static ILConstruct BinaryOperator(string operator, TypeDefinition resultType, ILConstruct left, ILConstruct right, Action`3<TracingILGenerator, ILConstruct, ILConstruct> operation, Action`4<TracingILGenerator, ILConstruct, ILConstruct, Label> branchOperation);
    public static ILConstruct Invoke(ILConstruct target, MethodDefinition method, IEnumerable`1<ILConstruct> arguments);
    public static ILConstruct Invoke(ILConstruct target, MethodInfo runtimeMethod, IEnumerable`1<ILConstruct> arguments);
    internal static ILConstruct NewObject(ILConstruct variable, ConstructorInfo constructor, IEnumerable`1<ILConstruct> arguments);
    public static ILConstruct Sequence(TypeDefinition contextType, IEnumerable`1<ILConstruct> statements);
    public static ILConstruct Composite(ILConstruct before, ILConstruct context);
    public static ILConstruct Literal(TypeDefinition type, T literalValue, Action`1<TracingILGenerator> instruction);
    public static ILConstruct Variable(TypeDefinition type, string name);
    public static ILConstruct MakeRef(ILConstruct variable);
    protected static void ValidateContextTypeMatch(ILConstruct left, ILConstruct right);
    private static Type GetNormalizedType(Type type);
}
internal class MsgPack.Serialization.EmittingSerializers.ILMethodConctext : ValueType {
    public TracingILGenerator ILGenerator;
    public MethodBuilder Method;
    public TypeDefinition[] ParameterTypes;
    public ILMethodConctext(TracingILGenerator ilGenerator, MethodBuilder method, IEnumerable`1<Type> parameterTypes);
}
internal class MsgPack.Serialization.EmittingSerializers.InvocationILConsruct : ContextfulILConstruct {
    private ILConstruct _target;
    private MethodBase _method;
    private Type _interface;
    private IEnumerable`1<ILConstruct> _arguments;
    public InvocationILConsruct(MethodInfo method, Type interface, ILConstruct target, IEnumerable`1<ILConstruct> arguments);
    public InvocationILConsruct(ConstructorInfo ctor, ILConstruct target, IEnumerable`1<ILConstruct> arguments);
    public virtual void Evaluate(TracingILGenerator il);
    public virtual void LoadValue(TracingILGenerator il, bool shouldBeAddress);
    public virtual void StoreValue(TracingILGenerator il);
    private void Invoke(TracingILGenerator il);
    public virtual string ToString();
}
internal class MsgPack.Serialization.EmittingSerializers.LoadFieldILConstruct : ContextfulILConstruct {
    private ILConstruct _instance;
    private FieldInfo _field;
    public LoadFieldILConstruct(ILConstruct instance, FieldInfo field);
    public virtual void Evaluate(TracingILGenerator il);
    public virtual void LoadValue(TracingILGenerator il, bool shouldBeAddress);
    public virtual string ToString();
}
internal class MsgPack.Serialization.EmittingSerializers.SequenceILConstruct : ILConstruct {
    private ILConstruct[] _statements;
    public SequenceILConstruct(TypeDefinition contextType, IEnumerable`1<ILConstruct> statements);
    public virtual void Evaluate(TracingILGenerator il);
    public virtual void LoadValue(TracingILGenerator il, bool shouldBeAddress);
    public virtual string ToString();
}
internal class MsgPack.Serialization.EmittingSerializers.SerializationMethodGeneratorManager : object {
    private static ConstructorInfo _debuggableAttributeCtor;
    private static Object[] _debuggableAttributeCtorArguments;
    private static int _assemblySequence;
    private static SerializationMethodGeneratorManager _canCollect;
    private static SerializationMethodGeneratorManager _canDump;
    private static SerializationMethodGeneratorManager _fast;
    private AssemblyBuilder _assembly;
    private ModuleBuilder _module;
    private bool _isDebuggable;
    public static SerializationMethodGeneratorManager CanCollect { get; }
    public static SerializationMethodGeneratorManager CanDump { get; }
    public static SerializationMethodGeneratorManager Fast { get; }
    [SecuritySafeCriticalAttribute]
private SerializationMethodGeneratorManager(bool isDebuggable, bool isCollectable, AssemblyBuilder assemblyBuilder);
    private static SerializationMethodGeneratorManager();
    public static SerializationMethodGeneratorManager Get();
    public static SerializationMethodGeneratorManager Get(SerializationMethodGeneratorOption option);
    public static SerializationMethodGeneratorManager get_CanCollect();
    public static SerializationMethodGeneratorManager get_CanDump();
    public static SerializationMethodGeneratorManager get_Fast();
    private static SerializationMethodGeneratorManager Create(bool isDebuggable, bool isCollectable, AssemblyBuilder assemblyBuilder);
    internal static void Refresh();
    internal static void SetUpAssemblyBuilderAttributes(AssemblyBuilder dedicatedAssemblyBuilder, bool isDebuggable);
    public static SerializationMethodGeneratorManager Get(AssemblyBuilder assemblyBuilder);
    public SerializerEmitter CreateObjectEmitter(SerializerSpecification specification, Type baseClass);
    public SerializerEmitter CreateEnumEmitter(SerializationContext context, SerializerSpecification specification);
}
internal class MsgPack.Serialization.EmittingSerializers.SerializerEmitter : object {
    private SerializerSpecification _specification;
    private bool _isDebuggable;
    private ModuleBuilder _host;
    private TypeBuilder _typeBuilder;
    private Dictionary`2<string, MethodBuilder> _methodTable;
    private Dictionary`2<string, FieldBuilder> _fieldTable;
    private static Type[] ContextConstructorParameterTypes;
    private static Type[] ContextAndEnumSerializationMethodConstructorParameterTypes;
    private EnumSerializationMethod _defaultEnumSerializationMethod;
    private static Type[] ConstructorParameterTypesWithoutCapabilities;
    private static Type[] ConstructorParameterTypesWithCapabilities;
    private static Type[] CollectionConstructorParameterTypes;
    private Dictionary`2<SerializerFieldKey, SerializerFieldInfo> _serializers;
    private Dictionary`2<RuntimeFieldHandle, CachedFieldInfo> _cachedFieldInfos;
    private Dictionary`2<RuntimeMethodHandle, CachedMethodBase> _cachedMethodBases;
    private TypeBuilder _unpackingContextType;
    public SerializerEmitter(ModuleBuilder host, SerializerSpecification specification, Type baseClass, bool isDebuggable);
    public SerializerEmitter(SerializationContext context, ModuleBuilder host, SerializerSpecification specification, bool isDebuggable);
    private static SerializerEmitter();
    public FieldBuilder RegisterField(string name, Type type);
    private FieldBuilder DefineInitonlyField(string name, Type type);
    public ILMethodConctext DefineOverrideMethod(string methodName);
    public ILMethodConctext DefinePrivateMethod(string methodName, bool isStatic, Type returnType, Type[] parameterTypes);
    private ILMethodConctext DefineMethod(string methodName, bool isOverride, bool isStatic, Type returnType, Type[] parameterTypes);
    private TracingILGenerator GetILGenerator(ConstructorBuilder builder, Type[] parameterTypes);
    private TracingILGenerator GetILGenerator(MethodBuilder builder, Type[] parameterTypes);
    private ConstructorBuilder DefineConstructor(MethodAttributes attributes, Type[] parameterTypes);
    private ConstructorBuilder CreateConstructor(MethodAttributes attributes, Type[] parameterTypes, Action`2<Type, TracingILGenerator> emitter);
    public MessagePackSerializer CreateEnumInstance(SerializationContext context, EnumSerializationMethod serializationMethod);
    public Func`3<SerializationContext, EnumSerializationMethod, MessagePackSerializer> CreateEnumConstructor();
    private void EmitDefaultEnumConstructor(ConstructorBuilder methodConstructor, TracingILGenerator il);
    private void EmitMethodEnumConstructor(Type baseType, TracingILGenerator il);
    public FieldBuilder RegisterSerializer(Type targetType, EnumMemberSerializationMethod enumMemberSerializationMethod, DateTimeMemberConversionMethod dateTimeConversionMethod, PolymorphismSchema polymorphismSchema, Func`1<IEnumerable`1<ILConstruct>> schemaRegenerationCodeProvider);
    public Action`2<TracingILGenerator, int> RegisterFieldCache(FieldInfo field);
    public Action`2<TracingILGenerator, int> RegisterMethodCache(MethodBase method);
    public void DefineUnpackingContext(string name, IList`1<KeyValuePair`2<string, Type>> fields, Type& type, ConstructorInfo& constructor);
    public MessagePackSerializer CreateObjectInstance(AssemblyBuilderEmittingContext context, AssemblyBuilderSerializerBuilder builder, SerializationTarget targetInfo, PolymorphismSchema schema, Nullable`1<SerializerCapabilities> capabilities);
    public Func`3<SerializationContext, PolymorphismSchema, MessagePackSerializer> CreateObjectConstructor(AssemblyBuilderEmittingContext context, AssemblyBuilderSerializerBuilder builder, SerializationTarget targetInfo, Nullable`1<SerializerCapabilities> capabilities);
    private static void CreateDefaultObjectConstructor(ConstructorBuilder contextfulConstructorBuilder, TracingILGenerator il);
    private void CreateContextfulObjectConstructor(AssemblyBuilderEmittingContext context, Type baseType, Nullable`1<SerializerCapabilities> capabilities, TracingILGenerator il, Func`1<ILConstruct> packActionListInitializerProvider, Func`1<ILConstruct> packActionTableInitializerProvider, Func`1<ILConstruct> nullCheckerTableInitializerProvider, Func`1<ILConstruct> unpackActionListInitializerProvider, Func`1<ILConstruct> unpackActionTableInitializerProvider, Func`1<ILConstruct> packAsyncActionListInitializerProvider, Func`1<ILConstruct> packAsyncActionTableInitializerProvider, Func`1<ILConstruct> unpackAsyncActionListInitializerProvider, Func`1<ILConstruct> unpackAsyncActionTableInitializerProvider, Func`1<ILConstruct> memberNamesInitializerProvider, Func`1<ILConstruct> unpackToInitializerProvider);
}
internal class MsgPack.Serialization.EmittingSerializers.SinglelStepILConstruct : ILConstruct {
    private string _description;
    private Action`1<TracingILGenerator> _instruction;
    private bool _isTerminating;
    public bool IsTerminating { get; }
    public SinglelStepILConstruct(TypeDefinition contextType, string description, bool isTerminating, Action`1<TracingILGenerator> instruction);
    public virtual bool get_IsTerminating();
    public virtual void Evaluate(TracingILGenerator il);
    public virtual void LoadValue(TracingILGenerator il, bool shouldBeAddress);
    public virtual void StoreValue(TracingILGenerator il);
    public virtual string ToString();
}
internal class MsgPack.Serialization.EmittingSerializers.StatementExpressionILConstruct : ContextfulILConstruct {
    private bool _isBound;
    private ILConstruct _binding;
    private ILConstruct _expression;
    public StatementExpressionILConstruct(ILConstruct binding, ILConstruct expression);
    public virtual void Evaluate(TracingILGenerator il);
    public virtual void LoadValue(TracingILGenerator il, bool shouldBeAddress);
    private void Evaluate(TracingILGenerator il, bool shouldBeAddress);
    public virtual string ToString();
}
internal class MsgPack.Serialization.EmittingSerializers.StoreFieldILConstruct : ContextfulILConstruct {
    private ILConstruct _instance;
    private ILConstruct _value;
    private FieldInfo _field;
    public StoreFieldILConstruct(ILConstruct instance, FieldInfo field, ILConstruct value);
    public virtual void Evaluate(TracingILGenerator il);
    public virtual void StoreValue(TracingILGenerator il);
    public virtual string ToString();
}
internal class MsgPack.Serialization.EmittingSerializers.StoreVariableILConstruct : ILConstruct {
    private ILConstruct _variable;
    private ILConstruct _value;
    public StoreVariableILConstruct(ILConstruct variable, ILConstruct value);
    public virtual void Evaluate(TracingILGenerator il);
    public virtual string ToString();
}
internal class MsgPack.Serialization.EmittingSerializers.UnaryOperatorILConstruct : ContextfulILConstruct {
    private string _operator;
    private ILConstruct _input;
    private Action`2<TracingILGenerator, ILConstruct> _operation;
    private Action`3<TracingILGenerator, ILConstruct, Label> _branchOperation;
    public UnaryOperatorILConstruct(string operator, ILConstruct input, Action`2<TracingILGenerator, ILConstruct> operation);
    public UnaryOperatorILConstruct(string operator, ILConstruct input, Action`2<TracingILGenerator, ILConstruct> operation, Action`3<TracingILGenerator, ILConstruct, Label> branchOperation);
    private static void BranchWithOperationResult(ILConstruct input, Action`2<TracingILGenerator, ILConstruct> operation, TracingILGenerator il, Label else);
    public virtual void Evaluate(TracingILGenerator il);
    public virtual void LoadValue(TracingILGenerator il, bool shouldBeAddress);
    protected virtual void BranchCore(TracingILGenerator il, Label else);
    public virtual string ToString();
}
internal class MsgPack.Serialization.EmittingSerializers.VariableILConstruct : ContextfulILConstruct {
    private bool _isLocal;
    private int _index;
    private string _name;
    public VariableILConstruct(string name, TypeDefinition valueType);
    public VariableILConstruct(string name, TypeDefinition valueType, int parameterIndex);
    public virtual void Evaluate(TracingILGenerator il);
    public virtual void LoadValue(TracingILGenerator il, bool shouldBeAddress);
    public virtual void StoreValue(TracingILGenerator il);
    public virtual string ToString();
}
public enum MsgPack.Serialization.EnumMemberSerializationMethod : Enum {
    public int value__;
    public static EnumMemberSerializationMethod Default;
    public static EnumMemberSerializationMethod ByName;
    public static EnumMemberSerializationMethod ByUnderlyingValue;
}
public abstract class MsgPack.Serialization.EnumMessagePackSerializer`1 : MessagePackSerializer`1<TEnum> {
    private Type _underlyingType;
    private Dictionary`2<TEnum, string> _serializationMapping;
    private Dictionary`2<string, TEnum> _deserializationMapping;
    private EnumSerializationMethod _serializationMethod;
    protected EnumMessagePackSerializer`1(SerializationContext ownerContext, EnumSerializationMethod serializationMethod);
    protected internal sealed virtual void PackToCore(Packer packer, TEnum objectTree);
    protected internal abstract virtual void PackUnderlyingValueTo(Packer packer, TEnum enumValue);
    protected internal sealed virtual Task PackToAsyncCore(Packer packer, TEnum objectTree, CancellationToken cancellationToken);
    protected internal virtual Task PackUnderlyingValueToAsync(Packer packer, TEnum enumValue, CancellationToken cancellationToken);
    protected internal sealed virtual TEnum UnpackFromCore(Unpacker unpacker);
    protected internal abstract virtual TEnum UnpackFromUnderlyingValue(MessagePackObject messagePackObject);
    protected internal sealed virtual Task`1<TEnum> UnpackFromAsyncCore(Unpacker unpacker, CancellationToken cancellationToken);
    private sealed virtual override ICustomizableEnumSerializer MsgPack.Serialization.ICustomizableEnumSerializer.GetCopyAs(EnumSerializationMethod method);
}
[EditorBrowsableAttribute("1")]
public static class MsgPack.Serialization.EnumMessagePackSerializerHelpers : object {
    public static EnumSerializationMethod DetermineEnumSerializationMethod(SerializationContext context, Type enumType, EnumMemberSerializationMethod enumMemberSerializationMethod);
}
internal class MsgPack.Serialization.EnumMessagePackSerializerProvider : MessagePackSerializerProvider {
    private Type _enumType;
    private object _serializerForName;
    private object _serializerForIntegral;
    public EnumMessagePackSerializerProvider(Type enumType, ICustomizableEnumSerializer serializer);
    public virtual object Get(SerializationContext context, object providerParameter);
}
public static class MsgPack.Serialization.EnumNameTransformers : object {
    private static Func`2<string, string> _lowerCamel;
    private static Func`2<string, string> _upperSnake;
    public static Func`2<string, string> LowerCamel { get; }
    public static Func`2<string, string> UpperSnake { get; }
    private static EnumNameTransformers();
    public static Func`2<string, string> get_LowerCamel();
    public static Func`2<string, string> get_UpperSnake();
}
public enum MsgPack.Serialization.EnumSerializationMethod : Enum {
    public int value__;
    public static EnumSerializationMethod ByName;
    public static EnumSerializationMethod ByUnderlyingValue;
}
public class MsgPack.Serialization.EnumSerializationOptions : object {
    private int _serializationMethod;
    private Func`2<string, string> _nameTransformer;
    public EnumSerializationMethod SerializationMethod { get; public set; }
    public Func`2<string, string> NameTransformer { get; public set; }
    internal Func`2<string, string> SafeNameTransformer { get; }
    public EnumSerializationMethod get_SerializationMethod();
    public void set_SerializationMethod(EnumSerializationMethod value);
    public Func`2<string, string> get_NameTransformer();
    public void set_NameTransformer(Func`2<string, string> value);
    internal Func`2<string, string> get_SafeNameTransformer();
}
[DefaultMemberAttribute("Item")]
public class MsgPack.Serialization.ExtTypeCodeMapping : object {
    private object _syncRoot;
    private Dictionary`2<string, byte> _index;
    private Dictionary`2<byte, string> _types;
    public byte Item { get; }
    public byte get_Item(string name);
    public bool Add(string name, byte typeCode);
    private bool AddInternal(string name, byte typeCode);
    public bool Remove(string name);
    public bool Remove(byte typeCode);
    private void RemoveCore(string name, byte typeCode);
    public void Clear();
    public sealed virtual IEnumerator`1<KeyValuePair`2<string, byte>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private static void ValidateName(string name);
    private static void ValidateTypeCode(byte typeCode);
}
internal interface MsgPack.Serialization.ICustomizableEnumSerializer {
    public abstract virtual ICustomizableEnumSerializer GetCopyAs(EnumSerializationMethod method);
}
internal static class MsgPack.Serialization.IdentifierUtility : object {
    public static string EscapeTypeName(Type type);
    public static string EscapeTypeName(string fullName);
}
[ObsoleteAttribute("Use MessagePackSerializer abstract class instead.")]
public interface MsgPack.Serialization.IMessagePackSerializer {
    public abstract virtual void PackTo(Packer packer, object objectTree);
    public abstract virtual object UnpackFrom(Unpacker unpacker);
    public abstract virtual void UnpackTo(Unpacker unpacker, object collection);
}
[ObsoleteAttribute("Use MessagePackSerializer abstract class instead.")]
public interface MsgPack.Serialization.IMessagePackSingleObjectSerializer {
    public abstract virtual Byte[] PackSingleObject(object objectTree);
    public abstract virtual object UnpackSingleObject(Byte[] buffer);
}
internal class MsgPack.Serialization.IndividualFileCodeGenerationSink : CodeGenerationSink {
    internal static IndividualFileCodeGenerationSink Instance;
    private static IndividualFileCodeGenerationSink();
    protected virtual void AssignTextWriterCore(SerializerCodeInformation codeInformation);
}
internal interface MsgPack.Serialization.INilImplicationHandlerOnUnpackedParameter`1 {
    public TAction Store { get; }
    public abstract virtual TAction get_Store();
}
internal interface MsgPack.Serialization.INilImplicationHandlerParameter {
    public Type ItemType { get; }
    public abstract virtual Type get_ItemType();
}
internal interface MsgPack.Serialization.ISerializerGeneratorConfiguration {
    public string OutputDirectory { get; public set; }
    public SerializationMethod SerializationMethod { get; public set; }
    public EnumSerializationMethod EnumSerializationMethod { get; public set; }
    public bool IsRecursive { get; public set; }
    public bool PreferReflectionBasedSerializer { get; public set; }
    public bool WithNullableSerializers { get; public set; }
    public SerializationCompatibilityOptions CompatibilityOptions { get; }
    public bool WithAsync { get; public set; }
    public abstract virtual string get_OutputDirectory();
    public abstract virtual void set_OutputDirectory(string value);
    public abstract virtual SerializationMethod get_SerializationMethod();
    public abstract virtual void set_SerializationMethod(SerializationMethod value);
    public abstract virtual EnumSerializationMethod get_EnumSerializationMethod();
    public abstract virtual void set_EnumSerializationMethod(EnumSerializationMethod value);
    public abstract virtual bool get_IsRecursive();
    public abstract virtual void set_IsRecursive(bool value);
    public abstract virtual bool get_PreferReflectionBasedSerializer();
    public abstract virtual void set_PreferReflectionBasedSerializer(bool value);
    public abstract virtual bool get_WithNullableSerializers();
    public abstract virtual void set_WithNullableSerializers(bool value);
    public abstract virtual SerializationCompatibilityOptions get_CompatibilityOptions();
    public abstract virtual bool get_WithAsync();
    public abstract virtual void set_WithAsync(bool value);
    public abstract virtual void Validate();
}
internal static class MsgPack.Serialization.KeyNameTransformers : object {
    public static Func`2<string, string> AsIs;
    private static KeyNameTransformers();
    public static string ToLowerCamel(string mayBeUpperCamel);
    public static string ToUpperSnake(string mayBeUpperCamel);
}
internal class MsgPack.Serialization.LazyDelegatingMessagePackSerializer`1 : MessagePackSerializer`1<T> {
    private object _providerParameter;
    private MessagePackSerializer`1<T> _delegated;
    public LazyDelegatingMessagePackSerializer`1(SerializationContext ownerContext, object providerParameter);
    internal virtual SerializerCapabilities InternalGetCapabilities();
    private MessagePackSerializer`1<T> GetDelegatedSerializer();
    protected internal virtual void PackToCore(Packer packer, T objectTree);
    protected internal virtual T UnpackFromCore(Unpacker unpacker);
    protected internal virtual void UnpackToCore(Unpacker unpacker, T collection);
    public virtual string ToString();
}
[AttributeUsageAttribute("384")]
public class MsgPack.Serialization.MessagePackDateTimeMemberAttribute : Attribute {
    [CompilerGeneratedAttribute]
private DateTimeMemberConversionMethod <DateTimeConversionMethod>k__BackingField;
    public DateTimeMemberConversionMethod DateTimeConversionMethod { get; public set; }
    [CompilerGeneratedAttribute]
public DateTimeMemberConversionMethod get_DateTimeConversionMethod();
    [CompilerGeneratedAttribute]
public void set_DateTimeConversionMethod(DateTimeMemberConversionMethod value);
}
[AttributeUsageAttribute("32")]
public class MsgPack.Serialization.MessagePackDeserializationConstructorAttribute : Attribute {
}
[AttributeUsageAttribute("16")]
public class MsgPack.Serialization.MessagePackEnumAttribute : Attribute {
    [CompilerGeneratedAttribute]
private EnumSerializationMethod <SerializationMethod>k__BackingField;
    public EnumSerializationMethod SerializationMethod { get; public set; }
    [CompilerGeneratedAttribute]
public EnumSerializationMethod get_SerializationMethod();
    [CompilerGeneratedAttribute]
public void set_SerializationMethod(EnumSerializationMethod value);
}
[AttributeUsageAttribute("384")]
public class MsgPack.Serialization.MessagePackEnumMemberAttribute : Attribute {
    [CompilerGeneratedAttribute]
private EnumMemberSerializationMethod <SerializationMethod>k__BackingField;
    public EnumMemberSerializationMethod SerializationMethod { get; public set; }
    [CompilerGeneratedAttribute]
public EnumMemberSerializationMethod get_SerializationMethod();
    [CompilerGeneratedAttribute]
public void set_SerializationMethod(EnumMemberSerializationMethod value);
}
[AttributeUsageAttribute("384")]
public class MsgPack.Serialization.MessagePackIgnoreAttribute : Attribute {
}
[AttributeUsageAttribute("1420")]
public class MsgPack.Serialization.MessagePackKnownCollectionItemTypeAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <TypeCode>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <BindingType>k__BackingField;
    private PolymorphismTarget MsgPack.Serialization.Polymorphic.IPolymorphicHelperAttribute.Target { get; }
    public string TypeCode { get; private set; }
    public Type BindingType { get; private set; }
    public MessagePackKnownCollectionItemTypeAttribute(string typeCode, Type bindingType);
    private sealed virtual override PolymorphismTarget MsgPack.Serialization.Polymorphic.IPolymorphicHelperAttribute.get_Target();
    [CompilerGeneratedAttribute]
public sealed virtual string get_TypeCode();
    [CompilerGeneratedAttribute]
private void set_TypeCode(string value);
    [CompilerGeneratedAttribute]
public sealed virtual Type get_BindingType();
    [CompilerGeneratedAttribute]
private void set_BindingType(Type value);
}
[AttributeUsageAttribute("1420")]
public class MsgPack.Serialization.MessagePackKnownDictionaryKeyTypeAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <TypeCode>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <BindingType>k__BackingField;
    private PolymorphismTarget MsgPack.Serialization.Polymorphic.IPolymorphicHelperAttribute.Target { get; }
    public string TypeCode { get; private set; }
    public Type BindingType { get; private set; }
    public MessagePackKnownDictionaryKeyTypeAttribute(string typeCode, Type bindingType);
    private sealed virtual override PolymorphismTarget MsgPack.Serialization.Polymorphic.IPolymorphicHelperAttribute.get_Target();
    [CompilerGeneratedAttribute]
public sealed virtual string get_TypeCode();
    [CompilerGeneratedAttribute]
private void set_TypeCode(string value);
    [CompilerGeneratedAttribute]
public sealed virtual Type get_BindingType();
    [CompilerGeneratedAttribute]
private void set_BindingType(Type value);
}
[AttributeUsageAttribute("384")]
public class MsgPack.Serialization.MessagePackKnownTupleItemTypeAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <TypeCode>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <BindingType>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ItemNumber>k__BackingField;
    private PolymorphismTarget MsgPack.Serialization.Polymorphic.IPolymorphicHelperAttribute.Target { get; }
    public string TypeCode { get; private set; }
    public Type BindingType { get; private set; }
    public int ItemNumber { get; private set; }
    public MessagePackKnownTupleItemTypeAttribute(int itemNumber, string typeCode, Type bindingType);
    private sealed virtual override PolymorphismTarget MsgPack.Serialization.Polymorphic.IPolymorphicHelperAttribute.get_Target();
    [CompilerGeneratedAttribute]
public sealed virtual string get_TypeCode();
    [CompilerGeneratedAttribute]
private void set_TypeCode(string value);
    [CompilerGeneratedAttribute]
public sealed virtual Type get_BindingType();
    [CompilerGeneratedAttribute]
private void set_BindingType(Type value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_ItemNumber();
    [CompilerGeneratedAttribute]
private void set_ItemNumber(int value);
}
[AttributeUsageAttribute("1420")]
public class MsgPack.Serialization.MessagePackKnownTypeAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <TypeCode>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <BindingType>k__BackingField;
    private PolymorphismTarget MsgPack.Serialization.Polymorphic.IPolymorphicHelperAttribute.Target { get; }
    public string TypeCode { get; private set; }
    public Type BindingType { get; private set; }
    public MessagePackKnownTypeAttribute(string typeCode, Type bindingType);
    private sealed virtual override PolymorphismTarget MsgPack.Serialization.Polymorphic.IPolymorphicHelperAttribute.get_Target();
    [CompilerGeneratedAttribute]
public sealed virtual string get_TypeCode();
    [CompilerGeneratedAttribute]
private void set_TypeCode(string value);
    [CompilerGeneratedAttribute]
public sealed virtual Type get_BindingType();
    [CompilerGeneratedAttribute]
private void set_BindingType(Type value);
}
[AttributeUsageAttribute("384")]
public class MsgPack.Serialization.MessagePackMemberAttribute : Attribute {
    private int _id;
    private string _name;
    private NilImplication _nilImplication;
    public int Id { get; }
    public string Name { get; public set; }
    public NilImplication NilImplication { get; public set; }
    public MessagePackMemberAttribute(int id);
    public int get_Id();
    public string get_Name();
    public void set_Name(string value);
    public NilImplication get_NilImplication();
    public void set_NilImplication(NilImplication value);
}
[AttributeUsageAttribute("1420")]
public class MsgPack.Serialization.MessagePackRuntimeCollectionItemTypeAttribute : Attribute {
    [CompilerGeneratedAttribute]
private Type <VerifierType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <VerifierMethodName>k__BackingField;
    private PolymorphismTarget MsgPack.Serialization.Polymorphic.IPolymorphicHelperAttribute.Target { get; }
    public Type VerifierType { get; public set; }
    public string VerifierMethodName { get; public set; }
    private sealed virtual override PolymorphismTarget MsgPack.Serialization.Polymorphic.IPolymorphicHelperAttribute.get_Target();
    [CompilerGeneratedAttribute]
public sealed virtual Type get_VerifierType();
    [CompilerGeneratedAttribute]
public void set_VerifierType(Type value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_VerifierMethodName();
    [CompilerGeneratedAttribute]
public void set_VerifierMethodName(string value);
}
[AttributeUsageAttribute("1420")]
public class MsgPack.Serialization.MessagePackRuntimeDictionaryKeyTypeAttribute : Attribute {
    [CompilerGeneratedAttribute]
private Type <VerifierType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <VerifierMethodName>k__BackingField;
    private PolymorphismTarget MsgPack.Serialization.Polymorphic.IPolymorphicHelperAttribute.Target { get; }
    public Type VerifierType { get; public set; }
    public string VerifierMethodName { get; public set; }
    private sealed virtual override PolymorphismTarget MsgPack.Serialization.Polymorphic.IPolymorphicHelperAttribute.get_Target();
    [CompilerGeneratedAttribute]
public sealed virtual Type get_VerifierType();
    [CompilerGeneratedAttribute]
public void set_VerifierType(Type value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_VerifierMethodName();
    [CompilerGeneratedAttribute]
public void set_VerifierMethodName(string value);
}
[AttributeUsageAttribute("384")]
public class MsgPack.Serialization.MessagePackRuntimeTupleItemTypeAttribute : Attribute {
    [CompilerGeneratedAttribute]
private Type <VerifierType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <VerifierMethodName>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ItemNumber>k__BackingField;
    private PolymorphismTarget MsgPack.Serialization.Polymorphic.IPolymorphicHelperAttribute.Target { get; }
    public Type VerifierType { get; public set; }
    public string VerifierMethodName { get; public set; }
    public int ItemNumber { get; private set; }
    public MessagePackRuntimeTupleItemTypeAttribute(int itemNumber);
    private sealed virtual override PolymorphismTarget MsgPack.Serialization.Polymorphic.IPolymorphicHelperAttribute.get_Target();
    [CompilerGeneratedAttribute]
public sealed virtual Type get_VerifierType();
    [CompilerGeneratedAttribute]
public void set_VerifierType(Type value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_VerifierMethodName();
    [CompilerGeneratedAttribute]
public void set_VerifierMethodName(string value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_ItemNumber();
    [CompilerGeneratedAttribute]
private void set_ItemNumber(int value);
}
[AttributeUsageAttribute("1420")]
public class MsgPack.Serialization.MessagePackRuntimeTypeAttribute : Attribute {
    [CompilerGeneratedAttribute]
private Type <VerifierType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <VerifierMethodName>k__BackingField;
    private PolymorphismTarget MsgPack.Serialization.Polymorphic.IPolymorphicHelperAttribute.Target { get; }
    public Type VerifierType { get; public set; }
    public string VerifierMethodName { get; public set; }
    private sealed virtual override PolymorphismTarget MsgPack.Serialization.Polymorphic.IPolymorphicHelperAttribute.get_Target();
    [CompilerGeneratedAttribute]
public sealed virtual Type get_VerifierType();
    [CompilerGeneratedAttribute]
public void set_VerifierType(Type value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_VerifierMethodName();
    [CompilerGeneratedAttribute]
public void set_VerifierMethodName(string value);
}
public abstract class MsgPack.Serialization.MessagePackSerializer : object {
    internal static UnpackerOptions DefaultUnpackerOptions;
    internal static int BufferSize;
    private SerializationContext _ownerContext;
    private Nullable`1<PackerCompatibilityOptions> _packerCompatibilityOptionsForCompatibility;
    private SerializerCapabilities _capabilities;
    private static ConcurrentDictionary`2<Type, Func`2<SerializationContext, MessagePackSerializer>> _creatorCache;
    private static MessagePackSerializer`1<MessagePackObject> _singleTonMpoDeserializer;
    protected internal SerializationContext OwnerContext { get; }
    protected internal PackerCompatibilityOptions PackerCompatibilityOptions { get; }
    public SerializerCapabilities Capabilities { get; }
    internal MessagePackSerializer(SerializationContext ownerContext, Nullable`1<PackerCompatibilityOptions> packerCompatibilityOptions, SerializerCapabilities capabilities);
    private static MessagePackSerializer();
    protected internal SerializationContext get_OwnerContext();
    protected internal PackerCompatibilityOptions get_PackerCompatibilityOptions();
    public SerializerCapabilities get_Capabilities();
    internal virtual SerializerCapabilities InternalGetCapabilities();
    public sealed virtual void PackTo(Packer packer, object objectTree);
    internal abstract virtual void InternalPackTo(Packer packer, object objectTree);
    public sealed virtual object UnpackFrom(Unpacker unpacker);
    internal abstract virtual object InternalUnpackFrom(Unpacker unpacker);
    public sealed virtual void UnpackTo(Unpacker unpacker, object collection);
    internal abstract virtual void InternalUnpackTo(Unpacker unpacker, object collection);
    public sealed virtual Byte[] PackSingleObject(object objectTree);
    internal abstract virtual Byte[] InternalPackSingleObject(object objectTree);
    public sealed virtual object UnpackSingleObject(Byte[] buffer);
    internal abstract virtual object InternalUnpackSingleObject(Byte[] buffer);
    public Task PackToAsync(Packer packer, object objectTree, CancellationToken cancellationToken);
    internal abstract virtual Task InternalPackToAsync(Packer packer, object objectTree, CancellationToken cancellationToken);
    public Task`1<object> UnpackFromAsync(Unpacker unpacker, CancellationToken cancellationToken);
    internal abstract virtual Task`1<object> InternalUnpackFromAsync(Unpacker unpacker, CancellationToken cancellationToken);
    public Task UnpackToAsync(Unpacker unpacker, object collection, CancellationToken cancellationToken);
    internal abstract virtual Task InternalUnpackToAsync(Unpacker unpacker, object collection, CancellationToken cancellationToken);
    public Task`1<Byte[]> PackSingleObjectAsync(object objectTree, CancellationToken cancellationToken);
    internal abstract virtual Task`1<Byte[]> InternalPackSingleObjectAsync(object objectTree, CancellationToken cancellationToken);
    public Task`1<object> UnpackSingleObjectAsync(Byte[] buffer, CancellationToken cancellationToken);
    internal abstract virtual Task`1<object> InternalUnpackSingleObjectAsync(Byte[] buffer, CancellationToken cancellationToken);
    internal static void ThrowArgumentNullException(string parameterName);
    [ObsoleteAttribute("Use Get<T>() instead.")]
public static MessagePackSerializer`1<T> Create();
    [ObsoleteAttribute("Use Get<T>(SerializationContext) instead.")]
public static MessagePackSerializer`1<T> Create(SerializationContext context);
    public static MessagePackSerializer`1<T> Get();
    public static MessagePackSerializer`1<T> Get(object providerParameter);
    public static MessagePackSerializer`1<T> Get(SerializationContext context);
    public static MessagePackSerializer`1<T> Get(SerializationContext context, object providerParameter);
    internal static MessagePackSerializer`1<T> CreateInternal(SerializationContext context, PolymorphismSchema schema);
    [ObsoleteAttribute("Use Get(Type) instead.")]
public static IMessagePackSingleObjectSerializer Create(Type targetType);
    [ObsoleteAttribute("Use Get(Type,SerializationContext) instead.")]
public static MessagePackSerializer Create(Type targetType, SerializationContext context);
    public static MessagePackSerializer Get(Type targetType);
    public static MessagePackSerializer Get(Type targetType, object providerParameter);
    public static MessagePackSerializer Get(Type targetType, SerializationContext context);
    public static MessagePackSerializer Get(Type targetType, SerializationContext context, object providerParameter);
    internal static MessagePackSerializer`1<T> CreateReflectionInternal(SerializationContext context, Type concreteType, PolymorphismSchema schema);
    private static void ValidateType(Type type);
    public static MessagePackObject UnpackMessagePackObject(Stream stream);
    public static MessagePackObject UnpackMessagePackObject(Byte[] buffer);
    public static void PrepareType();
    public static void PrepareDictionaryType();
    public static void PrepareCollectionType();
}
public abstract class MsgPack.Serialization.MessagePackSerializer`1 : MessagePackSerializer {
    private static bool IsNullable;
    [ObsoleteAttribute("Use MessagePackSerializer (SerlaizationContext, PackerCompatibilityOptions) instead.")]
protected MessagePackSerializer`1(PackerCompatibilityOptions packerCompatibilityOptions);
    protected MessagePackSerializer`1(SerializationContext ownerContext);
    protected MessagePackSerializer`1(SerializationContext ownerContext, PackerCompatibilityOptions packerCompatibilityOptions);
    protected MessagePackSerializer`1(SerializationContext ownerContext, SerializerCapabilities capabilities);
    protected MessagePackSerializer`1(SerializationContext ownerContext, PackerCompatibilityOptions packerCompatibilityOptions, SerializerCapabilities capabilities);
    private static MessagePackSerializer`1();
    private static bool JudgeNullable();
    private static SerializerCapabilities InferCapatibity();
    public void Pack(Stream stream, T objectTree);
    public Task PackAsync(Stream stream, T objectTree);
    [AsyncStateMachineAttribute("MsgPack.Serialization.MessagePackSerializer`1/<PackAsync>d__11")]
public Task PackAsync(Stream stream, T objectTree, CancellationToken cancellationToken);
    public T Unpack(Stream stream);
    public Task`1<T> UnpackAsync(Stream stream);
    [AsyncStateMachineAttribute("MsgPack.Serialization.MessagePackSerializer`1/<UnpackAsync>d__14")]
public Task`1<T> UnpackAsync(Stream stream, CancellationToken cancellationToken);
    public void PackTo(Packer packer, T objectTree);
    protected internal abstract virtual void PackToCore(Packer packer, T objectTree);
    public Task PackToAsync(Packer packer, T objectTree);
    [AsyncStateMachineAttribute("MsgPack.Serialization.MessagePackSerializer`1/<PackToAsync>d__18")]
public Task PackToAsync(Packer packer, T objectTree, CancellationToken cancellationToken);
    protected internal virtual Task PackToAsyncCore(Packer packer, T objectTree, CancellationToken cancellationToken);
    public T UnpackFrom(Unpacker unpacker);
    protected internal virtual T UnpackNil();
    protected internal abstract virtual T UnpackFromCore(Unpacker unpacker);
    public Task`1<T> UnpackFromAsync(Unpacker unpacker);
    [AsyncStateMachineAttribute("MsgPack.Serialization.MessagePackSerializer`1/<UnpackFromAsync>d__24")]
public Task`1<T> UnpackFromAsync(Unpacker unpacker, CancellationToken cancellationToken);
    protected internal virtual Task`1<T> UnpackFromAsyncCore(Unpacker unpacker, CancellationToken cancellationToken);
    public void UnpackTo(Unpacker unpacker, T collection);
    protected internal virtual void UnpackToCore(Unpacker unpacker, T collection);
    public Task UnpackToAsync(Unpacker unpacker, T collection);
    [AsyncStateMachineAttribute("MsgPack.Serialization.MessagePackSerializer`1/<UnpackToAsync>d__29")]
public Task UnpackToAsync(Unpacker unpacker, T collection, CancellationToken cancellationToken);
    protected internal virtual Task UnpackToAsyncCore(Unpacker unpacker, T collection, CancellationToken cancellationToken);
    public Byte[] PackSingleObject(T objectTree);
    public ArraySegment`1<byte> PackSingleObjectAsBytes(T objectTree);
    public Task`1<Byte[]> PackSingleObjectAsync(T objectTree);
    [AsyncStateMachineAttribute("MsgPack.Serialization.MessagePackSerializer`1/<PackSingleObjectAsync>d__34")]
public Task`1<Byte[]> PackSingleObjectAsync(T objectTree, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.Serialization.MessagePackSerializer`1/<PackSingleObjectAsBytesAsync>d__35")]
public Task`1<ArraySegment`1<byte>> PackSingleObjectAsBytesAsync(T objectTree, CancellationToken cancellationToken);
    public T UnpackSingleObject(Byte[] buffer);
    public Task`1<T> UnpackSingleObjectAsync(Byte[] buffer);
    public Task`1<T> UnpackSingleObjectAsync(Byte[] buffer, CancellationToken cancellationToken);
    internal sealed virtual void InternalPackTo(Packer packer, object objectTree);
    internal sealed virtual object InternalUnpackFrom(Unpacker unpacker);
    internal sealed virtual void InternalUnpackTo(Unpacker unpacker, object collection);
    internal sealed virtual Byte[] InternalPackSingleObject(object objectTree);
    internal sealed virtual object InternalUnpackSingleObject(Byte[] buffer);
    [AsyncStateMachineAttribute("MsgPack.Serialization.MessagePackSerializer`1/<InternalPackToAsync>d__44")]
internal sealed virtual Task InternalPackToAsync(Packer packer, object objectTree, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.Serialization.MessagePackSerializer`1/<InternalUnpackFromAsync>d__45")]
internal sealed virtual Task`1<object> InternalUnpackFromAsync(Unpacker unpacker, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.Serialization.MessagePackSerializer`1/<InternalUnpackToAsync>d__46")]
internal sealed virtual Task InternalUnpackToAsync(Unpacker unpacker, object collection, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.Serialization.MessagePackSerializer`1/<InternalPackSingleObjectAsync>d__47")]
internal sealed virtual Task`1<Byte[]> InternalPackSingleObjectAsync(object objectTree, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.Serialization.MessagePackSerializer`1/<InternalUnpackSingleObjectAsync>d__48")]
internal sealed virtual Task`1<object> InternalUnpackSingleObjectAsync(Byte[] buffer, CancellationToken cancellationToken);
    private static void ThrowArgumentException(string message, string parameterName);
    private static void ThrowNewValueTypeCannotBeNullException();
}
[ExtensionAttribute]
public static class MsgPack.Serialization.MessagePackSerializerExtensions : object {
    [ExtensionAttribute]
public static void Pack(MessagePackSerializer source, Stream stream, object objectTree);
    [ExtensionAttribute]
public static void Pack(MessagePackSerializer source, Stream stream, object objectTree, PackerCompatibilityOptions packerCompatibilityOptions);
    [ExtensionAttribute]
public static object Unpack(MessagePackSerializer source, Stream stream);
    [ExtensionAttribute]
public static MessagePackObject ToMessagePackObject(MessagePackSerializer source, object obj);
    [ExtensionAttribute]
public static MessagePackObject ToMessagePackObject(MessagePackSerializer`1<T> source, T obj);
    [ExtensionAttribute]
public static object FromMessagePackObject(MessagePackSerializer source, MessagePackObject mpo);
    [ExtensionAttribute]
public static T FromMessagePackObject(MessagePackSerializer`1<T> source, MessagePackObject mpo);
}
internal abstract class MsgPack.Serialization.MessagePackSerializerProvider : object {
    public abstract virtual object Get(SerializationContext context, object providerParameter);
}
internal static class MsgPack.Serialization.Metadata._CultureInfo : object {
    public static PropertyInfo InvariantCulture;
    private static _CultureInfo();
}
internal static class MsgPack.Serialization.Metadata._DateTimeMessagePackSerializerHelpers : object {
    public static MethodInfo DetermineDateTimeConversionMethodMethod;
    private static _DateTimeMessagePackSerializerHelpers();
}
internal static class MsgPack.Serialization.Metadata._Decimal : object {
    public static ConstructorInfo Constructor;
    private static _Decimal();
}
internal static class MsgPack.Serialization.Metadata._DictionaryEntry : object {
    public static PropertyInfo Key;
    public static PropertyInfo Value;
    private static _DictionaryEntry();
}
internal static class MsgPack.Serialization.Metadata._EnumMessagePackSerializerHelpers : object {
    public static MethodInfo DetermineEnumSerializationMethodMethod;
    private static _EnumMessagePackSerializerHelpers();
}
internal static class MsgPack.Serialization.Metadata._FieldInfo : object {
    public static MethodInfo GetFieldFromHandle;
    public static MethodInfo GetValue;
    public static MethodInfo SetValue;
    private static _FieldInfo();
}
internal static class MsgPack.Serialization.Metadata._IDictionaryEnumerator : object {
    public static PropertyInfo Entry;
    private static _IDictionaryEnumerator();
}
internal static class MsgPack.Serialization.Metadata._IDisposable : object {
    public static MethodInfo Dispose;
    private static _IDisposable();
}
internal static class MsgPack.Serialization.Metadata._IEnumerator : object {
    public static MethodInfo MoveNext;
    public static PropertyInfo Current;
    private static _IEnumerator();
    public static PropertyInfo FindEnumeratorCurrentProperty(Type enumeratorType, CollectionTraits traits);
    public static MethodInfo FindEnumeratorMoveNextMethod(Type enumeratorType);
}
internal static class MsgPack.Serialization.Metadata._MessagePackObject : object {
    public static PropertyInfo IsNil;
    private static _MessagePackObject();
}
internal static class MsgPack.Serialization.Metadata._MessagePackSerializer : object {
    public static MethodInfo Create1_Method;
    public static PropertyInfo OwnerContext;
    private static _MessagePackSerializer();
}
internal static class MsgPack.Serialization.Metadata._MethodBase : object {
    public static MethodInfo GetMethodFromHandle;
    public static MethodInfo Invoke_2;
    private static _MethodBase();
}
internal static class MsgPack.Serialization.Metadata._Object : object {
    public static ConstructorInfo Ctor;
    private static _Object();
}
internal static class MsgPack.Serialization.Metadata._Packer : object {
    public static MethodInfo PackNull;
    public static MethodInfo PackNullAsync;
    private static _Packer();
}
internal static class MsgPack.Serialization.Metadata._SerializationContext : object {
    public static MethodInfo GetSerializer1_Parameter_Method;
    public static PropertyInfo SerializationMethod;
    private static _SerializationContext();
}
internal static class MsgPack.Serialization.Metadata._String : object {
    public static MethodInfo Format_P;
    private static _String();
}
internal static class MsgPack.Serialization.Metadata._Unpacker : object {
    public static MethodInfo Read;
    public static PropertyInfo ItemsCount;
    public static PropertyInfo IsArrayHeader;
    public static PropertyInfo IsMapHeader;
    public static MethodInfo ReadAsync;
    private static _Unpacker();
}
internal static class MsgPack.Serialization.Metadata._UnpackHelpers : object {
    public static MethodInfo GetItemsCount;
    public static MethodInfo GetEqualityComparer_1Method;
    public static MethodInfo UnpackCollection_1Method;
    public static MethodInfo UnpackCollectionAsync_1Method;
    public static MethodInfo ToNullable1Method;
    public static MethodInfo UnpackFromMessageAsyncMethod;
    public static MethodInfo GetIdentity_1Method;
    public static MethodInfo Unbox_1Method;
    private static Dictionary`2<Type, MethodInfo> _directUnpackMethods;
    private static Dictionary`2<Type, MethodInfo> _asyncDirectUnpackMethods;
    private static _UnpackHelpers();
    private static Dictionary`2<Type, MethodInfo> GetDirectUnpackMethods();
    private static Dictionary`2<Type, MethodInfo> GetAsyncDirectUnpackMethods();
    public static MethodInfo GetDirectUnpackMethod(Type type, bool forAsync);
}
public enum MsgPack.Serialization.NilImplication : Enum {
    public int value__;
    public static NilImplication MemberDefault;
    public static NilImplication Null;
    public static NilImplication Prohibit;
}
internal abstract class MsgPack.Serialization.NilImplicationHandler`4 : object {
    public TAction OnPacking(TPackingParameter parameter, NilImplication nilImplication);
    protected abstract virtual TCondition OnPackingMessagePackObject(TPackingParameter parameter);
    protected abstract virtual TCondition OnPackingReferenceTypeObject(TPackingParameter parameter);
    protected abstract virtual TCondition OnPackingNullableValueTypeObject(TPackingParameter parameter);
    protected abstract virtual TAction OnPackingCore(TPackingParameter parameter, TCondition condition);
    public TAction OnUnpacked(TUnpackedParameter parameter, NilImplication nilImplication);
    protected abstract virtual TAction OnNopOnUnpacked(TUnpackedParameter parameter);
    protected abstract virtual TAction OnThrowNullIsProhibitedExceptionOnUnpacked(TUnpackedParameter parameter);
    protected abstract virtual TAction OnThrowValueTypeCannotBeNull3OnUnpacked(TUnpackedParameter parameter);
}
internal class MsgPack.Serialization.NullTextWriter : TextWriter {
    internal static NullTextWriter Instance;
    public Encoding Encoding { get; }
    private static NullTextWriter();
    public virtual Encoding get_Encoding();
    public virtual void Close();
    public virtual void Flush();
    public virtual void Write(char value);
    public virtual void Write(Char[] buffer);
    public virtual void Write(Char[] buffer, int index, int count);
    public virtual void Write(bool value);
    public virtual void Write(int value);
    public virtual void Write(UInt32 value);
    public virtual void Write(long value);
    public virtual void Write(ulong value);
    public virtual void Write(float value);
    public virtual void Write(double value);
    public virtual void Write(decimal value);
    public virtual void Write(string value);
    public virtual void Write(object value);
    public virtual void Write(string format, object arg0);
    public virtual void Write(string format, object arg0, object arg1);
    public virtual void Write(string format, object arg0, object arg1, object arg2);
    public virtual void Write(string format, Object[] arg);
    public virtual void WriteLine();
    public virtual void WriteLine(char value);
    public virtual void WriteLine(Char[] buffer);
    public virtual void WriteLine(Char[] buffer, int index, int count);
    public virtual void WriteLine(bool value);
    public virtual void WriteLine(int value);
    public virtual void WriteLine(UInt32 value);
    public virtual void WriteLine(long value);
    public virtual void WriteLine(ulong value);
    public virtual void WriteLine(float value);
    public virtual void WriteLine(double value);
    public virtual void WriteLine(decimal value);
    public virtual void WriteLine(string value);
    public virtual void WriteLine(object value);
    public virtual void WriteLine(string format, object arg0);
    public virtual void WriteLine(string format, object arg0, object arg1);
    public virtual void WriteLine(string format, object arg0, object arg1, object arg2);
    public virtual void WriteLine(string format, Object[] arg);
}
[EditorBrowsableAttribute("1")]
public static class MsgPack.Serialization.PackHelpers : object {
    [EditorBrowsableAttribute("1")]
public static void PackToArray(Packer packer, TObject target, IList`1<Action`2<Packer, TObject>> operations);
    [EditorBrowsableAttribute("1")]
public static void PackToArray(PackToArrayParameters`1& parameter);
    [EditorBrowsableAttribute("1")]
public static Task PackToArrayAsync(Packer packer, TObject target, IList`1<Func`4<Packer, TObject, CancellationToken, Task>> operations, CancellationToken cancellationToken);
    [EditorBrowsableAttribute("1")]
public static Task PackToArrayAsync(PackToArrayAsyncParameters`1& parameter);
    [AsyncStateMachineAttribute("MsgPack.Serialization.PackHelpers/<PackToArrayAsyncCore>d__4`1")]
private static Task PackToArrayAsyncCore(Packer packer, TObject target, IList`1<Func`4<Packer, TObject, CancellationToken, Task>> operations, CancellationToken cancellationToken);
    [EditorBrowsableAttribute("1")]
public static void PackToMap(Packer packer, TObject target, IDictionary`2<string, Action`2<Packer, TObject>> operations);
    [EditorBrowsableAttribute("1")]
public static void PackToMap(PackToMapParameters`1& parameter);
    [EditorBrowsableAttribute("1")]
public static Task PackToMapAsync(Packer packer, TObject target, IDictionary`2<string, Func`4<Packer, TObject, CancellationToken, Task>> operations, CancellationToken cancellationToken);
    [EditorBrowsableAttribute("1")]
public static Task PackToMapAsync(PackToMapAsyncParameters`1& parameter);
    [AsyncStateMachineAttribute("MsgPack.Serialization.PackHelpers/<PackToMapAsyncCore>d__9`1")]
private static Task PackToMapAsyncCore(SerializationContext serializationContext, Packer packer, TObject target, IDictionary`2<string, Func`4<Packer, TObject, CancellationToken, Task>> operations, IDictionary`2<string, Func`2<TObject, bool>> nullCheckers, CancellationToken cancellationToken);
}
[EditorBrowsableAttribute("1")]
public class MsgPack.Serialization.PackToArrayAsyncParameters`1 : ValueType {
    public Packer Packer;
    public T Target;
    public IList`1<Func`4<Packer, T, CancellationToken, Task>> Operations;
    public CancellationToken CancellationToken;
}
[EditorBrowsableAttribute("1")]
public class MsgPack.Serialization.PackToArrayParameters`1 : ValueType {
    public Packer Packer;
    public T Target;
    public IList`1<Action`2<Packer, T>> Operations;
}
[EditorBrowsableAttribute("1")]
public class MsgPack.Serialization.PackToMapAsyncParameters`1 : ValueType {
    public Packer Packer;
    public T Target;
    public SerializationContext SerializationContext;
    public IDictionary`2<string, Func`2<T, bool>> NullCheckers;
    public IDictionary`2<string, Func`4<Packer, T, CancellationToken, Task>> Operations;
    public CancellationToken CancellationToken;
}
[EditorBrowsableAttribute("1")]
public class MsgPack.Serialization.PackToMapParameters`1 : ValueType {
    public Packer Packer;
    public T Target;
    public SerializationContext SerializationContext;
    public IDictionary`2<string, Func`2<T, bool>> NullCheckers;
    public IDictionary`2<string, Action`2<Packer, T>> Operations;
}
internal interface MsgPack.Serialization.Polymorphic.IPolymorphicDeserializer {
    public abstract virtual object PolymorphicUnpackFrom(Unpacker unpacker);
    public abstract virtual Task`1<object> PolymorphicUnpackFromAsync(Unpacker unpacker, CancellationToken cancellationToken);
}
internal interface MsgPack.Serialization.Polymorphic.IPolymorphicHelperAttribute {
    public PolymorphismTarget Target { get; }
    public abstract virtual PolymorphismTarget get_Target();
}
internal interface MsgPack.Serialization.Polymorphic.IPolymorphicKnownTypeAttribute {
    public Type BindingType { get; }
    public string TypeCode { get; }
    public abstract virtual Type get_BindingType();
    public abstract virtual string get_TypeCode();
}
internal interface MsgPack.Serialization.Polymorphic.IPolymorphicRuntimeTypeAttribute {
    public Type VerifierType { get; }
    public string VerifierMethodName { get; }
    public abstract virtual Type get_VerifierType();
    public abstract virtual string get_VerifierMethodName();
}
internal interface MsgPack.Serialization.Polymorphic.IPolymorphicTupleItemTypeAttribute {
    public int ItemNumber { get; }
    public abstract virtual int get_ItemNumber();
}
internal class MsgPack.Serialization.Polymorphic.KnownTypePolymorphicMessagePackSerializer`1 : MessagePackSerializer`1<T> {
    private PolymorphismSchema _schema;
    private IDictionary`2<string, RuntimeTypeHandle> _typeHandleMap;
    private IDictionary`2<RuntimeTypeHandle, string> _typeCodeMap;
    public KnownTypePolymorphicMessagePackSerializer`1(SerializationContext ownerContext, PolymorphismSchema schema);
    private static IDictionary`2<string, RuntimeTypeHandle> BuildTypeCodeTypeHandleMap(IDictionary`2<string, Type> typeMap);
    private static IDictionary`2<RuntimeTypeHandle, string> BuildTypeHandleTypeCodeMap(IDictionary`2<string, Type> typeMap);
    private MessagePackSerializer GetActualTypeSerializer(Type actualType);
    protected internal virtual void PackToCore(Packer packer, T objectTree);
    private string GetTypeCode(T objectTree);
    protected internal virtual T UnpackFromCore(Unpacker unpacker);
    private Type GetTypeFromCode(string typeCode);
    private sealed virtual override object MsgPack.Serialization.Polymorphic.IPolymorphicDeserializer.PolymorphicUnpackFrom(Unpacker unpacker);
    [AsyncStateMachineAttribute("MsgPack.Serialization.Polymorphic.KnownTypePolymorphicMessagePackSerializer`1/<PackToAsyncCore>d__12")]
protected internal virtual Task PackToAsyncCore(Packer packer, T objectTree, CancellationToken cancellationToken);
    protected internal virtual Task`1<T> UnpackFromAsyncCore(Unpacker unpacker, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.Serialization.Polymorphic.KnownTypePolymorphicMessagePackSerializer`1/<MsgPack-Serialization-Polymorphic-IPolymorphicDeserializer-PolymorphicUnpackFromAsync>d__14")]
private sealed virtual override Task`1<object> MsgPack.Serialization.Polymorphic.IPolymorphicDeserializer.PolymorphicUnpackFromAsync(Unpacker unpacker, CancellationToken cancellationToken);
    protected internal virtual void UnpackToCore(Unpacker unpacker, T collection);
    [CompilerGeneratedAttribute]
private Type <UnpackFromCore>b__9_0(string c);
    [CompilerGeneratedAttribute]
private T <UnpackFromCore>b__9_1(Type t, Unpacker u);
    [CompilerGeneratedAttribute]
private Type <UnpackFromAsyncCore>b__13_0(string c);
    [CompilerGeneratedAttribute]
private Task`1<object> <UnpackFromAsyncCore>b__13_1(Type t, Unpacker u, CancellationToken c);
}
internal class MsgPack.Serialization.Polymorphic.PolymorphicSerializerProvider`1 : MessagePackSerializerProvider {
    private MessagePackSerializer`1<T> _defaultSerializer;
    private PolymorphismSchema _defaultSchema;
    public PolymorphicSerializerProvider`1(MessagePackSerializer`1<T> defaultSerializer);
    public virtual object Get(SerializationContext context, object providerParameter);
}
internal static class MsgPack.Serialization.Polymorphic.RuntimeTypeVerifier : object {
    private static int CacheSize;
    private static ReaderWriterLockSlim _resultCacheLock;
    private static Dictionary`2<KeyValuePair`2<string, string>, bool> _resultCache;
    private static Queue`1<KeyValuePair`2<string, string>> _histories;
    private static RuntimeTypeVerifier();
    public static void Verify(AssemblyName assemblyName, string typeFullName, Func`2<PolymorphicTypeVerificationContext, bool> typeVerifier);
    private static bool VerifyCore(AssemblyName assemblyName, string assemblyFullName, string typeFullName, Func`2<PolymorphicTypeVerificationContext, bool> typeVerifier);
}
internal class MsgPack.Serialization.Polymorphic.TypeEmbedingPolymorphicMessagePackSerializer`1 : MessagePackSerializer`1<T> {
    private PolymorphismSchema _schema;
    public TypeEmbedingPolymorphicMessagePackSerializer`1(SerializationContext ownerContext, PolymorphismSchema schema);
    private MessagePackSerializer GetActualTypeSerializer(Type actualType);
    protected internal virtual void PackToCore(Packer packer, T objectTree);
    protected internal virtual T UnpackFromCore(Unpacker unpacker);
    private sealed virtual override object MsgPack.Serialization.Polymorphic.IPolymorphicDeserializer.PolymorphicUnpackFrom(Unpacker unpacker);
    [AsyncStateMachineAttribute("MsgPack.Serialization.Polymorphic.TypeEmbedingPolymorphicMessagePackSerializer`1/<PackToAsyncCore>d__6")]
protected internal virtual Task PackToAsyncCore(Packer packer, T objectTree, CancellationToken cancellationToken);
    protected internal virtual Task`1<T> UnpackFromAsyncCore(Unpacker unpacker, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.Serialization.Polymorphic.TypeEmbedingPolymorphicMessagePackSerializer`1/<MsgPack-Serialization-Polymorphic-IPolymorphicDeserializer-PolymorphicUnpackFromAsync>d__8")]
private sealed virtual override Task`1<object> MsgPack.Serialization.Polymorphic.IPolymorphicDeserializer.PolymorphicUnpackFromAsync(Unpacker unpacker, CancellationToken cancellationToken);
    protected internal virtual void UnpackToCore(Unpacker unpacker, T collection);
    [CompilerGeneratedAttribute]
private Type <UnpackFromCore>b__4_0(Unpacker u);
    [CompilerGeneratedAttribute]
private T <UnpackFromCore>b__4_1(Type t, Unpacker u);
    [CompilerGeneratedAttribute]
private Task`1<Type> <UnpackFromAsyncCore>b__7_0(Unpacker u, CancellationToken c);
    [CompilerGeneratedAttribute]
private Task`1<object> <UnpackFromAsyncCore>b__7_1(Type t, Unpacker u, CancellationToken c);
}
internal static class MsgPack.Serialization.Polymorphic.TypeInfoEncoder : object {
    private static string Elipsis;
    public static void Encode(Packer packer, string typeCode);
    [AsyncStateMachineAttribute("MsgPack.Serialization.Polymorphic.TypeInfoEncoder/<EncodeAsync>d__2")]
public static Task EncodeAsync(Packer packer, string typeCode, CancellationToken cancellationToken);
    public static void Encode(Packer packer, Type type);
    [AsyncStateMachineAttribute("MsgPack.Serialization.Polymorphic.TypeInfoEncoder/<EncodeAsync>d__4")]
public static Task EncodeAsync(Packer packer, Type type, CancellationToken cancellationToken);
    public static T Decode(Unpacker unpacker, Func`2<string, Type> typeFinder, Func`3<Type, Unpacker, T> unpacking);
    public static T Decode(Unpacker unpacker, Func`2<Unpacker, Type> typeDecoder, Func`3<Type, Unpacker, T> unpacking);
    [AsyncStateMachineAttribute("MsgPack.Serialization.Polymorphic.TypeInfoEncoder/<DecodeAsync>d__7`1")]
public static Task`1<T> DecodeAsync(Unpacker unpacker, Func`2<string, Type> typeFinder, Func`4<Type, Unpacker, CancellationToken, Task`1<object>> unpackingAsync, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.Serialization.Polymorphic.TypeInfoEncoder/<DecodeAsync>d__8`1")]
public static Task`1<T> DecodeAsync(Unpacker unpacker, Func`3<Unpacker, CancellationToken, Task`1<Type>> asyncTypeDecoder, Func`4<Type, Unpacker, CancellationToken, Task`1<object>> unpackingAsync, CancellationToken cancellationToken);
    public static Type DecodeRuntimeTypeInfo(Unpacker unpacker, Func`2<PolymorphicTypeVerificationContext, bool> typeVerifier);
    private static void ThrowFailedToDecodeEncodingType();
    private static void ThrowUnknownEncodingType(byte encodeType);
    private static void ThrowFailedToDecodeCompressedTypeName();
    private static void ThrowFailedToDecodeAssemblySimpleName();
    private static void ThrowFailedToDecodeAssemblyVersion();
    private static void ThrowFailedToDecodeAssemblyCulture();
    private static void ThrowFailedToDecodeAssemblyKeyToken();
    private static void CheckUnpackerForRuntimeTypeInfoDecoding(Unpacker unpacker);
    private static void ThrowEncodedTypeIsNotInNonNillArray();
    private static void ThrowEncodedTypeDoesNotHaveValidArrayItems();
    private static AssemblyName BuildAssemblyName(string assemblySimpleName, Byte[] version, string culture, Byte[] publicKeyToken);
    private static string DecompressTypeName(string assemblySimpleName, string compressedTypeName);
    private static Type LoadDecodedType(AssemblyName assemblyName, string typeFullName);
    [AsyncStateMachineAttribute("MsgPack.Serialization.Polymorphic.TypeInfoEncoder/<DecodeRuntimeTypeInfoAsync>d__23")]
public static Task`1<Type> DecodeRuntimeTypeInfoAsync(Unpacker unpacker, Func`2<PolymorphicTypeVerificationContext, bool> typeVerifier, CancellationToken cancellationToken);
}
internal enum MsgPack.Serialization.Polymorphic.TypeInfoEncoding : Enum {
    public byte value__;
    public static TypeInfoEncoding KnownType;
    public static TypeInfoEncoding RawCompressed;
}
public class MsgPack.Serialization.PolymorphicTypeVerificationContext : ValueType {
    private string _loadingTypeFullName;
    private string _loadingAssemblyFullName;
    private AssemblyName _loadingAssemblyName;
    public string LoadingTypeFullName { get; }
    public string LoadingAssemblyFullName { get; }
    public AssemblyName LoadingAssemblyName { get; }
    internal PolymorphicTypeVerificationContext(string loadingTypeFullName, AssemblyName loadingAssemblyName, string loadingAssemblyFullName);
    public string get_LoadingTypeFullName();
    public string get_LoadingAssemblyFullName();
    public AssemblyName get_LoadingAssemblyName();
    public virtual string ToString();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(PolymorphicTypeVerificationContext other);
    public virtual int GetHashCode();
    public static bool op_Equality(PolymorphicTypeVerificationContext left, PolymorphicTypeVerificationContext right);
    public static bool op_Inequality(PolymorphicTypeVerificationContext left, PolymorphicTypeVerificationContext right);
}
[DebuggerDisplayAttribute("{DebugString}")]
public class MsgPack.Serialization.PolymorphismSchema : object {
    private static Dictionary`2<string, Type> EmptyMap;
    private static PolymorphismSchema[] EmptyChildren;
    [CompilerGeneratedAttribute]
private Type <TargetType>k__BackingField;
    [CompilerGeneratedAttribute]
private PolymorphismType <PolymorphismType>k__BackingField;
    private ReadOnlyDictionary`2<string, Type> _codeTypeMapping;
    [CompilerGeneratedAttribute]
private Func`2<PolymorphicTypeVerificationContext, bool> <TypeVerifier>k__BackingField;
    [CompilerGeneratedAttribute]
private PolymorphismSchemaChildrenType <ChildrenType>k__BackingField;
    private ReadOnlyCollection`1<PolymorphismSchema> _children;
    private static Func`2<PolymorphicTypeVerificationContext, bool> DefaultTypeVerfiier;
    internal static PolymorphismSchema Default;
    internal static MethodInfo ForPolymorphicObjectTypeEmbeddingMethod;
    internal static MethodInfo ForPolymorphicObjectCodeTypeMappingMethod;
    internal static MethodInfo ForContextSpecifiedCollectionMethod;
    internal static MethodInfo ForPolymorphicCollectionTypeEmbeddingMethod;
    internal static MethodInfo ForPolymorphicCollectionCodeTypeMappingMethod;
    internal static MethodInfo ForContextSpecifiedDictionaryMethod;
    internal static MethodInfo ForPolymorphicDictionaryTypeEmbeddingMethod;
    internal static MethodInfo ForPolymorphicDictionaryCodeTypeMappingMethod;
    internal static MethodInfo ForPolymorphicTupleMethod;
    internal static ConstructorInfo CodeTypeMapConstructor;
    internal static MethodInfo AddToCodeTypeMapMethod;
    internal Type TargetType { get; private set; }
    internal PolymorphismType PolymorphismType { get; private set; }
    internal IDictionary`2<string, Type> CodeTypeMapping { get; }
    internal bool UseDefault { get; }
    internal bool UseTypeEmbedding { get; }
    internal Func`2<PolymorphicTypeVerificationContext, bool> TypeVerifier { get; private set; }
    internal PolymorphismSchemaChildrenType ChildrenType { get; private set; }
    internal IList`1<PolymorphismSchema> ChildSchemaList { get; }
    internal PolymorphismSchema ItemSchema { get; }
    internal PolymorphismSchema KeySchema { get; }
    internal string DebugString { get; }
    private PolymorphismSchema(Type targetType, PolymorphismType polymorphismType, Func`2<PolymorphicTypeVerificationContext, bool> typeVerifier, PolymorphismSchemaChildrenType childrenType, PolymorphismSchema[] childItemSchemaList);
    private PolymorphismSchema(Type targetType, PolymorphismType polymorphismType, IDictionary`2<string, Type> codeTypeMapping, Func`2<PolymorphicTypeVerificationContext, bool> typeVerifier, PolymorphismSchemaChildrenType childrenType, PolymorphismSchema[] childItemSchemaList);
    private PolymorphismSchema(Type targetType, PolymorphismType polymorphismType, ReadOnlyDictionary`2<string, Type> codeTypeMapping, Func`2<PolymorphicTypeVerificationContext, bool> typeVerifier, PolymorphismSchemaChildrenType childrenType, ReadOnlyCollection`1<PolymorphismSchema> childItemSchemaList);
    private static PolymorphismSchema();
    public static PolymorphismSchema ForPolymorphicObject(Type targetType);
    public static PolymorphismSchema ForPolymorphicObject(Type targetType, Func`2<PolymorphicTypeVerificationContext, bool> typeVerifier);
    public static PolymorphismSchema ForPolymorphicObject(Type targetType, IDictionary`2<string, Type> codeTypeMapping);
    public static PolymorphismSchema ForContextSpecifiedCollection(Type targetType, PolymorphismSchema itemSchema);
    public static PolymorphismSchema ForPolymorphicCollection(Type targetType, PolymorphismSchema itemSchema);
    public static PolymorphismSchema ForPolymorphicCollection(Type targetType, PolymorphismSchema itemSchema, Func`2<PolymorphicTypeVerificationContext, bool> typeVerifier);
    public static PolymorphismSchema ForPolymorphicCollection(Type targetType, IDictionary`2<string, Type> codeTypeMapping, PolymorphismSchema itemSchema);
    public static PolymorphismSchema ForContextSpecifiedDictionary(Type targetType, PolymorphismSchema keySchema, PolymorphismSchema valueSchema);
    public static PolymorphismSchema ForPolymorphicDictionary(Type targetType, PolymorphismSchema keySchema, PolymorphismSchema valueSchema);
    public static PolymorphismSchema ForPolymorphicDictionary(Type targetType, PolymorphismSchema keySchema, PolymorphismSchema valueSchema, Func`2<PolymorphicTypeVerificationContext, bool> typeVerifier);
    public static PolymorphismSchema ForPolymorphicDictionary(Type targetType, IDictionary`2<string, Type> codeTypeMapping, PolymorphismSchema keySchema, PolymorphismSchema valueSchema);
    public static PolymorphismSchema ForPolymorphicTuple(Type targetType, PolymorphismSchema[] itemSchemaList);
    private static void VerifyArity(Type tupleType, ICollection`1<PolymorphismSchema> itemSchemaList);
    internal PolymorphismSchema FilterSelf();
    [CompilerGeneratedAttribute]
internal Type get_TargetType();
    [CompilerGeneratedAttribute]
private void set_TargetType(Type value);
    [CompilerGeneratedAttribute]
internal PolymorphismType get_PolymorphismType();
    [CompilerGeneratedAttribute]
private void set_PolymorphismType(PolymorphismType value);
    internal IDictionary`2<string, Type> get_CodeTypeMapping();
    internal bool get_UseDefault();
    internal bool get_UseTypeEmbedding();
    [CompilerGeneratedAttribute]
internal Func`2<PolymorphicTypeVerificationContext, bool> get_TypeVerifier();
    [CompilerGeneratedAttribute]
private void set_TypeVerifier(Func`2<PolymorphicTypeVerificationContext, bool> value);
    [CompilerGeneratedAttribute]
internal PolymorphismSchemaChildrenType get_ChildrenType();
    [CompilerGeneratedAttribute]
private void set_ChildrenType(PolymorphismSchemaChildrenType value);
    internal IList`1<PolymorphismSchema> get_ChildSchemaList();
    internal PolymorphismSchema get_ItemSchema();
    private PolymorphismSchema TryGetItemSchema();
    internal PolymorphismSchema get_KeySchema();
    private PolymorphismSchema TryGetKeySchema();
    internal string get_DebugString();
    private void ToDebugString(StringBuilder buffer);
    internal static PolymorphismSchema Create(Type type, Nullable`1<SerializingMember> memberMayBeNull);
    private static PolymorphismSchema CreateCore(MemberInfo member, PolymorphismSchema defaultSchema);
}
internal enum MsgPack.Serialization.PolymorphismSchemaChildrenType : Enum {
    public int value__;
    public static PolymorphismSchemaChildrenType None;
    public static PolymorphismSchemaChildrenType CollectionItems;
    public static PolymorphismSchemaChildrenType DictionaryKeyValues;
    public static PolymorphismSchemaChildrenType TupleItems;
}
internal enum MsgPack.Serialization.PolymorphismTarget : Enum {
    public int value__;
    public static PolymorphismTarget Member;
    public static PolymorphismTarget CollectionItem;
    public static PolymorphismTarget DictionaryKey;
    public static PolymorphismTarget TupleItem;
}
internal enum MsgPack.Serialization.PolymorphismType : Enum {
    public int value__;
    public static PolymorphismType None;
    public static PolymorphismType KnownTypes;
    public static PolymorphismType RuntimeType;
}
[ExtensionAttribute]
internal static class MsgPack.Serialization.Reflection.GenericTypeExtensions : object {
    [ExtensionAttribute]
public static bool Implements(Type source, Type genericType);
    private static IEnumerable`1<Type> EnumerateGenericIntefaces(Type source, Type genericType, bool includesOwn);
    [ExtensionAttribute]
public static string GetName(Type source);
    [ExtensionAttribute]
public static string GetFullName(Type source);
}
[ExtensionAttribute]
internal static class MsgPack.Serialization.Reflection.ReflectionExtensions : object {
    [ExtensionAttribute]
public static bool IsAssignableTo(Type source, Type target);
}
internal class MsgPack.Serialization.Reflection.TracingILGenerator : object {
    private static MethodInfo _type_GetTypeFromHandle;
    private ILGenerator _underlying;
    private TextWriter _trace;
    private Dictionary`2<LocalBuilder, string> _localDeclarations;
    private Dictionary`2<Label, string> _labels;
    private Label _endOfMethod;
    private Stack`1<Label> _endOfExceptionBlocks;
    private bool _isInDynamicMethod;
    private int _indentLevel;
    private string _indentChars;
    private int _lineNumber;
    private bool _isEnded;
    private bool _isDebuggable;
    public Label EndOfMethod { get; }
    public bool IsInExceptionBlock { get; }
    public bool IsEnded { get; }
    public TracingILGenerator(DynamicMethod dynamicMethod, TextWriter traceWriter, bool isDebuggable);
    public TracingILGenerator(MethodBuilder methodBuilder, TextWriter traceWriter, bool isDebuggable);
    public TracingILGenerator(ConstructorBuilder constructorBuilder, TextWriter traceWriter, bool isDebuggable);
    private TracingILGenerator(ILGenerator underlying, bool isInDynamicMethod, TextWriter traceWriter, bool isDebuggable);
    private static TracingILGenerator();
    public void EmitAnyCall(MethodInfo target);
    public void EmitGetProperty(PropertyInfo property);
    public void EmitCallConstructor(ConstructorInfo constructor);
    public void EmitLdargThis();
    public void EmitAnyLdarg(int argumentIndex);
    public void EmitAnyLdarga(int argumentIndex);
    public void EmitAnyLdloc(int localIndex);
    public void EmitAnyLdloc(LocalBuilder local);
    public void EmitAnyLdloca(int localIndex);
    public void EmitAnyLdloca(LocalBuilder local);
    public void EmitAnyLdc_I4(int value);
    public void EmitAnyStloc(int localIndex);
    public void EmitAnyStloc(LocalBuilder local);
    public void EmitNewarr(Type elementType, long length);
    private void EmitNewarrCore(Type elementType, long length);
    public void EmitAnyLdelem(Type elementType, Action`1<TracingILGenerator> arrayLoadingEmitter, Action`1<TracingILGenerator> indexEmitter);
    public void EmitAnyStelem(Type elementType, Action`1<TracingILGenerator> arrayLoadingEmitter, Action`1<TracingILGenerator> indexEmitter, Action`1<TracingILGenerator> elementLoadingEmitter);
    public void EmitLiteralInteger(long value);
    public void EmitTypeOf(Type type);
    public Label get_EndOfMethod();
    public bool get_IsInExceptionBlock();
    public bool get_IsEnded();
    public sealed virtual void Dispose();
    public void EmitRet();
    public void FlushTrace();
    public LocalBuilder DeclareLocal(Type localType);
    public LocalBuilder DeclareLocal(Type localType, string name);
    private LocalBuilder DeclareLocalCore(Type localType, string name);
    public Label BeginExceptionBlock();
    public void BeginFinallyBlock();
    public void EndExceptionBlock();
    public Label DefineLabel(string name);
    public void MarkLabel(Label label);
    public void TraceWrite(string value);
    public void TraceWriteLine();
    public void TraceWriteLine(string value);
    public void TraceWriteLine(string format, object arg0);
    private void TraceType(Type type);
    private static void WriteType(TextWriter writer, Type type);
    private void TraceField(FieldInfo field);
    private void TraceMethod(MethodBase method);
    private static void WriteCallingConventions(TextWriter writer, Nullable`1<CallingConventions> managedCallingConverntions, Nullable`1<CallingConvention> unamangedCallingConvention);
    private void TraceOpCode(OpCode opCode);
    private void TraceOperand(int value);
    private void TraceOperand(long value);
    private void TraceOperand(double value);
    private void TraceOperand(string value);
    private void TraceOperand(Label value);
    private void TraceOperand(Type value);
    private void TraceOperand(FieldInfo value);
    private void TraceOperand(MethodBase value);
    private void TraceOperandToken(Type target);
    private void TraceOperandToken(FieldInfo target);
    private void TraceOperandToken(MethodBase target);
    private void TraceOperandTokenValue(int value);
    private void TraceStart();
    private void WriteLineNumber();
    private void WriteIndent();
    private void WriteIndent(TextWriter writer, int indentLevel);
    private void Indent();
    private void Unindent();
    public void EmitLdarg_0();
    public void EmitLdarg_1();
    public void EmitLdarg_2();
    public void EmitLdarg_3();
    public void EmitLdloc_0();
    public void EmitLdloc_1();
    public void EmitLdloc_2();
    public void EmitLdloc_3();
    public void EmitStloc_0();
    public void EmitStloc_1();
    public void EmitStloc_2();
    public void EmitStloc_3();
    public void EmitLdarg_S(byte value);
    public void EmitLdarga_S(byte value);
    public void EmitLdloc_S(byte value);
    public void EmitLdloca_S(byte value);
    public void EmitStloc_S(byte value);
    public void EmitLdnull();
    public void EmitLdc_I4_M1();
    public void EmitLdc_I4_0();
    public void EmitLdc_I4_1();
    public void EmitLdc_I4_2();
    public void EmitLdc_I4_3();
    public void EmitLdc_I4_4();
    public void EmitLdc_I4_5();
    public void EmitLdc_I4_6();
    public void EmitLdc_I4_7();
    public void EmitLdc_I4_8();
    public void EmitLdc_I4_S(byte value);
    public void EmitLdc_I4(int value);
    public void EmitLdc_I8(long value);
    public void EmitLdc_R4(float value);
    public void EmitLdc_R8(double value);
    public void EmitPop();
    public void EmitCall(MethodInfo target);
    public void EmitBr(Label target);
    public void EmitBrfalse(Label target);
    public void EmitBrtrue(Label target);
    public void EmitAdd();
    public void EmitAnd();
    public void EmitCallvirt(MethodInfo target);
    public void EmitLdobj(Type type);
    public void EmitLdstr(string value);
    public void EmitNewobj(ConstructorInfo constructor);
    public void EmitThrow();
    public void EmitLdfld(FieldInfo field);
    public void EmitLdflda(FieldInfo field);
    public void EmitStfld(FieldInfo field);
    public void EmitStobj(Type type);
    public void EmitBox(Type type);
    public void EmitNewarr(Type type);
    public void EmitLdelema(Type type);
    public void EmitLdelem_I1();
    public void EmitLdelem_U1();
    public void EmitLdelem_I2();
    public void EmitLdelem_U2();
    public void EmitLdelem_I4();
    public void EmitLdelem_U4();
    public void EmitLdelem_I8();
    public void EmitLdelem_R4();
    public void EmitLdelem_R8();
    public void EmitLdelem_Ref();
    public void EmitStelem_I1();
    public void EmitStelem_I2();
    public void EmitStelem_I4();
    public void EmitStelem_I8();
    public void EmitStelem_R4();
    public void EmitStelem_R8();
    public void EmitStelem_Ref();
    public void EmitLdelem(Type type);
    public void EmitStelem(Type type);
    public void EmitUnbox_Any(Type type);
    public void EmitLdtoken(Type target);
    public void EmitLdtoken(MethodBase target);
    public void EmitLdtoken(FieldInfo target);
    public void EmitCeq();
    public void EmitCgt();
    public void EmitClt();
    public void EmitLdftn(MethodInfo method);
    public void EmitLdarg(int index);
    public void EmitLdarga(int index);
    public void EmitLdloc(int index);
    public void EmitLdloca(int index);
    public void EmitStloc(int index);
    public void EmitInitobj(Type type);
}
[ExtensionAttribute]
internal static class MsgPack.Serialization.ReflectionExtensions : object {
    private static Type[] ExceptionConstructorWithInnerParameterTypes;
    private static Type[] ObjectAddParameterTypes;
    private static ReflectionExtensions();
    [ExtensionAttribute]
internal static CollectionTraits GetCollectionTraits(Type source, CollectionTraitOptions options, bool allowNonCollectionEnumerableTypes);
    private static bool TryCreateCollectionTraitsForIEnumerableT(Type source, GenericCollectionTypes genericTypes, CollectionTraitOptions options, MethodInfo getMethod, CollectionTraits& result);
    private static bool TryCreateCollectionTraitsForHasGetEnumeratorType(Type source, CollectionTraitOptions options, MethodInfo getEnumerator, CollectionTraits& result);
    private static bool TryCreateGenericCollectionTraits(Type source, Type type, CollectionTraitOptions options, CollectionTraits& result);
    private static bool DetermineCollectionInterfaces(Type type, GenericCollectionTypes& genericTypes, Type& idictionary, Type& ilist, Type& icollection, Type& ienumerable);
    private static MethodInfo GetGetEnumeratorMethodFromElementType(Type targetType, Type elementType, CollectionTraitOptions options);
    private static MethodInfo GetGetEnumeratorMethodFromEnumerableType(Type targetType, Type enumerableType, CollectionTraitOptions options);
    private static MethodInfo FindInterfaceMethod(Type targetType, Type interfaceType, string name, Type[] parameterTypes);
    private static MethodInfo GetAddMethod(Type targetType, Type argumentType, CollectionTraitOptions options);
    private static MethodInfo GetCountGetterMethod(Type targetType, Type elementType, CollectionTraitOptions options);
    private static MethodInfo GetAddMethod(Type targetType, Type keyType, Type valueType, CollectionTraitOptions options);
    private static bool FilterCollectionType(Type type, object filterCriteria);
    private static bool IsIEnumeratorT(Type interface);
    [ExtensionAttribute]
public static bool GetHasPublicGetter(MemberInfo source);
    [ExtensionAttribute]
public static bool GetHasPublicSetter(MemberInfo source);
    [ExtensionAttribute]
public static bool GetIsPublic(MemberInfo source);
    [ExtensionAttribute]
public static TDelegate CreateConstructorDelegate(ConstructorInfo constructor);
    private static object CreateDelegate(Type delegateType, Type targetType, ConstructorInfo constructor, Type[] parameterTypes);
    [ExtensionAttribute]
public static Type[] GetParameterTypes(MethodBase source);
    [ExtensionAttribute]
public static Type GetMemberValueType(MemberInfo source);
    [ExtensionAttribute]
public static object InvokePreservingExceptionType(ConstructorInfo source, Object[] parameters);
    [ExtensionAttribute]
public static object InvokePreservingExceptionType(MethodInfo source, object instance, Object[] parameters);
    public static T CreateInstancePreservingExceptionType(Type instanceType, Object[] constructorParameters);
    public static object CreateInstancePreservingExceptionType(Type type, Object[] constructorParameters);
    private static Exception HoistUpInnerException(TargetInvocationException targetInvocationException);
}
[EditorBrowsableAttribute("1")]
public static class MsgPack.Serialization.ReflectionHelpers : object {
    [EditorBrowsableAttribute("1")]
public static MethodInfo GetMethod(Type type, string name, Type[] parameterTypes);
    [EditorBrowsableAttribute("1")]
public static FieldInfo GetField(Type type, string name);
}
[PreserveAttribute]
internal class MsgPack.Serialization.ReflectionSerializers.ReflectionCollectionMessagePackSerializer`2 : CollectionMessagePackSerializer`2<TCollection, TItem> {
    private Func`2<int, TCollection> _factory;
    private bool _isPackable;
    private bool _isUnpackable;
    private bool _isAsyncPackable;
    private bool _isAsyncUnpackable;
    public ReflectionCollectionMessagePackSerializer`2(SerializationContext ownerContext, Type targetType, CollectionTraits collectionTraits, PolymorphismSchema itemsSchema, SerializationTarget targetInfo);
    protected internal virtual void PackToCore(Packer packer, TCollection objectTree);
    protected internal virtual TCollection UnpackFromCore(Unpacker unpacker);
    protected internal virtual Task PackToAsyncCore(Packer packer, TCollection objectTree, CancellationToken cancellationToken);
    protected internal virtual Task`1<TCollection> UnpackFromAsyncCore(Unpacker unpacker, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.Serialization.ReflectionSerializers.ReflectionCollectionMessagePackSerializer`2/<UnpackFromMessageAsync>d__10")]
private Task`1<TCollection> UnpackFromMessageAsync(Unpacker unpacker, CancellationToken cancellationToken);
    protected virtual TCollection CreateInstance(int initialCapacity);
}
[PreserveAttribute]
internal class MsgPack.Serialization.ReflectionSerializers.ReflectionDictionaryMessagePackSerializer`3 : DictionaryMessagePackSerializer`3<TDictionary, TKey, TValue> {
    private Func`2<int, TDictionary> _factory;
    private bool _isPackable;
    private bool _isUnpackable;
    private bool _isAsyncPackable;
    private bool _isAsyncUnpackable;
    public ReflectionDictionaryMessagePackSerializer`3(SerializationContext ownerContext, Type targetType, CollectionTraits collectionTraits, PolymorphismSchema itemsSchema, SerializationTarget targetInfo);
    protected internal virtual void PackToCore(Packer packer, TDictionary objectTree);
    protected internal virtual TDictionary UnpackFromCore(Unpacker unpacker);
    protected internal virtual Task PackToAsyncCore(Packer packer, TDictionary objectTree, CancellationToken cancellationToken);
    protected internal virtual Task`1<TDictionary> UnpackFromAsyncCore(Unpacker unpacker, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.Serialization.ReflectionSerializers.ReflectionDictionaryMessagePackSerializer`3/<UnpackFromMessageAsync>d__10")]
private Task`1<TDictionary> UnpackFromMessageAsync(Unpacker unpacker, CancellationToken cancellationToken);
    protected virtual TDictionary CreateInstance(int initialCapacity);
}
[PreserveAttribute]
internal class MsgPack.Serialization.ReflectionSerializers.ReflectionEnumerableMessagePackSerializer`2 : EnumerableMessagePackSerializer`2<TCollection, TItem> {
    private Func`2<int, TCollection> _factory;
    private Action`2<TCollection, TItem> _addItem;
    private bool _isPackable;
    private bool _isUnpackable;
    private bool _isAsyncPackable;
    private bool _isAsyncUnpackable;
    public ReflectionEnumerableMessagePackSerializer`2(SerializationContext ownerContext, Type targetType, CollectionTraits collectionTraits, PolymorphismSchema itemsSchema, SerializationTarget targetInfo);
    protected internal virtual void PackToCore(Packer packer, TCollection objectTree);
    protected internal virtual Task PackToAsyncCore(Packer packer, TCollection objectTree, CancellationToken cancellationToken);
    protected internal virtual TCollection UnpackFromCore(Unpacker unpacker);
    [AsyncStateMachineAttribute("MsgPack.Serialization.ReflectionSerializers.ReflectionEnumerableMessagePackSerializer`2/<UnpackFromAsyncCore>d__10")]
protected internal virtual Task`1<TCollection> UnpackFromAsyncCore(Unpacker unpacker, CancellationToken cancellationToken);
    protected virtual TCollection CreateInstance(int initialCapacity);
    protected virtual void AddItem(TCollection collection, TItem item);
}
[PreserveAttribute]
internal class MsgPack.Serialization.ReflectionSerializers.ReflectionEnumMessagePackSerializer`1 : EnumMessagePackSerializer`1<T> {
    public ReflectionEnumMessagePackSerializer`1(SerializationContext context);
    protected internal virtual void PackUnderlyingValueTo(Packer packer, T enumValue);
    protected internal virtual Task PackUnderlyingValueToAsync(Packer packer, T enumValue, CancellationToken cancellationToken);
    protected internal virtual T UnpackFromUnderlyingValue(MessagePackObject messagePackObject);
}
internal class MsgPack.Serialization.ReflectionSerializers.ReflectionNilImplicationHandler : NilImplicationHandler`4<Action`1<object>, Func`2<object, bool>, ReflectionSerializerNilImplicationHandlerParameter, ReflectionSerializerNilImplicationHandlerOnUnpackedParameter> {
    public static ReflectionNilImplicationHandler Instance;
    private static ReflectionNilImplicationHandler();
    protected virtual Func`2<object, bool> OnPackingMessagePackObject(ReflectionSerializerNilImplicationHandlerParameter parameter);
    protected virtual Func`2<object, bool> OnPackingReferenceTypeObject(ReflectionSerializerNilImplicationHandlerParameter parameter);
    protected virtual Func`2<object, bool> OnPackingNullableValueTypeObject(ReflectionSerializerNilImplicationHandlerParameter parameter);
    protected virtual Action`1<object> OnPackingCore(ReflectionSerializerNilImplicationHandlerParameter parameter, Func`2<object, bool> condition);
    protected virtual Action`1<object> OnNopOnUnpacked(ReflectionSerializerNilImplicationHandlerOnUnpackedParameter parameter);
    protected virtual Action`1<object> OnThrowNullIsProhibitedExceptionOnUnpacked(ReflectionSerializerNilImplicationHandlerOnUnpackedParameter parameter);
    protected virtual Action`1<object> OnThrowValueTypeCannotBeNull3OnUnpacked(ReflectionSerializerNilImplicationHandlerOnUnpackedParameter parameter);
}
[PreserveAttribute]
internal class MsgPack.Serialization.ReflectionSerializers.ReflectionNonGenericCollectionMessagePackSerializer`1 : NonGenericCollectionMessagePackSerializer`1<TCollection> {
    private Func`2<int, TCollection> _factory;
    private Action`2<TCollection, object> _addItem;
    private bool _isPackable;
    private bool _isUnpackable;
    private bool _isAsyncPackable;
    private bool _isAsyncUnpackable;
    public ReflectionNonGenericCollectionMessagePackSerializer`1(SerializationContext ownerContext, Type targetType, CollectionTraits collectionTraits, PolymorphismSchema itemsSchema, SerializationTarget targetInfo);
    protected internal virtual void PackToCore(Packer packer, TCollection objectTree);
    protected internal virtual Task PackToAsyncCore(Packer packer, TCollection objectTree, CancellationToken cancellationToken);
    protected internal virtual TCollection UnpackFromCore(Unpacker unpacker);
    [AsyncStateMachineAttribute("MsgPack.Serialization.ReflectionSerializers.ReflectionNonGenericCollectionMessagePackSerializer`1/<UnpackFromAsyncCore>d__10")]
protected internal virtual Task`1<TCollection> UnpackFromAsyncCore(Unpacker unpacker, CancellationToken cancellationToken);
    protected virtual TCollection CreateInstance(int initialCapacity);
    protected virtual void AddItem(TCollection collection, object item);
}
[PreserveAttribute]
internal class MsgPack.Serialization.ReflectionSerializers.ReflectionNonGenericDictionaryMessagePackSerializer`1 : NonGenericDictionaryMessagePackSerializer`1<TDictionary> {
    private Func`2<int, TDictionary> _factory;
    private bool _isPackable;
    private bool _isUnpackable;
    private bool _isAsyncPackable;
    private bool _isAsyncUnpackable;
    public ReflectionNonGenericDictionaryMessagePackSerializer`1(SerializationContext ownerContext, Type targetType, CollectionTraits collectionTraits, PolymorphismSchema itemsSchema, SerializationTarget targetInfo);
    protected internal virtual void PackToCore(Packer packer, TDictionary objectTree);
    protected internal virtual TDictionary UnpackFromCore(Unpacker unpacker);
    protected internal virtual Task PackToAsyncCore(Packer packer, TDictionary objectTree, CancellationToken cancellationToken);
    protected internal virtual Task`1<TDictionary> UnpackFromAsyncCore(Unpacker unpacker, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.Serialization.ReflectionSerializers.ReflectionNonGenericDictionaryMessagePackSerializer`1/<UnpackFromMessageAsync>d__10")]
private Task`1<TDictionary> UnpackFromMessageAsync(Unpacker unpacker, CancellationToken cancellationToken);
    protected virtual TDictionary CreateInstance(int initialCapacity);
}
[PreserveAttribute]
internal class MsgPack.Serialization.ReflectionSerializers.ReflectionNonGenericEnumerableMessagePackSerializer`1 : NonGenericEnumerableMessagePackSerializer`1<TCollection> {
    private Func`2<int, TCollection> _factory;
    private Action`2<TCollection, object> _addItem;
    private bool _isPackable;
    private bool _isUnpackable;
    private bool _isAsyncPackable;
    private bool _isAsyncUnpackable;
    public ReflectionNonGenericEnumerableMessagePackSerializer`1(SerializationContext ownerContext, Type targetType, CollectionTraits collectionTraits, PolymorphismSchema itemsSchema, SerializationTarget targetInfo);
    protected internal virtual void PackToCore(Packer packer, TCollection objectTree);
    protected internal virtual Task PackToAsyncCore(Packer packer, TCollection objectTree, CancellationToken cancellationToken);
    protected internal virtual TCollection UnpackFromCore(Unpacker unpacker);
    [AsyncStateMachineAttribute("MsgPack.Serialization.ReflectionSerializers.ReflectionNonGenericEnumerableMessagePackSerializer`1/<UnpackFromAsyncCore>d__10")]
protected internal virtual Task`1<TCollection> UnpackFromAsyncCore(Unpacker unpacker, CancellationToken cancellationToken);
    protected virtual TCollection CreateInstance(int initialCapacity);
    protected virtual void AddItem(TCollection collection, object item);
}
[PreserveAttribute]
internal class MsgPack.Serialization.ReflectionSerializers.ReflectionNonGenericListMessagePackSerializer`1 : NonGenericListMessagePackSerializer`1<TList> {
    private Func`2<int, TList> _factory;
    private bool _isPackable;
    private bool _isUnpackable;
    private bool _isAsyncPackable;
    private bool _isAsyncUnpackable;
    public ReflectionNonGenericListMessagePackSerializer`1(SerializationContext ownerContext, Type targetType, CollectionTraits collectionTraits, PolymorphismSchema itemsSchema, SerializationTarget targetInfo);
    protected internal virtual void PackToCore(Packer packer, TList objectTree);
    protected internal virtual TList UnpackFromCore(Unpacker unpacker);
    protected internal virtual Task PackToAsyncCore(Packer packer, TList objectTree, CancellationToken cancellationToken);
    protected internal virtual Task`1<TList> UnpackFromAsyncCore(Unpacker unpacker, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.Serialization.ReflectionSerializers.ReflectionNonGenericListMessagePackSerializer`1/<UnpackFromMessageAsync>d__10")]
private Task`1<TList> UnpackFromMessageAsync(Unpacker unpacker, CancellationToken cancellationToken);
    protected virtual TList CreateInstance(int initialCapacity);
}
[PreserveAttribute]
internal class MsgPack.Serialization.ReflectionSerializers.ReflectionObjectMessagePackSerializer`1 : MessagePackSerializer`1<T> {
    private Func`2[] _getters;
    private Action`2[] _setters;
    private MemberInfo[] _memberInfos;
    private DataMemberContract[] _contracts;
    private Dictionary`2<string, int> _memberIndexes;
    private MessagePackSerializer[] _serializers;
    private ParameterInfo[] _constructorParameters;
    private Dictionary`2<int, int> _constructorArgumentIndexes;
    public ReflectionObjectMessagePackSerializer`1(SerializationContext context, SerializationTarget target, SerializerCapabilities capabilities);
    protected internal virtual void PackToCore(Packer packer, T objectTree);
    private bool IsNull(T objectTree, int index);
    private void PackMemberValue(Packer packer, T objectTree, int index);
    [AsyncStateMachineAttribute("MsgPack.Serialization.ReflectionSerializers.ReflectionObjectMessagePackSerializer`1/<PackToAsyncCore>d__12")]
protected internal virtual Task PackToAsyncCore(Packer packer, T objectTree, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.Serialization.ReflectionSerializers.ReflectionObjectMessagePackSerializer`1/<PackMemberValueAsync>d__13")]
private Task PackMemberValueAsync(Packer packer, T objectTree, int index, CancellationToken cancellationToken);
    protected internal virtual T UnpackFromCore(Unpacker unpacker);
    private object UnpackMemberValue(object objectGraph, Unpacker unpacker, int itemsCount, int unpacked, int index, int unpackerOffset);
    private object UnpackSingleValue(Unpacker unpacker, int index);
    private void UnpackAndAddCollectionItem(object objectGraph, Unpacker unpacker, int index);
    [AsyncStateMachineAttribute("MsgPack.Serialization.ReflectionSerializers.ReflectionObjectMessagePackSerializer`1/<UnpackFromAsyncCore>d__18")]
protected internal virtual Task`1<T> UnpackFromAsyncCore(Unpacker unpacker, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.Serialization.ReflectionSerializers.ReflectionObjectMessagePackSerializer`1/<UnpackMemberValueAsync>d__19")]
private Task`1<object> UnpackMemberValueAsync(object objectGraph, Unpacker unpacker, int itemsCount, int unpacked, int index, int unpackerOffset, CancellationToken cancellationToken);
    private Task`1<object> UnpackSingleValueAsync(Unpacker unpacker, int index, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.Serialization.ReflectionSerializers.ReflectionObjectMessagePackSerializer`1/<UnpackAndAddCollectionItemAsync>d__21")]
private Task UnpackAndAddCollectionItemAsync(object objectGraph, Unpacker unpacker, int index, CancellationToken cancellationToken);
}
internal static class MsgPack.Serialization.ReflectionSerializers.ReflectionSerializerHelper : object {
    internal static PropertyInfo DictionaryEntryKeyProperty;
    internal static PropertyInfo DictionaryEntryValueProperty;
    private static ReflectionSerializerHelper();
    public static MessagePackSerializer`1<T> CreateReflectionEnumMessagePackSerializer(SerializationContext context);
    public static MessagePackSerializer`1<T> CreateCollectionSerializer(SerializationContext context, Type targetType, CollectionTraits traits, PolymorphismSchema schema);
    public static Action`2<TCollection, TItem> GetAddItem(Type targetType, CollectionTraits collectionTraits);
    public static void GetMetadata(Type targetType, IList`1<SerializingMember> members, SerializationContext context, Func`2[]& getters, Action`2[]& setters, MemberInfo[]& memberInfos, DataMemberContract[]& contracts, MessagePackSerializer[]& serializers);
    private static void ThrowMissingGetterException(Type targetType, int number, PropertyInfo property);
    public static Func`2<int, T> CreateCollectionInstanceFactory(ConstructorInfo constructor);
}
internal class MsgPack.Serialization.ReflectionSerializers.ReflectionSerializerNilImplicationHandlerOnUnpackedParameter : ValueType {
    private Type _itemType;
    private Action`1<object> _store;
    public string MemberName;
    public Type DeclaringType;
    public Type ItemType { get; }
    public Action`1<object> Store { get; }
    public ReflectionSerializerNilImplicationHandlerOnUnpackedParameter(Type itemType, Action`1<object> store, string memberName, Type declaringType);
    public sealed virtual Type get_ItemType();
    public sealed virtual Action`1<object> get_Store();
}
internal class MsgPack.Serialization.ReflectionSerializers.ReflectionSerializerNilImplicationHandlerParameter : ValueType {
    private Type _itemType;
    private string _memberName;
    public Type ItemType { get; }
    public string MemberName { get; }
    public ReflectionSerializerNilImplicationHandlerParameter(Type itemType, string memberName);
    public sealed virtual Type get_ItemType();
    public string get_MemberName();
}
internal class MsgPack.Serialization.ReflectionSerializers.ReflectionTupleMessagePackSerializer`1 : MessagePackSerializer`1<T> {
    private IList`1<Type> _tupleTypes;
    private IList`1<ConstructorInfo> _tupleConstructors;
    private IList`1<Func`2<T, object>> _getters;
    private IList`1<MessagePackSerializer> _itemSerializers;
    public ReflectionTupleMessagePackSerializer`1(SerializationContext ownerContext, IList`1<PolymorphismSchema> itemSchemas);
    [IteratorStateMachineAttribute("MsgPack.Serialization.ReflectionSerializers.ReflectionTupleMessagePackSerializer`1/<GetGetters>d__5`2")]
private static IEnumerable`1<Func`2<T, object>> GetGetters(IList`1<Type> itemTypes, IList`1<Type> tupleTypes, Func`3<Type, string, TInfo> metadataFactory, Func`2<TInfo, TAccessor> accessorFactory, Func`2<IEnumerable`1<TAccessor>, Func`2<T, object>> chainedGetterFactory);
    protected internal virtual void PackToCore(Packer packer, T objectTree);
    [AsyncStateMachineAttribute("MsgPack.Serialization.ReflectionSerializers.ReflectionTupleMessagePackSerializer`1/<PackToAsyncCore>d__7")]
protected internal virtual Task PackToAsyncCore(Packer packer, T objectTree, CancellationToken cancellationToken);
    protected internal virtual T UnpackFromCore(Unpacker unpacker);
    [AsyncStateMachineAttribute("MsgPack.Serialization.ReflectionSerializers.ReflectionTupleMessagePackSerializer`1/<UnpackFromAsyncCore>d__9")]
protected internal virtual Task`1<T> UnpackFromAsyncCore(Unpacker unpacker, CancellationToken cancellationToken);
    private T CreateTuple(IList`1<object> unpackedItems);
}
public class MsgPack.Serialization.ResolveSerializerEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private SerializationContext <Context>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <TargetType>k__BackingField;
    [CompilerGeneratedAttribute]
private PolymorphismSchema <PolymorphismSchema>k__BackingField;
    private MessagePackSerializer _foundSerializer;
    public SerializationContext Context { get; private set; }
    public Type TargetType { get; private set; }
    public PolymorphismSchema PolymorphismSchema { get; private set; }
    internal ResolveSerializerEventArgs(SerializationContext context, Type targetType, PolymorphismSchema schema);
    [CompilerGeneratedAttribute]
public SerializationContext get_Context();
    [CompilerGeneratedAttribute]
private void set_Context(SerializationContext value);
    [CompilerGeneratedAttribute]
public Type get_TargetType();
    [CompilerGeneratedAttribute]
private void set_TargetType(Type value);
    [CompilerGeneratedAttribute]
public PolymorphismSchema get_PolymorphismSchema();
    [CompilerGeneratedAttribute]
private void set_PolymorphismSchema(PolymorphismSchema value);
    internal MessagePackSerializer`1<T> GetFoundSerializer();
    public void SetSerializer(MessagePackSerializer`1<T> foundSerializer);
}
public class MsgPack.Serialization.SerializationCompatibilityOptions : object {
    private bool _oneBoundDataMemberOrder;
    private int _packerCompatibilityOptions;
    private bool _ignorePackabilityForCollection;
    private bool _allowNonCollectionEnumerableTypes;
    private bool _allowAsymmetricSerializer;
    public bool OneBoundDataMemberOrder { get; public set; }
    public PackerCompatibilityOptions PackerCompatibilityOptions { get; public set; }
    public bool IgnorePackabilityForCollection { get; public set; }
    public bool AllowNonCollectionEnumerableTypes { get; public set; }
    public bool AllowAsymmetricSerializer { get; public set; }
    public bool get_OneBoundDataMemberOrder();
    public void set_OneBoundDataMemberOrder(bool value);
    public PackerCompatibilityOptions get_PackerCompatibilityOptions();
    public void set_PackerCompatibilityOptions(PackerCompatibilityOptions value);
    public bool get_IgnorePackabilityForCollection();
    public void set_IgnorePackabilityForCollection(bool value);
    public bool get_AllowNonCollectionEnumerableTypes();
    public void set_AllowNonCollectionEnumerableTypes(bool value);
    public bool get_AllowAsymmetricSerializer();
    public void set_AllowAsymmetricSerializer(bool value);
}
public class MsgPack.Serialization.SerializationContext : object {
    private static SerializationContext _default;
    private SerializerRepository _serializers;
    private ConcurrentDictionary`2<Type, object> _typeLock;
    private object _generationLock;
    private SerializerOptions _serializerGeneratorOptions;
    private SerializationCompatibilityOptions _compatibilityOptions;
    private DictionarySerlaizationOptions _dictionarySerializationOptions;
    private int _serializationMethod;
    private EnumSerializationOptions _enumSerializationOptions;
    private DefaultConcreteTypeRepository _defaultCollectionTypes;
    private int _defaultDateTimeConversionMethod;
    private EventHandler`1<ResolveSerializerEventArgs> _resolveSerializer;
    private ExtTypeCodeMapping _extTypeCodes;
    public static SerializationContext Default { get; public set; }
    public SerializerRepository Serializers { get; }
    public SerializerOptions SerializerOptions { get; }
    public SerializationCompatibilityOptions CompatibilityOptions { get; }
    public DictionarySerlaizationOptions DictionarySerlaizationOptions { get; }
    public SerializationMethod SerializationMethod { get; public set; }
    public EnumSerializationOptions EnumSerializationOptions { get; }
    [ObsoleteAttribute("Use EnumSerializationOptions.SerializationMethod instead.")]
public EnumSerializationMethod EnumSerializationMethod { get; public set; }
    [ObsoleteAttribute("Use SerializerOptions.GeneratorOption instead.")]
public SerializationMethodGeneratorOption GeneratorOption { get; public set; }
    public DefaultConcreteTypeRepository DefaultCollectionTypes { get; }
    public DateTimeConversionMethod DefaultDateTimeConversionMethod { get; public set; }
    public ExtTypeCodeMapping ExtTypeCodeMapping { get; }
    public SerializationContext(PackerCompatibilityOptions packerCompatibilityOptions);
    private static SerializationContext();
    public static SerializationContext get_Default();
    public static void set_Default(SerializationContext value);
    public SerializerRepository get_Serializers();
    public SerializerOptions get_SerializerOptions();
    public SerializationCompatibilityOptions get_CompatibilityOptions();
    public DictionarySerlaizationOptions get_DictionarySerlaizationOptions();
    public SerializationMethod get_SerializationMethod();
    public void set_SerializationMethod(SerializationMethod value);
    public EnumSerializationOptions get_EnumSerializationOptions();
    public EnumSerializationMethod get_EnumSerializationMethod();
    public void set_EnumSerializationMethod(EnumSerializationMethod value);
    public SerializationMethodGeneratorOption get_GeneratorOption();
    public void set_GeneratorOption(SerializationMethodGeneratorOption value);
    public DefaultConcreteTypeRepository get_DefaultCollectionTypes();
    public DateTimeConversionMethod get_DefaultDateTimeConversionMethod();
    public void set_DefaultDateTimeConversionMethod(DateTimeConversionMethod value);
    public void add_ResolveSerializer(EventHandler`1<ResolveSerializerEventArgs> value);
    public void remove_ResolveSerializer(EventHandler`1<ResolveSerializerEventArgs> value);
    private MessagePackSerializer`1<T> OnResolveSerializer(PolymorphismSchema schema);
    public static SerializationContext ConfigureClassic();
    public static SerializationContext CreateClassicContext();
    internal bool ContainsSerializer(Type rootType);
    public MessagePackSerializer`1<T> GetSerializer();
    public MessagePackSerializer`1<T> GetSerializer(object providerParameter);
    private Type EnsureConcreteTypeRegistered(Type mayBeAbstractType);
    private MessagePackSerializer`1<T> GetSerializerWithoutGeneration(PolymorphismSchema schema);
    public MessagePackSerializer GetSerializer(Type targetType);
    public MessagePackSerializer GetSerializer(Type targetType, object providerParameter);
    public ExtTypeCodeMapping get_ExtTypeCodeMapping();
}
[EditorBrowsableAttribute("1")]
public static class MsgPack.Serialization.SerializationExceptions : object {
    internal static MethodInfo ThrowValueTypeCannotBeNull3Method;
    internal static MethodInfo ThrowIsNotArrayHeaderMethod;
    internal static MethodInfo ThrowIsNotMapHeaderMethod;
    internal static MethodInfo ThrowTupleCardinarityIsNotMatchMethod;
    internal static MethodInfo ThrowNullIsProhibitedMethod;
    internal static MethodInfo NewUnpackFromIsNotSupportedMethod;
    internal static MethodInfo NewCreateInstanceIsNotSupportedMethod;
    private static SerializationExceptions();
    public static Exception NewValueTypeCannotBeNull(string name, Type memberType, Type declaringType);
    public static void ThrowValueTypeCannotBeNull(string name, Type memberType, Type declaringType);
    public static Exception NewValueTypeCannotBeNull(Type type);
    public static Exception NewTypeCannotSerialize(Type type);
    public static Exception NewTypeCannotDeserialize(Type type);
    public static Exception NewTypeCannotDeserialize(Type type, string memberName, Exception inner);
    public static Exception NewMissingItem(int index);
    public static void ThrowMissingItem(int index, Unpacker unpacker);
    public static void ThrowMissingItem(int index, string name, Unpacker unpacker);
    internal static void ThrowMissingKey(int index, Unpacker unpacker);
    internal static Exception NewTargetDoesNotHavePublicDefaultConstructor(Type type);
    internal static Exception NewTargetDoesNotHavePublicDefaultConstructorNorInitialCapacity(Type type);
    internal static void ThrowTargetDoesNotHavePublicDefaultConstructorNorInitialCapacity(Type type);
    public static Exception NewMissingProperty(string name);
    internal static void ThrowMissingProperty(string name);
    [ObsoleteAttribute("This method is no longer used internally. So this internal API will be removed in future.")]
public static Exception NewUnexpectedEndOfStream();
    internal static void ThrowUnexpectedEndOfStream(Unpacker unpacker);
    public static Exception NewMissingAddMethod(Type type);
    [ObsoleteAttribute("This method is no longer used internally. So this internal API will be removed in future.")]
public static Exception NewIsNotArrayHeader();
    public static void ThrowIsNotArrayHeader(Unpacker unpacker);
    public static Exception NewIsNotMapHeader();
    public static void ThrowIsNotMapHeader(Unpacker unpacker);
    public static Exception NewNotSupportedBecauseCannotInstanciateAbstractType(Type type);
    public static Exception NewTupleCardinarityIsNotMatch(int expectedTupleCardinality, int actualArrayLength);
    public static void ThrowTupleCardinarityIsNotMatch(int expectedTupleCardinality, long actualArrayLength, Unpacker unpacker);
    public static Exception NewIsIncorrectStream(Exception innerException);
    internal static void ThrowIsIncorrectStream(Exception innerException);
    public static Exception NewIsTooLargeCollection();
    internal static void ThrowIsTooLargeCollection();
    public static Exception NewNullIsProhibited(string memberName);
    public static void ThrowNullIsProhibited(string memberName);
    public static Exception NewReadOnlyMemberItemsMustNotBeNull(string memberName);
    public static Exception NewStreamDoesNotContainCollectionForMember(string memberName);
    public static Exception NewUnexpectedArrayLength(int expectedLength, int actualLength);
    public static Exception NewFailedToDeserializeMember(Type targetType, string memberName, Exception inner);
    internal static void ThrowFailedToDeserializeMember(Type targetType, string memberName, Exception inner);
    public static Exception NewUnpackFromIsNotSupported(Type targetType);
    public static Exception NewCreateInstanceIsNotSupported(Type targetType);
    internal static Exception NewUnpackToIsNotSupported(Type type, Exception inner);
    internal static Exception NewValueTypeCannotBePolymorphic(Type type);
    internal static Exception NewUnknownTypeEmbedding();
    internal static Exception NewIncompatibleCollectionSerializer(Type targetType, Type incompatibleType, Type exampleClass);
    internal static void ThrowArgumentNullException(string parameterName);
    internal static void ThrowArgumentNullException(string parameterName, string fieldName);
    internal static void ThrowArgumentCannotBeNegativeException(string parameterName);
    internal static void ThrowArgumentCannotBeNegativeException(string parameterName, string fieldName);
    internal static void ThrowArgumentException(string parameterName, string message);
    internal static void ThrowSerializationException(string message);
    internal static void ThrowSerializationException(string message, Exception innerException);
    internal static void ThrowInvalidArrayItemsCount(Unpacker unpacker, Type targetType, int requiredCount);
}
public enum MsgPack.Serialization.SerializationMethod : Enum {
    public int value__;
    public static SerializationMethod Array;
    public static SerializationMethod Map;
}
public enum MsgPack.Serialization.SerializationMethodGeneratorOption : Enum {
    public int value__;
    [EditorBrowsableAttribute("1")]
public static SerializationMethodGeneratorOption CanDump;
    public static SerializationMethodGeneratorOption CanCollect;
    public static SerializationMethodGeneratorOption Fast;
}
internal class MsgPack.Serialization.SerializationTarget : object {
    private static string MessagePackMemberAttributeTypeName;
    private static string MessagePackIgnoreAttributeTypeName;
    private static string MessagePackDeserializationConstructorAttributeTypeName;
    private static String[] EmptyStrings;
    private static SerializingMember[] EmptyMembers;
    private static Assembly ThisAssembly;
    [CompilerGeneratedAttribute]
private IList`1<SerializingMember> <Members>k__BackingField;
    [CompilerGeneratedAttribute]
private ConstructorInfo <DeserializationConstructor>k__BackingField;
    private String[] _correspondingMemberNames;
    [CompilerGeneratedAttribute]
private bool <IsConstructorDeserialization>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CanDeserialize>k__BackingField;
    public IList`1<SerializingMember> Members { get; private set; }
    public ConstructorInfo DeserializationConstructor { get; private set; }
    public bool IsConstructorDeserialization { get; private set; }
    public bool CanDeserialize { get; private set; }
    private SerializationTarget(IList`1<SerializingMember> members, ConstructorInfo constructor, String[] correspondingMemberNames, bool canDeserialize);
    private static SerializationTarget();
    [CompilerGeneratedAttribute]
public IList`1<SerializingMember> get_Members();
    [CompilerGeneratedAttribute]
private void set_Members(IList`1<SerializingMember> value);
    [CompilerGeneratedAttribute]
public ConstructorInfo get_DeserializationConstructor();
    [CompilerGeneratedAttribute]
private void set_DeserializationConstructor(ConstructorInfo value);
    [CompilerGeneratedAttribute]
public bool get_IsConstructorDeserialization();
    [CompilerGeneratedAttribute]
private void set_IsConstructorDeserialization(bool value);
    [CompilerGeneratedAttribute]
public bool get_CanDeserialize();
    [CompilerGeneratedAttribute]
private void set_CanDeserialize(bool value);
    public SerializerCapabilities GetCapabilitiesForObject();
    public SerializerCapabilities GetCapabilitiesForCollection(CollectionTraits traits);
    private static String[] FindCorrespondingMemberNames(IList`1<SerializingMember> members, ConstructorInfo constructor);
    private static string DetermineCorrespondingMemberName(ParameterInfo parameterInfo, IEnumerable`1<SerializingMember> members);
    private static void ThrowAmbigiousMatchException(ParameterInfo parameterInfo, ICollection`1<SerializingMember> members);
    public string GetCorrespondingMemberName(int constructorParameterIndex);
    public static void VerifyType(Type targetType);
    public static void VerifyCanSerializeTargetType(SerializationContext context, Type targetType);
    public static SerializationTarget Prepare(SerializationContext context, Type targetType);
    private static bool HasAnyCorrespondingMembers(IEnumerable`1<string> correspondingMemberNames);
    private static bool HasUnpackableInterface(Type targetType, SerializationContext context);
    private static bool DetermineCanDeserialize(ConstructorKind kind, SerializationContext context, Type targetType, IEnumerable`1<string> correspondingMemberNames, bool allowDefault);
    private static MemberInfo[] GetDistinctMembers(Type type);
    private static IEnumerable`1<SerializingMember> GetTargetMembers(Type type);
    private static IEnumerable`1<SerializingMember> GetAnnotatedMembersWithDuplicationDetection(Type type, MemberInfo[] filtered);
    private static object GetAttributeArgument(string attributeName, CustomAttributeData attribute, int index);
    private static object GetAttributeProperty(string attributeName, CustomAttributeData attribute, string propertyName);
    private static IEnumerable`1<SerializingMember> GetSystemRuntimeSerializationCompatibleMembers(MemberInfo[] members);
    private static IEnumerable`1<SerializingMember> GetPublicUnpreventedMembers(MemberInfo[] members);
    private static bool IsNonSerializedField(MemberInfo member);
    private static ConstructorInfo FindDeserializationConstructor(SerializationContext context, Type targetType, ConstructorKind& constructorKind);
    private static IList`1<ConstructorInfo> FindExplicitDeserializationConstructors(IEnumerable`1<ConstructorInfo> construtors);
    private static SerializationException NewTypeCannotBeSerializedException(Type targetType);
    private static bool CheckTargetEligibility(SerializationContext context, MemberInfo member);
    private static IList`1<SerializingMember> ComplementMembers(IList`1<SerializingMember> candidates, SerializationContext context, Type targetType);
    private static void VerifyNilImplication(Type type, IEnumerable`1<SerializingMember> entries);
    private static void VerifyKeyUniqueness(IList`1<SerializingMember> result);
    public static SerializationTarget CreateForCollection(ConstructorInfo collectionConstructor, bool canDeserialize);
    public static SerializationTarget CreateForTuple(IList`1<Type> itemTypes);
    public static string GetTupleItemNameFromIndex(int i);
    public static bool BuiltInSerializerExists(ISerializerGeneratorConfiguration configuration, Type type, CollectionTraits traits);
    [ConditionalAttribute("DEBUG")]
private static void Trace(string format, Object[] args);
}
public class MsgPack.Serialization.SerializerAssemblyGenerationConfiguration : object {
    private string _outputDirectory;
    private SerializationMethod _serializationMethod;
    private EnumSerializationMethod _enumSerializationMethod;
    [CompilerGeneratedAttribute]
private AssemblyName <AssemblyName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsRecursive>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PreferReflectionBasedSerializer>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <WithNullableSerializers>k__BackingField;
    private static string DefaultNamespace;
    private string _namespace;
    private SerializationCompatibilityOptions _compatibilityOptions;
    [CompilerGeneratedAttribute]
private bool <WithAsync>k__BackingField;
    public string OutputDirectory { get; public set; }
    [ObsoleteAttribute("Generated assembly now recognizes SerializationContext.SerializationMethod on demand. This property does not affect anything.")]
public SerializationMethod SerializationMethod { get; public set; }
    public EnumSerializationMethod EnumSerializationMethod { get; public set; }
    public AssemblyName AssemblyName { get; public set; }
    public bool IsRecursive { get; public set; }
    public bool PreferReflectionBasedSerializer { get; public set; }
    public bool WithNullableSerializers { get; public set; }
    public string Namespace { get; public set; }
    public SerializationCompatibilityOptions CompatibilityOptions { get; }
    public bool WithAsync { get; public set; }
    public sealed virtual string get_OutputDirectory();
    public sealed virtual void set_OutputDirectory(string value);
    public sealed virtual SerializationMethod get_SerializationMethod();
    public sealed virtual void set_SerializationMethod(SerializationMethod value);
    public sealed virtual EnumSerializationMethod get_EnumSerializationMethod();
    public sealed virtual void set_EnumSerializationMethod(EnumSerializationMethod value);
    [CompilerGeneratedAttribute]
public AssemblyName get_AssemblyName();
    [CompilerGeneratedAttribute]
public void set_AssemblyName(AssemblyName value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsRecursive();
    [CompilerGeneratedAttribute]
public sealed virtual void set_IsRecursive(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_PreferReflectionBasedSerializer();
    [CompilerGeneratedAttribute]
public sealed virtual void set_PreferReflectionBasedSerializer(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_WithNullableSerializers();
    [CompilerGeneratedAttribute]
public sealed virtual void set_WithNullableSerializers(bool value);
    public string get_Namespace();
    public void set_Namespace(string value);
    public sealed virtual SerializationCompatibilityOptions get_CompatibilityOptions();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_WithAsync();
    [CompilerGeneratedAttribute]
public sealed virtual void set_WithAsync(bool value);
    private sealed virtual override void MsgPack.Serialization.ISerializerGeneratorConfiguration.Validate();
    private static Exception CreateValidationError(Exception innerException);
}
[FlagsAttribute]
public enum MsgPack.Serialization.SerializerCapabilities : Enum {
    public int value__;
    public static SerializerCapabilities None;
    public static SerializerCapabilities PackTo;
    public static SerializerCapabilities UnpackFrom;
    public static SerializerCapabilities UnpackTo;
}
public class MsgPack.Serialization.SerializerCodeGenerationConfiguration : object {
    private static string DefaultNamespace;
    private static string DefaultLanguage;
    private static string DefaultIndentString;
    private string _namespace;
    private string _outputDirectory;
    private string _language;
    private string _indentString;
    private SerializationMethod _serializationMethod;
    private EnumSerializationMethod _enumSerializationMethod;
    [CompilerGeneratedAttribute]
private bool <IsRecursive>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PreferReflectionBasedSerializer>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <WithNullableSerializers>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsInternalToMsgPackLibrary>k__BackingField;
    private SerializationCompatibilityOptions _compatibilityOptions;
    [CompilerGeneratedAttribute]
private bool <WithAsync>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SuppressDebuggerNonUserCodeAttribute>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeGenerationSink <CodeGenerationSink>k__BackingField;
    public string Namespace { get; public set; }
    public string OutputDirectory { get; public set; }
    public string Language { get; public set; }
    public string CodeIndentString { get; public set; }
    public SerializationMethod SerializationMethod { get; public set; }
    public EnumSerializationMethod EnumSerializationMethod { get; public set; }
    public bool IsRecursive { get; public set; }
    public bool PreferReflectionBasedSerializer { get; public set; }
    public bool WithNullableSerializers { get; public set; }
    public bool IsInternalToMsgPackLibrary { get; public set; }
    public SerializationCompatibilityOptions CompatibilityOptions { get; }
    public bool WithAsync { get; public set; }
    public bool SuppressDebuggerNonUserCodeAttribute { get; public set; }
    public CodeGenerationSink CodeGenerationSink { get; public set; }
    public string get_Namespace();
    public void set_Namespace(string value);
    public sealed virtual string get_OutputDirectory();
    public sealed virtual void set_OutputDirectory(string value);
    public string get_Language();
    public void set_Language(string value);
    public string get_CodeIndentString();
    public void set_CodeIndentString(string value);
    public sealed virtual SerializationMethod get_SerializationMethod();
    public sealed virtual void set_SerializationMethod(SerializationMethod value);
    public sealed virtual EnumSerializationMethod get_EnumSerializationMethod();
    public sealed virtual void set_EnumSerializationMethod(EnumSerializationMethod value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsRecursive();
    [CompilerGeneratedAttribute]
public sealed virtual void set_IsRecursive(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_PreferReflectionBasedSerializer();
    [CompilerGeneratedAttribute]
public sealed virtual void set_PreferReflectionBasedSerializer(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_WithNullableSerializers();
    [CompilerGeneratedAttribute]
public sealed virtual void set_WithNullableSerializers(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsInternalToMsgPackLibrary();
    [CompilerGeneratedAttribute]
public void set_IsInternalToMsgPackLibrary(bool value);
    public sealed virtual SerializationCompatibilityOptions get_CompatibilityOptions();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_WithAsync();
    [CompilerGeneratedAttribute]
public sealed virtual void set_WithAsync(bool value);
    [CompilerGeneratedAttribute]
public bool get_SuppressDebuggerNonUserCodeAttribute();
    [CompilerGeneratedAttribute]
public void set_SuppressDebuggerNonUserCodeAttribute(bool value);
    [CompilerGeneratedAttribute]
public CodeGenerationSink get_CodeGenerationSink();
    [CompilerGeneratedAttribute]
public void set_CodeGenerationSink(CodeGenerationSink value);
    private sealed virtual override void MsgPack.Serialization.ISerializerGeneratorConfiguration.Validate();
}
public class MsgPack.Serialization.SerializerCodeGenerationResult : object {
    [CompilerGeneratedAttribute]
private string <FilePath>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <TargetType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SerializerTypeNamespace>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SerializerTypeName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SerializerTypeFullName>k__BackingField;
    public string FilePath { get; private set; }
    public Type TargetType { get; private set; }
    public string SerializerTypeNamespace { get; private set; }
    public string SerializerTypeName { get; private set; }
    public string SerializerTypeFullName { get; private set; }
    internal SerializerCodeGenerationResult(Type targetType, string filePath, string serializerTypeFullName, string serializerTypeNamespace, string serializerTypeName);
    [CompilerGeneratedAttribute]
public string get_FilePath();
    [CompilerGeneratedAttribute]
private void set_FilePath(string value);
    [CompilerGeneratedAttribute]
public Type get_TargetType();
    [CompilerGeneratedAttribute]
private void set_TargetType(Type value);
    [CompilerGeneratedAttribute]
public string get_SerializerTypeNamespace();
    [CompilerGeneratedAttribute]
private void set_SerializerTypeNamespace(string value);
    [CompilerGeneratedAttribute]
public string get_SerializerTypeName();
    [CompilerGeneratedAttribute]
private void set_SerializerTypeName(string value);
    [CompilerGeneratedAttribute]
public string get_SerializerTypeFullName();
    [CompilerGeneratedAttribute]
private void set_SerializerTypeFullName(string value);
}
public class MsgPack.Serialization.SerializerCodeInformation : object {
    [CompilerGeneratedAttribute]
private string <TypeFullName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Directory>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FileExtension>k__BackingField;
    [CompilerGeneratedAttribute]
private TextWriter <TextWriter>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FilePath>k__BackingField;
    public string TypeFullName { get; private set; }
    public string Directory { get; private set; }
    public string FileExtension { get; private set; }
    public TextWriter TextWriter { get; public set; }
    public string FilePath { get; public set; }
    internal SerializerCodeInformation(string typeFullName, string directory, string fileExtension);
    [CompilerGeneratedAttribute]
public string get_TypeFullName();
    [CompilerGeneratedAttribute]
private void set_TypeFullName(string value);
    [CompilerGeneratedAttribute]
public string get_Directory();
    [CompilerGeneratedAttribute]
private void set_Directory(string value);
    [CompilerGeneratedAttribute]
public string get_FileExtension();
    [CompilerGeneratedAttribute]
private void set_FileExtension(string value);
    [CompilerGeneratedAttribute]
public TextWriter get_TextWriter();
    [CompilerGeneratedAttribute]
public void set_TextWriter(TextWriter value);
    [CompilerGeneratedAttribute]
public string get_FilePath();
    [CompilerGeneratedAttribute]
public void set_FilePath(string value);
    public void SetFileWriter(string path);
    public void SetNonFileWriter(TextWriter writer);
}
internal static class MsgPack.Serialization.SerializerDebugging : object {
    public static TextWriter ILTraceWriter { get; }
    public static TextWriter get_ILTraceWriter();
    [ConditionalAttribute("DEBUG")]
public static void TracePolimorphicSchemaEvent(string format, MemberInfo memberInfo, PolymorphismSchema schema);
}
public class MsgPack.Serialization.SerializerGenerator : object {
    private HashSet`1<Type> _targetTypes;
    private AssemblyName _assemblyName;
    private SerializationMethod _method;
    [ObsoleteAttribute("Use TargetTypes instead.")]
public Type RootType { get; }
    [ObsoleteAttribute("Use static methods instead.")]
public ICollection`1<Type> TargetTypes { get; }
    [ObsoleteAttribute("Use static methods instead.")]
public AssemblyName AssemblyName { get; }
    [ObsoleteAttribute("Use static methods instead.")]
public SerializationMethod Method { get; public set; }
    [ObsoleteAttribute("Use static methods instead.")]
public SerializerGenerator(AssemblyName assemblyName);
    [ObsoleteAttribute("Use static methods instead.")]
public SerializerGenerator(Type rootType, AssemblyName assemblyName);
    public Type get_RootType();
    public ICollection`1<Type> get_TargetTypes();
    public AssemblyName get_AssemblyName();
    public SerializationMethod get_Method();
    public void set_Method(SerializationMethod value);
    [ObsoleteAttribute("Use static GenerateAssembly method instead.")]
public void GenerateAssemblyFile();
    [ObsoleteAttribute("Use static GenerateAssembly method instead.")]
public void GenerateAssemblyFile(string directory);
    public static string GenerateAssembly(SerializerAssemblyGenerationConfiguration configuration, Type[] targetTypes);
    public static string GenerateAssembly(SerializerAssemblyGenerationConfiguration configuration, IEnumerable`1<Type> targetTypes);
    public static IEnumerable`1<SerializerCodeGenerationResult> GenerateSerializerCodeAssembly(SerializerAssemblyGenerationConfiguration configuration, Type[] targetTypes);
    public static IEnumerable`1<SerializerCodeGenerationResult> GenerateSerializerCodeAssembly(SerializerAssemblyGenerationConfiguration configuration, IEnumerable`1<Type> targetTypes);
    public static IEnumerable`1<string> GenerateCode(Type[] targetTypes);
    public static IEnumerable`1<string> GenerateCode(IEnumerable`1<Type> targetTypes);
    public static IEnumerable`1<string> GenerateCode(SerializerCodeGenerationConfiguration configuration, Type[] targetTypes);
    public static IEnumerable`1<string> GenerateCode(SerializerCodeGenerationConfiguration configuration, IEnumerable`1<Type> targetTypes);
    public static IEnumerable`1<SerializerCodeGenerationResult> GenerateSerializerSourceCodes(Type[] targetTypes);
    public static IEnumerable`1<SerializerCodeGenerationResult> GenerateSerializerSourceCodes(IEnumerable`1<Type> targetTypes);
    public static IEnumerable`1<SerializerCodeGenerationResult> GenerateSerializerSourceCodes(SerializerCodeGenerationConfiguration configuration, Type[] targetTypes);
    public static IEnumerable`1<SerializerCodeGenerationResult> GenerateSerializerSourceCodes(SerializerCodeGenerationConfiguration configuration, IEnumerable`1<Type> targetTypes);
}
public class MsgPack.Serialization.SerializerOptions : object {
    private int _emitterFlavor;
    private int _generatorOption;
    private bool _isRuntimeGenerationDisabled;
    internal static bool CanEmit;
    private bool _isNonPublicAccessDisabled;
    private bool _withAsync;
    internal EmitterFlavor EmitterFlavor { get; internal set; }
    public SerializationMethodGeneratorOption GeneratorOption { get; public set; }
    public bool DisableRuntimeCodeGeneration { get; public set; }
    internal bool CanRuntimeCodeGeneration { get; }
    public bool DisablePrivilegedAccess { get; public set; }
    public bool WithAsync { get; public set; }
    private static SerializerOptions();
    internal EmitterFlavor get_EmitterFlavor();
    internal void set_EmitterFlavor(EmitterFlavor value);
    public SerializationMethodGeneratorOption get_GeneratorOption();
    public void set_GeneratorOption(SerializationMethodGeneratorOption value);
    public bool get_DisableRuntimeCodeGeneration();
    public void set_DisableRuntimeCodeGeneration(bool value);
    private static bool DetermineCanEmit();
    internal bool get_CanRuntimeCodeGeneration();
    public bool get_DisablePrivilegedAccess();
    public void set_DisablePrivilegedAccess(bool value);
    public bool get_WithAsync();
    public void set_WithAsync(bool value);
}
[FlagsAttribute]
public enum MsgPack.Serialization.SerializerRegistrationOptions : Enum {
    public int value__;
    public static SerializerRegistrationOptions None;
    public static SerializerRegistrationOptions AllowOverride;
    public static SerializerRegistrationOptions WithNullable;
}
public class MsgPack.Serialization.SerializerRepository : object {
    private static object SyncRoot;
    private static SerializerRepository _internalDefault;
    private SerializerTypeKeyRepository _repository;
    internal static int DefaultTableCapacity;
    internal static SerializerRepository InternalDefault { get; }
    [ObsoleteAttribute("Use GetDefault()")]
public static SerializerRepository Default { get; }
    public SerializerRepository(SerializerRepository copiedFrom);
    private SerializerRepository(Dictionary`2<RuntimeTypeHandle, object> table);
    private static SerializerRepository();
    internal static SerializerRepository get_InternalDefault();
    [ObsoleteAttribute("This class should not be disposable, so IDisposable will be removed in future.")]
public sealed virtual void Dispose();
    public MessagePackSerializer`1<T> Get(SerializationContext context);
    public MessagePackSerializer`1<T> Get(SerializationContext context, object providerParameter);
    public bool Register(MessagePackSerializer`1<T> serializer);
    public bool Register(MessagePackSerializer`1<T> serializer, SerializerRegistrationOptions options);
    internal static void GetNullableCompanion(Type targetType, SerializationContext context, object serializer, Type& nullableType, MessagePackSerializerProvider& nullableSerializerProvider);
    internal bool Register(Type targetType, MessagePackSerializerProvider serializerProvider, Type nullableType, MessagePackSerializerProvider nullableSerializerProvider, SerializerRegistrationOptions options);
    public void RegisterOverride(MessagePackSerializer`1<T> serializer);
    public static SerializerRepository get_Default();
    public static SerializerRepository GetDefault();
    [ObsoleteAttribute("Use GetDefault()")]
public static SerializerRepository GetDefault(PackerCompatibilityOptions packerCompatibilityOptions);
    public static SerializerRepository GetDefault(SerializationContext ownerContext);
    public bool ContainsFor(Type targetType);
    public IEnumerable`1<KeyValuePair`2<Type, MessagePackSerializer>> GetRegisteredSerializers();
    internal static Dictionary`2<RuntimeTypeHandle, object> InitializeDefaultTable(SerializationContext ownerContext);
}
[SecuritySafeCriticalAttribute]
internal class MsgPack.Serialization.SerializerTypeKeyRepository : TypeKeyRepository {
    public SerializerTypeKeyRepository(SerializerTypeKeyRepository copiedFrom);
    public SerializerTypeKeyRepository(Dictionary`2<RuntimeTypeHandle, object> table);
    public object Get(SerializationContext context, Type keyType);
}
internal class MsgPack.Serialization.SerializingMember : ValueType {
    public MemberInfo Member;
    public DataMemberContract Contract;
    public string MemberName;
    public SerializingMember(MemberInfo member, DataMemberContract contract);
    public SerializingMember(string name);
    public EnumMemberSerializationMethod GetEnumMemberSerializationMethod();
    public DateTimeMemberConversionMethod GetDateTimeMemberConversionMethod();
    public virtual string ToString();
}
internal class MsgPack.Serialization.SingleTextWriterCodeGenerationSink : CodeGenerationSink {
    private TextWriter _writer;
    public SingleTextWriterCodeGenerationSink(TextWriter writer);
    protected virtual void AssignTextWriterCore(SerializerCodeInformation codeInformation);
}
internal static class MsgPack.Serialization.Tracer : object {
    public static TraceSource Emit;
    public static TraceSource Binding;
    public static TraceSource Tracing;
    private static Tracer();
}
[SecuritySafeCriticalAttribute]
internal class MsgPack.Serialization.TypeKeyRepository : object {
    private ReaderWriterLockSlim _lock;
    private Dictionary`2<RuntimeTypeHandle, object> _table;
    public TypeKeyRepository(TypeKeyRepository copiedFrom);
    public TypeKeyRepository(Dictionary`2<RuntimeTypeHandle, object> table);
    [SecuritySafeCriticalAttribute]
private Dictionary`2<RuntimeTypeHandle, object> GetClonedTable();
    public bool Get(Type type, Object& matched, Object& genericDefinitionMatched);
    [SecuritySafeCriticalAttribute]
private bool GetCore(Type type, Object& matched, Object& genericDefinitionMatched);
    public bool Register(Type type, object entry, Type nullableType, object nullableValue, SerializerRegistrationOptions options);
    [SecuritySafeCriticalAttribute]
private bool RegisterCore(Type key, object value, Type nullableType, object nullableValue, SerializerRegistrationOptions options);
    private bool ContainsType(Type baseType, Type nullableType);
    public bool Unregister(Type type);
    [SecuritySafeCriticalAttribute]
private bool UnregisterCore(Type key);
    [SecuritySafeCriticalAttribute]
internal bool Contains(Type type);
    [SecuritySafeCriticalAttribute]
internal IEnumerable`1<KeyValuePair`2<Type, object>> GetEntries();
}
[EditorBrowsableAttribute("1")]
public class MsgPack.Serialization.UnpackCollectionAsyncParameters`1 : ValueType {
    public Unpacker Unpacker;
    public int ItemsCount;
    public T Collection;
    public Func`5<Unpacker, T, int, CancellationToken, Task> BulkOperation;
    public Func`6<Unpacker, T, int, int, CancellationToken, Task> EachOperation;
    public CancellationToken CancellationToken;
}
[EditorBrowsableAttribute("1")]
public class MsgPack.Serialization.UnpackCollectionParameters`1 : ValueType {
    public Unpacker Unpacker;
    public int ItemsCount;
    public T Collection;
    public Action`3<Unpacker, T, int> BulkOperation;
    public Action`4<Unpacker, T, int, int> EachOperation;
}
[EditorBrowsableAttribute("1")]
public class MsgPack.Serialization.UnpackFromArrayAsyncParameters`2 : ValueType {
    public Unpacker Unpacker;
    public TContext UnpackingContext;
    public Func`2<TContext, TResult> Factory;
    public IList`1<string> ItemNames;
    public IList`1<Func`6<Unpacker, TContext, int, int, CancellationToken, Task>> Operations;
    public CancellationToken CancellationToken;
}
[EditorBrowsableAttribute("1")]
public class MsgPack.Serialization.UnpackFromArrayParameters`2 : ValueType {
    public Unpacker Unpacker;
    public TContext UnpackingContext;
    public Func`2<TContext, TResult> Factory;
    public IList`1<string> ItemNames;
    public IList`1<Action`4<Unpacker, TContext, int, int>> Operations;
}
[EditorBrowsableAttribute("1")]
public class MsgPack.Serialization.UnpackFromMapAsyncParameters`2 : ValueType {
    public Unpacker Unpacker;
    public TContext UnpackingContext;
    public Func`2<TContext, TResult> Factory;
    public IDictionary`2<string, Func`6<Unpacker, TContext, int, int, CancellationToken, Task>> Operations;
    public CancellationToken CancellationToken;
}
[EditorBrowsableAttribute("1")]
public class MsgPack.Serialization.UnpackFromMapParameters`2 : ValueType {
    public Unpacker Unpacker;
    public TContext UnpackingContext;
    public Func`2<TContext, TResult> Factory;
    public IDictionary`2<string, Action`4<Unpacker, TContext, int, int>> Operations;
}
[EditorBrowsableAttribute("1")]
public static class MsgPack.Serialization.UnpackHelpers : object {
    private static MessagePackSerializer`1<MessagePackObject> _messagePackObjectSerializer;
    private static UnpackHelpers();
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This API is not used at generated serializers in current release, so this API will be removed future.")]
public static void UnpackArrayTo(Unpacker unpacker, MessagePackSerializer`1<T> serializer, T[] array);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This API is not used at generated serializers in current release, so this API will be removed future.")]
public static void UnpackCollectionTo(Unpacker unpacker, IEnumerable collection, Action`1<object> addition);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This API is not used at generated serializers in current release, so this API will be removed future.")]
public static void UnpackCollectionTo(Unpacker unpacker, MessagePackSerializer`1<T> serializer, IEnumerable`1<T> collection, Action`1<T> addition);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This API is not used at generated serializers in current release, so this API will be removed future.")]
public static void UnpackCollectionTo(Unpacker unpacker, IEnumerable collection, Func`2<object, TDiscarded> addition);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This API is not used at generated serializers in current release, so this API will be removed future.")]
public static void UnpackCollectionTo(Unpacker unpacker, MessagePackSerializer`1<T> serializer, IEnumerable`1<T> collection, Func`2<T, TDiscarded> addition);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This API is not used at generated serializers in current release, so this API will be removed future.")]
public static void UnpackMapTo(Unpacker unpacker, MessagePackSerializer`1<TKey> keySerializer, MessagePackSerializer`1<TValue> valueSerializer, IDictionary`2<TKey, TValue> dictionary);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This API is not used at generated serializers in current release, so this API will be removed future.")]
public static void UnpackMapTo(Unpacker unpacker, IDictionary dictionary);
    [EditorBrowsableAttribute("1")]
public static int GetItemsCount(Unpacker unpacker);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This API is not used at generated serializers in current release, so this API will be removed future.")]
public static T ConvertWithEnsuringNotNull(object boxed, string name, Type targetType);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This API is not used at generated serializers in current release, so this API will be removed future.")]
public static T InvokeUnpackFrom(MessagePackSerializer`1<T> serializer, Unpacker unpacker);
    internal static SerializationTarget DetermineCollectionSerializationStrategy(Type instanceType, bool allowAsymmetricSerializer);
    private static ConstructorInfo TryGetCollectionConstructor(Type instanceType);
    internal static bool IsIEqualityComparer(Type type);
    [EditorBrowsableAttribute("1")]
public static IEqualityComparer`1<T> GetEqualityComparer();
    [EditorBrowsableAttribute("1")]
public static Func`2<T, T> GetIdentity();
    [EditorBrowsableAttribute("1")]
public static Func`2<object, T> Unbox();
    [AsyncStateMachineAttribute("MsgPack.Serialization.UnpackHelpers/<ToNullable>d__17`1")]
[EditorBrowsableAttribute("1")]
public static Task`1<Nullable`1<T>> ToNullable(Task`1<T> task);
    [AsyncStateMachineAttribute("MsgPack.Serialization.UnpackHelpers/<UnpackFromMessageAsync>d__18`1")]
[EditorBrowsableAttribute("1")]
public static Task`1<T> UnpackFromMessageAsync(T target, Unpacker unpacker, CancellationToken cancellationToken);
    [ConditionalAttribute("TRACING")]
private static void InitializeUnpackerTrace(Unpacker unpacker, UnpackerTraceContext& context, string callerMemberName);
    [ConditionalAttribute("TRACING")]
private static void Trace(UnpackerTraceContext context, string label, Unpacker unpacker);
    [ConditionalAttribute("TRACING")]
private static void Trace(UnpackerTraceContext context, string label, Unpacker unpacker, int index);
    [ConditionalAttribute("TRACING")]
private static void Trace(UnpackerTraceContext context, string label, Unpacker unpacker, int index, IList`1<string> itemNames);
    [ConditionalAttribute("TRACING")]
private static void Trace(UnpackerTraceContext context, string label, Unpacker unpacker, int index, string key);
    [ConditionalAttribute("TRACING")]
private static void Trace(UnpackerTraceContext context, string label, Unpacker unpacker, string key);
    [ConditionalAttribute("TRACING")]
private static void TraceCore(string format, Object[] args);
    [EditorBrowsableAttribute("1")]
public static bool UnpackBooleanValue(Unpacker unpacker, Type objectType, string memberName);
    [EditorBrowsableAttribute("1")]
public static Nullable`1<bool> UnpackNullableBooleanValue(Unpacker unpacker, Type objectType, string memberName);
    [AsyncStateMachineAttribute("MsgPack.Serialization.UnpackHelpers/<UnpackBooleanValueAsync>d__29")]
[EditorBrowsableAttribute("1")]
public static Task`1<bool> UnpackBooleanValueAsync(Unpacker unpacker, Type objectType, string memberName, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.Serialization.UnpackHelpers/<UnpackNullableBooleanValueAsync>d__30")]
[EditorBrowsableAttribute("1")]
public static Task`1<Nullable`1<bool>> UnpackNullableBooleanValueAsync(Unpacker unpacker, Type objectType, string memberName, CancellationToken cancellationToken);
    [EditorBrowsableAttribute("1")]
public static byte UnpackByteValue(Unpacker unpacker, Type objectType, string memberName);
    [EditorBrowsableAttribute("1")]
public static Nullable`1<byte> UnpackNullableByteValue(Unpacker unpacker, Type objectType, string memberName);
    [AsyncStateMachineAttribute("MsgPack.Serialization.UnpackHelpers/<UnpackByteValueAsync>d__33")]
[EditorBrowsableAttribute("1")]
public static Task`1<byte> UnpackByteValueAsync(Unpacker unpacker, Type objectType, string memberName, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.Serialization.UnpackHelpers/<UnpackNullableByteValueAsync>d__34")]
[EditorBrowsableAttribute("1")]
public static Task`1<Nullable`1<byte>> UnpackNullableByteValueAsync(Unpacker unpacker, Type objectType, string memberName, CancellationToken cancellationToken);
    [EditorBrowsableAttribute("1")]
public static short UnpackInt16Value(Unpacker unpacker, Type objectType, string memberName);
    [EditorBrowsableAttribute("1")]
public static Nullable`1<short> UnpackNullableInt16Value(Unpacker unpacker, Type objectType, string memberName);
    [AsyncStateMachineAttribute("MsgPack.Serialization.UnpackHelpers/<UnpackInt16ValueAsync>d__37")]
[EditorBrowsableAttribute("1")]
public static Task`1<short> UnpackInt16ValueAsync(Unpacker unpacker, Type objectType, string memberName, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.Serialization.UnpackHelpers/<UnpackNullableInt16ValueAsync>d__38")]
[EditorBrowsableAttribute("1")]
public static Task`1<Nullable`1<short>> UnpackNullableInt16ValueAsync(Unpacker unpacker, Type objectType, string memberName, CancellationToken cancellationToken);
    [EditorBrowsableAttribute("1")]
public static int UnpackInt32Value(Unpacker unpacker, Type objectType, string memberName);
    [EditorBrowsableAttribute("1")]
public static Nullable`1<int> UnpackNullableInt32Value(Unpacker unpacker, Type objectType, string memberName);
    [AsyncStateMachineAttribute("MsgPack.Serialization.UnpackHelpers/<UnpackInt32ValueAsync>d__41")]
[EditorBrowsableAttribute("1")]
public static Task`1<int> UnpackInt32ValueAsync(Unpacker unpacker, Type objectType, string memberName, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.Serialization.UnpackHelpers/<UnpackNullableInt32ValueAsync>d__42")]
[EditorBrowsableAttribute("1")]
public static Task`1<Nullable`1<int>> UnpackNullableInt32ValueAsync(Unpacker unpacker, Type objectType, string memberName, CancellationToken cancellationToken);
    [EditorBrowsableAttribute("1")]
public static long UnpackInt64Value(Unpacker unpacker, Type objectType, string memberName);
    [EditorBrowsableAttribute("1")]
public static Nullable`1<long> UnpackNullableInt64Value(Unpacker unpacker, Type objectType, string memberName);
    [AsyncStateMachineAttribute("MsgPack.Serialization.UnpackHelpers/<UnpackInt64ValueAsync>d__45")]
[EditorBrowsableAttribute("1")]
public static Task`1<long> UnpackInt64ValueAsync(Unpacker unpacker, Type objectType, string memberName, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.Serialization.UnpackHelpers/<UnpackNullableInt64ValueAsync>d__46")]
[EditorBrowsableAttribute("1")]
public static Task`1<Nullable`1<long>> UnpackNullableInt64ValueAsync(Unpacker unpacker, Type objectType, string memberName, CancellationToken cancellationToken);
    [CLSCompliantAttribute("False")]
[EditorBrowsableAttribute("1")]
public static sbyte UnpackSByteValue(Unpacker unpacker, Type objectType, string memberName);
    [CLSCompliantAttribute("False")]
[EditorBrowsableAttribute("1")]
public static Nullable`1<sbyte> UnpackNullableSByteValue(Unpacker unpacker, Type objectType, string memberName);
    [AsyncStateMachineAttribute("MsgPack.Serialization.UnpackHelpers/<UnpackSByteValueAsync>d__49")]
[CLSCompliantAttribute("False")]
[EditorBrowsableAttribute("1")]
public static Task`1<sbyte> UnpackSByteValueAsync(Unpacker unpacker, Type objectType, string memberName, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.Serialization.UnpackHelpers/<UnpackNullableSByteValueAsync>d__50")]
[CLSCompliantAttribute("False")]
[EditorBrowsableAttribute("1")]
public static Task`1<Nullable`1<sbyte>> UnpackNullableSByteValueAsync(Unpacker unpacker, Type objectType, string memberName, CancellationToken cancellationToken);
    [CLSCompliantAttribute("False")]
[EditorBrowsableAttribute("1")]
public static ushort UnpackUInt16Value(Unpacker unpacker, Type objectType, string memberName);
    [CLSCompliantAttribute("False")]
[EditorBrowsableAttribute("1")]
public static Nullable`1<ushort> UnpackNullableUInt16Value(Unpacker unpacker, Type objectType, string memberName);
    [AsyncStateMachineAttribute("MsgPack.Serialization.UnpackHelpers/<UnpackUInt16ValueAsync>d__53")]
[CLSCompliantAttribute("False")]
[EditorBrowsableAttribute("1")]
public static Task`1<ushort> UnpackUInt16ValueAsync(Unpacker unpacker, Type objectType, string memberName, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.Serialization.UnpackHelpers/<UnpackNullableUInt16ValueAsync>d__54")]
[CLSCompliantAttribute("False")]
[EditorBrowsableAttribute("1")]
public static Task`1<Nullable`1<ushort>> UnpackNullableUInt16ValueAsync(Unpacker unpacker, Type objectType, string memberName, CancellationToken cancellationToken);
    [CLSCompliantAttribute("False")]
[EditorBrowsableAttribute("1")]
public static UInt32 UnpackUInt32Value(Unpacker unpacker, Type objectType, string memberName);
    [CLSCompliantAttribute("False")]
[EditorBrowsableAttribute("1")]
public static Nullable`1<UInt32> UnpackNullableUInt32Value(Unpacker unpacker, Type objectType, string memberName);
    [AsyncStateMachineAttribute("MsgPack.Serialization.UnpackHelpers/<UnpackUInt32ValueAsync>d__57")]
[CLSCompliantAttribute("False")]
[EditorBrowsableAttribute("1")]
public static Task`1<UInt32> UnpackUInt32ValueAsync(Unpacker unpacker, Type objectType, string memberName, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.Serialization.UnpackHelpers/<UnpackNullableUInt32ValueAsync>d__58")]
[CLSCompliantAttribute("False")]
[EditorBrowsableAttribute("1")]
public static Task`1<Nullable`1<UInt32>> UnpackNullableUInt32ValueAsync(Unpacker unpacker, Type objectType, string memberName, CancellationToken cancellationToken);
    [CLSCompliantAttribute("False")]
[EditorBrowsableAttribute("1")]
public static ulong UnpackUInt64Value(Unpacker unpacker, Type objectType, string memberName);
    [CLSCompliantAttribute("False")]
[EditorBrowsableAttribute("1")]
public static Nullable`1<ulong> UnpackNullableUInt64Value(Unpacker unpacker, Type objectType, string memberName);
    [AsyncStateMachineAttribute("MsgPack.Serialization.UnpackHelpers/<UnpackUInt64ValueAsync>d__61")]
[CLSCompliantAttribute("False")]
[EditorBrowsableAttribute("1")]
public static Task`1<ulong> UnpackUInt64ValueAsync(Unpacker unpacker, Type objectType, string memberName, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.Serialization.UnpackHelpers/<UnpackNullableUInt64ValueAsync>d__62")]
[CLSCompliantAttribute("False")]
[EditorBrowsableAttribute("1")]
public static Task`1<Nullable`1<ulong>> UnpackNullableUInt64ValueAsync(Unpacker unpacker, Type objectType, string memberName, CancellationToken cancellationToken);
    [EditorBrowsableAttribute("1")]
public static float UnpackSingleValue(Unpacker unpacker, Type objectType, string memberName);
    [EditorBrowsableAttribute("1")]
public static Nullable`1<float> UnpackNullableSingleValue(Unpacker unpacker, Type objectType, string memberName);
    [AsyncStateMachineAttribute("MsgPack.Serialization.UnpackHelpers/<UnpackSingleValueAsync>d__65")]
[EditorBrowsableAttribute("1")]
public static Task`1<float> UnpackSingleValueAsync(Unpacker unpacker, Type objectType, string memberName, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.Serialization.UnpackHelpers/<UnpackNullableSingleValueAsync>d__66")]
[EditorBrowsableAttribute("1")]
public static Task`1<Nullable`1<float>> UnpackNullableSingleValueAsync(Unpacker unpacker, Type objectType, string memberName, CancellationToken cancellationToken);
    [EditorBrowsableAttribute("1")]
public static double UnpackDoubleValue(Unpacker unpacker, Type objectType, string memberName);
    [EditorBrowsableAttribute("1")]
public static Nullable`1<double> UnpackNullableDoubleValue(Unpacker unpacker, Type objectType, string memberName);
    [AsyncStateMachineAttribute("MsgPack.Serialization.UnpackHelpers/<UnpackDoubleValueAsync>d__69")]
[EditorBrowsableAttribute("1")]
public static Task`1<double> UnpackDoubleValueAsync(Unpacker unpacker, Type objectType, string memberName, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.Serialization.UnpackHelpers/<UnpackNullableDoubleValueAsync>d__70")]
[EditorBrowsableAttribute("1")]
public static Task`1<Nullable`1<double>> UnpackNullableDoubleValueAsync(Unpacker unpacker, Type objectType, string memberName, CancellationToken cancellationToken);
    [EditorBrowsableAttribute("1")]
public static string UnpackStringValue(Unpacker unpacker, Type objectType, string memberName);
    [EditorBrowsableAttribute("1")]
public static Byte[] UnpackBinaryValue(Unpacker unpacker, Type objectType, string memberName);
    [AsyncStateMachineAttribute("MsgPack.Serialization.UnpackHelpers/<UnpackStringValueAsync>d__73")]
[EditorBrowsableAttribute("1")]
public static Task`1<string> UnpackStringValueAsync(Unpacker unpacker, Type objectType, string memberName, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.Serialization.UnpackHelpers/<UnpackBinaryValueAsync>d__74")]
[EditorBrowsableAttribute("1")]
public static Task`1<Byte[]> UnpackBinaryValueAsync(Unpacker unpacker, Type objectType, string memberName, CancellationToken cancellationToken);
    [EditorBrowsableAttribute("1")]
public static T UnpackComplexObject(Unpacker unpacker, MessagePackSerializer`1<T> serializer, int unpacked);
    [AsyncStateMachineAttribute("MsgPack.Serialization.UnpackHelpers/<UnpackComplexObjectAsync>d__76`1")]
[EditorBrowsableAttribute("1")]
public static Task`1<T> UnpackComplexObjectAsync(Unpacker unpacker, MessagePackSerializer`1<T> serializer, int unpacked, CancellationToken cancellationToken);
    [EditorBrowsableAttribute("1")]
public static void UnpackValueTypeValue(Unpacker unpacker, TContext context, MessagePackSerializer`1<TValue> serializer, int itemsCount, int unpacked, Type targetObjectType, string memberName, Func`4<Unpacker, Type, string, TValue> directRead, Action`2<TContext, TValue> setter);
    [EditorBrowsableAttribute("1")]
public static void UnpackValueTypeValue(UnpackValueTypeValueParameters`2& parameter);
    private static void UnpackValueTypeValueCore(Unpacker unpacker, TContext context, MessagePackSerializer`1<TValue> serializer, int itemsCount, int unpacked, Type targetObjectType, string memberName, Func`4<Unpacker, Type, string, TValue> directRead, Action`2<TContext, TValue> setter);
    [EditorBrowsableAttribute("1")]
public static Task UnpackValueTypeValueAsync(Unpacker unpacker, TContext context, MessagePackSerializer`1<TValue> serializer, int itemsCount, int unpacked, Type targetObjectType, string memberName, Func`5<Unpacker, Type, string, CancellationToken, Task`1<TValue>> directRead, Action`2<TContext, TValue> setter, CancellationToken cancellationToken);
    [EditorBrowsableAttribute("1")]
public static Task UnpackValueTypeValueAsync(UnpackValueTypeValueAsyncParameters`2& parameter);
    [AsyncStateMachineAttribute("MsgPack.Serialization.UnpackHelpers/<UnpackValueTypeValueAsyncCore>d__82`2")]
private static Task UnpackValueTypeValueAsyncCore(Unpacker unpacker, TContext context, MessagePackSerializer`1<TValue> serializer, int itemsCount, int unpacked, Type targetObjectType, string memberName, Func`5<Unpacker, Type, string, CancellationToken, Task`1<TValue>> directRead, Action`2<TContext, TValue> setter, CancellationToken cancellationToken);
    [EditorBrowsableAttribute("1")]
public static void UnpackReferenceTypeValue(Unpacker unpacker, TContext context, MessagePackSerializer`1<TValue> serializer, int itemsCount, int unpacked, Type targetObjectType, string memberName, NilImplication nilImplication, Func`4<Unpacker, Type, string, TValue> directRead, Action`2<TContext, TValue> setter);
    [EditorBrowsableAttribute("1")]
public static void UnpackReferenceTypeValue(UnpackReferenceTypeValueParameters`2& parameter);
    private static void UnpackReferenceTypeValueCore(Unpacker unpacker, TContext context, MessagePackSerializer`1<TValue> serializer, int itemsCount, int unpacked, Type targetObjectType, string memberName, NilImplication nilImplication, Func`4<Unpacker, Type, string, TValue> directRead, Action`2<TContext, TValue> setter);
    [EditorBrowsableAttribute("1")]
public static Task UnpackReferenceTypeValueAsync(Unpacker unpacker, TContext context, MessagePackSerializer`1<TValue> serializer, int itemsCount, int unpacked, Type targetObjectType, string memberName, NilImplication nilImplication, Func`5<Unpacker, Type, string, CancellationToken, Task`1<TValue>> directRead, Action`2<TContext, TValue> setter, CancellationToken cancellationToken);
    [EditorBrowsableAttribute("1")]
public static Task UnpackReferenceTypeValueAsync(UnpackReferenceTypeValueAsyncParameters`2& parameter);
    [AsyncStateMachineAttribute("MsgPack.Serialization.UnpackHelpers/<UnpackReferenceTypeValueAsyncCore>d__88`2")]
private static Task UnpackReferenceTypeValueAsyncCore(Unpacker unpacker, TContext context, MessagePackSerializer`1<TValue> serializer, int itemsCount, int unpacked, Type targetObjectType, string memberName, NilImplication nilImplication, Func`5<Unpacker, Type, string, CancellationToken, Task`1<TValue>> directRead, Action`2<TContext, TValue> setter, CancellationToken cancellationToken);
    [EditorBrowsableAttribute("1")]
public static void UnpackNullableTypeValue(Unpacker unpacker, TContext context, MessagePackSerializer`1<Nullable`1<TValue>> serializer, int itemsCount, int unpacked, Type targetObjectType, string memberName, NilImplication nilImplication, Func`4<Unpacker, Type, string, Nullable`1<TValue>> directRead, Action`2<TContext, Nullable`1<TValue>> setter);
    [EditorBrowsableAttribute("1")]
public static void UnpackNullableTypeValue(UnpackNullableTypeValueParameters`2& parameter);
    private static void UnpackNullableTypeValueCore(Unpacker unpacker, TContext context, MessagePackSerializer`1<Nullable`1<TValue>> serializer, int itemsCount, int unpacked, Type targetObjectType, string memberName, NilImplication nilImplication, Func`4<Unpacker, Type, string, Nullable`1<TValue>> directRead, Action`2<TContext, Nullable`1<TValue>> setter);
    [EditorBrowsableAttribute("1")]
public static Task UnpackNullableTypeValueAsync(Unpacker unpacker, TContext context, MessagePackSerializer`1<Nullable`1<TValue>> serializer, int itemsCount, int unpacked, Type targetObjectType, string memberName, NilImplication nilImplication, Func`5<Unpacker, Type, string, CancellationToken, Task`1<Nullable`1<TValue>>> directRead, Action`2<TContext, Nullable`1<TValue>> setter, CancellationToken cancellationToken);
    [EditorBrowsableAttribute("1")]
public static Task UnpackNullableTypeValueAsync(UnpackNullableTypeValueAsyncParameters`2& parameter);
    [AsyncStateMachineAttribute("MsgPack.Serialization.UnpackHelpers/<UnpackNullableTypeValueAsyncCore>d__94`2")]
private static Task UnpackNullableTypeValueAsyncCore(Unpacker unpacker, TContext context, MessagePackSerializer`1<Nullable`1<TValue>> serializer, int itemsCount, int unpacked, Type targetObjectType, string memberName, NilImplication nilImplication, Func`5<Unpacker, Type, string, CancellationToken, Task`1<Nullable`1<TValue>>> directRead, Action`2<TContext, Nullable`1<TValue>> setter, CancellationToken cancellationToken);
    [EditorBrowsableAttribute("1")]
public static void UnpackMessagePackObjectValueFromArray(Unpacker unpacker, TContext context, int itemsCount, int unpacked, string memberName, NilImplication nilImplication, Action`2<TContext, MessagePackObject> setter);
    [EditorBrowsableAttribute("1")]
public static Task UnpackMessagePackObjectValueFromArrayAsync(Unpacker unpacker, TContext context, int itemsCount, int unpacked, string memberName, NilImplication nilImplication, Action`2<TContext, MessagePackObject> setter, CancellationToken cancellationToken);
    [EditorBrowsableAttribute("1")]
public static void UnpackMessagePackObjectValueFromMap(Unpacker unpacker, TContext context, int itemsCount, int unpacked, string memberName, NilImplication nilImplication, Action`2<TContext, MessagePackObject> setter);
    [EditorBrowsableAttribute("1")]
public static Task UnpackMessagePackObjectValueFromMapAsync(Unpacker unpacker, TContext context, int itemsCount, int unpacked, string memberName, NilImplication nilImplication, Action`2<TContext, MessagePackObject> setter, CancellationToken cancellationToken);
    [EditorBrowsableAttribute("1")]
public static void UnpackMessagePackObjectValue(UnpackMessagePackObjectValueParameters`1& parameter);
    private static void UnpackMessagePackObjectValueCore(Unpacker unpacker, TContext unpackingContext, int itemsCount, int unpacked, string memberName, NilImplication nilImplication, Action`2<TContext, MessagePackObject> setter);
    [EditorBrowsableAttribute("1")]
public static Task UnpackMessagePackObjectValueAsync(UnpackMessagePackObjectValueAsyncParameters`1& parameter);
    [AsyncStateMachineAttribute("MsgPack.Serialization.UnpackHelpers/<UnpackMessagePackObjectValueAsyncCore>d__102`1")]
private static Task UnpackMessagePackObjectValueAsyncCore(Unpacker unpacker, TContext unpackingContext, int itemsCount, int unpacked, string memberName, NilImplication nilImplication, Action`2<TContext, MessagePackObject> setter, CancellationToken cancellationToken);
    [EditorBrowsableAttribute("1")]
public static TResult UnpackFromArray(Unpacker unpacker, TContext context, Func`2<TContext, TResult> factory, IList`1<string> itemNames, IList`1<Action`4<Unpacker, TContext, int, int>> operations);
    [EditorBrowsableAttribute("1")]
public static TResult UnpackFromArray(UnpackFromArrayParameters`2& parameter);
    private static TResult UnpackFromArrayCore(Unpacker unpacker, TContext unpackingContext, Func`2<TContext, TResult> factory, IList`1<string> itemNames, IList`1<Action`4<Unpacker, TContext, int, int>> operations);
    [EditorBrowsableAttribute("1")]
public static Task`1<TResult> UnpackFromArrayAsync(Unpacker unpacker, TContext context, Func`2<TContext, TResult> factory, IList`1<string> itemNames, IList`1<Func`6<Unpacker, TContext, int, int, CancellationToken, Task>> operations, CancellationToken cancellationToken);
    [EditorBrowsableAttribute("1")]
public static Task`1<TResult> UnpackFromArrayAsync(UnpackFromArrayAsyncParameters`2& parameter);
    [AsyncStateMachineAttribute("MsgPack.Serialization.UnpackHelpers/<UnpackFromArrayAsyncCore>d__108`2")]
private static Task`1<TResult> UnpackFromArrayAsyncCore(Unpacker unpacker, TContext unpackingContext, Func`2<TContext, TResult> factory, IList`1<string> itemNames, IList`1<Func`6<Unpacker, TContext, int, int, CancellationToken, Task>> operations, CancellationToken cancellationToken);
    [EditorBrowsableAttribute("1")]
public static TResult UnpackFromMap(Unpacker unpacker, TContext context, Func`2<TContext, TResult> factory, IDictionary`2<string, Action`4<Unpacker, TContext, int, int>> operations);
    [EditorBrowsableAttribute("1")]
public static TResult UnpackFromMap(UnpackFromMapParameters`2& parameter);
    private static TResult UnpackFromMapCore(Unpacker unpacker, TContext unpackingContext, Func`2<TContext, TResult> factory, IDictionary`2<string, Action`4<Unpacker, TContext, int, int>> operations);
    [EditorBrowsableAttribute("1")]
public static Task`1<TResult> UnpackFromMapAsync(Unpacker unpacker, TContext context, Func`2<TContext, TResult> factory, IDictionary`2<string, Func`6<Unpacker, TContext, int, int, CancellationToken, Task>> operations, CancellationToken cancellationToken);
    [EditorBrowsableAttribute("1")]
public static Task`1<TResult> UnpackFromMapAsync(UnpackFromMapAsyncParameters`2& parameter);
    [AsyncStateMachineAttribute("MsgPack.Serialization.UnpackHelpers/<UnpackFromMapAsyncCore>d__114`2")]
private static Task`1<TResult> UnpackFromMapAsyncCore(Unpacker unpacker, TContext unpackingContext, Func`2<TContext, TResult> factory, IDictionary`2<string, Func`6<Unpacker, TContext, int, int, CancellationToken, Task>> operations, CancellationToken cancellationToken);
    [EditorBrowsableAttribute("1")]
public static T UnpackCollection(Unpacker unpacker, int itemsCount, T collection, Action`3<Unpacker, T, int> bulkOperation, Action`4<Unpacker, T, int, int> eachOperation);
    [EditorBrowsableAttribute("1")]
public static T UnpackCollection(UnpackCollectionParameters`1& parameter);
    private static T UnpackCollectionCore(Unpacker unpacker, int itemsCount, T collection, Action`3<Unpacker, T, int> bulkOperation, Action`4<Unpacker, T, int, int> eachOperation);
    [EditorBrowsableAttribute("1")]
public static Task`1<T> UnpackCollectionAsync(Unpacker unpacker, int itemsCount, T collection, Func`5<Unpacker, T, int, CancellationToken, Task> bulkOperation, Func`6<Unpacker, T, int, int, CancellationToken, Task> eachOperation, CancellationToken cancellationToken);
    [EditorBrowsableAttribute("1")]
public static Task`1<T> UnpackCollectionAsync(UnpackCollectionAsyncParameters`1& parameter);
    [AsyncStateMachineAttribute("MsgPack.Serialization.UnpackHelpers/<UnpackCollectionAsyncCore>d__120`1")]
private static Task`1<T> UnpackCollectionAsyncCore(Unpacker unpacker, int itemsCount, T collection, Func`5<Unpacker, T, int, CancellationToken, Task> bulkOperation, Func`6<Unpacker, T, int, int, CancellationToken, Task> eachOperation, CancellationToken cancellationToken);
}
[EditorBrowsableAttribute("1")]
public class MsgPack.Serialization.UnpackMessagePackObjectValueAsyncParameters`1 : ValueType {
    public Unpacker Unpacker;
    public TContext UnpackingContext;
    public MessagePackSerializer`1<MessagePackObject> Serializer;
    public int ItemsCount;
    public int Unpacked;
    public string MemberName;
    public Action`2<TContext, MessagePackObject> Setter;
    public NilImplication NilImplication;
    public CancellationToken CancellationToken;
}
[EditorBrowsableAttribute("1")]
public class MsgPack.Serialization.UnpackMessagePackObjectValueParameters`1 : ValueType {
    public Unpacker Unpacker;
    public TContext UnpackingContext;
    public MessagePackSerializer`1<MessagePackObject> Serializer;
    public int ItemsCount;
    public int Unpacked;
    public string MemberName;
    public Action`2<TContext, MessagePackObject> Setter;
    public NilImplication NilImplication;
}
[EditorBrowsableAttribute("1")]
public class MsgPack.Serialization.UnpackNullableTypeValueAsyncParameters`2 : ValueType {
    public Unpacker Unpacker;
    public TContext UnpackingContext;
    public MessagePackSerializer`1<Nullable`1<TValue>> Serializer;
    public int ItemsCount;
    public int Unpacked;
    public string MemberName;
    public Action`2<TContext, Nullable`1<TValue>> Setter;
    public Type TargetObjectType;
    public Func`5<Unpacker, Type, string, CancellationToken, Task`1<Nullable`1<TValue>>> DirectRead;
    public NilImplication NilImplication;
    public CancellationToken CancellationToken;
}
[EditorBrowsableAttribute("1")]
public class MsgPack.Serialization.UnpackNullableTypeValueParameters`2 : ValueType {
    public Unpacker Unpacker;
    public TContext UnpackingContext;
    public MessagePackSerializer`1<Nullable`1<TValue>> Serializer;
    public int ItemsCount;
    public int Unpacked;
    public string MemberName;
    public Action`2<TContext, Nullable`1<TValue>> Setter;
    public Type TargetObjectType;
    public Func`4<Unpacker, Type, string, Nullable`1<TValue>> DirectRead;
    public NilImplication NilImplication;
}
[EditorBrowsableAttribute("1")]
public class MsgPack.Serialization.UnpackReferenceTypeValueAsyncParameters`2 : ValueType {
    public Unpacker Unpacker;
    public TContext UnpackingContext;
    public MessagePackSerializer`1<TValue> Serializer;
    public int ItemsCount;
    public int Unpacked;
    public string MemberName;
    public Action`2<TContext, TValue> Setter;
    public Type TargetObjectType;
    public Func`5<Unpacker, Type, string, CancellationToken, Task`1<TValue>> DirectRead;
    public NilImplication NilImplication;
    public CancellationToken CancellationToken;
}
[EditorBrowsableAttribute("1")]
public class MsgPack.Serialization.UnpackReferenceTypeValueParameters`2 : ValueType {
    public Unpacker Unpacker;
    public TContext UnpackingContext;
    public MessagePackSerializer`1<TValue> Serializer;
    public int ItemsCount;
    public int Unpacked;
    public string MemberName;
    public Action`2<TContext, TValue> Setter;
    public Type TargetObjectType;
    public Func`4<Unpacker, Type, string, TValue> DirectRead;
    public NilImplication NilImplication;
}
[EditorBrowsableAttribute("1")]
public class MsgPack.Serialization.UnpackValueTypeValueAsyncParameters`2 : ValueType {
    public Unpacker Unpacker;
    public TContext UnpackingContext;
    public MessagePackSerializer`1<TValue> Serializer;
    public int ItemsCount;
    public int Unpacked;
    public string MemberName;
    public Action`2<TContext, TValue> Setter;
    public Type TargetObjectType;
    public Func`5<Unpacker, Type, string, CancellationToken, Task`1<TValue>> DirectRead;
    public CancellationToken CancellationToken;
}
[EditorBrowsableAttribute("1")]
public class MsgPack.Serialization.UnpackValueTypeValueParameters`2 : ValueType {
    public Unpacker Unpacker;
    public TContext UnpackingContext;
    public MessagePackSerializer`1<TValue> Serializer;
    public int ItemsCount;
    public int Unpacked;
    public string MemberName;
    public Action`2<TContext, TValue> Setter;
    public Type TargetObjectType;
    public Func`4<Unpacker, Type, string, TValue> DirectRead;
}
internal static class MsgPack.SetOperation : object {
    public static bool IsProperSubsetOf(ISet`1<T> set, IEnumerable`1<T> other);
    public static bool IsSubsetOf(ISet`1<T> set, IEnumerable`1<T> other);
    private static bool IsSubsetOfCore(ISet`1<T> set, IEnumerable`1<T> other, Int32& otherCount);
    public static bool IsProperSupersetOf(ISet`1<T> set, IEnumerable`1<T> other);
    public static bool IsSupersetOf(ISet`1<T> set, IEnumerable`1<T> other);
    private static bool IsSupersetOfCore(ISet`1<T> set, IEnumerable`1<T> other, Int32& otherCount);
    public static bool Overlaps(ISet`1<T> set, IEnumerable`1<T> other);
    public static bool SetEquals(ISet`1<T> set, IEnumerable`1<T> other);
}
internal class MsgPack.SingleArrayBufferAllocator : ByteBufferAllocator {
    public static SingleArrayBufferAllocator Default;
    private Func`3<Byte[], int, Byte[]> _allocator;
    public SingleArrayBufferAllocator(Func`3<Byte[], int, Byte[]> allocator);
    private static SingleArrayBufferAllocator();
    private static Byte[] Allocate(Byte[] old, int requestSize);
    public virtual bool TryAllocate(Byte[] oldBuffer, int requestSize, Byte[]& newBuffer);
}
internal static class MsgPack.StringEscape : object {
    public static string ForDisplay(string value);
}
internal class MsgPack.SubtreeUnpacker : Unpacker {
    private Unpacker _root;
    private IRootUnpacker _internalRoot;
    private SubtreeUnpacker _parent;
    private Stack`1<bool> _isMap;
    private Stack`1<long> _unpacked;
    private Stack`1<long> _itemsCount;
    private State _state;
    public long ItemsCount { get; }
    public bool IsArrayHeader { get; }
    public bool IsMapHeader { get; }
    public bool IsCollectionHeader { get; }
    [ObsoleteAttribute("Consumer should not use this property. Query LastReadData instead.")]
public Nullable`1<MessagePackObject> Data { get; protected set; }
    public MessagePackObject LastReadData { get; protected set; }
    public SubtreeUnpacker(Unpacker parent);
    private SubtreeUnpacker(Unpacker root, SubtreeUnpacker parent);
    public virtual long get_ItemsCount();
    public virtual bool get_IsArrayHeader();
    public virtual bool get_IsMapHeader();
    public virtual bool get_IsCollectionHeader();
    public virtual Nullable`1<MessagePackObject> get_Data();
    protected virtual void set_Data(Nullable`1<MessagePackObject> value);
    public virtual MessagePackObject get_LastReadData();
    protected virtual void set_LastReadData(MessagePackObject value);
    protected virtual void Dispose(bool disposing);
    public virtual void Drain();
    [AsyncStateMachineAttribute("MsgPack.SubtreeUnpacker/<DrainAsync>d__25")]
public virtual Task DrainAsync(CancellationToken cancellationToken);
    protected internal virtual void EndReadSubtree();
    protected virtual Unpacker ReadSubtreeCore();
    private static void ThrowInTailException();
    private static void ThrowNotInHeadOfCollectionException();
    protected virtual bool ReadCore();
    [AsyncStateMachineAttribute("MsgPack.SubtreeUnpacker/<ReadAsyncCore>d__31")]
protected virtual Task`1<bool> ReadAsyncCore(CancellationToken cancellationToken);
    protected virtual Nullable`1<long> SkipCore();
    [AsyncStateMachineAttribute("MsgPack.SubtreeUnpacker/<SkipAsyncCore>d__33")]
protected virtual Task`1<Nullable`1<long>> SkipAsyncCore(CancellationToken cancellationToken);
    private void DiscardCompletedStacks();
    public virtual bool ReadBoolean(Boolean& result);
    public virtual bool ReadNullableBoolean(Nullable`1& result);
    public virtual bool ReadByte(Byte& result);
    public virtual bool ReadNullableByte(Nullable`1& result);
    public virtual bool ReadSByte(SByte& result);
    public virtual bool ReadNullableSByte(Nullable`1& result);
    public virtual bool ReadInt16(Int16& result);
    public virtual bool ReadNullableInt16(Nullable`1& result);
    public virtual bool ReadUInt16(UInt16& result);
    public virtual bool ReadNullableUInt16(Nullable`1& result);
    public virtual bool ReadInt32(Int32& result);
    public virtual bool ReadNullableInt32(Nullable`1& result);
    public virtual bool ReadUInt32(UInt32& result);
    public virtual bool ReadNullableUInt32(Nullable`1& result);
    public virtual bool ReadInt64(Int64& result);
    public virtual bool ReadNullableInt64(Nullable`1& result);
    public virtual bool ReadUInt64(UInt64& result);
    public virtual bool ReadNullableUInt64(Nullable`1& result);
    public virtual bool ReadSingle(Single& result);
    public virtual bool ReadNullableSingle(Nullable`1& result);
    public virtual bool ReadDouble(Double& result);
    public virtual bool ReadNullableDouble(Nullable`1& result);
    public virtual bool ReadArrayLength(Int64& result);
    public virtual bool ReadMapLength(Int64& result);
    public virtual bool ReadBinary(Byte[]& result);
    public virtual bool ReadString(String& result);
    public virtual bool ReadMessagePackExtendedTypeObject(MessagePackExtendedTypeObject& result);
    public virtual bool ReadObject(MessagePackObject& result);
}
internal static class MsgPack.TaskAugument : object {
    public static Task CompletedTask { get; }
    public static Task get_CompletedTask();
}
public class MsgPack.Timestamp : ValueType {
    private static BigInteger NanoToSecondsAsBigInteger;
    public static byte TypeCode;
    public static Timestamp Zero;
    public static Timestamp MinValue;
    public static Timestamp MaxValue;
    private static Int32[] LastDays;
    private static long MinUnixEpochSecondsForTicks;
    private static long MaxUnixEpochSecondsForTicks;
    private static int MaxNanoSeconds;
    private static long UnixEpochTicks;
    private static long UnixEpochInSeconds;
    private static int SecondsToTicks;
    private static int NanoToTicks;
    private static int SecondsToNanos;
    private long unixEpochSeconds;
    private UInt32 nanoseconds;
    private static int SecondsPerMinutes;
    private static int SecondsPerHours;
    private static int SecondsPerDay;
    private static int DaysPerYear;
    private static int DaysPer4Years;
    private static int DaysPer100Years;
    private static int DaysPer400Years;
    private static int DayOfWeekOfEpoc;
    private static UInt32[] DaysToMonth365;
    private static UInt32[] DaysToMonth366;
    private static UInt32[] ReversedDaysToMonth365;
    private static UInt32[] ReversedDaysToMonth366;
    public long UnixEpochSecondsPart { get; }
    public int NanosecondsPart { get; }
    public long Year { get; }
    public int Month { get; }
    public int Day { get; }
    public int Hour { get; }
    public int Minute { get; }
    public int Second { get; }
    public int Millisecond { get; }
    public int Microsecond { get; }
    public int Nanosecond { get; }
    public Timestamp Date { get; }
    public Timestamp TimeOfDay { get; }
    public DayOfWeek DayOfWeek { get; }
    public int DayOfYear { get; }
    public bool IsLeapYear { get; }
    public static Timestamp Today { get; }
    public static Timestamp UtcNow { get; }
    public Timestamp(long unixEpochSeconds, int nanoseconds);
    private static Timestamp();
    public Timestamp Add(TimeSpan offset);
    public Timestamp Subtract(TimeSpan offset);
    public Timestamp Add(BigInteger offsetNanoseconds);
    public Timestamp Subtract(BigInteger offsetNanoseconds);
    public BigInteger Subtract(Timestamp other);
    public static Timestamp op_Addition(Timestamp value, TimeSpan offset);
    public static Timestamp op_Subtraction(Timestamp value, TimeSpan offset);
    public static Timestamp op_Addition(Timestamp value, BigInteger offsetNanoseconds);
    public static Timestamp op_Subtraction(Timestamp value, BigInteger offsetNanoseconds);
    public static BigInteger op_Subtraction(Timestamp left, Timestamp right);
    public sealed virtual int CompareTo(Timestamp other);
    public static int Compare(Timestamp left, Timestamp right);
    private sealed virtual override int System.IComparable.CompareTo(object obj);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(Timestamp other);
    public virtual int GetHashCode();
    public static bool op_GreaterThan(Timestamp left, Timestamp right);
    public static bool op_LessThan(Timestamp left, Timestamp right);
    public static bool op_GreaterThanOrEqual(Timestamp left, Timestamp right);
    public static bool op_LessThanOrEqual(Timestamp left, Timestamp right);
    public static bool op_Equality(Timestamp left, Timestamp right);
    public static bool op_Inequality(Timestamp left, Timestamp right);
    private long ToTicks(Type destination);
    public DateTime ToDateTime();
    public DateTimeOffset ToDateTimeOffset();
    public MessagePackExtendedTypeObject Encode();
    private static void FromDateTimeTicks(long ticks, Int64& unixEpocSeconds, Int32& nanoSeconds);
    private static void FromOffsetTicks(long ticks, Int64& unixEpocSeconds, Int32& nanoSeconds);
    public static Timestamp FromDateTime(DateTime value);
    public static Timestamp FromDateTimeOffset(DateTimeOffset value);
    public static Timestamp Decode(MessagePackExtendedTypeObject value);
    public static DateTime op_Explicit(Timestamp value);
    public static DateTimeOffset op_Explicit(Timestamp value);
    public static MessagePackExtendedTypeObject op_Implicit(Timestamp value);
    public static Timestamp op_Implicit(DateTime value);
    public static Timestamp op_Implicit(DateTimeOffset value);
    public static Timestamp op_Explicit(MessagePackExtendedTypeObject value);
    internal static Timestamp FromComponents(Value& value, bool isLeapYear);
    private static long YearsToDaysOfNewYear(long years);
    private static int ToDaysOffsetFromNewYear(int month, int day, bool isLeapYear);
    internal static long DivRem(long dividend, long divisor, Int64& remainder);
    public static Timestamp ParseExact(string input, string format, IFormatProvider formatProvider);
    public static Timestamp ParseExact(string input, string format, IFormatProvider formatProvider, DateTimeStyles styles);
    public static Timestamp ParseExact(string input, String[] formats, IFormatProvider formatProvider, DateTimeStyles styles);
    private static void HandleParseResult(TimestampParseResult result, string messageForInvalidInput);
    public long get_UnixEpochSecondsPart();
    public int get_NanosecondsPart();
    public long get_Year();
    public int get_Month();
    public int get_Day();
    public int get_Hour();
    public int get_Minute();
    public int get_Second();
    public int get_Millisecond();
    public int get_Microsecond();
    public int get_Nanosecond();
    public Timestamp get_Date();
    public Timestamp get_TimeOfDay();
    public DayOfWeek get_DayOfWeek();
    public int get_DayOfYear();
    public bool get_IsLeapYear();
    internal static bool IsLeapYearInternal(long year);
    internal static int GetLastDay(int month, bool isLeapYear);
    private void GetDatePart(Int64& year, Int32& month, Int32& day, Int32& dayOfYear);
    private void GetDatePartAD(Int64& year, Int32& month, Int32& day, Int32& dayOfYear);
    private void GetDatePartBC(Int64& year, Int32& month, Int32& day, Int32& dayOfYear);
    public static Timestamp get_Today();
    public static Timestamp get_UtcNow();
    public virtual string ToString();
    public string ToString(IFormatProvider formatProvider);
    public string ToString(string format);
    public sealed virtual string ToString(string format, IFormatProvider formatProvider);
    public static bool TryParseExact(string input, string format, IFormatProvider formatProvider, DateTimeStyles styles, Timestamp& result);
    public static bool TryParseExact(string input, String[] formats, IFormatProvider formatProvider, DateTimeStyles styles, Timestamp& result);
    private static TimestampParseResult TryParseExactCore(string input, string format, IFormatProvider formatProvider, DateTimeStyles styles, Timestamp& result);
    private static TimestampParseResult TryParseExactCore(string input, String[] formats, IFormatProvider formatProvider, DateTimeStyles styles, Timestamp& result);
    private static void ValidateParseInput(string input);
    private static void ValidateParseStyles(DateTimeStyles styles);
}
internal enum MsgPack.TimestampParseResult : Enum {
    public int value__;
    public static TimestampParseResult Success;
    public static TimestampParseResult KindMask;
    public static TimestampParseResult KindNull;
    public static TimestampParseResult KindEmpty;
    public static TimestampParseResult KindUnsupported;
    public static TimestampParseResult KindLeadingWhitespaceNotSupported;
    public static TimestampParseResult KindTrailingWhitespaceNotSupported;
    public static TimestampParseResult KindMissingUtcSign;
    public static TimestampParseResult KindExtraCharactors;
    public static TimestampParseResult KindInvalidYear;
    public static TimestampParseResult KindInvalidMonth;
    public static TimestampParseResult KindInvalidDay;
    public static TimestampParseResult KindInvalidHour;
    public static TimestampParseResult KindInvalidMinute;
    public static TimestampParseResult KindInvalidSecond;
    public static TimestampParseResult KindInvalidNanoSecond;
    public static TimestampParseResult KindYearOutOfRange;
    public static TimestampParseResult KindInvalidYearMonthDeilimiter;
    public static TimestampParseResult KindInvalidMonthDayDelimiter;
    public static TimestampParseResult KindInvalidDateTimeDelimiter;
    public static TimestampParseResult KindInvalidHourMinuteDelimiter;
    public static TimestampParseResult KindInvalidMinuteSecondDelimiter;
    public static TimestampParseResult KindInvalidSubsecondDelimiter;
    public static TimestampParseResult KindNoMatchedFormats;
    public static TimestampParseResult ParameterMask;
    public static TimestampParseResult ParameterInput;
    public static TimestampParseResult ParameterFormat;
    public static TimestampParseResult ExceptionTypeMask;
    public static TimestampParseResult ArgumentNullException;
    public static TimestampParseResult ArgumentException;
    public static TimestampParseResult FormatException;
    public static TimestampParseResult NullInput;
    public static TimestampParseResult NullFormat;
    public static TimestampParseResult EmptyInput;
    public static TimestampParseResult EmptyFormat;
    public static TimestampParseResult UnsupportedFormat;
    public static TimestampParseResult LeadingWhitespaceNotAllowed;
    public static TimestampParseResult TrailingWhitespaceNotAllowed;
    public static TimestampParseResult MissingUtcSign;
    public static TimestampParseResult ExtraCharactors;
    public static TimestampParseResult InvalidYear;
    public static TimestampParseResult InvalidMonth;
    public static TimestampParseResult InvalidDay;
    public static TimestampParseResult InvalidHour;
    public static TimestampParseResult InvalidMinute;
    public static TimestampParseResult InvalidSecond;
    public static TimestampParseResult InvalidNanoSecond;
    public static TimestampParseResult YearOutOfRange;
    public static TimestampParseResult InvalidYearMonthDeilimiter;
    public static TimestampParseResult InvalidMonthDayDelimiter;
    public static TimestampParseResult InvalidDateTimeDelimiter;
    public static TimestampParseResult InvalidHourMinuteDelimiter;
    public static TimestampParseResult InvalidMinuteSecondDelimiter;
    public static TimestampParseResult InvalidSubsecondDelimiter;
    public static TimestampParseResult NoMatchedFormats;
}
internal static class MsgPack.TimestampStringConverter : object {
    private static char DateDelimiter;
    private static char TimeDelimiter;
    private static char DateTimeDelimiter;
    private static char SubsecondDelimiter;
    private static char UtcSign;
    private static string DefaultFormat;
    public static TimestampParseResult TryParseExact(string input, string format, IFormatProvider formatProvider, DateTimeStyles styles, Timestamp& result);
    private static bool ParseWhitespace(string input, Int32& position, bool allowWhitespace, bool isTrailing);
    private static bool ParseDelimiter(string input, Int32& position, char delimiter);
    private static bool ParseSign(string input, Int32& position, NumberFormatInfo numberFormat, Int32& sign);
    private static bool StartsWith(string input, int startIndex, string comparison);
    private static bool ParseDigit(string input, int minLength, Int32& position, Int64& digit);
    private static bool IsDigit(char c);
    private static bool ParseDigitRange(string input, int minLength, Int32& position, int min, int max, Int32& result);
    private static bool ParseYear(string input, Int32& position, NumberFormatInfo numberFormat, Int64& year);
    private static bool ParseDay(string input, Int32& position, int month, bool isLeapYear, Int32& day);
    public static string ToString(string format, IFormatProvider formatProvider, Value& value);
    private static string ToIso8601String(IFormatProvider formatProvider, bool containsNanosecons, Value& value);
}
internal static class MsgPack.TupleItems : object {
    public static List`1<Type> CreateTupleTypeList(Type rootTupleType);
    public static IList`1<Type> GetTupleItemTypes(Type tupleType);
    private static void GetTupleItemTypes(IList`1<Type> itemTypes, IList`1<Type> result);
    public static bool IsTuple(Type type);
}
public class MsgPack.UnassignedMessageTypeException : MessageTypeException {
    public UnassignedMessageTypeException(string message);
    public UnassignedMessageTypeException(string message, Exception inner);
    private UnassignedMessageTypeException(SerializationInfo info, StreamingContext context);
}
public abstract class MsgPack.Unpacker : object {
    private UnpackerMode _mode;
    [ObsoleteAttribute("Consumer should not use this property. Query LastReadData instead.")]
public Nullable`1<MessagePackObject> Data { get; protected set; }
    public MessagePackObject LastReadData { get; protected set; }
    public bool IsArrayHeader { get; }
    public bool IsMapHeader { get; }
    public bool IsCollectionHeader { get; }
    public long ItemsCount { get; }
    protected Stream UnderlyingStream { get; }
    public abstract virtual Nullable`1<MessagePackObject> get_Data();
    protected abstract virtual void set_Data(Nullable`1<MessagePackObject> value);
    public virtual MessagePackObject get_LastReadData();
    protected virtual void set_LastReadData(MessagePackObject value);
    public abstract virtual bool get_IsArrayHeader();
    public abstract virtual bool get_IsMapHeader();
    public virtual bool get_IsCollectionHeader();
    public abstract virtual long get_ItemsCount();
    internal void VerifyMode(UnpackerMode mode);
    internal void VerifyIsNotDisposed();
    private void ThrowObjectDisposedException();
    internal void ThrowInvalidModeException();
    protected virtual Stream get_UnderlyingStream();
    internal virtual bool GetPreviousPosition(Int64& offsetOrPosition);
    public static Unpacker Create(Stream stream);
    public static Unpacker Create(Stream stream, bool ownsStream);
    public static Unpacker Create(Stream stream, PackerUnpackerStreamOptions streamOptions);
    public static Unpacker Create(Stream stream, PackerUnpackerStreamOptions streamOptions, UnpackerOptions unpackerOptions);
    public static ByteArrayUnpacker Create(Byte[] source);
    public static ByteArrayUnpacker Create(Byte[] source, int startOffset);
    public static ByteArrayUnpacker Create(Byte[] source, UnpackerOptions unpackerOptions);
    public static ByteArrayUnpacker Create(Byte[] source, int startOffset, UnpackerOptions unpackerOptions);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public virtual void Drain();
    public Task DrainAsync();
    public virtual Task DrainAsync(CancellationToken cancellationToken);
    public Unpacker ReadSubtree();
    internal virtual Unpacker InternalReadSubtree();
    internal static void ThrowCannotBeSubtreeModeException();
    internal static void ThrowInSubtreeModeException();
    protected abstract virtual Unpacker ReadSubtreeCore();
    protected internal virtual void EndReadSubtree();
    public bool Read();
    internal bool ReadInternal();
    internal virtual void EnsureNotInSubtreeMode();
    private void SetStable();
    protected abstract virtual bool ReadCore();
    public Task`1<bool> ReadAsync();
    public Task`1<bool> ReadAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.Unpacker/<ReadInternalAsync>d__49")]
internal Task`1<bool> ReadInternalAsync(CancellationToken cancellationToken);
    protected Task`1<bool> ReadAsyncCore();
    protected virtual Task`1<bool> ReadAsyncCore(CancellationToken cancellationToken);
    [IteratorStateMachineAttribute("MsgPack.Unpacker/<GetEnumerator>d__52")]
public sealed virtual IEnumerator`1<MessagePackObject> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public Nullable`1<long> Skip();
    private void BeginSkip();
    internal virtual void BeginSkipCore();
    private void EndSkip(Nullable`1<long> result);
    protected abstract virtual Nullable`1<long> SkipCore();
    public Task`1<Nullable`1<long>> SkipAsync();
    [AsyncStateMachineAttribute("MsgPack.Unpacker/<SkipAsync>d__60")]
public Task`1<Nullable`1<long>> SkipAsync(CancellationToken cancellationToken);
    protected Task`1<Nullable`1<long>> SkipAsyncCore();
    protected virtual Task`1<Nullable`1<long>> SkipAsyncCore(CancellationToken cancellationToken);
    public Nullable`1<MessagePackObject> ReadItem();
    public MessagePackObject ReadItemData();
    public Task`1<Nullable`1<MessagePackObject>> ReadItemAsync();
    [AsyncStateMachineAttribute("MsgPack.Unpacker/<ReadItemAsync>d__66")]
public Task`1<Nullable`1<MessagePackObject>> ReadItemAsync(CancellationToken cancellationToken);
    public Task`1<MessagePackObject> ReadItemDataAsync();
    [AsyncStateMachineAttribute("MsgPack.Unpacker/<ReadItemDataAsync>d__68")]
public Task`1<MessagePackObject> ReadItemDataAsync(CancellationToken cancellationToken);
    internal virtual void ThrowEofException();
    public Nullable`1<MessagePackObject> UnpackSubtree();
    public MessagePackObject UnpackSubtreeData();
    internal bool UnpackSubtreeDataCore(MessagePackObject& result);
    public Task`1<Nullable`1<MessagePackObject>> UnpackSubtreeAsync();
    [AsyncStateMachineAttribute("MsgPack.Unpacker/<UnpackSubtreeAsync>d__74")]
public Task`1<Nullable`1<MessagePackObject>> UnpackSubtreeAsync(CancellationToken cancellationToken);
    public Task`1<MessagePackObject> UnpackSubtreeDataAsync();
    [AsyncStateMachineAttribute("MsgPack.Unpacker/<UnpackSubtreeDataAsync>d__76")]
public Task`1<MessagePackObject> UnpackSubtreeDataAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("MsgPack.Unpacker/<UnpackSubtreeDataAsyncCore>d__77")]
internal Task`1<AsyncReadResult`1<MessagePackObject>> UnpackSubtreeDataAsyncCore(CancellationToken cancellationToken);
    [CLSCompliantAttribute("False")]
public virtual bool ReadBoolean(Boolean& result);
    [CLSCompliantAttribute("False")]
public Task`1<AsyncReadResult`1<bool>> ReadBooleanAsync();
    [AsyncStateMachineAttribute("MsgPack.Unpacker/<ReadBooleanAsync>d__81")]
[CLSCompliantAttribute("False")]
public virtual Task`1<AsyncReadResult`1<bool>> ReadBooleanAsync(CancellationToken cancellationToken);
    [CLSCompliantAttribute("False")]
public virtual bool ReadNullableBoolean(Nullable`1& result);
    [CLSCompliantAttribute("False")]
public Task`1<AsyncReadResult`1<Nullable`1<bool>>> ReadNullableBooleanAsync();
    [AsyncStateMachineAttribute("MsgPack.Unpacker/<ReadNullableBooleanAsync>d__84")]
[CLSCompliantAttribute("False")]
public virtual Task`1<AsyncReadResult`1<Nullable`1<bool>>> ReadNullableBooleanAsync(CancellationToken cancellationToken);
    [CLSCompliantAttribute("False")]
public virtual bool ReadByte(Byte& result);
    [CLSCompliantAttribute("False")]
public Task`1<AsyncReadResult`1<byte>> ReadByteAsync();
    [AsyncStateMachineAttribute("MsgPack.Unpacker/<ReadByteAsync>d__87")]
[CLSCompliantAttribute("False")]
public virtual Task`1<AsyncReadResult`1<byte>> ReadByteAsync(CancellationToken cancellationToken);
    [CLSCompliantAttribute("False")]
public virtual bool ReadNullableByte(Nullable`1& result);
    [CLSCompliantAttribute("False")]
public Task`1<AsyncReadResult`1<Nullable`1<byte>>> ReadNullableByteAsync();
    [AsyncStateMachineAttribute("MsgPack.Unpacker/<ReadNullableByteAsync>d__90")]
[CLSCompliantAttribute("False")]
public virtual Task`1<AsyncReadResult`1<Nullable`1<byte>>> ReadNullableByteAsync(CancellationToken cancellationToken);
    [CLSCompliantAttribute("False")]
public virtual bool ReadSByte(SByte& result);
    [CLSCompliantAttribute("False")]
public Task`1<AsyncReadResult`1<sbyte>> ReadSByteAsync();
    [AsyncStateMachineAttribute("MsgPack.Unpacker/<ReadSByteAsync>d__93")]
[CLSCompliantAttribute("False")]
public virtual Task`1<AsyncReadResult`1<sbyte>> ReadSByteAsync(CancellationToken cancellationToken);
    [CLSCompliantAttribute("False")]
public virtual bool ReadNullableSByte(Nullable`1& result);
    [CLSCompliantAttribute("False")]
public Task`1<AsyncReadResult`1<Nullable`1<sbyte>>> ReadNullableSByteAsync();
    [AsyncStateMachineAttribute("MsgPack.Unpacker/<ReadNullableSByteAsync>d__96")]
[CLSCompliantAttribute("False")]
public virtual Task`1<AsyncReadResult`1<Nullable`1<sbyte>>> ReadNullableSByteAsync(CancellationToken cancellationToken);
    [CLSCompliantAttribute("False")]
public virtual bool ReadInt16(Int16& result);
    [CLSCompliantAttribute("False")]
public Task`1<AsyncReadResult`1<short>> ReadInt16Async();
    [AsyncStateMachineAttribute("MsgPack.Unpacker/<ReadInt16Async>d__99")]
[CLSCompliantAttribute("False")]
public virtual Task`1<AsyncReadResult`1<short>> ReadInt16Async(CancellationToken cancellationToken);
    [CLSCompliantAttribute("False")]
public virtual bool ReadNullableInt16(Nullable`1& result);
    [CLSCompliantAttribute("False")]
public Task`1<AsyncReadResult`1<Nullable`1<short>>> ReadNullableInt16Async();
    [AsyncStateMachineAttribute("MsgPack.Unpacker/<ReadNullableInt16Async>d__102")]
[CLSCompliantAttribute("False")]
public virtual Task`1<AsyncReadResult`1<Nullable`1<short>>> ReadNullableInt16Async(CancellationToken cancellationToken);
    [CLSCompliantAttribute("False")]
public virtual bool ReadUInt16(UInt16& result);
    [CLSCompliantAttribute("False")]
public Task`1<AsyncReadResult`1<ushort>> ReadUInt16Async();
    [AsyncStateMachineAttribute("MsgPack.Unpacker/<ReadUInt16Async>d__105")]
[CLSCompliantAttribute("False")]
public virtual Task`1<AsyncReadResult`1<ushort>> ReadUInt16Async(CancellationToken cancellationToken);
    [CLSCompliantAttribute("False")]
public virtual bool ReadNullableUInt16(Nullable`1& result);
    [CLSCompliantAttribute("False")]
public Task`1<AsyncReadResult`1<Nullable`1<ushort>>> ReadNullableUInt16Async();
    [AsyncStateMachineAttribute("MsgPack.Unpacker/<ReadNullableUInt16Async>d__108")]
[CLSCompliantAttribute("False")]
public virtual Task`1<AsyncReadResult`1<Nullable`1<ushort>>> ReadNullableUInt16Async(CancellationToken cancellationToken);
    [CLSCompliantAttribute("False")]
public virtual bool ReadInt32(Int32& result);
    [CLSCompliantAttribute("False")]
public Task`1<AsyncReadResult`1<int>> ReadInt32Async();
    [AsyncStateMachineAttribute("MsgPack.Unpacker/<ReadInt32Async>d__111")]
[CLSCompliantAttribute("False")]
public virtual Task`1<AsyncReadResult`1<int>> ReadInt32Async(CancellationToken cancellationToken);
    [CLSCompliantAttribute("False")]
public virtual bool ReadNullableInt32(Nullable`1& result);
    [CLSCompliantAttribute("False")]
public Task`1<AsyncReadResult`1<Nullable`1<int>>> ReadNullableInt32Async();
    [AsyncStateMachineAttribute("MsgPack.Unpacker/<ReadNullableInt32Async>d__114")]
[CLSCompliantAttribute("False")]
public virtual Task`1<AsyncReadResult`1<Nullable`1<int>>> ReadNullableInt32Async(CancellationToken cancellationToken);
    [CLSCompliantAttribute("False")]
public virtual bool ReadUInt32(UInt32& result);
    [CLSCompliantAttribute("False")]
public Task`1<AsyncReadResult`1<UInt32>> ReadUInt32Async();
    [AsyncStateMachineAttribute("MsgPack.Unpacker/<ReadUInt32Async>d__117")]
[CLSCompliantAttribute("False")]
public virtual Task`1<AsyncReadResult`1<UInt32>> ReadUInt32Async(CancellationToken cancellationToken);
    [CLSCompliantAttribute("False")]
public virtual bool ReadNullableUInt32(Nullable`1& result);
    [CLSCompliantAttribute("False")]
public Task`1<AsyncReadResult`1<Nullable`1<UInt32>>> ReadNullableUInt32Async();
    [AsyncStateMachineAttribute("MsgPack.Unpacker/<ReadNullableUInt32Async>d__120")]
[CLSCompliantAttribute("False")]
public virtual Task`1<AsyncReadResult`1<Nullable`1<UInt32>>> ReadNullableUInt32Async(CancellationToken cancellationToken);
    [CLSCompliantAttribute("False")]
public virtual bool ReadInt64(Int64& result);
    [CLSCompliantAttribute("False")]
public Task`1<AsyncReadResult`1<long>> ReadInt64Async();
    [AsyncStateMachineAttribute("MsgPack.Unpacker/<ReadInt64Async>d__123")]
[CLSCompliantAttribute("False")]
public virtual Task`1<AsyncReadResult`1<long>> ReadInt64Async(CancellationToken cancellationToken);
    [CLSCompliantAttribute("False")]
public virtual bool ReadNullableInt64(Nullable`1& result);
    [CLSCompliantAttribute("False")]
public Task`1<AsyncReadResult`1<Nullable`1<long>>> ReadNullableInt64Async();
    [AsyncStateMachineAttribute("MsgPack.Unpacker/<ReadNullableInt64Async>d__126")]
[CLSCompliantAttribute("False")]
public virtual Task`1<AsyncReadResult`1<Nullable`1<long>>> ReadNullableInt64Async(CancellationToken cancellationToken);
    [CLSCompliantAttribute("False")]
public virtual bool ReadUInt64(UInt64& result);
    [CLSCompliantAttribute("False")]
public Task`1<AsyncReadResult`1<ulong>> ReadUInt64Async();
    [AsyncStateMachineAttribute("MsgPack.Unpacker/<ReadUInt64Async>d__129")]
[CLSCompliantAttribute("False")]
public virtual Task`1<AsyncReadResult`1<ulong>> ReadUInt64Async(CancellationToken cancellationToken);
    [CLSCompliantAttribute("False")]
public virtual bool ReadNullableUInt64(Nullable`1& result);
    [CLSCompliantAttribute("False")]
public Task`1<AsyncReadResult`1<Nullable`1<ulong>>> ReadNullableUInt64Async();
    [AsyncStateMachineAttribute("MsgPack.Unpacker/<ReadNullableUInt64Async>d__132")]
[CLSCompliantAttribute("False")]
public virtual Task`1<AsyncReadResult`1<Nullable`1<ulong>>> ReadNullableUInt64Async(CancellationToken cancellationToken);
    [CLSCompliantAttribute("False")]
public virtual bool ReadSingle(Single& result);
    [CLSCompliantAttribute("False")]
public Task`1<AsyncReadResult`1<float>> ReadSingleAsync();
    [AsyncStateMachineAttribute("MsgPack.Unpacker/<ReadSingleAsync>d__135")]
[CLSCompliantAttribute("False")]
public virtual Task`1<AsyncReadResult`1<float>> ReadSingleAsync(CancellationToken cancellationToken);
    [CLSCompliantAttribute("False")]
public virtual bool ReadNullableSingle(Nullable`1& result);
    [CLSCompliantAttribute("False")]
public Task`1<AsyncReadResult`1<Nullable`1<float>>> ReadNullableSingleAsync();
    [AsyncStateMachineAttribute("MsgPack.Unpacker/<ReadNullableSingleAsync>d__138")]
[CLSCompliantAttribute("False")]
public virtual Task`1<AsyncReadResult`1<Nullable`1<float>>> ReadNullableSingleAsync(CancellationToken cancellationToken);
    [CLSCompliantAttribute("False")]
public virtual bool ReadDouble(Double& result);
    [CLSCompliantAttribute("False")]
public Task`1<AsyncReadResult`1<double>> ReadDoubleAsync();
    [AsyncStateMachineAttribute("MsgPack.Unpacker/<ReadDoubleAsync>d__141")]
[CLSCompliantAttribute("False")]
public virtual Task`1<AsyncReadResult`1<double>> ReadDoubleAsync(CancellationToken cancellationToken);
    [CLSCompliantAttribute("False")]
public virtual bool ReadNullableDouble(Nullable`1& result);
    [CLSCompliantAttribute("False")]
public Task`1<AsyncReadResult`1<Nullable`1<double>>> ReadNullableDoubleAsync();
    [AsyncStateMachineAttribute("MsgPack.Unpacker/<ReadNullableDoubleAsync>d__144")]
[CLSCompliantAttribute("False")]
public virtual Task`1<AsyncReadResult`1<Nullable`1<double>>> ReadNullableDoubleAsync(CancellationToken cancellationToken);
    public virtual bool ReadMessagePackExtendedTypeObject(MessagePackExtendedTypeObject& result);
    public Task`1<AsyncReadResult`1<MessagePackExtendedTypeObject>> ReadMessagePackExtendedTypeObjectAsync();
    [AsyncStateMachineAttribute("MsgPack.Unpacker/<ReadMessagePackExtendedTypeObjectAsync>d__147")]
public virtual Task`1<AsyncReadResult`1<MessagePackExtendedTypeObject>> ReadMessagePackExtendedTypeObjectAsync(CancellationToken cancellationToken);
    public virtual bool ReadNullableMessagePackExtendedTypeObject(Nullable`1& result);
    public Task`1<AsyncReadResult`1<Nullable`1<MessagePackExtendedTypeObject>>> ReadNullableMessagePackExtendedTypeObjectAsync();
    [AsyncStateMachineAttribute("MsgPack.Unpacker/<ReadNullableMessagePackExtendedTypeObjectAsync>d__150")]
public virtual Task`1<AsyncReadResult`1<Nullable`1<MessagePackExtendedTypeObject>>> ReadNullableMessagePackExtendedTypeObjectAsync(CancellationToken cancellationToken);
    public virtual bool ReadArrayLength(Int64& result);
    public Task`1<AsyncReadResult`1<long>> ReadArrayLengthAsync();
    [AsyncStateMachineAttribute("MsgPack.Unpacker/<ReadArrayLengthAsync>d__153")]
public virtual Task`1<AsyncReadResult`1<long>> ReadArrayLengthAsync(CancellationToken cancellationToken);
    public virtual bool ReadMapLength(Int64& result);
    public Task`1<AsyncReadResult`1<long>> ReadMapLengthAsync();
    [AsyncStateMachineAttribute("MsgPack.Unpacker/<ReadMapLengthAsync>d__156")]
public virtual Task`1<AsyncReadResult`1<long>> ReadMapLengthAsync(CancellationToken cancellationToken);
    public virtual bool ReadBinary(Byte[]& result);
    public Task`1<AsyncReadResult`1<Byte[]>> ReadBinaryAsync();
    [AsyncStateMachineAttribute("MsgPack.Unpacker/<ReadBinaryAsync>d__159")]
public virtual Task`1<AsyncReadResult`1<Byte[]>> ReadBinaryAsync(CancellationToken cancellationToken);
    public virtual bool ReadString(String& result);
    public Task`1<AsyncReadResult`1<string>> ReadStringAsync();
    [AsyncStateMachineAttribute("MsgPack.Unpacker/<ReadStringAsync>d__162")]
public virtual Task`1<AsyncReadResult`1<string>> ReadStringAsync(CancellationToken cancellationToken);
    public virtual bool ReadObject(MessagePackObject& result);
    public Task`1<AsyncReadResult`1<MessagePackObject>> ReadObjectAsync();
    [AsyncStateMachineAttribute("MsgPack.Unpacker/<ReadObjectAsync>d__165")]
public virtual Task`1<AsyncReadResult`1<MessagePackObject>> ReadObjectAsync(CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
private bool <ReadAsyncCore>b__51_0();
    [CompilerGeneratedAttribute]
private Nullable`1<long> <SkipAsyncCore>b__62_0();
}
public class MsgPack.UnpackerOptions : object {
    [CompilerGeneratedAttribute]
private UnpackerValidationLevel <ValidationLevel>k__BackingField;
    public UnpackerValidationLevel ValidationLevel { get; public set; }
    [CompilerGeneratedAttribute]
public UnpackerValidationLevel get_ValidationLevel();
    [CompilerGeneratedAttribute]
public void set_ValidationLevel(UnpackerValidationLevel value);
}
public enum MsgPack.UnpackerValidationLevel : Enum {
    public int value__;
    public static UnpackerValidationLevel None;
    public static UnpackerValidationLevel Collection;
}
public class MsgPack.UnpackException : Exception {
    public UnpackException(string message);
    public UnpackException(string message, Exception inner);
    private UnpackException(SerializationInfo info, StreamingContext context);
}
public static class MsgPack.Unpacking : object {
    private static void ValidateByteArray(Byte[] source, int offset);
    private static void ValidateStream(Stream source);
    private static void UnpackOne(Unpacker unpacker);
    private static void VerifyIsScalar(Unpacker unpacker);
    private static bool UnpackBooleanCore(Stream source);
    private static object UnpackNullCore(Stream source);
    private static Nullable`1<UInt32> UnpackArrayLengthCore(Stream source);
    private static IList`1<MessagePackObject> UnpackArrayCore(Stream source);
    private static IList`1<MessagePackObject> UnpackArrayCore(Unpacker unpacker);
    private static Nullable`1<UInt32> UnpackDictionaryCountCore(Stream source);
    private static MessagePackObjectDictionary UnpackDictionaryCore(Stream source);
    private static MessagePackObjectDictionary UnpackDictionaryCore(Unpacker unpacker);
    private static UInt32 UnpackRawLengthCore(Stream source);
    private static Byte[] ReadBytes(Stream source, int length);
    private static Byte[] UnpackBinaryCore(Stream source);
    private static MessagePackObject UnpackObjectCore(Stream source);
    private static MessagePackObject UnpackObjectCore(Unpacker unpacker);
    private static MessagePackExtendedTypeObject UnpackExtendedTypeObjectCore(Stream source);
    private static bool IsNil(Unpacker unpacker);
    private static Exception NewTypeMismatchException(Type requestedType, InvalidOperationException innerException);
    public static UnpackingResult`1<byte> UnpackByte(Byte[] source);
    public static UnpackingResult`1<byte> UnpackByte(Byte[] source, int offset);
    public static byte UnpackByte(Stream source);
    private static byte UnpackByteCore(Stream source);
    [CLSCompliantAttribute("False")]
public static UnpackingResult`1<sbyte> UnpackSByte(Byte[] source);
    [CLSCompliantAttribute("False")]
public static UnpackingResult`1<sbyte> UnpackSByte(Byte[] source, int offset);
    [CLSCompliantAttribute("False")]
public static sbyte UnpackSByte(Stream source);
    private static sbyte UnpackSByteCore(Stream source);
    public static UnpackingResult`1<short> UnpackInt16(Byte[] source);
    public static UnpackingResult`1<short> UnpackInt16(Byte[] source, int offset);
    public static short UnpackInt16(Stream source);
    private static short UnpackInt16Core(Stream source);
    [CLSCompliantAttribute("False")]
public static UnpackingResult`1<ushort> UnpackUInt16(Byte[] source);
    [CLSCompliantAttribute("False")]
public static UnpackingResult`1<ushort> UnpackUInt16(Byte[] source, int offset);
    [CLSCompliantAttribute("False")]
public static ushort UnpackUInt16(Stream source);
    private static ushort UnpackUInt16Core(Stream source);
    public static UnpackingResult`1<int> UnpackInt32(Byte[] source);
    public static UnpackingResult`1<int> UnpackInt32(Byte[] source, int offset);
    public static int UnpackInt32(Stream source);
    private static int UnpackInt32Core(Stream source);
    [CLSCompliantAttribute("False")]
public static UnpackingResult`1<UInt32> UnpackUInt32(Byte[] source);
    [CLSCompliantAttribute("False")]
public static UnpackingResult`1<UInt32> UnpackUInt32(Byte[] source, int offset);
    [CLSCompliantAttribute("False")]
public static UInt32 UnpackUInt32(Stream source);
    private static UInt32 UnpackUInt32Core(Stream source);
    public static UnpackingResult`1<long> UnpackInt64(Byte[] source);
    public static UnpackingResult`1<long> UnpackInt64(Byte[] source, int offset);
    public static long UnpackInt64(Stream source);
    private static long UnpackInt64Core(Stream source);
    [CLSCompliantAttribute("False")]
public static UnpackingResult`1<ulong> UnpackUInt64(Byte[] source);
    [CLSCompliantAttribute("False")]
public static UnpackingResult`1<ulong> UnpackUInt64(Byte[] source, int offset);
    [CLSCompliantAttribute("False")]
public static ulong UnpackUInt64(Stream source);
    private static ulong UnpackUInt64Core(Stream source);
    public static UnpackingResult`1<float> UnpackSingle(Byte[] source);
    public static UnpackingResult`1<float> UnpackSingle(Byte[] source, int offset);
    public static float UnpackSingle(Stream source);
    private static float UnpackSingleCore(Stream source);
    public static UnpackingResult`1<double> UnpackDouble(Byte[] source);
    public static UnpackingResult`1<double> UnpackDouble(Byte[] source, int offset);
    public static double UnpackDouble(Stream source);
    private static double UnpackDoubleCore(Stream source);
    public static UnpackingResult`1<IList`1<MessagePackObject>> UnpackArray(Byte[] source);
    public static UnpackingResult`1<IList`1<MessagePackObject>> UnpackArray(Byte[] source, int offset);
    public static IList`1<MessagePackObject> UnpackArray(Stream source);
    public static UnpackingResult`1<Nullable`1<long>> UnpackArrayLength(Byte[] source);
    public static UnpackingResult`1<Nullable`1<long>> UnpackArrayLength(Byte[] source, int offset);
    public static Nullable`1<long> UnpackArrayLength(Stream source);
    public static UnpackingResult`1<MessagePackObjectDictionary> UnpackDictionary(Byte[] source);
    public static UnpackingResult`1<MessagePackObjectDictionary> UnpackDictionary(Byte[] source, int offset);
    public static MessagePackObjectDictionary UnpackDictionary(Stream source);
    public static UnpackingResult`1<Nullable`1<long>> UnpackDictionaryCount(Byte[] source);
    public static UnpackingResult`1<Nullable`1<long>> UnpackDictionaryCount(Byte[] source, int offset);
    public static Nullable`1<long> UnpackDictionaryCount(Stream source);
    public static UnpackingResult`1<Byte[]> UnpackBinary(Byte[] source);
    public static UnpackingResult`1<Byte[]> UnpackBinary(Byte[] source, int offset);
    public static Byte[] UnpackBinary(Stream source);
    public static UnpackingResult`1<bool> UnpackBoolean(Byte[] source);
    public static UnpackingResult`1<bool> UnpackBoolean(Byte[] source, int offset);
    public static bool UnpackBoolean(Stream source);
    public static UnpackingResult`1<object> UnpackNull(Byte[] source);
    public static UnpackingResult`1<object> UnpackNull(Byte[] source, int offset);
    public static object UnpackNull(Stream source);
    public static UnpackingResult`1<MessagePackObject> UnpackObject(Byte[] source);
    public static UnpackingResult`1<MessagePackObject> UnpackObject(Byte[] source, int offset);
    public static MessagePackObject UnpackObject(Stream source);
    public static UnpackingResult`1<MessagePackExtendedTypeObject> UnpackExtendedTypeObject(Byte[] source);
    public static UnpackingResult`1<MessagePackExtendedTypeObject> UnpackExtendedTypeObject(Byte[] source, int offset);
    public static MessagePackExtendedTypeObject UnpackExtendedTypeObject(Stream source);
    public static UnpackingStream UnpackByteStream(Stream source);
    private static UnpackingStream UnpackByteStreamCore(Stream source);
    public static UnpackingStreamReader UnpackCharStream(Stream source);
    public static UnpackingStreamReader UnpackCharStream(Stream source, Encoding encoding);
    public static UnpackingResult`1<string> UnpackString(Byte[] source);
    public static UnpackingResult`1<string> UnpackString(Byte[] source, Encoding encoding);
    public static UnpackingResult`1<string> UnpackString(Byte[] source, int offset);
    public static UnpackingResult`1<string> UnpackString(Byte[] source, int offset, Encoding encoding);
    public static string UnpackString(Stream source);
    public static string UnpackString(Stream source, Encoding encoding);
    private static Exception NewInvalidEncodingException(Encoding encoding, Exception innerException);
}
internal enum MsgPack.UnpackingMode : Enum {
    public int value__;
    public static UnpackingMode PerEntry;
    public static UnpackingMode SkipSubtree;
}
public class MsgPack.UnpackingResult`1 : ValueType {
    private int _readCount;
    private T _value;
    public int ReadCount { get; }
    public T Value { get; }
    internal UnpackingResult`1(T value, int readCount);
    public int get_ReadCount();
    public T get_Value();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(UnpackingResult`1<T> other);
    public virtual int GetHashCode();
    public virtual string ToString();
    public static bool op_Equality(UnpackingResult`1<T> left, UnpackingResult`1<T> right);
    public static bool op_Inequality(UnpackingResult`1<T> left, UnpackingResult`1<T> right);
}
public abstract class MsgPack.UnpackingStream : Stream {
    internal Stream Underlying;
    internal long RawLength;
    internal long CurrentOffset;
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public bool CanTimeout { get; }
    internal UnpackingStream(Stream underlying, long rawLength);
    public sealed virtual bool get_CanRead();
    public sealed virtual bool get_CanWrite();
    public sealed virtual long get_Length();
    public sealed virtual bool get_CanTimeout();
    public sealed virtual int Read(Byte[] buffer, int offset, int count);
    public sealed virtual void Flush();
    public sealed virtual void SetLength(long value);
    public sealed virtual void Write(Byte[] buffer, int offset, int count);
}
public abstract class MsgPack.UnpackingStreamReader : StreamReader {
    private long _byteLength;
    public long ByteLength { get; }
    internal UnpackingStreamReader(Stream stream, Encoding encoding, long byteLength);
    public long get_ByteLength();
}
[SuppressUnmanagedCodeSecurityAttribute]
[SecurityCriticalAttribute]
internal static class MsgPack.UnsafeNativeMethods : object {
    private static int _libCAvailability;
    private static int _libCAvailability_Unknown;
    private static int _libCAvailability_MSVCRT;
    private static int _libCAvailability_LibC;
    private static int _libCAvailability_None;
    private static UnsafeNativeMethods();
    private static int memcmpVC(Byte[] s1, Byte[] s2, UIntPtr size);
    private static int memcmpLibC(Byte[] s1, Byte[] s2, UIntPtr size);
    public static bool TryMemCmp(Byte[] s1, Byte[] s2, UIntPtr size, Int32& result);
}
internal static class MsgPack.Validation : object {
    private static string UnicodeTr15Annex7Idneifier;
    private static Regex NamespacePattern;
    private static Validation();
    public static void ValidateNamespace(string namespace, string parameterName);
    private static bool IsPrintable(UnicodeCategory category);
}
