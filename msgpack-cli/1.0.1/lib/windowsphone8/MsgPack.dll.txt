public static class MsgPack.AsyncReadResult : object {
    public static AsyncReadResult`1<T> Success(T returnValue);
    public static AsyncReadResult`1<T> Fail();
    internal static AsyncReadResult`1<Int32OffsetValue`1<T>> Success(T returnValue, int offset);
    internal static AsyncReadResult`1<Int64OffsetValue`1<T>> Success(T returnValue, long offset);
}
public class MsgPack.AsyncReadResult`1 : ValueType {
    private bool _success;
    private T _value;
    public bool Success { get; }
    public T Value { get; }
    internal AsyncReadResult`1(T value, bool success);
    public bool get_Success();
    public T get_Value();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(AsyncReadResult`1<T> other);
    public virtual int GetHashCode();
    public virtual string ToString();
    public static bool op_Equality(AsyncReadResult`1<T> left, AsyncReadResult`1<T> right);
    public static bool op_Inequality(AsyncReadResult`1<T> left, AsyncReadResult`1<T> right);
}
internal static class MsgPack.BigEndianBinary : object {
    public static sbyte ToSByte(Byte[] buffer, int offset);
    public static short ToInt16(Byte[] buffer, int offset);
    public static int ToInt32(Byte[] buffer, int offset);
    public static long ToInt64(Byte[] buffer, int offset);
    public static byte ToByte(Byte[] buffer, int offset);
    public static ushort ToUInt16(Byte[] buffer, int offset);
    public static UInt32 ToUInt32(Byte[] buffer, int offset);
    public static ulong ToUInt64(Byte[] buffer, int offset);
    public static float ToSingle(Byte[] buffer, int offset);
    public static double ToDouble(Byte[] buffer, int offset);
}
internal static class MsgPack.Binary : object {
    public static Byte[] Empty;
    private static Binary();
    public static string ToHexString(Byte[] blob);
    public static string ToHexString(Byte[] blob, bool withPrefix);
    public static void ToHexString(Byte[] blob, StringBuilder buffer);
    private static void ToHexStringCore(Byte[] blob, StringBuilder buffer, bool withPrefix);
    private static char ToHexChar(int b);
    public static int ToBits(float value);
    public static long ToBits(double value);
}
internal static class MsgPack.BufferManager : object {
    private static int MaxByteBufferSize;
    private static int MaxCharBufferSize;
    public static Byte[] NewByteBuffer(int size);
    public static Char[] NewCharBuffer(int size);
}
public abstract class MsgPack.ByteArrayPacker : Packer {
    public int BytesUsed { get; }
    public int InitialBufferOffset { get; }
    protected ByteArrayPacker(PackerCompatibilityOptions compatibilityOptions);
    public abstract virtual int get_BytesUsed();
    public abstract virtual int get_InitialBufferOffset();
    public ArraySegment`1<byte> GetResultBytes();
    public abstract virtual Byte[] GetFinalBuffer();
}
public abstract class MsgPack.ByteArrayUnpacker : Unpacker {
    public int Offset { get; }
    public abstract virtual int get_Offset();
}
internal abstract class MsgPack.ByteBufferAllocator : object {
    public abstract virtual bool TryAllocate(Byte[] oldBuffer, int requestSize, Byte[]& newBuffer);
}
internal class MsgPack.CollectionDebuggerProxy`1 : object {
    private ICollection`1<T> _collection;
    [DebuggerBrowsableAttribute("3")]
public T[] Items { get; }
    public CollectionDebuggerProxy`1(ICollection`1<T> target);
    public T[] get_Items();
}
internal static class MsgPack.CollectionOperation : object {
    public static void CopyTo(IEnumerable`1<T> source, int sourceCount, int index, T[] array, int arrayIndex, int count);
    public static void CopyTo(IEnumerable`1<TSource> source, int sourceCount, int index, TDestination[] array, int arrayIndex, int count, Func`2<TSource, TDestination> converter);
    private static void ValidateCopyToArguments(int sourceCount, int index, T[] array, int arrayIndex, int count);
    public static void CopyTo(IEnumerable`1<T> source, int sourceCount, Array array, int arrayIndex);
}
internal enum MsgPack.CollectionType : Enum {
    public int value__;
    public static CollectionType None;
    public static CollectionType Array;
    public static CollectionType Map;
}
internal class MsgPack.CollectionValidatingByteArrayUnpacker : MessagePackByteArrayUnpacker {
    private bool _isSubtreeReading;
    public CollectionValidatingByteArrayUnpacker(Byte[] source, int startOffset);
    internal virtual Unpacker InternalReadSubtree();
    protected virtual Unpacker ReadSubtreeCore();
    protected internal virtual void EndReadSubtree();
    internal virtual void EnsureNotInSubtreeMode();
    internal virtual void BeginSkipCore();
}
internal class MsgPack.CollectionValidatingStreamUnpacker : MessagePackStreamUnpacker {
    private bool _isSubtreeReading;
    public CollectionValidatingStreamUnpacker(Stream stream, PackerUnpackerStreamOptions streamOptions);
    internal virtual Unpacker InternalReadSubtree();
    protected virtual Unpacker ReadSubtreeCore();
    protected internal virtual void EndReadSubtree();
    internal virtual void EnsureNotInSubtreeMode();
    internal virtual void BeginSkipCore();
}
internal class MsgPack.DictionaryDebuggerProxy`2 : object {
    private IDictionary`2<TKey, TValue> _dictionary;
    [DebuggerBrowsableAttribute("3")]
public KeyValuePair`2[] Items { get; }
    public DictionaryDebuggerProxy`2(IDictionary`2<TKey, TValue> target);
    public KeyValuePair`2[] get_Items();
}
[ExtensionAttribute]
internal static class MsgPack.EncodingExtensions : object {
    [ExtensionAttribute]
public static bool EncodeString(Encoder source, Char[] chars, int charsOffset, int charsLength, Byte[] buffer, int bufferOffset, int bufferCount, Int32& charsUsed, Int32& bytesUsed);
    [ExtensionAttribute]
public static bool DecodeString(Decoder source, Byte[] bytes, int bytesOffset, int bytesLength, Char[] buffer, StringBuilder result);
}
internal class MsgPack.FastByteArrayUnpacker : MessagePackByteArrayUnpacker {
    public FastByteArrayUnpacker(Byte[] source, int startOffset);
    protected virtual Unpacker ReadSubtreeCore();
}
internal class MsgPack.FastStreamUnpacker : MessagePackStreamUnpacker {
    public FastStreamUnpacker(Stream stream, PackerUnpackerStreamOptions streamOptions);
    protected virtual Unpacker ReadSubtreeCore();
}
internal class MsgPack.FixedArrayBufferAllocator : ByteBufferAllocator {
    public static ByteBufferAllocator Instance;
    private static FixedArrayBufferAllocator();
    public virtual bool TryAllocate(Byte[] oldBuffer, int requestSize, Byte[]& newBuffer);
}
internal class MsgPack.Float32Bits : ValueType {
    public float Value;
    public byte Byte0;
    public byte Byte1;
    public byte Byte2;
    public byte Byte3;
    public Float32Bits(float value);
    public Float32Bits(Byte[] bigEndianBytes, int offset);
}
internal class MsgPack.Float64Bits : ValueType {
    public double Value;
    public byte Byte0;
    public byte Byte1;
    public byte Byte2;
    public byte Byte3;
    public byte Byte4;
    public byte Byte5;
    public byte Byte6;
    public byte Byte7;
    public Float64Bits(Byte[] bigEndianBytes, int offset);
}
internal class MsgPack.Int32OffsetValue`1 : ValueType {
    public int Offset;
    public T Result;
    public Int32OffsetValue`1(T result, int offset);
}
internal class MsgPack.Int64OffsetValue`1 : ValueType {
    public long Offset;
    public T Result;
    public Int64OffsetValue`1(T result, long offset);
}
public class MsgPack.InvalidMessagePackStreamException : Exception {
    public InvalidMessagePackStreamException(string message);
    public InvalidMessagePackStreamException(string message, Exception inner);
}
public interface MsgPack.IPackable {
    public abstract virtual void PackToMessage(Packer packer, PackingOptions options);
}
internal interface MsgPack.IRootUnpacker {
    public CollectionType CollectionType { get; }
    public Nullable`1<MessagePackObject> Data { get; public set; }
    public MessagePackObject LastReadData { get; public set; }
    public abstract virtual CollectionType get_CollectionType();
    public abstract virtual Nullable`1<MessagePackObject> get_Data();
    public abstract virtual void set_Data(Nullable`1<MessagePackObject> value);
    public abstract virtual MessagePackObject get_LastReadData();
    public abstract virtual void set_LastReadData(MessagePackObject value);
    public abstract virtual bool ReadObject(bool isDeep, MessagePackObject& result);
}
public interface MsgPack.IUnpackable {
    public abstract virtual void UnpackFromMessage(Unpacker unpacker);
}
public static class MsgPack.KnownExtTypeCode : object {
    public static byte Timestamp { get; }
    public static byte MultidimensionalArray { get; }
    public static byte get_Timestamp();
    public static byte get_MultidimensionalArray();
}
public static class MsgPack.KnownExtTypeName : object {
    public static string Timestamp { get; }
    public static string MultidimensionalArray { get; }
    public static string get_Timestamp();
    public static string get_MultidimensionalArray();
}
public class MsgPack.MessageNotSupportedException : Exception {
    public MessageNotSupportedException(string message);
    public MessageNotSupportedException(string message, Exception inner);
}
internal class MsgPack.MessagePackByteArrayPacker : ByteArrayPacker {
    private static int MaximumUtf8Length;
    private Byte[] _buffer;
    private int _offset;
    private int _initialOffset;
    private ByteBufferAllocator _allocator;
    public int BytesUsed { get; }
    public int InitialBufferOffset { get; }
    public MessagePackByteArrayPacker(Byte[] buffer, ByteBufferAllocator allocator, PackerCompatibilityOptions compatibilityOptions);
    public MessagePackByteArrayPacker(Byte[] buffer, int startOffset, ByteBufferAllocator allocator, PackerCompatibilityOptions compatibilityOptions);
    public virtual int get_BytesUsed();
    public virtual int get_InitialBufferOffset();
    public virtual Byte[] GetFinalBuffer();
    protected virtual void WriteBytes(ICollection`1<byte> value);
    protected virtual void WriteBytes(Byte[] value, bool isImmutable);
    protected virtual void WriteByte(byte value);
    private void WriteBytes(Byte[] value, int startIndex, int count);
    private void WriteBytes(Byte[] value);
    private void ThrowEofException(int requiredSize);
    private void ThrowEofExceptionForString(int requiredCharCount);
    protected virtual void PackCore(bool value);
    protected virtual void PackCore(byte value);
    protected virtual void PackCore(sbyte value);
    protected virtual void PackCore(short value);
    protected virtual void PackCore(ushort value);
    protected virtual void PackCore(int value);
    protected virtual void PackCore(UInt32 value);
    protected virtual void PackCore(long value);
    protected virtual void PackCore(ulong value);
    protected virtual void PackCore(float value);
    protected virtual void PackCore(double value);
    protected virtual void PackArrayHeaderCore(int length);
    protected virtual void PackMapHeaderCore(int length);
    protected virtual void PackStringHeaderCore(int length);
    protected virtual void PackBinaryHeaderCore(int length);
    protected virtual void PackRawCore(string value);
    protected virtual void PackRawCore(Byte[] value);
    protected virtual void PackBinaryCore(Byte[] value);
    protected virtual void PackExtendedTypeValueCore(byte typeCode, Byte[] body);
    private void WriteStringHeader(int bytesLength, bool allowStr8);
    private void WriteBytes(byte header, byte value);
    private void WriteBytes(byte header, ushort value);
    private void WriteBytes(byte header, UInt32 value);
    private void WriteBytes(byte header, ulong value);
    private void WriteBytes(byte header, float value);
    private void WriteBytes(byte header, double value);
    private void WriteBytes(string value, bool allowStr8);
}
internal abstract class MsgPack.MessagePackByteArrayUnpacker : ByteArrayUnpacker {
    private Byte[] _source;
    private int _offset;
    private Byte[] _scalarBuffer;
    private CollectionType _collectionType;
    private MessagePackObject _data;
    public int Offset { get; }
    public Nullable`1<MessagePackObject> Data { get; protected set; }
    public MessagePackObject LastReadData { get; protected set; }
    public bool IsArrayHeader { get; }
    public bool IsMapHeader { get; }
    public bool IsCollectionHeader { get; }
    public long ItemsCount { get; }
    private CollectionType MsgPack.IRootUnpacker.CollectionType { get; }
    private Nullable`1<MessagePackObject> MsgPack.IRootUnpacker.Data { get; private set; }
    private MessagePackObject MsgPack.IRootUnpacker.LastReadData { get; private set; }
    public MessagePackByteArrayUnpacker(Byte[] source, int startOffset);
    public sealed virtual int get_Offset();
    public sealed virtual Nullable`1<MessagePackObject> get_Data();
    protected sealed virtual void set_Data(Nullable`1<MessagePackObject> value);
    public sealed virtual MessagePackObject get_LastReadData();
    protected sealed virtual void set_LastReadData(MessagePackObject value);
    public sealed virtual bool get_IsArrayHeader();
    public sealed virtual bool get_IsMapHeader();
    public sealed virtual bool get_IsCollectionHeader();
    public sealed virtual long get_ItemsCount();
    private sealed virtual override CollectionType MsgPack.IRootUnpacker.get_CollectionType();
    private sealed virtual override Nullable`1<MessagePackObject> MsgPack.IRootUnpacker.get_Data();
    private sealed virtual override void MsgPack.IRootUnpacker.set_Data(Nullable`1<MessagePackObject> value);
    private sealed virtual override MessagePackObject MsgPack.IRootUnpacker.get_LastReadData();
    private sealed virtual override void MsgPack.IRootUnpacker.set_LastReadData(MessagePackObject value);
    internal virtual bool GetPreviousPosition(Int64& offsetOrPosition);
    private bool ReadBinaryCore(int length, Int32& offset, Byte[]& result);
    private bool ReadStringCore(int length, Int32& offset, String& result);
    private bool ReadRawStringCore(int length, Int32& offset, MessagePackString& result);
    private bool Drain(UInt32 size);
    private sealed virtual override bool MsgPack.IRootUnpacker.ReadObject(bool isDeep, MessagePackObject& result);
    public sealed virtual bool ReadByte(Byte& result);
    private bool ReadByteSlow(ReadValueResult header, Byte[] source, Int32& offset, Byte& result);
    public sealed virtual bool ReadNullableByte(Nullable`1& result);
    private bool ReadNullableByteSlow(ReadValueResult header, Byte[] source, Int32& offset, Nullable`1& result);
    public sealed virtual bool ReadSByte(SByte& result);
    private bool ReadSByteSlow(ReadValueResult header, Byte[] source, Int32& offset, SByte& result);
    public sealed virtual bool ReadNullableSByte(Nullable`1& result);
    private bool ReadNullableSByteSlow(ReadValueResult header, Byte[] source, Int32& offset, Nullable`1& result);
    public sealed virtual bool ReadInt16(Int16& result);
    private bool ReadInt16Slow(ReadValueResult header, Byte[] source, Int32& offset, Int16& result);
    public sealed virtual bool ReadNullableInt16(Nullable`1& result);
    private bool ReadNullableInt16Slow(ReadValueResult header, Byte[] source, Int32& offset, Nullable`1& result);
    public sealed virtual bool ReadUInt16(UInt16& result);
    private bool ReadUInt16Slow(ReadValueResult header, Byte[] source, Int32& offset, UInt16& result);
    public sealed virtual bool ReadNullableUInt16(Nullable`1& result);
    private bool ReadNullableUInt16Slow(ReadValueResult header, Byte[] source, Int32& offset, Nullable`1& result);
    public sealed virtual bool ReadInt32(Int32& result);
    private bool ReadInt32Slow(ReadValueResult header, Byte[] source, Int32& offset, Int32& result);
    public sealed virtual bool ReadNullableInt32(Nullable`1& result);
    private bool ReadNullableInt32Slow(ReadValueResult header, Byte[] source, Int32& offset, Nullable`1& result);
    public sealed virtual bool ReadUInt32(UInt32& result);
    private bool ReadUInt32Slow(ReadValueResult header, Byte[] source, Int32& offset, UInt32& result);
    public sealed virtual bool ReadNullableUInt32(Nullable`1& result);
    private bool ReadNullableUInt32Slow(ReadValueResult header, Byte[] source, Int32& offset, Nullable`1& result);
    public sealed virtual bool ReadInt64(Int64& result);
    private bool ReadInt64Slow(ReadValueResult header, Byte[] source, Int32& offset, Int64& result);
    public sealed virtual bool ReadNullableInt64(Nullable`1& result);
    private bool ReadNullableInt64Slow(ReadValueResult header, Byte[] source, Int32& offset, Nullable`1& result);
    public sealed virtual bool ReadUInt64(UInt64& result);
    private bool ReadUInt64Slow(ReadValueResult header, Byte[] source, Int32& offset, UInt64& result);
    public sealed virtual bool ReadNullableUInt64(Nullable`1& result);
    private bool ReadNullableUInt64Slow(ReadValueResult header, Byte[] source, Int32& offset, Nullable`1& result);
    public sealed virtual bool ReadSingle(Single& result);
    private bool ReadSingleSlow(ReadValueResult header, Byte[] source, Int32& offset, Single& result);
    public sealed virtual bool ReadNullableSingle(Nullable`1& result);
    private bool ReadNullableSingleSlow(ReadValueResult header, Byte[] source, Int32& offset, Nullable`1& result);
    public sealed virtual bool ReadDouble(Double& result);
    private bool ReadDoubleSlow(ReadValueResult header, Byte[] source, Int32& offset, Double& result);
    public sealed virtual bool ReadNullableDouble(Nullable`1& result);
    private bool ReadNullableDoubleSlow(ReadValueResult header, Byte[] source, Int32& offset, Nullable`1& result);
    public sealed virtual bool ReadBoolean(Boolean& result);
    public sealed virtual bool ReadNullableBoolean(Nullable`1& result);
    public sealed virtual bool ReadBinary(Byte[]& result);
    public sealed virtual bool ReadString(String& result);
    private bool ReadObject(bool isDeep, MessagePackObject& result);
    private bool ReadObjectCore(bool isDeep, Byte[] source, Int32& offset, MessagePackObject& result);
    private bool ReadObjectSlow(ReadValueResult header, Byte[] source, Int32& offset, MessagePackObject& result);
    private bool ReadItems(int count, bool isMap, Byte[] source, Int32& offset, MessagePackObject& result);
    public sealed virtual bool ReadArrayLength(Int64& result);
    public sealed virtual bool ReadMapLength(Int64& result);
    public sealed virtual bool ReadMessagePackExtendedTypeObject(MessagePackExtendedTypeObject& result);
    private bool ReadMessagePackExtendedTypeObjectCore(int length, Byte[] source, Int32& offset, MessagePackExtendedTypeObject& result);
    public sealed virtual bool ReadNullableMessagePackExtendedTypeObject(Nullable`1& result);
    protected sealed virtual Nullable`1<long> SkipCore();
    public sealed virtual bool ReadObject(MessagePackObject& result);
    protected sealed virtual bool ReadCore();
    private void ThrowUnassignedMessageTypeException(int header);
    private void CheckLength(UInt32 length, ReadValueResult type);
    private void ThrowTooLongLengthException(UInt32 length, ReadValueResult type);
    private void ThrowTypeException(string type, ReadValueResult header);
    private void ThrowTypeException(Type type, ReadValueResult header);
}
internal static class MsgPack.MessagePackCode : object {
    public static int NilValue;
    public static int TrueValue;
    public static int FalseValue;
    public static int SignedInt8;
    public static int UnsignedInt8;
    public static int SignedInt16;
    public static int UnsignedInt16;
    public static int SignedInt32;
    public static int UnsignedInt32;
    public static int SignedInt64;
    public static int UnsignedInt64;
    public static int Real32;
    public static int Real64;
    public static int MinimumFixedArray;
    public static int MaximumFixedArray;
    public static int Array16;
    public static int Array32;
    public static int MinimumFixedMap;
    public static int MaximumFixedMap;
    public static int Map16;
    public static int Map32;
    public static int MinimumFixedRaw;
    public static int MaximumFixedRaw;
    public static int Str8;
    public static int Raw16;
    public static int Raw32;
    public static int Str16;
    public static int Str32;
    public static int Bin8;
    public static int Bin16;
    public static int Bin32;
    public static int Ext8;
    public static int Ext16;
    public static int Ext32;
    public static int FixExt1;
    public static int FixExt2;
    public static int FixExt4;
    public static int FixExt8;
    public static int FixExt16;
    public static string ToString(int code);
}
public static class MsgPack.MessagePackConvert : object {
    private static Encoding _utf8NonBomStrict;
    private static Encoding _utf8NonBom;
    private static long _ticksToMilliseconds;
    private static DateTime _unixEpocUtc;
    internal static Encoding Utf8NonBom { get; }
    internal static Encoding Utf8NonBomStrict { get; }
    private static MessagePackConvert();
    internal static Encoding get_Utf8NonBom();
    internal static Encoding get_Utf8NonBomStrict();
    public static Byte[] EncodeString(string value);
    public static string DecodeStringStrict(Byte[] value);
    public static DateTimeOffset ToDateTimeOffset(long value);
    public static DateTime ToDateTime(long value);
    public static long FromDateTimeOffset(DateTimeOffset value);
    public static long FromDateTime(DateTime value);
}
public class MsgPack.MessagePackExtendedTypeObject : ValueType {
    private byte _typeCode;
    private Byte[] _body;
    public byte TypeCode { get; }
    internal Byte[] Body { get; }
    public bool IsValid { get; }
    private MessagePackExtendedTypeObject(Byte[] body, byte unpackedTypeCode);
    public MessagePackExtendedTypeObject(byte typeCode, Byte[] body);
    public byte get_TypeCode();
    internal Byte[] get_Body();
    public Byte[] GetBody();
    public bool get_IsValid();
    public static MessagePackExtendedTypeObject Unpack(byte typeCode, Byte[] body);
    public virtual string ToString();
    internal void ToString(StringBuilder buffer, bool isJson);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(MessagePackExtendedTypeObject other);
    public static bool op_Equality(MessagePackExtendedTypeObject left, MessagePackExtendedTypeObject right);
    public static bool op_Inequality(MessagePackExtendedTypeObject left, MessagePackExtendedTypeObject right);
}
public class MsgPack.MessagePackObject : ValueType {
    private static ValueTypeCode _sbyteTypeCode;
    private static ValueTypeCode _byteTypeCode;
    private static ValueTypeCode _int16TypeCode;
    private static ValueTypeCode _uint16TypeCode;
    private static ValueTypeCode _int32TypeCode;
    private static ValueTypeCode _uint32TypeCode;
    private static ValueTypeCode _int64TypeCode;
    private static ValueTypeCode _uint64TypeCode;
    private static ValueTypeCode _singleTypeCode;
    private static ValueTypeCode _doubleTypeCode;
    private static ValueTypeCode _booleanTypeCode;
    public static MessagePackObject Nil;
    private object _handleOrTypeCode;
    private ulong _value;
    public bool IsNil { get; }
    public bool IsRaw { get; }
    public bool IsList { get; }
    public bool IsArray { get; }
    public bool IsDictionary { get; }
    public bool IsMap { get; }
    public Type UnderlyingType { get; }
    public MessagePackObject(bool value);
    public MessagePackObject(byte value);
    [CLSCompliantAttribute("False")]
public MessagePackObject(sbyte value);
    public MessagePackObject(short value);
    [CLSCompliantAttribute("False")]
public MessagePackObject(ushort value);
    public MessagePackObject(int value);
    [CLSCompliantAttribute("False")]
public MessagePackObject(UInt32 value);
    public MessagePackObject(long value);
    [CLSCompliantAttribute("False")]
public MessagePackObject(ulong value);
    public MessagePackObject(float value);
    public MessagePackObject(double value);
    public MessagePackObject(string value);
    public MessagePackObject(Byte[] value);
    public MessagePackObject(Byte[] value, bool isBinary);
    public MessagePackObject(MessagePackExtendedTypeObject value);
    public MessagePackObject(IList`1<MessagePackObject> value);
    public MessagePackObject(IList`1<MessagePackObject> value, bool isImmutable);
    public MessagePackObject(MessagePackObjectDictionary value);
    public MessagePackObject(MessagePackObjectDictionary value, bool isImmutable);
    internal MessagePackObject(MessagePackString messagePackString);
    private static MessagePackObject();
    public bool AsBoolean();
    public byte AsByte();
    [CLSCompliantAttribute("False")]
public sbyte AsSByte();
    public short AsInt16();
    [CLSCompliantAttribute("False")]
public ushort AsUInt16();
    public int AsInt32();
    [CLSCompliantAttribute("False")]
public UInt32 AsUInt32();
    public long AsInt64();
    [CLSCompliantAttribute("False")]
public ulong AsUInt64();
    public float AsSingle();
    public double AsDouble();
    public string AsString();
    public Byte[] AsBinary();
    public MessagePackExtendedTypeObject AsMessagePackExtendedTypeObject();
    public static MessagePackObject op_Implicit(bool value);
    public static MessagePackObject op_Implicit(byte value);
    [CLSCompliantAttribute("False")]
public static MessagePackObject op_Implicit(sbyte value);
    public static MessagePackObject op_Implicit(short value);
    [CLSCompliantAttribute("False")]
public static MessagePackObject op_Implicit(ushort value);
    public static MessagePackObject op_Implicit(int value);
    [CLSCompliantAttribute("False")]
public static MessagePackObject op_Implicit(UInt32 value);
    public static MessagePackObject op_Implicit(long value);
    [CLSCompliantAttribute("False")]
public static MessagePackObject op_Implicit(ulong value);
    public static MessagePackObject op_Implicit(float value);
    public static MessagePackObject op_Implicit(double value);
    public static MessagePackObject op_Implicit(string value);
    public static MessagePackObject op_Implicit(Byte[] value);
    public static MessagePackObject op_Implicit(MessagePackExtendedTypeObject value);
    public static bool op_Explicit(MessagePackObject value);
    public static byte op_Explicit(MessagePackObject value);
    [CLSCompliantAttribute("False")]
public static sbyte op_Explicit(MessagePackObject value);
    public static short op_Explicit(MessagePackObject value);
    [CLSCompliantAttribute("False")]
public static ushort op_Explicit(MessagePackObject value);
    public static int op_Explicit(MessagePackObject value);
    [CLSCompliantAttribute("False")]
public static UInt32 op_Explicit(MessagePackObject value);
    public static long op_Explicit(MessagePackObject value);
    [CLSCompliantAttribute("False")]
public static ulong op_Explicit(MessagePackObject value);
    public static float op_Explicit(MessagePackObject value);
    public static double op_Explicit(MessagePackObject value);
    public static string op_Explicit(MessagePackObject value);
    public static Byte[] op_Explicit(MessagePackObject value);
    public static MessagePackExtendedTypeObject op_Explicit(MessagePackObject value);
    public bool get_IsNil();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(MessagePackObject other);
    private bool EqualsWhenValueType(MessagePackObject other, ValueTypeCode valueTypeCode, ValueTypeCode otherValuetypeCode);
    private static bool IntegerIntegerEquals(ulong left, ValueTypeCode leftTypeCode, ulong right, ValueTypeCode rightTypeCode);
    private static bool IntegerSingleEquals(MessagePackObject integer, MessagePackObject real);
    private static bool IntegerDoubleEquals(MessagePackObject integer, MessagePackObject real);
    public virtual int GetHashCode();
    public virtual string ToString();
    private void ToString(StringBuilder buffer, bool isJson);
    private static void ToStringBinary(StringBuilder buffer, bool isJson, MessagePackString asBinary);
    public Nullable`1<bool> IsTypeOf();
    public Nullable`1<bool> IsTypeOf(Type type);
    public bool get_IsRaw();
    public bool get_IsList();
    public bool get_IsArray();
    public bool get_IsDictionary();
    public bool get_IsMap();
    public Type get_UnderlyingType();
    public sealed virtual void PackToMessage(Packer packer, PackingOptions options);
    public string AsString(Encoding encoding);
    public string AsStringUtf8();
    public string AsStringUtf16();
    public Char[] AsCharArray();
    public IEnumerable`1<MessagePackObject> AsEnumerable();
    public IList`1<MessagePackObject> AsList();
    public MessagePackObjectDictionary AsDictionary();
    private static void VerifyUnderlyingType(MessagePackObject instance, string parameterName);
    private static void VerifyUnderlyingRawType(MessagePackObject instance, string parameterName);
    private static void ThrowCannotBeNilAs();
    private static void ThrowInvalidTypeAs(MessagePackObject instance);
    public static MessagePackObject FromObject(object boxedValue);
    public object ToObject();
    public Timestamp AsTimestamp();
    public static bool op_Equality(MessagePackObject left, MessagePackObject right);
    public static bool op_Inequality(MessagePackObject left, MessagePackObject right);
    public static MessagePackObject op_Implicit(MessagePackObject[] value);
}
[DefaultMemberAttribute("Item")]
[DebuggerTypeProxyAttribute("MsgPack.DictionaryDebuggerProxy`2")]
public class MsgPack.MessagePackObjectDictionary : object {
    private static int Threashold;
    private static int ListInitialCapacity;
    private static int DictionaryInitialCapacity;
    private List`1<MessagePackObject> _keys;
    private List`1<MessagePackObject> _values;
    private Dictionary`2<MessagePackObject, MessagePackObject> _dictionary;
    private int _version;
    private bool _isFrozen;
    public bool IsFrozen { get; }
    public int Count { get; }
    public MessagePackObject Item { get; public set; }
    public KeySet Keys { get; }
    public ValueCollection Values { get; }
    private ICollection`1<MessagePackObject> System.Collections.Generic.IDictionary<MsgPack.MessagePackObject,MsgPack.MessagePackObject>.Keys { get; }
    private ICollection`1<MessagePackObject> System.Collections.Generic.IDictionary<MsgPack.MessagePackObject,MsgPack.MessagePackObject>.Values { get; }
    private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<MsgPack.MessagePackObject,MsgPack.MessagePackObject>>.IsReadOnly { get; }
    private bool System.Collections.IDictionary.IsFixedSize { get; }
    private bool System.Collections.IDictionary.IsReadOnly { get; }
    private ICollection System.Collections.IDictionary.Keys { get; }
    private ICollection System.Collections.IDictionary.Values { get; }
    private object System.Collections.IDictionary.Item { get; private set; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public MessagePackObjectDictionary(int initialCapacity);
    public MessagePackObjectDictionary(IDictionary`2<MessagePackObject, MessagePackObject> dictionary);
    public bool get_IsFrozen();
    public sealed virtual int get_Count();
    public sealed virtual MessagePackObject get_Item(MessagePackObject key);
    public sealed virtual void set_Item(MessagePackObject key, MessagePackObject value);
    public KeySet get_Keys();
    public ValueCollection get_Values();
    private sealed virtual override ICollection`1<MessagePackObject> System.Collections.Generic.IDictionary<MsgPack.MessagePackObject,MsgPack.MessagePackObject>.get_Keys();
    private sealed virtual override ICollection`1<MessagePackObject> System.Collections.Generic.IDictionary<MsgPack.MessagePackObject,MsgPack.MessagePackObject>.get_Values();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<MsgPack.MessagePackObject,MsgPack.MessagePackObject>>.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IDictionary.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IDictionary.get_IsReadOnly();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Keys();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Values();
    private sealed virtual override object System.Collections.IDictionary.get_Item(object key);
    private sealed virtual override void System.Collections.IDictionary.set_Item(object key, object value);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private static void ThrowKeyNotNilException(string parameterName);
    private static void ThrowDuplicatedKeyException(MessagePackObject key, string parameterName);
    private void VerifyIsNotFrozen();
    [ConditionalAttribute("DEBUG")]
private void AssertInvariant();
    private static MessagePackObject ValidateObjectArgument(object obj, string parameterName);
    private static Nullable`1<MessagePackObject> TryValidateObjectArgument(object value);
    public sealed virtual bool ContainsKey(MessagePackObject key);
    public bool ContainsValue(MessagePackObject value);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<MsgPack.MessagePackObject,MsgPack.MessagePackObject>>.Contains(KeyValuePair`2<MessagePackObject, MessagePackObject> item);
    private sealed virtual override bool System.Collections.IDictionary.Contains(object key);
    public sealed virtual bool TryGetValue(MessagePackObject key, MessagePackObject& value);
    public sealed virtual void Add(MessagePackObject key, MessagePackObject value);
    private void AddCore(MessagePackObject key, MessagePackObject value, bool allowOverwrite);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<MsgPack.MessagePackObject,MsgPack.MessagePackObject>>.Add(KeyValuePair`2<MessagePackObject, MessagePackObject> item);
    private sealed virtual override void System.Collections.IDictionary.Add(object key, object value);
    public sealed virtual bool Remove(MessagePackObject key);
    private bool RemoveCore(MessagePackObject key, MessagePackObject value, bool checkValue);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<MsgPack.MessagePackObject,MsgPack.MessagePackObject>>.Remove(KeyValuePair`2<MessagePackObject, MessagePackObject> item);
    private sealed virtual override void System.Collections.IDictionary.Remove(object key);
    public sealed virtual void Clear();
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<MsgPack.MessagePackObject,MsgPack.MessagePackObject>>.CopyTo(KeyValuePair`2[] array, int arrayIndex);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public Enumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<KeyValuePair`2<MessagePackObject, MessagePackObject>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<MsgPack.MessagePackObject,MsgPack.MessagePackObject>>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator();
    public MessagePackObjectDictionary Freeze();
    public MessagePackObjectDictionary AsFrozen();
}
internal class MsgPack.MessagePackObjectEqualityComparer : object {
    private static MessagePackObjectEqualityComparer _instance;
    internal static MessagePackObjectEqualityComparer Instance { get; }
    private static MessagePackObjectEqualityComparer();
    internal static MessagePackObjectEqualityComparer get_Instance();
    public sealed virtual bool Equals(MessagePackObject x, MessagePackObject y);
    public sealed virtual int GetHashCode(MessagePackObject obj);
}
internal class MsgPack.MessagePackStreamPacker : Packer {
    private Stream _destination;
    private Byte[] _scalarBuffer;
    private bool _ownsStream;
    public MessagePackStreamPacker(Stream stream, PackerUnpackerStreamOptions streamOptions, PackerCompatibilityOptions compatibilityOptions);
    protected virtual void Dispose(bool disposing);
    public virtual void Flush();
    protected virtual void WriteByte(byte value);
    protected virtual void WriteBytes(Byte[] value, bool isImmutable);
    protected virtual void WriteBytes(ICollection`1<byte> value);
    private void WriteBytes(Byte[] value);
    private void WriteBytes(Byte[] value, int startIndex, int count);
    protected virtual void PackCore(bool value);
    protected virtual void PackCore(byte value);
    protected virtual void PackCore(sbyte value);
    protected virtual void PackCore(short value);
    protected virtual void PackCore(ushort value);
    protected virtual void PackCore(int value);
    protected virtual void PackCore(UInt32 value);
    protected virtual void PackCore(long value);
    protected virtual void PackCore(ulong value);
    protected virtual void PackCore(float value);
    protected virtual void PackCore(double value);
    protected virtual void PackArrayHeaderCore(int length);
    protected virtual void PackMapHeaderCore(int length);
    protected virtual void PackStringHeaderCore(int length);
    protected virtual void PackBinaryHeaderCore(int length);
    protected virtual void PackRawCore(string value);
    protected virtual void PackRawCore(Byte[] value);
    protected virtual void PackBinaryCore(Byte[] value);
    protected virtual void PackExtendedTypeValueCore(byte typeCode, Byte[] body);
    private void WriteStringHeader(int bytesLength, bool allowStr8);
    private void WriteBytes(byte header, byte value);
    private void WriteBytes(byte header, ushort value);
    private void WriteBytes(byte header, UInt32 value);
    private void WriteBytes(byte header, ulong value);
    private void WriteBytes(byte header, float value);
    private void WriteBytes(byte header, double value);
    private void WriteBytes(string value, bool allowStr8);
    private void WriteStringBody(string value);
    private void WriteStringBody(Char[] value, int remainingCharsLength);
    private static bool EncodeString(Encoder encoder, Char[] value, int startOffset, int count, Byte[] buffer, Int32& charsUsed, Int32& bytesUsed);
}
internal abstract class MsgPack.MessagePackStreamUnpacker : Unpacker {
    private Byte[] _oneByteBuffer;
    private Byte[] _scalarBuffer;
    private Stream _source;
    private bool _useStreamPosition;
    private bool _ownsStream;
    private CollectionType _collectionType;
    private MessagePackObject _data;
    private int _subtreeCount;
    private long _offset;
    private long _lastOffset;
    public Nullable`1<MessagePackObject> Data { get; protected set; }
    public MessagePackObject LastReadData { get; protected set; }
    public bool IsArrayHeader { get; }
    public bool IsMapHeader { get; }
    public long ItemsCount { get; }
    public bool IsCollectionHeader { get; }
    private CollectionType MsgPack.IRootUnpacker.CollectionType { get; }
    private Nullable`1<MessagePackObject> MsgPack.IRootUnpacker.Data { get; private set; }
    private MessagePackObject MsgPack.IRootUnpacker.LastReadData { get; private set; }
    public MessagePackStreamUnpacker(Stream stream, PackerUnpackerStreamOptions streamOptions);
    public sealed virtual Nullable`1<MessagePackObject> get_Data();
    protected sealed virtual void set_Data(Nullable`1<MessagePackObject> value);
    public sealed virtual MessagePackObject get_LastReadData();
    protected sealed virtual void set_LastReadData(MessagePackObject value);
    public sealed virtual bool get_IsArrayHeader();
    public sealed virtual bool get_IsMapHeader();
    public sealed virtual long get_ItemsCount();
    public sealed virtual bool get_IsCollectionHeader();
    private sealed virtual override CollectionType MsgPack.IRootUnpacker.get_CollectionType();
    private sealed virtual override Nullable`1<MessagePackObject> MsgPack.IRootUnpacker.get_Data();
    private sealed virtual override void MsgPack.IRootUnpacker.set_Data(Nullable`1<MessagePackObject> value);
    private sealed virtual override MessagePackObject MsgPack.IRootUnpacker.get_LastReadData();
    private sealed virtual override void MsgPack.IRootUnpacker.set_LastReadData(MessagePackObject value);
    internal virtual bool GetPreviousPosition(Int64& offsetOrPosition);
    protected virtual void Dispose(bool disposing);
    protected void BeginReadSubtree();
    protected internal virtual void EndReadSubtree();
    private bool ReadBinaryCore(int length, Int64& offset, Byte[]& result);
    private bool ReadStringCore(int length, Int64& offset, String& result);
    private bool ReadRawStringCore(int length, Int64& offset, MessagePackString& result);
    private bool Drain(UInt32 size);
    private sealed virtual override bool MsgPack.IRootUnpacker.ReadObject(bool isDeep, MessagePackObject& result);
    private void ThrowEofException(long reading);
    public sealed virtual bool ReadByte(Byte& result);
    private bool ReadByteSlow(ReadValueResult header, Byte[] buffer, Int64& offset, Byte& result);
    public sealed virtual bool ReadNullableByte(Nullable`1& result);
    private bool ReadNullableByteSlow(ReadValueResult header, Byte[] buffer, Int64& offset, Nullable`1& result);
    public sealed virtual bool ReadSByte(SByte& result);
    private bool ReadSByteSlow(ReadValueResult header, Byte[] buffer, Int64& offset, SByte& result);
    public sealed virtual bool ReadNullableSByte(Nullable`1& result);
    private bool ReadNullableSByteSlow(ReadValueResult header, Byte[] buffer, Int64& offset, Nullable`1& result);
    public sealed virtual bool ReadInt16(Int16& result);
    private bool ReadInt16Slow(ReadValueResult header, Byte[] buffer, Int64& offset, Int16& result);
    public sealed virtual bool ReadNullableInt16(Nullable`1& result);
    private bool ReadNullableInt16Slow(ReadValueResult header, Byte[] buffer, Int64& offset, Nullable`1& result);
    public sealed virtual bool ReadUInt16(UInt16& result);
    private bool ReadUInt16Slow(ReadValueResult header, Byte[] buffer, Int64& offset, UInt16& result);
    public sealed virtual bool ReadNullableUInt16(Nullable`1& result);
    private bool ReadNullableUInt16Slow(ReadValueResult header, Byte[] buffer, Int64& offset, Nullable`1& result);
    public sealed virtual bool ReadInt32(Int32& result);
    private bool ReadInt32Slow(ReadValueResult header, Byte[] buffer, Int64& offset, Int32& result);
    public sealed virtual bool ReadNullableInt32(Nullable`1& result);
    private bool ReadNullableInt32Slow(ReadValueResult header, Byte[] buffer, Int64& offset, Nullable`1& result);
    public sealed virtual bool ReadUInt32(UInt32& result);
    private bool ReadUInt32Slow(ReadValueResult header, Byte[] buffer, Int64& offset, UInt32& result);
    public sealed virtual bool ReadNullableUInt32(Nullable`1& result);
    private bool ReadNullableUInt32Slow(ReadValueResult header, Byte[] buffer, Int64& offset, Nullable`1& result);
    public sealed virtual bool ReadInt64(Int64& result);
    private bool ReadInt64Slow(ReadValueResult header, Byte[] buffer, Int64& offset, Int64& result);
    public sealed virtual bool ReadNullableInt64(Nullable`1& result);
    private bool ReadNullableInt64Slow(ReadValueResult header, Byte[] buffer, Int64& offset, Nullable`1& result);
    public sealed virtual bool ReadUInt64(UInt64& result);
    private bool ReadUInt64Slow(ReadValueResult header, Byte[] buffer, Int64& offset, UInt64& result);
    public sealed virtual bool ReadNullableUInt64(Nullable`1& result);
    private bool ReadNullableUInt64Slow(ReadValueResult header, Byte[] buffer, Int64& offset, Nullable`1& result);
    public sealed virtual bool ReadSingle(Single& result);
    private bool ReadSingleSlow(ReadValueResult header, Byte[] buffer, Int64& offset, Single& result);
    public sealed virtual bool ReadNullableSingle(Nullable`1& result);
    private bool ReadNullableSingleSlow(ReadValueResult header, Byte[] buffer, Int64& offset, Nullable`1& result);
    public sealed virtual bool ReadDouble(Double& result);
    private bool ReadDoubleSlow(ReadValueResult header, Byte[] buffer, Int64& offset, Double& result);
    public sealed virtual bool ReadNullableDouble(Nullable`1& result);
    private bool ReadNullableDoubleSlow(ReadValueResult header, Byte[] buffer, Int64& offset, Nullable`1& result);
    public sealed virtual bool ReadBoolean(Boolean& result);
    public sealed virtual bool ReadNullableBoolean(Nullable`1& result);
    public sealed virtual bool ReadBinary(Byte[]& result);
    public sealed virtual bool ReadString(String& result);
    private bool ReadObject(bool isDeep, MessagePackObject& result);
    private bool ReadObjectCore(bool isDeep, Byte[] buffer, Int64& offset, MessagePackObject& result);
    private bool ReadObjectSlow(ReadValueResult header, Byte[] buffer, Int64& offset, MessagePackObject& result);
    private bool ReadItems(int count, bool isMap, Byte[] buffer, Int64& offset, MessagePackObject& result);
    public sealed virtual bool ReadArrayLength(Int64& result);
    public sealed virtual bool ReadMapLength(Int64& result);
    public sealed virtual bool ReadMessagePackExtendedTypeObject(MessagePackExtendedTypeObject& result);
    private bool ReadMessagePackExtendedTypeObjectCore(int length, Byte[] buffer, Int64& offset, MessagePackExtendedTypeObject& result);
    public sealed virtual bool ReadNullableMessagePackExtendedTypeObject(Nullable`1& result);
    protected sealed virtual Nullable`1<long> SkipCore();
    public sealed virtual bool ReadObject(MessagePackObject& result);
    protected sealed virtual bool ReadCore();
    private void ThrowUnassignedMessageTypeException(int header);
    private void CheckLength(UInt32 length, ReadValueResult type);
    private void ThrowTooLongLengthException(UInt32 length, ReadValueResult type);
    private void ThrowTypeException(string type, ReadValueResult header);
    private void ThrowTypeException(Type type, ReadValueResult header);
}
[SecuritySafeCriticalAttribute]
[DebuggerDisplayAttribute("{DebuggerDisplayString}")]
[DebuggerTypeProxyAttribute("MsgPack.MessagePackString/MessagePackStringDebuggerProxy")]
internal class MsgPack.MessagePackString : object {
    private static DecoderFallbackException IsBinary;
    private Byte[] _encoded;
    private string _decoded;
    private DecoderFallbackException _decodingError;
    private BinaryType _type;
    private string DebuggerDisplayString { get; }
    public MessagePackString(string decoded);
    public MessagePackString(Byte[] encoded, bool isBinary);
    private MessagePackString(MessagePackString other);
    private static MessagePackString();
    private string get_DebuggerDisplayString();
    private void EncodeIfNeeded();
    private void DecodeIfNeeded();
    public string TryGetString();
    public string GetString();
    public Byte[] UnsafeGetBuffer();
    public string UnsafeGetString();
    public Byte[] GetBytes();
    public Type GetUnderlyingType();
    public virtual string ToString();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    private static bool EqualsEncoded(MessagePackString left, MessagePackString right);
    private static bool SlowEquals(Byte[] x, Byte[] y);
}
public class MsgPack.MessageTypeException : Exception {
    public MessageTypeException(string message);
    public MessageTypeException(string message, Exception inner);
}
public abstract class MsgPack.Packer : object {
    private static Int32 modreq(System.Runtime.CompilerServices.IsVolatile) _defaultCompatibilityOptions;
    private bool _isDisposed;
    private PackerCompatibilityOptions _compatibilityOptions;
    public static PackerCompatibilityOptions DefaultCompatibilityOptions { get; public set; }
    public bool CanSeek { get; }
    public long Position { get; }
    public PackerCompatibilityOptions CompatibilityOptions { get; }
    protected Packer(PackerCompatibilityOptions compatibilityOptions);
    private static Packer();
    public static PackerCompatibilityOptions get_DefaultCompatibilityOptions();
    public static void set_DefaultCompatibilityOptions(PackerCompatibilityOptions value);
    public virtual bool get_CanSeek();
    public virtual long get_Position();
    public PackerCompatibilityOptions get_CompatibilityOptions();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    private void VerifyNotDisposed();
    private void ThrowObjectDisposedException();
    public virtual void Flush();
    protected virtual void SeekTo(long offset);
    protected abstract virtual void WriteByte(byte value);
    protected virtual void WriteBytes(ICollection`1<byte> value);
    protected virtual void WriteBytes(Byte[] value, bool isImmutable);
    [CLSCompliantAttribute("False")]
public Packer Pack(sbyte value);
    [CLSCompliantAttribute("False")]
protected virtual void PackCore(sbyte value);
    protected bool TryPackInt8(long value);
    public Packer Pack(byte value);
    protected virtual void PackCore(byte value);
    [CLSCompliantAttribute("False")]
protected bool TryPackUInt8(ulong value);
    public Packer Pack(bool value);
    protected virtual void PackCore(bool value);
    protected bool TryPackTinySignedInteger(long value);
    [CLSCompliantAttribute("False")]
protected bool TryPackTinyUnsignedInteger(ulong value);
    public Packer PackNull();
    private void PrivatePackNullCore();
    private static void ThrowArgumentNullException(string parameterName);
    private static void ThrowCannotBeNegativeException(string parameterName);
    private static void ThrowMissingBodyOfExtTypeValueException(string parameterName);
    private static void ThrowExtTypeIsProhibitedException();
    public static Packer Create(Stream stream);
    public static Packer Create(Stream stream, PackerCompatibilityOptions compatibilityOptions);
    public static Packer Create(Stream stream, bool ownsStream);
    public static Packer Create(Stream stream, PackerCompatibilityOptions compatibilityOptions, bool ownsStream);
    public static Packer Create(Stream stream, PackerCompatibilityOptions compatibilityOptions, PackerUnpackerStreamOptions streamOptions);
    public static ByteArrayPacker Create(Byte[] buffer);
    public static ByteArrayPacker Create(Byte[] buffer, int startOffset);
    public static ByteArrayPacker Create(Byte[] buffer, bool allowsBufferExpansion, PackerCompatibilityOptions compatibilityOptions);
    public static ByteArrayPacker Create(Byte[] buffer, int startOffset, bool allowsBufferExpansion, PackerCompatibilityOptions compatibilityOptions);
    public static ByteArrayPacker Create(Byte[] buffer, Func`3<Byte[], int, Byte[]> allocator, PackerCompatibilityOptions compatibilityOptions);
    public static ByteArrayPacker Create(Byte[] buffer, int startOffset, Func`3<Byte[], int, Byte[]> allocator, PackerCompatibilityOptions compatibilityOptions);
    [CLSCompliantAttribute("False")]
public Packer Pack(Nullable`1<sbyte> value);
    public Packer Pack(Nullable`1<byte> value);
    public Packer Pack(Nullable`1<short> value);
    [CLSCompliantAttribute("False")]
public Packer Pack(Nullable`1<ushort> value);
    public Packer Pack(Nullable`1<int> value);
    [CLSCompliantAttribute("False")]
public Packer Pack(Nullable`1<UInt32> value);
    public Packer Pack(Nullable`1<long> value);
    [CLSCompliantAttribute("False")]
public Packer Pack(Nullable`1<ulong> value);
    public Packer Pack(Nullable`1<float> value);
    public Packer Pack(Nullable`1<double> value);
    public Packer Pack(Nullable`1<bool> value);
    public Packer Pack(short value);
    protected virtual void PackCore(short value);
    protected bool TryPackInt16(long value);
    [CLSCompliantAttribute("False")]
public Packer Pack(ushort value);
    [CLSCompliantAttribute("False")]
protected virtual void PackCore(ushort value);
    [CLSCompliantAttribute("False")]
protected bool TryPackUInt16(ulong value);
    public Packer Pack(int value);
    protected virtual void PackCore(int value);
    protected bool TryPackInt32(long value);
    [CLSCompliantAttribute("False")]
public Packer Pack(UInt32 value);
    [CLSCompliantAttribute("False")]
protected virtual void PackCore(UInt32 value);
    [CLSCompliantAttribute("False")]
protected bool TryPackUInt32(ulong value);
    public Packer Pack(long value);
    protected virtual void PackCore(long value);
    protected bool TryPackInt64(long value);
    [CLSCompliantAttribute("False")]
public Packer Pack(ulong value);
    [CLSCompliantAttribute("False")]
protected virtual void PackCore(ulong value);
    [CLSCompliantAttribute("False")]
protected bool TryPackUInt64(ulong value);
    public Packer Pack(float value);
    protected virtual void PackCore(float value);
    public Packer Pack(double value);
    protected virtual void PackCore(double value);
    public Packer PackArrayHeader(int count);
    protected virtual void PackArrayHeaderCore(int count);
    public Packer PackMapHeader(int count);
    protected virtual void PackMapHeaderCore(int count);
    [ObsoleteAttribute("Use PackStringHeader(Int32) or Use PackBinaryHeader(Int32) instead.")]
public Packer PackRawHeader(int length);
    public Packer PackStringHeader(int length);
    public Packer PackBinaryHeader(int length);
    [ObsoleteAttribute("Use PackStringHeaderCore(Int32) or Use PackBinaryHeaderCore(Int32) instead.")]
protected void PackRawHeaderCore(int length);
    protected virtual void PackStringHeaderCore(int length);
    protected virtual void PackBinaryHeaderCore(int length);
    public Packer PackRaw(IEnumerable`1<byte> value);
    public Packer PackRaw(IList`1<byte> value);
    public Packer PackRaw(Byte[] value);
    protected virtual void PackRawCore(Byte[] value);
    public Packer PackBinary(IEnumerable`1<byte> value);
    public Packer PackBinary(IList`1<byte> value);
    public Packer PackBinary(Byte[] value);
    protected virtual void PackBinaryCore(Byte[] value);
    public Packer PackString(IEnumerable`1<char> value);
    public Packer PackString(IEnumerable`1<char> value, Encoding encoding);
    protected virtual void PackStringCore(IEnumerable`1<char> value, Encoding encoding);
    public Packer PackString(string value);
    public Packer PackString(string value, Encoding encoding);
    protected virtual void PackStringCore(string value, Encoding encoding);
    protected virtual void PackRawCore(string value);
    private void PackRawCore(IEnumerable`1<char> value);
    public Packer PackRawBody(Byte[] value);
    public Packer PackRawBody(IEnumerable`1<byte> value);
    private int PrivatePackRawBodyCore(IEnumerable`1<byte> value);
    private int PrivatePackRawBodyCore(ICollection`1<byte> value, bool isImmutable);
    public Packer PackArrayHeader(IList`1<TItem> array);
    public Packer PackMapHeader(IDictionary`2<TKey, TValue> map);
    public Packer PackExtendedTypeValue(byte typeCode, Byte[] body);
    public Packer PackExtendedTypeValue(MessagePackExtendedTypeObject mpeto);
    protected virtual void PackExtendedTypeValueCore(byte typeCode, Byte[] body);
    private void StreamWrite(IEnumerable`1<TItem> value, Action`2<IEnumerable`1<TItem>, PackingOptions> writeBody, PackingOptions options);
}
[FlagsAttribute]
public enum MsgPack.PackerCompatibilityOptions : Enum {
    public int value__;
    public static PackerCompatibilityOptions None;
    public static PackerCompatibilityOptions PackBinaryAsRaw;
    public static PackerCompatibilityOptions ProhibitExtendedTypeObjects;
    public static PackerCompatibilityOptions Classic;
}
[ExtensionAttribute]
public static class MsgPack.PackerUnpackerExtensions : object {
    [ExtensionAttribute]
public static Packer Pack(Packer source, T value);
    [ExtensionAttribute]
public static Packer Pack(Packer source, T value, SerializationContext context);
    private static void PackCore(Packer source, T value, SerializationContext context);
    [ExtensionAttribute]
public static Packer PackArray(Packer source, IEnumerable`1<T> collection);
    [ExtensionAttribute]
public static Packer PackArray(Packer source, IEnumerable`1<T> collection, SerializationContext context);
    [ExtensionAttribute]
public static Packer PackCollection(Packer source, IEnumerable`1<T> collection);
    [ExtensionAttribute]
public static Packer PackCollection(Packer source, IEnumerable`1<T> collection, SerializationContext context);
    private static void PackCollectionCore(Packer source, IEnumerable`1<T> collection, SerializationContext context);
    internal static void PackCollectionCore(Packer source, IEnumerable`1<T> collection, MessagePackSerializer`1<T> itemSerializer);
    [ExtensionAttribute]
public static Packer PackMap(Packer source, IDictionary`2<TKey, TValue> dictionary);
    [ExtensionAttribute]
public static Packer PackMap(Packer source, IDictionary`2<TKey, TValue> dictionary, SerializationContext context);
    [ExtensionAttribute]
public static Packer PackDictionary(Packer source, IDictionary`2<TKey, TValue> dictionary);
    [ExtensionAttribute]
public static Packer PackDictionary(Packer source, IDictionary`2<TKey, TValue> dictionary, SerializationContext context);
    private static void PackDictionaryCore(Packer source, IDictionary`2<TKey, TValue> dictionary, SerializationContext context);
    internal static void PackDictionaryCore(Packer source, IDictionary`2<TKey, TValue> dictionary, MessagePackSerializer`1<TKey> keySerializer, MessagePackSerializer`1<TValue> valueSerializer);
    [ExtensionAttribute]
[ObsoleteAttribute("Use PackArray<T>, PackCollection<T>, PackMap<TKey, TValue>, or PackDictionary<TKey, TValue> instead.")]
public static Packer Pack(Packer source, IEnumerable`1<T> items);
    [ExtensionAttribute]
[ObsoleteAttribute("Use PackArray<T>, PackCollection<T>, PackMap<TKey, TValue>, or PackDictionary<TKey, TValue> instead.")]
public static Packer Pack(Packer source, IEnumerable`1<T> items, SerializationContext context);
    [ExtensionAttribute]
public static Packer PackObject(Packer source, object value);
    [ExtensionAttribute]
public static Packer PackObject(Packer source, object value, SerializationContext context);
    private static void PackObjectCore(Packer source, object value, SerializationContext context);
    [ExtensionAttribute]
public static T Unpack(Unpacker source);
    [ExtensionAttribute]
public static T Unpack(Unpacker source, SerializationContext context);
    private static T UnpackCore(Unpacker source, SerializationContext context);
}
public class MsgPack.PackerUnpackerStreamOptions : object {
    private static HashSet`1<string> _knownMemoryOrBufferingStreams;
    internal static PackerUnpackerStreamOptions SingletonOwnsStream;
    internal static PackerUnpackerStreamOptions SingletonForAsync;
    internal static PackerUnpackerStreamOptions None;
    [CompilerGeneratedAttribute]
private bool <WithBuffering>k__BackingField;
    private int _bufferSize;
    [CompilerGeneratedAttribute]
private bool <OwnsStream>k__BackingField;
    public bool WithBuffering { get; public set; }
    public int BufferSize { get; public set; }
    public bool OwnsStream { get; public set; }
    private static PackerUnpackerStreamOptions();
    private static bool ShouldWrapStream(Stream stream);
    [CompilerGeneratedAttribute]
public bool get_WithBuffering();
    [CompilerGeneratedAttribute]
public void set_WithBuffering(bool value);
    public int get_BufferSize();
    public void set_BufferSize(int value);
    [CompilerGeneratedAttribute]
public bool get_OwnsStream();
    [CompilerGeneratedAttribute]
public void set_OwnsStream(bool value);
    internal Stream WrapStream(Stream stream);
}
public class MsgPack.PackingOptions : object {
    private Encoding _stringEncoding;
    public Encoding StringEncoding { get; public set; }
    public Encoding get_StringEncoding();
    public void set_StringEncoding(Encoding value);
}
internal class MsgPack.PreserveAttribute : Attribute {
    public bool AllMembers;
    public bool Conditional;
}
internal enum MsgPack.ReadValueResult : Enum {
    public int value__;
    public static ReadValueResult UInt8Type;
    public static ReadValueResult UInt16Type;
    public static ReadValueResult UInt32Type;
    public static ReadValueResult UInt64Type;
    public static ReadValueResult Int8Type;
    public static ReadValueResult Int16Type;
    public static ReadValueResult Int32Type;
    public static ReadValueResult Int64Type;
    public static ReadValueResult Real32Type;
    public static ReadValueResult Real64Type;
    public static ReadValueResult Bin8Type;
    public static ReadValueResult Bin16Type;
    public static ReadValueResult Bin32Type;
    public static ReadValueResult FixExtType;
    public static ReadValueResult Ext8Type;
    public static ReadValueResult Ext16Type;
    public static ReadValueResult Ext32Type;
    public static ReadValueResult FixArrayType;
    public static ReadValueResult Array16Type;
    public static ReadValueResult Array32Type;
    public static ReadValueResult FixMapType;
    public static ReadValueResult Map16Type;
    public static ReadValueResult Map32Type;
    public static ReadValueResult FixStrType;
    public static ReadValueResult Str8Type;
    public static ReadValueResult Str16Type;
    public static ReadValueResult Str32Type;
    public static ReadValueResult Nil;
    public static ReadValueResult False;
    public static ReadValueResult True;
    public static ReadValueResult InvalidCode;
    public static ReadValueResult EoF;
    public static ReadValueResult Unexpected;
    public static ReadValueResult NonScalarBitMask;
    public static ReadValueResult ArrayTypeMask;
    public static ReadValueResult MapTypeMask;
    public static ReadValueResult BinTypeMask;
    public static ReadValueResult RawTypeMask;
    public static ReadValueResult ExtTypeMask;
    public static ReadValueResult LengthOfLengthMask;
    public static ReadValueResult ValueOrLengthMask;
    public static ReadValueResult TypeCodeMask;
    public static ReadValueResult FlagsMask;
    public static ReadValueResult FlagsAndTypeCodeMask;
    public static ReadValueResult FlagsAndLengthOfLengthMask;
}
[ExtensionAttribute]
internal static class MsgPack.ReadValueResults : object {
    public static ReadValueResult[] EncodedTypes;
    public static Boolean[] HasConstantObject;
    public static MessagePackObject[] ContantObject;
    public static CollectionType[] CollectionType;
    private static ReadValueResults();
    [ExtensionAttribute]
public static byte ToByte(ReadValueResult source);
}
[ExtensionAttribute]
internal static class MsgPack.ReflectionAbstractions : object {
    public static char TypeDelimiter;
    public static Type[] EmptyTypes;
    private static ReflectionAbstractions();
    [ExtensionAttribute]
public static bool GetIsValueType(Type source);
    [ExtensionAttribute]
public static bool GetIsEnum(Type source);
    [ExtensionAttribute]
public static bool GetIsInterface(Type source);
    [ExtensionAttribute]
public static bool GetIsAbstract(Type source);
    [ExtensionAttribute]
public static bool GetIsGenericType(Type source);
    [ExtensionAttribute]
public static bool GetIsGenericTypeDefinition(Type source);
    [ExtensionAttribute]
public static Assembly GetAssembly(Type source);
    [ExtensionAttribute]
public static bool GetIsVisible(Type source);
    [ExtensionAttribute]
public static bool GetIsPublic(Type source);
    [ExtensionAttribute]
public static bool GetIsNestedPublic(Type source);
    [ExtensionAttribute]
public static Type GetBaseType(Type source);
    [ExtensionAttribute]
public static MethodBase GetDeclaringMethod(Type source);
    [ExtensionAttribute]
public static Type[] GetGenericTypeParameters(Type source);
    [ExtensionAttribute]
public static MethodInfo GetRuntimeMethod(Type source, string name);
    [ExtensionAttribute]
public static MethodInfo GetRuntimeMethod(Type source, string name, Type[] parameters);
    [ExtensionAttribute]
public static IEnumerable`1<MethodInfo> GetRuntimeMethods(Type source);
    [ExtensionAttribute]
public static PropertyInfo GetRuntimeProperty(Type source, string name);
    [ExtensionAttribute]
public static IEnumerable`1<PropertyInfo> GetRuntimeProperties(Type source);
    [ExtensionAttribute]
public static ConstructorInfo GetRuntimeConstructor(Type source, Type[] parameters);
    [ExtensionAttribute]
public static Delegate CreateDelegate(MethodInfo source, Type delegateType);
    [ExtensionAttribute]
public static Delegate CreateDelegate(MethodInfo source, Type delegateType, object target);
    [ExtensionAttribute]
public static T GetCustomAttribute(MemberInfo source);
    [ExtensionAttribute]
public static bool IsDefined(MemberInfo source, Type attributeType);
    [ExtensionAttribute]
public static Type GetAttributeType(Attribute source);
    [ExtensionAttribute]
public static string GetCultureName(AssemblyName source);
    [ExtensionAttribute]
public static IEnumerable`1<Attribute> GetCustomAttributesData(MemberInfo source);
    [ExtensionAttribute]
public static IEnumerable`1<NamedArgument> GetNamedArguments(Attribute attribute);
    [ExtensionAttribute]
public static bool GetHasDefaultValue(ParameterInfo source);
}
internal enum MsgPack.Serialization.CollectionDetailedKind : Enum {
    public int value__;
    public static CollectionDetailedKind NotCollection;
    public static CollectionDetailedKind Array;
    public static CollectionDetailedKind GenericList;
    public static CollectionDetailedKind NonGenericList;
    public static CollectionDetailedKind GenericDictionary;
    public static CollectionDetailedKind NonGenericDictionary;
    public static CollectionDetailedKind GenericSet;
    public static CollectionDetailedKind GenericCollection;
    public static CollectionDetailedKind NonGenericCollection;
    public static CollectionDetailedKind GenericEnumerable;
    public static CollectionDetailedKind NonGenericEnumerable;
    public static CollectionDetailedKind GenericReadOnlyList;
    public static CollectionDetailedKind GenericReadOnlyCollection;
    public static CollectionDetailedKind GenericReadOnlyDictionary;
    public static CollectionDetailedKind Unserializable;
}
internal enum MsgPack.Serialization.CollectionKind : Enum {
    public int value__;
    public static CollectionKind NotCollection;
    public static CollectionKind Array;
    public static CollectionKind Map;
    public static CollectionKind Unserializable;
}
public abstract class MsgPack.Serialization.CollectionSerializers.CollectionMessagePackSerializer`2 : CollectionMessagePackSerializerBase`2<TCollection, TItem> {
    protected CollectionMessagePackSerializer`2(SerializationContext ownerContext, PolymorphismSchema schema);
    protected CollectionMessagePackSerializer`2(SerializationContext ownerContext, PolymorphismSchema schema, SerializerCapabilities capabilities);
    protected virtual int GetCount(TCollection collection);
    protected virtual void AddItem(TCollection collection, TItem item);
}
public abstract class MsgPack.Serialization.CollectionSerializers.CollectionMessagePackSerializerBase`2 : EnumerableMessagePackSerializerBase`2<TCollection, TItem> {
    protected CollectionMessagePackSerializerBase`2(SerializationContext ownerContext, PolymorphismSchema schema);
    protected CollectionMessagePackSerializerBase`2(SerializationContext ownerContext, PolymorphismSchema schema, SerializerCapabilities capabilities);
    protected internal virtual void PackToCore(Packer packer, TCollection objectTree);
    protected abstract virtual int GetCount(TCollection collection);
    protected internal virtual TCollection UnpackFromCore(Unpacker unpacker);
    internal virtual TCollection InternalUnpackFromCore(Unpacker unpacker);
}
internal static class MsgPack.Serialization.CollectionSerializers.CollectionSerializerHelpers : object {
    public static Type[] CollectionConstructorTypes;
    private static CollectionSerializerHelpers();
}
public abstract class MsgPack.Serialization.CollectionSerializers.DictionaryMessagePackSerializer`3 : DictionaryMessagePackSerializerBase`3<TDictionary, TKey, TValue> {
    protected DictionaryMessagePackSerializer`3(SerializationContext ownerContext, PolymorphismSchema schema);
    protected DictionaryMessagePackSerializer`3(SerializationContext ownerContext, PolymorphismSchema schema, SerializerCapabilities capabilities);
    protected virtual int GetCount(TDictionary dictionary);
    protected virtual void AddItem(TDictionary dictionary, TKey key, TValue value);
}
public abstract class MsgPack.Serialization.CollectionSerializers.DictionaryMessagePackSerializerBase`3 : MessagePackSerializer`1<TDictionary> {
    private MessagePackSerializer`1<TKey> _keySerializer;
    private MessagePackSerializer`1<TValue> _valueSerializer;
    protected DictionaryMessagePackSerializerBase`3(SerializationContext ownerContext, PolymorphismSchema schema);
    protected DictionaryMessagePackSerializerBase`3(SerializationContext ownerContext, PolymorphismSchema schema, SerializerCapabilities capabilities);
    protected internal virtual void PackToCore(Packer packer, TDictionary objectTree);
    protected abstract virtual int GetCount(TDictionary dictionary);
    protected internal virtual TDictionary UnpackFromCore(Unpacker unpacker);
    internal virtual TDictionary InternalUnpackFromCore(Unpacker unpacker);
    protected abstract virtual TDictionary CreateInstance(int initialCapacity);
    private sealed virtual override object MsgPack.Serialization.CollectionSerializers.ICollectionInstanceFactory.CreateInstance(int initialCapacity);
    protected internal virtual void UnpackToCore(Unpacker unpacker, TDictionary collection);
    private void UnpackToCore(Unpacker unpacker, TDictionary collection, int itemsCount);
    protected virtual void AddItem(TDictionary dictionary, TKey key, TValue value);
}
public abstract class MsgPack.Serialization.CollectionSerializers.EnumerableMessagePackSerializer`2 : EnumerableMessagePackSerializerBase`2<TCollection, TItem> {
    protected EnumerableMessagePackSerializer`2(SerializationContext ownerContext, PolymorphismSchema schema);
    protected EnumerableMessagePackSerializer`2(SerializationContext ownerContext, PolymorphismSchema schema, SerializerCapabilities capabilities);
    protected internal virtual void PackToCore(Packer packer, TCollection objectTree);
}
public abstract class MsgPack.Serialization.CollectionSerializers.EnumerableMessagePackSerializerBase`2 : MessagePackSerializer`1<TCollection> {
    private MessagePackSerializer`1<TItem> _itemSerializer;
    internal MessagePackSerializer`1<TItem> ItemSerializer { get; }
    protected EnumerableMessagePackSerializerBase`2(SerializationContext ownerContext, PolymorphismSchema schema);
    protected EnumerableMessagePackSerializerBase`2(SerializationContext ownerContext, PolymorphismSchema schema, SerializerCapabilities capabilities);
    internal MessagePackSerializer`1<TItem> get_ItemSerializer();
    protected abstract virtual TCollection CreateInstance(int initialCapacity);
    private sealed virtual override object MsgPack.Serialization.CollectionSerializers.ICollectionInstanceFactory.CreateInstance(int initialCapacity);
    protected internal virtual void UnpackToCore(Unpacker unpacker, TCollection collection);
    protected internal void UnpackToCore(Unpacker unpacker, TCollection collection, int itemsCount);
    protected virtual void AddItem(TCollection collection, TItem item);
}
public interface MsgPack.Serialization.CollectionSerializers.ICollectionInstanceFactory {
    public abstract virtual object CreateInstance(int initialCapacity);
}
public abstract class MsgPack.Serialization.CollectionSerializers.NonGenericCollectionMessagePackSerializer`1 : NonGenericEnumerableMessagePackSerializerBase`1<TCollection> {
    protected NonGenericCollectionMessagePackSerializer`1(SerializationContext ownerContext, PolymorphismSchema schema);
    protected NonGenericCollectionMessagePackSerializer`1(SerializationContext ownerContext, PolymorphismSchema schema, SerializerCapabilities capabilities);
    protected internal virtual void PackToCore(Packer packer, TCollection objectTree);
}
public abstract class MsgPack.Serialization.CollectionSerializers.NonGenericDictionaryMessagePackSerializer`1 : MessagePackSerializer`1<TDictionary> {
    private MessagePackSerializer _keySerializer;
    private MessagePackSerializer _valueSerializer;
    protected NonGenericDictionaryMessagePackSerializer`1(SerializationContext ownerContext, PolymorphismSchema schema);
    protected NonGenericDictionaryMessagePackSerializer`1(SerializationContext ownerContext, PolymorphismSchema schema, SerializerCapabilities capabilities);
    protected internal virtual void PackToCore(Packer packer, TDictionary objectTree);
    protected internal virtual TDictionary UnpackFromCore(Unpacker unpacker);
    internal virtual TDictionary InternalUnpackFromCore(Unpacker unpacker);
    protected abstract virtual TDictionary CreateInstance(int initialCapacity);
    private sealed virtual override object MsgPack.Serialization.CollectionSerializers.ICollectionInstanceFactory.CreateInstance(int initialCapacity);
    protected internal virtual void UnpackToCore(Unpacker unpacker, TDictionary collection);
    private void UnpackToCore(Unpacker unpacker, TDictionary collection, int itemsCount);
}
public abstract class MsgPack.Serialization.CollectionSerializers.NonGenericEnumerableMessagePackSerializer`1 : NonGenericEnumerableMessagePackSerializerBase`1<TCollection> {
    protected NonGenericEnumerableMessagePackSerializer`1(SerializationContext ownerContext, PolymorphismSchema schema);
    protected NonGenericEnumerableMessagePackSerializer`1(SerializationContext ownerContext, PolymorphismSchema schema, SerializerCapabilities capabilities);
    protected internal virtual void PackToCore(Packer packer, TCollection objectTree);
}
public abstract class MsgPack.Serialization.CollectionSerializers.NonGenericEnumerableMessagePackSerializerBase`1 : MessagePackSerializer`1<TCollection> {
    private MessagePackSerializer _itemSerializer;
    internal MessagePackSerializer ItemSerializer { get; }
    protected NonGenericEnumerableMessagePackSerializerBase`1(SerializationContext ownerContext, PolymorphismSchema schema);
    protected NonGenericEnumerableMessagePackSerializerBase`1(SerializationContext ownerContext, PolymorphismSchema schema, SerializerCapabilities capabilities);
    internal MessagePackSerializer get_ItemSerializer();
    protected abstract virtual TCollection CreateInstance(int initialCapacity);
    private sealed virtual override object MsgPack.Serialization.CollectionSerializers.ICollectionInstanceFactory.CreateInstance(int initialCapacity);
    protected internal virtual void UnpackToCore(Unpacker unpacker, TCollection collection);
    protected internal void UnpackToCore(Unpacker unpacker, TCollection collection, int itemsCount);
    protected virtual void AddItem(TCollection collection, object item);
}
public abstract class MsgPack.Serialization.CollectionSerializers.NonGenericListMessagePackSerializer`1 : NonGenericCollectionMessagePackSerializer`1<TList> {
    protected NonGenericListMessagePackSerializer`1(SerializationContext ownerContext, PolymorphismSchema schema);
    protected NonGenericListMessagePackSerializer`1(SerializationContext ownerContext, PolymorphismSchema schema, SerializerCapabilities capabilities);
    protected internal virtual TList UnpackFromCore(Unpacker unpacker);
    internal virtual TList InternalUnpackFromCore(Unpacker unpacker);
    protected virtual void AddItem(TList collection, object item);
}
public abstract class MsgPack.Serialization.CollectionSerializers.ReadOnlyCollectionMessagePackSerializer`2 : CollectionMessagePackSerializerBase`2<TCollection, TItem> {
    protected ReadOnlyCollectionMessagePackSerializer`2(SerializationContext ownerContext, PolymorphismSchema schema);
    protected ReadOnlyCollectionMessagePackSerializer`2(SerializationContext ownerContext, PolymorphismSchema schema, SerializerCapabilities capabilities);
    protected virtual int GetCount(TCollection collection);
}
public abstract class MsgPack.Serialization.CollectionSerializers.ReadOnlyDictionaryMessagePackSerializer`3 : DictionaryMessagePackSerializerBase`3<TDictionary, TKey, TValue> {
    protected ReadOnlyDictionaryMessagePackSerializer`3(SerializationContext ownerContext, PolymorphismSchema schema);
    protected ReadOnlyDictionaryMessagePackSerializer`3(SerializationContext ownerContext, PolymorphismSchema schema, SerializerCapabilities capabilities);
    protected virtual int GetCount(TDictionary dictionary);
}
[FlagsAttribute]
internal enum MsgPack.Serialization.CollectionTraitOptions : Enum {
    public int value__;
    public static CollectionTraitOptions None;
    public static CollectionTraitOptions WithAddMethod;
    public static CollectionTraitOptions WithCountPropertyGetter;
    public static CollectionTraitOptions WithGetEnumeratorMethod;
    public static CollectionTraitOptions AllowNonCollectionEnumerableTypes;
    public static CollectionTraitOptions Full;
}
internal class MsgPack.Serialization.CollectionTraits : ValueType {
    public static CollectionTraits NotCollection;
    public static CollectionTraits Unserializable;
    public Type ElementType;
    public CollectionDetailedKind DetailedCollectionType;
    public MethodInfo GetEnumeratorMethod;
    public MethodInfo AddMethod;
    public MethodInfo CountPropertyGetter;
    public CollectionKind CollectionType { get; }
    public CollectionTraits(CollectionDetailedKind type, Type elementType, MethodInfo getEnumeratorMethod, MethodInfo addMethod, MethodInfo countPropertyGetter);
    private static CollectionTraits();
    public CollectionKind get_CollectionType();
}
internal class MsgPack.Serialization.DataMemberContract : ValueType {
    internal static int UnspecifiedId;
    private string _name;
    private int _id;
    private NilImplication _nilImplication;
    public string Name { get; }
    public int Id { get; }
    public NilImplication NilImplication { get; }
    public DataMemberContract(MemberInfo member);
    public DataMemberContract(MemberInfo member, string name, NilImplication nilImplication, Nullable`1<int> id);
    public DataMemberContract(MemberInfo member, MessagePackMemberAttribute attribute);
    public string get_Name();
    public int get_Id();
    public NilImplication get_NilImplication();
}
public enum MsgPack.Serialization.DateTimeConversionMethod : Enum {
    public int value__;
    public static DateTimeConversionMethod Native;
    public static DateTimeConversionMethod UnixEpoc;
    public static DateTimeConversionMethod Timestamp;
}
public enum MsgPack.Serialization.DateTimeMemberConversionMethod : Enum {
    public int value__;
    public static DateTimeMemberConversionMethod Default;
    public static DateTimeMemberConversionMethod Native;
    public static DateTimeMemberConversionMethod UnixEpoc;
    public static DateTimeMemberConversionMethod Timestamp;
}
[EditorBrowsableAttribute("1")]
public static class MsgPack.Serialization.DateTimeMessagePackSerializerHelpers : object {
    [EditorBrowsableAttribute("1")]
public static DateTimeConversionMethod DetermineDateTimeConversionMethod(SerializationContext context, DateTimeMemberConversionMethod dateTimeMemberConversionMethod);
    internal static bool IsDateTime(Type dateTimeType);
}
public class MsgPack.Serialization.DefaultConcreteTypeRepository : object {
    private TypeKeyRepository _defaultCollectionTypes;
    public Type Get(Type abstractCollectionType);
    internal Type GetConcreteType(Type abstractCollectionType);
    public void Register(Type abstractCollectionType, Type defaultCollectionType);
    private static bool IsAnscestorType(Type mayBeAncestor, Type mayBeDescendant);
    public bool Unregister(Type abstractCollectionType);
}
internal class MsgPack.Serialization.DefaultSerializers.AbstractCollectionMessagePackSerializer`2 : CollectionMessagePackSerializer`2<TCollection, TItem> {
    private ICollectionInstanceFactory _concreteCollectionInstanceFactory;
    private IPolymorphicDeserializer _polymorphicDeserializer;
    public AbstractCollectionMessagePackSerializer`2(SerializationContext ownerContext, Type targetType, PolymorphismSchema schema);
    internal virtual TCollection InternalUnpackFromCore(Unpacker unpacker);
    protected virtual TCollection CreateInstance(int initialCapacity);
}
internal static class MsgPack.Serialization.DefaultSerializers.AbstractCollectionSerializerHelper : object {
    public static void GetConcreteSerializer(SerializationContext context, PolymorphismSchema schema, Type abstractType, Type targetType, Type exampleType, ICollectionInstanceFactory& factory, MessagePackSerializer& serializer);
}
internal class MsgPack.Serialization.DefaultSerializers.AbstractDictionaryMessagePackSerializer`3 : DictionaryMessagePackSerializer`3<TDictionary, TKey, TValue> {
    private ICollectionInstanceFactory _concreteCollectionInstanceFactory;
    private IPolymorphicDeserializer _polymorphicDeserializer;
    public AbstractDictionaryMessagePackSerializer`3(SerializationContext ownerContext, Type targetType, PolymorphismSchema schema);
    internal virtual TDictionary InternalUnpackFromCore(Unpacker unpacker);
    protected virtual TDictionary CreateInstance(int initialCapacity);
}
internal class MsgPack.Serialization.DefaultSerializers.AbstractEnumerableMessagePackSerializer`2 : EnumerableMessagePackSerializer`2<TCollection, TItem> {
    private ICollectionInstanceFactory _concreteCollectionInstanceFactory;
    private MessagePackSerializer _concreteSerializer;
    public AbstractEnumerableMessagePackSerializer`2(SerializationContext ownerContext, Type targetType, PolymorphismSchema schema);
    internal virtual SerializerCapabilities InternalGetCapabilities();
    protected internal virtual TCollection UnpackFromCore(Unpacker unpacker);
    protected virtual TCollection CreateInstance(int initialCapacity);
}
internal class MsgPack.Serialization.DefaultSerializers.AbstractNonGenericCollectionMessagePackSerializer`1 : NonGenericCollectionMessagePackSerializer`1<TCollection> {
    private ICollectionInstanceFactory _concreteCollectionInstanceFactory;
    private MessagePackSerializer _concreteSerializer;
    public AbstractNonGenericCollectionMessagePackSerializer`1(SerializationContext ownerContext, Type targetType, PolymorphismSchema schema);
    internal virtual SerializerCapabilities InternalGetCapabilities();
    protected internal virtual TCollection UnpackFromCore(Unpacker unpacker);
    protected virtual TCollection CreateInstance(int initialCapacity);
}
internal class MsgPack.Serialization.DefaultSerializers.AbstractNonGenericDictionaryMessagePackSerializer`1 : NonGenericDictionaryMessagePackSerializer`1<TDictionary> {
    private ICollectionInstanceFactory _concreteCollectionInstanceFactory;
    private IPolymorphicDeserializer _polymorphicDeserializer;
    public AbstractNonGenericDictionaryMessagePackSerializer`1(SerializationContext ownerContext, Type targetType, PolymorphismSchema schema);
    internal virtual TDictionary InternalUnpackFromCore(Unpacker unpacker);
    protected virtual TDictionary CreateInstance(int initialCapacity);
}
internal class MsgPack.Serialization.DefaultSerializers.AbstractNonGenericEnumerableMessagePackSerializer`1 : NonGenericEnumerableMessagePackSerializer`1<TCollection> {
    private ICollectionInstanceFactory _concreteCollectionInstanceFactory;
    private MessagePackSerializer _concreteSerializer;
    public AbstractNonGenericEnumerableMessagePackSerializer`1(SerializationContext ownerContext, Type targetType, PolymorphismSchema schema);
    internal virtual SerializerCapabilities InternalGetCapabilities();
    protected internal virtual TCollection UnpackFromCore(Unpacker unpacker);
    protected virtual TCollection CreateInstance(int initialCapacity);
}
internal class MsgPack.Serialization.DefaultSerializers.AbstractNonGenericListMessagePackSerializer`1 : NonGenericListMessagePackSerializer`1<TCollection> {
    private ICollectionInstanceFactory _concreteCollectionInstanceFactory;
    private IPolymorphicDeserializer _polymorphicDeserializer;
    public AbstractNonGenericListMessagePackSerializer`1(SerializationContext ownerContext, Type targetType, PolymorphismSchema schema);
    internal virtual TCollection InternalUnpackFromCore(Unpacker unpacker);
    protected virtual TCollection CreateInstance(int initialCapacity);
}
internal class MsgPack.Serialization.DefaultSerializers.AbstractReadOnlyCollectionMessagePackSerializer`2 : ReadOnlyCollectionMessagePackSerializer`2<TCollection, TItem> {
    private ICollectionInstanceFactory _concreteCollectionInstanceFactory;
    private IPolymorphicDeserializer _polymorphicDeserializer;
    private MessagePackSerializer _concreteDeserializer;
    public AbstractReadOnlyCollectionMessagePackSerializer`2(SerializationContext ownerContext, Type targetType, PolymorphismSchema schema);
    internal virtual SerializerCapabilities InternalGetCapabilities();
    internal virtual TCollection InternalUnpackFromCore(Unpacker unpacker);
    protected virtual TCollection CreateInstance(int initialCapacity);
}
internal class MsgPack.Serialization.DefaultSerializers.AbstractReadOnlyDictionaryMessagePackSerializer`3 : ReadOnlyDictionaryMessagePackSerializer`3<TDictionary, TKey, TValue> {
    private ICollectionInstanceFactory _concreteCollectionInstanceFactory;
    private IPolymorphicDeserializer _polymorphicDeserializer;
    private MessagePackSerializer _concreteDeserializer;
    public AbstractReadOnlyDictionaryMessagePackSerializer`3(SerializationContext ownerContext, Type targetType, PolymorphismSchema schema);
    internal virtual SerializerCapabilities InternalGetCapabilities();
    internal virtual TDictionary InternalUnpackFromCore(Unpacker unpacker);
    protected virtual TDictionary CreateInstance(int initialCapacity);
}
internal static class MsgPack.Serialization.DefaultSerializers.ArraySegmentMessageSerializer : object {
    public static void PackByteArraySegmentTo(Packer packer, ArraySegment`1<byte> objectTree, MessagePackSerializer`1<byte> itemSerializer);
    public static void PackCharArraySegmentTo(Packer packer, ArraySegment`1<char> objectTree, MessagePackSerializer`1<char> itemSerializer);
    public static void PackGenericArraySegmentTo(Packer packer, ArraySegment`1<T> objectTree, MessagePackSerializer`1<T> itemSerializer);
    public static ArraySegment`1<byte> UnpackByteArraySegmentFrom(Unpacker unpacker, MessagePackSerializer`1<byte> itemSerializer);
    public static ArraySegment`1<char> UnpackCharArraySegmentFrom(Unpacker unpacker, MessagePackSerializer`1<char> itemSerializer);
    public static ArraySegment`1<T> UnpackGenericArraySegmentFrom(Unpacker unpacker, MessagePackSerializer`1<T> itemSerializer);
}
internal static class MsgPack.Serialization.DefaultSerializers.ArraySerializer : object {
    private static Dictionary`2<Type, Func`2<SerializationContext, object>> _arraySerializerFactories;
    private static ArraySerializer();
    public static MessagePackSerializer`1<T> Create(SerializationContext context, PolymorphismSchema itemsSchema);
    public static MessagePackSerializer Create(SerializationContext context, Type targetType, PolymorphismSchema itemsSchema);
    private static object GetPrimitiveArraySerializer(SerializationContext context, Type targetType);
    private static Dictionary`2<Type, Func`2<SerializationContext, object>> InitializeArraySerializerFactories();
}
[PreserveAttribute]
internal class MsgPack.Serialization.DefaultSerializers.ArraySerializer`1 : MessagePackSerializer`1<T[]> {
    private MessagePackSerializer`1<T> _itemSerializer;
    public ArraySerializer`1(SerializationContext ownerContext, PolymorphismSchema itemsSchema);
    protected internal virtual void PackToCore(Packer packer, T[] objectTree);
    protected internal virtual T[] UnpackFromCore(Unpacker unpacker);
    protected internal virtual void UnpackToCore(Unpacker unpacker, T[] collection);
    private void UnpackToCore(Unpacker unpacker, T[] collection, int count);
}
[PreserveAttribute]
internal class MsgPack.Serialization.DefaultSerializers.BinaryArraySerializer : MessagePackSerializer`1<Byte[][]> {
    public BinaryArraySerializer(SerializationContext ownerContext);
    protected internal virtual void PackToCore(Packer packer, Byte[][] objectTree);
    protected internal virtual Byte[][] UnpackFromCore(Unpacker unpacker);
    protected internal virtual void UnpackToCore(Unpacker unpacker, Byte[][] collection);
    private static void UnpackToCore(Unpacker unpacker, Byte[][] collection, int count);
}
[PreserveAttribute]
internal class MsgPack.Serialization.DefaultSerializers.BooleanArraySerializer : MessagePackSerializer`1<Boolean[]> {
    public BooleanArraySerializer(SerializationContext ownerContext);
    protected internal virtual void PackToCore(Packer packer, Boolean[] objectTree);
    protected internal virtual Boolean[] UnpackFromCore(Unpacker unpacker);
    protected internal virtual void UnpackToCore(Unpacker unpacker, Boolean[] collection);
    private static void UnpackToCore(Unpacker unpacker, Boolean[] collection, int count);
}
[PreserveAttribute]
internal class MsgPack.Serialization.DefaultSerializers.ByteArraySerializer : MessagePackSerializer`1<Byte[]> {
    public ByteArraySerializer(SerializationContext ownerContext);
    protected internal virtual void PackToCore(Packer packer, Byte[] objectTree);
    protected internal virtual Byte[] UnpackFromCore(Unpacker unpacker);
    protected internal virtual void UnpackToCore(Unpacker unpacker, Byte[] collection);
    private static void UnpackToCore(Unpacker unpacker, Byte[] collection, int count);
}
internal class MsgPack.Serialization.DefaultSerializers.DateTimeMessagePackSerializerProvider : MessagePackSerializerProvider {
    private MessagePackSerializer _unixEpoc;
    private MessagePackSerializer _native;
    private MessagePackSerializer _timestamp;
    public DateTimeMessagePackSerializerProvider(SerializationContext context, bool isNullable);
    public virtual object Get(SerializationContext context, object providerParameter);
}
internal class MsgPack.Serialization.DefaultSerializers.DateTimeOffsetMessagePackSerializer : MessagePackSerializer`1<DateTimeOffset> {
    private DateTimeConversionMethod _conversion;
    public DateTimeOffsetMessagePackSerializer(SerializationContext ownerContext, DateTimeConversionMethod conversion);
    protected internal virtual void PackToCore(Packer packer, DateTimeOffset objectTree);
    protected internal virtual DateTimeOffset UnpackFromCore(Unpacker unpacker);
}
internal class MsgPack.Serialization.DefaultSerializers.DateTimeOffsetMessagePackSerializerProvider : MessagePackSerializerProvider {
    private MessagePackSerializer _unixEpoc;
    private MessagePackSerializer _native;
    private MessagePackSerializer _timestamp;
    public DateTimeOffsetMessagePackSerializerProvider(SerializationContext context, bool isNullable);
    public virtual object Get(SerializationContext context, object providerParameter);
}
[PreserveAttribute]
internal class MsgPack.Serialization.DefaultSerializers.DoubleArraySerializer : MessagePackSerializer`1<Double[]> {
    public DoubleArraySerializer(SerializationContext ownerContext);
    protected internal virtual void PackToCore(Packer packer, Double[] objectTree);
    protected internal virtual Double[] UnpackFromCore(Unpacker unpacker);
    protected internal virtual void UnpackToCore(Unpacker unpacker, Double[] collection);
    private static void UnpackToCore(Unpacker unpacker, Double[] collection, int count);
}
internal class MsgPack.Serialization.DefaultSerializers.FileTimeMessagePackSerializerProvider : MessagePackSerializerProvider {
    private MessagePackSerializer _unixEpoc;
    private MessagePackSerializer _native;
    private MessagePackSerializer _timestamp;
    public FileTimeMessagePackSerializerProvider(SerializationContext context, bool isNullable);
    public virtual object Get(SerializationContext context, object providerParameter);
}
[PreserveAttribute]
internal class MsgPack.Serialization.DefaultSerializers.FSharpCollectionSerializer`2 : MessagePackSerializer`1<T> {
    private Func`2<TItem[], T> _factory;
    private MessagePackSerializer`1<TItem> _itemSerializer;
    public FSharpCollectionSerializer`2(SerializationContext ownerContext, PolymorphismSchema itemsSchema, string factoryTypeName);
    private static Func`2<TItem[], T> FindFactory(string factoryTypeName);
    protected internal virtual void PackToCore(Packer packer, T objectTree);
    protected internal virtual T UnpackFromCore(Unpacker unpacker);
    protected internal virtual void UnpackToCore(Unpacker unpacker, T collection);
}
[PreserveAttribute]
internal class MsgPack.Serialization.DefaultSerializers.FSharpMapSerializer`3 : MessagePackSerializer`1<T> {
    private Func`2<IEnumerable`1<Tuple`2<TKey, TValue>>, T> _factory;
    private MessagePackSerializer`1<TKey> _keySerializer;
    private MessagePackSerializer`1<TValue> _valueSerializer;
    public FSharpMapSerializer`3(SerializationContext ownerContext, PolymorphismSchema keysSchema, PolymorphismSchema valuesSchema);
    private static Func`2<IEnumerable`1<Tuple`2<TKey, TValue>>, T> FindFactory();
    protected internal virtual void PackToCore(Packer packer, T objectTree);
    protected internal virtual T UnpackFromCore(Unpacker unpacker);
    protected internal virtual void UnpackToCore(Unpacker unpacker, T collection);
}
internal static class MsgPack.Serialization.DefaultSerializers.GenericSerializer : object {
    public static MessagePackSerializer`1<T> Create(SerializationContext context, PolymorphismSchema schema);
    public static MessagePackSerializer Create(SerializationContext context, Type targetType, PolymorphismSchema schema);
    private static MessagePackSerializer CreateArraySerializer(SerializationContext context, Type targetType, PolymorphismSchema itemsSchema);
    private static MessagePackSerializer CreateNullableSerializer(SerializationContext context, Type underlyingType, PolymorphismSchema schema);
    private static MessagePackSerializer CreateListSerializer(SerializationContext context, Type itemType, PolymorphismSchema schema);
    private static MessagePackSerializer CreateDictionarySerializer(SerializationContext context, Type keyType, Type valueType, PolymorphismSchema schema);
    private static MessagePackSerializer TryCreateImmutableCollectionSerializer(SerializationContext context, Type targetType, PolymorphismSchema schema);
    public static MessagePackSerializer TryCreateAbstractCollectionSerializer(SerializationContext context, Type abstractType, Type concreteType, PolymorphismSchema schema);
    internal static MessagePackSerializer TryCreateAbstractCollectionSerializer(SerializationContext context, Type abstractType, Type concreteType, PolymorphismSchema schema, CollectionTraits traits);
    internal static bool IsSupported(Type type, CollectionTraits traits, bool preferReflectionBasedSerializer);
}
[PreserveAttribute]
internal class MsgPack.Serialization.DefaultSerializers.ImmutableCollectionSerializer`2 : MessagePackSerializer`1<T> {
    protected Func`2<TItem[], T> Factory;
    protected MessagePackSerializer`1<TItem> ItemSerializer;
    public ImmutableCollectionSerializer`2(SerializationContext ownerContext, PolymorphismSchema itemsSchema);
    private static Func`2<TItem[], T> FindFactory();
    protected internal virtual void PackToCore(Packer packer, T objectTree);
    protected internal virtual T UnpackFromCore(Unpacker unpacker);
    protected internal virtual void UnpackToCore(Unpacker unpacker, T collection);
}
[PreserveAttribute]
internal class MsgPack.Serialization.DefaultSerializers.ImmutableDictionarySerializer`3 : MessagePackSerializer`1<T> {
    private Func`2<KeyValuePair`2[], T> _factory;
    private MessagePackSerializer`1<TKey> _keySerializer;
    private MessagePackSerializer`1<TValue> _valueSerializer;
    public ImmutableDictionarySerializer`3(SerializationContext ownerContext, PolymorphismSchema keysSchema, PolymorphismSchema valuesSchema);
    private static Func`2<KeyValuePair`2[], T> FindFactory();
    protected internal virtual void PackToCore(Packer packer, T objectTree);
    protected internal virtual T UnpackFromCore(Unpacker unpacker);
    protected internal virtual void UnpackToCore(Unpacker unpacker, T collection);
}
[PreserveAttribute]
internal class MsgPack.Serialization.DefaultSerializers.ImmutableStackSerializer`2 : ImmutableCollectionSerializer`2<T, TItem> {
    public ImmutableStackSerializer`2(SerializationContext ownerContext, PolymorphismSchema itemsSchema);
    protected internal virtual T UnpackFromCore(Unpacker unpacker);
}
[PreserveAttribute]
internal class MsgPack.Serialization.DefaultSerializers.Int16ArraySerializer : MessagePackSerializer`1<Int16[]> {
    public Int16ArraySerializer(SerializationContext ownerContext);
    protected internal virtual void PackToCore(Packer packer, Int16[] objectTree);
    protected internal virtual Int16[] UnpackFromCore(Unpacker unpacker);
    protected internal virtual void UnpackToCore(Unpacker unpacker, Int16[] collection);
    private static void UnpackToCore(Unpacker unpacker, Int16[] collection, int count);
}
[PreserveAttribute]
internal class MsgPack.Serialization.DefaultSerializers.Int32ArraySerializer : MessagePackSerializer`1<Int32[]> {
    public Int32ArraySerializer(SerializationContext ownerContext);
    protected internal virtual void PackToCore(Packer packer, Int32[] objectTree);
    protected internal virtual Int32[] UnpackFromCore(Unpacker unpacker);
    protected internal virtual void UnpackToCore(Unpacker unpacker, Int32[] collection);
    private static void UnpackToCore(Unpacker unpacker, Int32[] collection, int count);
}
[PreserveAttribute]
internal class MsgPack.Serialization.DefaultSerializers.Int64ArraySerializer : MessagePackSerializer`1<Int64[]> {
    public Int64ArraySerializer(SerializationContext ownerContext);
    protected internal virtual void PackToCore(Packer packer, Int64[] objectTree);
    protected internal virtual Int64[] UnpackFromCore(Unpacker unpacker);
    protected internal virtual void UnpackToCore(Unpacker unpacker, Int64[] collection);
    private static void UnpackToCore(Unpacker unpacker, Int64[] collection, int count);
}
[ExtensionAttribute]
internal static class MsgPack.Serialization.DefaultSerializers.InternalDateTimeExtensions : object {
    private static ulong LocalMask;
    private static long TicksCeiling;
    private static int KindShift;
    private static DateTime _fileTimeEpocUtc;
    private static InternalDateTimeExtensions();
    [ExtensionAttribute]
public static long ToBinary(DateTime source);
    [ExtensionAttribute]
public static DateTime ToDateTime(FILETIME source);
    [ExtensionAttribute]
public static FILETIME ToWin32FileTimeUtc(DateTime source);
}
[PreserveAttribute]
internal class MsgPack.Serialization.DefaultSerializers.MessagePackObjectArraySerializer : MessagePackSerializer`1<MessagePackObject[]> {
    public MessagePackObjectArraySerializer(SerializationContext ownerContext);
    protected internal virtual void PackToCore(Packer packer, MessagePackObject[] objectTree);
    protected internal virtual MessagePackObject[] UnpackFromCore(Unpacker unpacker);
    protected internal virtual void UnpackToCore(Unpacker unpacker, MessagePackObject[] collection);
    private static void UnpackToCore(Unpacker unpacker, MessagePackObject[] collection, int count);
}
[ExtensionAttribute]
internal static class MsgPack.Serialization.DefaultSerializers.MessagePackObjectExtensions : object {
    [ExtensionAttribute]
public static long DeserializeAsInt64(MessagePackObject source);
    [ExtensionAttribute]
public static string DeserializeAsString(MessagePackObject source);
    [ExtensionAttribute]
public static MessagePackExtendedTypeObject DeserializeAsMessagePackExtendedTypeObject(MessagePackObject source);
}
internal class MsgPack.Serialization.DefaultSerializers.MsgPack_MessagePackExtendedTypeObjectMessagePackSerializer : MessagePackSerializer`1<MessagePackExtendedTypeObject> {
    public MsgPack_MessagePackExtendedTypeObjectMessagePackSerializer(SerializationContext ownerContext);
    protected internal virtual void PackToCore(Packer packer, MessagePackExtendedTypeObject value);
    protected internal virtual MessagePackExtendedTypeObject UnpackFromCore(Unpacker unpacker);
}
internal class MsgPack.Serialization.DefaultSerializers.MsgPack_MessagePackObjectDictionaryMessagePackSerializer : MessagePackSerializer`1<MessagePackObjectDictionary> {
    public MsgPack_MessagePackObjectDictionaryMessagePackSerializer(SerializationContext ownerContext);
    protected internal virtual void PackToCore(Packer packer, MessagePackObjectDictionary objectTree);
    protected internal virtual MessagePackObjectDictionary UnpackFromCore(Unpacker unpacker);
    protected internal virtual void UnpackToCore(Unpacker unpacker, MessagePackObjectDictionary collection);
    private static void UnpackToCore(Unpacker unpacker, int count, MessagePackObjectDictionary collection);
    public sealed virtual object CreateInstance(int initialCapacity);
}
internal class MsgPack.Serialization.DefaultSerializers.MsgPack_MessagePackObjectMessagePackSerializer : MessagePackSerializer`1<MessagePackObject> {
    public MsgPack_MessagePackObjectMessagePackSerializer(SerializationContext ownerContext);
    protected internal virtual void PackToCore(Packer packer, MessagePackObject value);
    protected internal virtual MessagePackObject UnpackFromCore(Unpacker unpacker);
}
[PreserveAttribute]
internal class MsgPack.Serialization.DefaultSerializers.MultidimensionalArraySerializer`2 : MessagePackSerializer`1<TArray> {
    private MessagePackSerializer`1<TItem> _itemSerializer;
    private MessagePackSerializer`1<Int32[]> _int32ArraySerializer;
    public MultidimensionalArraySerializer`2(SerializationContext ownerContext, PolymorphismSchema itemsSchema);
    protected internal virtual void PackToCore(Packer packer, TArray objectTree);
    private void PackArrayCore(Packer packer, Array array);
    private static void GetArrayMetadata(Array array, Int32[]& lengths, Int32[]& lowerBounds);
    protected internal virtual TArray UnpackFromCore(Unpacker unpacker);
    private void ReadArrayMetadata(Unpacker metadataUnpacker, Int32[]& lengths, Int32[]& lowerBounds);
    private static void ForEach(Array array, int totalLength, Int32[] lowerBounds, Int32[] lengths, Action`1<Int32[]> action);
}
internal class MsgPack.Serialization.DefaultSerializers.NativeDateTimeMessagePackSerializer : MessagePackSerializer`1<DateTime> {
    public NativeDateTimeMessagePackSerializer(SerializationContext ownerContext);
    protected internal virtual void PackToCore(Packer packer, DateTime objectTree);
    protected internal virtual DateTime UnpackFromCore(Unpacker unpacker);
}
internal class MsgPack.Serialization.DefaultSerializers.NativeFileTimeMessagePackSerializer : MessagePackSerializer`1<FILETIME> {
    public NativeFileTimeMessagePackSerializer(SerializationContext ownerContext);
    protected internal virtual void PackToCore(Packer packer, FILETIME objectTree);
    protected internal virtual FILETIME UnpackFromCore(Unpacker unpacker);
}
[PreserveAttribute]
internal class MsgPack.Serialization.DefaultSerializers.NullableBooleanArraySerializer : MessagePackSerializer`1<Nullable`1[]> {
    public NullableBooleanArraySerializer(SerializationContext ownerContext);
    protected internal virtual void PackToCore(Packer packer, Nullable`1[] objectTree);
    protected internal virtual Nullable`1[] UnpackFromCore(Unpacker unpacker);
    protected internal virtual void UnpackToCore(Unpacker unpacker, Nullable`1[] collection);
    private static void UnpackToCore(Unpacker unpacker, Nullable`1[] collection, int count);
}
[PreserveAttribute]
internal class MsgPack.Serialization.DefaultSerializers.NullableByteArraySerializer : MessagePackSerializer`1<Nullable`1[]> {
    public NullableByteArraySerializer(SerializationContext ownerContext);
    protected internal virtual void PackToCore(Packer packer, Nullable`1[] objectTree);
    protected internal virtual Nullable`1[] UnpackFromCore(Unpacker unpacker);
    protected internal virtual void UnpackToCore(Unpacker unpacker, Nullable`1[] collection);
    private static void UnpackToCore(Unpacker unpacker, Nullable`1[] collection, int count);
}
[PreserveAttribute]
internal class MsgPack.Serialization.DefaultSerializers.NullableDoubleArraySerializer : MessagePackSerializer`1<Nullable`1[]> {
    public NullableDoubleArraySerializer(SerializationContext ownerContext);
    protected internal virtual void PackToCore(Packer packer, Nullable`1[] objectTree);
    protected internal virtual Nullable`1[] UnpackFromCore(Unpacker unpacker);
    protected internal virtual void UnpackToCore(Unpacker unpacker, Nullable`1[] collection);
    private static void UnpackToCore(Unpacker unpacker, Nullable`1[] collection, int count);
}
[PreserveAttribute]
internal class MsgPack.Serialization.DefaultSerializers.NullableInt16ArraySerializer : MessagePackSerializer`1<Nullable`1[]> {
    public NullableInt16ArraySerializer(SerializationContext ownerContext);
    protected internal virtual void PackToCore(Packer packer, Nullable`1[] objectTree);
    protected internal virtual Nullable`1[] UnpackFromCore(Unpacker unpacker);
    protected internal virtual void UnpackToCore(Unpacker unpacker, Nullable`1[] collection);
    private static void UnpackToCore(Unpacker unpacker, Nullable`1[] collection, int count);
}
[PreserveAttribute]
internal class MsgPack.Serialization.DefaultSerializers.NullableInt32ArraySerializer : MessagePackSerializer`1<Nullable`1[]> {
    public NullableInt32ArraySerializer(SerializationContext ownerContext);
    protected internal virtual void PackToCore(Packer packer, Nullable`1[] objectTree);
    protected internal virtual Nullable`1[] UnpackFromCore(Unpacker unpacker);
    protected internal virtual void UnpackToCore(Unpacker unpacker, Nullable`1[] collection);
    private static void UnpackToCore(Unpacker unpacker, Nullable`1[] collection, int count);
}
[PreserveAttribute]
internal class MsgPack.Serialization.DefaultSerializers.NullableInt64ArraySerializer : MessagePackSerializer`1<Nullable`1[]> {
    public NullableInt64ArraySerializer(SerializationContext ownerContext);
    protected internal virtual void PackToCore(Packer packer, Nullable`1[] objectTree);
    protected internal virtual Nullable`1[] UnpackFromCore(Unpacker unpacker);
    protected internal virtual void UnpackToCore(Unpacker unpacker, Nullable`1[] collection);
    private static void UnpackToCore(Unpacker unpacker, Nullable`1[] collection, int count);
}
[PreserveAttribute]
internal class MsgPack.Serialization.DefaultSerializers.NullableMessagePackSerializer`1 : MessagePackSerializer`1<Nullable`1<T>> {
    private MessagePackSerializer`1<T> _valueSerializer;
    public NullableMessagePackSerializer`1(SerializationContext ownerContext);
    public NullableMessagePackSerializer`1(SerializationContext ownerContext, MessagePackSerializer`1<T> valueSerializer);
    protected internal virtual void PackToCore(Packer packer, Nullable`1<T> objectTree);
    protected internal virtual Nullable`1<T> UnpackFromCore(Unpacker unpacker);
}
[PreserveAttribute]
internal class MsgPack.Serialization.DefaultSerializers.NullableSByteArraySerializer : MessagePackSerializer`1<Nullable`1[]> {
    public NullableSByteArraySerializer(SerializationContext ownerContext);
    protected internal virtual void PackToCore(Packer packer, Nullable`1[] objectTree);
    protected internal virtual Nullable`1[] UnpackFromCore(Unpacker unpacker);
    protected internal virtual void UnpackToCore(Unpacker unpacker, Nullable`1[] collection);
    private static void UnpackToCore(Unpacker unpacker, Nullable`1[] collection, int count);
}
[PreserveAttribute]
internal class MsgPack.Serialization.DefaultSerializers.NullableSingleArraySerializer : MessagePackSerializer`1<Nullable`1[]> {
    public NullableSingleArraySerializer(SerializationContext ownerContext);
    protected internal virtual void PackToCore(Packer packer, Nullable`1[] objectTree);
    protected internal virtual Nullable`1[] UnpackFromCore(Unpacker unpacker);
    protected internal virtual void UnpackToCore(Unpacker unpacker, Nullable`1[] collection);
    private static void UnpackToCore(Unpacker unpacker, Nullable`1[] collection, int count);
}
[PreserveAttribute]
internal class MsgPack.Serialization.DefaultSerializers.NullableUInt16ArraySerializer : MessagePackSerializer`1<Nullable`1[]> {
    public NullableUInt16ArraySerializer(SerializationContext ownerContext);
    protected internal virtual void PackToCore(Packer packer, Nullable`1[] objectTree);
    protected internal virtual Nullable`1[] UnpackFromCore(Unpacker unpacker);
    protected internal virtual void UnpackToCore(Unpacker unpacker, Nullable`1[] collection);
    private static void UnpackToCore(Unpacker unpacker, Nullable`1[] collection, int count);
}
[PreserveAttribute]
internal class MsgPack.Serialization.DefaultSerializers.NullableUInt32ArraySerializer : MessagePackSerializer`1<Nullable`1[]> {
    public NullableUInt32ArraySerializer(SerializationContext ownerContext);
    protected internal virtual void PackToCore(Packer packer, Nullable`1[] objectTree);
    protected internal virtual Nullable`1[] UnpackFromCore(Unpacker unpacker);
    protected internal virtual void UnpackToCore(Unpacker unpacker, Nullable`1[] collection);
    private static void UnpackToCore(Unpacker unpacker, Nullable`1[] collection, int count);
}
[PreserveAttribute]
internal class MsgPack.Serialization.DefaultSerializers.NullableUInt64ArraySerializer : MessagePackSerializer`1<Nullable`1[]> {
    public NullableUInt64ArraySerializer(SerializationContext ownerContext);
    protected internal virtual void PackToCore(Packer packer, Nullable`1[] objectTree);
    protected internal virtual Nullable`1[] UnpackFromCore(Unpacker unpacker);
    protected internal virtual void UnpackToCore(Unpacker unpacker, Nullable`1[] collection);
    private static void UnpackToCore(Unpacker unpacker, Nullable`1[] collection, int count);
}
[PreserveAttribute]
internal class MsgPack.Serialization.DefaultSerializers.SByteArraySerializer : MessagePackSerializer`1<SByte[]> {
    public SByteArraySerializer(SerializationContext ownerContext);
    protected internal virtual void PackToCore(Packer packer, SByte[] objectTree);
    protected internal virtual SByte[] UnpackFromCore(Unpacker unpacker);
    protected internal virtual void UnpackToCore(Unpacker unpacker, SByte[] collection);
    private static void UnpackToCore(Unpacker unpacker, SByte[] collection, int count);
}
[PreserveAttribute]
internal class MsgPack.Serialization.DefaultSerializers.SingleArraySerializer : MessagePackSerializer`1<Single[]> {
    public SingleArraySerializer(SerializationContext ownerContext);
    protected internal virtual void PackToCore(Packer packer, Single[] objectTree);
    protected internal virtual Single[] UnpackFromCore(Unpacker unpacker);
    protected internal virtual void UnpackToCore(Unpacker unpacker, Single[] collection);
    private static void UnpackToCore(Unpacker unpacker, Single[] collection, int count);
}
[PreserveAttribute]
internal class MsgPack.Serialization.DefaultSerializers.StringArraySerializer : MessagePackSerializer`1<String[]> {
    public StringArraySerializer(SerializationContext ownerContext);
    protected internal virtual void PackToCore(Packer packer, String[] objectTree);
    protected internal virtual String[] UnpackFromCore(Unpacker unpacker);
    protected internal virtual void UnpackToCore(Unpacker unpacker, String[] collection);
    private static void UnpackToCore(Unpacker unpacker, String[] collection, int count);
}
[PreserveAttribute]
internal class MsgPack.Serialization.DefaultSerializers.System_ArraySegment_1MessagePackSerializer`1 : MessagePackSerializer`1<ArraySegment`1<T>> {
    private static Action`3<Packer, ArraySegment`1<T>, MessagePackSerializer`1<T>> _packing;
    private static Func`3<Unpacker, MessagePackSerializer`1<T>, ArraySegment`1<T>> _unpacking;
    private MessagePackSerializer`1<T> _itemSerializer;
    public System_ArraySegment_1MessagePackSerializer`1(SerializationContext ownerContext);
    private static System_ArraySegment_1MessagePackSerializer`1();
    private static Action`3<Packer, ArraySegment`1<T>, MessagePackSerializer`1<T>> InitializePacking();
    private static Func`3<Unpacker, MessagePackSerializer`1<T>, ArraySegment`1<T>> InitializeUnpacking();
    protected internal sealed virtual void PackToCore(Packer packer, ArraySegment`1<T> objectTree);
    protected internal sealed virtual ArraySegment`1<T> UnpackFromCore(Unpacker unpacker);
}
internal class MsgPack.Serialization.DefaultSerializers.System_BooleanMessagePackSerializer : MessagePackSerializer`1<bool> {
    public System_BooleanMessagePackSerializer(SerializationContext ownerContext);
    protected internal virtual void PackToCore(Packer packer, bool value);
    protected internal virtual bool UnpackFromCore(Unpacker unpacker);
}
internal class MsgPack.Serialization.DefaultSerializers.System_ByteArrayMessagePackSerializer : MessagePackSerializer`1<Byte[]> {
    public System_ByteArrayMessagePackSerializer(SerializationContext ownerContext);
    protected internal virtual void PackToCore(Packer packer, Byte[] value);
    protected internal virtual Byte[] UnpackFromCore(Unpacker unpacker);
}
internal class MsgPack.Serialization.DefaultSerializers.System_ByteMessagePackSerializer : MessagePackSerializer`1<byte> {
    public System_ByteMessagePackSerializer(SerializationContext ownerContext);
    protected internal virtual void PackToCore(Packer packer, byte value);
    protected internal virtual byte UnpackFromCore(Unpacker unpacker);
}
internal class MsgPack.Serialization.DefaultSerializers.System_CharArrayMessagePackSerializer : MessagePackSerializer`1<Char[]> {
    public System_CharArrayMessagePackSerializer(SerializationContext ownerContext);
    protected internal virtual void PackToCore(Packer packer, Char[] value);
    protected internal virtual Char[] UnpackFromCore(Unpacker unpacker);
}
internal class MsgPack.Serialization.DefaultSerializers.System_CharMessagePackSerializer : MessagePackSerializer`1<char> {
    public System_CharMessagePackSerializer(SerializationContext ownerContext);
    protected internal virtual void PackToCore(Packer packer, char value);
    protected internal virtual char UnpackFromCore(Unpacker unpacker);
}
[PreserveAttribute]
internal class MsgPack.Serialization.DefaultSerializers.System_Collections_DictionaryEntryMessagePackSerializer : MessagePackSerializer`1<DictionaryEntry> {
    public System_Collections_DictionaryEntryMessagePackSerializer(SerializationContext ownerContext);
    protected internal virtual void PackToCore(Packer packer, DictionaryEntry objectTree);
    private static MessagePackObject EnsureMessagePackObject(object obj);
    protected internal virtual DictionaryEntry UnpackFromCore(Unpacker unpacker);
}
[PreserveAttribute]
internal class MsgPack.Serialization.DefaultSerializers.System_Collections_Generic_Dictionary_2MessagePackSerializer`2 : MessagePackSerializer`1<Dictionary`2<TKey, TValue>> {
    private MessagePackSerializer`1<TKey> _keySerializer;
    private MessagePackSerializer`1<TValue> _valueSerializer;
    public System_Collections_Generic_Dictionary_2MessagePackSerializer`2(SerializationContext ownerContext, PolymorphismSchema keysSchema, PolymorphismSchema valuesSchema);
    protected internal virtual void PackToCore(Packer packer, Dictionary`2<TKey, TValue> objectTree);
    protected internal virtual Dictionary`2<TKey, TValue> UnpackFromCore(Unpacker unpacker);
    protected internal virtual void UnpackToCore(Unpacker unpacker, Dictionary`2<TKey, TValue> collection);
    private void UnpackToCore(Unpacker unpacker, Dictionary`2<TKey, TValue> collection, int count);
    public sealed virtual object CreateInstance(int initialCapacity);
}
[PreserveAttribute]
internal class MsgPack.Serialization.DefaultSerializers.System_Collections_Generic_KeyValuePair_2MessagePackSerializer`2 : MessagePackSerializer`1<KeyValuePair`2<TKey, TValue>> {
    private MessagePackSerializer`1<TKey> _keySerializer;
    private MessagePackSerializer`1<TValue> _valueSerializer;
    public System_Collections_Generic_KeyValuePair_2MessagePackSerializer`2(SerializationContext ownerContext);
    protected internal virtual void PackToCore(Packer packer, KeyValuePair`2<TKey, TValue> objectTree);
    protected internal virtual KeyValuePair`2<TKey, TValue> UnpackFromCore(Unpacker unpacker);
}
[PreserveAttribute]
internal class MsgPack.Serialization.DefaultSerializers.System_Collections_Generic_List_1MessagePackSerializer`1 : MessagePackSerializer`1<List`1<T>> {
    private MessagePackSerializer`1<T> _itemSerializer;
    public System_Collections_Generic_List_1MessagePackSerializer`1(SerializationContext ownerContext, PolymorphismSchema itemsSchema);
    protected internal virtual void PackToCore(Packer packer, List`1<T> objectTree);
    protected internal virtual List`1<T> UnpackFromCore(Unpacker unpacker);
    protected internal virtual void UnpackToCore(Unpacker unpacker, List`1<T> collection);
    private void UnpackToCore(Unpacker unpacker, List`1<T> collection, int count);
    public sealed virtual object CreateInstance(int initialCapacity);
}
internal class MsgPack.Serialization.DefaultSerializers.System_Collections_Generic_ListOfMessagePackObjectMessagePackSerializer : MessagePackSerializer`1<List`1<MessagePackObject>> {
    public System_Collections_Generic_ListOfMessagePackObjectMessagePackSerializer(SerializationContext ownerContext);
    protected internal virtual void PackToCore(Packer packer, List`1<MessagePackObject> objectTree);
    protected internal virtual List`1<MessagePackObject> UnpackFromCore(Unpacker unpacker);
    protected internal virtual void UnpackToCore(Unpacker unpacker, List`1<MessagePackObject> collection);
    private static void UnpackToCore(Unpacker unpacker, List`1<MessagePackObject> collection, int count);
    public sealed virtual object CreateInstance(int initialCapacity);
}
[PreserveAttribute]
internal class MsgPack.Serialization.DefaultSerializers.System_Collections_Generic_Queue_1MessagePackSerializer`1 : MessagePackSerializer`1<Queue`1<TItem>> {
    private MessagePackSerializer`1<TItem> _itemSerializer;
    public System_Collections_Generic_Queue_1MessagePackSerializer`1(SerializationContext ownerContext);
    protected internal virtual void PackToCore(Packer packer, Queue`1<TItem> objectTree);
    protected internal virtual Queue`1<TItem> UnpackFromCore(Unpacker unpacker);
    protected internal virtual void UnpackToCore(Unpacker unpacker, Queue`1<TItem> collection);
    public sealed virtual object CreateInstance(int initialCapacity);
}
[PreserveAttribute]
internal class MsgPack.Serialization.DefaultSerializers.System_Collections_Generic_Stack_1MessagePackSerializer`1 : MessagePackSerializer`1<Stack`1<TItem>> {
    private MessagePackSerializer`1<TItem> _itemSerializer;
    public System_Collections_Generic_Stack_1MessagePackSerializer`1(SerializationContext ownerContext);
    protected internal virtual void PackToCore(Packer packer, Stack`1<TItem> objectTree);
    protected internal virtual Stack`1<TItem> UnpackFromCore(Unpacker unpacker);
    protected internal virtual void UnpackToCore(Unpacker unpacker, Stack`1<TItem> collection);
    private IEnumerable`1<TItem> UnpackItemsInReverseOrder(Unpacker unpacker, int count);
    public sealed virtual object CreateInstance(int initialCapacity);
}
internal class MsgPack.Serialization.DefaultSerializers.System_DBNullMessagePackSerializer : MessagePackSerializer`1<DBNull> {
    public System_DBNullMessagePackSerializer(SerializationContext ownerContext);
    protected internal virtual void PackToCore(Packer packer, DBNull objectTree);
    protected internal virtual DBNull UnpackFromCore(Unpacker unpacker);
    protected internal virtual DBNull UnpackNil();
}
internal class MsgPack.Serialization.DefaultSerializers.System_DecimalMessagePackSerializer : MessagePackSerializer`1<decimal> {
    public System_DecimalMessagePackSerializer(SerializationContext ownerContext);
    protected internal virtual void PackToCore(Packer packer, decimal value);
    protected internal virtual decimal UnpackFromCore(Unpacker unpacker);
}
internal class MsgPack.Serialization.DefaultSerializers.System_DoubleMessagePackSerializer : MessagePackSerializer`1<double> {
    public System_DoubleMessagePackSerializer(SerializationContext ownerContext);
    protected internal virtual void PackToCore(Packer packer, double value);
    protected internal virtual double UnpackFromCore(Unpacker unpacker);
}
internal class MsgPack.Serialization.DefaultSerializers.System_Globalization_CultureInfoMessagePackSerializer : MessagePackSerializer`1<CultureInfo> {
    public System_Globalization_CultureInfoMessagePackSerializer(SerializationContext ownerContext);
    protected internal virtual void PackToCore(Packer packer, CultureInfo objectTree);
    protected internal virtual CultureInfo UnpackFromCore(Unpacker unpacker);
}
internal class MsgPack.Serialization.DefaultSerializers.System_GuidMessagePackSerializer : MessagePackSerializer`1<Guid> {
    public System_GuidMessagePackSerializer(SerializationContext ownerContext);
    protected internal virtual void PackToCore(Packer packer, Guid value);
    protected internal virtual Guid UnpackFromCore(Unpacker unpacker);
}
internal class MsgPack.Serialization.DefaultSerializers.System_Int16MessagePackSerializer : MessagePackSerializer`1<short> {
    public System_Int16MessagePackSerializer(SerializationContext ownerContext);
    protected internal virtual void PackToCore(Packer packer, short value);
    protected internal virtual short UnpackFromCore(Unpacker unpacker);
}
internal class MsgPack.Serialization.DefaultSerializers.System_Int32MessagePackSerializer : MessagePackSerializer`1<int> {
    public System_Int32MessagePackSerializer(SerializationContext ownerContext);
    protected internal virtual void PackToCore(Packer packer, int value);
    protected internal virtual int UnpackFromCore(Unpacker unpacker);
}
internal class MsgPack.Serialization.DefaultSerializers.System_Int64MessagePackSerializer : MessagePackSerializer`1<long> {
    public System_Int64MessagePackSerializer(SerializationContext ownerContext);
    protected internal virtual void PackToCore(Packer packer, long value);
    protected internal virtual long UnpackFromCore(Unpacker unpacker);
}
internal class MsgPack.Serialization.DefaultSerializers.System_ObjectMessagePackSerializer : MessagePackSerializer`1<object> {
    public System_ObjectMessagePackSerializer(SerializationContext ownerContext);
    protected internal virtual void PackToCore(Packer packer, object value);
    protected internal virtual object UnpackFromCore(Unpacker unpacker);
}
internal class MsgPack.Serialization.DefaultSerializers.System_SByteMessagePackSerializer : MessagePackSerializer`1<sbyte> {
    public System_SByteMessagePackSerializer(SerializationContext ownerContext);
    protected internal virtual void PackToCore(Packer packer, sbyte value);
    protected internal virtual sbyte UnpackFromCore(Unpacker unpacker);
}
internal class MsgPack.Serialization.DefaultSerializers.System_SingleMessagePackSerializer : MessagePackSerializer`1<float> {
    public System_SingleMessagePackSerializer(SerializationContext ownerContext);
    protected internal virtual void PackToCore(Packer packer, float value);
    protected internal virtual float UnpackFromCore(Unpacker unpacker);
}
internal class MsgPack.Serialization.DefaultSerializers.System_StringMessagePackSerializer : MessagePackSerializer`1<string> {
    public System_StringMessagePackSerializer(SerializationContext ownerContext);
    protected internal virtual void PackToCore(Packer packer, string value);
    protected internal virtual string UnpackFromCore(Unpacker unpacker);
}
internal class MsgPack.Serialization.DefaultSerializers.System_Text_StringBuilderMessagePackSerializer : MessagePackSerializer`1<StringBuilder> {
    public System_Text_StringBuilderMessagePackSerializer(SerializationContext ownerContext);
    protected internal virtual void PackToCore(Packer packer, StringBuilder value);
    protected internal virtual StringBuilder UnpackFromCore(Unpacker unpacker);
    protected internal virtual void UnpackToCore(Unpacker unpacker, StringBuilder collection);
}
internal class MsgPack.Serialization.DefaultSerializers.System_TimeSpanMessagePackSerializer : MessagePackSerializer`1<TimeSpan> {
    public System_TimeSpanMessagePackSerializer(SerializationContext ownerContext);
    protected internal virtual void PackToCore(Packer packer, TimeSpan value);
    protected internal virtual TimeSpan UnpackFromCore(Unpacker unpacker);
}
internal class MsgPack.Serialization.DefaultSerializers.System_UInt16MessagePackSerializer : MessagePackSerializer`1<ushort> {
    public System_UInt16MessagePackSerializer(SerializationContext ownerContext);
    protected internal virtual void PackToCore(Packer packer, ushort value);
    protected internal virtual ushort UnpackFromCore(Unpacker unpacker);
}
internal class MsgPack.Serialization.DefaultSerializers.System_UInt32MessagePackSerializer : MessagePackSerializer`1<UInt32> {
    public System_UInt32MessagePackSerializer(SerializationContext ownerContext);
    protected internal virtual void PackToCore(Packer packer, UInt32 value);
    protected internal virtual UInt32 UnpackFromCore(Unpacker unpacker);
}
internal class MsgPack.Serialization.DefaultSerializers.System_UInt64MessagePackSerializer : MessagePackSerializer`1<ulong> {
    public System_UInt64MessagePackSerializer(SerializationContext ownerContext);
    protected internal virtual void PackToCore(Packer packer, ulong value);
    protected internal virtual ulong UnpackFromCore(Unpacker unpacker);
}
internal class MsgPack.Serialization.DefaultSerializers.System_UriMessagePackSerializer : MessagePackSerializer`1<Uri> {
    public System_UriMessagePackSerializer(SerializationContext ownerContext);
    protected internal virtual void PackToCore(Packer packer, Uri objectTree);
    protected internal virtual Uri UnpackFromCore(Unpacker unpacker);
}
internal class MsgPack.Serialization.DefaultSerializers.System_VersionMessagePackSerializer : MessagePackSerializer`1<Version> {
    public System_VersionMessagePackSerializer(SerializationContext ownerContext);
    protected internal virtual void PackToCore(Packer packer, Version objectTree);
    protected internal virtual Version UnpackFromCore(Unpacker unpacker);
}
internal class MsgPack.Serialization.DefaultSerializers.TimestampDateTimeMessagePackSerializer : MessagePackSerializer`1<DateTime> {
    public TimestampDateTimeMessagePackSerializer(SerializationContext ownerContext);
    protected internal virtual void PackToCore(Packer packer, DateTime objectTree);
    protected internal virtual DateTime UnpackFromCore(Unpacker unpacker);
}
internal class MsgPack.Serialization.DefaultSerializers.TimestampFileTimeMessagePackSerializer : MessagePackSerializer`1<FILETIME> {
    public TimestampFileTimeMessagePackSerializer(SerializationContext ownerContext);
    protected internal virtual void PackToCore(Packer packer, FILETIME objectTree);
    protected internal virtual FILETIME UnpackFromCore(Unpacker unpacker);
}
internal class MsgPack.Serialization.DefaultSerializers.TimestampMessagePackSerializer : MessagePackSerializer`1<Timestamp> {
    private DateTimeConversionMethod _conversion;
    public TimestampMessagePackSerializer(SerializationContext ownerContext, DateTimeConversionMethod conversion);
    protected internal virtual void PackToCore(Packer packer, Timestamp objectTree);
    protected internal virtual Timestamp UnpackFromCore(Unpacker unpacker);
}
internal class MsgPack.Serialization.DefaultSerializers.TimestampMessagePackSerializerProvider : MessagePackSerializerProvider {
    private MessagePackSerializer _unixEpoc;
    private MessagePackSerializer _native;
    private MessagePackSerializer _timestamp;
    public TimestampMessagePackSerializerProvider(SerializationContext context, bool isNullable);
    public virtual object Get(SerializationContext context, object providerParameter);
}
[PreserveAttribute]
internal class MsgPack.Serialization.DefaultSerializers.UInt16ArraySerializer : MessagePackSerializer`1<UInt16[]> {
    public UInt16ArraySerializer(SerializationContext ownerContext);
    protected internal virtual void PackToCore(Packer packer, UInt16[] objectTree);
    protected internal virtual UInt16[] UnpackFromCore(Unpacker unpacker);
    protected internal virtual void UnpackToCore(Unpacker unpacker, UInt16[] collection);
    private static void UnpackToCore(Unpacker unpacker, UInt16[] collection, int count);
}
[PreserveAttribute]
internal class MsgPack.Serialization.DefaultSerializers.UInt32ArraySerializer : MessagePackSerializer`1<UInt32[]> {
    public UInt32ArraySerializer(SerializationContext ownerContext);
    protected internal virtual void PackToCore(Packer packer, UInt32[] objectTree);
    protected internal virtual UInt32[] UnpackFromCore(Unpacker unpacker);
    protected internal virtual void UnpackToCore(Unpacker unpacker, UInt32[] collection);
    private static void UnpackToCore(Unpacker unpacker, UInt32[] collection, int count);
}
[PreserveAttribute]
internal class MsgPack.Serialization.DefaultSerializers.UInt64ArraySerializer : MessagePackSerializer`1<UInt64[]> {
    public UInt64ArraySerializer(SerializationContext ownerContext);
    protected internal virtual void PackToCore(Packer packer, UInt64[] objectTree);
    protected internal virtual UInt64[] UnpackFromCore(Unpacker unpacker);
    protected internal virtual void UnpackToCore(Unpacker unpacker, UInt64[] collection);
    private static void UnpackToCore(Unpacker unpacker, UInt64[] collection, int count);
}
internal class MsgPack.Serialization.DefaultSerializers.UnixEpocDateTimeMessagePackSerializer : MessagePackSerializer`1<DateTime> {
    public UnixEpocDateTimeMessagePackSerializer(SerializationContext ownerContext);
    protected internal virtual void PackToCore(Packer packer, DateTime objectTree);
    protected internal virtual DateTime UnpackFromCore(Unpacker unpacker);
}
internal class MsgPack.Serialization.DefaultSerializers.UnixEpocFileTimeMessagePackSerializer : MessagePackSerializer`1<FILETIME> {
    public UnixEpocFileTimeMessagePackSerializer(SerializationContext ownerContext);
    protected internal virtual void PackToCore(Packer packer, FILETIME objectTree);
    protected internal virtual FILETIME UnpackFromCore(Unpacker unpacker);
}
public static class MsgPack.Serialization.DictionaryKeyTransformers : object {
    private static Func`2<string, string> _lowerCamel;
    public static Func`2<string, string> LowerCamel { get; }
    private static DictionaryKeyTransformers();
    public static Func`2<string, string> get_LowerCamel();
}
public class MsgPack.Serialization.DictionarySerlaizationOptions : object {
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _omitNullEntry;
    private Func`2 modreq(System.Runtime.CompilerServices.IsVolatile) _keyNameHandler;
    public bool OmitNullEntry { get; public set; }
    public Func`2<string, string> KeyTransformer { get; public set; }
    internal Func`2<string, string> SafeKeyTransformer { get; }
    public bool get_OmitNullEntry();
    public void set_OmitNullEntry(bool value);
    public Func`2<string, string> get_KeyTransformer();
    public void set_KeyTransformer(Func`2<string, string> value);
    internal Func`2<string, string> get_SafeKeyTransformer();
}
internal enum MsgPack.Serialization.EmitterFlavor : Enum {
    public int value__;
    public static EmitterFlavor ReflectionBased;
}
public enum MsgPack.Serialization.EnumMemberSerializationMethod : Enum {
    public int value__;
    public static EnumMemberSerializationMethod Default;
    public static EnumMemberSerializationMethod ByName;
    public static EnumMemberSerializationMethod ByUnderlyingValue;
}
public abstract class MsgPack.Serialization.EnumMessagePackSerializer`1 : MessagePackSerializer`1<TEnum> {
    private Type _underlyingType;
    private Dictionary`2<TEnum, string> _serializationMapping;
    private Dictionary`2<string, TEnum> _deserializationMapping;
    private EnumSerializationMethod _serializationMethod;
    protected EnumMessagePackSerializer`1(SerializationContext ownerContext, EnumSerializationMethod serializationMethod);
    protected internal sealed virtual void PackToCore(Packer packer, TEnum objectTree);
    protected internal abstract virtual void PackUnderlyingValueTo(Packer packer, TEnum enumValue);
    protected internal sealed virtual TEnum UnpackFromCore(Unpacker unpacker);
    protected internal abstract virtual TEnum UnpackFromUnderlyingValue(MessagePackObject messagePackObject);
    private sealed virtual override ICustomizableEnumSerializer MsgPack.Serialization.ICustomizableEnumSerializer.GetCopyAs(EnumSerializationMethod method);
}
[EditorBrowsableAttribute("1")]
public static class MsgPack.Serialization.EnumMessagePackSerializerHelpers : object {
    public static EnumSerializationMethod DetermineEnumSerializationMethod(SerializationContext context, Type enumType, EnumMemberSerializationMethod enumMemberSerializationMethod);
}
internal class MsgPack.Serialization.EnumMessagePackSerializerProvider : MessagePackSerializerProvider {
    private Type _enumType;
    private object _serializerForName;
    private object _serializerForIntegral;
    public EnumMessagePackSerializerProvider(Type enumType, ICustomizableEnumSerializer serializer);
    public virtual object Get(SerializationContext context, object providerParameter);
}
public static class MsgPack.Serialization.EnumNameTransformers : object {
    private static Func`2<string, string> _lowerCamel;
    private static Func`2<string, string> _upperSnake;
    public static Func`2<string, string> LowerCamel { get; }
    public static Func`2<string, string> UpperSnake { get; }
    private static EnumNameTransformers();
    public static Func`2<string, string> get_LowerCamel();
    public static Func`2<string, string> get_UpperSnake();
}
public enum MsgPack.Serialization.EnumSerializationMethod : Enum {
    public int value__;
    public static EnumSerializationMethod ByName;
    public static EnumSerializationMethod ByUnderlyingValue;
}
public class MsgPack.Serialization.EnumSerializationOptions : object {
    private int _serializationMethod;
    private Func`2 modreq(System.Runtime.CompilerServices.IsVolatile) _nameTransformer;
    public EnumSerializationMethod SerializationMethod { get; public set; }
    public Func`2<string, string> NameTransformer { get; public set; }
    internal Func`2<string, string> SafeNameTransformer { get; }
    public EnumSerializationMethod get_SerializationMethod();
    public void set_SerializationMethod(EnumSerializationMethod value);
    public Func`2<string, string> get_NameTransformer();
    public void set_NameTransformer(Func`2<string, string> value);
    internal Func`2<string, string> get_SafeNameTransformer();
}
[DefaultMemberAttribute("Item")]
public class MsgPack.Serialization.ExtTypeCodeMapping : object {
    private object _syncRoot;
    private Dictionary`2<string, byte> _index;
    private Dictionary`2<byte, string> _types;
    public byte Item { get; }
    public byte get_Item(string name);
    public bool Add(string name, byte typeCode);
    private bool AddInternal(string name, byte typeCode);
    public bool Remove(string name);
    public bool Remove(byte typeCode);
    private void RemoveCore(string name, byte typeCode);
    public void Clear();
    public sealed virtual IEnumerator`1<KeyValuePair`2<string, byte>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private static void ValidateName(string name);
    private static void ValidateTypeCode(byte typeCode);
}
internal interface MsgPack.Serialization.ICustomizableEnumSerializer {
    public abstract virtual ICustomizableEnumSerializer GetCopyAs(EnumSerializationMethod method);
}
internal static class MsgPack.Serialization.IdentifierUtility : object {
    public static string EscapeTypeName(Type type);
    public static string EscapeTypeName(string fullName);
}
[ObsoleteAttribute("Use MessagePackSerializer abstract class instead.")]
public interface MsgPack.Serialization.IMessagePackSerializer {
    public abstract virtual void PackTo(Packer packer, object objectTree);
    public abstract virtual object UnpackFrom(Unpacker unpacker);
    public abstract virtual void UnpackTo(Unpacker unpacker, object collection);
}
[ObsoleteAttribute("Use MessagePackSerializer abstract class instead.")]
public interface MsgPack.Serialization.IMessagePackSingleObjectSerializer {
    public abstract virtual Byte[] PackSingleObject(object objectTree);
    public abstract virtual object UnpackSingleObject(Byte[] buffer);
}
internal interface MsgPack.Serialization.INilImplicationHandlerOnUnpackedParameter`1 {
    public TAction Store { get; }
    public abstract virtual TAction get_Store();
}
internal interface MsgPack.Serialization.INilImplicationHandlerParameter {
    public Type ItemType { get; }
    public abstract virtual Type get_ItemType();
}
internal static class MsgPack.Serialization.KeyNameTransformers : object {
    public static Func`2<string, string> AsIs;
    private static KeyNameTransformers();
    public static string ToLowerCamel(string mayBeUpperCamel);
    public static string ToUpperSnake(string mayBeUpperCamel);
}
internal class MsgPack.Serialization.LazyDelegatingMessagePackSerializer`1 : MessagePackSerializer`1<T> {
    private object _providerParameter;
    private MessagePackSerializer`1<T> _delegated;
    public LazyDelegatingMessagePackSerializer`1(SerializationContext ownerContext, object providerParameter);
    internal virtual SerializerCapabilities InternalGetCapabilities();
    private MessagePackSerializer`1<T> GetDelegatedSerializer();
    protected internal virtual void PackToCore(Packer packer, T objectTree);
    protected internal virtual T UnpackFromCore(Unpacker unpacker);
    protected internal virtual void UnpackToCore(Unpacker unpacker, T collection);
    public virtual string ToString();
}
[AttributeUsageAttribute("384")]
public class MsgPack.Serialization.MessagePackDateTimeMemberAttribute : Attribute {
    [CompilerGeneratedAttribute]
private DateTimeMemberConversionMethod <DateTimeConversionMethod>k__BackingField;
    public DateTimeMemberConversionMethod DateTimeConversionMethod { get; public set; }
    [CompilerGeneratedAttribute]
public DateTimeMemberConversionMethod get_DateTimeConversionMethod();
    [CompilerGeneratedAttribute]
public void set_DateTimeConversionMethod(DateTimeMemberConversionMethod value);
}
[AttributeUsageAttribute("32")]
public class MsgPack.Serialization.MessagePackDeserializationConstructorAttribute : Attribute {
}
[AttributeUsageAttribute("16")]
public class MsgPack.Serialization.MessagePackEnumAttribute : Attribute {
    [CompilerGeneratedAttribute]
private EnumSerializationMethod <SerializationMethod>k__BackingField;
    public EnumSerializationMethod SerializationMethod { get; public set; }
    [CompilerGeneratedAttribute]
public EnumSerializationMethod get_SerializationMethod();
    [CompilerGeneratedAttribute]
public void set_SerializationMethod(EnumSerializationMethod value);
}
[AttributeUsageAttribute("384")]
public class MsgPack.Serialization.MessagePackEnumMemberAttribute : Attribute {
    [CompilerGeneratedAttribute]
private EnumMemberSerializationMethod <SerializationMethod>k__BackingField;
    public EnumMemberSerializationMethod SerializationMethod { get; public set; }
    [CompilerGeneratedAttribute]
public EnumMemberSerializationMethod get_SerializationMethod();
    [CompilerGeneratedAttribute]
public void set_SerializationMethod(EnumMemberSerializationMethod value);
}
[AttributeUsageAttribute("384")]
public class MsgPack.Serialization.MessagePackIgnoreAttribute : Attribute {
}
[AttributeUsageAttribute("1420")]
public class MsgPack.Serialization.MessagePackKnownCollectionItemTypeAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <TypeCode>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <BindingType>k__BackingField;
    private PolymorphismTarget MsgPack.Serialization.Polymorphic.IPolymorphicHelperAttribute.Target { get; }
    public string TypeCode { get; private set; }
    public Type BindingType { get; private set; }
    public MessagePackKnownCollectionItemTypeAttribute(string typeCode, Type bindingType);
    private sealed virtual override PolymorphismTarget MsgPack.Serialization.Polymorphic.IPolymorphicHelperAttribute.get_Target();
    [CompilerGeneratedAttribute]
public sealed virtual string get_TypeCode();
    [CompilerGeneratedAttribute]
private void set_TypeCode(string value);
    [CompilerGeneratedAttribute]
public sealed virtual Type get_BindingType();
    [CompilerGeneratedAttribute]
private void set_BindingType(Type value);
}
[AttributeUsageAttribute("1420")]
public class MsgPack.Serialization.MessagePackKnownDictionaryKeyTypeAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <TypeCode>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <BindingType>k__BackingField;
    private PolymorphismTarget MsgPack.Serialization.Polymorphic.IPolymorphicHelperAttribute.Target { get; }
    public string TypeCode { get; private set; }
    public Type BindingType { get; private set; }
    public MessagePackKnownDictionaryKeyTypeAttribute(string typeCode, Type bindingType);
    private sealed virtual override PolymorphismTarget MsgPack.Serialization.Polymorphic.IPolymorphicHelperAttribute.get_Target();
    [CompilerGeneratedAttribute]
public sealed virtual string get_TypeCode();
    [CompilerGeneratedAttribute]
private void set_TypeCode(string value);
    [CompilerGeneratedAttribute]
public sealed virtual Type get_BindingType();
    [CompilerGeneratedAttribute]
private void set_BindingType(Type value);
}
[AttributeUsageAttribute("384")]
public class MsgPack.Serialization.MessagePackKnownTupleItemTypeAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <TypeCode>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <BindingType>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ItemNumber>k__BackingField;
    private PolymorphismTarget MsgPack.Serialization.Polymorphic.IPolymorphicHelperAttribute.Target { get; }
    public string TypeCode { get; private set; }
    public Type BindingType { get; private set; }
    public int ItemNumber { get; private set; }
    public MessagePackKnownTupleItemTypeAttribute(int itemNumber, string typeCode, Type bindingType);
    private sealed virtual override PolymorphismTarget MsgPack.Serialization.Polymorphic.IPolymorphicHelperAttribute.get_Target();
    [CompilerGeneratedAttribute]
public sealed virtual string get_TypeCode();
    [CompilerGeneratedAttribute]
private void set_TypeCode(string value);
    [CompilerGeneratedAttribute]
public sealed virtual Type get_BindingType();
    [CompilerGeneratedAttribute]
private void set_BindingType(Type value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_ItemNumber();
    [CompilerGeneratedAttribute]
private void set_ItemNumber(int value);
}
[AttributeUsageAttribute("1420")]
public class MsgPack.Serialization.MessagePackKnownTypeAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <TypeCode>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <BindingType>k__BackingField;
    private PolymorphismTarget MsgPack.Serialization.Polymorphic.IPolymorphicHelperAttribute.Target { get; }
    public string TypeCode { get; private set; }
    public Type BindingType { get; private set; }
    public MessagePackKnownTypeAttribute(string typeCode, Type bindingType);
    private sealed virtual override PolymorphismTarget MsgPack.Serialization.Polymorphic.IPolymorphicHelperAttribute.get_Target();
    [CompilerGeneratedAttribute]
public sealed virtual string get_TypeCode();
    [CompilerGeneratedAttribute]
private void set_TypeCode(string value);
    [CompilerGeneratedAttribute]
public sealed virtual Type get_BindingType();
    [CompilerGeneratedAttribute]
private void set_BindingType(Type value);
}
[AttributeUsageAttribute("384")]
public class MsgPack.Serialization.MessagePackMemberAttribute : Attribute {
    private int _id;
    private string _name;
    private NilImplication _nilImplication;
    public int Id { get; }
    public string Name { get; public set; }
    public NilImplication NilImplication { get; public set; }
    public MessagePackMemberAttribute(int id);
    public int get_Id();
    public string get_Name();
    public void set_Name(string value);
    public NilImplication get_NilImplication();
    public void set_NilImplication(NilImplication value);
}
[AttributeUsageAttribute("1420")]
public class MsgPack.Serialization.MessagePackRuntimeCollectionItemTypeAttribute : Attribute {
    [CompilerGeneratedAttribute]
private Type <VerifierType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <VerifierMethodName>k__BackingField;
    private PolymorphismTarget MsgPack.Serialization.Polymorphic.IPolymorphicHelperAttribute.Target { get; }
    public Type VerifierType { get; public set; }
    public string VerifierMethodName { get; public set; }
    private sealed virtual override PolymorphismTarget MsgPack.Serialization.Polymorphic.IPolymorphicHelperAttribute.get_Target();
    [CompilerGeneratedAttribute]
public sealed virtual Type get_VerifierType();
    [CompilerGeneratedAttribute]
public void set_VerifierType(Type value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_VerifierMethodName();
    [CompilerGeneratedAttribute]
public void set_VerifierMethodName(string value);
}
[AttributeUsageAttribute("1420")]
public class MsgPack.Serialization.MessagePackRuntimeDictionaryKeyTypeAttribute : Attribute {
    [CompilerGeneratedAttribute]
private Type <VerifierType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <VerifierMethodName>k__BackingField;
    private PolymorphismTarget MsgPack.Serialization.Polymorphic.IPolymorphicHelperAttribute.Target { get; }
    public Type VerifierType { get; public set; }
    public string VerifierMethodName { get; public set; }
    private sealed virtual override PolymorphismTarget MsgPack.Serialization.Polymorphic.IPolymorphicHelperAttribute.get_Target();
    [CompilerGeneratedAttribute]
public sealed virtual Type get_VerifierType();
    [CompilerGeneratedAttribute]
public void set_VerifierType(Type value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_VerifierMethodName();
    [CompilerGeneratedAttribute]
public void set_VerifierMethodName(string value);
}
[AttributeUsageAttribute("384")]
public class MsgPack.Serialization.MessagePackRuntimeTupleItemTypeAttribute : Attribute {
    [CompilerGeneratedAttribute]
private Type <VerifierType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <VerifierMethodName>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ItemNumber>k__BackingField;
    private PolymorphismTarget MsgPack.Serialization.Polymorphic.IPolymorphicHelperAttribute.Target { get; }
    public Type VerifierType { get; public set; }
    public string VerifierMethodName { get; public set; }
    public int ItemNumber { get; private set; }
    public MessagePackRuntimeTupleItemTypeAttribute(int itemNumber);
    private sealed virtual override PolymorphismTarget MsgPack.Serialization.Polymorphic.IPolymorphicHelperAttribute.get_Target();
    [CompilerGeneratedAttribute]
public sealed virtual Type get_VerifierType();
    [CompilerGeneratedAttribute]
public void set_VerifierType(Type value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_VerifierMethodName();
    [CompilerGeneratedAttribute]
public void set_VerifierMethodName(string value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_ItemNumber();
    [CompilerGeneratedAttribute]
private void set_ItemNumber(int value);
}
[AttributeUsageAttribute("1420")]
public class MsgPack.Serialization.MessagePackRuntimeTypeAttribute : Attribute {
    [CompilerGeneratedAttribute]
private Type <VerifierType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <VerifierMethodName>k__BackingField;
    private PolymorphismTarget MsgPack.Serialization.Polymorphic.IPolymorphicHelperAttribute.Target { get; }
    public Type VerifierType { get; public set; }
    public string VerifierMethodName { get; public set; }
    private sealed virtual override PolymorphismTarget MsgPack.Serialization.Polymorphic.IPolymorphicHelperAttribute.get_Target();
    [CompilerGeneratedAttribute]
public sealed virtual Type get_VerifierType();
    [CompilerGeneratedAttribute]
public void set_VerifierType(Type value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_VerifierMethodName();
    [CompilerGeneratedAttribute]
public void set_VerifierMethodName(string value);
}
public abstract class MsgPack.Serialization.MessagePackSerializer : object {
    internal static UnpackerOptions DefaultUnpackerOptions;
    internal static int BufferSize;
    private SerializationContext _ownerContext;
    private Nullable`1<PackerCompatibilityOptions> _packerCompatibilityOptionsForCompatibility;
    private SerializerCapabilities _capabilities;
    private static object _syncRoot;
    private static Dictionary`2<Type, Func`2<SerializationContext, MessagePackSerializer>> _creatorCache;
    private static MethodInfo CreateInternal_2;
    private static MessagePackSerializer`1<MessagePackObject> _singleTonMpoDeserializer;
    protected internal SerializationContext OwnerContext { get; }
    protected internal PackerCompatibilityOptions PackerCompatibilityOptions { get; }
    public SerializerCapabilities Capabilities { get; }
    internal MessagePackSerializer(SerializationContext ownerContext, Nullable`1<PackerCompatibilityOptions> packerCompatibilityOptions, SerializerCapabilities capabilities);
    private static MessagePackSerializer();
    protected internal SerializationContext get_OwnerContext();
    protected internal PackerCompatibilityOptions get_PackerCompatibilityOptions();
    public SerializerCapabilities get_Capabilities();
    internal virtual SerializerCapabilities InternalGetCapabilities();
    public sealed virtual void PackTo(Packer packer, object objectTree);
    internal abstract virtual void InternalPackTo(Packer packer, object objectTree);
    public sealed virtual object UnpackFrom(Unpacker unpacker);
    internal abstract virtual object InternalUnpackFrom(Unpacker unpacker);
    public sealed virtual void UnpackTo(Unpacker unpacker, object collection);
    internal abstract virtual void InternalUnpackTo(Unpacker unpacker, object collection);
    public sealed virtual Byte[] PackSingleObject(object objectTree);
    internal abstract virtual Byte[] InternalPackSingleObject(object objectTree);
    public sealed virtual object UnpackSingleObject(Byte[] buffer);
    internal abstract virtual object InternalUnpackSingleObject(Byte[] buffer);
    internal static void ThrowArgumentNullException(string parameterName);
    [ObsoleteAttribute("Use Get<T>() instead.")]
public static MessagePackSerializer`1<T> Create();
    [ObsoleteAttribute("Use Get<T>(SerializationContext) instead.")]
public static MessagePackSerializer`1<T> Create(SerializationContext context);
    public static MessagePackSerializer`1<T> Get();
    public static MessagePackSerializer`1<T> Get(object providerParameter);
    public static MessagePackSerializer`1<T> Get(SerializationContext context);
    public static MessagePackSerializer`1<T> Get(SerializationContext context, object providerParameter);
    internal static MessagePackSerializer`1<T> CreateInternal(SerializationContext context, PolymorphismSchema schema);
    [ObsoleteAttribute("Use Get(Type) instead.")]
public static IMessagePackSingleObjectSerializer Create(Type targetType);
    [ObsoleteAttribute("Use Get(Type,SerializationContext) instead.")]
public static MessagePackSerializer Create(Type targetType, SerializationContext context);
    public static MessagePackSerializer Get(Type targetType);
    public static MessagePackSerializer Get(Type targetType, object providerParameter);
    public static MessagePackSerializer Get(Type targetType, SerializationContext context);
    public static MessagePackSerializer Get(Type targetType, SerializationContext context, object providerParameter);
    internal static MessagePackSerializer CreateInternal(SerializationContext context, Type targetType, PolymorphismSchema schema);
    internal static MessagePackSerializer`1<T> CreateReflectionInternal(SerializationContext context, Type concreteType, PolymorphismSchema schema);
    private static void ValidateType(Type type);
    public static MessagePackObject UnpackMessagePackObject(Stream stream);
    public static MessagePackObject UnpackMessagePackObject(Byte[] buffer);
    public static void PrepareType();
    public static void PrepareDictionaryType();
    public static void PrepareCollectionType();
}
public abstract class MsgPack.Serialization.MessagePackSerializer`1 : MessagePackSerializer {
    private static bool IsNullable;
    [ObsoleteAttribute("Use MessagePackSerializer (SerlaizationContext, PackerCompatibilityOptions) instead.")]
protected MessagePackSerializer`1(PackerCompatibilityOptions packerCompatibilityOptions);
    protected MessagePackSerializer`1(SerializationContext ownerContext);
    protected MessagePackSerializer`1(SerializationContext ownerContext, PackerCompatibilityOptions packerCompatibilityOptions);
    protected MessagePackSerializer`1(SerializationContext ownerContext, SerializerCapabilities capabilities);
    protected MessagePackSerializer`1(SerializationContext ownerContext, PackerCompatibilityOptions packerCompatibilityOptions, SerializerCapabilities capabilities);
    private static MessagePackSerializer`1();
    private static bool JudgeNullable();
    private static SerializerCapabilities InferCapatibity();
    public void Pack(Stream stream, T objectTree);
    public T Unpack(Stream stream);
    public void PackTo(Packer packer, T objectTree);
    protected internal abstract virtual void PackToCore(Packer packer, T objectTree);
    public T UnpackFrom(Unpacker unpacker);
    protected internal virtual T UnpackNil();
    protected internal abstract virtual T UnpackFromCore(Unpacker unpacker);
    public void UnpackTo(Unpacker unpacker, T collection);
    protected internal virtual void UnpackToCore(Unpacker unpacker, T collection);
    public Byte[] PackSingleObject(T objectTree);
    public ArraySegment`1<byte> PackSingleObjectAsBytes(T objectTree);
    public T UnpackSingleObject(Byte[] buffer);
    internal sealed virtual void InternalPackTo(Packer packer, object objectTree);
    internal sealed virtual object InternalUnpackFrom(Unpacker unpacker);
    internal sealed virtual void InternalUnpackTo(Unpacker unpacker, object collection);
    internal sealed virtual Byte[] InternalPackSingleObject(object objectTree);
    internal sealed virtual object InternalUnpackSingleObject(Byte[] buffer);
    private static void ThrowArgumentException(string message, string parameterName);
    private static void ThrowNewValueTypeCannotBeNullException();
}
[ExtensionAttribute]
public static class MsgPack.Serialization.MessagePackSerializerExtensions : object {
    [ExtensionAttribute]
public static void Pack(MessagePackSerializer source, Stream stream, object objectTree);
    [ExtensionAttribute]
public static void Pack(MessagePackSerializer source, Stream stream, object objectTree, PackerCompatibilityOptions packerCompatibilityOptions);
    [ExtensionAttribute]
public static object Unpack(MessagePackSerializer source, Stream stream);
    [ExtensionAttribute]
public static MessagePackObject ToMessagePackObject(MessagePackSerializer source, object obj);
    [ExtensionAttribute]
public static MessagePackObject ToMessagePackObject(MessagePackSerializer`1<T> source, T obj);
    [ExtensionAttribute]
public static object FromMessagePackObject(MessagePackSerializer source, MessagePackObject mpo);
    [ExtensionAttribute]
public static T FromMessagePackObject(MessagePackSerializer`1<T> source, MessagePackObject mpo);
}
internal abstract class MsgPack.Serialization.MessagePackSerializerProvider : object {
    public abstract virtual object Get(SerializationContext context, object providerParameter);
}
public enum MsgPack.Serialization.NilImplication : Enum {
    public int value__;
    public static NilImplication MemberDefault;
    public static NilImplication Null;
    public static NilImplication Prohibit;
}
internal abstract class MsgPack.Serialization.NilImplicationHandler`4 : object {
    public TAction OnPacking(TPackingParameter parameter, NilImplication nilImplication);
    protected abstract virtual TCondition OnPackingMessagePackObject(TPackingParameter parameter);
    protected abstract virtual TCondition OnPackingReferenceTypeObject(TPackingParameter parameter);
    protected abstract virtual TCondition OnPackingNullableValueTypeObject(TPackingParameter parameter);
    protected abstract virtual TAction OnPackingCore(TPackingParameter parameter, TCondition condition);
    public TAction OnUnpacked(TUnpackedParameter parameter, NilImplication nilImplication);
    protected abstract virtual TAction OnNopOnUnpacked(TUnpackedParameter parameter);
    protected abstract virtual TAction OnThrowNullIsProhibitedExceptionOnUnpacked(TUnpackedParameter parameter);
    protected abstract virtual TAction OnThrowValueTypeCannotBeNull3OnUnpacked(TUnpackedParameter parameter);
}
internal class MsgPack.Serialization.NullTextWriter : TextWriter {
    internal static NullTextWriter Instance;
    public Encoding Encoding { get; }
    private static NullTextWriter();
    public virtual Encoding get_Encoding();
    public virtual void Close();
    public virtual void Flush();
    public virtual void Write(char value);
    public virtual void Write(Char[] buffer);
    public virtual void Write(Char[] buffer, int index, int count);
    public virtual void Write(bool value);
    public virtual void Write(int value);
    public virtual void Write(UInt32 value);
    public virtual void Write(long value);
    public virtual void Write(ulong value);
    public virtual void Write(float value);
    public virtual void Write(double value);
    public virtual void Write(decimal value);
    public virtual void Write(string value);
    public virtual void Write(object value);
    public virtual void Write(string format, object arg0);
    public virtual void Write(string format, object arg0, object arg1);
    public virtual void Write(string format, Object[] arg);
    public virtual void WriteLine();
    public virtual void WriteLine(char value);
    public virtual void WriteLine(Char[] buffer);
    public virtual void WriteLine(Char[] buffer, int index, int count);
    public virtual void WriteLine(bool value);
    public virtual void WriteLine(int value);
    public virtual void WriteLine(UInt32 value);
    public virtual void WriteLine(long value);
    public virtual void WriteLine(ulong value);
    public virtual void WriteLine(float value);
    public virtual void WriteLine(double value);
    public virtual void WriteLine(decimal value);
    public virtual void WriteLine(string value);
    public virtual void WriteLine(object value);
    public virtual void WriteLine(string format, object arg0);
    public virtual void WriteLine(string format, object arg0, object arg1);
    public virtual void WriteLine(string format, Object[] arg);
}
[EditorBrowsableAttribute("1")]
public static class MsgPack.Serialization.PackHelpers : object {
    [EditorBrowsableAttribute("1")]
public static void PackToArray(Packer packer, TObject target, IList`1<Action`2<Packer, TObject>> operations);
    [EditorBrowsableAttribute("1")]
public static void PackToArray(PackToArrayParameters`1& parameter);
    [EditorBrowsableAttribute("1")]
public static void PackToMap(Packer packer, TObject target, IDictionary`2<string, Action`2<Packer, TObject>> operations);
    [EditorBrowsableAttribute("1")]
public static void PackToMap(PackToMapParameters`1& parameter);
}
[EditorBrowsableAttribute("1")]
public class MsgPack.Serialization.PackToArrayParameters`1 : ValueType {
    public Packer Packer;
    public T Target;
    public IList`1<Action`2<Packer, T>> Operations;
}
[EditorBrowsableAttribute("1")]
public class MsgPack.Serialization.PackToMapParameters`1 : ValueType {
    public Packer Packer;
    public T Target;
    public SerializationContext SerializationContext;
    public IDictionary`2<string, Func`2<T, bool>> NullCheckers;
    public IDictionary`2<string, Action`2<Packer, T>> Operations;
}
internal interface MsgPack.Serialization.Polymorphic.IPolymorphicDeserializer {
    public abstract virtual object PolymorphicUnpackFrom(Unpacker unpacker);
}
internal interface MsgPack.Serialization.Polymorphic.IPolymorphicHelperAttribute {
    public PolymorphismTarget Target { get; }
    public abstract virtual PolymorphismTarget get_Target();
}
internal interface MsgPack.Serialization.Polymorphic.IPolymorphicKnownTypeAttribute {
    public Type BindingType { get; }
    public string TypeCode { get; }
    public abstract virtual Type get_BindingType();
    public abstract virtual string get_TypeCode();
}
internal interface MsgPack.Serialization.Polymorphic.IPolymorphicRuntimeTypeAttribute {
    public Type VerifierType { get; }
    public string VerifierMethodName { get; }
    public abstract virtual Type get_VerifierType();
    public abstract virtual string get_VerifierMethodName();
}
internal interface MsgPack.Serialization.Polymorphic.IPolymorphicTupleItemTypeAttribute {
    public int ItemNumber { get; }
    public abstract virtual int get_ItemNumber();
}
internal class MsgPack.Serialization.Polymorphic.KnownTypePolymorphicMessagePackSerializer`1 : MessagePackSerializer`1<T> {
    private PolymorphismSchema _schema;
    private IDictionary`2<string, RuntimeTypeHandle> _typeHandleMap;
    private IDictionary`2<RuntimeTypeHandle, string> _typeCodeMap;
    public KnownTypePolymorphicMessagePackSerializer`1(SerializationContext ownerContext, PolymorphismSchema schema);
    private static IDictionary`2<string, RuntimeTypeHandle> BuildTypeCodeTypeHandleMap(IDictionary`2<string, Type> typeMap);
    private static IDictionary`2<RuntimeTypeHandle, string> BuildTypeHandleTypeCodeMap(IDictionary`2<string, Type> typeMap);
    private MessagePackSerializer GetActualTypeSerializer(Type actualType);
    protected internal virtual void PackToCore(Packer packer, T objectTree);
    private string GetTypeCode(T objectTree);
    protected internal virtual T UnpackFromCore(Unpacker unpacker);
    private Type GetTypeFromCode(string typeCode);
    private sealed virtual override object MsgPack.Serialization.Polymorphic.IPolymorphicDeserializer.PolymorphicUnpackFrom(Unpacker unpacker);
    protected internal virtual void UnpackToCore(Unpacker unpacker, T collection);
    [CompilerGeneratedAttribute]
private Type <UnpackFromCore>b__9_0(string c);
    [CompilerGeneratedAttribute]
private T <UnpackFromCore>b__9_1(Type t, Unpacker u);
}
internal class MsgPack.Serialization.Polymorphic.PolymorphicSerializerProvider`1 : MessagePackSerializerProvider {
    private MessagePackSerializer`1<T> _defaultSerializer;
    private PolymorphismSchema _defaultSchema;
    public PolymorphicSerializerProvider`1(MessagePackSerializer`1<T> defaultSerializer);
    public virtual object Get(SerializationContext context, object providerParameter);
}
internal static class MsgPack.Serialization.Polymorphic.RuntimeTypeVerifier : object {
    private static int CacheSize;
    private static ReaderWriterLockSlim _resultCacheLock;
    private static Dictionary`2<KeyValuePair`2<string, string>, bool> _resultCache;
    private static Queue`1<KeyValuePair`2<string, string>> _histories;
    private static RuntimeTypeVerifier();
    public static void Verify(AssemblyName assemblyName, string typeFullName, Func`2<PolymorphicTypeVerificationContext, bool> typeVerifier);
    private static bool VerifyCore(AssemblyName assemblyName, string assemblyFullName, string typeFullName, Func`2<PolymorphicTypeVerificationContext, bool> typeVerifier);
}
internal class MsgPack.Serialization.Polymorphic.TypeEmbedingPolymorphicMessagePackSerializer`1 : MessagePackSerializer`1<T> {
    private PolymorphismSchema _schema;
    public TypeEmbedingPolymorphicMessagePackSerializer`1(SerializationContext ownerContext, PolymorphismSchema schema);
    private MessagePackSerializer GetActualTypeSerializer(Type actualType);
    protected internal virtual void PackToCore(Packer packer, T objectTree);
    protected internal virtual T UnpackFromCore(Unpacker unpacker);
    private sealed virtual override object MsgPack.Serialization.Polymorphic.IPolymorphicDeserializer.PolymorphicUnpackFrom(Unpacker unpacker);
    protected internal virtual void UnpackToCore(Unpacker unpacker, T collection);
    [CompilerGeneratedAttribute]
private Type <UnpackFromCore>b__4_0(Unpacker u);
    [CompilerGeneratedAttribute]
private T <UnpackFromCore>b__4_1(Type t, Unpacker u);
}
internal static class MsgPack.Serialization.Polymorphic.TypeInfoEncoder : object {
    private static string Elipsis;
    public static void Encode(Packer packer, string typeCode);
    public static void Encode(Packer packer, Type type);
    public static T Decode(Unpacker unpacker, Func`2<string, Type> typeFinder, Func`3<Type, Unpacker, T> unpacking);
    public static T Decode(Unpacker unpacker, Func`2<Unpacker, Type> typeDecoder, Func`3<Type, Unpacker, T> unpacking);
    public static Type DecodeRuntimeTypeInfo(Unpacker unpacker, Func`2<PolymorphicTypeVerificationContext, bool> typeVerifier);
    private static void ThrowFailedToDecodeEncodingType();
    private static void ThrowUnknownEncodingType(byte encodeType);
    private static void ThrowFailedToDecodeCompressedTypeName();
    private static void ThrowFailedToDecodeAssemblySimpleName();
    private static void ThrowFailedToDecodeAssemblyVersion();
    private static void ThrowFailedToDecodeAssemblyCulture();
    private static void ThrowFailedToDecodeAssemblyKeyToken();
    private static void CheckUnpackerForRuntimeTypeInfoDecoding(Unpacker unpacker);
    private static void ThrowEncodedTypeIsNotInNonNillArray();
    private static void ThrowEncodedTypeDoesNotHaveValidArrayItems();
    private static AssemblyName BuildAssemblyName(string assemblySimpleName, Byte[] version, string culture, Byte[] publicKeyToken);
    private static string DecompressTypeName(string assemblySimpleName, string compressedTypeName);
    private static Type LoadDecodedType(AssemblyName assemblyName, string typeFullName);
}
internal enum MsgPack.Serialization.Polymorphic.TypeInfoEncoding : Enum {
    public byte value__;
    public static TypeInfoEncoding KnownType;
    public static TypeInfoEncoding RawCompressed;
}
public class MsgPack.Serialization.PolymorphicTypeVerificationContext : ValueType {
    private string _loadingTypeFullName;
    private string _loadingAssemblyFullName;
    private AssemblyName _loadingAssemblyName;
    public string LoadingTypeFullName { get; }
    public string LoadingAssemblyFullName { get; }
    public AssemblyName LoadingAssemblyName { get; }
    internal PolymorphicTypeVerificationContext(string loadingTypeFullName, AssemblyName loadingAssemblyName, string loadingAssemblyFullName);
    public string get_LoadingTypeFullName();
    public string get_LoadingAssemblyFullName();
    public AssemblyName get_LoadingAssemblyName();
    public virtual string ToString();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(PolymorphicTypeVerificationContext other);
    public virtual int GetHashCode();
    public static bool op_Equality(PolymorphicTypeVerificationContext left, PolymorphicTypeVerificationContext right);
    public static bool op_Inequality(PolymorphicTypeVerificationContext left, PolymorphicTypeVerificationContext right);
}
[DebuggerDisplayAttribute("{DebugString}")]
public class MsgPack.Serialization.PolymorphismSchema : object {
    private static Dictionary`2<string, Type> EmptyMap;
    private static PolymorphismSchema[] EmptyChildren;
    [CompilerGeneratedAttribute]
private Type <TargetType>k__BackingField;
    [CompilerGeneratedAttribute]
private PolymorphismType <PolymorphismType>k__BackingField;
    private ReadOnlyDictionary`2<string, Type> _codeTypeMapping;
    [CompilerGeneratedAttribute]
private Func`2<PolymorphicTypeVerificationContext, bool> <TypeVerifier>k__BackingField;
    [CompilerGeneratedAttribute]
private PolymorphismSchemaChildrenType <ChildrenType>k__BackingField;
    private ReadOnlyCollection`1<PolymorphismSchema> _children;
    private static Func`2<PolymorphicTypeVerificationContext, bool> DefaultTypeVerfiier;
    internal static PolymorphismSchema Default;
    internal static MethodInfo ForPolymorphicObjectTypeEmbeddingMethod;
    internal static MethodInfo ForPolymorphicObjectCodeTypeMappingMethod;
    internal static MethodInfo ForContextSpecifiedCollectionMethod;
    internal static MethodInfo ForPolymorphicCollectionTypeEmbeddingMethod;
    internal static MethodInfo ForPolymorphicCollectionCodeTypeMappingMethod;
    internal static MethodInfo ForContextSpecifiedDictionaryMethod;
    internal static MethodInfo ForPolymorphicDictionaryTypeEmbeddingMethod;
    internal static MethodInfo ForPolymorphicDictionaryCodeTypeMappingMethod;
    internal static MethodInfo ForPolymorphicTupleMethod;
    internal static ConstructorInfo CodeTypeMapConstructor;
    internal static MethodInfo AddToCodeTypeMapMethod;
    internal Type TargetType { get; private set; }
    internal PolymorphismType PolymorphismType { get; private set; }
    internal IDictionary`2<string, Type> CodeTypeMapping { get; }
    internal bool UseDefault { get; }
    internal bool UseTypeEmbedding { get; }
    internal Func`2<PolymorphicTypeVerificationContext, bool> TypeVerifier { get; private set; }
    internal PolymorphismSchemaChildrenType ChildrenType { get; private set; }
    internal IList`1<PolymorphismSchema> ChildSchemaList { get; }
    internal PolymorphismSchema ItemSchema { get; }
    internal PolymorphismSchema KeySchema { get; }
    internal string DebugString { get; }
    private PolymorphismSchema(Type targetType, PolymorphismType polymorphismType, Func`2<PolymorphicTypeVerificationContext, bool> typeVerifier, PolymorphismSchemaChildrenType childrenType, PolymorphismSchema[] childItemSchemaList);
    private PolymorphismSchema(Type targetType, PolymorphismType polymorphismType, IDictionary`2<string, Type> codeTypeMapping, Func`2<PolymorphicTypeVerificationContext, bool> typeVerifier, PolymorphismSchemaChildrenType childrenType, PolymorphismSchema[] childItemSchemaList);
    private PolymorphismSchema(Type targetType, PolymorphismType polymorphismType, ReadOnlyDictionary`2<string, Type> codeTypeMapping, Func`2<PolymorphicTypeVerificationContext, bool> typeVerifier, PolymorphismSchemaChildrenType childrenType, ReadOnlyCollection`1<PolymorphismSchema> childItemSchemaList);
    private static PolymorphismSchema();
    public static PolymorphismSchema ForPolymorphicObject(Type targetType);
    public static PolymorphismSchema ForPolymorphicObject(Type targetType, Func`2<PolymorphicTypeVerificationContext, bool> typeVerifier);
    public static PolymorphismSchema ForPolymorphicObject(Type targetType, IDictionary`2<string, Type> codeTypeMapping);
    public static PolymorphismSchema ForContextSpecifiedCollection(Type targetType, PolymorphismSchema itemSchema);
    public static PolymorphismSchema ForPolymorphicCollection(Type targetType, PolymorphismSchema itemSchema);
    public static PolymorphismSchema ForPolymorphicCollection(Type targetType, PolymorphismSchema itemSchema, Func`2<PolymorphicTypeVerificationContext, bool> typeVerifier);
    public static PolymorphismSchema ForPolymorphicCollection(Type targetType, IDictionary`2<string, Type> codeTypeMapping, PolymorphismSchema itemSchema);
    public static PolymorphismSchema ForContextSpecifiedDictionary(Type targetType, PolymorphismSchema keySchema, PolymorphismSchema valueSchema);
    public static PolymorphismSchema ForPolymorphicDictionary(Type targetType, PolymorphismSchema keySchema, PolymorphismSchema valueSchema);
    public static PolymorphismSchema ForPolymorphicDictionary(Type targetType, PolymorphismSchema keySchema, PolymorphismSchema valueSchema, Func`2<PolymorphicTypeVerificationContext, bool> typeVerifier);
    public static PolymorphismSchema ForPolymorphicDictionary(Type targetType, IDictionary`2<string, Type> codeTypeMapping, PolymorphismSchema keySchema, PolymorphismSchema valueSchema);
    public static PolymorphismSchema ForPolymorphicTuple(Type targetType, PolymorphismSchema[] itemSchemaList);
    private static void VerifyArity(Type tupleType, ICollection`1<PolymorphismSchema> itemSchemaList);
    internal PolymorphismSchema FilterSelf();
    [CompilerGeneratedAttribute]
internal Type get_TargetType();
    [CompilerGeneratedAttribute]
private void set_TargetType(Type value);
    [CompilerGeneratedAttribute]
internal PolymorphismType get_PolymorphismType();
    [CompilerGeneratedAttribute]
private void set_PolymorphismType(PolymorphismType value);
    internal IDictionary`2<string, Type> get_CodeTypeMapping();
    internal bool get_UseDefault();
    internal bool get_UseTypeEmbedding();
    [CompilerGeneratedAttribute]
internal Func`2<PolymorphicTypeVerificationContext, bool> get_TypeVerifier();
    [CompilerGeneratedAttribute]
private void set_TypeVerifier(Func`2<PolymorphicTypeVerificationContext, bool> value);
    [CompilerGeneratedAttribute]
internal PolymorphismSchemaChildrenType get_ChildrenType();
    [CompilerGeneratedAttribute]
private void set_ChildrenType(PolymorphismSchemaChildrenType value);
    internal IList`1<PolymorphismSchema> get_ChildSchemaList();
    internal PolymorphismSchema get_ItemSchema();
    private PolymorphismSchema TryGetItemSchema();
    internal PolymorphismSchema get_KeySchema();
    private PolymorphismSchema TryGetKeySchema();
    internal string get_DebugString();
    private void ToDebugString(StringBuilder buffer);
    internal static PolymorphismSchema Create(Type type, Nullable`1<SerializingMember> memberMayBeNull);
    private static PolymorphismSchema CreateCore(MemberInfo member, PolymorphismSchema defaultSchema);
}
internal enum MsgPack.Serialization.PolymorphismSchemaChildrenType : Enum {
    public int value__;
    public static PolymorphismSchemaChildrenType None;
    public static PolymorphismSchemaChildrenType CollectionItems;
    public static PolymorphismSchemaChildrenType DictionaryKeyValues;
    public static PolymorphismSchemaChildrenType TupleItems;
}
internal enum MsgPack.Serialization.PolymorphismTarget : Enum {
    public int value__;
    public static PolymorphismTarget Member;
    public static PolymorphismTarget CollectionItem;
    public static PolymorphismTarget DictionaryKey;
    public static PolymorphismTarget TupleItem;
}
internal enum MsgPack.Serialization.PolymorphismType : Enum {
    public int value__;
    public static PolymorphismType None;
    public static PolymorphismType KnownTypes;
    public static PolymorphismType RuntimeType;
}
[ExtensionAttribute]
internal static class MsgPack.Serialization.Reflection.GenericTypeExtensions : object {
    [ExtensionAttribute]
public static bool Implements(Type source, Type genericType);
    private static IEnumerable`1<Type> EnumerateGenericIntefaces(Type source, Type genericType, bool includesOwn);
    [ExtensionAttribute]
public static string GetName(Type source);
    [ExtensionAttribute]
public static string GetFullName(Type source);
}
[ExtensionAttribute]
internal static class MsgPack.Serialization.Reflection.ReflectionExtensions : object {
    [ExtensionAttribute]
public static bool IsAssignableTo(Type source, Type target);
}
[ExtensionAttribute]
internal static class MsgPack.Serialization.ReflectionExtensions : object {
    private static Type[] ExceptionConstructorWithInnerParameterTypes;
    private static Type[] ObjectAddParameterTypes;
    private static ReflectionExtensions();
    [ExtensionAttribute]
internal static CollectionTraits GetCollectionTraits(Type source, CollectionTraitOptions options, bool allowNonCollectionEnumerableTypes);
    private static bool TryCreateCollectionTraitsForIEnumerableT(Type source, GenericCollectionTypes genericTypes, CollectionTraitOptions options, MethodInfo getMethod, CollectionTraits& result);
    private static bool TryCreateCollectionTraitsForHasGetEnumeratorType(Type source, CollectionTraitOptions options, MethodInfo getEnumerator, CollectionTraits& result);
    private static bool TryCreateGenericCollectionTraits(Type source, Type type, CollectionTraitOptions options, CollectionTraits& result);
    private static bool DetermineCollectionInterfaces(Type type, GenericCollectionTypes& genericTypes, Type& idictionary, Type& ilist, Type& icollection, Type& ienumerable);
    private static MethodInfo GetGetEnumeratorMethodFromElementType(Type targetType, Type elementType, CollectionTraitOptions options);
    private static MethodInfo GetGetEnumeratorMethodFromEnumerableType(Type targetType, Type enumerableType, CollectionTraitOptions options);
    private static MethodInfo FindInterfaceMethod(Type targetType, Type interfaceType, string name, Type[] parameterTypes);
    private static MethodInfo GetAddMethod(Type targetType, Type argumentType, CollectionTraitOptions options);
    private static MethodInfo GetCountGetterMethod(Type targetType, Type elementType, CollectionTraitOptions options);
    private static MethodInfo GetAddMethod(Type targetType, Type keyType, Type valueType, CollectionTraitOptions options);
    private static bool FilterCollectionType(Type type, object filterCriteria);
    private static bool IsIEnumeratorT(Type interface);
    [IteratorStateMachineAttribute("MsgPack.Serialization.ReflectionExtensions/<FindInterfaces>d__13")]
[ExtensionAttribute]
public static IEnumerable`1<Type> FindInterfaces(Type source, Func`3<Type, object, bool> filter, object criterion);
    [ExtensionAttribute]
public static bool GetHasPublicGetter(MemberInfo source);
    [ExtensionAttribute]
public static bool GetHasPublicSetter(MemberInfo source);
    [ExtensionAttribute]
public static bool GetIsPublic(MemberInfo source);
    [ExtensionAttribute]
public static Type[] GetParameterTypes(MethodBase source);
    [ExtensionAttribute]
public static Type GetMemberValueType(MemberInfo source);
    [ExtensionAttribute]
public static object InvokePreservingExceptionType(ConstructorInfo source, Object[] parameters);
    [ExtensionAttribute]
public static object InvokePreservingExceptionType(MethodInfo source, object instance, Object[] parameters);
    public static T CreateInstancePreservingExceptionType(Type instanceType, Object[] constructorParameters);
    public static object CreateInstancePreservingExceptionType(Type type, Object[] constructorParameters);
    private static Exception HoistUpInnerException(TargetInvocationException targetInvocationException);
}
[EditorBrowsableAttribute("1")]
public static class MsgPack.Serialization.ReflectionHelpers : object {
    [EditorBrowsableAttribute("1")]
public static MethodInfo GetMethod(Type type, string name, Type[] parameterTypes);
    [EditorBrowsableAttribute("1")]
public static FieldInfo GetField(Type type, string name);
}
[PreserveAttribute]
internal class MsgPack.Serialization.ReflectionSerializers.ReflectionCollectionMessagePackSerializer`2 : CollectionMessagePackSerializer`2<TCollection, TItem> {
    private Func`2<int, TCollection> _factory;
    private bool _isPackable;
    private bool _isUnpackable;
    public ReflectionCollectionMessagePackSerializer`2(SerializationContext ownerContext, Type targetType, CollectionTraits collectionTraits, PolymorphismSchema itemsSchema, SerializationTarget targetInfo);
    protected internal virtual void PackToCore(Packer packer, TCollection objectTree);
    protected internal virtual TCollection UnpackFromCore(Unpacker unpacker);
    protected virtual TCollection CreateInstance(int initialCapacity);
}
[PreserveAttribute]
internal class MsgPack.Serialization.ReflectionSerializers.ReflectionDictionaryMessagePackSerializer`3 : DictionaryMessagePackSerializer`3<TDictionary, TKey, TValue> {
    private Func`2<int, TDictionary> _factory;
    private bool _isPackable;
    private bool _isUnpackable;
    public ReflectionDictionaryMessagePackSerializer`3(SerializationContext ownerContext, Type targetType, CollectionTraits collectionTraits, PolymorphismSchema itemsSchema, SerializationTarget targetInfo);
    protected internal virtual void PackToCore(Packer packer, TDictionary objectTree);
    protected internal virtual TDictionary UnpackFromCore(Unpacker unpacker);
    protected virtual TDictionary CreateInstance(int initialCapacity);
}
[PreserveAttribute]
internal class MsgPack.Serialization.ReflectionSerializers.ReflectionEnumerableMessagePackSerializer`2 : EnumerableMessagePackSerializer`2<TCollection, TItem> {
    private Func`2<int, TCollection> _factory;
    private Action`2<TCollection, TItem> _addItem;
    private bool _isPackable;
    private bool _isUnpackable;
    public ReflectionEnumerableMessagePackSerializer`2(SerializationContext ownerContext, Type targetType, CollectionTraits collectionTraits, PolymorphismSchema itemsSchema, SerializationTarget targetInfo);
    protected internal virtual void PackToCore(Packer packer, TCollection objectTree);
    protected internal virtual TCollection UnpackFromCore(Unpacker unpacker);
    protected virtual TCollection CreateInstance(int initialCapacity);
    protected virtual void AddItem(TCollection collection, TItem item);
}
[PreserveAttribute]
internal class MsgPack.Serialization.ReflectionSerializers.ReflectionEnumMessagePackSerializer`1 : EnumMessagePackSerializer`1<T> {
    public ReflectionEnumMessagePackSerializer`1(SerializationContext context);
    protected internal virtual void PackUnderlyingValueTo(Packer packer, T enumValue);
    protected internal virtual T UnpackFromUnderlyingValue(MessagePackObject messagePackObject);
}
internal class MsgPack.Serialization.ReflectionSerializers.ReflectionNilImplicationHandler : NilImplicationHandler`4<Action`1<object>, Func`2<object, bool>, ReflectionSerializerNilImplicationHandlerParameter, ReflectionSerializerNilImplicationHandlerOnUnpackedParameter> {
    public static ReflectionNilImplicationHandler Instance;
    private static ReflectionNilImplicationHandler();
    protected virtual Func`2<object, bool> OnPackingMessagePackObject(ReflectionSerializerNilImplicationHandlerParameter parameter);
    protected virtual Func`2<object, bool> OnPackingReferenceTypeObject(ReflectionSerializerNilImplicationHandlerParameter parameter);
    protected virtual Func`2<object, bool> OnPackingNullableValueTypeObject(ReflectionSerializerNilImplicationHandlerParameter parameter);
    protected virtual Action`1<object> OnPackingCore(ReflectionSerializerNilImplicationHandlerParameter parameter, Func`2<object, bool> condition);
    protected virtual Action`1<object> OnNopOnUnpacked(ReflectionSerializerNilImplicationHandlerOnUnpackedParameter parameter);
    protected virtual Action`1<object> OnThrowNullIsProhibitedExceptionOnUnpacked(ReflectionSerializerNilImplicationHandlerOnUnpackedParameter parameter);
    protected virtual Action`1<object> OnThrowValueTypeCannotBeNull3OnUnpacked(ReflectionSerializerNilImplicationHandlerOnUnpackedParameter parameter);
}
[PreserveAttribute]
internal class MsgPack.Serialization.ReflectionSerializers.ReflectionNonGenericCollectionMessagePackSerializer`1 : NonGenericCollectionMessagePackSerializer`1<TCollection> {
    private Func`2<int, TCollection> _factory;
    private Action`2<TCollection, object> _addItem;
    private bool _isPackable;
    private bool _isUnpackable;
    public ReflectionNonGenericCollectionMessagePackSerializer`1(SerializationContext ownerContext, Type targetType, CollectionTraits collectionTraits, PolymorphismSchema itemsSchema, SerializationTarget targetInfo);
    protected internal virtual void PackToCore(Packer packer, TCollection objectTree);
    protected internal virtual TCollection UnpackFromCore(Unpacker unpacker);
    protected virtual TCollection CreateInstance(int initialCapacity);
    protected virtual void AddItem(TCollection collection, object item);
}
[PreserveAttribute]
internal class MsgPack.Serialization.ReflectionSerializers.ReflectionNonGenericDictionaryMessagePackSerializer`1 : NonGenericDictionaryMessagePackSerializer`1<TDictionary> {
    private Func`2<int, TDictionary> _factory;
    private bool _isPackable;
    private bool _isUnpackable;
    public ReflectionNonGenericDictionaryMessagePackSerializer`1(SerializationContext ownerContext, Type targetType, CollectionTraits collectionTraits, PolymorphismSchema itemsSchema, SerializationTarget targetInfo);
    protected internal virtual void PackToCore(Packer packer, TDictionary objectTree);
    protected internal virtual TDictionary UnpackFromCore(Unpacker unpacker);
    protected virtual TDictionary CreateInstance(int initialCapacity);
}
[PreserveAttribute]
internal class MsgPack.Serialization.ReflectionSerializers.ReflectionNonGenericEnumerableMessagePackSerializer`1 : NonGenericEnumerableMessagePackSerializer`1<TCollection> {
    private Func`2<int, TCollection> _factory;
    private Action`2<TCollection, object> _addItem;
    private bool _isPackable;
    private bool _isUnpackable;
    public ReflectionNonGenericEnumerableMessagePackSerializer`1(SerializationContext ownerContext, Type targetType, CollectionTraits collectionTraits, PolymorphismSchema itemsSchema, SerializationTarget targetInfo);
    protected internal virtual void PackToCore(Packer packer, TCollection objectTree);
    protected internal virtual TCollection UnpackFromCore(Unpacker unpacker);
    protected virtual TCollection CreateInstance(int initialCapacity);
    protected virtual void AddItem(TCollection collection, object item);
}
[PreserveAttribute]
internal class MsgPack.Serialization.ReflectionSerializers.ReflectionNonGenericListMessagePackSerializer`1 : NonGenericListMessagePackSerializer`1<TList> {
    private Func`2<int, TList> _factory;
    private bool _isPackable;
    private bool _isUnpackable;
    public ReflectionNonGenericListMessagePackSerializer`1(SerializationContext ownerContext, Type targetType, CollectionTraits collectionTraits, PolymorphismSchema itemsSchema, SerializationTarget targetInfo);
    protected internal virtual void PackToCore(Packer packer, TList objectTree);
    protected internal virtual TList UnpackFromCore(Unpacker unpacker);
    protected virtual TList CreateInstance(int initialCapacity);
}
[PreserveAttribute]
internal class MsgPack.Serialization.ReflectionSerializers.ReflectionObjectMessagePackSerializer`1 : MessagePackSerializer`1<T> {
    private Func`2[] _getters;
    private Action`2[] _setters;
    private MemberInfo[] _memberInfos;
    private DataMemberContract[] _contracts;
    private Dictionary`2<string, int> _memberIndexes;
    private MessagePackSerializer[] _serializers;
    private ParameterInfo[] _constructorParameters;
    private Dictionary`2<int, int> _constructorArgumentIndexes;
    public ReflectionObjectMessagePackSerializer`1(SerializationContext context, SerializationTarget target, SerializerCapabilities capabilities);
    protected internal virtual void PackToCore(Packer packer, T objectTree);
    private bool IsNull(T objectTree, int index);
    private void PackMemberValue(Packer packer, T objectTree, int index);
    protected internal virtual T UnpackFromCore(Unpacker unpacker);
    private object UnpackMemberValue(object objectGraph, Unpacker unpacker, int itemsCount, int unpacked, int index, int unpackerOffset);
    private object UnpackSingleValue(Unpacker unpacker, int index);
    private void UnpackAndAddCollectionItem(object objectGraph, Unpacker unpacker, int index);
}
internal static class MsgPack.Serialization.ReflectionSerializers.ReflectionSerializerHelper : object {
    internal static PropertyInfo DictionaryEntryKeyProperty;
    internal static PropertyInfo DictionaryEntryValueProperty;
    private static ReflectionSerializerHelper();
    public static MessagePackSerializer`1<T> CreateReflectionEnumMessagePackSerializer(SerializationContext context);
    public static MessagePackSerializer`1<T> CreateCollectionSerializer(SerializationContext context, Type targetType, CollectionTraits traits, PolymorphismSchema schema);
    public static Action`2<TCollection, TItem> GetAddItem(Type targetType, CollectionTraits collectionTraits);
    public static void GetMetadata(Type targetType, IList`1<SerializingMember> members, SerializationContext context, Func`2[]& getters, Action`2[]& setters, MemberInfo[]& memberInfos, DataMemberContract[]& contracts, MessagePackSerializer[]& serializers);
    private static void ThrowMissingGetterException(Type targetType, int number, PropertyInfo property);
    public static Func`2<int, T> CreateCollectionInstanceFactory(ConstructorInfo constructor);
}
internal class MsgPack.Serialization.ReflectionSerializers.ReflectionSerializerNilImplicationHandlerOnUnpackedParameter : ValueType {
    private Type _itemType;
    private Action`1<object> _store;
    public string MemberName;
    public Type DeclaringType;
    public Type ItemType { get; }
    public Action`1<object> Store { get; }
    public ReflectionSerializerNilImplicationHandlerOnUnpackedParameter(Type itemType, Action`1<object> store, string memberName, Type declaringType);
    public sealed virtual Type get_ItemType();
    public sealed virtual Action`1<object> get_Store();
}
internal class MsgPack.Serialization.ReflectionSerializers.ReflectionSerializerNilImplicationHandlerParameter : ValueType {
    private Type _itemType;
    private string _memberName;
    public Type ItemType { get; }
    public string MemberName { get; }
    public ReflectionSerializerNilImplicationHandlerParameter(Type itemType, string memberName);
    public sealed virtual Type get_ItemType();
    public string get_MemberName();
}
internal class MsgPack.Serialization.ReflectionSerializers.ReflectionTupleMessagePackSerializer`1 : MessagePackSerializer`1<T> {
    private IList`1<Type> _tupleTypes;
    private IList`1<ConstructorInfo> _tupleConstructors;
    private IList`1<Func`2<T, object>> _getters;
    private IList`1<MessagePackSerializer> _itemSerializers;
    public ReflectionTupleMessagePackSerializer`1(SerializationContext ownerContext, IList`1<PolymorphismSchema> itemSchemas);
    [IteratorStateMachineAttribute("MsgPack.Serialization.ReflectionSerializers.ReflectionTupleMessagePackSerializer`1/<GetGetters>d__5`2")]
private static IEnumerable`1<Func`2<T, object>> GetGetters(IList`1<Type> itemTypes, IList`1<Type> tupleTypes, Func`3<Type, string, TInfo> metadataFactory, Func`2<TInfo, TAccessor> accessorFactory, Func`2<IEnumerable`1<TAccessor>, Func`2<T, object>> chainedGetterFactory);
    protected internal virtual void PackToCore(Packer packer, T objectTree);
    protected internal virtual T UnpackFromCore(Unpacker unpacker);
    private T CreateTuple(IList`1<object> unpackedItems);
}
public class MsgPack.Serialization.ResolveSerializerEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private SerializationContext <Context>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <TargetType>k__BackingField;
    [CompilerGeneratedAttribute]
private PolymorphismSchema <PolymorphismSchema>k__BackingField;
    private MessagePackSerializer _foundSerializer;
    public SerializationContext Context { get; private set; }
    public Type TargetType { get; private set; }
    public PolymorphismSchema PolymorphismSchema { get; private set; }
    internal ResolveSerializerEventArgs(SerializationContext context, Type targetType, PolymorphismSchema schema);
    [CompilerGeneratedAttribute]
public SerializationContext get_Context();
    [CompilerGeneratedAttribute]
private void set_Context(SerializationContext value);
    [CompilerGeneratedAttribute]
public Type get_TargetType();
    [CompilerGeneratedAttribute]
private void set_TargetType(Type value);
    [CompilerGeneratedAttribute]
public PolymorphismSchema get_PolymorphismSchema();
    [CompilerGeneratedAttribute]
private void set_PolymorphismSchema(PolymorphismSchema value);
    internal MessagePackSerializer`1<T> GetFoundSerializer();
    public void SetSerializer(MessagePackSerializer`1<T> foundSerializer);
}
public class MsgPack.Serialization.SerializationCompatibilityOptions : object {
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _oneBoundDataMemberOrder;
    private int _packerCompatibilityOptions;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _ignorePackabilityForCollection;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _allowNonCollectionEnumerableTypes;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _allowAsymmetricSerializer;
    public bool OneBoundDataMemberOrder { get; public set; }
    public PackerCompatibilityOptions PackerCompatibilityOptions { get; public set; }
    public bool IgnorePackabilityForCollection { get; public set; }
    public bool AllowNonCollectionEnumerableTypes { get; public set; }
    public bool AllowAsymmetricSerializer { get; public set; }
    public bool get_OneBoundDataMemberOrder();
    public void set_OneBoundDataMemberOrder(bool value);
    public PackerCompatibilityOptions get_PackerCompatibilityOptions();
    public void set_PackerCompatibilityOptions(PackerCompatibilityOptions value);
    public bool get_IgnorePackabilityForCollection();
    public void set_IgnorePackabilityForCollection(bool value);
    public bool get_AllowNonCollectionEnumerableTypes();
    public void set_AllowNonCollectionEnumerableTypes(bool value);
    public bool get_AllowAsymmetricSerializer();
    public void set_AllowAsymmetricSerializer(bool value);
}
public class MsgPack.Serialization.SerializationContext : object {
    private static MethodInfo GetSerializer1Method;
    private static SerializationContext _default;
    private SerializerRepository _serializers;
    private Dictionary`2<Type, object> _typeLock;
    private object _generationLock;
    private SerializerOptions _serializerGeneratorOptions;
    private SerializationCompatibilityOptions _compatibilityOptions;
    private DictionarySerlaizationOptions _dictionarySerializationOptions;
    private int _serializationMethod;
    private EnumSerializationOptions _enumSerializationOptions;
    private DefaultConcreteTypeRepository _defaultCollectionTypes;
    private int _defaultDateTimeConversionMethod;
    private EventHandler`1<ResolveSerializerEventArgs> _resolveSerializer;
    private ExtTypeCodeMapping _extTypeCodes;
    public static SerializationContext Default { get; public set; }
    public SerializerRepository Serializers { get; }
    public SerializerOptions SerializerOptions { get; }
    public SerializationCompatibilityOptions CompatibilityOptions { get; }
    public DictionarySerlaizationOptions DictionarySerlaizationOptions { get; }
    public SerializationMethod SerializationMethod { get; public set; }
    public EnumSerializationOptions EnumSerializationOptions { get; }
    [ObsoleteAttribute("Use EnumSerializationOptions.SerializationMethod instead.")]
public EnumSerializationMethod EnumSerializationMethod { get; public set; }
    [ObsoleteAttribute("Use SerializerOptions.GeneratorOption instead.")]
public SerializationMethodGeneratorOption GeneratorOption { get; public set; }
    public DefaultConcreteTypeRepository DefaultCollectionTypes { get; }
    public DateTimeConversionMethod DefaultDateTimeConversionMethod { get; public set; }
    public ExtTypeCodeMapping ExtTypeCodeMapping { get; }
    public SerializationContext(PackerCompatibilityOptions packerCompatibilityOptions);
    private static SerializationContext();
    public static SerializationContext get_Default();
    public static void set_Default(SerializationContext value);
    public SerializerRepository get_Serializers();
    public SerializerOptions get_SerializerOptions();
    public SerializationCompatibilityOptions get_CompatibilityOptions();
    public DictionarySerlaizationOptions get_DictionarySerlaizationOptions();
    public SerializationMethod get_SerializationMethod();
    public void set_SerializationMethod(SerializationMethod value);
    public EnumSerializationOptions get_EnumSerializationOptions();
    public EnumSerializationMethod get_EnumSerializationMethod();
    public void set_EnumSerializationMethod(EnumSerializationMethod value);
    public SerializationMethodGeneratorOption get_GeneratorOption();
    public void set_GeneratorOption(SerializationMethodGeneratorOption value);
    public DefaultConcreteTypeRepository get_DefaultCollectionTypes();
    public DateTimeConversionMethod get_DefaultDateTimeConversionMethod();
    public void set_DefaultDateTimeConversionMethod(DateTimeConversionMethod value);
    public void add_ResolveSerializer(EventHandler`1<ResolveSerializerEventArgs> value);
    public void remove_ResolveSerializer(EventHandler`1<ResolveSerializerEventArgs> value);
    private MessagePackSerializer`1<T> OnResolveSerializer(PolymorphismSchema schema);
    public static SerializationContext ConfigureClassic();
    public static SerializationContext CreateClassicContext();
    internal bool ContainsSerializer(Type rootType);
    public MessagePackSerializer`1<T> GetSerializer();
    public MessagePackSerializer`1<T> GetSerializer(object providerParameter);
    private Type EnsureConcreteTypeRegistered(Type mayBeAbstractType);
    private MessagePackSerializer`1<T> GetSerializerWithoutGeneration(PolymorphismSchema schema);
    public MessagePackSerializer GetSerializer(Type targetType);
    public MessagePackSerializer GetSerializer(Type targetType, object providerParameter);
    public ExtTypeCodeMapping get_ExtTypeCodeMapping();
}
[EditorBrowsableAttribute("1")]
public static class MsgPack.Serialization.SerializationExceptions : object {
    public static Exception NewValueTypeCannotBeNull(string name, Type memberType, Type declaringType);
    public static void ThrowValueTypeCannotBeNull(string name, Type memberType, Type declaringType);
    public static Exception NewValueTypeCannotBeNull(Type type);
    public static Exception NewTypeCannotSerialize(Type type);
    public static Exception NewTypeCannotDeserialize(Type type);
    public static Exception NewTypeCannotDeserialize(Type type, string memberName, Exception inner);
    public static Exception NewMissingItem(int index);
    public static void ThrowMissingItem(int index, Unpacker unpacker);
    public static void ThrowMissingItem(int index, string name, Unpacker unpacker);
    internal static void ThrowMissingKey(int index, Unpacker unpacker);
    internal static Exception NewTargetDoesNotHavePublicDefaultConstructor(Type type);
    internal static Exception NewTargetDoesNotHavePublicDefaultConstructorNorInitialCapacity(Type type);
    internal static void ThrowTargetDoesNotHavePublicDefaultConstructorNorInitialCapacity(Type type);
    public static Exception NewMissingProperty(string name);
    internal static void ThrowMissingProperty(string name);
    [ObsoleteAttribute("This method is no longer used internally. So this internal API will be removed in future.")]
public static Exception NewUnexpectedEndOfStream();
    internal static void ThrowUnexpectedEndOfStream(Unpacker unpacker);
    public static Exception NewMissingAddMethod(Type type);
    [ObsoleteAttribute("This method is no longer used internally. So this internal API will be removed in future.")]
public static Exception NewIsNotArrayHeader();
    public static void ThrowIsNotArrayHeader(Unpacker unpacker);
    public static Exception NewIsNotMapHeader();
    public static void ThrowIsNotMapHeader(Unpacker unpacker);
    public static Exception NewNotSupportedBecauseCannotInstanciateAbstractType(Type type);
    public static Exception NewTupleCardinarityIsNotMatch(int expectedTupleCardinality, int actualArrayLength);
    public static void ThrowTupleCardinarityIsNotMatch(int expectedTupleCardinality, long actualArrayLength, Unpacker unpacker);
    public static Exception NewIsIncorrectStream(Exception innerException);
    internal static void ThrowIsIncorrectStream(Exception innerException);
    public static Exception NewIsTooLargeCollection();
    internal static void ThrowIsTooLargeCollection();
    public static Exception NewNullIsProhibited(string memberName);
    public static void ThrowNullIsProhibited(string memberName);
    public static Exception NewReadOnlyMemberItemsMustNotBeNull(string memberName);
    public static Exception NewStreamDoesNotContainCollectionForMember(string memberName);
    public static Exception NewUnexpectedArrayLength(int expectedLength, int actualLength);
    public static Exception NewFailedToDeserializeMember(Type targetType, string memberName, Exception inner);
    internal static void ThrowFailedToDeserializeMember(Type targetType, string memberName, Exception inner);
    public static Exception NewUnpackFromIsNotSupported(Type targetType);
    public static Exception NewCreateInstanceIsNotSupported(Type targetType);
    internal static Exception NewUnpackToIsNotSupported(Type type, Exception inner);
    internal static Exception NewValueTypeCannotBePolymorphic(Type type);
    internal static Exception NewUnknownTypeEmbedding();
    internal static Exception NewIncompatibleCollectionSerializer(Type targetType, Type incompatibleType, Type exampleClass);
    internal static void ThrowArgumentNullException(string parameterName);
    internal static void ThrowArgumentNullException(string parameterName, string fieldName);
    internal static void ThrowArgumentCannotBeNegativeException(string parameterName);
    internal static void ThrowArgumentCannotBeNegativeException(string parameterName, string fieldName);
    internal static void ThrowArgumentException(string parameterName, string message);
    internal static void ThrowSerializationException(string message);
    internal static void ThrowSerializationException(string message, Exception innerException);
    internal static void ThrowInvalidArrayItemsCount(Unpacker unpacker, Type targetType, int requiredCount);
}
public enum MsgPack.Serialization.SerializationMethod : Enum {
    public int value__;
    public static SerializationMethod Array;
    public static SerializationMethod Map;
}
public enum MsgPack.Serialization.SerializationMethodGeneratorOption : Enum {
    public int value__;
    public static SerializationMethodGeneratorOption Fast;
}
internal class MsgPack.Serialization.SerializationTarget : object {
    private static string MessagePackMemberAttributeTypeName;
    private static string MessagePackIgnoreAttributeTypeName;
    private static string MessagePackDeserializationConstructorAttributeTypeName;
    private static String[] EmptyStrings;
    private static SerializingMember[] EmptyMembers;
    private static Assembly ThisAssembly;
    [CompilerGeneratedAttribute]
private IList`1<SerializingMember> <Members>k__BackingField;
    [CompilerGeneratedAttribute]
private ConstructorInfo <DeserializationConstructor>k__BackingField;
    private String[] _correspondingMemberNames;
    [CompilerGeneratedAttribute]
private bool <IsConstructorDeserialization>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CanDeserialize>k__BackingField;
    public IList`1<SerializingMember> Members { get; private set; }
    public ConstructorInfo DeserializationConstructor { get; private set; }
    public bool IsConstructorDeserialization { get; private set; }
    public bool CanDeserialize { get; private set; }
    private SerializationTarget(IList`1<SerializingMember> members, ConstructorInfo constructor, String[] correspondingMemberNames, bool canDeserialize);
    private static SerializationTarget();
    [CompilerGeneratedAttribute]
public IList`1<SerializingMember> get_Members();
    [CompilerGeneratedAttribute]
private void set_Members(IList`1<SerializingMember> value);
    [CompilerGeneratedAttribute]
public ConstructorInfo get_DeserializationConstructor();
    [CompilerGeneratedAttribute]
private void set_DeserializationConstructor(ConstructorInfo value);
    [CompilerGeneratedAttribute]
public bool get_IsConstructorDeserialization();
    [CompilerGeneratedAttribute]
private void set_IsConstructorDeserialization(bool value);
    [CompilerGeneratedAttribute]
public bool get_CanDeserialize();
    [CompilerGeneratedAttribute]
private void set_CanDeserialize(bool value);
    public SerializerCapabilities GetCapabilitiesForObject();
    public SerializerCapabilities GetCapabilitiesForCollection(CollectionTraits traits);
    private static String[] FindCorrespondingMemberNames(IList`1<SerializingMember> members, ConstructorInfo constructor);
    private static string DetermineCorrespondingMemberName(ParameterInfo parameterInfo, IEnumerable`1<SerializingMember> members);
    private static void ThrowAmbigiousMatchException(ParameterInfo parameterInfo, ICollection`1<SerializingMember> members);
    public string GetCorrespondingMemberName(int constructorParameterIndex);
    public static void VerifyType(Type targetType);
    public static void VerifyCanSerializeTargetType(SerializationContext context, Type targetType);
    public static SerializationTarget Prepare(SerializationContext context, Type targetType);
    private static bool HasAnyCorrespondingMembers(IEnumerable`1<string> correspondingMemberNames);
    private static bool HasUnpackableInterface(Type targetType, SerializationContext context);
    private static bool DetermineCanDeserialize(ConstructorKind kind, SerializationContext context, Type targetType, IEnumerable`1<string> correspondingMemberNames, bool allowDefault);
    private static MemberInfo[] GetDistinctMembers(Type type);
    private static IEnumerable`1<SerializingMember> GetTargetMembers(Type type);
    private static IEnumerable`1<SerializingMember> GetAnnotatedMembersWithDuplicationDetection(Type type, MemberInfo[] filtered);
    private static object GetAttributeProperty(string attributeName, Attribute attribute, string propertyName);
    private static IEnumerable`1<SerializingMember> GetSystemRuntimeSerializationCompatibleMembers(MemberInfo[] members);
    private static IEnumerable`1<SerializingMember> GetPublicUnpreventedMembers(MemberInfo[] members);
    private static bool IsNonSerializedField(MemberInfo member);
    private static ConstructorInfo FindDeserializationConstructor(SerializationContext context, Type targetType, ConstructorKind& constructorKind);
    private static IList`1<ConstructorInfo> FindExplicitDeserializationConstructors(IEnumerable`1<ConstructorInfo> construtors);
    private static SerializationException NewTypeCannotBeSerializedException(Type targetType);
    private static bool CheckTargetEligibility(SerializationContext context, MemberInfo member);
    private static IList`1<SerializingMember> ComplementMembers(IList`1<SerializingMember> candidates, SerializationContext context, Type targetType);
    private static void VerifyNilImplication(Type type, IEnumerable`1<SerializingMember> entries);
    private static void VerifyKeyUniqueness(IList`1<SerializingMember> result);
    public static SerializationTarget CreateForCollection(ConstructorInfo collectionConstructor, bool canDeserialize);
    public static SerializationTarget CreateForTuple(IList`1<Type> itemTypes);
    public static string GetTupleItemNameFromIndex(int i);
    [ConditionalAttribute("DEBUG")]
private static void Trace(string format, Object[] args);
}
[FlagsAttribute]
public enum MsgPack.Serialization.SerializerCapabilities : Enum {
    public int value__;
    public static SerializerCapabilities None;
    public static SerializerCapabilities PackTo;
    public static SerializerCapabilities UnpackFrom;
    public static SerializerCapabilities UnpackTo;
}
internal static class MsgPack.Serialization.SerializerDebugging : object {
    [ConditionalAttribute("DEBUG")]
public static void TracePolimorphicSchemaEvent(string format, MemberInfo memberInfo, PolymorphismSchema schema);
}
public class MsgPack.Serialization.SerializerOptions : object {
    private int _emitterFlavor;
    private int _generatorOption;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _isRuntimeGenerationDisabled;
    internal static bool CanEmit;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _isNonPublicAccessDisabled;
    internal EmitterFlavor EmitterFlavor { get; internal set; }
    public SerializationMethodGeneratorOption GeneratorOption { get; public set; }
    public bool DisableRuntimeCodeGeneration { get; public set; }
    internal bool CanRuntimeCodeGeneration { get; }
    public bool DisablePrivilegedAccess { get; public set; }
    private static SerializerOptions();
    internal EmitterFlavor get_EmitterFlavor();
    internal void set_EmitterFlavor(EmitterFlavor value);
    public SerializationMethodGeneratorOption get_GeneratorOption();
    public void set_GeneratorOption(SerializationMethodGeneratorOption value);
    public bool get_DisableRuntimeCodeGeneration();
    public void set_DisableRuntimeCodeGeneration(bool value);
    private static bool DetermineCanEmit();
    internal bool get_CanRuntimeCodeGeneration();
    public bool get_DisablePrivilegedAccess();
    public void set_DisablePrivilegedAccess(bool value);
}
[FlagsAttribute]
public enum MsgPack.Serialization.SerializerRegistrationOptions : Enum {
    public int value__;
    public static SerializerRegistrationOptions None;
    public static SerializerRegistrationOptions AllowOverride;
    public static SerializerRegistrationOptions WithNullable;
}
public class MsgPack.Serialization.SerializerRepository : object {
    private static object SyncRoot;
    private static SerializerRepository _internalDefault;
    private SerializerTypeKeyRepository _repository;
    internal static int DefaultTableCapacity;
    internal static SerializerRepository InternalDefault { get; }
    [ObsoleteAttribute("Use GetDefault()")]
public static SerializerRepository Default { get; }
    public SerializerRepository(SerializerRepository copiedFrom);
    private SerializerRepository(Dictionary`2<RuntimeTypeHandle, object> table);
    private static SerializerRepository();
    internal static SerializerRepository get_InternalDefault();
    [ObsoleteAttribute("This class should not be disposable, so IDisposable will be removed in future.")]
public sealed virtual void Dispose();
    public MessagePackSerializer`1<T> Get(SerializationContext context);
    public MessagePackSerializer`1<T> Get(SerializationContext context, object providerParameter);
    public bool Register(MessagePackSerializer`1<T> serializer);
    public bool Register(MessagePackSerializer`1<T> serializer, SerializerRegistrationOptions options);
    internal static void GetNullableCompanion(Type targetType, SerializationContext context, object serializer, Type& nullableType, MessagePackSerializerProvider& nullableSerializerProvider);
    internal bool Register(Type targetType, MessagePackSerializerProvider serializerProvider, Type nullableType, MessagePackSerializerProvider nullableSerializerProvider, SerializerRegistrationOptions options);
    public void RegisterOverride(MessagePackSerializer`1<T> serializer);
    public static SerializerRepository get_Default();
    public static SerializerRepository GetDefault();
    [ObsoleteAttribute("Use GetDefault()")]
public static SerializerRepository GetDefault(PackerCompatibilityOptions packerCompatibilityOptions);
    public static SerializerRepository GetDefault(SerializationContext ownerContext);
    public bool ContainsFor(Type targetType);
    public IEnumerable`1<KeyValuePair`2<Type, MessagePackSerializer>> GetRegisteredSerializers();
    internal static Dictionary`2<RuntimeTypeHandle, object> InitializeDefaultTable(SerializationContext ownerContext);
}
[SecuritySafeCriticalAttribute]
internal class MsgPack.Serialization.SerializerTypeKeyRepository : TypeKeyRepository {
    public SerializerTypeKeyRepository(SerializerTypeKeyRepository copiedFrom);
    public SerializerTypeKeyRepository(Dictionary`2<RuntimeTypeHandle, object> table);
    public object Get(SerializationContext context, Type keyType);
}
internal class MsgPack.Serialization.SerializingMember : ValueType {
    public MemberInfo Member;
    public DataMemberContract Contract;
    public string MemberName;
    public SerializingMember(MemberInfo member, DataMemberContract contract);
    public SerializingMember(string name);
    public EnumMemberSerializationMethod GetEnumMemberSerializationMethod();
    public DateTimeMemberConversionMethod GetDateTimeMemberConversionMethod();
    public virtual string ToString();
}
[SecuritySafeCriticalAttribute]
internal class MsgPack.Serialization.TypeKeyRepository : object {
    private ReaderWriterLockSlim _lock;
    private Dictionary`2<RuntimeTypeHandle, object> _table;
    public TypeKeyRepository(TypeKeyRepository copiedFrom);
    public TypeKeyRepository(Dictionary`2<RuntimeTypeHandle, object> table);
    [SecuritySafeCriticalAttribute]
private Dictionary`2<RuntimeTypeHandle, object> GetClonedTable();
    public bool Get(Type type, Object& matched, Object& genericDefinitionMatched);
    [SecuritySafeCriticalAttribute]
private bool GetCore(Type type, Object& matched, Object& genericDefinitionMatched);
    public bool Register(Type type, object entry, Type nullableType, object nullableValue, SerializerRegistrationOptions options);
    [SecuritySafeCriticalAttribute]
private bool RegisterCore(Type key, object value, Type nullableType, object nullableValue, SerializerRegistrationOptions options);
    private bool ContainsType(Type baseType, Type nullableType);
    public bool Unregister(Type type);
    [SecuritySafeCriticalAttribute]
private bool UnregisterCore(Type key);
    [SecuritySafeCriticalAttribute]
internal bool Contains(Type type);
    [SecuritySafeCriticalAttribute]
internal IEnumerable`1<KeyValuePair`2<Type, object>> GetEntries();
}
[EditorBrowsableAttribute("1")]
public class MsgPack.Serialization.UnpackCollectionParameters`1 : ValueType {
    public Unpacker Unpacker;
    public int ItemsCount;
    public T Collection;
    public Action`3<Unpacker, T, int> BulkOperation;
    public Action`4<Unpacker, T, int, int> EachOperation;
}
[EditorBrowsableAttribute("1")]
public class MsgPack.Serialization.UnpackFromArrayParameters`2 : ValueType {
    public Unpacker Unpacker;
    public TContext UnpackingContext;
    public Func`2<TContext, TResult> Factory;
    public IList`1<string> ItemNames;
    public IList`1<Action`4<Unpacker, TContext, int, int>> Operations;
}
[EditorBrowsableAttribute("1")]
public class MsgPack.Serialization.UnpackFromMapParameters`2 : ValueType {
    public Unpacker Unpacker;
    public TContext UnpackingContext;
    public Func`2<TContext, TResult> Factory;
    public IDictionary`2<string, Action`4<Unpacker, TContext, int, int>> Operations;
}
[EditorBrowsableAttribute("1")]
public static class MsgPack.Serialization.UnpackHelpers : object {
    private static MessagePackSerializer`1<MessagePackObject> _messagePackObjectSerializer;
    private static UnpackHelpers();
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This API is not used at generated serializers in current release, so this API will be removed future.")]
public static void UnpackArrayTo(Unpacker unpacker, MessagePackSerializer`1<T> serializer, T[] array);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This API is not used at generated serializers in current release, so this API will be removed future.")]
public static void UnpackCollectionTo(Unpacker unpacker, IEnumerable collection, Action`1<object> addition);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This API is not used at generated serializers in current release, so this API will be removed future.")]
public static void UnpackCollectionTo(Unpacker unpacker, MessagePackSerializer`1<T> serializer, IEnumerable`1<T> collection, Action`1<T> addition);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This API is not used at generated serializers in current release, so this API will be removed future.")]
public static void UnpackCollectionTo(Unpacker unpacker, IEnumerable collection, Func`2<object, TDiscarded> addition);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This API is not used at generated serializers in current release, so this API will be removed future.")]
public static void UnpackCollectionTo(Unpacker unpacker, MessagePackSerializer`1<T> serializer, IEnumerable`1<T> collection, Func`2<T, TDiscarded> addition);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This API is not used at generated serializers in current release, so this API will be removed future.")]
public static void UnpackMapTo(Unpacker unpacker, MessagePackSerializer`1<TKey> keySerializer, MessagePackSerializer`1<TValue> valueSerializer, IDictionary`2<TKey, TValue> dictionary);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This API is not used at generated serializers in current release, so this API will be removed future.")]
public static void UnpackMapTo(Unpacker unpacker, IDictionary dictionary);
    [EditorBrowsableAttribute("1")]
public static int GetItemsCount(Unpacker unpacker);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This API is not used at generated serializers in current release, so this API will be removed future.")]
public static T ConvertWithEnsuringNotNull(object boxed, string name, Type targetType);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This API is not used at generated serializers in current release, so this API will be removed future.")]
public static T InvokeUnpackFrom(MessagePackSerializer`1<T> serializer, Unpacker unpacker);
    internal static SerializationTarget DetermineCollectionSerializationStrategy(Type instanceType, bool allowAsymmetricSerializer);
    private static ConstructorInfo TryGetCollectionConstructor(Type instanceType);
    internal static bool IsIEqualityComparer(Type type);
    [EditorBrowsableAttribute("1")]
public static IEqualityComparer`1<T> GetEqualityComparer();
    [EditorBrowsableAttribute("1")]
public static Func`2<T, T> GetIdentity();
    [EditorBrowsableAttribute("1")]
public static Func`2<object, T> Unbox();
    [ConditionalAttribute("TRACING")]
private static void InitializeUnpackerTrace(Unpacker unpacker, UnpackerTraceContext& context, string callerMemberName);
    [ConditionalAttribute("TRACING")]
private static void Trace(UnpackerTraceContext context, string label, Unpacker unpacker);
    [ConditionalAttribute("TRACING")]
private static void Trace(UnpackerTraceContext context, string label, Unpacker unpacker, int index);
    [ConditionalAttribute("TRACING")]
private static void Trace(UnpackerTraceContext context, string label, Unpacker unpacker, int index, IList`1<string> itemNames);
    [ConditionalAttribute("TRACING")]
private static void Trace(UnpackerTraceContext context, string label, Unpacker unpacker, int index, string key);
    [ConditionalAttribute("TRACING")]
private static void Trace(UnpackerTraceContext context, string label, Unpacker unpacker, string key);
    [ConditionalAttribute("TRACING")]
private static void TraceCore(string format, Object[] args);
    [EditorBrowsableAttribute("1")]
public static bool UnpackBooleanValue(Unpacker unpacker, Type objectType, string memberName);
    [EditorBrowsableAttribute("1")]
public static Nullable`1<bool> UnpackNullableBooleanValue(Unpacker unpacker, Type objectType, string memberName);
    [EditorBrowsableAttribute("1")]
public static byte UnpackByteValue(Unpacker unpacker, Type objectType, string memberName);
    [EditorBrowsableAttribute("1")]
public static Nullable`1<byte> UnpackNullableByteValue(Unpacker unpacker, Type objectType, string memberName);
    [EditorBrowsableAttribute("1")]
public static short UnpackInt16Value(Unpacker unpacker, Type objectType, string memberName);
    [EditorBrowsableAttribute("1")]
public static Nullable`1<short> UnpackNullableInt16Value(Unpacker unpacker, Type objectType, string memberName);
    [EditorBrowsableAttribute("1")]
public static int UnpackInt32Value(Unpacker unpacker, Type objectType, string memberName);
    [EditorBrowsableAttribute("1")]
public static Nullable`1<int> UnpackNullableInt32Value(Unpacker unpacker, Type objectType, string memberName);
    [EditorBrowsableAttribute("1")]
public static long UnpackInt64Value(Unpacker unpacker, Type objectType, string memberName);
    [EditorBrowsableAttribute("1")]
public static Nullable`1<long> UnpackNullableInt64Value(Unpacker unpacker, Type objectType, string memberName);
    [CLSCompliantAttribute("False")]
[EditorBrowsableAttribute("1")]
public static sbyte UnpackSByteValue(Unpacker unpacker, Type objectType, string memberName);
    [CLSCompliantAttribute("False")]
[EditorBrowsableAttribute("1")]
public static Nullable`1<sbyte> UnpackNullableSByteValue(Unpacker unpacker, Type objectType, string memberName);
    [CLSCompliantAttribute("False")]
[EditorBrowsableAttribute("1")]
public static ushort UnpackUInt16Value(Unpacker unpacker, Type objectType, string memberName);
    [CLSCompliantAttribute("False")]
[EditorBrowsableAttribute("1")]
public static Nullable`1<ushort> UnpackNullableUInt16Value(Unpacker unpacker, Type objectType, string memberName);
    [CLSCompliantAttribute("False")]
[EditorBrowsableAttribute("1")]
public static UInt32 UnpackUInt32Value(Unpacker unpacker, Type objectType, string memberName);
    [CLSCompliantAttribute("False")]
[EditorBrowsableAttribute("1")]
public static Nullable`1<UInt32> UnpackNullableUInt32Value(Unpacker unpacker, Type objectType, string memberName);
    [CLSCompliantAttribute("False")]
[EditorBrowsableAttribute("1")]
public static ulong UnpackUInt64Value(Unpacker unpacker, Type objectType, string memberName);
    [CLSCompliantAttribute("False")]
[EditorBrowsableAttribute("1")]
public static Nullable`1<ulong> UnpackNullableUInt64Value(Unpacker unpacker, Type objectType, string memberName);
    [EditorBrowsableAttribute("1")]
public static float UnpackSingleValue(Unpacker unpacker, Type objectType, string memberName);
    [EditorBrowsableAttribute("1")]
public static Nullable`1<float> UnpackNullableSingleValue(Unpacker unpacker, Type objectType, string memberName);
    [EditorBrowsableAttribute("1")]
public static double UnpackDoubleValue(Unpacker unpacker, Type objectType, string memberName);
    [EditorBrowsableAttribute("1")]
public static Nullable`1<double> UnpackNullableDoubleValue(Unpacker unpacker, Type objectType, string memberName);
    [EditorBrowsableAttribute("1")]
public static string UnpackStringValue(Unpacker unpacker, Type objectType, string memberName);
    [EditorBrowsableAttribute("1")]
public static Byte[] UnpackBinaryValue(Unpacker unpacker, Type objectType, string memberName);
    [EditorBrowsableAttribute("1")]
public static T UnpackComplexObject(Unpacker unpacker, MessagePackSerializer`1<T> serializer, int unpacked);
    [EditorBrowsableAttribute("1")]
public static void UnpackValueTypeValue(Unpacker unpacker, TContext context, MessagePackSerializer`1<TValue> serializer, int itemsCount, int unpacked, Type targetObjectType, string memberName, Func`4<Unpacker, Type, string, TValue> directRead, Action`2<TContext, TValue> setter);
    [EditorBrowsableAttribute("1")]
public static void UnpackValueTypeValue(UnpackValueTypeValueParameters`2& parameter);
    private static void UnpackValueTypeValueCore(Unpacker unpacker, TContext context, MessagePackSerializer`1<TValue> serializer, int itemsCount, int unpacked, Type targetObjectType, string memberName, Func`4<Unpacker, Type, string, TValue> directRead, Action`2<TContext, TValue> setter);
    [EditorBrowsableAttribute("1")]
public static void UnpackReferenceTypeValue(Unpacker unpacker, TContext context, MessagePackSerializer`1<TValue> serializer, int itemsCount, int unpacked, Type targetObjectType, string memberName, NilImplication nilImplication, Func`4<Unpacker, Type, string, TValue> directRead, Action`2<TContext, TValue> setter);
    [EditorBrowsableAttribute("1")]
public static void UnpackReferenceTypeValue(UnpackReferenceTypeValueParameters`2& parameter);
    private static void UnpackReferenceTypeValueCore(Unpacker unpacker, TContext context, MessagePackSerializer`1<TValue> serializer, int itemsCount, int unpacked, Type targetObjectType, string memberName, NilImplication nilImplication, Func`4<Unpacker, Type, string, TValue> directRead, Action`2<TContext, TValue> setter);
    [EditorBrowsableAttribute("1")]
public static void UnpackNullableTypeValue(Unpacker unpacker, TContext context, MessagePackSerializer`1<Nullable`1<TValue>> serializer, int itemsCount, int unpacked, Type targetObjectType, string memberName, NilImplication nilImplication, Func`4<Unpacker, Type, string, Nullable`1<TValue>> directRead, Action`2<TContext, Nullable`1<TValue>> setter);
    [EditorBrowsableAttribute("1")]
public static void UnpackNullableTypeValue(UnpackNullableTypeValueParameters`2& parameter);
    private static void UnpackNullableTypeValueCore(Unpacker unpacker, TContext context, MessagePackSerializer`1<Nullable`1<TValue>> serializer, int itemsCount, int unpacked, Type targetObjectType, string memberName, NilImplication nilImplication, Func`4<Unpacker, Type, string, Nullable`1<TValue>> directRead, Action`2<TContext, Nullable`1<TValue>> setter);
    [EditorBrowsableAttribute("1")]
public static void UnpackMessagePackObjectValueFromArray(Unpacker unpacker, TContext context, int itemsCount, int unpacked, string memberName, NilImplication nilImplication, Action`2<TContext, MessagePackObject> setter);
    [EditorBrowsableAttribute("1")]
public static void UnpackMessagePackObjectValueFromMap(Unpacker unpacker, TContext context, int itemsCount, int unpacked, string memberName, NilImplication nilImplication, Action`2<TContext, MessagePackObject> setter);
    [EditorBrowsableAttribute("1")]
public static void UnpackMessagePackObjectValue(UnpackMessagePackObjectValueParameters`1& parameter);
    private static void UnpackMessagePackObjectValueCore(Unpacker unpacker, TContext unpackingContext, int itemsCount, int unpacked, string memberName, NilImplication nilImplication, Action`2<TContext, MessagePackObject> setter);
    [EditorBrowsableAttribute("1")]
public static TResult UnpackFromArray(Unpacker unpacker, TContext context, Func`2<TContext, TResult> factory, IList`1<string> itemNames, IList`1<Action`4<Unpacker, TContext, int, int>> operations);
    [EditorBrowsableAttribute("1")]
public static TResult UnpackFromArray(UnpackFromArrayParameters`2& parameter);
    private static TResult UnpackFromArrayCore(Unpacker unpacker, TContext unpackingContext, Func`2<TContext, TResult> factory, IList`1<string> itemNames, IList`1<Action`4<Unpacker, TContext, int, int>> operations);
    [EditorBrowsableAttribute("1")]
public static TResult UnpackFromMap(Unpacker unpacker, TContext context, Func`2<TContext, TResult> factory, IDictionary`2<string, Action`4<Unpacker, TContext, int, int>> operations);
    [EditorBrowsableAttribute("1")]
public static TResult UnpackFromMap(UnpackFromMapParameters`2& parameter);
    private static TResult UnpackFromMapCore(Unpacker unpacker, TContext unpackingContext, Func`2<TContext, TResult> factory, IDictionary`2<string, Action`4<Unpacker, TContext, int, int>> operations);
    [EditorBrowsableAttribute("1")]
public static T UnpackCollection(Unpacker unpacker, int itemsCount, T collection, Action`3<Unpacker, T, int> bulkOperation, Action`4<Unpacker, T, int, int> eachOperation);
    [EditorBrowsableAttribute("1")]
public static T UnpackCollection(UnpackCollectionParameters`1& parameter);
    private static T UnpackCollectionCore(Unpacker unpacker, int itemsCount, T collection, Action`3<Unpacker, T, int> bulkOperation, Action`4<Unpacker, T, int, int> eachOperation);
}
[EditorBrowsableAttribute("1")]
public class MsgPack.Serialization.UnpackMessagePackObjectValueParameters`1 : ValueType {
    public Unpacker Unpacker;
    public TContext UnpackingContext;
    public MessagePackSerializer`1<MessagePackObject> Serializer;
    public int ItemsCount;
    public int Unpacked;
    public string MemberName;
    public Action`2<TContext, MessagePackObject> Setter;
    public NilImplication NilImplication;
}
[EditorBrowsableAttribute("1")]
public class MsgPack.Serialization.UnpackNullableTypeValueParameters`2 : ValueType {
    public Unpacker Unpacker;
    public TContext UnpackingContext;
    public MessagePackSerializer`1<Nullable`1<TValue>> Serializer;
    public int ItemsCount;
    public int Unpacked;
    public string MemberName;
    public Action`2<TContext, Nullable`1<TValue>> Setter;
    public Type TargetObjectType;
    public Func`4<Unpacker, Type, string, Nullable`1<TValue>> DirectRead;
    public NilImplication NilImplication;
}
[EditorBrowsableAttribute("1")]
public class MsgPack.Serialization.UnpackReferenceTypeValueParameters`2 : ValueType {
    public Unpacker Unpacker;
    public TContext UnpackingContext;
    public MessagePackSerializer`1<TValue> Serializer;
    public int ItemsCount;
    public int Unpacked;
    public string MemberName;
    public Action`2<TContext, TValue> Setter;
    public Type TargetObjectType;
    public Func`4<Unpacker, Type, string, TValue> DirectRead;
    public NilImplication NilImplication;
}
[EditorBrowsableAttribute("1")]
public class MsgPack.Serialization.UnpackValueTypeValueParameters`2 : ValueType {
    public Unpacker Unpacker;
    public TContext UnpackingContext;
    public MessagePackSerializer`1<TValue> Serializer;
    public int ItemsCount;
    public int Unpacked;
    public string MemberName;
    public Action`2<TContext, TValue> Setter;
    public Type TargetObjectType;
    public Func`4<Unpacker, Type, string, TValue> DirectRead;
}
internal static class MsgPack.SetOperation : object {
    public static bool IsProperSubsetOf(ISet`1<T> set, IEnumerable`1<T> other);
    public static bool IsSubsetOf(ISet`1<T> set, IEnumerable`1<T> other);
    private static bool IsSubsetOfCore(ISet`1<T> set, IEnumerable`1<T> other, Int32& otherCount);
    public static bool IsProperSupersetOf(ISet`1<T> set, IEnumerable`1<T> other);
    public static bool IsSupersetOf(ISet`1<T> set, IEnumerable`1<T> other);
    private static bool IsSupersetOfCore(ISet`1<T> set, IEnumerable`1<T> other, Int32& otherCount);
    public static bool Overlaps(ISet`1<T> set, IEnumerable`1<T> other);
    public static bool SetEquals(ISet`1<T> set, IEnumerable`1<T> other);
}
internal class MsgPack.SingleArrayBufferAllocator : ByteBufferAllocator {
    public static SingleArrayBufferAllocator Default;
    private Func`3<Byte[], int, Byte[]> _allocator;
    public SingleArrayBufferAllocator(Func`3<Byte[], int, Byte[]> allocator);
    private static SingleArrayBufferAllocator();
    private static Byte[] Allocate(Byte[] old, int requestSize);
    public virtual bool TryAllocate(Byte[] oldBuffer, int requestSize, Byte[]& newBuffer);
}
internal static class MsgPack.StringEscape : object {
    public static string ForDisplay(string value);
}
internal class MsgPack.SubtreeUnpacker : Unpacker {
    private Unpacker _root;
    private IRootUnpacker _internalRoot;
    private SubtreeUnpacker _parent;
    private Stack`1<bool> _isMap;
    private Stack`1<long> _unpacked;
    private Stack`1<long> _itemsCount;
    private State _state;
    public long ItemsCount { get; }
    public bool IsArrayHeader { get; }
    public bool IsMapHeader { get; }
    public bool IsCollectionHeader { get; }
    [ObsoleteAttribute("Consumer should not use this property. Query LastReadData instead.")]
public Nullable`1<MessagePackObject> Data { get; protected set; }
    public MessagePackObject LastReadData { get; protected set; }
    public SubtreeUnpacker(Unpacker parent);
    private SubtreeUnpacker(Unpacker root, SubtreeUnpacker parent);
    public virtual long get_ItemsCount();
    public virtual bool get_IsArrayHeader();
    public virtual bool get_IsMapHeader();
    public virtual bool get_IsCollectionHeader();
    public virtual Nullable`1<MessagePackObject> get_Data();
    protected virtual void set_Data(Nullable`1<MessagePackObject> value);
    public virtual MessagePackObject get_LastReadData();
    protected virtual void set_LastReadData(MessagePackObject value);
    protected virtual void Dispose(bool disposing);
    public virtual void Drain();
    protected internal virtual void EndReadSubtree();
    protected virtual Unpacker ReadSubtreeCore();
    private static void ThrowInTailException();
    private static void ThrowNotInHeadOfCollectionException();
    protected virtual bool ReadCore();
    protected virtual Nullable`1<long> SkipCore();
    private void DiscardCompletedStacks();
    public virtual bool ReadBoolean(Boolean& result);
    public virtual bool ReadNullableBoolean(Nullable`1& result);
    public virtual bool ReadByte(Byte& result);
    public virtual bool ReadNullableByte(Nullable`1& result);
    public virtual bool ReadSByte(SByte& result);
    public virtual bool ReadNullableSByte(Nullable`1& result);
    public virtual bool ReadInt16(Int16& result);
    public virtual bool ReadNullableInt16(Nullable`1& result);
    public virtual bool ReadUInt16(UInt16& result);
    public virtual bool ReadNullableUInt16(Nullable`1& result);
    public virtual bool ReadInt32(Int32& result);
    public virtual bool ReadNullableInt32(Nullable`1& result);
    public virtual bool ReadUInt32(UInt32& result);
    public virtual bool ReadNullableUInt32(Nullable`1& result);
    public virtual bool ReadInt64(Int64& result);
    public virtual bool ReadNullableInt64(Nullable`1& result);
    public virtual bool ReadUInt64(UInt64& result);
    public virtual bool ReadNullableUInt64(Nullable`1& result);
    public virtual bool ReadSingle(Single& result);
    public virtual bool ReadNullableSingle(Nullable`1& result);
    public virtual bool ReadDouble(Double& result);
    public virtual bool ReadNullableDouble(Nullable`1& result);
    public virtual bool ReadArrayLength(Int64& result);
    public virtual bool ReadMapLength(Int64& result);
    public virtual bool ReadBinary(Byte[]& result);
    public virtual bool ReadString(String& result);
    public virtual bool ReadMessagePackExtendedTypeObject(MessagePackExtendedTypeObject& result);
    public virtual bool ReadObject(MessagePackObject& result);
}
public class MsgPack.Timestamp : ValueType {
    public static byte TypeCode;
    public static Timestamp Zero;
    public static Timestamp MinValue;
    public static Timestamp MaxValue;
    private static Int32[] LastDays;
    private static long MinUnixEpochSecondsForTicks;
    private static long MaxUnixEpochSecondsForTicks;
    private static int MaxNanoSeconds;
    private static long UnixEpochTicks;
    private static long UnixEpochInSeconds;
    private static int SecondsToTicks;
    private static int NanoToTicks;
    private static int SecondsToNanos;
    private long unixEpochSeconds;
    private UInt32 nanoseconds;
    private static int SecondsPerMinutes;
    private static int SecondsPerHours;
    private static int SecondsPerDay;
    private static int DaysPerYear;
    private static int DaysPer4Years;
    private static int DaysPer100Years;
    private static int DaysPer400Years;
    private static int DayOfWeekOfEpoc;
    private static UInt32[] DaysToMonth365;
    private static UInt32[] DaysToMonth366;
    private static UInt32[] ReversedDaysToMonth365;
    private static UInt32[] ReversedDaysToMonth366;
    public long UnixEpochSecondsPart { get; }
    public int NanosecondsPart { get; }
    public long Year { get; }
    public int Month { get; }
    public int Day { get; }
    public int Hour { get; }
    public int Minute { get; }
    public int Second { get; }
    public int Millisecond { get; }
    public int Microsecond { get; }
    public int Nanosecond { get; }
    public Timestamp Date { get; }
    public Timestamp TimeOfDay { get; }
    public DayOfWeek DayOfWeek { get; }
    public int DayOfYear { get; }
    public bool IsLeapYear { get; }
    public static Timestamp Today { get; }
    public static Timestamp UtcNow { get; }
    public Timestamp(long unixEpochSeconds, int nanoseconds);
    private static Timestamp();
    public Timestamp Add(TimeSpan offset);
    public Timestamp Subtract(TimeSpan offset);
    public static Timestamp op_Addition(Timestamp value, TimeSpan offset);
    public static Timestamp op_Subtraction(Timestamp value, TimeSpan offset);
    public sealed virtual int CompareTo(Timestamp other);
    public static int Compare(Timestamp left, Timestamp right);
    private sealed virtual override int System.IComparable.CompareTo(object obj);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(Timestamp other);
    public virtual int GetHashCode();
    public static bool op_GreaterThan(Timestamp left, Timestamp right);
    public static bool op_LessThan(Timestamp left, Timestamp right);
    public static bool op_GreaterThanOrEqual(Timestamp left, Timestamp right);
    public static bool op_LessThanOrEqual(Timestamp left, Timestamp right);
    public static bool op_Equality(Timestamp left, Timestamp right);
    public static bool op_Inequality(Timestamp left, Timestamp right);
    private long ToTicks(Type destination);
    public DateTime ToDateTime();
    public DateTimeOffset ToDateTimeOffset();
    public MessagePackExtendedTypeObject Encode();
    private static void FromDateTimeTicks(long ticks, Int64& unixEpocSeconds, Int32& nanoSeconds);
    private static void FromOffsetTicks(long ticks, Int64& unixEpocSeconds, Int32& nanoSeconds);
    public static Timestamp FromDateTime(DateTime value);
    public static Timestamp FromDateTimeOffset(DateTimeOffset value);
    public static Timestamp Decode(MessagePackExtendedTypeObject value);
    public static DateTime op_Explicit(Timestamp value);
    public static DateTimeOffset op_Explicit(Timestamp value);
    public static MessagePackExtendedTypeObject op_Implicit(Timestamp value);
    public static Timestamp op_Implicit(DateTime value);
    public static Timestamp op_Implicit(DateTimeOffset value);
    public static Timestamp op_Explicit(MessagePackExtendedTypeObject value);
    internal static Timestamp FromComponents(Value& value, bool isLeapYear);
    private static long YearsToDaysOfNewYear(long years);
    private static int ToDaysOffsetFromNewYear(int month, int day, bool isLeapYear);
    internal static long DivRem(long dividend, long divisor, Int64& remainder);
    public static Timestamp ParseExact(string input, string format, IFormatProvider formatProvider);
    public static Timestamp ParseExact(string input, string format, IFormatProvider formatProvider, DateTimeStyles styles);
    public static Timestamp ParseExact(string input, String[] formats, IFormatProvider formatProvider, DateTimeStyles styles);
    private static void HandleParseResult(TimestampParseResult result, string messageForInvalidInput);
    public long get_UnixEpochSecondsPart();
    public int get_NanosecondsPart();
    public long get_Year();
    public int get_Month();
    public int get_Day();
    public int get_Hour();
    public int get_Minute();
    public int get_Second();
    public int get_Millisecond();
    public int get_Microsecond();
    public int get_Nanosecond();
    public Timestamp get_Date();
    public Timestamp get_TimeOfDay();
    public DayOfWeek get_DayOfWeek();
    public int get_DayOfYear();
    public bool get_IsLeapYear();
    internal static bool IsLeapYearInternal(long year);
    internal static int GetLastDay(int month, bool isLeapYear);
    private void GetDatePart(Int64& year, Int32& month, Int32& day, Int32& dayOfYear);
    private void GetDatePartAD(Int64& year, Int32& month, Int32& day, Int32& dayOfYear);
    private void GetDatePartBC(Int64& year, Int32& month, Int32& day, Int32& dayOfYear);
    public static Timestamp get_Today();
    public static Timestamp get_UtcNow();
    public virtual string ToString();
    public string ToString(IFormatProvider formatProvider);
    public string ToString(string format);
    public sealed virtual string ToString(string format, IFormatProvider formatProvider);
    public static bool TryParseExact(string input, string format, IFormatProvider formatProvider, DateTimeStyles styles, Timestamp& result);
    public static bool TryParseExact(string input, String[] formats, IFormatProvider formatProvider, DateTimeStyles styles, Timestamp& result);
    private static TimestampParseResult TryParseExactCore(string input, string format, IFormatProvider formatProvider, DateTimeStyles styles, Timestamp& result);
    private static TimestampParseResult TryParseExactCore(string input, String[] formats, IFormatProvider formatProvider, DateTimeStyles styles, Timestamp& result);
    private static void ValidateParseInput(string input);
    private static void ValidateParseStyles(DateTimeStyles styles);
}
internal enum MsgPack.TimestampParseResult : Enum {
    public int value__;
    public static TimestampParseResult Success;
    public static TimestampParseResult KindMask;
    public static TimestampParseResult KindNull;
    public static TimestampParseResult KindEmpty;
    public static TimestampParseResult KindUnsupported;
    public static TimestampParseResult KindLeadingWhitespaceNotSupported;
    public static TimestampParseResult KindTrailingWhitespaceNotSupported;
    public static TimestampParseResult KindMissingUtcSign;
    public static TimestampParseResult KindExtraCharactors;
    public static TimestampParseResult KindInvalidYear;
    public static TimestampParseResult KindInvalidMonth;
    public static TimestampParseResult KindInvalidDay;
    public static TimestampParseResult KindInvalidHour;
    public static TimestampParseResult KindInvalidMinute;
    public static TimestampParseResult KindInvalidSecond;
    public static TimestampParseResult KindInvalidNanoSecond;
    public static TimestampParseResult KindYearOutOfRange;
    public static TimestampParseResult KindInvalidYearMonthDeilimiter;
    public static TimestampParseResult KindInvalidMonthDayDelimiter;
    public static TimestampParseResult KindInvalidDateTimeDelimiter;
    public static TimestampParseResult KindInvalidHourMinuteDelimiter;
    public static TimestampParseResult KindInvalidMinuteSecondDelimiter;
    public static TimestampParseResult KindInvalidSubsecondDelimiter;
    public static TimestampParseResult KindNoMatchedFormats;
    public static TimestampParseResult ParameterMask;
    public static TimestampParseResult ParameterInput;
    public static TimestampParseResult ParameterFormat;
    public static TimestampParseResult ExceptionTypeMask;
    public static TimestampParseResult ArgumentNullException;
    public static TimestampParseResult ArgumentException;
    public static TimestampParseResult FormatException;
    public static TimestampParseResult NullInput;
    public static TimestampParseResult NullFormat;
    public static TimestampParseResult EmptyInput;
    public static TimestampParseResult EmptyFormat;
    public static TimestampParseResult UnsupportedFormat;
    public static TimestampParseResult LeadingWhitespaceNotAllowed;
    public static TimestampParseResult TrailingWhitespaceNotAllowed;
    public static TimestampParseResult MissingUtcSign;
    public static TimestampParseResult ExtraCharactors;
    public static TimestampParseResult InvalidYear;
    public static TimestampParseResult InvalidMonth;
    public static TimestampParseResult InvalidDay;
    public static TimestampParseResult InvalidHour;
    public static TimestampParseResult InvalidMinute;
    public static TimestampParseResult InvalidSecond;
    public static TimestampParseResult InvalidNanoSecond;
    public static TimestampParseResult YearOutOfRange;
    public static TimestampParseResult InvalidYearMonthDeilimiter;
    public static TimestampParseResult InvalidMonthDayDelimiter;
    public static TimestampParseResult InvalidDateTimeDelimiter;
    public static TimestampParseResult InvalidHourMinuteDelimiter;
    public static TimestampParseResult InvalidMinuteSecondDelimiter;
    public static TimestampParseResult InvalidSubsecondDelimiter;
    public static TimestampParseResult NoMatchedFormats;
}
internal static class MsgPack.TimestampStringConverter : object {
    private static char DateDelimiter;
    private static char TimeDelimiter;
    private static char DateTimeDelimiter;
    private static char SubsecondDelimiter;
    private static char UtcSign;
    private static string DefaultFormat;
    public static TimestampParseResult TryParseExact(string input, string format, IFormatProvider formatProvider, DateTimeStyles styles, Timestamp& result);
    private static bool ParseWhitespace(string input, Int32& position, bool allowWhitespace, bool isTrailing);
    private static bool ParseDelimiter(string input, Int32& position, char delimiter);
    private static bool ParseSign(string input, Int32& position, NumberFormatInfo numberFormat, Int32& sign);
    private static bool StartsWith(string input, int startIndex, string comparison);
    private static bool ParseDigit(string input, int minLength, Int32& position, Int64& digit);
    private static bool IsDigit(char c);
    private static bool ParseDigitRange(string input, int minLength, Int32& position, int min, int max, Int32& result);
    private static bool ParseYear(string input, Int32& position, NumberFormatInfo numberFormat, Int64& year);
    private static bool ParseDay(string input, Int32& position, int month, bool isLeapYear, Int32& day);
    public static string ToString(string format, IFormatProvider formatProvider, Value& value);
    private static string ToIso8601String(IFormatProvider formatProvider, bool containsNanosecons, Value& value);
}
internal static class MsgPack.TupleItems : object {
    public static List`1<Type> CreateTupleTypeList(Type rootTupleType);
    public static IList`1<Type> GetTupleItemTypes(Type tupleType);
    private static void GetTupleItemTypes(IList`1<Type> itemTypes, IList`1<Type> result);
    public static bool IsTuple(Type type);
}
public class MsgPack.UnassignedMessageTypeException : MessageTypeException {
    public UnassignedMessageTypeException(string message);
    public UnassignedMessageTypeException(string message, Exception inner);
}
public abstract class MsgPack.Unpacker : object {
    private UnpackerMode _mode;
    [ObsoleteAttribute("Consumer should not use this property. Query LastReadData instead.")]
public Nullable`1<MessagePackObject> Data { get; protected set; }
    public MessagePackObject LastReadData { get; protected set; }
    public bool IsArrayHeader { get; }
    public bool IsMapHeader { get; }
    public bool IsCollectionHeader { get; }
    public long ItemsCount { get; }
    protected Stream UnderlyingStream { get; }
    public abstract virtual Nullable`1<MessagePackObject> get_Data();
    protected abstract virtual void set_Data(Nullable`1<MessagePackObject> value);
    public virtual MessagePackObject get_LastReadData();
    protected virtual void set_LastReadData(MessagePackObject value);
    public abstract virtual bool get_IsArrayHeader();
    public abstract virtual bool get_IsMapHeader();
    public virtual bool get_IsCollectionHeader();
    public abstract virtual long get_ItemsCount();
    internal void VerifyMode(UnpackerMode mode);
    internal void VerifyIsNotDisposed();
    private void ThrowObjectDisposedException();
    internal void ThrowInvalidModeException();
    protected virtual Stream get_UnderlyingStream();
    internal virtual bool GetPreviousPosition(Int64& offsetOrPosition);
    public static Unpacker Create(Stream stream);
    public static Unpacker Create(Stream stream, bool ownsStream);
    public static Unpacker Create(Stream stream, PackerUnpackerStreamOptions streamOptions);
    public static Unpacker Create(Stream stream, PackerUnpackerStreamOptions streamOptions, UnpackerOptions unpackerOptions);
    public static ByteArrayUnpacker Create(Byte[] source);
    public static ByteArrayUnpacker Create(Byte[] source, int startOffset);
    public static ByteArrayUnpacker Create(Byte[] source, UnpackerOptions unpackerOptions);
    public static ByteArrayUnpacker Create(Byte[] source, int startOffset, UnpackerOptions unpackerOptions);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public virtual void Drain();
    public Unpacker ReadSubtree();
    internal virtual Unpacker InternalReadSubtree();
    internal static void ThrowCannotBeSubtreeModeException();
    internal static void ThrowInSubtreeModeException();
    protected abstract virtual Unpacker ReadSubtreeCore();
    protected internal virtual void EndReadSubtree();
    public bool Read();
    internal bool ReadInternal();
    internal virtual void EnsureNotInSubtreeMode();
    private void SetStable();
    protected abstract virtual bool ReadCore();
    [IteratorStateMachineAttribute("MsgPack.Unpacker/<GetEnumerator>d__45")]
public sealed virtual IEnumerator`1<MessagePackObject> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public Nullable`1<long> Skip();
    private void BeginSkip();
    internal virtual void BeginSkipCore();
    private void EndSkip(Nullable`1<long> result);
    protected abstract virtual Nullable`1<long> SkipCore();
    public Nullable`1<MessagePackObject> ReadItem();
    public MessagePackObject ReadItemData();
    internal virtual void ThrowEofException();
    public Nullable`1<MessagePackObject> UnpackSubtree();
    public MessagePackObject UnpackSubtreeData();
    internal bool UnpackSubtreeDataCore(MessagePackObject& result);
    [CLSCompliantAttribute("False")]
public virtual bool ReadBoolean(Boolean& result);
    [CLSCompliantAttribute("False")]
public virtual bool ReadNullableBoolean(Nullable`1& result);
    [CLSCompliantAttribute("False")]
public virtual bool ReadByte(Byte& result);
    [CLSCompliantAttribute("False")]
public virtual bool ReadNullableByte(Nullable`1& result);
    [CLSCompliantAttribute("False")]
public virtual bool ReadSByte(SByte& result);
    [CLSCompliantAttribute("False")]
public virtual bool ReadNullableSByte(Nullable`1& result);
    [CLSCompliantAttribute("False")]
public virtual bool ReadInt16(Int16& result);
    [CLSCompliantAttribute("False")]
public virtual bool ReadNullableInt16(Nullable`1& result);
    [CLSCompliantAttribute("False")]
public virtual bool ReadUInt16(UInt16& result);
    [CLSCompliantAttribute("False")]
public virtual bool ReadNullableUInt16(Nullable`1& result);
    [CLSCompliantAttribute("False")]
public virtual bool ReadInt32(Int32& result);
    [CLSCompliantAttribute("False")]
public virtual bool ReadNullableInt32(Nullable`1& result);
    [CLSCompliantAttribute("False")]
public virtual bool ReadUInt32(UInt32& result);
    [CLSCompliantAttribute("False")]
public virtual bool ReadNullableUInt32(Nullable`1& result);
    [CLSCompliantAttribute("False")]
public virtual bool ReadInt64(Int64& result);
    [CLSCompliantAttribute("False")]
public virtual bool ReadNullableInt64(Nullable`1& result);
    [CLSCompliantAttribute("False")]
public virtual bool ReadUInt64(UInt64& result);
    [CLSCompliantAttribute("False")]
public virtual bool ReadNullableUInt64(Nullable`1& result);
    [CLSCompliantAttribute("False")]
public virtual bool ReadSingle(Single& result);
    [CLSCompliantAttribute("False")]
public virtual bool ReadNullableSingle(Nullable`1& result);
    [CLSCompliantAttribute("False")]
public virtual bool ReadDouble(Double& result);
    [CLSCompliantAttribute("False")]
public virtual bool ReadNullableDouble(Nullable`1& result);
    public virtual bool ReadMessagePackExtendedTypeObject(MessagePackExtendedTypeObject& result);
    public virtual bool ReadNullableMessagePackExtendedTypeObject(Nullable`1& result);
    public virtual bool ReadArrayLength(Int64& result);
    public virtual bool ReadMapLength(Int64& result);
    public virtual bool ReadBinary(Byte[]& result);
    public virtual bool ReadString(String& result);
    public virtual bool ReadObject(MessagePackObject& result);
}
public class MsgPack.UnpackerOptions : object {
    [CompilerGeneratedAttribute]
private UnpackerValidationLevel <ValidationLevel>k__BackingField;
    public UnpackerValidationLevel ValidationLevel { get; public set; }
    [CompilerGeneratedAttribute]
public UnpackerValidationLevel get_ValidationLevel();
    [CompilerGeneratedAttribute]
public void set_ValidationLevel(UnpackerValidationLevel value);
}
public enum MsgPack.UnpackerValidationLevel : Enum {
    public int value__;
    public static UnpackerValidationLevel None;
    public static UnpackerValidationLevel Collection;
}
public class MsgPack.UnpackException : Exception {
    public UnpackException(string message);
    public UnpackException(string message, Exception inner);
}
public static class MsgPack.Unpacking : object {
    private static void ValidateByteArray(Byte[] source, int offset);
    private static void ValidateStream(Stream source);
    private static void UnpackOne(Unpacker unpacker);
    private static void VerifyIsScalar(Unpacker unpacker);
    private static bool UnpackBooleanCore(Stream source);
    private static object UnpackNullCore(Stream source);
    private static Nullable`1<UInt32> UnpackArrayLengthCore(Stream source);
    private static IList`1<MessagePackObject> UnpackArrayCore(Stream source);
    private static IList`1<MessagePackObject> UnpackArrayCore(Unpacker unpacker);
    private static Nullable`1<UInt32> UnpackDictionaryCountCore(Stream source);
    private static MessagePackObjectDictionary UnpackDictionaryCore(Stream source);
    private static MessagePackObjectDictionary UnpackDictionaryCore(Unpacker unpacker);
    private static UInt32 UnpackRawLengthCore(Stream source);
    private static Byte[] ReadBytes(Stream source, int length);
    private static Byte[] UnpackBinaryCore(Stream source);
    private static MessagePackObject UnpackObjectCore(Stream source);
    private static MessagePackObject UnpackObjectCore(Unpacker unpacker);
    private static MessagePackExtendedTypeObject UnpackExtendedTypeObjectCore(Stream source);
    private static bool IsNil(Unpacker unpacker);
    private static Exception NewTypeMismatchException(Type requestedType, InvalidOperationException innerException);
    public static UnpackingResult`1<byte> UnpackByte(Byte[] source);
    public static UnpackingResult`1<byte> UnpackByte(Byte[] source, int offset);
    public static byte UnpackByte(Stream source);
    private static byte UnpackByteCore(Stream source);
    [CLSCompliantAttribute("False")]
public static UnpackingResult`1<sbyte> UnpackSByte(Byte[] source);
    [CLSCompliantAttribute("False")]
public static UnpackingResult`1<sbyte> UnpackSByte(Byte[] source, int offset);
    [CLSCompliantAttribute("False")]
public static sbyte UnpackSByte(Stream source);
    private static sbyte UnpackSByteCore(Stream source);
    public static UnpackingResult`1<short> UnpackInt16(Byte[] source);
    public static UnpackingResult`1<short> UnpackInt16(Byte[] source, int offset);
    public static short UnpackInt16(Stream source);
    private static short UnpackInt16Core(Stream source);
    [CLSCompliantAttribute("False")]
public static UnpackingResult`1<ushort> UnpackUInt16(Byte[] source);
    [CLSCompliantAttribute("False")]
public static UnpackingResult`1<ushort> UnpackUInt16(Byte[] source, int offset);
    [CLSCompliantAttribute("False")]
public static ushort UnpackUInt16(Stream source);
    private static ushort UnpackUInt16Core(Stream source);
    public static UnpackingResult`1<int> UnpackInt32(Byte[] source);
    public static UnpackingResult`1<int> UnpackInt32(Byte[] source, int offset);
    public static int UnpackInt32(Stream source);
    private static int UnpackInt32Core(Stream source);
    [CLSCompliantAttribute("False")]
public static UnpackingResult`1<UInt32> UnpackUInt32(Byte[] source);
    [CLSCompliantAttribute("False")]
public static UnpackingResult`1<UInt32> UnpackUInt32(Byte[] source, int offset);
    [CLSCompliantAttribute("False")]
public static UInt32 UnpackUInt32(Stream source);
    private static UInt32 UnpackUInt32Core(Stream source);
    public static UnpackingResult`1<long> UnpackInt64(Byte[] source);
    public static UnpackingResult`1<long> UnpackInt64(Byte[] source, int offset);
    public static long UnpackInt64(Stream source);
    private static long UnpackInt64Core(Stream source);
    [CLSCompliantAttribute("False")]
public static UnpackingResult`1<ulong> UnpackUInt64(Byte[] source);
    [CLSCompliantAttribute("False")]
public static UnpackingResult`1<ulong> UnpackUInt64(Byte[] source, int offset);
    [CLSCompliantAttribute("False")]
public static ulong UnpackUInt64(Stream source);
    private static ulong UnpackUInt64Core(Stream source);
    public static UnpackingResult`1<float> UnpackSingle(Byte[] source);
    public static UnpackingResult`1<float> UnpackSingle(Byte[] source, int offset);
    public static float UnpackSingle(Stream source);
    private static float UnpackSingleCore(Stream source);
    public static UnpackingResult`1<double> UnpackDouble(Byte[] source);
    public static UnpackingResult`1<double> UnpackDouble(Byte[] source, int offset);
    public static double UnpackDouble(Stream source);
    private static double UnpackDoubleCore(Stream source);
    public static UnpackingResult`1<IList`1<MessagePackObject>> UnpackArray(Byte[] source);
    public static UnpackingResult`1<IList`1<MessagePackObject>> UnpackArray(Byte[] source, int offset);
    public static IList`1<MessagePackObject> UnpackArray(Stream source);
    public static UnpackingResult`1<Nullable`1<long>> UnpackArrayLength(Byte[] source);
    public static UnpackingResult`1<Nullable`1<long>> UnpackArrayLength(Byte[] source, int offset);
    public static Nullable`1<long> UnpackArrayLength(Stream source);
    public static UnpackingResult`1<MessagePackObjectDictionary> UnpackDictionary(Byte[] source);
    public static UnpackingResult`1<MessagePackObjectDictionary> UnpackDictionary(Byte[] source, int offset);
    public static MessagePackObjectDictionary UnpackDictionary(Stream source);
    public static UnpackingResult`1<Nullable`1<long>> UnpackDictionaryCount(Byte[] source);
    public static UnpackingResult`1<Nullable`1<long>> UnpackDictionaryCount(Byte[] source, int offset);
    public static Nullable`1<long> UnpackDictionaryCount(Stream source);
    public static UnpackingResult`1<Byte[]> UnpackBinary(Byte[] source);
    public static UnpackingResult`1<Byte[]> UnpackBinary(Byte[] source, int offset);
    public static Byte[] UnpackBinary(Stream source);
    public static UnpackingResult`1<bool> UnpackBoolean(Byte[] source);
    public static UnpackingResult`1<bool> UnpackBoolean(Byte[] source, int offset);
    public static bool UnpackBoolean(Stream source);
    public static UnpackingResult`1<object> UnpackNull(Byte[] source);
    public static UnpackingResult`1<object> UnpackNull(Byte[] source, int offset);
    public static object UnpackNull(Stream source);
    public static UnpackingResult`1<MessagePackObject> UnpackObject(Byte[] source);
    public static UnpackingResult`1<MessagePackObject> UnpackObject(Byte[] source, int offset);
    public static MessagePackObject UnpackObject(Stream source);
    public static UnpackingResult`1<MessagePackExtendedTypeObject> UnpackExtendedTypeObject(Byte[] source);
    public static UnpackingResult`1<MessagePackExtendedTypeObject> UnpackExtendedTypeObject(Byte[] source, int offset);
    public static MessagePackExtendedTypeObject UnpackExtendedTypeObject(Stream source);
    public static UnpackingStream UnpackByteStream(Stream source);
    private static UnpackingStream UnpackByteStreamCore(Stream source);
    public static UnpackingStreamReader UnpackCharStream(Stream source);
    public static UnpackingStreamReader UnpackCharStream(Stream source, Encoding encoding);
    public static UnpackingResult`1<string> UnpackString(Byte[] source);
    public static UnpackingResult`1<string> UnpackString(Byte[] source, Encoding encoding);
    public static UnpackingResult`1<string> UnpackString(Byte[] source, int offset);
    public static UnpackingResult`1<string> UnpackString(Byte[] source, int offset, Encoding encoding);
    public static string UnpackString(Stream source);
    public static string UnpackString(Stream source, Encoding encoding);
    private static Exception NewInvalidEncodingException(Encoding encoding, Exception innerException);
}
internal enum MsgPack.UnpackingMode : Enum {
    public int value__;
    public static UnpackingMode PerEntry;
    public static UnpackingMode SkipSubtree;
}
public class MsgPack.UnpackingResult`1 : ValueType {
    private int _readCount;
    private T _value;
    public int ReadCount { get; }
    public T Value { get; }
    internal UnpackingResult`1(T value, int readCount);
    public int get_ReadCount();
    public T get_Value();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(UnpackingResult`1<T> other);
    public virtual int GetHashCode();
    public virtual string ToString();
    public static bool op_Equality(UnpackingResult`1<T> left, UnpackingResult`1<T> right);
    public static bool op_Inequality(UnpackingResult`1<T> left, UnpackingResult`1<T> right);
}
public abstract class MsgPack.UnpackingStream : Stream {
    internal Stream Underlying;
    internal long RawLength;
    internal long CurrentOffset;
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public bool CanTimeout { get; }
    internal UnpackingStream(Stream underlying, long rawLength);
    public sealed virtual bool get_CanRead();
    public sealed virtual bool get_CanWrite();
    public sealed virtual long get_Length();
    public sealed virtual bool get_CanTimeout();
    public sealed virtual int Read(Byte[] buffer, int offset, int count);
    public sealed virtual void Flush();
    public sealed virtual void SetLength(long value);
    public sealed virtual void Write(Byte[] buffer, int offset, int count);
}
public abstract class MsgPack.UnpackingStreamReader : StreamReader {
    private long _byteLength;
    public long ByteLength { get; }
    internal UnpackingStreamReader(Stream stream, Encoding encoding, long byteLength);
    public long get_ByteLength();
}
