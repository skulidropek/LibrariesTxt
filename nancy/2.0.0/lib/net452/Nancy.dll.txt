public class Nancy.AfterPipeline : AsyncNamedPipelineBase`2<Func`3<NancyContext, CancellationToken, Task>, Action`1<NancyContext>> {
    public AfterPipeline(int capacity);
    public static Func`3<NancyContext, CancellationToken, Task> op_Implicit(AfterPipeline pipeline);
    public static AfterPipeline op_Implicit(Func`3<NancyContext, CancellationToken, Task> func);
    public static AfterPipeline op_Addition(AfterPipeline pipeline, Func`3<NancyContext, CancellationToken, Task> func);
    public static AfterPipeline op_Addition(AfterPipeline pipeline, Action`1<NancyContext> action);
    public static AfterPipeline op_Addition(AfterPipeline pipelineToAddTo, AfterPipeline pipelineToAdd);
    [AsyncStateMachineAttribute("Nancy.AfterPipeline/<Invoke>d__7")]
public Task Invoke(NancyContext context, CancellationToken cancellationToken);
    protected virtual PipelineItem`1<Func`3<NancyContext, CancellationToken, Task>> Wrap(PipelineItem`1<Action`1<NancyContext>> pipelineItem);
}
public class Nancy.AppDomainAssemblyCatalog : object {
    private static AssemblyName NancyAssemblyName;
    private Lazy`1<IReadOnlyCollection`1<Assembly>> assemblies;
    private static AppDomainAssemblyCatalog();
    public virtual IReadOnlyCollection`1<Assembly> GetAssemblies();
    private static IReadOnlyCollection`1<Assembly> GetAvailableAssemblies();
    private static List`1<Assembly> GetLoadedNancyReferencingAssemblies();
    private static IEnumerable`1<Assembly> LoadNancyReferencingAssemblies(IEnumerable`1<Assembly> loadedAssemblies);
    private static AppDomain CreateInspectionAppDomain();
    private static ProxyNancyReferenceProber CreateRemoteReferenceProber(AppDomain appDomain);
    [IteratorStateMachineAttribute("Nancy.AppDomainAssemblyCatalog/<GetAssemblyDirectories>d__8")]
private static IEnumerable`1<string> GetAssemblyDirectories();
    private static AssemblyName SafeGetAssemblyName(string assemblyPath);
    private static Assembly SafeLoadAssembly(AppDomain domain, AssemblyName assemblyName);
}
public class Nancy.ArrayCache : object {
    public static T[] Empty();
}
public abstract class Nancy.AsyncNamedPipelineBase`2 : object {
    protected List`1<PipelineItem`1<TAsyncDelegate>> pipelineItems;
    public IEnumerable`1<PipelineItem`1<TAsyncDelegate>> PipelineItems { get; }
    public IEnumerable`1<TAsyncDelegate> PipelineDelegates { get; }
    protected AsyncNamedPipelineBase`2(int capacity);
    public IEnumerable`1<PipelineItem`1<TAsyncDelegate>> get_PipelineItems();
    public IEnumerable`1<TAsyncDelegate> get_PipelineDelegates();
    public virtual void AddItemToStartOfPipeline(TAsyncDelegate item);
    public virtual void AddItemToStartOfPipeline(TSyncDelegate item);
    public virtual void AddItemToStartOfPipeline(PipelineItem`1<TAsyncDelegate> item, bool replaceInPlace);
    public virtual void AddItemToStartOfPipeline(PipelineItem`1<TSyncDelegate> item, bool replaceInPlace);
    public virtual void AddItemToEndOfPipeline(TAsyncDelegate item);
    public virtual void AddItemToEndOfPipeline(TSyncDelegate item);
    public virtual void AddItemToEndOfPipeline(PipelineItem`1<TAsyncDelegate> item, bool replaceInPlace);
    public virtual void AddItemToEndOfPipeline(PipelineItem`1<TSyncDelegate> item, bool replaceInPlace);
    public virtual void InsertItemAtPipelineIndex(int index, TAsyncDelegate item);
    public virtual void InsertItemAtPipelineIndex(int index, TSyncDelegate item);
    public virtual void InsertItemAtPipelineIndex(int index, PipelineItem`1<TAsyncDelegate> item, bool replaceInPlace);
    public virtual void InsertItemAtPipelineIndex(int index, PipelineItem`1<TSyncDelegate> item, bool replaceInPlace);
    public virtual void InsertBefore(string name, TAsyncDelegate item);
    public virtual void InsertBefore(string name, TSyncDelegate item);
    public virtual void InsertBefore(string name, PipelineItem`1<TAsyncDelegate> item);
    public virtual void InsertBefore(string name, PipelineItem`1<TSyncDelegate> item);
    public virtual void InsertAfter(string name, TAsyncDelegate item);
    public virtual void InsertAfter(string name, TSyncDelegate item);
    public virtual void InsertAfter(string name, PipelineItem`1<TAsyncDelegate> item);
    public virtual void InsertAfter(string name, PipelineItem`1<TSyncDelegate> item);
    public virtual int RemoveByName(string name);
    protected abstract virtual PipelineItem`1<TAsyncDelegate> Wrap(PipelineItem`1<TSyncDelegate> syncDelegate);
}
public class Nancy.BeforePipeline : AsyncNamedPipelineBase`2<Func`3<NancyContext, CancellationToken, Task`1<Response>>, Func`2<NancyContext, Response>> {
    public BeforePipeline(int capacity);
    public static Func`3<NancyContext, CancellationToken, Task`1<Response>> op_Implicit(BeforePipeline pipeline);
    public static BeforePipeline op_Implicit(Func`3<NancyContext, CancellationToken, Task`1<Response>> func);
    public static BeforePipeline op_Addition(BeforePipeline pipeline, Func`3<NancyContext, CancellationToken, Task`1<Response>> func);
    public static BeforePipeline op_Addition(BeforePipeline pipeline, Func`2<NancyContext, Response> action);
    public static BeforePipeline op_Addition(BeforePipeline pipelineToAddTo, BeforePipeline pipelineToAdd);
    [AsyncStateMachineAttribute("Nancy.BeforePipeline/<Invoke>d__7")]
public Task`1<Response> Invoke(NancyContext context, CancellationToken cancellationToken);
    protected virtual PipelineItem`1<Func`3<NancyContext, CancellationToken, Task`1<Response>>> Wrap(PipelineItem`1<Func`2<NancyContext, Response>> pipelineItem);
}
public class Nancy.Bootstrapper.BootstrapperException : Exception {
    public BootstrapperException(string message);
    public BootstrapperException(string message, Exception innerException);
    protected BootstrapperException(SerializationInfo info, StreamingContext context);
}
public class Nancy.Bootstrapper.CollectionTypeRegistration : ContainerRegistration {
    [CompilerGeneratedAttribute]
private IEnumerable`1<Type> <ImplementationTypes>k__BackingField;
    public IEnumerable`1<Type> ImplementationTypes { get; private set; }
    public CollectionTypeRegistration(Type registrationType, IEnumerable`1<Type> implementationTypes, Lifetime lifetime);
    [CompilerGeneratedAttribute]
public IEnumerable`1<Type> get_ImplementationTypes();
    [CompilerGeneratedAttribute]
private void set_ImplementationTypes(IEnumerable`1<Type> value);
}
public abstract class Nancy.Bootstrapper.ContainerRegistration : object {
    [CompilerGeneratedAttribute]
private Lifetime <Lifetime>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <RegistrationType>k__BackingField;
    public Lifetime Lifetime { get; protected set; }
    public Type RegistrationType { get; protected set; }
    [CompilerGeneratedAttribute]
public Lifetime get_Lifetime();
    [CompilerGeneratedAttribute]
protected void set_Lifetime(Lifetime value);
    [CompilerGeneratedAttribute]
public Type get_RegistrationType();
    [CompilerGeneratedAttribute]
protected void set_RegistrationType(Type value);
    protected void ValidateTypeCompatibility(Type[] types);
    [CompilerGeneratedAttribute]
private bool <ValidateTypeCompatibility>b__8_0(Type type);
}
public class Nancy.Bootstrapper.FavIconApplicationStartup : object {
    private static TraceConfiguration traceConfiguration;
    private static IRootPathProvider rootPathProvider;
    private static Byte[] favIcon;
    public static Byte[] FavIcon { get; }
    public FavIconApplicationStartup(IRootPathProvider rootPathProvider, INancyEnvironment environment);
    public static Byte[] get_FavIcon();
    public sealed virtual void Initialize(IPipelines pipelines);
    private static Byte[] ExtractDefaultIcon();
    private static Byte[] LocateIconOnFileSystem();
    private static IEnumerable`1<string> EnumerateFiles(string extension);
    private static Byte[] ScanForFavIcon();
}
public interface Nancy.Bootstrapper.IApplicationStartup {
    public abstract virtual void Initialize(IPipelines pipelines);
}
public interface Nancy.Bootstrapper.INancyBootstrapper {
    public abstract virtual void Initialise();
    public abstract virtual INancyEngine GetEngine();
    public abstract virtual INancyEnvironment GetEnvironment();
}
public class Nancy.Bootstrapper.InstanceRegistration : ContainerRegistration {
    [CompilerGeneratedAttribute]
private object <Implementation>k__BackingField;
    public object Implementation { get; private set; }
    public InstanceRegistration(Type registrationType, object implementation);
    [CompilerGeneratedAttribute]
public object get_Implementation();
    [CompilerGeneratedAttribute]
private void set_Implementation(object value);
}
public interface Nancy.Bootstrapper.IPipelines {
    public BeforePipeline BeforeRequest { get; public set; }
    public AfterPipeline AfterRequest { get; public set; }
    public ErrorPipeline OnError { get; public set; }
    public abstract virtual BeforePipeline get_BeforeRequest();
    public abstract virtual void set_BeforeRequest(BeforePipeline value);
    public abstract virtual AfterPipeline get_AfterRequest();
    public abstract virtual void set_AfterRequest(AfterPipeline value);
    public abstract virtual ErrorPipeline get_OnError();
    public abstract virtual void set_OnError(ErrorPipeline value);
}
public interface Nancy.Bootstrapper.IRegistrations {
    public IEnumerable`1<TypeRegistration> TypeRegistrations { get; }
    public IEnumerable`1<CollectionTypeRegistration> CollectionTypeRegistrations { get; }
    public IEnumerable`1<InstanceRegistration> InstanceRegistrations { get; }
    public abstract virtual IEnumerable`1<TypeRegistration> get_TypeRegistrations();
    public abstract virtual IEnumerable`1<CollectionTypeRegistration> get_CollectionTypeRegistrations();
    public abstract virtual IEnumerable`1<InstanceRegistration> get_InstanceRegistrations();
}
public interface Nancy.Bootstrapper.IRequestStartup {
    public abstract virtual void Initialize(IPipelines pipelines, NancyContext context);
}
public enum Nancy.Bootstrapper.Lifetime : Enum {
    public int value__;
    public static Lifetime Transient;
    public static Lifetime Singleton;
    public static Lifetime PerRequest;
}
public class Nancy.Bootstrapper.ModuleRegistration : object {
    [CompilerGeneratedAttribute]
private Type <ModuleType>k__BackingField;
    public Type ModuleType { get; private set; }
    public ModuleRegistration(Type moduleType);
    [CompilerGeneratedAttribute]
public Type get_ModuleType();
    [CompilerGeneratedAttribute]
private void set_ModuleType(Type value);
}
public class Nancy.Bootstrapper.MultipleRootPathProvidersLocatedException : BootstrapperException {
    private static string DefaultMessageIntroduction;
    private static string DefaultMessageConclusion;
    private static string DefaultMessage;
    private string errorMessage;
    [CompilerGeneratedAttribute]
private IEnumerable`1<Type> <ProviderTypes>k__BackingField;
    public IEnumerable`1<Type> ProviderTypes { get; internal set; }
    public string Message { get; }
    public MultipleRootPathProvidersLocatedException(string message);
    public MultipleRootPathProvidersLocatedException(string message, Exception innerException);
    public MultipleRootPathProvidersLocatedException(IEnumerable`1<Type> providerTypes);
    protected MultipleRootPathProvidersLocatedException(SerializationInfo info, StreamingContext context);
    [CompilerGeneratedAttribute]
public IEnumerable`1<Type> get_ProviderTypes();
    [CompilerGeneratedAttribute]
internal void set_ProviderTypes(IEnumerable`1<Type> value);
    private void StoreProviderTypes(IEnumerable`1<Type> providerTypes);
    public virtual string get_Message();
    private string GetErrorMessage();
}
public abstract class Nancy.Bootstrapper.NancyBootstrapperBase`1 : object {
    private bool initialised;
    private bool disposing;
    private IRootPathProvider rootPathProvider;
    private NancyConventions conventions;
    private Func`2<ITypeCatalog, NancyInternalConfiguration> internalConfigurationFactory;
    private NancyInternalConfiguration internalConfiguration;
    [CompilerGeneratedAttribute]
private IPipelines <ApplicationPipelines>k__BackingField;
    private ModuleRegistration[] modules;
    [CompilerGeneratedAttribute]
private Type[] <RequestStartupTaskTypeCache>k__BackingField;
    private IAssemblyCatalog assemblyCatalog;
    private ITypeCatalog typeCatalog;
    [CompilerGeneratedAttribute]
private TContainer <ApplicationContainer>k__BackingField;
    protected IPipelines ApplicationPipelines { get; private set; }
    protected Type[] RequestStartupTaskTypeCache { get; private set; }
    protected TContainer ApplicationContainer { get; private set; }
    protected IAssemblyCatalog AssemblyCatalog { get; }
    protected ITypeCatalog TypeCatalog { get; }
    protected Func`2<ITypeCatalog, NancyInternalConfiguration> InternalConfiguration { get; }
    protected NancyConventions Conventions { get; }
    protected IEnumerable`1<ModuleRegistration> Modules { get; }
    protected IEnumerable`1<Type> ViewEngines { get; }
    protected IEnumerable`1<Type> ModelBinders { get; }
    protected IEnumerable`1<Type> TypeConverters { get; }
    protected IEnumerable`1<Type> BodyDeserializers { get; }
    protected IEnumerable`1<Type> ApplicationStartupTasks { get; }
    protected IEnumerable`1<Type> RequestStartupTasks { get; }
    protected IEnumerable`1<Type> RegistrationTasks { get; }
    protected IRootPathProvider RootPathProvider { get; }
    protected IEnumerable`1<Type> ModelValidatorFactories { get; }
    protected Byte[] FavIcon { get; }
    protected CryptographyConfiguration CryptographyConfiguration { get; }
    [CompilerGeneratedAttribute]
protected IPipelines get_ApplicationPipelines();
    [CompilerGeneratedAttribute]
private void set_ApplicationPipelines(IPipelines value);
    [CompilerGeneratedAttribute]
protected Type[] get_RequestStartupTaskTypeCache();
    [CompilerGeneratedAttribute]
private void set_RequestStartupTaskTypeCache(Type[] value);
    [CompilerGeneratedAttribute]
protected TContainer get_ApplicationContainer();
    [CompilerGeneratedAttribute]
private void set_ApplicationContainer(TContainer value);
    protected virtual IAssemblyCatalog get_AssemblyCatalog();
    protected virtual ITypeCatalog get_TypeCatalog();
    protected virtual Func`2<ITypeCatalog, NancyInternalConfiguration> get_InternalConfiguration();
    protected virtual NancyConventions get_Conventions();
    protected virtual IEnumerable`1<ModuleRegistration> get_Modules();
    protected virtual IEnumerable`1<Type> get_ViewEngines();
    protected virtual IEnumerable`1<Type> get_ModelBinders();
    protected virtual IEnumerable`1<Type> get_TypeConverters();
    protected virtual IEnumerable`1<Type> get_BodyDeserializers();
    protected virtual IEnumerable`1<Type> get_ApplicationStartupTasks();
    protected virtual IEnumerable`1<Type> get_RequestStartupTasks();
    protected virtual IEnumerable`1<Type> get_RegistrationTasks();
    protected virtual IRootPathProvider get_RootPathProvider();
    protected virtual IEnumerable`1<Type> get_ModelValidatorFactories();
    protected virtual Byte[] get_FavIcon();
    protected virtual CryptographyConfiguration get_CryptographyConfiguration();
    private NancyInternalConfiguration GetInitializedInternalConfiguration();
    public sealed virtual void Initialise();
    public virtual void Configure(INancyEnvironment environment);
    protected abstract virtual INancyEnvironmentConfigurator GetEnvironmentConfigurator();
    protected abstract virtual IDiagnostics GetDiagnostics();
    protected abstract virtual IEnumerable`1<IApplicationStartup> GetApplicationStartupTasks();
    protected abstract virtual IEnumerable`1<IRequestStartup> RegisterAndGetRequestStartupTasks(TContainer container, Type[] requestStartupTypes);
    protected abstract virtual IEnumerable`1<IRegistrations> GetRegistrationTasks();
    public abstract virtual IEnumerable`1<INancyModule> GetAllModules(NancyContext context);
    public abstract virtual INancyModule GetModule(Type moduleType, NancyContext context);
    public sealed virtual INancyEngine GetEngine();
    public abstract virtual INancyEnvironment GetEnvironment();
    public sealed virtual void Dispose();
    public sealed virtual bool Equals(object obj);
    public sealed virtual int GetHashCode();
    protected virtual IPipelines InitializeRequestPipelines(NancyContext context);
    public sealed virtual string ToString();
    protected virtual void ApplicationStartup(TContainer container, IPipelines pipelines);
    protected virtual void RequestStartup(TContainer container, IPipelines pipelines, NancyContext context);
    protected virtual void ConfigureApplicationContainer(TContainer existingContainer);
    protected virtual void ConfigureConventions(NancyConventions nancyConventions);
    protected virtual void Dispose(bool disposing);
    protected abstract virtual INancyEngine GetEngineInternal();
    protected abstract virtual TContainer GetApplicationContainer();
    protected abstract virtual void RegisterNancyEnvironment(TContainer container, INancyEnvironment environment);
    protected abstract virtual void RegisterBootstrapperTypes(TContainer applicationContainer);
    protected abstract virtual void RegisterTypes(TContainer container, IEnumerable`1<TypeRegistration> typeRegistrations);
    protected abstract virtual void RegisterCollectionTypes(TContainer container, IEnumerable`1<CollectionTypeRegistration> collectionTypeRegistrationsn);
    protected abstract virtual void RegisterModules(TContainer container, IEnumerable`1<ModuleRegistration> moduleRegistrationTypes);
    protected abstract virtual void RegisterInstances(TContainer container, IEnumerable`1<InstanceRegistration> instanceRegistrations);
    private IEnumerable`1<InstanceRegistration> GetAdditionalInstances();
    private IEnumerable`1<CollectionTypeRegistration> GetApplicationCollections();
    private INancyEngine SafeGetNancyEngineInstance();
    protected virtual void RegisterRegistrationTasks(IEnumerable`1<IRegistrations> registrationTasks);
    private IRootPathProvider GetRootPathProvider();
    [CompilerGeneratedAttribute]
private Response <Initialise>b__55_0(NancyContext ctx);
    [CompilerGeneratedAttribute]
private void <Initialise>b__55_1(Stream s);
}
public static class Nancy.Bootstrapper.NancyBootstrapperLocator : object {
    private static INancyBootstrapper instance;
    private static AssemblyName NancyAssemblyName;
    public static INancyBootstrapper Bootstrapper { get; public set; }
    private static NancyBootstrapperLocator();
    public static INancyBootstrapper get_Bootstrapper();
    public static void set_Bootstrapper(INancyBootstrapper value);
    private static INancyBootstrapper LocateBootstrapper();
    private static ITypeCatalog GetDefaultTypeCatalog();
    private static IReadOnlyCollection`1<Type> GetAvailableBootstrapperTypes(ITypeCatalog types);
    private static IAssemblyCatalog GetAssemblyCatalog();
    private static bool IsNancyReferencing(Assembly assembly);
    internal static Type GetBootstrapperType();
    internal static Type GetBootstrapperType(ITypeCatalog typeCatalog);
    internal static bool TryFindMostDerivedType(IReadOnlyCollection`1<Type> customBootstrappers, Type& bootstrapper);
    private static string GetMultipleBootstrappersMessage(IEnumerable`1<Type> customBootstrappers);
}
public abstract class Nancy.Bootstrapper.NancyBootstrapperWithRequestContainerBase`1 : NancyBootstrapperBase`1<TContainer> {
    private string contextKey;
    private IEnumerable`1<ModuleRegistration> moduleRegistrationTypeCache;
    [CompilerGeneratedAttribute]
private TypeRegistration[] <RequestScopedTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private CollectionTypeRegistration[] <RequestScopedCollectionTypes>k__BackingField;
    private TypeRegistration[] RequestScopedTypes { get; private set; }
    private CollectionTypeRegistration[] RequestScopedCollectionTypes { get; private set; }
    protected string ContextKey { get; }
    [CompilerGeneratedAttribute]
private TypeRegistration[] get_RequestScopedTypes();
    [CompilerGeneratedAttribute]
private void set_RequestScopedTypes(TypeRegistration[] value);
    [CompilerGeneratedAttribute]
private CollectionTypeRegistration[] get_RequestScopedCollectionTypes();
    [CompilerGeneratedAttribute]
private void set_RequestScopedCollectionTypes(CollectionTypeRegistration[] value);
    protected virtual string get_ContextKey();
    public sealed virtual IEnumerable`1<INancyModule> GetAllModules(NancyContext context);
    public sealed virtual INancyModule GetModule(Type moduleType, NancyContext context);
    protected sealed virtual IPipelines InitializeRequestPipelines(NancyContext context);
    protected sealed virtual void RegisterRegistrationTasks(IEnumerable`1<IRegistrations> registrationTasks);
    protected TContainer GetConfiguredRequestContainer(NancyContext context);
    protected virtual void ConfigureRequestContainer(TContainer container, NancyContext context);
    protected sealed virtual void RegisterModules(TContainer container, IEnumerable`1<ModuleRegistration> moduleRegistrationTypes);
    protected abstract virtual TContainer CreateRequestContainer(NancyContext context);
    protected abstract virtual void RegisterRequestContainerModules(TContainer container, IEnumerable`1<ModuleRegistration> moduleRegistrationTypes);
    protected abstract virtual IEnumerable`1<INancyModule> GetAllModules(TContainer container);
    protected abstract virtual INancyModule GetModule(TContainer container, Type moduleType);
}
public class Nancy.Bootstrapper.NancyInternalConfiguration : object {
    [CompilerGeneratedAttribute]
private Type <RuntimeEnvironmentInformation>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <SerializerFactory>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<Type> <DefaultConfigurationProviders>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <EnvironmentConfigurator>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <EnvironmentFactory>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<Type> <RouteMetadataProviders>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <RouteResolver>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <ContextFactory>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <NancyEngine>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <RouteCache>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <RouteCacheProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <ViewLocator>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <ViewFactory>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <NancyModuleBuilder>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <ResponseFormatterFactory>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <ModelBinderLocator>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <Binder>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <BindingDefaults>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <FieldNameConverter>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <ModelValidatorLocator>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <ViewResolver>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <ViewCache>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <RenderContextFactory>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <ViewLocationProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<Type> <StatusCodeHandlers>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <CsrfTokenValidator>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <ObjectSerializer>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<Type> <Serializers>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<Type> <InteractiveDiagnosticProviders>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <RequestTracing>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <RouteInvoker>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<Type> <ResponseProcessors>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <RequestDispatcher>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <Diagnostics>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <RouteSegmentExtractor>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <RouteDescriptionProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <CultureService>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <TextResource>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <ResourceAssemblyProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <ResourceReader>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <StaticContentProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <RouteResolverTrie>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <TrieNodeFactory>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<Type> <RouteSegmentConstraints>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <RequestTraceFactory>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <ResponseNegotiator>k__BackingField;
    public static Func`2<ITypeCatalog, NancyInternalConfiguration> Default { get; }
    public Type RuntimeEnvironmentInformation { get; public set; }
    public Type SerializerFactory { get; public set; }
    public IList`1<Type> DefaultConfigurationProviders { get; public set; }
    public Type EnvironmentConfigurator { get; public set; }
    public Type EnvironmentFactory { get; public set; }
    public IList`1<Type> RouteMetadataProviders { get; public set; }
    public Type RouteResolver { get; public set; }
    public Type ContextFactory { get; public set; }
    public Type NancyEngine { get; public set; }
    public Type RouteCache { get; public set; }
    public Type RouteCacheProvider { get; public set; }
    public Type ViewLocator { get; public set; }
    public Type ViewFactory { get; public set; }
    public Type NancyModuleBuilder { get; public set; }
    public Type ResponseFormatterFactory { get; public set; }
    public Type ModelBinderLocator { get; public set; }
    public Type Binder { get; public set; }
    public Type BindingDefaults { get; public set; }
    public Type FieldNameConverter { get; public set; }
    public Type ModelValidatorLocator { get; public set; }
    public Type ViewResolver { get; public set; }
    public Type ViewCache { get; public set; }
    public Type RenderContextFactory { get; public set; }
    public Type ViewLocationProvider { get; public set; }
    public IList`1<Type> StatusCodeHandlers { get; public set; }
    public Type CsrfTokenValidator { get; public set; }
    public Type ObjectSerializer { get; public set; }
    public IList`1<Type> Serializers { get; public set; }
    public IList`1<Type> InteractiveDiagnosticProviders { get; public set; }
    public Type RequestTracing { get; public set; }
    public Type RouteInvoker { get; public set; }
    public IList`1<Type> ResponseProcessors { get; public set; }
    public Type RequestDispatcher { get; public set; }
    public Type Diagnostics { get; public set; }
    public Type RouteSegmentExtractor { get; public set; }
    public Type RouteDescriptionProvider { get; public set; }
    public Type CultureService { get; public set; }
    public Type TextResource { get; public set; }
    public Type ResourceAssemblyProvider { get; public set; }
    public Type ResourceReader { get; public set; }
    public Type StaticContentProvider { get; public set; }
    public Type RouteResolverTrie { get; public set; }
    public Type TrieNodeFactory { get; public set; }
    public IList`1<Type> RouteSegmentConstraints { get; public set; }
    public Type RequestTraceFactory { get; public set; }
    public Type ResponseNegotiator { get; public set; }
    public bool IsValid { get; }
    public static Func`2<ITypeCatalog, NancyInternalConfiguration> get_Default();
    [CompilerGeneratedAttribute]
public Type get_RuntimeEnvironmentInformation();
    [CompilerGeneratedAttribute]
public void set_RuntimeEnvironmentInformation(Type value);
    [CompilerGeneratedAttribute]
public Type get_SerializerFactory();
    [CompilerGeneratedAttribute]
public void set_SerializerFactory(Type value);
    [CompilerGeneratedAttribute]
public IList`1<Type> get_DefaultConfigurationProviders();
    [CompilerGeneratedAttribute]
public void set_DefaultConfigurationProviders(IList`1<Type> value);
    [CompilerGeneratedAttribute]
public Type get_EnvironmentConfigurator();
    [CompilerGeneratedAttribute]
public void set_EnvironmentConfigurator(Type value);
    [CompilerGeneratedAttribute]
public Type get_EnvironmentFactory();
    [CompilerGeneratedAttribute]
public void set_EnvironmentFactory(Type value);
    [CompilerGeneratedAttribute]
public IList`1<Type> get_RouteMetadataProviders();
    [CompilerGeneratedAttribute]
public void set_RouteMetadataProviders(IList`1<Type> value);
    [CompilerGeneratedAttribute]
public Type get_RouteResolver();
    [CompilerGeneratedAttribute]
public void set_RouteResolver(Type value);
    [CompilerGeneratedAttribute]
public Type get_ContextFactory();
    [CompilerGeneratedAttribute]
public void set_ContextFactory(Type value);
    [CompilerGeneratedAttribute]
public Type get_NancyEngine();
    [CompilerGeneratedAttribute]
public void set_NancyEngine(Type value);
    [CompilerGeneratedAttribute]
public Type get_RouteCache();
    [CompilerGeneratedAttribute]
public void set_RouteCache(Type value);
    [CompilerGeneratedAttribute]
public Type get_RouteCacheProvider();
    [CompilerGeneratedAttribute]
public void set_RouteCacheProvider(Type value);
    [CompilerGeneratedAttribute]
public Type get_ViewLocator();
    [CompilerGeneratedAttribute]
public void set_ViewLocator(Type value);
    [CompilerGeneratedAttribute]
public Type get_ViewFactory();
    [CompilerGeneratedAttribute]
public void set_ViewFactory(Type value);
    [CompilerGeneratedAttribute]
public Type get_NancyModuleBuilder();
    [CompilerGeneratedAttribute]
public void set_NancyModuleBuilder(Type value);
    [CompilerGeneratedAttribute]
public Type get_ResponseFormatterFactory();
    [CompilerGeneratedAttribute]
public void set_ResponseFormatterFactory(Type value);
    [CompilerGeneratedAttribute]
public Type get_ModelBinderLocator();
    [CompilerGeneratedAttribute]
public void set_ModelBinderLocator(Type value);
    [CompilerGeneratedAttribute]
public Type get_Binder();
    [CompilerGeneratedAttribute]
public void set_Binder(Type value);
    [CompilerGeneratedAttribute]
public Type get_BindingDefaults();
    [CompilerGeneratedAttribute]
public void set_BindingDefaults(Type value);
    [CompilerGeneratedAttribute]
public Type get_FieldNameConverter();
    [CompilerGeneratedAttribute]
public void set_FieldNameConverter(Type value);
    [CompilerGeneratedAttribute]
public Type get_ModelValidatorLocator();
    [CompilerGeneratedAttribute]
public void set_ModelValidatorLocator(Type value);
    [CompilerGeneratedAttribute]
public Type get_ViewResolver();
    [CompilerGeneratedAttribute]
public void set_ViewResolver(Type value);
    [CompilerGeneratedAttribute]
public Type get_ViewCache();
    [CompilerGeneratedAttribute]
public void set_ViewCache(Type value);
    [CompilerGeneratedAttribute]
public Type get_RenderContextFactory();
    [CompilerGeneratedAttribute]
public void set_RenderContextFactory(Type value);
    [CompilerGeneratedAttribute]
public Type get_ViewLocationProvider();
    [CompilerGeneratedAttribute]
public void set_ViewLocationProvider(Type value);
    [CompilerGeneratedAttribute]
public IList`1<Type> get_StatusCodeHandlers();
    [CompilerGeneratedAttribute]
public void set_StatusCodeHandlers(IList`1<Type> value);
    [CompilerGeneratedAttribute]
public Type get_CsrfTokenValidator();
    [CompilerGeneratedAttribute]
public void set_CsrfTokenValidator(Type value);
    [CompilerGeneratedAttribute]
public Type get_ObjectSerializer();
    [CompilerGeneratedAttribute]
public void set_ObjectSerializer(Type value);
    [CompilerGeneratedAttribute]
public IList`1<Type> get_Serializers();
    [CompilerGeneratedAttribute]
public void set_Serializers(IList`1<Type> value);
    [CompilerGeneratedAttribute]
public IList`1<Type> get_InteractiveDiagnosticProviders();
    [CompilerGeneratedAttribute]
public void set_InteractiveDiagnosticProviders(IList`1<Type> value);
    [CompilerGeneratedAttribute]
public Type get_RequestTracing();
    [CompilerGeneratedAttribute]
public void set_RequestTracing(Type value);
    [CompilerGeneratedAttribute]
public Type get_RouteInvoker();
    [CompilerGeneratedAttribute]
public void set_RouteInvoker(Type value);
    [CompilerGeneratedAttribute]
public IList`1<Type> get_ResponseProcessors();
    [CompilerGeneratedAttribute]
public void set_ResponseProcessors(IList`1<Type> value);
    [CompilerGeneratedAttribute]
public Type get_RequestDispatcher();
    [CompilerGeneratedAttribute]
public void set_RequestDispatcher(Type value);
    [CompilerGeneratedAttribute]
public Type get_Diagnostics();
    [CompilerGeneratedAttribute]
public void set_Diagnostics(Type value);
    [CompilerGeneratedAttribute]
public Type get_RouteSegmentExtractor();
    [CompilerGeneratedAttribute]
public void set_RouteSegmentExtractor(Type value);
    [CompilerGeneratedAttribute]
public Type get_RouteDescriptionProvider();
    [CompilerGeneratedAttribute]
public void set_RouteDescriptionProvider(Type value);
    [CompilerGeneratedAttribute]
public Type get_CultureService();
    [CompilerGeneratedAttribute]
public void set_CultureService(Type value);
    [CompilerGeneratedAttribute]
public Type get_TextResource();
    [CompilerGeneratedAttribute]
public void set_TextResource(Type value);
    [CompilerGeneratedAttribute]
public Type get_ResourceAssemblyProvider();
    [CompilerGeneratedAttribute]
public void set_ResourceAssemblyProvider(Type value);
    [CompilerGeneratedAttribute]
public Type get_ResourceReader();
    [CompilerGeneratedAttribute]
public void set_ResourceReader(Type value);
    [CompilerGeneratedAttribute]
public Type get_StaticContentProvider();
    [CompilerGeneratedAttribute]
public void set_StaticContentProvider(Type value);
    [CompilerGeneratedAttribute]
public Type get_RouteResolverTrie();
    [CompilerGeneratedAttribute]
public void set_RouteResolverTrie(Type value);
    [CompilerGeneratedAttribute]
public Type get_TrieNodeFactory();
    [CompilerGeneratedAttribute]
public void set_TrieNodeFactory(Type value);
    [CompilerGeneratedAttribute]
public IList`1<Type> get_RouteSegmentConstraints();
    [CompilerGeneratedAttribute]
public void set_RouteSegmentConstraints(IList`1<Type> value);
    [CompilerGeneratedAttribute]
public Type get_RequestTraceFactory();
    [CompilerGeneratedAttribute]
public void set_RequestTraceFactory(Type value);
    [CompilerGeneratedAttribute]
public Type get_ResponseNegotiator();
    [CompilerGeneratedAttribute]
public void set_ResponseNegotiator(Type value);
    public bool get_IsValid();
    public static Func`2<ITypeCatalog, NancyInternalConfiguration> WithOverrides(Action`1<NancyInternalConfiguration> builder);
    public IEnumerable`1<TypeRegistration> GetTypeRegistrations();
    public IEnumerable`1<CollectionTypeRegistration> GetCollectionTypeRegistrations();
}
public class Nancy.Bootstrapper.Pipelines : object {
    [CompilerGeneratedAttribute]
private BeforePipeline <BeforeRequest>k__BackingField;
    [CompilerGeneratedAttribute]
private AfterPipeline <AfterRequest>k__BackingField;
    [CompilerGeneratedAttribute]
private ErrorPipeline <OnError>k__BackingField;
    public BeforePipeline BeforeRequest { get; public set; }
    public AfterPipeline AfterRequest { get; public set; }
    public ErrorPipeline OnError { get; public set; }
    public Pipelines(IPipelines pipelines);
    [CompilerGeneratedAttribute]
public sealed virtual BeforePipeline get_BeforeRequest();
    [CompilerGeneratedAttribute]
public sealed virtual void set_BeforeRequest(BeforePipeline value);
    [CompilerGeneratedAttribute]
public sealed virtual AfterPipeline get_AfterRequest();
    [CompilerGeneratedAttribute]
public sealed virtual void set_AfterRequest(AfterPipeline value);
    [CompilerGeneratedAttribute]
public sealed virtual ErrorPipeline get_OnError();
    [CompilerGeneratedAttribute]
public sealed virtual void set_OnError(ErrorPipeline value);
}
public abstract class Nancy.Bootstrapper.Registrations : object {
    private ITypeCatalog typeCatalog;
    private IList`1<CollectionTypeRegistration> collectionRegistrations;
    private IList`1<InstanceRegistration> instanceRegistrations;
    private IList`1<TypeRegistration> typeRegistrations;
    public IEnumerable`1<CollectionTypeRegistration> CollectionTypeRegistrations { get; }
    public IEnumerable`1<InstanceRegistration> InstanceRegistrations { get; }
    public IEnumerable`1<TypeRegistration> TypeRegistrations { get; }
    protected Registrations(ITypeCatalog typeCatalog);
    public sealed virtual IEnumerable`1<CollectionTypeRegistration> get_CollectionTypeRegistrations();
    public sealed virtual IEnumerable`1<InstanceRegistration> get_InstanceRegistrations();
    public sealed virtual IEnumerable`1<TypeRegistration> get_TypeRegistrations();
    public void Register(Lifetime lifetime);
    public void RegisterAll(Lifetime lifetime);
    public void Register(IEnumerable`1<Type> defaultImplementations, Lifetime lifetime);
    public void Register(Type implementation, Lifetime lifetime);
    public void Register(TRegistration instance);
    public void RegisterWithDefault(Type defaultImplementation, Lifetime lifetime);
    public void RegisterWithDefault(Func`1<TRegistration> defaultImplementationFactory);
    public void RegisterWithDefault(IEnumerable`1<Type> defaultImplementations, Lifetime lifetime);
    public void RegisterWithUserThenDefault(IEnumerable`1<Type> defaultImplementations, Lifetime lifetime);
    [CompilerGeneratedAttribute]
private bool <RegisterWithDefault>b__17_0(Type type);
}
public class Nancy.Bootstrapper.TypeRegistration : ContainerRegistration {
    [CompilerGeneratedAttribute]
private Type <ImplementationType>k__BackingField;
    public Type ImplementationType { get; private set; }
    public TypeRegistration(Type registrationType, Type implementationType, Lifetime lifetime);
    [CompilerGeneratedAttribute]
public Type get_ImplementationType();
    [CompilerGeneratedAttribute]
private void set_ImplementationType(Type value);
}
public class Nancy.Configuration.DefaultNancyEnvironment : object {
    private IDictionary`2<string, object> values;
    public int Count { get; }
    private object System.Collections.Generic.IReadOnlyDictionary<System.String,System.Object>.Item { get; }
    public IEnumerable`1<string> Keys { get; }
    public IEnumerable`1<object> Values { get; }
    public sealed virtual IEnumerator`1<KeyValuePair`2<string, object>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual int get_Count();
    public sealed virtual bool ContainsKey(string key);
    private sealed virtual override bool System.Collections.Generic.IReadOnlyDictionary<System.String,System.Object>.TryGetValue(string key, Object& value);
    private sealed virtual override object System.Collections.Generic.IReadOnlyDictionary<System.String,System.Object>.get_Item(string key);
    public sealed virtual IEnumerable`1<string> get_Keys();
    public sealed virtual IEnumerable`1<object> get_Values();
    public sealed virtual void AddValue(string key, T value);
    public sealed virtual bool TryGetValue(string key, T& value);
    private sealed virtual override Type Nancy.IHideObjectMembers.GetType();
}
public class Nancy.Configuration.DefaultNancyEnvironmentConfigurator : object {
    private INancyEnvironmentFactory factory;
    private IEnumerable`1<INancyDefaultConfigurationProvider> defaultConfigurationProviders;
    public DefaultNancyEnvironmentConfigurator(INancyEnvironmentFactory factory, IEnumerable`1<INancyDefaultConfigurationProvider> defaultConfigurationProviders);
    public sealed virtual INancyEnvironment ConfigureEnvironment(Action`1<INancyEnvironment> configuration);
    private static object SafeGetDefaultConfiguration(INancyDefaultConfigurationProvider configurationProvider);
    private sealed virtual override Type Nancy.IHideObjectMembers.GetType();
}
public class Nancy.Configuration.DefaultNancyEnvironmentFactory : object {
    public sealed virtual INancyEnvironment CreateEnvironment();
    private sealed virtual override Type Nancy.IHideObjectMembers.GetType();
}
public interface Nancy.Configuration.INancyDefaultConfigurationProvider {
    public string Key { get; }
    public abstract virtual object GetDefaultConfiguration();
    public abstract virtual string get_Key();
}
public interface Nancy.Configuration.INancyEnvironment {
    public abstract virtual void AddValue(string key, T value);
    public abstract virtual bool TryGetValue(string key, T& value);
}
public interface Nancy.Configuration.INancyEnvironmentConfigurator {
    public abstract virtual INancyEnvironment ConfigureEnvironment(Action`1<INancyEnvironment> configuration);
}
[ExtensionAttribute]
public static class Nancy.Configuration.INancyEnvironmentExtensions : object {
    [ExtensionAttribute]
public static void AddValue(INancyEnvironment environment, T value);
    [ExtensionAttribute]
public static T GetValue(INancyEnvironment environment);
    [ExtensionAttribute]
public static T GetValue(INancyEnvironment environment, string key);
    [ExtensionAttribute]
public static T GetValueWithDefault(INancyEnvironment environment, T defaultValue);
    [ExtensionAttribute]
public static T GetValueWithDefault(INancyEnvironment environment, string key, T defaultValue);
}
public interface Nancy.Configuration.INancyEnvironmentFactory {
    public abstract virtual INancyEnvironment CreateEnvironment();
}
public abstract class Nancy.Configuration.NancyDefaultConfigurationProvider`1 : object {
    public string Key { get; }
    public abstract virtual T GetDefaultConfiguration();
    private sealed virtual override object Nancy.Configuration.INancyDefaultConfigurationProvider.GetDefaultConfiguration();
    public virtual string get_Key();
    private sealed virtual override Type Nancy.IHideObjectMembers.GetType();
}
public class Nancy.ConfigurationException : Exception {
    public ConfigurationException(string message);
    public ConfigurationException(string message, Exception exception);
}
public class Nancy.Conventions.AcceptHeaderCoercionConventions : object {
    private IList`1<Func`3<IEnumerable`1<Tuple`2<string, decimal>>, NancyContext, IEnumerable`1<Tuple`2<string, decimal>>>> conventions;
    public AcceptHeaderCoercionConventions(IList`1<Func`3<IEnumerable`1<Tuple`2<string, decimal>>, NancyContext, IEnumerable`1<Tuple`2<string, decimal>>>> conventions);
    public sealed virtual IEnumerator`1<Func`3<IEnumerable`1<Tuple`2<string, decimal>>, NancyContext, IEnumerable`1<Tuple`2<string, decimal>>>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public static class Nancy.Conventions.BuiltInAcceptHeaderCoercions : object {
    private static string HtmlContentType;
    private static IEnumerable`1<Tuple`2<string, decimal>> DefaultAccept;
    private static String[] BrokenBrowsers;
    private static BuiltInAcceptHeaderCoercions();
    public static IEnumerable`1<Tuple`2<string, decimal>> CoerceBlankAcceptHeader(IEnumerable`1<Tuple`2<string, decimal>> currentAcceptHeaders, NancyContext context);
    public static IEnumerable`1<Tuple`2<string, decimal>> CoerceStupidBrowsers(IEnumerable`1<Tuple`2<string, decimal>> currentAcceptHeaders, NancyContext context);
    public static IEnumerable`1<Tuple`2<string, decimal>> BoostHtml(IEnumerable`1<Tuple`2<string, decimal>> currentAcceptHeaders, NancyContext context);
    private static bool IsStupidBrowser(Tuple`2[] current, NancyContext context);
    private static bool IsPotentiallyBrokenBrowser(string userAgent);
}
public static class Nancy.Conventions.BuiltInCultureConventions : object {
    public static CultureInfo FormCulture(NancyContext context, GlobalizationConfiguration configuration);
    public static CultureInfo PathCulture(NancyContext context, GlobalizationConfiguration configuration);
    public static CultureInfo HeaderCulture(NancyContext context, GlobalizationConfiguration configuration);
    public static CultureInfo SessionCulture(NancyContext context, GlobalizationConfiguration configuration);
    public static CultureInfo CookieCulture(NancyContext context, GlobalizationConfiguration configuration);
    public static CultureInfo GlobalizationConfigurationCulture(NancyContext context, GlobalizationConfiguration configuration);
    public static bool IsValidCultureInfoName(string name, GlobalizationConfiguration configuration);
}
public class Nancy.Conventions.CultureConventions : object {
    private IEnumerable`1<Func`3<NancyContext, GlobalizationConfiguration, CultureInfo>> conventions;
    public CultureConventions(IEnumerable`1<Func`3<NancyContext, GlobalizationConfiguration, CultureInfo>> conventions);
    public sealed virtual IEnumerator`1<Func`3<NancyContext, GlobalizationConfiguration, CultureInfo>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class Nancy.Conventions.DefaultAcceptHeaderCoercionConventions : object {
    public sealed virtual void Initialise(NancyConventions conventions);
    public sealed virtual Tuple`2<bool, string> Validate(NancyConventions conventions);
    private void ConfigureDefaultConventions(NancyConventions conventions);
}
public class Nancy.Conventions.DefaultCultureConventions : object {
    public sealed virtual void Initialise(NancyConventions conventions);
    public sealed virtual Tuple`2<bool, string> Validate(NancyConventions conventions);
    private static void ConfigureDefaultConventions(NancyConventions conventions);
}
public class Nancy.Conventions.DefaultStaticContentsConventions : object {
    public sealed virtual void Initialise(NancyConventions conventions);
    public sealed virtual Tuple`2<bool, string> Validate(NancyConventions conventions);
}
public class Nancy.Conventions.DefaultViewLocationConventions : object {
    public sealed virtual void Initialise(NancyConventions conventions);
    public sealed virtual Tuple`2<bool, string> Validate(NancyConventions conventions);
    private static void ConfigureViewLocationConventions(NancyConventions conventions);
}
public interface Nancy.Conventions.IConvention {
    public abstract virtual void Initialise(NancyConventions conventions);
    public abstract virtual Tuple`2<bool, string> Validate(NancyConventions conventions);
}
public class Nancy.Conventions.NancyConventions : object {
    private ITypeCatalog typeCatalog;
    private IEnumerable`1<IConvention> conventions;
    [CompilerGeneratedAttribute]
[DynamicAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IList`1<Func`4<string, object, ViewLocationContext, string>> <ViewLocationConventions>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<Func`3<NancyContext, string, Response>> <StaticContentsConventions>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<Func`3<IEnumerable`1<Tuple`2<string, decimal>>, NancyContext, IEnumerable`1<Tuple`2<string, decimal>>>> <AcceptHeaderCoercionConventions>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<Func`3<NancyContext, GlobalizationConfiguration, CultureInfo>> <CultureConventions>k__BackingField;
    [DynamicAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IList`1<Func`4<string, object, ViewLocationContext, string>> ViewLocationConventions { get; public set; }
    public IList`1<Func`3<NancyContext, string, Response>> StaticContentsConventions { get; public set; }
    public IList`1<Func`3<IEnumerable`1<Tuple`2<string, decimal>>, NancyContext, IEnumerable`1<Tuple`2<string, decimal>>>> AcceptHeaderCoercionConventions { get; public set; }
    public IList`1<Func`3<NancyContext, GlobalizationConfiguration, CultureInfo>> CultureConventions { get; public set; }
    public NancyConventions(ITypeCatalog typeCatalog);
    [CompilerGeneratedAttribute]
public IList`1<Func`4<string, object, ViewLocationContext, string>> get_ViewLocationConventions();
    [CompilerGeneratedAttribute]
public void set_ViewLocationConventions(IList`1<Func`4<string, object, ViewLocationContext, string>> value);
    [CompilerGeneratedAttribute]
public IList`1<Func`3<NancyContext, string, Response>> get_StaticContentsConventions();
    [CompilerGeneratedAttribute]
public void set_StaticContentsConventions(IList`1<Func`3<NancyContext, string, Response>> value);
    [CompilerGeneratedAttribute]
public IList`1<Func`3<IEnumerable`1<Tuple`2<string, decimal>>, NancyContext, IEnumerable`1<Tuple`2<string, decimal>>>> get_AcceptHeaderCoercionConventions();
    [CompilerGeneratedAttribute]
public void set_AcceptHeaderCoercionConventions(IList`1<Func`3<IEnumerable`1<Tuple`2<string, decimal>>, NancyContext, IEnumerable`1<Tuple`2<string, decimal>>>> value);
    [CompilerGeneratedAttribute]
public IList`1<Func`3<NancyContext, GlobalizationConfiguration, CultureInfo>> get_CultureConventions();
    [CompilerGeneratedAttribute]
public void set_CultureConventions(IList`1<Func`3<NancyContext, GlobalizationConfiguration, CultureInfo>> value);
    public Tuple`2<bool, string> Validate();
    public IEnumerable`1<InstanceRegistration> GetInstanceRegistrations();
    private void BuildDefaultConventions();
    [CompilerGeneratedAttribute]
private Tuple`2<bool, string> <Validate>b__19_0(IConvention convention);
}
public class Nancy.Conventions.StaticContentConventionBuilder : object {
    private static ConcurrentDictionary`2<ResponseFactoryCacheKey, Func`2<NancyContext, Response>> ResponseFactoryCache;
    private static Regex PathReplaceRegex;
    private static StaticContentConventionBuilder();
    public static Func`3<NancyContext, string, Response> AddDirectory(string requestedPath, string contentPath, String[] allowedExtensions);
    public static Func`3<NancyContext, string, Response> AddFile(string requestedFile, string contentFile);
    private static string GetSafeFileName(string path);
    private static string GetSafeFullPath(string path);
    private static string GetContentPath(string requestedPath, string contentPath);
    private static Func`2<ResponseFactoryCacheKey, Func`2<NancyContext, Response>> BuildContentDelegate(NancyContext context, string applicationRootPath, string requestedPath, string contentPath, String[] allowedExtensions);
    private static string GetEncodedPath(string path);
    private static string GetPathWithoutFilename(string fileName, string path);
    private static string GetSafeRequestPath(string requestPath, string requestedPath, string contentPath);
    private static bool IsWithinContentFolder(string contentRootPath, string fileName);
}
[ExtensionAttribute]
public static class Nancy.Conventions.StaticContentHelper : object {
    [ExtensionAttribute]
public static void MapStaticContent(NancyConventions conventions, Action`2<StaticFileContent, StaticDirectoryContent> staticConventions);
}
public class Nancy.Conventions.StaticContentsConventions : object {
    private IEnumerable`1<Func`3<NancyContext, string, Response>> conventions;
    public StaticContentsConventions(IEnumerable`1<Func`3<NancyContext, string, Response>> conventions);
    public sealed virtual IEnumerator`1<Func`3<NancyContext, string, Response>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[ExtensionAttribute]
public static class Nancy.Conventions.StaticContentsConventionsExtensions : object {
    [ExtensionAttribute]
public static void AddDirectory(IList`1<Func`3<NancyContext, string, Response>> conventions, string requestedPath, string contentPath, String[] allowedExtensions);
    [ExtensionAttribute]
public static void AddFile(IList`1<Func`3<NancyContext, string, Response>> conventions, string requestedFile, string contentFile);
}
[DefaultMemberAttribute("Item")]
public class Nancy.Conventions.StaticDirectoryContent : object {
    private NancyConventions conventions;
    unknown string Item {public set; }
    public StaticDirectoryContent(NancyConventions conventions);
    public void set_Item(string requestDirectory, String[] allowedExtensions, string value);
}
[DefaultMemberAttribute("Item")]
public class Nancy.Conventions.StaticFileContent : object {
    private NancyConventions conventions;
    unknown string Item {public set; }
    public StaticFileContent(NancyConventions conventions);
    public void set_Item(string requestFile, string value);
}
public class Nancy.Conventions.ViewLocationConventions : object {
    private IEnumerable`1<Func`4<string, object, ViewLocationContext, string>> conventions;
    public ViewLocationConventions(IEnumerable`1<Func`4<string, object, ViewLocationContext, string>> conventions);
    public sealed virtual IEnumerator`1<Func`4<string, object, ViewLocationContext, string>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public interface Nancy.Cookies.INancyCookie {
    public string Domain { get; public set; }
    public Nullable`1<DateTime> Expires { get; public set; }
    public string Name { get; }
    public string EncodedName { get; }
    public string Path { get; public set; }
    public string Value { get; }
    public string EncodedValue { get; }
    public bool HttpOnly { get; }
    public bool Secure { get; }
    public abstract virtual string get_Domain();
    public abstract virtual void set_Domain(string value);
    public abstract virtual Nullable`1<DateTime> get_Expires();
    public abstract virtual void set_Expires(Nullable`1<DateTime> value);
    public abstract virtual string get_Name();
    public abstract virtual string get_EncodedName();
    public abstract virtual string get_Path();
    public abstract virtual void set_Path(string value);
    public abstract virtual string get_Value();
    public abstract virtual string get_EncodedValue();
    public abstract virtual bool get_HttpOnly();
    public abstract virtual bool get_Secure();
}
public class Nancy.Cookies.NancyCookie : object {
    [CompilerGeneratedAttribute]
private string <Domain>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <Expires>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HttpOnly>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Secure>k__BackingField;
    public string Domain { get; public set; }
    public Nullable`1<DateTime> Expires { get; public set; }
    public string Name { get; private set; }
    public string EncodedName { get; }
    public string Path { get; public set; }
    public string Value { get; private set; }
    public string EncodedValue { get; }
    public bool HttpOnly { get; private set; }
    public bool Secure { get; private set; }
    public NancyCookie(string name, string value);
    public NancyCookie(string name, string value, DateTime expires);
    public NancyCookie(string name, string value, bool httpOnly);
    public NancyCookie(string name, string value, bool httpOnly, bool secure);
    public NancyCookie(string name, string value, bool httpOnly, bool secure, Nullable`1<DateTime> expires);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Domain();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Domain(string value);
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<DateTime> get_Expires();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Expires(Nullable`1<DateTime> value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
    public sealed virtual string get_EncodedName();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Path();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Path(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Value();
    [CompilerGeneratedAttribute]
private void set_Value(string value);
    public sealed virtual string get_EncodedValue();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_HttpOnly();
    [CompilerGeneratedAttribute]
private void set_HttpOnly(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_Secure();
    [CompilerGeneratedAttribute]
private void set_Secure(bool value);
    public virtual string ToString();
}
public class Nancy.Cryptography.AesEncryptionProvider : object {
    private Byte[] key;
    private Byte[] iv;
    public AesEncryptionProvider(IKeyGenerator keyGenerator);
    public sealed virtual string Encrypt(string data);
    public sealed virtual string Decrypt(string data);
}
public static class Nancy.Cryptography.Base64Helpers : object {
    public static int GetBase64Length(int normalLength);
}
public class Nancy.Cryptography.CryptographyConfiguration : object {
    private static Lazy`1<CryptographyConfiguration> DefaultConfiguration;
    private static Lazy`1<CryptographyConfiguration> NoEncryptionConfiguration;
    [CompilerGeneratedAttribute]
private IEncryptionProvider <EncryptionProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private IHmacProvider <HmacProvider>k__BackingField;
    public static CryptographyConfiguration Default { get; }
    public static CryptographyConfiguration NoEncryption { get; }
    public IEncryptionProvider EncryptionProvider { get; private set; }
    public IHmacProvider HmacProvider { get; private set; }
    public CryptographyConfiguration(IEncryptionProvider encryptionProvider, IHmacProvider hmacProvider);
    private static CryptographyConfiguration();
    public static CryptographyConfiguration get_Default();
    public static CryptographyConfiguration get_NoEncryption();
    [CompilerGeneratedAttribute]
public IEncryptionProvider get_EncryptionProvider();
    [CompilerGeneratedAttribute]
private void set_EncryptionProvider(IEncryptionProvider value);
    [CompilerGeneratedAttribute]
public IHmacProvider get_HmacProvider();
    [CompilerGeneratedAttribute]
private void set_HmacProvider(IHmacProvider value);
}
public class Nancy.Cryptography.DefaultHmacProvider : object {
    private int hmacLength;
    private static int PreferredKeySize;
    private Byte[] key;
    public int HmacLength { get; }
    public DefaultHmacProvider(IKeyGenerator keyGenerator);
    public sealed virtual int get_HmacLength();
    public sealed virtual Byte[] GenerateHmac(string data);
    public sealed virtual Byte[] GenerateHmac(Byte[] data);
}
public static class Nancy.Cryptography.HmacComparer : object {
    public static bool Compare(Byte[] hmac1, Byte[] hmac2, int hashLength);
}
public interface Nancy.Cryptography.IEncryptionProvider {
    public abstract virtual string Encrypt(string data);
    public abstract virtual string Decrypt(string data);
}
public interface Nancy.Cryptography.IHmacProvider {
    public int HmacLength { get; }
    public abstract virtual int get_HmacLength();
    public abstract virtual Byte[] GenerateHmac(string data);
    public abstract virtual Byte[] GenerateHmac(Byte[] data);
}
public interface Nancy.Cryptography.IKeyGenerator {
    public abstract virtual Byte[] GetBytes(int count);
}
public class Nancy.Cryptography.NoEncryptionProvider : object {
    public sealed virtual string Encrypt(string data);
    public sealed virtual string Decrypt(string data);
}
public class Nancy.Cryptography.PassphraseKeyGenerator : object {
    private Rfc2898DeriveBytes provider;
    public PassphraseKeyGenerator(string passphrase, Byte[] salt, int iterations);
    public sealed virtual Byte[] GetBytes(int count);
}
public class Nancy.Cryptography.RandomKeyGenerator : object {
    private RandomNumberGenerator provider;
    public sealed virtual Byte[] GetBytes(int count);
}
public class Nancy.Culture.DefaultCultureService : object {
    private CultureConventions cultureConventions;
    private GlobalizationConfiguration configuration;
    public DefaultCultureService(CultureConventions cultureConventions, INancyEnvironment environment);
    public sealed virtual CultureInfo DetermineCurrentCulture(NancyContext context);
}
public interface Nancy.Culture.ICultureService {
    public abstract virtual CultureInfo DetermineCurrentCulture(NancyContext context);
}
public class Nancy.DefaultGlobalizationConfigurationProvider : NancyDefaultConfigurationProvider`1<GlobalizationConfiguration> {
    public virtual GlobalizationConfiguration GetDefaultConfiguration();
}
public class Nancy.DefaultNancyBootstrapper : NancyBootstrapperWithRequestContainerBase`1<TinyIoCContainer> {
    public static IEnumerable`1<Func`2<Assembly, bool>> DefaultAutoRegisterIgnoredAssemblies;
    protected IEnumerable`1<Func`2<Assembly, bool>> AutoRegisterIgnoredAssemblies { get; }
    private static DefaultNancyBootstrapper();
    protected virtual IEnumerable`1<Func`2<Assembly, bool>> get_AutoRegisterIgnoredAssemblies();
    protected virtual void ConfigureApplicationContainer(TinyIoCContainer container);
    protected sealed virtual INancyEngine GetEngineInternal();
    protected virtual TinyIoCContainer GetApplicationContainer();
    protected virtual void RegisterNancyEnvironment(TinyIoCContainer container, INancyEnvironment environment);
    protected sealed virtual void RegisterBootstrapperTypes(TinyIoCContainer applicationContainer);
    protected sealed virtual void RegisterTypes(TinyIoCContainer container, IEnumerable`1<TypeRegistration> typeRegistrations);
    protected sealed virtual void RegisterCollectionTypes(TinyIoCContainer container, IEnumerable`1<CollectionTypeRegistration> collectionTypeRegistrations);
    protected sealed virtual void RegisterRequestContainerModules(TinyIoCContainer container, IEnumerable`1<ModuleRegistration> moduleRegistrationTypes);
    protected virtual void RegisterInstances(TinyIoCContainer container, IEnumerable`1<InstanceRegistration> instanceRegistrations);
    protected virtual TinyIoCContainer CreateRequestContainer(NancyContext context);
    protected virtual INancyEnvironmentConfigurator GetEnvironmentConfigurator();
    protected virtual IDiagnostics GetDiagnostics();
    protected virtual IEnumerable`1<IApplicationStartup> GetApplicationStartupTasks();
    protected virtual IEnumerable`1<IRequestStartup> RegisterAndGetRequestStartupTasks(TinyIoCContainer container, Type[] requestStartupTypes);
    protected virtual IEnumerable`1<IRegistrations> GetRegistrationTasks();
    public virtual INancyEnvironment GetEnvironment();
    protected sealed virtual IEnumerable`1<INancyModule> GetAllModules(TinyIoCContainer container);
    protected sealed virtual INancyModule GetModule(TinyIoCContainer container, Type moduleType);
    private void AutoRegister(TinyIoCContainer container, IEnumerable`1<Func`2<Assembly, bool>> ignoredAssemblies);
}
public class Nancy.DefaultNancyContextFactory : object {
    private ICultureService cultureService;
    private IRequestTraceFactory requestTraceFactory;
    private ITextResource textResource;
    private INancyEnvironment environment;
    public DefaultNancyContextFactory(ICultureService cultureService, IRequestTraceFactory requestTraceFactory, ITextResource textResource, INancyEnvironment environment);
    public sealed virtual NancyContext Create(Request request);
}
public class Nancy.DefaultObjectSerializer : object {
    public sealed virtual string Serialize(object sourceObject);
    private static object AddTypeInformation(object sourceObject);
    public sealed virtual object Deserialize(string sourceString);
    private static bool ContainsTypeDescription(string json);
}
public class Nancy.DefaultResponseFormatter : object {
    private IRootPathProvider rootPathProvider;
    private NancyContext context;
    private ISerializerFactory serializerFactory;
    private INancyEnvironment environment;
    public ISerializerFactory SerializerFactory { get; }
    public NancyContext Context { get; }
    public INancyEnvironment Environment { get; }
    public string RootPath { get; }
    public DefaultResponseFormatter(IRootPathProvider rootPathProvider, NancyContext context, ISerializerFactory serializerFactory, INancyEnvironment environment);
    public sealed virtual ISerializerFactory get_SerializerFactory();
    public sealed virtual NancyContext get_Context();
    public sealed virtual INancyEnvironment get_Environment();
    public sealed virtual string get_RootPath();
    private sealed virtual override Type Nancy.IHideObjectMembers.GetType();
}
public class Nancy.DefaultResponseFormatterFactory : object {
    private IRootPathProvider rootPathProvider;
    private ISerializerFactory serializerFactory;
    private INancyEnvironment environment;
    public DefaultResponseFormatterFactory(IRootPathProvider rootPathProvider, ISerializerFactory serializerFactory, INancyEnvironment environment);
    public sealed virtual IResponseFormatter Create(NancyContext context);
}
public class Nancy.DefaultRootPathProvider : object {
    public sealed virtual string GetRootPath();
    private sealed virtual override Type Nancy.IHideObjectMembers.GetType();
}
public class Nancy.DefaultRouteConfigurationProvider : NancyDefaultConfigurationProvider`1<RouteConfiguration> {
    public virtual RouteConfiguration GetDefaultConfiguration();
}
public class Nancy.DefaultRuntimeEnvironmentInformation : object {
    private Lazy`1<bool> isDebug;
    public bool IsDebug { get; }
    public DefaultRuntimeEnvironmentInformation(ITypeCatalog typeCatalog);
    public virtual bool get_IsDebug();
    private static bool GetDebugMode(ITypeCatalog typeCatalog);
}
public class Nancy.DefaultSerializerFactory : object {
    private IEnumerable`1<ISerializer> serializers;
    public DefaultSerializerFactory(IEnumerable`1<ISerializer> serializers);
    public sealed virtual ISerializer GetSerializer(MediaRange mediaRange);
    private ISerializer GetDefaultSerializerForMediaRange(MediaRange mediaRange);
    private static string GetErrorMessage(IEnumerable`1<ISerializer> matches, MediaRange mediaRange);
    private static bool SafeCanSerialize(ISerializer serializer, MediaRange mediaRange);
}
public class Nancy.DefaultStaticContentConfigurationProvider : NancyDefaultConfigurationProvider`1<StaticContentConfiguration> {
    private IRootPathProvider rootPathProvider;
    public DefaultStaticContentConfigurationProvider(IRootPathProvider rootPathProvider);
    public virtual StaticContentConfiguration GetDefaultConfiguration();
}
public class Nancy.DefaultStaticContentProvider : object {
    private IRootPathProvider rootPathProvider;
    private StaticContentsConventions conventions;
    private string rootPath;
    public DefaultStaticContentProvider(IRootPathProvider rootPathProvider, StaticContentsConventions conventions);
    public sealed virtual Response GetContent(NancyContext context);
}
public class Nancy.DefaultTraceConfigurationProvider : NancyDefaultConfigurationProvider`1<TraceConfiguration> {
    private IRuntimeEnvironmentInformation runtimeEnvironmentInformation;
    public DefaultTraceConfigurationProvider(IRuntimeEnvironmentInformation runtimeEnvironmentInformation);
    public virtual TraceConfiguration GetDefaultConfiguration();
}
public class Nancy.DefaultTypeCatalog : object {
    private IAssemblyCatalog assemblyCatalog;
    private ConcurrentDictionary`2<Type, IReadOnlyCollection`1<Type>> cache;
    public DefaultTypeCatalog(IAssemblyCatalog assemblyCatalog);
    public sealed virtual IReadOnlyCollection`1<Type> GetTypesAssignableTo(Type type, TypeResolveStrategy strategy);
    private IReadOnlyCollection`1<Type> GetTypesAssignableTo(Type type);
}
public class Nancy.DefaultViewConfigurationProvider : NancyDefaultConfigurationProvider`1<ViewConfiguration> {
    public virtual ViewConfiguration GetDefaultConfiguration();
}
public class Nancy.Diagnostics.ConcurrentLimitedCollection`1 : object {
    private int maxSize;
    private ConcurrentQueue`1<T> internalStore;
    public int CurrentSize { get; }
    public ConcurrentLimitedCollection`1(int maxSize);
    public int get_CurrentSize();
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public void Add(T item);
    public void Clear();
}
public class Nancy.Diagnostics.DefaultDiagnostics : object {
    private IEnumerable`1<IDiagnosticsProvider> diagnosticProviders;
    private IRootPathProvider rootPathProvider;
    private IRequestTracing requestTracing;
    private NancyInternalConfiguration configuration;
    private IModelBinderLocator modelBinderLocator;
    private IEnumerable`1<IResponseProcessor> responseProcessors;
    private IEnumerable`1<IRouteSegmentConstraint> routeSegmentConstraints;
    private ICultureService cultureService;
    private IRequestTraceFactory requestTraceFactory;
    private IEnumerable`1<IRouteMetadataProvider> routeMetadataProviders;
    private ITextResource textResource;
    private INancyEnvironment environment;
    private ITypeCatalog typeCatalog;
    private IAssemblyCatalog assemblyCatalog;
    private AcceptHeaderCoercionConventions acceptHeaderCoercionConventions;
    public DefaultDiagnostics(IEnumerable`1<IDiagnosticsProvider> diagnosticProviders, IRootPathProvider rootPathProvider, IRequestTracing requestTracing, NancyInternalConfiguration configuration, IModelBinderLocator modelBinderLocator, IEnumerable`1<IResponseProcessor> responseProcessors, IEnumerable`1<IRouteSegmentConstraint> routeSegmentConstraints, ICultureService cultureService, IRequestTraceFactory requestTraceFactory, IEnumerable`1<IRouteMetadataProvider> routeMetadataProviders, ITextResource textResource, INancyEnvironment environment, ITypeCatalog typeCatalog, IAssemblyCatalog assemblyCatalog, AcceptHeaderCoercionConventions acceptHeaderCoercionConventions);
    public sealed virtual void Initialize(IPipelines pipelines);
}
public class Nancy.Diagnostics.DefaultDiagnosticsConfigurationProvider : NancyDefaultConfigurationProvider`1<DiagnosticsConfiguration> {
    public virtual DiagnosticsConfiguration GetDefaultConfiguration();
}
public class Nancy.Diagnostics.DefaultRequestTrace : object {
    [CompilerGeneratedAttribute]
private IDictionary`2<string, object> <Items>k__BackingField;
    [CompilerGeneratedAttribute]
private RequestData <RequestData>k__BackingField;
    [CompilerGeneratedAttribute]
private ResponseData <ResponseData>k__BackingField;
    [CompilerGeneratedAttribute]
private ITraceLog <TraceLog>k__BackingField;
    public IDictionary`2<string, object> Items { get; public set; }
    public RequestData RequestData { get; public set; }
    public ResponseData ResponseData { get; public set; }
    public ITraceLog TraceLog { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual IDictionary`2<string, object> get_Items();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Items(IDictionary`2<string, object> value);
    [CompilerGeneratedAttribute]
public sealed virtual RequestData get_RequestData();
    [CompilerGeneratedAttribute]
public sealed virtual void set_RequestData(RequestData value);
    [CompilerGeneratedAttribute]
public sealed virtual ResponseData get_ResponseData();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ResponseData(ResponseData value);
    [CompilerGeneratedAttribute]
public sealed virtual ITraceLog get_TraceLog();
    [CompilerGeneratedAttribute]
public sealed virtual void set_TraceLog(ITraceLog value);
}
public class Nancy.Diagnostics.DefaultRequestTraceFactory : object {
    private TraceConfiguration configuration;
    public DefaultRequestTraceFactory(INancyEnvironment environment);
    public sealed virtual IRequestTrace Create(Request request);
}
public class Nancy.Diagnostics.DefaultRequestTracing : object {
    private static int MaxSize;
    private ConcurrentLimitedCollection`1<RequestTraceSession> sessions;
    public sealed virtual void AddRequestDiagnosticToSession(Guid sessionId, NancyContext context);
    public sealed virtual void Clear();
    public sealed virtual Guid CreateSession();
    public sealed virtual IEnumerable`1<RequestTraceSession> GetSessions();
    public sealed virtual bool IsValidSessionId(Guid sessionId);
}
public class Nancy.Diagnostics.DefaultTraceLog : object {
    private StringBuilder log;
    public sealed virtual void WriteLog(Action`1<StringBuilder> logDelegate);
    public virtual string ToString();
}
[AttributeUsageAttribute("192")]
public class Nancy.Diagnostics.DescriptionAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    public string Description { get; public set; }
    public DescriptionAttribute(string description);
    [CompilerGeneratedAttribute]
public string get_Description();
    [CompilerGeneratedAttribute]
public void set_Description(string value);
}
public abstract class Nancy.Diagnostics.DiagnosticModule : NancyModule {
    private INancyEnvironment environment;
    public DiagnosticsViewRenderer View { get; }
    protected DiagnosticModule(string basePath);
    public DiagnosticsViewRenderer get_View();
}
public class Nancy.Diagnostics.DiagnosticsConfiguration : object {
    public static DiagnosticsConfiguration Default;
    [CompilerGeneratedAttribute]
private string <CookieName>k__BackingField;
    [CompilerGeneratedAttribute]
private CryptographyConfiguration <CryptographyConfiguration>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Enabled>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Password>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private int <SlidingTimeout>k__BackingField;
    public string CookieName { get; private set; }
    public CryptographyConfiguration CryptographyConfiguration { get; private set; }
    public bool Enabled { get; private set; }
    public string Password { get; private set; }
    public string Path { get; private set; }
    public int SlidingTimeout { get; private set; }
    public DiagnosticsConfiguration(bool enabled, string password, string path, string cookieName, int slidingTimeout, CryptographyConfiguration cryptographyConfiguration);
    private static DiagnosticsConfiguration();
    [CompilerGeneratedAttribute]
public string get_CookieName();
    [CompilerGeneratedAttribute]
private void set_CookieName(string value);
    [CompilerGeneratedAttribute]
public CryptographyConfiguration get_CryptographyConfiguration();
    [CompilerGeneratedAttribute]
private void set_CryptographyConfiguration(CryptographyConfiguration value);
    [CompilerGeneratedAttribute]
public bool get_Enabled();
    [CompilerGeneratedAttribute]
private void set_Enabled(bool value);
    [CompilerGeneratedAttribute]
public string get_Password();
    [CompilerGeneratedAttribute]
private void set_Password(string value);
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
private void set_Path(string value);
    [CompilerGeneratedAttribute]
public int get_SlidingTimeout();
    [CompilerGeneratedAttribute]
private void set_SlidingTimeout(int value);
    private static string GetNormalizedPath(string path);
}
[ExtensionAttribute]
public static class Nancy.Diagnostics.DiagnosticsConfigurationExtensions : object {
    [ExtensionAttribute]
public static void Diagnostics(INancyEnvironment environment, string password, string path, string cookieName, int slidingTimeout, CryptographyConfiguration cryptographyConfiguration);
    [ExtensionAttribute]
public static void Diagnostics(INancyEnvironment environment, bool enabled, string password, string path, string cookieName, int slidingTimeout, CryptographyConfiguration cryptographyConfiguration);
}
public static class Nancy.Diagnostics.DiagnosticsHook : object {
    private static CancellationToken CancellationToken;
    private static string PipelineKey;
    internal static string ItemsKey;
    private static DiagnosticsHook();
    public static void Enable(IPipelines pipelines, IEnumerable`1<IDiagnosticsProvider> providers, IRootPathProvider rootPathProvider, IRequestTracing requestTracing, NancyInternalConfiguration configuration, IModelBinderLocator modelBinderLocator, IEnumerable`1<IResponseProcessor> responseProcessors, IEnumerable`1<IRouteSegmentConstraint> routeSegmentConstraints, ICultureService cultureService, IRequestTraceFactory requestTraceFactory, IEnumerable`1<IRouteMetadataProvider> routeMetadataProviders, ITextResource textResource, INancyEnvironment environment, ITypeCatalog typeCatalog, IAssemblyCatalog assemblyCatalog, AcceptHeaderCoercionConventions acceptHeaderCoercionConventions);
    private static INancyEnvironment GetDiagnosticsEnvironment();
    private static bool ValidateConfiguration(DiagnosticsConfiguration configuration);
    public static void Disable(IPipelines pipelines);
    private static Response GetDiagnosticsLoginView(NancyContext ctx, INancyEnvironment environment);
    private static Response ExecuteDiagnostics(NancyContext ctx, IRouteResolver routeResolver, DiagnosticsConfiguration diagnosticsConfiguration, DefaultObjectSerializer serializer, INancyEnvironment environment, IRouteInvoker routeInvoker);
    private static void AddUpdateSessionCookie(DiagnosticsSession session, NancyContext context, DiagnosticsConfiguration diagnosticsConfiguration, DefaultObjectSerializer serializer);
    private static DiagnosticsSession GetSession(NancyContext context, DiagnosticsConfiguration diagnosticsConfiguration, DefaultObjectSerializer serializer);
    private static bool SessionPasswordValid(DiagnosticsSession session, string realPassword);
    private static DiagnosticsSession ProcessLogin(NancyContext context, DiagnosticsConfiguration diagnosticsConfiguration, DefaultObjectSerializer serializer);
    private static bool IsLoginRequest(NancyContext context, DiagnosticsConfiguration diagnosticsConfiguration);
    private static void ExecuteRoutePreReq(NancyContext context, CancellationToken cancellationToken, BeforePipeline resolveResultPreReq);
    private static void RewriteDiagnosticsUrl(DiagnosticsConfiguration diagnosticsConfiguration, NancyContext ctx);
}
internal class Nancy.Diagnostics.DiagnosticsModuleBuilder : object {
    private IRootPathProvider rootPathProvider;
    private ISerializerFactory serializerFactory;
    private IModelBinderLocator modelBinderLocator;
    private INancyEnvironment environment;
    public DiagnosticsModuleBuilder(IRootPathProvider rootPathProvider, IModelBinderLocator modelBinderLocator, INancyEnvironment diagnosticsEnvironment, INancyEnvironment environment);
    public sealed virtual INancyModule BuildModule(INancyModule module, NancyContext context);
}
internal class Nancy.Diagnostics.DiagnosticsModuleCatalog : object {
    private TinyIoCContainer container;
    public DiagnosticsModuleCatalog(IEnumerable`1<IDiagnosticsProvider> providers, IRootPathProvider rootPathProvider, IRequestTracing requestTracing, NancyInternalConfiguration configuration, INancyEnvironment diagnosticsEnvironment, ITypeCatalog typeCatalog, IAssemblyCatalog assemblyCatalog);
    public sealed virtual IEnumerable`1<INancyModule> GetAllModules(NancyContext context);
    public sealed virtual INancyModule GetModule(Type moduleType, NancyContext context);
    private static TinyIoCContainer ConfigureContainer(IEnumerable`1<IDiagnosticsProvider> providers, IRootPathProvider rootPathProvider, IRequestTracing requestTracing, NancyInternalConfiguration configuration, INancyEnvironment diagnosticsEnvironment, ITypeCatalog typeCatalog, IAssemblyCatalog assemblyCatalog);
}
internal class Nancy.Diagnostics.DiagnosticsSerializerFactory : object {
    private ISerializer serializer;
    public DiagnosticsSerializerFactory(INancyEnvironment diagnosticsEnvironment);
    public sealed virtual ISerializer GetSerializer(MediaRange mediaRange);
}
public class Nancy.Diagnostics.DiagnosticsSession : object {
    [CompilerGeneratedAttribute]
private Byte[] <Hash>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <Salt>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <Expiry>k__BackingField;
    public Byte[] Hash { get; public set; }
    public Byte[] Salt { get; public set; }
    public DateTimeOffset Expiry { get; public set; }
    [CompilerGeneratedAttribute]
public Byte[] get_Hash();
    [CompilerGeneratedAttribute]
public void set_Hash(Byte[] value);
    [CompilerGeneratedAttribute]
public Byte[] get_Salt();
    [CompilerGeneratedAttribute]
public void set_Salt(Byte[] value);
    [CompilerGeneratedAttribute]
public DateTimeOffset get_Expiry();
    [CompilerGeneratedAttribute]
public void set_Expiry(DateTimeOffset value);
    public static Byte[] GenerateRandomSalt();
    public static Byte[] GenerateSaltedHash(Byte[] plainText, Byte[] salt);
    public static Byte[] GenerateSaltedHash(string plainText, Byte[] salt);
}
[DefaultMemberAttribute("Item")]
public class Nancy.Diagnostics.DiagnosticsViewRenderer : object {
    private NancyContext context;
    private INancyEnvironment environment;
    private static IViewResolver ViewResolver;
    private static IViewEngine Engine;
    public Response Item { get; }
    public Response Item { get; }
    public DiagnosticsViewRenderer(NancyContext context, INancyEnvironment environment);
    private static DiagnosticsViewRenderer();
    public Response get_Item(string name);
    public Response get_Item(string name, object model);
    private Response RenderView(string name, object model, NancyContext context);
    private static Stream GetBodyStream(string name);
    private static ViewLocationResult GetViewLocationResult(string name, Stream bodyStream);
}
public class Nancy.Diagnostics.DisabledDiagnostics : object {
    public sealed virtual void Initialize(IPipelines pipelines);
}
public interface Nancy.Diagnostics.IDiagnostics {
    public abstract virtual void Initialize(IPipelines pipelines);
}
public interface Nancy.Diagnostics.IDiagnosticsProvider {
    public string Name { get; }
    public string Description { get; }
    public object DiagnosticObject { get; }
    public abstract virtual string get_Name();
    public abstract virtual string get_Description();
    public abstract virtual object get_DiagnosticObject();
}
public interface Nancy.Diagnostics.IInteractiveDiagnostics {
    public IEnumerable`1<InteractiveDiagnostic> AvailableDiagnostics { get; }
    public abstract virtual IEnumerable`1<InteractiveDiagnostic> get_AvailableDiagnostics();
    public abstract virtual object ExecuteDiagnostic(InteractiveDiagnosticMethod interactiveDiagnosticMethod, Object[] arguments);
    public abstract virtual string GetTemplate(InteractiveDiagnosticMethod interactiveDiagnosticMethod);
    public abstract virtual InteractiveDiagnostic GetDiagnostic(string providerName);
    public abstract virtual InteractiveDiagnosticMethod GetMethod(string providerName, string methodName);
}
public class Nancy.Diagnostics.InteractiveDiagnostic : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<InteractiveDiagnosticMethod> <Methods>k__BackingField;
    public string Name { get; public set; }
    public string Description { get; public set; }
    public IEnumerable`1<InteractiveDiagnosticMethod> Methods { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_Description();
    [CompilerGeneratedAttribute]
public void set_Description(string value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<InteractiveDiagnosticMethod> get_Methods();
    [CompilerGeneratedAttribute]
public void set_Methods(IEnumerable`1<InteractiveDiagnosticMethod> value);
}
public class Nancy.Diagnostics.InteractiveDiagnosticMethod : object {
    [CompilerGeneratedAttribute]
private object <ParentDiagnosticObject>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <ReturnType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MethodName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<Tuple`2<string, Type>> <Arguments>k__BackingField;
    public object ParentDiagnosticObject { get; private set; }
    public Type ReturnType { get; private set; }
    public string MethodName { get; private set; }
    public string Description { get; private set; }
    public IEnumerable`1<Tuple`2<string, Type>> Arguments { get; private set; }
    public InteractiveDiagnosticMethod(object parentDiagnostic, Type returnType, string methodName, IEnumerable`1<Tuple`2<string, Type>> arguments, string description);
    [CompilerGeneratedAttribute]
public object get_ParentDiagnosticObject();
    [CompilerGeneratedAttribute]
private void set_ParentDiagnosticObject(object value);
    [CompilerGeneratedAttribute]
public Type get_ReturnType();
    [CompilerGeneratedAttribute]
private void set_ReturnType(Type value);
    [CompilerGeneratedAttribute]
public string get_MethodName();
    [CompilerGeneratedAttribute]
private void set_MethodName(string value);
    [CompilerGeneratedAttribute]
public string get_Description();
    [CompilerGeneratedAttribute]
private void set_Description(string value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<Tuple`2<string, Type>> get_Arguments();
    [CompilerGeneratedAttribute]
private void set_Arguments(IEnumerable`1<Tuple`2<string, Type>> value);
}
public class Nancy.Diagnostics.InteractiveDiagnostics : object {
    private IDiagnosticsProvider[] providers;
    private static BindingFlags Flags;
    [CompilerGeneratedAttribute]
private IEnumerable`1<InteractiveDiagnostic> <AvailableDiagnostics>k__BackingField;
    public IEnumerable`1<InteractiveDiagnostic> AvailableDiagnostics { get; private set; }
    public InteractiveDiagnostics(IEnumerable`1<IDiagnosticsProvider> providers);
    [CompilerGeneratedAttribute]
public sealed virtual IEnumerable`1<InteractiveDiagnostic> get_AvailableDiagnostics();
    [CompilerGeneratedAttribute]
private void set_AvailableDiagnostics(IEnumerable`1<InteractiveDiagnostic> value);
    public sealed virtual object ExecuteDiagnostic(InteractiveDiagnosticMethod interactiveDiagnosticMethod, Object[] arguments);
    public sealed virtual string GetTemplate(InteractiveDiagnosticMethod interactiveDiagnosticMethod);
    public sealed virtual InteractiveDiagnostic GetDiagnostic(string providerName);
    public sealed virtual InteractiveDiagnosticMethod GetMethod(string providerName, string methodName);
    private void BuildAvailableDiagnostics();
    private IEnumerable`1<InteractiveDiagnosticMethod> GetDiagnosticMethods(IDiagnosticsProvider diagnosticsProvider);
    private string GetDescription(IDiagnosticsProvider diagnosticsProvider, MethodInfo methodInfo);
    private IEnumerable`1<Tuple`2<string, Type>> GetArguments(MethodInfo methodInfo);
    private static string GetTemplateFromProperty(InteractiveDiagnosticMethod interactiveDiagnosticMethod, Type diagObjectType);
    private static string GetTemplateFromAttribute(InteractiveDiagnosticMethod interactiveDiagnosticMethod);
    private static string GetDescriptionFromProperty(IDiagnosticsProvider diagnosticsProvider, MethodInfo methodInfo);
    private static string GetDescriptionFromAttribute(IDiagnosticsProvider diagnosticsProvider, MethodInfo methodInfo);
    private static MethodInfo GetMethodInfo(InteractiveDiagnosticMethod interactiveDiagnosticMethod);
}
public interface Nancy.Diagnostics.IRequestTrace {
    public IDictionary`2<string, object> Items { get; public set; }
    public RequestData RequestData { get; public set; }
    public ResponseData ResponseData { get; public set; }
    public ITraceLog TraceLog { get; public set; }
    public abstract virtual IDictionary`2<string, object> get_Items();
    public abstract virtual void set_Items(IDictionary`2<string, object> value);
    public abstract virtual RequestData get_RequestData();
    public abstract virtual void set_RequestData(RequestData value);
    public abstract virtual ResponseData get_ResponseData();
    public abstract virtual void set_ResponseData(ResponseData value);
    public abstract virtual ITraceLog get_TraceLog();
    public abstract virtual void set_TraceLog(ITraceLog value);
}
public interface Nancy.Diagnostics.IRequestTraceFactory {
    public abstract virtual IRequestTrace Create(Request request);
}
public interface Nancy.Diagnostics.IRequestTracing {
    public abstract virtual void AddRequestDiagnosticToSession(Guid sessionId, NancyContext context);
    public abstract virtual void Clear();
    public abstract virtual Guid CreateSession();
    public abstract virtual IEnumerable`1<RequestTraceSession> GetSessions();
    public abstract virtual bool IsValidSessionId(Guid sessionId);
}
public interface Nancy.Diagnostics.ITraceLog {
    public abstract virtual void WriteLog(Action`1<StringBuilder> logDelegate);
}
public class Nancy.Diagnostics.Modules.InfoModule : DiagnosticModule {
    private ITypeCatalog typeCatalog;
    private IAssemblyCatalog assemblyCatalog;
    public InfoModule(IRootPathProvider rootPathProvider, NancyInternalConfiguration configuration, INancyEnvironment environment, ITypeCatalog typeCatalog, IAssemblyCatalog assemblyCatalog);
    private String[] GetViewEngines();
    private string GetBootstrapperContainer();
    private string GetHosting();
}
public class Nancy.Diagnostics.Modules.InteractiveModule : DiagnosticModule {
    private IInteractiveDiagnostics interactiveDiagnostics;
    public InteractiveModule(IInteractiveDiagnostics interactiveDiagnostics);
    private static Object[] GetArguments(InteractiveDiagnosticMethod method, object query);
    private static object ConvertArgument(string value, Type destinationType);
    [CompilerGeneratedAttribute]
private Response <.ctor>b__1_0(object _);
    [CompilerGeneratedAttribute]
private Response <.ctor>b__1_1(object _);
    [CompilerGeneratedAttribute]
private Response <.ctor>b__1_2(object ctx);
    [CompilerGeneratedAttribute]
private Response <.ctor>b__1_3(object ctx);
    [CompilerGeneratedAttribute]
private Response <.ctor>b__1_4(object ctx);
}
public class Nancy.Diagnostics.Modules.MainModule : DiagnosticModule {
    [CompilerGeneratedAttribute]
private Response <.ctor>b__0_0(object _);
    [CompilerGeneratedAttribute]
private Response <.ctor>b__0_1(object _);
}
public class Nancy.Diagnostics.Modules.SettingsModel : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Value>k__BackingField;
    public string Name { get; public set; }
    public bool Value { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public bool get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(bool value);
}
public class Nancy.Diagnostics.Modules.SettingsModule : DiagnosticModule {
    private static IEnumerable`1<Type> Types;
    private static SettingsModule();
    private static PropertyInfo GetProperty(SettingsModel model);
    private static string GetDescription(PropertyInfo property);
    [CompilerGeneratedAttribute]
private Response <.ctor>b__1_0(object _);
    [CompilerGeneratedAttribute]
private HttpStatusCode <.ctor>b__1_1(object _);
}
public class Nancy.Diagnostics.Modules.TraceModule : DiagnosticModule {
    private IRequestTracing sessionProvider;
    public TraceModule(IRequestTracing sessionProvider);
    [CompilerGeneratedAttribute]
private Response <.ctor>b__1_0(object _);
    [CompilerGeneratedAttribute]
private Response <.ctor>b__1_1(object _);
    [CompilerGeneratedAttribute]
private Response <.ctor>b__1_2(object ctx);
}
public class Nancy.Diagnostics.NullLog : object {
    public sealed virtual void WriteLog(Action`1<StringBuilder> logDelegate);
    public virtual string ToString();
}
public class Nancy.Diagnostics.RequestData : object {
    [CompilerGeneratedAttribute]
private MediaRange <ContentType>k__BackingField;
    [CompilerGeneratedAttribute]
private RequestHeaders <Headers>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Method>k__BackingField;
    [CompilerGeneratedAttribute]
private Url <Url>k__BackingField;
    public MediaRange ContentType { get; public set; }
    public RequestHeaders Headers { get; public set; }
    public string Method { get; public set; }
    public Url Url { get; public set; }
    [CompilerGeneratedAttribute]
public MediaRange get_ContentType();
    [CompilerGeneratedAttribute]
public void set_ContentType(MediaRange value);
    [CompilerGeneratedAttribute]
public RequestHeaders get_Headers();
    [CompilerGeneratedAttribute]
public void set_Headers(RequestHeaders value);
    [CompilerGeneratedAttribute]
public string get_Method();
    [CompilerGeneratedAttribute]
public void set_Method(string value);
    [CompilerGeneratedAttribute]
public Url get_Url();
    [CompilerGeneratedAttribute]
public void set_Url(Url value);
    public static RequestData op_Implicit(Request request);
}
public class Nancy.Diagnostics.RequestTraceSession : object {
    private static int MaxSize;
    private ConcurrentLimitedCollection`1<IRequestTrace> requestTraces;
    [CompilerGeneratedAttribute]
private Guid <Id>k__BackingField;
    public Guid Id { get; private set; }
    public IEnumerable`1<IRequestTrace> RequestTraces { get; }
    public RequestTraceSession(Guid id);
    [CompilerGeneratedAttribute]
public Guid get_Id();
    [CompilerGeneratedAttribute]
private void set_Id(Guid value);
    public IEnumerable`1<IRequestTrace> get_RequestTraces();
    public void AddRequestTrace(IRequestTrace trace);
}
public class Nancy.Diagnostics.ResponseData : object {
    [CompilerGeneratedAttribute]
private string <ContentType>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <Headers>k__BackingField;
    [CompilerGeneratedAttribute]
private HttpStatusCode <StatusCode>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    public string ContentType { get; public set; }
    public IDictionary`2<string, string> Headers { get; public set; }
    public HttpStatusCode StatusCode { get; public set; }
    public Type Type { get; public set; }
    [CompilerGeneratedAttribute]
public string get_ContentType();
    [CompilerGeneratedAttribute]
public void set_ContentType(string value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_Headers();
    [CompilerGeneratedAttribute]
public void set_Headers(IDictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public HttpStatusCode get_StatusCode();
    [CompilerGeneratedAttribute]
public void set_StatusCode(HttpStatusCode value);
    [CompilerGeneratedAttribute]
public Type get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(Type value);
    public static ResponseData op_Implicit(Response response);
}
[AttributeUsageAttribute("64")]
public class Nancy.Diagnostics.TemplateAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Template>k__BackingField;
    public string Template { get; public set; }
    public TemplateAttribute(string template);
    [CompilerGeneratedAttribute]
public string get_Template();
    [CompilerGeneratedAttribute]
public void set_Template(string value);
}
public class Nancy.Diagnostics.TestingDiagnosticProvider : object {
    private object diagObject;
    public string Name { get; }
    public string Description { get; }
    public object DiagnosticObject { get; }
    public sealed virtual string get_Name();
    public sealed virtual string get_Description();
    public sealed virtual object get_DiagnosticObject();
}
public class Nancy.DisabledStaticContentProvider : object {
    public sealed virtual Response GetContent(NancyContext context);
}
[DefaultMemberAttribute("Item")]
[DebuggerDisplayAttribute("{DebuggerDisplay, nq}")]
public class Nancy.DynamicDictionary : DynamicObject {
    private GlobalizationConfiguration globalizationConfiguration;
    [DynamicAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IDictionary`2<string, object> dictionary;
    public static DynamicDictionary Empty { get; }
    [DynamicAttribute]
public object Item { get; public set; }
    public ICollection`1<string> Keys { get; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    [DynamicAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ICollection`1<object> Values { get; }
    private string DebuggerDisplay { get; }
    public DynamicDictionary(GlobalizationConfiguration globalizationConfiguration);
    public static DynamicDictionary get_Empty();
    public static DynamicDictionary Create(IDictionary`2<string, object> values, GlobalizationConfiguration globalizationConfiguration);
    public virtual bool TrySetMember(SetMemberBinder binder, object value);
    public virtual bool TryGetMember(GetMemberBinder binder, Object& result);
    public virtual IEnumerable`1<string> GetDynamicMemberNames();
    public sealed virtual IEnumerator`1<string> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual object get_Item(string name);
    public sealed virtual void set_Item(string name, object value);
    public sealed virtual bool Equals(DynamicDictionary other);
    public virtual bool Equals(object obj);
    private sealed virtual override IEnumerator`1<KeyValuePair`2<string, object>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<System.String,System.Object>>.GetEnumerator();
    public virtual int GetHashCode();
    public sealed virtual void Add(string key, object value);
    public sealed virtual void Add(KeyValuePair`2<string, object> item);
    public sealed virtual bool ContainsKey(string key);
    public sealed virtual ICollection`1<string> get_Keys();
    public sealed virtual bool TryGetValue(string key, Object& value);
    public sealed virtual void Clear();
    public sealed virtual int get_Count();
    public sealed virtual bool Contains(KeyValuePair`2<string, object> item);
    public sealed virtual void CopyTo(KeyValuePair`2[] array, int arrayIndex);
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool Remove(string key);
    public sealed virtual bool Remove(KeyValuePair`2<string, object> item);
    public sealed virtual ICollection`1<object> get_Values();
    private KeyValuePair`2<string, object> GetDynamicKeyValuePair(KeyValuePair`2<string, object> item);
    private static string GetNeutralKey(string key);
    public Dictionary`2<string, object> ToDictionary();
    private string get_DebuggerDisplay();
    private sealed virtual override Type Nancy.IHideObjectMembers.GetType();
}
public class Nancy.DynamicDictionaryValue : DynamicObject {
    private object value;
    private GlobalizationConfiguration globalizationConfiguration;
    public bool HasValue { get; }
    public object Value { get; }
    public DynamicDictionaryValue(object value);
    public DynamicDictionaryValue(object value, GlobalizationConfiguration globalizationConfiguration);
    public bool get_HasValue();
    public object get_Value();
    public T Default(T defaultValue);
    public T TryParse(T defaultValue);
    public static bool op_Equality(DynamicDictionaryValue dynamicValue, object compareValue);
    public static bool op_Inequality(DynamicDictionaryValue dynamicValue, object compareValue);
    public sealed virtual bool Equals(DynamicDictionaryValue compareValue);
    public virtual bool Equals(object compareValue);
    public virtual int GetHashCode();
    public virtual bool TryBinaryOperation(BinaryOperationBinder binder, object arg, Object& result);
    public virtual bool TryConvert(ConvertBinder binder, Object& result);
    public virtual string ToString();
    public static Nullable`1<bool> op_Implicit(DynamicDictionaryValue dynamicValue);
    public static bool op_Implicit(DynamicDictionaryValue dynamicValue);
    public static string op_Implicit(DynamicDictionaryValue dynamicValue);
    public static Nullable`1<int> op_Implicit(DynamicDictionaryValue dynamicValue);
    public static int op_Implicit(DynamicDictionaryValue dynamicValue);
    public static Nullable`1<Guid> op_Implicit(DynamicDictionaryValue dynamicValue);
    public static Guid op_Implicit(DynamicDictionaryValue dynamicValue);
    public static Nullable`1<DateTime> op_Implicit(DynamicDictionaryValue dynamicValue);
    public static DateTime op_Implicit(DynamicDictionaryValue dynamicValue);
    public static Nullable`1<TimeSpan> op_Implicit(DynamicDictionaryValue dynamicValue);
    public static TimeSpan op_Implicit(DynamicDictionaryValue dynamicValue);
    public static Nullable`1<long> op_Implicit(DynamicDictionaryValue dynamicValue);
    public static long op_Implicit(DynamicDictionaryValue dynamicValue);
    public static Nullable`1<float> op_Implicit(DynamicDictionaryValue dynamicValue);
    public static float op_Implicit(DynamicDictionaryValue dynamicValue);
    public static Nullable`1<decimal> op_Implicit(DynamicDictionaryValue dynamicValue);
    public static decimal op_Implicit(DynamicDictionaryValue dynamicValue);
    public static Nullable`1<double> op_Implicit(DynamicDictionaryValue dynamicValue);
    public static double op_Implicit(DynamicDictionaryValue dynamicValue);
    public sealed virtual TypeCode GetTypeCode();
    public sealed virtual bool ToBoolean(IFormatProvider provider);
    public sealed virtual char ToChar(IFormatProvider provider);
    public sealed virtual sbyte ToSByte(IFormatProvider provider);
    public sealed virtual byte ToByte(IFormatProvider provider);
    public sealed virtual short ToInt16(IFormatProvider provider);
    public sealed virtual ushort ToUInt16(IFormatProvider provider);
    public sealed virtual int ToInt32(IFormatProvider provider);
    public sealed virtual UInt32 ToUInt32(IFormatProvider provider);
    public sealed virtual long ToInt64(IFormatProvider provider);
    public sealed virtual ulong ToUInt64(IFormatProvider provider);
    public sealed virtual float ToSingle(IFormatProvider provider);
    public sealed virtual double ToDouble(IFormatProvider provider);
    public sealed virtual decimal ToDecimal(IFormatProvider provider);
    public sealed virtual DateTime ToDateTime(IFormatProvider provider);
    public sealed virtual string ToString(IFormatProvider provider);
    public sealed virtual object ToType(Type conversionType, IFormatProvider provider);
    private sealed virtual override Type Nancy.IHideObjectMembers.GetType();
}
public class Nancy.ErrorHandling.DefaultStatusCodeHandler : object {
    private static string DisplayErrorTracesFalseMessage;
    private IDictionary`2<HttpStatusCode, string> errorMessages;
    private IDictionary`2<HttpStatusCode, string> errorPages;
    private IResponseNegotiator responseNegotiator;
    private HttpStatusCode[] supportedStatusCodes;
    private TraceConfiguration configuration;
    public DefaultStatusCodeHandler(IResponseNegotiator responseNegotiator, INancyEnvironment environment);
    public sealed virtual bool HandlesStatusCode(HttpStatusCode statusCode, NancyContext context);
    public sealed virtual void Handle(HttpStatusCode statusCode, NancyContext context);
    private void ModifyResponse(HttpStatusCode statusCode, NancyContext context, DefaultStatusCodeHandlerResult result);
    private static string LoadResource(string filename);
}
public interface Nancy.ErrorHandling.IStatusCodeHandler {
    public abstract virtual bool HandlesStatusCode(HttpStatusCode statusCode, NancyContext context);
    public abstract virtual void Handle(HttpStatusCode statusCode, NancyContext context);
}
public class Nancy.ErrorHandling.RouteExecutionEarlyExitException : Exception {
    [CompilerGeneratedAttribute]
private string <Reason>k__BackingField;
    [CompilerGeneratedAttribute]
private Response <Response>k__BackingField;
    public string Reason { get; public set; }
    public Response Response { get; protected set; }
    public RouteExecutionEarlyExitException(Response response, string reason);
    [CompilerGeneratedAttribute]
public string get_Reason();
    [CompilerGeneratedAttribute]
public void set_Reason(string value);
    [CompilerGeneratedAttribute]
public Response get_Response();
    [CompilerGeneratedAttribute]
protected void set_Response(Response value);
}
[DynamicAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Nancy.ErrorPipeline : NamedPipelineBase`1<Func`3<NancyContext, Exception, object>> {
    public ErrorPipeline(int capacity);
    public static Func`3<NancyContext, Exception, object> op_Implicit(ErrorPipeline pipeline);
    public static ErrorPipeline op_Implicit(Func`3<NancyContext, Exception, object> func);
    public static ErrorPipeline op_Addition(ErrorPipeline pipeline, Func`3<NancyContext, Exception, object> func);
    public static ErrorPipeline op_Addition(ErrorPipeline pipelineToAddTo, ErrorPipeline pipelineToAdd);
    public object Invoke(NancyContext context, Exception ex);
}
[ExtensionAttribute]
public static class Nancy.Extensions.AssemblyExtensions : object {
    [ExtensionAttribute]
public static Type[] SafeGetExportedTypes(Assembly assembly);
    [ExtensionAttribute]
public static bool IsReferencing(Assembly assembly, AssemblyName referenceName);
}
[ExtensionAttribute]
public static class Nancy.Extensions.CollectionExtensions : object {
    [ExtensionAttribute]
public static IDictionary`2<string, IEnumerable`1<string>> ToDictionary(NameValueCollection source);
    [ExtensionAttribute]
public static NameValueCollection ToNameValueCollection(IDictionary`2<string, IEnumerable`1<string>> source);
    [ExtensionAttribute]
public static IDictionary`2<string, string> Merge(IEnumerable`1<IDictionary`2<string, string>> dictionaries);
    [IteratorStateMachineAttribute("Nancy.Extensions.CollectionExtensions/<DistinctBy>d__3`2")]
[ExtensionAttribute]
public static IEnumerable`1<TSource> DistinctBy(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector);
}
[ExtensionAttribute]
public static class Nancy.Extensions.ContextExtensions : object {
    [ExtensionAttribute]
public static bool IsAjaxRequest(NancyContext context);
    [ExtensionAttribute]
public static string ToFullPath(NancyContext context, string path);
    [ExtensionAttribute]
public static RedirectResponse GetRedirect(NancyContext context, string path);
    [ExtensionAttribute]
public static string GetExceptionDetails(NancyContext context);
    [ExtensionAttribute]
public static Exception GetException(NancyContext context);
    [ExtensionAttribute]
public static T GetException(NancyContext context);
    [ExtensionAttribute]
public static bool TryGetException(NancyContext context, Exception& exception);
    [ExtensionAttribute]
public static bool TryGetException(NancyContext context, T& exception);
    [ExtensionAttribute]
public static void WriteTraceLog(NancyContext context, Action`1<StringBuilder> logDelegate);
    [ExtensionAttribute]
public static bool IsLocalUrl(NancyContext context, string url);
}
[ExtensionAttribute]
public static class Nancy.Extensions.MemoryStreamExtensions : object {
    [ExtensionAttribute]
public static ArraySegment`1<byte> GetBufferSegment(MemoryStream stream);
    [ExtensionAttribute]
private static Byte[] GetBytes(MemoryStream stream);
}
[ExtensionAttribute]
public static class Nancy.Extensions.ModuleExtensions : object {
    [ExtensionAttribute]
public static string GetModuleName(INancyModule module);
    [ExtensionAttribute]
public static bool RouteExecuting(INancyModule module);
    [ExtensionAttribute]
public static void AddBeforeHookOrExecute(INancyModule module, Func`2<NancyContext, Response> beforeDelegate, string earlyExitReason);
}
[ExtensionAttribute]
public static class Nancy.Extensions.ObjectExtensions : object {
    [ExtensionAttribute]
public static object ToDynamic(object value);
}
[ExtensionAttribute]
public static class Nancy.Extensions.RequestExtensions : object {
    [ExtensionAttribute]
public static bool IsAjaxRequest(Request request);
    [ExtensionAttribute]
public static bool IsLocal(Request request);
}
[ExtensionAttribute]
public static class Nancy.Extensions.StreamExtensions : object {
    internal static int BufferSize;
    [ExtensionAttribute]
public static string AsString(Stream stream, Encoding encoding);
}
[ExtensionAttribute]
public static class Nancy.Extensions.StringExtensions : object {
    [DebuggerBrowsableAttribute("0")]
private static Regex ParameterExpression;
    private static StringExtensions();
    [ExtensionAttribute]
public static IEnumerable`1<ParameterSegmentInformation> GetParameterDetails(string segment);
    [ExtensionAttribute]
public static bool IsParameterized(string segment);
    [ExtensionAttribute]
public static DynamicDictionary AsQueryDictionary(string queryString);
    [ExtensionAttribute]
public static string ToCamelCase(string value);
    [ExtensionAttribute]
public static string ToPascalCase(string value);
    [ExtensionAttribute]
private static string ConvertFirstCharacter(string value, Func`2<string, string> converter);
}
[ExtensionAttribute]
public static class Nancy.Extensions.TypeExtensions : object {
    [ExtensionAttribute]
public static T CreateInstance(Type type, bool nonPublic);
    [ExtensionAttribute]
public static object CreateInstance(Type type, bool nonPublic);
    [ExtensionAttribute]
public static Assembly GetAssembly(Type source);
    [ExtensionAttribute]
public static bool IsArray(Type source);
    [ExtensionAttribute]
public static bool IsAssignableToGenericType(Type givenType, Type genericType);
    [ExtensionAttribute]
public static bool IsCollection(Type source);
    [ExtensionAttribute]
public static bool IsEnumerable(Type source);
    [ExtensionAttribute]
public static bool IsNumeric(Type source);
    [ExtensionAttribute]
public static IEnumerable`1<Type> NotOfType(IEnumerable`1<Type> types);
    [ExtensionAttribute]
private static bool HasInterfaceThatMapsToGenericTypeDefinition(Type givenType, Type genericType);
    [ExtensionAttribute]
private static bool MapsToGenericTypeDefinition(Type givenType, Type genericType);
    [ExtensionAttribute]
public static TypeCode GetTypeCode(Type type);
    private static object CreateInstanceInternal(Type type, bool nonPublic);
}
[ExtensionAttribute]
public static class Nancy.FormatterExtensions : object {
    private static ISerializer jsonSerializer;
    private static ISerializer xmlSerializer;
    [ExtensionAttribute]
public static Response AsFile(IResponseFormatter formatter, string applicationRelativeFilePath, string contentType);
    [ExtensionAttribute]
public static Response AsFile(IResponseFormatter formatter, string applicationRelativeFilePath);
    [ExtensionAttribute]
public static Response AsText(IResponseFormatter formatter, string contents, string contentType, Encoding encoding);
    [ExtensionAttribute]
public static Response AsText(IResponseFormatter formatter, string contents, Encoding encoding);
    [ExtensionAttribute]
public static Response AsText(IResponseFormatter formatter, string contents, string contentType);
    [ExtensionAttribute]
public static Response AsText(IResponseFormatter formatter, string contents);
    [ExtensionAttribute]
public static Response AsJson(IResponseFormatter formatter, TModel model, HttpStatusCode statusCode);
    [ExtensionAttribute]
public static Response AsRedirect(IResponseFormatter formatter, string location, RedirectType type);
    [ExtensionAttribute]
public static Response AsXml(IResponseFormatter formatter, TModel model, HttpStatusCode statusCode);
    [ExtensionAttribute]
public static Response FromStream(IResponseFormatter formatter, Stream stream, string contentType);
    [ExtensionAttribute]
public static Response FromStream(IResponseFormatter formatter, Func`1<Stream> streamDelegate, string contentType);
}
public class Nancy.GlobalizationConfiguration : object {
    public static GlobalizationConfiguration Default;
    [CompilerGeneratedAttribute]
private DateTimeStyles <DateTimeStyles>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DefaultCulture>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <SupportedCultureNames>k__BackingField;
    public DateTimeStyles DateTimeStyles { get; private set; }
    public string DefaultCulture { get; private set; }
    public IEnumerable`1<string> SupportedCultureNames { get; private set; }
    public GlobalizationConfiguration(IEnumerable`1<string> supportedCultureNames, string defaultCulture, Nullable`1<DateTimeStyles> dateTimeStyles);
    private static GlobalizationConfiguration();
    [CompilerGeneratedAttribute]
public DateTimeStyles get_DateTimeStyles();
    [CompilerGeneratedAttribute]
private void set_DateTimeStyles(DateTimeStyles value);
    [CompilerGeneratedAttribute]
public string get_DefaultCulture();
    [CompilerGeneratedAttribute]
private void set_DefaultCulture(string value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_SupportedCultureNames();
    [CompilerGeneratedAttribute]
private void set_SupportedCultureNames(IEnumerable`1<string> value);
}
[ExtensionAttribute]
public static class Nancy.GlobalizationConfigurationExtensions : object {
    [ExtensionAttribute]
public static void Globalization(INancyEnvironment environment, IEnumerable`1<string> supportedCultureNames, string defaultCulture, Nullable`1<DateTimeStyles> dateTimeStyles);
}
public class Nancy.HeadResponse : Response {
    private static string ContentLength;
    private Response innerResponse;
    public HeadResponse(Response response);
    public virtual Task PreExecute(NancyContext context);
    private void CheckAndSetContentLength(Response response);
    [CompilerGeneratedAttribute]
private void <.ctor>b__2_0(Stream stream);
}
public static class Nancy.Helpers.CacheHelpers : object {
    public static bool ReturnNotModified(string etag, Nullable`1<DateTime> lastModified, NancyContext context);
}
[ExtensionAttribute]
internal static class Nancy.Helpers.ExceptionExtensions : object {
    [ExtensionAttribute]
internal static Exception FlattenInnerExceptions(Exception exception);
}
internal class Nancy.Helpers.HttpEncoder : object {
    private static Char[] hexChars;
    private static object entitiesLock;
    private static SortedDictionary`2<string, char> entities;
    private static HttpEncoder defaultEncoder;
    private static HttpEncoder currentEncoder;
    private static IDictionary`2<string, char> Entities { get; }
    public static HttpEncoder Current { get; }
    public static HttpEncoder Default { get; }
    private static HttpEncoder();
    private static IDictionary`2<string, char> get_Entities();
    public static HttpEncoder get_Current();
    public static HttpEncoder get_Default();
    internal static void HeaderNameValueEncode(string headerName, string headerValue, String& encodedHeaderName, String& encodedHeaderValue);
    private static void StringBuilderAppend(string s, StringBuilder& sb);
    private static string EncodeHeaderString(string input);
    internal static string UrlPathEncode(string value);
    internal static Byte[] UrlEncodeToBytes(Byte[] bytes, int offset, int count);
    internal static string HtmlEncode(string s);
    internal static string HtmlAttributeEncode(string s);
    internal static string HtmlDecode(string s);
    internal static bool IsHexDigit(char character);
    internal static int FromHex(char digit);
    internal static bool NotEncoded(char c);
    internal static void UrlEncodeChar(char c, Stream result, bool isUnicode);
    internal static void UrlPathEncodeChar(char c, Stream result);
    private static void InitEntities();
}
public class Nancy.Helpers.HttpUtility : object {
    public static void HtmlAttributeEncode(string s, TextWriter output);
    public static string HtmlAttributeEncode(string s);
    public static string UrlDecode(string str);
    private static Char[] GetChars(MemoryStream b, Encoding e);
    private static void WriteCharBytes(IList buf, char ch, Encoding e);
    public static string UrlDecode(string s, Encoding e);
    public static string UrlDecode(Byte[] bytes, Encoding e);
    private static int GetInt(byte b);
    private static int GetChar(Byte[] bytes, int offset, int length);
    private static int GetChar(string str, int offset, int length);
    public static string UrlDecode(Byte[] bytes, int offset, int count, Encoding e);
    public static Byte[] UrlDecodeToBytes(Byte[] bytes);
    public static Byte[] UrlDecodeToBytes(string str);
    public static Byte[] UrlDecodeToBytes(string str, Encoding e);
    public static Byte[] UrlDecodeToBytes(Byte[] bytes, int offset, int count);
    public static string UrlEncode(string str);
    public static string UrlEncode(string s, Encoding Enc);
    public static string UrlEncode(Byte[] bytes);
    public static string UrlEncode(Byte[] bytes, int offset, int count);
    public static Byte[] UrlEncodeToBytes(string str);
    public static Byte[] UrlEncodeToBytes(string str, Encoding e);
    public static Byte[] UrlEncodeToBytes(Byte[] bytes);
    public static Byte[] UrlEncodeToBytes(Byte[] bytes, int offset, int count);
    public static string UrlEncodeUnicode(string str);
    public static Byte[] UrlEncodeUnicodeToBytes(string str);
    public static string HtmlDecode(string s);
    public static void HtmlDecode(string s, TextWriter output);
    public static string HtmlEncode(string s);
    public static void HtmlEncode(string s, TextWriter output);
    public static string UrlPathEncode(string s);
    public static NameValueCollection ParseQueryString(string query);
    public static NameValueCollection ParseQueryString(string query, bool caseSensitive);
    public static NameValueCollection ParseQueryString(string query, Encoding encoding);
    public static NameValueCollection ParseQueryString(string query, Encoding encoding, bool caseSensitive);
    internal static void ParseQueryString(string query, Encoding encoding, NameValueCollection result);
    private static KeyValuePair`2<string, string> ParseQueryStringSegment(string segment, Encoding encoding);
}
internal class Nancy.Helpers.ProxyNancyReferenceProber : MarshalByRefObject {
    public bool HasReference(AssemblyName assemblyNameForProbing, AssemblyName referenceAssemblyName);
}
internal static class Nancy.Helpers.ReflectionUtils : object {
    private static Type GenericListType;
    private static Type GenericDictionaryType;
    private static ReflectionUtils();
    public static bool IsInstantiatableType(Type t);
    public static bool HasDefaultConstructor(Type t);
    public static bool IsAssignable(Type to, Type from);
    public static bool IsSubClass(Type type, Type check);
    public static Type GetTypedListItemType(Type type);
    public static Type GetTypedDictionaryValueType(Type type);
    public static Type GetGenericDictionary(Type type);
    public static Type GetMemberUnderlyingType(MemberInfo member);
    public static bool IsIndexedProperty(MemberInfo member);
    public static bool IsIndexedProperty(PropertyInfo property);
    public static object GetMemberValue(MemberInfo member, object target);
    public static void SetMemberValue(MemberInfo member, object target, object value);
    public static bool CanReadMemberValue(MemberInfo member);
    public static bool CanSetMemberValue(MemberInfo member);
    [IteratorStateMachineAttribute("Nancy.Helpers.ReflectionUtils/<GetFieldsAndProperties>d__16")]
public static IEnumerable`1<MemberInfo> GetFieldsAndProperties(Type type, BindingFlags bindingAttr);
}
public static class Nancy.Helpers.TaskHelpers : object {
    public static Task CompletedTask;
    private static TaskHelpers();
    public static Task`1<T> GetFaultedTask(Exception exception);
}
public class Nancy.HttpFile : object {
    [CompilerGeneratedAttribute]
private string <ContentType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private Stream <Value>k__BackingField;
    public string ContentType { get; private set; }
    public string Name { get; private set; }
    public string Key { get; private set; }
    public Stream Value { get; private set; }
    public HttpFile(HttpMultipartBoundary boundary);
    public HttpFile(string contentType, string name, Stream value, string key);
    [CompilerGeneratedAttribute]
public string get_ContentType();
    [CompilerGeneratedAttribute]
private void set_ContentType(string value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_Key();
    [CompilerGeneratedAttribute]
private void set_Key(string value);
    [CompilerGeneratedAttribute]
public Stream get_Value();
    [CompilerGeneratedAttribute]
private void set_Value(Stream value);
}
public class Nancy.HttpLink : object {
    private static HttpLinkParameterComparer ParameterComparer;
    private IDictionary`2<string, object> parameters;
    private Uri targetUri;
    public IDictionary`2<string, object> Parameters { get; }
    public HttpLinkRelation Relation { get; }
    public Uri TargetUri { get; }
    public string Title { get; }
    public MediaRange Type { get; }
    public HttpLink(string targetUri, string relation);
    public HttpLink(string targetUri, string relation, string type);
    public HttpLink(string targetUri, string relation, string type, string title);
    public HttpLink(Uri targetUri, string relation, string type, string title);
    private static HttpLink();
    public IDictionary`2<string, object> get_Parameters();
    public HttpLinkRelation get_Relation();
    public Uri get_TargetUri();
    public string get_Title();
    public MediaRange get_Type();
    public sealed virtual bool Equals(HttpLink other);
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
    public virtual string ToString();
    private T GetParameterValue(string parameterName);
    private static Uri ParseUri(string uri);
}
public class Nancy.HttpLinkBuilder : List`1<HttpLink> {
    private List`1<string> additionalLinks;
    public void Add(string link);
    public virtual string ToString();
}
public class Nancy.HttpLinkRelation : Uri {
    public static Uri IanaLinkRelationPrefix;
    private Uri prefix;
    private string value;
    public Uri Prefix { get; }
    public string Value { get; }
    public HttpLinkRelation(string relation);
    public HttpLinkRelation(Uri prefix, string value);
    private static HttpLinkRelation();
    public Uri get_Prefix();
    public string get_Value();
    public sealed virtual bool Equals(HttpLinkRelation other);
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
    public static HttpLinkRelation Parse(string relation);
    public virtual string ToString();
}
public class Nancy.HttpMultipart : object {
    private static byte LF;
    private Byte[] boundaryAsBytes;
    private HttpMultipartBuffer readBuffer;
    private Stream requestStream;
    private Byte[] closingBoundaryAsBytes;
    public HttpMultipart(Stream requestStream, string boundary);
    public IEnumerable`1<HttpMultipartBoundary> GetBoundaries();
    private IEnumerable`1<HttpMultipartSubStream> GetBoundarySubStreams();
    private bool MultipartIsNotCompleted(long boundaryPosition);
    private long GetActualEndOfBoundary(long boundaryEnd);
    private bool CheckIfFoundEndOfStream();
    private static Byte[] GetBoundaryAsBytes(string boundary, bool closing);
    private long GetNextBoundaryPosition();
}
public class Nancy.HttpMultipartBoundary : object {
    private static byte LF;
    private static byte CR;
    [CompilerGeneratedAttribute]
private string <ContentType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Filename>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private HttpMultipartSubStream <Value>k__BackingField;
    public string ContentType { get; private set; }
    public string Filename { get; private set; }
    public string Name { get; private set; }
    public HttpMultipartSubStream Value { get; private set; }
    public HttpMultipartBoundary(HttpMultipartSubStream boundaryStream);
    [CompilerGeneratedAttribute]
public string get_ContentType();
    [CompilerGeneratedAttribute]
private void set_ContentType(string value);
    [CompilerGeneratedAttribute]
public string get_Filename();
    [CompilerGeneratedAttribute]
private void set_Filename(string value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
    [CompilerGeneratedAttribute]
public HttpMultipartSubStream get_Value();
    [CompilerGeneratedAttribute]
private void set_Value(HttpMultipartSubStream value);
    private void ExtractHeaders();
    private static string ReadLineFromStream(Stream stream);
}
public class Nancy.HttpMultipartBuffer : object {
    private Byte[] boundaryAsBytes;
    private Byte[] closingBoundaryAsBytes;
    private Byte[] buffer;
    private int position;
    public bool IsBoundary { get; }
    public bool IsClosingBoundary { get; }
    public bool IsFull { get; }
    public int Length { get; }
    public HttpMultipartBuffer(Byte[] boundaryAsBytes, Byte[] closingBoundaryAsBytes);
    public bool get_IsBoundary();
    public bool get_IsClosingBoundary();
    public bool get_IsFull();
    public int get_Length();
    public void Reset();
    public void Insert(byte value);
}
public class Nancy.HttpMultipartSubStream : Stream {
    private Stream stream;
    private long start;
    private long end;
    private long position;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public HttpMultipartSubStream(Stream stream, long start, long end);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    private long CalculateSubStreamRelativePosition(SeekOrigin origin, long offset);
    public void PositionStartAtCurrentLocation();
    public virtual void Flush();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual int ReadByte();
    private void RepositionAfterRead(int bytesReadFromStream);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    private void ThrowExceptionIsPositionIsOutOfBounds(long subStreamRelativePosition);
}
public enum Nancy.HttpStatusCode : Enum {
    public int value__;
    public static HttpStatusCode Continue;
    public static HttpStatusCode SwitchingProtocols;
    public static HttpStatusCode Processing;
    public static HttpStatusCode Checkpoint;
    public static HttpStatusCode OK;
    public static HttpStatusCode Created;
    public static HttpStatusCode Accepted;
    public static HttpStatusCode NonAuthoritativeInformation;
    public static HttpStatusCode NoContent;
    public static HttpStatusCode ResetContent;
    public static HttpStatusCode PartialContent;
    public static HttpStatusCode MultipleStatus;
    public static HttpStatusCode IMUsed;
    public static HttpStatusCode MultipleChoices;
    public static HttpStatusCode MovedPermanently;
    public static HttpStatusCode Found;
    public static HttpStatusCode SeeOther;
    public static HttpStatusCode NotModified;
    public static HttpStatusCode UseProxy;
    public static HttpStatusCode SwitchProxy;
    public static HttpStatusCode TemporaryRedirect;
    public static HttpStatusCode ResumeIncomplete;
    public static HttpStatusCode BadRequest;
    public static HttpStatusCode Unauthorized;
    public static HttpStatusCode PaymentRequired;
    public static HttpStatusCode Forbidden;
    public static HttpStatusCode NotFound;
    public static HttpStatusCode MethodNotAllowed;
    public static HttpStatusCode NotAcceptable;
    public static HttpStatusCode ProxyAuthenticationRequired;
    public static HttpStatusCode RequestTimeout;
    public static HttpStatusCode Conflict;
    public static HttpStatusCode Gone;
    public static HttpStatusCode LengthRequired;
    public static HttpStatusCode PreconditionFailed;
    public static HttpStatusCode RequestEntityTooLarge;
    public static HttpStatusCode RequestUriTooLong;
    public static HttpStatusCode UnsupportedMediaType;
    public static HttpStatusCode RequestedRangeNotSatisfiable;
    public static HttpStatusCode ExpectationFailed;
    public static HttpStatusCode ImATeapot;
    public static HttpStatusCode EnhanceYourCalm;
    public static HttpStatusCode UnprocessableEntity;
    public static HttpStatusCode Locked;
    public static HttpStatusCode FailedDependency;
    public static HttpStatusCode UnorderedCollection;
    public static HttpStatusCode UpgradeRequired;
    public static HttpStatusCode TooManyRequests;
    public static HttpStatusCode NoResponse;
    public static HttpStatusCode RetryWith;
    public static HttpStatusCode BlockedByWindowsParentalControls;
    public static HttpStatusCode UnavailableForLegalReasons;
    public static HttpStatusCode ClientClosedRequest;
    public static HttpStatusCode InternalServerError;
    public static HttpStatusCode NotImplemented;
    public static HttpStatusCode BadGateway;
    public static HttpStatusCode ServiceUnavailable;
    public static HttpStatusCode GatewayTimeout;
    public static HttpStatusCode HttpVersionNotSupported;
    public static HttpStatusCode VariantAlsoNegotiates;
    public static HttpStatusCode InsufficientStorage;
    public static HttpStatusCode BandwidthLimitExceeded;
    public static HttpStatusCode NotExtended;
}
public interface Nancy.IAssemblyCatalog {
    public abstract virtual IReadOnlyCollection`1<Assembly> GetAssemblies();
}
[EditorBrowsableAttribute("1")]
public interface Nancy.IHideObjectMembers {
    [EditorBrowsableAttribute("1")]
public abstract virtual bool Equals(object obj);
    [EditorBrowsableAttribute("1")]
public abstract virtual int GetHashCode();
    [EditorBrowsableAttribute("1")]
public abstract virtual Type GetType();
    [EditorBrowsableAttribute("1")]
public abstract virtual string ToString();
}
[GeneratedCodeAttribute("simple-json", "1.0.0")]
internal interface Nancy.IJsonSerializerStrategy {
    public abstract virtual bool TrySerializeNonPrimitiveObject(object input, Object& output);
    public abstract virtual object DeserializeObject(object value, Type type);
}
public interface Nancy.INancyContextFactory {
    public abstract virtual NancyContext Create(Request request);
}
public interface Nancy.INancyEngine {
    public Func`2<NancyContext, IPipelines> RequestPipelinesFactory { get; public set; }
    public abstract virtual Func`2<NancyContext, IPipelines> get_RequestPipelinesFactory();
    public abstract virtual void set_RequestPipelinesFactory(Func`2<NancyContext, IPipelines> value);
    public abstract virtual Task`1<NancyContext> HandleRequest(Request request, Func`2<NancyContext, NancyContext> preRequest, CancellationToken cancellationToken);
}
public interface Nancy.INancyModule {
    public AfterPipeline After { get; public set; }
    public BeforePipeline Before { get; public set; }
    public ErrorPipeline OnError { get; public set; }
    public NancyContext Context { get; public set; }
    public IResponseFormatter Response { get; public set; }
    public IModelBinderLocator ModelBinderLocator { get; public set; }
    [EditorBrowsableAttribute("1")]
public ModelValidationResult ModelValidationResult { get; public set; }
    public IModelValidatorLocator ValidatorLocator { get; public set; }
    public Request Request { get; public set; }
    public IViewFactory ViewFactory { get; public set; }
    public string ModulePath { get; }
    public IEnumerable`1<Route> Routes { get; }
    [DynamicAttribute]
public object Text { get; }
    public ViewRenderer View { get; }
    public Negotiator Negotiate { get; }
    public abstract virtual AfterPipeline get_After();
    public abstract virtual void set_After(AfterPipeline value);
    public abstract virtual BeforePipeline get_Before();
    public abstract virtual void set_Before(BeforePipeline value);
    public abstract virtual ErrorPipeline get_OnError();
    public abstract virtual void set_OnError(ErrorPipeline value);
    public abstract virtual NancyContext get_Context();
    public abstract virtual void set_Context(NancyContext value);
    public abstract virtual IResponseFormatter get_Response();
    public abstract virtual void set_Response(IResponseFormatter value);
    public abstract virtual IModelBinderLocator get_ModelBinderLocator();
    public abstract virtual void set_ModelBinderLocator(IModelBinderLocator value);
    public abstract virtual ModelValidationResult get_ModelValidationResult();
    public abstract virtual void set_ModelValidationResult(ModelValidationResult value);
    public abstract virtual IModelValidatorLocator get_ValidatorLocator();
    public abstract virtual void set_ValidatorLocator(IModelValidatorLocator value);
    public abstract virtual Request get_Request();
    public abstract virtual void set_Request(Request value);
    public abstract virtual IViewFactory get_ViewFactory();
    public abstract virtual void set_ViewFactory(IViewFactory value);
    public abstract virtual string get_ModulePath();
    public abstract virtual IEnumerable`1<Route> get_Routes();
    public abstract virtual object get_Text();
    public abstract virtual ViewRenderer get_View();
    public abstract virtual Negotiator get_Negotiate();
}
public interface Nancy.INancyModuleCatalog {
    public abstract virtual IEnumerable`1<INancyModule> GetAllModules(NancyContext context);
    public abstract virtual INancyModule GetModule(Type moduleType, NancyContext context);
}
[AttributeUsageAttribute("1")]
public class Nancy.IncludeInNancyAssemblyScanningAttribute : Attribute {
}
public class Nancy.IO.RequestStream : Stream {
    internal static int BufferSize;
    public static long DEFAULT_SWITCHOVER_THRESHOLD;
    private bool disableStreamSwitching;
    private long thresholdLength;
    private bool isSafeToDisposeStream;
    private Stream stream;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanTimeout { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public bool IsInMemory { get; }
    public long Position { get; public set; }
    public RequestStream(long expectedLength, long thresholdLength, bool disableStreamSwitching);
    public RequestStream(Stream stream, long expectedLength, bool disableStreamSwitching);
    public RequestStream(long expectedLength, bool disableStreamSwitching);
    public RequestStream(Stream stream, long expectedLength, long thresholdLength, bool disableStreamSwitching);
    private static RequestStream();
    protected virtual override void Finalize();
    private void MoveToWritableStream();
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanTimeout();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public bool get_IsInMemory();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    protected virtual void Dispose(bool disposing);
    public virtual int EndRead(IAsyncResult asyncResult);
    public virtual void EndWrite(IAsyncResult asyncResult);
    public virtual void Flush();
    public static RequestStream FromStream(Stream stream);
    public static RequestStream FromStream(Stream stream, long expectedLength);
    public static RequestStream FromStream(Stream stream, long expectedLength, long thresholdLength);
    public static RequestStream FromStream(Stream stream, long expectedLength, bool disableStreamSwitching);
    public static RequestStream FromStream(Stream stream, long expectedLength, long thresholdLength, bool disableStreamSwitching);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual int ReadByte();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    private void ShiftStreamToFileStreamIfNecessary();
    private static FileStream CreateTemporaryFileStream();
    private Stream CreateDefaultMemoryStream(long expectedLength);
    private static void DeleteTemporaryFile(string fileName);
    private void MoveStreamOutOfMemoryIfContentsLengthExceedThresholdAndSwitchingIsEnabled();
    private bool MoveStreamOutOfMemoryIfExpectedLengthExceedSwitchLength(long expectedLength);
    private void MoveStreamContentsToFileStream();
    private static void ThrowExceptionIfCtorParametersWereInvalid(Stream stream, long expectedLength, long thresholdLength);
}
public class Nancy.IO.UnclosableStreamWrapper : Stream {
    private Stream baseStream;
    public Stream BaseStream { get; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public bool CanTimeout { get; }
    public int ReadTimeout { get; public set; }
    public int WriteTimeout { get; public set; }
    public UnclosableStreamWrapper(Stream baseStream);
    public Stream get_BaseStream();
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual bool get_CanTimeout();
    public virtual int get_ReadTimeout();
    public virtual void set_ReadTimeout(int value);
    public virtual int get_WriteTimeout();
    public virtual void set_WriteTimeout(int value);
    public virtual void Close();
    public sealed virtual void Dispose();
    public virtual void Flush();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual int EndRead(IAsyncResult asyncResult);
    public virtual void EndWrite(IAsyncResult asyncResult);
    public virtual int ReadByte();
    public virtual void WriteByte(byte value);
    protected virtual void Dispose(bool disposing);
}
public interface Nancy.IObjectSerializer {
    public abstract virtual string Serialize(object sourceObject);
    public abstract virtual object Deserialize(string sourceString);
}
public interface Nancy.IObjectSerializerSelector {
    public abstract virtual void WithSerializer(IObjectSerializer newSerializer);
}
public interface Nancy.IResourceAssemblyProvider {
    public abstract virtual IEnumerable`1<Assembly> GetAssembliesToScan();
}
public interface Nancy.IResponseFormatter {
    public ISerializerFactory SerializerFactory { get; }
    public NancyContext Context { get; }
    public INancyEnvironment Environment { get; }
    public string RootPath { get; }
    public abstract virtual ISerializerFactory get_SerializerFactory();
    public abstract virtual NancyContext get_Context();
    public abstract virtual INancyEnvironment get_Environment();
    public abstract virtual string get_RootPath();
}
public interface Nancy.IResponseFormatterFactory {
    public abstract virtual IResponseFormatter Create(NancyContext context);
}
public interface Nancy.IRootPathProvider {
    public abstract virtual string GetRootPath();
}
public interface Nancy.IRuntimeEnvironmentInformation {
    public bool IsDebug { get; }
    public abstract virtual bool get_IsDebug();
}
public interface Nancy.ISerializer {
    public IEnumerable`1<string> Extensions { get; }
    public abstract virtual bool CanSerialize(MediaRange mediaRange);
    public abstract virtual IEnumerable`1<string> get_Extensions();
    public abstract virtual void Serialize(MediaRange mediaRange, TModel model, Stream outputStream);
}
public interface Nancy.ISerializerFactory {
    public abstract virtual ISerializer GetSerializer(MediaRange mediaRange);
}
public interface Nancy.IStaticContentProvider {
    public abstract virtual Response GetContent(NancyContext context);
}
public interface Nancy.ITypeCatalog {
    public abstract virtual IReadOnlyCollection`1<Type> GetTypesAssignableTo(Type type, TypeResolveStrategy strategy);
}
public class Nancy.Json.Converters.TimeSpanConverter : JavaScriptConverter {
    public IEnumerable`1<Type> SupportedTypes { get; }
    public virtual IEnumerable`1<Type> get_SupportedTypes();
    public virtual object Deserialize(IDictionary`2<string, object> dictionary, Type type, JavaScriptSerializer serializer);
    public virtual IDictionary`2<string, object> Serialize(object obj, JavaScriptSerializer serializer);
    private int GetValue(IDictionary`2<string, object> dictionary, string key);
}
public class Nancy.Json.Converters.TupleConverter : JavaScriptConverter {
    public IEnumerable`1<Type> SupportedTypes { get; }
    [IteratorStateMachineAttribute("Nancy.Json.Converters.TupleConverter/<get_SupportedTypes>d__1")]
public virtual IEnumerable`1<Type> get_SupportedTypes();
    public virtual object Deserialize(IDictionary`2<string, object> dictionary, Type type, JavaScriptSerializer serializer);
    public virtual IDictionary`2<string, object> Serialize(object obj, JavaScriptSerializer serializer);
}
public class Nancy.Json.DefaultJsonConfigurationProvider : NancyDefaultConfigurationProvider`1<JsonConfiguration> {
    public virtual JsonConfiguration GetDefaultConfiguration();
}
public abstract class Nancy.Json.JavaScriptConverter : object {
    public IEnumerable`1<Type> SupportedTypes { get; }
    public abstract virtual IEnumerable`1<Type> get_SupportedTypes();
    public virtual object Deserialize(IDictionary`2<string, object> dictionary, Type type);
    public abstract virtual object Deserialize(IDictionary`2<string, object> dictionary, Type type, JavaScriptSerializer serializer);
    public IDictionary`2<string, object> Serialize(object obj);
    public abstract virtual IDictionary`2<string, object> Serialize(object obj, JavaScriptSerializer serializer);
}
public abstract class Nancy.Json.JavaScriptPrimitiveConverter : object {
    public IEnumerable`1<Type> SupportedTypes { get; }
    public abstract virtual IEnumerable`1<Type> get_SupportedTypes();
    public virtual object Deserialize(object primitiveValue, Type type);
    public abstract virtual object Deserialize(object primitiveValue, Type type, JavaScriptSerializer serializer);
    public virtual object Serialize(object obj);
    public abstract virtual object Serialize(object obj, JavaScriptSerializer serializer);
}
public class Nancy.Json.JavaScriptSerializer : object {
    private JsonConfiguration jsonConfiguration;
    private GlobalizationConfiguration globalizationConfiguration;
    private NancySerializationStrategy serializerStrategy;
    public JavaScriptSerializer(JsonConfiguration jsonConfiguration, GlobalizationConfiguration globalizationConfiguration);
    public JavaScriptSerializer(JsonConfiguration jsonConfiguration, bool registerConverters, GlobalizationConfiguration globalizationConfiguration);
    public T Deserialize(string input);
    public object DeserializeObject(string input);
    public void RegisterConverters(IEnumerable`1<JavaScriptConverter> converters);
    public void RegisterConverters(IEnumerable`1<JavaScriptPrimitiveConverter> primitiveConverters);
    public void RegisterConverters(IEnumerable`1<JavaScriptConverter> converters, IEnumerable`1<JavaScriptPrimitiveConverter> primitiveConverters);
    public string Serialize(object obj);
    public void Serialize(object obj, TextWriter output);
}
public static class Nancy.Json.Json : object {
    private static StringComparison ComparisonType;
    public static bool IsJsonContentType(string contentType);
}
public class Nancy.Json.JsonConfiguration : object {
    public static JsonConfiguration Default;
    [CompilerGeneratedAttribute]
private Encoding <DefaultEncoding>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<JavaScriptConverter> <Converters>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<JavaScriptPrimitiveConverter> <PrimitiveConverters>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RetainCasing>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SerializeEnumToString>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ExcludeNullValues>k__BackingField;
    public Encoding DefaultEncoding { get; private set; }
    public IList`1<JavaScriptConverter> Converters { get; private set; }
    public IList`1<JavaScriptPrimitiveConverter> PrimitiveConverters { get; private set; }
    public bool RetainCasing { get; private set; }
    public bool SerializeEnumToString { get; private set; }
    public bool ExcludeNullValues { get; public set; }
    public JsonConfiguration(Encoding defaultEncoding, IList`1<JavaScriptConverter> converters, IList`1<JavaScriptPrimitiveConverter> primitiveConverters, Nullable`1<bool> retainCasing, Nullable`1<bool> serializeEnumToString, Nullable`1<bool> excludeNullValues);
    private static JsonConfiguration();
    [CompilerGeneratedAttribute]
public Encoding get_DefaultEncoding();
    [CompilerGeneratedAttribute]
private void set_DefaultEncoding(Encoding value);
    [CompilerGeneratedAttribute]
public IList`1<JavaScriptConverter> get_Converters();
    [CompilerGeneratedAttribute]
private void set_Converters(IList`1<JavaScriptConverter> value);
    [CompilerGeneratedAttribute]
public IList`1<JavaScriptPrimitiveConverter> get_PrimitiveConverters();
    [CompilerGeneratedAttribute]
private void set_PrimitiveConverters(IList`1<JavaScriptPrimitiveConverter> value);
    [CompilerGeneratedAttribute]
public bool get_RetainCasing();
    [CompilerGeneratedAttribute]
private void set_RetainCasing(bool value);
    [CompilerGeneratedAttribute]
public bool get_SerializeEnumToString();
    [CompilerGeneratedAttribute]
private void set_SerializeEnumToString(bool value);
    [CompilerGeneratedAttribute]
public bool get_ExcludeNullValues();
    [CompilerGeneratedAttribute]
public void set_ExcludeNullValues(bool value);
}
[ExtensionAttribute]
public static class Nancy.Json.JsonConfigurationExtensions : object {
    [ExtensionAttribute]
public static void Json(INancyEnvironment environment, Encoding defaultEncoding, IList`1<JavaScriptConverter> converters, IList`1<JavaScriptPrimitiveConverter> primitiveConverters, Nullable`1<bool> retainCasing, Nullable`1<bool> serializeEnumToString, Nullable`1<bool> excludeNullValues);
}
[AttributeUsageAttribute("384")]
public class Nancy.Json.ScriptIgnoreAttribute : Attribute {
}
[GeneratedCodeAttribute("simple-json", "1.0.0")]
public interface Nancy.Json.Simple.IJsonSerializerStrategy {
    public abstract virtual bool TrySerializeNonPrimitiveObject(object input, Object& output);
    public abstract virtual object DeserializeObject(object value, Type type, DateTimeStyles dateTimeStyles);
    public abstract virtual string MapDictionaryKeyToFieldName(string stringKey);
}
[GeneratedCodeAttribute("simple-json", "1.0.0")]
[EditorBrowsableAttribute("1")]
public class Nancy.Json.Simple.JsonArray : List`1<object> {
    public JsonArray(int capacity);
    public virtual string ToString();
}
[DefaultMemberAttribute("Item")]
[GeneratedCodeAttribute("simple-json", "1.0.0")]
[EditorBrowsableAttribute("1")]
public class Nancy.Json.Simple.JsonObject : DynamicObject {
    private Dictionary`2<string, object> _members;
    public object Item { get; }
    public ICollection`1<string> Keys { get; }
    public ICollection`1<object> Values { get; }
    public object Item { get; public set; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public JsonObject(IEqualityComparer`1<string> comparer);
    public object get_Item(int index);
    internal static object GetAtIndex(IDictionary`2<string, object> obj, int index);
    public sealed virtual void Add(string key, object value);
    public sealed virtual bool ContainsKey(string key);
    public sealed virtual ICollection`1<string> get_Keys();
    public sealed virtual bool Remove(string key);
    public sealed virtual bool TryGetValue(string key, Object& value);
    public sealed virtual ICollection`1<object> get_Values();
    public sealed virtual object get_Item(string key);
    public sealed virtual void set_Item(string key, object value);
    public sealed virtual void Add(KeyValuePair`2<string, object> item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(KeyValuePair`2<string, object> item);
    public sealed virtual void CopyTo(KeyValuePair`2[] array, int arrayIndex);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool Remove(KeyValuePair`2<string, object> item);
    public sealed virtual IEnumerator`1<KeyValuePair`2<string, object>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public virtual string ToString();
    public virtual bool TryConvert(ConvertBinder binder, Object& result);
    public virtual bool TryDeleteMember(DeleteMemberBinder binder);
    public virtual bool TryGetIndex(GetIndexBinder binder, Object[] indexes, Object& result);
    public virtual bool TryGetMember(GetMemberBinder binder, Object& result);
    public virtual bool TrySetIndex(SetIndexBinder binder, Object[] indexes, object value);
    public virtual bool TrySetMember(SetMemberBinder binder, object value);
    [IteratorStateMachineAttribute("Nancy.Json.Simple.JsonObject/<GetDynamicMemberNames>d__35")]
public virtual IEnumerable`1<string> GetDynamicMemberNames();
}
public class Nancy.Json.Simple.NamedConstructorArgs : object {
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <ParameterNames>k__BackingField;
    public Type Type { get; private set; }
    public String[] ParameterNames { get; private set; }
    public NamedConstructorArgs(Type type, String[] parameterNames);
    [CompilerGeneratedAttribute]
public Type get_Type();
    [CompilerGeneratedAttribute]
private void set_Type(Type value);
    [CompilerGeneratedAttribute]
public String[] get_ParameterNames();
    [CompilerGeneratedAttribute]
private void set_ParameterNames(String[] value);
}
public class Nancy.Json.Simple.NancySerializationStrategy : PocoJsonSerializerStrategy {
    private bool retainCasing;
    private bool serializeEnumToString;
    private List`1<JavaScriptConverter> converters;
    private List`1<JavaScriptPrimitiveConverter> primitiveConverters;
    private ConcurrentDictionary`2<Type, JavaScriptConverter> converterCache;
    private ConcurrentDictionary`2<Type, JavaScriptPrimitiveConverter> primitiveConverterCache;
    public NancySerializationStrategy(bool retainCasing, bool serializeEnumToString);
    public void RegisterConverters(IEnumerable`1<JavaScriptConverter> javaScriptConverters);
    public void RegisterConverters(IEnumerable`1<JavaScriptPrimitiveConverter> javaScriptPrimitiveConverters);
    protected virtual string MapClrMemberNameToJsonFieldName(string clrPropertyName);
    public virtual object DeserializeObject(object value, Type type, DateTimeStyles dateTimeStyles);
    protected virtual object SerializeEnum(Enum p);
    protected virtual bool TrySerializeKnownTypes(object input, Object& output);
    private bool SerializeDateTime(DateTime input, Object& output);
    private bool TrySerializePrimitiveConverter(object input, Object& output, Type inputType);
    private JavaScriptPrimitiveConverter FindPrimitiveConverter(Type inputType);
    private bool TrySerializeJavaScriptConverter(object input, Object& output, Type inputType);
    private JavaScriptConverter FindJavaScriptConverter(Type inputType);
    [CompilerGeneratedAttribute]
private JavaScriptPrimitiveConverter <FindPrimitiveConverter>b__16_0(Type typeToConvert);
    [CompilerGeneratedAttribute]
private string <TrySerializeJavaScriptConverter>b__17_0(KeyValuePair`2<string, object> kvp);
    [CompilerGeneratedAttribute]
private JavaScriptConverter <FindJavaScriptConverter>b__18_0(Type typeToConvert);
}
[GeneratedCodeAttribute("simple-json", "1.0.0")]
public class Nancy.Json.Simple.PocoJsonSerializerStrategy : object {
    internal static IDictionary`2<Type, ConstructorDelegate> DefaultConstructorCache;
    internal static IDictionary`2<NamedConstructorArgs, ConstructorDelegate> TypedConstructorCache;
    internal static IDictionary`2<Type, IDictionary`2<string, GetDelegate>> GetCache;
    internal static IDictionary`2<Type, IDictionary`2<string, KeyValuePair`2<Type, SetDelegate>>> SetCache;
    internal static IDictionary`2<NamedConstructorArgs, IDictionary`2<string, Type>> ParameterTypeCache;
    internal static Type[] EmptyTypes;
    internal static Type[] ArrayConstructorParameterTypes;
    protected static string FullDateTimeWithOffset;
    protected static string FullDateTimeUtc;
    private static String[] Iso8601Format;
    private static PocoJsonSerializerStrategy();
    public sealed virtual string MapDictionaryKeyToFieldName(string stringKey);
    protected virtual string MapClrMemberNameToJsonFieldName(string clrPropertyName);
    internal static ConstructorDelegate ContructorDelegateFactory(Type key);
    internal static ConstructorDelegate ContructorDelegateFactory(NamedConstructorArgs constructorArgs);
    internal static IDictionary`2<string, GetDelegate> GetterValueFactory(Type type);
    internal static IDictionary`2<string, KeyValuePair`2<Type, SetDelegate>> SetterValueFactory(Type type);
    internal static IDictionary`2<string, Type> ParameterTypeFactory(NamedConstructorArgs constructor);
    public virtual bool TrySerializeNonPrimitiveObject(object input, Object& output);
    public virtual object DeserializeObject(object value, Type type, DateTimeStyles dateTimeStyles);
    protected virtual object SerializeEnum(Enum p);
    protected virtual bool TrySerializeKnownTypes(object input, Object& output);
    protected virtual bool TrySerializeUnknownTypes(object input, Object& output);
}
[GeneratedCodeAttribute("reflection-utils", "1.0.0")]
internal class Nancy.Json.Simple.ReflectionUtils : object {
    private static Object[] EmptyObjects;
    private static ReflectionUtils();
    public static TypeInfo GetTypeInfo(Type type);
    public static Attribute GetAttribute(MemberInfo info, Type type);
    public static Type GetGenericListElementType(Type type);
    public static Attribute GetAttribute(Type objectType, Type attributeType);
    public static Type[] GetGenericTypeArguments(Type type);
    public static bool IsTypeGeneric(Type type);
    public static bool IsTypeGenericeCollectionInterface(Type type);
    public static bool IsAssignableFrom(Type type1, Type type2);
    public static bool IsTypeDictionary(Type type);
    public static bool IsNullableType(Type type);
    public static object ToNullableType(object obj, Type nullableType);
    public static bool IsValueType(Type type);
    public static IEnumerable`1<ConstructorInfo> GetConstructors(Type type);
    public static ConstructorInfo GetConstructorInfo(Type type, Type[] argsType);
    public static ConstructorInfo GetNamedConstructorInfo(Type type, String[] parameterNames);
    public static IEnumerable`1<PropertyInfo> GetProperties(Type type);
    public static IEnumerable`1<FieldInfo> GetFields(Type type);
    public static MethodInfo GetGetterMethodInfo(PropertyInfo propertyInfo);
    public static MethodInfo GetSetterMethodInfo(PropertyInfo propertyInfo);
    public static ConstructorDelegate GetConstructor(ConstructorInfo constructorInfo);
    public static ConstructorDelegate GetConstructor(Type type, Type[] argsType);
    public static ConstructorDelegate GetNamedConstructor(Type type, String[] parameterNames);
    public static ConstructorDelegate GetConstructorByReflection(ConstructorInfo constructorInfo);
    public static ConstructorDelegate GetConstructorByReflection(Type type, Type[] argsType);
    public static ConstructorDelegate GetNamedConstructorByReflection(Type type, String[] parameterNames);
    public static ConstructorDelegate GetConstructorByExpression(ConstructorInfo constructorInfo);
    public static ConstructorDelegate GetConstructorByExpression(Type type, Type[] argsType);
    public static ConstructorDelegate GetNamedConstructorByExpression(Type type, String[] parameterNames);
    public static GetDelegate GetGetMethod(PropertyInfo propertyInfo);
    public static GetDelegate GetGetMethod(FieldInfo fieldInfo);
    public static GetDelegate GetGetMethodByReflection(PropertyInfo propertyInfo);
    public static GetDelegate GetGetMethodByReflection(FieldInfo fieldInfo);
    public static GetDelegate GetGetMethodByExpression(PropertyInfo propertyInfo);
    public static GetDelegate GetGetMethodByExpression(FieldInfo fieldInfo);
    public static SetDelegate GetSetMethod(PropertyInfo propertyInfo);
    public static SetDelegate GetSetMethod(FieldInfo fieldInfo);
    public static SetDelegate GetSetMethodByReflection(PropertyInfo propertyInfo);
    public static SetDelegate GetSetMethodByReflection(FieldInfo fieldInfo);
    public static SetDelegate GetSetMethodByExpression(PropertyInfo propertyInfo);
    public static SetDelegate GetSetMethodByExpression(FieldInfo fieldInfo);
    public static BinaryExpression Assign(Expression left, Expression right);
}
[GeneratedCodeAttribute("simple-json", "1.0.0")]
public static class Nancy.Json.Simple.SimpleJson : object {
    private static int TOKEN_NONE;
    private static int TOKEN_CURLY_OPEN;
    private static int TOKEN_CURLY_CLOSE;
    private static int TOKEN_SQUARED_OPEN;
    private static int TOKEN_SQUARED_CLOSE;
    private static int TOKEN_COLON;
    private static int TOKEN_COMMA;
    private static int TOKEN_STRING;
    private static int TOKEN_NUMBER;
    private static int TOKEN_TRUE;
    private static int TOKEN_FALSE;
    private static int TOKEN_NULL;
    private static int BUILDER_CAPACITY;
    private static Char[] EscapeTable;
    private static Char[] EscapeCharacters;
    private static string EscapeCharactersString;
    private static IJsonSerializerStrategy _currentJsonSerializerStrategy;
    private static PocoJsonSerializerStrategy _pocoJsonSerializerStrategy;
    public static IJsonSerializerStrategy CurrentJsonSerializerStrategy { get; public set; }
    [EditorBrowsableAttribute("2")]
public static PocoJsonSerializerStrategy PocoJsonSerializerStrategy { get; }
    private static SimpleJson();
    public static object DeserializeObject(string json);
    public static bool TryDeserializeObject(string json, Object& obj);
    public static object DeserializeObject(string json, Type type, IJsonSerializerStrategy jsonSerializerStrategy, DateTimeStyles dateTimeStyles);
    public static object DeserializeObject(string json, Type type, DateTimeStyles dateTimeStyles);
    public static T DeserializeObject(string json, IJsonSerializerStrategy jsonSerializerStrategy, DateTimeStyles dateTimeStyles);
    public static T DeserializeObject(string json);
    public static string SerializeObject(object json, IJsonSerializerStrategy jsonSerializerStrategy, bool excludeNullValues);
    public static string SerializeObject(object json);
    public static string EscapeToJavascriptString(string jsonString);
    private static IDictionary`2<string, object> ParseObject(Char[] json, Int32& index, Boolean& success);
    private static JsonArray ParseArray(Char[] json, Int32& index, Boolean& success);
    private static object ParseValue(Char[] json, Int32& index, Boolean& success);
    private static string ParseString(Char[] json, Int32& index, Boolean& success);
    private static string ConvertFromUtf32(int utf32);
    private static object ParseNumber(Char[] json, Int32& index, Boolean& success);
    private static int GetLastIndexOfNumber(Char[] json, int index);
    private static void EatWhitespace(Char[] json, Int32& index);
    private static int LookAhead(Char[] json, int index);
    private static int NextToken(Char[] json, Int32& index);
    private static bool SerializeValue(IJsonSerializerStrategy jsonSerializerStrategy, object value, StringBuilder builder, bool excludeNullValues);
    private static bool SerializeObject(IJsonSerializerStrategy jsonSerializerStrategy, IEnumerable keys, IEnumerable values, StringBuilder builder, bool excludeNullValues);
    private static bool SerializeArray(IJsonSerializerStrategy jsonSerializerStrategy, IEnumerable anArray, StringBuilder builder, bool excludeNullValues);
    private static bool SerializeString(string aString, StringBuilder builder);
    private static bool SerializeNumber(object number, StringBuilder builder);
    private static bool IsNumeric(object value);
    public static IJsonSerializerStrategy get_CurrentJsonSerializerStrategy();
    public static void set_CurrentJsonSerializerStrategy(IJsonSerializerStrategy value);
    public static PocoJsonSerializerStrategy get_PocoJsonSerializerStrategy();
}
internal class Nancy.Json.Simple.ValidConstructorNotFoundException : Exception {
    public ValidConstructorNotFoundException(Type type);
}
[GeneratedCodeAttribute("simple-json", "1.0.0")]
[EditorBrowsableAttribute("1")]
internal class Nancy.JsonArray : List`1<object> {
    public JsonArray(int capacity);
    public virtual string ToString();
}
[DefaultMemberAttribute("Item")]
[GeneratedCodeAttribute("simple-json", "1.0.0")]
[EditorBrowsableAttribute("1")]
internal class Nancy.JsonObject : DynamicObject {
    private Dictionary`2<string, object> _members;
    public object Item { get; }
    public ICollection`1<string> Keys { get; }
    public ICollection`1<object> Values { get; }
    public object Item { get; public set; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public JsonObject(IEqualityComparer`1<string> comparer);
    public object get_Item(int index);
    internal static object GetAtIndex(IDictionary`2<string, object> obj, int index);
    public sealed virtual void Add(string key, object value);
    public sealed virtual bool ContainsKey(string key);
    public sealed virtual ICollection`1<string> get_Keys();
    public sealed virtual bool Remove(string key);
    public sealed virtual bool TryGetValue(string key, Object& value);
    public sealed virtual ICollection`1<object> get_Values();
    public sealed virtual object get_Item(string key);
    public sealed virtual void set_Item(string key, object value);
    public sealed virtual void Add(KeyValuePair`2<string, object> item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(KeyValuePair`2<string, object> item);
    public sealed virtual void CopyTo(KeyValuePair`2[] array, int arrayIndex);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool Remove(KeyValuePair`2<string, object> item);
    public sealed virtual IEnumerator`1<KeyValuePair`2<string, object>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public virtual string ToString();
    public virtual bool TryConvert(ConvertBinder binder, Object& result);
    public virtual bool TryDeleteMember(DeleteMemberBinder binder);
    public virtual bool TryGetIndex(GetIndexBinder binder, Object[] indexes, Object& result);
    public virtual bool TryGetMember(GetMemberBinder binder, Object& result);
    public virtual bool TrySetIndex(SetIndexBinder binder, Object[] indexes, object value);
    public virtual bool TrySetMember(SetMemberBinder binder, object value);
    [IteratorStateMachineAttribute("Nancy.JsonObject/<GetDynamicMemberNames>d__35")]
public virtual IEnumerable`1<string> GetDynamicMemberNames();
}
public static class Nancy.Jsonp : object {
    private static PipelineItem`1<Action`1<NancyContext>> JsonpItem;
    private static Encoding encoding;
    private static string Encoding { get; }
    private static Jsonp();
    private static string get_Encoding();
    public static void Enable(IPipelines pipelines, INancyEnvironment environment);
    public static void Disable(IPipelines pipelines);
    private static void PrepareJsonp(NancyContext context);
}
public class Nancy.JsonpApplicationStartup : object {
    private INancyEnvironment environment;
    public JsonpApplicationStartup(INancyEnvironment environment);
    public sealed virtual void Initialize(IPipelines pipelines);
}
[DefaultMemberAttribute("Item")]
public interface Nancy.Localization.ITextResource {
    public string Item { get; }
    public abstract virtual string get_Item(string key, NancyContext context);
}
[DefaultMemberAttribute("Item")]
public class Nancy.Localization.ResourceBasedTextResource : object {
    private IResourceAssemblyProvider resourceAssemblyProvider;
    private IDictionary`2<string, ResourceManager> resourceManagers;
    public string Item { get; }
    public ResourceBasedTextResource(IResourceAssemblyProvider resourceAssemblyProvider);
    public sealed virtual string get_Item(string key, NancyContext context);
    private static Tuple`2<string, string> GetKeyComponents(string key);
}
[DefaultMemberAttribute("Item")]
public class Nancy.Localization.TextResourceFinder : DynamicObject {
    private ITextResource textResource;
    private NancyContext context;
    public ITextResource Resource { get; }
    public string Item { get; }
    public TextResourceFinder(ITextResource textResource, NancyContext context);
    public ITextResource get_Resource();
    public virtual bool TryGetMember(GetMemberBinder binder, Object& result);
    public string get_Item(string key);
}
public class Nancy.MimeTypes : object {
    private static Dictionary`2<string, string> mimeTypes;
    private static MimeTypes();
    public static void AddType(string extension, string type);
    public static string GetMimeType(string fileName);
}
public class Nancy.ModelBinding.BindingConfig : object {
    public static BindingConfig NoOverwrite;
    public static BindingConfig Default;
    [CompilerGeneratedAttribute]
private bool <BodyOnly>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IgnoreErrors>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Overwrite>k__BackingField;
    public bool BodyOnly { get; public set; }
    public bool IgnoreErrors { get; public set; }
    public bool Overwrite { get; public set; }
    private static BindingConfig();
    [CompilerGeneratedAttribute]
public bool get_BodyOnly();
    [CompilerGeneratedAttribute]
public void set_BodyOnly(bool value);
    [CompilerGeneratedAttribute]
public bool get_IgnoreErrors();
    [CompilerGeneratedAttribute]
public void set_IgnoreErrors(bool value);
    [CompilerGeneratedAttribute]
public bool get_Overwrite();
    [CompilerGeneratedAttribute]
public void set_Overwrite(bool value);
}
public class Nancy.ModelBinding.BindingContext : object {
    [CompilerGeneratedAttribute]
private BindingConfig <Configuration>k__BackingField;
    [CompilerGeneratedAttribute]
private NancyContext <Context>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <DestinationType>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <GenericType>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Model>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<BindingMemberInfo> <ValidModelBindingMembers>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <RequestData>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<ITypeConverter> <TypeConverters>k__BackingField;
    public BindingConfig Configuration { get; public set; }
    public NancyContext Context { get; public set; }
    public Type DestinationType { get; public set; }
    public Type GenericType { get; public set; }
    public object Model { get; public set; }
    public IEnumerable`1<BindingMemberInfo> ValidModelBindingMembers { get; public set; }
    public IDictionary`2<string, string> RequestData { get; public set; }
    public IEnumerable`1<ITypeConverter> TypeConverters { get; public set; }
    [CompilerGeneratedAttribute]
public BindingConfig get_Configuration();
    [CompilerGeneratedAttribute]
public void set_Configuration(BindingConfig value);
    [CompilerGeneratedAttribute]
public NancyContext get_Context();
    [CompilerGeneratedAttribute]
public void set_Context(NancyContext value);
    [CompilerGeneratedAttribute]
public Type get_DestinationType();
    [CompilerGeneratedAttribute]
public void set_DestinationType(Type value);
    [CompilerGeneratedAttribute]
public Type get_GenericType();
    [CompilerGeneratedAttribute]
public void set_GenericType(Type value);
    [CompilerGeneratedAttribute]
public object get_Model();
    [CompilerGeneratedAttribute]
public void set_Model(object value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<BindingMemberInfo> get_ValidModelBindingMembers();
    [CompilerGeneratedAttribute]
public void set_ValidModelBindingMembers(IEnumerable`1<BindingMemberInfo> value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_RequestData();
    [CompilerGeneratedAttribute]
public void set_RequestData(IDictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<ITypeConverter> get_TypeConverters();
    [CompilerGeneratedAttribute]
public void set_TypeConverters(IEnumerable`1<ITypeConverter> value);
}
public class Nancy.ModelBinding.BindingDefaults : object {
    private IEnumerable`1<ITypeConverter> defaultTypeConverters;
    private IEnumerable`1<IBodyDeserializer> defaultBodyDeserializers;
    public IEnumerable`1<ITypeConverter> DefaultTypeConverters { get; }
    public IEnumerable`1<IBodyDeserializer> DefaultBodyDeserializers { get; }
    public BindingDefaults(INancyEnvironment environment);
    public virtual IEnumerable`1<ITypeConverter> get_DefaultTypeConverters();
    public virtual IEnumerable`1<IBodyDeserializer> get_DefaultBodyDeserializers();
}
public class Nancy.ModelBinding.BindingMemberInfo : object {
    private PropertyInfo propertyInfo;
    private FieldInfo fieldInfo;
    public MemberInfo MemberInfo { get; }
    public string Name { get; }
    public Type PropertyType { get; }
    public BindingMemberInfo(PropertyInfo propertyInfo);
    public BindingMemberInfo(FieldInfo fieldInfo);
    public MemberInfo get_MemberInfo();
    public string get_Name();
    public Type get_PropertyType();
    public object GetValue(object sourceObject);
    public void SetValue(object destinationObject, object newValue);
    public virtual bool Equals(object obj);
    public bool Equals(BindingMemberInfo obj);
    public virtual int GetHashCode();
    public static IEnumerable`1<BindingMemberInfo> Collect();
    public static IEnumerable`1<BindingMemberInfo> Collect(Type type);
}
public class Nancy.ModelBinding.DefaultBinder : object {
    private IEnumerable`1<ITypeConverter> typeConverters;
    private IEnumerable`1<IBodyDeserializer> bodyDeserializers;
    private IFieldNameConverter fieldNameConverter;
    private BindingDefaults defaults;
    private static MethodInfo ToListMethodInfo;
    private static MethodInfo ToArrayMethodInfo;
    private static Regex BracketRegex;
    private static Regex UnderscoreRegex;
    public DefaultBinder(IEnumerable`1<ITypeConverter> typeConverters, IEnumerable`1<IBodyDeserializer> bodyDeserializers, IFieldNameConverter fieldNameConverter, BindingDefaults defaults);
    private static DefaultBinder();
    public sealed virtual object Bind(NancyContext context, Type modelType, object instance, BindingConfig configuration, String[] blackList);
    private bool BindingValueIsValid(string bindingValue, object existingValue, BindingMemberInfo modelProperty, BindingContext bindingContext);
    private int GetBindingListInstanceCount(NancyContext context);
    private static int IsMatch(string item);
    private static void UpdateModelWithDeserializedModel(object bodyDeserializedModel, BindingContext bindingContext);
    private static void HandleValueTypeCollectionElement(IList model, int count, object o);
    private static void HandleReferenceTypeCollectionElement(BindingContext bindingContext, IList model, int count, object o);
    private static void CopyValue(BindingMemberInfo modelProperty, object source, object destination);
    private static bool IsDefaultValue(object existingValue, Type propertyType);
    private BindingContext CreateBindingContext(NancyContext context, Type modelType, object instance, BindingConfig configuration, IEnumerable`1<string> blackList, Type genericType);
    private IDictionary`2<string, string> GetDataFields(NancyContext context);
    private IDictionary`2<string, string> ConvertDynamicDictionary(DynamicDictionary dictionary);
    private static void BindValue(BindingMemberInfo modelProperty, string stringValue, BindingContext context);
    private static void BindValue(BindingMemberInfo modelProperty, string stringValue, BindingContext context, object targetInstance);
    private static void SetBindingMemberValue(BindingMemberInfo modelProperty, object model, object value);
    private static IEnumerable`1<BindingMemberInfo> GetBindingMembers(Type modelType, Type genericType, IEnumerable`1<string> blackList);
    private static object CreateModel(Type modelType, Type genericType, object instance);
    private static string GetValue(string propertyName, BindingContext context, int index);
    private object DeserializeRequestBody(BindingContext context);
    private static MediaRange GetRequestContentType(NancyContext context);
}
public class Nancy.ModelBinding.DefaultBodyDeserializers.JsonBodyDeserializer : object {
    private MethodInfo deserializeMethod;
    private JsonConfiguration jsonConfiguration;
    private GlobalizationConfiguration globalizationConfiguration;
    public JsonBodyDeserializer(INancyEnvironment environment);
    public sealed virtual bool CanDeserialize(MediaRange mediaRange, BindingContext context);
    public sealed virtual object Deserialize(MediaRange mediaRange, Stream bodyStream, BindingContext context);
}
public class Nancy.ModelBinding.DefaultBodyDeserializers.XmlBodyDeserializer : object {
    public sealed virtual bool CanDeserialize(MediaRange mediaRange, BindingContext context);
    public sealed virtual object Deserialize(MediaRange mediaRange, Stream bodyStream, BindingContext context);
}
public class Nancy.ModelBinding.DefaultConverters.CollectionConverter : object {
    private MethodInfo enumerableCastMethod;
    private MethodInfo enumerableToArrayMethod;
    private MethodInfo enumerableToListMethod;
    public sealed virtual bool CanConvertTo(Type destinationType, BindingContext context);
    public sealed virtual object Convert(string input, Type destinationType, BindingContext context);
    private object ConvertCollection(String[] items, Type destinationType, BindingContext context);
    private object ConvertArray(String[] items, Type destinationType, BindingContext context);
    private object ConvertEnumerable(String[] items, Type destinationType, BindingContext context);
}
public class Nancy.ModelBinding.DefaultConverters.DateTimeConverter : object {
    public sealed virtual bool CanConvertTo(Type destinationType, BindingContext context);
    public sealed virtual object Convert(string input, Type destinationType, BindingContext context);
}
public class Nancy.ModelBinding.DefaultConverters.FallbackConverter : object {
    public sealed virtual bool CanConvertTo(Type destinationType, BindingContext context);
    public sealed virtual object Convert(string input, Type destinationType, BindingContext context);
}
public class Nancy.ModelBinding.DefaultConverters.NumericConverter : object {
    public sealed virtual bool CanConvertTo(Type destinationType, BindingContext context);
    public sealed virtual object Convert(string input, Type destinationType, BindingContext context);
}
public class Nancy.ModelBinding.DefaultFieldNameConverter : object {
    private ConcurrentDictionary`2<string, string> cache;
    public sealed virtual string Convert(string fieldName);
}
public class Nancy.ModelBinding.DefaultModelBinderLocator : object {
    private IReadOnlyCollection`1<IModelBinder> binders;
    private IBinder fallbackBinder;
    public DefaultModelBinderLocator(IEnumerable`1<IModelBinder> binders, IBinder fallbackBinder);
    public sealed virtual IBinder GetBinderForType(Type modelType, NancyContext context);
}
public class Nancy.ModelBinding.DynamicModelBinderAdapter : DynamicObject {
    private IModelBinderLocator locator;
    private NancyContext context;
    private object instance;
    private BindingConfig configuration;
    private String[] blacklistedProperties;
    public DynamicModelBinderAdapter(IModelBinderLocator locator, NancyContext context, object instance, BindingConfig configuration, String[] blacklistedProperties);
    public virtual bool TryConvert(ConvertBinder binder, Object& result);
}
[ExtensionAttribute]
public static class Nancy.ModelBinding.ExpressionExtensions : object {
    [ExtensionAttribute]
public static MemberInfo GetTargetMemberInfo(Expression expression);
}
public interface Nancy.ModelBinding.IBinder {
    public abstract virtual object Bind(NancyContext context, Type modelType, object instance, BindingConfig configuration, String[] blackList);
}
public interface Nancy.ModelBinding.IBodyDeserializer {
    public abstract virtual bool CanDeserialize(MediaRange mediaRange, BindingContext context);
    public abstract virtual object Deserialize(MediaRange mediaRange, Stream bodyStream, BindingContext context);
}
public interface Nancy.ModelBinding.IFieldNameConverter {
    public abstract virtual string Convert(string fieldName);
}
public interface Nancy.ModelBinding.IModelBinder {
    public abstract virtual bool CanBind(Type modelType);
}
public interface Nancy.ModelBinding.IModelBinderLocator {
    public abstract virtual IBinder GetBinderForType(Type modelType, NancyContext context);
}
public interface Nancy.ModelBinding.ITypeConverter {
    public abstract virtual bool CanConvertTo(Type destinationType, BindingContext context);
    public abstract virtual object Convert(string input, Type destinationType, BindingContext context);
}
public class Nancy.ModelBinding.ModelBindingException : Exception {
    private static string ExceptionMessage;
    [CompilerGeneratedAttribute]
private IEnumerable`1<PropertyBindingException> <PropertyBindingExceptions>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <BoundType>k__BackingField;
    public IEnumerable`1<PropertyBindingException> PropertyBindingExceptions { get; private set; }
    public Type BoundType { get; private set; }
    public ModelBindingException(Type boundType, IEnumerable`1<PropertyBindingException> propertyBindingExceptions, Exception innerException);
    protected ModelBindingException(SerializationInfo info, StreamingContext context);
    [CompilerGeneratedAttribute]
public virtual IEnumerable`1<PropertyBindingException> get_PropertyBindingExceptions();
    [CompilerGeneratedAttribute]
private void set_PropertyBindingExceptions(IEnumerable`1<PropertyBindingException> value);
    [CompilerGeneratedAttribute]
public virtual Type get_BoundType();
    [CompilerGeneratedAttribute]
private void set_BoundType(Type value);
}
[ExtensionAttribute]
public static class Nancy.ModelBinding.ModuleExtensions : object {
    private static String[] NoBlacklistedProperties;
    private static ModuleExtensions();
    [ExtensionAttribute]
private static String[] ParseBlacklistedPropertiesExpressionTree(IEnumerable`1<Expression`1<Func`2<T, object>>> expressions);
    [ExtensionAttribute]
public static object Bind(INancyModule module, String[] blacklistedProperties);
    [ExtensionAttribute]
public static object Bind(INancyModule module, BindingConfig configuration, String[] blacklistedProperties);
    [ExtensionAttribute]
public static TModel Bind(INancyModule module);
    [ExtensionAttribute]
public static TModel Bind(INancyModule module, String[] blacklistedProperties);
    [ExtensionAttribute]
public static TModel Bind(INancyModule module, Expression`1[] blacklistedProperties);
    [ExtensionAttribute]
public static TModel BindAndValidate(INancyModule module, String[] blacklistedProperties);
    [ExtensionAttribute]
public static TModel BindAndValidate(INancyModule module, Expression`1[] blacklistedProperties);
    [ExtensionAttribute]
public static TModel BindAndValidate(INancyModule module);
    [ExtensionAttribute]
public static TModel Bind(INancyModule module, BindingConfig configuration);
    [ExtensionAttribute]
public static TModel Bind(INancyModule module, BindingConfig configuration, String[] blacklistedProperties);
    [ExtensionAttribute]
public static TModel Bind(INancyModule module, BindingConfig configuration, Expression`1<Func`2<TModel, object>> blacklistedProperty);
    [ExtensionAttribute]
public static TModel Bind(INancyModule module, BindingConfig configuration, Expression`1[] blacklistedProperties);
    [ExtensionAttribute]
public static TModel BindAndValidate(INancyModule module, BindingConfig configuration, String[] blacklistedProperties);
    [ExtensionAttribute]
public static TModel BindAndValidate(INancyModule module, BindingConfig configuration, Expression`1[] blacklistedProperties);
    [ExtensionAttribute]
public static TModel BindAndValidate(INancyModule module, BindingConfig configuration);
    [ExtensionAttribute]
public static TModel BindTo(INancyModule module, TModel instance, String[] blacklistedProperties);
    [ExtensionAttribute]
public static TModel BindTo(INancyModule module, TModel instance, Expression`1[] blacklistedProperties);
    [ExtensionAttribute]
public static TModel BindTo(INancyModule module, TModel instance);
    [ExtensionAttribute]
public static TModel BindToAndValidate(INancyModule module, TModel instance, String[] blacklistedProperties);
    [ExtensionAttribute]
public static TModel BindToAndValidate(INancyModule module, TModel instance, Expression`1[] blacklistedProperties);
    [ExtensionAttribute]
public static TModel BindToAndValidate(INancyModule module, TModel instance);
    [ExtensionAttribute]
public static TModel BindTo(INancyModule module, TModel instance, BindingConfig configuration, String[] blacklistedProperties);
    [ExtensionAttribute]
public static TModel BindTo(INancyModule module, TModel instance, BindingConfig configuration, Expression`1[] blacklistedProperties);
    [ExtensionAttribute]
public static TModel BindTo(INancyModule module, TModel instance, BindingConfig configuration);
    [ExtensionAttribute]
public static TModel BindToAndValidate(INancyModule module, TModel instance, BindingConfig configuration, String[] blacklistedProperties);
    [ExtensionAttribute]
public static TModel BindToAndValidate(INancyModule module, TModel instance, BindingConfig configuration, Expression`1[] blacklistedProperties);
    [ExtensionAttribute]
public static TModel BindToAndValidate(INancyModule module, TModel instance, BindingConfig configuration);
}
public class Nancy.ModelBinding.PropertyBindingException : Exception {
    private static string ExceptionMessage;
    [CompilerGeneratedAttribute]
private string <PropertyName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AttemptedValue>k__BackingField;
    public string PropertyName { get; private set; }
    public string AttemptedValue { get; private set; }
    public PropertyBindingException(string propertyName, string attemptedValue, Exception innerException);
    [CompilerGeneratedAttribute]
public string get_PropertyName();
    [CompilerGeneratedAttribute]
private void set_PropertyName(string value);
    [CompilerGeneratedAttribute]
public string get_AttemptedValue();
    [CompilerGeneratedAttribute]
private void set_AttemptedValue(string value);
}
[ExtensionAttribute]
public static class Nancy.ModelValidationResultExtensions : object {
    [ExtensionAttribute]
public static IDictionary`2<string, IList`1<ModelValidationError>> Add(IDictionary`2<string, IList`1<ModelValidationError>> errors, string name, string errorMessage);
}
public abstract class Nancy.NamedPipelineBase`1 : object {
    protected List`1<PipelineItem`1<TDelegate>> pipelineItems;
    public IEnumerable`1<PipelineItem`1<TDelegate>> PipelineItems { get; }
    public IEnumerable`1<TDelegate> PipelineDelegates { get; }
    protected NamedPipelineBase`1(int capacity);
    public IEnumerable`1<PipelineItem`1<TDelegate>> get_PipelineItems();
    public IEnumerable`1<TDelegate> get_PipelineDelegates();
    public virtual void AddItemToStartOfPipeline(TDelegate item);
    public virtual void AddItemToStartOfPipeline(PipelineItem`1<TDelegate> item, bool replaceInPlace);
    public virtual void AddItemToEndOfPipeline(TDelegate item);
    public virtual void AddItemToEndOfPipeline(PipelineItem`1<TDelegate> item, bool replaceInPlace);
    public virtual void InsertItemAtPipelineIndex(int index, TDelegate item);
    public virtual void InsertItemAtPipelineIndex(int index, PipelineItem`1<TDelegate> item, bool replaceInPlace);
    public virtual void InsertBefore(string name, TDelegate item);
    public virtual void InsertBefore(string name, PipelineItem`1<TDelegate> item);
    public virtual void InsertAfter(string name, TDelegate item);
    public virtual void InsertAfter(string name, PipelineItem`1<TDelegate> item);
    public virtual int RemoveByName(string name);
}
public class Nancy.NancyContext : object {
    private Request request;
    private ModelValidationResult modelValidationResult;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, object> <Items>k__BackingField;
    [CompilerGeneratedAttribute]
private Route <ResolvedRoute>k__BackingField;
    [CompilerGeneratedAttribute]
[DynamicAttribute]
private object <Parameters>k__BackingField;
    [CompilerGeneratedAttribute]
private Response <Response>k__BackingField;
    [CompilerGeneratedAttribute]
private ClaimsPrincipal <CurrentUser>k__BackingField;
    [CompilerGeneratedAttribute]
private IRequestTrace <Trace>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ControlPanelEnabled>k__BackingField;
    [CompilerGeneratedAttribute]
[DynamicAttribute]
private object <ViewBag>k__BackingField;
    [CompilerGeneratedAttribute]
private CultureInfo <Culture>k__BackingField;
    [CompilerGeneratedAttribute]
private NegotiationContext <NegotiationContext>k__BackingField;
    [CompilerGeneratedAttribute]
[DynamicAttribute]
private object <Text>k__BackingField;
    [CompilerGeneratedAttribute]
private INancyEnvironment <Environment>k__BackingField;
    public IDictionary`2<string, object> Items { get; private set; }
    public Route ResolvedRoute { get; public set; }
    [DynamicAttribute]
public object Parameters { get; public set; }
    public Request Request { get; public set; }
    public Response Response { get; public set; }
    public ClaimsPrincipal CurrentUser { get; public set; }
    public IRequestTrace Trace { get; public set; }
    public bool ControlPanelEnabled { get; private set; }
    [DynamicAttribute]
public object ViewBag { get; private set; }
    public ModelValidationResult ModelValidationResult { get; public set; }
    public CultureInfo Culture { get; public set; }
    public NegotiationContext NegotiationContext { get; public set; }
    [DynamicAttribute]
public object Text { get; public set; }
    public INancyEnvironment Environment { get; public set; }
    [CompilerGeneratedAttribute]
public IDictionary`2<string, object> get_Items();
    [CompilerGeneratedAttribute]
private void set_Items(IDictionary`2<string, object> value);
    [CompilerGeneratedAttribute]
public Route get_ResolvedRoute();
    [CompilerGeneratedAttribute]
public void set_ResolvedRoute(Route value);
    [CompilerGeneratedAttribute]
public object get_Parameters();
    [CompilerGeneratedAttribute]
public void set_Parameters(object value);
    public Request get_Request();
    public void set_Request(Request value);
    [CompilerGeneratedAttribute]
public Response get_Response();
    [CompilerGeneratedAttribute]
public void set_Response(Response value);
    [CompilerGeneratedAttribute]
public ClaimsPrincipal get_CurrentUser();
    [CompilerGeneratedAttribute]
public void set_CurrentUser(ClaimsPrincipal value);
    [CompilerGeneratedAttribute]
public IRequestTrace get_Trace();
    [CompilerGeneratedAttribute]
public void set_Trace(IRequestTrace value);
    [CompilerGeneratedAttribute]
public bool get_ControlPanelEnabled();
    [CompilerGeneratedAttribute]
private void set_ControlPanelEnabled(bool value);
    [CompilerGeneratedAttribute]
public object get_ViewBag();
    [CompilerGeneratedAttribute]
private void set_ViewBag(object value);
    public ModelValidationResult get_ModelValidationResult();
    public void set_ModelValidationResult(ModelValidationResult value);
    [CompilerGeneratedAttribute]
public CultureInfo get_Culture();
    [CompilerGeneratedAttribute]
public void set_Culture(CultureInfo value);
    [CompilerGeneratedAttribute]
public NegotiationContext get_NegotiationContext();
    [CompilerGeneratedAttribute]
public void set_NegotiationContext(NegotiationContext value);
    [CompilerGeneratedAttribute]
public object get_Text();
    [CompilerGeneratedAttribute]
public void set_Text(object value);
    [CompilerGeneratedAttribute]
public INancyEnvironment get_Environment();
    [CompilerGeneratedAttribute]
public void set_Environment(INancyEnvironment value);
    public sealed virtual void Dispose();
}
public class Nancy.NancyEngine : object {
    public static string ERROR_KEY;
    public static string ERROR_EXCEPTION;
    private IRequestDispatcher dispatcher;
    private INancyContextFactory contextFactory;
    private IRequestTracing requestTracing;
    private IReadOnlyCollection`1<IStatusCodeHandler> statusCodeHandlers;
    private IStaticContentProvider staticContentProvider;
    private IResponseNegotiator negotiator;
    private CancellationTokenSource engineDisposedCts;
    private TraceConfiguration traceConfiguration;
    [CompilerGeneratedAttribute]
private Func`2<NancyContext, IPipelines> <RequestPipelinesFactory>k__BackingField;
    public Func`2<NancyContext, IPipelines> RequestPipelinesFactory { get; public set; }
    public NancyEngine(IRequestDispatcher dispatcher, INancyContextFactory contextFactory, IEnumerable`1<IStatusCodeHandler> statusCodeHandlers, IRequestTracing requestTracing, IStaticContentProvider staticContentProvider, IResponseNegotiator negotiator, INancyEnvironment environment);
    [CompilerGeneratedAttribute]
public sealed virtual Func`2<NancyContext, IPipelines> get_RequestPipelinesFactory();
    [CompilerGeneratedAttribute]
public sealed virtual void set_RequestPipelinesFactory(Func`2<NancyContext, IPipelines> value);
    [AsyncStateMachineAttribute("Nancy.NancyEngine/<HandleRequest>d__15")]
public sealed virtual Task`1<NancyContext> HandleRequest(Request request, Func`2<NancyContext, NancyContext> preRequest, CancellationToken cancellationToken);
    public virtual void Dispose();
    private void SaveTraceInformation(NancyContext ctx);
    private bool EnableTracing(NancyContext ctx);
    private Guid GetDiagnosticsSessionGuid(NancyContext ctx);
    private void UpdateTraceCookie(NancyContext ctx, Guid sessionGuid);
    private void CheckStatusCodeHandler(NancyContext context);
    [AsyncStateMachineAttribute("Nancy.NancyEngine/<InvokeRequestLifeCycle>d__22")]
private Task`1<NancyContext> InvokeRequestLifeCycle(NancyContext context, CancellationToken cancellationToken, IPipelines pipelines);
    private static Task`1<Response> InvokePreRequestHook(NancyContext context, CancellationToken cancellationToken, BeforePipeline pipeline);
    private Task InvokePostRequestHook(NancyContext context, CancellationToken cancellationToken, AfterPipeline pipeline);
    private void InvokeOnErrorHook(NancyContext context, ErrorPipeline pipeline, Exception ex);
}
[ExtensionAttribute]
public static class Nancy.NancyEngineExtensions : object {
    [ExtensionAttribute]
public static Task`1<NancyContext> HandleRequest(INancyEngine nancyEngine, Request request);
}
public abstract class Nancy.NancyModule : object {
    private List`1<Route> routes;
    [CompilerGeneratedAttribute]
private string <ModulePath>k__BackingField;
    [CompilerGeneratedAttribute]
private IModelValidatorLocator <ValidatorLocator>k__BackingField;
    [CompilerGeneratedAttribute]
private IViewFactory <ViewFactory>k__BackingField;
    [CompilerGeneratedAttribute]
private AfterPipeline <After>k__BackingField;
    [CompilerGeneratedAttribute]
private BeforePipeline <Before>k__BackingField;
    [CompilerGeneratedAttribute]
private ErrorPipeline <OnError>k__BackingField;
    [CompilerGeneratedAttribute]
private NancyContext <Context>k__BackingField;
    [CompilerGeneratedAttribute]
private IResponseFormatter <Response>k__BackingField;
    [CompilerGeneratedAttribute]
private IModelBinderLocator <ModelBinderLocator>k__BackingField;
    [DynamicAttribute]
public object ViewBag { get; }
    [DynamicAttribute]
public object Text { get; }
    public string ModulePath { get; protected set; }
    [EditorBrowsableAttribute("1")]
public IEnumerable`1<Route> Routes { get; }
    public ISession Session { get; }
    public ViewRenderer View { get; }
    public Negotiator Negotiate { get; }
    [EditorBrowsableAttribute("1")]
public IModelValidatorLocator ValidatorLocator { get; public set; }
    public Request Request { get; public set; }
    [EditorBrowsableAttribute("1")]
public IViewFactory ViewFactory { get; public set; }
    public AfterPipeline After { get; public set; }
    public BeforePipeline Before { get; public set; }
    public ErrorPipeline OnError { get; public set; }
    public NancyContext Context { get; public set; }
    public IResponseFormatter Response { get; public set; }
    [EditorBrowsableAttribute("1")]
public IModelBinderLocator ModelBinderLocator { get; public set; }
    public ModelValidationResult ModelValidationResult { get; public set; }
    protected NancyModule(string modulePath);
    public object get_ViewBag();
    public sealed virtual object get_Text();
    public virtual void Delete(string path, Func`2<object, object> action, Func`2<NancyContext, bool> condition, string name);
    public virtual void Delete(string path, Func`2<object, T> action, Func`2<NancyContext, bool> condition, string name);
    public virtual void Delete(string path, Func`2<object, Task`1<object>> action, Func`2<NancyContext, bool> condition, string name);
    public virtual void Delete(string path, Func`2<object, Task`1<T>> action, Func`2<NancyContext, bool> condition, string name);
    public virtual void Delete(string path, Func`3<object, CancellationToken, Task`1<object>> action, Func`2<NancyContext, bool> condition, string name);
    public virtual void Delete(string path, Func`3<object, CancellationToken, Task`1<T>> action, Func`2<NancyContext, bool> condition, string name);
    public virtual void Get(string path, Func`2<object, object> action, Func`2<NancyContext, bool> condition, string name);
    public virtual void Get(string path, Func`2<object, T> action, Func`2<NancyContext, bool> condition, string name);
    public virtual void Get(string path, Func`2<object, Task`1<object>> action, Func`2<NancyContext, bool> condition, string name);
    public virtual void Get(string path, Func`2<object, Task`1<T>> action, Func`2<NancyContext, bool> condition, string name);
    public virtual void Get(string path, Func`3<object, CancellationToken, Task`1<object>> action, Func`2<NancyContext, bool> condition, string name);
    public virtual void Get(string path, Func`3<object, CancellationToken, Task`1<T>> action, Func`2<NancyContext, bool> condition, string name);
    public virtual void Head(string path, Func`2<object, object> action, Func`2<NancyContext, bool> condition, string name);
    public virtual void Head(string path, Func`2<object, T> action, Func`2<NancyContext, bool> condition, string name);
    public virtual void Head(string path, Func`2<object, Task`1<object>> action, Func`2<NancyContext, bool> condition, string name);
    public virtual void Head(string path, Func`2<object, Task`1<T>> action, Func`2<NancyContext, bool> condition, string name);
    public virtual void Head(string path, Func`3<object, CancellationToken, Task`1<object>> action, Func`2<NancyContext, bool> condition, string name);
    public virtual void Head(string path, Func`3<object, CancellationToken, Task`1<T>> action, Func`2<NancyContext, bool> condition, string name);
    public virtual void Options(string path, Func`2<object, object> action, Func`2<NancyContext, bool> condition, string name);
    public virtual void Options(string path, Func`2<object, T> action, Func`2<NancyContext, bool> condition, string name);
    public virtual void Options(string path, Func`2<object, Task`1<object>> action, Func`2<NancyContext, bool> condition, string name);
    public virtual void Options(string path, Func`2<object, Task`1<T>> action, Func`2<NancyContext, bool> condition, string name);
    public virtual void Options(string path, Func`3<object, CancellationToken, Task`1<object>> action, Func`2<NancyContext, bool> condition, string name);
    public virtual void Options(string path, Func`3<object, CancellationToken, Task`1<T>> action, Func`2<NancyContext, bool> condition, string name);
    public virtual void Patch(string path, Func`2<object, object> action, Func`2<NancyContext, bool> condition, string name);
    public virtual void Patch(string path, Func`2<object, T> action, Func`2<NancyContext, bool> condition, string name);
    public virtual void Patch(string path, Func`2<object, Task`1<object>> action, Func`2<NancyContext, bool> condition, string name);
    public virtual void Patch(string path, Func`2<object, Task`1<T>> action, Func`2<NancyContext, bool> condition, string name);
    public virtual void Patch(string path, Func`3<object, CancellationToken, Task`1<object>> action, Func`2<NancyContext, bool> condition, string name);
    public virtual void Patch(string path, Func`3<object, CancellationToken, Task`1<T>> action, Func`2<NancyContext, bool> condition, string name);
    public virtual void Post(string path, Func`2<object, object> action, Func`2<NancyContext, bool> condition, string name);
    public virtual void Post(string path, Func`2<object, T> action, Func`2<NancyContext, bool> condition, string name);
    public virtual void Post(string path, Func`2<object, Task`1<object>> action, Func`2<NancyContext, bool> condition, string name);
    public virtual void Post(string path, Func`2<object, Task`1<T>> action, Func`2<NancyContext, bool> condition, string name);
    public virtual void Post(string path, Func`3<object, CancellationToken, Task`1<object>> action, Func`2<NancyContext, bool> condition, string name);
    public virtual void Post(string path, Func`3<object, CancellationToken, Task`1<T>> action, Func`2<NancyContext, bool> condition, string name);
    public virtual void Put(string path, Func`2<object, object> action, Func`2<NancyContext, bool> condition, string name);
    public virtual void Put(string path, Func`2<object, T> action, Func`2<NancyContext, bool> condition, string name);
    public virtual void Put(string path, Func`2<object, Task`1<object>> action, Func`2<NancyContext, bool> condition, string name);
    public virtual void Put(string path, Func`2<object, Task`1<T>> action, Func`2<NancyContext, bool> condition, string name);
    public virtual void Put(string path, Func`3<object, CancellationToken, Task`1<object>> action, Func`2<NancyContext, bool> condition, string name);
    public virtual void Put(string path, Func`3<object, CancellationToken, Task`1<T>> action, Func`2<NancyContext, bool> condition, string name);
    [CompilerGeneratedAttribute]
public sealed virtual string get_ModulePath();
    [CompilerGeneratedAttribute]
protected void set_ModulePath(string value);
    public virtual IEnumerable`1<Route> get_Routes();
    public ISession get_Session();
    public sealed virtual ViewRenderer get_View();
    public sealed virtual Negotiator get_Negotiate();
    [CompilerGeneratedAttribute]
public sealed virtual IModelValidatorLocator get_ValidatorLocator();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ValidatorLocator(IModelValidatorLocator value);
    public virtual Request get_Request();
    public virtual void set_Request(Request value);
    [CompilerGeneratedAttribute]
public sealed virtual IViewFactory get_ViewFactory();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ViewFactory(IViewFactory value);
    [CompilerGeneratedAttribute]
public sealed virtual AfterPipeline get_After();
    [CompilerGeneratedAttribute]
public sealed virtual void set_After(AfterPipeline value);
    [CompilerGeneratedAttribute]
public sealed virtual BeforePipeline get_Before();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Before(BeforePipeline value);
    [CompilerGeneratedAttribute]
public sealed virtual ErrorPipeline get_OnError();
    [CompilerGeneratedAttribute]
public sealed virtual void set_OnError(ErrorPipeline value);
    [CompilerGeneratedAttribute]
public sealed virtual NancyContext get_Context();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Context(NancyContext value);
    [CompilerGeneratedAttribute]
public sealed virtual IResponseFormatter get_Response();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Response(IResponseFormatter value);
    [CompilerGeneratedAttribute]
public sealed virtual IModelBinderLocator get_ModelBinderLocator();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ModelBinderLocator(IModelBinderLocator value);
    public virtual ModelValidationResult get_ModelValidationResult();
    public virtual void set_ModelValidationResult(ModelValidationResult value);
    protected void AddRoute(string method, string path, Func`3<object, CancellationToken, Task`1<T>> action, Func`2<NancyContext, bool> condition, string name);
    private string GetFullPath(string path);
    private sealed virtual override Type Nancy.IHideObjectMembers.GetType();
}
[ExtensionAttribute]
public static class Nancy.NegotiatorExtensions : object {
    [ExtensionAttribute]
public static Negotiator WithCookie(Negotiator negotiator, INancyCookie cookie);
    [ExtensionAttribute]
public static Negotiator WithCookies(Negotiator negotiator, IEnumerable`1<INancyCookie> cookies);
    [ExtensionAttribute]
public static Negotiator WithHeader(Negotiator negotiator, string header, string value);
    [ExtensionAttribute]
public static Negotiator WithContentType(Negotiator negotiator, string contentType);
    [ExtensionAttribute]
public static Negotiator WithHeaders(Negotiator negotiator, Object[] headers);
    [ExtensionAttribute]
public static Negotiator WithHeaders(Negotiator negotiator, Tuple`2[] headers);
    [ExtensionAttribute]
public static Negotiator WithFullNegotiation(Negotiator negotiator);
    [ExtensionAttribute]
public static Negotiator WithAllowedMediaRange(Negotiator negotiator, MediaRange mediaRange);
    [ExtensionAttribute]
public static Negotiator WithModel(Negotiator negotiator, object model);
    [ExtensionAttribute]
public static Negotiator WithView(Negotiator negotiator, string viewName);
    [ExtensionAttribute]
public static Negotiator WithMediaRangeModel(Negotiator negotiator, MediaRange range, object model);
    [ExtensionAttribute]
public static Negotiator WithMediaRangeModel(Negotiator negotiator, MediaRange range, Func`1<object> modelFactory);
    [ExtensionAttribute]
public static Negotiator WithMediaRangeResponse(Negotiator negotiator, MediaRange range, Response response);
    [ExtensionAttribute]
public static Negotiator WithMediaRangeResponse(Negotiator negotiator, MediaRange range, Func`1<Response> responseFactory);
    [ExtensionAttribute]
public static Negotiator WithStatusCode(Negotiator negotiator, int statusCode);
    [ExtensionAttribute]
public static Negotiator WithReasonPhrase(Negotiator negotiator, string reasonPhrase);
    [ExtensionAttribute]
public static Negotiator WithStatusCode(Negotiator negotiator, HttpStatusCode statusCode);
    private static Tuple`2<string, string> GetTuple(object header);
}
public class Nancy.NotFoundResponse : Response {
}
[ExtensionAttribute]
public static class Nancy.Owin.DelegateExtensions : object {
    [ExtensionAttribute]
public static Action`1<Func`2<Func`2<IDictionary`2<string, object>, Task>, Func`2<IDictionary`2<string, object>, Task>>> UseNancy(Action`1<Func`2<Func`2<IDictionary`2<string, object>, Task>, Func`2<IDictionary`2<string, object>, Task>>> builder, Action`1<NancyOptions> action);
    [ExtensionAttribute]
public static Action`1<Func`2<Func`2<IDictionary`2<string, object>, Task>, Func`2<IDictionary`2<string, object>, Task>>> UseNancy(Action`1<Func`2<Func`2<IDictionary`2<string, object>, Task>, Func`2<IDictionary`2<string, object>, Task>>> builder, NancyOptions options);
}
[ExtensionAttribute]
public static class Nancy.Owin.NancyContextExtensions : object {
    [ExtensionAttribute]
public static IDictionary`2<string, object> GetOwinEnvironment(NancyContext context);
}
public static class Nancy.Owin.NancyMiddleware : object {
    public static string RequestEnvironmentKey;
    public static Func`2<Func`2<IDictionary`2<string, object>, Task>, Func`2<IDictionary`2<string, object>, Task>> UseNancy(Action`1<NancyOptions> configuration);
    public static Func`2<Func`2<IDictionary`2<string, object>, Task>, Func`2<IDictionary`2<string, object>, Task>> UseNancy(NancyOptions options);
    private static Task RequestComplete(NancyContext context, IDictionary`2<string, object> environment, Func`2<NancyContext, bool> performPassThrough, Func`2<IDictionary`2<string, object>, Task> next);
    private static T Get(IDictionary`2<string, object> env, string key);
    private static string GetHeader(IDictionary`2<string, String[]> headers, string key);
    private static ClaimsPrincipal GetUser(IDictionary`2<string, object> environment);
    private static Nullable`1<long> ExpectedLength(IDictionary`2<string, String[]> headers);
    private static Url CreateUrl(string owinRequestHost, string owinRequestScheme, string owinRequestPathBase, string owinRequestPath, string owinRequestQueryString);
    private static Func`2<NancyContext, NancyContext> StoreEnvironment(IDictionary`2<string, object> environment, ClaimsPrincipal user);
}
public class Nancy.Owin.NancyOptions : object {
    private INancyBootstrapper bootstrapper;
    private Func`2<NancyContext, bool> performPassThrough;
    [CompilerGeneratedAttribute]
private bool <EnableClientCertificates>k__BackingField;
    public INancyBootstrapper Bootstrapper { get; public set; }
    public Func`2<NancyContext, bool> PerformPassThrough { get; public set; }
    public bool EnableClientCertificates { get; public set; }
    public INancyBootstrapper get_Bootstrapper();
    public void set_Bootstrapper(INancyBootstrapper value);
    public Func`2<NancyContext, bool> get_PerformPassThrough();
    public void set_PerformPassThrough(Func`2<NancyContext, bool> value);
    [CompilerGeneratedAttribute]
public bool get_EnableClientCertificates();
    [CompilerGeneratedAttribute]
public void set_EnableClientCertificates(bool value);
}
[ExtensionAttribute]
public static class Nancy.Owin.NancyOptionsExtensions : object {
    [ExtensionAttribute]
public static void PassThroughWhenStatusCodesAre(NancyOptions nancyOptions, HttpStatusCode[] httpStatusCode);
}
public class Nancy.PipelineItem`1 : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private TDelegate <Delegate>k__BackingField;
    public string Name { get; protected set; }
    public TDelegate Delegate { get; protected set; }
    public PipelineItem`1(string name, TDelegate delegate);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
protected void set_Name(string value);
    [CompilerGeneratedAttribute]
public TDelegate get_Delegate();
    [CompilerGeneratedAttribute]
protected void set_Delegate(TDelegate value);
    public static PipelineItem`1<TDelegate> op_Implicit(TDelegate action);
    public static TDelegate op_Implicit(PipelineItem`1<TDelegate> pipelineItem);
}
[GeneratedCodeAttribute("simple-json", "1.0.0")]
internal class Nancy.PocoJsonSerializerStrategy : object {
    internal IDictionary`2<Type, ConstructorDelegate> ConstructorCache;
    internal IDictionary`2<Type, IDictionary`2<string, GetDelegate>> GetCache;
    internal IDictionary`2<Type, IDictionary`2<string, KeyValuePair`2<Type, SetDelegate>>> SetCache;
    internal static Type[] EmptyTypes;
    internal static Type[] ArrayConstructorParameterTypes;
    private static String[] Iso8601Format;
    private static PocoJsonSerializerStrategy();
    protected virtual string MapClrMemberNameToJsonFieldName(string clrPropertyName);
    internal virtual ConstructorDelegate ContructorDelegateFactory(Type key);
    internal virtual IDictionary`2<string, GetDelegate> GetterValueFactory(Type type);
    internal virtual IDictionary`2<string, KeyValuePair`2<Type, SetDelegate>> SetterValueFactory(Type type);
    public virtual bool TrySerializeNonPrimitiveObject(object input, Object& output);
    public virtual object DeserializeObject(object value, Type type);
    protected virtual object SerializeEnum(Enum p);
    protected virtual bool TrySerializeKnownTypes(object input, Object& output);
    protected virtual bool TrySerializeUnknownTypes(object input, Object& output);
}
[GeneratedCodeAttribute("reflection-utils", "1.0.0")]
internal class Nancy.Reflection.ReflectionUtils : object {
    private static Object[] EmptyObjects;
    private static ReflectionUtils();
    public static Type GetTypeInfo(Type type);
    public static Attribute GetAttribute(MemberInfo info, Type type);
    public static Type GetGenericListElementType(Type type);
    public static Attribute GetAttribute(Type objectType, Type attributeType);
    public static Type[] GetGenericTypeArguments(Type type);
    public static bool IsTypeGeneric(Type type);
    public static bool IsTypeGenericeCollectionInterface(Type type);
    public static bool IsAssignableFrom(Type type1, Type type2);
    public static bool IsTypeDictionary(Type type);
    public static bool IsNullableType(Type type);
    public static object ToNullableType(object obj, Type nullableType);
    public static bool IsValueType(Type type);
    public static IEnumerable`1<ConstructorInfo> GetConstructors(Type type);
    public static ConstructorInfo GetConstructorInfo(Type type, Type[] argsType);
    public static IEnumerable`1<PropertyInfo> GetProperties(Type type);
    public static IEnumerable`1<FieldInfo> GetFields(Type type);
    public static MethodInfo GetGetterMethodInfo(PropertyInfo propertyInfo);
    public static MethodInfo GetSetterMethodInfo(PropertyInfo propertyInfo);
    public static ConstructorDelegate GetContructor(ConstructorInfo constructorInfo);
    public static ConstructorDelegate GetContructor(Type type, Type[] argsType);
    public static ConstructorDelegate GetConstructorByReflection(ConstructorInfo constructorInfo);
    public static ConstructorDelegate GetConstructorByReflection(Type type, Type[] argsType);
    public static ConstructorDelegate GetConstructorByExpression(ConstructorInfo constructorInfo);
    public static ConstructorDelegate GetConstructorByExpression(Type type, Type[] argsType);
    public static GetDelegate GetGetMethod(PropertyInfo propertyInfo);
    public static GetDelegate GetGetMethod(FieldInfo fieldInfo);
    public static GetDelegate GetGetMethodByReflection(PropertyInfo propertyInfo);
    public static GetDelegate GetGetMethodByReflection(FieldInfo fieldInfo);
    public static GetDelegate GetGetMethodByExpression(PropertyInfo propertyInfo);
    public static GetDelegate GetGetMethodByExpression(FieldInfo fieldInfo);
    public static SetDelegate GetSetMethod(PropertyInfo propertyInfo);
    public static SetDelegate GetSetMethod(FieldInfo fieldInfo);
    public static SetDelegate GetSetMethodByReflection(PropertyInfo propertyInfo);
    public static SetDelegate GetSetMethodByReflection(FieldInfo fieldInfo);
    public static SetDelegate GetSetMethodByExpression(PropertyInfo propertyInfo);
    public static SetDelegate GetSetMethodByExpression(FieldInfo fieldInfo);
    public static BinaryExpression Assign(Expression left, Expression right);
}
[DebuggerDisplayAttribute("{DebuggerDisplay, nq}")]
public class Nancy.Request : object {
    private List`1<HttpFile> files;
    [DynamicAttribute]
private object form;
    private IDictionary`2<string, string> cookies;
    [CompilerGeneratedAttribute]
private X509Certificate <ClientCertificate>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProtocolVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <UserHostAddress>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Method>k__BackingField;
    [CompilerGeneratedAttribute]
private Url <Url>k__BackingField;
    [CompilerGeneratedAttribute]
[DynamicAttribute]
private object <Query>k__BackingField;
    [CompilerGeneratedAttribute]
private Stream <Body>k__BackingField;
    [CompilerGeneratedAttribute]
private ISession <Session>k__BackingField;
    [CompilerGeneratedAttribute]
private RequestHeaders <Headers>k__BackingField;
    public X509Certificate ClientCertificate { get; private set; }
    public string ProtocolVersion { get; private set; }
    public string UserHostAddress { get; private set; }
    public string Method { get; private set; }
    public Url Url { get; private set; }
    public string Path { get; }
    [DynamicAttribute]
public object Query { get; public set; }
    public Stream Body { get; private set; }
    public IDictionary`2<string, string> Cookies { get; }
    public ISession Session { get; public set; }
    public IEnumerable`1<HttpFile> Files { get; }
    [DynamicAttribute]
public object Form { get; }
    public RequestHeaders Headers { get; private set; }
    private string DebuggerDisplay { get; }
    public Request(string method, string path, string scheme);
    public Request(string method, Url url, Stream body, IDictionary`2<string, IEnumerable`1<string>> headers, string ip, X509Certificate certificate, string protocolVersion);
    [CompilerGeneratedAttribute]
public X509Certificate get_ClientCertificate();
    [CompilerGeneratedAttribute]
private void set_ClientCertificate(X509Certificate value);
    [CompilerGeneratedAttribute]
public string get_ProtocolVersion();
    [CompilerGeneratedAttribute]
private void set_ProtocolVersion(string value);
    [CompilerGeneratedAttribute]
public string get_UserHostAddress();
    [CompilerGeneratedAttribute]
private void set_UserHostAddress(string value);
    [CompilerGeneratedAttribute]
public string get_Method();
    [CompilerGeneratedAttribute]
private void set_Method(string value);
    [CompilerGeneratedAttribute]
public Url get_Url();
    [CompilerGeneratedAttribute]
private void set_Url(Url value);
    public string get_Path();
    [CompilerGeneratedAttribute]
public object get_Query();
    [CompilerGeneratedAttribute]
public void set_Query(object value);
    [CompilerGeneratedAttribute]
public Stream get_Body();
    [CompilerGeneratedAttribute]
private void set_Body(Stream value);
    public IDictionary`2<string, string> get_Cookies();
    [CompilerGeneratedAttribute]
public ISession get_Session();
    [CompilerGeneratedAttribute]
public void set_Session(ISession value);
    private IDictionary`2<string, string> GetCookieData();
    public IEnumerable`1<HttpFile> get_Files();
    public object get_Form();
    [CompilerGeneratedAttribute]
public RequestHeaders get_Headers();
    [CompilerGeneratedAttribute]
private void set_Headers(RequestHeaders value);
    public sealed virtual void Dispose();
    private void ParseFormData();
    private void RewriteMethod();
    private string get_DebuggerDisplay();
}
public class Nancy.RequestExecutionException : Exception {
    public RequestExecutionException(Exception innerException);
}
[DefaultMemberAttribute("Item")]
public class Nancy.RequestHeaders : object {
    private IDictionary`2<string, IEnumerable`1<string>> headers;
    private ConcurrentDictionary`2<string, IEnumerable`1<Tuple`2<string, decimal>>> cache;
    public IEnumerable`1<Tuple`2<string, decimal>> Accept { get; public set; }
    public IEnumerable`1<Tuple`2<string, decimal>> AcceptCharset { get; public set; }
    public IEnumerable`1<string> AcceptEncoding { get; public set; }
    public IEnumerable`1<Tuple`2<string, decimal>> AcceptLanguage { get; public set; }
    public string Authorization { get; public set; }
    public IEnumerable`1<string> CacheControl { get; public set; }
    public IEnumerable`1<INancyCookie> Cookie { get; }
    public string Connection { get; public set; }
    public long ContentLength { get; public set; }
    public MediaRange ContentType { get; public set; }
    public Nullable`1<DateTime> Date { get; public set; }
    public string Host { get; public set; }
    public IEnumerable`1<string> IfMatch { get; public set; }
    public Nullable`1<DateTime> IfModifiedSince { get; public set; }
    public IEnumerable`1<string> IfNoneMatch { get; public set; }
    public string IfRange { get; public set; }
    public Nullable`1<DateTime> IfUnmodifiedSince { get; public set; }
    public IEnumerable`1<string> Keys { get; }
    public int MaxForwards { get; public set; }
    public string Referrer { get; public set; }
    public string UserAgent { get; public set; }
    public IEnumerable`1<IEnumerable`1<string>> Values { get; }
    public IEnumerable`1<string> Item { get; }
    public RequestHeaders(IDictionary`2<string, IEnumerable`1<string>> headers);
    public IEnumerable`1<Tuple`2<string, decimal>> get_Accept();
    public void set_Accept(IEnumerable`1<Tuple`2<string, decimal>> value);
    public IEnumerable`1<Tuple`2<string, decimal>> get_AcceptCharset();
    public void set_AcceptCharset(IEnumerable`1<Tuple`2<string, decimal>> value);
    public IEnumerable`1<string> get_AcceptEncoding();
    public void set_AcceptEncoding(IEnumerable`1<string> value);
    public IEnumerable`1<Tuple`2<string, decimal>> get_AcceptLanguage();
    public void set_AcceptLanguage(IEnumerable`1<Tuple`2<string, decimal>> value);
    public string get_Authorization();
    public void set_Authorization(string value);
    public IEnumerable`1<string> get_CacheControl();
    public void set_CacheControl(IEnumerable`1<string> value);
    public IEnumerable`1<INancyCookie> get_Cookie();
    public string get_Connection();
    public void set_Connection(string value);
    public long get_ContentLength();
    public void set_ContentLength(long value);
    public MediaRange get_ContentType();
    public void set_ContentType(MediaRange value);
    public Nullable`1<DateTime> get_Date();
    public void set_Date(Nullable`1<DateTime> value);
    public string get_Host();
    public void set_Host(string value);
    public IEnumerable`1<string> get_IfMatch();
    public void set_IfMatch(IEnumerable`1<string> value);
    public Nullable`1<DateTime> get_IfModifiedSince();
    public void set_IfModifiedSince(Nullable`1<DateTime> value);
    public IEnumerable`1<string> get_IfNoneMatch();
    public void set_IfNoneMatch(IEnumerable`1<string> value);
    public string get_IfRange();
    public void set_IfRange(string value);
    public Nullable`1<DateTime> get_IfUnmodifiedSince();
    public void set_IfUnmodifiedSince(Nullable`1<DateTime> value);
    public IEnumerable`1<string> get_Keys();
    public int get_MaxForwards();
    public void set_MaxForwards(int value);
    public string get_Referrer();
    public void set_Referrer(string value);
    public string get_UserAgent();
    public void set_UserAgent(string value);
    public IEnumerable`1<IEnumerable`1<string>> get_Values();
    public sealed virtual IEnumerator`1<KeyValuePair`2<string, IEnumerable`1<string>>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public IEnumerable`1<string> get_Item(string name);
    private static string GetDateAsString(Nullable`1<DateTime> value);
    private IEnumerable`1<string> GetSplitValues(string header);
    private IEnumerable`1<Tuple`2<string, decimal>> GetWeightedValues(string headerName);
    [IteratorStateMachineAttribute("Nancy.RequestHeaders/<GetNancyCookies>d__73")]
private static IEnumerable`1<INancyCookie> GetNancyCookies(IEnumerable`1<string> cookies);
    private IEnumerable`1<string> GetValue(string name);
    private T GetValue(string name, Func`2<IEnumerable`1<string>, T> converter, T defaultValue);
    private static IEnumerable`1<string> GetWeightedValuesAsStrings(IEnumerable`1<Tuple`2<string, decimal>> values);
    private static Nullable`1<DateTime> ParseDateTime(string value);
    private void SetHeaderValues(string header, T value, Func`2<T, IEnumerable`1<string>> valueTransformer);
    private void InvalidateCacheEntry(string header);
    [CompilerGeneratedAttribute]
private IEnumerable`1<Tuple`2<string, decimal>> <GetWeightedValues>b__72_0(string r);
}
public class Nancy.ResourceAssemblyProvider : object {
    private IAssemblyCatalog assemblyCatalog;
    private IEnumerable`1<Assembly> filteredAssemblies;
    public ResourceAssemblyProvider(IAssemblyCatalog assemblyCatalog);
    public sealed virtual IEnumerable`1<Assembly> GetAssembliesToScan();
    private IEnumerable`1<Assembly> GetFilteredAssemblies();
}
[DebuggerDisplayAttribute("{DebuggerDisplay, nq}")]
public class Nancy.Response : object {
    public static Action`1<Stream> NoBody;
    private string contentType;
    [CompilerGeneratedAttribute]
private Action`1<Stream> <Contents>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <Headers>k__BackingField;
    [CompilerGeneratedAttribute]
private HttpStatusCode <StatusCode>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ReasonPhrase>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<INancyCookie> <Cookies>k__BackingField;
    public string ContentType { get; public set; }
    public Action`1<Stream> Contents { get; public set; }
    public IDictionary`2<string, string> Headers { get; public set; }
    public HttpStatusCode StatusCode { get; public set; }
    public string ReasonPhrase { get; public set; }
    public IList`1<INancyCookie> Cookies { get; private set; }
    private string DebuggerDisplay { get; }
    private static Response();
    public string get_ContentType();
    public void set_ContentType(string value);
    [CompilerGeneratedAttribute]
public Action`1<Stream> get_Contents();
    [CompilerGeneratedAttribute]
public void set_Contents(Action`1<Stream> value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_Headers();
    [CompilerGeneratedAttribute]
public void set_Headers(IDictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public HttpStatusCode get_StatusCode();
    [CompilerGeneratedAttribute]
public void set_StatusCode(HttpStatusCode value);
    [CompilerGeneratedAttribute]
public string get_ReasonPhrase();
    [CompilerGeneratedAttribute]
public void set_ReasonPhrase(string value);
    [CompilerGeneratedAttribute]
public IList`1<INancyCookie> get_Cookies();
    [CompilerGeneratedAttribute]
private void set_Cookies(IList`1<INancyCookie> value);
    public virtual Task PreExecute(NancyContext context);
    public static Response op_Implicit(HttpStatusCode statusCode);
    public static Response op_Implicit(int statusCode);
    public static Response op_Implicit(string contents);
    public static Response op_Implicit(Action`1<Stream> streamFactory);
    public static Response op_Implicit(DynamicDictionaryValue value);
    protected static Action`1<Stream> GetStringContents(string contents);
    public virtual void Dispose();
    private string get_DebuggerDisplay();
}
[ExtensionAttribute]
public static class Nancy.ResponseExtensions : object {
    [ExtensionAttribute]
public static Response AsAttachment(Response response, string fileName, string contentType);
    [ExtensionAttribute]
public static Response WithCookie(Response response, string name, string value);
    [ExtensionAttribute]
public static Response WithCookie(Response response, string name, string value, Nullable`1<DateTime> expires);
    [ExtensionAttribute]
public static Response WithCookie(Response response, string name, string value, Nullable`1<DateTime> expires, string domain, string path);
    [ExtensionAttribute]
public static Response WithCookie(Response response, INancyCookie nancyCookie);
    [ExtensionAttribute]
public static Response WithHeader(Response response, string header, string value);
    [ExtensionAttribute]
public static Response WithHeaders(Response response, Object[] headers);
    [ExtensionAttribute]
public static Response WithHeaders(Response response, Tuple`2[] headers);
    [ExtensionAttribute]
public static Response WithContentType(Response response, string contentType);
    [ExtensionAttribute]
public static Response WithStatusCode(Response response, HttpStatusCode statusCode);
    [ExtensionAttribute]
public static Response WithStatusCode(Response response, int statusCode);
    private static Tuple`2<string, string> GetTuple(object header);
}
public class Nancy.Responses.DefaultJsonSerializer : object {
    private JsonConfiguration jsonConfiguration;
    private TraceConfiguration traceConfiguration;
    private GlobalizationConfiguration globalizationConfiguration;
    public IEnumerable`1<string> Extensions { get; }
    public DefaultJsonSerializer(INancyEnvironment environment);
    public sealed virtual bool CanSerialize(MediaRange mediaRange);
    [IteratorStateMachineAttribute("Nancy.Responses.DefaultJsonSerializer/<get_Extensions>d__6")]
public sealed virtual IEnumerable`1<string> get_Extensions();
    public sealed virtual void Serialize(MediaRange mediaRange, TModel model, Stream outputStream);
}
public class Nancy.Responses.DefaultXmlSerializer : object {
    private XmlConfiguration configuration;
    private TraceConfiguration traceConfiguration;
    public IEnumerable`1<string> Extensions { get; }
    public DefaultXmlSerializer(INancyEnvironment environment);
    public sealed virtual bool CanSerialize(MediaRange mediaRange);
    [IteratorStateMachineAttribute("Nancy.Responses.DefaultXmlSerializer/<get_Extensions>d__5")]
public sealed virtual IEnumerable`1<string> get_Extensions();
    public sealed virtual void Serialize(MediaRange mediaRange, TModel model, Stream outputStream);
    private static bool IsXmlType(string contentType);
}
public class Nancy.Responses.EmbeddedFileResponse : Response {
    private static Byte[] ErrorText;
    private static EmbeddedFileResponse();
    public EmbeddedFileResponse(Assembly assembly, string resourcePath, string name);
    private Stream GetResourceContent(Assembly assembly, string resourcePath, string name);
    private static string GetFileNameFromResourceName(string resourcePath, string resourceName);
    private static string GenerateETag(Stream stream);
    private static string ByteArrayToString(Byte[] data);
}
public class Nancy.Responses.GenericFileResponse : Response {
    private StaticContentConfiguration configuration;
    public static int BufferSize;
    [CompilerGeneratedAttribute]
private string <Filename>k__BackingField;
    public string Filename { get; protected set; }
    public GenericFileResponse(string filePath, NancyContext context);
    public GenericFileResponse(string filePath, string contentType, NancyContext context);
    private static GenericFileResponse();
    [CompilerGeneratedAttribute]
public string get_Filename();
    [CompilerGeneratedAttribute]
protected void set_Filename(string value);
    private static Action`1<Stream> GetFileContent(string filePath, long length);
    private static bool IsSafeFilePath(string rootPath, string filePath);
    private void InitializeGenericFileResponse(string filePath, string contentType, NancyContext context);
    private void SetResponseValues(string contentType, string fullPath, NancyContext context);
}
public class Nancy.Responses.HtmlResponse : Response {
    public HtmlResponse(HttpStatusCode statusCode, Action`1<Stream> contents, IDictionary`2<string, string> headers, IEnumerable`1<INancyCookie> cookies);
}
public class Nancy.Responses.JsonResponse : JsonResponse`1<object> {
    public JsonResponse(object model, ISerializer serializer, INancyEnvironment environment);
}
public class Nancy.Responses.JsonResponse`1 : Response {
    private JsonConfiguration configuration;
    private string DefaultContentType { get; }
    private string Encoding { get; }
    public JsonResponse`1(TModel model, ISerializer serializer, INancyEnvironment environment);
    private string get_DefaultContentType();
    private string get_Encoding();
    private Action`1<Stream> GetJsonContents(TModel model, ISerializer serializer);
}
public class Nancy.Responses.MaterialisingResponse : Response {
    private Response sourceResponse;
    private Byte[] oldResponseOutput;
    public MaterialisingResponse(Response sourceResponse);
    public virtual Task PreExecute(NancyContext context);
    private void WriteContents(Stream stream);
}
public class Nancy.Responses.NegotiatedResponse : Response {
    [CompilerGeneratedAttribute]
[DynamicAttribute]
private object <Value>k__BackingField;
    [DynamicAttribute]
public object Value { get; public set; }
    public NegotiatedResponse(object value);
    [CompilerGeneratedAttribute]
public object get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(object value);
}
public class Nancy.Responses.Negotiation.DefaultResponseNegotiator : object {
    private IReadOnlyCollection`1<IResponseProcessor> processors;
    private AcceptHeaderCoercionConventions coercionConventions;
    public DefaultResponseNegotiator(IEnumerable`1<IResponseProcessor> processors, AcceptHeaderCoercionConventions coercionConventions);
    public sealed virtual Response NegotiateResponse(object routeResult, NancyContext context);
    private static bool TryCastResultToResponse(object routeResult, Response& response);
    private static NegotiationContext GetNegotiationContext(object routeResult, NancyContext context);
    private IEnumerable`1<Tuple`2<string, decimal>> GetCoercedAcceptHeaders(NancyContext context);
    private static void GetAccepHeaderTraceLog(NancyContext context, NegotiationContext negotiationContext, Tuple`2[] coercedAcceptHeaders, StringBuilder sb);
    [IteratorStateMachineAttribute("Nancy.Responses.Negotiation.DefaultResponseNegotiator/<GetCompatibleHeaders>d__8")]
private IEnumerable`1<CompatibleHeader> GetCompatibleHeaders(IEnumerable`1<Tuple`2<string, decimal>> coercedAcceptHeaders, NegotiationContext negotiationContext, NancyContext context);
    private static IEnumerable`1<Tuple`2<string, decimal>> GetCompatibleHeaders(IEnumerable`1<Tuple`2<string, decimal>> coercedAcceptHeaders, NegotiationContext negotiationContext);
    [IteratorStateMachineAttribute("Nancy.Responses.Negotiation.DefaultResponseNegotiator/<GetCompatibleProcessorsByHeader>d__10")]
private IEnumerable`1<Tuple`2<IResponseProcessor, ProcessorMatch>> GetCompatibleProcessorsByHeader(string acceptHeader, object model, NancyContext context);
    private Response CreateResponse(IList`1<CompatibleHeader> compatibleHeaders, NegotiationContext negotiationContext, NancyContext context);
    private static Response NegotiateResponse(IEnumerable`1<CompatibleHeader> compatibleHeaders, NegotiationContext negotiationContext, NancyContext context);
    private void AddLinkHeader(IEnumerable`1<CompatibleHeader> compatibleHeaders, Response response, Url requestUrl);
    private static IDictionary`2<string, MediaRange> GetLinkProcessors(IEnumerable`1<CompatibleHeader> compatibleHeaders, string contentType);
    protected virtual string CreateLinkHeader(Url requestUrl, IEnumerable`1<KeyValuePair`2<string, MediaRange>> linkProcessors, string existingLinkHeader);
    private static void AddContentTypeHeader(NegotiationContext negotiationContext, Response response);
    private static void AddNegotiatedHeaders(NegotiationContext negotiationContext, Response response);
    private static void SetStatusCode(NegotiationContext negotiationContext, Response response);
    private static void SetReasonPhrase(NegotiationContext negotiationContext, Response response);
    private static void AddCookies(NegotiationContext negotiationContext, Response response);
}
public interface Nancy.Responses.Negotiation.IResponseNegotiator {
    public abstract virtual Response NegotiateResponse(object routeResult, NancyContext context);
}
public interface Nancy.Responses.Negotiation.IResponseProcessor {
    public IEnumerable`1<Tuple`2<string, MediaRange>> ExtensionMappings { get; }
    public abstract virtual IEnumerable`1<Tuple`2<string, MediaRange>> get_ExtensionMappings();
    public abstract virtual ProcessorMatch CanProcess(MediaRange requestedMediaRange, object model, NancyContext context);
    public abstract virtual Response Process(MediaRange requestedMediaRange, object model, NancyContext context);
}
public class Nancy.Responses.Negotiation.JsonProcessor : object {
    private ISerializer serializer;
    private INancyEnvironment environment;
    private static IEnumerable`1<Tuple`2<string, MediaRange>> extensionMappings;
    public IEnumerable`1<Tuple`2<string, MediaRange>> ExtensionMappings { get; }
    public JsonProcessor(IEnumerable`1<ISerializer> serializers, INancyEnvironment environment);
    private static JsonProcessor();
    public sealed virtual IEnumerable`1<Tuple`2<string, MediaRange>> get_ExtensionMappings();
    public sealed virtual ProcessorMatch CanProcess(MediaRange requestedMediaRange, object model, NancyContext context);
    public sealed virtual Response Process(MediaRange requestedMediaRange, object model, NancyContext context);
    private static bool IsExactJsonContentType(MediaRange requestedContentType);
    private static bool IsWildcardJsonContentType(MediaRange requestedContentType);
}
public enum Nancy.Responses.Negotiation.MatchResult : Enum {
    public int value__;
    public static MatchResult NoMatch;
    public static MatchResult DontCare;
    public static MatchResult NonExactMatch;
    public static MatchResult ExactMatch;
}
public class Nancy.Responses.Negotiation.MediaRange : object {
    [CompilerGeneratedAttribute]
private MediaType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private MediaType <Subtype>k__BackingField;
    [CompilerGeneratedAttribute]
private MediaRangeParameters <Parameters>k__BackingField;
    public MediaType Type { get; private set; }
    public MediaType Subtype { get; private set; }
    public MediaRangeParameters Parameters { get; private set; }
    public bool IsWildcard { get; }
    public MediaRange(string contentType);
    private void ParseContentType(string contentType);
    [CompilerGeneratedAttribute]
public MediaType get_Type();
    [CompilerGeneratedAttribute]
private void set_Type(MediaType value);
    [CompilerGeneratedAttribute]
public MediaType get_Subtype();
    [CompilerGeneratedAttribute]
private void set_Subtype(MediaType value);
    [CompilerGeneratedAttribute]
public MediaRangeParameters get_Parameters();
    [CompilerGeneratedAttribute]
private void set_Parameters(MediaRangeParameters value);
    public bool get_IsWildcard();
    public bool Matches(MediaRange other);
    public bool MatchesWithParameters(MediaRange other);
    public static MediaRange op_Implicit(string contentType);
    public static string op_Implicit(MediaRange mediaRange);
    public sealed virtual bool Equals(MediaRange other);
    public virtual string ToString();
}
[DefaultMemberAttribute("Item")]
public class Nancy.Responses.Negotiation.MediaRangeParameters : object {
    private IDictionary`2<string, string> parameters;
    public IEnumerable`1<string> Keys { get; }
    public IEnumerable`1<string> Values { get; }
    public string Item { get; }
    public MediaRangeParameters(IDictionary`2<string, string> parameters);
    public IEnumerable`1<string> get_Keys();
    public IEnumerable`1<string> get_Values();
    public sealed virtual IEnumerator`1<KeyValuePair`2<string, string>> GetEnumerator();
    public bool Matches(MediaRangeParameters other);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public string get_Item(string name);
    public static string op_Implicit(MediaRangeParameters mediaRangeParameters);
    public static MediaRangeParameters FromString(string parameters);
    public virtual string ToString();
}
public class Nancy.Responses.Negotiation.MediaType : object {
    private string type;
    public bool IsWildcard { get; }
    public MediaType(string type);
    public bool get_IsWildcard();
    public bool Matches(MediaType other);
    public static MediaType op_Implicit(string inputString);
    public static string op_Implicit(MediaType inputMediaType);
    public virtual string ToString();
}
public class Nancy.Responses.Negotiation.NegotiationContext : object {
    [CompilerGeneratedAttribute]
private IList`1<INancyCookie> <Cookies>k__BackingField;
    [CompilerGeneratedAttribute]
[DynamicAttribute]
private object <DefaultModel>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <Headers>k__BackingField;
    [CompilerGeneratedAttribute]
[DynamicAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IDictionary`2<MediaRange, Func`1<object>> <MediaRangeModelMappings>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ModuleName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ModulePath>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<MediaRange> <PermissableMediaRanges>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<HttpStatusCode> <StatusCode>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ReasonPhrase>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ViewName>k__BackingField;
    public IList`1<INancyCookie> Cookies { get; public set; }
    [DynamicAttribute]
public object DefaultModel { get; public set; }
    public IDictionary`2<string, string> Headers { get; public set; }
    [DynamicAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IDictionary`2<MediaRange, Func`1<object>> MediaRangeModelMappings { get; public set; }
    public string ModuleName { get; public set; }
    public string ModulePath { get; public set; }
    public IList`1<MediaRange> PermissableMediaRanges { get; public set; }
    public Nullable`1<HttpStatusCode> StatusCode { get; public set; }
    public string ReasonPhrase { get; public set; }
    public string ViewName { get; public set; }
    [CompilerGeneratedAttribute]
public IList`1<INancyCookie> get_Cookies();
    [CompilerGeneratedAttribute]
public void set_Cookies(IList`1<INancyCookie> value);
    [CompilerGeneratedAttribute]
public object get_DefaultModel();
    [CompilerGeneratedAttribute]
public void set_DefaultModel(object value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_Headers();
    [CompilerGeneratedAttribute]
public void set_Headers(IDictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public IDictionary`2<MediaRange, Func`1<object>> get_MediaRangeModelMappings();
    [CompilerGeneratedAttribute]
public void set_MediaRangeModelMappings(IDictionary`2<MediaRange, Func`1<object>> value);
    [CompilerGeneratedAttribute]
public string get_ModuleName();
    [CompilerGeneratedAttribute]
public void set_ModuleName(string value);
    [CompilerGeneratedAttribute]
public string get_ModulePath();
    [CompilerGeneratedAttribute]
public void set_ModulePath(string value);
    [CompilerGeneratedAttribute]
public IList`1<MediaRange> get_PermissableMediaRanges();
    [CompilerGeneratedAttribute]
public void set_PermissableMediaRanges(IList`1<MediaRange> value);
    [CompilerGeneratedAttribute]
public Nullable`1<HttpStatusCode> get_StatusCode();
    [CompilerGeneratedAttribute]
public void set_StatusCode(Nullable`1<HttpStatusCode> value);
    [CompilerGeneratedAttribute]
public string get_ReasonPhrase();
    [CompilerGeneratedAttribute]
public void set_ReasonPhrase(string value);
    [CompilerGeneratedAttribute]
public string get_ViewName();
    [CompilerGeneratedAttribute]
public void set_ViewName(string value);
    public object GetModelForMediaRange(MediaRange mediaRange);
    public void SetModule(INancyModule module);
}
public class Nancy.Responses.Negotiation.Negotiator : object {
    [CompilerGeneratedAttribute]
private NegotiationContext <NegotiationContext>k__BackingField;
    public NegotiationContext NegotiationContext { get; private set; }
    public Negotiator(NancyContext context);
    public TaskAwaiter`1<Negotiator> GetAwaiter();
    [CompilerGeneratedAttribute]
public NegotiationContext get_NegotiationContext();
    [CompilerGeneratedAttribute]
private void set_NegotiationContext(NegotiationContext value);
    private sealed virtual override Type Nancy.IHideObjectMembers.GetType();
}
public class Nancy.Responses.Negotiation.ProcessorMatch : object {
    public static ProcessorMatch None;
    [CompilerGeneratedAttribute]
private MatchResult <RequestedContentTypeResult>k__BackingField;
    [CompilerGeneratedAttribute]
private MatchResult <ModelResult>k__BackingField;
    public MatchResult RequestedContentTypeResult { get; public set; }
    public MatchResult ModelResult { get; public set; }
    private static ProcessorMatch();
    [CompilerGeneratedAttribute]
public MatchResult get_RequestedContentTypeResult();
    [CompilerGeneratedAttribute]
public void set_RequestedContentTypeResult(MatchResult value);
    [CompilerGeneratedAttribute]
public MatchResult get_ModelResult();
    [CompilerGeneratedAttribute]
public void set_ModelResult(MatchResult value);
}
public class Nancy.Responses.Negotiation.ResponseProcessor : object {
    public IEnumerable`1<Tuple`2<string, MediaRange>> ExtensionMappings { get; }
    public sealed virtual IEnumerable`1<Tuple`2<string, MediaRange>> get_ExtensionMappings();
    public sealed virtual ProcessorMatch CanProcess(MediaRange requestedMediaRange, object model, NancyContext context);
    public sealed virtual Response Process(MediaRange requestedMediaRange, object model, NancyContext context);
}
public class Nancy.Responses.Negotiation.ViewProcessor : object {
    private IViewFactory viewFactory;
    private TraceConfiguration traceConfiguration;
    public IEnumerable`1<Tuple`2<string, MediaRange>> ExtensionMappings { get; }
    public ViewProcessor(IViewFactory viewFactory, INancyEnvironment environment);
    [IteratorStateMachineAttribute("Nancy.Responses.Negotiation.ViewProcessor/<get_ExtensionMappings>d__4")]
public sealed virtual IEnumerable`1<Tuple`2<string, MediaRange>> get_ExtensionMappings();
    public sealed virtual ProcessorMatch CanProcess(MediaRange requestedMediaRange, object model, NancyContext context);
    public sealed virtual Response Process(MediaRange requestedMediaRange, object model, NancyContext context);
    private static ViewLocationContext GetViewLocationContext(NancyContext context);
}
public class Nancy.Responses.Negotiation.XmlProcessor : object {
    private ISerializer serializer;
    private static IEnumerable`1<Tuple`2<string, MediaRange>> extensionMappings;
    public IEnumerable`1<Tuple`2<string, MediaRange>> ExtensionMappings { get; }
    public XmlProcessor(IEnumerable`1<ISerializer> serializers);
    private static XmlProcessor();
    public sealed virtual IEnumerable`1<Tuple`2<string, MediaRange>> get_ExtensionMappings();
    public sealed virtual ProcessorMatch CanProcess(MediaRange requestedMediaRange, object model, NancyContext context);
    public sealed virtual Response Process(MediaRange requestedMediaRange, object model, NancyContext context);
    private static Response CreateResponse(object model, ISerializer serializer);
    private static bool IsExactXmlContentType(MediaRange requestedContentType);
    private static bool IsWildcardXmlContentType(MediaRange requestedContentType);
}
public class Nancy.Responses.NotAcceptableResponse : Response {
}
public class Nancy.Responses.RedirectResponse : Response {
    public RedirectResponse(string location, RedirectType type);
}
public class Nancy.Responses.StreamResponse : Response {
    private Stream source;
    public StreamResponse(Func`1<Stream> source, string contentType);
    private Action`1<Stream> GetResponseBodyDelegate(Func`1<Stream> sourceDelegate);
    public virtual void Dispose();
}
public class Nancy.Responses.TextResponse : Response {
    private static string TextPlainContentType;
    public TextResponse(string contents, string contentType, Encoding encoding);
    public TextResponse(HttpStatusCode statusCode, string contents, Encoding encoding, IDictionary`2<string, string> headers, IEnumerable`1<INancyCookie> cookies);
    private static string GetContentType(string contentType, Encoding encoding);
}
public class Nancy.Responses.XmlResponse`1 : Response {
    private XmlConfiguration configuration;
    private string DefaultContentType { get; }
    private string Encoding { get; }
    public XmlResponse`1(TModel model, ISerializer serializer, INancyEnvironment environment);
    private string get_DefaultContentType();
    private string get_Encoding();
    private Action`1<Stream> GetXmlContents(TModel model, ISerializer serializer);
}
public class Nancy.RouteConfiguration : object {
    public static RouteConfiguration Default;
    [CompilerGeneratedAttribute]
private bool <DisableMethodNotAllowedResponses>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ExplicitHeadRouting>k__BackingField;
    public bool DisableMethodNotAllowedResponses { get; private set; }
    public bool ExplicitHeadRouting { get; private set; }
    public RouteConfiguration(bool disableMethodNotAllowedResponses, bool explicitHeadRouting);
    private static RouteConfiguration();
    [CompilerGeneratedAttribute]
public bool get_DisableMethodNotAllowedResponses();
    [CompilerGeneratedAttribute]
private void set_DisableMethodNotAllowedResponses(bool value);
    [CompilerGeneratedAttribute]
public bool get_ExplicitHeadRouting();
    [CompilerGeneratedAttribute]
private void set_ExplicitHeadRouting(bool value);
}
[ExtensionAttribute]
public static class Nancy.RouteConfigurationExtensions : object {
    [ExtensionAttribute]
public static void Routing(INancyEnvironment environment, Nullable`1<bool> disableMethodNotAllowedResponses, Nullable`1<bool> explicitHeadRouting);
}
public class Nancy.Routing.Constraints.AlphaRouteSegmentConstraint : RouteSegmentConstraintBase`1<string> {
    public string Name { get; }
    public virtual string get_Name();
    protected virtual bool TryMatch(string constraint, string segment, String& matchedValue);
}
public class Nancy.Routing.Constraints.BoolRouteSegmentConstraint : RouteSegmentConstraintBase`1<bool> {
    public string Name { get; }
    public virtual string get_Name();
    protected virtual bool TryMatch(string constraint, string segment, Boolean& matchedValue);
}
public class Nancy.Routing.Constraints.CustomDateTimeRouteSegmentConstraint : ParameterizedRouteSegmentConstraintBase`1<DateTime> {
    public string Name { get; }
    public virtual string get_Name();
    protected virtual bool TryMatch(string segment, String[] parameters, DateTime& matchedValue);
}
public class Nancy.Routing.Constraints.DateTimeRouteSegmentConstraint : RouteSegmentConstraintBase`1<DateTime> {
    public string Name { get; }
    public virtual string get_Name();
    protected virtual bool TryMatch(string constraint, string segment, DateTime& matchedValue);
}
public class Nancy.Routing.Constraints.DecimalRouteSegmentConstraint : RouteSegmentConstraintBase`1<decimal> {
    public string Name { get; }
    public virtual string get_Name();
    protected virtual bool TryMatch(string constraint, string segment, Decimal& matchedValue);
}
public class Nancy.Routing.Constraints.GuidRouteSegmentConstraint : RouteSegmentConstraintBase`1<Guid> {
    public string Name { get; }
    public virtual string get_Name();
    protected virtual bool TryMatch(string constraint, string segment, Guid& matchedValue);
}
public class Nancy.Routing.Constraints.IntRouteSegmentConstraint : RouteSegmentConstraintBase`1<int> {
    public string Name { get; }
    public virtual string get_Name();
    protected virtual bool TryMatch(string constraint, string segment, Int32& matchedValue);
}
public interface Nancy.Routing.Constraints.IRouteSegmentConstraint {
    public abstract virtual bool Matches(string constraint);
    public abstract virtual SegmentMatch GetMatch(string constraint, string segment, string parameterName);
}
public class Nancy.Routing.Constraints.LengthRouteSegmentConstraint : ParameterizedRouteSegmentConstraintBase`1<string> {
    public string Name { get; }
    public virtual string get_Name();
    protected virtual bool TryMatch(string segment, String[] parameters, String& matchedValue);
}
public class Nancy.Routing.Constraints.LongRouteSegmentConstraint : RouteSegmentConstraintBase`1<long> {
    public string Name { get; }
    public virtual string get_Name();
    protected virtual bool TryMatch(string constraint, string segment, Int64& matchedValue);
}
public class Nancy.Routing.Constraints.MaxLengthRouteSegmentConstraint : ParameterizedRouteSegmentConstraintBase`1<string> {
    public string Name { get; }
    public virtual string get_Name();
    protected virtual bool TryMatch(string segment, String[] parameters, String& matchedValue);
}
public class Nancy.Routing.Constraints.MaxRouteSegmentConstraint : ParameterizedRouteSegmentConstraintBase`1<int> {
    public string Name { get; }
    public virtual string get_Name();
    protected virtual bool TryMatch(string segment, String[] parameters, Int32& matchedValue);
}
public class Nancy.Routing.Constraints.MinLengthRouteSegmentConstraint : ParameterizedRouteSegmentConstraintBase`1<string> {
    public string Name { get; }
    public virtual string get_Name();
    protected virtual bool TryMatch(string segment, String[] parameters, String& matchedValue);
}
public class Nancy.Routing.Constraints.MinRouteSegmentConstraint : ParameterizedRouteSegmentConstraintBase`1<int> {
    public string Name { get; }
    public virtual string get_Name();
    protected virtual bool TryMatch(string segment, String[] parameters, Int32& matchedValue);
}
public abstract class Nancy.Routing.Constraints.ParameterizedRouteSegmentConstraintBase`1 : RouteSegmentConstraintBase`1<T> {
    public virtual bool Matches(string constraint);
    protected virtual bool TryMatch(string constraint, string segment, T& matchedValue);
    protected bool TryParseInt(string string, Int32& result);
    protected abstract virtual bool TryMatch(string segment, String[] parameters, T& matchedValue);
}
public class Nancy.Routing.Constraints.RangeRouteSegmentConstraint : ParameterizedRouteSegmentConstraintBase`1<int> {
    public string Name { get; }
    public virtual string get_Name();
    protected virtual bool TryMatch(string segment, String[] parameters, Int32& matchedValue);
}
public abstract class Nancy.Routing.Constraints.RouteSegmentConstraintBase`1 : object {
    public string Name { get; }
    public abstract virtual string get_Name();
    public virtual bool Matches(string constraint);
    public sealed virtual SegmentMatch GetMatch(string constraint, string segment, string parameterName);
    protected abstract virtual bool TryMatch(string constraint, string segment, T& matchedValue);
    private static SegmentMatch CreateMatch(string parameterName, object matchedValue);
}
public class Nancy.Routing.Constraints.VersionRouteSegmentConstraint : RouteSegmentConstraintBase`1<Version> {
    public string Name { get; }
    public virtual string get_Name();
    protected virtual bool TryMatch(string constraint, string segment, Version& matchedValue);
}
public class Nancy.Routing.DefaultNancyModuleBuilder : object {
    private IViewFactory viewFactory;
    private IResponseFormatterFactory responseFormatterFactory;
    private IModelBinderLocator modelBinderLocator;
    private IModelValidatorLocator validatorLocator;
    public DefaultNancyModuleBuilder(IViewFactory viewFactory, IResponseFormatterFactory responseFormatterFactory, IModelBinderLocator modelBinderLocator, IModelValidatorLocator validatorLocator);
    public sealed virtual INancyModule BuildModule(INancyModule module, NancyContext context);
}
public class Nancy.Routing.DefaultRequestDispatcher : object {
    private IRouteResolver routeResolver;
    private IEnumerable`1<IResponseProcessor> responseProcessors;
    private IRouteInvoker routeInvoker;
    private IResponseNegotiator negotiator;
    public DefaultRequestDispatcher(IRouteResolver routeResolver, IEnumerable`1<IResponseProcessor> responseProcessors, IRouteInvoker routeInvoker, IResponseNegotiator negotiator);
    [AsyncStateMachineAttribute("Nancy.Routing.DefaultRequestDispatcher/<Dispatch>d__5")]
public sealed virtual Task`1<Response> Dispatch(NancyContext context, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Nancy.Routing.DefaultRequestDispatcher/<ExecutePost>d__6")]
private Task ExecutePost(NancyContext context, CancellationToken cancellationToken, AfterPipeline postHook, Func`3<NancyContext, Exception, object> onError);
    private static Task`1<Response> ExecuteRoutePreReq(NancyContext context, CancellationToken cancellationToken, BeforePipeline resolveResultPreReq);
    private Response ResolveErrorResult(NancyContext context, Func`3<NancyContext, Exception, object> resolveResultOnError, Exception exception);
    private ResolveResult Resolve(NancyContext context);
    private IEnumerable`1<Tuple`2<string, decimal>> GetMediaRangesForExtension(string extension);
    private ResolveResult InvokeRouteResolver(NancyContext context, string path, IEnumerable`1<Tuple`2<string, decimal>> acceptHeaders);
}
public class Nancy.Routing.DefaultRouteCacheProvider : object {
    protected Func`1<IRouteCache> RouteCacheFactory;
    [CompilerGeneratedAttribute]
private object <DiagnosticObject>k__BackingField;
    public string Name { get; }
    public string Description { get; }
    public object DiagnosticObject { get; private set; }
    public DefaultRouteCacheProvider(Func`1<IRouteCache> routeCacheFactory);
    public sealed virtual string get_Name();
    public sealed virtual string get_Description();
    [CompilerGeneratedAttribute]
public sealed virtual object get_DiagnosticObject();
    [CompilerGeneratedAttribute]
private void set_DiagnosticObject(object value);
    public sealed virtual IRouteCache GetCache();
}
public class Nancy.Routing.DefaultRouteDescriptionProvider : object {
    public sealed virtual string GetDescription(INancyModule module, string path);
}
public class Nancy.Routing.DefaultRouteInvoker : object {
    private IResponseNegotiator negotiator;
    public DefaultRouteInvoker(IResponseNegotiator negotiator);
    [AsyncStateMachineAttribute("Nancy.Routing.DefaultRouteInvoker/<Invoke>d__2")]
public sealed virtual Task`1<Response> Invoke(Route route, CancellationToken cancellationToken, DynamicDictionary parameters, NancyContext context);
}
public class Nancy.Routing.DefaultRouteResolver : object {
    private INancyModuleCatalog catalog;
    private INancyModuleBuilder moduleBuilder;
    private IRouteCache routeCache;
    private IRouteResolverTrie trie;
    private Lazy`1<RouteConfiguration> configuration;
    private GlobalizationConfiguration globalizationConfiguraton;
    public DefaultRouteResolver(INancyModuleCatalog catalog, INancyModuleBuilder moduleBuilder, IRouteCache routeCache, IRouteResolverTrie trie, INancyEnvironment environment);
    public sealed virtual ResolveResult Resolve(NancyContext context);
    private static ResolveResult BuildMethodNotAllowedResult(NancyContext context, IEnumerable`1<string> allowedMethods);
    private bool IsMethodNotAllowed(IEnumerable`1<string> allowedMethods);
    private static bool IsOptionsRequest(NancyContext context);
    private void BuildTrie();
    private static ResolveResult BuildOptionsResult(IEnumerable`1<string> allowedMethods, NancyContext context);
    private ResolveResult BuildResult(NancyContext context, MatchResult result);
    private INancyModule GetModuleFromMatchResult(NancyContext context, MatchResult result);
    private static ResolveResult GetNotFoundResult(NancyContext context);
    private string GetMethod(NancyContext context);
}
public class Nancy.Routing.DefaultRouteSegmentExtractor : object {
    [IteratorStateMachineAttribute("Nancy.Routing.DefaultRouteSegmentExtractor/<Extract>d__0")]
public sealed virtual IEnumerable`1<string> Extract(string path);
}
public interface Nancy.Routing.INancyModuleBuilder {
    public abstract virtual INancyModule BuildModule(INancyModule module, NancyContext context);
}
public interface Nancy.Routing.IRequestDispatcher {
    public abstract virtual Task`1<Response> Dispatch(NancyContext context, CancellationToken cancellationToken);
}
public interface Nancy.Routing.IRouteCache {
    public abstract virtual bool IsEmpty();
}
public interface Nancy.Routing.IRouteCacheProvider {
    public abstract virtual IRouteCache GetCache();
}
public interface Nancy.Routing.IRouteDescriptionProvider {
    public abstract virtual string GetDescription(INancyModule module, string path);
}
public interface Nancy.Routing.IRouteInvoker {
    public abstract virtual Task`1<Response> Invoke(Route route, CancellationToken cancellationToken, DynamicDictionary parameters, NancyContext context);
}
public interface Nancy.Routing.IRouteMetadataProvider {
    public abstract virtual Type GetMetadataType(INancyModule module, RouteDescription routeDescription);
    public abstract virtual object GetMetadata(INancyModule module, RouteDescription routeDescription);
}
public interface Nancy.Routing.IRouteResolver {
    public abstract virtual ResolveResult Resolve(NancyContext context);
}
public interface Nancy.Routing.IRouteSegmentExtractor {
    public abstract virtual IEnumerable`1<string> Extract(string path);
}
public class Nancy.Routing.MethodNotAllowedRoute : Route`1<Response> {
    public MethodNotAllowedRoute(string path, string method, IEnumerable`1<string> allowedMethods);
    private static Task`1<Response> CreateMethodNotAllowedResponse(IEnumerable`1<string> allowedMethods);
}
public class Nancy.Routing.NotFoundRoute : Route`1<Response> {
    public NotFoundRoute(string method, string path);
}
public class Nancy.Routing.OptionsRoute : Route`1<Response> {
    public OptionsRoute(string path, IEnumerable`1<string> allowedMethods);
    private static Task`1<Response> CreateMethodOptionsResponse(IEnumerable`1<string> allowedMethods);
}
public class Nancy.Routing.ParameterSegmentInformation : object {
    [CompilerGeneratedAttribute]
private string <DefaultValue>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsOptional>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public string DefaultValue { get; private set; }
    public string FullSegmentName { get; }
    public bool IsOptional { get; private set; }
    public string Name { get; private set; }
    public ParameterSegmentInformation(string name, string defaultValue, bool isOptional);
    [CompilerGeneratedAttribute]
public string get_DefaultValue();
    [CompilerGeneratedAttribute]
private void set_DefaultValue(string value);
    public string get_FullSegmentName();
    [CompilerGeneratedAttribute]
public bool get_IsOptional();
    [CompilerGeneratedAttribute]
private void set_IsOptional(bool value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
}
public class Nancy.Routing.ResolveResult : object {
    [CompilerGeneratedAttribute]
private Route <Route>k__BackingField;
    [CompilerGeneratedAttribute]
private DynamicDictionary <Parameters>k__BackingField;
    [CompilerGeneratedAttribute]
private BeforePipeline <Before>k__BackingField;
    [CompilerGeneratedAttribute]
private AfterPipeline <After>k__BackingField;
    [CompilerGeneratedAttribute]
[DynamicAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Func`3<NancyContext, Exception, object> <OnError>k__BackingField;
    public Route Route { get; public set; }
    public DynamicDictionary Parameters { get; public set; }
    public BeforePipeline Before { get; public set; }
    public AfterPipeline After { get; public set; }
    [DynamicAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Func`3<NancyContext, Exception, object> OnError { get; public set; }
    public ResolveResult(Route route, DynamicDictionary parameters, BeforePipeline before, AfterPipeline after, Func`3<NancyContext, Exception, object> onError);
    [CompilerGeneratedAttribute]
public Route get_Route();
    [CompilerGeneratedAttribute]
public void set_Route(Route value);
    [CompilerGeneratedAttribute]
public DynamicDictionary get_Parameters();
    [CompilerGeneratedAttribute]
public void set_Parameters(DynamicDictionary value);
    [CompilerGeneratedAttribute]
public BeforePipeline get_Before();
    [CompilerGeneratedAttribute]
public void set_Before(BeforePipeline value);
    [CompilerGeneratedAttribute]
public AfterPipeline get_After();
    [CompilerGeneratedAttribute]
public void set_After(AfterPipeline value);
    [CompilerGeneratedAttribute]
public Func`3<NancyContext, Exception, object> get_OnError();
    [CompilerGeneratedAttribute]
public void set_OnError(Func`3<NancyContext, Exception, object> value);
}
public abstract class Nancy.Routing.Route : object {
    [CompilerGeneratedAttribute]
private RouteDescription <Description>k__BackingField;
    public RouteDescription Description { get; private set; }
    protected Route(RouteDescription description);
    protected Route(string name, string method, string path, Func`2<NancyContext, bool> condition, Type returnType);
    [CompilerGeneratedAttribute]
public RouteDescription get_Description();
    [CompilerGeneratedAttribute]
private void set_Description(RouteDescription value);
    public abstract virtual Task`1<object> Invoke(DynamicDictionary parameters, CancellationToken cancellationToken);
}
[DebuggerDisplayAttribute("{Description.DebuggerDisplay, nq}")]
public class Nancy.Routing.Route`1 : Route {
    [CompilerGeneratedAttribute]
private Func`3<object, CancellationToken, Task`1<T>> <Action>k__BackingField;
    public Func`3<object, CancellationToken, Task`1<T>> Action { get; public set; }
    public Route`1(RouteDescription description, Func`3<object, CancellationToken, Task`1<T>> action);
    public Route`1(string name, string method, string path, Func`2<NancyContext, bool> condition, Func`3<object, CancellationToken, Task`1<T>> action);
    public Route`1(string method, string path, Func`2<NancyContext, bool> condition, Func`3<object, CancellationToken, Task`1<T>> action);
    [CompilerGeneratedAttribute]
public Func`3<object, CancellationToken, Task`1<T>> get_Action();
    [CompilerGeneratedAttribute]
public void set_Action(Func`3<object, CancellationToken, Task`1<T>> value);
    [AsyncStateMachineAttribute("Nancy.Routing.Route`1/<Invoke>d__7")]
public virtual Task`1<object> Invoke(DynamicDictionary parameters, CancellationToken cancellationToken);
}
public class Nancy.Routing.RouteCache : Dictionary`2<Type, List`1<Tuple`2<int, RouteDescription>>> {
    private IRouteSegmentExtractor routeSegmentExtractor;
    private IRouteDescriptionProvider routeDescriptionProvider;
    private IEnumerable`1<IRouteMetadataProvider> routeMetadataProviders;
    public RouteCache(INancyModuleCatalog moduleCatalog, INancyContextFactory contextFactory, IRouteSegmentExtractor routeSegmentExtractor, IRouteDescriptionProvider routeDescriptionProvider, ICultureService cultureService, IEnumerable`1<IRouteMetadataProvider> routeMetadataProviders);
    public sealed virtual bool IsEmpty();
    private void BuildCache(IEnumerable`1<INancyModule> modules);
    private RouteMetadata GetRouteMetadata(INancyModule module, RouteDescription routeDescription);
    private void AddRoutesToCache(IEnumerable`1<RouteDescription> routes, Type moduleType);
}
[ExtensionAttribute]
public static class Nancy.Routing.RouteCacheExtensions : object {
    [ExtensionAttribute]
public static IEnumerable`1<TMetadata> RetrieveMetadata(IDictionary`2<Type, List`1<Tuple`2<int, RouteDescription>>> cache);
}
[DebuggerDisplayAttribute("{DebuggerDisplay, nq}")]
public class Nancy.Routing.RouteDescription : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<NancyContext, bool> <Condition>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private RouteMetadata <Metadata>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Method>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <Segments>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <ReturnType>k__BackingField;
    public string Name { get; public set; }
    public Func`2<NancyContext, bool> Condition { get; private set; }
    public string Description { get; public set; }
    public RouteMetadata Metadata { get; public set; }
    public string Method { get; private set; }
    public string Path { get; private set; }
    public IEnumerable`1<string> Segments { get; public set; }
    public Type ReturnType { get; private set; }
    private string DebuggerDisplay { get; }
    public RouteDescription(string name, string method, string path, Func`2<NancyContext, bool> condition, Type returnType);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public Func`2<NancyContext, bool> get_Condition();
    [CompilerGeneratedAttribute]
private void set_Condition(Func`2<NancyContext, bool> value);
    [CompilerGeneratedAttribute]
public string get_Description();
    [CompilerGeneratedAttribute]
public void set_Description(string value);
    [CompilerGeneratedAttribute]
public RouteMetadata get_Metadata();
    [CompilerGeneratedAttribute]
public void set_Metadata(RouteMetadata value);
    [CompilerGeneratedAttribute]
public string get_Method();
    [CompilerGeneratedAttribute]
private void set_Method(string value);
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
private void set_Path(string value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_Segments();
    [CompilerGeneratedAttribute]
public void set_Segments(IEnumerable`1<string> value);
    [CompilerGeneratedAttribute]
public Type get_ReturnType();
    [CompilerGeneratedAttribute]
private void set_ReturnType(Type value);
    private string get_DebuggerDisplay();
}
public class Nancy.Routing.RouteMetadata : object {
    [CompilerGeneratedAttribute]
private IDictionary`2<Type, object> <Raw>k__BackingField;
    public IDictionary`2<Type, object> Raw { get; private set; }
    public RouteMetadata(IDictionary`2<Type, object> metadata);
    [CompilerGeneratedAttribute]
public IDictionary`2<Type, object> get_Raw();
    [CompilerGeneratedAttribute]
private void set_Raw(IDictionary`2<Type, object> value);
    public bool Has();
    public TMetadata Retrieve();
}
public abstract class Nancy.Routing.RouteMetadataProvider`1 : object {
    public sealed virtual Type GetMetadataType(INancyModule module, RouteDescription routeDescription);
    public sealed virtual object GetMetadata(INancyModule module, RouteDescription routeDescription);
    protected abstract virtual TMetadata GetRouteMetadata(INancyModule module, RouteDescription routeDescription);
}
public interface Nancy.Routing.Trie.IRouteResolverTrie {
    public abstract virtual void BuildTrie(IRouteCache cache);
    public abstract virtual MatchResult[] GetMatches(string method, string path, NancyContext context);
    public abstract virtual IEnumerable`1<string> GetOptions(string path, NancyContext context);
}
public interface Nancy.Routing.Trie.ITrieNodeFactory {
    public abstract virtual TrieNode GetNodeForSegment(TrieNode parent, string segment);
}
public class Nancy.Routing.Trie.MatchResult : NodeData {
    private static MatchResult noMatch;
    private static MatchResult[] noMatches;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, object> <Parameters>k__BackingField;
    public IDictionary`2<string, object> Parameters { get; public set; }
    public static MatchResult NoMatch { get; }
    public static MatchResult[] NoMatches { get; }
    public MatchResult(IDictionary`2<string, object> parameters);
    private static MatchResult();
    [CompilerGeneratedAttribute]
public IDictionary`2<string, object> get_Parameters();
    [CompilerGeneratedAttribute]
public void set_Parameters(IDictionary`2<string, object> value);
    public static MatchResult get_NoMatch();
    public static MatchResult[] get_NoMatches();
    public sealed virtual int CompareTo(MatchResult other);
}
public class Nancy.Routing.Trie.NodeData : object {
    [CompilerGeneratedAttribute]
private Type <ModuleType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Method>k__BackingField;
    [CompilerGeneratedAttribute]
private int <RouteIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private int <RouteLength>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Score>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<NancyContext, bool> <Condition>k__BackingField;
    public Type ModuleType { get; public set; }
    public string Method { get; public set; }
    public int RouteIndex { get; public set; }
    public int RouteLength { get; public set; }
    public int Score { get; public set; }
    public Func`2<NancyContext, bool> Condition { get; public set; }
    [CompilerGeneratedAttribute]
public Type get_ModuleType();
    [CompilerGeneratedAttribute]
public void set_ModuleType(Type value);
    [CompilerGeneratedAttribute]
public string get_Method();
    [CompilerGeneratedAttribute]
public void set_Method(string value);
    [CompilerGeneratedAttribute]
public int get_RouteIndex();
    [CompilerGeneratedAttribute]
public void set_RouteIndex(int value);
    [CompilerGeneratedAttribute]
public int get_RouteLength();
    [CompilerGeneratedAttribute]
public void set_RouteLength(int value);
    [CompilerGeneratedAttribute]
public int get_Score();
    [CompilerGeneratedAttribute]
public void set_Score(int value);
    [CompilerGeneratedAttribute]
public Func`2<NancyContext, bool> get_Condition();
    [CompilerGeneratedAttribute]
public void set_Condition(Func`2<NancyContext, bool> value);
}
[ExtensionAttribute]
public static class Nancy.Routing.Trie.NodeDataExtensions : object {
    [ExtensionAttribute]
public static MatchResult ToResult(NodeData data, IDictionary`2<string, object> parameters);
}
public class Nancy.Routing.Trie.Nodes.CaptureNode : TrieNode {
    private string parameterName;
    public int Score { get; }
    public CaptureNode(TrieNode parent, string segment, ITrieNodeFactory nodeFactory);
    public virtual int get_Score();
    public virtual SegmentMatch Match(string segment);
    private void ExtractParameterName();
}
public class Nancy.Routing.Trie.Nodes.CaptureNodeWithConstraint : TrieNode {
    private IEnumerable`1<IRouteSegmentConstraint> routeSegmentConstraints;
    private string parameterName;
    private string constraint;
    public int Score { get; }
    public CaptureNodeWithConstraint(TrieNode parent, string segment, ITrieNodeFactory nodeFactory, IEnumerable`1<IRouteSegmentConstraint> routeSegmentConstraints);
    public virtual int get_Score();
    public virtual SegmentMatch Match(string segment);
    private void ExtractParameterName();
    [CompilerGeneratedAttribute]
private bool <Match>b__6_0(IRouteSegmentConstraint x);
}
public class Nancy.Routing.Trie.Nodes.CaptureNodeWithDefaultValue : CaptureNode {
    private string parameterName;
    private string defaultValue;
    public int Score { get; }
    public CaptureNodeWithDefaultValue(TrieNode parent, string segment, ITrieNodeFactory nodeFactory);
    public virtual int get_Score();
    public virtual void Add(String[] segments, int currentIndex, int currentScore, int nodeCount, Type moduleType, int routeIndex, RouteDescription routeDescription);
    public virtual SegmentMatch Match(string segment);
    private void ExtractParameterNameAndDefaultValue();
}
public class Nancy.Routing.Trie.Nodes.CaptureNodeWithMultipleParameters : TrieNode {
    private static Regex MatchRegex;
    private List`1<string> parameterNames;
    private List`1<string> constraints;
    private string builtRegex;
    private IEnumerable`1<IRouteSegmentConstraint> routeSegmentConstraints;
    private static string AssertStart;
    private static string MatchParameter;
    private static string AssertEnd;
    public int Score { get; }
    public CaptureNodeWithMultipleParameters(TrieNode parent, string segment, ITrieNodeFactory nodeFactory, IEnumerable`1<IRouteSegmentConstraint> routeSegmentConstraints);
    private static CaptureNodeWithMultipleParameters();
    public static bool IsMatch(string segment);
    private static bool IsParameterCapture(Capture match);
    public virtual int get_Score();
    public virtual SegmentMatch Match(string segment);
    private void ExtractParameterNames();
    private void BuildRegex(string regexSegment);
}
public class Nancy.Routing.Trie.Nodes.GreedyCaptureNode : TrieNode {
    private string parameterName;
    public int Score { get; }
    public GreedyCaptureNode(TrieNode parent, string segment, ITrieNodeFactory nodeFactory);
    public virtual int get_Score();
    public virtual IEnumerable`1<MatchResult> GetMatches(String[] segments, int currentIndex, IDictionary`2<string, object> capturedParameters, NancyContext context);
    public virtual SegmentMatch Match(string segment);
    private IEnumerable`1<MatchResult> GetFullGreedy(String[] segments, int currentIndex, IDictionary`2<string, object> capturedParameters);
    private void GetParameterName();
}
public class Nancy.Routing.Trie.Nodes.GreedyRegExCaptureNode : TrieNode {
    private Regex expression;
    private String[] groupNames;
    public int Score { get; }
    public GreedyRegExCaptureNode(TrieNode parent, string segment, ITrieNodeFactory nodeFactory);
    public virtual int get_Score();
    public virtual IEnumerable`1<MatchResult> GetMatches(String[] segments, int currentIndex, IDictionary`2<string, object> capturedParameters, NancyContext context);
    public virtual SegmentMatch Match(string segment);
    private void BuildRegEx();
}
public class Nancy.Routing.Trie.Nodes.LiteralNode : TrieNode {
    public int Score { get; }
    public LiteralNode(TrieNode parent, string segment, ITrieNodeFactory nodeFactory);
    public virtual int get_Score();
    public virtual SegmentMatch Match(string segment);
}
public class Nancy.Routing.Trie.Nodes.OptionalCaptureNode : TrieNode {
    private string parameterName;
    public int Score { get; }
    public OptionalCaptureNode(TrieNode parent, string segment, ITrieNodeFactory nodeFactory);
    public virtual int get_Score();
    public virtual void Add(String[] segments, int currentIndex, int currentScore, int nodeCount, Type moduleType, int routeIndex, RouteDescription routeDescription);
    public virtual SegmentMatch Match(string segment);
    private void ExtractParameterName();
}
public class Nancy.Routing.Trie.Nodes.RegExNode : TrieNode {
    private Regex expression;
    private String[] groupNames;
    public int Score { get; }
    public RegExNode(TrieNode parent, string segment, ITrieNodeFactory nodeFactory);
    public virtual int get_Score();
    public virtual SegmentMatch Match(string segment);
    private void BuildRegEx();
}
public class Nancy.Routing.Trie.Nodes.RootNode : TrieNode {
    private SegmentMatch segmentMatch;
    private Dictionary`2<string, object> localCaptures;
    public int Score { get; }
    public RootNode(ITrieNodeFactory nodeFactory);
    public virtual int get_Score();
    public virtual IEnumerable`1<MatchResult> GetMatches(String[] segments, int currentIndex, IDictionary`2<string, object> capturedParameters, NancyContext context);
    public virtual SegmentMatch Match(string segment);
}
public abstract class Nancy.Routing.Trie.Nodes.TrieNode : object {
    private ITrieNodeFactory nodeFactory;
    [CompilerGeneratedAttribute]
private TrieNode <Parent>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RouteDefinitionSegment>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, TrieNode> <Children>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<NodeData> <NodeData>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, object> <AdditionalParameters>k__BackingField;
    public TrieNode Parent { get; protected set; }
    public string RouteDefinitionSegment { get; protected set; }
    public IDictionary`2<string, TrieNode> Children { get; protected set; }
    public IList`1<NodeData> NodeData { get; protected set; }
    public IDictionary`2<string, object> AdditionalParameters { get; protected set; }
    public int Score { get; }
    protected TrieNode(TrieNode parent, string segment, ITrieNodeFactory nodeFactory);
    [CompilerGeneratedAttribute]
public TrieNode get_Parent();
    [CompilerGeneratedAttribute]
protected void set_Parent(TrieNode value);
    [CompilerGeneratedAttribute]
public string get_RouteDefinitionSegment();
    [CompilerGeneratedAttribute]
protected void set_RouteDefinitionSegment(string value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, TrieNode> get_Children();
    [CompilerGeneratedAttribute]
protected void set_Children(IDictionary`2<string, TrieNode> value);
    [CompilerGeneratedAttribute]
public IList`1<NodeData> get_NodeData();
    [CompilerGeneratedAttribute]
protected void set_NodeData(IList`1<NodeData> value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, object> get_AdditionalParameters();
    [CompilerGeneratedAttribute]
protected void set_AdditionalParameters(IDictionary`2<string, object> value);
    public abstract virtual int get_Score();
    public void Add(String[] segments, Type moduleType, int routeIndex, RouteDescription routeDescription);
    public virtual void Add(String[] segments, int currentIndex, int currentScore, int nodeCount, Type moduleType, int routeIndex, RouteDescription routeDescription);
    public virtual IEnumerable`1<MatchResult> GetMatches(String[] segments, NancyContext context);
    public virtual IEnumerable`1<MatchResult> GetMatches(String[] segments, int currentIndex, IDictionary`2<string, object> capturedParameters, NancyContext context);
    public virtual IEnumerable`1<string> GetRoutes();
    protected virtual NodeData BuildNodeData(int nodeCount, int score, Type moduleType, int routeIndex, RouteDescription routeDescription);
    protected bool NoMoreSegments(String[] segments, int currentIndex);
    protected IEnumerable`1<MatchResult> BuildResults(IDictionary`2<string, object> capturedParameters, IDictionary`2<string, object> localCaptures);
    [IteratorStateMachineAttribute("Nancy.Routing.Trie.Nodes.TrieNode/<GetMatchingChildren>d__32")]
protected IEnumerable`1<MatchResult> GetMatchingChildren(String[] segments, int currentIndex, IDictionary`2<string, object> capturedParameters, IDictionary`2<string, object> localCaptures, NancyContext context);
    public abstract virtual SegmentMatch Match(string segment);
    [CompilerGeneratedAttribute]
private string <GetRoutes>b__28_1(string s);
}
public class Nancy.Routing.Trie.RouteResolverTrie : object {
    private ITrieNodeFactory nodeFactory;
    private IDictionary`2<string, TrieNode> routeTries;
    private static Char[] splitSeparators;
    public RouteResolverTrie(ITrieNodeFactory nodeFactory);
    private static RouteResolverTrie();
    public sealed virtual void BuildTrie(IRouteCache cache);
    public sealed virtual MatchResult[] GetMatches(string method, string path, NancyContext context);
    [IteratorStateMachineAttribute("Nancy.Routing.Trie.RouteResolverTrie/<GetOptions>d__6")]
public sealed virtual IEnumerable`1<string> GetOptions(string path, NancyContext context);
    public virtual string ToString();
}
public class Nancy.Routing.Trie.SegmentMatch : object {
    private static SegmentMatch noMatch;
    [CompilerGeneratedAttribute]
private bool <Matches>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, object> <CapturedParameters>k__BackingField;
    public bool Matches { get; private set; }
    public static SegmentMatch NoMatch { get; }
    public IDictionary`2<string, object> CapturedParameters { get; private set; }
    public SegmentMatch(bool matches);
    private static SegmentMatch();
    [CompilerGeneratedAttribute]
public bool get_Matches();
    [CompilerGeneratedAttribute]
private void set_Matches(bool value);
    public static SegmentMatch get_NoMatch();
    [CompilerGeneratedAttribute]
public IDictionary`2<string, object> get_CapturedParameters();
    [CompilerGeneratedAttribute]
private void set_CapturedParameters(IDictionary`2<string, object> value);
}
public class Nancy.Routing.Trie.TrieNodeFactory : object {
    private IEnumerable`1<IRouteSegmentConstraint> routeSegmentConstraints;
    public TrieNodeFactory(IEnumerable`1<IRouteSegmentConstraint> routeSegmentConstraints);
    public virtual TrieNode GetNodeForSegment(TrieNode parent, string segment);
    private TrieNode GetCaptureNode(TrieNode parent, string segment);
}
[ExtensionAttribute]
public static class Nancy.Security.ClaimsPrincipalExtensions : object {
    [ExtensionAttribute]
public static bool IsAuthenticated(ClaimsPrincipal user);
    [ExtensionAttribute]
public static bool HasClaims(ClaimsPrincipal user, Predicate`1[] requiredClaims);
    [ExtensionAttribute]
public static bool HasAnyClaim(ClaimsPrincipal user, Predicate`1[] requiredClaims);
    [ExtensionAttribute]
public static bool HasValidClaims(ClaimsPrincipal user, Func`2<IEnumerable`1<Claim>, bool> isValid);
}
[ExtensionAttribute]
public static class Nancy.Security.Csrf : object {
    private static string CsrfHookName;
    private static char ValueDelimiter;
    private static char PairDelimiter;
    public static void Enable(IPipelines pipelines, CryptographyConfiguration cryptographyConfiguration, bool useSecureCookie);
    public static void Disable(IPipelines pipelines);
    [ExtensionAttribute]
public static void CreateNewCsrfToken(INancyModule module, CryptographyConfiguration cryptographyConfiguration);
    internal static string GenerateTokenString(CryptographyConfiguration cryptographyConfiguration);
    [ExtensionAttribute]
public static void ValidateCsrfToken(INancyModule module, Nullable`1<TimeSpan> validityPeriod);
    private static CsrfToken GetProvidedToken(Request request);
    private static CsrfToken GetCookieToken(Request request);
    private static void AddTokenValue(Dictionary`2<string, string> dictionary, string key, string value);
    private static CsrfToken ParseToCsrfToken(string cookieTokenString);
}
public class Nancy.Security.CsrfApplicationStartup : object {
    [CompilerGeneratedAttribute]
private static CryptographyConfiguration <CryptographyConfiguration>k__BackingField;
    [CompilerGeneratedAttribute]
private static ICsrfTokenValidator <TokenValidator>k__BackingField;
    internal static CryptographyConfiguration CryptographyConfiguration { get; private set; }
    internal static ICsrfTokenValidator TokenValidator { get; private set; }
    public CsrfApplicationStartup(CryptographyConfiguration cryptographyConfiguration, ICsrfTokenValidator tokenValidator);
    [CompilerGeneratedAttribute]
internal static CryptographyConfiguration get_CryptographyConfiguration();
    [CompilerGeneratedAttribute]
private static void set_CryptographyConfiguration(CryptographyConfiguration value);
    [CompilerGeneratedAttribute]
internal static ICsrfTokenValidator get_TokenValidator();
    [CompilerGeneratedAttribute]
private static void set_TokenValidator(ICsrfTokenValidator value);
    public sealed virtual void Initialize(IPipelines pipelines);
}
public class Nancy.Security.CsrfToken : object {
    public static string DEFAULT_CSRF_KEY;
    [CompilerGeneratedAttribute]
private Byte[] <RandomBytes>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <CreatedDate>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <Hmac>k__BackingField;
    public Byte[] RandomBytes { get; public set; }
    public DateTimeOffset CreatedDate { get; public set; }
    public Byte[] Hmac { get; public set; }
    [CompilerGeneratedAttribute]
public Byte[] get_RandomBytes();
    [CompilerGeneratedAttribute]
public void set_RandomBytes(Byte[] value);
    [CompilerGeneratedAttribute]
public DateTimeOffset get_CreatedDate();
    [CompilerGeneratedAttribute]
public void set_CreatedDate(DateTimeOffset value);
    [CompilerGeneratedAttribute]
public Byte[] get_Hmac();
    [CompilerGeneratedAttribute]
public void set_Hmac(Byte[] value);
    public bool Equals(CsrfToken other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(CsrfToken left, CsrfToken right);
    public static bool op_Inequality(CsrfToken left, CsrfToken right);
}
[ExtensionAttribute]
public static class Nancy.Security.CsrfTokenExtensions : object {
    private static RandomNumberGenerator randomGenerator;
    private static CsrfTokenExtensions();
    [ExtensionAttribute]
public static Byte[] GetCsrfTokenBytes(CsrfToken token);
    [ExtensionAttribute]
public static void CreateHmac(CsrfToken token, IHmacProvider hmacProvider);
    [ExtensionAttribute]
public static void CreateRandomBytes(CsrfToken token);
}
public enum Nancy.Security.CsrfTokenValidationResult : Enum {
    public int value__;
    public static CsrfTokenValidationResult Ok;
    public static CsrfTokenValidationResult TokenTamperedWith;
    public static CsrfTokenValidationResult TokenMissing;
    public static CsrfTokenValidationResult TokenMismatch;
    public static CsrfTokenValidationResult TokenExpired;
}
public class Nancy.Security.CsrfValidationException : Exception {
    [CompilerGeneratedAttribute]
private CsrfTokenValidationResult <Result>k__BackingField;
    public CsrfTokenValidationResult Result { get; private set; }
    public CsrfValidationException(CsrfTokenValidationResult result);
    [CompilerGeneratedAttribute]
public CsrfTokenValidationResult get_Result();
    [CompilerGeneratedAttribute]
private void set_Result(CsrfTokenValidationResult value);
}
public class Nancy.Security.DefaultCsrfTokenValidator : object {
    private IHmacProvider hmacProvider;
    public DefaultCsrfTokenValidator(CryptographyConfiguration cryptoConfig);
    public sealed virtual CsrfTokenValidationResult Validate(CsrfToken tokenOne, CsrfToken tokenTwo, Nullable`1<TimeSpan> validityPeriod);
    public sealed virtual bool CookieTokenStillValid(CsrfToken cookieToken);
}
public interface Nancy.Security.ICsrfTokenValidator {
    public abstract virtual CsrfTokenValidationResult Validate(CsrfToken tokenOne, CsrfToken tokenTwo, Nullable`1<TimeSpan> validityPeriod);
    public abstract virtual bool CookieTokenStillValid(CsrfToken cookieToken);
}
[ExtensionAttribute]
public static class Nancy.Security.ModuleSecurity : object {
    [ExtensionAttribute]
public static void RequiresAuthentication(INancyModule module);
    [ExtensionAttribute]
public static void RequiresClaims(INancyModule module, Predicate`1[] requiredClaims);
    [ExtensionAttribute]
public static void RequiresAnyClaim(INancyModule module, Predicate`1[] requiredClaims);
    [ExtensionAttribute]
public static void RequiresHttps(INancyModule module);
    [ExtensionAttribute]
public static void RequiresHttps(INancyModule module, bool redirect);
    [ExtensionAttribute]
public static void RequiresHttps(INancyModule module, bool redirect, int httpsPort);
}
public static class Nancy.Security.SecurityHooks : object {
    public static Func`2<NancyContext, Response> RequiresAuthentication();
    public static Func`2<NancyContext, Response> RequiresClaims(Predicate`1[] claims);
    public static Func`2<NancyContext, Response> RequiresAnyClaim(Predicate`1[] claims);
    public static Func`2<NancyContext, Response> RequiresValidatedClaims(Func`2<IEnumerable`1<Claim>, bool> isValid);
    private static Func`2<NancyContext, Response> UnauthorizedIfNot(Func`2<NancyContext, bool> test);
    private static Func`2<NancyContext, Response> ForbiddenIfNot(Func`2<NancyContext, bool> test);
    private static Func`2<NancyContext, Response> HttpStatusCodeIfNot(HttpStatusCode statusCode, Func`2<NancyContext, bool> test);
    public static Func`2<NancyContext, Response> RequiresHttps(bool redirect, Nullable`1<int> httpsPort);
}
public static class Nancy.Security.SSLProxy : object {
    public static void RewriteSchemeUsingForwardedHeaders(IPipelines pipelines);
}
public class Nancy.Session.CookieBasedSessions : object {
    private CookieBasedSessionsConfiguration currentConfiguration;
    public string CookieName { get; }
    public CookieBasedSessions(IEncryptionProvider encryptionProvider, IHmacProvider hmacProvider, IObjectSerializer objectSerializer);
    public CookieBasedSessions(CookieBasedSessionsConfiguration configuration);
    public string get_CookieName();
    public static IObjectSerializerSelector Enable(IPipelines pipelines, CookieBasedSessionsConfiguration configuration);
    public static IObjectSerializerSelector Enable(IPipelines pipelines, CryptographyConfiguration cryptographyConfiguration);
    public static IObjectSerializerSelector Enable(IPipelines pipelines);
    public sealed virtual void WithSerializer(IObjectSerializer newSerializer);
    public void Save(ISession session, Response response);
    public ISession Load(Request request);
    private static void SaveSession(NancyContext context, CookieBasedSessions sessionStore);
    private static Response LoadSession(NancyContext context, CookieBasedSessions sessionStore);
    private sealed virtual override Type Nancy.IHideObjectMembers.GetType();
}
public class Nancy.Session.CookieBasedSessionsConfiguration : object {
    internal static string DefaultCookieName;
    [CompilerGeneratedAttribute]
private CryptographyConfiguration <CryptographyConfiguration>k__BackingField;
    [CompilerGeneratedAttribute]
private IObjectSerializer <Serializer>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CookieName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Domain>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    public CryptographyConfiguration CryptographyConfiguration { get; public set; }
    public IObjectSerializer Serializer { get; public set; }
    public string CookieName { get; public set; }
    public string Domain { get; public set; }
    public string Path { get; public set; }
    public bool IsValid { get; }
    public CookieBasedSessionsConfiguration(CryptographyConfiguration cryptographyConfiguration);
    [CompilerGeneratedAttribute]
public CryptographyConfiguration get_CryptographyConfiguration();
    [CompilerGeneratedAttribute]
public void set_CryptographyConfiguration(CryptographyConfiguration value);
    [CompilerGeneratedAttribute]
public IObjectSerializer get_Serializer();
    [CompilerGeneratedAttribute]
public void set_Serializer(IObjectSerializer value);
    [CompilerGeneratedAttribute]
public string get_CookieName();
    [CompilerGeneratedAttribute]
public void set_CookieName(string value);
    [CompilerGeneratedAttribute]
public string get_Domain();
    [CompilerGeneratedAttribute]
public void set_Domain(string value);
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
public void set_Path(string value);
    public virtual bool get_IsValid();
}
[DefaultMemberAttribute("Item")]
public interface Nancy.Session.ISession {
    public int Count { get; }
    public object Item { get; public set; }
    public bool HasChanged { get; }
    public abstract virtual int get_Count();
    public abstract virtual void DeleteAll();
    public abstract virtual void Delete(string key);
    public abstract virtual object get_Item(string key);
    public abstract virtual void set_Item(string key, object value);
    public abstract virtual bool get_HasChanged();
}
[DefaultMemberAttribute("Item")]
public class Nancy.Session.NullSessionProvider : object {
    public int Count { get; }
    public object Item { get; public set; }
    public bool HasChanged { get; }
    public sealed virtual IEnumerator`1<KeyValuePair`2<string, object>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual int get_Count();
    public sealed virtual void DeleteAll();
    public sealed virtual void Delete(string key);
    public sealed virtual object get_Item(string key);
    public sealed virtual void set_Item(string key, object value);
    public sealed virtual bool get_HasChanged();
}
[DefaultMemberAttribute("Item")]
public class Nancy.Session.Session : object {
    private IDictionary`2<string, object> dictionary;
    private bool hasChanged;
    public int Count { get; }
    public object Item { get; public set; }
    public bool HasChanged { get; }
    public Session(IDictionary`2<string, object> dictionary);
    public sealed virtual int get_Count();
    public sealed virtual void DeleteAll();
    public sealed virtual void Delete(string key);
    public sealed virtual object get_Item(string key);
    public sealed virtual void set_Item(string key, object value);
    public sealed virtual bool get_HasChanged();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual IEnumerator`1<KeyValuePair`2<string, object>> GetEnumerator();
    private void MarkAsChanged();
}
[GeneratedCodeAttribute("simple-json", "1.0.0")]
internal static class Nancy.SimpleJson : object {
    private static int TOKEN_NONE;
    private static int TOKEN_CURLY_OPEN;
    private static int TOKEN_CURLY_CLOSE;
    private static int TOKEN_SQUARED_OPEN;
    private static int TOKEN_SQUARED_CLOSE;
    private static int TOKEN_COLON;
    private static int TOKEN_COMMA;
    private static int TOKEN_STRING;
    private static int TOKEN_NUMBER;
    private static int TOKEN_TRUE;
    private static int TOKEN_FALSE;
    private static int TOKEN_NULL;
    private static int BUILDER_CAPACITY;
    private static Char[] EscapeTable;
    private static Char[] EscapeCharacters;
    private static string EscapeCharactersString;
    private static IJsonSerializerStrategy _currentJsonSerializerStrategy;
    private static PocoJsonSerializerStrategy _pocoJsonSerializerStrategy;
    public static IJsonSerializerStrategy CurrentJsonSerializerStrategy { get; public set; }
    [EditorBrowsableAttribute("2")]
public static PocoJsonSerializerStrategy PocoJsonSerializerStrategy { get; }
    private static SimpleJson();
    public static object DeserializeObject(string json);
    public static bool TryDeserializeObject(string json, Object& obj);
    public static object DeserializeObject(string json, Type type, IJsonSerializerStrategy jsonSerializerStrategy);
    public static object DeserializeObject(string json, Type type);
    public static T DeserializeObject(string json, IJsonSerializerStrategy jsonSerializerStrategy);
    public static T DeserializeObject(string json);
    public static string SerializeObject(object json, IJsonSerializerStrategy jsonSerializerStrategy);
    public static string SerializeObject(object json);
    public static string EscapeToJavascriptString(string jsonString);
    private static IDictionary`2<string, object> ParseObject(Char[] json, Int32& index, Boolean& success);
    private static JsonArray ParseArray(Char[] json, Int32& index, Boolean& success);
    private static object ParseValue(Char[] json, Int32& index, Boolean& success);
    private static string ParseString(Char[] json, Int32& index, Boolean& success);
    private static string ConvertFromUtf32(int utf32);
    private static object ParseNumber(Char[] json, Int32& index, Boolean& success);
    private static int GetLastIndexOfNumber(Char[] json, int index);
    private static void EatWhitespace(Char[] json, Int32& index);
    private static int LookAhead(Char[] json, int index);
    private static int NextToken(Char[] json, Int32& index);
    private static bool SerializeValue(IJsonSerializerStrategy jsonSerializerStrategy, object value, StringBuilder builder);
    private static bool SerializeObject(IJsonSerializerStrategy jsonSerializerStrategy, IEnumerable keys, IEnumerable values, StringBuilder builder);
    private static bool SerializeArray(IJsonSerializerStrategy jsonSerializerStrategy, IEnumerable anArray, StringBuilder builder);
    private static bool SerializeString(string aString, StringBuilder builder);
    private static bool SerializeNumber(object number, StringBuilder builder);
    private static bool IsNumeric(object value);
    public static IJsonSerializerStrategy get_CurrentJsonSerializerStrategy();
    public static void set_CurrentJsonSerializerStrategy(IJsonSerializerStrategy value);
    public static PocoJsonSerializerStrategy get_PocoJsonSerializerStrategy();
}
public static class Nancy.StaticConfiguration : object {
    [CompilerGeneratedAttribute]
private static bool <CaseSensitive>k__BackingField;
    [CompilerGeneratedAttribute]
private static int <RequestQueryFormMultipartLimit>k__BackingField;
    [CompilerGeneratedAttribute]
private static Nullable`1<bool> <DisableRequestStreamSwitching>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <AllowFileStreamUploadAsync>k__BackingField;
    [DescriptionAttribute("Enable case sensitivity in query, parameters (DynamicDictionary) and model binding. Enable this to conform with RFC3986.")]
public static bool CaseSensitive { get; public set; }
    public static int RequestQueryFormMultipartLimit { get; public set; }
    public static Nullable`1<bool> DisableRequestStreamSwitching { get; public set; }
    public static bool AllowFileStreamUploadAsync { get; public set; }
    private static StaticConfiguration();
    [CompilerGeneratedAttribute]
public static bool get_CaseSensitive();
    [CompilerGeneratedAttribute]
public static void set_CaseSensitive(bool value);
    [CompilerGeneratedAttribute]
public static int get_RequestQueryFormMultipartLimit();
    [CompilerGeneratedAttribute]
public static void set_RequestQueryFormMultipartLimit(int value);
    [CompilerGeneratedAttribute]
public static Nullable`1<bool> get_DisableRequestStreamSwitching();
    [CompilerGeneratedAttribute]
public static void set_DisableRequestStreamSwitching(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public static bool get_AllowFileStreamUploadAsync();
    [CompilerGeneratedAttribute]
public static void set_AllowFileStreamUploadAsync(bool value);
}
public class Nancy.StaticContent : object {
    private static IRootPathProvider rootPathProvider;
    private static StaticContentsConventions conventions;
    public StaticContent(IRootPathProvider rootPathProvider, StaticContentsConventions conventions);
    public sealed virtual void Initialize(IPipelines pipelines);
    public static void Enable(IPipelines pipelines);
}
public class Nancy.StaticContentConfiguration : object {
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <SafePaths>k__BackingField;
    public IEnumerable`1<string> SafePaths { get; private set; }
    public StaticContentConfiguration(IEnumerable`1<string> safePaths);
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_SafePaths();
    [CompilerGeneratedAttribute]
private void set_SafePaths(IEnumerable`1<string> value);
}
[ExtensionAttribute]
public static class Nancy.StaticContentConfigurationExtensions : object {
    [ExtensionAttribute]
public static void StaticContent(INancyEnvironment environment, String[] safepaths);
}
[ExtensionAttribute]
public static class Nancy.TinyIoc.AssemblyExtensions : object {
    [ExtensionAttribute]
public static Type[] SafeGetTypes(Assembly assembly);
}
public enum Nancy.TinyIoc.DuplicateImplementationActions : Enum {
    public int value__;
    public static DuplicateImplementationActions RegisterSingle;
    public static DuplicateImplementationActions RegisterMultiple;
    public static DuplicateImplementationActions Fail;
}
public class Nancy.TinyIoc.NamedParameterOverloads : Dictionary`2<string, object> {
    private static NamedParameterOverloads _Default;
    public static NamedParameterOverloads Default { get; }
    public NamedParameterOverloads(IDictionary`2<string, object> data);
    private static NamedParameterOverloads();
    public static NamedParameterOverloads FromIDictionary(IDictionary`2<string, object> data);
    public static NamedParameterOverloads get_Default();
}
public enum Nancy.TinyIoc.NamedResolutionFailureActions : Enum {
    public int value__;
    public static NamedResolutionFailureActions AttemptUnnamedResolution;
    public static NamedResolutionFailureActions Fail;
}
public class Nancy.TinyIoc.ResolveOptions : object {
    private static ResolveOptions _Default;
    private static ResolveOptions _FailUnregisteredAndNameNotFound;
    private static ResolveOptions _FailUnregisteredOnly;
    private static ResolveOptions _FailNameNotFoundOnly;
    private UnregisteredResolutionActions _UnregisteredResolutionAction;
    private NamedResolutionFailureActions _NamedResolutionFailureAction;
    public UnregisteredResolutionActions UnregisteredResolutionAction { get; public set; }
    public NamedResolutionFailureActions NamedResolutionFailureAction { get; public set; }
    public static ResolveOptions Default { get; }
    public static ResolveOptions FailNameNotFoundOnly { get; }
    public static ResolveOptions FailUnregisteredAndNameNotFound { get; }
    public static ResolveOptions FailUnregisteredOnly { get; }
    private static ResolveOptions();
    public UnregisteredResolutionActions get_UnregisteredResolutionAction();
    public void set_UnregisteredResolutionAction(UnregisteredResolutionActions value);
    public NamedResolutionFailureActions get_NamedResolutionFailureAction();
    public void set_NamedResolutionFailureAction(NamedResolutionFailureActions value);
    public static ResolveOptions get_Default();
    public static ResolveOptions get_FailNameNotFoundOnly();
    public static ResolveOptions get_FailUnregisteredAndNameNotFound();
    public static ResolveOptions get_FailUnregisteredOnly();
}
[ExtensionAttribute]
internal static class Nancy.TinyIoc.ReverseTypeExtender : object {
    [ExtensionAttribute]
public static bool IsClass(Type type);
    [ExtensionAttribute]
public static bool IsAbstract(Type type);
    [ExtensionAttribute]
public static bool IsInterface(Type type);
    [ExtensionAttribute]
public static bool IsPrimitive(Type type);
    [ExtensionAttribute]
public static bool IsValueType(Type type);
    [ExtensionAttribute]
public static bool IsGenericType(Type type);
    [ExtensionAttribute]
public static bool IsGenericParameter(Type type);
    [ExtensionAttribute]
public static bool IsGenericTypeDefinition(Type type);
    [ExtensionAttribute]
public static Type BaseType(Type type);
    [ExtensionAttribute]
public static Assembly Assembly(Type type);
}
[DefaultMemberAttribute("Item")]
public class Nancy.TinyIoc.SafeDictionary`2 : object {
    private ReaderWriterLockSlim _padlock;
    private Dictionary`2<TKey, TValue> _Dictionary;
    unknown TValue Item {public set; }
    public IEnumerable`1<TKey> Keys { get; }
    public void set_Item(TKey key, TValue value);
    public bool TryGetValue(TKey key, TValue& value);
    public bool Remove(TKey key);
    public void Clear();
    public IEnumerable`1<TKey> get_Keys();
    public sealed virtual void Dispose();
}
public class Nancy.TinyIoc.TinyIoCAutoRegistrationException : Exception {
    private static string ERROR_TEXT;
    public TinyIoCAutoRegistrationException(Type registerType, IEnumerable`1<Type> types);
    public TinyIoCAutoRegistrationException(Type registerType, IEnumerable`1<Type> types, Exception innerException);
    protected TinyIoCAutoRegistrationException(SerializationInfo info, StreamingContext context);
    private static string GetTypesString(IEnumerable`1<Type> types);
}
public class Nancy.TinyIoc.TinyIoCConstructorResolutionException : Exception {
    private static string ERROR_TEXT;
    public TinyIoCConstructorResolutionException(Type type);
    public TinyIoCConstructorResolutionException(Type type, Exception innerException);
    public TinyIoCConstructorResolutionException(string message, Exception innerException);
    public TinyIoCConstructorResolutionException(string message);
    protected TinyIoCConstructorResolutionException(SerializationInfo info, StreamingContext context);
}
public class Nancy.TinyIoc.TinyIoCContainer : object {
    private static TinyIoCContainer _Current;
    private SafeDictionary`2<TypeRegistration, ObjectFactoryBase> _RegisteredTypes;
    private static SafeDictionary`2<ConstructorInfo, ObjectConstructor> _ObjectConstructorCache;
    private TinyIoCContainer _Parent;
    private object _AutoRegisterLock;
    private bool disposed;
    public static TinyIoCContainer Current { get; }
    private static TinyIoCContainer();
    private TinyIoCContainer(TinyIoCContainer parent);
    public TinyIoCContainer GetChildContainer();
    public void AutoRegister();
    public void AutoRegister(Func`2<Type, bool> registrationPredicate);
    public void AutoRegister(DuplicateImplementationActions duplicateAction);
    public void AutoRegister(DuplicateImplementationActions duplicateAction, Func`2<Type, bool> registrationPredicate);
    public void AutoRegister(IEnumerable`1<Assembly> assemblies);
    public void AutoRegister(IEnumerable`1<Assembly> assemblies, Func`2<Type, bool> registrationPredicate);
    public void AutoRegister(IEnumerable`1<Assembly> assemblies, DuplicateImplementationActions duplicateAction);
    public void AutoRegister(IEnumerable`1<Assembly> assemblies, DuplicateImplementationActions duplicateAction, Func`2<Type, bool> registrationPredicate);
    public RegisterOptions Register(Type registerType);
    public RegisterOptions Register(Type registerType, string name);
    public RegisterOptions Register(Type registerType, Type registerImplementation);
    public RegisterOptions Register(Type registerType, Type registerImplementation, string name);
    public RegisterOptions Register(Type registerType, object instance);
    public RegisterOptions Register(Type registerType, object instance, string name);
    public RegisterOptions Register(Type registerType, Type registerImplementation, object instance);
    public RegisterOptions Register(Type registerType, Type registerImplementation, object instance, string name);
    public RegisterOptions Register(Type registerType, Func`3<TinyIoCContainer, NamedParameterOverloads, object> factory);
    public RegisterOptions Register(Type registerType, Func`3<TinyIoCContainer, NamedParameterOverloads, object> factory, string name);
    public RegisterOptions Register();
    public RegisterOptions Register(string name);
    public RegisterOptions Register();
    public RegisterOptions Register(string name);
    public RegisterOptions Register(RegisterType instance);
    public RegisterOptions Register(RegisterType instance, string name);
    public RegisterOptions Register(RegisterImplementation instance);
    public RegisterOptions Register(RegisterImplementation instance, string name);
    public RegisterOptions Register(Func`3<TinyIoCContainer, NamedParameterOverloads, RegisterType> factory);
    public RegisterOptions Register(Func`3<TinyIoCContainer, NamedParameterOverloads, RegisterType> factory, string name);
    public MultiRegisterOptions RegisterMultiple(IEnumerable`1<Type> implementationTypes);
    public MultiRegisterOptions RegisterMultiple(Type registrationType, IEnumerable`1<Type> implementationTypes);
    public bool Unregister();
    public bool Unregister(string name);
    public bool Unregister(Type registerType);
    public bool Unregister(Type registerType, string name);
    public object Resolve(Type resolveType);
    public object Resolve(Type resolveType, ResolveOptions options);
    public object Resolve(Type resolveType, string name);
    public object Resolve(Type resolveType, string name, ResolveOptions options);
    public object Resolve(Type resolveType, NamedParameterOverloads parameters);
    public object Resolve(Type resolveType, NamedParameterOverloads parameters, ResolveOptions options);
    public object Resolve(Type resolveType, string name, NamedParameterOverloads parameters);
    public object Resolve(Type resolveType, string name, NamedParameterOverloads parameters, ResolveOptions options);
    public ResolveType Resolve();
    public ResolveType Resolve(ResolveOptions options);
    public ResolveType Resolve(string name);
    public ResolveType Resolve(string name, ResolveOptions options);
    public ResolveType Resolve(NamedParameterOverloads parameters);
    public ResolveType Resolve(NamedParameterOverloads parameters, ResolveOptions options);
    public ResolveType Resolve(string name, NamedParameterOverloads parameters);
    public ResolveType Resolve(string name, NamedParameterOverloads parameters, ResolveOptions options);
    public bool CanResolve(Type resolveType);
    private bool CanResolve(Type resolveType, string name);
    public bool CanResolve(Type resolveType, ResolveOptions options);
    public bool CanResolve(Type resolveType, string name, ResolveOptions options);
    public bool CanResolve(Type resolveType, NamedParameterOverloads parameters);
    public bool CanResolve(Type resolveType, string name, NamedParameterOverloads parameters);
    public bool CanResolve(Type resolveType, NamedParameterOverloads parameters, ResolveOptions options);
    public bool CanResolve(Type resolveType, string name, NamedParameterOverloads parameters, ResolveOptions options);
    public bool CanResolve();
    public bool CanResolve(string name);
    public bool CanResolve(ResolveOptions options);
    public bool CanResolve(string name, ResolveOptions options);
    public bool CanResolve(NamedParameterOverloads parameters);
    public bool CanResolve(string name, NamedParameterOverloads parameters);
    public bool CanResolve(NamedParameterOverloads parameters, ResolveOptions options);
    public bool CanResolve(string name, NamedParameterOverloads parameters, ResolveOptions options);
    public bool TryResolve(Type resolveType, Object& resolvedType);
    public bool TryResolve(Type resolveType, ResolveOptions options, Object& resolvedType);
    public bool TryResolve(Type resolveType, string name, Object& resolvedType);
    public bool TryResolve(Type resolveType, string name, ResolveOptions options, Object& resolvedType);
    public bool TryResolve(Type resolveType, NamedParameterOverloads parameters, Object& resolvedType);
    public bool TryResolve(Type resolveType, string name, NamedParameterOverloads parameters, Object& resolvedType);
    public bool TryResolve(Type resolveType, NamedParameterOverloads parameters, ResolveOptions options, Object& resolvedType);
    public bool TryResolve(Type resolveType, string name, NamedParameterOverloads parameters, ResolveOptions options, Object& resolvedType);
    public bool TryResolve(ResolveType& resolvedType);
    public bool TryResolve(ResolveOptions options, ResolveType& resolvedType);
    public bool TryResolve(string name, ResolveType& resolvedType);
    public bool TryResolve(string name, ResolveOptions options, ResolveType& resolvedType);
    public bool TryResolve(NamedParameterOverloads parameters, ResolveType& resolvedType);
    public bool TryResolve(string name, NamedParameterOverloads parameters, ResolveType& resolvedType);
    public bool TryResolve(NamedParameterOverloads parameters, ResolveOptions options, ResolveType& resolvedType);
    public bool TryResolve(string name, NamedParameterOverloads parameters, ResolveOptions options, ResolveType& resolvedType);
    public IEnumerable`1<object> ResolveAll(Type resolveType, bool includeUnnamed);
    public IEnumerable`1<object> ResolveAll(Type resolveType);
    public IEnumerable`1<ResolveType> ResolveAll(bool includeUnnamed);
    public IEnumerable`1<ResolveType> ResolveAll();
    public void BuildUp(object input);
    public void BuildUp(object input, ResolveOptions resolveOptions);
    public static TinyIoCContainer get_Current();
    private void AutoRegisterInternal(IEnumerable`1<Assembly> assemblies, DuplicateImplementationActions duplicateAction, Func`2<Type, bool> registrationPredicate);
    private bool IsIgnoredAssembly(Assembly assembly);
    private bool IsIgnoredType(Type type, Func`2<Type, bool> registrationPredicate);
    private void RegisterDefaultTypes();
    private ObjectFactoryBase GetCurrentFactory(TypeRegistration registration);
    private RegisterOptions RegisterInternal(Type registerType, string name, ObjectFactoryBase factory);
    private RegisterOptions AddUpdateRegistration(TypeRegistration typeRegistration, ObjectFactoryBase factory);
    private bool RemoveRegistration(TypeRegistration typeRegistration);
    private ObjectFactoryBase GetDefaultObjectFactory(Type registerType, Type registerImplementation);
    private bool CanResolveInternal(TypeRegistration registration, NamedParameterOverloads parameters, ResolveOptions options);
    private bool IsIEnumerableRequest(Type type);
    private bool IsAutomaticLazyFactoryRequest(Type type);
    private ObjectFactoryBase GetParentObjectFactory(TypeRegistration registration);
    private object ResolveInternal(TypeRegistration registration, NamedParameterOverloads parameters, ResolveOptions options);
    private object GetLazyAutomaticFactoryRequest(Type type);
    private object GetIEnumerableRequest(Type type);
    private bool CanConstruct(ConstructorInfo ctor, NamedParameterOverloads parameters, ResolveOptions options);
    private ConstructorInfo GetBestConstructor(Type type, NamedParameterOverloads parameters, ResolveOptions options);
    private IEnumerable`1<ConstructorInfo> GetTypeConstructors(Type type);
    private object ConstructType(Type requestedType, Type implementationType, ResolveOptions options);
    private object ConstructType(Type requestedType, Type implementationType, ConstructorInfo constructor, ResolveOptions options);
    private object ConstructType(Type requestedType, Type implementationType, NamedParameterOverloads parameters, ResolveOptions options);
    private object ConstructType(Type requestedType, Type implementationType, ConstructorInfo constructor, NamedParameterOverloads parameters, ResolveOptions options);
    private static ObjectConstructor CreateObjectConstructionDelegateWithCache(ConstructorInfo constructor);
    private void BuildUpInternal(object input, ResolveOptions resolveOptions);
    private IEnumerable`1<TypeRegistration> GetParentRegistrationsForType(Type resolveType);
    private IEnumerable`1<object> ResolveAllInternal(Type resolveType, bool includeUnnamed);
    private static bool IsValidAssignment(Type registerType, Type registerImplementation);
    public sealed virtual void Dispose();
    [CompilerGeneratedAttribute]
private bool <AutoRegister>b__3_0(Assembly a);
    [CompilerGeneratedAttribute]
private bool <AutoRegister>b__4_0(Assembly a);
    [CompilerGeneratedAttribute]
private bool <AutoRegister>b__5_0(Assembly a);
    [CompilerGeneratedAttribute]
private bool <AutoRegister>b__6_0(Assembly a);
}
public class Nancy.TinyIoc.TinyIoCRegistrationException : Exception {
    private static string CONVERT_ERROR_TEXT;
    private static string GENERIC_CONSTRAINT_ERROR_TEXT;
    public TinyIoCRegistrationException(Type type, string method);
    public TinyIoCRegistrationException(Type type, string method, Exception innerException);
    public TinyIoCRegistrationException(Type registerType, Type implementationType);
    public TinyIoCRegistrationException(Type registerType, Type implementationType, Exception innerException);
    protected TinyIoCRegistrationException(SerializationInfo info, StreamingContext context);
}
public class Nancy.TinyIoc.TinyIoCRegistrationTypeException : Exception {
    private static string REGISTER_ERROR_TEXT;
    public TinyIoCRegistrationTypeException(Type type, string factory);
    public TinyIoCRegistrationTypeException(Type type, string factory, Exception innerException);
    protected TinyIoCRegistrationTypeException(SerializationInfo info, StreamingContext context);
}
public class Nancy.TinyIoc.TinyIoCResolutionException : Exception {
    private static string ERROR_TEXT;
    public TinyIoCResolutionException(Type type);
    public TinyIoCResolutionException(Type type, Exception innerException);
    protected TinyIoCResolutionException(SerializationInfo info, StreamingContext context);
}
public class Nancy.TinyIoc.TinyIoCWeakReferenceException : Exception {
    private static string ERROR_TEXT;
    public TinyIoCWeakReferenceException(Type type);
    public TinyIoCWeakReferenceException(Type type, Exception innerException);
    protected TinyIoCWeakReferenceException(SerializationInfo info, StreamingContext context);
}
[ExtensionAttribute]
public static class Nancy.TinyIoc.TypeExtensions : object {
    private static SafeDictionary`2<GenericMethodCacheKey, MethodInfo> _genericMethodCache;
    private static TypeExtensions();
    [ExtensionAttribute]
public static MethodInfo GetGenericMethod(Type sourceType, BindingFlags bindingFlags, string methodName, Type[] genericTypes, Type[] parameterTypes);
    private static MethodInfo GetMethod(Type sourceType, BindingFlags bindingFlags, string methodName, Type[] genericTypes, Type[] parameterTypes);
}
public enum Nancy.TinyIoc.UnregisteredResolutionActions : Enum {
    public int value__;
    public static UnregisteredResolutionActions AttemptResolve;
    public static UnregisteredResolutionActions Fail;
    public static UnregisteredResolutionActions GenericsOnly;
}
public class Nancy.TraceConfiguration : object {
    [CompilerGeneratedAttribute]
private bool <Enabled>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DisplayErrorTraces>k__BackingField;
    public bool Enabled { get; private set; }
    public bool DisplayErrorTraces { get; private set; }
    public TraceConfiguration(bool enabled, bool displayErrorTraces);
    [CompilerGeneratedAttribute]
public bool get_Enabled();
    [CompilerGeneratedAttribute]
private void set_Enabled(bool value);
    [CompilerGeneratedAttribute]
public bool get_DisplayErrorTraces();
    [CompilerGeneratedAttribute]
private void set_DisplayErrorTraces(bool value);
}
[ExtensionAttribute]
public static class Nancy.TraceConfigurationExtensions : object {
    [ExtensionAttribute]
public static void Tracing(INancyEnvironment environment, bool enabled, bool displayErrorTraces);
}
[ExtensionAttribute]
public static class Nancy.TypeCatalogExtensions : object {
    [ExtensionAttribute]
public static IReadOnlyCollection`1<Type> GetTypesAssignableTo(ITypeCatalog typeCatalog, Type type);
    [ExtensionAttribute]
public static IReadOnlyCollection`1<Type> GetTypesAssignableTo(ITypeCatalog typeCatalog);
    [ExtensionAttribute]
public static IReadOnlyCollection`1<Type> GetTypesAssignableTo(ITypeCatalog typeCatalog, TypeResolveStrategy strategy);
}
public class Nancy.TypeResolveStrategies : object {
    public static TypeResolveStrategy All;
    public static TypeResolveStrategy ExcludeNancy;
    public static TypeResolveStrategy ExcludeNancyNamespace;
    public static TypeResolveStrategy OnlyNancy;
    public static TypeResolveStrategy OnlyNancyNamespace;
    private static TypeResolveStrategies();
}
public class Nancy.TypeResolveStrategy : MulticastDelegate {
    public TypeResolveStrategy(object object, IntPtr method);
    public virtual bool Invoke(Type type);
    public virtual IAsyncResult BeginInvoke(Type type, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
public class Nancy.Url : object {
    private string basePath;
    private string query;
    [CompilerGeneratedAttribute]
private string <Scheme>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HostName>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <Port>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    public string Scheme { get; public set; }
    public string HostName { get; public set; }
    public Nullable`1<int> Port { get; public set; }
    public string BasePath { get; public set; }
    public string Path { get; public set; }
    public string Query { get; public set; }
    public string SiteBase { get; }
    public bool IsSecure { get; }
    public Url(string url);
    [CompilerGeneratedAttribute]
public string get_Scheme();
    [CompilerGeneratedAttribute]
public void set_Scheme(string value);
    [CompilerGeneratedAttribute]
public string get_HostName();
    [CompilerGeneratedAttribute]
public void set_HostName(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_Port();
    [CompilerGeneratedAttribute]
public void set_Port(Nullable`1<int> value);
    public string get_BasePath();
    public void set_BasePath(string value);
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
public void set_Path(string value);
    public string get_Query();
    public void set_Query(string value);
    public string get_SiteBase();
    public bool get_IsSecure();
    public virtual string ToString();
    public Url Clone();
    public static string op_Implicit(Url url);
    public static Url op_Implicit(string url);
    public static Uri op_Implicit(Url url);
    public static Url op_Implicit(Uri uri);
    private static string GetQuery(string query);
    private static string GetCorrectPath(string path);
    private static string GetPort(Nullable`1<int> port);
    private static string GetHostName(string hostName);
}
public class Nancy.Validation.CompositeValidator : object {
    private IEnumerable`1<IModelValidator> validators;
    [CompilerGeneratedAttribute]
private ModelValidationDescriptor <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <ModelType>k__BackingField;
    public ModelValidationDescriptor Description { get; private set; }
    public Type ModelType { get; private set; }
    public CompositeValidator(IEnumerable`1<IModelValidator> validators, Type modelType);
    [CompilerGeneratedAttribute]
public sealed virtual ModelValidationDescriptor get_Description();
    [CompilerGeneratedAttribute]
private void set_Description(ModelValidationDescriptor value);
    [CompilerGeneratedAttribute]
public sealed virtual Type get_ModelType();
    [CompilerGeneratedAttribute]
private void set_ModelType(Type value);
    public sealed virtual ModelValidationResult Validate(object instance, NancyContext context);
    private static ModelValidationDescriptor CreateCompositeDescription(IEnumerable`1<IModelValidator> validators, Type modelType);
}
public class Nancy.Validation.DefaultValidatorLocator : object {
    private ConcurrentDictionary`2<Type, IModelValidator> cachedValidators;
    private IEnumerable`1<IModelValidatorFactory> factories;
    public DefaultValidatorLocator(IEnumerable`1<IModelValidatorFactory> factories);
    public sealed virtual IModelValidator GetValidatorForType(Type type);
    private IModelValidator CreateValidator(Type type);
}
public interface Nancy.Validation.IModelValidator {
    public ModelValidationDescriptor Description { get; }
    public Type ModelType { get; }
    public abstract virtual ModelValidationDescriptor get_Description();
    public abstract virtual Type get_ModelType();
    public abstract virtual ModelValidationResult Validate(object instance, NancyContext context);
}
public interface Nancy.Validation.IModelValidatorFactory {
    public abstract virtual IModelValidator Create(Type type);
}
public interface Nancy.Validation.IModelValidatorLocator {
    public abstract virtual IModelValidator GetValidatorForType(Type type);
}
public class Nancy.Validation.ModelValidationDescriptor : object {
    [CompilerGeneratedAttribute]
private Type <ModelType>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, IList`1<ModelValidationRule>> <Rules>k__BackingField;
    public Type ModelType { get; private set; }
    public IDictionary`2<string, IList`1<ModelValidationRule>> Rules { get; private set; }
    public ModelValidationDescriptor(IEnumerable`1<ModelValidationRule> rules, Type modelType);
    public ModelValidationDescriptor(IDictionary`2<string, IList`1<ModelValidationRule>> rules, Type modelType);
    [CompilerGeneratedAttribute]
public Type get_ModelType();
    [CompilerGeneratedAttribute]
private void set_ModelType(Type value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, IList`1<ModelValidationRule>> get_Rules();
    [CompilerGeneratedAttribute]
private void set_Rules(IDictionary`2<string, IList`1<ModelValidationRule>> value);
    private static IDictionary`2<string, IList`1<ModelValidationRule>> GetModelValidationRuleDictionary(IEnumerable`1<ModelValidationRule> rules);
}
public class Nancy.Validation.ModelValidationError : object {
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <MemberNames>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ErrorMessage>k__BackingField;
    public IEnumerable`1<string> MemberNames { get; private set; }
    public string ErrorMessage { get; private set; }
    public ModelValidationError(string memberName, string errorMessage);
    public ModelValidationError(IEnumerable`1<string> memberNames, string errorMessage);
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_MemberNames();
    [CompilerGeneratedAttribute]
private void set_MemberNames(IEnumerable`1<string> value);
    [CompilerGeneratedAttribute]
public string get_ErrorMessage();
    [CompilerGeneratedAttribute]
private void set_ErrorMessage(string value);
    public static string op_Implicit(ModelValidationError error);
    public virtual string ToString();
}
public class Nancy.Validation.ModelValidationException : Exception {
    public ModelValidationException(string message);
    public ModelValidationException(string message, Exception innerException);
}
[DebuggerDisplayAttribute("IsValid = {IsValid}")]
public class Nancy.Validation.ModelValidationResult : object {
    [CompilerGeneratedAttribute]
private IDictionary`2<string, IList`1<ModelValidationError>> <Errors>k__BackingField;
    public IDictionary`2<string, IList`1<ModelValidationError>> Errors { get; public set; }
    [DynamicAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IEnumerable`1<object> FormattedErrors { get; }
    public bool IsValid { get; }
    public ModelValidationResult(IEnumerable`1<ModelValidationError> errors);
    public ModelValidationResult(IDictionary`2<string, IList`1<ModelValidationError>> errors);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, IList`1<ModelValidationError>> get_Errors();
    [CompilerGeneratedAttribute]
public void set_Errors(IDictionary`2<string, IList`1<ModelValidationError>> value);
    public IEnumerable`1<object> get_FormattedErrors();
    public bool get_IsValid();
    private static IDictionary`2<string, IList`1<ModelValidationError>> GetModelValidationErrorDictionary(ModelValidationError[] results);
}
public class Nancy.Validation.ModelValidationRule : object {
    private Func`2<string, string> errorMessageFormatter;
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <MemberNames>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RuleType>k__BackingField;
    public IEnumerable`1<string> MemberNames { get; private set; }
    public string RuleType { get; private set; }
    public ModelValidationRule(string ruleType, Func`2<string, string> errorMessageFormatter);
    public ModelValidationRule(string ruleType, Func`2<string, string> errorMessageFormatter, IEnumerable`1<string> memberNames);
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_MemberNames();
    [CompilerGeneratedAttribute]
private void set_MemberNames(IEnumerable`1<string> value);
    [CompilerGeneratedAttribute]
public string get_RuleType();
    [CompilerGeneratedAttribute]
private void set_RuleType(string value);
    public string GetErrorMessage(string name);
}
[ExtensionAttribute]
public static class Nancy.Validation.ModuleExtensions : object {
    [ExtensionAttribute]
public static ModelValidationResult Validate(INancyModule module, T instance);
}
public enum Nancy.Validation.Rules.ComparisonOperator : Enum {
    public int value__;
    public static ComparisonOperator GreaterThan;
    public static ComparisonOperator GreaterThanOrEqual;
    public static ComparisonOperator LessThan;
    public static ComparisonOperator LessThanOrEqual;
    public static ComparisonOperator Equal;
    public static ComparisonOperator NotEqual;
}
public class Nancy.Validation.Rules.ComparisonValidationRule : ModelValidationRule {
    [CompilerGeneratedAttribute]
private ComparisonOperator <Operator>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Value>k__BackingField;
    public ComparisonOperator Operator { get; private set; }
    public object Value { get; private set; }
    public ComparisonValidationRule(Func`2<string, string> errorMessageFormatter, IEnumerable`1<string> memberNames, ComparisonOperator operator, object value);
    [CompilerGeneratedAttribute]
public ComparisonOperator get_Operator();
    [CompilerGeneratedAttribute]
private void set_Operator(ComparisonOperator value);
    [CompilerGeneratedAttribute]
public object get_Value();
    [CompilerGeneratedAttribute]
private void set_Value(object value);
}
public class Nancy.Validation.Rules.NotEmptyValidationRule : ModelValidationRule {
    public NotEmptyValidationRule(Func`2<string, string> errorMessageFormatter, IEnumerable`1<string> memberNames);
}
public class Nancy.Validation.Rules.NotNullValidationRule : ModelValidationRule {
    public NotNullValidationRule(Func`2<string, string> errorMessageFormatter, IEnumerable`1<string> memberNames);
}
public class Nancy.Validation.Rules.RegexValidationRule : ModelValidationRule {
    [CompilerGeneratedAttribute]
private string <Pattern>k__BackingField;
    public string Pattern { get; private set; }
    public RegexValidationRule(Func`2<string, string> errorMessageFormatter, IEnumerable`1<string> memberNames, string pattern);
    [CompilerGeneratedAttribute]
public string get_Pattern();
    [CompilerGeneratedAttribute]
private void set_Pattern(string value);
}
public class Nancy.Validation.Rules.StringLengthValidationRule : ModelValidationRule {
    [CompilerGeneratedAttribute]
private int <MinLength>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxLength>k__BackingField;
    public int MinLength { get; private set; }
    public int MaxLength { get; private set; }
    public StringLengthValidationRule(Func`2<string, string> errorMessageFormatter, IEnumerable`1<string> memberNames, int minLength, int maxLength);
    [CompilerGeneratedAttribute]
public int get_MinLength();
    [CompilerGeneratedAttribute]
private void set_MinLength(int value);
    [CompilerGeneratedAttribute]
public int get_MaxLength();
    [CompilerGeneratedAttribute]
private void set_MaxLength(int value);
}
public class Nancy.ViewConfiguration : object {
    public static ViewConfiguration Default;
    [CompilerGeneratedAttribute]
private bool <RuntimeViewDiscovery>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RuntimeViewUpdates>k__BackingField;
    public bool RuntimeViewDiscovery { get; private set; }
    public bool RuntimeViewUpdates { get; private set; }
    public ViewConfiguration(bool runtimeViewDiscovery, bool runtimeViewUpdates);
    private static ViewConfiguration();
    [CompilerGeneratedAttribute]
public bool get_RuntimeViewDiscovery();
    [CompilerGeneratedAttribute]
private void set_RuntimeViewDiscovery(bool value);
    [CompilerGeneratedAttribute]
public bool get_RuntimeViewUpdates();
    [CompilerGeneratedAttribute]
private void set_RuntimeViewUpdates(bool value);
}
[ExtensionAttribute]
public static class Nancy.ViewConfigurationExtensions : object {
    [ExtensionAttribute]
public static void Views(INancyEnvironment environment, Nullable`1<bool> runtimeViewDiscovery, Nullable`1<bool> runtimeViewUpdates);
}
public class Nancy.ViewEngines.AmbiguousViewsException : Exception {
    public AmbiguousViewsException(string message);
}
public class Nancy.ViewEngines.DefaultFileSystemReader : object {
    public sealed virtual IEnumerable`1<Tuple`2<string, Func`1<StreamReader>>> GetViewsWithSupportedExtensions(string path, IEnumerable`1<string> supportedViewExtensions);
    public sealed virtual DateTime GetLastModified(string filename);
    public sealed virtual IEnumerable`1<Tuple`2<string, Func`1<StreamReader>>> GetViewsWithSupportedExtensions(string path, string viewName, IEnumerable`1<string> supportedViewExtensions);
    private static IEnumerable`1<string> GetFilenames(string path, string viewName, IEnumerable`1<string> supportedViewExtensions);
    private static bool IsValidExtention(string filename, IEnumerable`1<string> supportedViewExtensions);
    private static IEnumerable`1<string> GetFilenames(string path, string extension);
}
public class Nancy.ViewEngines.DefaultRenderContext : object {
    private IViewResolver viewResolver;
    private IViewCache viewCache;
    private ITextResource textResource;
    private ViewLocationContext viewLocationContext;
    private TextResourceFinder textResourceFinder;
    public NancyContext Context { get; }
    public IViewCache ViewCache { get; }
    public ITextResource TextResource { get; }
    [DynamicAttribute]
public object TextResourceFinder { get; }
    public DefaultRenderContext(IViewResolver viewResolver, IViewCache viewCache, ITextResource textResource, ViewLocationContext viewLocationContext);
    public sealed virtual NancyContext get_Context();
    public sealed virtual IViewCache get_ViewCache();
    public sealed virtual ITextResource get_TextResource();
    public sealed virtual object get_TextResourceFinder();
    public sealed virtual string ParsePath(string input);
    public sealed virtual string HtmlEncode(string input);
    public sealed virtual ViewLocationResult LocateView(string viewName, object model);
    public sealed virtual KeyValuePair`2<string, string> GetCsrfToken();
}
public class Nancy.ViewEngines.DefaultRenderContextFactory : object {
    private IViewCache viewCache;
    private IViewResolver viewResolver;
    private ITextResource textResource;
    public DefaultRenderContextFactory(IViewCache viewCache, IViewResolver viewResolver, ITextResource textResource);
    public sealed virtual IRenderContext GetRenderContext(ViewLocationContext viewLocationContext);
}
public class Nancy.ViewEngines.DefaultResourceReader : object {
    public sealed virtual IList`1<Tuple`2<string, Func`1<StreamReader>>> GetResourceStreamMatches(Assembly assembly, IEnumerable`1<string> supportedViewEngineExtensions);
    private static string GetResourceExtension(string resourceName);
}
public class Nancy.ViewEngines.DefaultViewCache : object {
    private ConcurrentDictionary`2<ViewLocationResult, object> cache;
    private ViewConfiguration configuration;
    public DefaultViewCache(INancyEnvironment environment);
    public sealed virtual TCompiledView GetOrAdd(ViewLocationResult viewLocationResult, Func`2<ViewLocationResult, TCompiledView> valueFactory);
}
public class Nancy.ViewEngines.DefaultViewFactory : object {
    private IViewResolver viewResolver;
    private IEnumerable`1<IViewEngine> viewEngines;
    private IRenderContextFactory renderContextFactory;
    private ViewLocationConventions conventions;
    private IRootPathProvider rootPathProvider;
    private static Action`1<Stream> EmptyView;
    private String[] viewEngineExtensions;
    public DefaultViewFactory(IViewResolver viewResolver, IEnumerable`1<IViewEngine> viewEngines, IRenderContextFactory renderContextFactory, ViewLocationConventions conventions, IRootPathProvider rootPathProvider);
    private static DefaultViewFactory();
    public sealed virtual Response RenderView(string viewName, object model, ViewLocationContext viewLocationContext);
    private Response GetRenderedView(string viewName, object model, ViewLocationContext viewLocationContext);
    private String[] GetInspectedLocations(string viewName, object model, ViewLocationContext viewLocationContext);
    private static object GetSafeModel(object model);
    private static ExpandoObject GetExpandoObject(object source);
    private IViewEngine GetViewEngine(ViewLocationResult viewLocationResult, NancyContext context);
    private static string GetViewNameFromModel(object model, NancyContext context);
    private static Response SafeInvokeViewEngine(IViewEngine viewEngine, ViewLocationResult locationResult, object model, IRenderContext renderContext);
    private sealed virtual override Type Nancy.IHideObjectMembers.GetType();
}
public class Nancy.ViewEngines.DefaultViewLocator : object {
    private List`1<ViewLocationResult> viewLocationResults;
    private IViewLocationProvider viewLocationProvider;
    private IEnumerable`1<IViewEngine> viewEngines;
    private ReaderWriterLockSlim padlock;
    private Char[] invalidCharacters;
    private ViewConfiguration configuration;
    public DefaultViewLocator(IViewLocationProvider viewLocationProvider, IEnumerable`1<IViewEngine> viewEngines, INancyEnvironment environment);
    public sealed virtual ViewLocationResult LocateView(string viewName, NancyContext context);
    public sealed virtual IEnumerable`1<ViewLocationResult> GetAllCurrentlyDiscoveredViews();
    private ViewLocationResult LocateAndCacheUncachedView(string viewName);
    private ViewLocationResult LocateCachedView(string viewName);
    private ViewLocationResult[] GetUncachedMatchingViews(string viewName);
    private ViewLocationResult[] GetCachedMatchingViews(string viewName);
    private IEnumerable`1<ViewLocationResult> GetInitialViewLocations();
    private IEnumerable`1<string> GetSupportedViewExtensions();
    private static string GetAmbiguousViewExceptionMessage(int count, IEnumerable`1<ViewLocationResult> viewsThatMatchesCriteria);
    private static string GetFullLocationOfView(ViewLocationResult viewLocationResult);
    private static bool ExtensionMatchesView(string viewName, ViewLocationResult viewLocationResult);
    private static bool LocationMatchesView(string viewName, ViewLocationResult viewLocationResult);
    private static bool NameMatchesView(string viewName, ViewLocationResult viewLocationResult);
    private static string GetFilenameWithoutExtensionFromViewName(string viewName);
    private static string GetLocationFromViewName(string viewName);
    private static string GetExtensionFromViewName(string viewName);
    private bool IsValidViewName(string viewName);
    private sealed virtual override Type Nancy.IHideObjectMembers.GetType();
}
public class Nancy.ViewEngines.DefaultViewResolver : object {
    private ViewLocationConventions conventions;
    private IViewLocator viewLocator;
    public DefaultViewResolver(IViewLocator viewLocator, ViewLocationConventions conventions);
    public sealed virtual ViewLocationResult GetViewLocation(string viewName, object model, ViewLocationContext viewLocationContext);
    private static string SafeInvokeConvention(Func`4<string, object, ViewLocationContext, string> convention, string viewName, object model, ViewLocationContext viewLocationContext);
    private sealed virtual override Type Nancy.IHideObjectMembers.GetType();
}
[ExtensionAttribute]
public static class Nancy.ViewEngines.Extensions : object {
    [ExtensionAttribute]
public static bool IsAnonymousType(object source);
    [ExtensionAttribute]
public static bool IsAnonymousType(Type type);
}
public class Nancy.ViewEngines.FileSystemViewLocationProvider : object {
    private IFileSystemReader fileSystemReader;
    private string rootPath;
    public FileSystemViewLocationProvider(IRootPathProvider rootPathProvider);
    public FileSystemViewLocationProvider(IRootPathProvider rootPathProvider, IFileSystemReader fileSystemReader);
    public sealed virtual IEnumerable`1<ViewLocationResult> GetLocatedViews(IEnumerable`1<string> supportedViewExtensions);
    public sealed virtual IEnumerable`1<ViewLocationResult> GetLocatedViews(IEnumerable`1<string> supportedViewExtensions, string location, string viewName);
    private IEnumerable`1<ViewLocationResult> GetViewsFromPath(string path, string viewName, IEnumerable`1<string> supportedViewExtensions);
    private IEnumerable`1<ViewLocationResult> GetViewsFromPath(string path, IEnumerable`1<string> supportedViewExtensions);
    private static string GetViewLocation(string match, string rootPath);
    [CompilerGeneratedAttribute]
private FileSystemViewLocationResult <GetViewsFromPath>b__6_0(Tuple`2<string, Func`1<StreamReader>> match);
    [CompilerGeneratedAttribute]
private FileSystemViewLocationResult <GetViewsFromPath>b__7_0(Tuple`2<string, Func`1<StreamReader>> match);
}
public class Nancy.ViewEngines.FileSystemViewLocationResult : ViewLocationResult {
    private IFileSystemReader fileSystem;
    private string fileName;
    private DateTime lastUpdated;
    private Func`1<TextReader> fileContents;
    public FileSystemViewLocationResult(string location, string name, string extension, Func`1<TextReader> contents, string fullFilename, IFileSystemReader fileSystem);
    public virtual bool IsStale();
    private TextReader GetContents();
}
public interface Nancy.ViewEngines.IFileSystemReader {
    public abstract virtual IEnumerable`1<Tuple`2<string, Func`1<StreamReader>>> GetViewsWithSupportedExtensions(string path, IEnumerable`1<string> supportedViewExtensions);
    public abstract virtual DateTime GetLastModified(string filename);
    public abstract virtual IEnumerable`1<Tuple`2<string, Func`1<StreamReader>>> GetViewsWithSupportedExtensions(string path, string viewName, IEnumerable`1<string> supportedViewExtensions);
}
public interface Nancy.ViewEngines.IRenderContext {
    public NancyContext Context { get; }
    public IViewCache ViewCache { get; }
    public ITextResource TextResource { get; }
    [DynamicAttribute]
public object TextResourceFinder { get; }
    public abstract virtual NancyContext get_Context();
    public abstract virtual IViewCache get_ViewCache();
    public abstract virtual ITextResource get_TextResource();
    public abstract virtual object get_TextResourceFinder();
    public abstract virtual string ParsePath(string input);
    public abstract virtual string HtmlEncode(string input);
    public abstract virtual ViewLocationResult LocateView(string viewName, object model);
    public abstract virtual KeyValuePair`2<string, string> GetCsrfToken();
}
public interface Nancy.ViewEngines.IRenderContextFactory {
    public abstract virtual IRenderContext GetRenderContext(ViewLocationContext viewLocationContext);
}
public interface Nancy.ViewEngines.IResourceReader {
    public abstract virtual IList`1<Tuple`2<string, Func`1<StreamReader>>> GetResourceStreamMatches(Assembly assembly, IEnumerable`1<string> supportedViewEngineExtensions);
}
public interface Nancy.ViewEngines.IViewCache {
    public abstract virtual TCompiledView GetOrAdd(ViewLocationResult viewLocationResult, Func`2<ViewLocationResult, TCompiledView> valueFactory);
}
public interface Nancy.ViewEngines.IViewEngine {
    public IEnumerable`1<string> Extensions { get; }
    public abstract virtual IEnumerable`1<string> get_Extensions();
    public abstract virtual void Initialize(ViewEngineStartupContext viewEngineStartupContext);
    public abstract virtual Response RenderView(ViewLocationResult viewLocationResult, object model, IRenderContext renderContext);
}
public interface Nancy.ViewEngines.IViewFactory {
    public abstract virtual Response RenderView(string viewName, object model, ViewLocationContext viewLocationContext);
}
public interface Nancy.ViewEngines.IViewLocationProvider {
    public abstract virtual IEnumerable`1<ViewLocationResult> GetLocatedViews(IEnumerable`1<string> supportedViewExtensions);
    public abstract virtual IEnumerable`1<ViewLocationResult> GetLocatedViews(IEnumerable`1<string> supportedViewExtensions, string location, string viewName);
}
public interface Nancy.ViewEngines.IViewLocator {
    public abstract virtual ViewLocationResult LocateView(string viewName, NancyContext context);
    public abstract virtual IEnumerable`1<ViewLocationResult> GetAllCurrentlyDiscoveredViews();
}
public interface Nancy.ViewEngines.IViewResolver {
    public abstract virtual ViewLocationResult GetViewLocation(string viewName, object model, ViewLocationContext viewLocationContext);
}
public class Nancy.ViewEngines.Razor.ViewRenderException : Exception {
    public ViewRenderException(string msg);
    public ViewRenderException(string msg, Exception innerException);
}
public class Nancy.ViewEngines.ResourceViewLocationProvider : object {
    private IResourceReader resourceReader;
    private IResourceAssemblyProvider resourceAssemblyProvider;
    public static IDictionary`2<Assembly, string> RootNamespaces;
    public static IList`1<Assembly> Ignore;
    public ResourceViewLocationProvider(IAssemblyCatalog assemblyCatalog);
    public ResourceViewLocationProvider(IResourceReader resourceReader, IResourceAssemblyProvider resourceAssemblyProvider);
    private static ResourceViewLocationProvider();
    public sealed virtual IEnumerable`1<ViewLocationResult> GetLocatedViews(IEnumerable`1<string> supportedViewExtensions);
    public sealed virtual IEnumerable`1<ViewLocationResult> GetLocatedViews(IEnumerable`1<string> supportedViewExtensions, string location, string viewName);
    private IEnumerable`1<ViewLocationResult> GetViewLocations(Assembly assembly, IEnumerable`1<string> supportedViewExtensions);
    private static string GetResourceLocation(string commonNamespace, string resource, string resourceName);
    private static string ExtractCommonResourceNamespace(IEnumerable`1<string> resources);
    private static string ExtractAssemblyRootNamespace(Assembly assembly);
    private static string GetResourceFileName(string resourceName);
    private static string GetResourceExtension(string resourceName);
}
public interface Nancy.ViewEngines.SuperSimpleViewEngine.ISuperSimpleViewEngineMatcher {
    public abstract virtual string Invoke(string content, object model, IViewEngineHost host);
}
public interface Nancy.ViewEngines.SuperSimpleViewEngine.IViewEngineHost {
    public object Context { get; }
    public abstract virtual object get_Context();
    public abstract virtual string HtmlEncode(string input);
    public abstract virtual string GetTemplate(string templateName, object model);
    public abstract virtual string GetUriString(string name, String[] parameters);
    public abstract virtual string ExpandPath(string path);
    public abstract virtual string AntiForgeryToken();
}
public class Nancy.ViewEngines.SuperSimpleViewEngine.NancyViewEngineHost : object {
    private IRenderContext renderContext;
    [CompilerGeneratedAttribute]
private object <Context>k__BackingField;
    public object Context { get; private set; }
    public NancyViewEngineHost(IRenderContext renderContext);
    [CompilerGeneratedAttribute]
public sealed virtual object get_Context();
    [CompilerGeneratedAttribute]
private void set_Context(object value);
    public sealed virtual string HtmlEncode(string input);
    public sealed virtual string GetTemplate(string templateName, object model);
    public sealed virtual string GetUriString(string name, String[] parameters);
    public sealed virtual string ExpandPath(string path);
    public sealed virtual string AntiForgeryToken();
}
public class Nancy.ViewEngines.SuperSimpleViewEngine.SuperSimpleViewEngine : object {
    private static Regex ViewBagSubstitutionsRegEx;
    private static Regex SingleSubstitutionsRegEx;
    private static Regex ContextSubstitutionsRegEx;
    private static Regex EachSubstitutionRegEx;
    private static Regex EachItemSubstitutionRegEx;
    private static string ConditionalOpenSyntaxPattern;
    private static string ConditionalOpenInnerSyntaxPattern;
    private static string ConditionalCloseStynaxPattern;
    private static string ConditionalSubstituionPattern;
    private static Regex ConditionalSubstitutionRegEx;
    private static Regex PartialSubstitutionRegEx;
    private static Regex SectionDeclarationRegEx;
    private static Regex SectionContentsRegEx;
    private static Regex MasterPageHeaderRegEx;
    private static Regex PathExpansionRegEx;
    private static Regex AttributeValuePathExpansionRegEx;
    private static Regex AntiForgeryTokenRegEx;
    private List`1<Func`4<string, object, IViewEngineHost, string>> processors;
    private IEnumerable`1<ISuperSimpleViewEngineMatcher> matchers;
    public SuperSimpleViewEngine(IEnumerable`1<ISuperSimpleViewEngineMatcher> matchers);
    private static SuperSimpleViewEngine();
    public string Render(string template, object model, IViewEngineHost host);
    private static Tuple`2<bool, object> GetPropertyValue(object model, string propertyName);
    private static Tuple`2<bool, object> GetDynamicMember(object obj, string memberName);
    private static Tuple`2<bool, object> StandardTypePropertyEvaluator(object model, string propertyName);
    private static Tuple`2<bool, object> DynamicDictionaryPropertyEvaluator(object model, string propertyName);
    private static IEnumerable`1<string> GetCaptureGroupValues(Match m, string groupName);
    private static Tuple`2<bool, object> GetPropertyValueFromParameterCollection(object model, IEnumerable`1<string> parameters);
    private static bool GetPredicateResult(object item, IEnumerable`1<string> properties, bool nullCheck);
    private static bool GetPredicateResultFromSubstitutionObject(object substitutionObject, bool nullCheck);
    private static bool GetHasPredicateResultFromSubstitutionObject(object substitutionObject);
    private static string PerformViewBagSubstitutions(string template, object model, IViewEngineHost host);
    private static string PerformSingleSubstitutions(string template, object model, IViewEngineHost host);
    private static string PerformContextSubstitutions(string template, object model, IViewEngineHost host);
    private string PerformEachSubstitutions(string template, object model, IViewEngineHost host);
    private static string ReplaceCurrentMatch(string contents, object item, IViewEngineHost host);
    private static string PerformConditionalSubstitutions(string template, object model, IViewEngineHost host);
    private static string PerformPathSubstitutions(string template, object model, IViewEngineHost host);
    private static string PerformAntiForgeryTokenSubstitutions(string template, object model, IViewEngineHost host);
    private string PerformPartialSubstitutions(string template, object model, IViewEngineHost host);
    private string PerformMasterPageSubstitutions(string template, object model, IViewEngineHost host);
    private string RenderMasterPage(string masterTemplate, IDictionary`2<string, string> sections, object model, IViewEngineHost host);
    private static string GetMasterPageName(string template);
}
public class Nancy.ViewEngines.SuperSimpleViewEngine.SuperSimpleViewEngineRegistrations : object {
    private ITypeCatalog typeCatalog;
    public IEnumerable`1<TypeRegistration> TypeRegistrations { get; }
    public IEnumerable`1<CollectionTypeRegistration> CollectionTypeRegistrations { get; }
    public IEnumerable`1<InstanceRegistration> InstanceRegistrations { get; }
    public SuperSimpleViewEngineRegistrations(ITypeCatalog typeCatalog);
    public sealed virtual IEnumerable`1<TypeRegistration> get_TypeRegistrations();
    public sealed virtual IEnumerable`1<CollectionTypeRegistration> get_CollectionTypeRegistrations();
    public sealed virtual IEnumerable`1<InstanceRegistration> get_InstanceRegistrations();
}
public class Nancy.ViewEngines.SuperSimpleViewEngine.SuperSimpleViewEngineWrapper : object {
    private String[] extensions;
    private SuperSimpleViewEngine viewEngine;
    public IEnumerable`1<string> Extensions { get; }
    public SuperSimpleViewEngineWrapper(IEnumerable`1<ISuperSimpleViewEngineMatcher> matchers);
    public sealed virtual IEnumerable`1<string> get_Extensions();
    public sealed virtual void Initialize(ViewEngineStartupContext viewEngineStartupContext);
    public sealed virtual Response RenderView(ViewLocationResult viewLocationResult, object model, IRenderContext renderContext);
}
public class Nancy.ViewEngines.ViewEngineApplicationStartup : object {
    private IEnumerable`1<IViewEngine> viewEngines;
    private IViewCache viewCache;
    private IViewLocator viewLocator;
    public ViewEngineApplicationStartup(IEnumerable`1<IViewEngine> viewEngines, IViewCache viewCache, IViewLocator viewLocator);
    public sealed virtual void Initialize(IPipelines pipelines);
    private ViewEngineStartupContext CreateViewEngineStartupContext(IViewEngine viewEngine);
}
public class Nancy.ViewEngines.ViewEngineStartupContext : object {
    [CompilerGeneratedAttribute]
private IViewCache <ViewCache>k__BackingField;
    [CompilerGeneratedAttribute]
private IViewLocator <ViewLocator>k__BackingField;
    public IViewCache ViewCache { get; private set; }
    public IViewLocator ViewLocator { get; private set; }
    public ViewEngineStartupContext(IViewCache viewCache, IViewLocator viewLocator);
    [CompilerGeneratedAttribute]
public IViewCache get_ViewCache();
    [CompilerGeneratedAttribute]
private void set_ViewCache(IViewCache value);
    [CompilerGeneratedAttribute]
public IViewLocator get_ViewLocator();
    [CompilerGeneratedAttribute]
private void set_ViewLocator(IViewLocator value);
}
public class Nancy.ViewEngines.ViewLocationContext : object {
    [CompilerGeneratedAttribute]
private string <ModulePath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ModuleName>k__BackingField;
    [CompilerGeneratedAttribute]
private NancyContext <Context>k__BackingField;
    public string ModulePath { get; public set; }
    public string ModuleName { get; public set; }
    public NancyContext Context { get; public set; }
    [CompilerGeneratedAttribute]
public string get_ModulePath();
    [CompilerGeneratedAttribute]
public void set_ModulePath(string value);
    [CompilerGeneratedAttribute]
public string get_ModuleName();
    [CompilerGeneratedAttribute]
public void set_ModuleName(string value);
    [CompilerGeneratedAttribute]
public NancyContext get_Context();
    [CompilerGeneratedAttribute]
public void set_Context(NancyContext value);
}
public class Nancy.ViewEngines.ViewLocationResult : object {
    [CompilerGeneratedAttribute]
private Func`1<TextReader> <Contents>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Extension>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Location>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public Func`1<TextReader> Contents { get; protected set; }
    public string Extension { get; protected set; }
    public string Location { get; protected set; }
    public string Name { get; protected set; }
    public ViewLocationResult(string location, string name, string extension, Func`1<TextReader> contents);
    [CompilerGeneratedAttribute]
public Func`1<TextReader> get_Contents();
    [CompilerGeneratedAttribute]
protected void set_Contents(Func`1<TextReader> value);
    [CompilerGeneratedAttribute]
public string get_Extension();
    [CompilerGeneratedAttribute]
protected void set_Extension(string value);
    [CompilerGeneratedAttribute]
public string get_Location();
    [CompilerGeneratedAttribute]
protected void set_Location(string value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
protected void set_Name(string value);
    public virtual bool IsStale();
    public sealed virtual bool Equals(ViewLocationResult other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(ViewLocationResult left, ViewLocationResult right);
    public static bool op_Inequality(ViewLocationResult left, ViewLocationResult right);
}
public class Nancy.ViewEngines.ViewNotFoundException : Exception {
    private IRootPathProvider rootPathProvider;
    [CompilerGeneratedAttribute]
private string <ViewName>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <AvailableViewEngineExtensions>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <InspectedLocations>k__BackingField;
    private string message;
    public string ViewName { get; private set; }
    public String[] AvailableViewEngineExtensions { get; private set; }
    public String[] InspectedLocations { get; private set; }
    public string Message { get; }
    public ViewNotFoundException(string viewName, String[] availableViewEngineExtensions, String[] inspectedLocations, IRootPathProvider rootPathProvider);
    public ViewNotFoundException(string viewName, String[] availableViewEngineExtensions);
    public ViewNotFoundException(string msg);
    [CompilerGeneratedAttribute]
public string get_ViewName();
    [CompilerGeneratedAttribute]
private void set_ViewName(string value);
    [CompilerGeneratedAttribute]
public String[] get_AvailableViewEngineExtensions();
    [CompilerGeneratedAttribute]
private void set_AvailableViewEngineExtensions(String[] value);
    [CompilerGeneratedAttribute]
public String[] get_InspectedLocations();
    [CompilerGeneratedAttribute]
private void set_InspectedLocations(String[] value);
    public virtual string get_Message();
}
[DefaultMemberAttribute("Item")]
public class Nancy.ViewRenderer : object {
    private INancyModule module;
    public Negotiator Item { get; }
    public Negotiator Item { get; }
    public Negotiator Item { get; }
    public ViewRenderer(INancyModule module);
    public Negotiator get_Item(object model);
    public Negotiator get_Item(string viewName);
    public Negotiator get_Item(string viewName, object model);
    private Negotiator GetNegotiator(string viewName, object model);
    private sealed virtual override Type Nancy.IHideObjectMembers.GetType();
}
public class Nancy.Xml.DefaultXmlConfigurationProvider : NancyDefaultConfigurationProvider`1<XmlConfiguration> {
    public virtual XmlConfiguration GetDefaultConfiguration();
}
public class Nancy.Xml.XmlConfiguration : object {
    public static XmlConfiguration Default;
    [CompilerGeneratedAttribute]
private bool <EncodingEnabled>k__BackingField;
    [CompilerGeneratedAttribute]
private Encoding <DefaultEncoding>k__BackingField;
    public bool EncodingEnabled { get; private set; }
    public Encoding DefaultEncoding { get; private set; }
    public XmlConfiguration(bool encodingEnabled, Encoding defaultEncoding);
    private static XmlConfiguration();
    [CompilerGeneratedAttribute]
public bool get_EncodingEnabled();
    [CompilerGeneratedAttribute]
private void set_EncodingEnabled(bool value);
    [CompilerGeneratedAttribute]
public Encoding get_DefaultEncoding();
    [CompilerGeneratedAttribute]
private void set_DefaultEncoding(Encoding value);
}
[ExtensionAttribute]
public static class Nancy.Xml.XmlConfigurationExtensions : object {
    [ExtensionAttribute]
public static void Xml(INancyEnvironment environment, bool enableEncoding, Encoding defaultEncoding);
}
