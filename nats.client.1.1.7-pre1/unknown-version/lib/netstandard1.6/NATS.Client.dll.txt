public class NATS.Client.AckType : object {
    public static AckType AckAck;
    public static AckType AckNak;
    public static AckType AckProgress;
    public static AckType AckTerm;
    [CompilerGeneratedAttribute]
private string <Text>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <Bytes>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsTerminal>k__BackingField;
    public string Text { get; }
    public Byte[] Bytes { get; }
    public bool IsTerminal { get; }
    public AckType(string text, bool terminal);
    private static AckType();
    [CompilerGeneratedAttribute]
public string get_Text();
    [CompilerGeneratedAttribute]
public Byte[] get_Bytes();
    [CompilerGeneratedAttribute]
public bool get_IsTerminal();
    public Byte[] BodyBytes(long delayNanoseconds);
}
public class NATS.Client.AsyncSubscription : Subscription {
    [CompilerGeneratedAttribute]
private EventHandler`1<MsgHandlerEventArgs> MessageHandler;
    private Task msgFeeder;
    private bool started;
    internal AsyncSubscription(Connection conn, string subject, string queue, bool forceOwnChannel);
    [CompilerGeneratedAttribute]
public sealed virtual void add_MessageHandler(EventHandler`1<MsgHandlerEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_MessageHandler(EventHandler`1<MsgHandlerEventArgs> value);
    internal virtual bool processMsg(Msg msg);
    internal bool isStarted();
    internal void enableAsyncProcessing();
    private void doAsyncProcessing();
    internal void disableAsyncProcessing();
    public sealed virtual void Start();
    public virtual void Unsubscribe();
    public virtual void AutoUnsubscribe(int max);
    internal virtual void close();
}
public class NATS.Client.Base32 : object {
    private static int InByteSize;
    private static int OutByteSize;
    private static string Base32Alphabet;
    public static Byte[] Decode(string input);
    public static string Encode(Byte[] input);
    private static int CharToValue(char c);
    private static char ValueToChar(byte b);
    public static string ToBase32String(Byte[] bytes);
    public static Byte[] FromBase32String(string base32String);
}
internal class NATS.Client.Channel`1 : object {
    private Queue`1<T> q;
    private object qLock;
    private bool finished;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public string Name { get; public set; }
    internal int Count { get; }
    internal Channel`1(string name);
    internal Channel`1(int initialCapacity, string name);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    internal T get(int timeout);
    internal int get(int timeout, T[] buffer);
    internal void add(T item);
    internal bool tryAdd(T item, int upperBound);
    internal void close();
    internal int get_Count();
}
public class NATS.Client.ClientExDetail : object {
    public static ClientExDetail JsSubPullCantHaveDeliverGroup;
    public static ClientExDetail JsSubPullCantHaveDeliverSubject;
    public static ClientExDetail JsSubPushCantHaveMaxPullWaiting;
    public static ClientExDetail JsSubQueueDeliverGroupMismatch;
    public static ClientExDetail JsSubFcHbNotValidPull;
    public static ClientExDetail JsSubFcHbNotValidQueue;
    public static ClientExDetail JsSubNoMatchingStreamForSubject;
    public static ClientExDetail JsSubConsumerAlreadyConfiguredAsPush;
    public static ClientExDetail JsSubConsumerAlreadyConfiguredAsPull;
    public static ClientExDetail JsSubSubjectDoesNotMatchFilter;
    public static ClientExDetail JsSubConsumerAlreadyBound;
    public static ClientExDetail JsSubExistingConsumerNotQueue;
    public static ClientExDetail JsSubExistingConsumerIsQueue;
    public static ClientExDetail JsSubExistingQueueDoesNotMatchRequestedQueue;
    public static ClientExDetail JsSubExistingConsumerCannotBeModified;
    public static ClientExDetail JsSubConsumerNotFoundRequiredInBind;
    public static ClientExDetail JsSubOrderedNotAllowOnQueues;
    public static ClientExDetail JsSubPushCantHaveMaxBatch;
    public static ClientExDetail JsSubPushCantHaveMaxBytes;
    public static ClientExDetail JsSubSubjectNeededToLookupStream;
    public static ClientExDetail JsSoDurableMismatch;
    public static ClientExDetail JsSoDeliverGroupMismatch;
    public static ClientExDetail JsSoDeliverSubjectMismatch;
    public static ClientExDetail JsSoOrderedNotAllowedWithBind;
    public static ClientExDetail JsSoOrderedNotAllowedWithDeliverGroup;
    public static ClientExDetail JsSoOrderedNotAllowedWithDurable;
    public static ClientExDetail JsSoOrderedNotAllowedWithDeliverSubject;
    public static ClientExDetail JsSoOrderedRequiresAckPolicyNone;
    public static ClientExDetail JsSoOrderedRequiresMaxDeliverOfOne;
    public static ClientExDetail JsSoNameMismatch;
    public static ClientExDetail JsSoOrderedMemStorageNotSuppliedOrTrue;
    public static ClientExDetail JsSoOrderedReplicasNotSuppliedOrOne;
    public static ClientExDetail JsSoNameOrDurableRequiredForBind;
    public static ClientExDetail OsObjectNotFound;
    public static ClientExDetail OsObjectIsDeleted;
    public static ClientExDetail OsObjectAlreadyExists;
    public static ClientExDetail OsCantLinkToLink;
    public static ClientExDetail OsGetDigestMismatch;
    public static ClientExDetail OsGetChunksMismatch;
    public static ClientExDetail OsGetSizeMismatch;
    public static ClientExDetail OsGetLinkToBucket;
    public static ClientExDetail OsLinkNotAllowOnPut;
    public static ClientExDetail JsConsumerCreate290NotAvailable;
    public static ClientExDetail JsConsumerNameDurableMismatch;
    public static ClientExDetail JsMultipleFilterSubjects210NotAvailable;
    private static string Sub;
    private static string So;
    private static string Os;
    private static string Con;
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [ObsoleteAttribute("constant name had typo, replaced with JsSubFcHbNotValidQueue")]
public static ClientExDetail JsSubFcHbHbNotValidQueue;
    [ObsoleteAttribute("constant name had typo, replaced with JsSoDeliverSubjectMismatch")]
public static ClientExDetail JsSoDeliverSubjectGroupMismatch;
    [ObsoleteAttribute("replaced with more comprehensive name, replaced with JsConsumerCreate290NotAvailable")]
public static ClientExDetail JsConsumerCantUseNameBefore290;
    [ObsoleteAttribute("replaced with more comprehensive name, replaced with JsSoOrderedRequiresMaxDeliverOfOne")]
public static ClientExDetail JsSoOrderedRequiresMaxDeliver;
    public string Id { get; }
    public string Message { get; }
    internal ClientExDetail(string group, int code, string description);
    internal ClientExDetail(ClientExDetail ced, string extraMessage);
    private static ClientExDetail();
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
public string get_Message();
    internal NATSJetStreamClientException Instance();
    internal NATSJetStreamClientException Instance(string extraMessage);
}
internal enum NATS.Client.ClientProtcolVersion : Enum {
    public int value__;
    public static ClientProtcolVersion ClientProtoZero;
    public static ClientProtcolVersion ClientProtoInfo;
}
internal class NATS.Client.ConnectInfo : object {
    [CompilerGeneratedAttribute]
private bool <verbose>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <pedantic>k__BackingField;
    [CompilerGeneratedAttribute]
private string <user>k__BackingField;
    [CompilerGeneratedAttribute]
private string <pass>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ssl_required>k__BackingField;
    [CompilerGeneratedAttribute]
private string <name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <auth_token>k__BackingField;
    [CompilerGeneratedAttribute]
private string <lang>k__BackingField;
    [CompilerGeneratedAttribute]
private string <version>k__BackingField;
    [CompilerGeneratedAttribute]
private int <protocol>k__BackingField;
    [CompilerGeneratedAttribute]
private string <jwt>k__BackingField;
    [CompilerGeneratedAttribute]
private string <nkey>k__BackingField;
    [CompilerGeneratedAttribute]
private string <sig>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <echo>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <headers>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <no_responders>k__BackingField;
    public bool verbose { get; private set; }
    public bool pedantic { get; private set; }
    public string user { get; private set; }
    public string pass { get; private set; }
    public bool ssl_required { get; private set; }
    public string name { get; private set; }
    public string auth_token { get; private set; }
    public string lang { get; private set; }
    public string version { get; private set; }
    public int protocol { get; private set; }
    public string jwt { get; private set; }
    public string nkey { get; private set; }
    public string sig { get; private set; }
    public bool echo { get; private set; }
    public bool headers { get; private set; }
    public bool no_responders { get; private set; }
    internal ConnectInfo(bool verbose, bool pedantic, string ujwt, string nkey, string sig, string user, string pass, string token, bool secure, string name, bool echo);
    [CompilerGeneratedAttribute]
public bool get_verbose();
    [CompilerGeneratedAttribute]
private void set_verbose(bool value);
    [CompilerGeneratedAttribute]
public bool get_pedantic();
    [CompilerGeneratedAttribute]
private void set_pedantic(bool value);
    [CompilerGeneratedAttribute]
public string get_user();
    [CompilerGeneratedAttribute]
private void set_user(string value);
    [CompilerGeneratedAttribute]
public string get_pass();
    [CompilerGeneratedAttribute]
private void set_pass(string value);
    [CompilerGeneratedAttribute]
public bool get_ssl_required();
    [CompilerGeneratedAttribute]
private void set_ssl_required(bool value);
    [CompilerGeneratedAttribute]
public string get_name();
    [CompilerGeneratedAttribute]
private void set_name(string value);
    [CompilerGeneratedAttribute]
public string get_auth_token();
    [CompilerGeneratedAttribute]
private void set_auth_token(string value);
    [CompilerGeneratedAttribute]
public string get_lang();
    [CompilerGeneratedAttribute]
private void set_lang(string value);
    [CompilerGeneratedAttribute]
public string get_version();
    [CompilerGeneratedAttribute]
private void set_version(string value);
    [CompilerGeneratedAttribute]
public int get_protocol();
    [CompilerGeneratedAttribute]
private void set_protocol(int value);
    [CompilerGeneratedAttribute]
public string get_jwt();
    [CompilerGeneratedAttribute]
private void set_jwt(string value);
    [CompilerGeneratedAttribute]
public string get_nkey();
    [CompilerGeneratedAttribute]
private void set_nkey(string value);
    [CompilerGeneratedAttribute]
public string get_sig();
    [CompilerGeneratedAttribute]
private void set_sig(string value);
    [CompilerGeneratedAttribute]
public bool get_echo();
    [CompilerGeneratedAttribute]
private void set_echo(bool value);
    [CompilerGeneratedAttribute]
public bool get_headers();
    [CompilerGeneratedAttribute]
private void set_headers(bool value);
    [CompilerGeneratedAttribute]
public bool get_no_responders();
    [CompilerGeneratedAttribute]
private void set_no_responders(bool value);
    internal StringBuilder AppendAsJsonTo(StringBuilder sb);
}
public class NATS.Client.Connection : object {
    private Statistics stats;
    private object mu;
    private Nuid _nuid;
    private Options opts;
    private List`1<Thread> wg;
    private Uri url;
    private IServerProvider srvProvider;
    private Stream bw;
    private Stream br;
    private MemoryStream pending;
    private object flusherLock;
    private bool flusherKicked;
    private bool flusherDone;
    private ServerInfo serverInfo;
    private Dictionary`2<long, Subscription> subs;
    private ConcurrentQueue`1<SingleUseChannel`1<bool>> pongs;
    internal MsgArg msgArgs;
    internal ConnState status;
    internal Exception lastEx;
    private Timer ptmr;
    private int pout;
    internal static Random random;
    private AsyncSubscription globalRequestSubscription;
    private string globalRequestInbox;
    private long nextRequestId;
    private Dictionary`2<string, InFlightRequest> waitingRequests;
    private Byte[] PING_P_BYTES;
    private int PING_P_BYTES_LEN;
    private Byte[] PONG_P_BYTES;
    private int PONG_P_BYTES_LEN;
    private Byte[] PUB_P_BYTES;
    private int PUB_P_BYTES_LEN;
    private Byte[] HPUB_P_BYTES;
    private int HPUB_P_BYTES_LEN;
    private Byte[] CRLF_BYTES;
    private int CRLF_BYTES_LEN;
    private Byte[] pubProtoBuf;
    private static int REQ_CANCEL_IVL;
    private static int DEFAULT_FLUSH_TIMEOUT;
    private ITCPConnection conn;
    private SubChannelPool subChannelPool;
    private CallbackScheduler callbackScheduler;
    private Char[] convertToStrBuf;
    private static Byte[] rev_3digit_lut;
    private static Byte[] rev_2digit_lut;
    private static Int32[] MultiplyDeBruijnBitPosition;
    private static Int32[] PowersOf10;
    private Int32[] argEnds;
    private bool disposedValue;
    public Options Opts { get; }
    public string ConnectedUrl { get; }
    public IPAddress ClientIP { get; }
    public int ClientID { get; }
    public string ConnectedId { get; }
    public ServerInfo ServerInfo { get; }
    public String[] Servers { get; }
    public String[] DiscoveredServers { get; }
    public Exception LastError { get; }
    public ConnState State { get; }
    public int SubscriptionCount { get; }
    public IStatistics Stats { get; }
    public long MaxPayload { get; }
    internal Connection(Options options);
    private static Connection();
    public sealed virtual Options get_Opts();
    internal Channel`1<Msg> getMessageChannel();
    private void buildPublishProtocolBuffers(int size);
    private void ensurePublishProtocolBuffer(string subject, string reply);
    private void pickServer();
    private void setupServerPool();
    private bool createConn(Srv s, Exception& ex);
    private void makeTLSConn();
    private void waitForExits();
    private void pingTimerCallback(object state);
    private void stopPingTimer();
    private void startPingTimer();
    private string generateThreadName(string prefix);
    private void spinUpSocketWatchers();
    public sealed virtual string get_ConnectedUrl();
    public sealed virtual IPAddress get_ClientIP();
    public sealed virtual int get_ClientID();
    public sealed virtual string get_ConnectedId();
    public sealed virtual ServerInfo get_ServerInfo();
    public sealed virtual String[] get_Servers();
    public sealed virtual String[] get_DiscoveredServers();
    private void processConnectInit(Srv s);
    internal bool connect(Srv s, Exception& exToThrow);
    internal void ScheduleErrorEvent(object sender, NATSException ex, Subscription subscription);
    internal void connect(bool reconnectOnConnect);
    private void checkForSecure(Srv s);
    private void processExpectedInfo();
    internal void SendUnsub(long sid, int max);
    internal void SendSub(string subject, string queue, long sid);
    private void writeString(string format, string a, string b);
    private void writeString(string format, string a, string b, string c);
    private void writeString(string value);
    private void sendProto(Byte[] value, int length);
    private string connectProto();
    private void sendConnect();
    private Control readOp();
    private void processDisconnect();
    public sealed virtual void Reconnect(ReconnectOptions reconnectOptions);
    private void processReconnect();
    private void flushReconnectPendingItems();
    private static void sleep(int millis);
    private void scheduleConnEvent(EventHandler`1<ConnEventArgs> connEvent, Exception error);
    private void DefaultReconnectDelayHandler(object o, ReconnectDelayEventArgs args);
    private void doReconnect();
    private bool isConnecting();
    private void processOpError(Exception e);
    private void readLoop();
    internal void deliverMsgs(Channel`1<Msg> ch);
    private int writeStringToBuffer(Byte[] buffer, int offset, string value);
    private int writeInt32ToBuffer(Byte[] buffer, int offset, int value);
    private int setMsgArgsAryOffsets(Byte[] buffer, long length);
    internal void processHeaderMsgArgs(Byte[] buffer, long length);
    internal void processMsgArgs(Byte[] buffer, long length);
    private static long ToInt64(Byte[] buffer, int start, int end);
    internal void processMsg(Byte[] msgBytes, long length);
    internal void processSlowConsumer(Subscription s);
    private void kickFlusher();
    private bool waitForFlusherKick();
    private void setFlusherDone(bool value);
    private bool isFlusherDone();
    private void flusher();
    internal void processPing();
    internal void processPong();
    internal void processOK();
    internal virtual void processInfo(string json, bool notify);
    internal void processAsyncInfo(Byte[] jsonBytes, int length);
    public sealed virtual Exception get_LastError();
    internal void processErr(MemoryStream errorStream);
    private string getNormalizedError(MemoryStream errorStream);
    private void WriteHPUBProto(Byte[] dst, string subject, string reply, int headerSize, int msgSize, Int32& length, Int32& offset);
    private void WritePUBProto(Byte[] dst, string subject, string reply, int msgSize, Int32& length, Int32& offset);
    internal void PublishImpl(string subject, string reply, MsgHeader inHeaders, Byte[] data, int offset, Nullable`1<int> inCount, bool flushBuffer);
    public sealed virtual void Publish(string subject, Byte[] data);
    public sealed virtual void Publish(string subject, MsgHeader headers, Byte[] data);
    public sealed virtual void Publish(string subject, Byte[] data, int offset, int count);
    public sealed virtual void Publish(string subject, MsgHeader headers, Byte[] data, int offset, int count);
    public sealed virtual void Publish(string subject, string reply, Byte[] data);
    public sealed virtual void Publish(string subject, string reply, MsgHeader headers, Byte[] data);
    public sealed virtual void Publish(string subject, string reply, Byte[] data, int offset, int count);
    public sealed virtual void Publish(string subject, string reply, MsgHeader headers, Byte[] data, int offset, int count);
    public sealed virtual void Publish(Msg msg);
    private void RemoveOutstandingRequest(string requestId);
    private static bool IsNoRespondersMsg(Msg m);
    private void RequestResponseHandler(object sender, MsgHandlerEventArgs args);
    private InFlightRequest setupRequest(int timeout, CancellationToken token);
    internal Msg RequestSyncImpl(string subject, MsgHeader headers, Byte[] data, int offset, Nullable`1<int> count, int timeout);
    [AsyncStateMachineAttribute("NATS.Client.Connection/<RequestAsyncImpl>d__148")]
private Task`1<Msg> RequestAsyncImpl(string subject, MsgHeader headers, Byte[] data, int offset, Nullable`1<int> count, int timeout, CancellationToken token);
    private Msg OldRequestImpl(string subject, MsgHeader headers, Byte[] data, int offset, Nullable`1<int> count, int timeout);
    public sealed virtual Msg Request(string subject, Byte[] data, int timeout);
    public sealed virtual Msg Request(string subject, MsgHeader headers, Byte[] data, int timeout);
    public sealed virtual Msg Request(string subject, Byte[] data, int offset, int count, int timeout);
    public sealed virtual Msg Request(string subject, MsgHeader headers, Byte[] data, int offset, int count, int timeout);
    public sealed virtual Msg Request(string subject, Byte[] data);
    public sealed virtual Msg Request(string subject, MsgHeader headers, Byte[] data);
    public sealed virtual Msg Request(string subject, Byte[] data, int offset, int count);
    public sealed virtual Msg Request(string subject, MsgHeader headers, Byte[] data, int offset, int count);
    public sealed virtual Msg Request(Msg message, int timeout);
    public sealed virtual Msg Request(Msg message);
    private Task`1<Msg> OldRequestAsyncImpl(string subject, MsgHeader headers, Byte[] data, int offset, Nullable`1<int> count, int timeout, CancellationToken ct);
    public sealed virtual Task`1<Msg> RequestAsync(string subject, Byte[] data, int timeout);
    public sealed virtual Task`1<Msg> RequestAsync(string subject, MsgHeader headers, Byte[] data, int timeout);
    public sealed virtual Task`1<Msg> RequestAsync(string subject, Byte[] data, int offset, int count, int timeout);
    public sealed virtual Task`1<Msg> RequestAsync(string subject, MsgHeader headers, Byte[] data, int offset, int count, int timeout);
    public sealed virtual Task`1<Msg> RequestAsync(string subject, Byte[] data);
    public sealed virtual Task`1<Msg> RequestAsync(string subject, MsgHeader headers, Byte[] data);
    public sealed virtual Task`1<Msg> RequestAsync(string subject, Byte[] data, int offset, int count);
    public sealed virtual Task`1<Msg> RequestAsync(string subject, MsgHeader headers, Byte[] data, int offset, int count);
    public sealed virtual Task`1<Msg> RequestAsync(string subject, Byte[] data, int timeout, CancellationToken token);
    public sealed virtual Task`1<Msg> RequestAsync(string subject, MsgHeader headers, Byte[] data, int timeout, CancellationToken token);
    public sealed virtual Task`1<Msg> RequestAsync(string subject, Byte[] data, CancellationToken token);
    public sealed virtual Task`1<Msg> RequestAsync(string subject, MsgHeader headers, Byte[] data, CancellationToken token);
    public sealed virtual Task`1<Msg> RequestAsync(string subject, Byte[] data, int offset, int count, CancellationToken token);
    public sealed virtual Task`1<Msg> RequestAsync(string subject, MsgHeader headers, Byte[] data, int offset, int count, CancellationToken token);
    public sealed virtual Task`1<Msg> RequestAsync(Msg message, int timeout);
    public sealed virtual Task`1<Msg> RequestAsync(Msg message);
    public sealed virtual Task`1<Msg> RequestAsync(Msg message, int timeout, CancellationToken token);
    public sealed virtual Task`1<Msg> RequestAsync(Msg message, CancellationToken token);
    public sealed virtual string NewInbox();
    internal void sendSubscriptionMessage(AsyncSubscription s);
    internal void AddSubscription(Subscription s);
    internal void RemoveSubscription(Subscription s);
    private void enableSubChannelPooling();
    private void disableSubChannelPooling();
    internal AsyncSubscription subscribeAsync(string subject, string queue, EventHandler`1<MsgHandlerEventArgs> handler, CreateAsyncSubscriptionDelegate createAsyncSubscriptionDelegate);
    internal SyncSubscription subscribeSync(string subject, string queue, CreateSyncSubscriptionDelegate syncSubDelegate);
    public sealed virtual ISyncSubscription SubscribeSync(string subject);
    public sealed virtual IAsyncSubscription SubscribeAsync(string subject);
    public sealed virtual IAsyncSubscription SubscribeAsync(string subject, EventHandler`1<MsgHandlerEventArgs> handler);
    public sealed virtual ISyncSubscription SubscribeSync(string subject, string queue);
    public sealed virtual IAsyncSubscription SubscribeAsync(string subject, string queue);
    public sealed virtual IAsyncSubscription SubscribeAsync(string subject, string queue, EventHandler`1<MsgHandlerEventArgs> handler);
    internal Task unsubscribe(Subscription sub, int max, bool drain, int timeout);
    internal void removeSubSafe(Subscription s);
    internal virtual void removeSub(Subscription s);
    private bool removeFlushEntry(SingleUseChannel`1<bool> chan);
    private void sendPing(SingleUseChannel`1<bool> ch);
    private void saveFlushException(Exception e);
    public sealed virtual void Flush(int timeout);
    public sealed virtual TimeSpan RTT();
    public sealed virtual void Flush();
    public sealed virtual void FlushBuffer();
    private void resendSubscriptions();
    private void clearPendingFlushCalls();
    private void clearPendingRequestCalls();
    private void close(ConnState closeState, bool invokeDelegates, Exception error, bool authAuthError);
    public sealed virtual void Close();
    private bool isClosed();
    public sealed virtual bool IsClosed();
    private void checkDrained(Subscription s, int timeout);
    internal void pushDrainException(Subscription s, Exception ex);
    private void drain(int timeout);
    public sealed virtual void Drain();
    public sealed virtual void Drain(int timeout);
    public sealed virtual Task DrainAsync();
    public sealed virtual Task DrainAsync(int timeout);
    private bool isDrainingPubs();
    private bool isDrainingSubs();
    public sealed virtual bool IsDraining();
    public sealed virtual bool IsReconnecting();
    public sealed virtual ConnState get_State();
    public sealed virtual int get_SubscriptionCount();
    private bool isReconnecting();
    private bool isConnected();
    public sealed virtual IStatistics get_Stats();
    public sealed virtual void ResetStats();
    public sealed virtual long get_MaxPayload();
    public virtual string ToString();
    protected virtual void Dispose(bool disposing);
    public sealed virtual void Dispose();
    public sealed virtual IStreamContext GetStreamContext(string streamName);
    public sealed virtual IStreamContext GetStreamContext(string streamName, JetStreamOptions options);
    public sealed virtual IConsumerContext GetConsumerContext(string streamName, string consumerName);
    public sealed virtual IConsumerContext GetConsumerContext(string streamName, string consumerName, JetStreamOptions options);
    public sealed virtual IJetStream CreateJetStreamContext(JetStreamOptions options);
    public sealed virtual IJetStreamManagement CreateJetStreamManagementContext(JetStreamOptions options);
    public sealed virtual IKeyValue CreateKeyValueContext(string bucketName, KeyValueOptions options);
    public sealed virtual IKeyValueManagement CreateKeyValueManagementContext(KeyValueOptions options);
    public sealed virtual IObjectStore CreateObjectStoreContext(string bucketName, ObjectStoreOptions options);
    public sealed virtual IObjectStoreManagement CreateObjectStoreManagementContext(ObjectStoreOptions options);
    [CompilerGeneratedAttribute]
private void <processReconnect>b__93_0();
    [CompilerGeneratedAttribute]
private AsyncSubscription <subscribeAsync>b__187_0(Connection lConn, string lSubject, string lQueue);
}
public class NATS.Client.ConnectionFactory : object {
    public sealed virtual IConnection CreateConnection(string url, bool reconnectOnConnect);
    public sealed virtual IConnection CreateConnection(string url, string credentialsPath, bool reconnectOnConnect);
    public sealed virtual IConnection CreateConnection(string url, string jwt, string privateNkey, bool reconnectOnConnect);
    public IConnection CreateConnectionWithCredentials(string url, string credentialsText, bool reconnectOnConnect);
    public IConnection CreateConnectionWithCredentials(string url, string userJwtText, string nkeySeedText, bool reconnectOnConnect);
    public static Options GetDefaultOptions(string server);
    public sealed virtual IConnection CreateSecureConnection(string url, bool reconnectOnConnect);
    public sealed virtual IConnection CreateConnection(bool reconnectOnConnect);
    public sealed virtual IConnection CreateConnection(Options opts, bool reconnectOnConnect);
    public sealed virtual IEncodedConnection CreateEncodedConnection(bool reconnectOnConnect);
    public sealed virtual IEncodedConnection CreateEncodedConnection(string url, bool reconnectOnConnect);
    public sealed virtual IEncodedConnection CreateEncodedConnection(Options opts, bool reconnectOnConnect);
}
public class NATS.Client.ConnEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private Connection <Conn>k__BackingField;
    [CompilerGeneratedAttribute]
private Exception <Error>k__BackingField;
    public Connection Conn { get; }
    public Exception Error { get; }
    internal ConnEventArgs(Connection c, Exception error);
    [CompilerGeneratedAttribute]
public Connection get_Conn();
    [CompilerGeneratedAttribute]
public Exception get_Error();
}
public class NATS.Client.ConnJsSubEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private Connection <Conn>k__BackingField;
    [CompilerGeneratedAttribute]
private Subscription <Sub>k__BackingField;
    [CompilerGeneratedAttribute]
private IJetStreamSubscription <JetStreamSub>k__BackingField;
    public Connection Conn { get; }
    public Subscription Sub { get; }
    public IJetStreamSubscription JetStreamSub { get; }
    protected ConnJsSubEventArgs(Connection conn, Subscription sub);
    [CompilerGeneratedAttribute]
public Connection get_Conn();
    [CompilerGeneratedAttribute]
public Subscription get_Sub();
    [CompilerGeneratedAttribute]
public IJetStreamSubscription get_JetStreamSub();
}
public enum NATS.Client.ConnState : Enum {
    public int value__;
    public static ConnState DISCONNECTED;
    public static ConnState CONNECTED;
    public static ConnState CLOSED;
    public static ConnState RECONNECTING;
    public static ConnState CONNECTING;
    public static ConnState DRAINING_SUBS;
    public static ConnState DRAINING_PUBS;
}
internal static class NATS.Client.Crc16 : object {
    private static UInt16[] crc16tab;
    private static Crc16();
    internal static ushort Checksum(Byte[] data);
}
public static class NATS.Client.Defaults : object {
    public static string Version;
    public static string Url;
    public static int Port;
    public static int MaxReconnect;
    public static int ReconnectWait;
    public static int Timeout;
    public static int PingInterval;
    public static int MaxPingOut;
    public static int MaxChanLen;
    public static int RequestChanLen;
    public static string LangString;
    public static long SubPendingMsgsLimit;
    public static long SubPendingBytesLimit;
    public static int DefaultDrainTimeout;
    public static int ReconnectBufferSize;
    public static int ReconnectJitter;
    public static int ReconnectJitterTLS;
    internal static int MaxControlLineSize;
    public static int defaultBufSize;
    internal static int defaultReadLength;
    internal static int defaultPendingSize;
    internal static int srvPoolSize;
    private static Defaults();
    public static EventHandler`1<ConnEventArgs> DefaultClosedEventHandler();
    public static EventHandler`1<ConnEventArgs> DefaultServerDiscoveredEventHandler();
    public static EventHandler`1<ConnEventArgs> DefaultDisconnectedEventHandler();
    public static EventHandler`1<ConnEventArgs> DefaultReconnectedEventHandler();
    public static EventHandler`1<ConnEventArgs> DefaultLameDuckModeEventHandler();
    public static EventHandler`1<ErrEventArgs> DefaultAsyncErrorEventHandler();
    public static EventHandler`1<HeartbeatAlarmEventArgs> DefaultHeartbeatAlarmEventHandler();
    public static EventHandler`1<UnhandledStatusEventArgs> DefaultUnhandledStatusEventHandler();
    public static EventHandler`1<StatusEventArgs> DefaultPullStatusWarningEventHandler();
    public static EventHandler`1<StatusEventArgs> DefaultPullStatusErrorEventHandler();
    public static EventHandler`1<FlowControlProcessedEventArgs> DefaultFlowControlProcessedEventHandler();
    private static void WriteJsEvent(string label, ConnJsSubEventArgs e, Object[] pairs);
    private static void WriteEvent(string label, ConnEventArgs e);
    private static void WriteError(string label, ErrEventArgs e);
    private static StringBuilder BeginFormatMessage(string label, Connection conn, Subscription sub, string error);
}
public class NATS.Client.DefaultUserJWTHandler : object {
    private string jwtFile;
    private string credsFile;
    public string JwtFile { get; }
    public string CredsFile { get; }
    public DefaultUserJWTHandler(string jwtFilePath, string credsFilePath);
    public string get_JwtFile();
    public string get_CredsFile();
    public static string LoadUserFromFile(string path);
    public static NkeyPair LoadNkeyPairFromSeedFile(string path);
    public void DefaultUserJWTEventHandler(object sender, UserJWTEventArgs args);
    public static void SignNonceFromFile(string credsFile, UserSignatureEventArgs args);
    public void DefaultUserSignatureHandler(object sender, UserSignatureEventArgs args);
}
public class NATS.Client.Deserializer : MulticastDelegate {
    public Deserializer(object object, IntPtr method);
    public virtual object Invoke(Byte[] data);
    public virtual IAsyncResult BeginInvoke(Byte[] data, AsyncCallback callback, object object);
    public virtual object EndInvoke(IAsyncResult result);
}
public class NATS.Client.EncodedConnection : Connection {
    private MemoryStream sStream;
    private object sStreamLock;
    private MemoryStream dStream;
    private object dStreamLock;
    private Serializer onSerialize;
    private Deserializer onDeserialize;
    private Serializer defaultSerializer;
    private Deserializer defaultDeserializer;
    private IDictionary`2<ISubscription, EncodedHandlerWrapper> wrappers;
    public Serializer OnSerialize { get; public set; }
    public Deserializer OnDeserialize { get; public set; }
    internal EncodedConnection(Options opts);
    private void PublishObjectImpl(string subject, string reply, MsgHeader headers, object o);
    public sealed virtual void Publish(string subject, object obj);
    public sealed virtual void Publish(string subject, MsgHeader headers, object obj);
    public sealed virtual void Publish(string subject, string reply, object obj);
    public sealed virtual void Publish(string subject, string reply, MsgHeader headers, object obj);
    private IAsyncSubscription subscribeAsync(string subject, string reply, EventHandler`1<EncodedMessageEventArgs> handler);
    public sealed virtual IAsyncSubscription SubscribeAsync(string subject, EventHandler`1<EncodedMessageEventArgs> handler);
    public sealed virtual IAsyncSubscription SubscribeAsync(string subject, string queue, EventHandler`1<EncodedMessageEventArgs> handler);
    private object RequestObjectImpl(string subject, MsgHeader headers, object obj, int timeout);
    public sealed virtual object Request(string subject, object obj, int timeout);
    public sealed virtual object Request(string subject, MsgHeader headers, object obj, int timeout);
    public sealed virtual object Request(string subject, object obj);
    public sealed virtual object Request(string subject, MsgHeader headers, object obj);
    internal virtual void removeSub(Subscription s);
    public sealed virtual Serializer get_OnSerialize();
    public sealed virtual void set_OnSerialize(Serializer value);
    public sealed virtual Deserializer get_OnDeserialize();
    public sealed virtual void set_OnDeserialize(Deserializer value);
    protected virtual void Dispose(bool disposing);
}
public class NATS.Client.EncodedMessageEventArgs : EventArgs {
    internal string subject;
    internal string reply;
    internal object obj;
    internal Msg msg;
    public string Subject { get; }
    public string Reply { get; }
    public object ReceivedObject { get; }
    public Msg Message { get; }
    public string get_Subject();
    public string get_Reply();
    public object get_ReceivedObject();
    public Msg get_Message();
}
public static class NATS.Client.EncodingUtils : object {
    public static string ToBase64UrlEncoded(Byte[] bytes);
    public static string FromBase64UrlEncoded(string s);
}
public class NATS.Client.ErrEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private Connection <Conn>k__BackingField;
    [CompilerGeneratedAttribute]
private Subscription <Subscription>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Error>k__BackingField;
    public Connection Conn { get; }
    public Subscription Subscription { get; }
    public string Error { get; }
    public ErrEventArgs(Connection conn, Subscription subscription, string error);
    [CompilerGeneratedAttribute]
public Connection get_Conn();
    [CompilerGeneratedAttribute]
public Subscription get_Subscription();
    [CompilerGeneratedAttribute]
public string get_Error();
}
public class NATS.Client.FlowControlProcessedEventArgs : ConnJsSubEventArgs {
    [CompilerGeneratedAttribute]
private string <FcSubject>k__BackingField;
    [CompilerGeneratedAttribute]
private FlowControlSource <Source>k__BackingField;
    public string FcSubject { get; }
    public FlowControlSource Source { get; }
    public FlowControlProcessedEventArgs(Connection c, Subscription s, string fcSubject, FlowControlSource source);
    [CompilerGeneratedAttribute]
public string get_FcSubject();
    [CompilerGeneratedAttribute]
public FlowControlSource get_Source();
}
public enum NATS.Client.FlowControlSource : Enum {
    public int value__;
    public static FlowControlSource FlowControl;
    public static FlowControlSource Heartbeat;
}
public class NATS.Client.HeartbeatAlarmEventArgs : ConnJsSubEventArgs {
    [CompilerGeneratedAttribute]
private ulong <LastStreamSequence>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <LastConsumerSequence>k__BackingField;
    public ulong LastStreamSequence { get; }
    public ulong LastConsumerSequence { get; }
    public HeartbeatAlarmEventArgs(Connection c, Subscription s, ulong lastStreamSequence, ulong lastConsumerSequence);
    [CompilerGeneratedAttribute]
public ulong get_LastStreamSequence();
    [CompilerGeneratedAttribute]
public ulong get_LastConsumerSequence();
}
public interface NATS.Client.IAsyncSubscription {
    [CompilerGeneratedAttribute]
public abstract virtual void add_MessageHandler(EventHandler`1<MsgHandlerEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_MessageHandler(EventHandler`1<MsgHandlerEventArgs> value);
    public abstract virtual void Start();
}
internal class NATS.Client.IC : object {
    internal static string _CRLF_;
    internal static string _EMPTY_;
    internal static string _SPC_;
    internal static string _PUB_P_;
    internal static string _HPUB_P_;
    internal static string _OK_OP_;
    internal static string _ERR_OP_;
    internal static string _MSG_OP_;
    internal static string _PING_OP_;
    internal static string _PONG_OP_;
    internal static string _INFO_OP_;
    internal static string inboxPrefix;
    internal static string conProtoNoCRLF;
    internal static string pingProto;
    internal static string pongProto;
    internal static string pubProto;
    internal static string subProto;
    internal static string unsubProto;
    internal static string pongProtoNoCRLF;
    internal static string okProtoNoCRLF;
    internal static string STALE_CONNECTION;
    internal static string AUTH_TIMEOUT;
}
public interface NATS.Client.IConnection {
    public Options Opts { get; }
    public IPAddress ClientIP { get; }
    public int ClientID { get; }
    public string ConnectedUrl { get; }
    public string ConnectedId { get; }
    public ServerInfo ServerInfo { get; }
    public String[] Servers { get; }
    public String[] DiscoveredServers { get; }
    public Exception LastError { get; }
    public ConnState State { get; }
    public IStatistics Stats { get; }
    public long MaxPayload { get; }
    public int SubscriptionCount { get; }
    public abstract virtual Options get_Opts();
    public abstract virtual IPAddress get_ClientIP();
    public abstract virtual int get_ClientID();
    public abstract virtual string get_ConnectedUrl();
    public abstract virtual string get_ConnectedId();
    public abstract virtual ServerInfo get_ServerInfo();
    public abstract virtual String[] get_Servers();
    public abstract virtual String[] get_DiscoveredServers();
    public abstract virtual Exception get_LastError();
    public abstract virtual void Reconnect(ReconnectOptions reconnectOptions);
    public abstract virtual void Publish(string subject, Byte[] data);
    public abstract virtual void Publish(string subject, MsgHeader headers, Byte[] data);
    public abstract virtual void Publish(string subject, Byte[] data, int offset, int count);
    public abstract virtual void Publish(string subject, MsgHeader headers, Byte[] data, int offset, int count);
    public abstract virtual void Publish(string subject, string reply, Byte[] data);
    public abstract virtual void Publish(string subject, string reply, MsgHeader headers, Byte[] data);
    public abstract virtual void Publish(string subject, string reply, Byte[] data, int offset, int count);
    public abstract virtual void Publish(string subject, string reply, MsgHeader headers, Byte[] data, int offset, int count);
    public abstract virtual void Publish(Msg msg);
    public abstract virtual Msg Request(string subject, Byte[] data, int timeout);
    public abstract virtual Msg Request(string subject, MsgHeader headers, Byte[] data, int timeout);
    public abstract virtual Msg Request(string subject, Byte[] data, int offset, int count, int timeout);
    public abstract virtual Msg Request(string subject, MsgHeader headers, Byte[] data, int offset, int count, int timeout);
    public abstract virtual Msg Request(string subject, Byte[] data);
    public abstract virtual Msg Request(string subject, MsgHeader headers, Byte[] data);
    public abstract virtual Msg Request(string subject, Byte[] data, int offset, int count);
    public abstract virtual Msg Request(string subject, MsgHeader headers, Byte[] data, int offset, int count);
    public abstract virtual Msg Request(Msg message);
    public abstract virtual Msg Request(Msg message, int timeout);
    public abstract virtual Task`1<Msg> RequestAsync(string subject, Byte[] data, int timeout);
    public abstract virtual Task`1<Msg> RequestAsync(string subject, MsgHeader headers, Byte[] data, int timeout);
    public abstract virtual Task`1<Msg> RequestAsync(string subject, Byte[] data, int offset, int count, int timeout);
    public abstract virtual Task`1<Msg> RequestAsync(string subject, MsgHeader headers, Byte[] data, int offset, int count, int timeout);
    public abstract virtual Task`1<Msg> RequestAsync(string subject, Byte[] data);
    public abstract virtual Task`1<Msg> RequestAsync(string subject, MsgHeader headers, Byte[] data);
    public abstract virtual Task`1<Msg> RequestAsync(string subject, Byte[] data, int offset, int count);
    public abstract virtual Task`1<Msg> RequestAsync(string subject, MsgHeader headers, Byte[] data, int offset, int count);
    public abstract virtual Task`1<Msg> RequestAsync(string subject, Byte[] data, int timeout, CancellationToken token);
    public abstract virtual Task`1<Msg> RequestAsync(string subject, MsgHeader headers, Byte[] data, int timeout, CancellationToken token);
    public abstract virtual Task`1<Msg> RequestAsync(string subject, Byte[] data, CancellationToken token);
    public abstract virtual Task`1<Msg> RequestAsync(string subject, MsgHeader headers, Byte[] data, CancellationToken token);
    public abstract virtual Task`1<Msg> RequestAsync(string subject, Byte[] data, int offset, int count, CancellationToken token);
    public abstract virtual Task`1<Msg> RequestAsync(string subject, MsgHeader headers, Byte[] data, int offset, int count, CancellationToken token);
    public abstract virtual Task`1<Msg> RequestAsync(Msg message);
    public abstract virtual Task`1<Msg> RequestAsync(Msg message, int timeout);
    public abstract virtual Task`1<Msg> RequestAsync(Msg message, CancellationToken token);
    public abstract virtual Task`1<Msg> RequestAsync(Msg message, int timeout, CancellationToken token);
    public abstract virtual string NewInbox();
    public abstract virtual ISyncSubscription SubscribeSync(string subject);
    public abstract virtual IAsyncSubscription SubscribeAsync(string subject);
    public abstract virtual IAsyncSubscription SubscribeAsync(string subject, EventHandler`1<MsgHandlerEventArgs> handler);
    public abstract virtual ISyncSubscription SubscribeSync(string subject, string queue);
    public abstract virtual IAsyncSubscription SubscribeAsync(string subject, string queue);
    public abstract virtual IAsyncSubscription SubscribeAsync(string subject, string queue, EventHandler`1<MsgHandlerEventArgs> handler);
    public abstract virtual void Flush(int timeout);
    public abstract virtual TimeSpan RTT();
    public abstract virtual void Flush();
    public abstract virtual void FlushBuffer();
    public abstract virtual void Close();
    public abstract virtual bool IsClosed();
    public abstract virtual bool IsReconnecting();
    public abstract virtual ConnState get_State();
    public abstract virtual IStatistics get_Stats();
    public abstract virtual void ResetStats();
    public abstract virtual long get_MaxPayload();
    public abstract virtual Task DrainAsync();
    public abstract virtual Task DrainAsync(int timeout);
    public abstract virtual void Drain();
    public abstract virtual void Drain(int timeout);
    public abstract virtual bool IsDraining();
    public abstract virtual int get_SubscriptionCount();
    public abstract virtual IStreamContext GetStreamContext(string streamName);
    public abstract virtual IStreamContext GetStreamContext(string streamName, JetStreamOptions options);
    public abstract virtual IConsumerContext GetConsumerContext(string streamName, string consumerName);
    public abstract virtual IConsumerContext GetConsumerContext(string streamName, string consumerName, JetStreamOptions options);
    public abstract virtual IJetStream CreateJetStreamContext(JetStreamOptions options);
    public abstract virtual IJetStreamManagement CreateJetStreamManagementContext(JetStreamOptions options);
    public abstract virtual IKeyValue CreateKeyValueContext(string bucketName, KeyValueOptions options);
    public abstract virtual IKeyValueManagement CreateKeyValueManagementContext(KeyValueOptions options);
    public abstract virtual IObjectStore CreateObjectStoreContext(string bucketName, ObjectStoreOptions options);
    public abstract virtual IObjectStoreManagement CreateObjectStoreManagementContext(ObjectStoreOptions options);
}
public interface NATS.Client.IConnectionFactory {
    public abstract virtual IConnection CreateConnection(string url, bool reconnectOnConnect);
    public abstract virtual IConnection CreateConnection(string url, string credentialsPath, bool reconnectOnConnect);
    public abstract virtual IConnection CreateConnection(string url, string jwt, string privateNkey, bool reconnectOnConnect);
    public abstract virtual IConnection CreateConnection(bool reconnectOnConnect);
    public abstract virtual IConnection CreateConnection(Options opts, bool reconnectOnConnect);
    public abstract virtual IConnection CreateSecureConnection(string url, bool reconnectOnConnect);
    public abstract virtual IEncodedConnection CreateEncodedConnection(bool reconnectOnConnect);
    public abstract virtual IEncodedConnection CreateEncodedConnection(string url, bool reconnectOnConnect);
    public abstract virtual IEncodedConnection CreateEncodedConnection(Options opts, bool reconnectOnConnect);
}
public interface NATS.Client.IEncodedConnection {
    public Options Opts { get; }
    public string ConnectedUrl { get; }
    public string ConnectedId { get; }
    public String[] Servers { get; }
    public String[] DiscoveredServers { get; }
    public Exception LastError { get; }
    public ConnState State { get; }
    public IStatistics Stats { get; }
    public long MaxPayload { get; }
    public Serializer OnSerialize { get; public set; }
    public Deserializer OnDeserialize { get; public set; }
    public int SubscriptionCount { get; }
    public abstract virtual Options get_Opts();
    public abstract virtual string get_ConnectedUrl();
    public abstract virtual string get_ConnectedId();
    public abstract virtual String[] get_Servers();
    public abstract virtual String[] get_DiscoveredServers();
    public abstract virtual Exception get_LastError();
    public abstract virtual void Publish(string subject, object obj);
    public abstract virtual void Publish(string subject, MsgHeader headers, object obj);
    public abstract virtual void Publish(string subject, string reply, object obj);
    public abstract virtual void Publish(string subject, string reply, MsgHeader headers, object obj);
    public abstract virtual object Request(string subject, object obj, int timeout);
    public abstract virtual object Request(string subject, MsgHeader headers, object obj, int timeout);
    public abstract virtual object Request(string subject, object obj);
    public abstract virtual object Request(string subject, MsgHeader headers, object obj);
    public abstract virtual string NewInbox();
    public abstract virtual IAsyncSubscription SubscribeAsync(string subject, EventHandler`1<EncodedMessageEventArgs> handler);
    public abstract virtual IAsyncSubscription SubscribeAsync(string subject, string queue, EventHandler`1<EncodedMessageEventArgs> handler);
    public abstract virtual void Flush(int timeout);
    public abstract virtual void Flush();
    public abstract virtual void FlushBuffer();
    public abstract virtual void Close();
    public abstract virtual bool IsClosed();
    public abstract virtual bool IsReconnecting();
    public abstract virtual ConnState get_State();
    public abstract virtual IStatistics get_Stats();
    public abstract virtual void ResetStats();
    public abstract virtual long get_MaxPayload();
    public abstract virtual Serializer get_OnSerialize();
    public abstract virtual void set_OnSerialize(Serializer value);
    public abstract virtual Deserializer get_OnDeserialize();
    public abstract virtual void set_OnDeserialize(Deserializer value);
    public abstract virtual Task DrainAsync();
    public abstract virtual Task DrainAsync(int timeout);
    public abstract virtual void Drain();
    public abstract virtual void Drain(int timeout);
    public abstract virtual bool IsDraining();
    public abstract virtual int get_SubscriptionCount();
}
public class NATS.Client.Internals.Claim : JsonSerializable {
    public string Aud;
    public string Jti;
    public long Iat;
    public string Iss;
    public string Name;
    public string Sub;
    public Duration Exp;
    public JsonSerializable Nats;
    public virtual JSONNode ToJsonNode();
}
internal static class NATS.Client.Internals.CompletedTask : object {
    internal static Task Get();
}
public class NATS.Client.Internals.Digester : object {
    private IncrementalHash hasher;
    private string digest;
    private string entry;
    public void AppendData(string s);
    public void AppendData(Byte[] data);
    private void _prepareDigest();
    public string GetDigestValue();
    public string GetDigestEntry();
    public bool DigestEntriesMatch(string thatEntry);
}
public class NATS.Client.Internals.Duration : object {
    public static long NanosPerMilli;
    public static long NanosPerSecond;
    public static long NanosPerMinute;
    public static long NanosPerHour;
    public static long NanosPerDay;
    public static Duration Zero;
    public static Duration One;
    [CompilerGeneratedAttribute]
private long <Nanos>k__BackingField;
    public long Nanos { get; }
    public int Millis { get; }
    private Duration(long nanos);
    private static Duration();
    [CompilerGeneratedAttribute]
public long get_Nanos();
    public int get_Millis();
    public static Duration OfNanos(long nanos);
    public static Duration OfMillis(long millis);
    public static Duration OfSeconds(long seconds);
    public static Duration OfMinutes(long minutes);
    public static Duration OfHours(long hours);
    public static Duration OfDays(long days);
    public bool IsZero();
    public bool IsNegative();
    public bool IsPositive();
    public virtual bool Equals(object obj);
    private bool Equals(Duration other);
    public virtual int GetHashCode();
    public virtual string ToString();
    public string ToDescription();
}
[ExtensionAttribute]
internal static class NATS.Client.Internals.Formatting : object {
    [ExtensionAttribute]
internal static string ToNumericString(int v);
    [ExtensionAttribute]
internal static string ToNumericString(long v);
}
public class NATS.Client.Internals.HeaderStatusReader : object {
    private int _serializedLength;
    private MsgHeader _header;
    private MsgStatus _status;
    public int SerializedLength { get; }
    public MsgHeader Header { get; }
    public MsgStatus Status { get; }
    public HeaderStatusReader(Byte[] bytes, int byteCount);
    public int get_SerializedLength();
    public MsgHeader get_Header();
    public MsgStatus get_Status();
    private void InitHeader(Byte[] serialized, int len, Token tCrlf, bool hadStatus);
    private Token InitStatus(Byte[] serialized, int len, Token tSpace);
}
internal class NATS.Client.Internals.InFlightRequest : object {
    private Action`1<string> _onCompleted;
    private CancellationTokenSource _tokenSource;
    private CancellationTokenRegistration _tokenRegistration;
    private CancellationToken _clientProvidedToken;
    internal TaskCompletionSource`1<Msg> Waiter;
    public string Id;
    public CancellationToken Token;
    internal InFlightRequest(string id, CancellationToken token, int timeout, Action`1<string> onCompleted);
    private static void CancellationCallback(object req);
    public sealed virtual void Dispose();
}
public class NATS.Client.Internals.InterlockedBoolean : object {
    private long _flag;
    public InterlockedBoolean(bool flag);
    public void Set(bool flag);
    public bool IsTrue();
    public bool IsFalse();
    public virtual string ToString();
}
public class NATS.Client.Internals.InterlockedInt : object {
    private InterlockedLong _il;
    public InterlockedInt(int start);
    public void Set(int i);
    public int Increment();
    public int Decrement();
    public long Add(int value);
    public int Read();
    public virtual string ToString();
}
public class NATS.Client.Internals.InterlockedLong : object {
    private long count;
    public InterlockedLong(long start);
    public void Set(long l);
    public long Increment();
    public long Decrement();
    public long Add(long value);
    public long Read();
    public virtual string ToString();
}
public static class NATS.Client.Internals.JetStreamConstants : object {
    [ObsoleteAttribute("This property is obsolete. We do not enforce a limit on pull batch size.", "False")]
public static int MaxPullSize;
    public static int MaxHistoryPerKey;
    public static string PrefixDollarJsDot;
    public static string PrefixApiDot;
    public static string PrefixApi;
    public static string DefaultApiPrefix;
    public static string JsAckSubjectPrefix;
    public static string JsapiAccountInfo;
    public static string JsapiConsumerCreate;
    public static string JsapiConsumerCreateV290;
    public static string JsapiConsumerCreateV290WithFilter;
    public static string JsapiDurableCreate;
    public static string JsapiConsumerInfo;
    public static string JsapiConsumerMsgNext;
    public static string JsapiConsumerDelete;
    public static string JsapiConsumerPause;
    public static string JsapiConsumerNames;
    public static string JsapiConsumerList;
    public static string JsapiStreamNames;
    public static string JsapiStreamCreate;
    public static string JsapiStreamInfo;
    public static string JsapiStreamUpdate;
    public static string JsapiStreamDelete;
    public static string JsapiStreamPurge;
    public static string JsapiStreamList;
    public static string JsapiMsgGet;
    public static string JsapiDirectGet;
    public static string JsapiDirectGetLast;
    public static string JsapiMsgDelete;
    public static string MsgIdHeader;
    public static string ExpStreamHeader;
    public static string ExpLastSeqHeader;
    public static string ExpLastIdHeader;
    public static string ExpLastSubjectSeqHeader;
    public static string LastConsumerHeader;
    public static string LastStreamHeader;
    public static string ConsumerStalledHeader;
    public static string MsgSizeHeader;
    public static string RollupHeader;
    public static string RollupHeaderSubject;
    public static string RollupHeaderAll;
    public static string NatsStream;
    public static string NatsSequence;
    public static string NatsTimestamp;
    public static string NatsSubject;
    public static string NatsLastSequence;
    public static string NatsPendingMessages;
    public static string NatsPendingBytes;
    public static int JsConsumerNotFoundErr;
    public static int JsNoMessageFoundErr;
    public static int JsWrongLastSequence;
    public static string BadRequest;
    public static string NoMessages;
    public static string ConsumerDeleted;
    public static string ConsumerIsPushBased;
    public static string MessageSizeExceedsMaxBytes;
    public static string ExceededMaxWaiting;
    public static string ExceededMaxRequestBatch;
    public static string ExceededMaxRequestExpires;
    public static string ExceededMaxRequestMaxBytes;
    public static string BatchCompleted;
    public static string ServerShutdown;
    [ObsoleteAttribute("This property is obsolete. Use LastConsumerHeader instead.", "False")]
public static string LastConsumerHdr;
    [ObsoleteAttribute("This property is obsolete. Use LastStreamHeader instead.", "False")]
public static string LastStreamHdr;
    [ObsoleteAttribute("This property is obsolete. Use ConsumerStalledHeader instead.", "False")]
public static string ConsumerStalledHdr;
    [ObsoleteAttribute("This property is obsolete. Use RollupHeader instead.", "False")]
public static string RollupHdr;
    [ObsoleteAttribute("This property is obsolete. Use MsgSizeHeader instead.", "False")]
public static string MsgSizeHdr;
}
public static class NATS.Client.Internals.JsonUtils : object {
    public static JSONNode MinusOne;
    private static JsonUtils();
    public static int AsIntOrMinus1(JSONNode node, string field);
    public static long AsLongOrZero(JSONNode node, string field);
    public static long AsLongOrMinus1(JSONNode node, string field);
    public static ulong AsUlongOrZero(JSONNode node, string field);
    public static ulong AsUlongOr(JSONNode node, string field, ulong dflt);
    public static Duration AsDuration(JSONNode node, string field, Duration dflt);
    public static List`1<string> StringList(JSONNode node, string field);
    public static List`1<Duration> DurationList(JSONNode node, string field, bool nullIfEmpty);
    public static List`1<T> ListOf(JSONNode node, string field, Func`2<JSONNode, T> provider, bool nullIfEmpty);
    public static List`1<string> OptionalStringList(JSONNode node, string field);
    [ObsoleteAttribute("Method name replaced with proper spelling, 'StringStringDictionary'")]
public static IDictionary`2<string, string> StringStringDictionay(JSONNode node, string field);
    public static IDictionary`2<string, string> StringStringDictionary(JSONNode node, string field, bool nullIfEmpty);
    public static MsgHeader AsHeaders(JSONNode node, string field);
    public static Byte[] AsByteArrayFromBase64(JSONNode node);
    public static DateTime AsDate(JSONNode node);
    public static Nullable`1<DateTime> AsOptionalDate(JSONNode node);
    public static string ToString(DateTime dt);
    public static string ToString(Nullable`1<DateTime> dt);
    public static string UnsafeToString(DateTime dt);
    public static JSONArray ToArray(List`1<string> list);
    public static string ToKey(Type type);
    public static Byte[] SimpleMessageBody(string name, long value);
    public static Byte[] SimpleMessageBody(string name, ulong value);
    public static Byte[] SimpleMessageBody(string name, string value);
    public static Byte[] Serialize(JSONNode node);
    public static string ObjectString(string name, object o);
    public static void AddField(JSONObject o, string field, string value);
    public static void AddFieldEvenEmpty(JSONObject o, string field, string value);
    public static void AddField(JSONObject o, string field, JsonSerializable value);
    public static void AddField(JSONObject o, string field, JSONNode value);
    public static void AddField(JSONObject o, string fname, IDictionary`2<string, string> dictionary);
    public static void AddField(JSONObject o, string field, Nullable`1<DateTime> value);
    public static void AddField(JSONObject o, string field, int value);
    public static void AddField(JSONObject o, string field, Nullable`1<int> value);
    public static void AddField(JSONObject o, string field, long value);
    public static void AddField(JSONObject o, string field, Nullable`1<long> value);
    public static void AddFieldWhenGtZero(JSONObject o, string field, int value);
    public static void AddFieldWhenGtZero(JSONObject o, string field, Nullable`1<int> value);
    public static void AddFieldWhenGtZero(JSONObject o, string field, long value);
    public static void AddFieldWhenGtZero(JSONObject o, string field, Nullable`1<long> value);
    public static void AddFieldWhenGteMinusOne(JSONObject o, string field, Nullable`1<long> value);
    public static void AddField(JSONObject o, string field, Duration value);
    public static void AddField(JSONObject o, string field, ulong value);
    public static void AddFieldWhenGreaterThan(JSONObject o, string field, ulong value, ulong gt);
    public static void AddField(JSONObject o, string field, Nullable`1<ulong> value);
    public static void AddField(JSONObject o, string field, bool value);
    public static void AddField(JSONObject o, string field, Nullable`1<bool> value);
    public static void AddField(JSONObject o, string field, IList`1<Duration> values);
    public static void AddField(JSONObject o, string field, String[] values);
    public static void AddField(JSONObject o, string field, IList`1<string> values);
    public static void AddField(JSONObject o, string field, IList`1<T> values);
    public static void AddField(JSONObject o, string field, MsgHeader headers);
}
public static class NATS.Client.Internals.JwtUtils : object {
    public static string EncodedClaimHeader;
    public static long NoLimit;
    public static string NatsUserJwtFormat;
    private static JwtUtils();
    public static long UnixTimeSeconds();
    public static string IssueUserJWT(NkeyPair signingKey, string accountId, string publicUserKey);
    public static string IssueUserJWT(NkeyPair signingKey, string accountId, string publicUserKey, string name);
    public static string IssueUserJWT(NkeyPair signingKey, string accountId, string publicUserKey, string name, Duration expiration, String[] tags);
    public static string IssueUserJWT(NkeyPair signingKey, string accountId, string publicUserKey, string name, Duration expiration, String[] tags, long issuedAt);
    public static string IssueUserJWT(NkeyPair signingKey, string accountId, string publicUserKey, string name, Duration expiration, String[] tags, long issuedAt, string audience);
    public static string IssueUserJWT(NkeyPair signingKey, string publicUserKey, string name, Duration expiration, long issuedAt, string audience, UserClaim nats);
    public static string issueJWT(NkeyPair signingKey, string publicUserKey, string name, Duration expiration, long issuedAt, string accSigningKeyPub, string audience, JsonSerializable nats);
    public static string GetClaimBody(string jwt);
}
internal static class NATS.Client.Internals.NatsConstants : object {
    internal static string HeaderVersion;
    internal static string HeaderVersionBytesPlusCrlf;
    internal static Byte[] HeaderVersionBytes;
    internal static int HeaderVersionBytesLen;
    internal static int MinimalValidHeaderLen;
    internal static int FlowOrHeartbeatStatusCode;
    internal static int NoRespondersCode;
    internal static int BadRequestCode;
    internal static int NotFoundCode;
    internal static int RequestTimeoutCode;
    internal static int ConflictCode;
    internal static string InvalidHeaderVersion;
    internal static string InvalidHeaderComposition;
    internal static string InvalidHeaderStatusCode;
    internal static string SerializedHeaderCannotBeNullOrEmpty;
    internal static string Empty;
    internal static char Dot;
    internal static byte Sp;
    internal static byte Colon;
    internal static byte Cr;
    internal static byte Lf;
    internal static string GreaterThan;
    private static NatsConstants();
}
public class NATS.Client.Internals.Nuid : object {
    private static int PREFIX_LENGTH;
    private static int SEQUENTIAL_LENGTH;
    private static int NUID_LENGTH;
    private static int MIN_INCREMENT;
    private static int MAX_INCREMENT;
    private static ulong MAX_SEQUENTIAL;
    private static int BASE;
    private static Byte[] _digits;
    private object _nuidLock;
    private Random _rng;
    private RandomNumberGenerator _cryptoRng;
    private Byte[] _prefix;
    private UInt32 _increment;
    private ulong _sequential;
    private static Nuid _global;
    internal Nuid(RandomNumberGenerator rng, Nullable`1<ulong> sequential, Nullable`1<UInt32> increment);
    private static Nuid();
    public string GetNext();
    public string GetNextSequence();
    public static string NextGlobal();
    public static string NextGlobalSequence();
    private UInt32 GetIncrement();
    private ulong GetSequential();
    private void SetPrefix();
}
public class NATS.Client.Internals.Permission : JsonSerializable {
    public String[] Allow;
    public String[] Deny;
    public virtual JSONNode ToJsonNode();
}
public class NATS.Client.Internals.ResponsePermission : JsonSerializable {
    public int MaxMsgs;
    public Duration Expires;
    public virtual JSONNode ToJsonNode();
}
internal class NATS.Client.Internals.ServerVersion : object {
    private static string NoExtra;
    private int major;
    private int minor;
    private int patch;
    private string extra;
    internal ServerVersion(string v);
    public virtual string ToString();
    public sealed virtual int CompareTo(ServerVersion o);
    public static bool IsNewer(string v, string than);
    public static bool IsSame(string v, string than);
    public static bool IsOlder(string v, string than);
    public static bool IsSameOrOlder(string v, string than);
    public static bool IsSameOrNewer(string v, string than);
}
public static class NATS.Client.Internals.SimpleJSON.JSON : object {
    public static JSONNode Parse(string aJSON);
}
[DefaultMemberAttribute("Item")]
public class NATS.Client.Internals.SimpleJSON.JSONArray : JSONNode {
    private List`1<JSONNode> m_List;
    private bool inline;
    public bool Inline { get; public set; }
    public JSONNodeType Tag { get; }
    public bool IsArray { get; }
    public JSONNode Item { get; public set; }
    public JSONNode Item { get; public set; }
    public int Count { get; }
    public IEnumerable`1<JSONNode> Children { get; }
    public virtual bool get_Inline();
    public virtual void set_Inline(bool value);
    public virtual JSONNodeType get_Tag();
    public virtual bool get_IsArray();
    public virtual Enumerator GetEnumerator();
    public virtual JSONNode get_Item(int aIndex);
    public virtual void set_Item(int aIndex, JSONNode value);
    public virtual JSONNode get_Item(string aKey);
    public virtual void set_Item(string aKey, JSONNode value);
    public virtual int get_Count();
    public virtual void Add(string aKey, JSONNode aItem);
    public virtual JSONNode Remove(int aIndex);
    public virtual JSONNode Remove(JSONNode aNode);
    [IteratorStateMachineAttribute("NATS.Client.Internals.SimpleJSON.JSONArray/<get_Children>d__22")]
public virtual IEnumerable`1<JSONNode> get_Children();
    internal virtual void WriteToStringBuilder(StringBuilder aSB, int aIndent, int aIndentInc, JSONTextMode aMode);
}
public class NATS.Client.Internals.SimpleJSON.JSONBool : JSONNode {
    private bool m_Data;
    public JSONNodeType Tag { get; }
    public bool IsBoolean { get; }
    public string Value { get; public set; }
    public bool AsBool { get; public set; }
    public JSONBool(bool aData);
    public JSONBool(string aData);
    public virtual JSONNodeType get_Tag();
    public virtual bool get_IsBoolean();
    public virtual Enumerator GetEnumerator();
    public virtual string get_Value();
    public virtual void set_Value(string value);
    public virtual bool get_AsBool();
    public virtual void set_AsBool(bool value);
    internal virtual void WriteToStringBuilder(StringBuilder aSB, int aIndent, int aIndentInc, JSONTextMode aMode);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[DefaultMemberAttribute("Item")]
public class NATS.Client.Internals.SimpleJSON.JSONLazyCreator : JSONNode {
    private JSONNode m_Node;
    private string m_Key;
    public JSONNodeType Tag { get; }
    public JSONNode Item { get; public set; }
    public JSONNode Item { get; public set; }
    public int AsInt { get; public set; }
    public float AsFloat { get; public set; }
    public double AsDouble { get; public set; }
    public long AsLong { get; public set; }
    public bool AsBool { get; public set; }
    public JSONArray AsArray { get; }
    public JSONObject AsObject { get; }
    public JSONLazyCreator(JSONNode aNode);
    public JSONLazyCreator(JSONNode aNode, string aKey);
    public virtual JSONNodeType get_Tag();
    public virtual Enumerator GetEnumerator();
    private T Set(T aVal);
    public virtual JSONNode get_Item(int aIndex);
    public virtual void set_Item(int aIndex, JSONNode value);
    public virtual JSONNode get_Item(string aKey);
    public virtual void set_Item(string aKey, JSONNode value);
    public virtual void Add(JSONNode aItem);
    public virtual void Add(string aKey, JSONNode aItem);
    public static bool op_Equality(JSONLazyCreator a, object b);
    public static bool op_Inequality(JSONLazyCreator a, object b);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual int get_AsInt();
    public virtual void set_AsInt(int value);
    public virtual float get_AsFloat();
    public virtual void set_AsFloat(float value);
    public virtual double get_AsDouble();
    public virtual void set_AsDouble(double value);
    public virtual long get_AsLong();
    public virtual void set_AsLong(long value);
    public virtual bool get_AsBool();
    public virtual void set_AsBool(bool value);
    public virtual JSONArray get_AsArray();
    public virtual JSONObject get_AsObject();
    internal virtual void WriteToStringBuilder(StringBuilder aSB, int aIndent, int aIndentInc, JSONTextMode aMode);
}
[DefaultMemberAttribute("Item")]
public abstract class NATS.Client.Internals.SimpleJSON.JSONNode : object {
    public static bool forceASCII;
    public static bool longAsString;
    public static bool allowLineComments;
    [ThreadStaticAttribute]
private static StringBuilder m_EscapeBuilder;
    public JSONNodeType Tag { get; }
    public JSONNode Item { get; public set; }
    public JSONNode Item { get; public set; }
    public string Value { get; public set; }
    public int Count { get; }
    public bool IsNumber { get; }
    public bool IsString { get; }
    public bool IsBoolean { get; }
    public bool IsNull { get; }
    public bool IsArray { get; }
    public bool IsObject { get; }
    public bool ShouldWrite { get; }
    public bool Inline { get; public set; }
    public IEnumerable`1<JSONNode> Children { get; }
    public IEnumerable`1<JSONNode> DeepChildren { get; }
    public IEnumerable`1<KeyValuePair`2<string, JSONNode>> Linq { get; }
    public KeyEnumerator Keys { get; }
    public ValueEnumerator Values { get; }
    public double AsDouble { get; public set; }
    public int AsInt { get; public set; }
    public float AsFloat { get; public set; }
    public bool AsBool { get; public set; }
    public long AsLong { get; public set; }
    public ulong AsUlong { get; public set; }
    public JSONArray AsArray { get; }
    public JSONObject AsObject { get; }
    internal static StringBuilder EscapeBuilder { get; }
    private static JSONNode();
    public abstract virtual JSONNodeType get_Tag();
    public virtual JSONNode get_Item(int aIndex);
    public virtual void set_Item(int aIndex, JSONNode value);
    public virtual JSONNode get_Item(string aKey);
    public virtual void set_Item(string aKey, JSONNode value);
    public virtual string get_Value();
    public virtual void set_Value(string value);
    public virtual int get_Count();
    public virtual bool get_IsNumber();
    public virtual bool get_IsString();
    public virtual bool get_IsBoolean();
    public virtual bool get_IsNull();
    public virtual bool get_IsArray();
    public virtual bool get_IsObject();
    public virtual bool get_ShouldWrite();
    public virtual bool get_Inline();
    public virtual void set_Inline(bool value);
    public virtual void Add(string aKey, JSONNode aItem);
    public virtual void Add(JSONNode aItem);
    public virtual JSONNode Remove(string aKey);
    public virtual JSONNode Remove(int aIndex);
    public virtual JSONNode Remove(JSONNode aNode);
    [IteratorStateMachineAttribute("NATS.Client.Internals.SimpleJSON.JSONNode/<get_Children>d__43")]
public virtual IEnumerable`1<JSONNode> get_Children();
    [IteratorStateMachineAttribute("NATS.Client.Internals.SimpleJSON.JSONNode/<get_DeepChildren>d__45")]
public IEnumerable`1<JSONNode> get_DeepChildren();
    public virtual bool HasKey(string aKey);
    public virtual JSONNode GetValueOrDefault(string aKey, JSONNode aDefault);
    public virtual string ToString();
    public virtual string ToString(int aIndent);
    internal abstract virtual void WriteToStringBuilder(StringBuilder aSB, int aIndent, int aIndentInc, JSONTextMode aMode);
    public abstract virtual Enumerator GetEnumerator();
    public IEnumerable`1<KeyValuePair`2<string, JSONNode>> get_Linq();
    public KeyEnumerator get_Keys();
    public ValueEnumerator get_Values();
    public virtual double get_AsDouble();
    public virtual void set_AsDouble(double value);
    public virtual int get_AsInt();
    public virtual void set_AsInt(int value);
    public virtual float get_AsFloat();
    public virtual void set_AsFloat(float value);
    public virtual bool get_AsBool();
    public virtual void set_AsBool(bool value);
    public virtual long get_AsLong();
    public virtual void set_AsLong(long value);
    public virtual int AsIntOr(int dflt);
    public virtual long AsLongOr(long dflt);
    public virtual ulong get_AsUlong();
    public virtual void set_AsUlong(ulong value);
    public virtual ulong AsUlongOr(ulong dflt);
    public virtual JSONArray get_AsArray();
    public virtual JSONObject get_AsObject();
    public static JSONNode op_Implicit(string s);
    public static string op_Implicit(JSONNode d);
    public static JSONNode op_Implicit(double n);
    public static double op_Implicit(JSONNode d);
    public static JSONNode op_Implicit(float n);
    public static float op_Implicit(JSONNode d);
    public static JSONNode op_Implicit(int n);
    public static int op_Implicit(JSONNode d);
    public static JSONNode op_Implicit(long n);
    public static JSONNode op_Implicit(ulong n);
    public static long op_Implicit(JSONNode d);
    public static ulong op_Implicit(JSONNode d);
    public static JSONNode op_Implicit(bool b);
    public static bool op_Implicit(JSONNode d);
    public static JSONNode op_Implicit(KeyValuePair`2<string, JSONNode> aKeyValue);
    public static bool op_Equality(JSONNode a, object b);
    public static bool op_Inequality(JSONNode a, object b);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    internal static StringBuilder get_EscapeBuilder();
    internal static string Escape(string aText);
    private static JSONNode ParseElement(string token, bool quoted);
    public static JSONNode Parse(string aJSON);
}
public enum NATS.Client.Internals.SimpleJSON.JSONNodeType : Enum {
    public int value__;
    public static JSONNodeType Array;
    public static JSONNodeType Object;
    public static JSONNodeType String;
    public static JSONNodeType Number;
    public static JSONNodeType NullValue;
    public static JSONNodeType Boolean;
    public static JSONNodeType None;
    public static JSONNodeType Custom;
}
public class NATS.Client.Internals.SimpleJSON.JSONNull : JSONNode {
    private static JSONNull m_StaticInstance;
    public static bool reuseSameInstance;
    public JSONNodeType Tag { get; }
    public bool IsNull { get; }
    public string Value { get; public set; }
    public bool AsBool { get; public set; }
    private static JSONNull();
    public static JSONNull CreateOrGet();
    public virtual JSONNodeType get_Tag();
    public virtual bool get_IsNull();
    public virtual Enumerator GetEnumerator();
    public virtual string get_Value();
    public virtual void set_Value(string value);
    public virtual bool get_AsBool();
    public virtual void set_AsBool(bool value);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    internal virtual void WriteToStringBuilder(StringBuilder aSB, int aIndent, int aIndentInc, JSONTextMode aMode);
}
public class NATS.Client.Internals.SimpleJSON.JSONNumber : JSONNode {
    private JSONNumberType numberType;
    private int intData;
    private long longData;
    private ulong ulongData;
    private double doubleData;
    public JSONNodeType Tag { get; }
    public bool IsNumber { get; }
    public string Value { get; public set; }
    public int AsInt { get; public set; }
    public long AsLong { get; public set; }
    public ulong AsUlong { get; public set; }
    public double AsDouble { get; public set; }
    public JSONNumber(int aData);
    public JSONNumber(long aData);
    public JSONNumber(ulong aData);
    public JSONNumber(double aData);
    public JSONNumber(string aData);
    public virtual JSONNodeType get_Tag();
    public virtual bool get_IsNumber();
    public virtual Enumerator GetEnumerator();
    public virtual string get_Value();
    public virtual void set_Value(string value);
    public virtual int get_AsInt();
    public virtual void set_AsInt(int value);
    public virtual long get_AsLong();
    public virtual void set_AsLong(long value);
    public virtual ulong get_AsUlong();
    public virtual void set_AsUlong(ulong value);
    public virtual double get_AsDouble();
    public virtual void set_AsDouble(double value);
    private void InitInt(int aData);
    private void InitLong(long aData);
    private void InitUlong(ulong aData);
    private void InitDouble(double aData);
    private void InitString(string aData);
    internal virtual void WriteToStringBuilder(StringBuilder aSB, int aIndent, int aIndentInc, JSONTextMode aMode);
    private static bool IsNumeric(object value);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal enum NATS.Client.Internals.SimpleJSON.JSONNumberType : Enum {
    public int value__;
    public static JSONNumberType I;
    public static JSONNumberType L;
    public static JSONNumberType U;
    public static JSONNumberType D;
    public static JSONNumberType X;
}
[DefaultMemberAttribute("Item")]
public class NATS.Client.Internals.SimpleJSON.JSONObject : JSONNode {
    private Dictionary`2<string, JSONNode> m_Dict;
    private bool inline;
    public bool Inline { get; public set; }
    public JSONNodeType Tag { get; }
    public bool IsObject { get; }
    public JSONNode Item { get; public set; }
    public JSONNode Item { get; public set; }
    public int Count { get; }
    public IEnumerable`1<JSONNode> Children { get; }
    public virtual bool get_Inline();
    public virtual void set_Inline(bool value);
    public virtual JSONNodeType get_Tag();
    public virtual bool get_IsObject();
    public virtual Enumerator GetEnumerator();
    public virtual JSONNode get_Item(string aKey);
    public virtual void set_Item(string aKey, JSONNode value);
    public virtual JSONNode get_Item(int aIndex);
    public virtual void set_Item(int aIndex, JSONNode value);
    public virtual int get_Count();
    public virtual void Add(string aKey, JSONNode aItem);
    public virtual JSONNode Remove(string aKey);
    public virtual JSONNode Remove(int aIndex);
    public virtual JSONNode Remove(JSONNode aNode);
    public virtual bool HasKey(string aKey);
    public virtual JSONNode GetValueOrDefault(string aKey, JSONNode aDefault);
    [IteratorStateMachineAttribute("NATS.Client.Internals.SimpleJSON.JSONObject/<get_Children>d__25")]
public virtual IEnumerable`1<JSONNode> get_Children();
    internal virtual void WriteToStringBuilder(StringBuilder aSB, int aIndent, int aIndentInc, JSONTextMode aMode);
}
public class NATS.Client.Internals.SimpleJSON.JSONString : JSONNode {
    private string m_Data;
    public JSONNodeType Tag { get; }
    public bool IsString { get; }
    public bool ShouldWrite { get; }
    public string Value { get; public set; }
    public JSONString(string aData);
    public virtual JSONNodeType get_Tag();
    public virtual bool get_IsString();
    public virtual bool get_ShouldWrite();
    public virtual Enumerator GetEnumerator();
    public virtual string get_Value();
    public virtual void set_Value(string value);
    internal virtual void WriteToStringBuilder(StringBuilder aSB, int aIndent, int aIndentInc, JSONTextMode aMode);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public enum NATS.Client.Internals.SimpleJSON.JSONTextMode : Enum {
    public int value__;
    public static JSONTextMode Compact;
    public static JSONTextMode Indent;
}
public class NATS.Client.Internals.TimeRange : JsonSerializable {
    public string Start;
    public string End;
    public TimeRange(string start, string end);
    public virtual JSONNode ToJsonNode();
}
public class NATS.Client.Internals.Token : object {
    private Byte[] _serialized;
    private TokenType _type;
    private int _start;
    private int _end;
    private bool _hasValue;
    internal Token(Byte[] serialized, int len, Token prev, Nullable`1<TokenType> required);
    internal Token(Byte[] serialized, int len, int cur, Nullable`1<TokenType> required);
    private void MustBeCrlf(int len, int cur);
    public void MustBe(TokenType expected);
    public bool IsType(TokenType expected);
    public bool HasValue();
    public string Value();
    public bool SamePoint(Token token);
}
public enum NATS.Client.Internals.TokenType : Enum {
    public int value__;
    public static TokenType Space;
    public static TokenType Crlf;
    public static TokenType Key;
    public static TokenType Word;
    public static TokenType Text;
}
public class NATS.Client.Internals.UserClaim : JsonSerializable {
    public string IssuerAccount;
    public String[] Tags;
    public string Type;
    public int Version;
    public Permission Pub;
    public Permission Sub;
    public ResponsePermission Resp;
    public String[] Src;
    public IList`1<TimeRange> Times;
    public string Locale;
    public long Subs;
    public long Data;
    public long Payload;
    public bool BearerToken;
    public String[] AllowedConnectionTypes;
    public UserClaim(string issuerAccount);
    public UserClaim(string issuerAccount, String[] tags);
    public virtual JSONNode ToJsonNode();
}
internal static class NATS.Client.Internals.Validator : object {
    private static Char[] WildGt;
    private static Char[] WildGtDot;
    private static Char[] WildGtDollar;
    private static Char[] WildGtDotSlashes;
    private static string SemVerPattern;
    private static Validator();
    internal static string Required(string s, string label);
    internal static void Required(object o, string label);
    internal static void Required(IDictionary`2<TKey, TValue> d, string label);
    public static string ValidateSubjectTerm(string subject, string label, bool required);
    internal static Tuple`2<bool, string> IsValidSubjectTerm(string subject, string label, bool required);
    public static string ValidateSubject(string s, bool required);
    public static string ValidateSubject(string subject, string label, bool required, bool cantEndWithGt);
    public static string ValidateReplyTo(string s, bool required);
    public static string ValidateQueueName(string s, bool required);
    public static string ValidateStreamName(string s, bool required);
    public static string ValidateDurable(string s, bool required);
    public static string ValidateConsumerName(string s, bool required);
    public static string ValidatePrefixOrDomain(string s, string label, bool required);
    public static IList`1<string> ValidateKvKeysWildcardAllowedRequired(IList`1<string> keys);
    public static string ValidateKvKeyWildcardAllowedRequired(string s);
    public static string ValidateNonWildcardKvKeyRequired(string s);
    public static void ValidateNotSupplied(string s, ClientExDetail detail);
    internal static string ValidateMustMatchIfBothSupplied(string s1, string s2, ClientExDetail detail);
    public static string Validate(string s, bool required, string label, Func`1<string> check);
    public static string ValidateJetStreamPrefix(string s);
    public static string ValidateMaxLength(string s, int maxLength, bool required, string label);
    public static string ValidatePrintable(string s, string label, bool required);
    public static string ValidatePrintableExceptWildDotGt(string s, string label, bool required);
    public static string ValidatePrintableExceptWildDotGtSlashes(string s, string label, bool required);
    public static string ValidatePrintableExceptWildGt(string s, string label, bool required);
    public static string ValidatePrintableExceptWildGtDollar(string s, string label, bool required);
    public static string ValidateIsRestrictedTerm(string s, string label, bool required);
    public static string ValidateBucketName(string s, bool required);
    public static string ValidateWildcardKvKey(string s, string label, bool required);
    public static string ValidateNonWildcardKvKey(string s, string label, bool required);
    internal static long ValidateMaxConsumers(long max);
    internal static long ValidateMaxMessages(long max);
    internal static long ValidateMaxBucketValues(long max);
    internal static long ValidateMaxMessagesPerSubject(long max);
    internal static int ValidateMaxHistory(int max);
    internal static long ValidateMaxHistoryPerKey(long max);
    internal static long ValidateMaxBytes(long max);
    internal static long ValidateMaxBucketBytes(long max);
    internal static long ValidateMaxMessageSize(long max, string label);
    internal static long ValidateMaxMessageSize(long max);
    internal static long ValidateMaxValueSize(long max);
    internal static int ValidateNumberOfReplicas(int replicas);
    internal static Duration ValidateDurationRequired(Duration d);
    internal static void ValidateDurationGtZeroRequired(long millis, string label);
    internal static Duration ValidateDurationNotRequiredGtOrEqZero(Duration d);
    internal static Duration ValidateDurationNotRequiredGtOrEqZero(long millis);
    internal static Duration ValidateDurationNotRequiredNotLessThanMin(Duration provided, Duration minimum);
    internal static Duration ValidateDurationNotRequiredNotLessThanMin(long millis, Duration minimum);
    internal static object ValidateNotNull(object o, string fieldName);
    internal static string ValidateNotNull(string s, string fieldName);
    internal static string ValidateNotEmpty(string s, string fieldName);
    internal static int ValidateGtZero(int i, string label);
    internal static int ValidateGtEqZero(int i, string label);
    internal static long ValidateGtZeroOrMinus1(long l, string label);
    internal static long ValidateNotNegative(long l, string label);
    [ObsoleteAttribute("This property is obsolete. use string.IsNullOrWhiteSpace(string) instead.", "False")]
public static bool NullOrEmpty(string s);
    public static bool NotPrintable(string s);
    public static bool NotPrintableOrHasChars(string s, Char[] charsToNotHave);
    public static bool NotRestrictedTerm(string s);
    public static bool NotNonWildcardKvKey(string s);
    public static bool NotWildcardKvKey(string s);
    public static bool NotPrintableOrHasWildGt(string s);
    public static bool NotPrintableOrHasWildGtDot(string s);
    public static bool NotPrintableOrHasWildGtDotSlashes(string s);
    public static bool NotPrintableOrHasWildGtDollar(string s);
    public static string EmptyAsNull(string s);
    public static string EmptyOrNullAs(string s, string ifEmpty);
    public static IList`1<TSource> EmptyAsNull(IList`1<TSource> list);
    public static bool EmptyOrNull(IList`1<TSource> list);
    public static bool EmptyOrNull(TSource[] list);
    public static bool ZeroOrLtMinus1(long l);
    public static Duration EnsureNotNullAndNotLessThanMin(Duration provided, Duration minimum, Duration dflt);
    public static Duration EnsureDurationNotLessThanMin(long providedMillis, Duration minimum, Duration dflt);
    public static bool Equal(Byte[] a, Byte[] a2);
    public static string EnsureEndsWithDot(string s);
    public static string ValidateSemVer(string s, string label, bool required);
    public static bool IsSemVer(string s);
    public static bool SequenceEqual(IList`1<T> l1, IList`1<T> l2, bool nullSecondEqualsEmptyFirst);
    public static bool ConsumerFilterSubjectsAreEquivalent(IList`1<T> l1, IList`1<T> l2);
    public static bool DictionariesEqual(IDictionary`2<string, string> d1, IDictionary`2<string, string> d2);
}
internal interface NATS.Client.IServerProvider {
    public abstract virtual void Setup(Options opts);
    public abstract virtual Srv First();
    public abstract virtual Srv SelectNextServer(int maxReconnect);
    public abstract virtual String[] GetServerList(bool implicitOnly);
    public abstract virtual void ConnectToAServer(Predicate`1<Srv> connectToServer);
    public abstract virtual bool HasSecureServer();
    public abstract virtual void SetCurrentServer(Srv value);
    public abstract virtual bool AcceptDiscoveredServers(String[] discoveredUrls);
}
public interface NATS.Client.IStatistics {
    public long InMsgs { get; }
    public long OutMsgs { get; }
    public long InBytes { get; }
    public long OutBytes { get; }
    public long Reconnects { get; }
    public abstract virtual long get_InMsgs();
    public abstract virtual long get_OutMsgs();
    public abstract virtual long get_InBytes();
    public abstract virtual long get_OutBytes();
    public abstract virtual long get_Reconnects();
}
public interface NATS.Client.ISubscription {
    public long Sid { get; }
    public string Subject { get; }
    public string Queue { get; }
    public Connection Connection { get; }
    public bool IsValid { get; }
    public int QueuedMessageCount { get; }
    public long PendingByteLimit { get; public set; }
    public long PendingMessageLimit { get; public set; }
    public long PendingBytes { get; }
    public long PendingMessages { get; }
    public long MaxPendingBytes { get; }
    public long MaxPendingMessages { get; }
    public long Delivered { get; }
    public long Dropped { get; }
    public abstract virtual long get_Sid();
    public abstract virtual string get_Subject();
    public abstract virtual string get_Queue();
    public abstract virtual Connection get_Connection();
    public abstract virtual bool get_IsValid();
    public abstract virtual void Unsubscribe();
    public abstract virtual void AutoUnsubscribe(int max);
    public abstract virtual int get_QueuedMessageCount();
    public abstract virtual void SetPendingLimits(long messageLimit, long bytesLimit);
    public abstract virtual long get_PendingByteLimit();
    public abstract virtual void set_PendingByteLimit(long value);
    public abstract virtual long get_PendingMessageLimit();
    public abstract virtual void set_PendingMessageLimit(long value);
    public abstract virtual void GetPending(Int64& pendingBytes, Int64& pendingMessages);
    public abstract virtual long get_PendingBytes();
    public abstract virtual long get_PendingMessages();
    public abstract virtual void GetMaxPending(Int64& maxPendingBytes, Int64& maxPendingMessages);
    public abstract virtual long get_MaxPendingBytes();
    public abstract virtual long get_MaxPendingMessages();
    public abstract virtual void ClearMaxPending();
    public abstract virtual long get_Delivered();
    public abstract virtual long get_Dropped();
    public abstract virtual void Drain();
    public abstract virtual void Drain(int timeout);
    public abstract virtual Task DrainAsync();
    public abstract virtual Task DrainAsync(int timeout);
}
public interface NATS.Client.ISyncSubscription {
    public abstract virtual Msg NextMessage();
    public abstract virtual Msg NextMessage(int timeout);
}
public interface NATS.Client.ITCPConnection {
    public bool Connected { get; }
    public bool DataAvailable { get; }
    unknown int SendTimeout {public set; }
    public int ReceiveTimeout { get; public set; }
    public abstract virtual bool get_Connected();
    public abstract virtual bool get_DataAvailable();
    public abstract virtual void set_SendTimeout(int value);
    public abstract virtual int get_ReceiveTimeout();
    public abstract virtual void set_ReceiveTimeout(int value);
    public abstract virtual void open(Srv s, Options options);
    public abstract virtual void close(TcpClient c);
    public abstract virtual void makeTLS();
    public abstract virtual bool isSetup();
    public abstract virtual void teardown();
    public abstract virtual Stream getReadBufferedStream();
    public abstract virtual Stream getWriteBufferedStream(int size);
}
internal abstract class NATS.Client.JetStream.AbstractListReader : object {
    private string objectName;
    private string filterFieldName;
    protected ListRequestEngine Engine;
    protected AbstractListReader(string objectName, string filterFieldName);
    internal void Process(Msg msg);
    protected abstract virtual void ProcessItem(JSONNode node);
    internal Byte[] NextJson();
    internal Byte[] NextJson(string filter);
    internal bool HasMore();
}
public class NATS.Client.JetStream.AccountLimits : object {
    [CompilerGeneratedAttribute]
private long <MaxMemory>k__BackingField;
    [CompilerGeneratedAttribute]
private long <MaxStorage>k__BackingField;
    [CompilerGeneratedAttribute]
private long <MaxStreams>k__BackingField;
    [CompilerGeneratedAttribute]
private long <MaxConsumers>k__BackingField;
    [CompilerGeneratedAttribute]
private long <MaxAckPending>k__BackingField;
    [CompilerGeneratedAttribute]
private long <MemoryMaxStreamBytes>k__BackingField;
    [CompilerGeneratedAttribute]
private long <StorageMaxStreamBytes>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <MaxBytesRequired>k__BackingField;
    public long MaxMemory { get; }
    public long MaxStorage { get; }
    public long MaxStreams { get; }
    public long MaxConsumers { get; }
    public long MaxAckPending { get; }
    public long MemoryMaxStreamBytes { get; }
    public long StorageMaxStreamBytes { get; }
    public bool MaxBytesRequired { get; }
    internal AccountLimits(JSONNode node);
    [CompilerGeneratedAttribute]
public long get_MaxMemory();
    [CompilerGeneratedAttribute]
public long get_MaxStorage();
    [CompilerGeneratedAttribute]
public long get_MaxStreams();
    [CompilerGeneratedAttribute]
public long get_MaxConsumers();
    [CompilerGeneratedAttribute]
public long get_MaxAckPending();
    [CompilerGeneratedAttribute]
public long get_MemoryMaxStreamBytes();
    [CompilerGeneratedAttribute]
public long get_StorageMaxStreamBytes();
    [CompilerGeneratedAttribute]
public bool get_MaxBytesRequired();
}
public class NATS.Client.JetStream.AccountStatistics : ApiResponse {
    private AccountTier _rollup;
    [CompilerGeneratedAttribute]
private string <Domain>k__BackingField;
    [CompilerGeneratedAttribute]
private ApiStats <Api>k__BackingField;
    public IDictionary`2<string, AccountTier> Tiers;
    public long Memory { get; }
    public long Storage { get; }
    public long Streams { get; }
    public long Consumers { get; }
    public AccountLimits Limits { get; }
    public string Domain { get; private set; }
    public ApiStats Api { get; private set; }
    public AccountStatistics(Msg msg, bool throwOnError);
    public AccountStatistics(string json, bool throwOnError);
    public long get_Memory();
    public long get_Storage();
    public long get_Streams();
    public long get_Consumers();
    public AccountLimits get_Limits();
    [CompilerGeneratedAttribute]
public string get_Domain();
    [CompilerGeneratedAttribute]
private void set_Domain(string value);
    [CompilerGeneratedAttribute]
public ApiStats get_Api();
    [CompilerGeneratedAttribute]
private void set_Api(ApiStats value);
    private void Init();
}
public class NATS.Client.JetStream.AccountTier : object {
    [CompilerGeneratedAttribute]
private long <Memory>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Storage>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Streams>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Consumers>k__BackingField;
    [CompilerGeneratedAttribute]
private AccountLimits <Limits>k__BackingField;
    public long Memory { get; }
    public long Storage { get; }
    public long Streams { get; }
    public long Consumers { get; }
    public AccountLimits Limits { get; }
    internal AccountTier(JSONNode jsonNode);
    [CompilerGeneratedAttribute]
public long get_Memory();
    [CompilerGeneratedAttribute]
public long get_Storage();
    [CompilerGeneratedAttribute]
public long get_Streams();
    [CompilerGeneratedAttribute]
public long get_Consumers();
    [CompilerGeneratedAttribute]
public AccountLimits get_Limits();
}
public enum NATS.Client.JetStream.AckPolicy : Enum {
    public int value__;
    public static AckPolicy None;
    public static AckPolicy All;
    public static AckPolicy Explicit;
}
public static class NATS.Client.JetStream.ApiConstants : object {
    public static string AckFloor;
    public static string AckPolicy;
    public static string AckWait;
    public static string Action;
    public static string Active;
    public static string AllowRollupHdrs;
    public static string AllowDirect;
    public static string Api;
    public static string AuthRequired;
    public static string AverageProcessingTime;
    public static string Backoff;
    public static string Batch;
    public static string Bucket;
    public static string Bytes;
    public static string Chunks;
    public static string ClientId;
    public static string ClientIp;
    public static string Cluster;
    public static string Code;
    public static string Compression;
    public static string Config;
    public static string ConnectUrls;
    public static string ConsumerCount;
    public static string ConsumerLimits;
    public static string ConsumerSeq;
    public static string Consumers;
    public static string Created;
    public static string Current;
    public static string Data;
    public static string Deleted;
    public static string DeletedDetails;
    public static string Deliver;
    public static string DeliverGroup;
    public static string DeliverPolicy;
    public static string DeliverSubject;
    public static string Delivered;
    public static string DenyDelete;
    public static string DenyPurge;
    public static string Description;
    public static string Dest;
    public static string Digest;
    public static string Discard;
    public static string DiscardNewPerSubject;
    public static string Domain;
    public static string Duplicate;
    public static string DuplicateWindow;
    public static string DurableName;
    public static string Endpoints;
    public static string ErrCode;
    public static string Error;
    public static string Errors;
    public static string Expires;
    public static string External;
    public static string Filter;
    public static string FilterSubject;
    public static string FilterSubjects;
    public static string FirstSequence;
    public static string FirstTs;
    public static string FlowControl;
    public static string Go;
    public static string Hdrs;
    public static string Headers;
    public static string HeadersOnly;
    public static string Host;
    public static string Id;
    public static string IdleHeartbeat;
    public static string InactiveThreshold;
    public static string Internal;
    public static string Jetstream;
    public static string Keep;
    public static string Lag;
    public static string LameDuckMode;
    public static string LastActive;
    public static string LastBySubject;
    public static string LastError;
    public static string LastSeq;
    public static string LastTs;
    public static string Leader;
    public static string Limit;
    public static string Limits;
    public static string Link;
    public static string Lost;
    public static string MaxAckPending;
    public static string MaxAge;
    public static string MaxBatch;
    public static string MaxBytes;
    public static string MaxBytesRequired;
    public static string MaxConsumers;
    public static string MaxChunkSize;
    public static string MaxDeliver;
    public static string MaxExpires;
    public static string MaxMemory;
    public static string MaxMsgSize;
    public static string MaxMsgs;
    public static string MaxMsgsPerSubject;
    public static string MaxPayload;
    public static string MaxStorage;
    public static string MaxStreams;
    public static string MaxWaiting;
    public static string Memory;
    public static string MemoryMaxStreamBytes;
    public static string MemStorage;
    public static string Message;
    public static string Messages;
    public static string Metadata;
    public static string Mirror;
    public static string MirrorDirect;
    public static string Msgs;
    public static string Name;
    public static string NextBySubject;
    public static string NoAck;
    public static string NoErase;
    public static string Nonce;
    public static string NoWait;
    public static string Nuid;
    public static string NumAckPending;
    public static string NumDeleted;
    public static string NumErrors;
    public static string NumPending;
    public static string NumRedelivered;
    public static string NumReplicas;
    public static string NumRequests;
    public static string NumSubjects;
    public static string NumWaiting;
    public static string Offline;
    public static string Offset;
    public static string Options;
    public static string OptStartSeq;
    public static string OptStartTime;
    public static string Paused;
    public static string PauseRemaining;
    public static string PauseUntil;
    public static string Placement;
    public static string ProcessingTime;
    public static string Republish;
    public static string Port;
    public static string Proto;
    public static string Purged;
    public static string PushBound;
    public static string QueueGroup;
    public static string RateLimitBps;
    public static string ReplayPolicy;
    public static string Replica;
    public static string Replicas;
    public static string Request;
    public static string Response;
    public static string Retention;
    public static string SampleFreq;
    public static string Schema;
    public static string Sealed;
    public static string Seq;
    public static string ServerId;
    public static string ServerName;
    public static string Size;
    public static string Source;
    public static string Sources;
    public static string Src;
    public static string Started;
    public static string State;
    public static string Stats;
    public static string Storage;
    public static string StorageMaxStreamBytes;
    public static string StreamName;
    public static string StreamSeq;
    public static string Stream;
    public static string Streams;
    public static string Subject;
    public static string SubjectTransform;
    public static string SubjectTransforms;
    public static string Subjects;
    public static string SubjectsFilter;
    public static string Success;
    public static string Tags;
    public static string TemplateOwner;
    public static string Tiers;
    public static string Time;
    public static string Timestamp;
    public static string Tls;
    public static string TlsRequired;
    public static string TlsAvailable;
    public static string Total;
    public static string Type;
    public static string Version;
}
[ExtensionAttribute]
public static class NATS.Client.JetStream.ApiEnums : object {
    [ExtensionAttribute]
public static string GetString(AckPolicy ackPolicy);
    [ExtensionAttribute]
public static string GetString(DeliverPolicy deliverPolicy);
    [ExtensionAttribute]
public static string GetString(DiscardPolicy discardPolicy);
    [ExtensionAttribute]
public static string GetString(ReplayPolicy replayPolicy);
    [ExtensionAttribute]
public static string GetString(RetentionPolicy retentionPolicy);
    [ExtensionAttribute]
public static string GetString(StorageType storageType);
    [ExtensionAttribute]
public static string GetString(CompressionOption compressionOption);
    [ExtensionAttribute]
public static string GetString(ConsumerCreateRequestAction action);
    public static Nullable`1<AckPolicy> GetAckPolicy(string value);
    public static Nullable`1<DeliverPolicy> GetDeliverPolicy(string value);
    public static Nullable`1<ReplayPolicy> GetReplayPolicy(string value);
    public static DiscardPolicy GetValueOrDefault(string value, DiscardPolicy aDefault);
    public static RetentionPolicy GetValueOrDefault(string value, RetentionPolicy aDefault);
    public static StorageType GetValueOrDefault(string value, StorageType aDefault);
    public static CompressionOption GetValueOrDefault(string value, CompressionOption aDefault);
}
public class NATS.Client.JetStream.ApiResponse : object {
    public static string NoType;
    [CompilerGeneratedAttribute]
private string <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private Error <Error>k__BackingField;
    [CompilerGeneratedAttribute]
private JSONNode <JsonNode>k__BackingField;
    public string Type { get; private set; }
    public Error Error { get; private set; }
    internal JSONNode JsonNode { get; private set; }
    public bool HasError { get; }
    public int ErrorCode { get; }
    public int ApiErrorCode { get; }
    public string ErrorDescription { get; }
    internal ApiResponse(Msg msg, bool throwOnError, bool ignoreMessage);
    internal ApiResponse(string json, bool throwOnError);
    [CompilerGeneratedAttribute]
public string get_Type();
    [CompilerGeneratedAttribute]
private void set_Type(string value);
    [CompilerGeneratedAttribute]
public Error get_Error();
    [CompilerGeneratedAttribute]
private void set_Error(Error value);
    [CompilerGeneratedAttribute]
internal JSONNode get_JsonNode();
    [CompilerGeneratedAttribute]
private void set_JsonNode(JSONNode value);
    private void InitJson(string json, bool throwOnError);
    public void ThrowOnHasError();
    public bool get_HasError();
    public int get_ErrorCode();
    public int get_ApiErrorCode();
    public string get_ErrorDescription();
}
public class NATS.Client.JetStream.ApiStats : object {
    [CompilerGeneratedAttribute]
private long <Total>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Errors>k__BackingField;
    public long Total { get; }
    public long Errors { get; }
    internal ApiStats(JSONNode jsonNode);
    [CompilerGeneratedAttribute]
public long get_Total();
    [CompilerGeneratedAttribute]
public long get_Errors();
}
public class NATS.Client.JetStream.BaseConsumeOptions : object {
    public static int DefaultMessageCount;
    public static int DefaultMessageCountWhenBytes;
    public static int DefaultThresholdPercent;
    public static int DefaultExpiresInMillis;
    public static int MinExpiresMills;
    public static int MaxHearbeatMillis;
    public static int MaxIdleHeartbeatPercent;
    [CompilerGeneratedAttribute]
private int <Messages>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Bytes>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ExpiresInMillis>k__BackingField;
    [CompilerGeneratedAttribute]
private int <IdleHeartbeat>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ThresholdPercent>k__BackingField;
    public int Messages { get; }
    public long Bytes { get; }
    public int ExpiresInMillis { get; }
    public int IdleHeartbeat { get; }
    public int ThresholdPercent { get; }
    protected BaseConsumeOptions(IBaseConsumeOptionsBuilder b);
    [CompilerGeneratedAttribute]
public int get_Messages();
    [CompilerGeneratedAttribute]
public long get_Bytes();
    [CompilerGeneratedAttribute]
public int get_ExpiresInMillis();
    [CompilerGeneratedAttribute]
public int get_IdleHeartbeat();
    [CompilerGeneratedAttribute]
public int get_ThresholdPercent();
    public virtual string ToString();
}
internal class NATS.Client.JetStream.CachedStreamInfo : object {
    [CompilerGeneratedAttribute]
private bool <AllowDirect>k__BackingField;
    internal bool AllowDirect { get; }
    internal CachedStreamInfo(StreamInfo si);
    [CompilerGeneratedAttribute]
internal bool get_AllowDirect();
}
public class NATS.Client.JetStream.ClusterInfo : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Leader>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<Replica> <Replicas>k__BackingField;
    public string Name { get; }
    public string Leader { get; }
    public List`1<Replica> Replicas { get; }
    private ClusterInfo(JSONNode clusterNode);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public string get_Leader();
    [CompilerGeneratedAttribute]
public List`1<Replica> get_Replicas();
    internal static ClusterInfo OptionalInstance(JSONNode clusterNode);
    public virtual string ToString();
}
public enum NATS.Client.JetStream.CompressionOption : Enum {
    public int value__;
    public static CompressionOption None;
    public static CompressionOption S2;
}
public class NATS.Client.JetStream.ConsumeOptions : BaseConsumeOptions {
    public static ConsumeOptions DefaultConsumeOptions;
    public int BatchSize { get; }
    public long BatchBytes { get; }
    protected ConsumeOptions(IBaseConsumeOptionsBuilder b);
    private static ConsumeOptions();
    public int get_BatchSize();
    public long get_BatchBytes();
    public static ConsumeOptionsBuilder Builder();
}
public class NATS.Client.JetStream.ConsumerConfiguration : JsonSerializable {
    [ObsoleteAttribute("This property is obsolete, it is not used.", "False")]
public static Duration MinAckWait;
    [ObsoleteAttribute("This property is obsolete, it is not used as a default", "False")]
public static Duration MinDefaultIdleHeartbeat;
    public static Duration DurationUnset;
    public static Duration MinIdleHeartbeat;
    public static int IntUnset;
    public static long LongUnset;
    public static ulong UlongUnset;
    public static long DurationUnsetLong;
    public static long DurationMinLong;
    public static int StandardMin;
    public static int MaxDeliverMin;
    public static long MinIdleHeartbeatNanos;
    public static long MinIdleHeartbeatMillis;
    internal Nullable`1<DeliverPolicy> _deliverPolicy;
    internal Nullable`1<AckPolicy> _ackPolicy;
    internal Nullable`1<ReplayPolicy> _replayPolicy;
    internal Nullable`1<ulong> _startSeq;
    internal Nullable`1<ulong> _rateLimitBps;
    internal Nullable`1<int> _maxDeliver;
    internal Nullable`1<int> _maxAckPending;
    internal Nullable`1<int> _maxPullWaiting;
    internal Nullable`1<int> _maxBatch;
    internal Nullable`1<int> _maxBytes;
    internal Nullable`1<int> _numReplicas;
    internal Nullable`1<bool> _flowControl;
    internal Nullable`1<bool> _headersOnly;
    internal Nullable`1<bool> _memStorage;
    internal IList`1<Duration> _backoff;
    internal IDictionary`2<string, string> _metadata;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Durable>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DeliverSubject>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DeliverGroup>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SampleFrequency>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <StartTime>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <PauseUntil>k__BackingField;
    [CompilerGeneratedAttribute]
private Duration <AckWait>k__BackingField;
    [CompilerGeneratedAttribute]
private Duration <IdleHeartbeat>k__BackingField;
    [CompilerGeneratedAttribute]
private Duration <MaxExpires>k__BackingField;
    [CompilerGeneratedAttribute]
private Duration <InactiveThreshold>k__BackingField;
    internal IList`1<string> _filterSubjects;
    public DeliverPolicy DeliverPolicy { get; }
    public AckPolicy AckPolicy { get; }
    public ReplayPolicy ReplayPolicy { get; }
    public string Description { get; }
    public string Durable { get; }
    public string Name { get; }
    public string DeliverSubject { get; }
    public string DeliverGroup { get; }
    public string SampleFrequency { get; }
    public DateTime StartTime { get; }
    public Nullable`1<DateTime> PauseUntil { get; }
    public Duration AckWait { get; }
    public Duration IdleHeartbeat { get; }
    public Duration MaxExpires { get; }
    public Duration InactiveThreshold { get; }
    public ulong StartSeq { get; }
    public int MaxDeliver { get; }
    public ulong RateLimitBps { get; }
    public int MaxAckPending { get; }
    public int MaxPullWaiting { get; }
    public int MaxBatch { get; }
    public int MaxBytes { get; }
    public int NumReplicas { get; }
    public bool FlowControl { get; }
    public bool HeadersOnly { get; }
    public bool MemStorage { get; }
    public IList`1<Duration> Backoff { get; }
    public IDictionary`2<string, string> Metadata { get; }
    public string FilterSubject { get; }
    public IList`1<string> FilterSubjects { get; }
    public bool HasMultipleFilterSubjects { get; }
    [ObsoleteAttribute("This property is obsolete. Use RateLimitBps.", "False")]
public long RateLimit { get; }
    internal ConsumerConfiguration(string json);
    internal ConsumerConfiguration(JSONNode ccNode);
    private ConsumerConfiguration(ConsumerConfigurationBuilder builder);
    private static ConsumerConfiguration();
    public DeliverPolicy get_DeliverPolicy();
    public AckPolicy get_AckPolicy();
    public ReplayPolicy get_ReplayPolicy();
    [CompilerGeneratedAttribute]
public string get_Description();
    [CompilerGeneratedAttribute]
public string get_Durable();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public string get_DeliverSubject();
    [CompilerGeneratedAttribute]
public string get_DeliverGroup();
    [CompilerGeneratedAttribute]
public string get_SampleFrequency();
    [CompilerGeneratedAttribute]
public DateTime get_StartTime();
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_PauseUntil();
    [CompilerGeneratedAttribute]
public Duration get_AckWait();
    [CompilerGeneratedAttribute]
public Duration get_IdleHeartbeat();
    [CompilerGeneratedAttribute]
public Duration get_MaxExpires();
    [CompilerGeneratedAttribute]
public Duration get_InactiveThreshold();
    public ulong get_StartSeq();
    public int get_MaxDeliver();
    public ulong get_RateLimitBps();
    public int get_MaxAckPending();
    public int get_MaxPullWaiting();
    public int get_MaxBatch();
    public int get_MaxBytes();
    public int get_NumReplicas();
    public bool get_FlowControl();
    public bool get_HeadersOnly();
    public bool get_MemStorage();
    public IList`1<Duration> get_Backoff();
    public IDictionary`2<string, string> get_Metadata();
    public string get_FilterSubject();
    public IList`1<string> get_FilterSubjects();
    public bool get_HasMultipleFilterSubjects();
    public long get_RateLimit();
    public virtual JSONNode ToJsonNode();
    internal IList`1<string> GetChanges(ConsumerConfiguration server);
    private void RecordWouldBeChange(string request, string server, string field, IList`1<string> changes);
    private void RecordWouldBeChange(DateTime request, DateTime server, string field, IList`1<string> changes);
    private void RecordWouldBeChange(Nullable`1<DateTime> request, Nullable`1<DateTime> server, string field, IList`1<string> changes);
    internal static int GetOrUnset(Nullable`1<int> val);
    internal static ulong GetOrUnset(Nullable`1<ulong> val);
    internal static Nullable`1<int> NormalizeToInt(Nullable`1<long> l, long min);
    internal static Nullable`1<ulong> Normalize(Nullable`1<ulong> u);
    internal static Duration Normalize(Duration d);
    internal static Duration NormalizeDuration(long millis);
    public static ConsumerConfigurationBuilder Builder();
    public static ConsumerConfigurationBuilder Builder(ConsumerConfiguration cc);
}
internal class NATS.Client.JetStream.ConsumerContext : object {
    private object stateLock;
    private StreamContext streamCtx;
    private bool ordered;
    private ConsumerConfiguration originalOrderedCc;
    private string subscribeSubject;
    private PullSubscribeOptions unorderedBindPso;
    private ConsumerInfo cachedConsumerInfo;
    private MessageConsumerBase lastConsumer;
    private ulong highestSeq;
    [CompilerGeneratedAttribute]
private string <ConsumerName>k__BackingField;
    public string ConsumerName { get; private set; }
    internal ConsumerContext(StreamContext sc, ConsumerInfo ci);
    internal ConsumerContext(StreamContext sc, OrderedConsumerConfiguration config);
    public sealed virtual IJetStreamSubscription Subscribe(EventHandler`1<MsgHandlerEventArgs> messageHandler, PullMessageManager optionalPmm, Nullable`1<long> optionalInactiveThreshold);
    private void CheckState();
    private MessageConsumerBase TrackConsume(MessageConsumerBase con);
    [CompilerGeneratedAttribute]
public sealed virtual string get_ConsumerName();
    [CompilerGeneratedAttribute]
private void set_ConsumerName(string value);
    public sealed virtual ConsumerInfo GetConsumerInfo();
    public sealed virtual ConsumerInfo GetCachedConsumerInfo();
    public sealed virtual Msg Next(int maxWaitMillis);
    public sealed virtual IFetchConsumer FetchMessages(int maxMessages);
    public sealed virtual IFetchConsumer FetchBytes(int maxBytes);
    public sealed virtual IFetchConsumer Fetch(FetchConsumeOptions fetchConsumeOptions);
    public sealed virtual IIterableConsumer Iterate(ConsumeOptions consumeOptions);
    public sealed virtual IMessageConsumer Consume(EventHandler`1<MsgHandlerEventArgs> handler, ConsumeOptions consumeOptions);
}
public class NATS.Client.JetStream.ConsumerCreateRequest : JsonSerializable {
    [CompilerGeneratedAttribute]
private string <StreamName>k__BackingField;
    [CompilerGeneratedAttribute]
private ConsumerConfiguration <Config>k__BackingField;
    [CompilerGeneratedAttribute]
private ConsumerCreateRequestAction <Action>k__BackingField;
    public string StreamName { get; }
    public ConsumerConfiguration Config { get; }
    public ConsumerCreateRequestAction Action { get; }
    internal ConsumerCreateRequest(string streamName, ConsumerConfiguration config, ConsumerCreateRequestAction action);
    [CompilerGeneratedAttribute]
public string get_StreamName();
    [CompilerGeneratedAttribute]
public ConsumerConfiguration get_Config();
    [CompilerGeneratedAttribute]
public ConsumerCreateRequestAction get_Action();
    public virtual JSONNode ToJsonNode();
}
public enum NATS.Client.JetStream.ConsumerCreateRequestAction : Enum {
    public int value__;
    public static ConsumerCreateRequestAction Create;
    public static ConsumerCreateRequestAction Update;
    public static ConsumerCreateRequestAction CreateOrUpdate;
}
public class NATS.Client.JetStream.ConsumerInfo : ApiResponse {
    [CompilerGeneratedAttribute]
private string <Stream>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private ConsumerConfiguration <ConsumerConfiguration>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <Created>k__BackingField;
    [CompilerGeneratedAttribute]
private SequenceInfo <Delivered>k__BackingField;
    [CompilerGeneratedAttribute]
private SequenceInfo <AckFloor>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <NumPending>k__BackingField;
    [CompilerGeneratedAttribute]
private long <NumWaiting>k__BackingField;
    [CompilerGeneratedAttribute]
private long <NumAckPending>k__BackingField;
    [CompilerGeneratedAttribute]
private long <NumRedelivered>k__BackingField;
    [CompilerGeneratedAttribute]
private ClusterInfo <ClusterInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PushBound>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <Timestamp>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Paused>k__BackingField;
    [CompilerGeneratedAttribute]
private Duration <PauseRemaining>k__BackingField;
    public string Stream { get; private set; }
    public string Name { get; private set; }
    public ConsumerConfiguration ConsumerConfiguration { get; private set; }
    public DateTime Created { get; private set; }
    public SequenceInfo Delivered { get; private set; }
    public SequenceInfo AckFloor { get; private set; }
    public ulong NumPending { get; private set; }
    public long NumWaiting { get; private set; }
    public long NumAckPending { get; private set; }
    public long NumRedelivered { get; private set; }
    public ClusterInfo ClusterInfo { get; private set; }
    public bool PushBound { get; private set; }
    public ulong CalculatedPending { get; }
    public DateTime Timestamp { get; private set; }
    public bool Paused { get; private set; }
    public Duration PauseRemaining { get; private set; }
    internal ConsumerInfo(Msg msg, bool throwOnError);
    internal ConsumerInfo(string json, bool throwOnError);
    internal ConsumerInfo(JSONNode ciNode);
    [CompilerGeneratedAttribute]
public string get_Stream();
    [CompilerGeneratedAttribute]
private void set_Stream(string value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
    [CompilerGeneratedAttribute]
public ConsumerConfiguration get_ConsumerConfiguration();
    [CompilerGeneratedAttribute]
private void set_ConsumerConfiguration(ConsumerConfiguration value);
    [CompilerGeneratedAttribute]
public DateTime get_Created();
    [CompilerGeneratedAttribute]
private void set_Created(DateTime value);
    [CompilerGeneratedAttribute]
public SequenceInfo get_Delivered();
    [CompilerGeneratedAttribute]
private void set_Delivered(SequenceInfo value);
    [CompilerGeneratedAttribute]
public SequenceInfo get_AckFloor();
    [CompilerGeneratedAttribute]
private void set_AckFloor(SequenceInfo value);
    [CompilerGeneratedAttribute]
public ulong get_NumPending();
    [CompilerGeneratedAttribute]
private void set_NumPending(ulong value);
    [CompilerGeneratedAttribute]
public long get_NumWaiting();
    [CompilerGeneratedAttribute]
private void set_NumWaiting(long value);
    [CompilerGeneratedAttribute]
public long get_NumAckPending();
    [CompilerGeneratedAttribute]
private void set_NumAckPending(long value);
    [CompilerGeneratedAttribute]
public long get_NumRedelivered();
    [CompilerGeneratedAttribute]
private void set_NumRedelivered(long value);
    [CompilerGeneratedAttribute]
public ClusterInfo get_ClusterInfo();
    [CompilerGeneratedAttribute]
private void set_ClusterInfo(ClusterInfo value);
    [CompilerGeneratedAttribute]
public bool get_PushBound();
    [CompilerGeneratedAttribute]
private void set_PushBound(bool value);
    public ulong get_CalculatedPending();
    [CompilerGeneratedAttribute]
public DateTime get_Timestamp();
    [CompilerGeneratedAttribute]
private void set_Timestamp(DateTime value);
    [CompilerGeneratedAttribute]
public bool get_Paused();
    [CompilerGeneratedAttribute]
private void set_Paused(bool value);
    [CompilerGeneratedAttribute]
public Duration get_PauseRemaining();
    [CompilerGeneratedAttribute]
private void set_PauseRemaining(Duration value);
    private void Init(JSONNode ciNode);
    public virtual string ToString();
}
public class NATS.Client.JetStream.ConsumerLimits : JsonSerializable {
    internal Nullable`1<int> _maxAckPending;
    [CompilerGeneratedAttribute]
private Duration <InactiveThreshold>k__BackingField;
    public int MaxAckPending { get; }
    public Duration InactiveThreshold { get; }
    private ConsumerLimits(ConsumerLimitsBuilder b);
    private ConsumerLimits(JSONNode clNode);
    public int get_MaxAckPending();
    [CompilerGeneratedAttribute]
public Duration get_InactiveThreshold();
    internal static ConsumerLimits OptionalInstance(JSONNode consumerLimitsNode);
    public virtual JSONNode ToJsonNode();
    public static ConsumerLimitsBuilder Builder();
}
internal class NATS.Client.JetStream.ConsumerListReader : AbstractListReader {
    private List`1<ConsumerInfo> _consumerInfos;
    public List`1<ConsumerInfo> Consumers { get; }
    protected virtual void ProcessItem(JSONNode node);
    public List`1<ConsumerInfo> get_Consumers();
}
internal class NATS.Client.JetStream.ConsumerNamesReader : StringListReader {
}
public class NATS.Client.JetStream.ConsumerPauseRequest : JsonSerializable {
    [CompilerGeneratedAttribute]
private DateTime <PauseUntil>k__BackingField;
    public DateTime PauseUntil { get; }
    internal ConsumerPauseRequest(DateTime pauseUntil);
    [CompilerGeneratedAttribute]
public DateTime get_PauseUntil();
    public virtual JSONNode ToJsonNode();
}
public class NATS.Client.JetStream.ConsumerPauseResponse : ApiResponse {
    [CompilerGeneratedAttribute]
private bool <Paused>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <PauseUntil>k__BackingField;
    [CompilerGeneratedAttribute]
private Duration <PauseRemaining>k__BackingField;
    public bool Paused { get; private set; }
    public Nullable`1<DateTime> PauseUntil { get; private set; }
    public Duration PauseRemaining { get; private set; }
    internal ConsumerPauseResponse(Msg msg, bool throwOnError);
    internal ConsumerPauseResponse(string json, bool throwOnError);
    [CompilerGeneratedAttribute]
public bool get_Paused();
    [CompilerGeneratedAttribute]
private void set_Paused(bool value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_PauseUntil();
    [CompilerGeneratedAttribute]
private void set_PauseUntil(Nullable`1<DateTime> value);
    [CompilerGeneratedAttribute]
public Duration get_PauseRemaining();
    [CompilerGeneratedAttribute]
private void set_PauseRemaining(Duration value);
    private void Init();
}
public enum NATS.Client.JetStream.DeliverPolicy : Enum {
    public int value__;
    public static DeliverPolicy All;
    public static DeliverPolicy Last;
    public static DeliverPolicy New;
    public static DeliverPolicy ByStartSequence;
    public static DeliverPolicy ByStartTime;
    public static DeliverPolicy LastPerSubject;
}
public enum NATS.Client.JetStream.DiscardPolicy : Enum {
    public int value__;
    public static DiscardPolicy New;
    public static DiscardPolicy Old;
}
public class NATS.Client.JetStream.Error : object {
    public static int NOT_SET;
    [CompilerGeneratedAttribute]
private int <Code>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ApiErrorCode>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Desc>k__BackingField;
    internal static Error JsBadRequestErr;
    internal static Error JsNoMessageFoundErr;
    public int Code { get; }
    public int ApiErrorCode { get; }
    public string Desc { get; }
    internal Error(JSONNode node);
    internal Error(int code, int apiErrorCode, string desc);
    private static Error();
    [CompilerGeneratedAttribute]
public int get_Code();
    [CompilerGeneratedAttribute]
public int get_ApiErrorCode();
    [CompilerGeneratedAttribute]
public string get_Desc();
    internal static Error OptionalInstance(JSONNode error);
    public virtual string ToString();
    internal static Error Convert(MsgStatus status);
}
public class NATS.Client.JetStream.External : JsonSerializable {
    [CompilerGeneratedAttribute]
private string <Api>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Deliver>k__BackingField;
    public string Api { get; }
    public string Deliver { get; }
    private External(JSONNode externalNode);
    public External(string api, string deliver);
    [CompilerGeneratedAttribute]
public string get_Api();
    [CompilerGeneratedAttribute]
public string get_Deliver();
    internal static External OptionalInstance(JSONNode externalNode);
    public virtual JSONNode ToJsonNode();
    public static ExternalBuilder Builder();
    private bool Equals(External other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public abstract class NATS.Client.JetStream.FeatureBase : object {
    internal JetStream js;
    internal IJetStreamManagement jsm;
    [CompilerGeneratedAttribute]
private string <StreamName>k__BackingField;
    internal string StreamName { get; internal set; }
    protected FeatureBase(IConnection connection, FeatureOptions fo);
    [CompilerGeneratedAttribute]
internal string get_StreamName();
    [CompilerGeneratedAttribute]
internal void set_StreamName(string value);
    internal MessageInfo _getLast(string subject);
    internal MessageInfo _getBySeq(ulong sequence);
    internal void VisitSubject(string subject, DeliverPolicy deliverPolicy, bool headersOnly, bool ordered, Action`1<Msg> action);
    internal void VisitSubject(IList`1<string> subjects, DeliverPolicy deliverPolicy, bool headersOnly, bool ordered, Action`1<Msg> action);
}
public abstract class NATS.Client.JetStream.FeatureOptions : object {
    [CompilerGeneratedAttribute]
private JetStreamOptions <JSOptions>k__BackingField;
    public JetStreamOptions JSOptions { get; }
    protected FeatureOptions(JetStreamOptions jso);
    [CompilerGeneratedAttribute]
public JetStreamOptions get_JSOptions();
}
public class NATS.Client.JetStream.FetchConsumeOptions : BaseConsumeOptions {
    public static FetchConsumeOptions DefaultConsumeOptions;
    public int MaxMessages { get; }
    public long MaxBytes { get; }
    protected FetchConsumeOptions(IBaseConsumeOptionsBuilder b);
    private static FetchConsumeOptions();
    public int get_MaxMessages();
    public long get_MaxBytes();
    public static FetchConsumeOptionsBuilder Builder();
}
internal class NATS.Client.JetStream.FetchConsumer : MessageConsumerBase {
    private long maxWaitTicks;
    private string pullSubject;
    private long startTicks;
    internal FetchConsumer(SimplifiedSubscriptionMaker subscriptionMaker, ConsumerInfo cachedConsumerInfo, FetchConsumeOptions fetchConsumeOptions);
    public sealed virtual void PendingUpdated();
    public sealed virtual void HeartbeatError();
    public sealed virtual Msg NextMessage();
}
public interface NATS.Client.JetStream.IBaseConsumerContext {
    public string ConsumerName { get; }
    public abstract virtual string get_ConsumerName();
    public abstract virtual Msg Next(int maxWaitMillis);
    public abstract virtual IFetchConsumer FetchMessages(int maxMessages);
    public abstract virtual IFetchConsumer FetchBytes(int maxBytes);
    public abstract virtual IFetchConsumer Fetch(FetchConsumeOptions fetchConsumeOptions);
    public abstract virtual IIterableConsumer Iterate(ConsumeOptions consumeOptions);
    public abstract virtual IMessageConsumer Consume(EventHandler`1<MsgHandlerEventArgs> handler, ConsumeOptions consumeOptions);
}
public interface NATS.Client.JetStream.IConsumerContext {
    public abstract virtual ConsumerInfo GetConsumerInfo();
    public abstract virtual ConsumerInfo GetCachedConsumerInfo();
}
public interface NATS.Client.JetStream.IFetchConsumer {
    public abstract virtual Msg NextMessage();
}
public interface NATS.Client.JetStream.IIterableConsumer {
    public abstract virtual Msg NextMessage(int timeoutMillis);
}
public interface NATS.Client.JetStream.IJetStream {
    public abstract virtual PublishAck Publish(string subject, Byte[] data);
    public abstract virtual PublishAck Publish(string subject, MsgHeader headers, Byte[] data);
    public abstract virtual PublishAck Publish(string subject, Byte[] data, PublishOptions publishOptions);
    public abstract virtual PublishAck Publish(string subject, MsgHeader headers, Byte[] data, PublishOptions publishOptions);
    public abstract virtual PublishAck Publish(Msg message);
    public abstract virtual PublishAck Publish(Msg message, PublishOptions publishOptions);
    public abstract virtual Task`1<PublishAck> PublishAsync(string subject, Byte[] data);
    public abstract virtual Task`1<PublishAck> PublishAsync(string subject, MsgHeader headers, Byte[] data);
    public abstract virtual Task`1<PublishAck> PublishAsync(string subject, Byte[] data, PublishOptions publishOptions);
    public abstract virtual Task`1<PublishAck> PublishAsync(string subject, MsgHeader headers, Byte[] data, PublishOptions publishOptions);
    public abstract virtual Task`1<PublishAck> PublishAsync(Msg message);
    public abstract virtual Task`1<PublishAck> PublishAsync(Msg message, PublishOptions publishOptions);
    public abstract virtual IJetStreamPullSubscription PullSubscribe(string subject, PullSubscribeOptions options);
    public abstract virtual IJetStreamPullAsyncSubscription PullSubscribeAsync(string subject, EventHandler`1<MsgHandlerEventArgs> handler, PullSubscribeOptions options);
    public abstract virtual IJetStreamPushAsyncSubscription PushSubscribeAsync(string subject, EventHandler`1<MsgHandlerEventArgs> handler, bool autoAck);
    public abstract virtual IJetStreamPushAsyncSubscription PushSubscribeAsync(string subject, EventHandler`1<MsgHandlerEventArgs> handler, bool autoAck, PushSubscribeOptions options);
    public abstract virtual IJetStreamPushAsyncSubscription PushSubscribeAsync(string subject, string queue, EventHandler`1<MsgHandlerEventArgs> handler, bool autoAck);
    public abstract virtual IJetStreamPushAsyncSubscription PushSubscribeAsync(string subject, string queue, EventHandler`1<MsgHandlerEventArgs> handler, bool autoAck, PushSubscribeOptions options);
    public abstract virtual IJetStreamPushSyncSubscription PushSubscribeSync(string subject);
    public abstract virtual IJetStreamPushSyncSubscription PushSubscribeSync(string subject, PushSubscribeOptions options);
    public abstract virtual IJetStreamPushSyncSubscription PushSubscribeSync(string subject, string queue);
    public abstract virtual IJetStreamPushSyncSubscription PushSubscribeSync(string subject, string queue, PushSubscribeOptions options);
    public abstract virtual IStreamContext GetStreamContext(string streamName);
    public abstract virtual IConsumerContext GetConsumerContext(string streamName, string consumerName);
}
public interface NATS.Client.JetStream.IJetStreamManagement {
    public abstract virtual AccountStatistics GetAccountStatistics();
    public abstract virtual StreamInfo AddStream(StreamConfiguration config);
    public abstract virtual StreamInfo UpdateStream(StreamConfiguration config);
    public abstract virtual bool DeleteStream(string streamName);
    public abstract virtual StreamInfo GetStreamInfo(string streamName);
    public abstract virtual StreamInfo GetStreamInfo(string streamName, StreamInfoOptions options);
    public abstract virtual PurgeResponse PurgeStream(string streamName);
    public abstract virtual PurgeResponse PurgeStream(string streamName, PurgeOptions options);
    public abstract virtual ConsumerInfo AddOrUpdateConsumer(string streamName, ConsumerConfiguration config);
    public abstract virtual ConsumerInfo CreateConsumer(string streamName, ConsumerConfiguration config);
    public abstract virtual ConsumerInfo UpdateConsumer(string streamName, ConsumerConfiguration config);
    public abstract virtual bool DeleteConsumer(string streamName, string consumer);
    public abstract virtual ConsumerPauseResponse PauseConsumer(string streamName, string consumer, DateTime pauseUntil);
    public abstract virtual bool ResumeConsumer(string streamName, string consumer);
    public abstract virtual ConsumerInfo GetConsumerInfo(string streamName, string consumer);
    public abstract virtual IList`1<string> GetConsumerNames(string streamName);
    public abstract virtual IList`1<ConsumerInfo> GetConsumers(string streamName);
    public abstract virtual IList`1<string> GetStreamNames();
    public abstract virtual IList`1<string> GetStreamNames(string subjectFilter);
    public abstract virtual IList`1<StreamInfo> GetStreams();
    public abstract virtual IList`1<StreamInfo> GetStreams(string subjectFilter);
    public abstract virtual MessageInfo GetMessage(string streamName, ulong sequence);
    public abstract virtual MessageInfo GetLastMessage(string streamName, string subject);
    public abstract virtual MessageInfo GetFirstMessage(string streamName, string subject);
    public abstract virtual MessageInfo GetNextMessage(string streamName, ulong sequence, string subject);
    public abstract virtual bool DeleteMessage(string streamName, ulong sequence);
    public abstract virtual bool DeleteMessage(string streamName, ulong sequence, bool erase);
    public abstract virtual IJetStream GetJetStreamContext();
}
public interface NATS.Client.JetStream.IJetStreamPullApiSubscription {
    public abstract virtual void Pull(int batchSize);
    public abstract virtual void Pull(PullRequestOptions pullRequestOptions);
    public abstract virtual void PullNoWait(int batchSize);
    public abstract virtual void PullNoWait(int batchSize, int expiresInMillis);
    public abstract virtual void PullExpiresIn(int batchSize, int expiresInMillis);
}
public interface NATS.Client.JetStream.IJetStreamPullAsyncSubscription {
}
public interface NATS.Client.JetStream.IJetStreamPullSubscription {
    public abstract virtual IList`1<Msg> Fetch(int batchSize, int maxWaitMillis);
}
public interface NATS.Client.JetStream.IJetStreamPushAsyncSubscription {
}
public interface NATS.Client.JetStream.IJetStreamPushSyncSubscription {
}
public interface NATS.Client.JetStream.IJetStreamSubscription {
    public JetStream Context { get; }
    public string Stream { get; }
    public string Consumer { get; }
    public string DeliverSubject { get; }
    public abstract virtual JetStream get_Context();
    public abstract virtual string get_Stream();
    public abstract virtual string get_Consumer();
    public abstract virtual string get_DeliverSubject();
    public abstract virtual ConsumerInfo GetConsumerInformation();
    public abstract virtual bool IsPullMode();
}
public interface NATS.Client.JetStream.IMessageConsumer {
    public bool Stopped { get; }
    public bool Finished { get; }
    public abstract virtual string GetConsumerName();
    public abstract virtual ConsumerInfo GetConsumerInformation();
    public abstract virtual ConsumerInfo GetCachedConsumerInformation();
    public abstract virtual void Stop();
    public abstract virtual bool get_Stopped();
    public abstract virtual bool get_Finished();
}
public interface NATS.Client.JetStream.IOrderedConsumerContext {
}
public interface NATS.Client.JetStream.IPullManagerObserver {
    public abstract virtual void PendingUpdated();
    public abstract virtual void HeartbeatError();
}
public interface NATS.Client.JetStream.IStreamContext {
    public string StreamName { get; }
    public abstract virtual string get_StreamName();
    public abstract virtual StreamInfo GetStreamInfo();
    public abstract virtual StreamInfo GetStreamInfo(StreamInfoOptions options);
    public abstract virtual PurgeResponse Purge();
    public abstract virtual PurgeResponse Purge(PurgeOptions options);
    public abstract virtual IConsumerContext GetConsumerContext(string consumerName);
    public abstract virtual IConsumerContext CreateOrUpdateConsumer(ConsumerConfiguration config);
    public abstract virtual IOrderedConsumerContext CreateOrderedConsumer(OrderedConsumerConfiguration config);
    public abstract virtual bool DeleteConsumer(string consumerName);
    public abstract virtual ConsumerInfo GetConsumerInfo(string consumerName);
    public abstract virtual IList`1<string> GetConsumerNames();
    public abstract virtual IList`1<ConsumerInfo> GetConsumers();
    public abstract virtual MessageInfo GetMessage(ulong seq);
    public abstract virtual MessageInfo GetLastMessage(string subject);
    public abstract virtual MessageInfo GetFirstMessage(string subject);
    public abstract virtual MessageInfo GetNextMessage(ulong seq, string subject);
    public abstract virtual bool DeleteMessage(ulong seq);
    public abstract virtual bool DeleteMessage(ulong seq, bool erase);
}
internal class NATS.Client.JetStream.IterableConsumer : MessageConsumer {
    internal IterableConsumer(SimplifiedSubscriptionMaker subscriptionMaker, ConsumeOptions consumeOptions, ConsumerInfo cachedConsumerInfo);
    public sealed virtual Msg NextMessage(int timeoutMillis);
}
public class NATS.Client.JetStream.JetStream : JetStreamBase {
    internal MessageManagerFactory _pushMessageManagerFactory;
    internal MessageManagerFactory _pushOrderedMessageManagerFactory;
    internal MessageManagerFactory _pullMessageManagerFactory;
    internal MessageManagerFactory _pullOrderedMessageManagerFactory;
    protected internal JetStream(IConnection connection, JetStreamOptions options);
    protected internal JetStream(JetStreamBase jetStreamBase);
    private MsgHeader MergePublishOptions(MsgHeader headers, PublishOptions opts);
    private MsgHeader MergeNum(MsgHeader h, string key, ulong value);
    private MsgHeader MergeString(MsgHeader h, string key, string value);
    private MsgHeader _MergeString(MsgHeader h, string key, string value);
    private PublishAck ProcessPublishResponse(Msg resp, PublishOptions options);
    private PublishAck PublishSyncInternal(string subject, Byte[] data, MsgHeader hdr, PublishOptions options);
    [AsyncStateMachineAttribute("NATS.Client.JetStream.JetStream/<PublishAsyncInternal>d__8")]
private Task`1<PublishAck> PublishAsyncInternal(string subject, Byte[] data, MsgHeader hdr, PublishOptions options);
    public sealed virtual PublishAck Publish(string subject, Byte[] data);
    public sealed virtual PublishAck Publish(string subject, MsgHeader headers, Byte[] data);
    public sealed virtual PublishAck Publish(string subject, Byte[] data, PublishOptions options);
    public sealed virtual PublishAck Publish(string subject, MsgHeader headers, Byte[] data, PublishOptions options);
    public sealed virtual PublishAck Publish(Msg msg);
    public sealed virtual PublishAck Publish(Msg msg, PublishOptions publishOptions);
    public sealed virtual Task`1<PublishAck> PublishAsync(string subject, Byte[] data);
    public sealed virtual Task`1<PublishAck> PublishAsync(string subject, MsgHeader headers, Byte[] data);
    public sealed virtual Task`1<PublishAck> PublishAsync(string subject, Byte[] data, PublishOptions publishOptions);
    public sealed virtual Task`1<PublishAck> PublishAsync(string subject, MsgHeader headers, Byte[] data, PublishOptions publishOptions);
    public sealed virtual Task`1<PublishAck> PublishAsync(Msg msg);
    public sealed virtual Task`1<PublishAck> PublishAsync(Msg msg, PublishOptions publishOptions);
    internal Subscription CreateSubscription(string userSubscribeSubject, PushSubscribeOptions pushSubscribeOptions, PullSubscribeOptions pullSubscribeOptions, string queueName, EventHandler`1<MsgHandlerEventArgs> userHandler, bool autoAck, PullMessageManager pmmInstance);
    protected internal ConsumerInfo LookupConsumerInfo(string lookupStream, string lookupConsumer);
    private string LookupStreamBySubject(string subject);
    private string LookupStreamSubject(string stream);
    private bool IsFilterMatch(string subscribeSubject, string filterSubject, string stream);
    public sealed virtual IJetStreamPullSubscription PullSubscribe(string subject, PullSubscribeOptions options);
    public sealed virtual IJetStreamPullAsyncSubscription PullSubscribeAsync(string subject, EventHandler`1<MsgHandlerEventArgs> handler, PullSubscribeOptions options);
    public sealed virtual IJetStreamPushAsyncSubscription PushSubscribeAsync(string subject, EventHandler`1<MsgHandlerEventArgs> handler, bool autoAck);
    public sealed virtual IJetStreamPushAsyncSubscription PushSubscribeAsync(string subject, string queue, EventHandler`1<MsgHandlerEventArgs> handler, bool autoAck);
    public sealed virtual IJetStreamPushAsyncSubscription PushSubscribeAsync(string subject, EventHandler`1<MsgHandlerEventArgs> handler, bool autoAck, PushSubscribeOptions options);
    public sealed virtual IJetStreamPushAsyncSubscription PushSubscribeAsync(string subject, string queue, EventHandler`1<MsgHandlerEventArgs> handler, bool autoAck, PushSubscribeOptions options);
    public sealed virtual IJetStreamPushSyncSubscription PushSubscribeSync(string subject);
    public sealed virtual IJetStreamPushSyncSubscription PushSubscribeSync(string subject, PushSubscribeOptions options);
    public sealed virtual IJetStreamPushSyncSubscription PushSubscribeSync(string subject, string queue);
    public sealed virtual IJetStreamPushSyncSubscription PushSubscribeSync(string subject, string queue, PushSubscribeOptions options);
    public sealed virtual IStreamContext GetStreamContext(string streamName);
    public sealed virtual IConsumerContext GetConsumerContext(string streamName, string consumerName);
}
public abstract class NATS.Client.JetStream.JetStreamAbstractAsyncSubscription : AsyncSubscription {
    internal MessageManager MessageManager;
    internal string _consumer;
    [CompilerGeneratedAttribute]
private JetStream <Context>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Stream>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DeliverSubject>k__BackingField;
    public JetStream Context { get; }
    public string Stream { get; }
    public string Consumer { get; }
    public string DeliverSubject { get; }
    internal JetStreamAbstractAsyncSubscription(Connection conn, string subject, string queue, JetStream js, string stream, string consumer, string deliver, MessageManager messageManager);
    [CompilerGeneratedAttribute]
public sealed virtual JetStream get_Context();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Stream();
    public sealed virtual string get_Consumer();
    [CompilerGeneratedAttribute]
public sealed virtual string get_DeliverSubject();
    internal virtual void SetConsumerName(string consumer);
    public sealed virtual ConsumerInfo GetConsumerInformation();
    public virtual void Unsubscribe();
    internal virtual void close();
}
public abstract class NATS.Client.JetStream.JetStreamAbstractSyncSubscription : SyncSubscription {
    internal MessageManager MessageManager;
    internal string _consumer;
    [CompilerGeneratedAttribute]
private JetStream <Context>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Stream>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DeliverSubject>k__BackingField;
    public JetStream Context { get; }
    public string Stream { get; }
    public string Consumer { get; }
    public string DeliverSubject { get; }
    internal JetStreamAbstractSyncSubscription(Connection conn, string subject, string queue, JetStream js, string stream, string consumer, string deliver, MessageManager messageManager);
    [CompilerGeneratedAttribute]
public sealed virtual JetStream get_Context();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Stream();
    public sealed virtual string get_Consumer();
    [CompilerGeneratedAttribute]
public sealed virtual string get_DeliverSubject();
    internal virtual void SetConsumerName(string consumer);
    public sealed virtual ConsumerInfo GetConsumerInformation();
    public virtual void Unsubscribe();
    public virtual void AutoUnsubscribe(int max);
    internal virtual void close();
    protected virtual void Dispose(bool disposing);
    public virtual Msg NextMessage();
    public virtual Msg NextMessage(int timeout);
    internal Msg _nextUnmanagedWaitForever(string expectedPullSubject);
    internal Msg _nextUnmanagedNoWait(string expectedPullSubject);
    internal Msg _nextUnmanaged(int timeout, string expectedPullSubject);
}
public class NATS.Client.JetStream.JetStreamBase : object {
    private ConcurrentDictionary`2<string, CachedStreamInfo> cachedStreamInfoDictionary;
    [CompilerGeneratedAttribute]
private string <Prefix>k__BackingField;
    [CompilerGeneratedAttribute]
private JetStreamOptions <JetStreamOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private IConnection <Conn>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Timeout>k__BackingField;
    private Nullable`1<bool> _consumerCreate290Available;
    private Nullable`1<bool> _multipleSubjectFilter210Available;
    public string Prefix { get; }
    public JetStreamOptions JetStreamOptions { get; }
    public IConnection Conn { get; }
    public int Timeout { get; }
    protected JetStreamBase(IConnection connection, JetStreamOptions options);
    protected JetStreamBase(JetStreamBase jetStreamBase);
    [CompilerGeneratedAttribute]
public string get_Prefix();
    [CompilerGeneratedAttribute]
public JetStreamOptions get_JetStreamOptions();
    [CompilerGeneratedAttribute]
public IConnection get_Conn();
    [CompilerGeneratedAttribute]
public int get_Timeout();
    protected bool ConsumerCreate290Available();
    protected bool MultipleSubjectFilter210Available();
    internal static ServerInfo ServerInfoOrException(IConnection conn);
    internal ConsumerInfo GetConsumerInfoInternal(string streamName, string consumer);
    internal ConsumerInfo CreateConsumerInternal(string streamName, ConsumerConfiguration config, ConsumerCreateRequestAction ccrAction);
    internal string GenerateConsumerName();
    internal ConsumerConfiguration ConsumerConfigurationForOrdered(ConsumerConfiguration originalCc, ulong lastStreamSeq, string newDeliverSubject, string consumerName, Nullable`1<long> inactiveThreshold);
    internal StreamInfo GetStreamInfoInternal(string streamName, StreamInfoOptions options);
    internal StreamInfo CreateAndCacheStreamInfoThrowOnError(string streamName, Msg resp);
    internal StreamInfo CacheStreamInfo(string streamName, StreamInfo si);
    internal IList`1<StreamInfo> CacheStreamInfo(IList`1<StreamInfo> list);
    internal IList`1<string> GetStreamNamesInternal(string subjectFilter);
    internal string PrependPrefix(string subject);
    public Msg RequestResponseRequired(string subject, Byte[] bytes, int timeout);
    internal CachedStreamInfo GetCachedStreamInfo(string streamName);
}
public class NATS.Client.JetStream.JetStreamManagement : JetStreamBase {
    private IJetStream js;
    internal JetStreamManagement(IConnection connection, JetStreamOptions options);
    public sealed virtual AccountStatistics GetAccountStatistics();
    public sealed virtual StreamInfo AddStream(StreamConfiguration config);
    public sealed virtual StreamInfo UpdateStream(StreamConfiguration config);
    private StreamInfo AddOrUpdateStream(StreamConfiguration config, string addUpdateTemplate);
    public sealed virtual bool DeleteStream(string streamName);
    public sealed virtual StreamInfo GetStreamInfo(string streamName);
    public sealed virtual StreamInfo GetStreamInfo(string streamName, StreamInfoOptions options);
    public sealed virtual PurgeResponse PurgeStream(string streamName);
    public sealed virtual PurgeResponse PurgeStream(string streamName, PurgeOptions options);
    public sealed virtual ConsumerInfo AddOrUpdateConsumer(string streamName, ConsumerConfiguration config);
    public sealed virtual ConsumerInfo CreateConsumer(string streamName, ConsumerConfiguration config);
    public sealed virtual ConsumerInfo UpdateConsumer(string streamName, ConsumerConfiguration config);
    public sealed virtual bool DeleteConsumer(string streamName, string consumer);
    public sealed virtual ConsumerPauseResponse PauseConsumer(string streamName, string consumer, DateTime pauseUntil);
    public sealed virtual bool ResumeConsumer(string streamName, string consumer);
    public sealed virtual ConsumerInfo GetConsumerInfo(string streamName, string consumer);
    public sealed virtual IList`1<string> GetConsumerNames(string streamName);
    public sealed virtual IList`1<ConsumerInfo> GetConsumers(string streamName);
    public sealed virtual IList`1<string> GetStreamNames();
    public sealed virtual IList`1<string> GetStreamNames(string subjectFilter);
    public sealed virtual IList`1<StreamInfo> GetStreams();
    public sealed virtual IList`1<StreamInfo> GetStreams(string subjectFilter);
    public sealed virtual MessageInfo GetMessage(string streamName, ulong sequence);
    public sealed virtual MessageInfo GetLastMessage(string streamName, string subject);
    public sealed virtual MessageInfo GetFirstMessage(string streamName, string subject);
    public sealed virtual MessageInfo GetNextMessage(string streamName, ulong sequence, string subject);
    internal MessageInfo _GetMessage(string streamName, MessageGetRequest messageGetRequest);
    public sealed virtual bool DeleteMessage(string streamName, ulong sequence);
    public sealed virtual bool DeleteMessage(string streamName, ulong sequence, bool erase);
    public sealed virtual IJetStream GetJetStreamContext();
}
public class NATS.Client.JetStream.JetStreamMsg : Msg {
    [CompilerGeneratedAttribute]
private MetaData <MetaData>k__BackingField;
    [CompilerGeneratedAttribute]
private IConnection <Connection>k__BackingField;
    public MetaData MetaData { get; }
    private IConnection Connection { get; }
    public bool IsJetStream { get; }
    public string Reply { get; }
    internal JetStreamMsg(IConnection conn, MsgArg arg, Subscription s, Byte[] payload, long totalLen);
    [CompilerGeneratedAttribute]
public virtual MetaData get_MetaData();
    [CompilerGeneratedAttribute]
private IConnection get_Connection();
    private void AckReply(AckType ackType, long delayNanoseconds, int timeout);
    private bool AckHasntBeenTermed();
    public virtual void Ack();
    public virtual void AckSync(int timeout);
    public virtual void Nak();
    public virtual void NakWithDelay(Duration nakDelay);
    public virtual void NakWithDelay(long nakDelayMillis);
    public virtual void Term();
    public virtual void InProgress();
    public virtual bool get_IsJetStream();
    public string get_Reply();
}
public class NATS.Client.JetStream.JetStreamOptions : object {
    [ObsoleteAttribute("This property is obsolete. The connection options request timeout is used as the default", "False")]
public static Duration DefaultTimeout;
    public static JetStreamOptions DefaultJsOptions;
    [CompilerGeneratedAttribute]
private string <Prefix>k__BackingField;
    [CompilerGeneratedAttribute]
private Duration <RequestTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsPublishNoAck>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsDefaultPrefix>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsOptOut290ConsumerCreate>k__BackingField;
    public string Prefix { get; }
    public Duration RequestTimeout { get; }
    public bool IsPublishNoAck { get; }
    public bool IsDefaultPrefix { get; }
    public bool IsOptOut290ConsumerCreate { get; }
    private JetStreamOptions(JetStreamOptionsBuilder b);
    private static JetStreamOptions();
    [CompilerGeneratedAttribute]
public string get_Prefix();
    [CompilerGeneratedAttribute]
public Duration get_RequestTimeout();
    [CompilerGeneratedAttribute]
public bool get_IsPublishNoAck();
    [CompilerGeneratedAttribute]
public bool get_IsDefaultPrefix();
    [CompilerGeneratedAttribute]
public bool get_IsOptOut290ConsumerCreate();
    internal static string ConvertDomainToPrefix(string domain);
    public static JetStreamOptionsBuilder Builder();
    public static JetStreamOptionsBuilder Builder(JetStreamOptions jso);
}
internal class NATS.Client.JetStream.JetStreamPullApiImpl : object {
    private InterlockedLong _pullSubjectIdHolder;
    private Connection _conn;
    private JetStream _js;
    private MessageManager _mm;
    private string _stream;
    private string _subject;
    private string _consumer;
    internal JetStreamPullApiImpl(Connection conn, JetStream js, MessageManager messageManager, string stream, string subject, string consumer);
    internal void UpdateConsumer(string consumer);
    internal string Pull(PullRequestOptions pullRequestOptions, bool raiseStatusWarnings, IPullManagerObserver pullManagerObserver);
}
public class NATS.Client.JetStream.JetStreamPullAsyncSubscription : JetStreamAbstractAsyncSubscription {
    internal JetStreamPullApiImpl pullImpl;
    internal JetStreamPullAsyncSubscription(Connection conn, string subject, JetStream js, string stream, string consumer, string deliver, MessageManager messageManager);
    internal virtual void SetConsumerName(string consumer);
    public sealed virtual bool IsPullMode();
    public sealed virtual void Pull(int batchSize);
    public sealed virtual void Pull(PullRequestOptions pullRequestOptions);
    public sealed virtual void PullExpiresIn(int batchSize, int expiresInMillis);
    public sealed virtual void PullNoWait(int batchSize);
    public sealed virtual void PullNoWait(int batchSize, int expiresInMillis);
}
public class NATS.Client.JetStream.JetStreamPullSubscription : JetStreamAbstractSyncSubscription {
    internal JetStreamPullApiImpl pullImpl;
    internal static int ExpireAdjustment;
    internal static int MinExpireMillis;
    internal JetStreamPullSubscription(Connection conn, string subject, JetStream js, string stream, string consumer, string deliver, MessageManager messageManager);
    internal virtual void SetConsumerName(string consumer);
    public sealed virtual bool IsPullMode();
    public sealed virtual void Pull(int batchSize);
    public sealed virtual void Pull(PullRequestOptions pullRequestOptions);
    public sealed virtual void PullExpiresIn(int batchSize, int expiresInMillis);
    public sealed virtual void PullNoWait(int batchSize);
    public sealed virtual void PullNoWait(int batchSize, int expiresInMillis);
    public sealed virtual IList`1<Msg> Fetch(int batchSize, int maxWaitMillis);
}
public class NATS.Client.JetStream.JetStreamPushAsyncSubscription : JetStreamAbstractAsyncSubscription {
    internal JetStreamPushAsyncSubscription(Connection conn, string subject, string queue, JetStream js, string stream, string consumer, string deliver, MessageManager messageManager);
    public sealed virtual bool IsPullMode();
}
public class NATS.Client.JetStream.JetStreamPushSyncSubscription : JetStreamAbstractSyncSubscription {
    internal JetStreamPushSyncSubscription(Connection conn, string subject, string queue, JetStream js, string stream, string consumer, string deliver, MessageManager messageManager);
    public sealed virtual bool IsPullMode();
}
public abstract class NATS.Client.JetStream.JsonSerializable : object {
    public abstract virtual JSONNode ToJsonNode();
    public virtual Byte[] Serialize();
    public virtual string ToJsonString();
}
internal class NATS.Client.JetStream.ListRequestEngine : ApiResponse {
    private static string OffsetJsonStart;
    protected int Total;
    protected int Limit;
    protected int LastOffset;
    internal ListRequestEngine(Msg msg);
    private static ListRequestEngine();
    internal bool HasMore();
    internal Byte[] InternalNextJson();
    internal Byte[] NoFilterJson();
    internal Byte[] InternalNextJson(string fieldName, string filter);
    internal int NextOffset();
    internal JSONArray GetNodes(string objectName);
}
public class NATS.Client.JetStream.LostStreamData : object {
    [CompilerGeneratedAttribute]
private IList`1<ulong> <Messages>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <Bytes>k__BackingField;
    public IList`1<ulong> Messages { get; }
    public ulong Bytes { get; }
    private LostStreamData(JSONNode lostNode);
    [CompilerGeneratedAttribute]
public IList`1<ulong> get_Messages();
    [CompilerGeneratedAttribute]
public ulong get_Bytes();
    internal static LostStreamData OptionalInstance(JSONNode lostNode);
    public virtual string ToString();
}
public enum NATS.Client.JetStream.ManageResult : Enum {
    public int value__;
    public static ManageResult Message;
    public static ManageResult StatusHandled;
    public static ManageResult StatusTerminus;
    public static ManageResult StatusError;
}
internal class NATS.Client.JetStream.MessageConsumer : MessageConsumerBase {
    private BaseConsumeOptions opts;
    private int thresholdMessages;
    private long thresholdBytes;
    private SimplifiedSubscriptionMaker subscriptionMaker;
    private EventHandler`1<MsgHandlerEventArgs> userMessageHandler;
    internal MessageConsumer(SimplifiedSubscriptionMaker subscriptionMaker, ConsumerInfo cachedConsumerInfo, BaseConsumeOptions opts, EventHandler`1<MsgHandlerEventArgs> userMessageHandler);
    public sealed virtual void HeartbeatError();
    private void DoSub();
    private void SetupHbAlarmToTrigger();
    public sealed virtual void PendingUpdated();
    private void Repull();
    [CompilerGeneratedAttribute]
private void <DoSub>b__7_0(object sender, MsgHandlerEventArgs args);
}
internal class NATS.Client.JetStream.MessageConsumerBase : object {
    internal IJetStreamSubscription sub;
    internal PullMessageManager pmm;
    internal JetStreamPullApiImpl pullImpl;
    internal ConsumerInfo cachedConsumerInfo;
    private InterlockedBoolean _stopped;
    private InterlockedBoolean _finished;
    public bool Stopped { get; internal set; }
    public bool Finished { get; internal set; }
    internal MessageConsumerBase(ConsumerInfo cachedConsumerInfo);
    public sealed virtual bool get_Stopped();
    internal void set_Stopped(bool value);
    public sealed virtual bool get_Finished();
    internal void set_Finished(bool value);
    internal void InitSub(IJetStreamSubscription inSub);
    public sealed virtual string GetConsumerName();
    public sealed virtual ConsumerInfo GetConsumerInformation();
    public sealed virtual ConsumerInfo GetCachedConsumerInformation();
    public sealed virtual void Stop();
    public sealed virtual void Dispose();
}
public class NATS.Client.JetStream.MessageDeleteRequest : JsonSerializable {
    [CompilerGeneratedAttribute]
private ulong <Sequence>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Erase>k__BackingField;
    public ulong Sequence { get; }
    public bool Erase { get; }
    public bool NoErase { get; }
    public MessageDeleteRequest(ulong sequence, bool erase);
    [CompilerGeneratedAttribute]
public ulong get_Sequence();
    [CompilerGeneratedAttribute]
public bool get_Erase();
    public bool get_NoErase();
    public virtual JSONNode ToJsonNode();
}
public class NATS.Client.JetStream.MessageGetRequest : JsonSerializable {
    [CompilerGeneratedAttribute]
private ulong <Sequence>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LastBySubject>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NextBySubject>k__BackingField;
    public ulong Sequence { get; }
    public string LastBySubject { get; }
    public string NextBySubject { get; }
    public bool IsSequenceOnly { get; }
    public bool IsLastBySubject { get; }
    public bool IsNextBySubject { get; }
    public MessageGetRequest(ulong sequence, string lastBySubject, string nextBySubject);
    [CompilerGeneratedAttribute]
public ulong get_Sequence();
    [CompilerGeneratedAttribute]
public string get_LastBySubject();
    [CompilerGeneratedAttribute]
public string get_NextBySubject();
    public bool get_IsSequenceOnly();
    public bool get_IsLastBySubject();
    public bool get_IsNextBySubject();
    public static MessageGetRequest ForSequence(ulong sequence);
    public static MessageGetRequest LastForSubject(string subject);
    public static MessageGetRequest FirstForSubject(string subject);
    public static MessageGetRequest NextForSubject(ulong sequence, string subject);
    public virtual JSONNode ToJsonNode();
}
public class NATS.Client.JetStream.MessageInfo : ApiResponse {
    [CompilerGeneratedAttribute]
private string <Subject>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <Sequence>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <Data>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <Time>k__BackingField;
    [CompilerGeneratedAttribute]
private MsgHeader <Headers>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Stream>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <LastSequence>k__BackingField;
    public string Subject { get; private set; }
    public ulong Sequence { get; private set; }
    public Byte[] Data { get; private set; }
    public DateTime Time { get; private set; }
    public MsgHeader Headers { get; private set; }
    public string Stream { get; private set; }
    public ulong LastSequence { get; private set; }
    [ObsoleteAttribute("This property is obsolete. Use Sequence instead.", "False")]
public long Seq { get; }
    internal MessageInfo(Msg msg, string streamName, bool fromDirect, bool throwOnError);
    public MessageInfo(string json);
    [CompilerGeneratedAttribute]
public string get_Subject();
    [CompilerGeneratedAttribute]
private void set_Subject(string value);
    [CompilerGeneratedAttribute]
public ulong get_Sequence();
    [CompilerGeneratedAttribute]
private void set_Sequence(ulong value);
    [CompilerGeneratedAttribute]
public Byte[] get_Data();
    [CompilerGeneratedAttribute]
private void set_Data(Byte[] value);
    [CompilerGeneratedAttribute]
public DateTime get_Time();
    [CompilerGeneratedAttribute]
private void set_Time(DateTime value);
    [CompilerGeneratedAttribute]
public MsgHeader get_Headers();
    [CompilerGeneratedAttribute]
private void set_Headers(MsgHeader value);
    [CompilerGeneratedAttribute]
public string get_Stream();
    [CompilerGeneratedAttribute]
private void set_Stream(string value);
    [CompilerGeneratedAttribute]
public ulong get_LastSequence();
    [CompilerGeneratedAttribute]
private void set_LastSequence(ulong value);
    public long get_Seq();
    private void Init(Msg msg, bool fromDirect, string streamName);
}
public abstract class NATS.Client.JetStream.MessageManager : object {
    public static int Threshold;
    protected object StateChangeLock;
    protected Connection Conn;
    protected SubscribeOptions SubOpts;
    protected bool SyncMode;
    protected IJetStreamSubscription Sub;
    internal ulong LastStreamSeq;
    internal ulong LastConsumerSeq;
    internal InterlockedLong LastMsgReceived;
    protected bool Hb;
    protected int IdleHeartbeatSetting;
    protected int AlarmPeriodSetting;
    protected Timer heartbeatTimer;
    protected MessageManager(Connection conn, SubscribeOptions so, bool syncMode);
    public virtual void Startup(IJetStreamSubscription sub);
    public virtual void Shutdown();
    public virtual void StartPullRequest(string pullSubject, PullRequestOptions pullRequestOptions, bool raiseStatusWarnings, IPullManagerObserver pullManagerObserver);
    protected void UpdateLastMessageReceived();
    protected virtual bool BeforeChannelAddCheck(Msg msg);
    public abstract virtual ManageResult Manage(Msg msg);
    protected void TrackJsMessage(Msg msg);
    internal virtual void HandleHeartbeatError();
    protected void ConfigureIdleHeartbeat(Duration configIdleHeartbeat, int configMessageAlarmTime);
    internal void InitOrResetHeartbeatTimer();
    protected void ShutdownHeartbeatTimer();
    [CompilerGeneratedAttribute]
private void <InitOrResetHeartbeatTimer>b__23_0(object state);
}
public class NATS.Client.JetStream.MetaData : object {
    private static DateTime epochTime;
    [CompilerGeneratedAttribute]
private string <Prefix>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Stream>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Domain>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Consumer>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <NumDelivered>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <StreamSequence>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <ConsumerSequence>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <Timestamp>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <TimestampNanos>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <NumPending>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AccountHash>k__BackingField;
    public string Prefix { get; }
    public string Stream { get; }
    public string Domain { get; }
    public string Consumer { get; }
    public ulong NumDelivered { get; }
    public ulong StreamSequence { get; }
    public ulong ConsumerSequence { get; }
    public DateTime Timestamp { get; }
    public ulong TimestampNanos { get; }
    public ulong NumPending { get; }
    internal string AccountHash { get; }
    internal MetaData(string metaData);
    private static MetaData();
    [CompilerGeneratedAttribute]
public string get_Prefix();
    [CompilerGeneratedAttribute]
public string get_Stream();
    [CompilerGeneratedAttribute]
public string get_Domain();
    [CompilerGeneratedAttribute]
public string get_Consumer();
    [CompilerGeneratedAttribute]
public ulong get_NumDelivered();
    [CompilerGeneratedAttribute]
public ulong get_StreamSequence();
    [CompilerGeneratedAttribute]
public ulong get_ConsumerSequence();
    [CompilerGeneratedAttribute]
public DateTime get_Timestamp();
    [CompilerGeneratedAttribute]
public ulong get_TimestampNanos();
    [CompilerGeneratedAttribute]
public ulong get_NumPending();
    [CompilerGeneratedAttribute]
internal string get_AccountHash();
    public virtual string ToString();
}
public class NATS.Client.JetStream.Mirror : SourceBase {
    public Mirror(string name, ulong startSeq, DateTime startTime, string filterSubject, External external, IList`1<SubjectTransform> subjectTransforms);
    internal Mirror(JSONNode mirrorNode);
    internal Mirror(MirrorBuilder mb);
    internal static Mirror OptionalInstance(JSONNode mirrorNode);
    public static MirrorBuilder Builder();
    public static MirrorBuilder Builder(Mirror mirror);
}
public class NATS.Client.JetStream.MirrorInfo : SourceInfoBase {
    private MirrorInfo(JSONNode mirrorInfoNode);
    internal static MirrorInfo OptionalInstance(JSONNode mirrorInfoNode);
}
public class NATS.Client.JetStream.NATSJetStreamException : NATSException {
    public static int ErrorCodeUnspecified;
    [CompilerGeneratedAttribute]
private int <ErrorCode>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ApiErrorCode>k__BackingField;
    public int ErrorCode { get; }
    public int ApiErrorCode { get; }
    public string ErrorDescription { get; }
    public NATSJetStreamException(ApiResponse apiResponse);
    public NATSJetStreamException(Error error);
    public NATSJetStreamException(string s);
    private static NATSJetStreamException();
    [CompilerGeneratedAttribute]
public int get_ErrorCode();
    [CompilerGeneratedAttribute]
public int get_ApiErrorCode();
    public string get_ErrorDescription();
}
public class NATS.Client.JetStream.OrderedConsumerConfiguration : object {
    public static string DefaultFilterSubject;
    [CompilerGeneratedAttribute]
private Nullable`1<DeliverPolicy> <DeliverPolicy>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <StartSequence>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <StartTime>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<ReplayPolicy> <ReplayPolicy>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <HeadersOnly>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<string> <FilterSubjects>k__BackingField;
    public Nullable`1<DeliverPolicy> DeliverPolicy { get; private set; }
    public ulong StartSequence { get; private set; }
    public DateTime StartTime { get; private set; }
    public Nullable`1<ReplayPolicy> ReplayPolicy { get; private set; }
    public Nullable`1<bool> HeadersOnly { get; private set; }
    public string FilterSubject { get; }
    public IList`1<string> FilterSubjects { get; }
    public bool HasMultipleFilterSubjects { get; }
    [CompilerGeneratedAttribute]
public Nullable`1<DeliverPolicy> get_DeliverPolicy();
    [CompilerGeneratedAttribute]
private void set_DeliverPolicy(Nullable`1<DeliverPolicy> value);
    [CompilerGeneratedAttribute]
public ulong get_StartSequence();
    [CompilerGeneratedAttribute]
private void set_StartSequence(ulong value);
    [CompilerGeneratedAttribute]
public DateTime get_StartTime();
    [CompilerGeneratedAttribute]
private void set_StartTime(DateTime value);
    [CompilerGeneratedAttribute]
public Nullable`1<ReplayPolicy> get_ReplayPolicy();
    [CompilerGeneratedAttribute]
private void set_ReplayPolicy(Nullable`1<ReplayPolicy> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_HeadersOnly();
    [CompilerGeneratedAttribute]
private void set_HeadersOnly(Nullable`1<bool> value);
    public string get_FilterSubject();
    [CompilerGeneratedAttribute]
public IList`1<string> get_FilterSubjects();
    public bool get_HasMultipleFilterSubjects();
    public OrderedConsumerConfiguration WithFilterSubject(string filterSubject);
    public OrderedConsumerConfiguration WithFilterSubjects(String[] filterSubjects);
    public OrderedConsumerConfiguration WithFilterSubjects(IList`1<string> filterSubjects);
    public OrderedConsumerConfiguration WithDeliverPolicy(Nullable`1<DeliverPolicy> deliverPolicy);
    public OrderedConsumerConfiguration WithStartSequence(ulong startSequence);
    public OrderedConsumerConfiguration WithStartTime(DateTime startTime);
    public OrderedConsumerConfiguration WithReplayPolicy(Nullable`1<ReplayPolicy> replayPolicy);
    public OrderedConsumerConfiguration WithHeadersOnly(Nullable`1<bool> headersOnly);
}
internal class NATS.Client.JetStream.OrderedConsumerContext : object {
    private ConsumerContext impl;
    public string ConsumerName { get; }
    internal OrderedConsumerContext(StreamContext streamContext, OrderedConsumerConfiguration config);
    public sealed virtual string get_ConsumerName();
    public sealed virtual Msg Next(int maxWaitMillis);
    public sealed virtual IFetchConsumer FetchMessages(int maxMessages);
    public sealed virtual IFetchConsumer FetchBytes(int maxBytes);
    public sealed virtual IFetchConsumer Fetch(FetchConsumeOptions fetchConsumeOptions);
    public sealed virtual IIterableConsumer Iterate(ConsumeOptions consumeOptions);
    public sealed virtual IMessageConsumer Consume(EventHandler`1<MsgHandlerEventArgs> handler, ConsumeOptions consumeOptions);
}
public class NATS.Client.JetStream.OrderedMessageManager : PushMessageManager {
    protected ulong ExpectedExternalConsumerSeq;
    protected Nullable`1<long> TargetSid;
    public OrderedMessageManager(Connection conn, JetStream js, string stream, SubscribeOptions so, ConsumerConfiguration originalCc, bool queueMode, bool syncMode);
    public virtual void Startup(IJetStreamSubscription sub);
    public virtual ManageResult Manage(Msg msg);
    internal virtual void HandleHeartbeatError();
    private void HandleErrorCondition();
}
internal class NATS.Client.JetStream.OrderedPullSubscribeOptionsBuilder : PullSubscribeOptionsSubscribeOptionsBuilder {
    internal OrderedPullSubscribeOptionsBuilder(string streamName, ConsumerConfiguration cc);
}
public abstract class NATS.Client.JetStream.PeerInfo : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Current>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Offline>k__BackingField;
    [CompilerGeneratedAttribute]
private Duration <Active>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Lag>k__BackingField;
    public string Name { get; }
    public bool Current { get; }
    public bool Offline { get; }
    public Duration Active { get; }
    public long Lag { get; }
    internal PeerInfo(JSONNode peerInfoNode);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public bool get_Current();
    [CompilerGeneratedAttribute]
public bool get_Offline();
    [CompilerGeneratedAttribute]
public Duration get_Active();
    [CompilerGeneratedAttribute]
public long get_Lag();
}
public class NATS.Client.JetStream.Placement : JsonSerializable {
    private string cluster;
    [CompilerGeneratedAttribute]
private List`1<string> <Tags>k__BackingField;
    public string Cluster { get; private set; }
    public List`1<string> Tags { get; }
    private Placement(JSONNode placementNode);
    public Placement(string cluster);
    public Placement(string cluster, List`1<string> tags);
    public Placement(string cluster, IList`1<string> tags);
    public Placement(IList`1<string> tags);
    public string get_Cluster();
    private void set_Cluster(string value);
    [CompilerGeneratedAttribute]
public List`1<string> get_Tags();
    internal static Placement OptionalInstance(JSONNode placementNode);
    public bool HasData();
    public virtual JSONNode ToJsonNode();
    public static PlacementBuilder Builder();
}
public class NATS.Client.JetStream.PublishAck : ApiResponse {
    [CompilerGeneratedAttribute]
private string <Stream>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <Seq>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Domain>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Duplicate>k__BackingField;
    public string Stream { get; private set; }
    public ulong Seq { get; private set; }
    public string Domain { get; private set; }
    public bool Duplicate { get; private set; }
    public PublishAck(Msg msg);
    public PublishAck(string json);
    [CompilerGeneratedAttribute]
public string get_Stream();
    [CompilerGeneratedAttribute]
private void set_Stream(string value);
    [CompilerGeneratedAttribute]
public ulong get_Seq();
    [CompilerGeneratedAttribute]
private void set_Seq(ulong value);
    [CompilerGeneratedAttribute]
public string get_Domain();
    [CompilerGeneratedAttribute]
private void set_Domain(string value);
    [CompilerGeneratedAttribute]
public bool get_Duplicate();
    [CompilerGeneratedAttribute]
private void set_Duplicate(bool value);
    private void Init();
    public virtual string ToString();
}
public class NATS.Client.JetStream.PublishOptions : object {
    public static Duration DefaultTimeout;
    public static string DefaultStream;
    public static ulong DefaultLastSequence;
    [CompilerGeneratedAttribute]
private string <Stream>k__BackingField;
    [CompilerGeneratedAttribute]
private Duration <StreamTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ExpectedStream>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ExpectedLastMsgId>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <ExpectedLastSeq>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <ExpectedLastSubjectSeq>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MessageId>k__BackingField;
    public string Stream { get; }
    public Duration StreamTimeout { get; }
    public string ExpectedStream { get; }
    public string ExpectedLastMsgId { get; }
    public ulong ExpectedLastSeq { get; }
    public ulong ExpectedLastSubjectSeq { get; }
    public string MessageId { get; }
    private PublishOptions(string stream, Duration streamTimeout, string expectedStream, string expectedLastMsgId, ulong expectedLastSeq, ulong expectedLastSubjectSeq, string messageId);
    private static PublishOptions();
    [CompilerGeneratedAttribute]
public string get_Stream();
    [CompilerGeneratedAttribute]
public Duration get_StreamTimeout();
    [CompilerGeneratedAttribute]
public string get_ExpectedStream();
    [CompilerGeneratedAttribute]
public string get_ExpectedLastMsgId();
    [CompilerGeneratedAttribute]
public ulong get_ExpectedLastSeq();
    [CompilerGeneratedAttribute]
public ulong get_ExpectedLastSubjectSeq();
    [CompilerGeneratedAttribute]
public string get_MessageId();
    public static PublishOptionsBuilder Builder();
}
public class NATS.Client.JetStream.PullMessageManager : MessageManager {
    internal int pendingMessages;
    internal long pendingBytes;
    internal bool trackingBytes;
    internal bool raiseStatusWarnings;
    internal IPullManagerObserver pullManagerObserver;
    public PullMessageManager(Connection conn, SubscribeOptions so, bool syncMode);
    public virtual void Startup(IJetStreamSubscription sub);
    public virtual void StartPullRequest(string pullSubject, PullRequestOptions pro, bool raiseStatusWarnings, IPullManagerObserver pullManagerObserver);
    internal virtual void HandleHeartbeatError();
    private void TrackIncoming(int m, long b);
    internal void ResetTracking();
    protected virtual bool BeforeChannelAddCheck(Msg msg);
    public virtual ManageResult Manage(Msg msg);
    protected ManageResult ManageStatus(Msg msg);
    internal bool NoMorePending();
}
public class NATS.Client.JetStream.PullOrderedMessageManager : PullMessageManager {
    protected ConsumerConfiguration OriginalCc;
    protected JetStream Js;
    protected string Stream;
    protected ulong ExpectedExternalConsumerSeq;
    protected Nullable`1<long> TargetSid;
    public PullOrderedMessageManager(Connection conn, JetStream js, string stream, SubscribeOptions so, ConsumerConfiguration originalCc, bool syncMode);
    public virtual void Startup(IJetStreamSubscription sub);
    public virtual ManageResult Manage(Msg msg);
}
public class NATS.Client.JetStream.PullRequestOptions : JsonSerializable {
    [CompilerGeneratedAttribute]
private int <BatchSize>k__BackingField;
    [CompilerGeneratedAttribute]
private long <MaxBytes>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <NoWait>k__BackingField;
    [CompilerGeneratedAttribute]
private Duration <ExpiresIn>k__BackingField;
    [CompilerGeneratedAttribute]
private Duration <IdleHeartbeat>k__BackingField;
    public int BatchSize { get; }
    public long MaxBytes { get; }
    public bool NoWait { get; }
    public Duration ExpiresIn { get; }
    public Duration IdleHeartbeat { get; }
    protected PullRequestOptions(PullRequestOptionsBuilder pro);
    [CompilerGeneratedAttribute]
public int get_BatchSize();
    [CompilerGeneratedAttribute]
public long get_MaxBytes();
    [CompilerGeneratedAttribute]
public bool get_NoWait();
    [CompilerGeneratedAttribute]
public Duration get_ExpiresIn();
    [CompilerGeneratedAttribute]
public Duration get_IdleHeartbeat();
    public virtual JSONNode ToJsonNode();
    public static PullRequestOptionsBuilder Builder(int batchSize);
}
public class NATS.Client.JetStream.PullSubscribeOptions : SubscribeOptions {
    public static PullSubscribeOptions DefaultPullOpts;
    private PullSubscribeOptions(ISubscribeOptionsBuilder builder);
    private static PullSubscribeOptions();
    public static PullSubscribeOptions BindTo(string stream, string name);
    public static PullSubscribeOptions FastBindTo(string stream, string name);
    public static PullSubscribeOptionsBuilder Builder();
}
public class NATS.Client.JetStream.PurgeOptions : JsonSerializable {
    [CompilerGeneratedAttribute]
private string <Subject>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <Sequence>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <Keep>k__BackingField;
    public string Subject { get; }
    public ulong Sequence { get; }
    public ulong Keep { get; }
    private PurgeOptions(string subject, ulong sequence, ulong keep);
    [CompilerGeneratedAttribute]
public string get_Subject();
    [CompilerGeneratedAttribute]
public ulong get_Sequence();
    [CompilerGeneratedAttribute]
public ulong get_Keep();
    public virtual JSONNode ToJsonNode();
    public static PurgeOptionsBuilder Builder();
    public static PurgeOptions WithSubject(string subject);
}
public class NATS.Client.JetStream.PurgeResponse : ApiResponse {
    [CompilerGeneratedAttribute]
private bool <Success>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <Purged>k__BackingField;
    public bool Success { get; private set; }
    public ulong Purged { get; private set; }
    internal PurgeResponse(Msg msg, bool throwOnError);
    internal PurgeResponse(string json, bool throwOnError);
    [CompilerGeneratedAttribute]
public bool get_Success();
    [CompilerGeneratedAttribute]
private void set_Success(bool value);
    [CompilerGeneratedAttribute]
public ulong get_Purged();
    [CompilerGeneratedAttribute]
private void set_Purged(ulong value);
    private void Init();
}
public class NATS.Client.JetStream.PushMessageManager : MessageManager {
    protected JetStream Js;
    protected string Stream;
    protected ConsumerConfiguration OriginalCc;
    protected bool QueueMode;
    protected bool Fc;
    protected string LastFcSubject;
    public PushMessageManager(Connection conn, JetStream js, string stream, SubscribeOptions so, ConsumerConfiguration originalCc, bool queueMode, bool syncMode);
    public virtual void Startup(IJetStreamSubscription sub);
    protected virtual bool BeforeChannelAddCheck(Msg msg);
    protected bool hasFcSubject(Msg msg);
    protected string extractFcSubject(Msg msg);
    public virtual ManageResult Manage(Msg msg);
    protected ManageResult ManageStatus(Msg msg);
    private void _processFlowControl(string fcSubject, FlowControlSource source);
}
public class NATS.Client.JetStream.PushSubscribeOptions : SubscribeOptions {
    public static PushSubscribeOptions DefaultPushOpts;
    private PushSubscribeOptions(ISubscribeOptionsBuilder builder, string deliverSubject, string deliverGroup, long pendingMessageLimit, long pendingByteLimit);
    private static PushSubscribeOptions();
    public static PushSubscribeOptions ForStream(string stream);
    public static PushSubscribeOptions BindTo(string stream, string durable);
    public static PushSubscribeOptionsBuilder Builder();
}
public enum NATS.Client.JetStream.ReplayPolicy : Enum {
    public int value__;
    public static ReplayPolicy Instant;
    public static ReplayPolicy Original;
}
public class NATS.Client.JetStream.Replica : PeerInfo {
    internal Replica(JSONNode replicaNode);
    internal static List`1<Replica> OptionalListOf(JSONNode replicaListNode);
}
public class NATS.Client.JetStream.Republish : JsonSerializable {
    [CompilerGeneratedAttribute]
private string <Source>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Destination>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HeadersOnly>k__BackingField;
    public string Source { get; }
    public string Destination { get; }
    public bool HeadersOnly { get; }
    private Republish(JSONNode republishNode);
    public Republish(string source, string destination, bool headersOnly);
    [CompilerGeneratedAttribute]
public string get_Source();
    [CompilerGeneratedAttribute]
public string get_Destination();
    [CompilerGeneratedAttribute]
public bool get_HeadersOnly();
    internal static Republish OptionalInstance(JSONNode republishNode);
    public virtual JSONNode ToJsonNode();
    public static RepublishBuilder Builder();
}
public enum NATS.Client.JetStream.RetentionPolicy : Enum {
    public int value__;
    public static RetentionPolicy Limits;
    public static RetentionPolicy Interest;
    public static RetentionPolicy WorkQueue;
}
public class NATS.Client.JetStream.SequenceInfo : SequencePair {
    [CompilerGeneratedAttribute]
private DateTime <LastActive>k__BackingField;
    public DateTime LastActive { get; }
    internal SequenceInfo(JSONNode spNode);
    [CompilerGeneratedAttribute]
public DateTime get_LastActive();
    public virtual string ToString();
}
public class NATS.Client.JetStream.SequencePair : object {
    [CompilerGeneratedAttribute]
private ulong <ConsumerSeq>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <StreamSeq>k__BackingField;
    public ulong ConsumerSeq { get; }
    public ulong StreamSeq { get; }
    internal SequencePair(JSONNode spNode);
    [CompilerGeneratedAttribute]
public ulong get_ConsumerSeq();
    [CompilerGeneratedAttribute]
public ulong get_StreamSeq();
    public virtual string ToString();
}
public class NATS.Client.JetStream.ServerInfo : object {
    private string sourceJson;
    [CompilerGeneratedAttribute]
private string <ServerId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ServerName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private string <GoVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Host>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Port>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HeadersSupported>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AuthRequired>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <TlsRequired>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <TlsAvailable>k__BackingField;
    [CompilerGeneratedAttribute]
private long <MaxPayload>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <ConnectURLs>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ProtocolVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Nonce>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <LameDuckMode>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <JetStreamAvailable>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ClientId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ClientIp>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Cluster>k__BackingField;
    public string ServerId { get; }
    public string ServerName { get; }
    public string Version { get; }
    public string GoVersion { get; }
    public string Host { get; }
    public int Port { get; }
    public bool HeadersSupported { get; }
    public bool AuthRequired { get; }
    public bool TlsRequired { get; }
    public bool TlsAvailable { get; }
    public long MaxPayload { get; }
    public String[] ConnectURLs { get; }
    public int ProtocolVersion { get; }
    public string Nonce { get; }
    public bool LameDuckMode { get; }
    public bool JetStreamAvailable { get; }
    public int ClientId { get; }
    public string ClientIp { get; }
    public string Cluster { get; }
    public ServerInfo(Msg msg);
    public ServerInfo(string json);
    [CompilerGeneratedAttribute]
public string get_ServerId();
    [CompilerGeneratedAttribute]
public string get_ServerName();
    [CompilerGeneratedAttribute]
public string get_Version();
    [CompilerGeneratedAttribute]
public string get_GoVersion();
    [CompilerGeneratedAttribute]
public string get_Host();
    [CompilerGeneratedAttribute]
public int get_Port();
    [CompilerGeneratedAttribute]
public bool get_HeadersSupported();
    [CompilerGeneratedAttribute]
public bool get_AuthRequired();
    [CompilerGeneratedAttribute]
public bool get_TlsRequired();
    [CompilerGeneratedAttribute]
public bool get_TlsAvailable();
    [CompilerGeneratedAttribute]
public long get_MaxPayload();
    [CompilerGeneratedAttribute]
public String[] get_ConnectURLs();
    [CompilerGeneratedAttribute]
public int get_ProtocolVersion();
    [CompilerGeneratedAttribute]
public string get_Nonce();
    [CompilerGeneratedAttribute]
public bool get_LameDuckMode();
    [CompilerGeneratedAttribute]
public bool get_JetStreamAvailable();
    [CompilerGeneratedAttribute]
public int get_ClientId();
    [CompilerGeneratedAttribute]
public string get_ClientIp();
    [CompilerGeneratedAttribute]
public string get_Cluster();
    public bool IsNewerVersionThan(string vTarget);
    public bool IsSameVersion(string vTarget);
    public bool IsOlderThanVersion(string vTarget);
    public bool IsSameOrOlderThanVersion(string vTarget);
    public bool IsSameOrNewerThanVersion(string vTarget);
    public virtual string ToString();
}
internal interface NATS.Client.JetStream.SimplifiedSubscriptionMaker {
    public abstract virtual IJetStreamSubscription Subscribe(EventHandler`1<MsgHandlerEventArgs> handler, PullMessageManager optionalPmm, Nullable`1<long> optionalInactiveThreshold);
}
public class NATS.Client.JetStream.Source : SourceBase {
    public Source(string name, ulong startSeq, DateTime startTime, string filterSubject, External external, IList`1<SubjectTransform> subjectTransforms);
    internal Source(JSONNode sourceBaseNode);
    internal Source(SourceBuilder sb);
    internal static List`1<Source> OptionalListOf(JSONNode sourceListNode);
    public static SourceBuilder Builder();
    public static SourceBuilder Builder(Source source);
}
public class NATS.Client.JetStream.SourceBase : JsonSerializable {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <StartSeq>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <StartTime>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FilterSubject>k__BackingField;
    [CompilerGeneratedAttribute]
private External <External>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<SubjectTransform> <SubjectTransforms>k__BackingField;
    public string Name { get; }
    public ulong StartSeq { get; }
    public DateTime StartTime { get; }
    public string FilterSubject { get; }
    public External External { get; }
    public IList`1<SubjectTransform> SubjectTransforms { get; }
    internal SourceBase(JSONNode sourceBaseNode);
    protected SourceBase(string name, ulong startSeq, DateTime startTime, string filterSubject, External external, IList`1<SubjectTransform> subjectTransforms);
    protected SourceBase(ISourceBaseBuilder isbb);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public ulong get_StartSeq();
    [CompilerGeneratedAttribute]
public DateTime get_StartTime();
    [CompilerGeneratedAttribute]
public string get_FilterSubject();
    [CompilerGeneratedAttribute]
public External get_External();
    [CompilerGeneratedAttribute]
public IList`1<SubjectTransform> get_SubjectTransforms();
    public virtual JSONNode ToJsonNode();
    protected bool Equals(SourceBase other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class NATS.Client.JetStream.SourceInfo : SourceInfoBase {
    private SourceInfo(JSONNode sourceInfo);
    internal static List`1<SourceInfo> OptionalListOf(JSONNode sourceInfoListNode);
}
public abstract class NATS.Client.JetStream.SourceInfoBase : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <Lag>k__BackingField;
    [CompilerGeneratedAttribute]
private Duration <Active>k__BackingField;
    [CompilerGeneratedAttribute]
private External <External>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<SubjectTransform> <SubjectTransforms>k__BackingField;
    [CompilerGeneratedAttribute]
private Error <Error>k__BackingField;
    public string Name { get; }
    public ulong Lag { get; }
    public Duration Active { get; }
    public External External { get; }
    public IList`1<SubjectTransform> SubjectTransforms { get; }
    public Error Error { get; }
    internal SourceInfoBase(JSONNode sourceInfoBaseNode);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public ulong get_Lag();
    [CompilerGeneratedAttribute]
public Duration get_Active();
    [CompilerGeneratedAttribute]
public External get_External();
    [CompilerGeneratedAttribute]
public IList`1<SubjectTransform> get_SubjectTransforms();
    [CompilerGeneratedAttribute]
public Error get_Error();
}
public enum NATS.Client.JetStream.StorageType : Enum {
    public int value__;
    public static StorageType File;
    public static StorageType Memory;
}
public class NATS.Client.JetStream.StreamConfiguration : JsonSerializable {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <Subjects>k__BackingField;
    [CompilerGeneratedAttribute]
private RetentionPolicy <RetentionPolicy>k__BackingField;
    [CompilerGeneratedAttribute]
private CompressionOption <CompressionOption>k__BackingField;
    [CompilerGeneratedAttribute]
private long <MaxConsumers>k__BackingField;
    [CompilerGeneratedAttribute]
private long <MaxMsgs>k__BackingField;
    [CompilerGeneratedAttribute]
private long <MaxMsgsPerSubject>k__BackingField;
    [CompilerGeneratedAttribute]
private long <MaxBytes>k__BackingField;
    [CompilerGeneratedAttribute]
private Duration <MaxAge>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaximumMessageSize>k__BackingField;
    [CompilerGeneratedAttribute]
private StorageType <StorageType>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Replicas>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <NoAck>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TemplateOwner>k__BackingField;
    [CompilerGeneratedAttribute]
private DiscardPolicy <DiscardPolicy>k__BackingField;
    [CompilerGeneratedAttribute]
private Duration <DuplicateWindow>k__BackingField;
    [CompilerGeneratedAttribute]
private Placement <Placement>k__BackingField;
    [CompilerGeneratedAttribute]
private Republish <Republish>k__BackingField;
    [CompilerGeneratedAttribute]
private SubjectTransform <SubjectTransform>k__BackingField;
    [CompilerGeneratedAttribute]
private ConsumerLimits <ConsumerLimits>k__BackingField;
    [CompilerGeneratedAttribute]
private Mirror <Mirror>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<Source> <Sources>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Sealed>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowRollup>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowDirect>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <MirrorDirect>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DenyDelete>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DenyPurge>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DiscardNewPerSubject>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <Metadata>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <FirstSequence>k__BackingField;
    public string Name { get; }
    public string Description { get; }
    public List`1<string> Subjects { get; }
    public RetentionPolicy RetentionPolicy { get; }
    public CompressionOption CompressionOption { get; }
    public long MaxConsumers { get; }
    public long MaxMsgs { get; }
    public long MaxMsgsPerSubject { get; }
    public long MaxBytes { get; }
    public Duration MaxAge { get; }
    public int MaximumMessageSize { get; }
    public StorageType StorageType { get; }
    public int Replicas { get; }
    public bool NoAck { get; }
    public string TemplateOwner { get; }
    public DiscardPolicy DiscardPolicy { get; }
    public Duration DuplicateWindow { get; }
    public Placement Placement { get; }
    public Republish Republish { get; }
    public SubjectTransform SubjectTransform { get; }
    public ConsumerLimits ConsumerLimits { get; }
    public Mirror Mirror { get; }
    public List`1<Source> Sources { get; }
    public bool Sealed { get; }
    public bool AllowRollup { get; }
    public bool AllowDirect { get; }
    public bool MirrorDirect { get; }
    public bool DenyDelete { get; }
    public bool DenyPurge { get; }
    public bool DiscardNewPerSubject { get; }
    public IDictionary`2<string, string> Metadata { get; }
    public ulong FirstSequence { get; private set; }
    [ObsoleteAttribute("The server value is a 32-bit signed value. Use MaximumMessageSize.", "False")]
public long MaxMsgSize { get; }
    [ObsoleteAttribute("MaxMsgSize was mistakenly renamed in a previous change. Use MaximumMessageSize.", "False")]
public long MaxValueSize { get; }
    internal StreamConfiguration(string json);
    internal StreamConfiguration(JSONNode scNode);
    private StreamConfiguration(StreamConfigurationBuilder builder);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public string get_Description();
    [CompilerGeneratedAttribute]
public List`1<string> get_Subjects();
    [CompilerGeneratedAttribute]
public RetentionPolicy get_RetentionPolicy();
    [CompilerGeneratedAttribute]
public CompressionOption get_CompressionOption();
    [CompilerGeneratedAttribute]
public long get_MaxConsumers();
    [CompilerGeneratedAttribute]
public long get_MaxMsgs();
    [CompilerGeneratedAttribute]
public long get_MaxMsgsPerSubject();
    [CompilerGeneratedAttribute]
public long get_MaxBytes();
    [CompilerGeneratedAttribute]
public Duration get_MaxAge();
    [CompilerGeneratedAttribute]
public int get_MaximumMessageSize();
    [CompilerGeneratedAttribute]
public StorageType get_StorageType();
    [CompilerGeneratedAttribute]
public int get_Replicas();
    [CompilerGeneratedAttribute]
public bool get_NoAck();
    [CompilerGeneratedAttribute]
public string get_TemplateOwner();
    [CompilerGeneratedAttribute]
public DiscardPolicy get_DiscardPolicy();
    [CompilerGeneratedAttribute]
public Duration get_DuplicateWindow();
    [CompilerGeneratedAttribute]
public Placement get_Placement();
    [CompilerGeneratedAttribute]
public Republish get_Republish();
    [CompilerGeneratedAttribute]
public SubjectTransform get_SubjectTransform();
    [CompilerGeneratedAttribute]
public ConsumerLimits get_ConsumerLimits();
    [CompilerGeneratedAttribute]
public Mirror get_Mirror();
    [CompilerGeneratedAttribute]
public List`1<Source> get_Sources();
    [CompilerGeneratedAttribute]
public bool get_Sealed();
    [CompilerGeneratedAttribute]
public bool get_AllowRollup();
    [CompilerGeneratedAttribute]
public bool get_AllowDirect();
    [CompilerGeneratedAttribute]
public bool get_MirrorDirect();
    [CompilerGeneratedAttribute]
public bool get_DenyDelete();
    [CompilerGeneratedAttribute]
public bool get_DenyPurge();
    [CompilerGeneratedAttribute]
public bool get_DiscardNewPerSubject();
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_Metadata();
    [CompilerGeneratedAttribute]
public ulong get_FirstSequence();
    [CompilerGeneratedAttribute]
private void set_FirstSequence(ulong value);
    public long get_MaxMsgSize();
    public long get_MaxValueSize();
    public virtual JSONNode ToJsonNode();
    public static StreamConfigurationBuilder Builder();
    public static StreamConfigurationBuilder Builder(StreamConfiguration sc);
}
internal class NATS.Client.JetStream.StreamContext : object {
    internal JetStream js;
    internal JetStreamManagement jsm;
    [CompilerGeneratedAttribute]
private string <StreamName>k__BackingField;
    public string StreamName { get; }
    internal StreamContext(string streamName, JetStream js, IConnection connection, JetStreamOptions jsOptions);
    [CompilerGeneratedAttribute]
public sealed virtual string get_StreamName();
    public sealed virtual StreamInfo GetStreamInfo();
    public sealed virtual StreamInfo GetStreamInfo(StreamInfoOptions options);
    public sealed virtual PurgeResponse Purge();
    public sealed virtual PurgeResponse Purge(PurgeOptions options);
    public sealed virtual IConsumerContext GetConsumerContext(string consumerName);
    public sealed virtual IConsumerContext CreateOrUpdateConsumer(ConsumerConfiguration config);
    public sealed virtual IOrderedConsumerContext CreateOrderedConsumer(OrderedConsumerConfiguration config);
    public sealed virtual bool DeleteConsumer(string consumerName);
    public sealed virtual ConsumerInfo GetConsumerInfo(string consumerName);
    public sealed virtual IList`1<string> GetConsumerNames();
    public sealed virtual IList`1<ConsumerInfo> GetConsumers();
    public sealed virtual MessageInfo GetMessage(ulong seq);
    public sealed virtual MessageInfo GetLastMessage(string subject);
    public sealed virtual MessageInfo GetFirstMessage(string subject);
    public sealed virtual MessageInfo GetNextMessage(ulong seq, string subject);
    public sealed virtual bool DeleteMessage(ulong seq);
    public sealed virtual bool DeleteMessage(ulong seq, bool erase);
}
public class NATS.Client.JetStream.StreamInfo : ApiResponse {
    [CompilerGeneratedAttribute]
private DateTime <Created>k__BackingField;
    [CompilerGeneratedAttribute]
private StreamConfiguration <Config>k__BackingField;
    [CompilerGeneratedAttribute]
private StreamState <State>k__BackingField;
    [CompilerGeneratedAttribute]
private ClusterInfo <ClusterInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private MirrorInfo <MirrorInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<SourceInfo> <SourceInfos>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <Timestamp>k__BackingField;
    public DateTime Created { get; private set; }
    public StreamConfiguration Config { get; private set; }
    public StreamState State { get; private set; }
    public ClusterInfo ClusterInfo { get; private set; }
    public MirrorInfo MirrorInfo { get; private set; }
    public List`1<SourceInfo> SourceInfos { get; private set; }
    public DateTime Timestamp { get; private set; }
    internal StreamInfo(Msg msg, bool throwOnError);
    public StreamInfo(string json, bool throwOnError);
    internal StreamInfo(JSONNode siNode);
    [CompilerGeneratedAttribute]
public DateTime get_Created();
    [CompilerGeneratedAttribute]
private void set_Created(DateTime value);
    [CompilerGeneratedAttribute]
public StreamConfiguration get_Config();
    [CompilerGeneratedAttribute]
private void set_Config(StreamConfiguration value);
    [CompilerGeneratedAttribute]
public StreamState get_State();
    [CompilerGeneratedAttribute]
private void set_State(StreamState value);
    [CompilerGeneratedAttribute]
public ClusterInfo get_ClusterInfo();
    [CompilerGeneratedAttribute]
private void set_ClusterInfo(ClusterInfo value);
    [CompilerGeneratedAttribute]
public MirrorInfo get_MirrorInfo();
    [CompilerGeneratedAttribute]
private void set_MirrorInfo(MirrorInfo value);
    [CompilerGeneratedAttribute]
public List`1<SourceInfo> get_SourceInfos();
    [CompilerGeneratedAttribute]
private void set_SourceInfos(List`1<SourceInfo> value);
    [CompilerGeneratedAttribute]
public DateTime get_Timestamp();
    [CompilerGeneratedAttribute]
private void set_Timestamp(DateTime value);
    private void Init(JSONNode siNode);
    public virtual string ToString();
}
public class NATS.Client.JetStream.StreamInfoOptions : JsonSerializable {
    [CompilerGeneratedAttribute]
private string <SubjectsFilter>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DeletedDetails>k__BackingField;
    public string SubjectsFilter { get; }
    public bool DeletedDetails { get; }
    internal StreamInfoOptions(string subjectsFilter, bool deletedDetails);
    [CompilerGeneratedAttribute]
public string get_SubjectsFilter();
    [CompilerGeneratedAttribute]
public bool get_DeletedDetails();
    public virtual JSONNode ToJsonNode();
    public static StreamInfoOptionsBuilder Builder();
}
internal class NATS.Client.JetStream.StreamInfoReader : object {
    [CompilerGeneratedAttribute]
private StreamInfo <StreamInfo>k__BackingField;
    private ListRequestEngine engine;
    internal StreamInfo StreamInfo { get; private set; }
    [CompilerGeneratedAttribute]
internal StreamInfo get_StreamInfo();
    [CompilerGeneratedAttribute]
private void set_StreamInfo(StreamInfo value);
    internal void Process(Msg msg);
    internal Byte[] NextJson(StreamInfoOptions options);
    internal bool HasMore();
}
internal class NATS.Client.JetStream.StreamListReader : AbstractListReader {
    private List`1<StreamInfo> _streamInfos;
    public List`1<StreamInfo> Streams { get; }
    protected virtual void ProcessItem(JSONNode node);
    public List`1<StreamInfo> get_Streams();
}
internal class NATS.Client.JetStream.StreamNamesReader : StringListReader {
}
public class NATS.Client.JetStream.StreamState : object {
    [CompilerGeneratedAttribute]
private ulong <Messages>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <Bytes>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <FirstSeq>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <LastSeq>k__BackingField;
    [CompilerGeneratedAttribute]
private long <ConsumerCount>k__BackingField;
    [CompilerGeneratedAttribute]
private long <SubjectCount>k__BackingField;
    [CompilerGeneratedAttribute]
private long <DeletedCount>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <FirstTime>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <LastTime>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<Subject> <Subjects>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<ulong> <Deleted>k__BackingField;
    [CompilerGeneratedAttribute]
private LostStreamData <LostStreamData>k__BackingField;
    public ulong Messages { get; }
    public ulong Bytes { get; }
    public ulong FirstSeq { get; }
    public ulong LastSeq { get; }
    public long ConsumerCount { get; }
    public long SubjectCount { get; }
    public long DeletedCount { get; }
    public DateTime FirstTime { get; }
    public DateTime LastTime { get; }
    public IList`1<Subject> Subjects { get; }
    public IList`1<ulong> Deleted { get; }
    public LostStreamData LostStreamData { get; }
    private StreamState(JSONNode streamState);
    [CompilerGeneratedAttribute]
public ulong get_Messages();
    [CompilerGeneratedAttribute]
public ulong get_Bytes();
    [CompilerGeneratedAttribute]
public ulong get_FirstSeq();
    [CompilerGeneratedAttribute]
public ulong get_LastSeq();
    [CompilerGeneratedAttribute]
public long get_ConsumerCount();
    [CompilerGeneratedAttribute]
public long get_SubjectCount();
    [CompilerGeneratedAttribute]
public long get_DeletedCount();
    [CompilerGeneratedAttribute]
public DateTime get_FirstTime();
    [CompilerGeneratedAttribute]
public DateTime get_LastTime();
    [CompilerGeneratedAttribute]
public IList`1<Subject> get_Subjects();
    [CompilerGeneratedAttribute]
public IList`1<ulong> get_Deleted();
    [CompilerGeneratedAttribute]
public LostStreamData get_LostStreamData();
    internal static StreamState OptionalInstance(JSONNode streamState);
    internal void AddAll(IList`1<Subject> optional);
    public virtual string ToString();
}
internal abstract class NATS.Client.JetStream.StringListReader : AbstractListReader {
    private List`1<string> _strings;
    public List`1<string> Strings { get; }
    protected StringListReader(string objectName, string filterFieldName);
    protected virtual void ProcessItem(JSONNode node);
    public List`1<string> get_Strings();
}
public class NATS.Client.JetStream.Subject : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Count>k__BackingField;
    public string Name { get; }
    public long Count { get; }
    public Subject(string name, long count);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public long get_Count();
    internal static IList`1<Subject> GetList(JSONNode subjectsNode);
    public virtual string ToString();
}
public class NATS.Client.JetStream.SubjectTransform : JsonSerializable {
    [CompilerGeneratedAttribute]
private string <Source>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Destination>k__BackingField;
    public string Source { get; }
    public string Destination { get; }
    private SubjectTransform(JSONNode subjectTransformNode);
    public SubjectTransform(string source, string destination);
    [CompilerGeneratedAttribute]
public string get_Source();
    [CompilerGeneratedAttribute]
public string get_Destination();
    internal static SubjectTransform OptionalInstance(JSONNode subjectTransformNode);
    internal static IList`1<SubjectTransform> OptionalListOf(JSONNode subjectTransformListNode);
    public virtual JSONNode ToJsonNode();
    public static SubjectTransformBuilder Builder();
    private bool Equals(SubjectTransform other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public abstract class NATS.Client.JetStream.SubscribeOptions : object {
    public static long DefaultOrderedHeartbeat;
    [CompilerGeneratedAttribute]
private string <Stream>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Pull>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Bind>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <FastBind>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Ordered>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MessageAlarmTime>k__BackingField;
    [CompilerGeneratedAttribute]
private ConsumerConfiguration <ConsumerConfiguration>k__BackingField;
    [CompilerGeneratedAttribute]
private long <PendingMessageLimit>k__BackingField;
    [CompilerGeneratedAttribute]
private long <PendingByteLimit>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public string Stream { get; }
    public bool Pull { get; }
    public bool Bind { get; }
    public bool FastBind { get; }
    public bool Ordered { get; }
    internal int MessageAlarmTime { get; }
    public ConsumerConfiguration ConsumerConfiguration { get; }
    public long PendingMessageLimit { get; }
    public long PendingByteLimit { get; }
    public string Name { get; }
    public string Durable { get; }
    public string DeliverSubject { get; }
    public string DeliverGroup { get; }
    protected SubscribeOptions(ISubscribeOptionsBuilder builder, bool pull, string deliverSubject, string deliverGroup, long pendingMessageLimit, long pendingByteLimit);
    [CompilerGeneratedAttribute]
public string get_Stream();
    [CompilerGeneratedAttribute]
public bool get_Pull();
    [CompilerGeneratedAttribute]
public bool get_Bind();
    [CompilerGeneratedAttribute]
public bool get_FastBind();
    [CompilerGeneratedAttribute]
public bool get_Ordered();
    [CompilerGeneratedAttribute]
internal int get_MessageAlarmTime();
    [CompilerGeneratedAttribute]
public ConsumerConfiguration get_ConsumerConfiguration();
    [CompilerGeneratedAttribute]
public long get_PendingMessageLimit();
    [CompilerGeneratedAttribute]
public long get_PendingByteLimit();
    [CompilerGeneratedAttribute]
public string get_Name();
    public string get_Durable();
    public string get_DeliverSubject();
    public string get_DeliverGroup();
    public virtual string ToString();
}
public class NATS.Client.JetStream.SuccessApiResponse : ApiResponse {
    [CompilerGeneratedAttribute]
private bool <Success>k__BackingField;
    public bool Success { get; }
    internal SuccessApiResponse(Msg msg, bool throwOnError);
    internal SuccessApiResponse(string json, bool throwOnError);
    [CompilerGeneratedAttribute]
public bool get_Success();
}
public class NATS.Client.JWTHandlerUtils : object {
    public static string LoadUser(string text);
    public static NkeyPair LoadNkeyPair(string nkeySeed);
}
internal class NATS.Client.KeyValue.BucketAndKey : object {
    [CompilerGeneratedAttribute]
private string <Bucket>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Key>k__BackingField;
    public string Bucket { get; }
    public string Key { get; }
    public BucketAndKey(Msg m);
    public BucketAndKey(string subject);
    [CompilerGeneratedAttribute]
public string get_Bucket();
    [CompilerGeneratedAttribute]
public string get_Key();
    public bool Equals(BucketAndKey other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public interface NATS.Client.KeyValue.IKeyValue {
    public string BucketName { get; }
    public abstract virtual string get_BucketName();
    public abstract virtual KeyValueEntry Get(string key);
    public abstract virtual KeyValueEntry Get(string key, ulong revision);
    public abstract virtual ulong Put(string key, Byte[] value);
    public abstract virtual ulong Put(string key, string value);
    public abstract virtual ulong Put(string key, long value);
    public abstract virtual ulong Create(string key, Byte[] value);
    public abstract virtual ulong Update(string key, Byte[] value, ulong expectedRevision);
    public abstract virtual void Delete(string key);
    public abstract virtual void Delete(string key, ulong expectedRevision);
    public abstract virtual void Purge(string key);
    public abstract virtual void Purge(string key, ulong expectedRevision);
    public abstract virtual KeyValueWatchSubscription Watch(string key, IKeyValueWatcher watcher, KeyValueWatchOption[] watchOptions);
    public abstract virtual KeyValueWatchSubscription Watch(string key, IKeyValueWatcher watcher, ulong fromRevision, KeyValueWatchOption[] watchOptions);
    public abstract virtual KeyValueWatchSubscription Watch(IList`1<string> keys, IKeyValueWatcher watcher, KeyValueWatchOption[] watchOptions);
    public abstract virtual KeyValueWatchSubscription Watch(IList`1<string> keys, IKeyValueWatcher watcher, ulong fromRevision, KeyValueWatchOption[] watchOptions);
    public abstract virtual KeyValueWatchSubscription WatchAll(IKeyValueWatcher watcher, KeyValueWatchOption[] watchOptions);
    public abstract virtual KeyValueWatchSubscription WatchAll(IKeyValueWatcher watcher, ulong fromRevision, KeyValueWatchOption[] watchOptions);
    public abstract virtual IList`1<string> Keys();
    public abstract virtual IList`1<string> Keys(string filter);
    public abstract virtual IList`1<string> Keys(IList`1<string> filters);
    public abstract virtual IList`1<KeyValueEntry> History(string key);
    public abstract virtual void PurgeDeletes();
    public abstract virtual void PurgeDeletes(KeyValuePurgeOptions options);
    public abstract virtual KeyValueStatus Status();
}
public interface NATS.Client.KeyValue.IKeyValueManagement {
    public abstract virtual KeyValueStatus Create(KeyValueConfiguration config);
    public abstract virtual KeyValueStatus Update(KeyValueConfiguration config);
    public abstract virtual IList`1<string> GetBucketNames();
    [ObsoleteAttribute("This method will soon be deprecated. Use GetStatus instead.")]
public abstract virtual KeyValueStatus GetBucketInfo(string bucketName);
    public abstract virtual KeyValueStatus GetStatus(string bucketName);
    public abstract virtual IList`1<KeyValueStatus> GetStatuses();
    public abstract virtual void Delete(string bucketName);
}
public interface NATS.Client.KeyValue.IKeyValueWatcher {
    public abstract virtual void Watch(KeyValueEntry kve);
    public abstract virtual void EndOfData();
}
public class NATS.Client.KeyValue.KeyValue : FeatureBase {
    [CompilerGeneratedAttribute]
private string <StreamSubject>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ReadPrefix>k__BackingField;
    [CompilerGeneratedAttribute]
private string <WritePrefix>k__BackingField;
    [CompilerGeneratedAttribute]
private string <BucketName>k__BackingField;
    internal string StreamSubject { get; }
    internal string ReadPrefix { get; }
    internal string WritePrefix { get; }
    public string BucketName { get; }
    internal KeyValue(IConnection connection, string bucketName, KeyValueOptions kvo);
    [CompilerGeneratedAttribute]
internal string get_StreamSubject();
    [CompilerGeneratedAttribute]
internal string get_ReadPrefix();
    [CompilerGeneratedAttribute]
internal string get_WritePrefix();
    [CompilerGeneratedAttribute]
public sealed virtual string get_BucketName();
    internal string ReadSubject(string key);
    internal string WriteSubject(string key);
    public sealed virtual KeyValueEntry Get(string key);
    public sealed virtual KeyValueEntry Get(string key, ulong revision);
    private KeyValueEntry existingOnly(KeyValueEntry kve);
    private KeyValueEntry _get(string key);
    private KeyValueEntry _getBySeq(string key, ulong revision);
    public sealed virtual ulong Put(string key, Byte[] value);
    public sealed virtual ulong Put(string key, string value);
    public sealed virtual ulong Put(string key, long value);
    public sealed virtual ulong Create(string key, Byte[] value);
    public sealed virtual ulong Update(string key, Byte[] value, ulong expectedRevision);
    public sealed virtual void Delete(string key);
    public sealed virtual void Delete(string key, ulong expectedRevision);
    public sealed virtual void Purge(string key);
    public sealed virtual void Purge(string key, ulong expectedRevision);
    public sealed virtual KeyValueWatchSubscription Watch(string key, IKeyValueWatcher watcher, KeyValueWatchOption[] watchOptions);
    public sealed virtual KeyValueWatchSubscription Watch(string key, IKeyValueWatcher watcher, ulong fromRevision, KeyValueWatchOption[] watchOptions);
    public sealed virtual KeyValueWatchSubscription Watch(IList`1<string> keys, IKeyValueWatcher watcher, KeyValueWatchOption[] watchOptions);
    public sealed virtual KeyValueWatchSubscription Watch(IList`1<string> keys, IKeyValueWatcher watcher, ulong fromRevision, KeyValueWatchOption[] watchOptions);
    public sealed virtual KeyValueWatchSubscription WatchAll(IKeyValueWatcher watcher, KeyValueWatchOption[] watchOptions);
    public sealed virtual KeyValueWatchSubscription WatchAll(IKeyValueWatcher watcher, ulong fromRevision, KeyValueWatchOption[] watchOptions);
    private PublishAck _write(string key, Byte[] data, MsgHeader h);
    public sealed virtual IList`1<string> Keys();
    public sealed virtual IList`1<string> Keys(string filter);
    public sealed virtual IList`1<string> Keys(IList`1<string> filters);
    internal IList`1<string> _keys(IList`1<string> readSubjectFilters);
    public sealed virtual IList`1<KeyValueEntry> History(string key);
    public sealed virtual void PurgeDeletes();
    public sealed virtual void PurgeDeletes(KeyValuePurgeOptions options);
    public sealed virtual KeyValueStatus Status();
}
public class NATS.Client.KeyValue.KeyValueConfiguration : object {
    internal static CompressionOption JsCompressionYes;
    internal static CompressionOption JsCompressionNo;
    [CompilerGeneratedAttribute]
private StreamConfiguration <BackingConfig>k__BackingField;
    [CompilerGeneratedAttribute]
private string <BucketName>k__BackingField;
    internal StreamConfiguration BackingConfig { get; }
    public string BucketName { get; }
    public string Description { get; }
    public long MaxHistoryPerKey { get; }
    public long MaxBucketSize { get; }
    [ObsoleteAttribute("The server value is a 32-bit signed value. Use MaximumValueSize.", "False")]
public long MaxValueSize { get; }
    public int MaximumValueSize { get; }
    public Duration Ttl { get; }
    public StorageType StorageType { get; }
    public int Replicas { get; }
    public Placement Placement { get; }
    public Republish Republish { get; }
    public bool AllowDirect { get; }
    public bool IsCompressed { get; }
    public IDictionary`2<string, string> Metadata { get; }
    internal KeyValueConfiguration(StreamConfiguration sc);
    private static KeyValueConfiguration();
    [CompilerGeneratedAttribute]
internal StreamConfiguration get_BackingConfig();
    [CompilerGeneratedAttribute]
public string get_BucketName();
    internal static KeyValueConfiguration Instance(string json);
    public string get_Description();
    public long get_MaxHistoryPerKey();
    public long get_MaxBucketSize();
    public long get_MaxValueSize();
    public int get_MaximumValueSize();
    public Duration get_Ttl();
    public StorageType get_StorageType();
    public int get_Replicas();
    public Placement get_Placement();
    public Republish get_Republish();
    public bool get_AllowDirect();
    public bool get_IsCompressed();
    public IDictionary`2<string, string> get_Metadata();
    public static KeyValueConfigurationBuilder Builder();
    public static KeyValueConfigurationBuilder Builder(string name);
    public static KeyValueConfigurationBuilder Builder(KeyValueConfiguration kvc);
    public virtual string ToString();
}
public class NATS.Client.KeyValue.KeyValueEntry : object {
    private BucketAndKey bucketAndKey;
    [CompilerGeneratedAttribute]
private Byte[] <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <Created>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <Revision>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <Delta>k__BackingField;
    [CompilerGeneratedAttribute]
private KeyValueOperation <Operation>k__BackingField;
    [CompilerGeneratedAttribute]
private long <DataLength>k__BackingField;
    public Byte[] Value { get; }
    public DateTime Created { get; }
    public ulong Revision { get; }
    public ulong Delta { get; }
    public KeyValueOperation Operation { get; }
    public long DataLength { get; }
    public string Bucket { get; }
    public string Key { get; }
    public KeyValueEntry(MessageInfo mi);
    public KeyValueEntry(Msg m);
    [CompilerGeneratedAttribute]
public Byte[] get_Value();
    [CompilerGeneratedAttribute]
public DateTime get_Created();
    [CompilerGeneratedAttribute]
public ulong get_Revision();
    [CompilerGeneratedAttribute]
public ulong get_Delta();
    [CompilerGeneratedAttribute]
public KeyValueOperation get_Operation();
    [CompilerGeneratedAttribute]
public long get_DataLength();
    public string get_Bucket();
    public string get_Key();
    public string ValueAsString();
    public bool TryGetLongValue(Int64& lvalue);
    private static Byte[] ExtractValue(Byte[] data);
    private static long CalculateLength(Byte[] value, MsgHeader h);
    public virtual string ToString();
    public bool Equals(KeyValueEntry other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class NATS.Client.KeyValue.KeyValueManagement : object {
    private JetStreamManagement jsm;
    internal KeyValueManagement(IConnection connection, KeyValueOptions kvo);
    public sealed virtual KeyValueStatus Create(KeyValueConfiguration config);
    public sealed virtual KeyValueStatus Update(KeyValueConfiguration config);
    public sealed virtual IList`1<string> GetBucketNames();
    public sealed virtual KeyValueStatus GetBucketInfo(string bucketName);
    public sealed virtual KeyValueStatus GetStatus(string bucketName);
    public sealed virtual IList`1<KeyValueStatus> GetStatuses();
    public sealed virtual void Delete(string bucketName);
}
public class NATS.Client.KeyValue.KeyValueOperation : object {
    private byte _id;
    [CompilerGeneratedAttribute]
private string <HeaderValue>k__BackingField;
    public static KeyValueOperation Put;
    public static KeyValueOperation Delete;
    public static KeyValueOperation Purge;
    public string HeaderValue { get; }
    private KeyValueOperation(byte id, string headerValue);
    private static KeyValueOperation();
    [CompilerGeneratedAttribute]
public string get_HeaderValue();
    public static KeyValueOperation GetOrDefault(string s, KeyValueOperation dflt);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public bool Equals(KeyValueOperation other);
    public virtual string ToString();
}
public class NATS.Client.KeyValue.KeyValueOptions : FeatureOptions {
    private KeyValueOptions(JetStreamOptions jso);
    public static KeyValueOptionsBuilder Builder();
    public static KeyValueOptionsBuilder Builder(KeyValueOptions kvo);
    public static KeyValueOptionsBuilder Builder(JetStreamOptions jso);
}
public class NATS.Client.KeyValue.KeyValuePurgeOptions : object {
    public static long DefaultThresholdMillis;
    [CompilerGeneratedAttribute]
private long <DeleteMarkersThresholdMillis>k__BackingField;
    public long DeleteMarkersThresholdMillis { get; }
    private KeyValuePurgeOptions(long deleteMarkersThresholdMillis);
    private static KeyValuePurgeOptions();
    [CompilerGeneratedAttribute]
public long get_DeleteMarkersThresholdMillis();
    public static KeyValuePurgeOptionsBuilder Builder();
}
public class NATS.Client.KeyValue.KeyValueStatus : object {
    [CompilerGeneratedAttribute]
private StreamInfo <BackingStreamInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private KeyValueConfiguration <Config>k__BackingField;
    public StreamInfo BackingStreamInfo { get; }
    public KeyValueConfiguration Config { get; }
    public string BucketName { get; }
    public string Description { get; }
    public ulong EntryCount { get; }
    public ulong Bytes { get; }
    public long MaxHistoryPerKey { get; }
    public long MaxBucketSize { get; }
    [ObsoleteAttribute("The server value is a 32-bit signed value. Use MaximumValueSize.", "False")]
public long MaxValueSize { get; }
    public long MaximumValueSize { get; }
    public Duration Ttl { get; }
    public StorageType StorageType { get; }
    public int Replicas { get; }
    public Placement Placement { get; }
    public Republish Republish { get; }
    public bool IsCompressed { get; }
    public IDictionary`2<string, string> Metadata { get; }
    public string BackingStore { get; }
    public KeyValueStatus(StreamInfo si);
    [CompilerGeneratedAttribute]
public StreamInfo get_BackingStreamInfo();
    [CompilerGeneratedAttribute]
public KeyValueConfiguration get_Config();
    public string get_BucketName();
    public string get_Description();
    public ulong get_EntryCount();
    public ulong get_Bytes();
    public long get_MaxHistoryPerKey();
    public long get_MaxBucketSize();
    public long get_MaxValueSize();
    public long get_MaximumValueSize();
    public Duration get_Ttl();
    public StorageType get_StorageType();
    public int get_Replicas();
    public Placement get_Placement();
    public Republish get_Republish();
    public bool get_IsCompressed();
    public IDictionary`2<string, string> get_Metadata();
    public string get_BackingStore();
    public virtual string ToString();
}
public static class NATS.Client.KeyValue.KeyValueUtil : object {
    internal static string KvStreamPrefix;
    internal static int KvStreamPrefixLen;
    internal static string KvSubjectPrefix;
    internal static string KvSubjectSuffix;
    internal static string KvOperationHeaderKey;
    public static MsgHeader PurgeHeaders;
    public static MsgHeader DeleteHeaders { get; }
    private static KeyValueUtil();
    public static MsgHeader get_DeleteHeaders();
    public static string ExtractBucketName(string streamName);
    public static string ToStreamName(string bucketName);
    public static string ToStreamSubject(string bucketName);
    public static string ToKeyPrefix(string bucketName);
    public static bool HasPrefix(string bucketName);
    public static string TrimPrefix(string bucketName);
    public static string GetOperationHeader(MsgHeader h);
    public static KeyValueOperation GetOperation(MsgHeader h, KeyValueOperation dflt);
}
public enum NATS.Client.KeyValue.KeyValueWatchOption : Enum {
    public int value__;
    public static KeyValueWatchOption IgnoreDelete;
    public static KeyValueWatchOption MetaOnly;
    public static KeyValueWatchOption IncludeHistory;
    public static KeyValueWatchOption UpdatesOnly;
}
public class NATS.Client.KeyValue.KeyValueWatchSubscription : object {
    private IJetStreamPushAsyncSubscription sub;
    private InterlockedBoolean endOfDataSent;
    private object subLock;
    public KeyValueWatchSubscription(KeyValue kv, IList`1<string> keyPatterns, IKeyValueWatcher watcher, ulong fromRevision, KeyValueWatchOption[] watchOptions);
    public void Unsubscribe();
    public sealed virtual void Dispose();
}
public class NATS.Client.Msg : object {
    protected static Byte[] Empty;
    protected string subject;
    protected long sid;
    protected string _reply;
    protected Byte[] data;
    internal Subscription sub;
    internal MsgHeader header;
    internal int headerLen;
    internal MsgStatus status;
    protected AckType _lastAck;
    public string Subject { get; public set; }
    internal long Sid { get; }
    public string Reply { get; public set; }
    public Byte[] Data { get; public set; }
    [ObsoleteAttribute("This property will soon be deprecated. Use ArrivalSubscription instead.")]
public ISubscription ArrivalSubcription { get; }
    public ISubscription ArrivalSubscription { get; }
    public MsgHeader Header { get; public set; }
    public bool HasHeaders { get; }
    public MsgStatus Status { get; }
    public bool HasStatus { get; }
    public MetaData MetaData { get; }
    public AckType LastAck { get; }
    public bool IsJetStream { get; }
    public long ConsumeByteCount { get; }
    public Msg(string subject, string reply, MsgHeader header, Byte[] data);
    public Msg(string subject, MsgHeader header, Byte[] data);
    public Msg(string subject, string reply, Byte[] data);
    public Msg(string subject, Byte[] data);
    public Msg(string subject);
    protected internal Msg(Msg msg);
    internal Msg(MsgArg arg, Subscription s, Byte[] payload, long totalLen);
    private static Msg();
    public string get_Subject();
    public void set_Subject(string value);
    internal long get_Sid();
    public string get_Reply();
    public void set_Reply(string value);
    public Byte[] get_Data();
    public void set_Data(Byte[] value);
    public void AssignData(Byte[] data);
    public ISubscription get_ArrivalSubcription();
    public ISubscription get_ArrivalSubscription();
    public void Respond(Byte[] data);
    public virtual string ToString();
    public MsgHeader get_Header();
    public void set_Header(MsgHeader value);
    public bool get_HasHeaders();
    public MsgStatus get_Status();
    public bool get_HasStatus();
    public virtual MetaData get_MetaData();
    public AckType get_LastAck();
    public virtual void Ack();
    public virtual void AckSync(int timeout);
    public virtual void Nak();
    public virtual void NakWithDelay(Duration nakDelay);
    public virtual void NakWithDelay(long nakDelayMillis);
    public virtual void Term();
    public virtual void InProgress();
    public virtual bool get_IsJetStream();
    public long get_ConsumeByteCount();
}
internal class NATS.Client.MsgArg : object {
    internal string subject;
    internal string reply;
    internal long sid;
    internal int hdr;
    internal int size;
}
public class NATS.Client.MsgHandlerEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private Msg <Message>k__BackingField;
    public Msg Message { get; }
    public MsgHandlerEventArgs(Msg message);
    [CompilerGeneratedAttribute]
public Msg get_Message();
}
[DefaultMemberAttribute("Item")]
public class NATS.Client.MsgHeader : object {
    public static string Status;
    public static string Description;
    private Byte[] bytes;
    private NameValueCollection nvc;
    public IEnumerable Keys { get; }
    public int Count { get; }
    public string Item { get; public set; }
    public MsgHeader(MsgHeader header);
    private void CheckKeyValue(string key, string value);
    public IEnumerable get_Keys();
    public int get_Count();
    public string get_Item(string name);
    public void set_Item(string name, string value);
    public void Add(string name, string value);
    public void Set(string name, string value);
    public void Remove(string name);
    public void Clear();
    private string ToHeaderString();
    internal Byte[] ToByteArray();
    public String[] GetValues(string name);
    public string GetFirst(string name);
    public string GetLast(string name);
    public sealed virtual IEnumerator GetEnumerator();
    private bool Equals(MsgHeader other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class NATS.Client.MsgStatus : object {
    private static string FlowControlText;
    private static string HeartbeatText;
    private static string NoRespondersText;
    private int _code;
    private string _message;
    public int Code { get; }
    public string Message { get; }
    public MsgStatus(int code, string message);
    public MsgStatus(Token codeToken, Token messageToken);
    public int get_Code();
    public string get_Message();
    private static string ExtractMessage(Token messageToken);
    private static int ExtractCode(Token codeToken);
    private string MakeMessage(int code);
    private bool IsStatus(int code, string text);
    public bool IsFlowControl();
    public bool IsHeartbeat();
    public bool IsNoResponders();
    public virtual string ToString();
}
internal static class NATS.Client.NaCl.CryptoBytes : object {
    public static bool ConstantTimeEquals(Byte[] x, Byte[] y);
    public static bool ConstantTimeEquals(ArraySegment`1<byte> x, ArraySegment`1<byte> y);
    public static bool ConstantTimeEquals(Byte[] x, int xOffset, Byte[] y, int yOffset, int length);
    private static UInt32 InternalConstantTimeEquals(Byte[] x, int xOffset, Byte[] y, int yOffset, int length);
    public static void Wipe(Byte[] data);
    public static void Wipe(Byte[] data, int offset, int length);
    public static void Wipe(ArraySegment`1<byte> data);
    internal static void InternalWipe(Byte[] data, int offset, int count);
    internal static void InternalWipe(T& data);
    public static string ToHexStringUpper(Byte[] data);
    public static string ToHexStringLower(Byte[] data);
    public static Byte[] FromHexString(string hexString);
    public static string ToBase64String(Byte[] data);
    public static Byte[] FromBase64String(string base64String);
}
internal static class NATS.Client.NaCl.Ed25519 : object {
    public static int PublicKeySize;
    public static int SignatureSize;
    public static int PrivateKeySeedSize;
    public static int ExpandedPrivateKeySize;
    public static bool Verify(ArraySegment`1<byte> signature, ArraySegment`1<byte> message, ArraySegment`1<byte> publicKey);
    public static bool Verify(Byte[] signature, Byte[] message, Byte[] publicKey);
    public static void Sign(ArraySegment`1<byte> signature, ArraySegment`1<byte> message, ArraySegment`1<byte> expandedPrivateKey);
    public static Byte[] Sign(Byte[] message, Byte[] expandedPrivateKey);
    public static Byte[] PublicKeyFromSeed(Byte[] privateKeySeed);
    public static Byte[] ExpandedPrivateKeyFromSeed(Byte[] privateKeySeed);
    public static void KeyPairFromSeed(Byte[]& publicKey, Byte[]& expandedPrivateKey, Byte[] privateKeySeed);
    public static void KeyPairFromSeed(ArraySegment`1<byte> publicKey, ArraySegment`1<byte> expandedPrivateKey, ArraySegment`1<byte> privateKeySeed);
}
internal class NATS.Client.NaCl.Internal.Array16`1 : ValueType {
    public T x0;
    public T x1;
    public T x2;
    public T x3;
    public T x4;
    public T x5;
    public T x6;
    public T x7;
    public T x8;
    public T x9;
    public T x10;
    public T x11;
    public T x12;
    public T x13;
    public T x14;
    public T x15;
}
internal class NATS.Client.NaCl.Internal.Array8`1 : ValueType {
    public T x0;
    public T x1;
    public T x2;
    public T x3;
    public T x4;
    public T x5;
    public T x6;
    public T x7;
}
internal static class NATS.Client.NaCl.Internal.ByteIntegerConverter : object {
    public static ulong LoadBigEndian64(Byte[] buf, int offset);
    public static void StoreBigEndian64(Byte[] buf, int offset, ulong value);
    public static void Array16LoadBigEndian64(Array16`1& output, Byte[] input, int inputOffset);
}
internal static class NATS.Client.NaCl.Internal.Ed25519Ref10.Ed25519Operations : object {
    public static void crypto_sign_keypair(Byte[] pk, int pkoffset, Byte[] sk, int skoffset, Byte[] seed, int seedoffset);
    public static bool crypto_sign_verify(Byte[] sig, int sigoffset, Byte[] m, int moffset, int mlen, Byte[] pk, int pkoffset);
    public static void crypto_sign(Byte[] sig, int sigoffset, Byte[] m, int moffset, int mlen, Byte[] sk, int skoffset);
}
internal class NATS.Client.NaCl.Internal.Ed25519Ref10.FieldElement : ValueType {
    internal int x0;
    internal int x1;
    internal int x2;
    internal int x3;
    internal int x4;
    internal int x5;
    internal int x6;
    internal int x7;
    internal int x8;
    internal int x9;
    internal FieldElement(Int32[] elements);
}
internal static class NATS.Client.NaCl.Internal.Ed25519Ref10.FieldOperations : object {
    public static void fe_0(FieldElement& h);
    public static void fe_1(FieldElement& h);
    internal static void fe_add(FieldElement& h, FieldElement& f, FieldElement& g);
    internal static void fe_cmov(FieldElement& f, FieldElement& g, int b);
    public static void fe_cswap(FieldElement& f, FieldElement& g, UInt32 b);
    private static long load_3(Byte[] data, int offset);
    private static long load_4(Byte[] data, int offset);
    internal static void fe_frombytes(FieldElement& h, Byte[] data, int offset);
    internal static void fe_frombytes2(FieldElement& h, Byte[] data, int offset);
    internal static void fe_invert(FieldElement& result, FieldElement& z);
    public static int fe_isnegative(FieldElement& f);
    internal static int fe_isnonzero(FieldElement& f);
    internal static void fe_mul(FieldElement& h, FieldElement& f, FieldElement& g);
    public static void fe_mul121666(FieldElement& h, FieldElement& f);
    internal static void fe_neg(FieldElement& h, FieldElement& f);
    internal static void fe_pow22523(FieldElement& result, FieldElement& z);
    internal static void fe_sq(FieldElement& h, FieldElement& f);
    internal static void fe_sq2(FieldElement& h, FieldElement& f);
    internal static void fe_sub(FieldElement& h, FieldElement& f, FieldElement& g);
    internal static void fe_tobytes(Byte[] s, int offset, FieldElement& h);
    internal static void fe_reduce(FieldElement& hr, FieldElement& h);
}
internal class NATS.Client.NaCl.Internal.Ed25519Ref10.GroupElementCached : ValueType {
    public FieldElement YplusX;
    public FieldElement YminusX;
    public FieldElement Z;
    public FieldElement T2d;
}
internal class NATS.Client.NaCl.Internal.Ed25519Ref10.GroupElementP1P1 : ValueType {
    public FieldElement X;
    public FieldElement Y;
    public FieldElement Z;
    public FieldElement T;
}
internal class NATS.Client.NaCl.Internal.Ed25519Ref10.GroupElementP2 : ValueType {
    public FieldElement X;
    public FieldElement Y;
    public FieldElement Z;
}
internal class NATS.Client.NaCl.Internal.Ed25519Ref10.GroupElementP3 : ValueType {
    public FieldElement X;
    public FieldElement Y;
    public FieldElement Z;
    public FieldElement T;
}
internal class NATS.Client.NaCl.Internal.Ed25519Ref10.GroupElementPreComp : ValueType {
    public FieldElement yplusx;
    public FieldElement yminusx;
    public FieldElement xy2d;
    public GroupElementPreComp(FieldElement yplusx, FieldElement yminusx, FieldElement xy2d);
}
internal static class NATS.Client.NaCl.Internal.Ed25519Ref10.GroupOperations : object {
    internal static void ge_add(GroupElementP1P1& r, GroupElementP3& p, GroupElementCached& q);
    private static void slide(SByte[] r, Byte[] a);
    public static void ge_double_scalarmult_vartime(GroupElementP2& r, Byte[] a, GroupElementP3& A, Byte[] b);
    public static int ge_frombytes_negate_vartime(GroupElementP3& h, Byte[] data, int offset);
    public static void ge_madd(GroupElementP1P1& r, GroupElementP3& p, GroupElementPreComp& q);
    public static void ge_msub(GroupElementP1P1& r, GroupElementP3& p, GroupElementPreComp& q);
    public static void ge_p1p1_to_p2(GroupElementP2& r, GroupElementP1P1& p);
    public static void ge_p1p1_to_p3(GroupElementP3& r, GroupElementP1P1& p);
    public static void ge_p2_0(GroupElementP2& h);
    public static void ge_p2_dbl(GroupElementP1P1& r, GroupElementP2& p);
    public static void ge_p3_0(GroupElementP3& h);
    public static void ge_p3_dbl(GroupElementP1P1& r, GroupElementP3& p);
    public static void ge_p3_tobytes(Byte[] s, int offset, GroupElementP3& h);
    public static void ge_p3_to_cached(GroupElementCached& r, GroupElementP3& p);
    public static void ge_p3_to_p2(GroupElementP2& r, GroupElementP3& p);
    public static void ge_precomp_0(GroupElementPreComp& h);
    private static byte equal(byte b, byte c);
    private static byte negative(sbyte b);
    private static void cmov(GroupElementPreComp& t, GroupElementPreComp& u, byte b);
    private static void select(GroupElementPreComp& t, int pos, sbyte b);
    public static void ge_scalarmult_base(GroupElementP3& h, Byte[] a, int offset);
    public static void ge_sub(GroupElementP1P1& r, GroupElementP3& p, GroupElementCached& q);
    public static void ge_tobytes(Byte[] s, int offset, GroupElementP2& h);
}
internal static class NATS.Client.NaCl.Internal.Ed25519Ref10.LookupTables : object {
    internal static GroupElementPreComp[][] Base;
    internal static GroupElementPreComp[] Base2;
    internal static FieldElement d;
    internal static FieldElement d2;
    internal static FieldElement sqrtm1;
    private static LookupTables();
}
internal static class NATS.Client.NaCl.Internal.Ed25519Ref10.MontgomeryOperations : object {
    public static void scalarmult(Byte[] q, int qoffset, Byte[] n, int noffset, Byte[] p, int poffset);
    internal static void scalarmult(FieldElement& q, Byte[] n, int noffset, FieldElement& p);
}
internal static class NATS.Client.NaCl.Internal.Ed25519Ref10.ScalarOperations : object {
    public static void sc_clamp(Byte[] s, int offset);
    private static long load_3(Byte[] input, int offset);
    private static long load_4(Byte[] input, int offset);
    public static void sc_muladd(Byte[] s, Byte[] a, Byte[] b, Byte[] c);
    public static void sc_reduce(Byte[] s);
}
internal static class NATS.Client.NaCl.Internal.Sha512Internal : object {
    private static UInt64[] K;
    private static Sha512Internal();
    internal static void Sha512Init(Array8`1& state);
    internal static void Core(Array8`1& outputState, Array8`1& inputState, Array16`1& input);
}
internal class NATS.Client.NaCl.Sha512 : object {
    private Array8`1<ulong> _state;
    private Byte[] _buffer;
    private ulong _totalBytes;
    public static int BlockSize;
    private static Byte[] _padding;
    private static Sha512();
    public void Init();
    public void Update(ArraySegment`1<byte> data);
    public void Update(Byte[] data, int index, int length);
    public void Finalize(ArraySegment`1<byte> output);
    public Byte[] Finalize();
    public static Byte[] Hash(Byte[] data);
    public static Byte[] Hash(Byte[] data, int index, int length);
}
public class NATS.Client.NATSBadSubscriptionException : NATSException {
    public NATSBadSubscriptionException(string s);
}
public class NATS.Client.NATSConnectionClosedException : NATSException {
}
public class NATS.Client.NATSConnectionDrainingException : NATSConnectionException {
}
public class NATS.Client.NATSConnectionException : NATSException {
    public NATSConnectionException(string err);
    public NATSConnectionException(string err, Exception innerEx);
}
public class NATS.Client.NATSException : Exception {
    public NATSException(string err);
    public NATSException(string err, Exception innerEx);
    public static bool IsAuthenticationOrAuthorizationError(string message, bool alreadyLowered);
}
public class NATS.Client.NATSInvalidHeaderException : NATSException {
    public NATSInvalidHeaderException(string s);
}
public class NATS.Client.NATSJetStreamClientException : NATSException {
    private ClientExDetail _detail;
    public string Id { get; }
    internal NATSJetStreamClientException(ClientExDetail detail);
    public string get_Id();
}
public class NATS.Client.NATSJetStreamStatusException : NATSException {
    [CompilerGeneratedAttribute]
private Subscription <Sub>k__BackingField;
    [CompilerGeneratedAttribute]
private MsgStatus <Status>k__BackingField;
    public Subscription Sub { get; }
    public MsgStatus Status { get; }
    public NATSJetStreamStatusException(MsgStatus status, Subscription sub);
    [CompilerGeneratedAttribute]
public Subscription get_Sub();
    [CompilerGeneratedAttribute]
public MsgStatus get_Status();
}
public class NATS.Client.NATSMaxMessagesException : NATSException {
}
public class NATS.Client.NATSMaxPayloadException : NATSException {
    public NATSMaxPayloadException(string err);
}
public class NATS.Client.NATSNoRespondersException : NATSTimeoutException {
}
public class NATS.Client.NATSNoServersException : NATSException {
    public NATSNoServersException(string err);
}
public class NATS.Client.NATSNotSupportedException : NATSException {
    public NATSNotSupportedException(string s);
}
public class NATS.Client.NATSProtocolException : NATSException {
    public NATSProtocolException(string err);
}
public class NATS.Client.NATSReconnectBufferException : NATSConnectionException {
    public NATSReconnectBufferException(string err);
}
public class NATS.Client.NATSSecureConnRequiredException : NATSException {
    public NATSSecureConnRequiredException(string s);
}
public class NATS.Client.NATSSecureConnWantedException : NATSException {
}
public class NATS.Client.NATSSlowConsumerException : NATSException {
}
public class NATS.Client.NATSStaleConnectionException : NATSException {
}
public class NATS.Client.NATSTimeoutException : NATSException {
    public NATSTimeoutException(string s);
}
public class NATS.Client.NkeyPair : object {
    private Byte[] seed;
    private Byte[] expandedPrivateKey;
    private Byte[] key;
    [CompilerGeneratedAttribute]
private PrefixType <Type>k__BackingField;
    private bool disposedValue;
    public PrefixType Type { get; }
    public Byte[] PublicKey { get; }
    public string EncodedPublicKey { get; }
    public Byte[] PrivateKeySeed { get; }
    public string EncodedSeed { get; }
    internal NkeyPair(Byte[] publicKey, Byte[] privateKey, PrefixType type);
    internal NkeyPair(Byte[] userSeed, PrefixType type);
    [CompilerGeneratedAttribute]
public PrefixType get_Type();
    public Byte[] get_PublicKey();
    public string get_EncodedPublicKey();
    public Byte[] get_PrivateKeySeed();
    public string get_EncodedSeed();
    public void Wipe();
    public Byte[] Sign(Byte[] src);
    protected virtual void Dispose(bool disposing);
    public sealed virtual void Dispose();
}
public class NATS.Client.Nkeys : object {
    internal static byte PrefixByteSeed;
    internal static byte PrefixBytePrivate;
    internal static byte PrefixByteServer;
    internal static byte PrefixByteCluster;
    internal static byte PrefixByteOperator;
    internal static byte PrefixByteAccount;
    internal static byte PrefixByteUser;
    internal static byte PrefixByteUknown;
    public static Byte[] Decode(string src);
    private static bool IsValidPublicPrefixByte(byte prefixByte);
    internal static Nullable`1<PrefixType> TypeFromPrefix(byte prefixByte);
    internal static byte PrefixFromType(PrefixType type);
    public static void Wipe(Byte[]& src);
    public static void Wipe(string src);
    internal static Byte[] DecodeSeed(Byte[] raw);
    internal static Byte[] DecodeSeed(Byte[] raw, PrefixType& type);
    internal static Byte[] DecodeSeed(string src);
    internal static Byte[] DecodeSeed(string src, PrefixType& type);
    public static NkeyPair FromPublicKey(string publicKey);
    public static NkeyPair FromPublicKey(Char[] publicKey);
    public static NkeyPair FromSeed(string seed);
    internal static string Encode(byte prefixbyte, bool seed, Byte[] src);
    private static string CreateSeed(byte prefixbyte);
    public static string CreateUserSeed();
    public static string CreateAccountSeed();
    public static string CreateOperatorSeed();
    public static string PublicKeyFromSeed(string seed);
}
[ObsoleteAttribute("NATS.Client.NUID is deprecated and will be removed in a future version")]
public class NATS.Client.NUID : object {
    private static Char[] digits;
    private static int nuidBase;
    private static int preLen;
    private static long seqLen;
    public static long LENGTH;
    public static long MAXPRE;
    public static long MAXSEQ;
    private static int minInc;
    private static int maxInc;
    private static long totalLen;
    private RandomNumberGenerator srand;
    private Random prand;
    private Byte[] pre;
    private long seq;
    private long inc;
    private static NUID globalNUID;
    private static object globalLock;
    public static NUID Instance { get; }
    public static string NextGlobal { get; }
    public string Next { get; }
    public Byte[] Pre { get; public set; }
    public long Seq { get; public set; }
    public long Length { get; }
    private static NUID();
    private long nextLong(bool useSecureRand, long min, long max);
    private long nextLong(bool useSecureRand, long max);
    private long nextLong(bool useSecureRand);
    private string getNextNuid();
    private void resetSequential();
    public void RandomizePrefix();
    public static NUID get_Instance();
    public static string get_NextGlobal();
    public string get_Next();
    public Byte[] get_Pre();
    public void set_Pre(Byte[] value);
    public long get_Seq();
    public void set_Seq(long value);
    public long get_Length();
}
public interface NATS.Client.ObjectStore.IObjectStore {
    public string BucketName { get; }
    public abstract virtual string get_BucketName();
    public abstract virtual ObjectInfo Put(ObjectMeta meta, Stream inputStream);
    public abstract virtual ObjectInfo Put(string objectName, Stream inputStream);
    public abstract virtual ObjectInfo Put(string objectName, Byte[] input);
    public abstract virtual ObjectInfo Put(FileInfo fileInfo);
    public abstract virtual ObjectInfo Get(string objectName, Stream outputStream);
    public abstract virtual ObjectInfo GetInfo(string objectName);
    public abstract virtual ObjectInfo GetInfo(string objectName, bool includingDeleted);
    public abstract virtual ObjectInfo UpdateMeta(string objectName, ObjectMeta meta);
    public abstract virtual ObjectInfo Delete(string objectName);
    public abstract virtual ObjectInfo AddLink(string objectName, ObjectInfo toInfo);
    public abstract virtual ObjectInfo AddBucketLink(string objectName, IObjectStore toStore);
    public abstract virtual ObjectStoreStatus Seal();
    public abstract virtual IList`1<ObjectInfo> GetList();
    public abstract virtual ObjectStoreWatchSubscription Watch(IObjectStoreWatcher watcher, ObjectStoreWatchOption[] watchOptions);
    public abstract virtual ObjectStoreStatus GetStatus();
}
public interface NATS.Client.ObjectStore.IObjectStoreManagement {
    public abstract virtual ObjectStoreStatus Create(ObjectStoreConfiguration config);
    public abstract virtual IList`1<string> GetBucketNames();
    public abstract virtual ObjectStoreStatus GetStatus(string bucketName);
    public abstract virtual IList`1<ObjectStoreStatus> GetStatuses();
    public abstract virtual void Delete(string bucketName);
}
public interface NATS.Client.ObjectStore.IObjectStoreWatcher {
    public abstract virtual void Watch(ObjectInfo oi);
    public abstract virtual void EndOfData();
}
public class NATS.Client.ObjectStore.ObjectInfo : JsonSerializable {
    [CompilerGeneratedAttribute]
private string <Bucket>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Nuid>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Size>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <Modified>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Chunks>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Digest>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsDeleted>k__BackingField;
    [CompilerGeneratedAttribute]
private ObjectMeta <ObjectMeta>k__BackingField;
    public string Bucket { get; }
    public string Nuid { get; }
    public long Size { get; }
    public DateTime Modified { get; }
    public long Chunks { get; }
    public string Digest { get; }
    public bool IsDeleted { get; }
    public ObjectMeta ObjectMeta { get; }
    public string ObjectName { get; }
    public string Description { get; }
    public MsgHeader Headers { get; }
    public bool IsLink { get; }
    public ObjectLink Link { get; }
    internal ObjectInfo(ObjectInfoBuilder b);
    public ObjectInfo(MessageInfo mi);
    public ObjectInfo(Msg m);
    internal ObjectInfo(string json, DateTime messageTime);
    [CompilerGeneratedAttribute]
public string get_Bucket();
    [CompilerGeneratedAttribute]
public string get_Nuid();
    [CompilerGeneratedAttribute]
public long get_Size();
    [CompilerGeneratedAttribute]
public DateTime get_Modified();
    [CompilerGeneratedAttribute]
public long get_Chunks();
    [CompilerGeneratedAttribute]
public string get_Digest();
    [CompilerGeneratedAttribute]
public bool get_IsDeleted();
    [CompilerGeneratedAttribute]
public ObjectMeta get_ObjectMeta();
    public string get_ObjectName();
    public string get_Description();
    public MsgHeader get_Headers();
    public bool get_IsLink();
    public ObjectLink get_Link();
    public virtual JSONNode ToJsonNode();
    protected bool Equals(ObjectInfo other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    internal static ObjectInfoBuilder Builder(string bucket, string objectName);
    internal static ObjectInfoBuilder Builder(string bucket, ObjectMeta meta);
    internal static ObjectInfoBuilder Builder(ObjectInfo info);
}
public class NATS.Client.ObjectStore.ObjectLink : JsonSerializable {
    [CompilerGeneratedAttribute]
private string <Bucket>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ObjectName>k__BackingField;
    public string Bucket { get; }
    public string ObjectName { get; }
    public bool IsObjectLink { get; }
    public bool IsBucketLink { get; }
    private ObjectLink(JSONNode objectLinkNode);
    internal ObjectLink(string bucket, string objectName);
    [CompilerGeneratedAttribute]
public string get_Bucket();
    [CompilerGeneratedAttribute]
public string get_ObjectName();
    public bool get_IsObjectLink();
    public bool get_IsBucketLink();
    internal static ObjectLink OptionalInstance(JSONNode objectLinkNode);
    public static ObjectLink ForBucket(string bucket);
    public static ObjectLink ForObject(string bucket, string objectName);
    public virtual JSONNode ToJsonNode();
    private bool Equals(ObjectLink other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class NATS.Client.ObjectStore.ObjectMeta : JsonSerializable {
    [CompilerGeneratedAttribute]
private string <ObjectName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private MsgHeader <Headers>k__BackingField;
    [CompilerGeneratedAttribute]
private ObjectMetaOptions <ObjectMetaOptions>k__BackingField;
    public string ObjectName { get; }
    public string Description { get; }
    public MsgHeader Headers { get; }
    public ObjectMetaOptions ObjectMetaOptions { get; }
    internal ObjectMeta(JSONNode node);
    private ObjectMeta(ObjectMetaBuilder b);
    [CompilerGeneratedAttribute]
public string get_ObjectName();
    [CompilerGeneratedAttribute]
public string get_Description();
    [CompilerGeneratedAttribute]
public MsgHeader get_Headers();
    [CompilerGeneratedAttribute]
public ObjectMetaOptions get_ObjectMetaOptions();
    public virtual JSONNode ToJsonNode();
    internal void EmbedJson(JSONObject jsonObject);
    protected bool Equals(ObjectMeta other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static ObjectMetaBuilder Builder(string objectName);
    internal static ObjectMetaBuilder Builder(ObjectMeta om);
    public static ObjectMeta ForObjectName(string objectName);
}
public class NATS.Client.ObjectStore.ObjectMetaOptions : JsonSerializable {
    [CompilerGeneratedAttribute]
private ObjectLink <Link>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ChunkSize>k__BackingField;
    public ObjectLink Link { get; }
    public int ChunkSize { get; }
    public bool HasData { get; }
    internal ObjectMetaOptions(JSONNode node);
    private ObjectMetaOptions(ObjectMetaOptionsBuilder b);
    [CompilerGeneratedAttribute]
public ObjectLink get_Link();
    [CompilerGeneratedAttribute]
public int get_ChunkSize();
    public bool get_HasData();
    public virtual JSONNode ToJsonNode();
    protected bool Equals(ObjectMetaOptions other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    internal static ObjectMetaOptionsBuilder Builder();
    internal static ObjectMetaOptionsBuilder Builder(ObjectMetaOptions om);
}
public class NATS.Client.ObjectStore.ObjectStore : FeatureBase {
    internal ObjectStoreOptions oso;
    [CompilerGeneratedAttribute]
private string <RawChunkPrefix>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PubSubChunkPrefix>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RawMetaPrefix>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PubSubMetaPrefix>k__BackingField;
    [CompilerGeneratedAttribute]
private string <BucketName>k__BackingField;
    internal string RawChunkPrefix { get; }
    internal string PubSubChunkPrefix { get; }
    internal string RawMetaPrefix { get; }
    internal string PubSubMetaPrefix { get; }
    public string BucketName { get; }
    internal ObjectStore(IConnection connection, string bucketName, ObjectStoreOptions oso);
    [CompilerGeneratedAttribute]
internal string get_RawChunkPrefix();
    [CompilerGeneratedAttribute]
internal string get_PubSubChunkPrefix();
    [CompilerGeneratedAttribute]
internal string get_RawMetaPrefix();
    [CompilerGeneratedAttribute]
internal string get_PubSubMetaPrefix();
    [CompilerGeneratedAttribute]
public sealed virtual string get_BucketName();
    internal string RawChunkSubject(string nuid);
    internal string PubSubChunkSubject(string nuid);
    internal string RawMetaSubject(string name);
    internal string RawAllMetaSubject();
    internal string PubSubMetaSubject(string name);
    private ObjectInfo PublishMeta(ObjectInfo info);
    public sealed virtual ObjectInfo Put(ObjectMeta meta, Stream inputStream);
    public sealed virtual ObjectInfo Put(string objectName, Stream inputStream);
    public sealed virtual ObjectInfo Put(string objectName, Byte[] input);
    public sealed virtual ObjectInfo Put(FileInfo fileInfo);
    public sealed virtual ObjectInfo Get(string objectName, Stream outputStream);
    public sealed virtual ObjectInfo GetInfo(string objectName);
    public sealed virtual ObjectInfo GetInfo(string objectName, bool includingDeleted);
    public sealed virtual ObjectInfo UpdateMeta(string objectName, ObjectMeta meta);
    public sealed virtual ObjectInfo Delete(string objectName);
    public sealed virtual ObjectInfo AddLink(string objectName, ObjectInfo toInfo);
    public sealed virtual ObjectInfo AddBucketLink(string objectName, IObjectStore toStore);
    public sealed virtual ObjectStoreStatus Seal();
    public sealed virtual IList`1<ObjectInfo> GetList();
    public sealed virtual ObjectStoreWatchSubscription Watch(IObjectStoreWatcher watcher, ObjectStoreWatchOption[] watchOptions);
    public sealed virtual ObjectStoreStatus GetStatus();
}
public class NATS.Client.ObjectStore.ObjectStoreConfiguration : object {
    internal static CompressionOption JsCompressionYes;
    internal static CompressionOption JsCompressionNo;
    [CompilerGeneratedAttribute]
private StreamConfiguration <BackingConfig>k__BackingField;
    [CompilerGeneratedAttribute]
private string <BucketName>k__BackingField;
    internal StreamConfiguration BackingConfig { get; }
    public string BucketName { get; }
    public string Description { get; }
    public long MaxBucketSize { get; }
    public Duration Ttl { get; }
    public StorageType StorageType { get; }
    public int Replicas { get; }
    public Placement Placement { get; }
    public bool IsCompressed { get; }
    public IDictionary`2<string, string> Metadata { get; }
    internal ObjectStoreConfiguration(StreamConfiguration sc);
    private static ObjectStoreConfiguration();
    [CompilerGeneratedAttribute]
internal StreamConfiguration get_BackingConfig();
    [CompilerGeneratedAttribute]
public string get_BucketName();
    internal static ObjectStoreConfiguration Instance(string json);
    public string get_Description();
    public long get_MaxBucketSize();
    public Duration get_Ttl();
    public StorageType get_StorageType();
    public int get_Replicas();
    public Placement get_Placement();
    public bool get_IsCompressed();
    public IDictionary`2<string, string> get_Metadata();
    public static ObjectStoreConfigurationBuilder Builder();
    public static ObjectStoreConfigurationBuilder Builder(string name);
    public static ObjectStoreConfigurationBuilder Builder(ObjectStoreConfiguration osc);
    public virtual string ToString();
}
public class NATS.Client.ObjectStore.ObjectStoreManagement : object {
    private JetStreamManagement jsm;
    internal ObjectStoreManagement(IConnection connection, ObjectStoreOptions oso);
    public sealed virtual ObjectStoreStatus Create(ObjectStoreConfiguration config);
    public ObjectStoreStatus Update(ObjectStoreConfiguration config);
    public sealed virtual IList`1<string> GetBucketNames();
    public sealed virtual ObjectStoreStatus GetStatus(string bucketName);
    public sealed virtual IList`1<ObjectStoreStatus> GetStatuses();
    public sealed virtual void Delete(string bucketName);
}
public class NATS.Client.ObjectStore.ObjectStoreOptions : FeatureOptions {
    private ObjectStoreOptions(JetStreamOptions jso);
    public static ObjectStoreOptionsBuilder Builder();
    public static ObjectStoreOptionsBuilder Builder(ObjectStoreOptions oso);
    public static ObjectStoreOptionsBuilder Builder(JetStreamOptions jso);
}
public class NATS.Client.ObjectStore.ObjectStoreStatus : object {
    [CompilerGeneratedAttribute]
private StreamInfo <BackingStreamInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private ObjectStoreConfiguration <Config>k__BackingField;
    public StreamInfo BackingStreamInfo { get; }
    public ObjectStoreConfiguration Config { get; }
    public string BucketName { get; }
    public string Description { get; }
    public ulong Size { get; }
    public bool Sealed { get; }
    public Duration Ttl { get; }
    public StorageType StorageType { get; }
    public int Replicas { get; }
    public Placement Placement { get; }
    public bool IsCompressed { get; }
    public IDictionary`2<string, string> Metadata { get; }
    public string BackingStore { get; }
    public ObjectStoreStatus(StreamInfo si);
    [CompilerGeneratedAttribute]
public StreamInfo get_BackingStreamInfo();
    [CompilerGeneratedAttribute]
public ObjectStoreConfiguration get_Config();
    public string get_BucketName();
    public string get_Description();
    public ulong get_Size();
    public bool get_Sealed();
    public Duration get_Ttl();
    public StorageType get_StorageType();
    public int get_Replicas();
    public Placement get_Placement();
    public bool get_IsCompressed();
    public IDictionary`2<string, string> get_Metadata();
    public string get_BackingStore();
    public virtual string ToString();
}
public static class NATS.Client.ObjectStore.ObjectStoreUtil : object {
    public static int DefaultChunkSize;
    internal static string ObjStreamPrefix;
    internal static int ObjStreamPrefixLen;
    internal static string ObjSubjectPrefix;
    internal static string ObjSubjectSuffix;
    internal static string ObjMetaPart;
    internal static string ObjChunkPart;
    public static MsgHeader MetaHeaders { get; }
    private static ObjectStoreUtil();
    public static MsgHeader get_MetaHeaders();
    public static string ExtractBucketName(string streamName);
    public static string ToStreamName(string bucketName);
    public static string ToMetaStreamSubject(string bucketName);
    public static string ToChunkStreamSubject(string bucketName);
    public static string ToMetaPrefix(string bucketName);
    public static string ToChunkPrefix(string bucketName);
    public static string EncodeForSubject(string name);
}
public enum NATS.Client.ObjectStore.ObjectStoreWatchOption : Enum {
    public int value__;
    public static ObjectStoreWatchOption IgnoreDelete;
    public static ObjectStoreWatchOption IncludeHistory;
    public static ObjectStoreWatchOption UpdatesOnly;
}
public class NATS.Client.ObjectStore.ObjectStoreWatchSubscription : object {
    private IJetStreamPushAsyncSubscription sub;
    private InterlockedBoolean endOfDataSent;
    public ObjectStoreWatchSubscription(ObjectStore os, IObjectStoreWatcher watcher, ObjectStoreWatchOption[] watchOptions);
    public void Unsubscribe();
    public sealed virtual void Dispose();
}
public class NATS.Client.Options : object {
    private string url;
    private String[] servers;
    private bool noRandomize;
    private string name;
    private bool verbose;
    private bool pedantic;
    private bool useOldRequestStyle;
    private bool secure;
    private bool allowReconnect;
    private bool noEcho;
    private bool ignoreDiscoveredServers;
    private bool tlsFirst;
    private bool clientSideLimitChecks;
    private IServerProvider serverProvider;
    private int maxReconnect;
    private int reconnectWait;
    private int pingInterval;
    private int timeout;
    private int reconnectJitter;
    private int reconnectJitterTLS;
    private ITCPConnection tcpConnection;
    internal X509Certificate2Collection certificates;
    public EventHandler`1<ConnEventArgs> ClosedEventHandler;
    public EventHandler`1<ConnEventArgs> ServerDiscoveredEventHandler;
    public EventHandler`1<ConnEventArgs> DisconnectedEventHandler;
    public EventHandler`1<ConnEventArgs> ReconnectedEventHandler;
    public EventHandler`1<ErrEventArgs> AsyncErrorEventHandler;
    public EventHandler`1<ConnEventArgs> LameDuckModeEventHandler;
    public EventHandler`1<ReconnectDelayEventArgs> ReconnectDelayHandler;
    public EventHandler`1<HeartbeatAlarmEventArgs> HeartbeatAlarmEventHandler;
    public EventHandler`1<UnhandledStatusEventArgs> UnhandledStatusEventHandler;
    public EventHandler`1<StatusEventArgs> PullStatusWarningEventHandler;
    public EventHandler`1<StatusEventArgs> PullStatusErrorEventHandler;
    public EventHandler`1<FlowControlProcessedEventArgs> FlowControlProcessedEventHandler;
    internal EventHandler`1<UserJWTEventArgs> UserJWTEventHandler;
    internal EventHandler`1<UserSignatureEventArgs> UserSignatureEventHandler;
    internal int maxPingsOut;
    private long pendingMessageLimit;
    private long pendingBytesLimit;
    internal int subscriberDeliveryTaskCount;
    internal int subscriptionBatchSize;
    internal int reconnectBufSize;
    internal string user;
    internal string password;
    internal string token;
    internal string nkey;
    internal string customInboxPrefix;
    private static String[] protcolSep;
    public static int ReconnectForever;
    public RemoteCertificateValidationCallback TLSRemoteCertificationValidationCallback;
    public static int ReconnectBufferSizeUnbounded;
    public static int ReconnectBufferDisabled;
    [CompilerGeneratedAttribute]
private bool <CheckCertificateRevocation>k__BackingField;
    public EventHandler`1<ConnEventArgs> ClosedEventHandlerOrDefault { get; }
    public EventHandler`1<ConnEventArgs> ServerDiscoveredEventHandlerOrDefault { get; }
    public EventHandler`1<ConnEventArgs> DisconnectedEventHandlerOrDefault { get; }
    public EventHandler`1<ConnEventArgs> ReconnectedEventHandlerOrDefault { get; }
    public EventHandler`1<ErrEventArgs> AsyncErrorEventHandlerOrDefault { get; }
    public EventHandler`1<ConnEventArgs> LameDuckModeEventHandlerOrDefault { get; }
    public EventHandler`1<HeartbeatAlarmEventArgs> HeartbeatAlarmEventHandlerOrDefault { get; }
    public EventHandler`1<UnhandledStatusEventArgs> UnhandledStatusEventHandlerOrDefault { get; }
    public EventHandler`1<StatusEventArgs> PullStatusWarningEventHandlerOrDefault { get; }
    public EventHandler`1<StatusEventArgs> PullStatusErrorEventHandlerOrDefault { get; }
    public EventHandler`1<FlowControlProcessedEventArgs> FlowControlProcessedEventHandlerOrDefault { get; }
    public string Url { get; public set; }
    public String[] Servers { get; public set; }
    public bool NoRandomize { get; public set; }
    public string Name { get; public set; }
    public bool Verbose { get; public set; }
    public bool Pedantic { get; public set; }
    public bool UseOldRequestStyle { get; public set; }
    public bool Secure { get; public set; }
    public ITCPConnection TCPConnection { get; public set; }
    public bool AllowReconnect { get; public set; }
    public int MaxReconnect { get; public set; }
    public int ReconnectWait { get; public set; }
    public int PingInterval { get; public set; }
    public int Timeout { get; public set; }
    public int MaxPingsOut { get; public set; }
    [ObsoleteAttribute("Please use the PendingMessageLimit property instead")]
public int SubChannelLength { get; public set; }
    public long PendingMessageLimit { get; public set; }
    public long PendingBytesLimit { get; public set; }
    public string User { get; public set; }
    unknown string Password {public set; }
    public string Token { get; public set; }
    public string CustomInboxPrefix { get; public set; }
    public int SubscriberDeliveryTaskCount { get; public set; }
    public int SubscriptionBatchSize { get; public set; }
    public bool NoEcho { get; public set; }
    public bool IgnoreDiscoveredServers { get; public set; }
    public bool TlsFirst { get; public set; }
    public bool ClientSideLimitChecks { get; public set; }
    internal IServerProvider ServerProvider { get; internal set; }
    public int ReconnectBufferSize { get; public set; }
    public int ReconnectJitter { get; }
    public int ReconnectJitterTLS { get; }
    public bool CheckCertificateRevocation { get; public set; }
    internal Options(Options o);
    private static Options();
    private bool Equals(Options other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public EventHandler`1<ConnEventArgs> get_ClosedEventHandlerOrDefault();
    public EventHandler`1<ConnEventArgs> get_ServerDiscoveredEventHandlerOrDefault();
    public EventHandler`1<ConnEventArgs> get_DisconnectedEventHandlerOrDefault();
    public EventHandler`1<ConnEventArgs> get_ReconnectedEventHandlerOrDefault();
    public EventHandler`1<ErrEventArgs> get_AsyncErrorEventHandlerOrDefault();
    public EventHandler`1<ConnEventArgs> get_LameDuckModeEventHandlerOrDefault();
    public EventHandler`1<HeartbeatAlarmEventArgs> get_HeartbeatAlarmEventHandlerOrDefault();
    public EventHandler`1<UnhandledStatusEventArgs> get_UnhandledStatusEventHandlerOrDefault();
    public EventHandler`1<StatusEventArgs> get_PullStatusWarningEventHandlerOrDefault();
    public EventHandler`1<StatusEventArgs> get_PullStatusErrorEventHandlerOrDefault();
    public EventHandler`1<FlowControlProcessedEventArgs> get_FlowControlProcessedEventHandlerOrDefault();
    public void SetUserCredentials(string credentialsPath, string privateKeyPath);
    public void SetUserCredentialsFromString(string credentialsText);
    public void SetUserCredentialsFromStrings(string userJwtText, string nkeySeedText);
    public void SetUserCredentials(string credentialsPath);
    public void SetUserCredentialHandlers(EventHandler`1<UserJWTEventArgs> userJWTEventHandler, EventHandler`1<UserSignatureEventArgs> userSignatureEventHandler);
    public void SetNkey(string publicNkey, EventHandler`1<UserSignatureEventArgs> userSignatureEventHandler);
    public void SetNkey(string publicNkey, string privateKeyPath);
    public void SetJWTEventHandlers(EventHandler`1<UserJWTEventArgs> JWTEventHandler, EventHandler`1<UserSignatureEventArgs> SignatureEventHandler);
    private static string ensureProperUrl(string url);
    public string get_Url();
    public void set_Url(string value);
    public String[] get_Servers();
    public void set_Servers(String[] value);
    public bool get_NoRandomize();
    public void set_NoRandomize(bool value);
    public string get_Name();
    public void set_Name(string value);
    public bool get_Verbose();
    public void set_Verbose(bool value);
    public bool get_Pedantic();
    public void set_Pedantic(bool value);
    public bool get_UseOldRequestStyle();
    public void set_UseOldRequestStyle(bool value);
    public bool get_Secure();
    public void set_Secure(bool value);
    public ITCPConnection get_TCPConnection();
    public void set_TCPConnection(ITCPConnection value);
    public bool get_AllowReconnect();
    public void set_AllowReconnect(bool value);
    public int get_MaxReconnect();
    public void set_MaxReconnect(int value);
    public int get_ReconnectWait();
    public void set_ReconnectWait(int value);
    public int get_PingInterval();
    public void set_PingInterval(int value);
    public int get_Timeout();
    public void set_Timeout(int value);
    public int get_MaxPingsOut();
    public void set_MaxPingsOut(int value);
    public int get_SubChannelLength();
    public void set_SubChannelLength(int value);
    public long get_PendingMessageLimit();
    public void set_PendingMessageLimit(long value);
    public long get_PendingBytesLimit();
    public void set_PendingBytesLimit(long value);
    public string get_User();
    public void set_User(string value);
    public void set_Password(string value);
    public string get_Token();
    public void set_Token(string value);
    public string get_CustomInboxPrefix();
    public void set_CustomInboxPrefix(string value);
    public void AddCertificate(string fileName);
    public void AddCertificate(X509Certificate2 certificate);
    public int get_SubscriberDeliveryTaskCount();
    public void set_SubscriberDeliveryTaskCount(int value);
    public int get_SubscriptionBatchSize();
    public void set_SubscriptionBatchSize(int value);
    public bool get_NoEcho();
    public void set_NoEcho(bool value);
    public bool get_IgnoreDiscoveredServers();
    public void set_IgnoreDiscoveredServers(bool value);
    public bool get_TlsFirst();
    public void set_TlsFirst(bool value);
    public bool get_ClientSideLimitChecks();
    public void set_ClientSideLimitChecks(bool value);
    internal IServerProvider get_ServerProvider();
    internal void set_ServerProvider(IServerProvider value);
    private void appendEventHandler(StringBuilder sb, string name, Delegate eh);
    public int get_ReconnectBufferSize();
    public void set_ReconnectBufferSize(int value);
    public void SetReconnectJitter(int jitter, int tlsJitter);
    public int get_ReconnectJitter();
    public int get_ReconnectJitterTLS();
    [CompilerGeneratedAttribute]
public bool get_CheckCertificateRevocation();
    [CompilerGeneratedAttribute]
public void set_CheckCertificateRevocation(bool value);
    public virtual string ToString();
}
internal class NATS.Client.Parser : object {
    private Connection conn;
    private Byte[] argBufBase;
    private MemoryStream argBufStream;
    private Byte[] msgBufBase;
    private MemoryStream msgBufStream;
    internal int state;
    internal int hdr;
    private static int OP_START;
    private static int OP_PLUS;
    private static int OP_PLUS_O;
    private static int OP_PLUS_OK;
    private static int OP_MINUS;
    private static int OP_MINUS_E;
    private static int OP_MINUS_ER;
    private static int OP_MINUS_ERR;
    private static int OP_MINUS_ERR_SPC;
    private static int MINUS_ERR_ARG;
    private static int OP_C;
    private static int OP_CO;
    private static int OP_CON;
    private static int OP_CONN;
    private static int OP_CONNE;
    private static int OP_CONNEC;
    private static int OP_CONNECT;
    private static int CONNECT_ARG;
    private static int OP_M;
    private static int OP_MS;
    private static int OP_MSG;
    private static int OP_MSG_SPC;
    private static int MSG_ARG;
    private static int MSG_PAYLOAD;
    private static int MSG_END;
    private static int OP_P;
    private static int OP_H;
    private static int OP_PI;
    private static int OP_PIN;
    private static int OP_PING;
    private static int OP_PO;
    private static int OP_PON;
    private static int OP_PONG;
    private static int OP_I;
    private static int OP_IN;
    private static int OP_INF;
    private static int OP_INFO;
    private static int OP_INFO_SPC;
    private static int INFO_ARG;
    internal Parser(Connection conn);
    private void parseError(Byte[] buffer, int position);
    internal void parse(Byte[] buffer, int len);
}
public class NATS.Client.ReconnectDelayEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private int <Attempts>k__BackingField;
    public int Attempts { get; }
    internal ReconnectDelayEventArgs(int attempts);
    [CompilerGeneratedAttribute]
public int get_Attempts();
}
public class NATS.Client.ReconnectOptions : object {
    private int flushTimeout;
    public int FlushTimeout { get; public set; }
    public int get_FlushTimeout();
    public void set_FlushTimeout(int value);
    public ReconnectOptions WithFlushTimeout(int timeout);
}
public interface NATS.Client.Rx.INATSObservable`1 {
}
public abstract class NATS.Client.Rx.NATSObservable`1 : object {
    private ConcurrentDictionary`2<int, ObserverSubscription<T>> subscriptions;
    protected void InvokeObservers(T data);
    private void DisposeSubscription(ObserverSubscription<T> sub);
    public sealed virtual IDisposable Subscribe(IObserver`1<T> observer);
    protected virtual void Dispose(bool disposing);
    public sealed virtual void Dispose();
}
public class NATS.Client.Rx.NATSObservableSubscription : NATSObservable`1<Msg> {
    private IAsyncSubscription subscription;
    private NATSObservableSubscription(IAsyncSubscription subscription);
    public static INATSObservable`1<Msg> Wrap(IAsyncSubscription subscription);
    private void OnIncomingMessage(object _, MsgHandlerEventArgs e);
    protected virtual void Dispose(bool disposing);
}
public class NATS.Client.Rx.NATSRxException : NATSException {
    public NATSRxException(string message);
    public NATSRxException(string message, Exception innerException);
}
internal class NATS.Client.Rx.Ops.DelegatingObserver`1 : object {
    private Action`1<T> onNext;
    private Action`1<Exception> onError;
    private Action onCompleted;
    internal DelegatingObserver`1(Action`1<T> onNext, Action`1<Exception> onError, Action onCompleted);
    public sealed virtual void OnNext(T value);
    public sealed virtual void OnError(Exception error);
    public sealed virtual void OnCompleted();
}
internal class NATS.Client.Rx.Ops.MapObservable`2 : object {
    private INATSObservable`1<TSrc> src;
    private Func`2<TSrc, TResult> mapper;
    public MapObservable`2(INATSObservable`1<TSrc> src, Func`2<TSrc, TResult> predicate);
    public sealed virtual void Dispose();
    public sealed virtual IDisposable Subscribe(IObserver`1<TResult> observer);
}
[ExtensionAttribute]
public static class NATS.Client.Rx.Ops.OpsExtensions : object {
    [ExtensionAttribute]
public static IDisposable Subscribe(INATSObservable`1<T> ob, Action`1<T> onNext, Action`1<Exception> onError, Action onCompleted);
    [ExtensionAttribute]
public static IDisposable SubscribeSafe(INATSObservable`1<T> ob, Action`1<T> onNext, Action`1<Exception> onError, Action onCompleted);
    [ExtensionAttribute]
public static IDisposable SubscribeSafe(INATSObservable`1<T> ob, IObserver`1<T> observer);
    [ExtensionAttribute]
public static INATSObservable`1<T> Where(INATSObservable`1<T> ob, Func`2<T, bool> predicate);
    [ExtensionAttribute]
public static INATSObservable`1<TResult> Select(INATSObservable`1<TSrc> ob, Func`2<TSrc, TResult> mapper);
}
internal class NATS.Client.Rx.Ops.SafeObserver`1 : object {
    private Action`1<T> onNext;
    private Action`1<Exception> onError;
    private Action onCompleted;
    internal SafeObserver`1(Action`1<T> onNext, Action`1<Exception> onError, Action onCompleted);
    public sealed virtual void OnNext(T value);
    public sealed virtual void OnError(Exception error);
    public sealed virtual void OnCompleted();
}
internal class NATS.Client.Rx.Ops.WhereObservable`1 : object {
    private INATSObservable`1<T> src;
    private Func`2<T, bool> predicate;
    public WhereObservable`1(INATSObservable`1<T> src, Func`2<T, bool> predicate);
    public sealed virtual void Dispose();
    public sealed virtual IDisposable Subscribe(IObserver`1<T> observer);
}
[ExtensionAttribute]
public static class NATS.Client.Rx.RxExtensions : object {
    [ExtensionAttribute]
public static INATSObservable`1<Msg> Observe(IConnection cn, string subject);
    [ExtensionAttribute]
public static INATSObservable`1<Msg> ToObservable(IAsyncSubscription subscription);
}
public class NATS.Client.Serializer : MulticastDelegate {
    public Serializer(object object, IntPtr method);
    public virtual Byte[] Invoke(object obj);
    public virtual IAsyncResult BeginInvoke(object obj, AsyncCallback callback, object object);
    public virtual Byte[] EndInvoke(IAsyncResult result);
}
[DefaultMemberAttribute("Item")]
internal class NATS.Client.ServerPool : object {
    protected object poolLock;
    protected LinkedList`1<Srv> sList;
    protected Srv currentServer;
    protected Random rand;
    protected bool randomize;
    protected bool ignoreDiscoveredServers;
    protected SrvEqualityComparer duplicateSrvCheck;
    protected Srv Item { get; }
    public virtual void Setup(Options opts);
    public virtual void ConnectToAServer(Predicate`1<Srv> connectToServer);
    protected virtual Srv get_Item(int index);
    public virtual void SetCurrentServer(Srv value);
    public virtual Srv SelectNextServer(int maxReconnect);
    public virtual String[] GetServerList(bool implicitOnly);
    protected virtual bool Add(string s, bool isImplicit);
    protected virtual bool Add(Srv s);
    public virtual bool AcceptDiscoveredServers(String[] discoveredUrls);
    internal void PruneOutdatedServers(String[] newUrls);
    internal bool Add(String[] urls, bool isImplicit);
    internal static void Shuffle(IList`1<T> list);
    protected virtual void Shuffle();
    protected virtual bool IsEmpty();
    public virtual Srv First();
    public virtual bool HasSecureServer();
}
public class NATS.Client.Service.Discovery : object {
    public static int DefaultDiscoveryMaxTimeMillis;
    public static int DefaultDiscoveryMaxResults;
    private IConnection conn;
    private int maxTimeMillis;
    private int maxResults;
    private Func`1<string> _inboxSupplier;
    public Func`1<string> InboxSupplier { get; public set; }
    public Discovery(IConnection conn, int maxTimeMillis, int maxResults);
    public Func`1<string> get_InboxSupplier();
    public void set_InboxSupplier(Func`1<string> value);
    public IList`1<PingResponse> Ping();
    public IList`1<PingResponse> Ping(string serviceName);
    public PingResponse PingForNameAndId(string serviceName, string serviceId);
    public IList`1<InfoResponse> Info();
    public IList`1<InfoResponse> Info(string serviceName);
    public InfoResponse InfoForNameAndId(string serviceName, string serviceId);
    public IList`1<StatsResponse> Stats();
    public IList`1<StatsResponse> Stats(string serviceName);
    public StatsResponse StatsForNameAndId(string serviceName, string serviceId);
    private string DiscoverOne(string action, string serviceName, string serviceId);
    private void DiscoverMany(string action, string serviceName, Action`1<string> stringConsumer);
}
public class NATS.Client.Service.Endpoint : JsonSerializable {
    private static string DefaultQueueGroup;
    private IDictionary`2<string, string> _metadata;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Subject>k__BackingField;
    [CompilerGeneratedAttribute]
private string <QueueGroup>k__BackingField;
    public string Name { get; }
    public string Subject { get; }
    public string QueueGroup { get; }
    public IDictionary`2<string, string> Metadata { get; }
    public Endpoint(string name);
    public Endpoint(string name, IDictionary`2<string, string> metadata);
    public Endpoint(string name, string subject);
    public Endpoint(string name, string subject, IDictionary`2<string, string> metadata);
    public Endpoint(string name, string subject, string queueGroup, IDictionary`2<string, string> metadata);
    internal Endpoint(string name, string subject, string queueGroup, IDictionary`2<string, string> metadata, bool validate);
    internal Endpoint(JSONNode node);
    private Endpoint(EndpointBuilder b);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public string get_Subject();
    [CompilerGeneratedAttribute]
public string get_QueueGroup();
    public IDictionary`2<string, string> get_Metadata();
    public virtual JSONNode ToJsonNode();
    public static EndpointBuilder Builder();
    public virtual string ToString();
    protected bool Equals(Endpoint other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class NATS.Client.Service.EndpointContext : object {
    private IConnection conn;
    private ServiceEndpoint se;
    private bool recordStats;
    private string qGroup;
    [CompilerGeneratedAttribute]
private IAsyncSubscription <Sub>k__BackingField;
    private DateTime started;
    private string lastError;
    private InterlockedLong numRequests;
    private InterlockedLong numErrors;
    private InterlockedLong processingTime;
    internal IAsyncSubscription Sub { get; private set; }
    internal EndpointContext(IConnection conn, bool internalEndpoint, ServiceEndpoint se);
    [CompilerGeneratedAttribute]
internal IAsyncSubscription get_Sub();
    [CompilerGeneratedAttribute]
private void set_Sub(IAsyncSubscription value);
    internal void Start();
    internal void OnMessage(object sender, MsgHandlerEventArgs args);
    internal EndpointStats GetEndpointStats();
    internal void Reset();
}
public class NATS.Client.Service.EndpointStats : JsonSerializable {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Subject>k__BackingField;
    [CompilerGeneratedAttribute]
private string <QueueGroup>k__BackingField;
    [CompilerGeneratedAttribute]
private long <NumRequests>k__BackingField;
    [CompilerGeneratedAttribute]
private long <NumErrors>k__BackingField;
    [CompilerGeneratedAttribute]
private long <ProcessingTime>k__BackingField;
    [CompilerGeneratedAttribute]
private long <AverageProcessingTime>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LastError>k__BackingField;
    [CompilerGeneratedAttribute]
private JSONNode <Data>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <Started>k__BackingField;
    public string Name { get; }
    public string Subject { get; }
    public string QueueGroup { get; }
    public long NumRequests { get; }
    public long NumErrors { get; }
    public long ProcessingTime { get; }
    public long AverageProcessingTime { get; }
    public string LastError { get; }
    public JSONNode Data { get; }
    public string DataAsJson { get; }
    public DateTime Started { get; }
    internal EndpointStats(string name, string subject, string queueGroup, long numRequests, long numErrors, long processingTime, string lastError, JSONNode data, DateTime started);
    internal EndpointStats(JSONNode node);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public string get_Subject();
    [CompilerGeneratedAttribute]
public string get_QueueGroup();
    [CompilerGeneratedAttribute]
public long get_NumRequests();
    [CompilerGeneratedAttribute]
public long get_NumErrors();
    [CompilerGeneratedAttribute]
public long get_ProcessingTime();
    [CompilerGeneratedAttribute]
public long get_AverageProcessingTime();
    [CompilerGeneratedAttribute]
public string get_LastError();
    [CompilerGeneratedAttribute]
public JSONNode get_Data();
    public string get_DataAsJson();
    [CompilerGeneratedAttribute]
public DateTime get_Started();
    internal static IList`1<EndpointStats> ListOf(JSONNode listNode);
    public virtual JSONNode ToJsonNode();
    public virtual string ToString();
    protected bool Equals(EndpointStats other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class NATS.Client.Service.Group : object {
    private Group _next;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public string Name { get; }
    public Group Next { get; }
    public string Subject { get; }
    public Group(string name);
    [CompilerGeneratedAttribute]
public string get_Name();
    public Group get_Next();
    public string get_Subject();
    public Group AppendGroup(Group group);
    public virtual string ToString();
    protected bool Equals(Group other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class NATS.Client.Service.InfoResponse : ServiceResponse {
    public static string ResponseType;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<Endpoint> <Endpoints>k__BackingField;
    public string Description { get; }
    public IList`1<Endpoint> Endpoints { get; }
    public InfoResponse(string id, string name, string version, IDictionary`2<string, string> metadata, string description, ICollection`1<ServiceEndpoint> serviceEndpoints);
    internal InfoResponse(string json);
    internal InfoResponse(JSONNode node);
    [CompilerGeneratedAttribute]
public string get_Description();
    [CompilerGeneratedAttribute]
public IList`1<Endpoint> get_Endpoints();
    public virtual JSONNode ToJsonNode();
    protected bool Equals(InfoResponse other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class NATS.Client.Service.PingResponse : ServiceResponse {
    public static string ResponseType;
    internal PingResponse(string id, string name, string version, IDictionary`2<string, string> metadata);
    internal PingResponse(string json);
    internal PingResponse(JSONNode node);
    public virtual JSONNode ToJsonNode();
}
public class NATS.Client.Service.Service : object {
    public static string SrvPing;
    public static string SrvInfo;
    public static string SrvSchema;
    public static string SrvStats;
    public static string DefaultServicePrefix;
    private IConnection conn;
    [CompilerGeneratedAttribute]
private int <DrainTimeoutMillis>k__BackingField;
    private IDictionary`2<string, EndpointContext> serviceContexts;
    private IList`1<EndpointContext> discoveryContexts;
    [CompilerGeneratedAttribute]
private PingResponse <PingResponse>k__BackingField;
    [CompilerGeneratedAttribute]
private InfoResponse <InfoResponse>k__BackingField;
    private object startStopLock;
    private TaskCompletionSource`1<bool> runningIndicator;
    private DateTime started;
    public int DrainTimeoutMillis { get; }
    public PingResponse PingResponse { get; }
    public InfoResponse InfoResponse { get; }
    public string Id { get; }
    public string Name { get; }
    public string Version { get; }
    public string Description { get; }
    internal Service(ServiceBuilder b);
    [CompilerGeneratedAttribute]
public int get_DrainTimeoutMillis();
    [CompilerGeneratedAttribute]
public PingResponse get_PingResponse();
    [CompilerGeneratedAttribute]
public InfoResponse get_InfoResponse();
    private void AddDiscoveryContexts(string discoveryName, EventHandler`1<ServiceMsgHandlerEventArgs> handler);
    private void AddDiscoveryContexts(string discoveryName, ServiceResponse sr);
    private void AddStatsContexts();
    private Endpoint InternalEndpoint(string discoveryName, string optionalServiceNameSegment, string optionalServiceIdSegment);
    internal static string ToDiscoverySubject(string discoverySubject, string serviceName, string serviceId);
    public Task`1<bool> StartService();
    public static ServiceBuilder Builder();
    public void Stop();
    public void Stop(Exception e);
    public void Stop(bool drain);
    public void Stop(bool drain, Exception e);
    public void Reset();
    public string get_Id();
    public string get_Name();
    public string get_Version();
    public string get_Description();
    public StatsResponse GetStatsResponse();
    public EndpointStats GetEndpointStats(string endpointName);
    public virtual string ToString();
    [CompilerGeneratedAttribute]
private void <AddStatsContexts>g__Handler|23_0(object sender, ServiceMsgHandlerEventArgs args);
}
public class NATS.Client.Service.ServiceBuilder : object {
    public static int DefaultDrainTimeoutMillis;
    internal IConnection Conn;
    internal string Name;
    internal string Description;
    internal string Version;
    internal IDictionary`2<string, ServiceEndpoint> ServiceEndpoints;
    internal int DrainTimeoutMillis;
    internal IDictionary`2<string, string> Metadata;
    public ServiceBuilder WithConnection(IConnection conn);
    public ServiceBuilder WithName(string name);
    public ServiceBuilder WithDescription(string description);
    public ServiceBuilder WithVersion(string version);
    public ServiceBuilder WithMetadata(IDictionary`2<string, string> metadata);
    public ServiceBuilder AddServiceEndpoint(ServiceEndpoint serviceEndpoint);
    public ServiceBuilder WithDrainTimeoutMillis(int drainTimeoutMillis);
    public Service Build();
}
public class NATS.Client.Service.ServiceEndpoint : object {
    [CompilerGeneratedAttribute]
private Group <Group>k__BackingField;
    [CompilerGeneratedAttribute]
private EventHandler`1<ServiceMsgHandlerEventArgs> <Handler>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`1<JSONNode> <StatsDataSupplier>k__BackingField;
    [CompilerGeneratedAttribute]
private Endpoint <Endpoint>k__BackingField;
    internal Group Group { get; }
    internal EventHandler`1<ServiceMsgHandlerEventArgs> Handler { get; }
    internal Func`1<JSONNode> StatsDataSupplier { get; }
    internal Endpoint Endpoint { get; }
    public string Name { get; }
    public string Subject { get; }
    public string QueueGroup { get; }
    public IDictionary`2<string, string> Metadata { get; }
    public string GroupName { get; }
    internal ServiceEndpoint(ServiceEndpointBuilder b, Endpoint e);
    internal ServiceEndpoint(Endpoint endpoint, EventHandler`1<ServiceMsgHandlerEventArgs> handler);
    [CompilerGeneratedAttribute]
internal Group get_Group();
    [CompilerGeneratedAttribute]
internal EventHandler`1<ServiceMsgHandlerEventArgs> get_Handler();
    [CompilerGeneratedAttribute]
internal Func`1<JSONNode> get_StatsDataSupplier();
    [CompilerGeneratedAttribute]
internal Endpoint get_Endpoint();
    public string get_Name();
    public string get_Subject();
    public string get_QueueGroup();
    public IDictionary`2<string, string> get_Metadata();
    public string get_GroupName();
    public static ServiceEndpointBuilder Builder();
    protected bool Equals(ServiceEndpoint other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class NATS.Client.Service.ServiceException : Exception {
    [CompilerGeneratedAttribute]
private int <Code>k__BackingField;
    public int Code { get; }
    internal ServiceException(string message, int code);
    [CompilerGeneratedAttribute]
public int get_Code();
    internal static ServiceException GetInstance(Exception e);
}
public class NATS.Client.Service.ServiceMsg : object {
    public static string NatsServiceError;
    public static string NatsServiceErrorCode;
    private Msg msg;
    public string Subject { get; }
    public string Reply { get; }
    public bool HasHeaders { get; }
    public MsgHeader Header { get; }
    public Byte[] Data { get; }
    internal ServiceMsg(Msg msg);
    public string get_Subject();
    public string get_Reply();
    public bool get_HasHeaders();
    public MsgHeader get_Header();
    public Byte[] get_Data();
    public void Respond(IConnection conn, Byte[] response);
    public void Respond(IConnection conn, string response);
    public void Respond(IConnection conn, JsonSerializable response);
    public void Respond(IConnection conn, JSONNode response);
    public void Respond(IConnection conn, Byte[] response, MsgHeader headers);
    public void Respond(IConnection conn, string response, MsgHeader headers);
    public void Respond(IConnection conn, JsonSerializable response, MsgHeader headers);
    public void Respond(IConnection conn, JSONNode response, MsgHeader headers);
    public void RespondStandardError(IConnection conn, string errorText, int errorCode);
}
public class NATS.Client.Service.ServiceMsgHandlerEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private ServiceMsg <Message>k__BackingField;
    public ServiceMsg Message { get; }
    public ServiceMsgHandlerEventArgs(ServiceMsg message);
    [CompilerGeneratedAttribute]
public ServiceMsg get_Message();
}
public abstract class NATS.Client.Service.ServiceResponse : JsonSerializable {
    internal IDictionary`2<string, string> _metadata;
    [CompilerGeneratedAttribute]
private string <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Version>k__BackingField;
    public string Type { get; }
    public string Id { get; }
    public string Name { get; }
    public string Version { get; }
    public IDictionary`2<string, string> Metadata { get; }
    internal ServiceResponse(string type, string id, string name, string version, IDictionary`2<string, string> metadata);
    internal ServiceResponse(string type, ServiceResponse template);
    internal ServiceResponse(string type, JSONNode node);
    [CompilerGeneratedAttribute]
public string get_Type();
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public string get_Version();
    public IDictionary`2<string, string> get_Metadata();
    protected JSONObject BaseJsonObject();
    protected bool Equals(ServiceResponse other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class NATS.Client.Service.StatsResponse : ServiceResponse {
    public static string ResponseType;
    [CompilerGeneratedAttribute]
private DateTime <Started>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<EndpointStats> <EndpointStatsList>k__BackingField;
    public DateTime Started { get; }
    public IList`1<EndpointStats> EndpointStatsList { get; }
    internal StatsResponse(ServiceResponse template, DateTime started, IList`1<EndpointStats> endpointStatsList);
    internal StatsResponse(string json);
    internal StatsResponse(JSONNode node);
    [CompilerGeneratedAttribute]
public DateTime get_Started();
    [CompilerGeneratedAttribute]
public IList`1<EndpointStats> get_EndpointStatsList();
    public virtual JSONNode ToJsonNode();
    protected bool Equals(StatsResponse other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class NATS.Client.SidGenerator : object {
    private static InterlockedLong Generator;
    private static SidGenerator();
    internal static long Next();
}
internal class NATS.Client.SingleUseChannel`1 : object {
    private static ConcurrentBag`1<SingleUseChannel`1<T>> Channels;
    private ManualResetEventSlim e;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) hasValue;
    private T actualValue;
    private static SingleUseChannel`1();
    public static SingleUseChannel`1<T> GetOrCreate();
    public static void Return(SingleUseChannel`1<T> ch);
    internal T get(int timeout);
    internal void add(T value);
    internal void reset();
}
public class NATS.Client.Srv : object {
    public static string DefaultScheme;
    public static int DefaultPort;
    public static int NoPortSpecified;
    [CompilerGeneratedAttribute]
private Uri <Url>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsImplicit>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Secure>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <LastAttempt>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DidConnect>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Reconnects>k__BackingField;
    public Uri Url { get; private set; }
    public bool IsImplicit { get; }
    public bool Secure { get; }
    public DateTime LastAttempt { get; private set; }
    public bool DidConnect { get; public set; }
    public int Reconnects { get; public set; }
    public TimeSpan TimeSinceLastAttempt { get; }
    public Srv(string urlString);
    public Srv(string urlString, bool isUrlImplicit);
    [CompilerGeneratedAttribute]
public Uri get_Url();
    [CompilerGeneratedAttribute]
private void set_Url(Uri value);
    [CompilerGeneratedAttribute]
public bool get_IsImplicit();
    [CompilerGeneratedAttribute]
public bool get_Secure();
    [CompilerGeneratedAttribute]
public DateTime get_LastAttempt();
    [CompilerGeneratedAttribute]
private void set_LastAttempt(DateTime value);
    [CompilerGeneratedAttribute]
public bool get_DidConnect();
    [CompilerGeneratedAttribute]
public void set_DidConnect(bool value);
    [CompilerGeneratedAttribute]
public int get_Reconnects();
    [CompilerGeneratedAttribute]
public void set_Reconnects(int value);
    internal void SetUrl(string urlString);
    public void UpdateLastAttempt();
    public TimeSpan get_TimeSinceLastAttempt();
    public virtual string ToString();
}
public class NATS.Client.Statistics : object {
    internal long inMsgs;
    internal long outMsgs;
    internal long inBytes;
    internal long outBytes;
    internal long reconnects;
    public long InMsgs { get; }
    public long OutMsgs { get; }
    public long InBytes { get; }
    public long OutBytes { get; }
    public long Reconnects { get; }
    internal Statistics(Statistics obj);
    public sealed virtual long get_InMsgs();
    public sealed virtual long get_OutMsgs();
    public sealed virtual long get_InBytes();
    public sealed virtual long get_OutBytes();
    public sealed virtual long get_Reconnects();
    internal void clear();
}
public class NATS.Client.StatusEventArgs : ConnJsSubEventArgs {
    [CompilerGeneratedAttribute]
private MsgStatus <Status>k__BackingField;
    public MsgStatus Status { get; }
    public StatusEventArgs(Connection c, Subscription s, MsgStatus status);
    [CompilerGeneratedAttribute]
public MsgStatus get_Status();
}
[ExtensionAttribute]
internal static class NATS.Client.StreamExtensions : object {
    [ExtensionAttribute]
internal static string ReadUntilCrlf(Stream stream);
}
public class NATS.Client.StringUserJWTHandler : object {
    [CompilerGeneratedAttribute]
private string <UserJwt>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NkeySeed>k__BackingField;
    public string UserJwt { get; }
    public string NkeySeed { get; }
    public StringUserJWTHandler(string credentialsText);
    public StringUserJWTHandler(string userJwt, string nkeySeed);
    [CompilerGeneratedAttribute]
public string get_UserJwt();
    [CompilerGeneratedAttribute]
public string get_NkeySeed();
    public void DefaultUserJWTEventHandler(object sender, UserJWTEventArgs args);
    public void SignNonce(UserSignatureEventArgs args);
    public void DefaultUserSignatureHandler(object sender, UserSignatureEventArgs args);
}
public class NATS.Client.Subscription : object {
    internal object mu;
    internal long sid;
    private long msgs;
    internal long delivered;
    private long bytes;
    internal long max;
    internal bool sc;
    internal Connection conn;
    internal bool closed;
    internal bool connClosed;
    internal Channel`1<Msg> mch;
    internal bool ownsChannel;
    internal long pendingMessages;
    internal long pendingBytes;
    internal long pendingMessagesMax;
    internal long pendingBytesMax;
    internal long pendingMessagesLimit;
    internal long pendingBytesLimit;
    internal long dropped;
    private string subject;
    internal Func`2<Msg, bool> _beforeChannelAddCheck;
    private string queue;
    private bool disposedValue;
    private static Char[] invalidSubjectChars;
    internal Func`2<Msg, bool> BeforeChannelAddCheck { get; internal set; }
    public long Sid { get; }
    public string Subject { get; }
    public string Queue { get; }
    public Connection Connection { get; }
    public bool IsValid { get; }
    public int QueuedMessageCount { get; }
    public long PendingByteLimit { get; public set; }
    public long PendingMessageLimit { get; public set; }
    public long PendingBytes { get; }
    public long PendingMessages { get; }
    public long MaxPendingBytes { get; }
    public long MaxPendingMessages { get; }
    public long Delivered { get; }
    public long Dropped { get; }
    internal Subscription(Connection conn, string subject, string queue);
    private static Subscription();
    internal Func`2<Msg, bool> get_BeforeChannelAddCheck();
    internal void set_BeforeChannelAddCheck(Func`2<Msg, bool> value);
    internal void ReSubscribe(string deliverSubject);
    internal virtual void close();
    internal void close(bool closeChannel);
    public sealed virtual long get_Sid();
    public sealed virtual string get_Subject();
    public sealed virtual string get_Queue();
    internal string SubName();
    public sealed virtual Connection get_Connection();
    internal bool tallyMessage(long bytes);
    internal virtual bool processMsg(Msg msg);
    private void handleSlowConsumer(Msg msg);
    protected long tallyDeliveredMessage(Msg msg);
    internal bool addMessage(Msg msg);
    public sealed virtual bool get_IsValid();
    internal void unsubscribe(bool throwEx);
    public virtual void Unsubscribe();
    public virtual void AutoUnsubscribe(int max);
    public sealed virtual int get_QueuedMessageCount();
    protected virtual void Dispose(bool disposing);
    public sealed virtual void Dispose();
    public virtual string ToString();
    private void checkState();
    public sealed virtual void SetPendingLimits(long messageLimit, long bytesLimit);
    private void SetPendingByteLimitInternal(long bytesLimit);
    private void SetPendingMessageLimitInternal(long messageLimit);
    public sealed virtual long get_PendingByteLimit();
    public sealed virtual void set_PendingByteLimit(long value);
    public sealed virtual long get_PendingMessageLimit();
    public sealed virtual void set_PendingMessageLimit(long value);
    public sealed virtual void GetPending(Int64& pendingBytes, Int64& pendingMessages);
    public sealed virtual long get_PendingBytes();
    public sealed virtual long get_PendingMessages();
    public sealed virtual void GetMaxPending(Int64& maxPendingBytes, Int64& maxPendingMessages);
    public sealed virtual long get_MaxPendingBytes();
    public sealed virtual long get_MaxPendingMessages();
    public sealed virtual void ClearMaxPending();
    internal Task InternalDrain(int timeout);
    public sealed virtual Task DrainAsync();
    public sealed virtual Task DrainAsync(int timeout);
    public sealed virtual void Drain();
    public sealed virtual void Drain(int timeout);
    public sealed virtual long get_Delivered();
    public sealed virtual long get_Dropped();
    private static bool ContainsInvalidChars(string value);
    public static bool IsValidSubject(string subject);
    public static bool IsValidPrefix(string prefix);
    public static bool IsValidQueueGroupName(string queueGroup);
}
public class NATS.Client.SyncSubscription : Subscription {
    internal SyncSubscription(Connection conn, string subject, string queue);
    public virtual Msg NextMessage();
    public virtual Msg NextMessage(int timeout);
    protected Msg NextMessageImpl(int timeout);
}
public class NATS.Client.UnhandledStatusEventArgs : StatusEventArgs {
    public UnhandledStatusEventArgs(Connection c, Subscription s, MsgStatus status);
}
public class NATS.Client.UserJWTEventArgs : EventArgs {
    private string jwt;
    internal string JWT { get; public set; }
    public void set_JWT(string value);
    internal string get_JWT();
}
public class NATS.Client.UserSignatureEventArgs : EventArgs {
    private Byte[] signedNonce;
    private Byte[] serverNonce;
    public Byte[] ServerNonce { get; }
    internal Byte[] SignedNonce { get; public set; }
    internal UserSignatureEventArgs(Byte[] nonce);
    public Byte[] get_ServerNonce();
    public void set_SignedNonce(Byte[] value);
    internal Byte[] get_SignedNonce();
}
