[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class NuGet.NoAllocEnumerateExtensions : object {
    [ExtensionAttribute]
public static OptimisticallyNonAllocatingListEnumerable`1<T> NoAllocEnumerate(IList`1<T> list);
    [ExtensionAttribute]
public static OptimisticallyNonAllocatingEnumerable`1<T> NoAllocEnumerate(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static OptimisticallyNonAllocatingDictionaryEnumerable`2<TKey, TValue> NoAllocEnumerate(IDictionary`2<TKey, TValue> dictionary);
}
public class NuGet.PackageManagement.ActionEventBase : TelemetryEvent {
    public String[] ProjectIds;
    public string OperationId { get; }
    public int PackagesCount { get; }
    public NuGetOperationStatus Status { get; }
    public string StartTime { get; }
    public string EndTime { get; }
    public double Duration { get; }
    public int ProjectsCount { get; }
    public ActionEventBase(string eventName, string operationId, String[] projectIds, DateTimeOffset startTime, NuGetOperationStatus status, int packageCount, DateTimeOffset endTime, double duration);
    public string get_OperationId();
    public int get_PackagesCount();
    public NuGetOperationStatus get_Status();
    public string get_StartTime();
    public string get_EndTime();
    public double get_Duration();
    public int get_ProjectsCount();
}
public class NuGet.PackageManagement.ActionsExecutedEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private IEnumerable`1<ResolvedAction> <Actions>k__BackingField;
    public IEnumerable`1<ResolvedAction> Actions { get; }
    public ActionsExecutedEventArgs(IEnumerable`1<ResolvedAction> actions);
    [CompilerGeneratedAttribute]
public IEnumerable`1<ResolvedAction> get_Actions();
}
public class NuGet.PackageManagement.ActionsTelemetryEvent : ActionEventBase {
    public static string NugetActionEventName;
    public NuGetProjectActionType OperationType { get; }
    public ActionsTelemetryEvent(string operationId, String[] projectIds, NuGetProjectActionType operationType, DateTimeOffset startTime, NuGetOperationStatus status, int packageCount, DateTimeOffset endTime, double duration);
    public NuGetProjectActionType get_OperationType();
}
public class NuGet.PackageManagement.ActionTelemetryStepEvent : TelemetryEvent {
    public static string NugetActionStepsEventName;
    public string SubStepName { get; }
    public double Duration { get; }
    public string ParentId { get; }
    public ActionTelemetryStepEvent(string parentId, string stepName, double duration);
    public string get_SubStepName();
    public double get_Duration();
    public string get_ParentId();
}
public class NuGet.PackageManagement.AssetsFileMissingStatusChanged : MulticastDelegate {
    public AssetsFileMissingStatusChanged(object object, IntPtr method);
    public virtual void Invoke(object sender, bool isAssetsFileMissing);
    public virtual IAsyncResult BeginInvoke(object sender, bool isAssetsFileMissing, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NuGet.PackageManagement.AuditUtility : object {
    private IEnumerable`1<PackageRestoreData> _packages;
    private List`1<SourceRepository> _sourceRepositories;
    private ILogger _logger;
    private SourceCacheContext _sourceCacheContext;
    private PackageVulnerabilitySeverity _minSeverity;
    public AuditUtility(PackageVulnerabilitySeverity minSeverity, IEnumerable`1<PackageRestoreData> packages, List`1<SourceRepository> sourceRepositories, SourceCacheContext sourceCacheContext, ILogger logger);
    [AsyncStateMachineAttribute("NuGet.PackageManagement.AuditUtility/<CheckPackageVulnerabilitiesAsync>d__6")]
public Task CheckPackageVulnerabilitiesAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.PackageManagement.AuditUtility/<GetAllVulnerabilityDataAsync>d__7")]
internal static Task`1<GetVulnerabilityInfoResult> GetAllVulnerabilityDataAsync(List`1<SourceRepository> sourceRepositories, SourceCacheContext sourceCacheContext, ILogger logger, CancellationToken cancellationToken);
    internal static void CreateWarningsForPackagesWithVulnerabilities(Dictionary`2<PackageIdentity, PackageAuditInfo> packagesWithKnownVulnerabilities, ILogger logger);
    internal static Dictionary`2<PackageIdentity, PackageAuditInfo> FindPackagesWithKnownVulnerabilities(IReadOnlyList`1<IReadOnlyDictionary`2<string, IReadOnlyList`1<PackageVulnerabilityInfo>>> knownVulnerabilities, IEnumerable`1<PackageRestoreData> packages, PackageVulnerabilitySeverity minSeverity);
    internal static List`1<PackageVulnerabilityInfo> GetKnownVulnerabilities(string name, NuGetVersion version, IReadOnlyList`1<IReadOnlyDictionary`2<string, IReadOnlyList`1<PackageVulnerabilityInfo>>> knownVulnerabilities);
    internal static ValueTuple`2<string, NuGetLogCode> GetSeverityLabelAndCode(PackageVulnerabilitySeverity severity);
    [CompilerGeneratedAttribute]
internal static bool <CheckPackageVulnerabilitiesAsync>g__IsAnyVulnerabilityDataFound|6_0(IReadOnlyList`1<IReadOnlyDictionary`2<string, IReadOnlyList`1<PackageVulnerabilityInfo>>> knownVulnerabilities);
    [AsyncStateMachineAttribute("NuGet.PackageManagement.AuditUtility/<<GetAllVulnerabilityDataAsync>g__GetVulnerabilityInfoAsync|7_0>d")]
[CompilerGeneratedAttribute]
internal static Task`1<GetVulnerabilityInfoResult> <GetAllVulnerabilityDataAsync>g__GetVulnerabilityInfoAsync|7_0(SourceRepository source, SourceCacheContext cacheContext, ILogger logger);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NuGet.PackageManagement.BuildIntegratedProjectAction : NuGetProjectAction {
    [CompilerGeneratedAttribute]
private LockFile <OriginalLockFile>k__BackingField;
    [CompilerGeneratedAttribute]
private RestoreResult <RestoreResult>k__BackingField;
    [CompilerGeneratedAttribute]
private RestoreResultPair <RestoreResultPair>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<SourceRepository> <Sources>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<NuGetProjectAction> <OriginalActions>k__BackingField;
    [CompilerGeneratedAttribute]
private BuildIntegratedInstallationContext <InstallationContext>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private IReadOnlyList`1<ValueTuple`2<NuGetProjectAction, BuildIntegratedInstallationContext>> <ActionAndContextList>k__BackingField;
    public LockFile OriginalLockFile { get; }
    public RestoreResult RestoreResult { get; }
    public RestoreResultPair RestoreResultPair { get; }
    public IReadOnlyList`1<SourceRepository> Sources { get; }
    [ObsoleteAttribute("The internal ActionAndContextList property should be used.")]
public IReadOnlyList`1<NuGetProjectAction> OriginalActions { get; }
    [ObsoleteAttribute("The internal ActionAndContextList property should be used.")]
public BuildIntegratedInstallationContext InstallationContext { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal IReadOnlyList`1<ValueTuple`2<NuGetProjectAction, BuildIntegratedInstallationContext>> ActionAndContextList { get; }
    [ObsoleteAttribute("This type is not expected to be created externally.")]
public BuildIntegratedProjectAction(NuGetProject project, PackageIdentity packageIdentity, NuGetProjectActionType nuGetProjectActionType, LockFile originalLockFile, RestoreResultPair restoreResultPair, IReadOnlyList`1<SourceRepository> sources, IReadOnlyList`1<NuGetProjectAction> originalActions, BuildIntegratedInstallationContext installationContext);
    [ObsoleteAttribute("This type is not expected to be created externally.")]
public BuildIntegratedProjectAction(NuGetProject project, PackageIdentity packageIdentity, NuGetProjectActionType nuGetProjectActionType, LockFile originalLockFile, RestoreResultPair restoreResultPair, IReadOnlyList`1<SourceRepository> sources, IReadOnlyList`1<NuGetProjectAction> originalActions, BuildIntegratedInstallationContext installationContext, VersionRange versionRange);
    internal BuildIntegratedProjectAction(NuGetProject project, PackageIdentity packageIdentity, NuGetProjectActionType nuGetProjectActionType, LockFile originalLockFile, RestoreResultPair restoreResultPair, IReadOnlyList`1<SourceRepository> sources, IReadOnlyList`1<ValueTuple`2<NuGetProjectAction, BuildIntegratedInstallationContext>> originalActionsAndInstallationContexts, VersionRange versionRange);
    [CompilerGeneratedAttribute]
public LockFile get_OriginalLockFile();
    [CompilerGeneratedAttribute]
public RestoreResult get_RestoreResult();
    [CompilerGeneratedAttribute]
public RestoreResultPair get_RestoreResultPair();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<SourceRepository> get_Sources();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<NuGetProjectAction> get_OriginalActions();
    [CompilerGeneratedAttribute]
public BuildIntegratedInstallationContext get_InstallationContext();
    [CompilerGeneratedAttribute]
internal IReadOnlyList`1<ValueTuple`2<NuGetProjectAction, BuildIntegratedInstallationContext>> get_ActionAndContextList();
    public IReadOnlyList`1<NuGetProjectAction> GetProjectActions();
}
public static class NuGet.PackageManagement.BuildIntegratedRestoreUtility : object {
    [AsyncStateMachineAttribute("NuGet.PackageManagement.BuildIntegratedRestoreUtility/<ExecuteInitPs1ScriptsAsync>d__0")]
public static Task ExecuteInitPs1ScriptsAsync(BuildIntegratedNuGetProject project, IEnumerable`1<PackageIdentity> packages, FallbackPackagePathResolver pathResolver, INuGetProjectContext projectContext, CancellationToken token);
    public static IReadOnlyList`1<PackageIdentity> GetAddedPackages(LockFile originalLockFile, LockFile updatedLockFile);
    public static IReadOnlyList`1<BuildIntegratedNuGetProject> GetParentProjectsInClosure(IReadOnlyList`1<BuildIntegratedNuGetProject> projects, BuildIntegratedNuGetProject target, DependencyGraphSpec cache);
    public static void UpdatePackageReferenceMetadata(LockFile lockFile, FallbackPackagePathResolver pathResolver, PackageIdentity package);
}
public static class NuGet.PackageManagement.DependencyGraphRestoreUtility : object {
    public static Task`1<IReadOnlyList`1<RestoreSummary>> RestoreAsync(ISolutionManager solutionManager, DependencyGraphSpec dgSpec, DependencyGraphCacheContext context, RestoreCommandProvidersCache providerCache, Action`1<SourceCacheContext> cacheContextModifier, IEnumerable`1<SourceRepository> sources, Guid parentId, bool forceRestore, bool isRestoreOriginalAction, ILogger log, CancellationToken token);
    [ObsoleteAttribute("This method will be removed in a future release. Use other one of the other RestoreAsync methods.")]
public static Task`1<IReadOnlyList`1<RestoreSummary>> RestoreAsync(ISolutionManager solutionManager, DependencyGraphSpec dgSpec, DependencyGraphCacheContext context, RestoreCommandProvidersCache providerCache, Action`1<SourceCacheContext> cacheContextModifier, IEnumerable`1<SourceRepository> sources, Guid parentId, bool forceRestore, bool isRestoreOriginalAction, IReadOnlyList`1<IAssetsLogMessage> additionalMessages, ILogger log, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.PackageManagement.DependencyGraphRestoreUtility/<RestoreAsync>d__2")]
public static Task`1<IReadOnlyList`1<RestoreSummary>> RestoreAsync(DependencyGraphSpec dgSpec, DependencyGraphCacheContext context, RestoreCommandProvidersCache providerCache, Action`1<SourceCacheContext> cacheContextModifier, IEnumerable`1<SourceRepository> sources, Guid parentId, bool forceRestore, bool isRestoreOriginalAction, IReadOnlyList`1<IAssetsLogMessage> additionalMessages, IRestoreProgressReporter progressReporter, ILogger log, CancellationToken token);
    [ObsoleteAttribute]
public static string GetDefaultDGSpecFileName();
    [AsyncStateMachineAttribute("NuGet.PackageManagement.DependencyGraphRestoreUtility/<PreviewRestoreAsync>d__4")]
internal static Task`1<RestoreResultPair> PreviewRestoreAsync(ISolutionManager solutionManager, BuildIntegratedNuGetProject project, PackageSpec packageSpec, DependencyGraphCacheContext context, RestoreCommandProvidersCache providerCache, Action`1<SourceCacheContext> cacheContextModifier, IEnumerable`1<SourceRepository> sources, Guid parentId, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.PackageManagement.DependencyGraphRestoreUtility/<PreviewRestoreProjectsAsync>d__5")]
internal static Task`1<IEnumerable`1<RestoreResultPair>> PreviewRestoreProjectsAsync(ISolutionManager solutionManager, IEnumerable`1<BuildIntegratedNuGetProject> projects, IEnumerable`1<PackageSpec> updatedNugetPackageSpecs, DependencyGraphCacheContext context, RestoreCommandProvidersCache providerCache, Action`1<SourceCacheContext> cacheContextModifier, IEnumerable`1<SourceRepository> sources, Guid parentId, ILogger log, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.PackageManagement.DependencyGraphRestoreUtility/<RestoreProjectAsync>d__6")]
[ObsoleteAttribute("This is an unused method and will be removed in a future release.")]
public static Task`1<RestoreResult> RestoreProjectAsync(ISolutionManager solutionManager, BuildIntegratedNuGetProject project, DependencyGraphCacheContext context, RestoreCommandProvidersCache providerCache, Action`1<SourceCacheContext> cacheContextModifier, IEnumerable`1<SourceRepository> sources, Guid parentId, ILogger log, CancellationToken token);
    public static bool IsRestoreRequired(DependencyGraphSpec solutionDgSpec);
    [AsyncStateMachineAttribute("NuGet.PackageManagement.DependencyGraphRestoreUtility/<GetProjectSpec>d__8")]
public static Task`1<PackageSpec> GetProjectSpec(IDependencyGraphProject project, DependencyGraphCacheContext context);
    [AsyncStateMachineAttribute("NuGet.PackageManagement.DependencyGraphRestoreUtility/<GetSolutionRestoreSpec>d__9")]
public static Task`1<DependencyGraphSpec> GetSolutionRestoreSpec(ISolutionManager solutionManager, DependencyGraphCacheContext context);
    [AsyncStateMachineAttribute("NuGet.PackageManagement.DependencyGraphRestoreUtility/<GetSolutionRestoreSpecAndAdditionalMessages>d__10")]
public static Task`1<ValueTuple`2<DependencyGraphSpec, IReadOnlyList`1<IAssetsLogMessage>>> GetSolutionRestoreSpecAndAdditionalMessages(ISolutionManager solutionManager, DependencyGraphCacheContext context);
    private static RestoreArgs GetRestoreArgs(DependencyGraphCacheContext context, RestoreCommandProvidersCache providerCache, SourceCacheContext sourceCacheContext, IEnumerable`1<SourceRepository> sources, DependencyGraphSpec dgFile, Guid parentId, bool forceRestore, bool isRestoreOriginalAction, bool restoreForceEvaluate, IReadOnlyList`1<IAssetsLogMessage> additionalMessasges, IRestoreProgressReporter progressReporter);
}
public static class NuGet.PackageManagement.ExceptionUtility : object {
    public static Exception GetRootException(Exception exception);
    public static Exception Unwrap(Exception exception);
}
public class NuGet.PackageManagement.GatherCache : object {
    private ConcurrentDictionary`2<GatherSingleCacheKey, SourcePackageDependencyInfo> _singleVersion;
    private ConcurrentDictionary`2<GatherAllCacheKey, List`1<SourcePackageDependencyInfo>> _allPackageVersions;
    public void AddPackageFromSingleVersionLookup(PackageSource source, PackageIdentity identity, NuGetFramework framework, SourcePackageDependencyInfo package);
    public void AddAllPackagesForId(PackageSource source, string packageId, NuGetFramework framework, List`1<SourcePackageDependencyInfo> packages);
    public GatherCacheResult GetPackage(PackageSource source, PackageIdentity package, NuGetFramework framework);
    public GatherCacheResult GetPackages(PackageSource source, string packageId, NuGetFramework framework);
}
public class NuGet.PackageManagement.GatherCacheResult : object {
    [CompilerGeneratedAttribute]
private bool <HasEntry>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<SourcePackageDependencyInfo> <Packages>k__BackingField;
    public bool HasEntry { get; }
    public IReadOnlyList`1<SourcePackageDependencyInfo> Packages { get; }
    public GatherCacheResult(bool hasEntry, IReadOnlyList`1<SourcePackageDependencyInfo> packages);
    [CompilerGeneratedAttribute]
public bool get_HasEntry();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<SourcePackageDependencyInfo> get_Packages();
}
public class NuGet.PackageManagement.GatherContext : object {
    [CompilerGeneratedAttribute]
private NuGetFramework <TargetFramework>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<SourceRepository> <PrimarySources>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<SourceRepository> <AllSources>k__BackingField;
    [CompilerGeneratedAttribute]
private SourceRepository <PackagesFolderSource>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<string> <PrimaryTargetIds>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<PackageIdentity> <PrimaryTargets>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<PackageIdentity> <InstalledPackages>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowDowngrades>k__BackingField;
    [CompilerGeneratedAttribute]
private ResolutionContext <ResolutionContext>k__BackingField;
    [CompilerGeneratedAttribute]
private INuGetProjectContext <ProjectContext>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsUpdateAll>k__BackingField;
    [CompilerGeneratedAttribute]
private PackageSourceMapping <PackageSourceMapping>k__BackingField;
    public NuGetFramework TargetFramework { get; public set; }
    public IReadOnlyList`1<SourceRepository> PrimarySources { get; public set; }
    public IReadOnlyList`1<SourceRepository> AllSources { get; public set; }
    public SourceRepository PackagesFolderSource { get; public set; }
    public IReadOnlyList`1<string> PrimaryTargetIds { get; public set; }
    public IReadOnlyList`1<PackageIdentity> PrimaryTargets { get; public set; }
    public IReadOnlyList`1<PackageIdentity> InstalledPackages { get; public set; }
    public bool AllowDowngrades { get; public set; }
    public ResolutionContext ResolutionContext { get; public set; }
    public INuGetProjectContext ProjectContext { get; public set; }
    public bool IsUpdateAll { get; public set; }
    public PackageSourceMapping PackageSourceMapping { get; }
    public ILogger Log { get; }
    public GatherContext(PackageSourceMapping _packageSourceMappingConfiguration);
    [CompilerGeneratedAttribute]
public NuGetFramework get_TargetFramework();
    [CompilerGeneratedAttribute]
public void set_TargetFramework(NuGetFramework value);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<SourceRepository> get_PrimarySources();
    [CompilerGeneratedAttribute]
public void set_PrimarySources(IReadOnlyList`1<SourceRepository> value);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<SourceRepository> get_AllSources();
    [CompilerGeneratedAttribute]
public void set_AllSources(IReadOnlyList`1<SourceRepository> value);
    [CompilerGeneratedAttribute]
public SourceRepository get_PackagesFolderSource();
    [CompilerGeneratedAttribute]
public void set_PackagesFolderSource(SourceRepository value);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<string> get_PrimaryTargetIds();
    [CompilerGeneratedAttribute]
public void set_PrimaryTargetIds(IReadOnlyList`1<string> value);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<PackageIdentity> get_PrimaryTargets();
    [CompilerGeneratedAttribute]
public void set_PrimaryTargets(IReadOnlyList`1<PackageIdentity> value);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<PackageIdentity> get_InstalledPackages();
    [CompilerGeneratedAttribute]
public void set_InstalledPackages(IReadOnlyList`1<PackageIdentity> value);
    [CompilerGeneratedAttribute]
public bool get_AllowDowngrades();
    [CompilerGeneratedAttribute]
public void set_AllowDowngrades(bool value);
    [CompilerGeneratedAttribute]
public ResolutionContext get_ResolutionContext();
    [CompilerGeneratedAttribute]
public void set_ResolutionContext(ResolutionContext value);
    [CompilerGeneratedAttribute]
public INuGetProjectContext get_ProjectContext();
    [CompilerGeneratedAttribute]
public void set_ProjectContext(INuGetProjectContext value);
    [CompilerGeneratedAttribute]
public bool get_IsUpdateAll();
    [CompilerGeneratedAttribute]
public void set_IsUpdateAll(bool value);
    [CompilerGeneratedAttribute]
public PackageSourceMapping get_PackageSourceMapping();
    public ILogger get_Log();
}
public static class NuGet.PackageManagement.GatherExceptionHelpers : object {
    public static void ThrowIfVersionIsDisallowedByPackagesConfig(string target, IEnumerable`1<PackageReference> packagesConfig, IEnumerable`1<PackageDependencyInfo> availablePackages, ILogger logger);
    public static void ThrowIfVersionIsDisallowedByPackagesConfig(IEnumerable`1<string> targets, IEnumerable`1<PackageReference> packagesConfig, IEnumerable`1<PackageDependencyInfo> availablePackages, ILogger logger);
    public static void ThrowIfNewerVersionAlreadyReferenced(string target, IEnumerable`1<PackageReference> packagesConfig, IEnumerable`1<PackageDependencyInfo> availablePackages);
}
public interface NuGet.PackageManagement.ICommonOperations {
    public abstract virtual Task OpenFile(string fullPath);
    public abstract virtual Task SaveSolutionExplorerNodeStates(ISolutionManager solutionManager);
    public abstract virtual Task CollapseAllNodes(ISolutionManager solutionManager);
}
public class NuGet.PackageManagement.IDEExecutionContext : ExecutionContext {
    [CompilerGeneratedAttribute]
private ICommonOperations <CommonOperations>k__BackingField;
    public ICommonOperations CommonOperations { get; }
    public PackageIdentity IDEDirectInstall { get; public set; }
    public IDEExecutionContext(ICommonOperations commonOperations);
    [CompilerGeneratedAttribute]
public ICommonOperations get_CommonOperations();
    [AsyncStateMachineAttribute("NuGet.PackageManagement.IDEExecutionContext/<OpenFile>d__4")]
public virtual Task OpenFile(string fullPath);
    [AsyncStateMachineAttribute("NuGet.PackageManagement.IDEExecutionContext/<SaveExpandedNodeStates>d__5")]
public Task SaveExpandedNodeStates(ISolutionManager solutionManager);
    [AsyncStateMachineAttribute("NuGet.PackageManagement.IDEExecutionContext/<CollapseAllNodes>d__6")]
public Task CollapseAllNodes(ISolutionManager solutionManager);
    public PackageIdentity get_IDEDirectInstall();
    public void set_IDEDirectInstall(PackageIdentity value);
}
public interface NuGet.PackageManagement.IDeleteOnRestartManager {
    public abstract virtual IReadOnlyList`1<string> GetPackageDirectoriesMarkedForDeletion();
    public abstract virtual void CheckAndRaisePackageDirectoriesMarkedForDeletion();
    public abstract virtual void MarkPackageDirectoryForDeletion(PackageIdentity package, string packageDirectory, INuGetProjectContext projectContext);
    public abstract virtual Task DeleteMarkedPackageDirectoriesAsync(INuGetProjectContext projectContext);
    [CompilerGeneratedAttribute]
public abstract virtual void add_PackagesMarkedForDeletionFound(EventHandler`1<PackagesMarkedForDeletionEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_PackagesMarkedForDeletionFound(EventHandler`1<PackagesMarkedForDeletionEventArgs> value);
}
public interface NuGet.PackageManagement.IInstallationCompatibility {
    public abstract virtual void EnsurePackageCompatibility(NuGetProject nuGetProject, INuGetPathContext pathContext, IEnumerable`1<NuGetProjectAction> nuGetProjectActions, RestoreResult restoreResult);
    public abstract virtual Task EnsurePackageCompatibilityAsync(NuGetProject nuGetProject, PackageIdentity packageIdentity, DownloadResourceResult resourceResult, CancellationToken cancellationToken);
}
public class NuGet.PackageManagement.InstallationCompatibility : object {
    private static InstallationCompatibility _instance;
    public static InstallationCompatibility Instance { get; }
    public static InstallationCompatibility get_Instance();
    public sealed virtual void EnsurePackageCompatibility(NuGetProject nuGetProject, INuGetPathContext pathContext, IEnumerable`1<NuGetProjectAction> nuGetProjectActions, RestoreResult restoreResult);
    [AsyncStateMachineAttribute("NuGet.PackageManagement.InstallationCompatibility/<EnsurePackageCompatibilityAsync>d__4")]
public sealed virtual Task EnsurePackageCompatibilityAsync(NuGetProject nuGetProject, PackageIdentity packageIdentity, DownloadResourceResult resourceResult, CancellationToken cancellationToken);
    private static void EnsurePackageCompatibility(NuGetProject nuGetProject, PackageIdentity packageIdentity, NuspecReader nuspecReader);
}
public interface NuGet.PackageManagement.IPackageProjectEventsProvider {
    public abstract virtual PackageProjectEvents GetPackageProjectEvents();
}
public interface NuGet.PackageManagement.IPackageRestoreManager {
    [CompilerGeneratedAttribute]
public abstract virtual void add_PackagesMissingStatusChanged(EventHandler`1<PackagesMissingStatusEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_PackagesMissingStatusChanged(EventHandler`1<PackagesMissingStatusEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_AssetsFileMissingStatusChanged(AssetsFileMissingStatusChanged value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_AssetsFileMissingStatusChanged(AssetsFileMissingStatusChanged value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_PackageRestoredEvent(EventHandler`1<PackageRestoredEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_PackageRestoredEvent(EventHandler`1<PackageRestoredEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_PackageRestoreFailedEvent(EventHandler`1<PackageRestoreFailedEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_PackageRestoreFailedEvent(EventHandler`1<PackageRestoreFailedEventArgs> value);
    public abstract virtual Task`1<IEnumerable`1<PackageRestoreData>> GetPackagesInSolutionAsync(string solutionDirectory, CancellationToken token);
    public abstract virtual IEnumerable`1<PackageRestoreData> GetPackagesRestoreData(string solutionDirectory, Dictionary`2<PackageReference, List`1<string>> packageReferencesDict);
    public abstract virtual Task RaisePackagesMissingEventForSolutionAsync(string solutionDirectory, CancellationToken token);
    public abstract virtual void RaiseAssetsFileMissingEventForProjectAsync(bool isAssetsFileMissing);
    public abstract virtual Task`1<PackageRestoreResult> RestoreMissingPackagesInSolutionAsync(string solutionDirectory, INuGetProjectContext nuGetProjectContext, ILogger logger, CancellationToken token);
    public abstract virtual Task`1<PackageRestoreResult> RestoreMissingPackagesInSolutionAsync(string solutionDirectory, INuGetProjectContext nuGetProjectContext, CancellationToken token);
    public abstract virtual Task`1<PackageRestoreResult> RestoreMissingPackagesAsync(string solutionDirectory, IEnumerable`1<PackageRestoreData> packages, INuGetProjectContext nuGetProjectContext, PackageDownloadContext downloadContext, ILogger logger, CancellationToken token);
    public abstract virtual Task`1<PackageRestoreResult> RestoreMissingPackagesAsync(string solutionDirectory, IEnumerable`1<PackageRestoreData> packages, INuGetProjectContext nuGetProjectContext, PackageDownloadContext downloadContext, CancellationToken token);
}
internal interface NuGet.PackageManagement.IPackagesConfigContentHashProvider {
    public abstract virtual string GetContentHash(PackageIdentity packageIdentity, CancellationToken token);
}
public interface NuGet.PackageManagement.IProductUpdateService {
    public abstract virtual void CheckForAvailableUpdateAsync();
    public abstract virtual void Update();
    public abstract virtual void DeclineUpdate(bool doNotRemindAgain);
    [CompilerGeneratedAttribute]
public abstract virtual void add_UpdateAvailable(EventHandler`1<ProductUpdateAvailableEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_UpdateAvailable(EventHandler`1<ProductUpdateAvailableEventArgs> value);
}
public interface NuGet.PackageManagement.ISolutionManager {
    public string SolutionDirectory { get; }
    public bool IsSolutionOpen { get; }
    public INuGetProjectContext NuGetProjectContext { get; public set; }
    [CompilerGeneratedAttribute]
public abstract virtual void add_SolutionOpening(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_SolutionOpening(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_SolutionOpened(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_SolutionOpened(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_SolutionClosing(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_SolutionClosing(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_SolutionClosed(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_SolutionClosed(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_AfterNuGetCacheUpdated(EventHandler`1<NuGetEventArgs`1<string>> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_AfterNuGetCacheUpdated(EventHandler`1<NuGetEventArgs`1<string>> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_NuGetProjectAdded(EventHandler`1<NuGetProjectEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_NuGetProjectAdded(EventHandler`1<NuGetProjectEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_NuGetProjectRemoved(EventHandler`1<NuGetProjectEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_NuGetProjectRemoved(EventHandler`1<NuGetProjectEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_NuGetProjectRenamed(EventHandler`1<NuGetProjectEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_NuGetProjectRenamed(EventHandler`1<NuGetProjectEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_NuGetProjectUpdated(EventHandler`1<NuGetProjectEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_NuGetProjectUpdated(EventHandler`1<NuGetProjectEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_AfterNuGetProjectRenamed(EventHandler`1<NuGetProjectEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_AfterNuGetProjectRenamed(EventHandler`1<NuGetProjectEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_ActionsExecuted(EventHandler`1<ActionsExecutedEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_ActionsExecuted(EventHandler`1<ActionsExecutedEventArgs> value);
    public abstract virtual string get_SolutionDirectory();
    public abstract virtual bool get_IsSolutionOpen();
    public abstract virtual Task`1<bool> IsSolutionAvailableAsync();
    public abstract virtual INuGetProjectContext get_NuGetProjectContext();
    public abstract virtual void set_NuGetProjectContext(INuGetProjectContext value);
    public abstract virtual Task`1<IEnumerable`1<NuGetProject>> GetNuGetProjectsAsync();
    public abstract virtual Task`1<string> GetNuGetProjectSafeNameAsync(NuGetProject nuGetProject);
    public abstract virtual Task`1<NuGetProject> GetNuGetProjectAsync(string nuGetProjectSafeName);
    public abstract virtual void OnActionsExecuted(IEnumerable`1<ResolvedAction> actions);
    public abstract virtual void EnsureSolutionIsLoaded();
    public abstract virtual Task`1<bool> DoesNuGetSupportsAnyProjectAsync();
}
[ExtensionAttribute]
public static class NuGet.PackageManagement.LogUtility : object {
    public static MessageLevel LogLevelToMessageLevel(LogLevel level);
    [ExtensionAttribute]
internal static RestoreLogMessage AsRestoreLogMessage(IAssetsLogMessage logMessage);
}
public class NuGet.PackageManagement.NuGetEventArgs`1 : EventArgs {
    [CompilerGeneratedAttribute]
private T <Arg>k__BackingField;
    public T Arg { get; }
    public NuGetEventArgs`1(T arg);
    [CompilerGeneratedAttribute]
public T get_Arg();
}
public class NuGet.PackageManagement.NuGetPackageManager : object {
    private IReadOnlyList`1<SourceRepository> _globalPackageFolderRepositories;
    [CompilerGeneratedAttribute]
private ISourceRepositoryProvider <SourceRepositoryProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private ISolutionManager <SolutionManager>k__BackingField;
    [CompilerGeneratedAttribute]
private ISettings <Settings>k__BackingField;
    private HashSet`1<string> _buildIntegratedProjectsUpdateSet;
    private DependencyGraphSpec _buildIntegratedProjectsCache;
    private RestoreCommandProvidersCache _restoreProviderCache;
    [CompilerGeneratedAttribute]
private IDeleteOnRestartManager <DeleteOnRestartManager>k__BackingField;
    [CompilerGeneratedAttribute]
private FolderNuGetProject <PackagesFolderNuGetProject>k__BackingField;
    [CompilerGeneratedAttribute]
private SourceRepository <PackagesFolderSourceRepository>k__BackingField;
    [CompilerGeneratedAttribute]
private IInstallationCompatibility <InstallationCompatibility>k__BackingField;
    [CompilerGeneratedAttribute]
private IRestoreProgressReporter <RestoreProgressReporter>k__BackingField;
    [CompilerGeneratedAttribute]
private EventHandler`1<PackageProjectEventArgs> BatchStart;
    [CompilerGeneratedAttribute]
private EventHandler`1<PackageProjectEventArgs> BatchEnd;
    private ISourceRepositoryProvider SourceRepositoryProvider { get; }
    private ISolutionManager SolutionManager { get; }
    private ISettings Settings { get; }
    public IDeleteOnRestartManager DeleteOnRestartManager { get; }
    public FolderNuGetProject PackagesFolderNuGetProject { get; public set; }
    public SourceRepository PackagesFolderSourceRepository { get; public set; }
    public IInstallationCompatibility InstallationCompatibility { get; public set; }
    private IRestoreProgressReporter RestoreProgressReporter { get; }
    public IReadOnlyList`1<SourceRepository> GlobalPackageFolderRepositories { get; }
    public NuGetPackageManager(ISourceRepositoryProvider sourceRepositoryProvider, ISettings settings, string packagesFolderPath);
    public NuGetPackageManager(ISourceRepositoryProvider sourceRepositoryProvider, ISettings settings, string packagesFolderPath, bool excludeVersion);
    public NuGetPackageManager(ISourceRepositoryProvider sourceRepositoryProvider, ISettings settings, ISolutionManager solutionManager, IDeleteOnRestartManager deleteOnRestartManager);
    public NuGetPackageManager(ISourceRepositoryProvider sourceRepositoryProvider, ISettings settings, ISolutionManager solutionManager, IDeleteOnRestartManager deleteOnRestartManager, bool excludeVersion);
    public NuGetPackageManager(ISourceRepositoryProvider sourceRepositoryProvider, ISettings settings, ISolutionManager solutionManager, IDeleteOnRestartManager deleteOnRestartManager, IRestoreProgressReporter reporter);
    public NuGetPackageManager(ISourceRepositoryProvider sourceRepositoryProvider, ISettings settings, ISolutionManager solutionManager, IDeleteOnRestartManager deleteOnRestartManager, IRestoreProgressReporter reporter, bool excludeVersion);
    [CompilerGeneratedAttribute]
private ISourceRepositoryProvider get_SourceRepositoryProvider();
    [CompilerGeneratedAttribute]
private ISolutionManager get_SolutionManager();
    [CompilerGeneratedAttribute]
private ISettings get_Settings();
    [CompilerGeneratedAttribute]
public IDeleteOnRestartManager get_DeleteOnRestartManager();
    [CompilerGeneratedAttribute]
public FolderNuGetProject get_PackagesFolderNuGetProject();
    [CompilerGeneratedAttribute]
public void set_PackagesFolderNuGetProject(FolderNuGetProject value);
    [CompilerGeneratedAttribute]
public SourceRepository get_PackagesFolderSourceRepository();
    [CompilerGeneratedAttribute]
public void set_PackagesFolderSourceRepository(SourceRepository value);
    [CompilerGeneratedAttribute]
public IInstallationCompatibility get_InstallationCompatibility();
    [CompilerGeneratedAttribute]
public void set_InstallationCompatibility(IInstallationCompatibility value);
    [CompilerGeneratedAttribute]
private IRestoreProgressReporter get_RestoreProgressReporter();
    [CompilerGeneratedAttribute]
public void add_BatchStart(EventHandler`1<PackageProjectEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_BatchStart(EventHandler`1<PackageProjectEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_BatchEnd(EventHandler`1<PackageProjectEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_BatchEnd(EventHandler`1<PackageProjectEventArgs> value);
    public IReadOnlyList`1<SourceRepository> get_GlobalPackageFolderRepositories();
    private void InitializePackagesFolderInfo(string packagesFolderPath, bool excludeVersion);
    public Task InstallPackageAsync(NuGetProject nuGetProject, string packageId, ResolutionContext resolutionContext, INuGetProjectContext nuGetProjectContext, SourceRepository primarySourceRepository, IEnumerable`1<SourceRepository> secondarySources, CancellationToken token);
    public Task InstallPackageAsync(NuGetProject nuGetProject, string packageId, ResolutionContext resolutionContext, INuGetProjectContext nuGetProjectContext, PackageDownloadContext downloadContext, SourceRepository primarySourceRepository, IEnumerable`1<SourceRepository> secondarySources, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.PackageManagement.NuGetPackageManager/<InstallPackageAsync>d__48")]
public Task InstallPackageAsync(NuGetProject nuGetProject, string packageId, ResolutionContext resolutionContext, INuGetProjectContext nuGetProjectContext, IEnumerable`1<SourceRepository> primarySources, IEnumerable`1<SourceRepository> secondarySources, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.PackageManagement.NuGetPackageManager/<InstallPackageAsync>d__49")]
public Task InstallPackageAsync(NuGetProject nuGetProject, string packageId, ResolutionContext resolutionContext, INuGetProjectContext nuGetProjectContext, PackageDownloadContext downloadContext, IEnumerable`1<SourceRepository> primarySources, IEnumerable`1<SourceRepository> secondarySources, CancellationToken token);
    public Task InstallPackageAsync(NuGetProject nuGetProject, PackageIdentity packageIdentity, ResolutionContext resolutionContext, INuGetProjectContext nuGetProjectContext, SourceRepository primarySourceRepository, IEnumerable`1<SourceRepository> secondarySources, CancellationToken token);
    public Task InstallPackageAsync(NuGetProject nuGetProject, PackageIdentity packageIdentity, ResolutionContext resolutionContext, INuGetProjectContext nuGetProjectContext, PackageDownloadContext downloadContext, SourceRepository primarySourceRepository, IEnumerable`1<SourceRepository> secondarySources, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.PackageManagement.NuGetPackageManager/<InstallPackageAsync>d__52")]
public Task InstallPackageAsync(NuGetProject nuGetProject, PackageIdentity packageIdentity, ResolutionContext resolutionContext, INuGetProjectContext nuGetProjectContext, IEnumerable`1<SourceRepository> primarySources, IEnumerable`1<SourceRepository> secondarySources, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.PackageManagement.NuGetPackageManager/<InstallPackageAsync>d__53")]
public Task InstallPackageAsync(NuGetProject nuGetProject, PackageIdentity packageIdentity, ResolutionContext resolutionContext, INuGetProjectContext nuGetProjectContext, PackageDownloadContext downloadContext, IEnumerable`1<SourceRepository> primarySources, IEnumerable`1<SourceRepository> secondarySources, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.PackageManagement.NuGetPackageManager/<UninstallPackageAsync>d__54")]
public Task UninstallPackageAsync(NuGetProject nuGetProject, string packageId, UninstallationContext uninstallationContext, INuGetProjectContext nuGetProjectContext, CancellationToken token);
    public Task`1<IEnumerable`1<NuGetProjectAction>> PreviewInstallPackageAsync(NuGetProject nuGetProject, string packageId, ResolutionContext resolutionContext, INuGetProjectContext nuGetProjectContext, SourceRepository primarySourceRepository, IEnumerable`1<SourceRepository> secondarySources, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.PackageManagement.NuGetPackageManager/<PreviewInstallPackageAsync>d__56")]
public Task`1<IEnumerable`1<NuGetProjectAction>> PreviewInstallPackageAsync(NuGetProject nuGetProject, string packageId, ResolutionContext resolutionContext, INuGetProjectContext nuGetProjectContext, IEnumerable`1<SourceRepository> primarySources, IEnumerable`1<SourceRepository> secondarySources, CancellationToken token);
    public Task`1<IEnumerable`1<NuGetProjectAction>> PreviewUpdatePackagesAsync(IEnumerable`1<NuGetProject> nuGetProjects, ResolutionContext resolutionContext, INuGetProjectContext nuGetProjectContext, IEnumerable`1<SourceRepository> primarySources, IEnumerable`1<SourceRepository> secondarySources, CancellationToken token);
    public Task`1<IEnumerable`1<NuGetProjectAction>> PreviewUpdatePackagesAsync(string packageId, IEnumerable`1<NuGetProject> nuGetProjects, ResolutionContext resolutionContext, INuGetProjectContext nuGetProjectContext, IEnumerable`1<SourceRepository> primarySources, IEnumerable`1<SourceRepository> secondarySources, CancellationToken token);
    public Task`1<IEnumerable`1<NuGetProjectAction>> PreviewUpdatePackagesAsync(PackageIdentity packageIdentity, IEnumerable`1<NuGetProject> nuGetProjects, ResolutionContext resolutionContext, INuGetProjectContext nuGetProjectContext, IEnumerable`1<SourceRepository> primarySources, IEnumerable`1<SourceRepository> secondarySources, CancellationToken token);
    public Task`1<IEnumerable`1<NuGetProjectAction>> PreviewUpdatePackagesAsync(List`1<PackageIdentity> packageIdentities, IEnumerable`1<NuGetProject> nuGetProjects, ResolutionContext resolutionContext, INuGetProjectContext nuGetProjectContext, IEnumerable`1<SourceRepository> primarySources, IEnumerable`1<SourceRepository> secondarySources, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.PackageManagement.NuGetPackageManager/<PreviewUpdatePackagesAsync>d__61")]
private Task`1<IEnumerable`1<NuGetProjectAction>> PreviewUpdatePackagesAsync(string packageId, List`1<PackageIdentity> packageIdentities, IEnumerable`1<NuGetProject> nuGetProjects, ResolutionContext resolutionContext, INuGetProjectContext nuGetProjectContext, IEnumerable`1<SourceRepository> primarySources, IEnumerable`1<SourceRepository> secondarySources, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.PackageManagement.NuGetPackageManager/<GetPackagesToUpdateInProjectAsync>d__62")]
private Task`1<List`1<PackageIdentity>> GetPackagesToUpdateInProjectAsync(NuGetProject project, List`1<PackageIdentity> packages, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.PackageManagement.NuGetPackageManager/<CompleteTaskAsync>d__63`1")]
private Task`1<IEnumerable`1<T>> CompleteTaskAsync(List`1<Task`1<IEnumerable`1<T>>> updateTasks);
    [AsyncStateMachineAttribute("NuGet.PackageManagement.NuGetPackageManager/<PreviewUpdatePackagesForBuildIntegratedAsync>d__64")]
private Task`1<IEnumerable`1<NuGetProjectAction>> PreviewUpdatePackagesForBuildIntegratedAsync(string packageId, IReadOnlyList`1<PackageIdentity> packageIdentities, NuGetProject nuGetProject, ResolutionContext resolutionContext, INuGetProjectContext nuGetProjectContext, IEnumerable`1<SourceRepository> primarySources, CancellationToken token);
    private static bool IsPackageReferenceAutoReferenced(PackageReference package);
    [AsyncStateMachineAttribute("NuGet.PackageManagement.NuGetPackageManager/<PreviewUpdatePackagesForClassicAsync>d__66")]
private Task`1<IEnumerable`1<NuGetProjectAction>> PreviewUpdatePackagesForClassicAsync(string packageId, IReadOnlyList`1<PackageIdentity> packageIdentities, NuGetProject nuGetProject, ResolutionContext resolutionContext, INuGetProjectContext nuGetProjectContext, IEnumerable`1<SourceRepository> primarySources, IEnumerable`1<SourceRepository> secondarySources, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.PackageManagement.NuGetPackageManager/<GetInstalledPackagesDependencyInfo>d__67")]
public Task`1<IEnumerable`1<PackageDependencyInfo>> GetInstalledPackagesDependencyInfo(NuGetProject nuGetProject, CancellationToken token, bool includeUnresolved);
    [AsyncStateMachineAttribute("NuGet.PackageManagement.NuGetPackageManager/<GetInstalledPackagesInDependencyOrder>d__68")]
public Task`1<IEnumerable`1<PackageIdentity>> GetInstalledPackagesInDependencyOrder(NuGetProject nuGetProject, CancellationToken token);
    private static List`1<NuGetProjectAction> GetProjectActionsForUpdate(NuGetProject project, IEnumerable`1<PackageIdentity> newListOfInstalledPackages, IEnumerable`1<PackageIdentity> oldListOfInstalledPackages, IEnumerable`1<SourcePackageDependencyInfo> availablePackageDependencyInfoWithSourceSet, INuGetProjectContext nuGetProjectContext, bool isReinstall, IEnumerable`1<string> targetIds, bool isDependencyBehaviorIgnore);
    private static HashSet`1<string> GetDependencies(IEnumerable`1<string> targetIds, IEnumerable`1<PackageIdentity> newListOfInstalledPackages, IEnumerable`1<SourcePackageDependencyInfo> available);
    private static void CollectDependencies(HashSet`1<string> result, string id, IEnumerable`1<PackageIdentity> packages, IEnumerable`1<SourcePackageDependencyInfo> available, int depth);
    [AsyncStateMachineAttribute("NuGet.PackageManagement.NuGetPackageManager/<PreviewInstallPackageAsync>d__72")]
public Task`1<IEnumerable`1<NuGetProjectAction>> PreviewInstallPackageAsync(NuGetProject nuGetProject, PackageIdentity packageIdentity, ResolutionContext resolutionContext, INuGetProjectContext nuGetProjectContext, SourceRepository primarySourceRepository, IEnumerable`1<SourceRepository> secondarySources, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.PackageManagement.NuGetPackageManager/<PreviewProjectsInstallPackageAsync>d__73")]
public Task`1<IEnumerable`1<ResolvedAction>> PreviewProjectsInstallPackageAsync(IReadOnlyCollection`1<NuGetProject> nuGetProjects, PackageIdentity packageIdentity, ResolutionContext resolutionContext, INuGetProjectContext nuGetProjectContext, IReadOnlyCollection`1<SourceRepository> activeSources, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.PackageManagement.NuGetPackageManager/<PreviewProjectsInstallPackageAsync>d__74")]
public Task`1<IEnumerable`1<ResolvedAction>> PreviewProjectsInstallPackageAsync(IReadOnlyCollection`1<NuGetProject> nuGetProjects, PackageIdentity packageIdentity, ResolutionContext resolutionContext, INuGetProjectContext nuGetProjectContext, IReadOnlyCollection`1<SourceRepository> activeSources, VersionRange versionRange, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.PackageManagement.NuGetPackageManager/<PreviewProjectsInstallPackageAsync>d__75")]
public Task`1<IEnumerable`1<ResolvedAction>> PreviewProjectsInstallPackageAsync(IReadOnlyCollection`1<NuGetProject> nuGetProjects, PackageIdentity packageIdentity, ResolutionContext resolutionContext, INuGetProjectContext nuGetProjectContext, IReadOnlyCollection`1<SourceRepository> activeSources, VersionRange versionRange, string newMappingID, string newMappingSource, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.PackageManagement.NuGetPackageManager/<PreviewInstallPackageAsync>d__76")]
public Task`1<IEnumerable`1<NuGetProjectAction>> PreviewInstallPackageAsync(NuGetProject nuGetProject, PackageIdentity packageIdentity, ResolutionContext resolutionContext, INuGetProjectContext nuGetProjectContext, IEnumerable`1<SourceRepository> primarySources, IEnumerable`1<SourceRepository> secondarySources, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.PackageManagement.NuGetPackageManager/<PreviewInstallPackageAsync>d__77")]
public Task`1<IEnumerable`1<NuGetProjectAction>> PreviewInstallPackageAsync(NuGetProject nuGetProject, PackageIdentity packageIdentity, ResolutionContext resolutionContext, INuGetProjectContext nuGetProjectContext, IEnumerable`1<SourceRepository> primarySources, IEnumerable`1<SourceRepository> secondarySources, VersionRange versionRange, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.PackageManagement.NuGetPackageManager/<GetSourceRepository>d__78")]
private static Task`1<SourceRepository> GetSourceRepository(PackageIdentity packageIdentity, IEnumerable`1<SourceRepository> sourceRepositories, SourceCacheContext sourceCacheContext, ILogger logger);
    [AsyncStateMachineAttribute("NuGet.PackageManagement.NuGetPackageManager/<PreviewProjectsUninstallPackageAsync>d__79")]
public Task`1<IEnumerable`1<NuGetProjectAction>> PreviewProjectsUninstallPackageAsync(IReadOnlyCollection`1<NuGetProject> nuGetProjects, string packageId, UninstallationContext uninstallationContext, INuGetProjectContext nuGetProjectContext, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.PackageManagement.NuGetPackageManager/<PreviewBuildIntegratedNuGetProjectsUninstallPackageInternalAsync>d__80")]
private Task`1<IEnumerable`1<NuGetProjectAction>> PreviewBuildIntegratedNuGetProjectsUninstallPackageInternalAsync(IReadOnlyList`1<BuildIntegratedNuGetProject> buildIntegratedProjects, string packageId, INuGetProjectContext nuGetProjectContext, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.PackageManagement.NuGetPackageManager/<PreviewUninstallPackageAsync>d__81")]
public Task`1<IEnumerable`1<NuGetProjectAction>> PreviewUninstallPackageAsync(NuGetProject nuGetProject, string packageId, UninstallationContext uninstallationContext, INuGetProjectContext nuGetProjectContext, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.PackageManagement.NuGetPackageManager/<PreviewUninstallPackageAsync>d__82")]
public Task`1<IEnumerable`1<NuGetProjectAction>> PreviewUninstallPackageAsync(NuGetProject nuGetProject, PackageIdentity packageIdentity, UninstallationContext uninstallationContext, INuGetProjectContext nuGetProjectContext, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.PackageManagement.NuGetPackageManager/<PreviewUninstallPackageInternalAsync>d__83")]
private Task`1<IEnumerable`1<NuGetProjectAction>> PreviewUninstallPackageInternalAsync(NuGetProject nuGetProject, PackageReference packageReference, UninstallationContext uninstallationContext, INuGetProjectContext nuGetProjectContext, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.PackageManagement.NuGetPackageManager/<GetDependencyInfoFromPackagesFolderAsync>d__84")]
private Task`1<IEnumerable`1<PackageDependencyInfo>> GetDependencyInfoFromPackagesFolderAsync(IEnumerable`1<PackageIdentity> packageIdentities, NuGetFramework nuGetFramework, bool includeUnresolved);
    [AsyncStateMachineAttribute("NuGet.PackageManagement.NuGetPackageManager/<ExecuteNuGetProjectActionsAsync>d__85")]
public Task ExecuteNuGetProjectActionsAsync(IEnumerable`1<NuGetProject> nuGetProjects, IEnumerable`1<NuGetProjectAction> nuGetProjectActions, INuGetProjectContext nuGetProjectContext, SourceCacheContext sourceCacheContext, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.PackageManagement.NuGetPackageManager/<ExecuteNuGetProjectActionsAsync>d__86")]
public Task ExecuteNuGetProjectActionsAsync(NuGetProject nuGetProject, IEnumerable`1<NuGetProjectAction> nuGetProjectActions, INuGetProjectContext nuGetProjectContext, SourceCacheContext sourceCacheContext, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.PackageManagement.NuGetPackageManager/<ExecuteNuGetProjectActionsAsync>d__87")]
public Task ExecuteNuGetProjectActionsAsync(NuGetProject nuGetProject, IEnumerable`1<NuGetProjectAction> nuGetProjectActions, INuGetProjectContext nuGetProjectContext, PackageDownloadContext downloadContext, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.PackageManagement.NuGetPackageManager/<PreviewBuildIntegratedProjectActionsAsync>d__88")]
public Task`1<BuildIntegratedProjectAction> PreviewBuildIntegratedProjectActionsAsync(BuildIntegratedNuGetProject buildIntegratedProject, IEnumerable`1<NuGetProjectAction> nuGetProjectActions, INuGetProjectContext nuGetProjectContext, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.PackageManagement.NuGetPackageManager/<PreviewBuildIntegratedProjectsActionsAsync>d__89")]
internal Task`1<IEnumerable`1<ResolvedAction>> PreviewBuildIntegratedProjectsActionsAsync(IReadOnlyCollection`1<BuildIntegratedNuGetProject> buildIntegratedProjects, Dictionary`2<string, NuGetProjectAction[]> nugetProjectActionsLookup, PackageIdentity packageIdentity, IReadOnlyCollection`1<SourceRepository> primarySources, INuGetProjectContext nuGetProjectContext, VersionRange versionRange, string newMappingID, string newMappingSource, CancellationToken token);
    internal static BuildIntegratedInstallationContext CreateInstallationContextForPackageId(string packageIdentityId, PackageSpec packageSpec, PackageSpec originalPackageSpec, List`1<NuGetFramework> unsuccessfulFrameworks, Dictionary`2<NuGetFramework, string> originalFrameworks);
    private static bool DoesPackageAppearWithDifferentVersions(string packageIdentityId, PackageSpec packageSpec);
    private void AddNewPackageSourceMappingToSettings(string newMappingID, string newMappingSource, PackageSourceMappingProvider mappingProvider);
    [AsyncStateMachineAttribute("NuGet.PackageManagement.NuGetPackageManager/<ExecuteBuildIntegratedProjectActionsAsync>d__93")]
public Task ExecuteBuildIntegratedProjectActionsAsync(BuildIntegratedNuGetProject buildIntegratedProject, IEnumerable`1<NuGetProjectAction> nuGetProjectActions, INuGetProjectContext nuGetProjectContext, CancellationToken token);
    private static IReadOnlyList`1<string> GetFilesToBeUpdated(RestoreResultPair result);
    [AsyncStateMachineAttribute("NuGet.PackageManagement.NuGetPackageManager/<RollbackAsync>d__95")]
private Task RollbackAsync(NuGetProject nuGetProject, Stack`1<NuGetProjectAction> executedNuGetProjectActions, HashSet`1<PackageIdentity> packageWithDirectoriesToBeDeleted, INuGetProjectContext nuGetProjectContext, CancellationToken token);
    private Task OpenReadmeFile(NuGetProject nuGetProject, INuGetProjectContext nuGetProjectContext, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.PackageManagement.NuGetPackageManager/<RestorePackageAsync>d__97")]
public Task`1<bool> RestorePackageAsync(PackageIdentity packageIdentity, INuGetProjectContext nuGetProjectContext, PackageDownloadContext downloadContext, IEnumerable`1<SourceRepository> sourceRepositories, CancellationToken token);
    public Task`1<bool> CopySatelliteFilesAsync(PackageIdentity packageIdentity, INuGetProjectContext nuGetProjectContext, CancellationToken token);
    public bool PackageExistsInPackagesFolder(PackageIdentity packageIdentity, PackageSaveMode packageSaveMode);
    public bool PackageExistsInPackagesFolder(PackageIdentity packageIdentity);
    [AsyncStateMachineAttribute("NuGet.PackageManagement.NuGetPackageManager/<ExecuteInstallAsync>d__101")]
private Task ExecuteInstallAsync(NuGetProject nuGetProject, PackageIdentity packageIdentity, DownloadResourceResult resourceResult, HashSet`1<PackageIdentity> packageWithDirectoriesToBeDeleted, INuGetProjectContext nuGetProjectContext, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.PackageManagement.NuGetPackageManager/<ExecuteUninstallAsync>d__102")]
private Task ExecuteUninstallAsync(NuGetProject nuGetProject, PackageIdentity packageIdentity, HashSet`1<PackageIdentity> packageWithDirectoriesToBeDeleted, INuGetProjectContext nuGetProjectContext, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.PackageManagement.NuGetPackageManager/<PackageExistsInAnotherNuGetProject>d__103")]
public static Task`1<bool> PackageExistsInAnotherNuGetProject(NuGetProject nuGetProject, PackageIdentity packageIdentity, ISolutionManager solutionManager, CancellationToken token, bool excludeIntegrated);
    [AsyncStateMachineAttribute("NuGet.PackageManagement.NuGetPackageManager/<DeletePackageAsync>d__104")]
private Task`1<bool> DeletePackageAsync(PackageIdentity packageIdentity, INuGetProjectContext nuGetProjectContext, CancellationToken token);
    public static Task`1<ResolvedPackage> GetLatestVersionAsync(string packageId, NuGetFramework framework, ResolutionContext resolutionContext, SourceRepository primarySourceRepository, ILogger log, CancellationToken token);
    public static Task`1<ResolvedPackage> GetLatestVersionAsync(string packageId, NuGetProject project, ResolutionContext resolutionContext, SourceRepository primarySourceRepository, ILogger log, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.PackageManagement.NuGetPackageManager/<GetLatestVersionAsync>d__107")]
public static Task`1<ResolvedPackage> GetLatestVersionAsync(string packageId, NuGetProject project, ResolutionContext resolutionContext, IEnumerable`1<SourceRepository> sources, ILogger log, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.PackageManagement.NuGetPackageManager/<GetLatestVersionAsync>d__108")]
public static Task`1<ResolvedPackage> GetLatestVersionAsync(string packageId, NuGetFramework framework, ResolutionContext resolutionContext, IEnumerable`1<SourceRepository> sources, ILogger log, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.PackageManagement.NuGetPackageManager/<GetLatestVersionAsync>d__109")]
public static Task`1<ResolvedPackage> GetLatestVersionAsync(PackageReference package, NuGetFramework framework, ResolutionContext resolutionContext, IEnumerable`1<SourceRepository> sources, ILogger log, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.PackageManagement.NuGetPackageManager/<GetLatestVersionCoreAsync>d__110")]
private static Task`1<ResolvedPackage> GetLatestVersionCoreAsync(string packageId, NuGetVersion version, NuGetFramework framework, ResolutionContext resolutionContext, SourceRepository source, ILogger log, CancellationToken token);
    private IEnumerable`1<SourceRepository> GetEffectiveSources(IEnumerable`1<SourceRepository> primarySources, IEnumerable`1<SourceRepository> secondarySources);
    public static void SetDirectInstall(PackageIdentity directInstall, INuGetProjectContext nuGetProjectContext);
    public static void ClearDirectInstall(INuGetProjectContext nuGetProjectContext);
    private RestoreCommandProvidersCache GetRestoreProviderCache();
}
[DebuggerDisplayAttribute("{NuGetProjectActionType} {PackageIdentity}")]
public class NuGet.PackageManagement.NuGetProjectAction : object {
    [CompilerGeneratedAttribute]
private PackageIdentity <PackageIdentity>k__BackingField;
    [CompilerGeneratedAttribute]
private VersionRange <VersionRange>k__BackingField;
    [CompilerGeneratedAttribute]
private NuGetProjectActionType <NuGetProjectActionType>k__BackingField;
    [CompilerGeneratedAttribute]
private SourceRepository <SourceRepository>k__BackingField;
    [CompilerGeneratedAttribute]
private NuGetProject <Project>k__BackingField;
    public PackageIdentity PackageIdentity { get; private set; }
    public VersionRange VersionRange { get; private set; }
    public NuGetProjectActionType NuGetProjectActionType { get; private set; }
    public SourceRepository SourceRepository { get; private set; }
    public NuGetProject Project { get; private set; }
    protected NuGetProjectAction(PackageIdentity packageIdentity, NuGetProjectActionType nuGetProjectActionType, NuGetProject project, SourceRepository sourceRepository);
    protected NuGetProjectAction(PackageIdentity packageIdentity, NuGetProjectActionType nuGetProjectActionType, NuGetProject project, SourceRepository sourceRepository, VersionRange versionRange);
    [CompilerGeneratedAttribute]
public PackageIdentity get_PackageIdentity();
    [CompilerGeneratedAttribute]
private void set_PackageIdentity(PackageIdentity value);
    [CompilerGeneratedAttribute]
public VersionRange get_VersionRange();
    [CompilerGeneratedAttribute]
private void set_VersionRange(VersionRange value);
    [CompilerGeneratedAttribute]
public NuGetProjectActionType get_NuGetProjectActionType();
    [CompilerGeneratedAttribute]
private void set_NuGetProjectActionType(NuGetProjectActionType value);
    [CompilerGeneratedAttribute]
public SourceRepository get_SourceRepository();
    [CompilerGeneratedAttribute]
private void set_SourceRepository(SourceRepository value);
    [CompilerGeneratedAttribute]
public NuGetProject get_Project();
    [CompilerGeneratedAttribute]
private void set_Project(NuGetProject value);
    public static NuGetProjectAction CreateInstallProjectAction(PackageIdentity packageIdentity, SourceRepository sourceRepository, NuGetProject project);
    public static NuGetProjectAction CreateInstallProjectAction(PackageIdentity packageIdentity, SourceRepository sourceRepository, NuGetProject project, VersionRange versionRange);
    public static NuGetProjectAction CreateUninstallProjectAction(PackageIdentity packageIdentity, NuGetProject project);
}
public enum NuGet.PackageManagement.NuGetProjectActionType : Enum {
    public int value__;
    public static NuGetProjectActionType Install;
    public static NuGetProjectActionType Uninstall;
    public static NuGetProjectActionType Update;
}
public class NuGet.PackageManagement.NuGetProjectEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private NuGetProject <NuGetProject>k__BackingField;
    public NuGetProject NuGetProject { get; private set; }
    public NuGetProjectEventArgs(NuGetProject nuGetProject);
    [CompilerGeneratedAttribute]
public NuGetProject get_NuGetProject();
    [CompilerGeneratedAttribute]
private void set_NuGetProject(NuGetProject value);
}
public class NuGet.PackageManagement.PackageAlreadyInstalledException : Exception {
    public PackageAlreadyInstalledException(string message);
}
public static class NuGet.PackageManagement.PackageDownloader : object {
    [AsyncStateMachineAttribute("NuGet.PackageManagement.PackageDownloader/<GetDownloadResourceResultAsync>d__0")]
public static Task`1<DownloadResourceResult> GetDownloadResourceResultAsync(IEnumerable`1<SourceRepository> sources, PackageIdentity packageIdentity, PackageDownloadContext downloadContext, string globalPackagesFolder, ILogger logger, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.PackageManagement.PackageDownloader/<GetDownloadResourceResultAsync>d__1")]
public static Task`1<DownloadResourceResult> GetDownloadResourceResultAsync(SourceRepository sourceRepository, PackageIdentity packageIdentity, PackageDownloadContext downloadContext, string globalPackagesFolder, ILogger logger, CancellationToken token);
}
public static class NuGet.PackageManagement.PackageGraphAnalysisUtilities : object {
    [AsyncStateMachineAttribute("NuGet.PackageManagement.PackageGraphAnalysisUtilities/<GetDependencyInfoForPackageIdentitiesAsync>d__0")]
public static Task`1<IEnumerable`1<PackageDependencyInfo>> GetDependencyInfoForPackageIdentitiesAsync(IEnumerable`1<PackageIdentity> packageIdentities, NuGetFramework nuGetFramework, DependencyInfoResource dependencyInfoResource, SourceCacheContext sourceCacheContext, bool includeUnresolved, ILogger logger, CancellationToken cancellationToken);
    public static IList`1<PackageDependencyInfo> GetDependantPackages(PackageDependencyInfo package, IList`1<PackageDependencyInfo> packageDependencyInfos);
    public static IList`1<PackageWithDependants> GetPackagesWithDependants(IList`1<PackageDependencyInfo> packageDependencyInfos);
}
public static class NuGet.PackageManagement.PackageManagementConstants : object {
    public static int DefaultMaxDegreeOfParallelism;
    public static TimeSpan DefaultRequestTimeout;
    private static PackageManagementConstants();
}
public class NuGet.PackageManagement.PackageManagementContext : object {
    [CompilerGeneratedAttribute]
private ISourceRepositoryProvider <SourceRepositoryProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private ISolutionManager <VsSolutionManager>k__BackingField;
    [CompilerGeneratedAttribute]
private ISettings <Settings>k__BackingField;
    [CompilerGeneratedAttribute]
private ISourceControlManagerProvider <SourceControlManagerProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private ICommonOperations <CommonOperations>k__BackingField;
    public ISourceRepositoryProvider SourceRepositoryProvider { get; private set; }
    public ISolutionManager VsSolutionManager { get; private set; }
    public ISettings Settings { get; private set; }
    public ISourceControlManagerProvider SourceControlManagerProvider { get; private set; }
    public ICommonOperations CommonOperations { get; private set; }
    public PackageManagementContext(ISourceRepositoryProvider sourceRepositoryProvider, ISolutionManager solutionManager, ISettings settings, ISourceControlManagerProvider sourceControlManagerProvider, ICommonOperations commonOperations);
    [CompilerGeneratedAttribute]
public ISourceRepositoryProvider get_SourceRepositoryProvider();
    [CompilerGeneratedAttribute]
private void set_SourceRepositoryProvider(ISourceRepositoryProvider value);
    [CompilerGeneratedAttribute]
public ISolutionManager get_VsSolutionManager();
    [CompilerGeneratedAttribute]
private void set_VsSolutionManager(ISolutionManager value);
    [CompilerGeneratedAttribute]
public ISettings get_Settings();
    [CompilerGeneratedAttribute]
private void set_Settings(ISettings value);
    [CompilerGeneratedAttribute]
public ISourceControlManagerProvider get_SourceControlManagerProvider();
    [CompilerGeneratedAttribute]
private void set_SourceControlManagerProvider(ISourceControlManagerProvider value);
    [CompilerGeneratedAttribute]
public ICommonOperations get_CommonOperations();
    [CompilerGeneratedAttribute]
private void set_CommonOperations(ICommonOperations value);
}
public static class NuGet.PackageManagement.PackagePreFetcher : object {
    [AsyncStateMachineAttribute("NuGet.PackageManagement.PackagePreFetcher/<GetPackagesAsync>d__0")]
public static Task`1<Dictionary`2<PackageIdentity, PackagePreFetcherResult>> GetPackagesAsync(IEnumerable`1<NuGetProjectAction> actions, FolderNuGetProject packagesFolder, PackageDownloadContext downloadContext, string globalPackagesFolder, ILogger logger, CancellationToken token);
    public static void LogFetchMessages(IEnumerable`1<PackagePreFetcherResult> fetchResults, string packagesFolderRoot, ILogger logger);
}
public class NuGet.PackageManagement.PackagePreFetcherResult : object {
    private Task`1<DownloadResourceResult> _downloadTask;
    private string _nupkgPath;
    private DownloadResourceResult _result;
    private ExceptionDispatchInfo _exception;
    private DateTimeOffset _downloadStartTime;
    private DateTimeOffset _packageFetchTime;
    private DateTimeOffset _taskReturnTime;
    private bool _disposed;
    [CompilerGeneratedAttribute]
private bool <InPackagesFolder>k__BackingField;
    [CompilerGeneratedAttribute]
private PackageIdentity <Package>k__BackingField;
    [CompilerGeneratedAttribute]
private PackageSource <Source>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsComplete>k__BackingField;
    public static string PackagePreFetcherInformation;
    public bool InPackagesFolder { get; }
    public PackageIdentity Package { get; }
    public PackageSource Source { get; }
    public bool IsComplete { get; private set; }
    public PackagePreFetcherResult(Task`1<DownloadResourceResult> downloadTask, PackageIdentity package, PackageSource source);
    public PackagePreFetcherResult(string nupkgPath, PackageIdentity package);
    [CompilerGeneratedAttribute]
public bool get_InPackagesFolder();
    [CompilerGeneratedAttribute]
public PackageIdentity get_Package();
    [CompilerGeneratedAttribute]
public PackageSource get_Source();
    [CompilerGeneratedAttribute]
public bool get_IsComplete();
    [CompilerGeneratedAttribute]
private void set_IsComplete(bool value);
    [AsyncStateMachineAttribute("NuGet.PackageManagement.PackagePreFetcherResult/<EnsureResultAsync>d__24")]
public Task EnsureResultAsync();
    [AsyncStateMachineAttribute("NuGet.PackageManagement.PackagePreFetcherResult/<GetResultAsync>d__25")]
public Task`1<DownloadResourceResult> GetResultAsync();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public void EmitTelemetryEvent(Guid parentId);
    private DownloadResourceResult GetPackagesFolderResult(string nupkgPath);
}
public class NuGet.PackageManagement.PackageProjectEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProjectPath>k__BackingField;
    public string Id { get; }
    public string Name { get; }
    public string ProjectPath { get; }
    public PackageProjectEventArgs(string id, string name, string projectPath);
    public PackageProjectEventArgs(string id, string name);
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public string get_ProjectPath();
}
public class NuGet.PackageManagement.PackageProjectEvents : object {
    [CompilerGeneratedAttribute]
private EventHandler`1<PackageProjectEventArgs> BatchStart;
    [CompilerGeneratedAttribute]
private EventHandler`1<PackageProjectEventArgs> BatchEnd;
    [CompilerGeneratedAttribute]
public void add_BatchStart(EventHandler`1<PackageProjectEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_BatchStart(EventHandler`1<PackageProjectEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_BatchEnd(EventHandler`1<PackageProjectEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_BatchEnd(EventHandler`1<PackageProjectEventArgs> value);
    internal void NotifyBatchStart(PackageProjectEventArgs e);
    internal void NotifyBatchEnd(PackageProjectEventArgs e);
}
[ExportAttribute("NuGet.PackageManagement.IPackageProjectEventsProvider")]
public class NuGet.PackageManagement.PackageProjectEventsProvider : object {
    private static PackageProjectEvents _instance;
    internal static PackageProjectEvents Instance { get; }
    public sealed virtual PackageProjectEvents GetPackageProjectEvents();
    internal static PackageProjectEvents get_Instance();
}
public class NuGet.PackageManagement.PackageReferenceComparer : object {
    [CompilerGeneratedAttribute]
private static PackageReferenceComparer <Instance>k__BackingField;
    public static PackageReferenceComparer Instance { get; }
    private static PackageReferenceComparer();
    [CompilerGeneratedAttribute]
public static PackageReferenceComparer get_Instance();
    public sealed virtual bool Equals(PackageReference x, PackageReference y);
    public sealed virtual int GetHashCode(PackageReference obj);
}
public class NuGet.PackageManagement.PackageReferenceRollbackException : InvalidOperationException {
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<ILogMessage> <LogMessages>k__BackingField;
    public IReadOnlyList`1<ILogMessage> LogMessages { get; }
    public PackageReferenceRollbackException(string message, IEnumerable`1<ILogMessage> logMessages);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<ILogMessage> get_LogMessages();
}
public class NuGet.PackageManagement.PackageRestoreConsent : object {
    private static string EnvironmentVariableName;
    private static string PackageRestoreSection;
    private static string PackageRestoreConsentKey;
    private static string PackageRestoreAutomaticKey;
    private ISettings _settings;
    private IEnvironmentVariableReader _environmentReader;
    private ConfigurationDefaults _configurationDefaults;
    public bool IsGranted { get; }
    public bool IsGrantedInSettings { get; public set; }
    public bool IsAutomatic { get; public set; }
    public PackageRestoreConsent(ISettings settings);
    public PackageRestoreConsent(ISettings settings, IEnvironmentVariableReader environmentReader);
    public PackageRestoreConsent(ISettings settings, IEnvironmentVariableReader environmentReader, ConfigurationDefaults configurationDefaults);
    public bool get_IsGranted();
    public bool get_IsGrantedInSettings();
    public void set_IsGrantedInSettings(bool value);
    public bool get_IsAutomatic();
    public void set_IsAutomatic(bool value);
    private static bool IsSet(string value, bool defaultValue);
}
public class NuGet.PackageManagement.PackageRestoreContext : object {
    [CompilerGeneratedAttribute]
private NuGetPackageManager <PackageManager>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<PackageRestoreData> <Packages>k__BackingField;
    [CompilerGeneratedAttribute]
private CancellationToken <Token>k__BackingField;
    [CompilerGeneratedAttribute]
private EventHandler`1<PackageRestoredEventArgs> <PackageRestoredEvent>k__BackingField;
    [CompilerGeneratedAttribute]
private EventHandler`1<PackageRestoreFailedEventArgs> <PackageRestoreFailedEvent>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<SourceRepository> <SourceRepositories>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxNumberOfParallelTasks>k__BackingField;
    [CompilerGeneratedAttribute]
private ILogger <Logger>k__BackingField;
    public NuGetPackageManager PackageManager { get; }
    public IEnumerable`1<PackageRestoreData> Packages { get; }
    public CancellationToken Token { get; }
    public EventHandler`1<PackageRestoredEventArgs> PackageRestoredEvent { get; }
    public EventHandler`1<PackageRestoreFailedEventArgs> PackageRestoreFailedEvent { get; }
    public IEnumerable`1<SourceRepository> SourceRepositories { get; }
    public int MaxNumberOfParallelTasks { get; }
    public ILogger Logger { get; }
    public PackageRestoreContext(NuGetPackageManager nuGetPackageManager, IEnumerable`1<PackageRestoreData> packages, CancellationToken token, EventHandler`1<PackageRestoredEventArgs> packageRestoredEvent, EventHandler`1<PackageRestoreFailedEventArgs> packageRestoreFailedEvent, IEnumerable`1<SourceRepository> sourceRepositories, int maxNumberOfParallelTasks, ILogger logger);
    [CompilerGeneratedAttribute]
public NuGetPackageManager get_PackageManager();
    [CompilerGeneratedAttribute]
public IEnumerable`1<PackageRestoreData> get_Packages();
    [CompilerGeneratedAttribute]
public CancellationToken get_Token();
    [CompilerGeneratedAttribute]
public EventHandler`1<PackageRestoredEventArgs> get_PackageRestoredEvent();
    [CompilerGeneratedAttribute]
public EventHandler`1<PackageRestoreFailedEventArgs> get_PackageRestoreFailedEvent();
    [CompilerGeneratedAttribute]
public IEnumerable`1<SourceRepository> get_SourceRepositories();
    [CompilerGeneratedAttribute]
public int get_MaxNumberOfParallelTasks();
    [CompilerGeneratedAttribute]
public ILogger get_Logger();
}
public class NuGet.PackageManagement.PackageRestoreData : object {
    [CompilerGeneratedAttribute]
private PackageReference <PackageReference>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <ProjectNames>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsMissing>k__BackingField;
    public PackageReference PackageReference { get; }
    public IEnumerable`1<string> ProjectNames { get; }
    public bool IsMissing { get; }
    public PackageRestoreData(PackageReference packageReference, IEnumerable`1<string> projectNames, bool isMissing);
    [CompilerGeneratedAttribute]
public PackageReference get_PackageReference();
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_ProjectNames();
    [CompilerGeneratedAttribute]
public bool get_IsMissing();
}
public class NuGet.PackageManagement.PackageRestoredEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private PackageIdentity <Package>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Restored>k__BackingField;
    public PackageIdentity Package { get; private set; }
    public bool Restored { get; private set; }
    public PackageRestoredEventArgs(PackageIdentity packageIdentity, bool restored);
    [CompilerGeneratedAttribute]
public PackageIdentity get_Package();
    [CompilerGeneratedAttribute]
private void set_Package(PackageIdentity value);
    [CompilerGeneratedAttribute]
public bool get_Restored();
    [CompilerGeneratedAttribute]
private void set_Restored(bool value);
}
public class NuGet.PackageManagement.PackageRestoreFailedEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private PackageReference <RestoreFailedPackageReference>k__BackingField;
    [CompilerGeneratedAttribute]
private Exception <Exception>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <ProjectNames>k__BackingField;
    public PackageReference RestoreFailedPackageReference { get; private set; }
    public Exception Exception { get; private set; }
    public IEnumerable`1<string> ProjectNames { get; private set; }
    public PackageRestoreFailedEventArgs(PackageReference restoredFailedPackageReference, Exception exception, IEnumerable`1<string> projectNames);
    [CompilerGeneratedAttribute]
public PackageReference get_RestoreFailedPackageReference();
    [CompilerGeneratedAttribute]
private void set_RestoreFailedPackageReference(PackageReference value);
    [CompilerGeneratedAttribute]
public Exception get_Exception();
    [CompilerGeneratedAttribute]
private void set_Exception(Exception value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_ProjectNames();
    [CompilerGeneratedAttribute]
private void set_ProjectNames(IEnumerable`1<string> value);
}
public class NuGet.PackageManagement.PackageRestoreManager : object {
    [CompilerGeneratedAttribute]
private ISourceRepositoryProvider <SourceRepositoryProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private ISolutionManager <SolutionManager>k__BackingField;
    [CompilerGeneratedAttribute]
private ISettings <Settings>k__BackingField;
    [CompilerGeneratedAttribute]
private EventHandler`1<PackagesMissingStatusEventArgs> PackagesMissingStatusChanged;
    [CompilerGeneratedAttribute]
private EventHandler`1<PackageRestoredEventArgs> PackageRestoredEvent;
    [CompilerGeneratedAttribute]
private EventHandler`1<PackageRestoreFailedEventArgs> PackageRestoreFailedEvent;
    [CompilerGeneratedAttribute]
private AssetsFileMissingStatusChanged _assetsFileMissingStatusChanged;
    private ISourceRepositoryProvider SourceRepositoryProvider { get; }
    private ISolutionManager SolutionManager { get; }
    private ISettings Settings { get; }
    public PackageRestoreManager(ISourceRepositoryProvider sourceRepositoryProvider, ISettings settings, ISolutionManager solutionManager);
    [CompilerGeneratedAttribute]
private ISourceRepositoryProvider get_SourceRepositoryProvider();
    [CompilerGeneratedAttribute]
private ISolutionManager get_SolutionManager();
    [CompilerGeneratedAttribute]
private ISettings get_Settings();
    [CompilerGeneratedAttribute]
public sealed virtual void add_PackagesMissingStatusChanged(EventHandler`1<PackagesMissingStatusEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PackagesMissingStatusChanged(EventHandler`1<PackagesMissingStatusEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_PackageRestoredEvent(EventHandler`1<PackageRestoredEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PackageRestoredEvent(EventHandler`1<PackageRestoredEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_PackageRestoreFailedEvent(EventHandler`1<PackageRestoreFailedEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PackageRestoreFailedEvent(EventHandler`1<PackageRestoreFailedEventArgs> value);
    [CompilerGeneratedAttribute]
private void add__assetsFileMissingStatusChanged(AssetsFileMissingStatusChanged value);
    [CompilerGeneratedAttribute]
private void remove__assetsFileMissingStatusChanged(AssetsFileMissingStatusChanged value);
    public sealed virtual void add_AssetsFileMissingStatusChanged(AssetsFileMissingStatusChanged value);
    public sealed virtual void remove_AssetsFileMissingStatusChanged(AssetsFileMissingStatusChanged value);
    [AsyncStateMachineAttribute("NuGet.PackageManagement.PackageRestoreManager/<RaisePackagesMissingEventForSolutionAsync>d__25")]
public virtual Task RaisePackagesMissingEventForSolutionAsync(string solutionDirectory, CancellationToken token);
    public virtual void RaiseAssetsFileMissingEventForProjectAsync(bool isAssetsFileMissing);
    protected void ClearMissingEventForSolution();
    [AsyncStateMachineAttribute("NuGet.PackageManagement.PackageRestoreManager/<GetPackagesInSolutionAsync>d__28")]
public sealed virtual Task`1<IEnumerable`1<PackageRestoreData>> GetPackagesInSolutionAsync(string solutionDirectory, CancellationToken token);
    public sealed virtual IEnumerable`1<PackageRestoreData> GetPackagesRestoreData(string solutionDirectory, Dictionary`2<PackageReference, List`1<string>> packageReferencesDict);
    [AsyncStateMachineAttribute("NuGet.PackageManagement.PackageRestoreManager/<GetPackagesReferencesDictionaryAsync>d__30")]
private Task`1<Dictionary`2<PackageReference, List`1<string>>> GetPackagesReferencesDictionaryAsync(CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.PackageManagement.PackageRestoreManager/<RestoreMissingPackagesInSolutionAsync>d__31")]
public virtual Task`1<PackageRestoreResult> RestoreMissingPackagesInSolutionAsync(string solutionDirectory, INuGetProjectContext nuGetProjectContext, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.PackageManagement.PackageRestoreManager/<RestoreMissingPackagesInSolutionAsync>d__32")]
public virtual Task`1<PackageRestoreResult> RestoreMissingPackagesInSolutionAsync(string solutionDirectory, INuGetProjectContext nuGetProjectContext, ILogger logger, CancellationToken token);
    public virtual Task`1<PackageRestoreResult> RestoreMissingPackagesAsync(string solutionDirectory, IEnumerable`1<PackageRestoreData> packages, INuGetProjectContext nuGetProjectContext, PackageDownloadContext downloadContext, CancellationToken token);
    public virtual Task`1<PackageRestoreResult> RestoreMissingPackagesAsync(string solutionDirectory, IEnumerable`1<PackageRestoreData> packages, INuGetProjectContext nuGetProjectContext, PackageDownloadContext downloadContext, ILogger logger, CancellationToken token);
    private NuGetPackageManager GetNuGetPackageManager(string solutionDirectory);
    [AsyncStateMachineAttribute("NuGet.PackageManagement.PackageRestoreManager/<RestoreMissingPackagesAsync>d__36")]
public static Task`1<PackageRestoreResult> RestoreMissingPackagesAsync(PackageRestoreContext packageRestoreContext, INuGetProjectContext nuGetProjectContext, PackageDownloadContext downloadContext);
    [AsyncStateMachineAttribute("NuGet.PackageManagement.PackageRestoreManager/<ThrottledPackageRestoreAsync>d__37")]
private static Task`1<IEnumerable`1<AttemptedPackage>> ThrottledPackageRestoreAsync(HashSet`1<PackageReference> packageReferences, PackageRestoreContext packageRestoreContext, INuGetProjectContext nuGetProjectContext, PackageDownloadContext downloadContext);
    [AsyncStateMachineAttribute("NuGet.PackageManagement.PackageRestoreManager/<PackageRestoreRunnerAsync>d__38")]
private static Task`1<List`1<AttemptedPackage>> PackageRestoreRunnerAsync(ConcurrentQueue`1<PackageReference> packageReferencesQueue, PackageRestoreContext packageRestoreContext, INuGetProjectContext nuGetProjectContext, PackageDownloadContext downloadContext);
    private static Task ThrottledCopySatelliteFilesAsync(HashSet`1<PackageReference> packageReferences, PackageRestoreContext packageRestoreContext, INuGetProjectContext nuGetProjectContext);
    [AsyncStateMachineAttribute("NuGet.PackageManagement.PackageRestoreManager/<RestorePackageAsync>d__40")]
private static Task`1<AttemptedPackage> RestorePackageAsync(PackageReference packageReference, PackageRestoreContext packageRestoreContext, INuGetProjectContext nuGetProjectContext, PackageDownloadContext downloadContext);
    [AsyncStateMachineAttribute("NuGet.PackageManagement.PackageRestoreManager/<CopySatelliteFilesRunnerAsync>d__41")]
private static Task CopySatelliteFilesRunnerAsync(ConcurrentQueue`1<PackageReference> packageReferencesQueue, PackageRestoreContext packageRestoreContext, INuGetProjectContext nuGetProjectContext);
}
public class NuGet.PackageManagement.PackageRestoreResult : object {
    [CompilerGeneratedAttribute]
private bool <Restored>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<PackageIdentity> <RestoredPackages>k__BackingField;
    public bool Restored { get; }
    public IEnumerable`1<PackageIdentity> RestoredPackages { get; }
    public PackageRestoreResult(bool restored, IEnumerable`1<PackageIdentity> restoredPackages);
    [CompilerGeneratedAttribute]
public bool get_Restored();
    [CompilerGeneratedAttribute]
public IEnumerable`1<PackageIdentity> get_RestoredPackages();
}
internal class NuGet.PackageManagement.PackagesConfigContentHashProvider : object {
    private FolderNuGetProject _packagesFolder;
    internal PackagesConfigContentHashProvider(FolderNuGetProject packagesFolder);
    public sealed virtual string GetContentHash(PackageIdentity packageIdentity, CancellationToken token);
    private string GetNupkgPath(PackageIdentity packageIdentity, CancellationToken token);
    private Result TryGetNupkgMetadata(string nupkgPath);
    private string GetNupkgMetadataPath(string nupkgPath);
    private string GetContentHashFromNupkg(string filePath, CancellationToken token);
    private void WriteNupkgMetadata(string nupkgPath, string contentHash);
}
public static class NuGet.PackageManagement.PackagesFolderPathUtility : object {
    private static string DefaultRepositoryPath;
    public static string GetPackagesFolderPath(ISolutionManager solutionManager, ISettings settings);
    public static string GetPackagesFolderPath(string solutionDirectory, ISettings settings);
}
public class NuGet.PackageManagement.PackagesMarkedForDeletionEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<string> <DirectoriesMarkedForDeletion>k__BackingField;
    public IReadOnlyList`1<string> DirectoriesMarkedForDeletion { get; }
    public PackagesMarkedForDeletionEventArgs(IReadOnlyList`1<string> directoriesMarkedForDeletion);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<string> get_DirectoriesMarkedForDeletion();
}
public class NuGet.PackageManagement.PackagesMissingStatusEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private bool <PackagesMissing>k__BackingField;
    public bool PackagesMissing { get; private set; }
    public PackagesMissingStatusEventArgs(bool packagesMissing);
    [CompilerGeneratedAttribute]
public bool get_PackagesMissing();
    [CompilerGeneratedAttribute]
private void set_PackagesMissing(bool value);
}
public class NuGet.PackageManagement.PackageWithDependants : object {
    [CompilerGeneratedAttribute]
private PackageIdentity <Identity>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<PackageIdentity> <DependantPackages>k__BackingField;
    public PackageIdentity Identity { get; }
    public IReadOnlyList`1<PackageIdentity> DependantPackages { get; }
    public bool IsTopLevelPackage { get; }
    public PackageWithDependants(PackageIdentity identity, IReadOnlyList`1<PackageIdentity> dependingPackages);
    [CompilerGeneratedAttribute]
public PackageIdentity get_Identity();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<PackageIdentity> get_DependantPackages();
    public bool get_IsTopLevelPackage();
}
public class NuGet.PackageManagement.ProductUpdateAvailableEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private Version <CurrentVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private Version <NewVersion>k__BackingField;
    public Version CurrentVersion { get; private set; }
    public Version NewVersion { get; private set; }
    public ProductUpdateAvailableEventArgs(Version currentVersion, Version newVersion);
    [CompilerGeneratedAttribute]
public Version get_CurrentVersion();
    [CompilerGeneratedAttribute]
private void set_CurrentVersion(Version value);
    [CompilerGeneratedAttribute]
public Version get_NewVersion();
    [CompilerGeneratedAttribute]
private void set_NewVersion(Version value);
}
public class NuGet.PackageManagement.ProjectContextLogger : LoggerBase {
    private INuGetProjectContext _projectContext;
    public ProjectContextLogger(INuGetProjectContext projectContext);
    public virtual void Log(ILogMessage message);
    public virtual Task LogAsync(ILogMessage message);
}
public static class NuGet.PackageManagement.PrunePackageTree : object {
    public static IEnumerable`1<SourcePackageDependencyInfo> PrunePrereleaseExceptAllowed(IEnumerable`1<SourcePackageDependencyInfo> packages, IEnumerable`1<PackageIdentity> installedPackages, bool isUpdateAll);
    public static IEnumerable`1<SourcePackageDependencyInfo> PrunePreleaseForStableTargets(IEnumerable`1<SourcePackageDependencyInfo> packages, IEnumerable`1<PackageIdentity> targets, IEnumerable`1<PackageIdentity> packagesToInstall);
    private static void CollectAllowedFromTargets(IEnumerable`1<PackageIdentity> targets, HashSet`1<string> allowed);
    private static void CollectAllowedFromDependenciesOfPackagesToInstall(IEnumerable`1<SourcePackageDependencyInfo> packages, IEnumerable`1<PackageIdentity> packagesToInstall, HashSet`1<string> allowed);
    private static void WalkDependencies(IDictionary`2<string, SourcePackageDependencyInfo[]> packagesDict, SourcePackageDependencyInfo packageToInstall, HashSet`1<string> allowed, HashSet`1<SourcePackageDependencyInfo> visitedNodes);
    public static IEnumerable`1<SourcePackageDependencyInfo> PruneDowngrades(IEnumerable`1<SourcePackageDependencyInfo> packages, IEnumerable`1<PackageReference> packageReferences);
    public static IEnumerable`1<SourcePackageDependencyInfo> PruneDisallowedVersions(IEnumerable`1<SourcePackageDependencyInfo> packages, IEnumerable`1<PackageReference> packageReferences);
    public static IEnumerable`1<SourcePackageDependencyInfo> RemoveAllVersionsForIdExcept(IEnumerable`1<SourcePackageDependencyInfo> packages, PackageIdentity target);
    public static IEnumerable`1<SourcePackageDependencyInfo> RemoveAllPrereleaseVersionsForId(IEnumerable`1<SourcePackageDependencyInfo> packages, string id);
    public static IEnumerable`1<SourcePackageDependencyInfo> RemoveAllVersionsLessThan(IEnumerable`1<SourcePackageDependencyInfo> packages, PackageIdentity minimum);
    public static IEnumerable`1<SourcePackageDependencyInfo> RemoveDisallowedVersions(IEnumerable`1<SourcePackageDependencyInfo> packages, PackageReference packageReference);
    public static IEnumerable`1<SourcePackageDependencyInfo> PruneByPrimaryTargets(IEnumerable`1<SourcePackageDependencyInfo> packages, IEnumerable`1<PackageIdentity> primaryTargets);
    public static IEnumerable`1<SourcePackageDependencyInfo> PruneAllButHighest(IEnumerable`1<SourcePackageDependencyInfo> packages, string packageId);
    public static IEnumerable`1<SourcePackageDependencyInfo> PruneByUpdateConstraints(IEnumerable`1<SourcePackageDependencyInfo> packages, IEnumerable`1<PackageReference> packageReferences, VersionConstraints versionConstraints);
    public static IEnumerable`1<SourcePackageDependencyInfo> PruneByUpdateConstraints(IEnumerable`1<SourcePackageDependencyInfo> packages, NuGetVersion existingVersion, VersionConstraints versionConstraints);
    private static bool MeetsVersionConstraints(NuGetVersion newVersion, NuGetVersion existingVersion, VersionConstraints versionConstraints);
    public static bool IsExactVersion(VersionConstraints versionConstraints);
}
public class NuGet.PackageManagement.ResolutionContext : object {
    [CompilerGeneratedAttribute]
private DependencyBehavior <DependencyBehavior>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludePrerelease>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludeUnlisted>k__BackingField;
    [CompilerGeneratedAttribute]
private VersionConstraints <VersionConstraints>k__BackingField;
    [CompilerGeneratedAttribute]
private GatherCache <GatherCache>k__BackingField;
    [CompilerGeneratedAttribute]
private SourceCacheContext <SourceCacheContext>k__BackingField;
    public DependencyBehavior DependencyBehavior { get; }
    public bool IncludePrerelease { get; }
    public bool IncludeUnlisted { get; }
    public VersionConstraints VersionConstraints { get; }
    public GatherCache GatherCache { get; }
    public SourceCacheContext SourceCacheContext { get; }
    public ResolutionContext(DependencyBehavior dependencyBehavior, bool includePrelease, bool includeUnlisted, VersionConstraints versionConstraints);
    public ResolutionContext(DependencyBehavior dependencyBehavior, bool includePrelease, bool includeUnlisted, VersionConstraints versionConstraints, GatherCache gatherCache, SourceCacheContext sourceCacheContext);
    [CompilerGeneratedAttribute]
public DependencyBehavior get_DependencyBehavior();
    [CompilerGeneratedAttribute]
public bool get_IncludePrerelease();
    [CompilerGeneratedAttribute]
public bool get_IncludeUnlisted();
    [CompilerGeneratedAttribute]
public VersionConstraints get_VersionConstraints();
    [CompilerGeneratedAttribute]
public GatherCache get_GatherCache();
    [CompilerGeneratedAttribute]
public SourceCacheContext get_SourceCacheContext();
}
public class NuGet.PackageManagement.ResolvedAction : object {
    [CompilerGeneratedAttribute]
private NuGetProject <Project>k__BackingField;
    [CompilerGeneratedAttribute]
private NuGetProjectAction <Action>k__BackingField;
    public NuGetProject Project { get; }
    public NuGetProjectAction Action { get; }
    public ResolvedAction(NuGetProject project, NuGetProjectAction action);
    [CompilerGeneratedAttribute]
public NuGetProject get_Project();
    [CompilerGeneratedAttribute]
public NuGetProjectAction get_Action();
}
public class NuGet.PackageManagement.ResolvedPackage : object {
    [CompilerGeneratedAttribute]
private NuGetVersion <LatestVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Exists>k__BackingField;
    public NuGetVersion LatestVersion { get; }
    public bool Exists { get; }
    public ResolvedPackage(NuGetVersion latestVersion, bool exists);
    [CompilerGeneratedAttribute]
public NuGetVersion get_LatestVersion();
    [CompilerGeneratedAttribute]
public bool get_Exists();
}
public class NuGet.PackageManagement.ResolverGather : object {
    private GatherContext _context;
    private List`1<SourceResource> _primaryResources;
    private List`1<SourceResource> _allResources;
    private DependencyInfoResource _packagesFolderResource;
    private Queue`1<GatherRequest> _gatherRequests;
    private GatherCache _cache;
    private List`1<Task`1<GatherResult>> _workerTasks;
    private int _lastRequestId;
    private List`1<GatherResult> _results;
    private HashSet`1<string> _idsSearched;
    private int _maxDegreeOfParallelism;
    private ConcurrentDictionary`2<string, TimeSpan> _timeTaken;
    private bool _isSourceMappingConfigured;
    [CompilerGeneratedAttribute]
private TimeSpan <RequestTimeout>k__BackingField;
    public int MaxDegreeOfParallelism { get; public set; }
    public TimeSpan RequestTimeout { get; public set; }
    private ResolverGather(GatherContext context);
    public int get_MaxDegreeOfParallelism();
    public void set_MaxDegreeOfParallelism(int value);
    [CompilerGeneratedAttribute]
public TimeSpan get_RequestTimeout();
    [CompilerGeneratedAttribute]
public void set_RequestTimeout(TimeSpan value);
    [AsyncStateMachineAttribute("NuGet.PackageManagement.ResolverGather/<GatherAsync>d__21")]
public static Task`1<HashSet`1<SourcePackageDependencyInfo>> GatherAsync(GatherContext context, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.PackageManagement.ResolverGather/<GatherAsync>d__22")]
private Task`1<HashSet`1<SourcePackageDependencyInfo>> GatherAsync(CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.PackageManagement.ResolverGather/<StartTasksAndProcessWork>d__23")]
private Task StartTasksAndProcessWork(CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.PackageManagement.ResolverGather/<GatherInstalledPackagesAsync>d__24")]
private Task GatherInstalledPackagesAsync(IEnumerable`1<PackageIdentity> installedPackages, HashSet`1<string> allPrimaryTargets, CancellationToken token);
    private static HashSet`1<string> GetClosure(HashSet`1<SourcePackageDependencyInfo> combinedResults, HashSet`1<SourcePackageDependencyInfo> installedPackages, HashSet`1<string> idsSearched);
    [AsyncStateMachineAttribute("NuGet.PackageManagement.ResolverGather/<ProcessResultsAsync>d__26")]
private Task ProcessResultsAsync();
    private void StartWorkerTasks(CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.PackageManagement.ResolverGather/<GatherPackageAsync>d__28")]
private Task`1<GatherResult> GatherPackageAsync(GatherRequest request, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.PackageManagement.ResolverGather/<GatherPackageFromSourceAsync>d__29")]
private Task`1<List`1<SourcePackageDependencyInfo>> GatherPackageFromSourceAsync(string packageId, NuGetVersion version, DependencyInfoResource resource, NuGetFramework targetFramework, bool ignoreExceptions, CancellationToken token);
    private void QueueWork(IReadOnlyList`1<SourceResource> sources, string packageId, bool ignoreExceptions);
    private void QueueWork(IReadOnlyList`1<SourceResource> sources, PackageIdentity package, bool ignoreExceptions, bool isInstalledPackage);
    [AsyncStateMachineAttribute("NuGet.PackageManagement.ResolverGather/<InitializeResourcesAsync>d__32")]
private Task InitializeResourcesAsync(CancellationToken token);
    private int GetNextRequestId();
}
public class NuGet.PackageManagement.SourceRepositoryComparer : object {
    [CompilerGeneratedAttribute]
private static SourceRepositoryComparer <Instance>k__BackingField;
    public static SourceRepositoryComparer Instance { get; }
    private static SourceRepositoryComparer();
    [CompilerGeneratedAttribute]
public static SourceRepositoryComparer get_Instance();
    public sealed virtual bool Equals(SourceRepository x, SourceRepository y);
    public sealed virtual int GetHashCode(SourceRepository obj);
}
internal static class NuGet.PackageManagement.StringFormatter : object {
    internal static string Log_PackageSourceMappingMatchFound(string packageId, string packageSourcesAtPrefix);
    internal static string Log_PackageSourceMappingNoMatchFound(string packageId);
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "17.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class NuGet.PackageManagement.Strings : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string AddedPackageToFolder { get; }
    internal static string AddedPackageToFolderFromSource { get; }
    internal static string AddedPackageToPackagesConfig { get; }
    internal static string AddingPackageToFolder { get; }
    internal static string AddingPackageWithOnlyDependencies { get; }
    internal static string AddingPackageWithOnlyToolsGroup { get; }
    internal static string Argument_Cannot_Be_Null_Or_Empty { get; }
    internal static string AttemptingToGatherDependencyInfo { get; }
    internal static string AttemptingToGatherDependencyInfoForMultiplePackages { get; }
    internal static string AttemptingToResolveDependencies { get; }
    internal static string AttemptingToResolveDependenciesForMultiplePackages { get; }
    internal static string Debug_AddedFile { get; }
    internal static string Debug_AddedFileToFolder { get; }
    internal static string Debug_RemovedFile { get; }
    internal static string Debug_RemovedFileFromFolder { get; }
    internal static string Debug_RemovedFolder { get; }
    internal static string Debug_TargetFrameworkInfo { get; }
    internal static string Debug_TargetFrameworkInfoPrefix { get; }
    internal static string DependencyDoesNotHaveValidVersion { get; }
    internal static string DownloadResourceNotFound { get; }
    internal static string DownloadStreamNotAvailable { get; }
    internal static string Error_DirectoryDoesNotExist { get; }
    internal static string Error_FileDoesNotExist { get; }
    internal static string Error_InvalidLockFileInput { get; }
    internal static string Error_PackageValidationFailed { get; }
    internal static string Error_RestoreInLockedModePackagesConfig { get; }
    internal static string Error_VulnerabilityDataFetch { get; }
    internal static string ErrorLoadingPackagesConfig { get; }
    internal static string ErrorWritingPackagesConfig { get; }
    internal static string ExceptionWhenTryingToAddSource { get; }
    internal static string FileConflictMessage { get; }
    internal static string FoundPackageInPackagesFolder { get; }
    internal static string GatherTotalTime { get; }
    internal static string Info_OverwritingExistingFile { get; }
    internal static string InvalidProjectName { get; }
    internal static string MultiplePackageTypesNotSupported { get; }
    internal static string NewerVersionAlreadyReferenced { get; }
    internal static string NoLatestVersionFound { get; }
    internal static string NoPackagesInProject { get; }
    internal static string NoPackageUpdates { get; }
    internal static string NoUpdatesAvailable { get; }
    internal static string NugetActionsTotalTime { get; }
    internal static string PackageAlreadyExistsInFolder { get; }
    internal static string PackageAlreadyExistsInPackagesConfig { get; }
    internal static string PackageAlreadyExistsInProject { get; }
    internal static string PackageCancelledFromSource { get; }
    internal static string PackageCouldNotBeInstalled { get; }
    internal static string PackageDoesNotExistInFolder { get; }
    internal static string PackageDoesNotExistInProject { get; }
    internal static string PackageDoesNotExisttInPackagesConfig { get; }
    internal static string PackageHasDependent { get; }
    internal static string PackageHasDependents { get; }
    internal static string PackageNotFound { get; }
    internal static string PackageNotFoundInPrimarySources { get; }
    internal static string PackageNotFoundOnSource { get; }
    internal static string PackagesConfigAllowedVersionConflict { get; }
    internal static string PackagesConfigAllowedVersions { get; }
    internal static string PackagesCouldNotBeInstalled { get; }
    internal static string PackageSourceMappingPatternMatchFound { get; }
    internal static string PackageSourceMappingPatternNoMatchFound { get; }
    internal static string PackageStreamShouldBeSeekable { get; }
    internal static string PackageToBeUninstalledCouldNotBeFound { get; }
    internal static string ParameterCannotBeZeroOrNegative { get; }
    internal static string ProjectNotLoaded_RestoreFailed { get; }
    internal static string PropertyCannotBeNull { get; }
    internal static string RemovedPackageFromFolder { get; }
    internal static string RemovedPackageFromPackagesConfig { get; }
    internal static string RemovingPackageFromFolder { get; }
    internal static string ResolutionSuccessfulNoAction { get; }
    internal static string ResolvedActionsToInstallPackage { get; }
    internal static string ResolvedActionsToUninstallPackage { get; }
    internal static string ResolvingActionsToInstallOrUpdateMultiplePackages { get; }
    internal static string ResolvingActionsToInstallPackage { get; }
    internal static string ResolvingActionsToUninstallPackage { get; }
    internal static string RestoreFailedRollingBack { get; }
    internal static string RestoringPackage { get; }
    internal static string RetrievingPackageStart { get; }
    internal static string SignatureVerificationMultiple { get; }
    internal static string SolutionDirectoryNotAvailable { get; }
    internal static string SolutionManagerNotAvailableForUninstall { get; }
    internal static string SuccessfullyInstalled { get; }
    internal static string SuccessfullyUninstalled { get; }
    internal static string UnableToFindCompatibleItems { get; }
    internal static string UnableToFindPathInLookupOrList { get; }
    internal static string UnableToGatherDependencyInfo { get; }
    internal static string UnableToGatherDependencyInfoForMultiplePackages { get; }
    internal static string UnableToGatherPackageFromSource { get; }
    internal static string UnableToResolveDependencyInfo { get; }
    internal static string UnableToResolveDependencyInfoForMultiplePackages { get; }
    internal static string UnknownPackage { get; }
    internal static string UnknownPackageSpecificVersion { get; }
    internal static string UnsupportedPackageType { get; }
    internal static string Warning_DirectoryNotEmpty { get; }
    internal static string Warning_ErrorFindingRepository { get; }
    internal static string Warning_FileAlreadyExists { get; }
    internal static string Warning_FileModified { get; }
    internal static string Warning_HttpServerUsage { get; }
    internal static string Warning_PackageWithKnownVulnerability { get; }
    internal static string Warning_RollingBack { get; }
    internal static string XdtError { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_AddedPackageToFolder();
    internal static string get_AddedPackageToFolderFromSource();
    internal static string get_AddedPackageToPackagesConfig();
    internal static string get_AddingPackageToFolder();
    internal static string get_AddingPackageWithOnlyDependencies();
    internal static string get_AddingPackageWithOnlyToolsGroup();
    internal static string get_Argument_Cannot_Be_Null_Or_Empty();
    internal static string get_AttemptingToGatherDependencyInfo();
    internal static string get_AttemptingToGatherDependencyInfoForMultiplePackages();
    internal static string get_AttemptingToResolveDependencies();
    internal static string get_AttemptingToResolveDependenciesForMultiplePackages();
    internal static string get_Debug_AddedFile();
    internal static string get_Debug_AddedFileToFolder();
    internal static string get_Debug_RemovedFile();
    internal static string get_Debug_RemovedFileFromFolder();
    internal static string get_Debug_RemovedFolder();
    internal static string get_Debug_TargetFrameworkInfo();
    internal static string get_Debug_TargetFrameworkInfoPrefix();
    internal static string get_DependencyDoesNotHaveValidVersion();
    internal static string get_DownloadResourceNotFound();
    internal static string get_DownloadStreamNotAvailable();
    internal static string get_Error_DirectoryDoesNotExist();
    internal static string get_Error_FileDoesNotExist();
    internal static string get_Error_InvalidLockFileInput();
    internal static string get_Error_PackageValidationFailed();
    internal static string get_Error_RestoreInLockedModePackagesConfig();
    internal static string get_Error_VulnerabilityDataFetch();
    internal static string get_ErrorLoadingPackagesConfig();
    internal static string get_ErrorWritingPackagesConfig();
    internal static string get_ExceptionWhenTryingToAddSource();
    internal static string get_FileConflictMessage();
    internal static string get_FoundPackageInPackagesFolder();
    internal static string get_GatherTotalTime();
    internal static string get_Info_OverwritingExistingFile();
    internal static string get_InvalidProjectName();
    internal static string get_MultiplePackageTypesNotSupported();
    internal static string get_NewerVersionAlreadyReferenced();
    internal static string get_NoLatestVersionFound();
    internal static string get_NoPackagesInProject();
    internal static string get_NoPackageUpdates();
    internal static string get_NoUpdatesAvailable();
    internal static string get_NugetActionsTotalTime();
    internal static string get_PackageAlreadyExistsInFolder();
    internal static string get_PackageAlreadyExistsInPackagesConfig();
    internal static string get_PackageAlreadyExistsInProject();
    internal static string get_PackageCancelledFromSource();
    internal static string get_PackageCouldNotBeInstalled();
    internal static string get_PackageDoesNotExistInFolder();
    internal static string get_PackageDoesNotExistInProject();
    internal static string get_PackageDoesNotExisttInPackagesConfig();
    internal static string get_PackageHasDependent();
    internal static string get_PackageHasDependents();
    internal static string get_PackageNotFound();
    internal static string get_PackageNotFoundInPrimarySources();
    internal static string get_PackageNotFoundOnSource();
    internal static string get_PackagesConfigAllowedVersionConflict();
    internal static string get_PackagesConfigAllowedVersions();
    internal static string get_PackagesCouldNotBeInstalled();
    internal static string get_PackageSourceMappingPatternMatchFound();
    internal static string get_PackageSourceMappingPatternNoMatchFound();
    internal static string get_PackageStreamShouldBeSeekable();
    internal static string get_PackageToBeUninstalledCouldNotBeFound();
    internal static string get_ParameterCannotBeZeroOrNegative();
    internal static string get_ProjectNotLoaded_RestoreFailed();
    internal static string get_PropertyCannotBeNull();
    internal static string get_RemovedPackageFromFolder();
    internal static string get_RemovedPackageFromPackagesConfig();
    internal static string get_RemovingPackageFromFolder();
    internal static string get_ResolutionSuccessfulNoAction();
    internal static string get_ResolvedActionsToInstallPackage();
    internal static string get_ResolvedActionsToUninstallPackage();
    internal static string get_ResolvingActionsToInstallOrUpdateMultiplePackages();
    internal static string get_ResolvingActionsToInstallPackage();
    internal static string get_ResolvingActionsToUninstallPackage();
    internal static string get_RestoreFailedRollingBack();
    internal static string get_RestoringPackage();
    internal static string get_RetrievingPackageStart();
    internal static string get_SignatureVerificationMultiple();
    internal static string get_SolutionDirectoryNotAvailable();
    internal static string get_SolutionManagerNotAvailableForUninstall();
    internal static string get_SuccessfullyInstalled();
    internal static string get_SuccessfullyUninstalled();
    internal static string get_UnableToFindCompatibleItems();
    internal static string get_UnableToFindPathInLookupOrList();
    internal static string get_UnableToGatherDependencyInfo();
    internal static string get_UnableToGatherDependencyInfoForMultiplePackages();
    internal static string get_UnableToGatherPackageFromSource();
    internal static string get_UnableToResolveDependencyInfo();
    internal static string get_UnableToResolveDependencyInfoForMultiplePackages();
    internal static string get_UnknownPackage();
    internal static string get_UnknownPackageSpecificVersion();
    internal static string get_UnsupportedPackageType();
    internal static string get_Warning_DirectoryNotEmpty();
    internal static string get_Warning_ErrorFindingRepository();
    internal static string get_Warning_FileAlreadyExists();
    internal static string get_Warning_FileModified();
    internal static string get_Warning_HttpServerUsage();
    internal static string get_Warning_PackageWithKnownVulnerability();
    internal static string get_Warning_RollingBack();
    internal static string get_XdtError();
}
public static class NuGet.PackageManagement.TelemetryConstants : object {
    public static string PreviewBuildIntegratedStepName;
    public static string GatherDependencyStepName;
    public static string ResolveDependencyStepName;
    public static string ResolvedActionsStepName;
    public static string ExecuteActionStepName;
    private static TelemetryConstants();
}
public class NuGet.PackageManagement.UninstallationContext : object {
    [CompilerGeneratedAttribute]
private bool <RemoveDependencies>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ForceRemove>k__BackingField;
    public bool RemoveDependencies { get; private set; }
    public bool ForceRemove { get; private set; }
    public UninstallationContext(bool removeDependencies, bool forceRemove);
    [CompilerGeneratedAttribute]
public bool get_RemoveDependencies();
    [CompilerGeneratedAttribute]
private void set_RemoveDependencies(bool value);
    [CompilerGeneratedAttribute]
public bool get_ForceRemove();
    [CompilerGeneratedAttribute]
private void set_ForceRemove(bool value);
}
public static class NuGet.PackageManagement.UninstallResolver : object {
    public static IDictionary`2<PackageIdentity, HashSet`1<PackageIdentity>> GetPackageDependents(IEnumerable`1<PackageDependencyInfo> dependencyInfoEnumerable, IEnumerable`1<PackageIdentity> installedPackages, IDictionary`2& dependenciesDict);
    public static ICollection`1<PackageIdentity> GetPackagesToBeUninstalled(PackageIdentity packageIdentity, IEnumerable`1<PackageDependencyInfo> dependencyInfoEnumerable, IEnumerable`1<PackageIdentity> installedPackages, UninstallationContext uninstallationContext);
    private static void CheckIfPackageCanBeUninstalled(PackageIdentity packageIdentity, IDictionary`2<PackageIdentity, HashSet`1<PackageIdentity>> dependenciesDict, IDictionary`2<PackageIdentity, HashSet`1<PackageIdentity>> dependentsDict, UninstallationContext uninstallationContext, HashSet`1<PackageIdentity> packagesMarkedForUninstall);
    private static HashSet`1<PackageIdentity> MarkPackagesToBeUninstalled(PackageIdentity packageIdentity, IDictionary`2<PackageIdentity, HashSet`1<PackageIdentity>> dependenciesDict, UninstallationContext uninstallationContext);
    private static InvalidOperationException CreatePackageHasDependentsException(PackageIdentity packageIdentity, List`1<PackageIdentity> packageDependents);
}
public static class NuGet.PackageManagement.UriHelper : object {
    public static void OpenExternalLink(Uri url);
    public static bool IsHttpSource(string source);
    public static bool IsHttpSource(PackageSourceProvider packageSourceProvider);
    public static bool IsHttpSource(string source, PackageSourceProvider packageSourceProvider);
    private static bool IsHttpUrl(Uri uri);
    private static bool IsLocal(string currentSource);
    private static bool IsUNC(string currentSource);
    public static bool IsAnySourceLocal(PackageSourceProvider packageSourceProvider, String& localSource);
    public static bool IsAnySourceAvailable(PackageSourceProvider packageSourceProvider, bool checkHttp);
}
public static class NuGet.PackageManagement.Utility.PackagesConfigLockFileUtility : object {
    private static IComparer _dependencyComparer;
    private static PackagesConfigLockFileUtility();
    internal static void UpdateLockFile(MSBuildNuGetProject msbuildProject, List`1<NuGetProjectAction> actionsList, CancellationToken token);
    internal static string GetPackagesLockFilePath(MSBuildNuGetProject msbuildProject);
    public static string GetPackagesLockFilePath(string projectPath, string nuGetLockFilePath, string projectName);
    public static IReadOnlyList`1<IRestoreLogMessage> ValidatePackagesConfigLockFiles(string projectFile, string packagesConfigFile, string projectName, string nuGetLockFilePath, string restorePackagesWithLockFile, NuGetFramework projectTfm, string packagesFolderPath, bool restoreLockedMode, CancellationToken token);
    private static Nullable`1<bool> IsRestorePackagesWithLockFileEnabled(MSBuildNuGetProject msbuildProject);
    internal static PackagesLockFile GetLockFile(bool lockFileExists, string lockFileName);
    internal static void ApplyChanges(PackagesLockFile lockFile, List`1<NuGetProjectAction> actionsList, IPackagesConfigContentHashProvider contentHashUtil, CancellationToken token);
    private static void RemoveUninstalledPackages(PackagesLockFile lockFile, IEnumerable`1<NuGetProjectAction> actionsList);
    private static void AddInstalledPackages(PackagesLockFile lockFile, IEnumerable`1<NuGetProjectAction> actionsList, IPackagesConfigContentHashProvider contentHashUtil, CancellationToken token);
    public static PackagesLockFile FromPackagesConfigFile(string pcFile, NuGetFramework projectTfm, string packagesFolderPath, CancellationToken token);
}
[FlagsAttribute]
public enum NuGet.PackageManagement.VersionConstraints : Enum {
    public int value__;
    public static VersionConstraints None;
    public static VersionConstraints ExactMajor;
    public static VersionConstraints ExactMinor;
    public static VersionConstraints ExactPatch;
    public static VersionConstraints ExactRelease;
}
public class NuGet.ProjectManagement.BuildIntegratedInstallationContext : object {
    [CompilerGeneratedAttribute]
private IEnumerable`1<NuGetFramework> <SuccessfulFrameworks>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<NuGetFramework> <UnsuccessfulFrameworks>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<NuGetFramework, string> <OriginalFrameworks>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AreAllPackagesConditional>k__BackingField;
    [CompilerGeneratedAttribute]
private LibraryIncludeFlags <SuppressParent>k__BackingField;
    [CompilerGeneratedAttribute]
private LibraryIncludeFlags <IncludeType>k__BackingField;
    public IEnumerable`1<NuGetFramework> SuccessfulFrameworks { get; }
    public IEnumerable`1<NuGetFramework> UnsuccessfulFrameworks { get; }
    public IDictionary`2<NuGetFramework, string> OriginalFrameworks { get; }
    public bool AreAllPackagesConditional { get; }
    public LibraryIncludeFlags SuppressParent { get; public set; }
    public LibraryIncludeFlags IncludeType { get; public set; }
    public BuildIntegratedInstallationContext(IEnumerable`1<NuGetFramework> successfulFrameworks, IEnumerable`1<NuGetFramework> unsucessfulFrameworks, IDictionary`2<NuGetFramework, string> originalFrameworks, bool areAllPackagesConditional);
    public BuildIntegratedInstallationContext(IEnumerable`1<NuGetFramework> successfulFrameworks, IEnumerable`1<NuGetFramework> unsucessfulFrameworks, IDictionary`2<NuGetFramework, string> originalFrameworks);
    [CompilerGeneratedAttribute]
public IEnumerable`1<NuGetFramework> get_SuccessfulFrameworks();
    [CompilerGeneratedAttribute]
public IEnumerable`1<NuGetFramework> get_UnsuccessfulFrameworks();
    [CompilerGeneratedAttribute]
public IDictionary`2<NuGetFramework, string> get_OriginalFrameworks();
    [CompilerGeneratedAttribute]
public bool get_AreAllPackagesConditional();
    [CompilerGeneratedAttribute]
public LibraryIncludeFlags get_SuppressParent();
    [CompilerGeneratedAttribute]
public void set_SuppressParent(LibraryIncludeFlags value);
    [CompilerGeneratedAttribute]
public LibraryIncludeFlags get_IncludeType();
    [CompilerGeneratedAttribute]
public void set_IncludeType(LibraryIncludeFlags value);
}
public class NuGet.ProjectManagement.BuildIntegratedPackageReference : PackageReference {
    [CompilerGeneratedAttribute]
private LibraryDependency <Dependency>k__BackingField;
    public LibraryDependency Dependency { get; }
    public BuildIntegratedPackageReference(LibraryDependency dependency, NuGetFramework projectFramework);
    public BuildIntegratedPackageReference(LibraryDependency dependency, NuGetFramework projectFramework, PackageIdentity installedVersion);
    [CompilerGeneratedAttribute]
public LibraryDependency get_Dependency();
    private static PackageIdentity GetIdentity(LibraryDependency dependency);
    private static VersionRange GetAllowedVersions(LibraryDependency dependency);
    private static NuGetVersion GetMinVersion(LibraryDependency dependency);
}
public static class NuGet.ProjectManagement.BuildIntegratedProjectUtility : object {
    [AsyncStateMachineAttribute("NuGet.ProjectManagement.BuildIntegratedProjectUtility/<GetOrderedProjectPackageDependencies>d__0")]
public static Task`1<IReadOnlyList`1<PackageIdentity>> GetOrderedProjectPackageDependencies(BuildIntegratedNuGetProject buildIntegratedProject);
    [AsyncStateMachineAttribute("NuGet.ProjectManagement.BuildIntegratedProjectUtility/<GetLockFileOrNull>d__1")]
public static Task`1<LockFile> GetLockFileOrNull(BuildIntegratedNuGetProject buildIntegratedProject);
    public static LockFile GetLockFileOrNull(string lockFilePath);
    public static IReadOnlyList`1<PackageIdentity> GetOrderedLockFilePackageDependencies(LockFile lockFile);
    public static IReadOnlyList`1<LibraryIdentity> GetOrderedLockFileDependencies(LockFile lockFile);
}
public static class NuGet.ProjectManagement.CollectionsUtility : object {
    public static void AddRange(ICollection`1<T> collection, IEnumerable`1<T> items);
    public static int RemoveAll(ICollection`1<T> collection, Func`2<T, bool> match);
}
public class NuGet.ProjectManagement.ConsoleProjectContext : object {
    private ILogger _logger;
    [CompilerGeneratedAttribute]
private PackageExtractionContext <PackageExtractionContext>k__BackingField;
    [CompilerGeneratedAttribute]
private XDocument <OriginalPackagesConfig>k__BackingField;
    [CompilerGeneratedAttribute]
private NuGetActionType <ActionType>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <OperationId>k__BackingField;
    public ExecutionContext ExecutionContext { get; }
    public PackageExtractionContext PackageExtractionContext { get; public set; }
    public XDocument OriginalPackagesConfig { get; public set; }
    public ISourceControlManagerProvider SourceControlManagerProvider { get; }
    public NuGetActionType ActionType { get; public set; }
    public Guid OperationId { get; public set; }
    public ConsoleProjectContext(ILogger logger);
    public sealed virtual ExecutionContext get_ExecutionContext();
    [CompilerGeneratedAttribute]
public sealed virtual PackageExtractionContext get_PackageExtractionContext();
    [CompilerGeneratedAttribute]
public sealed virtual void set_PackageExtractionContext(PackageExtractionContext value);
    [CompilerGeneratedAttribute]
public sealed virtual XDocument get_OriginalPackagesConfig();
    [CompilerGeneratedAttribute]
public sealed virtual void set_OriginalPackagesConfig(XDocument value);
    public sealed virtual ISourceControlManagerProvider get_SourceControlManagerProvider();
    public sealed virtual void Log(MessageLevel level, string message, Object[] args);
    public sealed virtual void Log(ILogMessage message);
    public sealed virtual void ReportError(string message);
    public sealed virtual void ReportError(ILogMessage message);
    public virtual FileConflictAction ResolveFileConflict(string message);
    [CompilerGeneratedAttribute]
public sealed virtual NuGetActionType get_ActionType();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ActionType(NuGetActionType value);
    [CompilerGeneratedAttribute]
public sealed virtual Guid get_OperationId();
    [CompilerGeneratedAttribute]
public sealed virtual void set_OperationId(Guid value);
}
public static class NuGet.ProjectManagement.Constants : object {
    public static string BinDirectory;
    public static string PackageReferenceFile;
    public static string MirroringReferenceFile;
    public static string ReadmeFileName;
    public static string BeginIgnoreMarker;
    public static string EndIgnoreMarker;
    internal static string PackageRelationshipNamespace;
    public static DateTimeOffset Unpublished;
    public static ICollection`1<string> AssemblyReferencesExtensions;
    public static string ResourceAssemblyExtension;
    public static string NativeTFM;
    public static string JSProjectExt;
    public static string VCXProjextExt;
    public static string ProjectExt;
    public static string TargetPlatformIdentifier;
    public static string TargetPlatformVersion;
    public static string TargetFrameworkMoniker;
    private static Constants();
}
internal class NuGet.ProjectManagement.DefaultProjectServices : object {
    [CompilerGeneratedAttribute]
private static INuGetProjectServices <Instance>k__BackingField;
    public static INuGetProjectServices Instance { get; }
    [ObsoleteAttribute]
public IProjectBuildProperties BuildProperties { get; }
    public IProjectSystemCapabilities Capabilities { get; }
    public IProjectSystemReferencesReader ReferencesReader { get; }
    public IProjectSystemService ProjectSystem { get; }
    public IProjectSystemReferencesService References { get; }
    public IProjectScriptHostService ScriptService { get; }
    public bool SupportsPackageReferences { get; }
    public bool NominatesOnSolutionLoad { get; }
    private static DefaultProjectServices();
    [CompilerGeneratedAttribute]
public static INuGetProjectServices get_Instance();
    public sealed virtual IProjectBuildProperties get_BuildProperties();
    public sealed virtual IProjectSystemCapabilities get_Capabilities();
    public sealed virtual IProjectSystemReferencesReader get_ReferencesReader();
    public sealed virtual IProjectSystemService get_ProjectSystem();
    public sealed virtual IProjectSystemReferencesService get_References();
    public sealed virtual IProjectScriptHostService get_ScriptService();
    public sealed virtual bool get_SupportsPackageReferences();
    public sealed virtual bool get_NominatesOnSolutionLoad();
    public sealed virtual Task AddOrUpdatePackageReferenceAsync(LibraryDependency packageReference, CancellationToken _);
    public sealed virtual Task`1<IEnumerable`1<LibraryDependency>> GetPackageReferencesAsync(NuGetFramework targetFramework, CancellationToken _);
    public sealed virtual Task`1<IEnumerable`1<ProjectRestoreReference>> GetProjectReferencesAsync(ILogger _, CancellationToken __);
    public sealed virtual string GetPropertyValue(string propertyName);
    public sealed virtual Task`1<string> GetPropertyValueAsync(string propertyName);
    public T GetGlobalService();
    public sealed virtual Task RemovePackageReferenceAsync(string packageName);
    public sealed virtual Task SaveProjectAsync(CancellationToken _);
    public sealed virtual Task ExecutePackageScriptAsync(PackageIdentity packageIdentity, string packageInstallPath, string scriptRelativePath, INuGetProjectContext projectContext, bool throwOnFailure, CancellationToken _);
    public sealed virtual Task`1<bool> ExecutePackageInitScriptAsync(PackageIdentity packageIdentity, string packageInstallPath, INuGetProjectContext projectContext, bool throwOnFailure, CancellationToken _);
}
public class NuGet.ProjectManagement.DependencyGraphCacheContext : object {
    [CompilerGeneratedAttribute]
private Dictionary`2<string, DependencyGraphSpec> <DependencyGraphCache>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, PackageSpec> <PackageSpecCache>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, IReadOnlyList`1<IDependencyGraphProject>> <DirectReferenceCache>k__BackingField;
    [CompilerGeneratedAttribute]
private ILogger <Logger>k__BackingField;
    [CompilerGeneratedAttribute]
private ISettings <Settings>k__BackingField;
    public Dictionary`2<string, DependencyGraphSpec> DependencyGraphCache { get; public set; }
    public Dictionary`2<string, PackageSpec> PackageSpecCache { get; public set; }
    public Dictionary`2<string, IReadOnlyList`1<IDependencyGraphProject>> DirectReferenceCache { get; public set; }
    public ILogger Logger { get; }
    public ISettings Settings { get; }
    public DependencyGraphCacheContext(ILogger logger, ISettings settings);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, DependencyGraphSpec> get_DependencyGraphCache();
    [CompilerGeneratedAttribute]
public void set_DependencyGraphCache(Dictionary`2<string, DependencyGraphSpec> value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, PackageSpec> get_PackageSpecCache();
    [CompilerGeneratedAttribute]
public void set_PackageSpecCache(Dictionary`2<string, PackageSpec> value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, IReadOnlyList`1<IDependencyGraphProject>> get_DirectReferenceCache();
    [CompilerGeneratedAttribute]
public void set_DirectReferenceCache(Dictionary`2<string, IReadOnlyList`1<IDependencyGraphProject>> value);
    [CompilerGeneratedAttribute]
public ILogger get_Logger();
    [CompilerGeneratedAttribute]
public ISettings get_Settings();
}
public class NuGet.ProjectManagement.EmptyNuGetProjectContext : object {
    [CompilerGeneratedAttribute]
private PackageExtractionContext <PackageExtractionContext>k__BackingField;
    [CompilerGeneratedAttribute]
private XDocument <OriginalPackagesConfig>k__BackingField;
    [CompilerGeneratedAttribute]
private NuGetActionType <ActionType>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <OperationId>k__BackingField;
    public PackageExtractionContext PackageExtractionContext { get; public set; }
    public ISourceControlManagerProvider SourceControlManagerProvider { get; }
    public ExecutionContext ExecutionContext { get; }
    public XDocument OriginalPackagesConfig { get; public set; }
    public NuGetActionType ActionType { get; public set; }
    public Guid OperationId { get; public set; }
    public sealed virtual void Log(MessageLevel level, string message, Object[] args);
    public sealed virtual FileConflictAction ResolveFileConflict(string message);
    [CompilerGeneratedAttribute]
public sealed virtual PackageExtractionContext get_PackageExtractionContext();
    [CompilerGeneratedAttribute]
public sealed virtual void set_PackageExtractionContext(PackageExtractionContext value);
    public sealed virtual ISourceControlManagerProvider get_SourceControlManagerProvider();
    public sealed virtual ExecutionContext get_ExecutionContext();
    [CompilerGeneratedAttribute]
public sealed virtual XDocument get_OriginalPackagesConfig();
    [CompilerGeneratedAttribute]
public sealed virtual void set_OriginalPackagesConfig(XDocument value);
    public sealed virtual void ReportError(string message);
    public sealed virtual void Log(ILogMessage message);
    public sealed virtual void ReportError(ILogMessage message);
    [CompilerGeneratedAttribute]
public sealed virtual NuGetActionType get_ActionType();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ActionType(NuGetActionType value);
    [CompilerGeneratedAttribute]
public sealed virtual Guid get_OperationId();
    [CompilerGeneratedAttribute]
public sealed virtual void set_OperationId(Guid value);
}
public abstract class NuGet.ProjectManagement.ExecutionContext : object {
    [CompilerGeneratedAttribute]
private PackageIdentity <DirectInstall>k__BackingField;
    public PackageIdentity DirectInstall { get; protected set; }
    public abstract virtual Task OpenFile(string fullPath);
    [CompilerGeneratedAttribute]
public PackageIdentity get_DirectInstall();
    [CompilerGeneratedAttribute]
protected void set_DirectInstall(PackageIdentity value);
}
public enum NuGet.ProjectManagement.FileConflictAction : Enum {
    public int value__;
    public static FileConflictAction PromptUser;
    public static FileConflictAction Overwrite;
    public static FileConflictAction OverwriteAll;
    public static FileConflictAction Ignore;
    public static FileConflictAction IgnoreAll;
}
public static class NuGet.ProjectManagement.FileSystemUtility : object {
    public static void MakeWritable(string fullPath);
    public static bool FileExists(string root, string path);
    public static string GetFullPath(string root, string path);
    public static void AddFile(string root, string path, Stream stream, INuGetProjectContext nuGetProjectContext);
    public static void AddFile(string root, string path, Action`1<Stream> writeToStream, INuGetProjectContext nuGetProjectContext);
    private static void AddFileCore(string root, string path, Action`1<Stream> writeToStream, INuGetProjectContext nuGetProjectContext);
    private static void WriteAddedFileAndDirectory(string path, INuGetProjectContext nuGetProjectContext);
    public static Stream CreateFile(string root, string path, INuGetProjectContext nuGetProjectContext);
    public static Stream CreateFile(string fullPath, INuGetProjectContext nuGetProjectContext);
    public static Stream CreateFile(string fullPath);
    public static Stream GetFileStream(string fullPath);
    public static IEnumerable`1<string> GetFiles(string root, string path, string filter);
    public static IEnumerable`1<string> GetFiles(string root, string path, string filter, bool recursive);
    public static void DeleteFile(string fullPath, INuGetProjectContext nuGetProjectContext);
    public static void DeleteFiles(IEnumerable`1<ZipFilePair> packageFiles, string packagesDir, INuGetProjectContext nuGetProjectContext);
    public static bool ContentEquals(string path, Func`1<Stream> streamFactory);
    [AsyncStateMachineAttribute("NuGet.ProjectManagement.FileSystemUtility/<ContentEqualsAsync>d__16")]
public static Task`1<bool> ContentEqualsAsync(string path, Func`1<Task`1<Stream>> streamTaskFactory);
    public static void PendAddFiles(IEnumerable`1<string> addedPackageFiles, string packagesDir, INuGetProjectContext nuGetProjectContext);
    public static bool DirectoryExists(string root, string path);
    public static void DeleteFileAndParentDirectoriesIfEmpty(string root, string filePath, INuGetProjectContext nuGetProjectContext);
    public static void DeleteDirectorySafe(string fullPath, bool recursive, INuGetProjectContext nuGetProjectContext);
    public static void DeleteDirectory(string fullPath, bool recursive, INuGetProjectContext nuGetProjectContext);
    public static IEnumerable`1<string> GetDirectories(string root, string path);
    [IteratorStateMachineAttribute("NuGet.ProjectManagement.FileSystemUtility/<GetDirectories>d__23")]
internal static IEnumerable`1<string> GetDirectories(string path, bool altDirectorySeparator);
    [IteratorStateMachineAttribute("NuGet.ProjectManagement.FileSystemUtility/<IndexOfAll>d__24")]
private static IEnumerable`1<int> IndexOfAll(string value, char ch);
    public static string MakeRelativePath(string root, string fullPath);
    public static string GetRelativePath(string root, string fullPath);
    internal static void DeleteFileSafe(string fullPath, INuGetProjectContext nuGetProjectContext);
    private static void DoSafeAction(Action action, INuGetProjectContext nuGetProjectContext);
    private static void Attempt(Action action, int retries, int delayBeforeRetry);
}
public class NuGet.ProjectManagement.FileTransformExtensions : object {
    [CompilerGeneratedAttribute]
private string <InstallExtension>k__BackingField;
    [CompilerGeneratedAttribute]
private string <UninstallExtension>k__BackingField;
    public string InstallExtension { get; }
    public string UninstallExtension { get; }
    public FileTransformExtensions(string installExtension, string uninstallExtension);
    [CompilerGeneratedAttribute]
public string get_InstallExtension();
    [CompilerGeneratedAttribute]
public string get_UninstallExtension();
    public sealed virtual bool Equals(FileTransformExtensions other);
    public virtual int GetHashCode();
}
public class NuGet.ProjectManagement.FolderNuGetProject : NuGetProject {
    [CompilerGeneratedAttribute]
private string <Root>k__BackingField;
    [CompilerGeneratedAttribute]
private PackagePathResolver <PackagePathResolver>k__BackingField;
    private NuGetFramework _framework;
    public string Root { get; public set; }
    private PackagePathResolver PackagePathResolver { get; private set; }
    public FolderNuGetProject(string root);
    public FolderNuGetProject(string root, PackagePathResolver packagePathResolver);
    public FolderNuGetProject(string root, PackagePathResolver packagePathResolver, NuGetFramework targetFramework);
    [CompilerGeneratedAttribute]
public string get_Root();
    [CompilerGeneratedAttribute]
public void set_Root(string value);
    [CompilerGeneratedAttribute]
private PackagePathResolver get_PackagePathResolver();
    [CompilerGeneratedAttribute]
private void set_PackagePathResolver(PackagePathResolver value);
    public virtual Task`1<IEnumerable`1<PackageReference>> GetInstalledPackagesAsync(CancellationToken token);
    public virtual Task`1<bool> InstallPackageAsync(PackageIdentity packageIdentity, DownloadResourceResult downloadResourceResult, INuGetProjectContext nuGetProjectContext, CancellationToken token);
    public virtual Task`1<bool> UninstallPackageAsync(PackageIdentity packageIdentity, INuGetProjectContext nuGetProjectContext, CancellationToken token);
    public bool PackageExists(PackageIdentity packageIdentity);
    public bool PackageExists(PackageIdentity packageIdentity, PackageSaveMode packageSaveMode);
    public bool ManifestExists(PackageIdentity packageIdentity);
    public bool PackageAndManifestExists(PackageIdentity packageIdentity);
    [AsyncStateMachineAttribute("NuGet.ProjectManagement.FolderNuGetProject/<CopySatelliteFilesAsync>d__19")]
public Task`1<bool> CopySatelliteFilesAsync(PackageIdentity packageIdentity, INuGetProjectContext nuGetProjectContext, CancellationToken token);
    public string GetInstalledPackageFilePath(PackageIdentity packageIdentity);
    public string GetInstalledManifestFilePath(PackageIdentity packageIdentity);
    public string GetPackageDownloadMarkerFilePath(PackageIdentity packageIdentity);
    public string GetInstalledPath(PackageIdentity packageIdentity);
    [AsyncStateMachineAttribute("NuGet.ProjectManagement.FolderNuGetProject/<DeletePackage>d__24")]
public Task`1<bool> DeletePackage(PackageIdentity packageIdentity, INuGetProjectContext nuGetProjectContext, CancellationToken token);
    private PackageSaveMode GetPackageSaveMode(INuGetProjectContext nuGetProjectContext);
}
public interface NuGet.ProjectManagement.IDependencyGraphProject {
    public string MSBuildProjectPath { get; }
    public abstract virtual string get_MSBuildProjectPath();
    public abstract virtual Task`1<IReadOnlyList`1<PackageSpec>> GetPackageSpecsAsync(DependencyGraphCacheContext context);
    public abstract virtual Task`1<ValueTuple`2<IReadOnlyList`1<PackageSpec>, IReadOnlyList`1<IAssetsLogMessage>>> GetPackageSpecsAndAdditionalMessagesAsync(DependencyGraphCacheContext context);
}
public enum NuGet.ProjectManagement.ImportLocation : Enum {
    public int value__;
    public static ImportLocation Top;
    public static ImportLocation Bottom;
}
public interface NuGet.ProjectManagement.IMSBuildNuGetProjectContext {
    public bool SkipAssemblyReferences { get; }
    public bool BindingRedirectsDisabled { get; }
    public abstract virtual bool get_SkipAssemblyReferences();
    public abstract virtual bool get_BindingRedirectsDisabled();
}
public interface NuGet.ProjectManagement.IMSBuildProjectSystem {
    public NuGetFramework TargetFramework { get; }
    public string ProjectName { get; }
    public string ProjectUniqueName { get; }
    public string ProjectFullPath { get; }
    public string ProjectFileFullPath { get; }
    public INuGetProjectContext NuGetProjectContext { get; public set; }
    public abstract virtual NuGetFramework get_TargetFramework();
    public abstract virtual string get_ProjectName();
    public abstract virtual string get_ProjectUniqueName();
    public abstract virtual string get_ProjectFullPath();
    public abstract virtual string get_ProjectFileFullPath();
    public abstract virtual INuGetProjectContext get_NuGetProjectContext();
    public abstract virtual void set_NuGetProjectContext(INuGetProjectContext value);
    public abstract virtual void AddFile(string path, Stream stream);
    public abstract virtual void AddExistingFile(string path);
    public abstract virtual void RemoveFile(string path);
    public abstract virtual bool FileExistsInProject(string path);
    public abstract virtual Task AddReferenceAsync(string referencePath);
    public abstract virtual Task RemoveReferenceAsync(string name);
    public abstract virtual Task`1<bool> ReferenceExistsAsync(string name);
    public abstract virtual Task AddFrameworkReferenceAsync(string name, string packageId);
    public abstract virtual void AddImport(string targetFullPath, ImportLocation location);
    public abstract virtual void RemoveImport(string targetFullPath);
    public abstract virtual object GetPropertyValue(string propertyName);
    public abstract virtual string ResolvePath(string path);
    public abstract virtual bool IsSupportedFile(string path);
    public abstract virtual void AddBindingRedirects();
    public abstract virtual Task BeginProcessingAsync();
    public abstract virtual void RegisterProcessedFiles(IEnumerable`1<string> files);
    public abstract virtual Task EndProcessingAsync();
    public abstract virtual void DeleteDirectory(string path, bool recursive);
    public abstract virtual IEnumerable`1<string> GetFiles(string path, string filter, bool recursive);
    public abstract virtual IEnumerable`1<string> GetFullPaths(string fileName);
    public abstract virtual IEnumerable`1<string> GetDirectories(string path);
}
public class NuGet.ProjectManagement.InternalZipFileInfo : object {
    [CompilerGeneratedAttribute]
private string <ZipArchivePath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ZipArchiveEntryFullName>k__BackingField;
    public string ZipArchivePath { get; private set; }
    public string ZipArchiveEntryFullName { get; private set; }
    public InternalZipFileInfo(string zipArchivePath, string zipArchiveEntryFullName);
    [CompilerGeneratedAttribute]
public string get_ZipArchivePath();
    [CompilerGeneratedAttribute]
private void set_ZipArchivePath(string value);
    [CompilerGeneratedAttribute]
public string get_ZipArchiveEntryFullName();
    [CompilerGeneratedAttribute]
private void set_ZipArchiveEntryFullName(string value);
}
public interface NuGet.ProjectManagement.INuGetProjectContext {
    public PackageExtractionContext PackageExtractionContext { get; public set; }
    public ISourceControlManagerProvider SourceControlManagerProvider { get; }
    public ExecutionContext ExecutionContext { get; }
    public XDocument OriginalPackagesConfig { get; public set; }
    public NuGetActionType ActionType { get; public set; }
    public Guid OperationId { get; public set; }
    public abstract virtual void Log(MessageLevel level, string message, Object[] args);
    public abstract virtual void Log(ILogMessage message);
    public abstract virtual void ReportError(string message);
    public abstract virtual void ReportError(ILogMessage message);
    public abstract virtual FileConflictAction ResolveFileConflict(string message);
    public abstract virtual PackageExtractionContext get_PackageExtractionContext();
    public abstract virtual void set_PackageExtractionContext(PackageExtractionContext value);
    public abstract virtual ISourceControlManagerProvider get_SourceControlManagerProvider();
    public abstract virtual ExecutionContext get_ExecutionContext();
    public abstract virtual XDocument get_OriginalPackagesConfig();
    public abstract virtual void set_OriginalPackagesConfig(XDocument value);
    public abstract virtual NuGetActionType get_ActionType();
    public abstract virtual void set_ActionType(NuGetActionType value);
    public abstract virtual Guid get_OperationId();
    public abstract virtual void set_OperationId(Guid value);
}
public interface NuGet.ProjectManagement.INuGetProjectServices {
    [ObsoleteAttribute]
public IProjectBuildProperties BuildProperties { get; }
    public IProjectSystemCapabilities Capabilities { get; }
    public IProjectSystemReferencesReader ReferencesReader { get; }
    public IProjectSystemReferencesService References { get; }
    public IProjectSystemService ProjectSystem { get; }
    public IProjectScriptHostService ScriptService { get; }
    public abstract virtual IProjectBuildProperties get_BuildProperties();
    public abstract virtual IProjectSystemCapabilities get_Capabilities();
    public abstract virtual IProjectSystemReferencesReader get_ReferencesReader();
    public abstract virtual IProjectSystemReferencesService get_References();
    public abstract virtual IProjectSystemService get_ProjectSystem();
    public abstract virtual IProjectScriptHostService get_ScriptService();
}
public interface NuGet.ProjectManagement.IPackageEventsProvider {
    public abstract virtual PackageEvents GetPackageEvents();
}
public interface NuGet.ProjectManagement.IPackageFileTransformer {
    public abstract virtual Task TransformFileAsync(Func`1<Task`1<Stream>> streamTaskFactory, string targetPath, IMSBuildProjectSystem projectSystem, CancellationToken cancellationToken);
    public abstract virtual Task RevertFileAsync(Func`1<Task`1<Stream>> streamTaskFactory, string targetPath, IEnumerable`1<InternalZipFileInfo> matchingFiles, IMSBuildProjectSystem projectSystem, CancellationToken cancellationToken);
}
[ObsoleteAttribute("This was only used by NuGet's VS extension, so has been moved there")]
public interface NuGet.ProjectManagement.IProjectBuildProperties {
    public abstract virtual string GetPropertyValue(string propertyName);
    public abstract virtual Task`1<string> GetPropertyValueAsync(string propertyName);
}
public interface NuGet.ProjectManagement.IProjectScriptHostService {
    public abstract virtual Task ExecutePackageScriptAsync(PackageIdentity packageIdentity, string packageInstallPath, string scriptRelativePath, INuGetProjectContext projectContext, bool throwOnFailure, CancellationToken token);
    public abstract virtual Task`1<bool> ExecutePackageInitScriptAsync(PackageIdentity packageIdentity, string packageInstallPath, INuGetProjectContext projectContext, bool throwOnFailure, CancellationToken token);
}
public interface NuGet.ProjectManagement.IProjectSystemCapabilities {
    public bool SupportsPackageReferences { get; }
    public bool NominatesOnSolutionLoad { get; }
    public abstract virtual bool get_SupportsPackageReferences();
    public abstract virtual bool get_NominatesOnSolutionLoad();
}
public interface NuGet.ProjectManagement.IProjectSystemReferencesReader {
    public abstract virtual Task`1<IEnumerable`1<LibraryDependency>> GetPackageReferencesAsync(NuGetFramework targetFramework, CancellationToken token);
    public abstract virtual Task`1<IEnumerable`1<ProjectRestoreReference>> GetProjectReferencesAsync(ILogger logger, CancellationToken token);
}
public interface NuGet.ProjectManagement.IProjectSystemReferencesService {
    public abstract virtual Task AddOrUpdatePackageReferenceAsync(LibraryDependency packageReference, CancellationToken token);
    public abstract virtual Task RemovePackageReferenceAsync(string packageName);
}
public interface NuGet.ProjectManagement.IProjectSystemService {
    public abstract virtual Task SaveProjectAsync(CancellationToken token);
}
public interface NuGet.ProjectManagement.ISourceControlManagerProvider {
    public abstract virtual SourceControlManager GetSourceControlManager();
}
public static class NuGet.ProjectManagement.JsonConfigUtility : object {
    private static string DEPENDENCIES_TAG;
    private static string FRAMEWORKS_TAG;
    [IteratorStateMachineAttribute("NuGet.ProjectManagement.JsonConfigUtility/<GetDependencies>d__2")]
public static IEnumerable`1<PackageDependency> GetDependencies(JObject json);
    public static PackageDependency ParseDependency(JToken dependencyToken);
    public static void AddDependency(JObject json, PackageIdentity package);
    public static void AddDependency(JObject json, PackageDependency dependency);
    public static void RemoveDependency(JObject json, string packageId);
    public static IEnumerable`1<NuGetFramework> GetFrameworks(JObject json);
    public static void AddFramework(JObject json, NuGetFramework framework);
    public static void ClearFrameworks(JObject json);
    private static JObject SortProperties(JObject parent);
    private static bool HasFramework(IEnumerable`1<NuGetFramework> list, NuGetFramework framework);
    private static string GetChildKey(JToken token);
}
public class NuGet.ProjectManagement.LoggerAdapter : LegacyLoggerAdapter {
    [CompilerGeneratedAttribute]
private INuGetProjectContext <ProjectLogger>k__BackingField;
    public INuGetProjectContext ProjectLogger { get; }
    public LoggerAdapter(INuGetProjectContext projectLogger);
    [CompilerGeneratedAttribute]
public INuGetProjectContext get_ProjectLogger();
    public virtual void LogDebug(string data);
    public virtual void LogError(string data);
    public virtual void LogInformation(string data);
    public virtual void LogMinimal(string data);
    public virtual void LogVerbose(string data);
    public virtual void LogWarning(string data);
    public virtual void LogInformationSummary(string data);
    public virtual void Log(ILogMessage message);
    public virtual Task LogAsync(ILogMessage message);
}
public enum NuGet.ProjectManagement.MessageLevel : Enum {
    public int value__;
    public static MessageLevel Info;
    public static MessageLevel Warning;
    public static MessageLevel Debug;
    public static MessageLevel Error;
}
[ExtensionAttribute]
public static class NuGet.ProjectManagement.MessageLevelExtensions : object {
    [ExtensionAttribute]
public static LogLevel ToLogLevel(MessageLevel messageLevel);
}
[DebuggerDisplayAttribute("{ProjectSystem.ProjectName} [{ProjectStyle}]")]
public class NuGet.ProjectManagement.MSBuildNuGetProject : NuGetProject {
    private IDictionary`2<FileTransformExtensions, IPackageFileTransformer> FileTransformers;
    [CompilerGeneratedAttribute]
private EventHandler`1<PackageEventArgs> PackageInstalling;
    [CompilerGeneratedAttribute]
private EventHandler`1<PackageEventArgs> PackageInstalled;
    [CompilerGeneratedAttribute]
private EventHandler`1<PackageEventArgs> PackageUninstalling;
    [CompilerGeneratedAttribute]
private EventHandler`1<PackageEventArgs> PackageUninstalled;
    [CompilerGeneratedAttribute]
private EventHandler`1<PackageEventArgs> PackageReferenceAdded;
    [CompilerGeneratedAttribute]
private EventHandler`1<PackageEventArgs> PackageReferenceRemoved;
    [CompilerGeneratedAttribute]
private IMSBuildProjectSystem <ProjectSystem>k__BackingField;
    [CompilerGeneratedAttribute]
private FolderNuGetProject <FolderNuGetProject>k__BackingField;
    [CompilerGeneratedAttribute]
private PackagesConfigNuGetProject <PackagesConfigNuGetProject>k__BackingField;
    public IMSBuildProjectSystem ProjectSystem { get; }
    public FolderNuGetProject FolderNuGetProject { get; }
    public PackagesConfigNuGetProject PackagesConfigNuGetProject { get; }
    public string MSBuildProjectPath { get; }
    public MSBuildNuGetProject(IMSBuildProjectSystem msbuildNuGetProjectSystem, string folderNuGetProjectPath, string packagesConfigFolderPath);
    [CompilerGeneratedAttribute]
public void add_PackageInstalling(EventHandler`1<PackageEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_PackageInstalling(EventHandler`1<PackageEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_PackageInstalled(EventHandler`1<PackageEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_PackageInstalled(EventHandler`1<PackageEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_PackageUninstalling(EventHandler`1<PackageEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_PackageUninstalling(EventHandler`1<PackageEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_PackageUninstalled(EventHandler`1<PackageEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_PackageUninstalled(EventHandler`1<PackageEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_PackageReferenceAdded(EventHandler`1<PackageEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_PackageReferenceAdded(EventHandler`1<PackageEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_PackageReferenceRemoved(EventHandler`1<PackageEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_PackageReferenceRemoved(EventHandler`1<PackageEventArgs> value);
    [CompilerGeneratedAttribute]
public IMSBuildProjectSystem get_ProjectSystem();
    [CompilerGeneratedAttribute]
public FolderNuGetProject get_FolderNuGetProject();
    [CompilerGeneratedAttribute]
public PackagesConfigNuGetProject get_PackagesConfigNuGetProject();
    public sealed virtual string get_MSBuildProjectPath();
    public virtual Task`1<IEnumerable`1<PackageReference>> GetInstalledPackagesAsync(CancellationToken token);
    public bool DoesPackagesConfigExists();
    public void AddBindingRedirects();
    private static bool IsBindingRedirectsDisabled(INuGetProjectContext nuGetProjectContext);
    private static bool IsSkipAssemblyReferences(INuGetProjectContext nuGetProjectContext);
    [AsyncStateMachineAttribute("NuGet.ProjectManagement.MSBuildNuGetProject/<InstallPackageAsync>d__36")]
public virtual Task`1<bool> InstallPackageAsync(PackageIdentity packageIdentity, DownloadResourceResult downloadResourceResult, INuGetProjectContext nuGetProjectContext, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.ProjectManagement.MSBuildNuGetProject/<UninstallPackageAsync>d__37")]
public virtual Task`1<bool> UninstallPackageAsync(PackageIdentity packageIdentity, INuGetProjectContext nuGetProjectContext, CancellationToken token);
    public virtual Task PostProcessAsync(INuGetProjectContext nuGetProjectContext, CancellationToken token);
    private static bool IsAssemblyReference(string filePath);
    private static IDictionary`2<XName, Action`2<XElement, XElement>> GetConfigMappings();
    [AsyncStateMachineAttribute("NuGet.ProjectManagement.MSBuildNuGetProject/<GetPackageSpecsAsync>d__41")]
public sealed virtual Task`1<IReadOnlyList`1<PackageSpec>> GetPackageSpecsAsync(DependencyGraphCacheContext context);
    [AsyncStateMachineAttribute("NuGet.ProjectManagement.MSBuildNuGetProject/<GetPackageSpecsAndAdditionalMessagesAsync>d__42")]
public sealed virtual Task`1<ValueTuple`2<IReadOnlyList`1<PackageSpec>, IReadOnlyList`1<IAssetsLogMessage>>> GetPackageSpecsAndAdditionalMessagesAsync(DependencyGraphCacheContext context);
}
public static class NuGet.ProjectManagement.MSBuildNuGetProjectSystemUtility : object {
    internal static XDocument GetOrCreateDocument(XName rootName, string path, IMSBuildProjectSystem msBuildNuGetProjectSystem);
    public static FrameworkSpecificGroup GetMostCompatibleGroup(NuGetFramework projectTargetFramework, IEnumerable`1<FrameworkSpecificGroup> itemGroups);
    public static FrameworkSpecificGroup Normalize(FrameworkSpecificGroup group);
    public static bool IsValid(FrameworkSpecificGroup frameworkSpecificGroup);
    [AsyncStateMachineAttribute("NuGet.ProjectManagement.MSBuildNuGetProjectSystemUtility/<TryAddFileAsync>d__4")]
internal static Task TryAddFileAsync(IMSBuildProjectSystem projectSystem, string path, Func`1<Task`1<Stream>> streamTaskFactory, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.ProjectManagement.MSBuildNuGetProjectSystemUtility/<AddFilesAsync>d__5")]
internal static Task AddFilesAsync(IMSBuildProjectSystem projectSystem, IAsyncPackageCoreReader packageReader, FrameworkSpecificGroup frameworkSpecificGroup, IDictionary`2<FileTransformExtensions, IPackageFileTransformer> fileTransformers, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.ProjectManagement.MSBuildNuGetProjectSystemUtility/<DeleteFilesAsync>d__6")]
internal static Task DeleteFilesAsync(IMSBuildProjectSystem projectSystem, ZipArchive zipArchive, IEnumerable`1<string> otherPackagesPath, FrameworkSpecificGroup frameworkSpecificGroup, IDictionary`2<FileTransformExtensions, IPackageFileTransformer> fileTransformers, CancellationToken cancellationToken);
    internal static IEnumerable`1<string> GetFilesSafe(IMSBuildProjectSystem projectSystem, string path);
    internal static IEnumerable`1<string> GetFilesSafe(IMSBuildProjectSystem projectSystem, string path, string filter);
    internal static IEnumerable`1<string> GetFiles(IMSBuildProjectSystem projectSystem, string path, string filter, bool recursive);
    [AsyncStateMachineAttribute("NuGet.ProjectManagement.MSBuildNuGetProjectSystemUtility/<DeleteFileSafeAsync>d__10")]
internal static Task DeleteFileSafeAsync(string path, Func`1<Task`1<Stream>> streamFactory, IMSBuildProjectSystem projectSystem, CancellationToken cancellationToken);
    internal static IEnumerable`1<string> GetDirectoriesSafe(IMSBuildProjectSystem projectSystem, string path);
    internal static IEnumerable`1<string> GetDirectories(IMSBuildProjectSystem projectSystem, string path);
    internal static void DeleteDirectorySafe(IMSBuildProjectSystem projectSystem, string path);
    private static void DeleteDirectory(IMSBuildProjectSystem projectSystem, string path);
    private static void PerformSafeAction(Action action, INuGetProjectContext nuGetProjectContext);
    private static void Attempt(Action action, int retries, int delayBeforeRetry);
    private static bool IsEmptyFolder(string packageFilePath);
    private static string ResolvePath(IDictionary`2<FileTransformExtensions, IPackageFileTransformer> fileTransformers, Func`2<FileTransformExtensions, string> extensionSelector, string effectivePath);
    private static string ResolveTargetPath(IMSBuildProjectSystem projectSystem, IDictionary`2<FileTransformExtensions, IPackageFileTransformer> fileTransformers, Func`2<FileTransformExtensions, string> extensionSelector, string effectivePath, IPackageFileTransformer& transformer);
    private static IPackageFileTransformer FindFileTransformer(IDictionary`2<FileTransformExtensions, IPackageFileTransformer> fileTransformers, Func`2<FileTransformExtensions, string> extensionSelector, string effectivePath, String& truncatedPath);
    private static string GetEffectivePathForContentFile(NuGetFramework nuGetFramework, string zipArchiveEntryFullName);
    internal static IEnumerable`1<string> GetValidPackageItems(IEnumerable`1<string> items);
    internal static void AddFile(IMSBuildProjectSystem projectSystem, string path, Action`1<Stream> writeToStream);
}
public enum NuGet.ProjectManagement.NuGetActionType : Enum {
    public int value__;
    public static NuGetActionType Install;
    public static NuGetActionType Uninstall;
    public static NuGetActionType Reinstall;
    public static NuGetActionType Update;
    public static NuGetActionType UpdateAll;
}
public abstract class NuGet.ProjectManagement.NuGetProject : object {
    [CompilerGeneratedAttribute]
private Dictionary`2<string, object> <InternalMetadata>k__BackingField;
    [CompilerGeneratedAttribute]
private INuGetProjectServices <ProjectServices>k__BackingField;
    [CompilerGeneratedAttribute]
private ProjectStyle <ProjectStyle>k__BackingField;
    protected Dictionary`2<string, object> InternalMetadata { get; }
    public IReadOnlyDictionary`2<string, object> Metadata { get; }
    public INuGetProjectServices ProjectServices { get; protected set; }
    public ProjectStyle ProjectStyle { get; protected set; }
    protected NuGetProject(Dictionary`2<string, object> optionalMetadata);
    [CompilerGeneratedAttribute]
protected Dictionary`2<string, object> get_InternalMetadata();
    public IReadOnlyDictionary`2<string, object> get_Metadata();
    [CompilerGeneratedAttribute]
public INuGetProjectServices get_ProjectServices();
    [CompilerGeneratedAttribute]
protected void set_ProjectServices(INuGetProjectServices value);
    [CompilerGeneratedAttribute]
public ProjectStyle get_ProjectStyle();
    [CompilerGeneratedAttribute]
protected void set_ProjectStyle(ProjectStyle value);
    public abstract virtual Task`1<bool> InstallPackageAsync(PackageIdentity packageIdentity, DownloadResourceResult downloadResourceResult, INuGetProjectContext nuGetProjectContext, CancellationToken token);
    public abstract virtual Task`1<bool> UninstallPackageAsync(PackageIdentity packageIdentity, INuGetProjectContext nuGetProjectContext, CancellationToken token);
    public abstract virtual Task`1<IEnumerable`1<PackageReference>> GetInstalledPackagesAsync(CancellationToken token);
    public virtual Task PreProcessAsync(INuGetProjectContext nuGetProjectContext, CancellationToken token);
    public virtual Task PostProcessAsync(INuGetProjectContext nuGetProjectContext, CancellationToken token);
    public T GetMetadata(string key);
    public bool TryGetMetadata(string key, T& value);
    public object GetMetadataOrNull(string key);
    public Task SaveAsync(CancellationToken token);
    public static string GetUniqueNameOrName(NuGetProject nuGetProject);
}
public static class NuGet.ProjectManagement.NuGetProjectMetadataKeys : object {
    public static string Name;
    public static string UniqueName;
    public static string TargetFramework;
    public static string FullPath;
    public static string SupportedFrameworks;
    public static string ProjectId;
}
public class NuGet.ProjectManagement.PackageEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private PackageIdentity <Identity>k__BackingField;
    [CompilerGeneratedAttribute]
private string <InstallPath>k__BackingField;
    [CompilerGeneratedAttribute]
private NuGetProject <Project>k__BackingField;
    public PackageIdentity Identity { get; }
    public string InstallPath { get; }
    public NuGetProject Project { get; }
    public PackageEventArgs(NuGetProject project, PackageIdentity identity, string installPath);
    [CompilerGeneratedAttribute]
public PackageIdentity get_Identity();
    [CompilerGeneratedAttribute]
public string get_InstallPath();
    [CompilerGeneratedAttribute]
public NuGetProject get_Project();
}
public class NuGet.ProjectManagement.PackageEvents : object {
    [CompilerGeneratedAttribute]
private EventHandler`1<PackageEventArgs> PackageInstalling;
    [CompilerGeneratedAttribute]
private EventHandler`1<PackageEventArgs> PackageInstalled;
    [CompilerGeneratedAttribute]
private EventHandler`1<PackageEventArgs> PackageUninstalling;
    [CompilerGeneratedAttribute]
private EventHandler`1<PackageEventArgs> PackageUninstalled;
    [CompilerGeneratedAttribute]
private EventHandler`1<PackageEventArgs> PackageReferenceAdded;
    [CompilerGeneratedAttribute]
private EventHandler`1<PackageEventArgs> PackageReferenceRemoved;
    [CompilerGeneratedAttribute]
public void add_PackageInstalling(EventHandler`1<PackageEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_PackageInstalling(EventHandler`1<PackageEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_PackageInstalled(EventHandler`1<PackageEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_PackageInstalled(EventHandler`1<PackageEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_PackageUninstalling(EventHandler`1<PackageEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_PackageUninstalling(EventHandler`1<PackageEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_PackageUninstalled(EventHandler`1<PackageEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_PackageUninstalled(EventHandler`1<PackageEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_PackageReferenceAdded(EventHandler`1<PackageEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_PackageReferenceAdded(EventHandler`1<PackageEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_PackageReferenceRemoved(EventHandler`1<PackageEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_PackageReferenceRemoved(EventHandler`1<PackageEventArgs> value);
    internal void NotifyInstalling(PackageEventArgs e);
    internal void NotifyInstalled(PackageEventArgs e);
    internal void NotifyUninstalling(PackageEventArgs e);
    internal void NotifyUninstalled(PackageEventArgs e);
    internal void NotifyReferenceAdded(PackageEventArgs e);
    internal void NotifyReferenceRemoved(PackageEventArgs e);
}
[ExportAttribute("NuGet.ProjectManagement.IPackageEventsProvider")]
public class NuGet.ProjectManagement.PackageEventsProvider : object {
    private static PackageEvents _instance;
    internal static PackageEvents Instance { get; }
    public sealed virtual PackageEvents GetPackageEvents();
    internal static PackageEvents get_Instance();
}
public class NuGet.ProjectManagement.PackagesConfigNuGetProject : NuGetProject {
    private object _configLock;
    [CompilerGeneratedAttribute]
private bool <UsingPackagesProjectNameConfigPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PackagesConfigPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PackagesProjectNameConfigPath>k__BackingField;
    [CompilerGeneratedAttribute]
private NuGetFramework <TargetFramework>k__BackingField;
    public string FullPath { get; }
    private bool UsingPackagesProjectNameConfigPath { get; private set; }
    private string PackagesConfigPath { get; }
    private string PackagesProjectNameConfigPath { get; }
    private NuGetFramework TargetFramework { get; }
    public PackagesConfigNuGetProject(string folderPath, Dictionary`2<string, object> metadata);
    public string get_FullPath();
    [CompilerGeneratedAttribute]
private bool get_UsingPackagesProjectNameConfigPath();
    [CompilerGeneratedAttribute]
private void set_UsingPackagesProjectNameConfigPath(bool value);
    [CompilerGeneratedAttribute]
private string get_PackagesConfigPath();
    [CompilerGeneratedAttribute]
private string get_PackagesProjectNameConfigPath();
    [CompilerGeneratedAttribute]
private NuGetFramework get_TargetFramework();
    [AsyncStateMachineAttribute("NuGet.ProjectManagement.PackagesConfigNuGetProject/<InstallPackageAsync>d__17")]
public virtual Task`1<bool> InstallPackageAsync(PackageIdentity packageIdentity, DownloadResourceResult downloadResourceResult, INuGetProjectContext nuGetProjectContext, CancellationToken token);
    public virtual Task`1<bool> UninstallPackageAsync(PackageIdentity packageIdentity, INuGetProjectContext nuGetProjectContext, CancellationToken token);
    public virtual Task`1<IEnumerable`1<PackageReference>> GetInstalledPackagesAsync(CancellationToken token);
    public bool PackagesConfigExists();
    public XDocument GetPackagesConfig();
    private void UpdateFullPath();
    private List`1<PackageReference> GetInstalledPackagesList();
    [AsyncStateMachineAttribute("NuGet.ProjectManagement.PackagesConfigNuGetProject/<CheckDevelopmentDependencyAsync>d__24")]
private static Task`1<bool> CheckDevelopmentDependencyAsync(DownloadResourceResult downloadResourceResult, CancellationToken token);
}
public static class NuGet.ProjectManagement.PowerShellScripts : object {
    public static string Install;
    public static string Uninstall;
    public static string Init;
    public static string InitPS1RelativePath;
    private static PowerShellScripts();
}
public class NuGet.ProjectManagement.Preprocessor : object {
    [AsyncStateMachineAttribute("NuGet.ProjectManagement.Preprocessor/<TransformFileAsync>d__0")]
public sealed virtual Task TransformFileAsync(Func`1<Task`1<Stream>> streamTaskFactory, string targetPath, IMSBuildProjectSystem projectSystem, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.ProjectManagement.Preprocessor/<RevertFileAsync>d__1")]
public sealed virtual Task RevertFileAsync(Func`1<Task`1<Stream>> streamTaskFactory, string targetPath, IEnumerable`1<InternalZipFileInfo> matchingFiles, IMSBuildProjectSystem projectSystem, CancellationToken cancellationToken);
    internal static Task`1<string> ProcessAsync(Func`1<Task`1<Stream>> streamTaskFactory, IMSBuildProjectSystem projectSystem, CancellationToken cancellationToken);
}
public static class NuGet.ProjectManagement.ProjectBuildProperties : object {
    public static string MSBuildProjectExtensionsPath;
    public static string PackageTargetFallback;
    public static string AssetTargetFallback;
    public static string PackageVersion;
    public static string RestoreProjectStyle;
    public static string RuntimeIdentifier;
    public static string RuntimeIdentifiers;
    public static string RuntimeSupports;
    public static string TargetFramework;
    public static string TargetFrameworkIdentifier;
    public static string TargetFrameworkMoniker;
    public static string TargetFrameworkProfile;
    public static string TargetFrameworkVersion;
    public static string TargetFrameworks;
    public static string TargetPlatformIdentifier;
    public static string TargetPlatformMoniker;
    public static string TargetPlatformMinVersion;
    public static string CLRSupport;
    public static string WindowsTargetPlatformMinVersion;
    public static string TargetPlatformVersion;
    public static string Version;
    public static string RestorePackagesPath;
    public static string RestoreSources;
    public static string RestoreFallbackFolders;
    public static string ProjectTypeGuids;
    public static string RestoreAdditionalProjectSources;
    public static string RestoreAdditionalProjectFallbackFolders;
    public static string RestoreAdditionalProjectFallbackFoldersExcludes;
    public static string NoWarn;
    public static string WarningsAsErrors;
    public static string WarningsNotAsErrors;
    public static string TreatWarningsAsErrors;
    public static string DotnetCliToolTargetFramework;
    public static string RestorePackagesWithLockFile;
    public static string NuGetLockFilePath;
    public static string RestoreLockedMode;
    public static string PackageId;
    public static string IncludeAssets;
    public static string ExcludeAssets;
    public static string PrivateAssets;
    public static string ReferenceOutputAssembly;
    public static string Clear;
    public static string RuntimeIdentifierGraphPath;
    public static string ManagePackageVersionsCentrally;
    public static string CentralPackageVersionOverrideEnabled;
    public static string AssemblyName;
    public static string CentralPackageTransitivePinningEnabled;
    public static string NuGetAudit;
    public static string NuGetAuditLevel;
    public static string NuGetAuditMode;
    public static string CentralPackageFloatingVersionsEnabled;
}
public static class NuGet.ProjectManagement.ProjectItemProperties : object {
    public static string IncludeAssets;
    public static string ExcludeAssets;
    public static string PrivateAssets;
    public static string IsImplicitlyDefined;
    public static string NoWarn;
    public static string GeneratePathProperty;
    public static string Aliases;
    public static string VersionOverride;
}
public static class NuGet.ProjectManagement.ProjectItems : object {
    public static string PackageReference;
    public static string ProjectReference;
}
[DebuggerDisplayAttribute("{ProjectName} [{ProjectStyle}]")]
public abstract class NuGet.ProjectManagement.Projects.BuildIntegratedNuGetProject : NuGetProject {
    public string ProjectName { get; }
    public string MSBuildProjectPath { get; }
    public abstract virtual string get_ProjectName();
    public abstract virtual string get_MSBuildProjectPath();
    public abstract virtual Task`1<string> GetAssetsFilePathAsync();
    public abstract virtual Task`1<string> GetCacheFilePathAsync();
    public abstract virtual Task`1<string> GetAssetsFilePathOrNullAsync();
    public abstract virtual Task AddFileToProjectAsync(string filePath);
    public abstract virtual Task`1<IReadOnlyList`1<PackageSpec>> GetPackageSpecsAsync(DependencyGraphCacheContext context);
    public abstract virtual Task`1<ValueTuple`2<IReadOnlyList`1<PackageSpec>, IReadOnlyList`1<IAssetsLogMessage>>> GetPackageSpecsAndAdditionalMessagesAsync(DependencyGraphCacheContext context);
    public abstract virtual Task`1<bool> InstallPackageAsync(string packageId, VersionRange range, INuGetProjectContext nuGetProjectContext, BuildIntegratedInstallationContext installationContext, CancellationToken token);
    public sealed virtual Task`1<bool> InstallPackageAsync(PackageIdentity packageIdentity, DownloadResourceResult downloadResourceResult, INuGetProjectContext nuGetProjectContext, CancellationToken token);
    public abstract virtual Task`1<bool> UninstallPackageAsync(string packageId, BuildIntegratedInstallationContext installationContext, CancellationToken token);
}
public interface NuGet.ProjectManagement.Projects.INuGetIntegratedProject {
}
public class NuGet.ProjectManagement.Projects.ProjectJsonNuGetProject : BuildIntegratedNuGetProject {
    private FileInfo _jsonConfig;
    private string _projectName;
    [CompilerGeneratedAttribute]
private string <MSBuildProjectPath>k__BackingField;
    public string JsonConfigPath { get; }
    public string MSBuildProjectPath { get; }
    public string ProjectName { get; }
    public ProjectJsonNuGetProject(string jsonConfig, string msBuildProjectPath);
    public virtual Task`1<string> GetAssetsFilePathAsync();
    public virtual Task`1<string> GetAssetsFilePathOrNullAsync();
    public virtual Task AddFileToProjectAsync(string filePath);
    public string get_JsonConfigPath();
    [CompilerGeneratedAttribute]
public virtual string get_MSBuildProjectPath();
    public virtual string get_ProjectName();
    protected virtual Task UpdateInternalTargetFrameworkAsync();
    [AsyncStateMachineAttribute("NuGet.ProjectManagement.Projects.ProjectJsonNuGetProject/<GetInstalledPackagesAsync>d__14")]
public virtual Task`1<IEnumerable`1<PackageReference>> GetInstalledPackagesAsync(CancellationToken token);
    protected virtual Task`1<string> GetMSBuildProjectExtensionsPathAsync();
    [AsyncStateMachineAttribute("NuGet.ProjectManagement.Projects.ProjectJsonNuGetProject/<GetPackageSpecsAsync>d__16")]
public virtual Task`1<IReadOnlyList`1<PackageSpec>> GetPackageSpecsAsync(DependencyGraphCacheContext context);
    [AsyncStateMachineAttribute("NuGet.ProjectManagement.Projects.ProjectJsonNuGetProject/<GetPackageSpecsAndAdditionalMessagesAsync>d__17")]
public virtual Task`1<ValueTuple`2<IReadOnlyList`1<PackageSpec>, IReadOnlyList`1<IAssetsLogMessage>>> GetPackageSpecsAndAdditionalMessagesAsync(DependencyGraphCacheContext context);
    [AsyncStateMachineAttribute("NuGet.ProjectManagement.Projects.ProjectJsonNuGetProject/<InstallPackageAsync>d__18")]
public virtual Task`1<bool> InstallPackageAsync(string packageId, VersionRange range, INuGetProjectContext nuGetProjectContext, BuildIntegratedInstallationContext installationContext, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.ProjectManagement.Projects.ProjectJsonNuGetProject/<RemoveDependencyAsync>d__19")]
public Task`1<bool> RemoveDependencyAsync(string packageId, INuGetProjectContext nuGetProjectContext, CancellationToken token);
    [AsyncStateMachineAttribute("NuGet.ProjectManagement.Projects.ProjectJsonNuGetProject/<UninstallPackageAsync>d__20")]
public virtual Task`1<bool> UninstallPackageAsync(PackageIdentity packageIdentity, INuGetProjectContext nuGetProjectContext, CancellationToken token);
    protected bool IsUAPFramework(NuGetFramework framework);
    private JObject GetJson();
    [AsyncStateMachineAttribute("NuGet.ProjectManagement.Projects.ProjectJsonNuGetProject/<GetJsonAsync>d__23")]
private Task`1<JObject> GetJsonAsync();
    [AsyncStateMachineAttribute("NuGet.ProjectManagement.Projects.ProjectJsonNuGetProject/<SaveJsonAsync>d__24")]
private Task SaveJsonAsync(JObject json);
    [AsyncStateMachineAttribute("NuGet.ProjectManagement.Projects.ProjectJsonNuGetProject/<UpdateFrameworkAsync>d__25")]
private Task UpdateFrameworkAsync(JObject json);
    private bool TryGetInternalFramework(Object& internalTargetFramework);
    public virtual Task`1<string> GetCacheFilePathAsync();
    public virtual Task`1<bool> UninstallPackageAsync(string packageId, BuildIntegratedInstallationContext installationContext, CancellationToken token);
}
public abstract class NuGet.ProjectManagement.SourceControlManager : object {
    [CompilerGeneratedAttribute]
private ISettings <Settings>k__BackingField;
    protected ISettings Settings { get; protected set; }
    protected SourceControlManager(ISettings settings);
    [CompilerGeneratedAttribute]
protected ISettings get_Settings();
    [CompilerGeneratedAttribute]
protected void set_Settings(ISettings value);
    public abstract virtual Stream CreateFile(string fullPath, INuGetProjectContext nuGetProjectContext);
    public abstract virtual void PendAddFiles(IEnumerable`1<string> fullPaths, string root, INuGetProjectContext nuGetProjectContext);
    public abstract virtual void PendDeleteFiles(IEnumerable`1<string> fullPaths, string root, INuGetProjectContext nuGetProjectContext);
    public bool IsPackagesFolderBoundToSourceControl();
}
public static class NuGet.ProjectManagement.SourceControlUtility : object {
    private static string SolutionSection;
    private static string DisableSourceControlIntegerationKey;
    public static bool IsSourceControlDisabled(ISettings settings);
    public static void DisableSourceControlMode(ISettings settings);
    public static SourceControlManager GetSourceControlManager(INuGetProjectContext nuGetProjectContext);
    public static bool IsPackagesFolderBoundToSourceControl(INuGetProjectContext nuGetProjectContext);
}
public static class NuGet.ProjectManagement.StreamUtility : object {
    public static Stream StreamFromString(string content);
    public static Stream StreamFromString(string content, Encoding encoding);
    public static bool ContentEquals(Stream stream, Stream otherStream);
    public static bool IsBinary(Stream stream);
    private static bool CompareText(Stream stream, Stream otherStream);
    [IteratorStateMachineAttribute("NuGet.ProjectManagement.StreamUtility/<ReadStreamLines>d__5")]
private static IEnumerable`1<string> ReadStreamLines(Stream stream);
    private static bool CompareBinary(Stream stream, Stream otherStream);
}
public class NuGet.ProjectManagement.XdtTransformer : object {
    [AsyncStateMachineAttribute("NuGet.ProjectManagement.XdtTransformer/<TransformFileAsync>d__0")]
public sealed virtual Task TransformFileAsync(Func`1<Task`1<Stream>> streamTaskFactory, string targetPath, IMSBuildProjectSystem projectSystem, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.ProjectManagement.XdtTransformer/<RevertFileAsync>d__1")]
public sealed virtual Task RevertFileAsync(Func`1<Task`1<Stream>> streamTaskFactory, string targetPath, IEnumerable`1<InternalZipFileInfo> matchingFiles, IMSBuildProjectSystem projectSystem, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.ProjectManagement.XdtTransformer/<PerformXdtTransformAsync>d__2")]
internal static Task PerformXdtTransformAsync(Func`1<Task`1<Stream>> streamTaskFactory, string targetPath, IMSBuildProjectSystem msBuildNuGetProjectSystem, CancellationToken cancellationToken);
}
[ExtensionAttribute]
public static class NuGet.ProjectManagement.XElementExtensions : object {
    [ExtensionAttribute]
public static string GetOptionalAttributeValue(XElement element, string localName, string namespaceName);
    [ExtensionAttribute]
public static string GetOptionalElementValue(XContainer element, string localName, string namespaceName);
    [ExtensionAttribute]
public static IEnumerable`1<XElement> ElementsNoNamespace(XContainer container, string localName);
    [ExtensionAttribute]
public static IEnumerable`1<XElement> ElementsNoNamespace(IEnumerable`1<XContainer> source, string localName);
    [ExtensionAttribute]
public static XElement Except(XElement source, XElement target);
    [ExtensionAttribute]
public static XElement MergeWith(XElement source, XElement target);
    [ExtensionAttribute]
public static XElement MergeWith(XElement source, XElement target, IDictionary`2<XName, Action`2<XElement, XElement>> nodeActions);
    private static XElement FindElement(XElement source, XElement targetChild);
    private static bool HasComment(XElement element, XComment comment);
    private static int Compare(XElement target, XElement left, XElement right);
    private static int CountMatches(XElement left, XElement right, Func`3<XAttribute, XAttribute, bool> matcher);
    private static bool HasConflict(XElement source, XElement target);
    [ExtensionAttribute]
public static void RemoveAttributes(XElement element, Func`2<XAttribute, bool> condition);
    [ExtensionAttribute]
public static void AddIndented(XContainer container, XContainer content);
    private static void AddTrailingIndentation(XContainer container, string containerIndent);
    private static void AddLeadingIndentation(XContainer container, string containerIndent, string oneIndentLevel);
    [ExtensionAttribute]
private static void IndentChildrenElements(XContainer container, string containerIndent, string oneIndentLevel);
    [ExtensionAttribute]
public static void RemoveIndented(XNode element);
    [ExtensionAttribute]
private static bool IsWhiteSpace(XText textNode);
    [ExtensionAttribute]
private static string ComputeOneLevelOfIndentation(XNode node);
    private static bool AttributeEquals(XAttribute source, XAttribute target);
    private static void AddContents(Queue`1<T> pendingComments, Action`1<T> action);
}
public class NuGet.ProjectManagement.XmlTransformer : object {
    private IDictionary`2<XName, Action`2<XElement, XElement>> _nodeActions;
    public XmlTransformer(IDictionary`2<XName, Action`2<XElement, XElement>> nodeActions);
    [AsyncStateMachineAttribute("NuGet.ProjectManagement.XmlTransformer/<TransformFileAsync>d__2")]
public sealed virtual Task TransformFileAsync(Func`1<Task`1<Stream>> streamTaskFactory, string targetPath, IMSBuildProjectSystem projectSystem, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.ProjectManagement.XmlTransformer/<RevertFileAsync>d__3")]
public sealed virtual Task RevertFileAsync(Func`1<Task`1<Stream>> streamTaskFactory, string targetPath, IEnumerable`1<InternalZipFileInfo> matchingFiles, IMSBuildProjectSystem projectSystem, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.ProjectManagement.XmlTransformer/<GetXmlAsync>d__4")]
private static Task`1<XElement> GetXmlAsync(InternalZipFileInfo packageFileInfo, IMSBuildProjectSystem projectSystem, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NuGet.ProjectManagement.XmlTransformer/<GetXmlAsync>d__5")]
private static Task`1<XElement> GetXmlAsync(Func`1<Task`1<Stream>> streamTaskFactory, IMSBuildProjectSystem projectSystem, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
private XElement <RevertFileAsync>b__3_0(XElement left, XElement right);
}
public static class NuGet.ProjectManagement.XmlUtility : object {
    [ObsoleteAttribute("This method is obsolete and will be removed in a future release.")]
public static XDocument LoadSafe(string filePath);
    [ObsoleteAttribute("This method is obsolete and will be removed in a future release.")]
public static XDocument LoadSafe(Stream input);
    [ObsoleteAttribute("This method is obsolete and will be removed in a future release.")]
public static XDocument LoadSafe(Stream input, bool ignoreWhiteSpace);
    [ObsoleteAttribute("This method is obsolete and will be removed in a future release.")]
public static XDocument LoadSafe(Stream input, LoadOptions options);
    [ObsoleteAttribute("This method is obsolete and will be removed in a future release.")]
public static XDocument GetOrCreateDocument(XName rootName, string path, IMSBuildProjectSystem msBuildNuGetProjectSystem);
    public static XDocument GetOrCreateDocument(XName rootName, string root, string path, INuGetProjectContext nuGetProjectContext);
    [ObsoleteAttribute("This method is obsolete and will be removed in a future release.")]
public static XDocument CreateDocument(XName rootName, string path, IMSBuildProjectSystem msBuildNuGetProjectSystem);
    public static XDocument CreateDocument(XName rootName, string root, string path, INuGetProjectContext nuGetProjectContext);
    [ObsoleteAttribute("This method is obsolete and will be removed in a future release.")]
public static XDocument GetDocument(string root, string path);
    [ObsoleteAttribute("This method is obsolete and will be removed in a future release.")]
public static bool TryParseDocument(string content, XDocument& document);
}
internal static class NuGet.Shared.EncodingUtility : object {
    [NullableContextAttribute("1")]
internal static string ToHex(Byte[] bytes, int length);
    private static char ToHexChar(int input);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class NuGet.Shared.EqualityUtility : object {
    [ExtensionAttribute]
internal static bool OrderedEquals(IEnumerable`1<TSource> self, IEnumerable`1<TSource> other, Func`2<TSource, TKey> keySelector, IComparer`1<TKey> orderComparer, IEqualityComparer`1<TSource> sequenceComparer);
    [ExtensionAttribute]
internal static bool OrderedEquals(ICollection`1<TSource> self, ICollection`1<TSource> other, Func`2<TSource, TKey> keySelector, IComparer`1<TKey> orderComparer, IEqualityComparer`1<TSource> sequenceComparer);
    [ExtensionAttribute]
internal static bool OrderedEquals(IList`1<TSource> self, IList`1<TSource> other, Func`2<TSource, TKey> keySelector, IComparer`1<TKey> orderComparer, IEqualityComparer`1<TSource> sequenceComparer);
    [ExtensionAttribute]
internal static bool SequenceEqualWithNullCheck(IEnumerable`1<T> self, IEnumerable`1<T> other, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
internal static bool SequenceEqualWithNullCheck(ICollection`1<T> self, ICollection`1<T> other, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
internal static bool SequenceEqualWithNullCheck(IList`1<T> self, IList`1<T> other, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
internal static bool SetEqualsWithNullCheck(ISet`1<T> self, ISet`1<T> other, IEqualityComparer`1<T> comparer);
    [NullableContextAttribute("1")]
internal static bool DictionaryEquals(IDictionary`2<TKey, TValue> self, IDictionary`2<TKey, TValue> other, Func`3<TValue, TValue, bool> compareValues);
    [NullableContextAttribute("1")]
internal static bool DictionaryOfSequenceEquals(IDictionary`2<TKey, IEnumerable`1<TValue>> self, IDictionary`2<TKey, IEnumerable`1<TValue>> other);
    [NullableContextAttribute("1")]
internal static bool EqualsWithNullCheck(T self, T other);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
internal static bool EqualsFalse(string value);
    private static bool TryIdentityEquals(T self, T other, Boolean& equals);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class NuGet.Shared.Extensions : object {
    [ExtensionAttribute]
public static List`1<T> AsList(IEnumerable`1<T> enumerable);
    [ExtensionAttribute]
public static HashSet`1<T> AsHashSet(ISet`1<T> enumerable, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
public static void ForEach(IEnumerable`1<T> enumeration, Action`1<T> action);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[CompilerFeatureRequiredAttribute("RefStructs")]
internal class NuGet.Shared.HashCodeCombiner : ValueType {
    private static long Seed;
    private long _combinedHash;
    internal int CombinedHash { get; }
    internal int get_CombinedHash();
    private void AddHashCode(int i);
    internal void AddObject(int i);
    internal void AddObject(bool b);
    internal void AddObject(T o, IEqualityComparer`1<T> comparer);
    internal void AddObject(T o);
    [NullableContextAttribute("0")]
internal void AddStruct(Nullable`1<T> o);
    [NullableContextAttribute("0")]
internal void AddStruct(T o);
    [NullableContextAttribute("2")]
internal void AddStringIgnoreCase(string s);
    internal void AddSequence(IEnumerable`1<T> sequence);
    internal void AddSequence(T[] array);
    internal void AddSequence(IList`1<T> list);
    internal void AddSequence(IReadOnlyList`1<T> list);
    internal void AddUnorderedSequence(IEnumerable`1<T> list);
    internal void AddUnorderedSequence(IEnumerable`1<T> list, IEqualityComparer`1<T> comparer);
    internal void AddDictionary(IEnumerable`1<KeyValuePair`2<TKey, TValue>> dictionary);
    internal static int GetHashCode(T1 o1, T2 o2);
    internal static int GetHashCode(T1 o1, T2 o2, T3 o3);
}
internal static class NuGet.Shared.XmlUtility : object {
    internal static XDocument Load(string path);
    internal static XDocument Load(string path, LoadOptions options);
    internal static XDocument Load(Stream input);
    internal static XDocument Load(Stream input, LoadOptions options);
    internal static string GetEncodedXMLName(string name);
    internal static XmlReaderSettings GetXmlReaderSettings(LoadOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NuGet.SimplePool`1 : object {
    private ConcurrentStack`1<T> _values;
    private Func`1<T> _allocate;
    public SimplePool`1(Func`1<T> allocate);
    public T Allocate();
    public void Free(T value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NuGet.StringBuilderPool : object {
    private static int MaxPoolSize;
    private SimplePool`1<StringBuilder> _pool;
    public static StringBuilderPool Shared;
    private static StringBuilderPool();
    public StringBuilder Rent(int minimumCapacity);
    public string ToStringAndReturn(StringBuilder builder);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class NuGet.TaskResult : object {
    [CompilerGeneratedAttribute]
private static Task`1<bool> <True>k__BackingField;
    [CompilerGeneratedAttribute]
private static Task`1<bool> <False>k__BackingField;
    [CompilerGeneratedAttribute]
private static Task`1<int> <Zero>k__BackingField;
    [CompilerGeneratedAttribute]
private static Task`1<int> <One>k__BackingField;
    public static Task`1<bool> True { get; }
    public static Task`1<bool> False { get; }
    public static Task`1<int> Zero { get; }
    public static Task`1<int> One { get; }
    private static TaskResult();
    [CompilerGeneratedAttribute]
public static Task`1<bool> get_True();
    [CompilerGeneratedAttribute]
public static Task`1<bool> get_False();
    public static Task`1<bool> Boolean(bool b);
    [CompilerGeneratedAttribute]
public static Task`1<int> get_Zero();
    [CompilerGeneratedAttribute]
public static Task`1<int> get_One();
    public static Task`1<int> Integer(int i);
    public static Task`1<T> Null();
    public static Task`1<IEnumerable`1<T>> EmptyEnumerable();
    public static Task`1<T[]> EmptyArray();
}
[ExtensionAttribute]
internal static class System.Collections.Generic.DeconstructionExtensions : object {
    [ExtensionAttribute]
[DebuggerStepThroughAttribute]
public static void Deconstruct(KeyValuePair`2<TKey, TValue> pair, TKey& key, TValue& value);
}
[AttributeUsageAttribute("2432")]
internal class System.Diagnostics.CodeAnalysis.AllowNullAttribute : Attribute {
}
[AttributeUsageAttribute("2432")]
internal class System.Diagnostics.CodeAnalysis.DisallowNullAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
internal class System.Diagnostics.CodeAnalysis.DoesNotReturnAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ParameterValue>k__BackingField;
    public bool ParameterValue { get; }
    public DoesNotReturnIfAttribute(bool parameterValue);
    [CompilerGeneratedAttribute]
public bool get_ParameterValue();
}
[AttributeUsageAttribute("10624")]
internal class System.Diagnostics.CodeAnalysis.MaybeNullAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public MaybeNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[AttributeUsageAttribute("192")]
internal class System.Diagnostics.CodeAnalysis.MemberNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public String[] Members { get; }
    public MemberNotNullAttribute(string member);
    public MemberNotNullAttribute(String[] members);
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[AttributeUsageAttribute("192")]
internal class System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public bool ReturnValue { get; }
    public String[] Members { get; }
    public MemberNotNullWhenAttribute(bool returnValue, string member);
    public MemberNotNullWhenAttribute(bool returnValue, String[] members);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[AttributeUsageAttribute("10624")]
internal class System.Diagnostics.CodeAnalysis.NotNullAttribute : Attribute {
}
[AttributeUsageAttribute("10368")]
internal class System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <ParameterName>k__BackingField;
    public string ParameterName { get; }
    public NotNullIfNotNullAttribute(string parameterName);
    [CompilerGeneratedAttribute]
public string get_ParameterName();
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.NotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public NotNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[AttributeUsageAttribute("32")]
internal class System.Diagnostics.CodeAnalysis.SetsRequiredMembersAttribute : Attribute {
}
[AttributeUsageAttribute("32767")]
internal class System.Runtime.CompilerServices.CompilerFeatureRequiredAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <FeatureName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsOptional>k__BackingField;
    public static string RefStructs;
    public static string RequiredMembers;
    public string FeatureName { get; }
    public bool IsOptional { get; public set; }
    public CompilerFeatureRequiredAttribute(string featureName);
    [CompilerGeneratedAttribute]
public string get_FeatureName();
    [CompilerGeneratedAttribute]
public bool get_IsOptional();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_IsOptional(bool value);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsByRefLikeAttribute : Attribute {
}
[DebuggerNonUserCodeAttribute]
internal static class System.Runtime.CompilerServices.IsExternalInit : object {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsReadOnlyAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
[AttributeUsageAttribute("396")]
[EditorBrowsableAttribute("1")]
internal class System.Runtime.CompilerServices.RequiredMemberAttribute : Attribute {
}
