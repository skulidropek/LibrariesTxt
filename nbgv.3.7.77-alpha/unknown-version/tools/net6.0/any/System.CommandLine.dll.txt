[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.CommandLine.Argument : Symbol {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Func`2<ArgumentResult, object> _defaultValueFactory;
    private ArgumentArity _arity;
    [NullableAttribute("2")]
private TryConvertArgument _convertArguments;
    [NullableAttribute("2")]
private CompletionSourceList _completions;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<ValidateSymbolResult`1<ArgumentResult>> _validators;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private HashSet`1<string> <AllowedValues>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <HelpName>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal HashSet`1<string> AllowedValues { get; private set; }
    public ArgumentArity Arity { get; public set; }
    [NullableAttribute("2")]
public string HelpName { get; public set; }
    [NullableAttribute("2")]
internal TryConvertArgument ConvertArguments { get; internal set; }
    public CompletionSourceList Completions { get; }
    public Type ValueType { get; }
    private protected string DefaultName { get; }
    internal List`1<ValidateSymbolResult`1<ArgumentResult>> Validators { get; }
    public bool HasDefaultValue { get; }
    internal bool HasCustomParser { get; }
    private string System.CommandLine.Binding.IValueDescriptor.ValueName { get; }
    [NullableContextAttribute("2")]
protected Argument(string name, string description);
    [CompilerGeneratedAttribute]
internal HashSet`1<string> get_AllowedValues();
    [CompilerGeneratedAttribute]
private void set_AllowedValues(HashSet`1<string> value);
    public ArgumentArity get_Arity();
    public void set_Arity(ArgumentArity value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_HelpName();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_HelpName(string value);
    [NullableContextAttribute("2")]
internal TryConvertArgument get_ConvertArguments();
    [NullableContextAttribute("2")]
internal Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ConvertArguments(TryConvertArgument value);
    public CompletionSourceList get_Completions();
    public abstract virtual Type get_ValueType();
    private protected virtual string get_DefaultName();
    internal List`1<ValidateSymbolResult`1<ArgumentResult>> get_Validators();
    public void AddValidator(ValidateSymbolResult`1<ArgumentResult> validate);
    [NullableContextAttribute("2")]
public sealed virtual object GetDefaultValue();
    internal object GetDefaultValue(ArgumentResult argumentResult);
    [NullableContextAttribute("2")]
public void SetDefaultValue(object value);
    public void SetDefaultValueFactory(Func`1<object> getDefaultValue);
    public void SetDefaultValueFactory(Func`2<ArgumentResult, object> getDefaultValue);
    public sealed virtual bool get_HasDefaultValue();
    internal virtual bool get_HasCustomParser();
    internal static Argument None();
    internal void AddAllowedValues(IReadOnlyList`1<string> values);
    public virtual IEnumerable`1<CompletionItem> GetCompletions(CompletionContext context);
    public virtual string ToString();
    private sealed virtual override string System.CommandLine.Binding.IValueDescriptor.get_ValueName();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.CommandLine.Argument`1 : Argument {
    private bool _hasCustomParser;
    internal bool HasCustomParser { get; }
    public Type ValueType { get; }
    [NullableContextAttribute("2")]
public Argument`1(string name, string description);
    public Argument`1(string name, Func`1<T> getDefaultValue, string description);
    public Argument`1(Func`1<T> getDefaultValue);
    [NullableContextAttribute("2")]
public Argument`1(string name, ParseArgument`1<T> parse, bool isDefault, string description);
    public Argument`1(ParseArgument`1<T> parse, bool isDefault);
    internal virtual bool get_HasCustomParser();
    public virtual Type get_ValueType();
}
[IsReadOnlyAttribute]
[DebuggerDisplayAttribute("\{{MinimumNumberOfValues},{MaximumNumberOfValues}\}")]
public class System.CommandLine.ArgumentArity : ValueType {
    private static int MaximumArity;
    [CompilerGeneratedAttribute]
private int <MinimumNumberOfValues>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaximumNumberOfValues>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsNonDefault>k__BackingField;
    public int MinimumNumberOfValues { get; }
    public int MaximumNumberOfValues { get; }
    internal bool IsNonDefault { get; }
    public static ArgumentArity Zero { get; }
    public static ArgumentArity ZeroOrOne { get; }
    public static ArgumentArity ExactlyOne { get; }
    public static ArgumentArity ZeroOrMore { get; }
    public static ArgumentArity OneOrMore { get; }
    public ArgumentArity(int minimumNumberOfValues, int maximumNumberOfValues);
    [CompilerGeneratedAttribute]
public int get_MinimumNumberOfValues();
    [CompilerGeneratedAttribute]
public int get_MaximumNumberOfValues();
    [CompilerGeneratedAttribute]
internal bool get_IsNonDefault();
    public sealed virtual bool Equals(ArgumentArity other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [NullableContextAttribute("1")]
internal static ArgumentConversionResult Validate(SymbolResult symbolResult, Argument argument, int minimumNumberOfValues, int maximumNumberOfValues);
    public static ArgumentArity get_Zero();
    public static ArgumentArity get_ZeroOrOne();
    public static ArgumentArity get_ExactlyOne();
    public static ArgumentArity get_ZeroOrMore();
    public static ArgumentArity get_OneOrMore();
    [NullableContextAttribute("1")]
internal static ArgumentArity Default(Type type, Argument argument, ParentNode firstParent);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class System.CommandLine.ArgumentExtensions : object {
    [ExtensionAttribute]
public static TArgument AddCompletions(TArgument argument, String[] values);
    [ExtensionAttribute]
public static TArgument AddCompletions(TArgument argument, Func`2<CompletionContext, IEnumerable`1<string>> complete);
    [ExtensionAttribute]
public static TArgument AddCompletions(TArgument argument, CompletionDelegate complete);
    [ExtensionAttribute]
public static TArgument FromAmong(TArgument argument, String[] values);
    [ExtensionAttribute]
public static Argument`1<FileInfo> ExistingOnly(Argument`1<FileInfo> argument);
    [ExtensionAttribute]
public static Argument`1<DirectoryInfo> ExistingOnly(Argument`1<DirectoryInfo> argument);
    [ExtensionAttribute]
public static Argument`1<FileSystemInfo> ExistingOnly(Argument`1<FileSystemInfo> argument);
    [ExtensionAttribute]
public static Argument`1<T> ExistingOnly(Argument`1<T> argument);
    [ExtensionAttribute]
public static TArgument LegalFilePathsOnly(TArgument argument);
    [ExtensionAttribute]
public static TArgument LegalFileNamesOnly(TArgument argument);
    [ExtensionAttribute]
public static ParseResult Parse(Argument argument, string commandLine);
    [ExtensionAttribute]
public static ParseResult Parse(Argument argument, String[] args);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class System.CommandLine.Binding.ArgumentConversionResult : object {
    internal Argument Argument;
    [NullableAttribute("2")]
internal object Value;
    [NullableAttribute("2")]
internal string ErrorMessage;
    internal ArgumentConversionResultType Result;
    private ArgumentConversionResult(Argument argument, string error, ArgumentConversionResultType failure);
    private ArgumentConversionResult(Argument argument, object value);
    private ArgumentConversionResult(Argument argument);
    internal ArgumentConversionResult(Argument argument, Type expectedType, string value, LocalizationResources localizationResources);
    internal static ArgumentConversionResult Failure(Argument argument, string error, ArgumentConversionResultType reason);
    public static ArgumentConversionResult Success(Argument argument, object value);
    internal static ArgumentConversionResult None(Argument argument);
    private static string FormatErrorMessage(Argument argument, Type expectedType, string value, LocalizationResources localizationResources);
}
internal enum System.CommandLine.Binding.ArgumentConversionResultType : Enum {
    public int value__;
    public static ArgumentConversionResultType NoArgument;
    public static ArgumentConversionResultType Successful;
    public static ArgumentConversionResultType Failed;
    public static ArgumentConversionResultType FailedArity;
    public static ArgumentConversionResultType FailedType;
    public static ArgumentConversionResultType FailedTooManyArguments;
    public static ArgumentConversionResultType FailedMissingArgument;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class System.CommandLine.Binding.ArgumentConverter : object {
    [NullableAttribute("2")]
private static ConstructorInfo _listCtor;
    private static Dictionary`2<Type, TryConvertString> _stringConverters;
    private static ArgumentConverter();
    internal static ArgumentConversionResult ConvertObject(Argument argument, Type type, object value, LocalizationResources localizationResources);
    private static ArgumentConversionResult ConvertToken(Argument argument, Type type, Token token, LocalizationResources localizationResources);
    private static ArgumentConversionResult ConvertTokens(Argument argument, Type type, IReadOnlyList`1<Token> tokens, LocalizationResources localizationResources, ArgumentResult argumentResult);
    internal static TryConvertArgument GetConverter(Argument argument);
    [ExtensionAttribute]
private static bool CanBeBoundFromScalarValue(Type type);
    private static ArgumentConversionResult Failure(Argument argument, Type expectedType, string value, LocalizationResources localizationResources);
    [ExtensionAttribute]
internal static ArgumentConversionResult ConvertIfNeeded(ArgumentConversionResult conversionResult, SymbolResult symbolResult, Type toType);
    [ExtensionAttribute]
internal static T GetValueOrDefault(ArgumentConversionResult result);
    public static bool TryConvertArgument(ArgumentResult argumentResult, Object& value);
    internal static object GetDefaultValue(Type type);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL3050")]
private static Array CreateArray(Type itemType, int capacity);
    private static IList CreateEmptyList(Type listType);
    private static IList CreateEnumerable(Type type, Type itemType, int capacity);
    [UnconditionalSuppressMessageAttribute("ReflectionAnalysis", "IL2067:UnrecognizedReflectionPattern")]
private static object CreateDefaultValueType(Type type);
    [CompilerGeneratedAttribute]
internal static bool <GetConverter>g__ConvertSingleString|3_2(ArgumentResult result, TryConvertString convert, Object& value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.CommandLine.Binding.BinderBase`1 : object {
    private string System.CommandLine.Binding.IValueDescriptor.ValueName { get; }
    private Type System.CommandLine.Binding.IValueDescriptor.ValueType { get; }
    private bool System.CommandLine.Binding.IValueDescriptor.HasDefaultValue { get; }
    protected abstract virtual T GetBoundValue(BindingContext bindingContext);
    private sealed virtual override string System.CommandLine.Binding.IValueDescriptor.get_ValueName();
    private sealed virtual override Type System.CommandLine.Binding.IValueDescriptor.get_ValueType();
    private sealed virtual override bool System.CommandLine.Binding.IValueDescriptor.get_HasDefaultValue();
    [NullableContextAttribute("2")]
private sealed virtual override object System.CommandLine.Binding.IValueDescriptor.GetDefaultValue();
    private sealed virtual override bool System.CommandLine.Binding.IValueSource.TryGetValue(IValueDescriptor valueDescriptor, BindingContext bindingContext, Object& boundValue);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.CommandLine.Binding.BindingContext : object {
    [NullableAttribute("2")]
private HelpBuilder _helpBuilder;
    [CompilerGeneratedAttribute]
private InvocationContext <InvocationContext>k__BackingField;
    [CompilerGeneratedAttribute]
private ServiceProvider <ServiceProvider>k__BackingField;
    internal InvocationContext InvocationContext { get; }
    public ParseResult ParseResult { get; }
    internal HelpBuilder HelpBuilder { get; }
    public IConsole Console { get; }
    internal ServiceProvider ServiceProvider { get; }
    internal BindingContext(InvocationContext invocationContext);
    [CompilerGeneratedAttribute]
internal InvocationContext get_InvocationContext();
    public ParseResult get_ParseResult();
    internal HelpBuilder get_HelpBuilder();
    public IConsole get_Console();
    [CompilerGeneratedAttribute]
internal ServiceProvider get_ServiceProvider();
    public sealed virtual object GetService(Type serviceType);
    public void AddService(Type serviceType, Func`2<IServiceProvider, object> factory);
    public void AddService(Func`2<IServiceProvider, T> factory);
    internal bool TryGetValueSource(IValueDescriptor valueDescriptor, IValueSource& valueSource);
    internal bool TryBindToScalarValue(IValueDescriptor valueDescriptor, IValueSource valueSource, LocalizationResources localizationResources, Nullable`1& boundValue);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private InvocationContext <.ctor>b__1_0(IServiceProvider _);
    [CompilerGeneratedAttribute]
private CancellationToken <.ctor>b__1_1(IServiceProvider _);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class System.CommandLine.Binding.BoundValue : ValueType {
    [CompilerGeneratedAttribute]
private IValueDescriptor <ValueDescriptor>k__BackingField;
    [CompilerGeneratedAttribute]
private IValueSource <ValueSource>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private object <Value>k__BackingField;
    public IValueDescriptor ValueDescriptor { get; }
    public IValueSource ValueSource { get; }
    [NullableAttribute("2")]
public object Value { get; }
    internal BoundValue(object value, IValueDescriptor valueDescriptor, IValueSource valueSource);
    [CompilerGeneratedAttribute]
public IValueDescriptor get_ValueDescriptor();
    [CompilerGeneratedAttribute]
public IValueSource get_ValueSource();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public object get_Value();
    public virtual string ToString();
}
[NullableContextAttribute("1")]
public interface System.CommandLine.Binding.IValueDescriptor {
    public string ValueName { get; }
    public Type ValueType { get; }
    public bool HasDefaultValue { get; }
    public abstract virtual string get_ValueName();
    public abstract virtual Type get_ValueType();
    public abstract virtual bool get_HasDefaultValue();
    [NullableContextAttribute("2")]
public abstract virtual object GetDefaultValue();
}
public interface System.CommandLine.Binding.IValueDescriptor`1 {
}
[NullableContextAttribute("1")]
public interface System.CommandLine.Binding.IValueSource {
    public abstract virtual bool TryGetValue(IValueDescriptor valueDescriptor, BindingContext bindingContext, Object& boundValue);
}
internal static class System.CommandLine.Binding.ServiceProviderExtensions : object {
}
internal class System.CommandLine.Binding.ServiceProviderValueSource : object {
    [NullableContextAttribute("2")]
public sealed virtual bool TryGetValue(IValueDescriptor valueDescriptor, BindingContext bindingContext, Object& boundValue);
}
internal class System.CommandLine.Binding.TryConvertArgument : MulticastDelegate {
    public TryConvertArgument(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual bool Invoke(ArgumentResult argumentResult, Object& value);
    public virtual IAsyncResult BeginInvoke(ArgumentResult argumentResult, Object& value, AsyncCallback callback, object object);
    public virtual bool EndInvoke(Object& value, IAsyncResult result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class System.CommandLine.Binding.TypeExtensions : object {
    [ExtensionAttribute]
internal static Type GetElementTypeIfEnumerable(Type type);
    [ExtensionAttribute]
internal static bool IsEnumerable(Type type);
    [ExtensionAttribute]
internal static bool IsNullable(Type t);
    [ExtensionAttribute]
internal static bool TryGetNullableType(Type type, Type& nullableType);
}
internal class System.CommandLine.Binding.ValueDescriptorDefaultValueSource : object {
    [NullableAttribute("1")]
public static IValueSource Instance;
    private static ValueDescriptorDefaultValueSource();
    [NullableContextAttribute("1")]
public sealed virtual bool TryGetValue(IValueDescriptor valueDescriptor, BindingContext bindingContext, Object& boundValue);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.CommandLine.Builder.CommandLineBuilder : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<Tuple`2<InvocationMiddleware, int>> _middlewareList;
    [NullableAttribute("2")]
private LocalizationResources _localizationResources;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Action`1<HelpContext> _customizeHelpBuilder;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Func`2<BindingContext, HelpBuilder> _helpBuilderFactory;
    [CompilerGeneratedAttribute]
private Command <Command>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EnableDirectives>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EnablePosixBundling>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EnableTokenReplacement>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EnableLegacyDoubleDashBehavior>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private HelpOption <HelpOption>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private VersionOption <VersionOption>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MaxHelpWidth>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private TryReplaceToken <TokenReplacer>k__BackingField;
    public Command Command { get; }
    internal bool EnableDirectives { get; internal set; }
    internal bool EnablePosixBundling { get; internal set; }
    internal bool EnableTokenReplacement { get; internal set; }
    internal bool EnableLegacyDoubleDashBehavior { get; internal set; }
    [NullableAttribute("2")]
internal HelpOption HelpOption { get; internal set; }
    [NullableAttribute("2")]
internal VersionOption VersionOption { get; internal set; }
    internal Nullable`1<int> MaxHelpWidth { get; internal set; }
    internal LocalizationResources LocalizationResources { get; internal set; }
    [NullableAttribute("2")]
internal TryReplaceToken TokenReplacer { get; internal set; }
    [NullableContextAttribute("2")]
public CommandLineBuilder(Command rootCommand);
    [CompilerGeneratedAttribute]
public Command get_Command();
    [CompilerGeneratedAttribute]
internal bool get_EnableDirectives();
    [CompilerGeneratedAttribute]
internal void set_EnableDirectives(bool value);
    [CompilerGeneratedAttribute]
internal bool get_EnablePosixBundling();
    [CompilerGeneratedAttribute]
internal void set_EnablePosixBundling(bool value);
    [CompilerGeneratedAttribute]
internal bool get_EnableTokenReplacement();
    [CompilerGeneratedAttribute]
internal void set_EnableTokenReplacement(bool value);
    [CompilerGeneratedAttribute]
internal bool get_EnableLegacyDoubleDashBehavior();
    [CompilerGeneratedAttribute]
internal void set_EnableLegacyDoubleDashBehavior(bool value);
    internal void CustomizeHelpLayout(Action`1<HelpContext> customize);
    internal void UseHelpBuilderFactory(Func`2<BindingContext, HelpBuilder> factory);
    private Func`2<BindingContext, HelpBuilder> GetHelpBuilderFactory();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal HelpOption get_HelpOption();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal void set_HelpOption(HelpOption value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal VersionOption get_VersionOption();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal void set_VersionOption(VersionOption value);
    [CompilerGeneratedAttribute]
internal Nullable`1<int> get_MaxHelpWidth();
    [CompilerGeneratedAttribute]
internal void set_MaxHelpWidth(Nullable`1<int> value);
    internal LocalizationResources get_LocalizationResources();
    internal void set_LocalizationResources(LocalizationResources value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal TryReplaceToken get_TokenReplacer();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal void set_TokenReplacer(TryReplaceToken value);
    public Parser Build();
    private IReadOnlyList`1<InvocationMiddleware> GetMiddleware();
    internal void AddMiddleware(InvocationMiddleware middleware, MiddlewareOrder order);
    internal void AddMiddleware(InvocationMiddleware middleware, MiddlewareOrderInternal order);
    private void AddMiddleware(InvocationMiddleware middleware, int order);
    [CompilerGeneratedAttribute]
private HelpBuilder <GetHelpBuilderFactory>g__CreateHelpBuilder|26_0(BindingContext bindingContext);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class System.CommandLine.Builder.CommandLineBuilderExtensions : object {
    private static Lazy`1<string> _assemblyVersion;
    private static CommandLineBuilderExtensions();
    [ExtensionAttribute]
public static CommandLineBuilder CancelOnProcessTermination(CommandLineBuilder builder);
    [ExtensionAttribute]
public static CommandLineBuilder EnableDirectives(CommandLineBuilder builder, bool value);
    [ExtensionAttribute]
public static CommandLineBuilder EnableLegacyDoubleDashBehavior(CommandLineBuilder builder, bool value);
    [ExtensionAttribute]
public static CommandLineBuilder EnablePosixBundling(CommandLineBuilder builder, bool value);
    [ExtensionAttribute]
public static CommandLineBuilder RegisterWithDotnetSuggest(CommandLineBuilder builder);
    [ExtensionAttribute]
public static CommandLineBuilder UseEnvironmentVariableDirective(CommandLineBuilder builder);
    [ExtensionAttribute]
public static CommandLineBuilder UseDefaults(CommandLineBuilder builder);
    [ExtensionAttribute]
public static CommandLineBuilder UseExceptionHandler(CommandLineBuilder builder, Action`2<Exception, InvocationContext> onException, Nullable`1<int> errorExitCode);
    [ExtensionAttribute]
public static CommandLineBuilder UseHelp(CommandLineBuilder builder, Nullable`1<int> maxWidth);
    [ExtensionAttribute]
public static CommandLineBuilder UseHelp(CommandLineBuilder builder, String[] helpAliases);
    [ExtensionAttribute]
public static CommandLineBuilder UseHelp(CommandLineBuilder builder, Action`1<HelpContext> customize, Nullable`1<int> maxWidth);
    [ExtensionAttribute]
internal static CommandLineBuilder UseHelp(CommandLineBuilder builder, HelpOption helpOption, Nullable`1<int> maxWidth);
    [ExtensionAttribute]
public static TBuilder UseHelpBuilder(TBuilder builder, Func`2<BindingContext, HelpBuilder> getHelpBuilder);
    [ExtensionAttribute]
public static CommandLineBuilder AddMiddleware(CommandLineBuilder builder, InvocationMiddleware middleware, MiddlewareOrder order);
    [ExtensionAttribute]
public static CommandLineBuilder AddMiddleware(CommandLineBuilder builder, Action`1<InvocationContext> onInvoke, MiddlewareOrder order);
    [ExtensionAttribute]
public static CommandLineBuilder UseParseDirective(CommandLineBuilder builder, Nullable`1<int> errorExitCode);
    [ExtensionAttribute]
public static CommandLineBuilder UseParseErrorReporting(CommandLineBuilder builder, Nullable`1<int> errorExitCode);
    [ExtensionAttribute]
public static CommandLineBuilder UseSuggestDirective(CommandLineBuilder builder);
    [ExtensionAttribute]
public static CommandLineBuilder UseTypoCorrections(CommandLineBuilder builder, int maxLevenshteinDistance);
    [ExtensionAttribute]
public static CommandLineBuilder UseLocalizationResources(CommandLineBuilder builder, LocalizationResources validationMessages);
    [ExtensionAttribute]
public static CommandLineBuilder UseTokenReplacer(CommandLineBuilder builder, TryReplaceToken replaceToken);
    [ExtensionAttribute]
public static CommandLineBuilder UseVersionOption(CommandLineBuilder builder);
    [ExtensionAttribute]
public static CommandLineBuilder UseVersionOption(CommandLineBuilder builder, String[] aliases);
    private static bool ShowHelp(InvocationContext context, Option helpOption);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.CommandLine.Command : IdentifierSymbol {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<Argument> _arguments;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<Option> _options;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<Command> _subcommands;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<ValidateSymbolResult`1<CommandResult>> _validators;
    [CompilerGeneratedAttribute]
private bool <TreatUnmatchedTokensAsErrors>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private ICommandHandler <Handler>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private Parser <ImplicitInvocationParser>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private Parser <ImplicitSimpleParser>k__BackingField;
    public IEnumerable`1<Symbol> Children { get; }
    public IReadOnlyList`1<Argument> Arguments { get; }
    internal bool HasArguments { get; }
    public IReadOnlyList`1<Option> Options { get; }
    public IReadOnlyList`1<Command> Subcommands { get; }
    internal IReadOnlyList`1<ValidateSymbolResult`1<CommandResult>> Validators { get; }
    internal bool HasValidators { get; }
    private protected string DefaultName { get; }
    public bool TreatUnmatchedTokensAsErrors { get; public set; }
    [NullableAttribute("2")]
public ICommandHandler Handler { get; public set; }
    [NullableAttribute("2")]
internal Parser ImplicitInvocationParser { get; internal set; }
    [NullableAttribute("2")]
internal Parser ImplicitSimpleParser { get; internal set; }
    public Command(string name, string description);
    [IteratorStateMachineAttribute("System.CommandLine.Command/<get_Children>d__6")]
public IEnumerable`1<Symbol> get_Children();
    public IReadOnlyList`1<Argument> get_Arguments();
    internal bool get_HasArguments();
    public IReadOnlyList`1<Option> get_Options();
    public IReadOnlyList`1<Command> get_Subcommands();
    internal IReadOnlyList`1<ValidateSymbolResult`1<CommandResult>> get_Validators();
    internal bool get_HasValidators();
    public void AddArgument(Argument argument);
    public void AddCommand(Command command);
    public void AddOption(Option option);
    public void AddGlobalOption(Option option);
    public void Add(Option option);
    public void Add(Argument argument);
    public void Add(Command command);
    private protected virtual string get_DefaultName();
    public void AddValidator(ValidateSymbolResult`1<CommandResult> validate);
    [CompilerGeneratedAttribute]
public bool get_TreatUnmatchedTokensAsErrors();
    [CompilerGeneratedAttribute]
public void set_TreatUnmatchedTokensAsErrors(bool value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public ICommandHandler get_Handler();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_Handler(ICommandHandler value);
    public sealed virtual IEnumerator`1<Symbol> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal Parser get_ImplicitInvocationParser();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal void set_ImplicitInvocationParser(Parser value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal Parser get_ImplicitSimpleParser();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal void set_ImplicitSimpleParser(Parser value);
    public virtual IEnumerable`1<CompletionItem> GetCompletions(CompletionContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class System.CommandLine.CommandExtensions : object {
    [ExtensionAttribute]
public static int Invoke(Command command, String[] args, IConsole console);
    [ExtensionAttribute]
public static int Invoke(Command command, string commandLine, IConsole console);
    [AsyncStateMachineAttribute("System.CommandLine.CommandExtensions/<InvokeAsync>d__2")]
[ExtensionAttribute]
public static Task`1<int> InvokeAsync(Command command, String[] args, IConsole console);
    [ExtensionAttribute]
public static Task`1<int> InvokeAsync(Command command, string commandLine, IConsole console);
    private static InvocationPipeline GetDefaultInvocationPipeline(Command command, String[] args);
    [ExtensionAttribute]
public static ParseResult Parse(Command command, String[] args);
    [ExtensionAttribute]
public static ParseResult Parse(Command command, string commandLine);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.CommandLine.CommandLineConfiguration : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Func`2<BindingContext, HelpBuilder> _helpBuilderFactory;
    [NullableAttribute("2")]
private TryReplaceToken _tokenReplacer;
    [CompilerGeneratedAttribute]
private bool <EnableDirectives>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EnableLegacyDoubleDashBehavior>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EnablePosixBundling>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EnableTokenReplacement>k__BackingField;
    [CompilerGeneratedAttribute]
private LocalizationResources <LocalizationResources>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<InvocationMiddleware> <Middleware>k__BackingField;
    [CompilerGeneratedAttribute]
private Command <RootCommand>k__BackingField;
    public bool EnableDirectives { get; }
    public bool EnableLegacyDoubleDashBehavior { get; }
    public bool EnablePosixBundling { get; }
    public bool EnableTokenReplacement { get; }
    public LocalizationResources LocalizationResources { get; }
    internal Func`2<BindingContext, HelpBuilder> HelpBuilderFactory { get; }
    internal IReadOnlyList`1<InvocationMiddleware> Middleware { get; }
    [NullableAttribute("2")]
internal TryReplaceToken TokenReplacer { get; }
    public Command RootCommand { get; }
    [NullableContextAttribute("2")]
public CommandLineConfiguration(Command command, bool enablePosixBundling, bool enableDirectives, bool enableLegacyDoubleDashBehavior, bool enableTokenReplacement, LocalizationResources resources, IReadOnlyList`1<InvocationMiddleware> middlewarePipeline, Func`2<BindingContext, HelpBuilder> helpBuilderFactory, TryReplaceToken tokenReplacer);
    internal static HelpBuilder DefaultHelpBuilderFactory(BindingContext context, Nullable`1<int> requestedMaxWidth);
    [CompilerGeneratedAttribute]
public bool get_EnableDirectives();
    [CompilerGeneratedAttribute]
public bool get_EnableLegacyDoubleDashBehavior();
    [CompilerGeneratedAttribute]
public bool get_EnablePosixBundling();
    [CompilerGeneratedAttribute]
public bool get_EnableTokenReplacement();
    [CompilerGeneratedAttribute]
public LocalizationResources get_LocalizationResources();
    internal Func`2<BindingContext, HelpBuilder> get_HelpBuilderFactory();
    [CompilerGeneratedAttribute]
internal IReadOnlyList`1<InvocationMiddleware> get_Middleware();
    [NullableContextAttribute("2")]
internal TryReplaceToken get_TokenReplacer();
    private bool DefaultTokenReplacer(string tokenToReplace, IReadOnlyList`1& replacementTokens, String& errorMessage);
    [CompilerGeneratedAttribute]
public Command get_RootCommand();
    public void ThrowIfInvalid();
    [CompilerGeneratedAttribute]
internal static void <ThrowIfInvalid>g__ThrowIfInvalid|30_0(Command command);
    [CompilerGeneratedAttribute]
internal static IdentifierSymbol <ThrowIfInvalid>g__GetChild|30_1(int index, Command command);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.CommandLine.CommandLineConfigurationException : Exception {
    public CommandLineConfigurationException(string message);
    protected CommandLineConfigurationException(SerializationInfo info, StreamingContext context);
    public CommandLineConfigurationException(string message, Exception innerException);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class System.CommandLine.Completions.AnonymousCompletionSource : object {
    private CompletionDelegate _complete;
    public AnonymousCompletionSource(CompletionDelegate complete);
    public AnonymousCompletionSource(Func`2<CompletionContext, IEnumerable`1<string>> complete);
    public sealed virtual IEnumerable`1<CompletionItem> GetCompletions(CompletionContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.CommandLine.Completions.CompletionContext : object {
    [CompilerGeneratedAttribute]
private string <WordToComplete>k__BackingField;
    [CompilerGeneratedAttribute]
private ParseResult <ParseResult>k__BackingField;
    public string WordToComplete { get; }
    public ParseResult ParseResult { get; }
    internal CompletionContext(ParseResult parseResult, string wordToComplete);
    [CompilerGeneratedAttribute]
public string get_WordToComplete();
    [CompilerGeneratedAttribute]
public ParseResult get_ParseResult();
    internal static CompletionContext Empty();
    protected static string GetWordToComplete(ParseResult parseResult, Nullable`1<int> position);
}
public class System.CommandLine.Completions.CompletionDelegate : MulticastDelegate {
    public CompletionDelegate(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual IEnumerable`1<CompletionItem> Invoke(CompletionContext context);
    public virtual IAsyncResult BeginInvoke(CompletionContext context, AsyncCallback callback, object object);
    public virtual IEnumerable`1<CompletionItem> EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.CommandLine.Completions.CompletionItem : object {
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private string <Label>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Kind>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private string <SortText>k__BackingField;
    [CompilerGeneratedAttribute]
private string <InsertText>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Documentation>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Detail>k__BackingField;
    [NullableAttribute("1")]
public string Label { get; }
    public string Kind { get; }
    [NullableAttribute("1")]
public string SortText { get; }
    public string InsertText { get; }
    public string Documentation { get; public set; }
    public string Detail { get; }
    public CompletionItem(string label, string kind, string sortText, string insertText, string documentation, string detail);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public string get_Label();
    [CompilerGeneratedAttribute]
public string get_Kind();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public string get_SortText();
    [CompilerGeneratedAttribute]
public string get_InsertText();
    [CompilerGeneratedAttribute]
public string get_Documentation();
    [CompilerGeneratedAttribute]
public void set_Documentation(string value);
    [CompilerGeneratedAttribute]
public string get_Detail();
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("1")]
protected bool Equals(CompletionItem other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class System.CommandLine.Completions.CompletionItemKind : object {
    public static string Keyword;
    public static string Value;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class System.CommandLine.Completions.CompletionSource : object {
    private static ConcurrentDictionary`2<Type, ICompletionSource> _completionSourcesByType;
    [CompilerGeneratedAttribute]
private static ICompletionSource <Empty>k__BackingField;
    internal static ICompletionSource Empty { get; }
    private static CompletionSource();
    internal static ICompletionSource ForType(Type type);
    [CompilerGeneratedAttribute]
internal static ICompletionSource get_Empty();
}
[NullableContextAttribute("1")]
public interface System.CommandLine.Completions.ICompletionSource {
    public abstract virtual IEnumerable`1<CompletionItem> GetCompletions(CompletionContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.CommandLine.Completions.TextCompletionContext : CompletionContext {
    [CompilerGeneratedAttribute]
private int <CursorPosition>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CommandLineText>k__BackingField;
    public int CursorPosition { get; }
    public string CommandLineText { get; }
    private TextCompletionContext(ParseResult parseResult, string commandLineText, int cursorPosition);
    internal TextCompletionContext(ParseResult parseResult, string commandLineText);
    [CompilerGeneratedAttribute]
public int get_CursorPosition();
    [CompilerGeneratedAttribute]
public string get_CommandLineText();
    public TextCompletionContext AtCursorPosition(int position);
}
public class System.CommandLine.Completions.TokenCompletionContext : CompletionContext {
    [NullableContextAttribute("1")]
internal TokenCompletionContext(ParseResult parseResult);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class System.CommandLine.CompletionSourceExtensions : object {
    [ExtensionAttribute]
public static void Add(CompletionSourceList completionSources, Func`2<CompletionContext, IEnumerable`1<string>> complete);
    [ExtensionAttribute]
public static void Add(CompletionSourceList completionSources, CompletionDelegate complete);
    [ExtensionAttribute]
public static void Add(CompletionSourceList completionSources, String[] completions);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class System.CommandLine.CompletionSourceList : object {
    private List`1<ICompletionSource> _sources;
    public int Count { get; }
    public ICompletionSource Item { get; }
    public void Add(ICompletionSource source);
    public sealed virtual IEnumerator`1<ICompletionSource> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public void Clear();
    public sealed virtual int get_Count();
    public sealed virtual ICompletionSource get_Item(int index);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class System.CommandLine.ConsoleExtensions : object {
    [ExtensionAttribute]
public static void Write(IConsole console, string value);
    [ExtensionAttribute]
public static void WriteLine(IConsole console, string value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class System.CommandLine.DebugAssert : object {
    [ConditionalAttribute("DEBUG")]
public static void ThrowIf(bool condition, string message);
    [ConditionalAttribute("DEBUG")]
public static void Throw(string message);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class System.CommandLine.DictionaryExtensions : object {
    [ExtensionAttribute]
public static TValue GetOrAdd(IDictionary`2<TKey, TValue> source, TKey key, Func`2<TKey, TValue> create);
    [ExtensionAttribute]
public static bool TryAdd(IDictionary`2<TKey, TValue> source, TKey key, TValue value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.CommandLine.DirectiveCollection : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<string, List`1<string>> _directives;
    internal void Add(string name, string value);
    public bool Contains(string name);
    public bool TryGetValues(string name, IReadOnlyList`1& values);
    public sealed virtual IEnumerator`1<KeyValuePair`2<string, IEnumerable`1<string>>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class System.CommandLine.EnumerableExtensions : object {
    [IteratorStateMachineAttribute("System.CommandLine.EnumerableExtensions/<FlattenBreadthFirst>d__0`1")]
[ExtensionAttribute]
internal static IEnumerable`1<T> FlattenBreadthFirst(IEnumerable`1<T> source, Func`2<T, IEnumerable`1<T>> children);
    [IteratorStateMachineAttribute("System.CommandLine.EnumerableExtensions/<RecurseWhileNotNull>d__1`1")]
[ExtensionAttribute]
internal static IEnumerable`1<T> RecurseWhileNotNull(T source, Func`2<T, T> next);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class System.CommandLine.Handler : object {
    [ExtensionAttribute]
public static void SetHandler(Command command, Action`1<InvocationContext> handle);
    [ExtensionAttribute]
public static void SetHandler(Command command, Action handle);
    [ExtensionAttribute]
public static void SetHandler(Command command, Action`1<T> handle, IValueDescriptor`1<T> symbol);
    [ExtensionAttribute]
public static void SetHandler(Command command, Action`2<T1, T2> handle, IValueDescriptor`1<T1> symbol1, IValueDescriptor`1<T2> symbol2);
    [ExtensionAttribute]
public static void SetHandler(Command command, Action`3<T1, T2, T3> handle, IValueDescriptor`1<T1> symbol1, IValueDescriptor`1<T2> symbol2, IValueDescriptor`1<T3> symbol3);
    [ExtensionAttribute]
public static void SetHandler(Command command, Action`4<T1, T2, T3, T4> handle, IValueDescriptor`1<T1> symbol1, IValueDescriptor`1<T2> symbol2, IValueDescriptor`1<T3> symbol3, IValueDescriptor`1<T4> symbol4);
    [ExtensionAttribute]
public static void SetHandler(Command command, Action`5<T1, T2, T3, T4, T5> handle, IValueDescriptor`1<T1> symbol1, IValueDescriptor`1<T2> symbol2, IValueDescriptor`1<T3> symbol3, IValueDescriptor`1<T4> symbol4, IValueDescriptor`1<T5> symbol5);
    [ExtensionAttribute]
public static void SetHandler(Command command, Action`6<T1, T2, T3, T4, T5, T6> handle, IValueDescriptor`1<T1> symbol1, IValueDescriptor`1<T2> symbol2, IValueDescriptor`1<T3> symbol3, IValueDescriptor`1<T4> symbol4, IValueDescriptor`1<T5> symbol5, IValueDescriptor`1<T6> symbol6);
    [ExtensionAttribute]
public static void SetHandler(Command command, Action`7<T1, T2, T3, T4, T5, T6, T7> handle, IValueDescriptor`1<T1> symbol1, IValueDescriptor`1<T2> symbol2, IValueDescriptor`1<T3> symbol3, IValueDescriptor`1<T4> symbol4, IValueDescriptor`1<T5> symbol5, IValueDescriptor`1<T6> symbol6, IValueDescriptor`1<T7> symbol7);
    [ExtensionAttribute]
public static void SetHandler(Command command, Action`8<T1, T2, T3, T4, T5, T6, T7, T8> handle, IValueDescriptor`1<T1> symbol1, IValueDescriptor`1<T2> symbol2, IValueDescriptor`1<T3> symbol3, IValueDescriptor`1<T4> symbol4, IValueDescriptor`1<T5> symbol5, IValueDescriptor`1<T6> symbol6, IValueDescriptor`1<T7> symbol7, IValueDescriptor`1<T8> symbol8);
    private static T GetValueForHandlerParameter(IValueDescriptor`1<T> symbol, InvocationContext context);
    [ExtensionAttribute]
public static void SetHandler(Command command, Func`1<Task> handle);
    [ExtensionAttribute]
public static void SetHandler(Command command, Func`2<InvocationContext, Task> handle);
    [ExtensionAttribute]
public static void SetHandler(Command command, Func`2<T, Task> handle, IValueDescriptor`1<T> symbol);
    [ExtensionAttribute]
public static void SetHandler(Command command, Func`3<T1, T2, Task> handle, IValueDescriptor`1<T1> symbol1, IValueDescriptor`1<T2> symbol2);
    [ExtensionAttribute]
public static void SetHandler(Command command, Func`4<T1, T2, T3, Task> handle, IValueDescriptor`1<T1> symbol1, IValueDescriptor`1<T2> symbol2, IValueDescriptor`1<T3> symbol3);
    [ExtensionAttribute]
public static void SetHandler(Command command, Func`5<T1, T2, T3, T4, Task> handle, IValueDescriptor`1<T1> symbol1, IValueDescriptor`1<T2> symbol2, IValueDescriptor`1<T3> symbol3, IValueDescriptor`1<T4> symbol4);
    [ExtensionAttribute]
public static void SetHandler(Command command, Func`6<T1, T2, T3, T4, T5, Task> handle, IValueDescriptor`1<T1> symbol1, IValueDescriptor`1<T2> symbol2, IValueDescriptor`1<T3> symbol3, IValueDescriptor`1<T4> symbol4, IValueDescriptor`1<T5> symbol5);
    [ExtensionAttribute]
public static void SetHandler(Command command, Func`7<T1, T2, T3, T4, T5, T6, Task> handle, IValueDescriptor`1<T1> symbol1, IValueDescriptor`1<T2> symbol2, IValueDescriptor`1<T3> symbol3, IValueDescriptor`1<T4> symbol4, IValueDescriptor`1<T5> symbol5, IValueDescriptor`1<T6> symbol6);
    [ExtensionAttribute]
public static void SetHandler(Command command, Func`8<T1, T2, T3, T4, T5, T6, T7, Task> handle, IValueDescriptor`1<T1> symbol1, IValueDescriptor`1<T2> symbol2, IValueDescriptor`1<T3> symbol3, IValueDescriptor`1<T4> symbol4, IValueDescriptor`1<T5> symbol5, IValueDescriptor`1<T6> symbol6, IValueDescriptor`1<T7> symbol7);
    [ExtensionAttribute]
public static void SetHandler(Command command, Func`9<T1, T2, T3, T4, T5, T6, T7, T8, Task> handle, IValueDescriptor`1<T1> symbol1, IValueDescriptor`1<T2> symbol2, IValueDescriptor`1<T3> symbol3, IValueDescriptor`1<T4> symbol4, IValueDescriptor`1<T5> symbol5, IValueDescriptor`1<T6> symbol6, IValueDescriptor`1<T7> symbol7, IValueDescriptor`1<T8> symbol8);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.CommandLine.Help.HelpBuilder : object {
    private static string Indent;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<Symbol, Customization> _customizationsBySymbol;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Func`2<HelpContext, IEnumerable`1<HelpSectionDelegate>> _getLayout;
    [CompilerGeneratedAttribute]
private LocalizationResources <LocalizationResources>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxWidth>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Action`1<HelpContext> <OnCustomize>k__BackingField;
    public LocalizationResources LocalizationResources { get; }
    public int MaxWidth { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal Action`1<HelpContext> OnCustomize { get; internal set; }
    public HelpBuilder(LocalizationResources localizationResources, int maxWidth);
    [CompilerGeneratedAttribute]
public LocalizationResources get_LocalizationResources();
    [CompilerGeneratedAttribute]
public int get_MaxWidth();
    public virtual void Write(HelpContext context);
    [CompilerGeneratedAttribute]
internal Action`1<HelpContext> get_OnCustomize();
    [CompilerGeneratedAttribute]
internal void set_OnCustomize(Action`1<HelpContext> value);
    public void CustomizeSymbol(Symbol symbol, Func`2<HelpContext, string> firstColumnText, Func`2<HelpContext, string> secondColumnText, Func`2<HelpContext, string> defaultValue);
    public void CustomizeLayout(Func`2<HelpContext, IEnumerable`1<HelpSectionDelegate>> getLayout);
    private string GetUsage(Command command);
    private IEnumerable`1<TwoColumnHelpRow> GetCommandArgumentRows(Command command, HelpContext context);
    private void WriteSubcommands(HelpContext context);
    private void WriteAdditionalArguments(HelpContext context);
    [NullableContextAttribute("2")]
private void WriteHeading(string heading, string description, TextWriter writer);
    public void WriteColumns(IReadOnlyList`1<TwoColumnHelpRow> items, HelpContext context);
    private string FormatArgumentUsage(IReadOnlyList`1<Argument> arguments);
    private IEnumerable`1<HelpSectionDelegate> GetLayout(HelpContext context);
    [IteratorStateMachineAttribute("System.CommandLine.Help.HelpBuilder/<WrapText>d__25")]
private static IEnumerable`1<string> WrapText(string text, int maxWidth);
    public TwoColumnHelpRow GetTwoColumnRow(Symbol symbol, HelpContext context);
    private string GetArgumentDefaultValue(IdentifierSymbol parent, Argument argument, bool displayArgumentName, HelpContext context);
    [IteratorStateMachineAttribute("System.CommandLine.Help.HelpBuilder/<<WriteColumns>g__ZipWithEmpty|22_2>d")]
[CompilerGeneratedAttribute]
internal static IEnumerable`1<ValueTuple`2<string, string>> <WriteColumns>g__ZipWithEmpty|22_2(IEnumerable`1<string> first, IEnumerable`1<string> second);
    [CompilerGeneratedAttribute]
internal static bool <FormatArgumentUsage>g__IsMultiParented|23_0(Argument a);
    [CompilerGeneratedAttribute]
internal static bool <FormatArgumentUsage>g__IsOptional|23_1(Argument argument);
}
[ExtensionAttribute]
public static class System.CommandLine.Help.HelpBuilderExtensions : object {
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static void CustomizeSymbol(HelpBuilder builder, Symbol symbol, string firstColumnText, string secondColumnText, string defaultValue);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static void Write(HelpBuilder helpBuilder, Command command, TextWriter writer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.CommandLine.Help.HelpContext : object {
    [CompilerGeneratedAttribute]
private HelpBuilder <HelpBuilder>k__BackingField;
    [CompilerGeneratedAttribute]
private ParseResult <ParseResult>k__BackingField;
    [CompilerGeneratedAttribute]
private Command <Command>k__BackingField;
    [CompilerGeneratedAttribute]
private TextWriter <Output>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <WasSectionSkipped>k__BackingField;
    public HelpBuilder HelpBuilder { get; }
    public ParseResult ParseResult { get; }
    public Command Command { get; }
    public TextWriter Output { get; }
    internal bool WasSectionSkipped { get; internal set; }
    public HelpContext(HelpBuilder helpBuilder, Command command, TextWriter output, ParseResult parseResult);
    [CompilerGeneratedAttribute]
public HelpBuilder get_HelpBuilder();
    [CompilerGeneratedAttribute]
public ParseResult get_ParseResult();
    [CompilerGeneratedAttribute]
public Command get_Command();
    [CompilerGeneratedAttribute]
public TextWriter get_Output();
    [CompilerGeneratedAttribute]
internal bool get_WasSectionSkipped();
    [CompilerGeneratedAttribute]
internal void set_WasSectionSkipped(bool value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class System.CommandLine.Help.HelpOption : Option`1<bool> {
    private Func`1<LocalizationResources> _localizationResources;
    [NullableAttribute("2")]
private string _description;
    [NullableAttribute("2")]
public string Description { get; public set; }
    internal Argument Argument { get; }
    internal bool IsGreedy { get; }
    public HelpOption(String[] aliases, Func`1<LocalizationResources> getLocalizationResources);
    public HelpOption(Func`1<LocalizationResources> getLocalizationResources);
    [NullableContextAttribute("2")]
public virtual string get_Description();
    [NullableContextAttribute("2")]
public virtual void set_Description(string value);
    internal virtual Argument get_Argument();
    internal virtual bool get_IsGreedy();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class System.CommandLine.Help.HelpResult : object {
    [NullableContextAttribute("1")]
public sealed virtual void Apply(InvocationContext context);
}
public class System.CommandLine.Help.HelpSectionDelegate : MulticastDelegate {
    public HelpSectionDelegate(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual void Invoke(HelpContext context);
    public virtual IAsyncResult BeginInvoke(HelpContext context, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.CommandLine.Help.TwoColumnHelpRow : object {
    [CompilerGeneratedAttribute]
private string <FirstColumnText>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SecondColumnText>k__BackingField;
    public string FirstColumnText { get; }
    public string SecondColumnText { get; }
    public TwoColumnHelpRow(string firstColumnText, string secondColumnText);
    [CompilerGeneratedAttribute]
public string get_FirstColumnText();
    [CompilerGeneratedAttribute]
public string get_SecondColumnText();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(TwoColumnHelpRow other);
    public virtual int GetHashCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class System.CommandLine.Help.VersionOption : Option`1<bool> {
    private CommandLineBuilder _builder;
    [NullableAttribute("2")]
private string _description;
    [NullableAttribute("2")]
public string Description { get; public set; }
    internal Argument Argument { get; }
    internal bool IsGreedy { get; }
    public VersionOption(CommandLineBuilder builder);
    public VersionOption(String[] aliases, CommandLineBuilder builder);
    private void AddValidators();
    private static bool IsNotImplicit(SymbolResult symbolResult);
    [NullableContextAttribute("2")]
public virtual string get_Description();
    [NullableContextAttribute("2")]
public virtual void set_Description(string value);
    internal virtual Argument get_Argument();
    internal virtual bool get_IsGreedy();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public interface System.CommandLine.IConsole {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.CommandLine.IdentifierSymbol : Symbol {
    private protected HashSet`1<string> _aliases;
    [NullableAttribute("2")]
private string _specifiedName;
    public IReadOnlyCollection`1<string> Aliases { get; }
    public string Name { get; public set; }
    [NullableContextAttribute("2")]
protected IdentifierSymbol(string description);
    protected IdentifierSymbol(string name, string description);
    public IReadOnlyCollection`1<string> get_Aliases();
    public virtual string get_Name();
    public virtual void set_Name(string value);
    public void AddAlias(string alias);
    private protected virtual void RemoveAlias(string alias);
    public bool HasAlias(string alias);
    [DebuggerStepThroughAttribute]
private void ThrowIfAliasIsInvalid(string alias);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class System.CommandLine.Invocation.AnonymousCommandHandler : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Func`2<InvocationContext, Task> _asyncHandle;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Action`1<InvocationContext> _syncHandle;
    public AnonymousCommandHandler(Func`2<InvocationContext, Task> handle);
    public AnonymousCommandHandler(Action`1<InvocationContext> handle);
    public sealed virtual int Invoke(InvocationContext context);
    private int SyncUsingAsync(InvocationContext context);
    [AsyncStateMachineAttribute("System.CommandLine.Invocation.AnonymousCommandHandler/<InvokeAsync>d__6")]
public sealed virtual Task`1<int> InvokeAsync(InvocationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class System.CommandLine.Invocation.FeatureRegistration : object {
    [NullableAttribute("2")]
private static string _assemblyName;
    private FileInfo _sentinelFile;
    public FeatureRegistration(string featureName);
    private static FeatureRegistration();
    [AsyncStateMachineAttribute("System.CommandLine.Invocation.FeatureRegistration/<EnsureRegistered>d__3")]
public Task EnsureRegistered(Func`1<Task`1<string>> onInitialize);
}
[NullableContextAttribute("1")]
public interface System.CommandLine.Invocation.ICommandHandler {
    public abstract virtual int Invoke(InvocationContext context);
    public abstract virtual Task`1<int> InvokeAsync(InvocationContext context);
}
[NullableContextAttribute("1")]
public interface System.CommandLine.Invocation.IInvocationResult {
    public abstract virtual void Apply(InvocationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.CommandLine.Invocation.InvocationContext : object {
    [NullableAttribute("2")]
private CancellationTokenSource _cts;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Action`1<CancellationTokenSource> _cancellationHandlingAddedEvent;
    [NullableAttribute("2")]
private HelpBuilder _helpBuilder;
    [NullableAttribute("2")]
private BindingContext _bindingContext;
    [NullableAttribute("2")]
private IConsole _console;
    [CompilerGeneratedAttribute]
private ParseResult <ParseResult>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ExitCode>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private IInvocationResult <InvocationResult>k__BackingField;
    public BindingContext BindingContext { get; }
    public IConsole Console { get; public set; }
    public HelpBuilder HelpBuilder { get; }
    public Parser Parser { get; }
    public LocalizationResources LocalizationResources { get; }
    public ParseResult ParseResult { get; public set; }
    public int ExitCode { get; public set; }
    [NullableAttribute("2")]
public IInvocationResult InvocationResult { get; public set; }
    public InvocationContext(ParseResult parseResult, IConsole console);
    public BindingContext get_BindingContext();
    public IConsole get_Console();
    public void set_Console(IConsole value);
    public HelpBuilder get_HelpBuilder();
    public Parser get_Parser();
    public LocalizationResources get_LocalizationResources();
    [CompilerGeneratedAttribute]
public ParseResult get_ParseResult();
    [CompilerGeneratedAttribute]
public void set_ParseResult(ParseResult value);
    [CompilerGeneratedAttribute]
public int get_ExitCode();
    [CompilerGeneratedAttribute]
public void set_ExitCode(int value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public IInvocationResult get_InvocationResult();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_InvocationResult(IInvocationResult value);
    internal void add_CancellationHandlingAdded(Action`1<CancellationTokenSource> value);
    internal void remove_CancellationHandlingAdded(Action`1<CancellationTokenSource> value);
    public CancellationToken GetCancellationToken();
}
public class System.CommandLine.Invocation.InvocationMiddleware : MulticastDelegate {
    public InvocationMiddleware(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual Task Invoke(InvocationContext context, Func`2<InvocationContext, Task> next);
    public virtual IAsyncResult BeginInvoke(InvocationContext context, Func`2<InvocationContext, Task> next, AsyncCallback callback, object object);
    public virtual Task EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class System.CommandLine.Invocation.InvocationPipeline : object {
    private ParseResult parseResult;
    public InvocationPipeline(ParseResult parseResult);
    public Task`1<int> InvokeAsync(IConsole console);
    [NullableContextAttribute("2")]
public int Invoke(IConsole console);
    private static InvocationMiddleware BuildInvocationChain(InvocationContext context, bool invokeAsync);
    private static int GetExitCode(InvocationContext context);
    [AsyncStateMachineAttribute("System.CommandLine.Invocation.InvocationPipeline/<<InvokeAsync>g__FullInvocationChainAsync|2_0>d")]
[CompilerGeneratedAttribute]
internal static Task`1<int> <InvokeAsync>g__FullInvocationChainAsync|2_0(InvocationContext context);
    [CompilerGeneratedAttribute]
internal static int <Invoke>g__FullInvocationChain|3_0(InvocationContext context);
}
public enum System.CommandLine.Invocation.MiddlewareOrder : Enum {
    public int value__;
    public static MiddlewareOrder ExceptionHandler;
    public static MiddlewareOrder Configuration;
    public static MiddlewareOrder Default;
    public static MiddlewareOrder ErrorReporting;
}
internal enum System.CommandLine.Invocation.MiddlewareOrderInternal : Enum {
    public int value__;
    public static MiddlewareOrderInternal Startup;
    public static MiddlewareOrderInternal ExceptionHandler;
    public static MiddlewareOrderInternal EnvironmentVariableDirective;
    public static MiddlewareOrderInternal ConfigureConsole;
    public static MiddlewareOrderInternal RegisterWithDotnetSuggest;
    public static MiddlewareOrderInternal DebugDirective;
    public static MiddlewareOrderInternal ParseDirective;
    public static MiddlewareOrderInternal SuggestDirective;
    public static MiddlewareOrderInternal TypoCorrection;
    public static MiddlewareOrderInternal VersionOption;
    public static MiddlewareOrderInternal HelpOption;
    public static MiddlewareOrderInternal ParseErrorReporting;
}
internal class System.CommandLine.Invocation.ParseDirectiveResult : object {
    private Nullable`1<int> _errorExitCode;
    public ParseDirectiveResult(Nullable`1<int> errorExitCode);
    [NullableContextAttribute("1")]
public sealed virtual void Apply(InvocationContext context);
}
internal class System.CommandLine.Invocation.ParseErrorResult : object {
    private Nullable`1<int> _errorExitCode;
    public ParseErrorResult(Nullable`1<int> errorExitCode);
    [NullableContextAttribute("1")]
public sealed virtual void Apply(InvocationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class System.CommandLine.Invocation.Process : object {
    [AsyncStateMachineAttribute("System.CommandLine.Invocation.Process/<CompleteAsync>d__0")]
[ExtensionAttribute]
public static Task`1<int> CompleteAsync(Process process, Nullable`1<CancellationToken> cancellationToken);
    public static Process StartProcess(string command, string args, string workingDir, Action`1<string> stdOut, Action`1<string> stdErr, ValueTuple`2[] environmentVariables);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class System.CommandLine.Invocation.ServiceProvider : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<Type, Func`2<IServiceProvider, object>> _services;
    public IReadOnlyCollection`1<Type> AvailableServiceTypes { get; }
    public ServiceProvider(BindingContext bindingContext);
    public void AddService(Func`2<IServiceProvider, T> factory);
    public void AddService(Type serviceType, Func`2<IServiceProvider, object> factory);
    public IReadOnlyCollection`1<Type> get_AvailableServiceTypes();
    public sealed virtual object GetService(Type serviceType);
}
internal class System.CommandLine.Invocation.SuggestDirectiveResult : object {
    private int _position;
    public SuggestDirectiveResult(int position);
    [NullableContextAttribute("1")]
public sealed virtual void Apply(InvocationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class System.CommandLine.Invocation.TypoCorrection : object {
    private int _maxLevenshteinDistance;
    public TypoCorrection(int maxLevenshteinDistance);
    public void ProvideSuggestions(ParseResult result, IConsole console);
    private IEnumerable`1<string> GetPossibleTokens(Command targetSymbol, string token);
    private static int GetStartsWithDistance(string first, string second);
    private static int GetDistance(string first, string second);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class System.CommandLine.IO.ConsoleExtensions : object {
    [ExtensionAttribute]
internal static void SetTerminalForegroundRed(IConsole console);
    [ExtensionAttribute]
internal static void ResetTerminalForegroundColor(IConsole console);
}
[NullableContextAttribute("1")]
public interface System.CommandLine.IO.IStandardError {
    public IStandardStreamWriter Error { get; }
    public bool IsErrorRedirected { get; }
    public abstract virtual IStandardStreamWriter get_Error();
    public abstract virtual bool get_IsErrorRedirected();
}
public interface System.CommandLine.IO.IStandardIn {
    public bool IsInputRedirected { get; }
    public abstract virtual bool get_IsInputRedirected();
}
[NullableContextAttribute("1")]
public interface System.CommandLine.IO.IStandardOut {
    public IStandardStreamWriter Out { get; }
    public bool IsOutputRedirected { get; }
    public abstract virtual IStandardStreamWriter get_Out();
    public abstract virtual bool get_IsOutputRedirected();
}
[NullableContextAttribute("2")]
public interface System.CommandLine.IO.IStandardStreamWriter {
    public abstract virtual void Write(string value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class System.CommandLine.IO.StandardStreamWriter : object {
    [ExtensionAttribute]
public static TextWriter CreateTextWriter(IStandardStreamWriter writer);
    public static IStandardStreamWriter Create(TextWriter writer);
    [ExtensionAttribute]
public static void WriteLine(IStandardStreamWriter writer);
    [ExtensionAttribute]
public static void WriteLine(IStandardStreamWriter writer, string value);
}
public class System.CommandLine.IO.SystemConsole : object {
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private IStandardStreamWriter <Error>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private IStandardStreamWriter <Out>k__BackingField;
    [NullableAttribute("1")]
public IStandardStreamWriter Error { get; }
    public bool IsErrorRedirected { get; }
    [NullableAttribute("1")]
public IStandardStreamWriter Out { get; }
    public bool IsOutputRedirected { get; }
    public bool IsInputRedirected { get; }
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public sealed virtual IStandardStreamWriter get_Error();
    public sealed virtual bool get_IsErrorRedirected();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public sealed virtual IStandardStreamWriter get_Out();
    public sealed virtual bool get_IsOutputRedirected();
    public sealed virtual bool get_IsInputRedirected();
    internal int GetWindowWidth();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.CommandLine.IO.TestConsole : object {
    [CompilerGeneratedAttribute]
private IStandardStreamWriter <Error>k__BackingField;
    [CompilerGeneratedAttribute]
private IStandardStreamWriter <Out>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsOutputRedirected>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsErrorRedirected>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsInputRedirected>k__BackingField;
    public IStandardStreamWriter Error { get; protected set; }
    public IStandardStreamWriter Out { get; protected set; }
    public bool IsOutputRedirected { get; protected set; }
    public bool IsErrorRedirected { get; protected set; }
    public bool IsInputRedirected { get; protected set; }
    [CompilerGeneratedAttribute]
public sealed virtual IStandardStreamWriter get_Error();
    [CompilerGeneratedAttribute]
protected void set_Error(IStandardStreamWriter value);
    [CompilerGeneratedAttribute]
public sealed virtual IStandardStreamWriter get_Out();
    [CompilerGeneratedAttribute]
protected void set_Out(IStandardStreamWriter value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsOutputRedirected();
    [CompilerGeneratedAttribute]
protected void set_IsOutputRedirected(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsErrorRedirected();
    [CompilerGeneratedAttribute]
protected void set_IsErrorRedirected(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsInputRedirected();
    [CompilerGeneratedAttribute]
protected void set_IsInputRedirected(bool value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.CommandLine.LocalizationResources : object {
    [NullableAttribute("2")]
private static LocalizationResources _instance;
    public static LocalizationResources Instance { get; }
    public static LocalizationResources get_Instance();
    public virtual string ExpectsOneArgument(SymbolResult symbolResult);
    public virtual string NoArgumentProvided(SymbolResult symbolResult);
    public virtual string ExpectsFewerArguments(Token token, int providedNumberOfValues, int maximumNumberOfValues);
    public virtual string DirectoryDoesNotExist(string path);
    public virtual string FileDoesNotExist(string filePath);
    public virtual string FileOrDirectoryDoesNotExist(string path);
    public virtual string InvalidCharactersInPath(char invalidChar);
    public virtual string InvalidCharactersInFileName(char invalidChar);
    public virtual string RequiredArgumentMissing(SymbolResult symbolResult);
    public virtual string RequiredCommandWasNotProvided();
    public virtual string UnrecognizedArgument(string unrecognizedArg, IReadOnlyCollection`1<string> allowedValues);
    public virtual string UnrecognizedCommandOrArgument(string arg);
    public virtual string ResponseFileNotFound(string filePath);
    public virtual string ErrorReadingResponseFile(string filePath, IOException e);
    public virtual string HelpOptionDescription();
    public virtual string HelpUsageTitle();
    public virtual string HelpDescriptionTitle();
    public virtual string HelpUsageOptions();
    public virtual string HelpUsageCommand();
    public virtual string HelpUsageAdditionalArguments();
    public virtual string HelpArgumentsTitle();
    public virtual string HelpOptionsTitle();
    public virtual string HelpOptionsRequiredLabel();
    public virtual string HelpArgumentDefaultValueLabel();
    public virtual string HelpCommandsTitle();
    public virtual string HelpAdditionalArgumentsTitle();
    public virtual string HelpAdditionalArgumentsDescription();
    public virtual string SuggestionsTokenNotMatched(string token);
    public virtual string VersionOptionDescription();
    public virtual string VersionOptionCannotBeCombinedWithOtherArguments(string optionAlias);
    public virtual string ExceptionHandlerHeader();
    public virtual string ArgumentConversionCannotParse(string value, Type expectedType);
    public virtual string ArgumentConversionCannotParseForCommand(string value, string commandAlias, Type expectedType);
    public virtual string ArgumentConversionCannotParseForOption(string value, string optionAlias, Type expectedType);
    protected virtual string GetResourceString(string resourceString, Object[] formatArguments);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.CommandLine.Option : IdentifierSymbol {
    [NullableAttribute("2")]
private string _name;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<ValidateSymbolResult`1<OptionResult>> _validators;
    private Argument _argument;
    [CompilerGeneratedAttribute]
private bool <IsGlobal>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DisallowBinding>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowMultipleArgumentsPerToken>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsRequired>k__BackingField;
    internal Argument Argument { get; }
    [NullableAttribute("2")]
public string ArgumentHelpName { get; public set; }
    public ArgumentArity Arity { get; public set; }
    internal bool IsGlobal { get; internal set; }
    internal bool DisallowBinding { get; internal set; }
    unknown string Name {public set; }
    internal List`1<ValidateSymbolResult`1<OptionResult>> Validators { get; }
    internal bool HasValidators { get; }
    public bool AllowMultipleArgumentsPerToken { get; public set; }
    internal bool IsGreedy { get; }
    public bool IsRequired { get; public set; }
    private string System.CommandLine.Binding.IValueDescriptor.ValueName { get; }
    public Type ValueType { get; }
    private bool System.CommandLine.Binding.IValueDescriptor.HasDefaultValue { get; }
    private protected string DefaultName { get; }
    internal Option(string name, string description, Argument argument);
    internal Option(String[] aliases, string description, Argument argument);
    internal virtual Argument get_Argument();
    [NullableContextAttribute("2")]
public string get_ArgumentHelpName();
    [NullableContextAttribute("2")]
public void set_ArgumentHelpName(string value);
    public virtual ArgumentArity get_Arity();
    public virtual void set_Arity(ArgumentArity value);
    [CompilerGeneratedAttribute]
internal bool get_IsGlobal();
    [CompilerGeneratedAttribute]
internal void set_IsGlobal(bool value);
    [CompilerGeneratedAttribute]
internal bool get_DisallowBinding();
    [CompilerGeneratedAttribute]
internal Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_DisallowBinding(bool value);
    public virtual void set_Name(string value);
    internal List`1<ValidateSymbolResult`1<OptionResult>> get_Validators();
    internal bool get_HasValidators();
    public void AddValidator(ValidateSymbolResult`1<OptionResult> validate);
    public bool HasAliasIgnoringPrefix(string alias);
    [NullableContextAttribute("2")]
public void SetDefaultValue(object value);
    public void SetDefaultValueFactory(Func`1<object> getDefaultValue);
    [CompilerGeneratedAttribute]
public bool get_AllowMultipleArgumentsPerToken();
    [CompilerGeneratedAttribute]
public void set_AllowMultipleArgumentsPerToken(bool value);
    internal virtual bool get_IsGreedy();
    [CompilerGeneratedAttribute]
public bool get_IsRequired();
    [CompilerGeneratedAttribute]
public void set_IsRequired(bool value);
    private sealed virtual override string System.CommandLine.Binding.IValueDescriptor.get_ValueName();
    public sealed virtual Type get_ValueType();
    private sealed virtual override bool System.CommandLine.Binding.IValueDescriptor.get_HasDefaultValue();
    [NullableContextAttribute("2")]
private sealed virtual override object System.CommandLine.Binding.IValueDescriptor.GetDefaultValue();
    private protected virtual string get_DefaultName();
    private string GetLongestAlias();
    public virtual IEnumerable`1<CompletionItem> GetCompletions(CompletionContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.CommandLine.Option`1 : Option {
    public ArgumentArity Arity { get; public set; }
    public Option`1(string name, string description);
    public Option`1(String[] aliases, string description);
    public Option`1(string name, ParseArgument`1<T> parseArgument, bool isDefault, string description);
    public Option`1(String[] aliases, ParseArgument`1<T> parseArgument, bool isDefault, string description);
    public Option`1(string name, Func`1<T> getDefaultValue, string description);
    public Option`1(String[] aliases, Func`1<T> getDefaultValue, string description);
    public virtual ArgumentArity get_Arity();
    public virtual void set_Arity(ArgumentArity value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class System.CommandLine.OptionExtensions : object {
    [ExtensionAttribute]
public static TOption FromAmong(TOption option, String[] values);
    [ExtensionAttribute]
public static TOption AddCompletions(TOption option, String[] values);
    [ExtensionAttribute]
public static TOption AddCompletions(TOption option, Func`2<CompletionContext, IEnumerable`1<string>> complete);
    [ExtensionAttribute]
public static TOption AddCompletions(TOption option, CompletionDelegate complete);
    [ExtensionAttribute]
public static Option`1<FileInfo> ExistingOnly(Option`1<FileInfo> option);
    [ExtensionAttribute]
public static Option`1<DirectoryInfo> ExistingOnly(Option`1<DirectoryInfo> option);
    [ExtensionAttribute]
public static Option`1<FileSystemInfo> ExistingOnly(Option`1<FileSystemInfo> option);
    [ExtensionAttribute]
public static Option`1<T> ExistingOnly(Option`1<T> option);
    [ExtensionAttribute]
public static TOption LegalFilePathsOnly(TOption option);
    [ExtensionAttribute]
public static TOption LegalFileNamesOnly(TOption option);
    [ExtensionAttribute]
public static ParseResult Parse(Option option, string commandLine);
    [ExtensionAttribute]
public static ParseResult Parse(Option option, String[] args);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class System.CommandLine.ParentNode : object {
    [CompilerGeneratedAttribute]
private Symbol <Symbol>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private ParentNode <Next>k__BackingField;
    internal Symbol Symbol { get; }
    [NullableAttribute("2")]
internal ParentNode Next { get; internal set; }
    internal ParentNode(Symbol symbol);
    [CompilerGeneratedAttribute]
internal Symbol get_Symbol();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal ParentNode get_Next();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal void set_Next(ParentNode value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.CommandLine.Parsing.ArgumentResult : SymbolResult {
    [NullableAttribute("2")]
private ArgumentConversionResult _conversionResult;
    [CompilerGeneratedAttribute]
private Argument <Argument>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private IReadOnlyList`1<Token> <PassedOnTokens>k__BackingField;
    public Argument Argument { get; }
    internal bool IsImplicit { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal IReadOnlyList`1<Token> PassedOnTokens { get; private set; }
    internal ArgumentResult(Argument argument, SymbolResult parent);
    [CompilerGeneratedAttribute]
public Argument get_Argument();
    internal bool get_IsImplicit();
    [CompilerGeneratedAttribute]
internal IReadOnlyList`1<Token> get_PassedOnTokens();
    [CompilerGeneratedAttribute]
private void set_PassedOnTokens(IReadOnlyList`1<Token> value);
    internal ArgumentConversionResult GetArgumentConversionResult();
    [NullableContextAttribute("2")]
public object GetValueOrDefault();
    public T GetValueOrDefault();
    public void OnlyTake(int numberOfTokens);
    public virtual string ToString();
    internal ParseError CustomError(Argument argument);
    private ArgumentConversionResult Convert(Argument argument);
    [CompilerGeneratedAttribute]
private bool <Convert>g__ShouldCheckArity|17_0();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class System.CommandLine.Parsing.CommandArgumentNode : SyntaxNode {
    [CompilerGeneratedAttribute]
private Argument <Argument>k__BackingField;
    [CompilerGeneratedAttribute]
private CommandNode <ParentCommandNode>k__BackingField;
    public Argument Argument { get; }
    public CommandNode ParentCommandNode { get; }
    public CommandArgumentNode(Token token, Argument argument, CommandNode parent);
    [CompilerGeneratedAttribute]
public Argument get_Argument();
    [CompilerGeneratedAttribute]
public CommandNode get_ParentCommandNode();
}
public class System.CommandLine.Parsing.CommandLineStringSplitter : object {
    [NullableAttribute("1")]
public static CommandLineStringSplitter Instance;
    private static CommandLineStringSplitter();
    [NullableContextAttribute("1")]
[IteratorStateMachineAttribute("System.CommandLine.Parsing.CommandLineStringSplitter/<Split>d__3")]
public IEnumerable`1<string> Split(string commandLine);
    [CompilerGeneratedAttribute]
internal static void <Split>g__Advance|3_0(<>c__DisplayClass3_0& );
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
internal static string <Split>g__CurrentToken|3_1(<>c__DisplayClass3_0& );
    [CompilerGeneratedAttribute]
internal static int <Split>g__IndexOfEndOfToken|3_2(<>c__DisplayClass3_0& );
    [CompilerGeneratedAttribute]
internal static bool <Split>g__IsAtEndOfInput|3_3(<>c__DisplayClass3_0& );
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class System.CommandLine.Parsing.CommandNode : NonterminalSyntaxNode {
    [CompilerGeneratedAttribute]
private Command <Command>k__BackingField;
    public Command Command { get; }
    public CommandNode(Token token, Command command, CommandNode parent);
    [CompilerGeneratedAttribute]
public Command get_Command();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.CommandLine.Parsing.CommandResult : SymbolResult {
    [CompilerGeneratedAttribute]
private Command <Command>k__BackingField;
    [CompilerGeneratedAttribute]
private Token <Token>k__BackingField;
    public Command Command { get; }
    public Token Token { get; }
    internal CommandResult(Command command, Token token, CommandResult parent);
    [CompilerGeneratedAttribute]
public Command get_Command();
    [CompilerGeneratedAttribute]
public Token get_Token();
    internal virtual bool UseDefaultValueFor(Argument argument);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class System.CommandLine.Parsing.DirectiveNode : SyntaxNode {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    public string Name { get; }
    [NullableAttribute("2")]
public string Value { get; }
    public DirectiveNode(Token token, CommandNode parent, string name, string value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_Value();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class System.CommandLine.Parsing.NonterminalSyntaxNode : SyntaxNode {
    private List`1<SyntaxNode> _children;
    public IReadOnlyList`1<SyntaxNode> Children { get; }
    protected NonterminalSyntaxNode(Token token, SyntaxNode parent);
    public IReadOnlyList`1<SyntaxNode> get_Children();
    internal void AddChildNode(SyntaxNode node);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class System.CommandLine.Parsing.OptionArgumentNode : SyntaxNode {
    [CompilerGeneratedAttribute]
private Argument <Argument>k__BackingField;
    [CompilerGeneratedAttribute]
private OptionNode <ParentOptionNode>k__BackingField;
    public Argument Argument { get; }
    public OptionNode ParentOptionNode { get; }
    public OptionArgumentNode(Token token, Argument argument, OptionNode parent);
    [CompilerGeneratedAttribute]
public Argument get_Argument();
    [CompilerGeneratedAttribute]
public OptionNode get_ParentOptionNode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class System.CommandLine.Parsing.OptionNode : NonterminalSyntaxNode {
    [CompilerGeneratedAttribute]
private Option <Option>k__BackingField;
    public Option Option { get; }
    public OptionNode(Token token, Option option, CommandNode parent);
    [CompilerGeneratedAttribute]
public Option get_Option();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.CommandLine.Parsing.OptionResult : SymbolResult {
    [NullableAttribute("2")]
private ArgumentConversionResult _argumentConversionResult;
    [CompilerGeneratedAttribute]
private Option <Option>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private Token <Token>k__BackingField;
    public Option Option { get; }
    public bool IsImplicit { get; }
    [NullableAttribute("2")]
public Token Token { get; }
    private protected int RemainingArgumentCapacity { get; }
    internal ArgumentConversionResult ArgumentConversionResult { get; }
    [NullableContextAttribute("2")]
internal OptionResult(Option option, Token token, CommandResult parent);
    [CompilerGeneratedAttribute]
public Option get_Option();
    public bool get_IsImplicit();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public Token get_Token();
    [NullableContextAttribute("2")]
public object GetValueOrDefault();
    public T GetValueOrDefault();
    private protected virtual int get_RemainingArgumentCapacity();
    internal ArgumentConversionResult get_ArgumentConversionResult();
    internal virtual bool UseDefaultValueFor(Argument argument);
}
[ExtensionAttribute]
internal static class System.CommandLine.Parsing.OptionResultExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
internal static ArgumentConversionResult ConvertIfNeeded(OptionResult optionResult, Type type);
}
public class System.CommandLine.Parsing.ParseArgument`1 : MulticastDelegate {
    public ParseArgument`1(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual T Invoke(ArgumentResult result);
    public virtual IAsyncResult BeginInvoke(ArgumentResult result, AsyncCallback callback, object object);
    public virtual T EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.CommandLine.Parsing.ParseError : object {
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private SymbolResult <SymbolResult>k__BackingField;
    public string Message { get; }
    [NullableAttribute("2")]
public SymbolResult SymbolResult { get; }
    internal ParseError(string message, SymbolResult symbolResult);
    [CompilerGeneratedAttribute]
public string get_Message();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public SymbolResult get_SymbolResult();
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class System.CommandLine.Parsing.ParseOperation : object {
    private TokenizeResult _tokenizeResult;
    private CommandLineConfiguration _configuration;
    private int _index;
    [CompilerGeneratedAttribute]
private List`1<ParseError> <Errors>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private CommandNode <RootCommandNode>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private List`1<Token> <UnmatchedTokens>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private List`1<Token> <UnparsedTokens>k__BackingField;
    private Token CurrentToken { get; }
    public List`1<ParseError> Errors { get; }
    [NullableAttribute("2")]
public CommandNode RootCommandNode { get; private set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public List`1<Token> UnmatchedTokens { get; private set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public List`1<Token> UnparsedTokens { get; private set; }
    public ParseOperation(TokenizeResult tokenizeResult, CommandLineConfiguration configuration);
    private Token get_CurrentToken();
    [CompilerGeneratedAttribute]
public List`1<ParseError> get_Errors();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public CommandNode get_RootCommandNode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private void set_RootCommandNode(CommandNode value);
    [CompilerGeneratedAttribute]
public List`1<Token> get_UnmatchedTokens();
    [CompilerGeneratedAttribute]
private void set_UnmatchedTokens(List`1<Token> value);
    [CompilerGeneratedAttribute]
public List`1<Token> get_UnparsedTokens();
    [CompilerGeneratedAttribute]
private void set_UnparsedTokens(List`1<Token> value);
    private void Advance();
    private bool More(TokenType& currentTokenType);
    public void Parse();
    private CommandNode ParseRootCommand();
    private void ParseSubcommand(CommandNode parentNode);
    private void ParseCommandChildren(CommandNode parent);
    private void ParseCommandArguments(CommandNode commandNode, Int32& currentArgumentCount, Int32& currentArgumentIndex);
    private void ParseOption(CommandNode parent);
    private void ParseOptionArguments(OptionNode optionNode);
    private void ParseDirectives(CommandNode rootCommandNode);
    private void ParseRemainingTokens();
    private void AddCurrentTokenToUnmatched();
    private void AddCurrentTokenToUnparsed();
    [CompilerGeneratedAttribute]
private void <ParseDirectives>g__ParseDirective|30_0(CommandNode parent);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.CommandLine.Parsing.Parser : object {
    [CompilerGeneratedAttribute]
private CommandLineConfiguration <Configuration>k__BackingField;
    public CommandLineConfiguration Configuration { get; }
    public Parser(CommandLineConfiguration configuration);
    public Parser(Command command);
    [CompilerGeneratedAttribute]
public CommandLineConfiguration get_Configuration();
    public ParseResult Parse(IReadOnlyList`1<string> arguments, string rawInput);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.CommandLine.Parsing.ParseResult : object {
    private List`1<ParseError> _errors;
    private RootCommandResult _rootCommandResult;
    private IReadOnlyList`1<Token> _unparsedTokens;
    private IReadOnlyList`1<Token> _unmatchedTokens;
    [NullableAttribute("2")]
private CompletionContext _completionContext;
    [CompilerGeneratedAttribute]
private CommandResult <CommandResult>k__BackingField;
    [CompilerGeneratedAttribute]
private Parser <Parser>k__BackingField;
    [CompilerGeneratedAttribute]
private DirectiveCollection <Directives>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<Token> <Tokens>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <CommandLineText>k__BackingField;
    public CommandResult CommandResult { get; }
    public Parser Parser { get; }
    public CommandResult RootCommandResult { get; }
    public IReadOnlyList`1<ParseError> Errors { get; }
    public DirectiveCollection Directives { get; }
    public IReadOnlyList`1<Token> Tokens { get; }
    [NullableAttribute("2")]
internal string CommandLineText { get; }
    public IReadOnlyList`1<string> UnmatchedTokens { get; }
    public IReadOnlyList`1<string> UnparsedTokens { get; }
    internal ParseResult(Parser parser, RootCommandResult rootCommandResult, CommandResult commandResult, DirectiveCollection directives, TokenizeResult tokenizeResult, IReadOnlyList`1<Token> unparsedTokens, IReadOnlyList`1<Token> unmatchedTokens, List`1<ParseError> errors, string commandLineText);
    internal static ParseResult Empty();
    [CompilerGeneratedAttribute]
public CommandResult get_CommandResult();
    [CompilerGeneratedAttribute]
public Parser get_Parser();
    public CommandResult get_RootCommandResult();
    public IReadOnlyList`1<ParseError> get_Errors();
    [CompilerGeneratedAttribute]
public DirectiveCollection get_Directives();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<Token> get_Tokens();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal string get_CommandLineText();
    public IReadOnlyList`1<string> get_UnmatchedTokens();
    public IReadOnlyList`1<string> get_UnparsedTokens();
    public CompletionContext GetCompletionContext();
    [NullableContextAttribute("2")]
internal T GetValueFor(IValueDescriptor`1<T> symbol);
    public object GetValueForOption(Option option);
    public object GetValueForArgument(Argument argument);
    public T GetValueForArgument(Argument`1<T> argument);
    [NullableContextAttribute("2")]
public T GetValueForOption(Option`1<T> option);
    public virtual string ToString();
    public ArgumentResult FindResultFor(Argument argument);
    public CommandResult FindResultFor(Command command);
    public OptionResult FindResultFor(Option option);
    public SymbolResult FindResultFor(Symbol symbol);
    public IEnumerable`1<CompletionItem> GetCompletions(Nullable`1<int> position);
    private SymbolResult SymbolToComplete(Nullable`1<int> position);
    [CompilerGeneratedAttribute]
internal static IEnumerable`1<string> <GetCompletions>g__OptionsWithArgumentLimitReached|41_1(SymbolResult symbolResult);
    [CompilerGeneratedAttribute]
internal static bool <SymbolToComplete>g__WillAcceptAnArgument|42_1(ParseResult parseResult, Nullable`1<int> position, OptionResult optionResult);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class System.CommandLine.Parsing.ParseResultExtensions : object {
    [AsyncStateMachineAttribute("System.CommandLine.Parsing.ParseResultExtensions/<InvokeAsync>d__0")]
[ExtensionAttribute]
public static Task`1<int> InvokeAsync(ParseResult parseResult, IConsole console);
    [ExtensionAttribute]
public static int Invoke(ParseResult parseResult, IConsole console);
    [ExtensionAttribute]
public static string Diagram(ParseResult parseResult);
    [ExtensionAttribute]
private static void Diagram(StringBuilder builder, SymbolResult symbolResult, ParseResult parseResult);
    [ExtensionAttribute]
public static bool HasOption(ParseResult parseResult, Option option);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class System.CommandLine.Parsing.ParseResultVisitor : object {
    private Parser _parser;
    private TokenizeResult _tokenizeResult;
    [NullableAttribute("2")]
private string _rawInput;
    private DirectiveCollection _directives;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<Token> _unparsedTokens;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<Token> _unmatchedTokens;
    private List`1<ParseError> _errors;
    private Dictionary`2<Symbol, SymbolResult> _symbolResults;
    private List`1<OptionResult> _optionResults;
    private List`1<ArgumentResult> _argumentResults;
    [NullableAttribute("2")]
private RootCommandResult _rootCommandResult;
    [NullableAttribute("2")]
private CommandResult _innermostCommandResult;
    private bool _isHelpRequested;
    public ParseResultVisitor(Parser parser, TokenizeResult tokenizeResult, List`1<Token> unparsedTokens, List`1<Token> unmatchedTokens, string rawInput);
    public void Visit(SyntaxNode node);
    private void VisitInternal(SyntaxNode node);
    private void AddToResult(CommandResult result);
    private void AddToResult(OptionResult result);
    private void AddToResult(ArgumentResult result);
    private void VisitRootCommandNode(CommandNode rootCommandNode);
    private void VisitCommandNode(CommandNode commandNode);
    private void VisitCommandArgumentNode(CommandArgumentNode argumentNode);
    private void VisitOptionNode(OptionNode optionNode);
    private void VisitOptionArgumentNode(OptionArgumentNode argumentNode);
    private void VisitDirectiveNode(DirectiveNode directiveNode);
    private void Stop();
    private void ValidateAndConvertArgumentResults(IReadOnlyList`1<Argument> arguments, int commandArgumentResultCount);
    private void ValidateCommandResult();
    private bool UseValidators(Command command, CommandResult innermostCommandResult);
    private void ValidateArguments(IReadOnlyList`1<Argument> arguments, CommandResult innermostCommandResult);
    private void ValidateCommandHandler();
    private void ValidateAndConvertOptionResult(OptionResult optionResult);
    private void ValidateAndConvertArgumentResult(ArgumentResult argumentResult);
    private void PopulateDefaultValues();
    private void AddErrorToResult(SymbolResult symbolResult, ParseError parseError);
    public ParseResult GetResult();
    [CompilerGeneratedAttribute]
private void <PopulateDefaultValues>g__Handle|33_0(SymbolResult symbolResult, Symbol symbol, <>c__DisplayClass33_0& );
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class System.CommandLine.Parsing.ParserExtensions : object {
    [ExtensionAttribute]
public static int Invoke(Parser parser, string commandLine, IConsole console);
    [ExtensionAttribute]
public static int Invoke(Parser parser, String[] args, IConsole console);
    [ExtensionAttribute]
public static Task`1<int> InvokeAsync(Parser parser, string commandLine, IConsole console);
    [AsyncStateMachineAttribute("System.CommandLine.Parsing.ParserExtensions/<InvokeAsync>d__3")]
[ExtensionAttribute]
public static Task`1<int> InvokeAsync(Parser parser, String[] args, IConsole console);
    [ExtensionAttribute]
public static ParseResult Parse(Parser parser, string commandLine);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class System.CommandLine.Parsing.RootCommandResult : CommandResult {
    private Dictionary`2<Symbol, SymbolResult> _symbolResults;
    internal RootCommandResult Root { get; }
    public RootCommandResult(Command command, Token token, Dictionary`2<Symbol, SymbolResult> symbolResults);
    internal virtual RootCommandResult get_Root();
    public virtual ArgumentResult FindResultFor(Argument argument);
    public virtual CommandResult FindResultFor(Command command);
    public virtual OptionResult FindResultFor(Option option);
    internal SymbolResult FindResultForSymbol(Symbol symbol);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class System.CommandLine.Parsing.StringExtensions : object {
    [ExtensionAttribute]
internal static bool ContainsCaseInsensitive(string source, string value);
    [ExtensionAttribute]
internal static int IndexOfCaseInsensitive(string source, string value);
    [ExtensionAttribute]
internal static string RemovePrefix(string alias);
    [ExtensionAttribute]
internal static int GetPrefixLength(string alias);
    [ExtensionAttribute]
internal static ValueTuple`2<string, string> SplitPrefix(string rawAlias);
    [ExtensionAttribute]
internal static TokenizeResult Tokenize(IReadOnlyList`1<string> args, CommandLineConfiguration configuration, bool inferRootCommand);
    private static List`1<string> NormalizeRootCommand(IReadOnlyList`1<string> args, Command rootCommand, bool inferRootCommand);
    [ExtensionAttribute]
private static string GetReplaceableTokenValue(string arg);
    [ExtensionAttribute]
internal static bool TrySplitIntoSubtokens(string arg, String& first, String& rest);
    internal static bool TryReadResponseFile(string filePath, LocalizationResources localizationResources, IReadOnlyList`1& newTokens, String& error);
    [ExtensionAttribute]
private static Dictionary`2<string, Token> ValidTokens(Command command);
    [CompilerGeneratedAttribute]
internal static Token <Tokenize>g__Argument|5_3(string value, <>c__DisplayClass5_1& );
    [CompilerGeneratedAttribute]
internal static Token <Tokenize>g__CommandArgument|5_4(string value, Command command, <>c__DisplayClass5_1& );
    [CompilerGeneratedAttribute]
internal static Token <Tokenize>g__OptionArgument|5_5(string value, Option option, <>c__DisplayClass5_1& );
    [CompilerGeneratedAttribute]
internal static Token <Tokenize>g__Command|5_6(string value, Command cmd, <>c__DisplayClass5_1& );
    [CompilerGeneratedAttribute]
internal static Token <Tokenize>g__Option|5_7(string value, Option option, <>c__DisplayClass5_1& );
    [CompilerGeneratedAttribute]
internal static Token <Tokenize>g__DoubleDash|5_8(<>c__DisplayClass5_1& );
    [CompilerGeneratedAttribute]
internal static Token <Tokenize>g__Unparsed|5_9(string value, <>c__DisplayClass5_1& );
    [CompilerGeneratedAttribute]
internal static Token <Tokenize>g__Directive|5_10(string value, <>c__DisplayClass5_1& );
    [CompilerGeneratedAttribute]
internal static bool <Tokenize>g__CanBeUnbundled|5_0(string arg, <>c__DisplayClass5_0& );
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
internal static bool <Tokenize>g__TryUnbundle|5_1(ReadOnlySpan`1<char> alias, int argumentIndex, <>c__DisplayClass5_0& );
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal static bool <Tokenize>g__PreviousTokenIsAnOptionExpectingAnArgument|5_2(Option& option, <>c__DisplayClass5_0& );
    [IteratorStateMachineAttribute("System.CommandLine.Parsing.StringExtensions/<<TryReadResponseFile>g__ExpandResponseFile|9_0>d")]
[CompilerGeneratedAttribute]
internal static IEnumerable`1<string> <TryReadResponseFile>g__ExpandResponseFile|9_0(string filePath);
    [IteratorStateMachineAttribute("System.CommandLine.Parsing.StringExtensions/<<TryReadResponseFile>g__SplitLine|9_1>d")]
[CompilerGeneratedAttribute]
internal static IEnumerable`1<string> <TryReadResponseFile>g__SplitLine|9_1(string line);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.CommandLine.Parsing.SymbolResult : object {
    private List`1<SymbolResult> _children;
    private protected List`1<Token> _tokens;
    [NullableAttribute("2")]
private LocalizationResources _resources;
    private Dictionary`2<Argument, ArgumentResult> _defaultArgumentValues;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <ErrorMessage>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private SymbolResult <Parent>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private RootCommandResult <Root>k__BackingField;
    [CompilerGeneratedAttribute]
private Symbol <Symbol>k__BackingField;
    [NullableAttribute("2")]
public string ErrorMessage { get; public set; }
    public IReadOnlyList`1<SymbolResult> Children { get; }
    [NullableAttribute("2")]
public SymbolResult Parent { get; }
    [NullableAttribute("2")]
internal RootCommandResult Root { get; }
    public Symbol Symbol { get; }
    public IReadOnlyList`1<Token> Tokens { get; }
    internal bool IsArgumentLimitReached { get; }
    private protected int RemainingArgumentCapacity { get; }
    internal int MaximumArgumentCapacity { get; }
    public LocalizationResources LocalizationResources { get; public set; }
    private protected SymbolResult(Symbol symbol, SymbolResult parent);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_ErrorMessage();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_ErrorMessage(string value);
    public IReadOnlyList`1<SymbolResult> get_Children();
    internal void AddChild(SymbolResult symbolResult);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public SymbolResult get_Parent();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal virtual RootCommandResult get_Root();
    [CompilerGeneratedAttribute]
public Symbol get_Symbol();
    public IReadOnlyList`1<Token> get_Tokens();
    internal bool get_IsArgumentLimitReached();
    private protected virtual int get_RemainingArgumentCapacity();
    internal int get_MaximumArgumentCapacity();
    public LocalizationResources get_LocalizationResources();
    public void set_LocalizationResources(LocalizationResources value);
    internal void AddToken(Token token);
    public virtual ArgumentResult FindResultFor(Argument argument);
    public virtual CommandResult FindResultFor(Command command);
    public virtual OptionResult FindResultFor(Option option);
    public T GetValueForArgument(Argument`1<T> argument);
    public object GetValueForArgument(Argument argument);
    [NullableContextAttribute("2")]
public T GetValueForOption(Option`1<T> option);
    public object GetValueForOption(Option option);
    internal ArgumentResult GetOrCreateDefaultArgumentResult(Argument argument);
    internal virtual bool UseDefaultValueFor(Argument argument);
    public virtual string ToString();
    internal ParseError UnrecognizedArgumentError(Argument argument);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private ArgumentResult <GetOrCreateDefaultArgumentResult>b__40_0(Argument arg);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class System.CommandLine.Parsing.SymbolResultExtensions : object {
    [IteratorStateMachineAttribute("System.CommandLine.Parsing.SymbolResultExtensions/<AllSymbolResults>d__0")]
[ExtensionAttribute]
internal static IEnumerable`1<SymbolResult> AllSymbolResults(SymbolResult symbolResult);
    [ExtensionAttribute]
internal static Token Token(SymbolResult symbolResult);
    [CompilerGeneratedAttribute]
internal static Token <Token>g__CreateImplicitToken|1_0(Option option);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class System.CommandLine.Parsing.SymbolResultVisitor : object {
    public void Visit(SymbolResult symbolResult);
    private void VisitInternal(SymbolResult node);
    protected virtual void VisitOptionResult(OptionResult optionResult);
    protected virtual void VisitCommandResult(CommandResult commandResult);
    protected virtual void VisitArgumentResult(ArgumentResult argumentResult);
    protected virtual void VisitRootCommandResult(RootCommandResult rootCommandResult);
    protected virtual void Start(SymbolResult node);
    protected virtual void Stop(SymbolResult node);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class System.CommandLine.Parsing.SyntaxNode : object {
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private SyntaxNode <Parent>k__BackingField;
    [CompilerGeneratedAttribute]
private Token <Token>k__BackingField;
    [NullableAttribute("2")]
public SyntaxNode Parent { get; }
    public Token Token { get; }
    protected SyntaxNode(Token token, SyntaxNode parent);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public SyntaxNode get_Parent();
    [CompilerGeneratedAttribute]
public Token get_Token();
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.CommandLine.Parsing.Token : object {
    internal static int ImplicitPosition;
    [CompilerGeneratedAttribute]
private int <Position>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private TokenType <Type>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private Symbol <Symbol>k__BackingField;
    internal int Position { get; }
    public string Value { get; }
    internal bool IsImplicit { get; }
    public TokenType Type { get; }
    [NullableAttribute("2")]
internal Symbol Symbol { get; }
    public Token(string value, TokenType type, Symbol symbol);
    [NullableContextAttribute("2")]
internal Token(string value, TokenType type, Symbol symbol, int position);
    [CompilerGeneratedAttribute]
internal int get_Position();
    [CompilerGeneratedAttribute]
public string get_Value();
    internal bool get_IsImplicit();
    [CompilerGeneratedAttribute]
public TokenType get_Type();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal Symbol get_Symbol();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(Token other);
    public virtual int GetHashCode();
    public virtual string ToString();
    public static bool op_Equality(Token left, Token right);
    public static bool op_Inequality(Token left, Token right);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class System.CommandLine.Parsing.TokenizeResult : object {
    [CompilerGeneratedAttribute]
private List`1<Token> <Tokens>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <Errors>k__BackingField;
    public List`1<Token> Tokens { get; }
    public List`1<string> Errors { get; }
    internal TokenizeResult(List`1<Token> tokens, List`1<string> errors);
    [CompilerGeneratedAttribute]
public List`1<Token> get_Tokens();
    [CompilerGeneratedAttribute]
public List`1<string> get_Errors();
}
public enum System.CommandLine.Parsing.TokenType : Enum {
    public int value__;
    public static TokenType Argument;
    public static TokenType Command;
    public static TokenType Option;
    public static TokenType DoubleDash;
    public static TokenType Unparsed;
    public static TokenType Directive;
}
public class System.CommandLine.Parsing.TryReplaceToken : MulticastDelegate {
    public TryReplaceToken(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual bool Invoke(string tokenToReplace, IReadOnlyList`1& replacementTokens, String& errorMessage);
    public virtual IAsyncResult BeginInvoke(string tokenToReplace, IReadOnlyList`1& replacementTokens, String& errorMessage, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IReadOnlyList`1& replacementTokens, String& errorMessage, IAsyncResult result);
}
public class System.CommandLine.Parsing.ValidateSymbolResult`1 : MulticastDelegate {
    public ValidateSymbolResult`1(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual void Invoke(T symbolResult);
    public virtual IAsyncResult BeginInvoke(T symbolResult, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal static class System.CommandLine.Platform : object {
    private static Nullable`1<bool> _isConsoleRedirectionCheckSupported;
    public static bool IsConsoleRedirectionCheckSupported { get; }
    public static bool get_IsConsoleRedirectionCheckSupported();
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "17.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class System.CommandLine.Properties.Resources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string ArgumentConversionCannotParse { get; }
    internal static string ArgumentConversionCannotParseForCommand { get; }
    internal static string ArgumentConversionCannotParseForOption { get; }
    internal static string CommandExpectsFewerArguments { get; }
    internal static string CommandExpectsOneArgument { get; }
    internal static string CommandNoArgumentProvided { get; }
    internal static string CommandRequiredArgumentMissing { get; }
    internal static string DirectoryDoesNotExist { get; }
    internal static string ErrorReadingResponseFile { get; }
    internal static string ExceptionHandlerHeader { get; }
    internal static string FileDoesNotExist { get; }
    internal static string FileOrDirectoryDoesNotExist { get; }
    internal static string HelpAdditionalArgumentsDescription { get; }
    internal static string HelpAdditionalArgumentsTitle { get; }
    internal static string HelpArgumentDefaultValueLabel { get; }
    internal static string HelpArgumentsTitle { get; }
    internal static string HelpCommandsTitle { get; }
    internal static string HelpDescriptionTitle { get; }
    internal static string HelpOptionDescription { get; }
    internal static string HelpOptionsRequiredLabel { get; }
    internal static string HelpOptionsTitle { get; }
    internal static string HelpUsageAdditionalArguments { get; }
    internal static string HelpUsageCommand { get; }
    internal static string HelpUsageOptions { get; }
    internal static string HelpUsageTitle { get; }
    internal static string InvalidCharactersInFileName { get; }
    internal static string InvalidCharactersInPath { get; }
    internal static string OptionExpectsFewerArguments { get; }
    internal static string OptionExpectsOneArgument { get; }
    internal static string OptionNoArgumentProvided { get; }
    internal static string OptionRequiredArgumentMissing { get; }
    internal static string RequiredCommandWasNotProvided { get; }
    internal static string ResponseFileNotFound { get; }
    internal static string SuggestionsTokenNotMatched { get; }
    internal static string UnrecognizedArgument { get; }
    internal static string UnrecognizedCommandOrArgument { get; }
    internal static string VersionOptionCannotBeCombinedWithOtherArguments { get; }
    internal static string VersionOptionDescription { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_ArgumentConversionCannotParse();
    internal static string get_ArgumentConversionCannotParseForCommand();
    internal static string get_ArgumentConversionCannotParseForOption();
    internal static string get_CommandExpectsFewerArguments();
    internal static string get_CommandExpectsOneArgument();
    internal static string get_CommandNoArgumentProvided();
    internal static string get_CommandRequiredArgumentMissing();
    internal static string get_DirectoryDoesNotExist();
    internal static string get_ErrorReadingResponseFile();
    internal static string get_ExceptionHandlerHeader();
    internal static string get_FileDoesNotExist();
    internal static string get_FileOrDirectoryDoesNotExist();
    internal static string get_HelpAdditionalArgumentsDescription();
    internal static string get_HelpAdditionalArgumentsTitle();
    internal static string get_HelpArgumentDefaultValueLabel();
    internal static string get_HelpArgumentsTitle();
    internal static string get_HelpCommandsTitle();
    internal static string get_HelpDescriptionTitle();
    internal static string get_HelpOptionDescription();
    internal static string get_HelpOptionsRequiredLabel();
    internal static string get_HelpOptionsTitle();
    internal static string get_HelpUsageAdditionalArguments();
    internal static string get_HelpUsageCommand();
    internal static string get_HelpUsageOptions();
    internal static string get_HelpUsageTitle();
    internal static string get_InvalidCharactersInFileName();
    internal static string get_InvalidCharactersInPath();
    internal static string get_OptionExpectsFewerArguments();
    internal static string get_OptionExpectsOneArgument();
    internal static string get_OptionNoArgumentProvided();
    internal static string get_OptionRequiredArgumentMissing();
    internal static string get_RequiredCommandWasNotProvided();
    internal static string get_ResponseFileNotFound();
    internal static string get_SuggestionsTokenNotMatched();
    internal static string get_UnrecognizedArgument();
    internal static string get_UnrecognizedCommandOrArgument();
    internal static string get_VersionOptionCannotBeCombinedWithOtherArguments();
    internal static string get_VersionOptionDescription();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.CommandLine.RootCommand : Command {
    [NullableAttribute("2")]
private static Assembly _assembly;
    [NullableAttribute("2")]
private static string _executablePath;
    [NullableAttribute("2")]
private static string _executableName;
    public static string ExecutableName { get; }
    public static string ExecutablePath { get; }
    public RootCommand(string description);
    internal static Assembly GetAssembly();
    public static string get_ExecutableName();
    public static string get_ExecutablePath();
    private protected virtual void RemoveAlias(string alias);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class System.CommandLine.StringBuilderPool : object {
    public static int DefaultPoolSize;
    [CompilerGeneratedAttribute]
private static StringBuilderPool <Default>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public WeakReference`1[] _pool;
    public static StringBuilderPool Default { get; }
    public StringBuilderPool(int poolSize);
    private static StringBuilderPool();
    [CompilerGeneratedAttribute]
public static StringBuilderPool get_Default();
    public StringBuilder Rent();
    public void ReturnToPool(StringBuilder stringBuilder);
    public string GetStringAndReturn(StringBuilder stringBuilder);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.CommandLine.Symbol : object {
    [NullableAttribute("2")]
private string _name;
    [NullableAttribute("2")]
private ParentNode _firstParent;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsHidden>k__BackingField;
    [NullableAttribute("2")]
public string Description { get; public set; }
    public string Name { get; public set; }
    private protected string DefaultName { get; }
    [NullableAttribute("2")]
internal ParentNode FirstParent { get; }
    public bool IsHidden { get; public set; }
    public IEnumerable`1<Symbol> Parents { get; }
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual string get_Description();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual void set_Description(string value);
    public virtual string get_Name();
    public virtual void set_Name(string value);
    private protected abstract virtual string get_DefaultName();
    [NullableContextAttribute("2")]
internal ParentNode get_FirstParent();
    internal void AddParent(Symbol symbol);
    [CompilerGeneratedAttribute]
public bool get_IsHidden();
    [CompilerGeneratedAttribute]
public void set_IsHidden(bool value);
    [IteratorStateMachineAttribute("System.CommandLine.Symbol/<get_Parents>d__20")]
public IEnumerable`1<Symbol> get_Parents();
    public IEnumerable`1<CompletionItem> GetCompletions();
    public abstract virtual IEnumerable`1<CompletionItem> GetCompletions(CompletionContext context);
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class System.CommandLine.SymbolExtensions : object {
    [ExtensionAttribute]
internal static IReadOnlyList`1<Argument> Arguments(Symbol symbol);
    [ExtensionAttribute]
internal static Parser GetOrCreateDefaultSimpleParser(Symbol symbol);
    [ExtensionAttribute]
internal static Parser GetOrCreateDefaultInvocationParser(Symbol symbol);
    internal static Command GetOrCreateRootCommand(Symbol symbol);
    [CompilerGeneratedAttribute]
internal static RootCommand <GetOrCreateRootCommand>g__Create|3_0(Symbol notCommand);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class System.CommandLine.Validate : object {
    internal static void FileExists(ArgumentResult result);
    internal static void DirectoryExists(ArgumentResult result);
    internal static void FileOrDirectoryExists(ArgumentResult result);
}
internal static class System.Runtime.CompilerServices.IsExternalInit : object {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
