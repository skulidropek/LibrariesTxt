[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
internal class NBitcoin.ActionDisposable : object {
    private Action onEnter;
    private Action onLeave;
    public ActionDisposable(Action onEnter, Action onLeave);
    public sealed virtual void Dispose();
}
public abstract class NBitcoin.Base58Data : object {
    protected Byte[] vchData;
    protected ReadOnlyMemory`1<byte> vchVersion;
    protected string wifData;
    private Network _Network;
    public Network Network { get; }
    protected bool IsValid { get; }
    public Base58Type Type { get; }
    protected Base58Data(Byte[] rawBytes, Network network);
    public sealed virtual Network get_Network();
    protected void Init(string base64, Network expectedNetwork);
    private void SetString(string psz);
    private void SetData(Byte[] vchData);
    protected virtual bool get_IsValid();
    public abstract virtual Base58Type get_Type();
    public string ToWif();
    public Byte[] ToBytes();
    public virtual string ToString();
    public virtual bool Equals(object obj);
    public static bool op_Equality(Base58Data a, Base58Data b);
    public static bool op_Inequality(Base58Data a, Base58Data b);
    public virtual int GetHashCode();
}
public enum NBitcoin.Base58Type : Enum {
    public int value__;
    public static Base58Type PUBKEY_ADDRESS;
    public static Base58Type SCRIPT_ADDRESS;
    public static Base58Type SECRET_KEY;
    public static Base58Type EXT_PUBLIC_KEY;
    public static Base58Type EXT_SECRET_KEY;
    public static Base58Type ENCRYPTED_SECRET_KEY_EC;
    public static Base58Type ENCRYPTED_SECRET_KEY_NO_EC;
    public static Base58Type PASSPHRASE_CODE;
    public static Base58Type CONFIRMATION_CODE;
    public static Base58Type ASSET_ID;
    public static Base58Type COLORED_ADDRESS;
    public static Base58Type BLINDED_ADDRESS;
    public static Base58Type MAX_BASE58_TYPES;
}
public enum NBitcoin.Bech32Type : Enum {
    public int value__;
    public static Bech32Type WITNESS_PUBKEY_ADDRESS;
    public static Bech32Type WITNESS_SCRIPT_ADDRESS;
    public static Bech32Type TAPROOT_ADDRESS;
    public static Bech32Type BLINDED_ADDRESS;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class NBitcoin.BIP322.BIP322Signature : object {
    [CompilerGeneratedAttribute]
private Network <Network>k__BackingField;
    private static string TAG;
    internal static ScriptVerify BIP322ScriptVerify;
    public Network Network { get; }
    private static Byte[] BITCOIN_SIGNED_MESSAGE_HEADER_BYTES { get; }
    protected BIP322Signature(Network network);
    private static BIP322Signature();
    [CompilerGeneratedAttribute]
public Network get_Network();
    public static BIP322Signature Parse(string str, Network network);
    public static bool IsValidPSBT(PSBT psbt);
    public static BIP322Signature FromPSBT(PSBT psbt, SignatureType signatureType);
    private static Byte[] get_BITCOIN_SIGNED_MESSAGE_HEADER_BYTES();
    public static uint256 CreateMessageHash(string message, bool legacy);
    public static PSBT CreatePSBT(BitcoinAddress bitcoinAddress, string message, UInt32 version, UInt32 lockTime, UInt32 sequence, Coin[] fundProofOutputs);
    public static bool TryParse(string str, Network network, BIP322Signature& result);
    public static bool TryCreate(Byte[] bytes, Network network, BIP322Signature& result);
    private static bool TryParseWitScript(Byte[] bytes, WitScript& witScript);
    private static bool TryParseTransaction(Byte[] bytes, Network network, Transaction& tx);
    public abstract virtual Byte[] ToBytes();
    public string ToBase64();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
public static bool op_Equality(BIP322Signature a, BIP322Signature b);
    [NullableContextAttribute("2")]
public static bool op_Inequality(BIP322Signature a, BIP322Signature b);
    public virtual int GetHashCode();
}
public enum NBitcoin.BIP322.SignatureType : Enum {
    public int value__;
    public static SignatureType Legacy;
    public static SignatureType Simple;
    public static SignatureType Full;
}
public enum NBitcoin.BIP9Deployments : Enum {
    public int value__;
    public static BIP9Deployments TestDummy;
    public static BIP9Deployments CSV;
    public static BIP9Deployments Segwit;
}
public class NBitcoin.BIP9DeploymentsParameters : object {
    public static long AlwaysActive;
    [CompilerGeneratedAttribute]
private int <Bit>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <StartTime>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <Timeout>k__BackingField;
    public int Bit { get; private set; }
    public DateTimeOffset StartTime { get; private set; }
    public DateTimeOffset Timeout { get; private set; }
    public BIP9DeploymentsParameters(int bit, DateTimeOffset startTime, DateTimeOffset timeout);
    public BIP9DeploymentsParameters(int bit, long startTime, long timeout);
    [CompilerGeneratedAttribute]
public int get_Bit();
    [CompilerGeneratedAttribute]
private void set_Bit(int value);
    [CompilerGeneratedAttribute]
public DateTimeOffset get_StartTime();
    [CompilerGeneratedAttribute]
private void set_StartTime(DateTimeOffset value);
    [CompilerGeneratedAttribute]
public DateTimeOffset get_Timeout();
    [CompilerGeneratedAttribute]
private void set_Timeout(DateTimeOffset value);
}
public class NBitcoin.Bitcoin : object {
    [CompilerGeneratedAttribute]
private static Bitcoin <Instance>k__BackingField;
    private ConcurrentDictionary`2<ChainName, Network> _Networks;
    private static ChainName MutinynetName;
    private static ChainName SignetName;
    public static Bitcoin Instance { get; }
    public string CryptoCode { get; }
    public Network Mainnet { get; }
    public Network Mutinynet { get; }
    public Network Regtest { get; }
    public Network Signet { get; }
    public Network Testnet { get; }
    private static Bitcoin();
    internal void Init();
    [CompilerGeneratedAttribute]
public static Bitcoin get_Instance();
    public sealed virtual string get_CryptoCode();
    public sealed virtual Network GetNetwork(ChainName chainName);
    [IteratorStateMachineAttribute("NBitcoin.Bitcoin/<LoadNetworkAddresses>d__9")]
private static IEnumerable`1<NetworkAddress> LoadNetworkAddresses(Byte[] payload, NetworkBuilder builder);
    public sealed virtual Network get_Mainnet();
    private Network CreateMainnet();
    private static void assert(bool v);
    private Byte[] GetMainnetSeeds();
    public Network get_Mutinynet();
    private Network CreateMutinyNet();
    private static UInt32 GetMutinynetMagic();
    public sealed virtual Network get_Regtest();
    private Network CreateRegtest();
    public Network get_Signet();
    private Network CreateSignet();
    private static UInt32 GetSignetMagic();
    public sealed virtual Network get_Testnet();
    private Network CreateTestnet();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class NBitcoin.BitcoinAddress : object {
    protected string _Str;
    [NullableAttribute("2")]
private Script _ScriptPubKey;
    private Network _Network;
    public Script ScriptPubKey { get; }
    public Network Network { get; }
    protected internal BitcoinAddress(string str, Network network);
    public static BitcoinAddress Create(string str, Network expectedNetwork);
    public sealed virtual Script get_ScriptPubKey();
    protected abstract virtual Script GeneratePaymentScript();
    public BitcoinColoredAddress ToColoredAddress();
    public sealed virtual Network get_Network();
    public virtual string ToString();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
public static bool op_Equality(BitcoinAddress a, BitcoinAddress b);
    [NullableContextAttribute("2")]
public static bool op_Inequality(BitcoinAddress a, BitcoinAddress b);
    public virtual int GetHashCode();
    public bool VerifyBIP322(string message, string signature, Coin[] fundProofOutputs);
    public bool VerifyBIP322(string message, BIP322Signature signature, Coin[] fundProofOutputs);
    public PSBT CreateBIP322PSBT(string message, UInt32 version, UInt32 lockTime, UInt32 sequence, Coin[] fundProofOutputs);
}
public class NBitcoin.BitcoinColoredAddress : Base58Data {
    private BitcoinAddress _Address;
    protected bool IsValid { get; }
    public BitcoinAddress Address { get; }
    public Base58Type Type { get; }
    public Script ScriptPubKey { get; }
    public BitcoinColoredAddress(string base58, Network expectedNetwork);
    public BitcoinColoredAddress(BitcoinAddress address);
    private static Byte[] Build(BitcoinAddress address);
    protected virtual bool get_IsValid();
    public BitcoinAddress get_Address();
    public virtual Base58Type get_Type();
    public sealed virtual Script get_ScriptPubKey();
    public static string GetWrappedBase58(string base58, Network network);
}
public class NBitcoin.BitcoinConfirmationCode : Base58Data {
    private Byte[] _AddressHash;
    private Byte[] _OwnerEntropy;
    private LotSequence _LotSequence;
    private Byte[] _EncryptedPointB;
    public Byte[] AddressHash { get; }
    public bool IsCompressed { get; }
    public Byte[] OwnerEntropy { get; }
    public LotSequence LotSequence { get; }
    private Byte[] EncryptedPointB { get; }
    public Base58Type Type { get; }
    protected bool IsValid { get; }
    public BitcoinConfirmationCode(string wif, Network expectedNetwork);
    public BitcoinConfirmationCode(Byte[] rawBytes, Network network);
    public Byte[] get_AddressHash();
    public bool get_IsCompressed();
    public Byte[] get_OwnerEntropy();
    public LotSequence get_LotSequence();
    private Byte[] get_EncryptedPointB();
    public virtual Base58Type get_Type();
    protected virtual bool get_IsValid();
    public bool Check(string passphrase, BitcoinAddress expectedAddress);
}
public abstract class NBitcoin.BitcoinEncryptedSecret : Base58Data {
    private Byte[] _AddressHash;
    private Byte[] _LastHalf;
    protected int ValidLength;
    public bool EcMultiply { get; }
    public Byte[] AddressHash { get; }
    public bool IsCompressed { get; }
    public Byte[] EncryptedHalf2 { get; }
    protected bool IsValid { get; }
    protected BitcoinEncryptedSecret(Byte[] raw, Network network);
    protected BitcoinEncryptedSecret(string wif, Network expectedNetwork);
    public static BitcoinEncryptedSecret Create(string wif, Network expectedNetwork);
    public static BitcoinEncryptedSecretNoEC Generate(Key key, string password, Network network);
    public bool get_EcMultiply();
    public Byte[] get_AddressHash();
    public bool get_IsCompressed();
    public Byte[] get_EncryptedHalf2();
    protected virtual bool get_IsValid();
    public Key GetKey(string password);
    public abstract virtual bool TryGetKey(string password, Key& key);
    public BitcoinSecret GetSecret(string password);
    internal static Aes CreateAES256();
    internal static Byte[] EncryptKey(Byte[] key, Byte[] derived);
    private static Byte[] EncryptKey(Byte[] keyhalf1, Byte[] keyhalf2, Byte[] derived);
    internal static Byte[] DecryptKey(Byte[] encrypted, Byte[] derived);
    internal static Byte[] EncryptSeed(Byte[] seedb, Byte[] derived);
    internal static Byte[] DecryptSeed(Byte[] encrypted, Byte[] derived);
}
public class NBitcoin.BitcoinEncryptedSecretEC : BitcoinEncryptedSecret {
    private Byte[] _OwnerEntropy;
    private LotSequence _LotSequence;
    private Byte[] _EncryptedHalfHalf1;
    private Byte[] _PartialEncrypted;
    public Byte[] OwnerEntropy { get; }
    public LotSequence LotSequence { get; }
    public Byte[] EncryptedHalfHalf1 { get; }
    public Byte[] PartialEncrypted { get; }
    public Base58Type Type { get; }
    public BitcoinEncryptedSecretEC(string wif, Network expectedNetwork);
    public BitcoinEncryptedSecretEC(Byte[] raw, Network network);
    public Byte[] get_OwnerEntropy();
    public LotSequence get_LotSequence();
    public Byte[] get_EncryptedHalfHalf1();
    public Byte[] get_PartialEncrypted();
    public virtual Base58Type get_Type();
    public virtual bool TryGetKey(string password, Key& key);
    internal static Byte[] HashAddress(BitcoinAddress address);
    internal static Byte[] CalculatePassPoint(Byte[] passfactor);
    internal static Byte[] CalculatePassFactor(string password, LotSequence lotSequence, Byte[] ownerEntropy);
    internal static Byte[] CalculateDecryptionKey(Byte[] Passpoint, Byte[] addresshash, Byte[] ownerEntropy);
}
public class NBitcoin.BitcoinEncryptedSecretNoEC : BitcoinEncryptedSecret {
    private Byte[] _FirstHalf;
    private Byte[] _Encrypted;
    public Byte[] EncryptedHalf1 { get; }
    public Byte[] Encrypted { get; }
    public Base58Type Type { get; }
    public BitcoinEncryptedSecretNoEC(string wif, Network expectedNetwork);
    public BitcoinEncryptedSecretNoEC(Byte[] raw, Network network);
    public BitcoinEncryptedSecretNoEC(Key key, string password, Network network);
    private static string GenerateWif(Key key, string password, Network network);
    public Byte[] get_EncryptedHalf1();
    public Byte[] get_Encrypted();
    public virtual Base58Type get_Type();
    public virtual bool TryGetKey(string password, Key& key);
}
public class NBitcoin.BitcoinExtKey : BitcoinExtKeyBase {
    private ExtKey _Key;
    protected bool IsValid { get; }
    public ExtKey ExtKey { get; }
    public Base58Type Type { get; }
    public Script ScriptPubKey { get; }
    public Key PrivateKey { get; }
    public BitcoinExtKey(string base58, Network expectedNetwork);
    public BitcoinExtKey(ExtKey key, Network network);
    public BitcoinExtKey(BitcoinExtPubKey bitcoinExtPubKey, Key key);
    protected virtual bool get_IsValid();
    public ExtKey get_ExtKey();
    public virtual Base58Type get_Type();
    public virtual Script get_ScriptPubKey();
    public BitcoinExtPubKey Neuter();
    public BitcoinExtKey Derive(UInt32 index);
    private sealed virtual override IHDKey NBitcoin.IHDKey.Derive(KeyPath keyPath);
    public BitcoinExtKey Derive(KeyPath keyPath);
    public ExtKey Derive(RootedKeyPath rootedKeyPath);
    public sealed virtual PubKey GetPublicKey();
    private sealed virtual override bool NBitcoin.IHDKey.CanDeriveHardenedPath();
    public sealed virtual Key get_PrivateKey();
    public static ExtKey op_Implicit(BitcoinExtKey key);
}
public abstract class NBitcoin.BitcoinExtKeyBase : Base58Data {
    public Script ScriptPubKey { get; }
    protected BitcoinExtKeyBase(Byte[] bytes, Network network);
    public abstract virtual Script get_ScriptPubKey();
}
public class NBitcoin.BitcoinExtPubKey : BitcoinExtKeyBase {
    private ExtPubKey _PubKey;
    public ExtPubKey ExtPubKey { get; }
    protected bool IsValid { get; }
    public Base58Type Type { get; }
    public Script ScriptPubKey { get; }
    public BitcoinExtPubKey(string base58, Network expectedNetwork);
    public BitcoinExtPubKey(ExtPubKey key, Network network);
    public ExtPubKey get_ExtPubKey();
    protected virtual bool get_IsValid();
    public virtual Base58Type get_Type();
    public virtual Script get_ScriptPubKey();
    public static ExtPubKey op_Implicit(BitcoinExtPubKey key);
    private sealed virtual override IHDKey NBitcoin.IHDKey.Derive(KeyPath keyPath);
    public BitcoinExtPubKey Derive(UInt32 index);
    public BitcoinExtPubKey Derive(KeyPath keyPath);
    public sealed virtual PubKey GetPublicKey();
    private sealed virtual override bool NBitcoin.IHDKey.CanDeriveHardenedPath();
}
internal class NBitcoin.BitcoinFormatter : object {
    public static BitcoinFormatter Formatter;
    private static BitcoinFormatter();
    public sealed virtual object GetFormat(Type formatType);
    public sealed virtual string Format(string format, object arg, IFormatProvider formatProvider);
}
public class NBitcoin.BitcoinPassphraseCode : Base58Data {
    private LotSequence _LotSequence;
    private Byte[] _OwnerEntropy;
    private Byte[] _Passpoint;
    public LotSequence LotSequence { get; }
    public Byte[] OwnerEntropy { get; }
    public Byte[] Passpoint { get; }
    protected bool IsValid { get; }
    public Base58Type Type { get; }
    public BitcoinPassphraseCode(string passphrase, Network network, LotSequence lotsequence, Byte[] ownersalt);
    public BitcoinPassphraseCode(string wif, Network expectedNetwork);
    private static string GenerateWif(string passphrase, Network network, LotSequence lotsequence, Byte[] ownersalt);
    public LotSequence get_LotSequence();
    public EncryptedKeyResult GenerateEncryptedSecret(bool isCompressed, Byte[] seedb);
    public Byte[] get_OwnerEntropy();
    public Byte[] get_Passpoint();
    protected virtual bool get_IsValid();
    public virtual Base58Type get_Type();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NBitcoin.BitcoinPubKeyAddress : BitcoinAddress {
    private KeyId _KeyId;
    public KeyId Hash { get; }
    public Base58Type Type { get; }
    public BitcoinPubKeyAddress(string base58, Network expectedNetwork);
    public BitcoinPubKeyAddress(string str, KeyId id, Network expectedNetwork);
    public BitcoinPubKeyAddress(KeyId keyId, Network network);
    private static string Validate(string base58, Network expectedNetwork);
    private static string NotNull(KeyId keyId);
    public KeyId get_Hash();
    public sealed virtual Base58Type get_Type();
    protected virtual Script GeneratePaymentScript();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NBitcoin.BitcoinScriptAddress : BitcoinAddress {
    private ScriptId _Hash;
    public ScriptId Hash { get; }
    public Base58Type Type { get; }
    public BitcoinScriptAddress(string base58, Network expectedNetwork);
    public BitcoinScriptAddress(string str, ScriptId id, Network expectedNetwork);
    public BitcoinScriptAddress(ScriptId scriptId, Network network);
    private static string Validate(string base58, Network expectedNetwork);
    private static string NotNull(ScriptId scriptId);
    public ScriptId get_Hash();
    public sealed virtual Base58Type get_Type();
    protected virtual Script GeneratePaymentScript();
}
public class NBitcoin.BitcoinSecret : Base58Data {
    private Key _Key;
    public KeyId PubKeyHash { get; }
    public PubKey PubKey { get; }
    public Key PrivateKey { get; }
    protected bool IsValid { get; }
    public bool IsCompressed { get; }
    public Base58Type Type { get; }
    private Script NBitcoin.IDestination.ScriptPubKey { get; }
    public BitcoinSecret(Key key, Network network);
    public BitcoinSecret(string base58, Network expectedNetwork);
    private static Byte[] ToBytes(Key key);
    public BitcoinAddress GetAddress(ScriptPubKeyType type);
    public virtual KeyId get_PubKeyHash();
    public PubKey get_PubKey();
    public sealed virtual Key get_PrivateKey();
    protected virtual bool get_IsValid();
    public BitcoinEncryptedSecret Encrypt(string password);
    public BitcoinSecret Copy(Nullable`1<bool> compressed);
    public bool get_IsCompressed();
    public virtual Base58Type get_Type();
    private sealed virtual override Script NBitcoin.IDestination.get_ScriptPubKey();
}
[ExtensionAttribute]
public static class NBitcoin.BitcoinSerializableExtensions : object {
    [ExtensionAttribute]
public static void ReadWrite(IBitcoinSerializable serializable, Stream stream, bool serializing, Network network, Nullable`1<UInt32> version);
    [ExtensionAttribute]
public static void ReadWrite(IBitcoinSerializable serializable, Stream stream, bool serializing, ConsensusFactory consensusFactory, Nullable`1<UInt32> version);
    [ExtensionAttribute]
public static int GetSerializedSize(IBitcoinSerializable serializable, Nullable`1<UInt32> version, SerializationType serializationType);
    [ExtensionAttribute]
public static int GetSerializedSize(IBitcoinSerializable serializable, TransactionOptions options);
    [ExtensionAttribute]
public static int GetSerializedSize(IBitcoinSerializable serializable, Nullable`1<UInt32> version);
    [ExtensionAttribute]
public static void ReadWrite(IBitcoinSerializable serializable, Byte[] bytes, Network network, Nullable`1<UInt32> version);
    [ExtensionAttribute]
public static void ReadWrite(IBitcoinSerializable serializable, Byte[] bytes, ConsensusFactory consensusFactory, Nullable`1<UInt32> version);
    [ExtensionAttribute]
public static void FromBytes(IBitcoinSerializable serializable, Byte[] bytes, Nullable`1<UInt32> version);
    [ExtensionAttribute]
public static T Clone(T serializable, Nullable`1<UInt32> version);
    [ExtensionAttribute]
public static Byte[] ToBytes(IBitcoinSerializable serializable, Nullable`1<UInt32> version);
    [ExtensionAttribute]
public static Byte[] ToArrayEfficient(MemoryStream ms);
}
public class NBitcoin.BitcoinStream : object {
    private int _MaxArraySize;
    internal static MethodInfo _ReadWriteTyped;
    private bool _IsNetworkStream;
    private Stream _Inner;
    private bool _Serializing;
    private ConsensusFactory _ConsensusFactory;
    private PerformanceCounter _Counter;
    [CompilerGeneratedAttribute]
private bool <IsBigEndian>k__BackingField;
    private Nullable`1<UInt32> _ProtocolVersion;
    private ProtocolCapabilities _ProtocolCapabilities;
    private TransactionOptions _TransactionSupportedOptions;
    [CompilerGeneratedAttribute]
private SerializationType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private CancellationToken <ReadCancellationToken>k__BackingField;
    private MutableUint256 _MutableUint256;
    private MutableUint160 _MutableUint160;
    public int MaxArraySize { get; public set; }
    public Stream Inner { get; }
    public bool Serializing { get; }
    public ConsensusFactory ConsensusFactory { get; public set; }
    public PerformanceCounter Counter { get; }
    public bool IsBigEndian { get; public set; }
    public Nullable`1<UInt32> ProtocolVersion { get; public set; }
    public ProtocolCapabilities ProtocolCapabilities { get; }
    public TransactionOptions TransactionOptions { get; public set; }
    public SerializationType Type { get; public set; }
    public CancellationToken ReadCancellationToken { get; public set; }
    private static BitcoinStream();
    public BitcoinStream(Stream inner, bool serializing);
    public BitcoinStream(Byte[] bytes, ConsensusFactory consensusFactory);
    public BitcoinStream(Byte[] bytes);
    public BitcoinStream(Byte[] bytes, int offset, int length);
    public int get_MaxArraySize();
    public void set_MaxArraySize(int value);
    public Stream get_Inner();
    public bool get_Serializing();
    public Script ReadWrite(Script data);
    public void ReadWrite(Script& script);
    public T ReadWrite(T data);
    public ConsensusFactory get_ConsensusFactory();
    public void set_ConsensusFactory(ConsensusFactory value);
    public void ReadWriteAsVarString(Byte[]& bytes);
    public void ReadWrite(Type type, Object& obj);
    public void ReadWrite(Byte& data);
    public byte ReadWrite(byte data);
    public void ReadWrite(Boolean& data);
    public void ReadWriteStruct(T& data);
    public void ReadWriteStruct(T data);
    public void ReadWrite(T& data);
    public void ReadWrite(List`1& list);
    public void ReadWrite(TxInList& list);
    public void ReadWrite(TxOutList& list);
    public void ReadWrite(Byte[] arr);
    public void ReadWrite(Span`1<byte> arr);
    public void ReadWrite(Byte[] arr, int offset, int count);
    public void ReadWrite(T[]& arr);
    private void ReadWriteNumber(Int64& value, int size);
    private void ReadWriteNumber(UInt64& value, int size);
    private void ReadWriteNumberInefficient(UInt64& value, int size);
    internal void ReadWriteBytes(Byte[] data, int offset, int count);
    private void ReadWriteBytes(Span`1<byte> data);
    public PerformanceCounter get_Counter();
    private void ReadWriteByte(Byte& data);
    [CompilerGeneratedAttribute]
public bool get_IsBigEndian();
    [CompilerGeneratedAttribute]
public void set_IsBigEndian(bool value);
    public IDisposable BigEndianScope();
    public Nullable`1<UInt32> get_ProtocolVersion();
    public void set_ProtocolVersion(Nullable`1<UInt32> value);
    public ProtocolCapabilities get_ProtocolCapabilities();
    public TransactionOptions get_TransactionOptions();
    public void set_TransactionOptions(TransactionOptions value);
    public IDisposable ProtocolVersionScope(Nullable`1<UInt32> version);
    public void CopyParameters(BitcoinStream from);
    [CompilerGeneratedAttribute]
public SerializationType get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(SerializationType value);
    public IDisposable SerializationTypeScope(SerializationType value);
    public IDisposable ConsensusFactoryScope(ConsensusFactory consensusFactory);
    [CompilerGeneratedAttribute]
public CancellationToken get_ReadCancellationToken();
    [CompilerGeneratedAttribute]
public void set_ReadCancellationToken(CancellationToken value);
    public void ReadWriteAsVarInt(UInt32& val);
    public void ReadWriteAsVarInt(UInt64& val);
    public void ReadWriteAsCompactVarInt(UInt32& val);
    public void ReadWriteAsCompactVarInt(UInt64& val);
    private void ReadWriteArray(T[]& data);
    private void ReadWriteArray(UInt64[]& data);
    private void ReadWriteArray(UInt16[]& data);
    private void ReadWriteArray(UInt32[]& data);
    public void ReadWrite(UInt64[]& data);
    public void ReadWrite(UInt16[]& data);
    public void ReadWrite(UInt32[]& data);
    public void ReadWrite(uint256& value);
    public void ReadWrite(uint256 value);
    public void ReadWrite(List`1& value);
    public void ReadWrite(uint160& value);
    public void ReadWrite(uint160 value);
    public void ReadWrite(List`1& value);
    public void ReadWrite(UInt64& data);
    public ulong ReadWrite(ulong data);
    public void ReadWrite(UInt16& data);
    public ushort ReadWrite(ushort data);
    public void ReadWrite(UInt32& data);
    public UInt32 ReadWrite(UInt32 data);
    public void ReadWrite(Int64& data);
    public long ReadWrite(long data);
    public void ReadWrite(Int16& data);
    public short ReadWrite(short data);
    public void ReadWrite(Int32& data);
    public int ReadWrite(int data);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NBitcoin.BitcoinWitPubKeyAddress : BitcoinAddress {
    private WitKeyId _Hash;
    public WitKeyId Hash { get; }
    public Bech32Type Type { get; }
    public BitcoinWitPubKeyAddress(string bech32, Network expectedNetwork);
    internal BitcoinWitPubKeyAddress(string str, Byte[] key, Network network);
    public BitcoinWitPubKeyAddress(WitKeyId segwitKeyId, Network network);
    private static string Validate(string bech32, Network expectedNetwork);
    private static string NotNull(WitKeyId segwitKeyId);
    public WitKeyId get_Hash();
    protected virtual Script GeneratePaymentScript();
    public sealed virtual Bech32Type get_Type();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NBitcoin.BitcoinWitScriptAddress : BitcoinAddress {
    private WitScriptId _Hash;
    public WitScriptId Hash { get; }
    public Bech32Type Type { get; }
    public BitcoinWitScriptAddress(string bech32, Network expectedNetwork);
    internal BitcoinWitScriptAddress(string str, Byte[] keyId, Network network);
    public BitcoinWitScriptAddress(WitScriptId segwitScriptId, Network network);
    private static string Validate(string bech32, Network expectedNetwork);
    private static string NotNull(WitScriptId segwitScriptId);
    public WitScriptId get_Hash();
    protected virtual Script GeneratePaymentScript();
    public sealed virtual Bech32Type get_Type();
}
internal class NBitcoin.BitReader : object {
    private BitArray array;
    [CompilerGeneratedAttribute]
private int <Position>k__BackingField;
    public int Position { get; public set; }
    public int Count { get; }
    public BitReader(BitArray array);
    public bool Read();
    [CompilerGeneratedAttribute]
public int get_Position();
    [CompilerGeneratedAttribute]
public void set_Position(int value);
    public int get_Count();
}
internal class NBitcoin.BitStream : object {
    private Byte[] _buffer;
    private int _writePos;
    private int _readPos;
    private int _lengthInBits;
    public BitStream(Byte[] buffer);
    public void WriteBit(bool bit);
    public void WriteBits(ulong data, byte count);
    public void WriteByte(byte b);
    public bool TryReadBit(Boolean& bit);
    public bool TryReadBits(int count, UInt64& bits);
    public bool TryReadByte(Byte& b);
    public Byte[] ToByteArray();
    private void EnsureCapacity();
}
internal class NBitcoin.BitWriter : object {
    private List`1<bool> values;
    private int _Position;
    public int Count { get; }
    public int Position { get; public set; }
    public int get_Count();
    public void Write(bool value);
    internal void Write(Byte[] bytes);
    public void Write(Byte[] bytes, int bitCount);
    public Byte[] ToBytes();
    private static Byte[] ToByteArray(BitArray bits);
    public BitArray ToBitArray();
    public Int32[] ToIntegers();
    private static Byte[] SwapEndianBytes(Byte[] bytes);
    public void Write(UInt32 value, int bitCount);
    public int get_Position();
    public void set_Position(int value);
    internal void Write(BitReader reader, int bitCount);
    public void Write(BitArray bitArray);
    public void Write(BitArray bitArray, int bitCount);
    public void Write(BitReader reader);
    public BitReader ToReader();
    public virtual string ToString();
}
public class NBitcoin.Block : object {
    private BlockHeader header;
    public static UInt32 MAX_BLOCK_SIZE;
    private List`1<Transaction> vtx;
    public List`1<Transaction> Transactions { get; public set; }
    public BlockHeader Header { get; public set; }
    [ObsoleteAttribute("Should use ConsensusFactories")]
public Block(BlockHeader blockHeader);
    public List`1<Transaction> get_Transactions();
    public void set_Transactions(List`1<Transaction> value);
    public MerkleNode GetMerkleRoot();
    public virtual void ReadWrite(BitcoinStream stream);
    public Nullable`1<int> GetCoinbaseHeight();
    private void SetNull();
    public BlockHeader get_Header();
    public void set_Header(BlockHeader value);
    public uint256 GetHash();
    public Transaction AddTransaction(Transaction tx);
    public Block WithOptions(TransactionOptions options);
    public virtual ConsensusFactory GetConsensusFactory();
    public void UpdateMerkleRoot();
    public bool Check();
    public bool CheckProofOfWork();
    public bool CheckMerkleRoot();
    public Block CreateNextBlockWithCoinbase(BitcoinAddress address, int height);
    public Block CreateNextBlockWithCoinbase(BitcoinAddress address, int height, DateTimeOffset now);
    public int GetWeight();
    public Block CreateNextBlockWithCoinbase(PubKey pubkey, Money value, DateTimeOffset now, ConsensusFactory consensusFactory);
    public Block CreateNextBlockWithCoinbase(PubKey pubkey, Money value, ConsensusFactory consensusFactory);
    public static Block Parse(string hex, Network network);
    public static Block Parse(string hex, Consensus consensus);
    public static Block Parse(string hex, ConsensusFactory consensusFactory);
    public static Block Load(Byte[] hex, Network network);
    public static Block Load(Byte[] hex, Consensus consensus);
    public static Block Load(Byte[] hex, ConsensusFactory consensusFactory);
    public MerkleBlock Filter(uint256[] txIds);
    public MerkleBlock Filter(BloomFilter filter);
}
public class NBitcoin.BlockHeader : object {
    internal static int Size;
    private static int CURRENT_VERSION;
    protected uint256 hashPrevBlock;
    protected uint256 hashMerkleRoot;
    protected UInt32 nTime;
    protected UInt32 nBits;
    protected int nVersion;
    protected UInt32 nNonce;
    private uint256[] _Hashes;
    private static BigInteger Pow256;
    public uint256 HashPrevBlock { get; public set; }
    public Target Bits { get; public set; }
    public int Version { get; public set; }
    public UInt32 Nonce { get; public set; }
    public uint256 HashMerkleRoot { get; public set; }
    public bool IsNull { get; }
    public DateTimeOffset BlockTime { get; public set; }
    public BlockHeader(string hex, Network network);
    public BlockHeader(string hex, Consensus consensus);
    public BlockHeader(string hex, ConsensusFactory consensusFactory);
    public BlockHeader(Byte[] data, Network network);
    public BlockHeader(Byte[] data, Consensus consensus);
    public BlockHeader(Byte[] data, ConsensusFactory consensusFactory);
    private static BlockHeader();
    public static BlockHeader Parse(string hex, Network network);
    public static BlockHeader Parse(string hex, Consensus consensus);
    public static BlockHeader Parse(string hex, ConsensusFactory consensusFactory);
    public uint256 get_HashPrevBlock();
    public void set_HashPrevBlock(uint256 value);
    public Target get_Bits();
    public void set_Bits(Target value);
    public int get_Version();
    public void set_Version(int value);
    public UInt32 get_Nonce();
    public void set_Nonce(UInt32 value);
    public uint256 get_HashMerkleRoot();
    public void set_HashMerkleRoot(uint256 value);
    protected internal virtual void SetNull();
    public virtual bool get_IsNull();
    public virtual void ReadWrite(BitcoinStream stream);
    public virtual uint256 GetPoWHash();
    public uint256 GetHash();
    protected virtual HashStreamBase CreateHashStream();
    public void PrecomputeHash(bool invalidateExisting, bool lazily);
    public DateTimeOffset get_BlockTime();
    public void set_BlockTime(DateTimeOffset value);
    public bool CheckProofOfWork();
    public virtual string ToString();
    public void UpdateTime(Network network, ChainedBlock prev);
    public void UpdateTime(Consensus consensus, ChainedBlock prev);
    public void UpdateTime(DateTimeOffset now, Consensus consensus, ChainedBlock prev);
    public void UpdateTime(DateTimeOffset now, Network network, ChainedBlock prev);
    public Target GetWorkRequired(Network network, ChainedBlock prev);
    public Target GetWorkRequired(Consensus consensus, ChainedBlock prev);
}
public class NBitcoin.BlockLocator : object {
    private List`1<uint256> vHave;
    public List`1<uint256> Blocks { get; public set; }
    public List`1<uint256> get_Blocks();
    public void set_Blocks(List`1<uint256> value);
    public sealed virtual void ReadWrite(BitcoinStream stream);
}
public class NBitcoin.BloomFilter : object {
    private static UInt32 MAX_BLOOM_FILTER_SIZE;
    private static UInt32 MAX_HASH_FUNCS;
    [DecimalConstantAttribute("28", "0", "260454100", "3151050610", "1131349103")]
private static decimal LN2SQUARED;
    [DecimalConstantAttribute("28", "0", "375755839", "2180329217", "2860148159")]
private static decimal LN2;
    private Byte[] vData;
    private UInt32 nHashFuncs;
    private UInt32 nTweak;
    private byte nFlags;
    private bool isFull;
    private bool isEmpty;
    public BloomFilter(int nElements, double nFPRate, BloomFlags nFlagsIn);
    public BloomFilter(int nElements, double nFPRate, UInt32 nTweakIn, BloomFlags nFlagsIn);
    private static BloomFilter();
    private UInt32 Hash(UInt32 nHashNum, Byte[] vDataToHash);
    public void Insert(Byte[] vKey);
    public bool Contains(Byte[] vKey);
    public bool Contains(OutPoint outPoint);
    public bool Contains(uint256 hash);
    public void Insert(OutPoint outPoint);
    public void Insert(uint256 value);
    public bool IsWithinSizeConstraints();
    public sealed virtual void ReadWrite(BitcoinStream stream);
    public bool IsRelevantAndUpdate(Transaction tx);
}
[FlagsAttribute]
public enum NBitcoin.BloomFlags : Enum {
    public byte value__;
    public static BloomFlags UPDATE_NONE;
    public static BloomFlags UPDATE_ALL;
    public static BloomFlags UPDATE_P2PUBKEY_ONLY;
    public static BloomFlags UPDATE_MASK;
}
internal abstract class NBitcoin.BouncyCastle.Crypto.Digests.GeneralDigest : object {
    private static int BYTE_LENGTH;
    private Byte[] xBuf;
    private int xBufOff;
    private long byteCount;
    public string AlgorithmName { get; }
    internal GeneralDigest(GeneralDigest t);
    protected void CopyIn(GeneralDigest t);
    public void Update(byte input);
    public void BlockUpdate(Byte[] input, int inOff, int length);
    public void Finish();
    public virtual void Reset();
    public int GetByteLength();
    internal abstract virtual void ProcessWord(Byte[] input, int inOff);
    internal abstract virtual void ProcessLength(long bitLength);
    internal abstract virtual void ProcessBlock();
    public abstract virtual string get_AlgorithmName();
    public abstract virtual int GetDigestSize();
    public abstract virtual int DoFinal(Byte[] output, int outOff);
}
internal class NBitcoin.BouncyCastle.Crypto.Digests.KeccakDigest : object {
    private static UInt64[] KeccakRoundConstants;
    private UInt64[] state;
    protected Byte[] dataQueue;
    protected int rate;
    protected int bitsInQueue;
    protected int fixedOutputLength;
    protected bool squeezing;
    public string AlgorithmName { get; }
    public KeccakDigest(int bitLength);
    public KeccakDigest(KeccakDigest source);
    private static KeccakDigest();
    private void CopyIn(KeccakDigest source);
    public virtual string get_AlgorithmName();
    public virtual int GetDigestSize();
    public virtual void Update(byte input);
    public virtual void BlockUpdate(Byte[] input, int inOff, int len);
    public virtual int DoFinal(Byte[] output, int outOff);
    protected virtual int DoFinal(Byte[] output, int outOff, byte partialByte, int partialBits);
    public virtual void Reset();
    public virtual int GetByteLength();
    private void Init(int bitLength);
    private void InitSponge(int rate);
    protected void Absorb(byte data);
    protected void Absorb(Byte[] data, int off, int len);
    protected void AbsorbBits(int data, int bits);
    private void PadAndSwitchToSqueezingPhase();
    protected void Squeeze(Byte[] output, int offset, long outputLength);
    private void KeccakAbsorb(Byte[] data, int off);
    private void KeccakExtract();
    private void KeccakPermutation();
}
internal class NBitcoin.BouncyCastle.Crypto.Digests.RipeMD160Digest : GeneralDigest {
    private static int DigestLength;
    private int H0;
    private int H1;
    private int H2;
    private int H3;
    private int H4;
    private Int32[] X;
    private int xOff;
    public string AlgorithmName { get; }
    public RipeMD160Digest(RipeMD160Digest t);
    private void CopyIn(RipeMD160Digest t);
    public virtual string get_AlgorithmName();
    public virtual int GetDigestSize();
    internal virtual void ProcessWord(Byte[] input, int inOff);
    internal virtual void ProcessLength(long bitLength);
    private void UnpackWord(int word, Byte[] outBytes, int outOff);
    public virtual int DoFinal(Byte[] output, int outOff);
    public virtual void Reset();
    private int RL(int x, int n);
    private int F1(int x, int y, int z);
    private int F2(int x, int y, int z);
    private int F3(int x, int y, int z);
    private int F4(int x, int y, int z);
    private int F5(int x, int y, int z);
    internal virtual void ProcessBlock();
}
internal class NBitcoin.BouncyCastle.Crypto.Digests.Sha256Digest : GeneralDigest {
    private static int DigestLength;
    private UInt32 H1;
    private UInt32 H2;
    private UInt32 H3;
    private UInt32 H4;
    private UInt32 H5;
    private UInt32 H6;
    private UInt32 H7;
    private UInt32 H8;
    private UInt32[] X;
    private int xOff;
    private static UInt32[] K;
    public string AlgorithmName { get; }
    public Byte[] MidState { get; }
    public Sha256Digest(Sha256Digest t);
    private static Sha256Digest();
    private void CopyIn(Sha256Digest t);
    public virtual string get_AlgorithmName();
    public Byte[] get_MidState();
    public virtual int GetDigestSize();
    internal virtual void ProcessWord(Byte[] input, int inOff);
    internal virtual void ProcessLength(long bitLength);
    public virtual int DoFinal(Byte[] output, int outOff);
    public virtual void Reset();
    private void initHs();
    internal virtual void ProcessBlock();
    private static UInt32 Sum1Ch(UInt32 x, UInt32 y, UInt32 z);
    private static UInt32 Sum0Maj(UInt32 x, UInt32 y, UInt32 z);
    private static UInt32 Theta0(UInt32 x);
    private static UInt32 Theta1(UInt32 x);
}
internal class NBitcoin.BouncyCastle.Crypto.Digests.Sha3Digest : KeccakDigest {
    public string AlgorithmName { get; }
    public Sha3Digest(int bitLength);
    public Sha3Digest(Sha3Digest source);
    private static int CheckBitLength(int bitLength);
    public virtual string get_AlgorithmName();
    public virtual int DoFinal(Byte[] output, int outOff);
    protected virtual int DoFinal(Byte[] output, int outOff, byte partialByte, int partialBits);
}
internal static class NBitcoin.BouncyCastle.Crypto.Utilities.Pack : object {
    internal static void UInt32_To_BE(UInt32 n, Byte[] bs, int off);
    internal static UInt32 BE_To_UInt32(Byte[] bs, int off);
    internal static void BE_To_UInt32(Byte[] bs, int off, UInt32[] ns);
    internal static void UInt64_To_BE(ulong n, Byte[] bs, int off);
    internal static ulong BE_To_UInt64(Byte[] bs, int off);
    internal static void UInt16_To_LE(ushort n, Byte[] bs, int off);
    internal static ushort LE_To_UInt16(Byte[] bs);
    internal static ushort LE_To_UInt16(Byte[] bs, int off);
    internal static Byte[] UInt32_To_LE(UInt32 n);
    internal static void UInt32_To_LE(UInt32 n, Byte[] bs);
    internal static void UInt32_To_LE(UInt32 n, Byte[] bs, int off);
    internal static Byte[] UInt32_To_LE(UInt32[] ns);
    internal static void UInt32_To_LE(UInt32[] ns, Byte[] bs, int off);
    internal static UInt32 LE_To_UInt32(Byte[] bs, int off);
    internal static void UInt64_To_LE(ulong n, Byte[] bs, int off);
    internal static void UInt64_To_LE(UInt64[] ns, int nsOff, int nsLen, Byte[] bs, int bsOff);
    internal static ulong LE_To_UInt64(Byte[] bs, int off);
}
internal abstract class NBitcoin.BouncyCastle.Utilities.Arrays : object {
    public static bool AreEqual(Byte[] a, Byte[] b);
    public static bool AreEqual(Int32[] a, Int32[] b);
    private static bool HaveSameContents(Byte[] a, Byte[] b);
    private static bool HaveSameContents(Int32[] a, Int32[] b);
    public static int GetHashCode(Byte[] data);
    public static int GetHashCode(Int32[] data);
    public static int GetHashCode(UInt32[] data, int off, int len);
    public static Byte[] Clone(Byte[] data);
    public static Int32[] Clone(Int32[] data);
    internal static UInt32[] Clone(UInt32[] data);
    public static Int64[] Clone(Int64[] data);
    public static void Fill(Byte[] buf, byte b);
}
internal abstract class NBitcoin.BouncyCastle.Utilities.Platform : object {
    private static CompareInfo InvariantCompareInfo;
    internal static string NewLine;
    private static Platform();
    private static string GetNewLine();
    internal static bool EqualsIgnoreCase(string a, string b);
    internal static string GetEnvironmentVariable(string variable);
    internal static Exception CreateNotImplementedException(string message);
    internal static IList CreateArrayList();
    internal static IList CreateArrayList(int capacity);
    internal static IList CreateArrayList(ICollection collection);
    internal static IList CreateArrayList(IEnumerable collection);
    internal static IDictionary CreateHashtable();
    internal static IDictionary CreateHashtable(int capacity);
    internal static IDictionary CreateHashtable(IDictionary dictionary);
    internal static string ToLowerInvariant(string s);
    internal static string ToUpperInvariant(string s);
    internal static void Dispose(Stream s);
    internal static void Dispose(TextWriter t);
    internal static int IndexOf(string source, string value);
    internal static int LastIndexOf(string source, string value);
    internal static bool StartsWith(string source, string prefix);
    internal static bool EndsWith(string source, string suffix);
    internal static string GetTypeName(object obj);
}
public abstract class NBitcoin.BuilderExtensions.BuilderExtension : object {
    public static TransactionSignature DummySignature;
    private static BuilderExtension();
    public abstract virtual bool Match(ICoin coin, PSBTInput input);
    public abstract virtual void Sign(InputSigningContext inputSigningContext, IKeyRepository keyRepository, ISigner signer);
    public abstract virtual Script DeduceScriptPubKey(Script scriptSig);
    public abstract virtual bool CanDeduceScriptPubKey(Script scriptSig);
    public abstract virtual bool CanEstimateScriptSigSize(ICoin coin);
    public abstract virtual int EstimateScriptSigSize(ICoin coin);
    public abstract virtual bool IsCompatibleKey(IPubKey publicKey, Script scriptPubKey);
    public abstract virtual void Finalize(InputSigningContext inputSigningContext);
    public virtual void ExtractExistingSignatures(InputSigningContext inputSigningContext);
    public virtual void MergePartialSignatures(InputSigningContext inputSigningContext);
}
[NullableContextAttribute("1")]
public interface NBitcoin.BuilderExtensions.IKeyRepository {
    public abstract virtual IPubKey FindKey(Script scriptPubKey);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NBitcoin.BuilderExtensions.InputSigningContext : object {
    [CompilerGeneratedAttribute]
private TransactionSigningContext <TransactionContext>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private TxIn <OriginalTxIn>k__BackingField;
    [CompilerGeneratedAttribute]
private BuilderExtension <Extension>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private CoinOptions <CoinOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private ICoin <Coin>k__BackingField;
    [CompilerGeneratedAttribute]
private PSBTInput <Input>k__BackingField;
    internal TransactionSigningContext TransactionContext { get; }
    [NullableAttribute("2")]
public TxIn OriginalTxIn { get; }
    public BuilderExtension Extension { get; }
    [NullableAttribute("2")]
public CoinOptions CoinOptions { get; public set; }
    public ICoin Coin { get; }
    public PSBTInput Input { get; }
    internal InputSigningContext(TransactionSigningContext transactionSigningContext, ICoin coin, CoinOptions coinOptions, PSBTInput input, TxIn originalTxIn, BuilderExtension extension);
    [CompilerGeneratedAttribute]
internal TransactionSigningContext get_TransactionContext();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public TxIn get_OriginalTxIn();
    [CompilerGeneratedAttribute]
public BuilderExtension get_Extension();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public CoinOptions get_CoinOptions();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_CoinOptions(CoinOptions value);
    [CompilerGeneratedAttribute]
public ICoin get_Coin();
    [CompilerGeneratedAttribute]
public PSBTInput get_Input();
}
[NullableContextAttribute("1")]
public interface NBitcoin.BuilderExtensions.ISigner {
    public abstract virtual ITransactionSignature Sign(IPubKey key);
}
public class NBitcoin.BuilderExtensions.OPTrueExtension : BuilderExtension {
    public virtual bool CanDeduceScriptPubKey(Script scriptSig);
    public virtual bool CanEstimateScriptSigSize(ICoin coin);
    private static bool CanSign(Script executedScript);
    public virtual Script DeduceScriptPubKey(Script scriptSig);
    public virtual int EstimateScriptSigSize(ICoin coin);
    public virtual bool IsCompatibleKey(IPubKey publicKey, Script scriptPubKey);
    public virtual void Finalize(InputSigningContext inputSigningContext);
    public virtual bool Match(ICoin coin, PSBTInput input);
    public virtual void Sign(InputSigningContext inputSigningContext, IKeyRepository keyRepository, ISigner signer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NBitcoin.BuilderExtensions.P2MultiSigBuilderExtension : BuilderExtension {
    public virtual bool CanDeduceScriptPubKey(Script scriptSig);
    public virtual bool CanEstimateScriptSigSize(ICoin coin);
    private static bool CanSign(Script scriptPubKey);
    public virtual Script DeduceScriptPubKey(Script scriptSig);
    public virtual int EstimateScriptSigSize(ICoin coin);
    public virtual void Sign(InputSigningContext inputSigningContext, IKeyRepository keyRepository, ISigner signer);
    public virtual bool IsCompatibleKey(IPubKey publicKey, Script scriptPubKey);
    public virtual void Finalize(InputSigningContext inputSigningContext);
    public virtual bool Match(ICoin coin, PSBTInput input);
    public virtual void ExtractExistingSignatures(InputSigningContext inputSigningContext);
    public virtual void MergePartialSignatures(InputSigningContext inputSigningContext);
}
public class NBitcoin.BuilderExtensions.P2PKBuilderExtension : BuilderExtension {
    public virtual bool CanDeduceScriptPubKey(Script scriptSig);
    public virtual bool CanEstimateScriptSigSize(ICoin coin);
    public virtual void Sign(InputSigningContext inputSigningContext, IKeyRepository keyRepository, ISigner signer);
    private static bool CanSign(Script scriptPubKey);
    public virtual Script DeduceScriptPubKey(Script scriptSig);
    public virtual int EstimateScriptSigSize(ICoin coin);
    public virtual bool IsCompatibleKey(IPubKey publicKey, Script scriptPubKey);
    public virtual void Finalize(InputSigningContext inputSigningContext);
    public virtual bool Match(ICoin coin, PSBTInput input);
    public virtual void ExtractExistingSignatures(InputSigningContext inputSigningContext);
}
public class NBitcoin.BuilderExtensions.P2PKHBuilderExtension : BuilderExtension {
    public virtual bool CanDeduceScriptPubKey(Script scriptSig);
    public virtual bool CanEstimateScriptSigSize(ICoin coin);
    private static bool CanSign(Script scriptPubKey);
    public virtual Script DeduceScriptPubKey(Script scriptSig);
    public virtual int EstimateScriptSigSize(ICoin coin);
    public virtual bool IsCompatibleKey(IPubKey publicKey, Script scriptPubKey);
    public virtual void Sign(InputSigningContext inputSigningContext, IKeyRepository keyRepository, ISigner signer);
    public virtual void Finalize(InputSigningContext inputSigningContext);
    public virtual bool Match(ICoin coin, PSBTInput input);
    public virtual void ExtractExistingSignatures(InputSigningContext inputSigningContext);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NBitcoin.BuilderExtensions.TaprootKeySpendExtension : BuilderExtension {
    public virtual bool CanDeduceScriptPubKey(Script scriptSig);
    public virtual bool CanEstimateScriptSigSize(ICoin coin);
    private bool CanSign(Script executedScript);
    public virtual Script DeduceScriptPubKey(Script scriptSig);
    public virtual int EstimateScriptSigSize(ICoin coin);
    public virtual void Sign(InputSigningContext inputSigningContext, IKeyRepository keyRepository, ISigner signer);
    public virtual bool IsCompatibleKey(IPubKey publicKey, Script scriptPubKey);
    public virtual void Finalize(InputSigningContext inputSigningContext);
    public virtual bool Match(ICoin coin, PSBTInput input);
}
public enum NBitcoin.BuriedDeployments : Enum {
    public int value__;
    public static BuriedDeployments BIP34;
    public static BuriedDeployments BIP65;
    public static BuriedDeployments BIP66;
}
[ExtensionAttribute]
internal static class NBitcoin.ByteArrayExtensions : object {
    [ExtensionAttribute]
internal static bool StartWith(Byte[] data, Byte[] versionBytes);
    [ExtensionAttribute]
internal static Byte[] SafeSubarray(Byte[] array, int offset, int count);
    [ExtensionAttribute]
internal static Byte[] SafeSubarray(Byte[] array, int offset);
    [ExtensionAttribute]
internal static Byte[] Concat(Byte[] arr, Byte[][] arrs);
}
public class NBitcoin.BytesComparer : Comparer`1<Byte[]> {
    private static BytesComparer _Instance;
    public static BytesComparer Instance { get; }
    private static BytesComparer();
    public static BytesComparer get_Instance();
    public virtual int Compare(Byte[] x, Byte[] y);
    public int Compare(ReadOnlySpan`1<byte> x, ReadOnlySpan`1<byte> y);
}
public class NBitcoin.CachedGRCodedStreamReader : GRCodedStreamReader {
    private List`1<ulong> _cachedValues;
    private int _position;
    internal CachedGRCodedStreamReader(BitStream stream, byte p, ulong lastValue);
    public virtual bool TryRead(UInt64& value);
    internal virtual void ResetPosition();
}
public class NBitcoin.CachedNoSqlRepository : NoSqlRepository {
    private NoSqlRepository _InnerRepository;
    private Dictionary`2<string, Byte[]> _Table;
    private HashSet`1<string> _Removed;
    private HashSet`1<string> _Added;
    private ReaderWriterLock lock;
    public NoSqlRepository InnerRepository { get; }
    public CachedNoSqlRepository(NoSqlRepository inner);
    public NoSqlRepository get_InnerRepository();
    [AsyncStateMachineAttribute("NBitcoin.CachedNoSqlRepository/<PutBatch>d__9")]
public virtual Task PutBatch(IEnumerable`1<Tuple`2<string, IBitcoinSerializable>> values);
    protected virtual Task PutBytesBatch(IEnumerable`1<Tuple`2<string, Byte[]>> enumerable);
    [AsyncStateMachineAttribute("NBitcoin.CachedNoSqlRepository/<GetBytes>d__11")]
protected virtual Task`1<Byte[]> GetBytes(string key);
    public void Flush();
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task <>n__0(IEnumerable`1<Tuple`2<string, IBitcoinSerializable>> values);
    [CompilerGeneratedAttribute]
private Tuple`2<string, IBitcoinSerializable> <Flush>b__12_1(string k);
}
public class NBitcoin.CachedTransactionRepository : object {
    private ITransactionRepository _Inner;
    private Dictionary`2<uint256, Transaction> _Transactions;
    private Queue`1<uint256> _EvictionQueue;
    private ReaderWriterLock lock;
    [CompilerGeneratedAttribute]
private int <MaxCachedTransactions>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <WriteThrough>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ReadThrough>k__BackingField;
    public int MaxCachedTransactions { get; public set; }
    public bool WriteThrough { get; public set; }
    public bool ReadThrough { get; public set; }
    public CachedTransactionRepository(ITransactionRepository inner);
    [CompilerGeneratedAttribute]
public int get_MaxCachedTransactions();
    [CompilerGeneratedAttribute]
public void set_MaxCachedTransactions(int value);
    public Transaction GetFromCache(uint256 txId);
    [AsyncStateMachineAttribute("NBitcoin.CachedTransactionRepository/<GetAsync>d__10")]
public sealed virtual Task`1<Transaction> GetAsync(uint256 txId);
    private void EvictIfNecessary(uint256 txId);
    public sealed virtual Task PutAsync(uint256 txId, Transaction tx);
    [CompilerGeneratedAttribute]
public bool get_WriteThrough();
    [CompilerGeneratedAttribute]
public void set_WriteThrough(bool value);
    [CompilerGeneratedAttribute]
public bool get_ReadThrough();
    [CompilerGeneratedAttribute]
public void set_ReadThrough(bool value);
}
public abstract class NBitcoin.ChainBase : object {
    public ChainedBlock Genesis { get; }
    public ChainedBlock Tip { get; }
    public int Height { get; }
    public virtual ChainedBlock get_Genesis();
    public abstract virtual ChainedBlock GetBlock(uint256 id);
    public abstract virtual ChainedBlock GetBlock(int height);
    public abstract virtual ChainedBlock get_Tip();
    public abstract virtual int get_Height();
    public bool Contains(uint256 hash);
    [IteratorStateMachineAttribute("NBitcoin.ChainBase/<ToEnumerable>d__9")]
public IEnumerable`1<ChainedBlock> ToEnumerable(bool fromTip);
    public ChainedBlock SetTip(ChainBase otherChain);
    public bool SetTip(BlockHeader header);
    public bool TrySetTip(BlockHeader header, ChainedBlock& chainedHeader);
    protected abstract virtual IEnumerable`1<ChainedBlock> EnumerateFromStart();
    public bool Contains(ChainedBlock blockIndex);
    public bool SameTip(ChainBase chain);
    public Target GetWorkRequired(Network network, int height);
    public bool Validate(Network network, bool fullChain);
    public ChainedBlock FindFork(ChainBase chain);
    public ChainedBlock FindFork(IEnumerable`1<uint256> hashes);
    public ChainedBlock FindFork(BlockLocator locator);
    public IEnumerable`1<ChainedBlock> EnumerateAfter(uint256 blockHash);
    public IEnumerable`1<ChainedBlock> EnumerateToTip(ChainedBlock block);
    [IteratorStateMachineAttribute("NBitcoin.ChainBase/<EnumerateToTip>d__23")]
public IEnumerable`1<ChainedBlock> EnumerateToTip(uint256 blockHash);
    [IteratorStateMachineAttribute("NBitcoin.ChainBase/<EnumerateAfter>d__24")]
public virtual IEnumerable`1<ChainedBlock> EnumerateAfter(ChainedBlock block);
    public abstract virtual ChainedBlock SetTip(ChainedBlock pindex);
}
public class NBitcoin.ChainedBlock : object {
    private uint256 phashBlock;
    private ChainedBlock pprev;
    private int nHeight;
    private BlockHeader header;
    private object _ChainWork;
    private static BigInteger Pow256;
    private static int nMedianTimeSpan;
    public uint256 HashBlock { get; }
    public ChainedBlock Previous { get; }
    public int Height { get; }
    public bool HasHeader { get; }
    public BlockHeader Header { get; }
    [DebuggerBrowsableAttribute("0")]
[ObsoleteAttribute("Use GetChainWork() instead")]
public uint256 ChainWork { get; }
    public ChainedBlock(BlockHeader header, uint256 headerHash, ChainedBlock previous);
    public ChainedBlock(BlockHeader header, int height);
    private static ChainedBlock();
    public uint256 get_HashBlock();
    public void StripCachedData();
    public void StripHeader();
    public ChainedBlock get_Previous();
    public int get_Height();
    public bool get_HasHeader();
    public bool TryGetHeader(BlockHeader& header);
    public BlockHeader get_Header();
    public uint256 get_ChainWork();
    public uint256 GetChainWork(bool cacheResult);
    private BigInteger GetChainWorkValue(bool cacheResult);
    private BigInteger CalculateChainWork();
    private BigInteger GetBlockProof();
    public BlockLocator GetLocator();
    public virtual bool Equals(object obj);
    public static bool op_Equality(ChainedBlock a, ChainedBlock b);
    public static bool op_Inequality(ChainedBlock a, ChainedBlock b);
    public virtual int GetHashCode();
    [IteratorStateMachineAttribute("NBitcoin.ChainedBlock/<EnumerateToGenesis>d__32")]
public IEnumerable`1<ChainedBlock> EnumerateToGenesis();
    public virtual string ToString();
    public ChainedBlock FindAncestorOrSelf(int height);
    public ChainedBlock FindAncestorOrSelf(uint256 blockHash);
    public Target GetWorkRequired(Network network);
    public Target GetNextWorkRequired(Network network);
    public Target GetNextWorkRequired(Consensus consensus);
    public Target GetNextWorkRequired(BlockHeader block, Network network);
    public Target GetNextWorkRequired(BlockHeader block, Consensus consensus);
    private void AssertHasHeader();
    public Target GetWorkRequired(Consensus consensus);
    public DateTimeOffset GetMedianTimePast();
    private static void assert(object obj);
    public bool Validate(Network network);
    public bool Validate(Consensus consensus);
    public bool CheckProofOfWorkAndTarget(Network network);
    public bool CheckProofOfWorkAndTarget(Consensus consensus);
    public ChainedBlock FindFork(ChainedBlock block);
    public ChainedBlock GetAncestor(int height);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NBitcoin.ChainName : object {
    [CompilerGeneratedAttribute]
private static ChainName <Mainnet>k__BackingField;
    [CompilerGeneratedAttribute]
private static ChainName <Testnet>k__BackingField;
    [CompilerGeneratedAttribute]
private static ChainName <Regtest>k__BackingField;
    private string nameInvariant;
    public static ChainName Mainnet { get; }
    public static ChainName Testnet { get; }
    public static ChainName Regtest { get; }
    private static ChainName();
    public ChainName(string chainName);
    [CompilerGeneratedAttribute]
public static ChainName get_Mainnet();
    [CompilerGeneratedAttribute]
public static ChainName get_Testnet();
    [CompilerGeneratedAttribute]
public static ChainName get_Regtest();
    [NullableContextAttribute("0")]
private static void CreateInvariant(Span`1<char> span, string arg);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public static bool op_Equality(ChainName a, ChainName b);
    public static bool op_Inequality(ChainName a, ChainName b);
    public virtual int GetHashCode();
    public virtual string ToString();
}
[FlagsAttribute]
public enum NBitcoin.ChangeType : Enum {
    public int value__;
    public static ChangeType All;
    public static ChangeType Colored;
    public static ChangeType Uncolored;
}
[ExtensionAttribute]
internal static class NBitcoin.CharExtensions : object {
    [ExtensionAttribute]
public static bool IsDigit(char c);
}
public class NBitcoin.Coin : object {
    [CompilerGeneratedAttribute]
private OutPoint <Outpoint>k__BackingField;
    [CompilerGeneratedAttribute]
private TxOut <TxOut>k__BackingField;
    protected Script _OverrideScriptCode;
    public bool IsMalleable { get; }
    public bool CanGetScriptCode { get; }
    public OutPoint Outpoint { get; public set; }
    public TxOut TxOut { get; public set; }
    public Money Amount { get; public set; }
    public Script ScriptPubKey { get; public set; }
    private IMoney NBitcoin.ICoin.Amount { get; }
    private OutPoint NBitcoin.ICoinable.Outpoint { get; }
    private TxOut NBitcoin.ICoinable.TxOut { get; }
    public Coin(OutPoint fromOutpoint, TxOut fromTxOut);
    public Coin(Transaction fromTx, UInt32 fromOutputIndex);
    public Coin(Transaction fromTx, TxOut fromOutput);
    public Coin(IndexedTxOut txOut);
    public Coin(uint256 fromTxHash, UInt32 fromOutputIndex, Money amount, Script scriptPubKey);
    public virtual Script GetScriptCode();
    public sealed virtual bool get_IsMalleable();
    public virtual bool get_CanGetScriptCode();
    public virtual HashVersion GetHashVersion();
    public ScriptCoin ToScriptCoin(Script redeemScript);
    public ScriptCoin TryToScriptCoin(Script redeemScript);
    public ScriptCoin TryToScriptCoin(PubKey pubKey);
    public ColoredCoin ToColoredCoin(AssetId asset, ulong quantity);
    public ColoredCoin ToColoredCoin(BitcoinAssetId asset, ulong quantity);
    public ColoredCoin ToColoredCoin(AssetMoney asset);
    [CompilerGeneratedAttribute]
public OutPoint get_Outpoint();
    [CompilerGeneratedAttribute]
public void set_Outpoint(OutPoint value);
    [CompilerGeneratedAttribute]
public TxOut get_TxOut();
    [CompilerGeneratedAttribute]
public void set_TxOut(TxOut value);
    public Money get_Amount();
    public void set_Amount(Money value);
    private void EnsureTxOut();
    public sealed virtual void OverrideScriptCode(Script scriptCode);
    public Script get_ScriptPubKey();
    public void set_ScriptPubKey(Script value);
    private sealed virtual override IMoney NBitcoin.ICoin.get_Amount();
    private sealed virtual override OutPoint NBitcoin.ICoinable.get_Outpoint();
    private sealed virtual override TxOut NBitcoin.ICoinable.get_TxOut();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NBitcoin.CoinNotFoundException : KeyNotFoundException {
    private OutPoint _OutPoint;
    private UInt32 _InputIndex;
    public OutPoint OutPoint { get; }
    public UInt32 InputIndex { get; }
    public CoinNotFoundException(IndexedTxIn txIn);
    public OutPoint get_OutPoint();
    public UInt32 get_InputIndex();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class NBitcoin.CoinOptions : object {
    [CompilerGeneratedAttribute]
private Nullable`1<Sequence> <Sequence>k__BackingField;
    [CompilerGeneratedAttribute]
private KeyPair <KeyPair>k__BackingField;
    public Nullable`1<Sequence> Sequence { get; public set; }
    public KeyPair KeyPair { get; public set; }
    [CompilerGeneratedAttribute]
public Nullable`1<Sequence> get_Sequence();
    [CompilerGeneratedAttribute]
public void set_Sequence(Nullable`1<Sequence> value);
    [CompilerGeneratedAttribute]
public KeyPair get_KeyPair();
    [CompilerGeneratedAttribute]
public void set_KeyPair(KeyPair value);
}
public class NBitcoin.ColoredCoin : object {
    [CompilerGeneratedAttribute]
private AssetMoney <Amount>k__BackingField;
    [CompilerGeneratedAttribute]
private Coin <Bearer>k__BackingField;
    public AssetId AssetId { get; }
    public bool IsMalleable { get; }
    public AssetMoney Amount { get; public set; }
    public Coin Bearer { get; public set; }
    public TxOut TxOut { get; }
    public OutPoint Outpoint { get; }
    public Script ScriptPubKey { get; }
    private AssetId NBitcoin.IColoredCoin.AssetId { get; }
    private Coin NBitcoin.IColoredCoin.Bearer { get; }
    private IMoney NBitcoin.ICoin.Amount { get; }
    private OutPoint NBitcoin.ICoinable.Outpoint { get; }
    private TxOut NBitcoin.ICoinable.TxOut { get; }
    public bool CanGetScriptCode { get; }
    public ColoredCoin(AssetMoney asset, Coin bearer);
    public ColoredCoin(Transaction tx, ColoredEntry entry);
    public AssetId get_AssetId();
    public sealed virtual bool get_IsMalleable();
    [CompilerGeneratedAttribute]
public AssetMoney get_Amount();
    [CompilerGeneratedAttribute]
public void set_Amount(AssetMoney value);
    [CompilerGeneratedAttribute]
public Coin get_Bearer();
    [CompilerGeneratedAttribute]
public void set_Bearer(Coin value);
    public TxOut get_TxOut();
    public OutPoint get_Outpoint();
    public Script get_ScriptPubKey();
    public static IEnumerable`1<ColoredCoin> Find(Transaction tx, ColoredTransaction colored);
    [IteratorStateMachineAttribute("NBitcoin.ColoredCoin/<Find>d__22")]
public static IEnumerable`1<ColoredCoin> Find(uint256 txId, Transaction tx, ColoredTransaction colored);
    public static IEnumerable`1<ColoredCoin> Find(Transaction tx, IColoredTransactionRepository repo);
    public static IEnumerable`1<ColoredCoin> Find(uint256 txId, Transaction tx, IColoredTransactionRepository repo);
    private sealed virtual override AssetId NBitcoin.IColoredCoin.get_AssetId();
    private sealed virtual override Coin NBitcoin.IColoredCoin.get_Bearer();
    private sealed virtual override IMoney NBitcoin.ICoin.get_Amount();
    private sealed virtual override OutPoint NBitcoin.ICoinable.get_Outpoint();
    private sealed virtual override TxOut NBitcoin.ICoinable.get_TxOut();
    public sealed virtual Script GetScriptCode();
    public sealed virtual bool get_CanGetScriptCode();
    public sealed virtual HashVersion GetHashVersion();
    public sealed virtual void OverrideScriptCode(Script scriptCode);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NBitcoin.CompactSignature : object {
    [CompilerGeneratedAttribute]
private int <RecoveryId>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <Signature>k__BackingField;
    public int RecoveryId { get; }
    public Byte[] Signature { get; }
    public CompactSignature(int recoveryId, Byte[] sig64);
    public static bool IsValidRecId(int recid);
    [CompilerGeneratedAttribute]
public int get_RecoveryId();
    [CompilerGeneratedAttribute]
public Byte[] get_Signature();
    public PubKey RecoverPubKey(uint256 hash);
}
public class NBitcoin.ConcurrentChain : ChainBase {
    private Dictionary`2<uint256, ChainedBlock> _BlocksById;
    private ChainedBlock[] _BlocksByHeight;
    private ReaderWriterLock lock;
    private ChainedBlock modreq(System.Runtime.CompilerServices.IsVolatile) _Tip;
    public ChainedBlock Tip { get; }
    public int Height { get; }
    public ConcurrentChain(BlockHeader genesis);
    public ConcurrentChain(Network network);
    public ConcurrentChain(Byte[] bytes, ConsensusFactory consensusFactory);
    public ConcurrentChain(Byte[] bytes, Consensus consensus);
    public ConcurrentChain(Byte[] bytes, Network network);
    [ObsoleteAttribute("Use ConcurrentChain(byte[], ConsensusFactory|Network|Consensus) instead")]
public ConcurrentChain(Byte[] bytes);
    public ConcurrentChain(Byte[] bytes, ConsensusFactory consensusFactory, ChainSerializationFormat format);
    public ConcurrentChain(Byte[] bytes, Consensus consensus, ChainSerializationFormat format);
    public ConcurrentChain(Byte[] bytes, Network network, ChainSerializationFormat format);
    [ObsoleteAttribute("Use ConcurrentChain(byte[], ConsensusFactory|Network|Consensus, ChainSerializationFormat format) instead")]
public ConcurrentChain(Byte[] bytes, ChainSerializationFormat format);
    public void Load(Byte[] chain, Network network, ChainSerializationFormat format);
    public void Load(Byte[] chain, Consensus consensus, ChainSerializationFormat format);
    public void Load(Byte[] chain, ConsensusFactory consensusFactory, ChainSerializationFormat format);
    [ObsoleteAttribute("Use Load(byte[], ConsensusFactory|Network|Consensus, ChainSerializationFormat format) instead")]
public void Load(Byte[] chain, ChainSerializationFormat format);
    public void Load(Byte[] chain, ConsensusFactory consensusFactory);
    public void Load(Byte[] chain, Consensus consensus);
    public void Load(Byte[] chain, Network network);
    [ObsoleteAttribute("Use Load(byte[], ConsensusFactory|Network|Consensus) instead")]
public void Load(Byte[] chain);
    public void Load(Stream stream, ConsensusFactory consensusFactory, ChainSerializationFormat format);
    public void Load(Stream stream, Network network, ChainSerializationFormat format);
    public void Load(Stream stream, Consensus consensus, ChainSerializationFormat format);
    [ObsoleteAttribute("Use Load(Stream, ConsensusFactory|Network|Consensus, ChainSerializationFormat) instead")]
public void Load(Stream stream, ChainSerializationFormat format);
    public void Load(Stream stream);
    public void Load(BitcoinStream stream);
    public void Load(BitcoinStream stream, ChainSerializationFormat format);
    public Byte[] ToBytes();
    public void WriteTo(Stream stream);
    public void WriteTo(Stream stream, ChainSerializationFormat format);
    public void WriteTo(BitcoinStream stream);
    public void WriteTo(BitcoinStream stream, ChainSerializationFormat format);
    public ConcurrentChain Clone();
    public virtual ChainedBlock SetTip(ChainedBlock block);
    private ChainedBlock SetTipNoLock(ChainedBlock block);
    [IteratorStateMachineAttribute("NBitcoin.ConcurrentChain/<EnumerateThisToFork>d__38")]
private IEnumerable`1<ChainedBlock> EnumerateThisToFork(ChainedBlock block);
    public virtual ChainedBlock GetBlock(uint256 id);
    private ChainedBlock GetBlockNoLock(int height);
    private bool TryGetBlocksByHeight(int height, ChainedBlock& result);
    private void RemoveBlocksByHeight(int height);
    private void AddOrReplaceBlocksByHeight(int height, ChainedBlock newBlock);
    public virtual ChainedBlock GetBlock(int height);
    public virtual ChainedBlock get_Tip();
    public virtual int get_Height();
    [IteratorStateMachineAttribute("NBitcoin.ConcurrentChain/<EnumerateFromStart>d__50")]
protected virtual IEnumerable`1<ChainedBlock> EnumerateFromStart();
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NBitcoin.Consensus : object {
    private BuriedDeploymentsArray _BuriedDeployments;
    private BIP9DeploymentsArray _BIP9Deployments;
    private int _SubsidyHalvingInterval;
    private ConsensusFactory _ConsensusFactory;
    private int _MajorityEnforceBlockUpgrade;
    private int _MajorityRejectBlockOutdated;
    private int _MajorityWindow;
    [NullableAttribute("2")]
private uint256 _BIP34Hash;
    [NullableAttribute("2")]
private Target _PowLimit;
    private TimeSpan _PowTargetTimespan;
    private TimeSpan _PowTargetSpacing;
    private bool _PowAllowMinDifficultyBlocks;
    private bool _PowNoRetargeting;
    [NullableAttribute("2")]
private uint256 _HashGenesisBlock;
    [NullableAttribute("2")]
private Byte[] _genesis;
    [NullableAttribute("2")]
private uint256 _MinimumChainWork;
    private int _MinerConfirmationWindow;
    private int _RuleChangeActivationThreshold;
    private int _CoinbaseMaturity;
    private int _CoinType;
    private bool _LitecoinWorkCalculation;
    private bool frozen;
    private bool _SupportTaproot;
    private bool _SupportSegwit;
    private bool _NeverNeedPreviousTxForSigning;
    public static Consensus Main { get; }
    public static Consensus TestNet { get; }
    public static Consensus RegTest { get; }
    public BuriedDeploymentsArray BuriedDeployments { get; }
    public BIP9DeploymentsArray BIP9Deployments { get; }
    public int SubsidyHalvingInterval { get; public set; }
    public ConsensusFactory ConsensusFactory { get; public set; }
    public int MajorityEnforceBlockUpgrade { get; public set; }
    public int MajorityRejectBlockOutdated { get; public set; }
    public int MajorityWindow { get; public set; }
    [NullableAttribute("2")]
public uint256 BIP34Hash { get; public set; }
    [NullableAttribute("2")]
public Target PowLimit { get; public set; }
    public TimeSpan PowTargetTimespan { get; public set; }
    public TimeSpan PowTargetSpacing { get; public set; }
    public bool PowAllowMinDifficultyBlocks { get; public set; }
    public bool PowNoRetargeting { get; public set; }
    public uint256 HashGenesisBlock { get; }
    [NullableAttribute("2")]
public uint256 MinimumChainWork { get; public set; }
    public long DifficultyAdjustmentInterval { get; }
    public int MinerConfirmationWindow { get; public set; }
    public int RuleChangeActivationThreshold { get; public set; }
    public int CoinbaseMaturity { get; public set; }
    public int CoinType { get; public set; }
    public bool LitecoinWorkCalculation { get; public set; }
    public bool SupportTaproot { get; public set; }
    public bool SupportSegwit { get; public set; }
    public bool NeverNeedPreviousTxForSigning { get; public set; }
    public static Consensus get_Main();
    public static Consensus get_TestNet();
    public static Consensus get_RegTest();
    public BuriedDeploymentsArray get_BuriedDeployments();
    public BIP9DeploymentsArray get_BIP9Deployments();
    public int get_SubsidyHalvingInterval();
    public void set_SubsidyHalvingInterval(int value);
    public ConsensusFactory get_ConsensusFactory();
    public void set_ConsensusFactory(ConsensusFactory value);
    public int get_MajorityEnforceBlockUpgrade();
    public void set_MajorityEnforceBlockUpgrade(int value);
    public int get_MajorityRejectBlockOutdated();
    public void set_MajorityRejectBlockOutdated(int value);
    public int get_MajorityWindow();
    public void set_MajorityWindow(int value);
    [NullableContextAttribute("2")]
public uint256 get_BIP34Hash();
    [NullableContextAttribute("2")]
public void set_BIP34Hash(uint256 value);
    [NullableContextAttribute("2")]
public Target get_PowLimit();
    [NullableContextAttribute("2")]
public void set_PowLimit(Target value);
    public TimeSpan get_PowTargetTimespan();
    public void set_PowTargetTimespan(TimeSpan value);
    public TimeSpan get_PowTargetSpacing();
    public void set_PowTargetSpacing(TimeSpan value);
    public bool get_PowAllowMinDifficultyBlocks();
    public void set_PowAllowMinDifficultyBlocks(bool value);
    public bool get_PowNoRetargeting();
    public void set_PowNoRetargeting(bool value);
    internal void SetBlock(Byte[] genesis);
    public uint256 get_HashGenesisBlock();
    [NullableContextAttribute("2")]
public uint256 get_MinimumChainWork();
    [NullableContextAttribute("2")]
public void set_MinimumChainWork(uint256 value);
    public long get_DifficultyAdjustmentInterval();
    public int get_MinerConfirmationWindow();
    public void set_MinerConfirmationWindow(int value);
    public int get_RuleChangeActivationThreshold();
    public void set_RuleChangeActivationThreshold(int value);
    public int get_CoinbaseMaturity();
    public void set_CoinbaseMaturity(int value);
    public int get_CoinType();
    public void set_CoinType(int value);
    public bool get_LitecoinWorkCalculation();
    public void set_LitecoinWorkCalculation(bool value);
    public void Freeze();
    private void EnsureNotFrozen();
    public bool get_SupportTaproot();
    public void set_SupportTaproot(bool value);
    public bool get_SupportSegwit();
    public void set_SupportSegwit(bool value);
    public bool get_NeverNeedPreviousTxForSigning();
    public void set_NeverNeedPreviousTxForSigning(bool value);
    public virtual Consensus Clone();
    public TimeSpan GetExpectedTimeFor(double blockCount);
    public double GetExpectedBlocksFor(TimeSpan timeSpan);
    protected void Fill(Consensus consensus);
}
public class NBitcoin.ConsensusFactory : object {
    private static TypeInfo BlockHeaderType;
    private static TypeInfo BlockType;
    private static TypeInfo TransactionType;
    private static TypeInfo TxInType;
    private static TypeInfo TxOutType;
    private static TypeInfo PSBTType;
    private static ConsensusFactory();
    protected bool IsBlockHeader(Type type);
    protected bool IsTxIn(Type type);
    protected bool IsTxOut(Type type);
    protected bool IsBlock(Type type);
    protected bool IsTransaction(Type type);
    public virtual bool TryCreateNew(Type type, IBitcoinSerializable& result);
    public bool TryCreateNew(T& result);
    public virtual Payload CreatePayload(string command);
    public virtual ProtocolCapabilities GetProtocolCapabilities(UInt32 protocolVersion);
    public virtual Block CreateBlock();
    public virtual BlockHeader CreateBlockHeader();
    public virtual Transaction CreateTransaction();
    public virtual TxIn CreateTxIn();
    public virtual TxOut CreateTxOut();
    protected virtual TransactionBuilder CreateTransactionBuilderCore(Network network);
    internal TransactionBuilder CreateTransactionBuilderCore2(Network network);
}
public class NBitcoin.ContextStack`1 : object {
    private T[] _array;
    private int _position;
    public int Count { get; }
    public ContextStack`1(ContextStack`1<T> stack);
    public ContextStack`1(IEnumerable`1<T> elements);
    public int get_Count();
    public void Push(T item);
    public T Pop();
    public void Clear(int n);
    public T Top(int i);
    public void Swap(int i, int j);
    public void Insert(int position, T value);
    public void Remove(int from);
    public void Remove(int from, int to);
    private void EnsureSize();
    public T[] AsInternalArray();
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    internal void Clear();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NBitcoin.ControlBlock : object {
    [CompilerGeneratedAttribute]
private TapLeafVersion <LeafVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <OutputParityIsOdd>k__BackingField;
    [CompilerGeneratedAttribute]
private TaprootInternalPubKey <InternalPubKey>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private List`1<uint256> <MerkleBranch>k__BackingField;
    private static HexEncoder _hex;
    public TapLeafVersion LeafVersion { get; }
    public bool OutputParityIsOdd { get; }
    public TaprootInternalPubKey InternalPubKey { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public List`1<uint256> MerkleBranch { get; }
    public ControlBlock(TapLeafVersion leafVersion, bool outputParityIsOdd, TaprootInternalPubKey internalPubKey, List`1<uint256> merkleBranch);
    private static ControlBlock();
    [CompilerGeneratedAttribute]
public TapLeafVersion get_LeafVersion();
    [CompilerGeneratedAttribute]
public bool get_OutputParityIsOdd();
    [CompilerGeneratedAttribute]
public TaprootInternalPubKey get_InternalPubKey();
    [CompilerGeneratedAttribute]
public List`1<uint256> get_MerkleBranch();
    public static ControlBlock FromHex(string hex);
    [NullableContextAttribute("0")]
public static ControlBlock FromSlice(ReadOnlySpan`1<byte> buffer);
    public Byte[] ToBytes();
    public bool VerifyTaprootCommitment(TaprootFullPubKey outputKey, TapScript script);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(ControlBlock other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class NBitcoin.Crypto.AesBuilder : object {
    private Byte[] _key;
    private Nullable`1<bool> _forEncryption;
    private Byte[] _iv;
    public AesBuilder SetKey(Byte[] key);
    public AesBuilder IsUsedForEncryption(bool forEncryption);
    public AesBuilder SetIv(Byte[] iv);
    public AesWrapper Build();
}
internal class NBitcoin.Crypto.AesWrapper : object {
    private Aes _inner;
    private ICryptoTransform _transformer;
    private AesWrapper(Aes aes);
    internal static AesWrapper Create();
    public Byte[] Process(Byte[] inputBuffer, int inputOffset, int inputCount);
    internal void Initialize(Byte[] key, Byte[] iv, bool forEncryption);
}
public abstract class NBitcoin.Crypto.BufferedHashStream : HashStreamBase {
    private MemoryStream ms;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public BufferedHashStream(int capacity);
    public static BufferedHashStream CreateFrom(Func`4<Byte[], int, int, Byte[]> calculateHash, int capacity);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Flush();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void WriteByte(byte value);
    public virtual uint256 GetHash();
    protected abstract virtual uint256 GetHash(Byte[] data, int offset, int length);
}
public class NBitcoin.Crypto.ECDSASignature : object {
    private Scalar r;
    private Scalar s;
    private static string InvalidDERSignature;
    public bool IsLowS { get; }
    public bool IsLowR { get; }
    internal ECDSASignature(Scalar& r, Scalar& s);
    internal ECDSASignature(SecpECDSASignature sig);
    public ECDSASignature(Byte[] derSig);
    public ECDSASignature(ReadOnlySpan`1<byte> derSig);
    private static bool ecdsa_signature_parse_der_lax(ReadOnlySpan`1<byte> input, SecpECDSASignature& sig);
    public static bool TryParseFromCompact(Byte[] compactFormat, ECDSASignature& signature);
    public static bool TryParseFromCompact(ReadOnlySpan`1<byte> compactFormat, ECDSASignature& signature);
    public Byte[] ToCompact();
    public Byte[] ToDER();
    public void WriteDerToSpan(Span`1<byte> sigs, Int32& length);
    internal SecpECDSASignature ToSecpECDSASignature();
    public static ECDSASignature FromDER(Byte[] sig);
    public ECDSASignature MakeCanonical();
    public bool get_IsLowS();
    public bool get_IsLowR();
    public static bool IsValidDER(ReadOnlySpan`1<byte> bytes);
    public static bool IsValidDER(Byte[] bytes);
}
public static class NBitcoin.Crypto.Hashes : object {
    public static uint256 DoubleSHA256(Byte[] data);
    public static uint256 DoubleSHA256(Byte[] data, int count);
    public static uint256 DoubleSHA256(Byte[] data, int offset, int count);
    public static Byte[] DoubleSHA256RawBytes(Byte[] data);
    public static Byte[] DoubleSHA256RawBytes(Byte[] data, int offset, int count);
    public static uint160 Hash160(Byte[] data);
    public static uint160 Hash160(ReadOnlySpan`1<byte> data);
    public static uint160 Hash160(Byte[] data, int count);
    public static uint160 Hash160(Byte[] data, int offset, int count);
    public static Byte[] RIPEMD160(Byte[] data);
    public static Byte[] RIPEMD160(Byte[] data, int count);
    public static Byte[] RIPEMD160(Byte[] data, int offset, int count);
    public static Byte[] SHA1(Byte[] data, int offset, int count);
    public static ulong SipHash(ulong k0, ulong k1, uint256 val);
    public static Byte[] SHA256(Byte[] data);
    public static Byte[] SHA256(ReadOnlySpan`1<byte> data);
    public static Byte[] SHA256(Byte[] data, int offset, int count);
    public static Byte[] SHA512(Byte[] data);
    public static Byte[] SHA512(Byte[] data, int offset, int count);
    private static UInt32 rotl32(UInt32 x, byte r);
    private static UInt32 fmix(UInt32 h);
    public static UInt32 MurmurHash3(UInt32 nHashSeed, Byte[] vDataToHash);
    public static Byte[] HMACSHA512(Byte[] key, Byte[] data);
    public static bool HMACSHA512(Byte[] key, ReadOnlySpan`1<byte> data, Span`1<byte> output, Int32& outputLength);
    public static Byte[] HMACSHA256(Byte[] key, Byte[] data);
    public static void BIP32Hash(Byte[] chainCode, UInt32 nChild, byte header, Span`1<byte> data, Span`1<byte> output);
    public static Byte[] BIP32Hash(Byte[] chainCode, UInt32 nChild, byte header, Byte[] data);
}
public class NBitcoin.Crypto.HashStream : HashStreamBase {
    [CompilerGeneratedAttribute]
private bool <SingleSHA256>k__BackingField;
    private Byte[] _Buffer;
    private int _Pos;
    private SHA256 sha;
    private static Byte[] Empty;
    public bool SingleSHA256 { get; public set; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    private static HashStream();
    [CompilerGeneratedAttribute]
public bool get_SingleSHA256();
    [CompilerGeneratedAttribute]
public void set_SingleSHA256(bool value);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Flush();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(ReadOnlySpan`1<byte> buffer);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void WriteByte(byte value);
    private bool ProcessBlockIfNeeded();
    private void ProcessBlock();
    public virtual uint256 GetHash();
    public void GetHash(Span`1<byte> output);
    protected virtual void Dispose(bool disposing);
}
public abstract class NBitcoin.Crypto.HashStreamBase : Stream {
    public abstract virtual uint256 GetHash();
    public void InitializeTagged(string tag);
}
internal static class NBitcoin.Crypto.Internal.BitMath : object {
    public static bool IsPositivePowerOf2(int value);
    public static byte ReverseBits(byte value);
}
internal static class NBitcoin.Crypto.Internal.BitPacking : object {
    public static UInt32 UInt24FromLEBytes(Byte[] bytes, int offset);
    public static UInt32 UInt32FromLEBytes(Byte[] bytes, int offset);
    public static void BEBytesFromUInt32(UInt32 value, Byte[] bytes, int offset);
    public static void LEBytesFromUInt24(UInt32 value, Byte[] bytes, int offset);
    public static void LEBytesFromUInt32(UInt32 value, Byte[] bytes, int offset);
}
internal static class NBitcoin.Crypto.Internal.Check : object {
    public static void Bounds(string valueName, Array value, int offset, int count);
    public static void Length(string valueName, Array value, int minimum, int maximum);
    public static void Null(string valueName, T value);
    public static void Range(string valueName, int value, int minimum, int maximum);
}
internal static class NBitcoin.Crypto.Internal.Exceptions : object {
    public static ArgumentException Argument(string valueName, string message, Object[] args);
    public static ArgumentNullException ArgumentNull(string valueName);
    public static ArgumentOutOfRangeException ArgumentOutOfRange(string valueName, string message, Object[] args);
    public static NotSupportedException NotSupported();
}
internal static class NBitcoin.Crypto.Internal.Security : object {
    public static void Clear(Array array);
}
[ObsoleteAttribute("This might disappear in favour of .NET BCL's Rfc2898DeriveBytes class")]
public class NBitcoin.Crypto.Pbkdf2 : Stream {
    private Byte[] _saltBuffer;
    private Byte[] _digest;
    private Byte[] _digestT1;
    private KeyedHashAlgorithm _hmacAlgorithm;
    private int _iterations;
    private long _blockStart;
    private long _blockEnd;
    private long _pos;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public Pbkdf2(KeyedHashAlgorithm hmacAlgorithm, Byte[] salt, int iterations);
    public Byte[] Read(int count);
    public static Byte[] ComputeDerivedKey(KeyedHashAlgorithm hmacAlgorithm, Byte[] salt, int iterations, int derivedKeyLength);
    public virtual void Close();
    private void DisposeHmac();
    private void ComputeBlock(UInt32 pos);
    private void ComputeHmac(Byte[] input, Byte[] output);
    public virtual void Flush();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
}
public static class NBitcoin.Crypto.Salsa20Core : object {
    private static UInt32 R(UInt32 a, int b);
    public static void Compute(int rounds, UInt32[] input, int inputOffset, UInt32[] output, int outputOffset);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NBitcoin.Crypto.SchnorrSignature : object {
    internal SecpSchnorrSignature secpShnorr;
    public SchnorrSignature(Byte[] bytes);
    internal SchnorrSignature(SecpSchnorrSignature secpShnorr);
    public static SchnorrSignature Parse(string hex);
    [NullableContextAttribute("0")]
public static bool TryParse(ReadOnlySpan`1<byte> in64, SchnorrSignature& sig);
    public static bool TryParse(Byte[] in64, SchnorrSignature& sig);
    public Byte[] ToBytes();
}
public static class NBitcoin.Crypto.SCrypt : object {
    private static int hLen;
    public static Byte[] ComputeDerivedKey(Byte[] key, Byte[] salt, int cost, int blockSize, int parallel, Nullable`1<int> maxThreads, int derivedKeyLength);
    public static Byte[] GetEffectivePbkdf2Salt(Byte[] key, Byte[] salt, int cost, int blockSize, int parallel, Nullable`1<int> maxThreads);
    private static Byte[] MFcrypt(Byte[] P, Byte[] S, int cost, int blockSize, int parallel, Nullable`1<int> maxThreads);
    private static void ThreadSMixCalls(UInt32[] B0, int MFLen, int cost, int blockSize, int parallel, int maxThreads);
    private static void SMix(UInt32[] B, int Boffset, UInt32[] Bp, int Bpoffset, UInt32 N, int r);
    private static void BlockMix(UInt32[] B, int Boffset, UInt32[] Bp, int Bpoffset, UInt32[] x, UInt32[] y, UInt32[] scratch, int r);
    public static Byte[] BitcoinComputeDerivedKey(Byte[] password, Byte[] salt, int outputCount);
    public static Byte[] BitcoinComputeDerivedKey2(Byte[] password, Byte[] salt, int outputCount);
    public static Byte[] BitcoinComputeDerivedKey(string password, Byte[] salt);
}
public class NBitcoin.DataEncoders.ASCIIEncoder : DataEncoder {
    public virtual Byte[] DecodeData(string encoded);
    public void DecodeData(string encoded, Span`1<byte> output);
    public virtual string EncodeData(Byte[] data, int offset, int count);
}
public class NBitcoin.DataEncoders.Base32Encoder : DataEncoder {
    private static Int32[] decode32_table;
    private static string pbase32;
    private static Base32Encoder();
    public virtual string EncodeData(Byte[] data, int offset, int count);
    private static bool ConvertBits(Action`1<byte> outfn, Span`1<byte> val, int valOffset, int valCount, int frombits, int tobits, bool pad);
    public virtual Byte[] DecodeData(string encoded);
}
public class NBitcoin.DataEncoders.Base58CheckEncoder : Base58Encoder {
    private static Base58Encoder InternalEncoder;
    private static Base58CheckEncoder();
    public virtual bool IsMaybeEncoded(string str);
    public virtual string EncodeData(Byte[] data, int offset, int count);
    public virtual Byte[] DecodeData(string encoded);
    protected virtual Byte[] CalculateHash(Byte[] bytes, int offset, int length);
}
public class NBitcoin.DataEncoders.Base58Encoder : DataEncoder {
    private static Char[] pszBase58;
    private static Int32[] mapBase58;
    private static Base58Encoder();
    public virtual bool IsMaybeEncoded(string str);
    public virtual string EncodeData(Byte[] data, int offset, int count);
    public virtual Byte[] DecodeData(string encoded);
}
public class NBitcoin.DataEncoders.Base64Encoder : DataEncoder {
    public virtual Byte[] DecodeData(string encoded);
    public virtual string EncodeData(Byte[] data, int offset, int count);
}
public class NBitcoin.DataEncoders.Bech32Encoder : object {
    private static Int32[] GF1024_EXP;
    private static Int32[] GF1024_LOG;
    protected static Byte[] Byteset;
    private static UInt32[] Generator;
    protected Byte[] _HrpExpand;
    protected Byte[] _Hrp;
    [CompilerGeneratedAttribute]
private bool <StrictLength>k__BackingField;
    public Byte[] HumanReadablePart { get; }
    public bool StrictLength { get; public set; }
    private static Bech32Encoder();
    internal Bech32Encoder(string hrp);
    public Bech32Encoder(Byte[] hrp);
    private UInt32 syndrome(UInt32 residue);
    private Int32[] locate_errors(UInt32 residue, int length);
    public Byte[] get_HumanReadablePart();
    private static UInt32 Polymod(ReadOnlySpan`1<byte> values);
    protected virtual bool VerifyChecksum(Byte[] data, int bechStringLen, Bech32EncodingType& encodingType, Int32[]& errorPosition);
    protected virtual bool VerifyChecksum(ReadOnlySpan`1<byte> data, int bechStringLen, Bech32EncodingType& encodingType, Int32[]& errorPosition);
    private void CreateChecksum(ReadOnlySpan`1<byte> data, Bech32EncodingType encodingType, Span`1<byte> ret);
    public virtual string EncodeData(ReadOnlySpan`1<byte> data, Bech32EncodingType encodingType);
    public static Bech32Encoder ExtractEncoderFromString(string test);
    protected virtual void CheckCase(string hrp);
    public Byte[] DecodeDataRaw(string encoded, Bech32EncodingType& encodingType);
    [CompilerGeneratedAttribute]
public bool get_StrictLength();
    [CompilerGeneratedAttribute]
public void set_StrictLength(bool value);
    protected virtual Byte[] DecodeDataCore(string encoded, Bech32EncodingType& encodingType);
    protected virtual Byte[] ConvertBits(IEnumerable`1<byte> data, int fromBits, int toBits, bool pad);
    protected virtual Byte[] ConvertBits(ReadOnlySpan`1<byte> data, int fromBits, int toBits, bool pad);
    public virtual Byte[] Decode(string addr, Byte& witnessVerion);
    public string EncodeRaw(Byte[] data, Bech32EncodingType encodingType);
    public string EncodeRaw(ReadOnlySpan`1<byte> data, Bech32EncodingType encodingType);
    public string Encode(byte witnessVerion, Byte[] witnessProgramm);
    public string Encode(byte witnessVerion, ReadOnlySpan`1<byte> witnessProgramm);
}
public class NBitcoin.DataEncoders.Bech32EncodingType : object {
    public static Bech32EncodingType BECH32;
    public static Bech32EncodingType BECH32M;
    public static Bech32EncodingType[] All;
    [CompilerGeneratedAttribute]
private int <EncodingConstant>k__BackingField;
    public int EncodingConstant { get; }
    private static Bech32EncodingType();
    public Bech32EncodingType(int encodingConstant);
    [CompilerGeneratedAttribute]
public int get_EncodingConstant();
}
public class NBitcoin.DataEncoders.Bech32FormatException : FormatException {
    [CompilerGeneratedAttribute]
private Int32[] <ErrorIndexes>k__BackingField;
    public Int32[] ErrorIndexes { get; internal set; }
    public Bech32FormatException(string message, Int32[] indexes);
    [CompilerGeneratedAttribute]
public Int32[] get_ErrorIndexes();
    [CompilerGeneratedAttribute]
internal void set_ErrorIndexes(Int32[] value);
}
public abstract class NBitcoin.DataEncoders.DataEncoder : object {
    public static bool IsSpace(char c);
    public string EncodeData(Byte[] data);
    public abstract virtual string EncodeData(Byte[] data, int offset, int count);
    public virtual string EncodeData(ReadOnlySpan`1<byte> data);
    public abstract virtual Byte[] DecodeData(string encoded);
}
public static class NBitcoin.DataEncoders.Encoders : object {
    private static ASCIIEncoder _ASCII;
    private static HexEncoder _Hex;
    private static Base58Encoder _Base58;
    private static Base32Encoder _Base32;
    private static Base58CheckEncoder _Base58Check;
    private static Base64Encoder _Base64;
    public static DataEncoder ASCII { get; }
    public static DataEncoder Hex { get; }
    public static DataEncoder Base58 { get; }
    public static DataEncoder Base32 { get; }
    public static DataEncoder Base58Check { get; }
    public static DataEncoder Base64 { get; }
    private static Encoders();
    public static DataEncoder get_ASCII();
    public static DataEncoder get_Hex();
    public static DataEncoder get_Base58();
    public static DataEncoder get_Base32();
    public static DataEncoder get_Base58Check();
    public static DataEncoder get_Base64();
    public static Bech32Encoder Bech32(string hrp);
    public static Bech32Encoder Bech32(Byte[] hrp);
}
public class NBitcoin.DataEncoders.HexEncoder : DataEncoder {
    public static ReadOnlySpan`1<byte> CharToHexLookup { get; }
    public static ReadOnlySpan`1<byte> get_CharToHexLookup();
    public virtual string EncodeData(Byte[] data, int offset, int count);
    private void CreateHexString(Span`1<char> s, ValueTuple`3<int, int, Byte[]> state);
    public static void ToCharsBuffer(byte value, Span`1<char> buffer, int startingIndex);
    public virtual Byte[] DecodeData(string encoded);
    public void DecodeData(string encoded, Span`1<byte> output);
    public bool IsValid(string str);
    public static int IsDigit(char c);
    private static byte IsDigitCore(char c);
    public static bool IsWellFormed(string str);
}
public class NBitcoin.DecryptionResult : object {
    [CompilerGeneratedAttribute]
private Key <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private LotSequence <LotSequence>k__BackingField;
    public Key Key { get; public set; }
    public LotSequence LotSequence { get; public set; }
    [CompilerGeneratedAttribute]
public Key get_Key();
    [CompilerGeneratedAttribute]
public void set_Key(Key value);
    [CompilerGeneratedAttribute]
public LotSequence get_LotSequence();
    [CompilerGeneratedAttribute]
public void set_LotSequence(LotSequence value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NBitcoin.DefaultCoinSelector : object {
    [NullableAttribute("2")]
private Random _Rand;
    [CompilerGeneratedAttribute]
private bool <GroupByScriptPubKey>k__BackingField;
    [CompilerGeneratedAttribute]
private IMoney <MinimumChange>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Iterations>k__BackingField;
    public bool GroupByScriptPubKey { get; public set; }
    public IMoney MinimumChange { get; public set; }
    public int Iterations { get; public set; }
    public DefaultCoinSelector(int seed);
    [NullableContextAttribute("2")]
public DefaultCoinSelector(Random random);
    [CompilerGeneratedAttribute]
public bool get_GroupByScriptPubKey();
    [CompilerGeneratedAttribute]
public void set_GroupByScriptPubKey(bool value);
    [CompilerGeneratedAttribute]
public IMoney get_MinimumChange();
    [CompilerGeneratedAttribute]
public void set_MinimumChange(IMoney value);
    public sealed virtual IEnumerable`1<ICoin> Select(IEnumerable`1<ICoin> coins, IMoney target);
    [CompilerGeneratedAttribute]
public int get_Iterations();
    [CompilerGeneratedAttribute]
public void set_Iterations(int value);
    private void ApproximateBestSubset(List`1<OutputGroup> groups, IMoney nTotalLower, IMoney nTargetValue, Boolean[]& vfBest, IMoney& nBest);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NBitcoin.DNSSeedData : object {
    private string name;
    private string host;
    public string Name { get; }
    public string Host { get; }
    public DNSSeedData(string name, string host);
    public string get_Name();
    public string get_Host();
    public Task`1<IPEndPoint[]> GetAddressNodesAsync(int port);
    public Task`1<IPEndPoint[]> GetAddressNodesAsync(int port, IDnsResolver dnsResolver, CancellationToken cancellationToken);
    public virtual string ToString();
}
public class NBitcoin.EncryptedKeyResult : object {
    private BitcoinEncryptedSecretEC _EncryptedKey;
    private Func`1<BitcoinConfirmationCode> _CalculateConfirmation;
    private BitcoinConfirmationCode _ConfirmationCode;
    private BitcoinAddress _GeneratedAddress;
    private Byte[] _Seed;
    public BitcoinEncryptedSecretEC EncryptedKey { get; }
    public BitcoinConfirmationCode ConfirmationCode { get; }
    public BitcoinAddress GeneratedAddress { get; }
    public Byte[] Seed { get; }
    public EncryptedKeyResult(BitcoinEncryptedSecretEC key, BitcoinAddress address, Byte[] seed, Func`1<BitcoinConfirmationCode> calculateConfirmation);
    public BitcoinEncryptedSecretEC get_EncryptedKey();
    public BitcoinConfirmationCode get_ConfirmationCode();
    public BitcoinAddress get_GeneratedAddress();
    public Byte[] get_Seed();
}
[ExtensionAttribute]
internal static class NBitcoin.EnumerableExtensions : object {
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static TSource MinBy(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, IComparer`1<TKey> comparer);
}
public class NBitcoin.ExecutionData : object {
    [CompilerGeneratedAttribute]
private uint256 <AnnexHash>k__BackingField;
    [CompilerGeneratedAttribute]
private uint256 <TapleafHash>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <CodeseparatorPosition>k__BackingField;
    [CompilerGeneratedAttribute]
private long <ValidationWeightLeft>k__BackingField;
    public uint256 AnnexHash { get; public set; }
    public uint256 TapleafHash { get; internal set; }
    public UInt32 CodeseparatorPosition { get; public set; }
    public long ValidationWeightLeft { get; public set; }
    [CompilerGeneratedAttribute]
public uint256 get_AnnexHash();
    [CompilerGeneratedAttribute]
public void set_AnnexHash(uint256 value);
    [CompilerGeneratedAttribute]
public uint256 get_TapleafHash();
    [CompilerGeneratedAttribute]
internal void set_TapleafHash(uint256 value);
    [CompilerGeneratedAttribute]
public UInt32 get_CodeseparatorPosition();
    [CompilerGeneratedAttribute]
public void set_CodeseparatorPosition(UInt32 value);
    [CompilerGeneratedAttribute]
public long get_ValidationWeightLeft();
    [CompilerGeneratedAttribute]
public void set_ValidationWeightLeft(long value);
}
[ExtensionAttribute]
public static class NBitcoin.Extensions : object {
    [ExtensionAttribute]
internal static ECDSASignature Sign(ECPrivKey key, uint256 h, bool enforceLowR);
    [ExtensionAttribute]
internal static SecpECDSASignature Sign(ECPrivKey key, uint256 h, bool enforceLowR, Int32& recid);
    [ExtensionAttribute]
public static IHDKey AsHDKeyCache(IHDKey hdkey);
    [ExtensionAttribute]
public static IHDScriptPubKey AsHDKeyCache(IHDScriptPubKey hdScriptPubKey);
    [ExtensionAttribute]
public static IHDScriptPubKey AsHDScriptPubKey(IHDKey hdKey, ScriptPubKeyType type);
    [ExtensionAttribute]
public static IHDKey Derive(IHDKey hdkey, UInt32 index);
    [ExtensionAttribute]
public static IHDKey[] Derive(IHDKey hdkey, KeyPath[] keyPaths);
    [AsyncStateMachineAttribute("NBitcoin.Extensions/<WithCancellation>d__7")]
[ExtensionAttribute]
public static Task WithCancellation(Task task, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NBitcoin.Extensions/<WithCancellation>d__8`1")]
[ExtensionAttribute]
public static Task`1<T> WithCancellation(Task`1<T> task, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Block GetBlock(IBlockRepository repository, uint256 blockId);
    [ExtensionAttribute]
public static T ToNetwork(T obj, ChainName chainName);
    [ExtensionAttribute]
public static T ToNetwork(T obj, Network network);
    [ExtensionAttribute]
public static Byte[] ReadBytes(Stream stream, int bytesToRead);
    [ExtensionAttribute]
public static int ReadBytes(Stream stream, int bytesToRead, Byte[] buffer);
    [AsyncStateMachineAttribute("NBitcoin.Extensions/<ReadBytesAsync>d__14")]
[ExtensionAttribute]
public static Task`1<Byte[]> ReadBytesAsync(Stream stream, int bytesToRead);
    [ExtensionAttribute]
public static int ReadBytes(Stream stream, int count, Byte[]& result);
    [ExtensionAttribute]
public static IEnumerable`1<T> Resize(List`1<T> list, int count);
    [ExtensionAttribute]
public static IEnumerable`1<List`1<T>> Partition(IEnumerable`1<T> source, int max);
    [IteratorStateMachineAttribute("NBitcoin.Extensions/<Partition>d__18`1")]
[ExtensionAttribute]
public static IEnumerable`1<List`1<T>> Partition(IEnumerable`1<T> source, Func`1<int> max);
    [ExtensionAttribute]
public static int ReadEx(Stream stream, Byte[] buffer, int offset, int count, CancellationToken cancellation);
    [ExtensionAttribute]
public static int ReadEx(Stream stream, Span`1<byte> buffer, CancellationToken cancellation);
    [ExtensionAttribute]
public static void AddOrReplace(IDictionary`2<TKey, TValue> dico, TKey key, TValue value);
    [ExtensionAttribute]
public static TValue TryGet(IDictionary`2<TKey, TValue> dictionary, TKey key);
    [ExtensionAttribute]
public static bool TryAdd(IDictionary`2<TKey, TValue> dictionary, TKey key, TValue value);
    [ExtensionAttribute]
public static int ToUnixTimestamp(DateTime value);
    [ExtensionAttribute]
public static int UnixTimestamp(DateTime ignored);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NBitcoin.ExtKey : object {
    private static int ChainCodeLength;
    private Key key;
    private Byte[] vchChainCode;
    private UInt32 nChild;
    private byte nDepth;
    private HDFingerprint parentFingerprint;
    private static Byte[] hashkey;
    public static int Length;
    private Nullable`1<int> hashcode;
    public byte Depth { get; }
    public UInt32 Child { get; }
    public Byte[] ChainCode { get; }
    public Key PrivateKey { get; }
    public HDFingerprint ParentFingerprint { get; }
    public Script ScriptPubKey { get; }
    public bool IsHardened { get; }
    public ExtKey(BitcoinExtPubKey extPubKey, BitcoinSecret key);
    public ExtKey(ExtPubKey extPubKey, Key privateKey);
    public ExtKey(Key key, Byte[] chainCode, byte depth, HDFingerprint fingerprint, UInt32 child);
    public ExtKey(Key masterKey, Byte[] chainCode);
    public ExtKey(string seedHex);
    private ExtKey(Byte[] bytes, bool isSeed);
    [NullableContextAttribute("0")]
private ExtKey(ReadOnlySpan`1<byte> bytes, bool isSeed);
    private static ExtKey();
    public static ExtKey Parse(string wif, Network expectedNetwork);
    public byte get_Depth();
    public UInt32 get_Child();
    public Byte[] get_ChainCode();
    public ExtKey Derive(RootedKeyPath rootedKeyPath);
    public static ExtKey CreateFromSeed(Byte[] seed);
    public static ExtKey CreateFromBytes(Byte[] bytes);
    [NullableContextAttribute("0")]
public static ExtKey CreateFromSeed(ReadOnlySpan`1<byte> seed);
    [NullableContextAttribute("0")]
public static ExtKey CreateFromBytes(ReadOnlySpan`1<byte> bytes);
    private static Key CalculateKey(ReadOnlySpan`1<byte> seed, Byte[]& chainCode);
    public sealed virtual Key get_PrivateKey();
    public ExtPubKey Neuter();
    public bool IsChildOf(ExtKey parentKey);
    public bool IsParentOf(ExtKey childKey);
    public HDFingerprint get_ParentFingerprint();
    public ExtKey Derive(UInt32 index);
    public ExtKey Derive(int index, bool hardened);
    public ExtKey Derive(KeyPath keyPath);
    public BitcoinExtKey GetWif(Network network);
    public Byte[] ToBytes();
    public string ToString(Network network);
    public sealed virtual Script get_ScriptPubKey();
    public bool get_IsHardened();
    public ExtKey GetParentExtKey(ExtPubKey parent);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(ExtKey other);
    private sealed virtual override IHDKey NBitcoin.IHDKey.Derive(KeyPath keyPath);
    public sealed virtual PubKey GetPublicKey();
    private sealed virtual override bool NBitcoin.IHDKey.CanDeriveHardenedPath();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
public static bool op_Equality(ExtKey a, ExtKey b);
    [NullableContextAttribute("2")]
public static bool op_Inequality(ExtKey a, ExtKey b);
    public virtual int GetHashCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NBitcoin.ExtPubKey : object {
    private static int ChainCodeLength;
    internal byte nDepth;
    internal HDFingerprint parentFingerprint;
    internal UInt32 nChild;
    internal PubKey pubkey;
    internal Byte[] vchChainCode;
    public static int Length;
    private int hashcode;
    public byte Depth { get; }
    public UInt32 Child { get; }
    public bool IsHardened { get; }
    public PubKey PubKey { get; }
    public Byte[] ChainCode { get; }
    public HDFingerprint ParentFingerprint { get; }
    public Script ScriptPubKey { get; }
    public ExtPubKey(Byte[] bytes);
    public ExtPubKey(Byte[] bytes, int offset, int length);
    [NullableContextAttribute("0")]
public ExtPubKey(ReadOnlySpan`1<byte> bytes);
    public ExtPubKey(string hex);
    public ExtPubKey(PubKey pubkey, Byte[] chainCode, byte depth, HDFingerprint fingerprint, UInt32 child);
    public ExtPubKey(PubKey masterKey, Byte[] chainCode);
    public static ExtPubKey Parse(string wif, Network expectedNetwork);
    public byte get_Depth();
    public UInt32 get_Child();
    public bool get_IsHardened();
    public PubKey get_PubKey();
    public Byte[] get_ChainCode();
    public bool IsChildOf(ExtPubKey parentKey);
    public bool IsParentOf(ExtPubKey childKey);
    public HDFingerprint get_ParentFingerprint();
    public ExtPubKey Derive(UInt32 index);
    public ExtPubKey Derive(KeyPath derivation);
    public ExtPubKey Derive(int index, bool hardened);
    public BitcoinExtPubKey GetWif(Network network);
    public Byte[] ToBytes();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
public static bool op_Equality(ExtPubKey a, ExtPubKey b);
    [NullableContextAttribute("2")]
public static bool op_Inequality(ExtPubKey a, ExtPubKey b);
    public virtual int GetHashCode();
    public string ToString(Network network);
    private sealed virtual override IHDKey NBitcoin.IHDKey.Derive(KeyPath keyPath);
    public sealed virtual PubKey GetPublicKey();
    private sealed virtual override bool NBitcoin.IHDKey.CanDeriveHardenedPath();
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(ExtPubKey other);
    public sealed virtual Script get_ScriptPubKey();
}
public class NBitcoin.FeeRate : object {
    private Money _FeePerK;
    private static FeeRate _Zero;
    public Money FeePerK { get; }
    public decimal SatoshiPerByte { get; }
    public static FeeRate Zero { get; }
    public FeeRate(Money feePerK);
    public FeeRate(Money feePaid, int size);
    public FeeRate(decimal satoshiPerByte);
    private static FeeRate();
    public Money get_FeePerK();
    public decimal get_SatoshiPerByte();
    public static FeeRate get_Zero();
    public Money GetFee(int virtualSize);
    public Money GetFee(Transaction tx);
    public virtual bool Equals(object obj);
    public virtual string ToString();
    public sealed virtual bool Equals(FeeRate other);
    public sealed virtual int CompareTo(FeeRate other);
    public int CompareTo(object obj);
    public static bool op_LessThan(FeeRate left, FeeRate right);
    public static bool op_GreaterThan(FeeRate left, FeeRate right);
    public static bool op_LessThanOrEqual(FeeRate left, FeeRate right);
    public static bool op_GreaterThanOrEqual(FeeRate left, FeeRate right);
    public static bool op_Equality(FeeRate left, FeeRate right);
    public static bool op_Inequality(FeeRate left, FeeRate right);
    public virtual int GetHashCode();
    public static FeeRate Min(FeeRate left, FeeRate right);
    public static FeeRate Max(FeeRate left, FeeRate right);
}
public class NBitcoin.FeeRateGroup : object {
    [CompilerGeneratedAttribute]
private int <Group>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <Sizes>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <Count>k__BackingField;
    [CompilerGeneratedAttribute]
private Money <Fees>k__BackingField;
    [CompilerGeneratedAttribute]
private FeeRate <From>k__BackingField;
    [CompilerGeneratedAttribute]
private FeeRate <To>k__BackingField;
    public int Group { get; public set; }
    public ulong Sizes { get; public set; }
    public UInt32 Count { get; public set; }
    public Money Fees { get; public set; }
    public FeeRate From { get; public set; }
    public FeeRate To { get; public set; }
    [CompilerGeneratedAttribute]
public int get_Group();
    [CompilerGeneratedAttribute]
public void set_Group(int value);
    [CompilerGeneratedAttribute]
public ulong get_Sizes();
    [CompilerGeneratedAttribute]
public void set_Sizes(ulong value);
    [CompilerGeneratedAttribute]
public UInt32 get_Count();
    [CompilerGeneratedAttribute]
public void set_Count(UInt32 value);
    [CompilerGeneratedAttribute]
public Money get_Fees();
    [CompilerGeneratedAttribute]
public void set_Fees(Money value);
    [CompilerGeneratedAttribute]
public FeeRate get_From();
    [CompilerGeneratedAttribute]
public void set_From(FeeRate value);
    [CompilerGeneratedAttribute]
public FeeRate get_To();
    [CompilerGeneratedAttribute]
public void set_To(FeeRate value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NBitcoin.FlatSigningRepository : object {
    [CompilerGeneratedAttribute]
private ConcurrentDictionary`2<KeyId, ISecret> <Secrets>k__BackingField;
    [CompilerGeneratedAttribute]
private ConcurrentDictionary`2<KeyId, PubKey> <Pubkeys>k__BackingField;
    [CompilerGeneratedAttribute]
private ConcurrentDictionary`2<KeyId, RootedKeyPath> <KeyIdToKeyOrigins>k__BackingField;
    [CompilerGeneratedAttribute]
private ConcurrentDictionary`2<ScriptId, Script> <Scripts>k__BackingField;
    [CompilerGeneratedAttribute]
private ConcurrentDictionary`2<TaprootPubKey, TaprootSpendInfo> <SpendInfos>k__BackingField;
    [CompilerGeneratedAttribute]
private ConcurrentDictionary`2<TaprootPubKey, RootedKeyPath> <TaprootKeyOrigins>k__BackingField;
    [CompilerGeneratedAttribute]
private ConcurrentDictionary`2<TaprootPubKey, ISecret> <TaprootKeysToSecret>k__BackingField;
    public ConcurrentDictionary`2<KeyId, ISecret> Secrets { get; }
    public ConcurrentDictionary`2<KeyId, PubKey> Pubkeys { get; }
    public ConcurrentDictionary`2<KeyId, RootedKeyPath> KeyIdToKeyOrigins { get; }
    public ConcurrentDictionary`2<ScriptId, Script> Scripts { get; }
    public ConcurrentDictionary`2<TaprootPubKey, TaprootSpendInfo> SpendInfos { get; }
    public ConcurrentDictionary`2<TaprootPubKey, RootedKeyPath> TaprootKeyOrigins { get; }
    public ConcurrentDictionary`2<TaprootPubKey, ISecret> TaprootKeysToSecret { get; }
    public RootedKeyPath[] KeyOrigins { get; }
    [CompilerGeneratedAttribute]
public ConcurrentDictionary`2<KeyId, ISecret> get_Secrets();
    [CompilerGeneratedAttribute]
public ConcurrentDictionary`2<KeyId, PubKey> get_Pubkeys();
    [CompilerGeneratedAttribute]
public ConcurrentDictionary`2<KeyId, RootedKeyPath> get_KeyIdToKeyOrigins();
    [CompilerGeneratedAttribute]
public ConcurrentDictionary`2<ScriptId, Script> get_Scripts();
    [CompilerGeneratedAttribute]
public ConcurrentDictionary`2<TaprootPubKey, TaprootSpendInfo> get_SpendInfos();
    [CompilerGeneratedAttribute]
public ConcurrentDictionary`2<TaprootPubKey, RootedKeyPath> get_TaprootKeyOrigins();
    [CompilerGeneratedAttribute]
public ConcurrentDictionary`2<TaprootPubKey, ISecret> get_TaprootKeysToSecret();
    public RootedKeyPath[] get_KeyOrigins();
    public sealed virtual bool TryGetScript(ScriptId scriptId, Script& script);
    public sealed virtual bool TryGetPubKey(KeyId keyId, PubKey& pubkey);
    public sealed virtual bool TryGetKeyOrigin(KeyId keyId, RootedKeyPath& keyOrigin);
    public sealed virtual bool TryGetSecret(KeyId keyId, ISecret& key);
    public sealed virtual void SetScript(ScriptId scriptId, Script script);
    public sealed virtual void SetPubKey(KeyId keyId, PubKey pubkey);
    public sealed virtual void SetSecret(KeyId keyId, ISecret secret);
    public sealed virtual void SetKeyOrigin(KeyId keyId, RootedKeyPath keyOrigin);
    public sealed virtual bool TryGetKeyOrigin(TaprootPubKey taprootPubKey, RootedKeyPath& keyorigin);
    public sealed virtual bool TryGetTaprootSpendInfo(TaprootPubKey taprootOutput, TaprootSpendInfo& spendInfo);
    public sealed virtual bool TryGetSecret(TaprootPubKey key, ISecret& secret);
    public sealed virtual void SetTaprootSpendInfo(TaprootPubKey key, TaprootSpendInfo value);
    public sealed virtual void SetSecret(TaprootPubKey key, BitcoinSecret secret);
    public sealed virtual void SetKeyOrigin(TaprootPubKey taprootPubKey, RootedKeyPath keyOrigin);
    public sealed virtual void Merge(ISigningRepository other);
    private void MergeDict(ConcurrentDictionary`2<U, T> a, ConcurrentDictionary`2<U, T> b);
}
public class NBitcoin.GolombRiceFilter : object {
    internal static byte DefaultP;
    internal static UInt32 DefaultM;
    [CompilerGeneratedAttribute]
private byte <P>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <M>k__BackingField;
    [CompilerGeneratedAttribute]
private int <N>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <Data>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <ModulusP>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <ModulusNP>k__BackingField;
    [CompilerGeneratedAttribute]
private static GolombRiceFilter <Empty>k__BackingField;
    public byte P { get; }
    public UInt32 M { get; }
    public int N { get; }
    public Byte[] Data { get; }
    private ulong ModulusP { get; }
    private ulong ModulusNP { get; }
    public static GolombRiceFilter Empty { get; }
    public GolombRiceFilter(Byte[] data);
    public GolombRiceFilter(Byte[] data, byte p, UInt32 m);
    internal GolombRiceFilter(Byte[] data, int n, byte p, UInt32 m);
    private static GolombRiceFilter();
    [CompilerGeneratedAttribute]
public byte get_P();
    [CompilerGeneratedAttribute]
public UInt32 get_M();
    [CompilerGeneratedAttribute]
public int get_N();
    [CompilerGeneratedAttribute]
public Byte[] get_Data();
    [CompilerGeneratedAttribute]
private ulong get_ModulusP();
    [CompilerGeneratedAttribute]
private ulong get_ModulusNP();
    [CompilerGeneratedAttribute]
public static GolombRiceFilter get_Empty();
    public static GolombRiceFilter Parse(string str);
    internal static UInt64[] ConstructHashedSet(byte P, int n, UInt32 m, Byte[] key, IEnumerable`1<Byte[]> data, int dataCount);
    public uint256 GetHeader(uint256 previousHeader);
    public bool Match(Byte[] data, Byte[] key);
    public bool Match(Byte[] data, Byte[] key, GRCodedStreamReader reader);
    public bool MatchAny(Byte[][] data, Byte[] key);
    public bool MatchAny(IEnumerable`1<Byte[]> data, Byte[] key);
    public bool MatchAny(IEnumerable`1<Byte[]> data, Byte[] key, GRCodedStreamReader reader);
    internal bool MatchAny(IEnumerable`1<Byte[]> data, int dataCount, Byte[] key, GRCodedStreamReader reader);
    private bool InternalMatchAny(IEnumerable`1<Byte[]> data, int dataCount, Byte[] key, GRCodedStreamReader sr);
    public Byte[] ToBytes();
    public virtual string ToString();
    public CachedGRCodedStreamReader GetNewGRStreamReader();
    internal static ulong FastReduction(ulong value, ulong nhi, ulong nlo);
    private static ulong SipHash(ulong k0, ulong k1, Byte[] data);
}
public class NBitcoin.GolombRiceFilterBuilder : object {
    private byte _p;
    private UInt32 _m;
    private Byte[] _key;
    private HashSet`1<Byte[]> _values;
    private static Byte[] EmptyBytes;
    private static GolombRiceFilterBuilder();
    public static GolombRiceFilter BuildBasicFilter(Block block);
    public GolombRiceFilterBuilder SetKey(uint256 blockHash);
    public GolombRiceFilterBuilder SetP(int p);
    public GolombRiceFilterBuilder SetM(UInt32 m);
    public GolombRiceFilterBuilder AddTxId(uint256 id);
    public GolombRiceFilterBuilder AddScriptPubkey(Script scriptPubkey);
    public GolombRiceFilterBuilder AddScriptSig(Script scriptSig);
    public void AddWitness(WitScript witScript);
    public GolombRiceFilterBuilder AddOutPoint(OutPoint outpoint);
    public GolombRiceFilterBuilder AddEntries(IEnumerable`1<Byte[]> entries);
    public GolombRiceFilter Build();
    private static Byte[] Compress(UInt64[] values, byte P);
}
public class NBitcoin.GRCodedStreamReader : object {
    private BitStream _stream;
    private byte _p;
    private ulong _modP;
    private ulong _lastValue;
    internal GRCodedStreamReader(BitStream stream, byte p, ulong lastValue);
    public virtual bool TryRead(UInt64& value);
    internal virtual void ResetPosition();
    private bool TryReadUInt64(UInt64& value);
}
internal class NBitcoin.GRCodedStreamWriter : object {
    private BitStream _stream;
    private byte _p;
    private ulong _modP;
    private ulong _lastValue;
    public GRCodedStreamWriter(BitStream stream, byte p);
    public void Write(ulong value);
}
public class NBitcoin.HardcodedWordlistSource : object {
    private static Dictionary`2<string, string> _WordLists;
    private static HardcodedWordlistSource();
    public sealed virtual Task`1<Wordlist> Load(string name);
}
public enum NBitcoin.HashVersion : Enum {
    public int value__;
    public static HashVersion Original;
    public static HashVersion WitnessV0;
    public static HashVersion Taproot;
    public static HashVersion Tapscript;
}
[IsReadOnlyAttribute]
public class NBitcoin.HDFingerprint : ValueType {
    private UInt32 _Value;
    public HDFingerprint(Byte[] bytes);
    public HDFingerprint(ReadOnlySpan`1<byte> bytes);
    public HDFingerprint(Byte[] bytes, int index);
    public HDFingerprint(UInt32 value);
    public static bool TryParse(string str, HDFingerprint& result);
    public static HDFingerprint Parse(string str);
    public static HDFingerprint FromKeyId(KeyId id);
    public Byte[] ToBytes();
    public void ToBytes(Span`1<byte> output);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(HDFingerprint x, HDFingerprint y);
    public static bool op_Inequality(HDFingerprint x, HDFingerprint y);
    public virtual string ToString();
}
internal class NBitcoin.HDKeyCache : object {
    private IHDKey hdKey;
    private KeyPath _PathFromRoot;
    private ConcurrentDictionary`2<KeyPath, IHDKey> derivationCache;
    public IHDKey Inner { get; }
    internal int Cached { get; }
    internal HDKeyCache(IHDKey masterKey);
    private HDKeyCache(IHDKey hdKey, KeyPath childPath, ConcurrentDictionary`2<KeyPath, IHDKey> cache);
    public IHDKey get_Inner();
    public sealed virtual IHDKey Derive(KeyPath keyPath);
    internal int get_Cached();
    public sealed virtual PubKey GetPublicKey();
    public sealed virtual bool CanDeriveHardenedPath();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NBitcoin.HDKeyScriptPubKey : object {
    private IHDKey hdKey;
    private ScriptPubKeyType type;
    [NullableAttribute("2")]
private Script _ScriptPubKey;
    public IHDKey HDKey { get; }
    public Script ScriptPubKey { get; }
    public HDKeyScriptPubKey(IHDKey hdKey, ScriptPubKeyType type);
    public IHDKey get_HDKey();
    public sealed virtual Script get_ScriptPubKey();
    public sealed virtual IHDScriptPubKey Derive(KeyPath keyPath);
    public sealed virtual bool CanDeriveHardenedPath();
}
internal class NBitcoin.HDScriptPubKeyCache : object {
    private IHDScriptPubKey hdKey;
    private KeyPath _PathFromRoot;
    private ConcurrentDictionary`2<KeyPath, IHDScriptPubKey> derivationCache;
    public IHDScriptPubKey Inner { get; }
    internal int Cached { get; }
    public Script ScriptPubKey { get; }
    internal HDScriptPubKeyCache(IHDScriptPubKey masterKey);
    private HDScriptPubKeyCache(IHDScriptPubKey hdKey, KeyPath childPath, ConcurrentDictionary`2<KeyPath, IHDScriptPubKey> cache);
    public IHDScriptPubKey get_Inner();
    public sealed virtual IHDScriptPubKey Derive(KeyPath keyPath);
    internal int get_Cached();
    public sealed virtual Script get_ScriptPubKey();
    public sealed virtual bool CanDeriveHardenedPath();
}
public interface NBitcoin.IAddressableDestination {
    public abstract virtual bool IsSupported(Network network);
    public abstract virtual BitcoinAddress GetAddress(Network network);
}
public interface NBitcoin.IBase58Data {
    public Base58Type Type { get; }
    public abstract virtual Base58Type get_Type();
}
public interface NBitcoin.IBech32Data {
    public Bech32Type Type { get; }
    public abstract virtual Bech32Type get_Type();
}
public interface NBitcoin.IBitcoinSerializable {
    public abstract virtual void ReadWrite(BitcoinStream stream);
}
public interface NBitcoin.IBitcoinString {
    public Network Network { get; }
    public abstract virtual Network get_Network();
}
public interface NBitcoin.IBlockRepository {
    public abstract virtual Task`1<Block> GetBlockAsync(uint256 blockId, CancellationToken cancellationToken);
}
public interface NBitcoin.ICoin {
    public IMoney Amount { get; }
    public bool CanGetScriptCode { get; }
    public bool IsMalleable { get; }
    public abstract virtual IMoney get_Amount();
    public abstract virtual Script GetScriptCode();
    public abstract virtual void OverrideScriptCode(Script scriptCode);
    public abstract virtual bool get_CanGetScriptCode();
    public abstract virtual HashVersion GetHashVersion();
    public abstract virtual bool get_IsMalleable();
}
public interface NBitcoin.ICoinable {
    public OutPoint Outpoint { get; }
    public TxOut TxOut { get; }
    public abstract virtual OutPoint get_Outpoint();
    public abstract virtual TxOut get_TxOut();
}
[NullableContextAttribute("1")]
public interface NBitcoin.ICoinSelector {
    public abstract virtual IEnumerable`1<ICoin> Select(IEnumerable`1<ICoin> coins, IMoney target);
}
public interface NBitcoin.IColoredCoin {
    public AssetId AssetId { get; }
    public Coin Bearer { get; }
    public abstract virtual AssetId get_AssetId();
    public abstract virtual Coin get_Bearer();
}
public interface NBitcoin.IDestination {
    public Script ScriptPubKey { get; }
    public abstract virtual Script get_ScriptPubKey();
}
public interface NBitcoin.IHasForkId {
    public UInt32 ForkId { get; }
    public abstract virtual UInt32 get_ForkId();
}
public interface NBitcoin.IHDKey {
    public abstract virtual IHDKey Derive(KeyPath keyPath);
    public abstract virtual PubKey GetPublicKey();
    public abstract virtual bool CanDeriveHardenedPath();
}
public interface NBitcoin.IHDScriptPubKey {
    public Script ScriptPubKey { get; }
    public abstract virtual IHDScriptPubKey Derive(KeyPath keyPath);
    public abstract virtual bool CanDeriveHardenedPath();
    public abstract virtual Script get_ScriptPubKey();
}
public interface NBitcoin.IMoney {
    public abstract virtual IMoney Add(IMoney money);
    public abstract virtual IMoney Sub(IMoney money);
    public abstract virtual IMoney Negate();
    public abstract virtual bool IsCompatible(IMoney money);
    public abstract virtual IEnumerable`1<IMoney> Split(int parts);
}
public class NBitcoin.IndexedTxIn : object {
    [CompilerGeneratedAttribute]
private TxIn <TxIn>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <Index>k__BackingField;
    [CompilerGeneratedAttribute]
private Transaction <Transaction>k__BackingField;
    public TxIn TxIn { get; public set; }
    public UInt32 Index { get; public set; }
    public OutPoint PrevOut { get; public set; }
    public Script ScriptSig { get; public set; }
    public WitScript WitScript { get; public set; }
    public Transaction Transaction { get; public set; }
    [CompilerGeneratedAttribute]
public TxIn get_TxIn();
    [CompilerGeneratedAttribute]
public void set_TxIn(TxIn value);
    [CompilerGeneratedAttribute]
public UInt32 get_Index();
    [CompilerGeneratedAttribute]
public void set_Index(UInt32 value);
    public OutPoint get_PrevOut();
    public void set_PrevOut(OutPoint value);
    public Script get_ScriptSig();
    public void set_ScriptSig(Script value);
    public WitScript get_WitScript();
    public void set_WitScript(WitScript value);
    [CompilerGeneratedAttribute]
public Transaction get_Transaction();
    [CompilerGeneratedAttribute]
public void set_Transaction(Transaction value);
    [NullableContextAttribute("1")]
public bool VerifyScript(TxOut spentOutput, ScriptVerify scriptVerify);
    [NullableContextAttribute("1")]
public bool VerifyScript(TxOut spentOutput, ScriptError& error);
    [NullableContextAttribute("1")]
public bool VerifyScript(TxOut spentOutput, ScriptVerify scriptVerify, ScriptError& error);
    [NullableContextAttribute("1")]
public bool VerifyScript(ICoin spentCoin, ScriptVerify scriptVerify);
    [NullableContextAttribute("1")]
public bool VerifyScript(ICoin spentCoin, ScriptVerify scriptVerify, ScriptError& error);
    [NullableContextAttribute("1")]
public bool VerifyScript(ICoin spentCoin, ScriptVerify scriptVerify, PrecomputedTransactionData precomputedTransactionData, ScriptError& error);
    [NullableContextAttribute("1")]
public bool VerifyScript(TxOut spentOutput, ScriptVerify scriptVerify, PrecomputedTransactionData precomputedTransactionData, ScriptError& error);
    [NullableContextAttribute("1")]
public bool VerifyScript(ICoin coin, ScriptError& error);
    [NullableContextAttribute("1")]
public TaprootSignature SignTaprootKeySpend(TaprootKeyPair keyPair, ICoin coin, SigningOptions signingOptions);
    [NullableContextAttribute("1")]
public TransactionSignature Sign(Key key, ICoin coin);
    [NullableContextAttribute("1")]
public TransactionSignature Sign(Key key, ICoin coin, SigningOptions signingOptions);
    [NullableContextAttribute("1")]
public uint256 GetSignatureHash(ICoin coin, SigHash sigHash);
    [NullableContextAttribute("1")]
public uint256 GetSignatureHash(ICoin coin, SigHash sigHash, PrecomputedTransactionData transactionData);
    [NullableContextAttribute("1")]
public uint256 GetSignatureHashTaproot(ICoin coin, TaprootSigHash sigHash, PrecomputedTransactionData transactionData);
}
public class NBitcoin.IndexedTxOut : object {
    [CompilerGeneratedAttribute]
private TxOut <TxOut>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <N>k__BackingField;
    [CompilerGeneratedAttribute]
private Transaction <Transaction>k__BackingField;
    public TxOut TxOut { get; public set; }
    public UInt32 N { get; public set; }
    public Transaction Transaction { get; public set; }
    [CompilerGeneratedAttribute]
public TxOut get_TxOut();
    [CompilerGeneratedAttribute]
public void set_TxOut(TxOut value);
    [CompilerGeneratedAttribute]
public UInt32 get_N();
    [CompilerGeneratedAttribute]
public void set_N(UInt32 value);
    [CompilerGeneratedAttribute]
public Transaction get_Transaction();
    [CompilerGeneratedAttribute]
public void set_Transaction(Transaction value);
    public Coin ToCoin();
}
public interface NBitcoin.INetworkSet {
    public Network Mainnet { get; }
    public Network Testnet { get; }
    public Network Regtest { get; }
    public string CryptoCode { get; }
    public abstract virtual Network GetNetwork(ChainName chainName);
    public abstract virtual Network get_Mainnet();
    public abstract virtual Network get_Testnet();
    public abstract virtual Network get_Regtest();
    public abstract virtual string get_CryptoCode();
}
public class NBitcoin.InMemoryNoSqlRepository : NoSqlRepository {
    private Dictionary`2<string, Byte[]> _Table;
    public InMemoryNoSqlRepository(ConsensusFactory consensusFactory);
    protected virtual Task PutBytesBatch(IEnumerable`1<Tuple`2<string, Byte[]>> enumerable);
    protected virtual Task`1<Byte[]> GetBytes(string key);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NBitcoin.InputValidationResult : object {
    [CompilerGeneratedAttribute]
private int <InputIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<ScriptError> <Error>k__BackingField;
    [CompilerGeneratedAttribute]
private ExecutionData <ExecutionData>k__BackingField;
    public int InputIndex { get; }
    public Nullable`1<ScriptError> Error { get; }
    public ExecutionData ExecutionData { get; }
    internal InputValidationResult(int index, ScriptError error, ExecutionData executionData);
    internal InputValidationResult(int index, ExecutionData executionData);
    [CompilerGeneratedAttribute]
public int get_InputIndex();
    [CompilerGeneratedAttribute]
public Nullable`1<ScriptError> get_Error();
    [CompilerGeneratedAttribute]
public ExecutionData get_ExecutionData();
}
[ExtensionAttribute]
public static class NBitcoin.IpExtensions : object {
    private static Byte[] pchRFC6052;
    private static Byte[] pchRFC4862;
    private static Byte[] pchRFC6145;
    private static Byte[] pchOnionCat;
    private static Byte[] pchLocal;
    private static Byte[] ipNone;
    private static Byte[] inadddr_none;
    private static Byte[] ipNone_v4;
    private static IpExtensions();
    [ExtensionAttribute]
public static bool IsRFC1918(IPAddress address);
    [ExtensionAttribute]
public static bool IsIPv4(IPAddress address);
    [ExtensionAttribute]
public static bool IsRFC3927(IPAddress address);
    [ExtensionAttribute]
public static bool IsRFC3849(IPAddress address);
    [ExtensionAttribute]
public static bool IsRFC3964(IPAddress address);
    [ExtensionAttribute]
public static bool IsRFC6052(IPAddress address);
    [ExtensionAttribute]
public static bool IsRFC4380(IPAddress address);
    [ExtensionAttribute]
public static bool IsRFC4862(IPAddress address);
    [ExtensionAttribute]
public static bool IsRFC4193(IPAddress address);
    [ExtensionAttribute]
public static bool IsRFC6145(IPAddress address);
    [ExtensionAttribute]
public static bool IsRFC4843(IPAddress address);
    [ExtensionAttribute]
public static Byte[] GetGroup(EndPoint endpoint);
    [ExtensionAttribute]
public static Byte[] GetGroup(IPAddress address);
    [ExtensionAttribute]
public static bool IsTor(IPAddress address);
    [ExtensionAttribute]
public static bool IsTor(EndPoint endpoint);
    [ExtensionAttribute]
public static bool IsTor(DnsEndPoint dnsEndPoint);
    [ExtensionAttribute]
public static bool IsTor(IPEndPoint iPEndPoint);
    [ExtensionAttribute]
public static bool IsI2P(EndPoint endPoint);
    [ExtensionAttribute]
public static bool IsCjdns(IPAddress address);
    [ExtensionAttribute]
public static string ToEndpointString(EndPoint endpoint);
    [ExtensionAttribute]
public static string GetStringAddress(EndPoint endPoint);
    [ExtensionAttribute]
public static bool IsEqualTo(EndPoint endPoint1, EndPoint endPoint2);
    [ExtensionAttribute]
public static DnsEndPoint AsOnionDNSEndpoint(EndPoint endpoint);
    [ExtensionAttribute]
public static bool TryConvertToOnionDNSEndpoint(EndPoint endpoint, DnsEndPoint& dnsEndpoint);
    [ExtensionAttribute]
public static IPEndPoint AsOnionCatIPEndpoint(EndPoint endpoint);
    [ExtensionAttribute]
public static Task`1<IPEndPoint[]> ResolveToIPEndpointsAsync(EndPoint endpoint);
    [AsyncStateMachineAttribute("NBitcoin.IpExtensions/<ResolveToIPEndpointsAsync>d__30")]
[ExtensionAttribute]
public static Task`1<IPEndPoint[]> ResolveToIPEndpointsAsync(EndPoint endpoint, IDnsResolver dnsResolver, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static IPAddress EnsureIPv6(IPAddress address);
    [ExtensionAttribute]
public static IPEndPoint MapToIPv6(IPEndPoint endpoint);
    [ExtensionAttribute]
public static bool IsLocal(IPAddress address);
    [ExtensionAttribute]
public static bool IsMulticast(IPAddress address);
    [ExtensionAttribute]
public static bool IsRoutable(EndPoint endpoint, bool allowLocal);
    [ExtensionAttribute]
public static bool IsRoutable(IPAddress address, bool allowLocal);
    [ExtensionAttribute]
public static bool IsValid(EndPoint endpoint);
    [ExtensionAttribute]
public static bool IsValid(IPAddress address);
}
public interface NBitcoin.IPubKey {
}
public interface NBitcoin.IRandom {
    public abstract virtual void GetBytes(Byte[] output);
    public abstract virtual void GetBytes(Span`1<byte> output);
}
public interface NBitcoin.ISecret {
    public Key PrivateKey { get; }
    public abstract virtual Key get_PrivateKey();
}
[NullableContextAttribute("1")]
public interface NBitcoin.ISigningRepository {
    public abstract virtual bool TryGetScript(ScriptId scriptId, Script& script);
    public abstract virtual bool TryGetPubKey(KeyId keyId, PubKey& pubkey);
    public abstract virtual bool TryGetKeyOrigin(KeyId keyId, RootedKeyPath& keyorigin);
    public abstract virtual bool TryGetSecret(KeyId keyId, ISecret& secret);
    public abstract virtual void SetScript(ScriptId scriptId, Script script);
    public abstract virtual void SetPubKey(KeyId keyId, PubKey pubkey);
    public abstract virtual void SetSecret(KeyId keyId, ISecret secret);
    public abstract virtual void SetKeyOrigin(KeyId keyId, RootedKeyPath keyOrigin);
    public abstract virtual bool TryGetKeyOrigin(TaprootPubKey taprootPubKey, RootedKeyPath& keyorigin);
    public abstract virtual bool TryGetTaprootSpendInfo(TaprootPubKey taprootOutput, TaprootSpendInfo& spendInfo);
    public abstract virtual bool TryGetSecret(TaprootPubKey key, ISecret& secret);
    public abstract virtual void SetTaprootSpendInfo(TaprootPubKey key, TaprootSpendInfo value);
    public abstract virtual void SetSecret(TaprootPubKey key, BitcoinSecret secret);
    public abstract virtual void SetKeyOrigin(TaprootPubKey taprootPubKey, RootedKeyPath keyOrigin);
    public abstract virtual void Merge(ISigningRepository other);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class NBitcoin.ISigningRepositoryExtensions : object {
    [ExtensionAttribute]
[ObsoleteAttribute("Use OutputDescriptor.IsSolvable")]
public static bool IsSolvable(ISigningRepository repo, Script scriptPubKey);
    [ExtensionAttribute]
public static Key GetPrivateKey(ISigningRepository repo, KeyId id);
}
public class NBitcoin.IssuanceCoin : object {
    [CompilerGeneratedAttribute]
private Uri <DefinitionUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private Coin <Bearer>k__BackingField;
    public bool IsMalleable { get; }
    public AssetId AssetId { get; }
    public Uri DefinitionUrl { get; public set; }
    public Money Amount { get; public set; }
    public TxOut TxOut { get; }
    public Script ScriptPubKey { get; }
    public Coin Bearer { get; public set; }
    public OutPoint Outpoint { get; }
    private AssetId NBitcoin.IColoredCoin.AssetId { get; }
    private Coin NBitcoin.IColoredCoin.Bearer { get; }
    private IMoney NBitcoin.ICoin.Amount { get; }
    private OutPoint NBitcoin.ICoinable.Outpoint { get; }
    private TxOut NBitcoin.ICoinable.TxOut { get; }
    public bool CanGetScriptCode { get; }
    public IssuanceCoin(Coin bearer);
    public IssuanceCoin(OutPoint outpoint, TxOut txout);
    public sealed virtual bool get_IsMalleable();
    public AssetId get_AssetId();
    [CompilerGeneratedAttribute]
public Uri get_DefinitionUrl();
    [CompilerGeneratedAttribute]
public void set_DefinitionUrl(Uri value);
    public Money get_Amount();
    public void set_Amount(Money value);
    public TxOut get_TxOut();
    public Script get_ScriptPubKey();
    [CompilerGeneratedAttribute]
public Coin get_Bearer();
    [CompilerGeneratedAttribute]
public void set_Bearer(Coin value);
    public OutPoint get_Outpoint();
    private sealed virtual override AssetId NBitcoin.IColoredCoin.get_AssetId();
    private sealed virtual override Coin NBitcoin.IColoredCoin.get_Bearer();
    private sealed virtual override IMoney NBitcoin.ICoin.get_Amount();
    private sealed virtual override OutPoint NBitcoin.ICoinable.get_Outpoint();
    private sealed virtual override TxOut NBitcoin.ICoinable.get_TxOut();
    public sealed virtual Script GetScriptCode();
    public sealed virtual bool get_CanGetScriptCode();
    public sealed virtual HashVersion GetHashVersion();
    public sealed virtual void OverrideScriptCode(Script scriptCode);
}
public interface NBitcoin.ITransactionRepository {
    public abstract virtual Task`1<Transaction> GetAsync(uint256 txId);
    public abstract virtual Task PutAsync(uint256 txId, Transaction tx);
}
public interface NBitcoin.ITransactionSignature {
    public abstract virtual Byte[] ToBytes();
}
public interface NBitcoin.IWordlistSource {
    public abstract virtual Task`1<Wordlist> Load(string name);
}
public class NBitcoin.JsonConverters.AssetIdJsonConverter : JsonConverter {
    [CompilerGeneratedAttribute]
private Network <Network>k__BackingField;
    public Network Network { get; public set; }
    public AssetIdJsonConverter(Network network);
    public virtual bool CanConvert(Type objectType);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    [CompilerGeneratedAttribute]
public Network get_Network();
    [CompilerGeneratedAttribute]
public void set_Network(Network value);
}
public class NBitcoin.JsonConverters.BitcoinSerializableJsonConverter : JsonConverter {
    [CompilerGeneratedAttribute]
private Network <Network>k__BackingField;
    public Network Network { get; public set; }
    public BitcoinSerializableJsonConverter(Network network);
    [CompilerGeneratedAttribute]
public Network get_Network();
    [CompilerGeneratedAttribute]
public void set_Network(Network value);
    public virtual bool CanConvert(Type objectType);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
}
public class NBitcoin.JsonConverters.BitcoinStringJsonConverter : JsonConverter {
    [CompilerGeneratedAttribute]
private Network <Network>k__BackingField;
    public Network Network { get; public set; }
    public BitcoinStringJsonConverter(Network network);
    public virtual bool CanConvert(Type objectType);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    [CompilerGeneratedAttribute]
public Network get_Network();
    [CompilerGeneratedAttribute]
public void set_Network(Network value);
}
public class NBitcoin.JsonConverters.ChainNameJsonConverter : JsonConverter`1<ChainName> {
    public virtual void WriteJson(JsonWriter writer, ChainName value, JsonSerializer serializer);
    public virtual ChainName ReadJson(JsonReader reader, Type objectType, ChainName existingValue, bool hasExistingValue, JsonSerializer serializer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NBitcoin.JsonConverters.CoinJsonConverter : JsonConverter {
    [CompilerGeneratedAttribute]
private Network <Network>k__BackingField;
    public Network Network { get; public set; }
    public CoinJsonConverter(Network network);
    [CompilerGeneratedAttribute]
public Network get_Network();
    [CompilerGeneratedAttribute]
public void set_Network(Network value);
    public virtual bool CanConvert(Type objectType);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
}
public class NBitcoin.JsonConverters.DateTimeToUnixTimeConverter : JsonConverter {
    public virtual bool CanConvert(Type objectType);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
}
public class NBitcoin.JsonConverters.FeeRateJsonConverter : JsonConverter {
    public virtual bool CanConvert(Type objectType);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
}
public class NBitcoin.JsonConverters.HDFingerprintJsonConverter : JsonConverter {
    public virtual bool CanConvert(Type objectType);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
}
public class NBitcoin.JsonConverters.HexJsonConverter : JsonConverter {
    public virtual bool CanConvert(Type objectType);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
}
[ExtensionAttribute]
internal static class NBitcoin.JsonConverters.JsonConverterUtils : object {
    [ExtensionAttribute]
public static void AssertJsonType(JsonReader reader, JsonToken expectedType);
    [ExtensionAttribute]
public static void AssertJsonType(JsonReader reader, JsonToken[] anyExpectedTypes);
}
public class NBitcoin.JsonConverters.JsonObjectException : Exception {
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    public string Path { get; private set; }
    public JsonObjectException(Exception inner, JsonReader reader);
    public JsonObjectException(string message, JsonReader reader);
    public JsonObjectException(Exception inner, string path);
    public JsonObjectException(string message, string path);
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
private void set_Path(string value);
}
public class NBitcoin.JsonConverters.KeyJsonConverter : JsonConverter {
    public virtual bool CanConvert(Type objectType);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    private static void InverseIfNeeded(Type type, Byte[] bytes);
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
}
public class NBitcoin.JsonConverters.KeyPathJsonConverter : JsonConverter {
    public virtual bool CanConvert(Type objectType);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
}
public class NBitcoin.JsonConverters.LockTimeJsonConverter : JsonConverter {
    public virtual bool CanConvert(Type objectType);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
}
public class NBitcoin.JsonConverters.MoneyJsonConverter : JsonConverter {
    public virtual bool CanConvert(Type objectType);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
}
public class NBitcoin.JsonConverters.NetworkJsonConverter : JsonConverter {
    public virtual bool CanConvert(Type objectType);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
}
public class NBitcoin.JsonConverters.OutpointJsonConverter : JsonConverter {
    public virtual bool CanConvert(Type objectType);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NBitcoin.JsonConverters.OutputDescriptorJsonConverter : JsonConverter {
    private bool _requireChecksum;
    [NullableAttribute("2")]
private ISigningRepository _signingRepository;
    [CompilerGeneratedAttribute]
private Network <Network>k__BackingField;
    public Network Network { get; }
    public OutputDescriptorJsonConverter(Network network, bool requireChecksum, ISigningRepository signingRepository);
    [CompilerGeneratedAttribute]
public Network get_Network();
    public virtual bool CanConvert(Type objectType);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
}
public class NBitcoin.JsonConverters.PSBTJsonConverter : JsonConverter {
    [CompilerGeneratedAttribute]
private Network <Network>k__BackingField;
    public Network Network { get; public set; }
    public PSBTJsonConverter(Network network);
    [CompilerGeneratedAttribute]
public Network get_Network();
    [CompilerGeneratedAttribute]
public void set_Network(Network value);
    public virtual bool CanConvert(Type objectType);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
}
public class NBitcoin.JsonConverters.ScriptJsonConverter : JsonConverter {
    public virtual bool CanConvert(Type objectType);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
}
public class NBitcoin.JsonConverters.SequenceJsonConverter : JsonConverter {
    public virtual bool CanConvert(Type objectType);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
}
public class NBitcoin.JsonConverters.Serializer : object {
    public static void RegisterFrontConverters(JsonSerializerSettings settings, Network network);
    public static T ToObject(string data);
    public static T ToObject(string data, Network network);
    public static string ToString(T response, Network network);
    public static string ToString(T response);
}
public class NBitcoin.JsonConverters.SignatureJsonConverter : JsonConverter {
    public virtual bool CanConvert(Type objectType);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
}
public class NBitcoin.JsonConverters.TxDestinationJsonConverter : JsonConverter {
    public virtual bool CanConvert(Type objectType);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
}
public class NBitcoin.JsonConverters.UInt160JsonConverter : JsonConverter {
    public virtual bool CanConvert(Type objectType);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
}
public class NBitcoin.JsonConverters.UInt256JsonConverter : JsonConverter {
    public virtual bool CanConvert(Type objectType);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
}
internal class NBitcoin.KDTable : object {
    private static Int32[][] _SupportedChars;
    private static string _SubstitutionTable;
    private static KDTable();
    public static string NormalizeKD(string str);
    private static void Substitute(char c, StringBuilder builder);
    private static void Substitute(int pos, StringBuilder builder);
    private static bool Supported(char c);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NBitcoin.Key : object {
    private static int KEY_SIZE;
    private static uint256 N;
    internal ECPrivKey _ECKey;
    [CompilerGeneratedAttribute]
private bool <IsCompressed>k__BackingField;
    [NullableAttribute("2")]
private PubKey _PubKey;
    private bool disposed;
    public bool IsCompressed { get; internal set; }
    public PubKey PubKey { get; }
    private Script NBitcoin.IDestination.ScriptPubKey { get; }
    internal Key(ECPrivKey ecKey, bool compressed);
    [NullableContextAttribute("0")]
internal Key(ReadOnlySpan`1<byte> bytes, bool compressed);
    public Key(bool fCompressedIn);
    public Key(Byte[] data, int count, bool fCompressedIn);
    private static Key();
    public BIP322Signature SignBIP322(BitcoinAddress address, string message, SignatureType type);
    public static Key Parse(string wif, Network expectedNetwork);
    public static Key Parse(string wif, string password, Network network);
    [CompilerGeneratedAttribute]
public bool get_IsCompressed();
    [CompilerGeneratedAttribute]
internal void set_IsCompressed(bool value);
    public BitcoinAddress GetAddress(ScriptPubKeyType scriptPubKeyType, Network network);
    public IAddressableDestination GetDestination(ScriptPubKeyType scriptPubKeyType);
    public Script GetScriptPubKey(ScriptPubKeyType scriptPubKeyType);
    private static bool Check(Byte[] vch);
    public PubKey get_PubKey();
    public ECDSASignature Sign(uint256 hash, bool useLowR);
    public ECDSASignature Sign(uint256 hash);
    public TaprootSignature SignTaprootKeySpend(uint256 hash, TaprootSigHash sigHash);
    public TaprootSignature SignTaprootKeySpend(uint256 hash, uint256 merkleRoot, TaprootSigHash sigHash);
    public TaprootSignature SignTaprootKeySpend(uint256 hash, uint256 merkleRoot, uint256 aux, TaprootSigHash sigHash);
    public TaprootKeyPair CreateTaprootKeyPair();
    public TaprootKeyPair CreateTaprootKeyPair(uint256 merkleRoot);
    public KeyPair CreateKeyPair();
    public CompactSignature SignCompact(uint256 hash);
    public CompactSignature SignCompact(uint256 hash, bool forceLowR);
    public string Decrypt(string encryptedText);
    public Byte[] Decrypt(Byte[] encrypted);
    public Key Derivate(Byte[] cc, UInt32 nChild, Byte[]& ccChild);
    public BitcoinSecret GetBitcoinSecret(Network network);
    public BitcoinSecret GetWif(Network network);
    public BitcoinEncryptedSecretNoEC GetEncryptedBitcoinSecret(string password, Network network);
    public string ToString(Network network);
    private sealed virtual override Script NBitcoin.IDestination.get_ScriptPubKey();
    public TransactionSignature Sign(uint256 hash, SigningOptions signingOptions);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
public static bool op_Equality(Key a, Key b);
    [NullableContextAttribute("2")]
public static bool op_Inequality(Key a, Key b);
    public virtual int GetHashCode();
    public Byte[] ToBytes();
    public string ToHex();
    public sealed virtual void Dispose();
    private void AssertNotDisposed();
    protected virtual void Dispose(bool disposing);
    protected virtual override void Finalize();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NBitcoin.KeyId : object {
    private uint160 v;
    public Script ScriptPubKey { get; }
    public KeyId(Byte[] value);
    public KeyId(uint160 value);
    public KeyId(string value);
    public sealed virtual Script get_ScriptPubKey();
    public BitcoinPubKeyAddress GetAddress(Network network);
    private sealed virtual override BitcoinAddress NBitcoin.IAddressableDestination.GetAddress(Network network);
    public sealed virtual bool IsSupported(Network network);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
public static bool op_Equality(KeyId a, KeyId b);
    [NullableContextAttribute("2")]
public static bool op_Inequality(KeyId a, KeyId b);
    public virtual int GetHashCode();
    public Byte[] ToBytes();
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NBitcoin.KeyPair : object {
    [CompilerGeneratedAttribute]
private IPubKey <PubKey>k__BackingField;
    [CompilerGeneratedAttribute]
private Key <Key>k__BackingField;
    public IPubKey PubKey { get; }
    public Key Key { get; }
    public KeyPair(Key key, IPubKey pubKey);
    [CompilerGeneratedAttribute]
public IPubKey get_PubKey();
    [CompilerGeneratedAttribute]
public Key get_Key();
    public static TaprootKeyPair CreateTaprootPair(Key key);
    public static TaprootKeyPair CreateTaprootPair(Key key, uint256 merkleRoot);
    public static KeyPair CreateECDSAPair(Key key);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class NBitcoin.KeyPath : object {
    private static KeyPath _Empty;
    private UInt32[] _Indexes;
    [NullableAttribute("2")]
private string _Path;
    public static KeyPath Empty { get; }
    public UInt32 Item { get; }
    public UInt32[] Indexes { get; }
    public int Length { get; }
    [NullableAttribute("2")]
public KeyPath Parent { get; }
    public bool IsHardened { get; }
    public bool IsHardenedPath { get; }
    public KeyPath(string path);
    public KeyPath(UInt32[] indexes);
    private static KeyPath();
    public static KeyPath Parse(string path);
    public static bool TryParse(string path, KeyPath& keyPath);
    public static KeyPath FromBytes(Byte[] data);
    public Byte[] ToBytes();
    private static bool TryParseCore(string i, UInt32& index);
    public static KeyPath get_Empty();
    public UInt32 get_Item(int index);
    public UInt32[] get_Indexes();
    public int get_Length();
    public KeyPath Derive(int index, bool hardened);
    public KeyPath Derive(string path);
    public KeyPath Derive(UInt32 index);
    public KeyPath Derive(KeyPath derivation);
    [NullableContextAttribute("2")]
public KeyPath get_Parent();
    public KeyPath Increment();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
public static bool op_Equality(KeyPath a, KeyPath b);
    [NullableContextAttribute("2")]
public static KeyPath op_Addition(KeyPath a, KeyPath b);
    public static bool op_Inequality(KeyPath a, KeyPath b);
    public virtual int GetHashCode();
    public virtual string ToString();
    private static string ToString(UInt32 i);
    public bool get_IsHardened();
    public KeyPath GetAddressKeyPath();
    public KeyPath GetAccountKeyPath();
    public bool get_IsHardenedPath();
    public RootedKeyPath ToRootedKeyPath(IHDKey masterKey);
    public RootedKeyPath ToRootedKeyPath(HDFingerprint masterFingerprint);
}
public enum NBitcoin.Language : Enum {
    public int value__;
    public static Language English;
    public static Language Japanese;
    public static Language Spanish;
    public static Language ChineseSimplified;
    public static Language ChineseTraditional;
    public static Language French;
    public static Language PortugueseBrazil;
    public static Language Czech;
    public static Language Unknown;
}
public class NBitcoin.LockTime : ValueType {
    internal static UInt32 LOCKTIME_THRESHOLD;
    private UInt32 _value;
    public static LockTime Zero { get; }
    public DateTimeOffset Date { get; }
    public int Height { get; }
    public UInt32 Value { get; }
    public bool IsHeightLock { get; }
    public bool IsTimeLock { get; }
    public LockTime(DateTimeOffset dateTime);
    public LockTime(int valueOrHeight);
    public LockTime(UInt32 valueOrHeight);
    public static LockTime get_Zero();
    public DateTimeOffset get_Date();
    public int get_Height();
    public UInt32 get_Value();
    public bool get_IsHeightLock();
    public bool get_IsTimeLock();
    public sealed virtual void ReadWrite(BitcoinStream stream);
    public virtual string ToString();
    public static LockTime op_Implicit(int valueOrHeight);
    public static LockTime op_Implicit(DateTimeOffset date);
    public static LockTime op_Implicit(UInt32 valueOrHeight);
    public static DateTimeOffset op_Implicit(LockTime lockTime);
    public static int op_Implicit(LockTime lockTime);
    public static UInt32 op_Implicit(LockTime lockTime);
    public static long op_Implicit(LockTime lockTime);
    public virtual bool Equals(object obj);
    public static bool op_Equality(LockTime a, LockTime b);
    public static bool op_Inequality(LockTime a, LockTime b);
    public virtual int GetHashCode();
}
public class NBitcoin.Logging.FuncLoggerFactory : object {
    private Func`2<string, ILogger> createLogger;
    public FuncLoggerFactory(Func`2<string, ILogger> createLogger);
    public sealed virtual void AddProvider(ILoggerProvider provider);
    public sealed virtual ILogger CreateLogger(string categoryName);
    public sealed virtual void Dispose();
}
public class NBitcoin.Logging.Logs : object {
    [CompilerGeneratedAttribute]
private static ILogger <NodeServer>k__BackingField;
    [CompilerGeneratedAttribute]
private static ILogger <Utils>k__BackingField;
    public static int ColumnLength;
    public static ILogger NodeServer { get; public set; }
    public static ILogger Utils { get; public set; }
    private static Logs();
    public static void Configure(ILoggerFactory factory);
    [CompilerGeneratedAttribute]
public static ILogger get_NodeServer();
    [CompilerGeneratedAttribute]
public static void set_NodeServer(ILogger value);
    [CompilerGeneratedAttribute]
public static ILogger get_Utils();
    [CompilerGeneratedAttribute]
public static void set_Utils(ILogger value);
}
public class NBitcoin.Logging.NullLogger : object {
    [CompilerGeneratedAttribute]
private static NullLogger <Instance>k__BackingField;
    public static NullLogger Instance { get; }
    private static NullLogger();
    [CompilerGeneratedAttribute]
public static NullLogger get_Instance();
    public sealed virtual IDisposable BeginScope(TState state);
    public sealed virtual bool IsEnabled(LogLevel logLevel);
    public sealed virtual void Log(LogLevel logLevel, EventId eventId, TState state, Exception exception, Func`3<TState, Exception, string> formatter);
}
public class NBitcoin.Logging.NullScope : object {
    [CompilerGeneratedAttribute]
private static NullScope <Instance>k__BackingField;
    public static NullScope Instance { get; }
    private static NullScope();
    [CompilerGeneratedAttribute]
public static NullScope get_Instance();
    public sealed virtual void Dispose();
}
public class NBitcoin.LotSequence : object {
    private int _Lot;
    private int _Sequence;
    private Byte[] _Bytes;
    public int Lot { get; }
    public int Sequence { get; }
    private int Id { get; }
    public LotSequence(int lot, int sequence);
    public LotSequence(Byte[] bytes);
    public int get_Lot();
    public int get_Sequence();
    public Byte[] ToBytes();
    private int get_Id();
    public virtual bool Equals(object obj);
    public static bool op_Equality(LotSequence a, LotSequence b);
    public static bool op_Inequality(LotSequence a, LotSequence b);
    public virtual int GetHashCode();
}
public class NBitcoin.MemPoolInfo : object {
    [CompilerGeneratedAttribute]
private int <Size>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Bytes>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Usage>k__BackingField;
    [CompilerGeneratedAttribute]
private double <MaxMemPool>k__BackingField;
    [CompilerGeneratedAttribute]
private double <MemPoolMinFee>k__BackingField;
    [CompilerGeneratedAttribute]
private double <MinRelayTxFee>k__BackingField;
    [CompilerGeneratedAttribute]
private FeeRateGroup[] <Histogram>k__BackingField;
    public int Size { get; public set; }
    public int Bytes { get; public set; }
    public int Usage { get; public set; }
    public double MaxMemPool { get; public set; }
    public double MemPoolMinFee { get; public set; }
    public double MinRelayTxFee { get; public set; }
    public FeeRateGroup[] Histogram { get; public set; }
    [CompilerGeneratedAttribute]
public int get_Size();
    [CompilerGeneratedAttribute]
public void set_Size(int value);
    [CompilerGeneratedAttribute]
public int get_Bytes();
    [CompilerGeneratedAttribute]
public void set_Bytes(int value);
    [CompilerGeneratedAttribute]
public int get_Usage();
    [CompilerGeneratedAttribute]
public void set_Usage(int value);
    [CompilerGeneratedAttribute]
public double get_MaxMemPool();
    [CompilerGeneratedAttribute]
public void set_MaxMemPool(double value);
    [CompilerGeneratedAttribute]
public double get_MemPoolMinFee();
    [CompilerGeneratedAttribute]
public void set_MemPoolMinFee(double value);
    [CompilerGeneratedAttribute]
public double get_MinRelayTxFee();
    [CompilerGeneratedAttribute]
public void set_MinRelayTxFee(double value);
    [CompilerGeneratedAttribute]
public FeeRateGroup[] get_Histogram();
    [CompilerGeneratedAttribute]
public void set_Histogram(FeeRateGroup[] value);
}
public class NBitcoin.MerkleBlock : object {
    private BlockHeader header;
    private PartialMerkleTree _PartialMerkleTree;
    public BlockHeader Header { get; public set; }
    public PartialMerkleTree PartialMerkleTree { get; public set; }
    public MerkleBlock(Block block, BloomFilter filter);
    public MerkleBlock(Block block, uint256[] txIds);
    public BlockHeader get_Header();
    public void set_Header(BlockHeader value);
    public PartialMerkleTree get_PartialMerkleTree();
    public void set_PartialMerkleTree(PartialMerkleTree value);
    public sealed virtual void ReadWrite(BitcoinStream stream);
}
public class NBitcoin.MerkleNode : object {
    [CompilerGeneratedAttribute]
private bool <IsLeaf>k__BackingField;
    private uint256 _Hash;
    [CompilerGeneratedAttribute]
private MerkleNode <Parent>k__BackingField;
    [CompilerGeneratedAttribute]
private MerkleNode <Left>k__BackingField;
    [CompilerGeneratedAttribute]
private MerkleNode <Right>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsMarked>k__BackingField;
    public uint256 Hash { get; public set; }
    public bool IsLeaf { get; private set; }
    public MerkleNode Parent { get; private set; }
    public MerkleNode Left { get; private set; }
    public MerkleNode Right { get; private set; }
    internal bool IsMarked { get; internal set; }
    public MerkleNode(uint256 hash);
    public MerkleNode(MerkleNode left, MerkleNode right);
    public static MerkleNode GetRoot(IEnumerable`1<uint256> leafs);
    public static MerkleNode GetRoot(int leafCount);
    public uint256 get_Hash();
    public void set_Hash(uint256 value);
    public void UpdateHash();
    [CompilerGeneratedAttribute]
public bool get_IsLeaf();
    [CompilerGeneratedAttribute]
private void set_IsLeaf(bool value);
    [CompilerGeneratedAttribute]
public MerkleNode get_Parent();
    [CompilerGeneratedAttribute]
private void set_Parent(MerkleNode value);
    [CompilerGeneratedAttribute]
public MerkleNode get_Left();
    [CompilerGeneratedAttribute]
private void set_Left(MerkleNode value);
    [CompilerGeneratedAttribute]
public MerkleNode get_Right();
    [CompilerGeneratedAttribute]
private void set_Right(MerkleNode value);
    public IEnumerable`1<MerkleNode> EnumerateDescendants();
    public MerkleNode GetLeaf(int i);
    public IEnumerable`1<MerkleNode> GetLeafs();
    [CompilerGeneratedAttribute]
internal bool get_IsMarked();
    [CompilerGeneratedAttribute]
internal void set_IsMarked(bool value);
    [IteratorStateMachineAttribute("NBitcoin.MerkleNode/<Ancestors>d__32")]
public IEnumerable`1<MerkleNode> Ancestors();
    public virtual string ToString();
    public string ToString(bool hierachy);
    private void ToString(StringBuilder builder, int indent);
}
public class NBitcoin.Mnemonic : object {
    private static Int32[] msArray;
    private static Int32[] csArray;
    private static Int32[] entArray;
    private Nullable`1<bool> _IsValidChecksum;
    private Wordlist _WordList;
    private Int32[] _Indices;
    private String[] _Words;
    private static Encoding NoBOMUTF8;
    private static Nullable`1<bool> _SupportOSNormalization;
    private string _Mnemonic;
    public bool IsValidChecksum { get; }
    public Wordlist WordList { get; }
    public Int32[] Indices { get; }
    public String[] Words { get; }
    public Mnemonic(string mnemonic, Wordlist wordlist);
    public Mnemonic(Wordlist wordList, Byte[] entropy);
    public Mnemonic(Wordlist wordList, WordCount wordCount);
    private static Mnemonic();
    private static Byte[] GenerateEntropy(WordCount wordCount);
    public bool get_IsValidChecksum();
    private static bool CorrectWordCount(int ms);
    public Wordlist get_WordList();
    public Int32[] get_Indices();
    public String[] get_Words();
    public Byte[] DeriveSeed(string passphrase);
    internal static Byte[] Normalize(string str);
    internal static string NormalizeString(string word);
    internal static bool SupportOsNormalization();
    public ExtKey DeriveExtKey(string passphrase);
    private static Byte[] Concat(Byte[] source1, Byte[] source2);
    public virtual string ToString();
}
public class NBitcoin.Money : object {
    private static NumberStyles BitcoinStyle;
    private long _Satoshis;
    private static Money _Zero;
    public static long COIN;
    public static long CENT;
    public static long NANO;
    public long Satoshi { get; private set; }
    public static Money Zero { get; }
    [ObsoleteAttribute("You shouldn't use 'int' for a satoshi amount; you should use long/int64, as Int32.MaxValue is only 2,147,483,647, while there can be 21,000,000*100,000,000 satoshis")]
public Money(int satoshis);
    [ObsoleteAttribute("You shouldn't use 'uint' for a satoshi amount; you should use long/int64, as UInt32.MaxValue is only 4,294,967,295, while there can be 21,000,000*100,000,000 satoshis")]
public Money(UInt32 satoshis);
    public Money(long satoshis);
    public Money(ulong satoshis);
    public Money(decimal amount, MoneyUnit unit);
    public Money(long amount, MoneyUnit unit);
    public Money(ulong amount, MoneyUnit unit);
    private static Money();
    public static bool TryParse(string bitcoin, Money& nRet);
    public static Money Parse(string bitcoin);
    public long get_Satoshi();
    private void set_Satoshi(long value);
    public Money Abs();
    [IteratorStateMachineAttribute("NBitcoin.Money/<Split>d__15")]
public IEnumerable`1<Money> Split(int parts);
    private static long DivRem(long a, long b, Int64& result);
    public static Money FromUnit(decimal amount, MoneyUnit unit);
    public decimal ToUnit(MoneyUnit unit);
    public decimal ToDecimal(MoneyUnit unit);
    public static Money Coins(decimal coins);
    public static Money Bits(decimal bits);
    public static Money Cents(decimal cents);
    public static Money Satoshis(decimal sats);
    public static Money Satoshis(ulong sats);
    public static Money Satoshis(long sats);
    public sealed virtual bool Equals(Money other);
    public sealed virtual int CompareTo(Money other);
    public int CompareTo(object obj);
    public static Money op_Subtraction(Money left, Money right);
    public static Money op_UnaryNegation(Money left);
    public static Money op_Addition(Money left, Money right);
    public static Money op_Multiply(int left, Money right);
    public static Money op_Multiply(Money right, int left);
    public static Money op_Multiply(long left, Money right);
    public static Money op_Multiply(Money right, long left);
    public static Money op_Division(Money left, long right);
    public static bool op_LessThan(Money left, Money right);
    public static bool op_GreaterThan(Money left, Money right);
    public static bool op_LessThanOrEqual(Money left, Money right);
    public static bool op_GreaterThanOrEqual(Money left, Money right);
    public static Money op_Implicit(long value);
    [ObsoleteAttribute("You shouldn't use 'int' for a satoshi amount; you should use long/int64, as Int32.MaxValue is only 2,147,483,647, while there can be 21,000,000*100,000,000 satoshis")]
public static Money op_Implicit(int value);
    [ObsoleteAttribute("You shouldn't use 'int' for a satoshi amount; you should use long/int64, as Int32.MaxValue is only 2,147,483,647, while there can be 21,000,000*100,000,000 satoshis")]
public static Money op_Implicit(UInt32 value);
    public static Money op_Implicit(ulong value);
    public static long op_Implicit(Money value);
    public static ulong op_Implicit(Money value);
    public static Money op_Implicit(string value);
    public virtual bool Equals(object obj);
    public static bool op_Equality(Money a, Money b);
    public static bool op_Inequality(Money a, Money b);
    public virtual int GetHashCode();
    public virtual string ToString();
    public string ToString(bool fplus, bool trimExcessZero);
    public static Money get_Zero();
    public bool Almost(Money amount, Money dust);
    public bool Almost(Money amount, decimal margin);
    public static Money Min(Money a, Money b);
    public static Money Max(Money a, Money b);
    private static void CheckLongMinValue(long value);
    private static void CheckMoneyUnit(MoneyUnit value, string paramName);
    private sealed virtual override IMoney NBitcoin.IMoney.Add(IMoney money);
    private sealed virtual override IMoney NBitcoin.IMoney.Sub(IMoney money);
    private sealed virtual override IMoney NBitcoin.IMoney.Negate();
    private sealed virtual override int System.IComparable.CompareTo(object obj);
    private sealed virtual override int System.IComparable<NBitcoin.IMoney>.CompareTo(IMoney other);
    private sealed virtual override bool System.IEquatable<NBitcoin.IMoney>.Equals(IMoney other);
    private sealed virtual override bool NBitcoin.IMoney.IsCompatible(IMoney money);
    private sealed virtual override IEnumerable`1<IMoney> NBitcoin.IMoney.Split(int parts);
}
public class NBitcoin.MoneyBag : object {
    private List`1<IMoney> _bag;
    public MoneyBag(MoneyBag money);
    public MoneyBag(IMoney[] bag);
    private MoneyBag(IEnumerable`1<IMoney> bag);
    private void AppendMoney(MoneyBag money);
    private void AppendMoney(IMoney money);
    public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(IMoney other);
    public sealed virtual bool Equals(MoneyBag other);
    public sealed virtual bool Equals(IMoney other);
    public static MoneyBag op_Subtraction(MoneyBag left, IMoney right);
    public static MoneyBag op_Addition(MoneyBag left, IMoney right);
    private sealed virtual override IMoney NBitcoin.IMoney.Add(IMoney money);
    private sealed virtual override IMoney NBitcoin.IMoney.Sub(IMoney money);
    private sealed virtual override IMoney NBitcoin.IMoney.Negate();
    private sealed virtual override bool NBitcoin.IMoney.IsCompatible(IMoney money);
    public IMoney GetAmount(AssetId assetId);
    public virtual string ToString();
    public sealed virtual IEnumerator`1<IMoney> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [IteratorStateMachineAttribute("NBitcoin.MoneyBag/<Split>d__21")]
public IEnumerable`1<MoneyBag> Split(int parts);
    private sealed virtual override IEnumerable`1<IMoney> NBitcoin.IMoney.Split(int parts);
    public TMoney GetAmount(TMoney zero);
}
[ExtensionAttribute]
public static class NBitcoin.MoneyExtensions : object {
    [ExtensionAttribute]
public static Money Sum(IEnumerable`1<Money> moneys);
    [ExtensionAttribute]
public static IMoney Sum(IEnumerable`1<IMoney> moneys, IMoney zero);
    [ExtensionAttribute]
public static AssetMoney Sum(IEnumerable`1<AssetMoney> moneys, AssetId assetId);
}
public enum NBitcoin.MoneyUnit : Enum {
    public int value__;
    public static MoneyUnit BTC;
    public static MoneyUnit MilliBTC;
    public static MoneyUnit Bit;
    public static MoneyUnit Satoshi;
}
internal class NBitcoin.NBitcoinContext : object {
    private static Lazy`1<Context> _Instance;
    public static Context Instance { get; }
    private static NBitcoinContext();
    public static Context get_Instance();
    private static Context CreateInstance();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NBitcoin.Network : object {
    internal Byte[][] base58Prefixes;
    internal Bech32Encoder[] bech32Encoders;
    [CompilerGeneratedAttribute]
private string <UriScheme>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <MaxP2PVersion>k__BackingField;
    private UInt32 magic;
    private List`1<DNSSeedData> vSeeds;
    private List`1<NetworkAddress> vFixedSeeds;
    private Byte[] _GenesisBytes;
    private int nRPCPort;
    private int nDefaultPort;
    private Consensus consensus;
    private string name;
    [NullableAttribute("2")]
private ChainName chainName;
    internal static UInt32 BITCOIN_MAX_P2P_VERSION;
    private static ConcurrentDictionary`2<string, Network> _OtherAliases;
    private static List`1<Network> _OtherNetworks;
    private INetworkSet _NetworkSet;
    [CompilerGeneratedAttribute]
private NetworkStringParser <NetworkStringParser>k__BackingField;
    private Byte[] _MagicBytes;
    public string UriScheme { get; internal set; }
    public UInt32 MaxP2PVersion { get; internal set; }
    public int RPCPort { get; }
    public int DefaultPort { get; }
    public Consensus Consensus { get; }
    public string Name { get; }
    public ChainName ChainName { get; }
    public static Network Main { get; }
    public static Network TestNet { get; }
    public static Network RegTest { get; }
    public INetworkSet NetworkSet { get; }
    internal NetworkStringParser NetworkStringParser { get; internal set; }
    public uint256 GenesisHash { get; }
    public IEnumerable`1<NetworkAddress> SeedNodes { get; }
    public IEnumerable`1<DNSSeedData> DNSSeeds { get; }
    public Byte[] MagicBytes { get; }
    public UInt32 Magic { get; }
    private Network(string name, Byte[] genesis, UInt32 magic, string uriScheme, INetworkSet networkSet);
    private static Network();
    [CompilerGeneratedAttribute]
public string get_UriScheme();
    [CompilerGeneratedAttribute]
internal void set_UriScheme(string value);
    [CompilerGeneratedAttribute]
public UInt32 get_MaxP2PVersion();
    [CompilerGeneratedAttribute]
internal void set_MaxP2PVersion(UInt32 value);
    [NullableContextAttribute("2")]
public Bech32Encoder GetBech32Encoder(Bech32Type type, bool throws);
    internal NotSupportedException Bech32NotSupported(Bech32Type type);
    [NullableContextAttribute("2")]
public Byte[] GetVersionBytes(Base58Type type, bool throws);
    [NullableContextAttribute("0")]
public Nullable`1<ReadOnlyMemory`1<byte>> GetVersionMemory(Base58Type type, bool throws);
    internal NotSupportedException Base58NotSupported(Base58Type type);
    internal static string CreateBase58(Base58Type type, Byte[] bytes, Network network);
    internal static string CreateBech32(Bech32Type type, Byte[] bytes, byte witnessVersion, Network network);
    public Transaction CreateTransaction();
    public int get_RPCPort();
    public int get_DefaultPort();
    public Consensus get_Consensus();
    public string get_Name();
    public ChainName get_ChainName();
    public static Network get_Main();
    public static Network get_TestNet();
    public static Network get_RegTest();
    public INetworkSet get_NetworkSet();
    public static string GetDefaultDataFolder(string folderName);
    internal static Network Register(NetworkBuilder builder);
    private Block CreateGenesisBlock(UInt32 nTime, UInt32 nNonce, UInt32 nBits, int nVersion, Money genesisReward);
    private Block CreateGenesisBlock(string pszTimestamp, Script genesisOutputScript, UInt32 nTime, UInt32 nNonce, UInt32 nBits, int nVersion, Money genesisReward);
    public BitcoinSecret CreateBitcoinSecret(string base58);
    public BitcoinAddress CreateBitcoinAddress(string base58);
    public BitcoinScriptAddress CreateBitcoinScriptAddress(string base58);
    private Nullable`1<Base58Type> GetBase58Type(string base58);
    private Nullable`1<Base58Type> GetBase58Type(Byte[] bytes, Int32& prefixLength);
    internal static Network GetNetworkFromBase58Data(string base58, Nullable`1<Base58Type> expectedType);
    public T Parse(string str);
    public IBitcoinString Parse(string str);
    public IBitcoinString Parse(string str, Type targetType);
    public static IBitcoinString Parse(string str, Network expectedNetwork, Type targetType);
    public static T Parse(string str, Network expectedNetwork);
    private IBase58Data GetCandidate(string base58, Byte[] decoded);
    [CompilerGeneratedAttribute]
internal NetworkStringParser get_NetworkStringParser();
    [CompilerGeneratedAttribute]
internal void set_NetworkStringParser(NetworkStringParser value);
    public TransactionBuilder CreateTransactionBuilder();
    public TransactionBuilder CreateTransactionBuilder(int seed);
    public Base58CheckEncoder GetBase58CheckEncoder();
    private IBase58Data CreateBase58Data(Base58Type type, string base58);
    private BitcoinColoredAddress CreateColoredAddress(string base58);
    public BitcoinAssetId CreateAssetId(string base58);
    private BitcoinPassphraseCode CreatePassphraseCode(string base58);
    private BitcoinEncryptedSecretNoEC CreateEncryptedKeyNoEC(string base58);
    private BitcoinEncryptedSecretEC CreateEncryptedKeyEC(string base58);
    private Base58Data CreateConfirmationCode(string base58);
    private Base58Data CreateBitcoinExtPubKey(string base58);
    public BitcoinExtKey CreateBitcoinExtKey(ExtKey key);
    public BitcoinExtPubKey CreateBitcoinExtPubKey(ExtPubKey pubkey);
    public BitcoinExtKey CreateBitcoinExtKey(string base58);
    public virtual string ToString();
    public Block GetGenesis();
    public uint256 get_GenesisHash();
    [IteratorStateMachineAttribute("NBitcoin.Network/<GetNetworks>d__88")]
public static IEnumerable`1<Network> GetNetworks();
    public static Network GetNetwork(string name);
    public BitcoinSecret CreateBitcoinSecret(Key key);
    public BitcoinPubKeyAddress CreateBitcoinAddress(KeyId dest);
    private BitcoinScriptAddress CreateBitcoinScriptAddress(ScriptId scriptId);
    public Message ParseMessage(Byte[] bytes, Nullable`1<UInt32> version);
    public IEnumerable`1<NetworkAddress> get_SeedNodes();
    public IEnumerable`1<DNSSeedData> get_DNSSeeds();
    public Byte[] get_MagicBytes();
    public UInt32 get_Magic();
    public Money GetReward(int nHeight);
    public bool ReadMagic(Stream stream, CancellationToken cancellation, bool throwIfEOF);
}
public class NBitcoin.NetworkBuilder : object {
    internal NetworkStringParser _NetworkStringParser;
    internal string _Name;
    internal ChainName _ChainName;
    internal Dictionary`2<Base58Type, Byte[]> _Base58Prefixes;
    internal Dictionary`2<Bech32Type, Bech32Encoder> _Bech32Prefixes;
    internal List`1<string> _Aliases;
    internal int _RPCPort;
    internal int _Port;
    internal UInt32 _Magic;
    internal Consensus _Consensus;
    internal List`1<DNSSeedData> vSeeds;
    internal List`1<NetworkAddress> vFixedSeeds;
    internal Byte[] _Genesis;
    internal Nullable`1<UInt32> _MaxP2PVersion;
    internal INetworkSet _NetworkSet;
    internal string _UriScheme;
    public NetworkBuilder SetNetworkSet(INetworkSet networkSet);
    public NetworkBuilder SetUriScheme(string uriScheme);
    public NetworkBuilder SetMaxP2PVersion(UInt32 version);
    public NetworkBuilder SetName(string name);
    public void CopyFrom(Network network);
    public NetworkBuilder SetNetworkStringParser(NetworkStringParser networkStringParser);
    public NetworkBuilder AddAlias(string alias);
    public NetworkBuilder SetRPCPort(int port);
    public NetworkBuilder SetPort(int port);
    public NetworkBuilder SetMagic(UInt32 magic);
    public NetworkBuilder AddDNSSeeds(IEnumerable`1<DNSSeedData> seeds);
    public NetworkBuilder AddSeeds(IEnumerable`1<NetworkAddress> seeds);
    public NetworkBuilder SetConsensus(Consensus consensus);
    public NetworkBuilder SetGenesis(string hex);
    public NetworkBuilder SetBase58Bytes(Base58Type type, Byte[] bytes);
    public NetworkBuilder SetBech32(Bech32Type type, string humanReadablePart);
    public NetworkBuilder SetBech32(Bech32Type type, Bech32Encoder encoder);
    public NetworkBuilder SetChainName(ChainName chainName);
    public Network BuildAndRegister();
}
public abstract class NBitcoin.NetworkSetBase : object {
    private object l;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _Registered;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _Registering;
    private Network _Mainnet;
    private Network _Testnet;
    private Network _Regtest;
    public Network Mainnet { get; }
    public Network Testnet { get; }
    public Network Regtest { get; }
    public string CryptoCode { get; }
    public virtual Network GetNetwork(ChainName chainName);
    public void EnsureRegistered();
    protected virtual void PostInit();
    protected abstract virtual NetworkBuilder CreateMainnet();
    protected abstract virtual NetworkBuilder CreateTestnet();
    protected abstract virtual NetworkBuilder CreateRegtest();
    public sealed virtual Network get_Mainnet();
    public sealed virtual Network get_Testnet();
    public sealed virtual Network get_Regtest();
    public abstract virtual string get_CryptoCode();
    protected void RegisterDefaultCookiePath(string folderName, FolderName folder);
    protected static IEnumerable`1<NetworkAddress> ToSeed(Tuple`2[] tuples);
}
public class NBitcoin.NetworkStringParser : object {
    public bool TryParse(string str, Network network, T& result);
    public virtual bool TryParse(string str, Network network, Type targetType, IBitcoinString& result);
    public virtual Base58CheckEncoder GetBase58CheckEncoder();
    public virtual BitcoinPubKeyAddress CreateP2PKH(KeyId keyId, Network network);
    public virtual BitcoinScriptAddress CreateP2SH(ScriptId scriptId, Network network);
    public virtual BitcoinWitPubKeyAddress CreateP2WPKH(WitKeyId witKeyId, Network network);
    public virtual BitcoinWitScriptAddress CreateP2WSH(WitScriptId scriptId, Network network);
}
public abstract class NBitcoin.NoSqlRepository : object {
    [CompilerGeneratedAttribute]
private ConsensusFactory <ConsensusFactory>k__BackingField;
    public ConsensusFactory ConsensusFactory { get; }
    public NoSqlRepository(ConsensusFactory consensusFactory);
    [CompilerGeneratedAttribute]
public ConsensusFactory get_ConsensusFactory();
    public Task PutAsync(string key, IBitcoinSerializable obj);
    public void Put(string key, IBitcoinSerializable obj);
    [AsyncStateMachineAttribute("NBitcoin.NoSqlRepository/<GetAsync>d__6`1")]
public Task`1<T> GetAsync(string key);
    public T Get(string key);
    public virtual Task PutBatch(IEnumerable`1<Tuple`2<string, IBitcoinSerializable>> values);
    protected abstract virtual Task PutBytesBatch(IEnumerable`1<Tuple`2<string, Byte[]>> enumerable);
    protected abstract virtual Task`1<Byte[]> GetBytes(string key);
    protected virtual Task PutBytes(string key, Byte[] data);
}
public class NBitcoin.NoSqlTransactionRepository : object {
    private NoSqlRepository _Repository;
    public NoSqlRepository Repository { get; }
    public NoSqlTransactionRepository(NoSqlRepository repository);
    public NoSqlRepository get_Repository();
    public sealed virtual Task`1<Transaction> GetAsync(uint256 txId);
    private string GetId(uint256 txId);
    public sealed virtual Task PutAsync(uint256 txId, Transaction tx);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NBitcoin.NotEnoughFundsException : Exception {
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <Group>k__BackingField;
    [CompilerGeneratedAttribute]
private IMoney <Missing>k__BackingField;
    [NullableAttribute("2")]
public string Group { get; private set; }
    public IMoney Missing { get; private set; }
    public NotEnoughFundsException(string message, string group, IMoney missing);
    private static string BuildMessage(string message, string group, IMoney missing);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_Group();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private void set_Group(string value);
    [CompilerGeneratedAttribute]
public IMoney get_Missing();
    [CompilerGeneratedAttribute]
private void set_Missing(IMoney value);
}
public class NBitcoin.Op : object {
    internal static Dictionary`2<string, OpcodeType> _OpcodeByName;
    private string _Name;
    private OpcodeType _Code;
    private static Boolean[] _ValidOpCode;
    [CompilerGeneratedAttribute]
private Byte[] <PushData>k__BackingField;
    private static string unknown;
    private static int MAX_SCRIPT_ELEMENT_SIZE;
    [CompilerGeneratedAttribute]
private bool <IsInvalid>k__BackingField;
    public string Name { get; }
    public OpcodeType Code { get; public set; }
    public Byte[] PushData { get; public set; }
    public bool IsInvalid { get; private set; }
    public bool IsSmallUInt { get; }
    public bool IsSmallInt { get; }
    private static Op();
    public static string GetOpName(OpcodeType opcode);
    internal static bool IsPushCode(OpcodeType opcode);
    public static bool GetOpCode(string name, OpcodeType& result);
    public static Op GetPushOp(long value);
    public static Op GetPushOp(Byte[] data);
    public string get_Name();
    private static Boolean[] GetValidOpCode();
    public OpcodeType get_Code();
    public void set_Code(OpcodeType value);
    [CompilerGeneratedAttribute]
public Byte[] get_PushData();
    [CompilerGeneratedAttribute]
public void set_PushData(Byte[] value);
    private void PushDataToStream(Byte[] data, Stream result);
    internal Byte[] ReadData(Stream stream);
    public Byte[] ToBytes();
    public virtual string ToString();
    public void WriteTo(Stream stream);
    internal static Op Read(TextReader textReader);
    public static Op op_Implicit(OpcodeType codeType);
    private static string ReadWord(TextReader textReader);
    [CompilerGeneratedAttribute]
public bool get_IsInvalid();
    [CompilerGeneratedAttribute]
private void set_IsInvalid(bool value);
    public bool get_IsSmallUInt();
    public bool get_IsSmallInt();
    public Nullable`1<int> GetInt();
    public Nullable`1<long> GetLong();
}
public enum NBitcoin.OpcodeType : Enum {
    public byte value__;
    public static OpcodeType OP_0;
    public static OpcodeType OP_FALSE;
    public static OpcodeType OP_PUSHDATA1;
    public static OpcodeType OP_PUSHDATA2;
    public static OpcodeType OP_PUSHDATA4;
    public static OpcodeType OP_1NEGATE;
    public static OpcodeType OP_RESERVED;
    public static OpcodeType OP_1;
    public static OpcodeType OP_TRUE;
    public static OpcodeType OP_2;
    public static OpcodeType OP_3;
    public static OpcodeType OP_4;
    public static OpcodeType OP_5;
    public static OpcodeType OP_6;
    public static OpcodeType OP_7;
    public static OpcodeType OP_8;
    public static OpcodeType OP_9;
    public static OpcodeType OP_10;
    public static OpcodeType OP_11;
    public static OpcodeType OP_12;
    public static OpcodeType OP_13;
    public static OpcodeType OP_14;
    public static OpcodeType OP_15;
    public static OpcodeType OP_16;
    public static OpcodeType OP_NOP;
    public static OpcodeType OP_VER;
    public static OpcodeType OP_IF;
    public static OpcodeType OP_NOTIF;
    public static OpcodeType OP_VERIF;
    public static OpcodeType OP_VERNOTIF;
    public static OpcodeType OP_ELSE;
    public static OpcodeType OP_ENDIF;
    public static OpcodeType OP_VERIFY;
    public static OpcodeType OP_RETURN;
    public static OpcodeType OP_TOALTSTACK;
    public static OpcodeType OP_FROMALTSTACK;
    public static OpcodeType OP_2DROP;
    public static OpcodeType OP_2DUP;
    public static OpcodeType OP_3DUP;
    public static OpcodeType OP_2OVER;
    public static OpcodeType OP_2ROT;
    public static OpcodeType OP_2SWAP;
    public static OpcodeType OP_IFDUP;
    public static OpcodeType OP_DEPTH;
    public static OpcodeType OP_DROP;
    public static OpcodeType OP_DUP;
    public static OpcodeType OP_NIP;
    public static OpcodeType OP_OVER;
    public static OpcodeType OP_PICK;
    public static OpcodeType OP_ROLL;
    public static OpcodeType OP_ROT;
    public static OpcodeType OP_SWAP;
    public static OpcodeType OP_TUCK;
    public static OpcodeType OP_CAT;
    public static OpcodeType OP_SUBSTR;
    public static OpcodeType OP_LEFT;
    public static OpcodeType OP_RIGHT;
    public static OpcodeType OP_SIZE;
    public static OpcodeType OP_INVERT;
    public static OpcodeType OP_AND;
    public static OpcodeType OP_OR;
    public static OpcodeType OP_XOR;
    public static OpcodeType OP_EQUAL;
    public static OpcodeType OP_EQUALVERIFY;
    public static OpcodeType OP_RESERVED1;
    public static OpcodeType OP_RESERVED2;
    public static OpcodeType OP_1ADD;
    public static OpcodeType OP_1SUB;
    public static OpcodeType OP_2MUL;
    public static OpcodeType OP_2DIV;
    public static OpcodeType OP_NEGATE;
    public static OpcodeType OP_ABS;
    public static OpcodeType OP_NOT;
    public static OpcodeType OP_0NOTEQUAL;
    public static OpcodeType OP_ADD;
    public static OpcodeType OP_SUB;
    public static OpcodeType OP_MUL;
    public static OpcodeType OP_DIV;
    public static OpcodeType OP_MOD;
    public static OpcodeType OP_LSHIFT;
    public static OpcodeType OP_RSHIFT;
    public static OpcodeType OP_BOOLAND;
    public static OpcodeType OP_BOOLOR;
    public static OpcodeType OP_NUMEQUAL;
    public static OpcodeType OP_NUMEQUALVERIFY;
    public static OpcodeType OP_NUMNOTEQUAL;
    public static OpcodeType OP_LESSTHAN;
    public static OpcodeType OP_GREATERTHAN;
    public static OpcodeType OP_LESSTHANOREQUAL;
    public static OpcodeType OP_GREATERTHANOREQUAL;
    public static OpcodeType OP_MIN;
    public static OpcodeType OP_MAX;
    public static OpcodeType OP_WITHIN;
    public static OpcodeType OP_RIPEMD160;
    public static OpcodeType OP_SHA1;
    public static OpcodeType OP_SHA256;
    public static OpcodeType OP_HASH160;
    public static OpcodeType OP_HASH256;
    public static OpcodeType OP_CODESEPARATOR;
    public static OpcodeType OP_CHECKSIG;
    public static OpcodeType OP_CHECKSIGVERIFY;
    public static OpcodeType OP_CHECKMULTISIG;
    public static OpcodeType OP_CHECKMULTISIGVERIFY;
    public static OpcodeType OP_CHECKLOCKTIMEVERIFY;
    public static OpcodeType OP_CHECKSEQUENCEVERIFY;
    public static OpcodeType OP_NOP1;
    public static OpcodeType OP_NOP2;
    public static OpcodeType OP_NOP3;
    public static OpcodeType OP_NOP4;
    public static OpcodeType OP_NOP5;
    public static OpcodeType OP_NOP6;
    public static OpcodeType OP_NOP7;
    public static OpcodeType OP_NOP8;
    public static OpcodeType OP_NOP9;
    public static OpcodeType OP_NOP10;
    public static OpcodeType OP_CHECKSIGADD;
}
public class NBitcoin.OpenAsset.AssetId : object {
    internal Byte[] _Bytes;
    private string _Str;
    public AssetId(IDestination assetScriptPubKey);
    public AssetId(BitcoinAssetId assetId);
    public AssetId(Script assetScriptPubKey);
    public AssetId(ScriptId scriptId);
    public AssetId(Byte[] value);
    public AssetId(uint160 value);
    public AssetId(string value);
    public BitcoinAssetId GetWif(Network network);
    public Byte[] ToBytes();
    public Byte[] ToBytes(bool unsafe);
    public virtual bool Equals(object obj);
    public static bool op_Equality(AssetId a, AssetId b);
    public static bool op_Inequality(AssetId a, AssetId b);
    public virtual int GetHashCode();
    public virtual string ToString();
    public string ToString(Network network);
}
public class NBitcoin.OpenAsset.AssetMoney : object {
    private long _Quantity;
    private AssetId _Id;
    public long Quantity { get; private set; }
    public AssetId Id { get; }
    public AssetMoney(AssetId assetId);
    public AssetMoney(IDestination issuer, long quantity);
    public AssetMoney(AssetId assetId, int quantity);
    public AssetMoney(AssetId assetId, UInt32 quantity);
    public AssetMoney(AssetId assetId, long quantity);
    public AssetMoney(AssetId assetId, ulong quantity);
    public AssetMoney(AssetId assetId, decimal amount, int divisibility);
    public long get_Quantity();
    private void set_Quantity(long value);
    private static void CheckLongMinValue(long value);
    public AssetId get_Id();
    public AssetMoney Abs();
    private static int Pow10(int divisibility);
    [IteratorStateMachineAttribute("NBitcoin.OpenAsset.AssetMoney/<Split>d__17")]
public IEnumerable`1<AssetMoney> Split(int parts);
    private static long DivRem(long a, long b, Int64& result);
    public decimal ToDecimal(int divisibility);
    public sealed virtual bool Equals(AssetMoney other);
    internal void CheckAssetId(AssetMoney other, string param);
    public sealed virtual int CompareTo(AssetMoney other);
    public int CompareTo(object obj);
    public static AssetMoney op_Subtraction(AssetMoney left, AssetMoney right);
    public static AssetMoney op_UnaryNegation(AssetMoney left);
    public static AssetMoney op_Addition(AssetMoney left, AssetMoney right);
    public static AssetMoney op_Multiply(int left, AssetMoney right);
    public static AssetMoney op_Multiply(AssetMoney right, int left);
    public static AssetMoney op_Multiply(long left, AssetMoney right);
    public static AssetMoney op_Multiply(AssetMoney right, long left);
    public static bool op_LessThan(AssetMoney left, AssetMoney right);
    public static bool op_GreaterThan(AssetMoney left, AssetMoney right);
    public static bool op_LessThanOrEqual(AssetMoney left, AssetMoney right);
    public static bool op_GreaterThanOrEqual(AssetMoney left, AssetMoney right);
    public virtual bool Equals(object obj);
    public static bool op_Equality(AssetMoney a, AssetMoney b);
    public static bool op_Inequality(AssetMoney a, AssetMoney b);
    public virtual int GetHashCode();
    public virtual string ToString();
    public static AssetMoney Min(AssetMoney a, AssetMoney b);
    private sealed virtual override IMoney NBitcoin.IMoney.Add(IMoney money);
    private sealed virtual override IMoney NBitcoin.IMoney.Sub(IMoney money);
    private sealed virtual override IMoney NBitcoin.IMoney.Negate();
    private sealed virtual override int System.IComparable.CompareTo(object obj);
    private sealed virtual override int System.IComparable<NBitcoin.IMoney>.CompareTo(IMoney other);
    private sealed virtual override bool System.IEquatable<NBitcoin.IMoney>.Equals(IMoney other);
    private sealed virtual override bool NBitcoin.IMoney.IsCompatible(IMoney money);
    private sealed virtual override IEnumerable`1<IMoney> NBitcoin.IMoney.Split(int parts);
}
public class NBitcoin.OpenAsset.BitcoinAssetId : Base58Data {
    private AssetId _AssetId;
    public AssetId AssetId { get; }
    protected bool IsValid { get; }
    public Base58Type Type { get; }
    public BitcoinAssetId(string base58, Network expectedNetwork);
    public BitcoinAssetId(Byte[] raw, Network network);
    public BitcoinAssetId(AssetId assetId, Network network);
    public AssetId get_AssetId();
    protected virtual bool get_IsValid();
    public virtual Base58Type get_Type();
    public static AssetId op_Implicit(BitcoinAssetId id);
}
public class NBitcoin.OpenAsset.CachedColoredTransactionRepository : object {
    private IColoredTransactionRepository _Inner;
    private CachedTransactionRepository _InnerTransactionRepository;
    private Dictionary`2<uint256, ColoredTransaction> _ColoredTransactions;
    private Queue`1<uint256> _EvictionQueue;
    private ReaderWriterLock _lock;
    public int MaxCachedTransactions { get; public set; }
    public bool WriteThrough { get; public set; }
    public bool ReadThrough { get; public set; }
    public CachedTransactionRepository Transactions { get; }
    private ITransactionRepository NBitcoin.OpenAsset.IColoredTransactionRepository.Transactions { get; }
    public CachedColoredTransactionRepository(IColoredTransactionRepository inner);
    public ColoredTransaction GetFromCache(uint256 txId);
    public int get_MaxCachedTransactions();
    public void set_MaxCachedTransactions(int value);
    public bool get_WriteThrough();
    public void set_WriteThrough(bool value);
    public bool get_ReadThrough();
    public void set_ReadThrough(bool value);
    public CachedTransactionRepository get_Transactions();
    private sealed virtual override ITransactionRepository NBitcoin.OpenAsset.IColoredTransactionRepository.get_Transactions();
    private void EvictIfNecessary(uint256 txId);
    [AsyncStateMachineAttribute("NBitcoin.OpenAsset.CachedColoredTransactionRepository/<GetAsync>d__21")]
public sealed virtual Task`1<ColoredTransaction> GetAsync(uint256 txId);
    public sealed virtual Task PutAsync(uint256 txId, ColoredTransaction tx);
}
public class NBitcoin.OpenAsset.ColoredEntry : object {
    private UInt32 _Index;
    private AssetMoney _Asset;
    public UInt32 Index { get; public set; }
    public AssetMoney Asset { get; public set; }
    public ColoredEntry(UInt32 index, AssetMoney asset);
    public UInt32 get_Index();
    public void set_Index(UInt32 value);
    public AssetMoney get_Asset();
    public void set_Asset(AssetMoney value);
    public sealed virtual void ReadWrite(BitcoinStream stream);
    public virtual string ToString();
}
public class NBitcoin.OpenAsset.ColoredTransaction : object {
    private ColorMarker _Marker;
    private List`1<ColoredEntry> _Issuances;
    private List`1<ColoredEntry> _Transfers;
    private List`1<ColoredEntry> _Inputs;
    public static DateTimeOffset FirstColoredDate;
    public ColorMarker Marker { get; public set; }
    public List`1<ColoredEntry> Issuances { get; public set; }
    public List`1<ColoredEntry> Transfers { get; public set; }
    public List`1<ColoredEntry> Inputs { get; public set; }
    public ColoredTransaction(Transaction tx, ColoredCoin[] spentCoins, Script issuanceScriptPubkey);
    public ColoredTransaction(uint256 txId, Transaction tx, ColoredCoin[] spentCoins, Script issuanceScriptPubkey);
    private static ColoredTransaction();
    public static Task`1<ColoredTransaction> FetchColorsAsync(Transaction tx, IColoredTransactionRepository repo);
    public static ColoredTransaction FetchColors(Transaction tx, IColoredTransactionRepository repo);
    public static Task`1<ColoredTransaction> FetchColorsAsync(uint256 txId, IColoredTransactionRepository repo);
    public static ColoredTransaction FetchColors(uint256 txId, IColoredTransactionRepository repo);
    public static ColoredTransaction FetchColors(uint256 txId, Transaction tx, IColoredTransactionRepository repo);
    [AsyncStateMachineAttribute("NBitcoin.OpenAsset.ColoredTransaction/<FetchColorsAsync>d__6")]
public static Task`1<ColoredTransaction> FetchColorsAsync(uint256 txId, Transaction tx, IColoredTransactionRepository repo);
    [AsyncStateMachineAttribute("NBitcoin.OpenAsset.ColoredTransaction/<BulkLoadIfCached>d__7")]
private static Task`1<bool> BulkLoadIfCached(Transaction transaction, IColoredTransactionRepository repo);
    public ColoredEntry GetColoredEntry(UInt32 n);
    public static bool HasIssuance(Transaction tx);
    public ColorMarker get_Marker();
    public void set_Marker(ColorMarker value);
    public List`1<ColoredEntry> get_Issuances();
    public void set_Issuances(List`1<ColoredEntry> value);
    public List`1<ColoredEntry> get_Transfers();
    public void set_Transfers(List`1<ColoredEntry> value);
    public AssetMoney[] GetDestroyedAssets();
    public sealed virtual void ReadWrite(BitcoinStream stream);
    public List`1<ColoredEntry> get_Inputs();
    public void set_Inputs(List`1<ColoredEntry> value);
    public virtual string ToString();
    public string ToString(Network network);
    private static void WriteEntry(Network network, JArray inputs, ColoredEntry entry);
}
[ExtensionAttribute]
public static class NBitcoin.OpenAsset.ColoredTxRepoExtensions : object {
    [ExtensionAttribute]
public static Task`1<ColoredTransaction> GetAsync(IColoredTransactionRepository repo, string txId);
    [ExtensionAttribute]
public static ColoredTransaction Get(IColoredTransactionRepository repo, string txId);
    [ExtensionAttribute]
public static ColoredTransaction Get(IColoredTransactionRepository repo, uint256 txId);
    [ExtensionAttribute]
public static void Put(IColoredTransactionRepository repo, uint256 txId, ColoredTransaction tx);
}
public class NBitcoin.OpenAsset.ColorMarker : object {
    private static ushort Tag;
    private ushort _Version;
    private UInt64[] _Quantities;
    private Byte[] _Metadata;
    private static ulong MAX_QUANTITY;
    private static TxNullDataTemplate _Template;
    public ushort Version { get; public set; }
    public UInt64[] Quantities { get; public set; }
    public Byte[] Metadata { get; public set; }
    public ColorMarker(Script script);
    public ColorMarker(UInt64[] quantities);
    private static ColorMarker();
    public static ColorMarker TryParse(string script);
    public static ColorMarker TryParse(Transaction transaction);
    public static ColorMarker TryParse(Script script);
    private bool ReadScript(Script script);
    private bool ReadData(Byte[] data);
    private static ulong ReadLEB128(BitcoinStream stream);
    private void WriteLEB128(ulong value, BitcoinStream stream);
    public ushort get_Version();
    public void set_Version(ushort value);
    public UInt64[] get_Quantities();
    public void set_Quantities(UInt64[] value);
    public void SetQuantity(UInt32 index, long quantity);
    public void SetQuantity(int index, long quantity);
    public Byte[] get_Metadata();
    public void set_Metadata(Byte[] value);
    public Script GetScript();
    public Byte[] ToBytes();
    public static ColorMarker Get(Transaction transaction);
    public static ColorMarker Get(Transaction transaction, UInt32& markerPosition);
    public sealed virtual void ReadWrite(BitcoinStream stream);
    public static bool HasValidColorMarker(Transaction tx);
    public bool HasValidQuantitiesCount(Transaction tx);
    public Uri GetMetadataUrl();
    public void SetMetadataUrl(Uri uri);
}
[ExtensionAttribute]
public static class NBitcoin.OpenAsset.Extensions : object {
    [ExtensionAttribute]
public static ColoredTransaction GetColoredTransaction(Transaction tx, IColoredTransactionRepository repo);
    [AsyncStateMachineAttribute("NBitcoin.OpenAsset.Extensions/<GetColoredTransactionAsync>d__1")]
[ExtensionAttribute]
public static Task`1<ColoredTransaction> GetColoredTransactionAsync(Transaction tx, IColoredTransactionRepository repo);
    [ExtensionAttribute]
public static ColorMarker GetColoredMarker(Transaction tx);
    [ExtensionAttribute]
public static bool HasValidColoredMarker(Transaction tx);
    [ExtensionAttribute]
public static AssetId ToAssetId(ScriptId id);
}
public interface NBitcoin.OpenAsset.IColoredTransactionRepository {
    public ITransactionRepository Transactions { get; }
    public abstract virtual ITransactionRepository get_Transactions();
    public abstract virtual Task`1<ColoredTransaction> GetAsync(uint256 txId);
    public abstract virtual Task PutAsync(uint256 txId, ColoredTransaction tx);
}
internal class NBitcoin.OpenAsset.NoDuplicateColoredTransactionRepository : object {
    private IColoredTransactionRepository _Inner;
    private Dictionary`2<string, Task> _Tasks;
    private ReaderWriterLock lock;
    public ITransactionRepository Transactions { get; }
    public NoDuplicateColoredTransactionRepository(IColoredTransactionRepository inner);
    public sealed virtual ITransactionRepository get_Transactions();
    public sealed virtual Task`1<ColoredTransaction> GetAsync(uint256 txId);
    public sealed virtual Task PutAsync(uint256 txId, ColoredTransaction tx);
    private sealed virtual override Task`1<Transaction> NBitcoin.ITransactionRepository.GetAsync(uint256 txId);
    public sealed virtual Task PutAsync(uint256 txId, Transaction tx);
    private Task`1<T> Request(string key, Func`1<Task`1<T>> wrapped);
}
public class NBitcoin.OpenAsset.NoSqlColoredTransactionRepository : object {
    private NoSqlRepository _Repository;
    private ITransactionRepository _Transactions;
    public NoSqlRepository Repository { get; }
    public ITransactionRepository Transactions { get; }
    public NoSqlColoredTransactionRepository(ITransactionRepository transactionRepository);
    public NoSqlColoredTransactionRepository(ITransactionRepository transactionRepository, NoSqlRepository repository);
    public NoSqlRepository get_Repository();
    public sealed virtual ITransactionRepository get_Transactions();
    public sealed virtual Task`1<ColoredTransaction> GetAsync(uint256 txId);
    private static string GetId(uint256 txId);
    public sealed virtual Task PutAsync(uint256 txId, ColoredTransaction tx);
}
public class NBitcoin.OpenAsset.NullColoredTransactionRepository : object {
    private ITransactionRepository _Inner;
    public ITransactionRepository Transactions { get; }
    public NullColoredTransactionRepository(ITransactionRepository repo);
    public sealed virtual ITransactionRepository get_Transactions();
    public sealed virtual Task`1<ColoredTransaction> GetAsync(uint256 txId);
    public sealed virtual Task PutAsync(uint256 txId, ColoredTransaction tx);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NBitcoin.OutPoint : object {
    private uint256 hash;
    private UInt32 n;
    public static OutPoint Zero;
    public bool IsNull { get; }
    public uint256 Hash { get; public set; }
    public UInt32 N { get; public set; }
    public OutPoint(uint256 hashIn, UInt32 nIn);
    public OutPoint(uint256 hashIn, int nIn);
    public OutPoint(Transaction tx, UInt32 i);
    public OutPoint(Transaction tx, int i);
    public OutPoint(OutPoint outpoint);
    private static OutPoint();
    public bool get_IsNull();
    public uint256 get_Hash();
    public void set_Hash(uint256 value);
    public UInt32 get_N();
    public void set_N(UInt32 value);
    public static bool TryParse(string str, OutPoint& result);
    public static OutPoint Parse(string str);
    public sealed virtual void ReadWrite(BitcoinStream stream);
    private void SetNull();
    public static bool op_LessThan(OutPoint a, OutPoint b);
    public static bool op_GreaterThan(OutPoint a, OutPoint b);
    [NullableContextAttribute("2")]
public static bool op_Equality(OutPoint a, OutPoint b);
    [NullableContextAttribute("2")]
public static bool op_Inequality(OutPoint a, OutPoint b);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(OutPoint other);
    public virtual int GetHashCode();
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NBitcoin.OutputTooSmallException : NotEnoughFundsException {
    [CompilerGeneratedAttribute]
private ErrorType <Reason>k__BackingField;
    [CompilerGeneratedAttribute]
private Script <Destination>k__BackingField;
    [CompilerGeneratedAttribute]
private Money <Value>k__BackingField;
    public ErrorType Reason { get; }
    public Script Destination { get; }
    public Money Value { get; }
    public OutputTooSmallException(string message, string group, IMoney missing, ErrorType reason, TxOut output);
    [CompilerGeneratedAttribute]
public ErrorType get_Reason();
    [CompilerGeneratedAttribute]
public Script get_Destination();
    [CompilerGeneratedAttribute]
public Money get_Value();
}
public class NBitcoin.PartialMerkleTree : object {
    private UInt32 _TransactionCount;
    private List`1<uint256> _Hashes;
    private BitArray _Flags;
    public UInt32 TransactionCount { get; public set; }
    public List`1<uint256> Hashes { get; }
    public BitArray Flags { get; public set; }
    public PartialMerkleTree(uint256[] vTxid, Boolean[] vMatch);
    public UInt32 get_TransactionCount();
    public void set_TransactionCount(UInt32 value);
    public List`1<uint256> get_Hashes();
    public BitArray get_Flags();
    public void set_Flags(BitArray value);
    public sealed virtual void ReadWrite(BitcoinStream stream);
    private byte ToByte(bool v);
    private static void MarkNodes(MerkleNode root, Boolean[] vMatch);
    private static void MarkToTop(MerkleNode leaf, bool value);
    public MerkleNode GetMerkleRoot();
    public bool Check(uint256 expectedMerkleRootHash);
    private void BuildCore(MerkleNode node, BitWriter flags);
    public IEnumerable`1<uint256> GetMatchedTransactions();
    private IEnumerable`1<uint256> GetMatchedTransactionsCore(MerkleNode node, BitReader flags, IEnumerator`1<uint256> hashes, bool calculateHash);
    public MerkleNode TryGetMerkleRoot();
    public PartialMerkleTree Trim(uint256[] matchedTransactions);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NBitcoin.Payment.BitcoinUrlBuilder : object {
    [CompilerGeneratedAttribute]
private Network <Network>k__BackingField;
    private string scheme;
    private Dictionary`2<string, string> _UnknownParameters;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private BitcoinAddress <Address>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private Money <Amount>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <Label>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    public Network Network { get; }
    public IReadOnlyDictionary`2<string, string> UnknownParameters { get; }
    [ObsoleteAttribute("Use UnknownParameters property")]
public Dictionary`2<string, string> UnknowParameters { get; }
    [NullableAttribute("2")]
public BitcoinAddress Address { get; public set; }
    [NullableAttribute("2")]
public Money Amount { get; public set; }
    [NullableAttribute("2")]
public string Label { get; public set; }
    [NullableAttribute("2")]
public string Message { get; public set; }
    public Uri Uri { get; }
    public BitcoinUrlBuilder(Network network);
    public BitcoinUrlBuilder(Uri uri, Network network);
    public BitcoinUrlBuilder(string uri, Network network);
    [CompilerGeneratedAttribute]
public Network get_Network();
    public IReadOnlyDictionary`2<string, string> get_UnknownParameters();
    public Dictionary`2<string, string> get_UnknowParameters();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public BitcoinAddress get_Address();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_Address(BitcoinAddress value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public Money get_Amount();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_Amount(Money value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_Label();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_Label(string value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_Message();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_Message(string value);
    public Uri get_Uri();
    private static void WriteParameters(Dictionary`2<string, string> parameters, StringBuilder builder);
    public virtual string ToString();
}
internal static class NBitcoin.Payment.UriHelper : object {
    public static Dictionary`2<string, string> DecodeQueryParameters(string uri);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NBitcoin.PayToMultiSigTemplate : ScriptTemplate {
    private static PayToMultiSigTemplate _Instance;
    public static PayToMultiSigTemplate Instance { get; }
    private static PayToMultiSigTemplate();
    public static PayToMultiSigTemplate get_Instance();
    public Script GenerateScriptPubKey(int sigCount, PubKey[] keys);
    public Script GenerateScriptPubKey(int sigCount, bool sort, PubKey[] keys);
    public Script GenerateScriptPubKey(int sigCount, bool sort, bool forceSmallSigCount, PubKey[] keys);
    protected virtual bool CheckScriptPubKeyCore(Script scriptPubKey, Op[] scriptPubKeyOps);
    public PayToMultiSigTemplateParameters ExtractScriptPubKeyParameters(Script scriptPubKey);
    protected virtual bool FastCheckScriptSig(Script scriptSig, Script scriptPubKey, Boolean& needMoreCheck);
    protected virtual bool CheckScriptSigCore(Script scriptSig, Op[] scriptSigOps, Script scriptPubKey, Op[] scriptPubKeyOps);
    public TransactionSignature[] ExtractScriptSigParameters(Script scriptSig);
    public Script GenerateScriptSig(TransactionSignature[] signatures);
    public Script GenerateScriptSig(IEnumerable`1<TransactionSignature> signatures);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NBitcoin.PayToMultiSigTemplateParameters : object {
    [CompilerGeneratedAttribute]
private int <SignatureCount>k__BackingField;
    [CompilerGeneratedAttribute]
private PubKey[] <PubKeys>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[][] <InvalidPubKeys>k__BackingField;
    public int SignatureCount { get; public set; }
    public PubKey[] PubKeys { get; public set; }
    public Byte[][] InvalidPubKeys { get; public set; }
    public PayToMultiSigTemplateParameters(int signatureCount, PubKey[] pubkeys, Byte[][] invalidPubkeys);
    [CompilerGeneratedAttribute]
public int get_SignatureCount();
    [CompilerGeneratedAttribute]
public void set_SignatureCount(int value);
    [CompilerGeneratedAttribute]
public PubKey[] get_PubKeys();
    [CompilerGeneratedAttribute]
public void set_PubKeys(PubKey[] value);
    [CompilerGeneratedAttribute]
public Byte[][] get_InvalidPubKeys();
    [CompilerGeneratedAttribute]
public void set_InvalidPubKeys(Byte[][] value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NBitcoin.PayToPubkeyHashScriptSigParameters : object {
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private TransactionSignature <TransactionSignature>k__BackingField;
    [CompilerGeneratedAttribute]
private PubKey <PublicKey>k__BackingField;
    [NullableAttribute("2")]
public TransactionSignature TransactionSignature { get; public set; }
    public PubKey PublicKey { get; public set; }
    public IAddressableDestination Hash { get; }
    public Script ScriptPubKey { get; }
    public PayToPubkeyHashScriptSigParameters(TransactionSignature transactionSignature, PubKey pubKey);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public TransactionSignature get_TransactionSignature();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_TransactionSignature(TransactionSignature value);
    [CompilerGeneratedAttribute]
public PubKey get_PublicKey();
    [CompilerGeneratedAttribute]
public void set_PublicKey(PubKey value);
    public virtual IAddressableDestination get_Hash();
    public sealed virtual Script get_ScriptPubKey();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NBitcoin.PayToPubkeyHashTemplate : ScriptTemplate {
    private static PayToPubkeyHashTemplate _Instance;
    public static PayToPubkeyHashTemplate Instance { get; }
    private static PayToPubkeyHashTemplate();
    public static PayToPubkeyHashTemplate get_Instance();
    public Script GenerateScriptPubKey(BitcoinPubKeyAddress address);
    public Script GenerateScriptPubKey(PubKey pubKey);
    public Script GenerateScriptPubKey(KeyId pubkeyHash);
    public Script GenerateScriptSig(TransactionSignature signature, PubKey publicKey);
    protected virtual bool FastCheckScriptPubKey(Script scriptPubKey, Boolean& needMoreCheck);
    protected virtual bool CheckScriptPubKeyCore(Script scriptPubKey, Op[] scriptPubKeyOps);
    public KeyId ExtractScriptPubKeyParameters(Script scriptPubKey);
    protected virtual bool CheckScriptSigCore(Script scriptSig, Op[] scriptSigOps, Script scriptPubKey, Op[] scriptPubKeyOps);
    public bool CheckScriptSig(Script scriptSig);
    public PayToPubkeyHashScriptSigParameters ExtractScriptSigParameters(Script scriptSig);
    public Script GenerateScriptSig(PayToPubkeyHashScriptSigParameters parameters);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NBitcoin.PayToPubkeyTemplate : ScriptTemplate {
    private static PayToPubkeyTemplate _Instance;
    public static PayToPubkeyTemplate Instance { get; }
    private static PayToPubkeyTemplate();
    public static PayToPubkeyTemplate get_Instance();
    public Script GenerateScriptPubKey(PubKey pubkey);
    public Script GenerateScriptPubKey(Byte[] pubkey);
    protected virtual bool FastCheckScriptPubKey(Script scriptPubKey, Boolean& needMoreCheck);
    protected virtual bool CheckScriptPubKeyCore(Script scriptPubKey, Op[] scriptPubKeyOps);
    public Script GenerateScriptSig(ECDSASignature signature);
    public Script GenerateScriptSig(TransactionSignature signature);
    public TransactionSignature ExtractScriptSigParameters(Script scriptSig);
    protected virtual bool FastCheckScriptSig(Script scriptSig, Script scriptPubKey, Boolean& needMoreCheck);
    protected virtual bool CheckScriptSigCore(Script scriptSig, Op[] scriptSigOps, Script scriptPubKey, Op[] scriptPubKeyOps);
    public PubKey ExtractScriptPubKeyParameters(Script scriptPubKey);
    public PubKey ExtractScriptPubKeyParameters(Script scriptPubKey, bool deepCheck);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NBitcoin.PayToScriptHashSigParameters : object {
    [CompilerGeneratedAttribute]
private Script <RedeemScript>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[][] <Pushes>k__BackingField;
    public Script RedeemScript { get; public set; }
    public Byte[][] Pushes { get; public set; }
    public PayToScriptHashSigParameters(Script redeemScript, Byte[][] pushes);
    [CompilerGeneratedAttribute]
public Script get_RedeemScript();
    [CompilerGeneratedAttribute]
public void set_RedeemScript(Script value);
    [CompilerGeneratedAttribute]
public Byte[][] get_Pushes();
    [CompilerGeneratedAttribute]
public void set_Pushes(Byte[][] value);
    [NullableContextAttribute("2")]
public TransactionSignature[] GetMultisigSignatures();
    public PubKey[] GetMultisigPubKeys();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NBitcoin.PayToScriptHashTemplate : ScriptTemplate {
    private static PayToScriptHashTemplate _Instance;
    public static PayToScriptHashTemplate Instance { get; }
    private static PayToScriptHashTemplate();
    public static PayToScriptHashTemplate get_Instance();
    public Script GenerateScriptPubKey(ScriptId scriptId);
    public Script GenerateScriptPubKey(Script scriptPubKey);
    protected virtual bool FastCheckScriptPubKey(Script scriptPubKey, Boolean& needMoreCheck);
    protected virtual bool CheckScriptPubKeyCore(Script scriptPubKey, Op[] scriptPubKeyOps);
    public Script GenerateScriptSig(Op[] ops, Script redeemScript);
    public PayToScriptHashSigParameters ExtractScriptSigParameters(Script scriptSig);
    public PayToScriptHashSigParameters ExtractScriptSigParameters(Script scriptSig, ScriptId expectedScriptId);
    [NullableContextAttribute("2")]
public PayToScriptHashSigParameters ExtractScriptSigParameters(Script scriptSig, Script scriptPubKey);
    public Script GenerateScriptSig(Byte[][] pushes, Script redeemScript);
    public Script GenerateScriptSig(TransactionSignature[] signatures, Script redeemScript);
    public Script GenerateScriptSig(ECDSASignature[] signatures, Script redeemScript);
    protected virtual bool CheckScriptSigCore(Script scriptSig, Op[] scriptSigOps, Script scriptPubKey, Op[] scriptPubKeyOps);
    public ScriptId ExtractScriptPubKeyParameters(Script scriptPubKey);
    public Script GenerateScriptSig(PayToScriptHashSigParameters parameters);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NBitcoin.PayToTaprootScriptSigParameters : object {
    [CompilerGeneratedAttribute]
private TaprootSignature <TransactionSignature>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private Byte[] <Annex>k__BackingField;
    public TaprootSignature TransactionSignature { get; public set; }
    [NullableAttribute("2")]
public Byte[] Annex { get; public set; }
    public PayToTaprootScriptSigParameters(TaprootSignature transactionSignature, Byte[] annex);
    [CompilerGeneratedAttribute]
public TaprootSignature get_TransactionSignature();
    [CompilerGeneratedAttribute]
public void set_TransactionSignature(TaprootSignature value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public Byte[] get_Annex();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_Annex(Byte[] value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NBitcoin.PayToTaprootTemplate : ScriptTemplate {
    [NullableAttribute("2")]
private static PayToTaprootTemplate _Instance;
    public static PayToTaprootTemplate Instance { get; }
    public static PayToTaprootTemplate get_Instance();
    [ObsoleteAttribute("Use pubKey.ScriptPubKey instead")]
public Script GenerateScriptPubKey(TaprootPubKey pubKey);
    public TaprootPubKey ExtractScriptPubKeyParameters(Script scriptPubKey);
    protected virtual bool FastCheckScriptPubKey(Script scriptPubKey, Boolean& needMoreCheck);
    protected virtual bool CheckScriptPubKeyCore(Script scriptPubKey, Op[] scriptPubKeyOps);
    protected virtual bool FastCheckScriptSig(Script scriptSig, Script scriptPubKey, Boolean& needMoreCheck);
    protected virtual bool CheckScriptSigCore(Script scriptSig, Op[] scriptSigOps, Script scriptPubKey, Op[] scriptPubKeyOps);
    [ObsoleteAttribute("Use GenerateWitScript(TaprootSignature signature) instead")]
public Script GenerateScriptSig(TaprootSignature signature);
    public PayToTaprootScriptSigParameters ExtractWitScriptParameters(WitScript witScript);
    private bool CheckAnnex(Byte[] annex);
    public WitScript GenerateWitScript(TaprootSignature signature);
    public WitScript GenerateWitScript(TaprootSignature signature, Byte[] annex);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NBitcoin.PayToWitPubkeyHashScriptSigParameters : PayToPubkeyHashScriptSigParameters {
    public IAddressableDestination Hash { get; }
    public PayToWitPubkeyHashScriptSigParameters(TransactionSignature transactionSignature, PubKey pubKey);
    public virtual IAddressableDestination get_Hash();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NBitcoin.PayToWitPubKeyHashTemplate : PayToWitTemplate {
    [NullableAttribute("2")]
private static PayToWitPubKeyHashTemplate _Instance;
    public static PayToWitPubKeyHashTemplate Instance { get; }
    public static PayToWitPubKeyHashTemplate get_Instance();
    public Script GenerateScriptPubKey(PubKey pubKey);
    public Script GenerateScriptPubKey(WitKeyId pubkeyHash);
    public WitScript GenerateWitScript(TransactionSignature signature, PubKey publicKey);
    public Script GenerateScriptPubKey(BitcoinWitPubKeyAddress address);
    public virtual bool CheckScriptPubKey(Script scriptPubKey);
    public WitKeyId ExtractScriptPubKeyParameters(Script scriptPubKey);
    public PayToWitPubkeyHashScriptSigParameters ExtractWitScriptParameters(WitScript witScript);
    private bool CheckWitScriptCore(WitScript witScript);
    public WitScript GenerateWitScript(PayToWitPubkeyHashScriptSigParameters parameters);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NBitcoin.PayToWitScriptHashTemplate : PayToWitTemplate {
    [NullableAttribute("2")]
private static PayToWitScriptHashTemplate _Instance;
    public static PayToWitScriptHashTemplate Instance { get; }
    public static PayToWitScriptHashTemplate get_Instance();
    public Script GenerateScriptPubKey(WitScriptId scriptHash);
    public WitScript GenerateWitScript(Script scriptSig, Script redeemScript);
    public WitScript GenerateWitScript(Op[] scriptSig, Script redeemScript);
    public Script GenerateScriptPubKey(BitcoinWitScriptAddress address);
    public virtual bool CheckScriptPubKey(Script scriptPubKey);
    public WitScriptId ExtractScriptPubKeyParameters(Script scriptPubKey);
    [NullableContextAttribute("2")]
public Script ExtractWitScriptParameters(WitScript witScript, WitScriptId expectedScriptId);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NBitcoin.PayToWitTemplate : ScriptTemplate {
    [NullableAttribute("2")]
private static PayToWitTemplate _Instance;
    public static PayToWitTemplate Instance { get; }
    public static PayToWitTemplate get_Instance();
    public Script GenerateScriptPubKey(OpcodeType segWitVersion, Byte[] data);
    public virtual bool CheckScriptSig(Script scriptSig, Script scriptPubKey);
    public virtual bool CheckScriptPubKey(Script scriptPubKey);
    public static bool ValidSegwitVersion(byte version);
    public IAddressableDestination ExtractScriptPubKeyParameters(Script scriptPubKey);
    public WitProgramParameters ExtractScriptPubKeyParameters2(Script scriptPubKey);
    protected virtual bool CheckScriptPubKeyCore(Script scriptPubKey, Op[] scriptPubKeyOps);
    protected virtual bool CheckScriptSigCore(Script scriptSig, Op[] scriptSigOps, Script scriptPubKey, Op[] scriptPubKeyOps);
}
public class NBitcoin.PerformanceCounter : object {
    private long _WrittenBytes;
    private long _ReadenBytes;
    private DateTime _Start;
    public long WrittenBytes { get; }
    public long ReadenBytes { get; }
    public DateTime Start { get; }
    public TimeSpan Elapsed { get; }
    public long get_WrittenBytes();
    public void AddWritten(long count);
    public void AddReaden(long count);
    public long get_ReadenBytes();
    public PerformanceSnapshot Snapshot();
    public DateTime get_Start();
    public TimeSpan get_Elapsed();
    public virtual string ToString();
    internal void Add(PerformanceCounter counter);
}
public class NBitcoin.PerformanceSnapshot : object {
    private long _TotalWrittenBytes;
    private long _TotalReadenBytes;
    [CompilerGeneratedAttribute]
private DateTime <Start>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <Taken>k__BackingField;
    public long TotalWrittenBytes { get; }
    public long TotalReadenBytes { get; public set; }
    public TimeSpan Elapsed { get; }
    public ulong ReadenBytesPerSecond { get; }
    public ulong WrittenBytesPerSecond { get; }
    public DateTime Start { get; public set; }
    public DateTime Taken { get; public set; }
    public PerformanceSnapshot(long readen, long written);
    public long get_TotalWrittenBytes();
    public long get_TotalReadenBytes();
    public void set_TotalReadenBytes(long value);
    public TimeSpan get_Elapsed();
    public ulong get_ReadenBytesPerSecond();
    public ulong get_WrittenBytesPerSecond();
    public static PerformanceSnapshot op_Subtraction(PerformanceSnapshot end, PerformanceSnapshot start);
    public virtual string ToString();
    private string ToKBSec(ulong bytesPerSec);
    [CompilerGeneratedAttribute]
public DateTime get_Start();
    [CompilerGeneratedAttribute]
public void set_Start(DateTime value);
    [CompilerGeneratedAttribute]
public DateTime get_Taken();
    [CompilerGeneratedAttribute]
public void set_Taken(DateTime value);
}
public class NBitcoin.Policy.DuplicateInputPolicyError : TransactionPolicyError {
    private OutPoint _OutPoint;
    private UInt32[] _InputIndices;
    public OutPoint OutPoint { get; }
    public UInt32[] InputIndices { get; }
    public DuplicateInputPolicyError(IndexedTxIn[] duplicated);
    public OutPoint get_OutPoint();
    public UInt32[] get_InputIndices();
}
public class NBitcoin.Policy.DustPolicyError : TransactionPolicyError {
    private Money _Value;
    private Money _DustThreshold;
    public Money Value { get; }
    public Money DustThreshold { get; }
    public DustPolicyError(Money value, Money dust);
    public Money get_Value();
    public Money get_DustThreshold();
}
public class NBitcoin.Policy.FeeTooHighPolicyError : TransactionPolicyError {
    private Money _Fee;
    private Money _ExpectedMaxFee;
    public Money Fee { get; }
    public Money ExpectedMaxFee { get; }
    public FeeTooHighPolicyError(Money fees, Money max);
    public Money get_Fee();
    public Money get_ExpectedMaxFee();
}
public class NBitcoin.Policy.FeeTooLowPolicyError : TransactionPolicyError {
    private Money _Fee;
    private Money _ExpectedMinFee;
    public Money Fee { get; }
    public Money ExpectedMinFee { get; }
    public FeeTooLowPolicyError(Money fees, Money min);
    public Money get_Fee();
    public Money get_ExpectedMinFee();
}
public class NBitcoin.Policy.InputPolicyError : TransactionPolicyError {
    private OutPoint _OutPoint;
    private UInt32 _InputIndex;
    public OutPoint OutPoint { get; }
    public UInt32 InputIndex { get; }
    public InputPolicyError(string message, IndexedTxIn txIn);
    public OutPoint get_OutPoint();
    public UInt32 get_InputIndex();
}
public interface NBitcoin.Policy.ITransactionPolicy {
    public abstract virtual TransactionPolicyError[] Check(Transaction transaction, ICoin[] spentCoins);
}
public class NBitcoin.Policy.MinerTransactionPolicy : object {
    private static MinerTransactionPolicy _Instance;
    public static MinerTransactionPolicy Instance { get; }
    private static MinerTransactionPolicy();
    public static MinerTransactionPolicy get_Instance();
    public sealed virtual TransactionPolicyError[] Check(Transaction transaction, ICoin[] spentCoins);
    public TransactionPolicyError[] Check(TransactionValidator validator);
}
public class NBitcoin.Policy.NotEnoughFundsPolicyError : TransactionPolicyError {
    [CompilerGeneratedAttribute]
private IMoney <Missing>k__BackingField;
    public IMoney Missing { get; private set; }
    public NotEnoughFundsPolicyError(string message, IMoney missing);
    public NotEnoughFundsPolicyError(string message);
    private static string BuildMessage(string message, IMoney missing);
    [CompilerGeneratedAttribute]
public IMoney get_Missing();
    [CompilerGeneratedAttribute]
private void set_Missing(IMoney value);
    internal Exception AsException();
}
public class NBitcoin.Policy.OutputPolicyError : TransactionPolicyError {
    private int _OutputIndex;
    public int OutputIndex { get; }
    public OutputPolicyError(string message, int outputIndex);
    public int get_OutputIndex();
}
public class NBitcoin.Policy.ScriptPolicyError : InputPolicyError {
    private ScriptError _ScriptError;
    private ScriptVerify _ScriptVerify;
    private Script _ScriptPubKey;
    public ScriptError ScriptError { get; }
    public ScriptVerify ScriptVerify { get; }
    public Script ScriptPubKey { get; }
    public ScriptPolicyError(IndexedTxIn input, ScriptError error, ScriptVerify scriptVerify, Script scriptPubKey);
    public ScriptError get_ScriptError();
    public ScriptVerify get_ScriptVerify();
    public Script get_ScriptPubKey();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class NBitcoin.Policy.StandardTransactionPolicy : object {
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MaxTransactionSize>k__BackingField;
    [CompilerGeneratedAttribute]
private FeeRate <MaxTxFee>k__BackingField;
    [CompilerGeneratedAttribute]
private FeeRate <MinRelayTxFee>k__BackingField;
    [CompilerGeneratedAttribute]
private Money <MinFee>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<ScriptVerify> <ScriptVerify>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CheckFee>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseConsensusLib>k__BackingField;
    public static int MaxScriptSigLength;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private StandardTransactionPolicyStrategy <Strategy>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CheckScriptPubKey>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CheckDust>k__BackingField;
    public Nullable`1<int> MaxTransactionSize { get; public set; }
    public FeeRate MaxTxFee { get; public set; }
    public FeeRate MinRelayTxFee { get; public set; }
    public Money MinFee { get; public set; }
    public Nullable`1<ScriptVerify> ScriptVerify { get; public set; }
    public bool CheckFee { get; public set; }
    public bool UseConsensusLib { get; public set; }
    [NullableAttribute("1")]
public StandardTransactionPolicyStrategy Strategy { get; public set; }
    public bool CheckScriptPubKey { get; public set; }
    public bool CheckDust { get; public set; }
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_MaxTransactionSize();
    [CompilerGeneratedAttribute]
public void set_MaxTransactionSize(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public FeeRate get_MaxTxFee();
    [CompilerGeneratedAttribute]
public void set_MaxTxFee(FeeRate value);
    [CompilerGeneratedAttribute]
public FeeRate get_MinRelayTxFee();
    [CompilerGeneratedAttribute]
public void set_MinRelayTxFee(FeeRate value);
    [CompilerGeneratedAttribute]
public Money get_MinFee();
    [CompilerGeneratedAttribute]
public void set_MinFee(Money value);
    [CompilerGeneratedAttribute]
public Nullable`1<ScriptVerify> get_ScriptVerify();
    [CompilerGeneratedAttribute]
public void set_ScriptVerify(Nullable`1<ScriptVerify> value);
    [CompilerGeneratedAttribute]
public bool get_CheckFee();
    [CompilerGeneratedAttribute]
public void set_CheckFee(bool value);
    [CompilerGeneratedAttribute]
public bool get_UseConsensusLib();
    [CompilerGeneratedAttribute]
public void set_UseConsensusLib(bool value);
    [NullableContextAttribute("1")]
public sealed virtual TransactionPolicyError[] Check(Transaction transaction, ICoin[] spentCoins);
    [NullableContextAttribute("1")]
public TransactionPolicyError[] Check(TransactionValidator validator);
    [NullableContextAttribute("1")]
private static bool IsOpReturn(Byte[] bytes);
    [NullableContextAttribute("1")]
private bool VerifyScript(TransactionValidator validator, int inputIndex, Nullable`1& error);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public StandardTransactionPolicyStrategy get_Strategy();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public void set_Strategy(StandardTransactionPolicyStrategy value);
    [NullableContextAttribute("1")]
public StandardTransactionPolicy Clone();
    [CompilerGeneratedAttribute]
public bool get_CheckScriptPubKey();
    [CompilerGeneratedAttribute]
public void set_CheckScriptPubKey(bool value);
    [CompilerGeneratedAttribute]
public bool get_CheckDust();
    [CompilerGeneratedAttribute]
public void set_CheckDust(bool value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NBitcoin.Policy.StandardTransactionPolicyStrategy : object {
    [CompilerGeneratedAttribute]
private static StandardTransactionPolicyStrategy <Instance>k__BackingField;
    public static StandardTransactionPolicyStrategy Instance { get; }
    private static StandardTransactionPolicyStrategy();
    [CompilerGeneratedAttribute]
public static StandardTransactionPolicyStrategy get_Instance();
    public virtual bool IsStandardOutput(TxOut txout);
}
public class NBitcoin.Policy.TransactionPolicyError : object {
    private string _Message;
    public TransactionPolicyError(string message);
    public virtual string ToString();
}
public class NBitcoin.Policy.TransactionSizePolicyError : TransactionPolicyError {
    private int _ActualSize;
    private int _MaximumSize;
    public int ActualSize { get; }
    public int MaximumSize { get; }
    public TransactionSizePolicyError(int actualSize, int maximumSize);
    public int get_ActualSize();
    public int get_MaximumSize();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NBitcoin.PrecomputedTransactionData : object {
    [CompilerGeneratedAttribute]
private uint256 <HashPrevouts>k__BackingField;
    [CompilerGeneratedAttribute]
private uint256 <HashSequence>k__BackingField;
    [CompilerGeneratedAttribute]
private uint256 <HashOutputs>k__BackingField;
    public uint256 HashPrevouts { get; public set; }
    public uint256 HashSequence { get; public set; }
    public uint256 HashOutputs { get; public set; }
    public PrecomputedTransactionData(Transaction tx);
    [CompilerGeneratedAttribute]
public uint256 get_HashPrevouts();
    [CompilerGeneratedAttribute]
public void set_HashPrevouts(uint256 value);
    [CompilerGeneratedAttribute]
public uint256 get_HashSequence();
    [CompilerGeneratedAttribute]
public void set_HashSequence(uint256 value);
    [CompilerGeneratedAttribute]
public uint256 get_HashOutputs();
    [CompilerGeneratedAttribute]
public void set_HashOutputs(uint256 value);
}
public class NBitcoin.Protocol.AddressManager : object {
    private static byte V0_HISTORICAL;
    private static byte V1_DETERMINISTIC;
    private static byte V2_ASMAP;
    private static byte V3_BIP155;
    [CompilerGeneratedAttribute]
private IDnsResolver <DnsResolver>k__BackingField;
    internal static int ADDRMAN_TRIED_BUCKET_COUNT;
    internal static int ADDRMAN_NEW_BUCKET_COUNT;
    internal static int ADDRMAN_BUCKET_SIZE;
    internal static int ADDRMAN_TRIED_BUCKETS_PER_GROUP;
    internal static int ADDRMAN_NEW_BUCKETS_PER_SOURCE_GROUP;
    private static int ADDRMAN_NEW_BUCKETS_PER_ADDRESS;
    internal static int ADDRMAN_HORIZON_DAYS;
    internal static int ADDRMAN_RETRIES;
    internal static int ADDRMAN_MAX_FAILURES;
    internal static int ADDRMAN_MIN_FAIL_DAYS;
    private static int ADDRMAN_GETADDR_MAX_PCT;
    private static int ADDRMAN_GETADDR_MAX;
    private byte nVersion;
    private byte nKeySize;
    internal uint256 nKey;
    internal int nNew;
    internal int nTried;
    private List`1<int> vRandom;
    private Int32[0...,0...] vvNew;
    private Int32[0...,0...] vvTried;
    private int _DiscoveredPeers;
    [CompilerGeneratedAttribute]
private int <NeededPeers>k__BackingField;
    private Dictionary`2<int, AddressInfo> mapInfo;
    private Dictionary`2<string, int> mapAddr;
    private int nIdCount;
    private object cs;
    [CompilerGeneratedAttribute]
private bool <DebugMode>k__BackingField;
    public IDnsResolver DnsResolver { get; public set; }
    public int DiscoveredPeers { get; }
    public int NeededPeers { get; private set; }
    internal bool DebugMode { get; internal set; }
    public int Count { get; }
    [CompilerGeneratedAttribute]
public IDnsResolver get_DnsResolver();
    [CompilerGeneratedAttribute]
public void set_DnsResolver(IDnsResolver value);
    public Task AddAsync(EndPoint endpoint, IPAddress source);
    [AsyncStateMachineAttribute("NBitcoin.Protocol.AddressManager/<AddAsync>d__9")]
public Task AddAsync(EndPoint endpoint, IPAddress source, CancellationToken cancellationToken);
    public static AddressManager LoadPeerFile(string filePath, Network expectedNetwork);
    public void SavePeerFile(string filePath, Network network);
    private AddressInfo Find(NetworkAddress addr);
    private AddressInfo Find(NetworkAddress addr, Int32& pnId);
    private void Clear();
    public int get_DiscoveredPeers();
    [CompilerGeneratedAttribute]
public int get_NeededPeers();
    [CompilerGeneratedAttribute]
private void set_NeededPeers(int value);
    public sealed virtual void ReadWrite(BitcoinStream stream);
    public bool Add(NetworkAddress addr, IPAddress source);
    public bool Add(NetworkAddress addr);
    public bool Add(NetworkAddress addr, IPAddress source, TimeSpan nTimePenalty);
    public bool Add(IEnumerable`1<NetworkAddress> vAddr, IPAddress source);
    public bool Add(IEnumerable`1<NetworkAddress> vAddr, IPAddress source, TimeSpan nTimePenalty);
    private bool Add_(NetworkAddress addr, IPAddress source, TimeSpan nTimePenalty);
    private void ClearNew(int nUBucket, int nUBucketPos);
    private void Delete(int nId);
    private void SwapRandom(int nRndPos1, int nRndPos2);
    private AddressInfo Create(NetworkAddress addr, IPAddress addrSource, Int32& pnId);
    [CompilerGeneratedAttribute]
internal bool get_DebugMode();
    [CompilerGeneratedAttribute]
internal void set_DebugMode(bool value);
    internal void Check();
    private int Check_();
    public void Good(NetworkAddress addr);
    public void Good(NetworkAddress addr, DateTimeOffset nTime);
    private void Good_(NetworkAddress addr, DateTimeOffset nTime);
    private void MakeTried(AddressInfo info, int nId);
    private static void assert(bool value);
    public void Attempt(NetworkAddress addr);
    public void Attempt(NetworkAddress addr, DateTimeOffset nTime);
    private void Attempt_(NetworkAddress addr, DateTimeOffset nTime);
    public void Connected(NetworkAddress addr);
    public void Connected(NetworkAddress addr, DateTimeOffset nTime);
    private void Connected_(NetworkAddress addr, DateTimeOffset nTime);
    public NetworkAddress Select();
    private AddressInfo Select_();
    private static int GetRandInt(int max);
    public NetworkAddress[] GetAddr();
    private IEnumerable`1<NetworkAddress> GetAddr_();
    public int get_Count();
    internal void DiscoverPeers(Network network, NodeConnectionParameters parameters, int peerToFind);
    [AsyncStateMachineAttribute("NBitcoin.Protocol.AddressManager/<PopulateTableWithDNSNodes>d__84")]
private Task PopulateTableWithDNSNodes(Network network, List`1<NetworkAddress> peers, CancellationToken cancellationToken);
    private static void PopulateTableWithHardNodes(Network network, List`1<NetworkAddress> peers);
}
public class NBitcoin.Protocol.AddrPayload : Payload {
    private NetworkAddress[] addr_list;
    public string Command { get; }
    public NetworkAddress[] Addresses { get; }
    public AddrPayload(NetworkAddress address);
    public AddrPayload(NetworkAddress[] addresses);
    public virtual string get_Command();
    public NetworkAddress[] get_Addresses();
    public virtual void ReadWriteCore(BitcoinStream stream);
    public virtual string ToString();
}
public class NBitcoin.Protocol.AddrV2Payload : AddrPayload {
    public string Command { get; }
    public AddrV2Payload(NetworkAddress address);
    public AddrV2Payload(NetworkAddress[] addresses);
    public virtual string get_Command();
    public virtual void ReadWriteCore(BitcoinStream stream);
}
public class NBitcoin.Protocol.Behaviors.AddressManagerBehavior : NodeBehavior {
    private int _PeersToDiscover;
    [CompilerGeneratedAttribute]
private AddressManagerBehaviorMode <Mode>k__BackingField;
    private AddressManager _AddressManager;
    public int PeersToDiscover { get; public set; }
    public AddressManagerBehaviorMode Mode { get; public set; }
    public AddressManager AddressManager { get; public set; }
    public AddressManagerBehavior(AddressManager manager);
    public static AddressManager GetAddrman(Node node);
    public static AddressManager GetAddrman(NodeConnectionParameters parameters);
    public static AddressManager GetAddrman(NodeBehaviorsCollection behaviors);
    public static void SetAddrman(Node node, AddressManager addrman);
    public static void SetAddrman(NodeConnectionParameters parameters, AddressManager addrman);
    public int get_PeersToDiscover();
    public void set_PeersToDiscover(int value);
    public static void SetAddrman(NodeBehaviorsCollection behaviors, AddressManager addrman);
    [CompilerGeneratedAttribute]
public AddressManagerBehaviorMode get_Mode();
    [CompilerGeneratedAttribute]
public void set_Mode(AddressManagerBehaviorMode value);
    public AddressManager get_AddressManager();
    public void set_AddressManager(AddressManager value);
    protected virtual void AttachCore();
    private void AttachedNode_MessageReceived(Node node, IncomingMessage message);
    private void AttachedNode_StateChanged(Node node, NodeState oldState);
    protected virtual void DetachCore();
    public virtual object Clone();
    internal void DiscoverPeers(Network network, NodeConnectionParameters parameters);
}
[FlagsAttribute]
public enum NBitcoin.Protocol.Behaviors.AddressManagerBehaviorMode : Enum {
    public int value__;
    public static AddressManagerBehaviorMode None;
    public static AddressManagerBehaviorMode Advertize;
    public static AddressManagerBehaviorMode Discover;
    public static AddressManagerBehaviorMode AdvertizeDiscover;
}
public class NBitcoin.Protocol.Behaviors.BroadcastHub : object {
    internal ConcurrentDictionary`2<uint256, Transaction> BroadcastedTransaction;
    internal ConcurrentDictionary`2<Node, Node> Nodes;
    [CompilerGeneratedAttribute]
private TransactionBroadcastedDelegate TransactionBroadcasted;
    [CompilerGeneratedAttribute]
private bool <ManualBroadcast>k__BackingField;
    public IEnumerable`1<Transaction> BroadcastingTransactions { get; }
    public bool ManualBroadcast { get; public set; }
    public static BroadcastHub GetBroadcastHub(Node node);
    public static BroadcastHub GetBroadcastHub(NodeConnectionParameters parameters);
    public static BroadcastHub GetBroadcastHub(NodeBehaviorsCollection behaviors);
    [CompilerGeneratedAttribute]
public void add_TransactionBroadcasted(TransactionBroadcastedDelegate value);
    [CompilerGeneratedAttribute]
public void remove_TransactionBroadcasted(TransactionBroadcastedDelegate value);
    public IEnumerable`1<Transaction> get_BroadcastingTransactions();
    internal void OnBroadcastTransaction(Transaction transaction);
    internal void OnTransactionBroadcasted(Transaction tx);
    public Task`1<bool> BroadcastTransactionAsync(Transaction transaction);
    [CompilerGeneratedAttribute]
public bool get_ManualBroadcast();
    [CompilerGeneratedAttribute]
public void set_ManualBroadcast(bool value);
    public void BroadcastTransactions();
    public BroadcastHubBehavior CreateBehavior();
}
public class NBitcoin.Protocol.Behaviors.BroadcastHubBehavior : NodeBehavior {
    private ConcurrentDictionary`2<uint256, TransactionBroadcast> _HashToTransaction;
    private ConcurrentDictionary`2<ulong, TransactionBroadcast> _PingToTransaction;
    private BroadcastHub _BroadcastHub;
    private Timer _Flush;
    public BroadcastHub BroadcastHub { get; }
    public IEnumerable`1<TransactionBroadcast> Broadcasts { get; }
    public BroadcastHubBehavior(BroadcastHub hub);
    public BroadcastHub get_BroadcastHub();
    private TransactionBroadcast GetTransaction(uint256 hash, bool remove);
    private TransactionBroadcast GetTransaction(ulong pingValue, bool remove);
    private void AttachedNode_StateChanged(Node node, NodeState oldState);
    internal void AnnounceAll(bool force);
    internal void BroadcastTransactionCore(Transaction transaction);
    internal void Announce(TransactionBroadcast tx, uint256 hash, bool force);
    protected virtual void AttachCore();
    protected virtual void DetachCore();
    private void AttachedNode_MessageReceived(Node node, IncomingMessage message);
    public virtual object Clone();
    public IEnumerable`1<TransactionBroadcast> get_Broadcasts();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private void <AttachCore>b__14_0(object o);
}
public enum NBitcoin.Protocol.Behaviors.BroadcastState : Enum {
    public int value__;
    public static BroadcastState NotSent;
    public static BroadcastState Announced;
    public static BroadcastState Broadcasted;
    public static BroadcastState Rejected;
    public static BroadcastState Accepted;
}
public class NBitcoin.Protocol.Behaviors.ChainBehavior : NodeBehavior {
    private State _State;
    [CompilerGeneratedAttribute]
private bool <StripHeader>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SkipPoWCheck>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CanSync>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CanRespondToGetHeaders>k__BackingField;
    private ConcurrentChain _Chain;
    private int _SynchingCount;
    private Timer _Refresh;
    [CompilerGeneratedAttribute]
private bool <AutoSync>k__BackingField;
    private ChainedBlock _PendingTip;
    private bool invalidHeaderReceived;
    public bool StripHeader { get; public set; }
    public bool SkipPoWCheck { get; public set; }
    public State SharedState { get; }
    public bool CanSync { get; public set; }
    public bool CanRespondToGetHeaders { get; public set; }
    public ConcurrentChain Chain { get; public set; }
    internal bool Synching { get; }
    public bool AutoSync { get; public set; }
    public bool InvalidHeaderReceived { get; }
    public ChainedBlock PendingTip { get; }
    public ChainBehavior(ConcurrentChain chain);
    [CompilerGeneratedAttribute]
public bool get_StripHeader();
    [CompilerGeneratedAttribute]
public void set_StripHeader(bool value);
    [CompilerGeneratedAttribute]
public bool get_SkipPoWCheck();
    [CompilerGeneratedAttribute]
public void set_SkipPoWCheck(bool value);
    public State get_SharedState();
    [CompilerGeneratedAttribute]
public bool get_CanSync();
    [CompilerGeneratedAttribute]
public void set_CanSync(bool value);
    [CompilerGeneratedAttribute]
public bool get_CanRespondToGetHeaders();
    [CompilerGeneratedAttribute]
public void set_CanRespondToGetHeaders(bool value);
    public ConcurrentChain get_Chain();
    public void set_Chain(ConcurrentChain value);
    internal bool get_Synching();
    protected virtual void AttachCore();
    private void Intercept(IncomingMessage message, Action act);
    public bool CheckAnnouncedBlocks();
    [CompilerGeneratedAttribute]
public bool get_AutoSync();
    [CompilerGeneratedAttribute]
public void set_AutoSync(bool value);
    public bool get_InvalidHeaderReceived();
    private void AttachedNode_StateChanged(Node node, NodeState oldState);
    public void TrySync();
    private ChainedBlock GetPendingTipOrChainTip();
    public ChainedBlock get_PendingTip();
    protected virtual void DetachCore();
    public virtual object Clone();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private void <AttachCore>b__28_0(object o);
    [CompilerGeneratedAttribute]
private bool <Intercept>b__29_0(InventoryVector i);
}
public interface NBitcoin.Protocol.Behaviors.INodeBehavior {
    public Node AttachedNode { get; }
    public abstract virtual Node get_AttachedNode();
    public abstract virtual void Attach(Node node);
    public abstract virtual void Detach();
    public abstract virtual INodeBehavior Clone();
}
public abstract class NBitcoin.Protocol.Behaviors.NodeBehavior : object {
    private List`1<IDisposable> _Disposables;
    [CompilerGeneratedAttribute]
private Node <AttachedNode>k__BackingField;
    private object cs;
    public Node AttachedNode { get; private set; }
    protected void RegisterDisposable(IDisposable disposable);
    [CompilerGeneratedAttribute]
public sealed virtual Node get_AttachedNode();
    [CompilerGeneratedAttribute]
private void set_AttachedNode(Node value);
    public sealed virtual void Attach(Node node);
    protected void AssertNotAttached();
    private static bool Disconnected(Node node);
    protected abstract virtual void AttachCore();
    public sealed virtual void Detach();
    protected abstract virtual void DetachCore();
    public abstract virtual object Clone();
    private sealed virtual override INodeBehavior NBitcoin.Protocol.Behaviors.INodeBehavior.Clone();
}
public class NBitcoin.Protocol.Behaviors.NodeBehaviorsCollection : ThreadSafeCollection`1<INodeBehavior> {
    private Node _Node;
    private bool _DelayAttach;
    private bool CanAttach { get; }
    internal bool DelayAttach { get; internal set; }
    public NodeBehaviorsCollection(Node node);
    private bool get_CanAttach();
    protected virtual void OnAdding(INodeBehavior obj);
    protected virtual void OnRemoved(INodeBehavior obj);
    internal bool get_DelayAttach();
    internal void set_DelayAttach(bool value);
}
internal class NBitcoin.Protocol.Behaviors.NodesGroupBehavior : NodeBehavior {
    internal NodesGroup _Parent;
    public NodesGroupBehavior(NodesGroup parent);
    protected virtual void AttachCore();
    protected virtual void DetachCore();
    private void AttachedNode_StateChanged(Node node, NodeState oldState);
    public virtual object Clone();
}
public class NBitcoin.Protocol.Behaviors.PingPongBehavior : NodeBehavior {
    private PingPongMode _Mode;
    private TimeSpan _TimeoutInterval;
    private TimeSpan _PingInterval;
    private object cs;
    private Timer _PingTimeoutTimer;
    private PingPayload modreq(System.Runtime.CompilerServices.IsVolatile) _CurrentPing;
    private DateTimeOffset _DateSent;
    [CompilerGeneratedAttribute]
private TimeSpan <Latency>k__BackingField;
    public PingPongMode Mode { get; public set; }
    public TimeSpan TimeoutInterval { get; public set; }
    public TimeSpan PingInterval { get; public set; }
    public TimeSpan Latency { get; private set; }
    public PingPongMode get_Mode();
    public void set_Mode(PingPongMode value);
    public TimeSpan get_TimeoutInterval();
    public void set_TimeoutInterval(TimeSpan value);
    public TimeSpan get_PingInterval();
    public void set_PingInterval(TimeSpan value);
    protected virtual void AttachCore();
    private bool PingVersion();
    private void AttachedNode_StateChanged(Node node, NodeState oldState);
    private void Ping(object unused);
    public void Probe();
    private void PingTimeout(object ping);
    [CompilerGeneratedAttribute]
public TimeSpan get_Latency();
    [CompilerGeneratedAttribute]
private void set_Latency(TimeSpan value);
    private void AttachedNode_MessageReceived(Node node, IncomingMessage message);
    private void ClearCurrentPing();
    protected virtual void DetachCore();
    public virtual object Clone();
}
[FlagsAttribute]
public enum NBitcoin.Protocol.Behaviors.PingPongMode : Enum {
    public int value__;
    public static PingPongMode SendPing;
    public static PingPongMode RespondPong;
    public static PingPongMode Both;
}
public class NBitcoin.Protocol.Behaviors.SlimChainBehavior : NodeBehavior {
    private SlimChain _Chain;
    private Timer _Refresh;
    public SlimChain Chain { get; }
    public SlimChainBehavior(SlimChain chain);
    public SlimChain get_Chain();
    public virtual object Clone();
    protected virtual void AttachCore();
    private void Intercept(IncomingMessage message, Action act);
    private bool AddToChain(BlockHeader blockHeader);
    private void TrySync();
    private void AttachedNode_StateChanged(Node node, NodeState oldState);
    protected virtual void DetachCore();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private void <AttachCore>b__6_0(object o);
}
public class NBitcoin.Protocol.Behaviors.SocksSettingsBehavior : NodeBehavior {
    [CompilerGeneratedAttribute]
private EndPoint <SocksEndpoint>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <OnlyForOnionHosts>k__BackingField;
    [CompilerGeneratedAttribute]
private NetworkCredential <NetworkCredential>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <StreamIsolation>k__BackingField;
    public EndPoint SocksEndpoint { get; public set; }
    public bool OnlyForOnionHosts { get; public set; }
    public NetworkCredential NetworkCredential { get; public set; }
    public bool StreamIsolation { get; public set; }
    public SocksSettingsBehavior(EndPoint socksEndpoint);
    public SocksSettingsBehavior(EndPoint socksEndpoint, bool onlyForOnionHosts);
    public SocksSettingsBehavior(EndPoint socksEndpoint, bool onlyForOnionHosts, NetworkCredential networkCredential, bool streamIsolation);
    [CompilerGeneratedAttribute]
public EndPoint get_SocksEndpoint();
    [CompilerGeneratedAttribute]
public void set_SocksEndpoint(EndPoint value);
    [CompilerGeneratedAttribute]
public bool get_OnlyForOnionHosts();
    [CompilerGeneratedAttribute]
public void set_OnlyForOnionHosts(bool value);
    [CompilerGeneratedAttribute]
public NetworkCredential get_NetworkCredential();
    [CompilerGeneratedAttribute]
public void set_NetworkCredential(NetworkCredential value);
    [CompilerGeneratedAttribute]
public bool get_StreamIsolation();
    [CompilerGeneratedAttribute]
public void set_StreamIsolation(bool value);
    internal NetworkCredential GetCredentials();
    public DnsSocksResolver CreateDnsResolver();
    private NetworkCredential GenerateCredentials();
    public virtual object Clone();
    protected virtual void AttachCore();
    protected virtual void DetachCore();
}
public class NBitcoin.Protocol.Behaviors.TransactionBroadcast : object {
    [CompilerGeneratedAttribute]
private BroadcastState <State>k__BackingField;
    [CompilerGeneratedAttribute]
private Transaction <Transaction>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <PingValue>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <AnnouncedTime>k__BackingField;
    public BroadcastState State { get; internal set; }
    public Transaction Transaction { get; internal set; }
    internal ulong PingValue { get; internal set; }
    public DateTime AnnouncedTime { get; internal set; }
    [CompilerGeneratedAttribute]
public BroadcastState get_State();
    [CompilerGeneratedAttribute]
internal void set_State(BroadcastState value);
    [CompilerGeneratedAttribute]
public Transaction get_Transaction();
    [CompilerGeneratedAttribute]
internal void set_Transaction(Transaction value);
    [CompilerGeneratedAttribute]
internal ulong get_PingValue();
    [CompilerGeneratedAttribute]
internal void set_PingValue(ulong value);
    [CompilerGeneratedAttribute]
public DateTime get_AnnouncedTime();
    [CompilerGeneratedAttribute]
internal void set_AnnouncedTime(DateTime value);
}
public class NBitcoin.Protocol.Behaviors.TransactionBroadcastedDelegate : MulticastDelegate {
    public TransactionBroadcastedDelegate(object object, IntPtr method);
    public virtual void Invoke(Transaction transaction);
    public virtual IAsyncResult BeginInvoke(Transaction transaction, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public abstract class NBitcoin.Protocol.BitcoinSerializablePayload`1 : Payload {
    private T _Object;
    public T Object { get; public set; }
    public BitcoinSerializablePayload`1(T obj);
    public T get_Object();
    public void set_Object(T value);
    public virtual void ReadWriteCore(BitcoinStream stream);
}
public class NBitcoin.Protocol.BlockPayload : BitcoinSerializablePayload`1<Block> {
    public string Command { get; }
    public BlockPayload(Block block);
    public virtual string get_Command();
}
public class NBitcoin.Protocol.BlockTxnPayload : Payload {
    private uint256 _BlockId;
    private List`1<Transaction> _Transactions;
    public string Command { get; }
    public uint256 BlockId { get; public set; }
    public List`1<Transaction> Transactions { get; }
    public virtual string get_Command();
    public uint256 get_BlockId();
    public void set_BlockId(uint256 value);
    public List`1<Transaction> get_Transactions();
    public virtual void ReadWriteCore(BitcoinStream stream);
}
public class NBitcoin.Protocol.CmpctBlockPayload : Payload {
    private BlockHeader _Header;
    private ulong _Nonce;
    private List`1<ulong> _ShortIds;
    private List`1<PrefilledTransaction> _PrefilledTransactions;
    private ulong _ShortTxidk0;
    private ulong _ShortTxidk1;
    public string Command { get; }
    public BlockHeader Header { get; public set; }
    public ulong Nonce { get; public set; }
    public List`1<ulong> ShortIds { get; }
    public List`1<PrefilledTransaction> PrefilledTransactions { get; }
    public CmpctBlockPayload(Block block);
    public virtual string get_Command();
    public BlockHeader get_Header();
    public void set_Header(BlockHeader value);
    public ulong get_Nonce();
    public void set_Nonce(ulong value);
    public List`1<ulong> get_ShortIds();
    public List`1<PrefilledTransaction> get_PrefilledTransactions();
    public virtual void ReadWriteCore(BitcoinStream stream);
    private void UpdateShortTxIDSelector();
    public ulong AddTransactionShortId(Transaction tx);
    public ulong AddTransactionShortId(uint256 txId);
    public ulong GetShortID(uint256 txId);
}
public class NBitcoin.Protocol.CompactFilterCheckPointPayload : Payload {
    protected byte _FilterType;
    protected uint256 _StopHash;
    protected List`1<uint256> _FilterHeaders;
    public string Command { get; }
    public FilterType FilterType { get; internal set; }
    public uint256 StopHash { get; public set; }
    public List`1<uint256> FilterHeaders { get; public set; }
    public CompactFilterCheckPointPayload(FilterType filterType, uint256 stopHash, List`1<uint256> filterHeaders);
    public virtual string get_Command();
    public FilterType get_FilterType();
    internal void set_FilterType(FilterType value);
    public uint256 get_StopHash();
    public void set_StopHash(uint256 value);
    public List`1<uint256> get_FilterHeaders();
    public void set_FilterHeaders(List`1<uint256> value);
    public virtual void ReadWriteCore(BitcoinStream stream);
}
public class NBitcoin.Protocol.CompactFilterHeadersPayload : CompactFilterCheckPointPayload {
    private uint256 _PreviousFilterHeader;
    public string Command { get; }
    public uint256 PreviousFilterHeader { get; public set; }
    public virtual string get_Command();
    public virtual void ReadWriteCore(BitcoinStream stream);
    public uint256 get_PreviousFilterHeader();
    public void set_PreviousFilterHeader(uint256 value);
}
public class NBitcoin.Protocol.CompactFilterPayload : Payload {
    private byte _FilterType;
    private Byte[] _FilterBytes;
    private uint256 _BlockHash;
    public string Command { get; }
    public FilterType FilterType { get; internal set; }
    public Byte[] FilterBytes { get; }
    public uint256 BlockHash { get; }
    public CompactFilterPayload(FilterType filterType, uint256 blockhash, Byte[] filterBytes);
    public virtual string get_Command();
    public FilterType get_FilterType();
    internal void set_FilterType(FilterType value);
    public Byte[] get_FilterBytes();
    public uint256 get_BlockHash();
    public virtual void ReadWriteCore(BitcoinStream stream);
}
public abstract class NBitcoin.Protocol.CompactFiltersQueryPayload : Payload {
    private byte _FilterType;
    private UInt32 _StartHeight;
    private uint256 _StopHash;
    public FilterType FilterType { get; internal set; }
    public UInt32 StartHeight { get; }
    public uint256 StopHash { get; }
    protected CompactFiltersQueryPayload(FilterType filterType, UInt32 startHeight, uint256 stopHash);
    public FilterType get_FilterType();
    internal void set_FilterType(FilterType value);
    public UInt32 get_StartHeight();
    public uint256 get_StopHash();
    public virtual void ReadWriteCore(BitcoinStream stream);
}
public class NBitcoin.Protocol.CompactVarInt : object {
    private ulong _Value;
    private int _Size;
    public CompactVarInt(int size);
    public CompactVarInt(ulong value, int size);
    public sealed virtual void ReadWrite(BitcoinStream stream);
    public ulong ToLong();
}
public class NBitcoin.Protocol.Connectors.DefaultEndpointConnector : object {
    [CompilerGeneratedAttribute]
private bool <AllowOnlyTorEndpoints>k__BackingField;
    public bool AllowOnlyTorEndpoints { get; public set; }
    public DefaultEndpointConnector(bool allowOnlyTorEndpoints);
    [CompilerGeneratedAttribute]
public bool get_AllowOnlyTorEndpoints();
    [CompilerGeneratedAttribute]
public void set_AllowOnlyTorEndpoints(bool value);
    public sealed virtual IEnpointConnector Clone();
    [AsyncStateMachineAttribute("NBitcoin.Protocol.Connectors.DefaultEndpointConnector/<ConnectSocket>d__7")]
public sealed virtual Task ConnectSocket(Socket socket, EndPoint endpoint, NodeConnectionParameters nodeConnectionParameters, CancellationToken cancellationToken);
    private static EndPoint NormalizeEndpoint(EndPoint socketEndpoint);
}
public interface NBitcoin.Protocol.Connectors.IEnpointConnector {
    public abstract virtual Task ConnectSocket(Socket socket, EndPoint endPoint, NodeConnectionParameters nodeConnectionParameters, CancellationToken cancellationToken);
    public abstract virtual IEnpointConnector Clone();
}
[ExtensionAttribute]
internal static class NBitcoin.Protocol.Connectors.SocketExtensions : object {
    [ExtensionAttribute]
public static Task ConnectAsync(Socket socket, EndPoint remoteEP, CancellationToken cancellationToken);
}
public class NBitcoin.Protocol.DnsResolver : object {
    private static DnsResolver _Instance;
    public static DnsResolver Instance { get; }
    private static DnsResolver();
    public static DnsResolver get_Instance();
    [AsyncStateMachineAttribute("NBitcoin.Protocol.DnsResolver/<GetHostAddressesAsync>d__4")]
public sealed virtual Task`1<IPAddress[]> GetHostAddressesAsync(string hostNameOrAddress, CancellationToken cancellationToken);
}
public class NBitcoin.Protocol.DnsSocksResolver : object {
    [CompilerGeneratedAttribute]
private EndPoint <SocksEndpoint>k__BackingField;
    [CompilerGeneratedAttribute]
private NetworkCredential <NetworkCredential>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <StreamIsolation>k__BackingField;
    public EndPoint SocksEndpoint { get; }
    public NetworkCredential NetworkCredential { get; public set; }
    public bool StreamIsolation { get; public set; }
    public DnsSocksResolver(EndPoint socksEndpoint);
    [CompilerGeneratedAttribute]
public EndPoint get_SocksEndpoint();
    [AsyncStateMachineAttribute("NBitcoin.Protocol.DnsSocksResolver/<GetHostAddressesAsync>d__4")]
public sealed virtual Task`1<IPAddress[]> GetHostAddressesAsync(string hostNameOrAddress, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
public NetworkCredential get_NetworkCredential();
    [CompilerGeneratedAttribute]
public void set_NetworkCredential(NetworkCredential value);
    [CompilerGeneratedAttribute]
public bool get_StreamIsolation();
    [CompilerGeneratedAttribute]
public void set_StreamIsolation(bool value);
    internal NetworkCredential GetCredentials();
    private NetworkCredential GenerateCredentials();
}
public class NBitcoin.Protocol.EventLoopMessageListener`1 : object {
    private BlockingCollection`1<T> _MessageQueue;
    private CancellationTokenSource cancellationSource;
    public BlockingCollection`1<T> MessageQueue { get; }
    public EventLoopMessageListener`1(Action`1<T> processMessage);
    public BlockingCollection`1<T> get_MessageQueue();
    public sealed virtual void PushMessage(T message);
    public sealed virtual void Dispose();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NBitcoin.Protocol.FeeFilterPayload : Payload {
    private FeeRate _feeRate;
    public string Command { get; }
    public FeeRate FeeRate { get; public set; }
    public virtual string get_Command();
    public FeeRate get_FeeRate();
    public void set_FeeRate(FeeRate value);
    public virtual void ReadWriteCore(BitcoinStream stream);
    public virtual string ToString();
}
public class NBitcoin.Protocol.FilterAddPayload : Payload {
    private Byte[] _Data;
    public string Command { get; }
    public Byte[] Data { get; public set; }
    public FilterAddPayload(Byte[] data);
    public virtual string get_Command();
    public Byte[] get_Data();
    public void set_Data(Byte[] value);
    public virtual void ReadWriteCore(BitcoinStream stream);
}
public class NBitcoin.Protocol.FilterLoadPayload : BitcoinSerializablePayload`1<BloomFilter> {
    public string Command { get; }
    public FilterLoadPayload(BloomFilter filter);
    public virtual string get_Command();
}
public class NBitcoin.Protocol.Filters.ActionFilter : object {
    private Action`2<IncomingMessage, Action> _OnIncoming;
    private Action`3<Node, Payload, Action> _OnSending;
    public ActionFilter(Action`2<IncomingMessage, Action> onIncoming, Action`3<Node, Payload, Action> onSending);
    public sealed virtual void OnReceivingMessage(IncomingMessage message, Action next);
    public sealed virtual void OnSendingMessage(Node node, Payload payload, Action next);
}
public interface NBitcoin.Protocol.Filters.INodeFilter {
    public abstract virtual void OnReceivingMessage(IncomingMessage message, Action next);
    public abstract virtual void OnSendingMessage(Node node, Payload payload, Action next);
}
public class NBitcoin.Protocol.Filters.NodeFiltersCollection : ThreadSafeList`1<INodeFilter> {
    public IDisposable Add(Action`2<IncomingMessage, Action> onReceiving, Action`3<Node, Payload, Action> onSending);
}
public enum NBitcoin.Protocol.FilterType : Enum {
    public byte value__;
    public static FilterType Basic;
}
public class NBitcoin.Protocol.GetAddrPayload : Payload {
    public string Command { get; }
    public virtual string get_Command();
}
public class NBitcoin.Protocol.GetBlocksPayload : Payload {
    private UInt32 version;
    private BlockLocator blockLocators;
    private uint256 _HashStop;
    public string Command { get; }
    public UInt32 Version { get; public set; }
    public BlockLocator BlockLocators { get; public set; }
    public uint256 HashStop { get; public set; }
    public GetBlocksPayload(BlockLocator locator);
    public virtual string get_Command();
    public UInt32 get_Version();
    public void set_Version(UInt32 value);
    public BlockLocator get_BlockLocators();
    public void set_BlockLocators(BlockLocator value);
    public uint256 get_HashStop();
    public void set_HashStop(uint256 value);
    public virtual void ReadWriteCore(BitcoinStream stream);
}
public class NBitcoin.Protocol.GetBlockTxnPayload : Payload {
    private uint256 _BlockId;
    private List`1<int> _Indices;
    public string Command { get; }
    public uint256 BlockId { get; public set; }
    public List`1<int> Indices { get; }
    public virtual string get_Command();
    public uint256 get_BlockId();
    public void set_BlockId(uint256 value);
    public List`1<int> get_Indices();
    public virtual void ReadWriteCore(BitcoinStream stream);
}
public class NBitcoin.Protocol.GetCompactFilterCheckPointPayload : Payload {
    private byte _FilterType;
    private uint256 _StopHash;
    public string Command { get; }
    public FilterType FilterType { get; internal set; }
    public uint256 StopHash { get; }
    public GetCompactFilterCheckPointPayload(FilterType filterType, uint256 stopHash);
    public virtual string get_Command();
    public virtual void ReadWriteCore(BitcoinStream stream);
    public FilterType get_FilterType();
    internal void set_FilterType(FilterType value);
    public uint256 get_StopHash();
}
public class NBitcoin.Protocol.GetCompactFilterHeadersPayload : CompactFiltersQueryPayload {
    public string Command { get; }
    public GetCompactFilterHeadersPayload(FilterType filterType, UInt32 startHeight, uint256 stopHash);
    public virtual string get_Command();
}
public class NBitcoin.Protocol.GetCompactFiltersPayload : CompactFiltersQueryPayload {
    public string Command { get; }
    public GetCompactFiltersPayload(FilterType filterType, UInt32 startHeight, uint256 stopHash);
    public virtual string get_Command();
}
public class NBitcoin.Protocol.GetDataPayload : Payload {
    private List`1<InventoryVector> inventory;
    public string Command { get; }
    public List`1<InventoryVector> Inventory { get; public set; }
    public GetDataPayload(InventoryVector[] vectors);
    public virtual string get_Command();
    public void set_Inventory(List`1<InventoryVector> value);
    public List`1<InventoryVector> get_Inventory();
    public virtual void ReadWriteCore(BitcoinStream stream);
}
public class NBitcoin.Protocol.GetHeadersPayload : Payload {
    private UInt32 version;
    private BlockLocator blockLocators;
    private uint256 hashStop;
    public string Command { get; }
    public UInt32 Version { get; public set; }
    public BlockLocator BlockLocators { get; public set; }
    public uint256 HashStop { get; public set; }
    public GetHeadersPayload(BlockLocator locator);
    public virtual string get_Command();
    public UInt32 get_Version();
    public void set_Version(UInt32 value);
    public BlockLocator get_BlockLocators();
    public void set_BlockLocators(BlockLocator value);
    public uint256 get_HashStop();
    public void set_HashStop(uint256 value);
    public virtual void ReadWriteCore(BitcoinStream stream);
}
public class NBitcoin.Protocol.HaveWitnessPayload : Payload {
    public string Command { get; }
    public virtual string get_Command();
}
public class NBitcoin.Protocol.HeadersPayload : Payload {
    private List`1<BlockHeader> headers;
    public string Command { get; }
    public List`1<BlockHeader> Headers { get; }
    public HeadersPayload(BlockHeader[] headers);
    public virtual string get_Command();
    public List`1<BlockHeader> get_Headers();
    public virtual void ReadWriteCore(BitcoinStream stream);
}
public interface NBitcoin.Protocol.IDnsResolver {
    public abstract virtual Task`1<IPAddress[]> GetHostAddressesAsync(string hostNameOrAddress, CancellationToken cancellationToken);
}
public class NBitcoin.Protocol.IncomingMessage : object {
    [CompilerGeneratedAttribute]
private Message <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private Socket <Socket>k__BackingField;
    [CompilerGeneratedAttribute]
private Node <Node>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Length>k__BackingField;
    public Message Message { get; public set; }
    internal Socket Socket { get; internal set; }
    public Node Node { get; public set; }
    public long Length { get; public set; }
    public IncomingMessage(Payload payload, Network network);
    [CompilerGeneratedAttribute]
public Message get_Message();
    [CompilerGeneratedAttribute]
public void set_Message(Message value);
    [CompilerGeneratedAttribute]
internal Socket get_Socket();
    [CompilerGeneratedAttribute]
internal void set_Socket(Socket value);
    [CompilerGeneratedAttribute]
public Node get_Node();
    [CompilerGeneratedAttribute]
public void set_Node(Node value);
    [CompilerGeneratedAttribute]
public long get_Length();
    [CompilerGeneratedAttribute]
public void set_Length(long value);
    internal T AssertPayload();
}
public enum NBitcoin.Protocol.InventoryType : Enum {
    public UInt32 value__;
    public static InventoryType Error;
    public static InventoryType MSG_TX;
    public static InventoryType MSG_BLOCK;
    public static InventoryType MSG_WTX;
    public static InventoryType MSG_FILTERED_BLOCK;
    public static InventoryType MSG_CMPCT_BLOCK;
    public static InventoryType MSG_TYPE_MASK;
    public static InventoryType MSG_WITNESS_FLAG;
    public static InventoryType MSG_WITNESS_BLOCK;
    public static InventoryType MSG_WITNESS_TX;
    public static InventoryType MSG_FILTERED_WITNESS_BLOCK;
}
public class NBitcoin.Protocol.InventoryVector : object {
    private UInt32 type;
    private uint256 hash;
    public InventoryType Type { get; public set; }
    public uint256 Hash { get; public set; }
    public InventoryVector(InventoryType type, uint256 hash);
    public InventoryType get_Type();
    public void set_Type(InventoryType value);
    public uint256 get_Hash();
    public void set_Hash(uint256 value);
    public sealed virtual void ReadWrite(BitcoinStream stream);
    public void ReadWriteCore(BitcoinStream stream);
    public virtual string ToString();
}
public class NBitcoin.Protocol.InvPayload : Payload {
    private List`1<InventoryVector> _Inventory;
    public static int MAX_INV_SZ;
    public string Command { get; }
    public List`1<InventoryVector> Inventory { get; }
    public InvPayload(Transaction[] transactions);
    public InvPayload(Block[] blocks);
    public InvPayload(InventoryType type, uint256[] hashes);
    public InvPayload(InventoryVector[] invs);
    public virtual string get_Command();
    public List`1<InventoryVector> get_Inventory();
    public virtual void ReadWriteCore(BitcoinStream stream);
    public virtual string ToString();
    public sealed virtual IEnumerator`1<InventoryVector> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public interface NBitcoin.Protocol.IReadOnlyNodesCollection {
    [CompilerGeneratedAttribute]
public abstract virtual void add_Added(EventHandler`1<NodeEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Added(EventHandler`1<NodeEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_Removed(EventHandler`1<NodeEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Removed(EventHandler`1<NodeEventArgs> value);
    public abstract virtual Node FindByEndpoint(EndPoint endpoint);
    public abstract virtual Node FindByIp(IPAddress ip);
    public abstract virtual Node FindLocal();
}
public class NBitcoin.Protocol.MempoolPayload : Payload {
    public string Command { get; }
    public virtual string get_Command();
}
public class NBitcoin.Protocol.MerkleBlockPayload : BitcoinSerializablePayload`1<MerkleBlock> {
    public string Command { get; }
    public MerkleBlockPayload(MerkleBlock block);
    public virtual string get_Command();
}
public class NBitcoin.Protocol.Message : object {
    private UInt32 magic;
    private Byte[] command;
    private Payload _PayloadObject;
    private static Lazy`1<ArrayPool`1<byte>> BigArrayPool;
    private bool _SkipMagic;
    public UInt32 Magic { get; public set; }
    public string Command { get; private set; }
    public Payload Payload { get; public set; }
    private static Message();
    public UInt32 get_Magic();
    public void set_Magic(UInt32 value);
    public string get_Command();
    private void set_Command(string value);
    public Payload get_Payload();
    public void set_Payload(Payload value);
    public bool IfPayloadIs(Action`1<TPayload> action);
    private ArrayPool`1<byte> GetArrayPool(int size);
    public sealed virtual void ReadWrite(BitcoinStream stream);
    public virtual string ToString();
    public static Message ReadNext(Socket socket, Network network, UInt32 version, CancellationToken cancellationToken);
    public static Message ReadNext(Socket socket, Network network, UInt32 version, CancellationToken cancellationToken, PerformanceCounter& counter);
    public static Message ReadNext(Stream stream, Network network, UInt32 version, CancellationToken cancellationToken);
    public static Message ReadNext(Stream stream, Network network, UInt32 version, CancellationToken cancellationToken, PerformanceCounter& counter);
    private IDisposable SkipMagicScope(bool value);
}
public interface NBitcoin.Protocol.MessageListener`1 {
    public abstract virtual void PushMessage(T message);
}
public class NBitcoin.Protocol.MessageProducer`1 : object {
    private List`1<MessageListener`1<T>> _Listeners;
    public IDisposable AddMessageListener(MessageListener`1<T> listener);
    public void RemoveMessageListener(MessageListener`1<T> listener);
    public void PushMessage(T message);
    public void PushMessages(IEnumerable`1<T> messages);
}
public class NBitcoin.Protocol.NetworkAddress : object {
    public static UInt32 AddrV2Format;
    private static int ADDR_IPV4_SIZE;
    private static int ADDR_IPV6_SIZE;
    private static int ADDR_TORV2_SIZE;
    private static int ADDR_TORV3_SIZE;
    private static int ADDR_I2P_SIZE;
    private static int ADDR_CJDNS_SIZE;
    private static int TORV3_ADDR_CHECKSUM_LEN;
    private static int TORV3_ADDR_VERSION_LEN;
    private static Byte[] IPV4_IN_IPV6_PREFIX;
    private static Byte[] TORV2_IN_IPV6_PREFIX;
    private static Byte[] INTERNAL_IN_IPV6_PREFIX;
    private static Byte[] IPV6_NONE;
    private NetworkAddressType network;
    private Byte[] addr;
    private ushort port;
    private static UInt32 TIME_INIT;
    internal UInt32 nTime;
    private ulong services;
    public NetworkAddressType AddressType { get; }
    public ushort Port { get; }
    [ObsoleteAttribute("Use AddressType instead")]
public bool IsIPv4 { get; }
    [ObsoleteAttribute("Use AddressType instead")]
public bool IsIPv6 { get; }
    [ObsoleteAttribute("Use AddressType instead")]
public bool IsTor { get; }
    [ObsoleteAttribute("Use AddressType instead")]
public bool IsI2P { get; }
    [ObsoleteAttribute("Use AddressType instead")]
public bool IsCjdns { get; }
    public EndPoint Endpoint { get; public set; }
    public NodeServices Services { get; public set; }
    public DateTimeOffset Time { get; public set; }
    public TimeSpan Ago { get; public set; }
    public bool IsAddrV1Compatible { get; }
    public NetworkAddress(IPAddress ip, int port);
    public NetworkAddress(IPAddress ip);
    public NetworkAddress(EndPoint endPoint);
    private static NetworkAddress();
    public NetworkAddressType get_AddressType();
    public ushort get_Port();
    public bool get_IsIPv4();
    public bool get_IsIPv6();
    public bool get_IsTor();
    public bool get_IsI2P();
    public bool get_IsCjdns();
    public EndPoint get_Endpoint();
    public void set_Endpoint(EndPoint value);
    protected void SetIp(IPAddress ip);
    public void SetLegacyIpv6(Byte[] ipv6);
    private bool SetTor(string address);
    public bool SetI2P(string address);
    public bool SetSpecial(string address);
    private static Byte[] CalculateChecksum(Byte[] pubkey);
    public NodeServices get_Services();
    public void set_Services(NodeServices value);
    public DateTimeOffset get_Time();
    public void set_Time(DateTimeOffset value);
    public TimeSpan get_Ago();
    public void set_Ago(TimeSpan value);
    public virtual void ReadWrite(BitcoinStream stream);
    private BIP155Network GetBIP155Network();
    private bool SetNetFromBIP155Network(BIP155Network bip155Network, int length);
    private Byte[] SerializeV1Array();
    public bool get_IsAddrV1Compatible();
    public Byte[] GetAddressBytes();
    public string ToAddressString();
    public virtual string ToString();
    public Byte[] GetKey();
    private bool HasPrefix(Byte[] arr, Byte[] prefix);
    [CompilerGeneratedAttribute]
internal static NetworkAddressType <SetNetFromBIP155Network>g__AssignIfCorrectSize|59_0(NetworkAddressType net, int expectedSize, <>c__DisplayClass59_0& );
}
public enum NBitcoin.Protocol.NetworkAddressType : Enum {
    public int value__;
    public static NetworkAddressType Unroutable;
    public static NetworkAddressType IPv4;
    public static NetworkAddressType IPv6;
    public static NetworkAddressType Onion;
    public static NetworkAddressType I2P;
    public static NetworkAddressType Cjdns;
}
public class NBitcoin.Protocol.NewThreadMessageListener`1 : object {
    private Action`1<T> _Process;
    public NewThreadMessageListener`1(Action`1<T> process);
    public sealed virtual void PushMessage(T message);
}
public class NBitcoin.Protocol.Node : object {
    [CompilerGeneratedAttribute]
private DateTimeOffset <ConnectedAt>k__BackingField;
    private NodeState modreq(System.Runtime.CompilerServices.IsVolatile) _State;
    [CompilerGeneratedAttribute]
private NodeStateEventHandler StateChanged;
    private NodeFiltersCollection _Filters;
    [CompilerGeneratedAttribute]
private NodeEventMessageIncoming MessageReceived;
    [CompilerGeneratedAttribute]
private NodeExceptionDelegate UncaughtException;
    [CompilerGeneratedAttribute]
private NodeEventHandler Disconnected;
    internal NodeConnection _Connection;
    private IPAddress _RemoteSocketAddress;
    private EndPoint _RemoteSocketEndpoint;
    private int _RemoteSocketPort;
    [CompilerGeneratedAttribute]
private bool <Inbound>k__BackingField;
    private NodeBehaviorsCollection _Behaviors;
    private NetworkAddress _Peer;
    [CompilerGeneratedAttribute]
private DateTimeOffset <LastSeen>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<TimeSpan> <TimeOffset>k__BackingField;
    private PerformanceCounter _Counter;
    [CompilerGeneratedAttribute]
private UInt32 <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private ProtocolCapabilities <ProtocolCapabilities>k__BackingField;
    private MessageProducer`1<IncomingMessage> _MessageProducer;
    [CompilerGeneratedAttribute]
private bool <Advertize>k__BackingField;
    private VersionPayload _MyVersion;
    private VersionPayload _PeerVersion;
    private int _Disconnecting;
    private TransactionOptions _PreferredTransactionOptions;
    private TransactionOptions _SupportedTransactionOptions;
    [CompilerGeneratedAttribute]
private bool <PreferAddressV2>k__BackingField;
    [CompilerGeneratedAttribute]
private NodeDisconnectReason <DisconnectReason>k__BackingField;
    internal TimeSpan PollHeaderDelay;
    [CompilerGeneratedAttribute]
private Network <Network>k__BackingField;
    public DateTimeOffset ConnectedAt { get; private set; }
    public NodeState State { get; private set; }
    public NodeFiltersCollection Filters { get; }
    public IPAddress RemoteSocketAddress { get; }
    public EndPoint RemoteSocketEndpoint { get; }
    public int RemoteSocketPort { get; }
    public bool Inbound { get; private set; }
    public NodeBehaviorsCollection Behaviors { get; }
    public NetworkAddress Peer { get; }
    public DateTimeOffset LastSeen { get; private set; }
    public Nullable`1<TimeSpan> TimeOffset { get; private set; }
    public PerformanceCounter Counter { get; }
    public UInt32 Version { get; internal set; }
    public ProtocolCapabilities ProtocolCapabilities { get; internal set; }
    public bool IsConnected { get; }
    public MessageProducer`1<IncomingMessage> MessageProducer { get; }
    public bool Advertize { get; public set; }
    public VersionPayload MyVersion { get; }
    public VersionPayload PeerVersion { get; }
    public TransactionOptions PreferredTransactionOptions { get; public set; }
    public TransactionOptions SupportedTransactionOptions { get; }
    public bool PreferAddressV2 { get; internal set; }
    public TransactionOptions ActualTransactionOptions { get; }
    public NodeDisconnectReason DisconnectReason { get; private set; }
    private Socket Socket { get; }
    public Network Network { get; public set; }
    internal Node(NetworkAddress peer, Network network, NodeConnectionParameters parameters, Socket socket, VersionPayload peerVersion);
    [CompilerGeneratedAttribute]
public DateTimeOffset get_ConnectedAt();
    [CompilerGeneratedAttribute]
private void set_ConnectedAt(DateTimeOffset value);
    public NodeState get_State();
    private void set_State(NodeState value);
    [CompilerGeneratedAttribute]
public void add_StateChanged(NodeStateEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_StateChanged(NodeStateEventHandler value);
    private void OnStateChanged(NodeState previous);
    public NodeFiltersCollection get_Filters();
    [CompilerGeneratedAttribute]
public void add_MessageReceived(NodeEventMessageIncoming value);
    [CompilerGeneratedAttribute]
public void remove_MessageReceived(NodeEventMessageIncoming value);
    protected void OnMessageReceived(IncomingMessage message);
    private void OnSendingMessage(Payload payload, Action final);
    private void FireFilters(IEnumerator`1<INodeFilter> enumerator, Payload payload);
    [CompilerGeneratedAttribute]
public void add_UncaughtException(NodeExceptionDelegate value);
    [CompilerGeneratedAttribute]
public void remove_UncaughtException(NodeExceptionDelegate value);
    private void FireFilters(IEnumerator`1<INodeFilter> enumerator, IncomingMessage message);
    [CompilerGeneratedAttribute]
public void add_Disconnected(NodeEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_Disconnected(NodeEventHandler value);
    private void OnDisconnected();
    public static Node Connect(Network network, AddressManager addrman, NodeConnectionParameters parameters, EndPoint[] connectedEndpoints);
    private static bool SupportSocks(NodeConnectionParameters parameters);
    public static Node Connect(Network network, NodeConnectionParameters parameters, EndPoint[] connectedEndpoints, Func`2<EndPoint, Byte[]> getGroup);
    public static Node ConnectToLocal(Network network, NodeConnectionParameters parameters);
    public static Node ConnectToLocal(Network network, Nullable`1<UInt32> myVersion, bool isRelay, CancellationToken cancellation);
    public static Node Connect(Network network, string endpoint, NodeConnectionParameters parameters);
    public static Node Connect(Network network, string endpoint, Nullable`1<UInt32> myVersion, bool isRelay, CancellationToken cancellation);
    public static Task`1<Node> ConnectAsync(Network network, NetworkAddress endpoint, NodeConnectionParameters parameters);
    public static Node Connect(Network network, NetworkAddress endpoint, NodeConnectionParameters parameters);
    public static Node Connect(Network network, EndPoint endpoint, NodeConnectionParameters parameters);
    public static Task`1<Node> ConnectAsync(Network network, EndPoint endpoint, NodeConnectionParameters parameters);
    public static Task`1<Node> ConnectAsync(Network network, string endpoint, NodeConnectionParameters parameters);
    [AsyncStateMachineAttribute("NBitcoin.Protocol.Node/<ConnectAsync>d__45")]
public static Task`1<Node> ConnectAsync(Network network, EndPoint endpoint, NetworkAddress peer, NodeConnectionParameters parameters);
    public static Node Connect(Network network, EndPoint endpoint, Nullable`1<UInt32> myVersion, bool isRelay, CancellationToken cancellation);
    private void SetVersion(UInt32 version);
    public IPAddress get_RemoteSocketAddress();
    public EndPoint get_RemoteSocketEndpoint();
    public int get_RemoteSocketPort();
    [CompilerGeneratedAttribute]
public bool get_Inbound();
    [CompilerGeneratedAttribute]
private void set_Inbound(bool value);
    private void InitDefaultBehaviors(NodeConnectionParameters parameters);
    public NodeBehaviorsCollection get_Behaviors();
    public NetworkAddress get_Peer();
    [CompilerGeneratedAttribute]
public DateTimeOffset get_LastSeen();
    [CompilerGeneratedAttribute]
private void set_LastSeen(DateTimeOffset value);
    [CompilerGeneratedAttribute]
public Nullable`1<TimeSpan> get_TimeOffset();
    [CompilerGeneratedAttribute]
private void set_TimeOffset(Nullable`1<TimeSpan> value);
    public Task SendMessageAsync(Payload payload);
    public void SendMessage(Payload payload, CancellationToken cancellation);
    public PerformanceCounter get_Counter();
    [CompilerGeneratedAttribute]
public UInt32 get_Version();
    [CompilerGeneratedAttribute]
internal void set_Version(UInt32 value);
    [CompilerGeneratedAttribute]
public ProtocolCapabilities get_ProtocolCapabilities();
    [CompilerGeneratedAttribute]
internal void set_ProtocolCapabilities(ProtocolCapabilities value);
    public bool get_IsConnected();
    public MessageProducer`1<IncomingMessage> get_MessageProducer();
    public TPayload ReceiveMessage(TimeSpan timeout);
    public TPayload ReceiveMessage(CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
public bool get_Advertize();
    [CompilerGeneratedAttribute]
public void set_Advertize(bool value);
    public VersionPayload get_MyVersion();
    public VersionPayload get_PeerVersion();
    public void VersionHandshake(CancellationToken cancellationToken);
    public void VersionHandshake(NodeRequirement requirements, CancellationToken cancellationToken);
    public void RespondToHandShake(CancellationToken cancellation);
    public void Disconnect();
    public void Disconnect(string reason, Exception exception);
    private void AssertNoListeningThread();
    public void DisconnectAsync();
    public void DisconnectAsync(string reason, Exception exception);
    public TransactionOptions get_PreferredTransactionOptions();
    public void set_PreferredTransactionOptions(TransactionOptions value);
    public TransactionOptions get_SupportedTransactionOptions();
    [CompilerGeneratedAttribute]
public bool get_PreferAddressV2();
    [CompilerGeneratedAttribute]
internal void set_PreferAddressV2(bool value);
    public TransactionOptions get_ActualTransactionOptions();
    [CompilerGeneratedAttribute]
public NodeDisconnectReason get_DisconnectReason();
    [CompilerGeneratedAttribute]
private void set_DisconnectReason(NodeDisconnectReason value);
    public virtual string ToString();
    private Socket get_Socket();
    public ConcurrentChain GetChain(SynchronizeChainOptions options, CancellationToken cancellationToken);
    public SlimChain GetSlimChain(uint256 hashStop, CancellationToken cancellationToken);
    public ConcurrentChain GetChain(uint256 hashStop, CancellationToken cancellationToken);
    [IteratorStateMachineAttribute("NBitcoin.Protocol.Node/<GetHeadersFromFork>d__140")]
public IEnumerable`1<ChainedBlock> GetHeadersFromFork(ChainedBlock currentTip, SynchronizeChainOptions options, CancellationToken cancellationToken);
    public IEnumerable`1<ChainedBlock> GetHeadersFromFork(ChainedBlock currentTip, uint256 hashStop, CancellationToken cancellationToken);
    public IEnumerable`1<ChainedBlock> SynchronizeChain(ChainBase chain, SynchronizeChainOptions options, CancellationToken cancellationToken);
    public IEnumerable`1<ChainedBlock> SynchronizeChain(ChainBase chain, uint256 hashStop, CancellationToken cancellationToken);
    public void SynchronizeSlimChain(SlimChain chain, uint256 hashStop, CancellationToken cancellationToken);
    public IEnumerable`1<Block> GetBlocks(SynchronizeChainOptions synchronizeChainOptions, CancellationToken cancellationToken);
    public IEnumerable`1<Block> GetBlocks(uint256 hashStop, CancellationToken cancellationToken);
    [IteratorStateMachineAttribute("NBitcoin.Protocol.Node/<GetBlocksFromFork>d__147")]
public IEnumerable`1<Block> GetBlocksFromFork(ChainedBlock currentTip, SynchronizeChainOptions synchronizeChainOptions, CancellationToken cancellationToken);
    public IEnumerable`1<Block> GetBlocksFromFork(ChainedBlock currentTip, uint256 hashStop, CancellationToken cancellationToken);
    public IEnumerable`1<Block> GetBlocks(IEnumerable`1<ChainedBlock> blocks, CancellationToken cancellationToken);
    [IteratorStateMachineAttribute("NBitcoin.Protocol.Node/<GetBlocks>d__150")]
public IEnumerable`1<Block> GetBlocks(IEnumerable`1<uint256> neededBlocks, CancellationToken cancellationToken);
    public NodeListener CreateListener();
    private void AssertState(NodeState nodeState, CancellationToken cancellationToken);
    public uint256[] GetMempool(CancellationToken cancellationToken);
    public Transaction[] GetMempoolTransactions(CancellationToken cancellationToken);
    public Transaction[] GetMempoolTransactions(uint256[] txIds, CancellationToken cancellationToken);
    public InventoryType AddSupportedOptions(InventoryType inventoryType);
    [CompilerGeneratedAttribute]
public Network get_Network();
    [CompilerGeneratedAttribute]
public void set_Network(Network value);
    public sealed virtual void Dispose();
    public TimeSpan PingPong(CancellationToken cancellation);
    [CompilerGeneratedAttribute]
private void <OnMessageReceived>b__20_0(IncomingMessage m, Action n);
    [CompilerGeneratedAttribute]
private InventoryVector <GetMempoolTransactions>b__155_2(uint256 txid);
}
public class NBitcoin.Protocol.NodeConnectionParameters : object {
    [CompilerGeneratedAttribute]
private bool <Advertize>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<UInt32> <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsRelay>k__BackingField;
    [CompilerGeneratedAttribute]
private NodeServices <Services>k__BackingField;
    [CompilerGeneratedAttribute]
private TransactionOptions <PreferredTransactionOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private string <UserAgent>k__BackingField;
    [CompilerGeneratedAttribute]
private SocketSettings <SocketSettings>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnpointConnector <EndpointConnector>k__BackingField;
    [CompilerGeneratedAttribute]
private CancellationToken <ConnectCancellation>k__BackingField;
    private NodeBehaviorsCollection _TemplateBehaviors;
    [CompilerGeneratedAttribute]
private EndPoint <AddressFrom>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<ulong> <Nonce>k__BackingField;
    public bool Advertize { get; public set; }
    public Nullable`1<UInt32> Version { get; public set; }
    public bool IsRelay { get; public set; }
    public NodeServices Services { get; public set; }
    public TransactionOptions PreferredTransactionOptions { get; public set; }
    public string UserAgent { get; public set; }
    public SocketSettings SocketSettings { get; public set; }
    public IEnpointConnector EndpointConnector { get; public set; }
    public CancellationToken ConnectCancellation { get; public set; }
    public NodeBehaviorsCollection TemplateBehaviors { get; }
    public EndPoint AddressFrom { get; public set; }
    public Nullable`1<ulong> Nonce { get; public set; }
    public NodeConnectionParameters(NodeConnectionParameters other);
    [CompilerGeneratedAttribute]
public bool get_Advertize();
    [CompilerGeneratedAttribute]
public void set_Advertize(bool value);
    [CompilerGeneratedAttribute]
public Nullable`1<UInt32> get_Version();
    [CompilerGeneratedAttribute]
public void set_Version(Nullable`1<UInt32> value);
    [CompilerGeneratedAttribute]
public bool get_IsRelay();
    [CompilerGeneratedAttribute]
public void set_IsRelay(bool value);
    [CompilerGeneratedAttribute]
public NodeServices get_Services();
    [CompilerGeneratedAttribute]
public void set_Services(NodeServices value);
    [CompilerGeneratedAttribute]
public TransactionOptions get_PreferredTransactionOptions();
    [CompilerGeneratedAttribute]
public void set_PreferredTransactionOptions(TransactionOptions value);
    [CompilerGeneratedAttribute]
public string get_UserAgent();
    [CompilerGeneratedAttribute]
public void set_UserAgent(string value);
    [CompilerGeneratedAttribute]
public SocketSettings get_SocketSettings();
    [CompilerGeneratedAttribute]
public void set_SocketSettings(SocketSettings value);
    [CompilerGeneratedAttribute]
public IEnpointConnector get_EndpointConnector();
    [CompilerGeneratedAttribute]
public void set_EndpointConnector(IEnpointConnector value);
    [CompilerGeneratedAttribute]
public CancellationToken get_ConnectCancellation();
    [CompilerGeneratedAttribute]
public void set_ConnectCancellation(CancellationToken value);
    public NodeBehaviorsCollection get_TemplateBehaviors();
    public NodeConnectionParameters Clone();
    [CompilerGeneratedAttribute]
public EndPoint get_AddressFrom();
    [CompilerGeneratedAttribute]
public void set_AddressFrom(EndPoint value);
    [CompilerGeneratedAttribute]
public Nullable`1<ulong> get_Nonce();
    [CompilerGeneratedAttribute]
public void set_Nonce(Nullable`1<ulong> value);
    public VersionPayload CreateVersion(EndPoint peer, Network network);
}
public class NBitcoin.Protocol.NodeDisconnectReason : object {
    [CompilerGeneratedAttribute]
private string <Reason>k__BackingField;
    [CompilerGeneratedAttribute]
private Exception <Exception>k__BackingField;
    public string Reason { get; public set; }
    public Exception Exception { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Reason();
    [CompilerGeneratedAttribute]
public void set_Reason(string value);
    [CompilerGeneratedAttribute]
public Exception get_Exception();
    [CompilerGeneratedAttribute]
public void set_Exception(Exception value);
}
public class NBitcoin.Protocol.NodeEventArgs : EventArgs {
    private bool _Added;
    private Node _Node;
    public bool Added { get; }
    public Node Node { get; }
    public NodeEventArgs(Node node, bool added);
    public bool get_Added();
    public Node get_Node();
}
public class NBitcoin.Protocol.NodeEventHandler : MulticastDelegate {
    public NodeEventHandler(object object, IntPtr method);
    public virtual void Invoke(Node node);
    public virtual IAsyncResult BeginInvoke(Node node, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class NBitcoin.Protocol.NodeEventMessageIncoming : MulticastDelegate {
    public NodeEventMessageIncoming(object object, IntPtr method);
    public virtual void Invoke(Node node, IncomingMessage message);
    public virtual IAsyncResult BeginInvoke(Node node, IncomingMessage message, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class NBitcoin.Protocol.NodeListener : PollMessageListener`1<IncomingMessage> {
    private Node _Node;
    private IDisposable _Subscription;
    private List`1<Func`2<IncomingMessage, bool>> _Predicates;
    public Node Node { get; }
    public NodeListener(Node node);
    public Node get_Node();
    public NodeListener Where(Func`2<IncomingMessage, bool> predicate);
    public NodeListener OfType();
    public TPayload ReceivePayload(CancellationToken cancellationToken);
    public sealed virtual void Dispose();
}
public class NBitcoin.Protocol.NodeRequirement : object {
    [CompilerGeneratedAttribute]
private Nullable`1<UInt32> <MinVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private ProtocolCapabilities <MinProtocolCapabilities>k__BackingField;
    [CompilerGeneratedAttribute]
private NodeServices <RequiredServices>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MinStartHeight>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SupportSPV>k__BackingField;
    public Nullable`1<UInt32> MinVersion { get; public set; }
    public ProtocolCapabilities MinProtocolCapabilities { get; public set; }
    public NodeServices RequiredServices { get; public set; }
    public Nullable`1<int> MinStartHeight { get; public set; }
    public bool SupportSPV { get; public set; }
    [CompilerGeneratedAttribute]
public Nullable`1<UInt32> get_MinVersion();
    [CompilerGeneratedAttribute]
public void set_MinVersion(Nullable`1<UInt32> value);
    [CompilerGeneratedAttribute]
public ProtocolCapabilities get_MinProtocolCapabilities();
    [CompilerGeneratedAttribute]
public void set_MinProtocolCapabilities(ProtocolCapabilities value);
    [CompilerGeneratedAttribute]
public NodeServices get_RequiredServices();
    [CompilerGeneratedAttribute]
public void set_RequiredServices(NodeServices value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_MinStartHeight();
    [CompilerGeneratedAttribute]
public void set_MinStartHeight(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public bool get_SupportSPV();
    [CompilerGeneratedAttribute]
public void set_SupportSPV(bool value);
    public virtual bool Check(VersionPayload version, ProtocolCapabilities capabilities);
}
public class NBitcoin.Protocol.NodesCollection : object {
    private Bridge bridge;
    private MessageProducer`1<IncomingMessage> _MessageProducer;
    private ConcurrentDictionary`2<Node, Node> _Nodes;
    [CompilerGeneratedAttribute]
private EventHandler`1<NodeEventArgs> Added;
    [CompilerGeneratedAttribute]
private EventHandler`1<NodeEventArgs> Removed;
    public MessageProducer`1<IncomingMessage> MessageProducer { get; }
    public int Count { get; }
    public MessageProducer`1<IncomingMessage> get_MessageProducer();
    public int get_Count();
    public bool Add(Node node);
    public bool Remove(Node node);
    [CompilerGeneratedAttribute]
public sealed virtual void add_Added(EventHandler`1<NodeEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_Added(EventHandler`1<NodeEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_Removed(EventHandler`1<NodeEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_Removed(EventHandler`1<NodeEventArgs> value);
    private void OnNodeAdded(Node node);
    private void OnNodeRemoved(Node node);
    public sealed virtual Node FindLocal();
    public sealed virtual Node FindByIp(IPAddress ip);
    public sealed virtual Node FindByEndpoint(EndPoint endpoint);
    private static bool Match(EndPoint endpoint, Node n, bool ignorePort);
    public sealed virtual IEnumerator`1<Node> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public void DisconnectAll(CancellationToken cancellation);
    public void Clear();
}
public class NBitcoin.Protocol.NodeServer : object {
    private Network _Network;
    private UInt32 _Version;
    [CompilerGeneratedAttribute]
private NodeConnectionParameters <InboundNodeConnectionParameters>k__BackingField;
    [CompilerGeneratedAttribute]
private NodeServerNodeEventHandler NodeRemoved;
    [CompilerGeneratedAttribute]
private NodeServerNodeEventHandler NodeAdded;
    [CompilerGeneratedAttribute]
private NodeServerMessageEventHandler MessageReceived;
    [CompilerGeneratedAttribute]
private bool <AllowLocalPeers>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxConnections>k__BackingField;
    private IPEndPoint _LocalEndpoint;
    private Socket socket;
    internal MessageProducer`1<IncomingMessage> _MessageProducer;
    internal MessageProducer`1<object> _InternalMessageProducer;
    private MessageProducer`1<IncomingMessage> _AllMessages;
    private EndPoint modreq(System.Runtime.CompilerServices.IsVolatile) _ExternalEndpoint;
    private NodesCollection _ConnectedNodes;
    private List`1<IDisposable> _Resources;
    private CancellationTokenSource _Cancel;
    private ulong _Nonce;
    public Network Network { get; }
    public UInt32 Version { get; }
    public NodeConnectionParameters InboundNodeConnectionParameters { get; public set; }
    public bool AllowLocalPeers { get; public set; }
    public int MaxConnections { get; public set; }
    public IPEndPoint LocalEndpoint { get; public set; }
    public bool IsListening { get; }
    public MessageProducer`1<IncomingMessage> AllMessages { get; }
    public EndPoint ExternalEndpoint { get; public set; }
    public NodesCollection ConnectedNodes { get; }
    public ulong Nonce { get; public set; }
    public NodeServer(Network network, Nullable`1<UInt32> version, int internalPort);
    public Network get_Network();
    public UInt32 get_Version();
    [CompilerGeneratedAttribute]
public NodeConnectionParameters get_InboundNodeConnectionParameters();
    [CompilerGeneratedAttribute]
public void set_InboundNodeConnectionParameters(NodeConnectionParameters value);
    [CompilerGeneratedAttribute]
public void add_NodeRemoved(NodeServerNodeEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_NodeRemoved(NodeServerNodeEventHandler value);
    [CompilerGeneratedAttribute]
public void add_NodeAdded(NodeServerNodeEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_NodeAdded(NodeServerNodeEventHandler value);
    [CompilerGeneratedAttribute]
public void add_MessageReceived(NodeServerMessageEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_MessageReceived(NodeServerMessageEventHandler value);
    private void _Nodes_NodeRemoved(object sender, NodeEventArgs node);
    private void _Nodes_NodeAdded(object sender, NodeEventArgs node);
    [CompilerGeneratedAttribute]
public bool get_AllowLocalPeers();
    [CompilerGeneratedAttribute]
public void set_AllowLocalPeers(bool value);
    [CompilerGeneratedAttribute]
public int get_MaxConnections();
    [CompilerGeneratedAttribute]
public void set_MaxConnections(int value);
    public IPEndPoint get_LocalEndpoint();
    public void set_LocalEndpoint(IPEndPoint value);
    public bool get_IsListening();
    public void Listen(int maxIncoming);
    private void BeginAccept();
    private void Accept_Completed(object sender, SocketAsyncEventArgs e);
    private void EndAccept(SocketAsyncEventArgs args);
    public MessageProducer`1<IncomingMessage> get_AllMessages();
    public EndPoint get_ExternalEndpoint();
    public void set_ExternalEndpoint(EndPoint value);
    private void ProcessMessage(IncomingMessage message);
    private void ProcessMessageCore(IncomingMessage message);
    private void node_StateChanged(Node node, NodeState oldState);
    public NodesCollection get_ConnectedNodes();
    private IDisposable OwnResource(IDisposable resource);
    public sealed virtual void Dispose();
    internal NodeConnectionParameters CreateNodeConnectionParameters();
    public ulong get_Nonce();
    public void set_Nonce(ulong value);
    public bool IsConnectedTo(EndPoint endpoint);
    public Node FindOrConnect(EndPoint endpoint);
}
public class NBitcoin.Protocol.NodeServerMessageEventHandler : MulticastDelegate {
    public NodeServerMessageEventHandler(object object, IntPtr method);
    public virtual void Invoke(NodeServer sender, IncomingMessage message);
    public virtual IAsyncResult BeginInvoke(NodeServer sender, IncomingMessage message, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class NBitcoin.Protocol.NodeServerNodeEventHandler : MulticastDelegate {
    public NodeServerNodeEventHandler(object object, IntPtr method);
    public virtual void Invoke(NodeServer sender, Node node);
    public virtual IAsyncResult BeginInvoke(NodeServer sender, Node node, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[FlagsAttribute]
public enum NBitcoin.Protocol.NodeServices : Enum {
    public ulong value__;
    public static NodeServices Nothing;
    public static NodeServices Network;
    public static NodeServices GetUTXO;
    public static NodeServices NODE_BLOOM;
    public static NodeServices NODE_WITNESS;
    public static NodeServices NODE_COMPACT_FILTERS;
    public static NodeServices NODE_NETWORK_LIMITED;
}
public class NBitcoin.Protocol.NodesGroup : object {
    private IDisposable _logScope;
    private NodeConnectionParameters _ConnectionParameters;
    private NodeRequirement _Requirements;
    private CancellationTokenSource _Disconnect;
    private Network _Network;
    private object cs;
    private AddressManager _DefaultAddressManager;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _Connecting;
    [CompilerGeneratedAttribute]
private int <MaximumNodeConnection>k__BackingField;
    internal NodesCollection _ConnectedNodes;
    [CompilerGeneratedAttribute]
private bool <AllowSameGroup>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<EndPoint, Byte[]> <CustomGroupSelector>k__BackingField;
    public NodeConnectionParameters NodeConnectionParameters { get; public set; }
    public int MaximumNodeConnection { get; public set; }
    public NodeRequirement Requirements { get; public set; }
    public NodesCollection ConnectedNodes { get; }
    public bool AllowSameGroup { get; public set; }
    public Func`2<EndPoint, Byte[]> CustomGroupSelector { get; public set; }
    public NodesGroup(Network network, NodeConnectionParameters connectionParameters, NodeRequirement requirements);
    public NodeConnectionParameters get_NodeConnectionParameters();
    public void set_NodeConnectionParameters(NodeConnectionParameters value);
    public void Connect();
    public void Disconnect();
    internal void StartConnecting();
    public static NodesGroup GetNodeGroup(Node node);
    public static NodesGroup GetNodeGroup(NodeConnectionParameters parameters);
    public static NodesGroup GetNodeGroup(NodeBehaviorsCollection behaviors);
    public void Purge(string reason);
    [CompilerGeneratedAttribute]
public int get_MaximumNodeConnection();
    [CompilerGeneratedAttribute]
public void set_MaximumNodeConnection(int value);
    public NodeRequirement get_Requirements();
    public void set_Requirements(NodeRequirement value);
    public NodesCollection get_ConnectedNodes();
    [CompilerGeneratedAttribute]
public bool get_AllowSameGroup();
    [CompilerGeneratedAttribute]
public void set_AllowSameGroup(bool value);
    [CompilerGeneratedAttribute]
public Func`2<EndPoint, Byte[]> get_CustomGroupSelector();
    [CompilerGeneratedAttribute]
public void set_CustomGroupSelector(Func`2<EndPoint, Byte[]> value);
    public sealed virtual void Dispose();
    [CompilerGeneratedAttribute]
private void <StartConnecting>b__14_0();
}
public enum NBitcoin.Protocol.NodeState : Enum {
    public int value__;
    public static NodeState Failed;
    public static NodeState Offline;
    public static NodeState Disconnecting;
    public static NodeState Connected;
    public static NodeState HandShaked;
}
public class NBitcoin.Protocol.NodeStateEventHandler : MulticastDelegate {
    public NodeStateEventHandler(object object, IntPtr method);
    public virtual void Invoke(Node node, NodeState oldState);
    public virtual IAsyncResult BeginInvoke(Node node, NodeState oldState, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class NBitcoin.Protocol.NotFoundPayload : Payload {
    private List`1<InventoryVector> _Inventory;
    public string Command { get; }
    public List`1<InventoryVector> Inventory { get; }
    public NotFoundPayload(Transaction[] transactions);
    public NotFoundPayload(Block[] blocks);
    public NotFoundPayload(InventoryType type, uint256[] hashes);
    public NotFoundPayload(InventoryVector[] invs);
    public virtual string get_Command();
    public List`1<InventoryVector> get_Inventory();
    public virtual void ReadWriteCore(BitcoinStream stream);
    public virtual string ToString();
    public sealed virtual IEnumerator`1<InventoryVector> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class NBitcoin.Protocol.NullMessageListener`1 : object {
    public sealed virtual void PushMessage(T message);
}
public abstract class NBitcoin.Protocol.Payload : object {
    public string Command { get; }
    public abstract virtual string get_Command();
    public sealed virtual void ReadWrite(BitcoinStream stream);
    public virtual void ReadWriteCore(BitcoinStream stream);
    public virtual string ToString();
}
public class NBitcoin.Protocol.PingPayload : Payload {
    private ulong _Nonce;
    public string Command { get; }
    public ulong Nonce { get; public set; }
    public virtual string get_Command();
    public ulong get_Nonce();
    public void set_Nonce(ulong value);
    public virtual void ReadWriteCore(BitcoinStream stream);
    public PongPayload CreatePong();
    public virtual string ToString();
}
public class NBitcoin.Protocol.PollMessageListener`1 : object {
    private BlockingCollection`1<T> _MessageQueue;
    public BlockingCollection`1<T> MessageQueue { get; }
    public BlockingCollection`1<T> get_MessageQueue();
    public virtual T ReceiveMessage(CancellationToken cancellationToken);
    public virtual void PushMessage(T message);
}
public class NBitcoin.Protocol.PongPayload : Payload {
    private ulong _Nonce;
    public string Command { get; }
    public ulong Nonce { get; public set; }
    public virtual string get_Command();
    public ulong get_Nonce();
    public void set_Nonce(ulong value);
    public virtual void ReadWriteCore(BitcoinStream stream);
    public virtual string ToString();
}
public class NBitcoin.Protocol.PrefilledTransaction : object {
    [CompilerGeneratedAttribute]
private Transaction <Transaction>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Index>k__BackingField;
    public Transaction Transaction { get; public set; }
    public int Index { get; public set; }
    [CompilerGeneratedAttribute]
public Transaction get_Transaction();
    [CompilerGeneratedAttribute]
public void set_Transaction(Transaction value);
    [CompilerGeneratedAttribute]
public int get_Index();
    [CompilerGeneratedAttribute]
public void set_Index(int value);
}
public class NBitcoin.Protocol.ProtocolCapabilities : object {
    [CompilerGeneratedAttribute]
private bool <PeerTooOld>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SupportTimeAddress>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SupportGetBlock>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SupportPingPong>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SupportMempoolQuery>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SupportNodeBloom>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SupportSendHeaders>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SupportWitness>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SupportCompactBlocks>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SupportCheckSum>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SupportUserAgent>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SupportAddrv2>k__BackingField;
    public bool PeerTooOld { get; public set; }
    public bool SupportTimeAddress { get; public set; }
    public bool SupportGetBlock { get; public set; }
    public bool SupportPingPong { get; public set; }
    public bool SupportMempoolQuery { get; public set; }
    public bool SupportNodeBloom { get; public set; }
    public bool SupportSendHeaders { get; public set; }
    public bool SupportWitness { get; public set; }
    public bool SupportCompactBlocks { get; public set; }
    public bool SupportCheckSum { get; public set; }
    public bool SupportUserAgent { get; public set; }
    public bool SupportAddrv2 { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_PeerTooOld();
    [CompilerGeneratedAttribute]
public void set_PeerTooOld(bool value);
    [CompilerGeneratedAttribute]
public bool get_SupportTimeAddress();
    [CompilerGeneratedAttribute]
public void set_SupportTimeAddress(bool value);
    [CompilerGeneratedAttribute]
public bool get_SupportGetBlock();
    [CompilerGeneratedAttribute]
public void set_SupportGetBlock(bool value);
    [CompilerGeneratedAttribute]
public bool get_SupportPingPong();
    [CompilerGeneratedAttribute]
public void set_SupportPingPong(bool value);
    [CompilerGeneratedAttribute]
public bool get_SupportMempoolQuery();
    [CompilerGeneratedAttribute]
public void set_SupportMempoolQuery(bool value);
    [CompilerGeneratedAttribute]
public bool get_SupportNodeBloom();
    [CompilerGeneratedAttribute]
public void set_SupportNodeBloom(bool value);
    [CompilerGeneratedAttribute]
public bool get_SupportSendHeaders();
    [CompilerGeneratedAttribute]
public void set_SupportSendHeaders(bool value);
    [CompilerGeneratedAttribute]
public bool get_SupportWitness();
    [CompilerGeneratedAttribute]
public void set_SupportWitness(bool value);
    [CompilerGeneratedAttribute]
public bool get_SupportCompactBlocks();
    [CompilerGeneratedAttribute]
public void set_SupportCompactBlocks(bool value);
    [CompilerGeneratedAttribute]
public bool get_SupportCheckSum();
    [CompilerGeneratedAttribute]
public void set_SupportCheckSum(bool value);
    public virtual HashStreamBase GetChecksumHashStream();
    public virtual HashStreamBase GetChecksumHashStream(int hintSize);
    [CompilerGeneratedAttribute]
public bool get_SupportUserAgent();
    [CompilerGeneratedAttribute]
public void set_SupportUserAgent(bool value);
    [CompilerGeneratedAttribute]
public bool get_SupportAddrv2();
    [CompilerGeneratedAttribute]
public void set_SupportAddrv2(bool value);
    public static ProtocolCapabilities CreateSupportAll();
    public bool IsSupersetOf(ProtocolCapabilities capabilities);
}
public class NBitcoin.Protocol.ProtocolException : Exception {
    public ProtocolException(string message);
}
public enum NBitcoin.Protocol.RejectCode : Enum {
    public byte value__;
    public static RejectCode MALFORMED;
    public static RejectCode INVALID;
    public static RejectCode OBSOLETE;
    public static RejectCode DUPLICATE;
    public static RejectCode NONSTANDARD;
    public static RejectCode DUST;
    public static RejectCode INSUFFICIENTFEE;
    public static RejectCode CHECKPOINT;
}
public class NBitcoin.Protocol.SendAddrV2Payload : Payload {
    public string Command { get; }
    public virtual string get_Command();
}
public class NBitcoin.Protocol.SendCmpctPayload : Payload {
    private byte _PreferHeaderAndIDs;
    private ulong _Version;
    public string Command { get; }
    public bool PreferHeaderAndIDs { get; public set; }
    public ulong Version { get; public set; }
    public SendCmpctPayload(bool preferHeaderAndIDs);
    public virtual string get_Command();
    public bool get_PreferHeaderAndIDs();
    public void set_PreferHeaderAndIDs(bool value);
    public ulong get_Version();
    public void set_Version(ulong value);
    public virtual void ReadWriteCore(BitcoinStream stream);
}
public class NBitcoin.Protocol.SendHeadersPayload : Payload {
    public string Command { get; }
    public virtual string get_Command();
}
public class NBitcoin.Protocol.SocketSettings : object {
    [CompilerGeneratedAttribute]
private Nullable`1<TimeSpan> <ReceiveTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<TimeSpan> <SendTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <ReceiveBufferSize>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <SendBufferSize>k__BackingField;
    public Nullable`1<TimeSpan> ReceiveTimeout { get; public set; }
    public Nullable`1<TimeSpan> SendTimeout { get; public set; }
    public Nullable`1<int> ReceiveBufferSize { get; public set; }
    public Nullable`1<int> SendBufferSize { get; public set; }
    [CompilerGeneratedAttribute]
public Nullable`1<TimeSpan> get_ReceiveTimeout();
    [CompilerGeneratedAttribute]
public void set_ReceiveTimeout(Nullable`1<TimeSpan> value);
    [CompilerGeneratedAttribute]
public Nullable`1<TimeSpan> get_SendTimeout();
    [CompilerGeneratedAttribute]
public void set_SendTimeout(Nullable`1<TimeSpan> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_ReceiveBufferSize();
    [CompilerGeneratedAttribute]
public void set_ReceiveBufferSize(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_SendBufferSize();
    [CompilerGeneratedAttribute]
public void set_SendBufferSize(Nullable`1<int> value);
    public void SetSocketProperties(Socket socket);
    public SocketSettings Clone();
}
public class NBitcoin.Protocol.SynchronizeChainOptions : object {
    [CompilerGeneratedAttribute]
private uint256 <HashStop>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SkipPoWCheck>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <StripHeaders>k__BackingField;
    public uint256 HashStop { get; public set; }
    public bool SkipPoWCheck { get; public set; }
    public bool StripHeaders { get; public set; }
    [CompilerGeneratedAttribute]
public uint256 get_HashStop();
    [CompilerGeneratedAttribute]
public void set_HashStop(uint256 value);
    [CompilerGeneratedAttribute]
public bool get_SkipPoWCheck();
    [CompilerGeneratedAttribute]
public void set_SkipPoWCheck(bool value);
    [CompilerGeneratedAttribute]
public bool get_StripHeaders();
    [CompilerGeneratedAttribute]
public void set_StripHeaders(bool value);
}
public class NBitcoin.Protocol.TxPayload : Payload {
    private Transaction _Object;
    public string Command { get; }
    public Transaction Object { get; public set; }
    public TxPayload(Transaction transaction);
    public virtual string get_Command();
    public Transaction get_Object();
    public void set_Object(Transaction value);
    public virtual void ReadWriteCore(BitcoinStream stream);
}
public class NBitcoin.Protocol.UnknownPayload : Payload {
    internal string _Command;
    private Byte[] _Data;
    public string Command { get; }
    public Byte[] Data { get; public set; }
    public UnknownPayload(string command);
    public virtual string get_Command();
    public Byte[] get_Data();
    public void set_Data(Byte[] value);
    public virtual void ReadWriteCore(BitcoinStream stream);
}
[ObsoleteAttribute("Use UnknownPayload")]
public class NBitcoin.Protocol.UnknowPayload : UnknownPayload {
}
public class NBitcoin.Protocol.UTxOut : object {
    private UInt32 _version;
    private UInt32 _height;
    private TxOut _txOut;
    public UInt32 Version { get; internal set; }
    public UInt32 Height { get; internal set; }
    public TxOut Output { get; internal set; }
    public UInt32 get_Version();
    internal void set_Version(UInt32 value);
    public UInt32 get_Height();
    internal void set_Height(UInt32 value);
    public TxOut get_Output();
    internal void set_Output(TxOut value);
    public sealed virtual void ReadWrite(BitcoinStream stream);
}
public class NBitcoin.Protocol.UTxOutputPayload : Payload {
    private UTxOutputs _uTxOutputs;
    public string Command { get; }
    public virtual string get_Command();
    public virtual void ReadWriteCore(BitcoinStream stream);
}
public class NBitcoin.Protocol.UTxOutputs : object {
    private VarString _bitmap;
    private int _chainHeight;
    private uint256 _chainTipHash;
    private UTxOut[] _outputs;
    public int ChainHeight { get; internal set; }
    public uint256 ChainTipHash { get; internal set; }
    public BitArray Bitmap { get; }
    public UTxOut[] Outputs { get; internal set; }
    public int get_ChainHeight();
    internal void set_ChainHeight(int value);
    public uint256 get_ChainTipHash();
    internal void set_ChainTipHash(uint256 value);
    public BitArray get_Bitmap();
    public UTxOut[] get_Outputs();
    internal void set_Outputs(UTxOut[] value);
    public sealed virtual void ReadWrite(BitcoinStream stream);
}
public class NBitcoin.Protocol.VarInt : object {
    private ulong _Value;
    public VarInt(ulong value);
    internal void SetValue(ulong value);
    public static void StaticWrite(BitcoinStream bs, ulong length);
    public static ulong StaticRead(BitcoinStream bs);
    public ulong ToLong();
    public sealed virtual void ReadWrite(BitcoinStream stream);
}
public class NBitcoin.Protocol.VarString : object {
    private Byte[] _Bytes;
    public int Length { get; }
    public VarString(Byte[] bytes);
    public int get_Length();
    public Byte[] GetString();
    public Byte[] GetString(bool unsafe);
    public sealed virtual void ReadWrite(BitcoinStream stream);
    internal static void StaticWrite(BitcoinStream bs, Byte[] bytes);
    internal static void StaticRead(BitcoinStream bs, Byte[]& bytes);
}
public class NBitcoin.Protocol.VerAckPayload : Payload {
    public string Command { get; }
    public virtual string get_Command();
    public virtual void ReadWriteCore(BitcoinStream stream);
}
public class NBitcoin.Protocol.VersionPayload : Payload {
    private static string _NUserAgent;
    private UInt32 version;
    private ulong services;
    private long timestamp;
    private NetworkAddress addr_recv;
    private NetworkAddress addr_from;
    private ulong nonce;
    private int start_height;
    private bool relay;
    private VarString user_agent;
    public string Command { get; }
    public UInt32 Version { get; public set; }
    public NodeServices Services { get; public set; }
    public DateTimeOffset Timestamp { get; public set; }
    public EndPoint AddressReceiver { get; public set; }
    public EndPoint AddressFrom { get; public set; }
    public ulong Nonce { get; public set; }
    public int StartHeight { get; public set; }
    public bool Relay { get; public set; }
    public string UserAgent { get; public set; }
    public virtual string get_Command();
    public static string GetNBitcoinUserAgent();
    public UInt32 get_Version();
    public void set_Version(UInt32 value);
    public NodeServices get_Services();
    public void set_Services(NodeServices value);
    public DateTimeOffset get_Timestamp();
    public void set_Timestamp(DateTimeOffset value);
    public EndPoint get_AddressReceiver();
    public void set_AddressReceiver(EndPoint value);
    public EndPoint get_AddressFrom();
    public void set_AddressFrom(EndPoint value);
    public ulong get_Nonce();
    public void set_Nonce(ulong value);
    public int get_StartHeight();
    public void set_StartHeight(int value);
    public bool get_Relay();
    public void set_Relay(bool value);
    public string get_UserAgent();
    public void set_UserAgent(string value);
    public virtual void ReadWriteCore(BitcoinStream stream);
    public virtual string ToString();
}
public class NBitcoin.Protocol.WellKnownGroupSelectors : object {
    private static Random _Rand;
    private static Func`2<EndPoint, Byte[]> _GroupByRandom;
    private static Func`2<EndPoint, Byte[]> _GroupByIp;
    private static Func`2<EndPoint, Byte[]> _GroupByEndpoint;
    private static Func`2<EndPoint, Byte[]> _GroupByNetwork;
    public static Func`2<EndPoint, Byte[]> ByRandom { get; }
    public static Func`2<EndPoint, Byte[]> ByIp { get; }
    public static Func`2<EndPoint, Byte[]> ByEndpoint { get; }
    public static Func`2<EndPoint, Byte[]> ByNetwork { get; }
    private static WellKnownGroupSelectors();
    public static Func`2<EndPoint, Byte[]> get_ByRandom();
    public static Func`2<EndPoint, Byte[]> get_ByIp();
    public static Func`2<EndPoint, Byte[]> get_ByEndpoint();
    public static Func`2<EndPoint, Byte[]> get_ByNetwork();
}
public class NBitcoin.Protocol.WTxIdRelayPayload : Payload {
    public string Command { get; }
    public virtual string get_Command();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NBitcoin.PSBT : object {
    private static Byte[] PSBT_MAGIC_BYTES;
    [NullableAttribute("2")]
internal Byte[] _XPubVersionBytes;
    internal Transaction tx;
    [CompilerGeneratedAttribute]
private SortedDictionary`2<BitcoinExtPubKey, RootedKeyPath> <GlobalXPubs>k__BackingField;
    [CompilerGeneratedAttribute]
private PSBTInputList <Inputs>k__BackingField;
    [CompilerGeneratedAttribute]
private PSBTOutputList <Outputs>k__BackingField;
    internal SortedDictionary`2<Byte[], Byte[]> unknown;
    [CompilerGeneratedAttribute]
private Network <Network>k__BackingField;
    [CompilerGeneratedAttribute]
private PSBTSettings <Settings>k__BackingField;
    private static UInt32 defaultKeyLen;
    private Byte[] XPubVersionBytes { get; }
    public SortedDictionary`2<BitcoinExtPubKey, RootedKeyPath> GlobalXPubs { get; }
    public PSBTInputList Inputs { get; }
    public PSBTOutputList Outputs { get; }
    public Network Network { get; }
    public PSBTSettings Settings { get; public set; }
    private PSBT(Transaction transaction, Network network);
    internal PSBT(BitcoinStream stream, Network network);
    private static PSBT();
    private Byte[] get_XPubVersionBytes();
    [CompilerGeneratedAttribute]
public SortedDictionary`2<BitcoinExtPubKey, RootedKeyPath> get_GlobalXPubs();
    [CompilerGeneratedAttribute]
public PSBTInputList get_Inputs();
    [CompilerGeneratedAttribute]
public PSBTOutputList get_Outputs();
    public static PSBT Parse(string hexOrBase64, Network network);
    public static bool TryParse(string hexOrBase64, Network network, PSBT& psbt);
    public static PSBT Load(Byte[] rawBytes, Network network);
    internal ConsensusFactory GetConsensusFactory();
    [CompilerGeneratedAttribute]
public Network get_Network();
    public PSBT AddCoins(ICoin[] coins);
    public PSBT AddCoins(Transaction[] transactions);
    public PSBT AddTransactions(Transaction[] parentTransactions);
    public PSBT Combine(PSBT other);
    public PSBT UpdateFrom(PSBT other);
    public PSBT CoinJoin(PSBT other);
    public PSBT Finalize();
    public bool TryFinalize(IList`1& errors);
    internal SigningOptions GetSigningOptions(SigningOptions signingOptions);
    public bool IsReadyToSign();
    public bool IsReadyToSign(PSBTError[]& errors);
    [CompilerGeneratedAttribute]
public PSBTSettings get_Settings();
    [CompilerGeneratedAttribute]
public void set_Settings(PSBTSettings value);
    public PSBT SignAll(ScriptPubKeyType scriptPubKeyType, IHDKey accountKey, RootedKeyPath accountKeyPath);
    public PSBT SignAll(ScriptPubKeyType scriptPubKeyType, IHDKey accountKey);
    public PSBT SignAll(IHDScriptPubKey accountHDScriptPubKey, IHDKey accountKey);
    public PSBT SignAll(IHDScriptPubKey accountHDScriptPubKey, IHDKey accountKey, RootedKeyPath accountKeyPath);
    public bool TryGetFee(Money& fee);
    public Money GetFee();
    public bool TryGetEstimatedFeeRate(FeeRate& estimatedFeeRate);
    public bool TryGetVirtualSize(Int32& vsize);
    public FeeRate GetEstimatedFeeRate();
    public PSBT SignWithKeys(ISecret[] keys);
    public PSBT SignWithKeys(Key[] keys);
    public PrecomputedTransactionData PrecomputeTransactionData();
    public TransactionValidator CreateTransactionValidator();
    internal bool TryCreateTransactionValidator(TransactionValidator& validator, IList`1& errors);
    private TxOut[] GetSpentTxOuts(IList`1& errors);
    internal TransactionBuilder CreateTransactionBuilder();
    [IteratorStateMachineAttribute("NBitcoin.PSBT/<GetAllCoins>d__56")]
private IEnumerable`1<ICoin> GetAllCoins();
    public Transaction ExtractTransaction();
    public bool CanExtractTransaction();
    public bool IsAllFinalized();
    public IList`1<PSBTError> CheckSanity();
    public void AssertSanity();
    public bool TryGetFinalizedHash(uint256& hash);
    public void Serialize(BitcoinStream stream);
    public virtual string ToString();
    public Byte[] ToBytes();
    public PSBT Clone();
    public PSBT Clone(bool keepOriginalTransactionInformation);
    public string ToBase64();
    public string ToHex();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(PSBT b);
    public virtual int GetHashCode();
    public static PSBT FromTransaction(Transaction transaction, Network network);
    public PSBT AddScripts(Script[] redeems);
    public Money GetBalance(ScriptPubKeyType scriptPubKeyType, IHDKey accountKey, RootedKeyPath accountKeyPath);
    public Money GetBalance(IHDScriptPubKey accountHDScriptPubKey, IHDKey accountKey, RootedKeyPath accountKeyPath);
    public IEnumerable`1<PSBTCoin> CoinsFor(IHDScriptPubKey accountHDScriptPubKey, IHDKey accountKey, RootedKeyPath accountKeyPath);
    public IEnumerable`1<PSBTHDKeyMatch> HDKeysFor(IHDScriptPubKey accountHDScriptPubKey, IHDKey accountKey, RootedKeyPath accountKeyPath);
    public IEnumerable`1<PSBTHDKeyMatch> HDKeysFor(IHDKey accountKey, RootedKeyPath accountKeyPath);
    public PSBT AddKeyPath(IHDKey masterKey, KeyPath[] paths);
    public PSBT AddKeyPath(IHDKey masterKey, Tuple`2[] paths);
    public PSBT AddKeyPath(PubKey pubkey, RootedKeyPath rootedKeyPath);
    public PSBT AddKeyPath(PubKey pubkey, RootedKeyPath rootedKeyPath, Script scriptPubKey);
    public PSBT RebaseKeyPaths(IHDKey accountKey, RootedKeyPath newRoot);
    public Transaction GetOriginalTransaction();
    public Transaction GetGlobalTransaction();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class NBitcoin.PSBTCoin : object {
    protected SortedDictionary`2<PubKey, RootedKeyPath> hd_keypaths;
    protected SortedDictionary`2<TaprootPubKey, TaprootKeyPath> hd_taprootkeypaths;
    protected SortedDictionary`2<Byte[], Byte[]> unknown;
    [NullableAttribute("2")]
protected Script redeem_script;
    [NullableAttribute("2")]
protected Script witness_script;
    protected PSBT Parent;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private TaprootInternalPubKey <TaprootInternalKey>k__BackingField;
    public PSBT PSBT { get; }
    public SortedDictionary`2<Byte[], Byte[]> Unknown { get; }
    public SortedDictionary`2<PubKey, RootedKeyPath> HDKeyPaths { get; }
    public SortedDictionary`2<TaprootPubKey, TaprootKeyPath> HDTaprootKeyPaths { get; }
    [NullableAttribute("2")]
public TaprootInternalPubKey TaprootInternalKey { get; public set; }
    [NullableAttribute("2")]
public Script RedeemScript { get; public set; }
    [NullableAttribute("2")]
public Script WitnessScript { get; public set; }
    public PSBTCoin(PSBT parent);
    public PSBT get_PSBT();
    public SortedDictionary`2<Byte[], Byte[]> get_Unknown();
    public SortedDictionary`2<PubKey, RootedKeyPath> get_HDKeyPaths();
    public SortedDictionary`2<TaprootPubKey, TaprootKeyPath> get_HDTaprootKeyPaths();
    [IteratorStateMachineAttribute("NBitcoin.PSBTCoin/<EnumerateKeyPaths>d__15")]
public IEnumerable`1<KeyValuePair`2<IPubKey, RootedKeyPath>> EnumerateKeyPaths();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public TaprootInternalPubKey get_TaprootInternalKey();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_TaprootInternalKey(TaprootInternalPubKey value);
    [NullableContextAttribute("2")]
public Script get_RedeemScript();
    [NullableContextAttribute("2")]
public void set_RedeemScript(Script value);
    [NullableContextAttribute("2")]
public Script get_WitnessScript();
    [NullableContextAttribute("2")]
public void set_WitnessScript(Script value);
    public virtual void AddKeyPath(PubKey pubKey, RootedKeyPath rootedKeyPath);
    [NullableContextAttribute("2")]
public abstract virtual Coin GetCoin();
    [NullableContextAttribute("2")]
public Coin GetSignableCoin();
    [NullableContextAttribute("2")]
public virtual Coin GetSignableCoin(String& error);
    [NullableContextAttribute("2")]
internal virtual Script GetRedeemScript();
    [NullableContextAttribute("2")]
internal virtual Script GetWitnessScript();
    public IEnumerable`1<PSBTHDKeyMatch> HDKeysFor(IHDScriptPubKey accountHDScriptPubKey, IHDKey accountKey, RootedKeyPath accountKeyPath);
    [IteratorStateMachineAttribute("NBitcoin.PSBTCoin/<HDKeysFor>d__33")]
internal IEnumerable`1<PSBTHDKeyMatch> HDKeysFor(IHDScriptPubKey accountHDScriptPubKey, IHDKey accountKey, RootedKeyPath accountKeyPath, HDFingerprint accountFingerprint);
    protected abstract virtual PSBTHDKeyMatch CreateHDKeyMatch(IHDKey accountKey, KeyPath addressKeyPath, KeyValuePair`2<IPubKey, RootedKeyPath> kv);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class NBitcoin.PSBTCoinList`1 : object {
    protected List`1<T> _Inner;
    public int Count { get; }
    public T Item { get; }
    public IEnumerable`1<T> CoinsFor(IHDScriptPubKey accountHDScriptPubKey, IHDKey accountKey, RootedKeyPath accountKeyPath);
    public IEnumerable`1<PSBTHDKeyMatch`1<T>> HDKeysFor(IHDScriptPubKey accountHDScriptPubKey, IHDKey accountKey, RootedKeyPath accountKeyPath);
    public IEnumerable`1<PSBTHDKeyMatch`1<T>> HDKeysFor(IHDKey accountKey, RootedKeyPath accountKeyPath);
    internal IEnumerable`1<T> GetPSBTCoins(IHDScriptPubKey accountHDScriptPubKey, IHDKey accountKey, RootedKeyPath accountKeyPath);
    [IteratorStateMachineAttribute("NBitcoin.PSBTCoinList`1/<GetHDKeys>d__4")]
internal IEnumerable`1<PSBTHDKeyMatch`1<T>> GetHDKeys(IHDScriptPubKey hdScriptPubKey, IHDKey accountKey, RootedKeyPath accountKeyPath);
    public sealed virtual int get_Count();
    public sealed virtual T get_Item(int index);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class NBitcoin.PSBTConstants : object {
    [CompilerGeneratedAttribute]
private static Byte[] <PSBT_GLOBAL_ALL>k__BackingField;
    [CompilerGeneratedAttribute]
private static Byte[] <PSBT_IN_ALL>k__BackingField;
    [CompilerGeneratedAttribute]
private static Byte[] <PSBT_OUT_ALL>k__BackingField;
    public static byte PSBT_GLOBAL_UNSIGNED_TX;
    public static byte PSBT_GLOBAL_XPUB;
    public static byte PSBT_IN_NON_WITNESS_UTXO;
    public static byte PSBT_IN_WITNESS_UTXO;
    public static byte PSBT_IN_PARTIAL_SIG;
    public static byte PSBT_IN_SIGHASH;
    public static byte PSBT_IN_REDEEMSCRIPT;
    public static byte PSBT_IN_WITNESSSCRIPT;
    public static byte PSBT_IN_BIP32_DERIVATION;
    public static byte PSBT_IN_SCRIPTSIG;
    public static byte PSBT_IN_SCRIPTWITNESS;
    public static byte PSBT_OUT_TAP_INTERNAL_KEY;
    public static byte PSBT_IN_TAP_KEY_SIG;
    public static byte PSBT_IN_TAP_INTERNAL_KEY;
    public static byte PSBT_IN_TAP_BIP32_DERIVATION;
    public static byte PSBT_OUT_TAP_BIP32_DERIVATION;
    public static byte PSBT_IN_TAP_MERKLE_ROOT;
    public static byte PSBT_OUT_REDEEMSCRIPT;
    public static byte PSBT_OUT_WITNESSSCRIPT;
    public static byte PSBT_OUT_BIP32_DERIVATION;
    public static byte PSBT_SEPARATOR;
    public static Byte[] PSBT_GLOBAL_ALL { get; }
    public static Byte[] PSBT_IN_ALL { get; }
    public static Byte[] PSBT_OUT_ALL { get; }
    private static PSBTConstants();
    [CompilerGeneratedAttribute]
public static Byte[] get_PSBT_GLOBAL_ALL();
    [CompilerGeneratedAttribute]
public static Byte[] get_PSBT_IN_ALL();
    [CompilerGeneratedAttribute]
public static Byte[] get_PSBT_OUT_ALL();
}
public class NBitcoin.PSBTError : object {
    [CompilerGeneratedAttribute]
private UInt32 <InputIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    public UInt32 InputIndex { get; }
    public string Message { get; }
    public PSBTError(UInt32 inputIndex, string errorMessage);
    [CompilerGeneratedAttribute]
public UInt32 get_InputIndex();
    [CompilerGeneratedAttribute]
public string get_Message();
    public virtual string ToString();
}
public class NBitcoin.PSBTException : InvalidOperationException {
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<PSBTError> <Errors>k__BackingField;
    public IReadOnlyList`1<PSBTError> Errors { get; }
    public PSBTException(IEnumerable`1<PSBTError> errors);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<PSBTError> get_Errors();
    private static string GetMessage(IEnumerable`1<PSBTError> errors);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NBitcoin.PSBTHDKeyMatch : object {
    private PSBTCoin _Coin;
    private IPubKey _PubKey;
    private KeyPath _AddressKeyPath;
    private IHDKey _AccountKey;
    private RootedKeyPath _KeyPath;
    public PSBTCoin Coin { get; }
    public IPubKey PubKey { get; }
    public KeyPath AddressKeyPath { get; }
    public IHDKey AccountKey { get; }
    public RootedKeyPath RootedKeyPath { get; }
    internal PSBTHDKeyMatch(PSBTCoin psbtCoin, IHDKey accountKey, KeyPath addressKeyPath, KeyValuePair`2<IPubKey, RootedKeyPath> kv);
    public PSBTCoin get_Coin();
    public IPubKey get_PubKey();
    public KeyPath get_AddressKeyPath();
    public IHDKey get_AccountKey();
    public RootedKeyPath get_RootedKeyPath();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NBitcoin.PSBTHDKeyMatch`1 : PSBTHDKeyMatch {
    private T _Coin;
    public T Coin { get; }
    internal PSBTHDKeyMatch`1(T psbtCoin, IHDKey accountKey, KeyPath addressKeyPath, KeyValuePair`2<IPubKey, RootedKeyPath> kv);
    public T get_Coin();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NBitcoin.PSBTInput : PSBTCoin {
    internal Script originalScriptSig;
    internal WitScript originalWitScript;
    [NullableAttribute("2")]
internal TxOut orphanTxOut;
    [CompilerGeneratedAttribute]
private TxIn <TxIn>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <Index>k__BackingField;
    [NullableAttribute("2")]
private Transaction non_witness_utxo;
    [NullableAttribute("2")]
private TxOut witness_utxo;
    [NullableAttribute("2")]
private Script final_script_sig;
    [NullableAttribute("2")]
private WitScript final_script_witness;
    private SortedDictionary`2<PubKey, TransactionSignature> partial_sigs;
    private Nullable`1<UInt32> sighash_type;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private TaprootSignature <TaprootKeySignature>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private uint256 <TaprootMerkleRoot>k__BackingField;
    private static UInt32 defaultKeyLen;
    internal TxIn TxIn { get; }
    public OutPoint PrevOut { get; }
    public UInt32 Index { get; }
    internal Transaction Transaction { get; }
    [NullableAttribute("2")]
public Transaction NonWitnessUtxo { get; public set; }
    [NullableAttribute("2")]
public TxOut WitnessUtxo { get; public set; }
    public Nullable`1<SigHash> SighashType { get; public set; }
    public Nullable`1<TaprootSigHash> TaprootSighashType { get; public set; }
    [NullableAttribute("2")]
public Script FinalScriptSig { get; public set; }
    [NullableAttribute("2")]
public WitScript FinalScriptWitness { get; public set; }
    [NullableAttribute("2")]
public TaprootSignature TaprootKeySignature { get; public set; }
    [NullableAttribute("2")]
public uint256 TaprootMerkleRoot { get; public set; }
    public SortedDictionary`2<PubKey, TransactionSignature> PartialSigs { get; }
    internal PSBTInput(PSBT parent, UInt32 index, TxIn input);
    internal PSBTInput(BitcoinStream stream, PSBT parent, UInt32 index, TxIn input);
    private static PSBTInput();
    public void SetSequence(ushort sequence);
    [CompilerGeneratedAttribute]
internal TxIn get_TxIn();
    internal IndexedTxIn GetIndexedInput();
    public OutPoint get_PrevOut();
    [CompilerGeneratedAttribute]
public UInt32 get_Index();
    internal Transaction get_Transaction();
    [NullableContextAttribute("2")]
public Transaction get_NonWitnessUtxo();
    [NullableContextAttribute("2")]
public void set_NonWitnessUtxo(Transaction value);
    [NullableContextAttribute("2")]
public TxOut get_WitnessUtxo();
    [NullableContextAttribute("2")]
public void set_WitnessUtxo(TxOut value);
    public Nullable`1<SigHash> get_SighashType();
    public void set_SighashType(Nullable`1<SigHash> value);
    public Nullable`1<TaprootSigHash> get_TaprootSighashType();
    public void set_TaprootSighashType(Nullable`1<TaprootSigHash> value);
    [NullableContextAttribute("2")]
public Script get_FinalScriptSig();
    [NullableContextAttribute("2")]
public void set_FinalScriptSig(Script value);
    [NullableContextAttribute("2")]
public WitScript get_FinalScriptWitness();
    [NullableContextAttribute("2")]
public void set_FinalScriptWitness(WitScript value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public TaprootSignature get_TaprootKeySignature();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_TaprootKeySignature(TaprootSignature value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public uint256 get_TaprootMerkleRoot();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_TaprootMerkleRoot(uint256 value);
    public SortedDictionary`2<PubKey, TransactionSignature> get_PartialSigs();
    public void UpdateFromCoin(ICoin coin);
    public void UpdateFrom(PSBTInput other);
    public uint256 GetSignatureHash(TaprootSigHash sigHash, PrecomputedTransactionData precomputedTransactionData);
    public uint256 GetSignatureHash(SigHash sigHash, PrecomputedTransactionData precomputedTransactionData);
    public bool IsFinalized();
    private Op[] GetPushItems(Script redeem);
    public void ClearForFinalize();
    [NullableContextAttribute("2")]
public Coin GetSignableCoin();
    [NullableContextAttribute("2")]
public virtual Coin GetSignableCoin(String& error);
    [NullableContextAttribute("2")]
internal virtual Script GetRedeemScript();
    [NullableContextAttribute("2")]
internal virtual Script GetWitnessScript();
    public IList`1<PSBTError> CheckSanity();
    public void TrySign(IHDScriptPubKey accountHDScriptPubKey, IHDKey accountKey, RootedKeyPath accountKeyPath);
    internal void TrySign(IHDScriptPubKey accountHDScriptPubKey, IHDKey accountKey, RootedKeyPath accountKeyPath, SigningOptions signingOptions);
    public void AssertSanity();
    public void Serialize(BitcoinStream stream);
    public Byte[] ToBytes();
    internal void Write(JsonTextWriter jsonWriter);
    private string GetName(UInt32 sighashType);
    [NullableContextAttribute("2")]
public TxOut GetTxOut();
    public bool TryFinalizeInput(IList`1& errors);
    internal bool TryFinalizeInput(SigningOptions signingOptions, IList`1& errors);
    internal static bool IsTaprootReady(SigningOptions signingOptions, Coin coin);
    [NullableContextAttribute("2")]
public bool VerifyScript(PrecomputedTransactionData precomputedTransactionData, ScriptError& err);
    [NullableContextAttribute("2")]
public bool VerifyScript(ScriptVerify scriptVerify, PrecomputedTransactionData precomputedTransactionData, ScriptError& err);
    public void FinalizeInput();
    public void Sign(Key key);
    public void Sign(KeyPair keyPair);
    internal void Sign(KeyPair keyPair, SigningOptions signingOptions);
    internal void Sign(Key key, SigningOptions signingOptions);
    private bool SameSigHash(UInt32 a, UInt32 b);
    private void CheckCompatibleSigHash(UInt32 sigHash);
    public bool TrySlimUTXO();
    [NullableContextAttribute("2")]
public virtual Coin GetCoin();
    public virtual string ToString();
    protected virtual PSBTHDKeyMatch CreateHDKeyMatch(IHDKey accountKey, KeyPath addressKeyPath, KeyValuePair`2<IPubKey, RootedKeyPath> kv);
    [CompilerGeneratedAttribute]
private void <TryFinalizeInput>g__Rollback|73_0(<>c__DisplayClass73_0& );
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class NBitcoin.PSBTInputList : PSBTCoinList`1<PSBTInput> {
    private Dictionary`2<OutPoint, PSBTInput> _InputsByOutpoint;
    internal void Add(PSBTInput input);
    public PSBTInput FindIndexedInput(OutPoint prevOut);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NBitcoin.PSBTOutput : PSBTCoin {
    [CompilerGeneratedAttribute]
private TxOut <TxOut>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <Index>k__BackingField;
    private static UInt32 defaultKeyLen;
    internal TxOut TxOut { get; }
    public Script ScriptPubKey { get; }
    public Money Value { get; }
    public UInt32 Index { get; public set; }
    internal Transaction Transaction { get; }
    internal PSBTOutput(PSBT parent, UInt32 index, TxOut txOut);
    internal PSBTOutput(BitcoinStream stream, PSBT parent, UInt32 index, TxOut txOut);
    private static PSBTOutput();
    [CompilerGeneratedAttribute]
internal TxOut get_TxOut();
    public Script get_ScriptPubKey();
    public Money get_Value();
    [CompilerGeneratedAttribute]
public UInt32 get_Index();
    [CompilerGeneratedAttribute]
public void set_Index(UInt32 value);
    internal Transaction get_Transaction();
    public void UpdateFrom(PSBTOutput other);
    public void Serialize(BitcoinStream stream);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public bool Equals(PSBTOutput b);
    public virtual int GetHashCode();
    public Byte[] ToBytes();
    public void UpdateFromCoin(ICoin coin);
    internal void Write(JsonTextWriter jsonWriter);
    public virtual string ToString();
    public virtual Coin GetCoin();
    protected virtual PSBTHDKeyMatch CreateHDKeyMatch(IHDKey accountKey, KeyPath addressKeyPath, KeyValuePair`2<IPubKey, RootedKeyPath> kv);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class NBitcoin.PSBTOutputList : PSBTCoinList`1<PSBTOutput> {
    internal void Add(PSBTOutput item);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NBitcoin.PSBTSettings : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private IEnumerable`1<BuilderExtension> <CustomBuilderExtensions>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsSmart>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SkipVerifyScript>k__BackingField;
    [CompilerGeneratedAttribute]
private SigningOptions <SigningOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private ScriptVerify <ScriptVerify>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AutomaticUTXOTrimming>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IEnumerable`1<BuilderExtension> CustomBuilderExtensions { get; public set; }
    public bool IsSmart { get; public set; }
    public bool SkipVerifyScript { get; public set; }
    public SigningOptions SigningOptions { get; public set; }
    public ScriptVerify ScriptVerify { get; internal set; }
    public bool AutomaticUTXOTrimming { get; public set; }
    [CompilerGeneratedAttribute]
public IEnumerable`1<BuilderExtension> get_CustomBuilderExtensions();
    [CompilerGeneratedAttribute]
public void set_CustomBuilderExtensions(IEnumerable`1<BuilderExtension> value);
    [CompilerGeneratedAttribute]
public bool get_IsSmart();
    [CompilerGeneratedAttribute]
public void set_IsSmart(bool value);
    [CompilerGeneratedAttribute]
public bool get_SkipVerifyScript();
    [CompilerGeneratedAttribute]
public void set_SkipVerifyScript(bool value);
    [CompilerGeneratedAttribute]
public SigningOptions get_SigningOptions();
    [CompilerGeneratedAttribute]
public void set_SigningOptions(SigningOptions value);
    [CompilerGeneratedAttribute]
public ScriptVerify get_ScriptVerify();
    [CompilerGeneratedAttribute]
internal void set_ScriptVerify(ScriptVerify value);
    [CompilerGeneratedAttribute]
public bool get_AutomaticUTXOTrimming();
    [CompilerGeneratedAttribute]
public void set_AutomaticUTXOTrimming(bool value);
    public PSBTSettings Clone();
}
[ExtensionAttribute]
internal static class NBitcoin.PSBTUtils : object {
    [ExtensionAttribute]
public static void WritePropertyValue(JsonWriter writer, string name, TValue value);
    [ExtensionAttribute]
public static void WriteBIP32Derivations(JsonTextWriter jsonWriter, SortedDictionary`2<TaprootPubKey, TaprootKeyPath> hd_keypaths);
    [ExtensionAttribute]
public static void WriteBIP32Derivations(JsonTextWriter jsonWriter, SortedDictionary`2<PubKey, RootedKeyPath> hd_keypaths);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NBitcoin.PubKey : object {
    private bool compressed;
    private ECPubKey _ECKey;
    [NullableAttribute("2")]
private KeyId _ID;
    [NullableAttribute("2")]
private WitKeyId _WitID;
    [NullableAttribute("2")]
private PubKey _twin;
    [NullableAttribute("2")]
private TaprootInternalPubKey _InternalKey;
    [NullableAttribute("2")]
private TaprootPubKey _TaprootPubKey;
    private Nullable`1<HDFingerprint> fp;
    private Nullable`1<int> hashcode;
    [NullableAttribute("2")]
private Script _ScriptPubKey;
    [IsReadOnlyAttribute]
internal ECPubKey& modreq(System.Runtime.InteropServices.InAttribute) ECKey { get; }
    public KeyId Hash { get; }
    public WitKeyId WitHash { get; }
    public bool IsCompressed { get; }
    internal bool Parity { get; }
    public TaprootInternalPubKey TaprootInternalKey { get; }
    internal TaprootPubKey TaprootPubKey { get; }
    public Script ScriptPubKey { get; }
    public PubKey(string hex);
    internal PubKey(ECPubKey pubkey, bool compressed);
    public PubKey(Byte[] bytes);
    [NullableContextAttribute("0")]
public PubKey(ReadOnlySpan`1<byte> bytes);
    public static bool TryCreatePubKey(Byte[] bytes, PubKey& pubKey);
    [NullableContextAttribute("0")]
public static bool TryCreatePubKey(ReadOnlySpan`1<byte> bytes, PubKey& pubKey);
    internal ECPubKey& modreq(System.Runtime.InteropServices.InAttribute) get_ECKey();
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(PubKey other);
    public PubKey Compress();
    public PubKey Decompress();
    public static bool SanityCheck(Byte[] data);
    public static bool SanityCheck(Byte[] data, int offset, int count);
    public KeyId get_Hash();
    public WitKeyId get_WitHash();
    public bool get_IsCompressed();
    public BitcoinAddress GetAddress(ScriptPubKeyType type, Network network);
    public TaprootFullPubKey GetTaprootFullPubKey();
    public TaprootFullPubKey GetTaprootFullPubKey(uint256 merkleRoot);
    internal bool get_Parity();
    internal PubKey GetYCoordinateEvenPubKey();
    public TaprootInternalPubKey get_TaprootInternalKey();
    internal TaprootPubKey get_TaprootPubKey();
    public HDFingerprint GetHDFingerPrint();
    public bool Verify(uint256 hash, ECDSASignature sig);
    public bool Verify(uint256 hash, Byte[] sig);
    public Script GetScriptPubKey(ScriptPubKeyType type);
    public IAddressableDestination GetDestination(ScriptPubKeyType type);
    public string ToHex();
    public Byte[] ToBytes();
    [NullableContextAttribute("0")]
public void ToBytes(Span`1<byte> output, Int32& length);
    public Byte[] ToBytes(bool unsafe);
    public virtual string ToString();
    public static PubKey RecoverCompact(uint256 hash, CompactSignature compactSignature);
    public PubKey Derivate(Byte[] cc, UInt32 nChild, Byte[]& ccChild);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(PubKey pk);
    [NullableContextAttribute("2")]
public static bool op_Equality(PubKey a, PubKey b);
    [NullableContextAttribute("2")]
public static bool op_Inequality(PubKey a, PubKey b);
    public virtual int GetHashCode();
    public sealed virtual Script get_ScriptPubKey();
    public PubKey GetSharedPubkey(Key key);
    public string Encrypt(string message);
    public Byte[] Encrypt(Byte[] message);
}
internal class NBitcoin.PubKeyComparer : object {
    [CompilerGeneratedAttribute]
private static PubKeyComparer <Instance>k__BackingField;
    public static PubKeyComparer Instance { get; }
    private static PubKeyComparer();
    [CompilerGeneratedAttribute]
public static PubKeyComparer get_Instance();
    public sealed virtual int Compare(PubKey x, PubKey y);
}
public class NBitcoin.RandomNumberGeneratorRandom : object {
    private RandomNumberGenerator _Instance;
    public sealed virtual void GetBytes(Byte[] output);
    public sealed virtual void GetBytes(Span`1<byte> output);
}
public class NBitcoin.RandomUtils : object {
    [CompilerGeneratedAttribute]
private static bool <UseAdditionalEntropy>k__BackingField;
    [CompilerGeneratedAttribute]
private static IRandom <Random>k__BackingField;
    private static Byte[] modreq(System.Runtime.CompilerServices.IsVolatile) additionalEntropy;
    private static Int32 modreq(System.Runtime.CompilerServices.IsVolatile) entropyIndex;
    public static bool UseAdditionalEntropy { get; public set; }
    public static IRandom Random { get; public set; }
    private static RandomUtils();
    [CompilerGeneratedAttribute]
public static bool get_UseAdditionalEntropy();
    [CompilerGeneratedAttribute]
public static void set_UseAdditionalEntropy(bool value);
    [CompilerGeneratedAttribute]
public static IRandom get_Random();
    [CompilerGeneratedAttribute]
public static void set_Random(IRandom value);
    public static Byte[] GetBytes(int length);
    public static void GetBytes(Span`1<byte> span);
    private static void PushEntropy(Byte[] data);
    public static void AddEntropy(string data);
    public static void AddEntropy(Byte[] data);
    public static uint256 GetUInt256();
    public static UInt32 GetUInt32();
    public static int GetInt32();
    public static ulong GetUInt64();
    public static long GetInt64();
    public static void GetBytes(Byte[] output);
}
internal class NBitcoin.ReaderWriterLock : object {
    private ReaderWriterLockSlim lock;
    public IDisposable LockRead();
    public IDisposable LockWrite();
    internal bool TryLockWrite(IDisposable& locked);
    [CompilerGeneratedAttribute]
private void <LockRead>b__1_0();
    [CompilerGeneratedAttribute]
private void <LockRead>b__1_1();
    [CompilerGeneratedAttribute]
private void <LockWrite>b__2_0();
    [CompilerGeneratedAttribute]
private void <LockWrite>b__2_1();
    [CompilerGeneratedAttribute]
private void <TryLockWrite>b__3_1();
}
public enum NBitcoin.RedeemType : Enum {
    public int value__;
    public static RedeemType P2SH;
    public static RedeemType WitnessV0;
}
public class NBitcoin.RootedKeyPath : object {
    private KeyPath _KeyPath;
    private HDFingerprint _MasterFingerprint;
    public KeyPath KeyPath { get; }
    public HDFingerprint MasterFingerprint { get; }
    public RootedKeyPath(HDFingerprint masterFingerprint, KeyPath keyPath);
    public RootedKeyPath(IHDKey masterKey, KeyPath keyPath);
    public static RootedKeyPath Parse(string str);
    public static bool TryParse(string str, RootedKeyPath& result);
    public KeyPath get_KeyPath();
    public HDFingerprint get_MasterFingerprint();
    public RootedKeyPath Derive(KeyPath keyPath);
    public RootedKeyPath Derive(UInt32 index);
    public RootedKeyPath GetAccountKeyPath();
    public virtual string ToString();
    public string ToStringWithEmptyKeyPathAware();
    public virtual bool Equals(object obj);
    public static bool op_Equality(RootedKeyPath a, RootedKeyPath b);
    public static bool op_Inequality(RootedKeyPath a, RootedKeyPath b);
    public virtual int GetHashCode();
}
public class NBitcoin.RPC.AddedNodeInfo : object {
    [CompilerGeneratedAttribute]
private EndPoint <AddedNode>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Connected>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<NodeAddressInfo> <Addresses>k__BackingField;
    public EndPoint AddedNode { get; internal set; }
    public bool Connected { get; internal set; }
    public IEnumerable`1<NodeAddressInfo> Addresses { get; internal set; }
    [CompilerGeneratedAttribute]
public EndPoint get_AddedNode();
    [CompilerGeneratedAttribute]
internal void set_AddedNode(EndPoint value);
    [CompilerGeneratedAttribute]
public bool get_Connected();
    [CompilerGeneratedAttribute]
internal void set_Connected(bool value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<NodeAddressInfo> get_Addresses();
    [CompilerGeneratedAttribute]
internal void set_Addresses(IEnumerable`1<NodeAddressInfo> value);
}
public class NBitcoin.RPC.AddressGrouping : object {
    [CompilerGeneratedAttribute]
private BitcoinAddress <PublicAddress>k__BackingField;
    [CompilerGeneratedAttribute]
private Money <Amount>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Account>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<ChangeAddress> <ChangeAddresses>k__BackingField;
    public BitcoinAddress PublicAddress { get; public set; }
    public Money Amount { get; public set; }
    public string Account { get; public set; }
    public List`1<ChangeAddress> ChangeAddresses { get; public set; }
    [CompilerGeneratedAttribute]
public BitcoinAddress get_PublicAddress();
    [CompilerGeneratedAttribute]
public void set_PublicAddress(BitcoinAddress value);
    [CompilerGeneratedAttribute]
public Money get_Amount();
    [CompilerGeneratedAttribute]
public void set_Amount(Money value);
    [CompilerGeneratedAttribute]
public string get_Account();
    [CompilerGeneratedAttribute]
public void set_Account(string value);
    [CompilerGeneratedAttribute]
public List`1<ChangeAddress> get_ChangeAddresses();
    [CompilerGeneratedAttribute]
public void set_ChangeAddresses(List`1<ChangeAddress> value);
}
public enum NBitcoin.RPC.AddressType : Enum {
    public int value__;
    public static AddressType Legacy;
    public static AddressType P2SHSegwit;
    public static AddressType Bech32;
}
public class NBitcoin.RPC.BlockchainInfo : object {
    [CompilerGeneratedAttribute]
private Network <Chain>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <Blocks>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <Headers>k__BackingField;
    [CompilerGeneratedAttribute]
private uint256 <BestBlockHash>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <Difficulty>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <MedianTime>k__BackingField;
    [CompilerGeneratedAttribute]
private float <VerificationProgress>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <InitialBlockDownload>k__BackingField;
    [CompilerGeneratedAttribute]
private uint256 <ChainWork>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <SizeOnDisk>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Pruned>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<SoftFork> <SoftForks>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<Bip9SoftFork> <Bip9SoftForks>k__BackingField;
    public Network Chain { get; public set; }
    public ulong Blocks { get; public set; }
    public ulong Headers { get; public set; }
    public uint256 BestBlockHash { get; public set; }
    public ulong Difficulty { get; public set; }
    public ulong MedianTime { get; public set; }
    public float VerificationProgress { get; public set; }
    public bool InitialBlockDownload { get; public set; }
    public uint256 ChainWork { get; public set; }
    public ulong SizeOnDisk { get; public set; }
    public bool Pruned { get; public set; }
    [ObsoleteAttribute]
public List`1<SoftFork> SoftForks { get; public set; }
    [ObsoleteAttribute]
public List`1<Bip9SoftFork> Bip9SoftForks { get; public set; }
    [CompilerGeneratedAttribute]
public Network get_Chain();
    [CompilerGeneratedAttribute]
public void set_Chain(Network value);
    [CompilerGeneratedAttribute]
public ulong get_Blocks();
    [CompilerGeneratedAttribute]
public void set_Blocks(ulong value);
    [CompilerGeneratedAttribute]
public ulong get_Headers();
    [CompilerGeneratedAttribute]
public void set_Headers(ulong value);
    [CompilerGeneratedAttribute]
public uint256 get_BestBlockHash();
    [CompilerGeneratedAttribute]
public void set_BestBlockHash(uint256 value);
    [CompilerGeneratedAttribute]
public ulong get_Difficulty();
    [CompilerGeneratedAttribute]
public void set_Difficulty(ulong value);
    [CompilerGeneratedAttribute]
public ulong get_MedianTime();
    [CompilerGeneratedAttribute]
public void set_MedianTime(ulong value);
    [CompilerGeneratedAttribute]
public float get_VerificationProgress();
    [CompilerGeneratedAttribute]
public void set_VerificationProgress(float value);
    [CompilerGeneratedAttribute]
public bool get_InitialBlockDownload();
    [CompilerGeneratedAttribute]
public void set_InitialBlockDownload(bool value);
    [CompilerGeneratedAttribute]
public uint256 get_ChainWork();
    [CompilerGeneratedAttribute]
public void set_ChainWork(uint256 value);
    [CompilerGeneratedAttribute]
public ulong get_SizeOnDisk();
    [CompilerGeneratedAttribute]
public void set_SizeOnDisk(ulong value);
    [CompilerGeneratedAttribute]
public bool get_Pruned();
    [CompilerGeneratedAttribute]
public void set_Pruned(bool value);
    [CompilerGeneratedAttribute]
public List`1<SoftFork> get_SoftForks();
    [CompilerGeneratedAttribute]
public void set_SoftForks(List`1<SoftFork> value);
    [CompilerGeneratedAttribute]
public List`1<Bip9SoftFork> get_Bip9SoftForks();
    [CompilerGeneratedAttribute]
public void set_Bip9SoftForks(List`1<Bip9SoftFork> value);
}
internal static class NBitcoin.RPC.BlockExplorerFormatter : object {
    public static string ToString(Transaction transaction);
    private static void WritePropertyValue(JsonWriter writer, string name, TValue value);
    internal static void WriteTransaction(JsonTextWriter writer, Transaction tx);
}
public class NBitcoin.RPC.BlockFilter : object {
    [CompilerGeneratedAttribute]
private GolombRiceFilter <Filter>k__BackingField;
    [CompilerGeneratedAttribute]
private uint256 <Header>k__BackingField;
    public GolombRiceFilter Filter { get; }
    public uint256 Header { get; }
    public BlockFilter(GolombRiceFilter filter, uint256 header);
    [CompilerGeneratedAttribute]
public GolombRiceFilter get_Filter();
    [CompilerGeneratedAttribute]
public uint256 get_Header();
}
public class NBitcoin.RPC.BlockStats : object {
    [CompilerGeneratedAttribute]
private Money <AvgFee>k__BackingField;
    [CompilerGeneratedAttribute]
private Money <AvgFeeRate>k__BackingField;
    [CompilerGeneratedAttribute]
private int <AvgTxSize>k__BackingField;
    [CompilerGeneratedAttribute]
private uint256 <BlockHash>k__BackingField;
    [CompilerGeneratedAttribute]
private Money[] <FeeRatePercentiles>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Height>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Ins>k__BackingField;
    [CompilerGeneratedAttribute]
private Money <MaxFee>k__BackingField;
    [CompilerGeneratedAttribute]
private Money <MaxFeeRate>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxTxSize>k__BackingField;
    [CompilerGeneratedAttribute]
private Money <MedianFee>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <MedianTime>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MedianTxSize>k__BackingField;
    [CompilerGeneratedAttribute]
private Money <MinFee>k__BackingField;
    [CompilerGeneratedAttribute]
private Money <MinFeeRate>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MinTxSize>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Outs>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Subsidy>k__BackingField;
    [CompilerGeneratedAttribute]
private long <SWTotalSize>k__BackingField;
    [CompilerGeneratedAttribute]
private long <SWTotalWeight>k__BackingField;
    [CompilerGeneratedAttribute]
private int <SWTxs>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <Time>k__BackingField;
    [CompilerGeneratedAttribute]
private long <TotalOut>k__BackingField;
    [CompilerGeneratedAttribute]
private long <TotalSize>k__BackingField;
    [CompilerGeneratedAttribute]
private long <TotalWeight>k__BackingField;
    [CompilerGeneratedAttribute]
private Money <TotalFee>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Txs>k__BackingField;
    [CompilerGeneratedAttribute]
private int <UTXOIncrease>k__BackingField;
    [CompilerGeneratedAttribute]
private int <UTXOSizeInc>k__BackingField;
    public Money AvgFee { get; public set; }
    public Money AvgFeeRate { get; public set; }
    public int AvgTxSize { get; public set; }
    public uint256 BlockHash { get; public set; }
    public Money[] FeeRatePercentiles { get; public set; }
    public int Height { get; public set; }
    public int Ins { get; public set; }
    public Money MaxFee { get; public set; }
    public Money MaxFeeRate { get; public set; }
    public int MaxTxSize { get; public set; }
    public Money MedianFee { get; public set; }
    public DateTimeOffset MedianTime { get; public set; }
    public int MedianTxSize { get; public set; }
    public Money MinFee { get; public set; }
    public Money MinFeeRate { get; public set; }
    public int MinTxSize { get; public set; }
    public int Outs { get; public set; }
    public long Subsidy { get; public set; }
    public long SWTotalSize { get; public set; }
    public long SWTotalWeight { get; public set; }
    public int SWTxs { get; public set; }
    public DateTimeOffset Time { get; public set; }
    public long TotalOut { get; public set; }
    public long TotalSize { get; public set; }
    public long TotalWeight { get; public set; }
    public Money TotalFee { get; public set; }
    public int Txs { get; public set; }
    public int UTXOIncrease { get; public set; }
    public int UTXOSizeInc { get; public set; }
    [CompilerGeneratedAttribute]
public Money get_AvgFee();
    [CompilerGeneratedAttribute]
public void set_AvgFee(Money value);
    [CompilerGeneratedAttribute]
public Money get_AvgFeeRate();
    [CompilerGeneratedAttribute]
public void set_AvgFeeRate(Money value);
    [CompilerGeneratedAttribute]
public int get_AvgTxSize();
    [CompilerGeneratedAttribute]
public void set_AvgTxSize(int value);
    [CompilerGeneratedAttribute]
public uint256 get_BlockHash();
    [CompilerGeneratedAttribute]
public void set_BlockHash(uint256 value);
    [CompilerGeneratedAttribute]
public Money[] get_FeeRatePercentiles();
    [CompilerGeneratedAttribute]
public void set_FeeRatePercentiles(Money[] value);
    [CompilerGeneratedAttribute]
public int get_Height();
    [CompilerGeneratedAttribute]
public void set_Height(int value);
    [CompilerGeneratedAttribute]
public int get_Ins();
    [CompilerGeneratedAttribute]
public void set_Ins(int value);
    [CompilerGeneratedAttribute]
public Money get_MaxFee();
    [CompilerGeneratedAttribute]
public void set_MaxFee(Money value);
    [CompilerGeneratedAttribute]
public Money get_MaxFeeRate();
    [CompilerGeneratedAttribute]
public void set_MaxFeeRate(Money value);
    [CompilerGeneratedAttribute]
public int get_MaxTxSize();
    [CompilerGeneratedAttribute]
public void set_MaxTxSize(int value);
    [CompilerGeneratedAttribute]
public Money get_MedianFee();
    [CompilerGeneratedAttribute]
public void set_MedianFee(Money value);
    [CompilerGeneratedAttribute]
public DateTimeOffset get_MedianTime();
    [CompilerGeneratedAttribute]
public void set_MedianTime(DateTimeOffset value);
    [CompilerGeneratedAttribute]
public int get_MedianTxSize();
    [CompilerGeneratedAttribute]
public void set_MedianTxSize(int value);
    [CompilerGeneratedAttribute]
public Money get_MinFee();
    [CompilerGeneratedAttribute]
public void set_MinFee(Money value);
    [CompilerGeneratedAttribute]
public Money get_MinFeeRate();
    [CompilerGeneratedAttribute]
public void set_MinFeeRate(Money value);
    [CompilerGeneratedAttribute]
public int get_MinTxSize();
    [CompilerGeneratedAttribute]
public void set_MinTxSize(int value);
    [CompilerGeneratedAttribute]
public int get_Outs();
    [CompilerGeneratedAttribute]
public void set_Outs(int value);
    [CompilerGeneratedAttribute]
public long get_Subsidy();
    [CompilerGeneratedAttribute]
public void set_Subsidy(long value);
    [CompilerGeneratedAttribute]
public long get_SWTotalSize();
    [CompilerGeneratedAttribute]
public void set_SWTotalSize(long value);
    [CompilerGeneratedAttribute]
public long get_SWTotalWeight();
    [CompilerGeneratedAttribute]
public void set_SWTotalWeight(long value);
    [CompilerGeneratedAttribute]
public int get_SWTxs();
    [CompilerGeneratedAttribute]
public void set_SWTxs(int value);
    [CompilerGeneratedAttribute]
public DateTimeOffset get_Time();
    [CompilerGeneratedAttribute]
public void set_Time(DateTimeOffset value);
    [CompilerGeneratedAttribute]
public long get_TotalOut();
    [CompilerGeneratedAttribute]
public void set_TotalOut(long value);
    [CompilerGeneratedAttribute]
public long get_TotalSize();
    [CompilerGeneratedAttribute]
public void set_TotalSize(long value);
    [CompilerGeneratedAttribute]
public long get_TotalWeight();
    [CompilerGeneratedAttribute]
public void set_TotalWeight(long value);
    [CompilerGeneratedAttribute]
public Money get_TotalFee();
    [CompilerGeneratedAttribute]
public void set_TotalFee(Money value);
    [CompilerGeneratedAttribute]
public int get_Txs();
    [CompilerGeneratedAttribute]
public void set_Txs(int value);
    [CompilerGeneratedAttribute]
public int get_UTXOIncrease();
    [CompilerGeneratedAttribute]
public void set_UTXOIncrease(int value);
    [CompilerGeneratedAttribute]
public int get_UTXOSizeInc();
    [CompilerGeneratedAttribute]
public void set_UTXOSizeInc(int value);
}
public class NBitcoin.RPC.BumpResponse : object {
    [CompilerGeneratedAttribute]
private uint256 <TransactionId>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <OriginalFee>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <Fee>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <Errors>k__BackingField;
    public uint256 TransactionId { get; public set; }
    public ulong OriginalFee { get; public set; }
    public ulong Fee { get; public set; }
    public List`1<string> Errors { get; public set; }
    [CompilerGeneratedAttribute]
public uint256 get_TransactionId();
    [CompilerGeneratedAttribute]
public void set_TransactionId(uint256 value);
    [CompilerGeneratedAttribute]
public ulong get_OriginalFee();
    [CompilerGeneratedAttribute]
public void set_OriginalFee(ulong value);
    [CompilerGeneratedAttribute]
public ulong get_Fee();
    [CompilerGeneratedAttribute]
public void set_Fee(ulong value);
    [CompilerGeneratedAttribute]
public List`1<string> get_Errors();
    [CompilerGeneratedAttribute]
public void set_Errors(List`1<string> value);
}
public class NBitcoin.RPC.ChainInfo : object {
    [CompilerGeneratedAttribute]
private string <Chain>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Blocks>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Headers>k__BackingField;
    [CompilerGeneratedAttribute]
private uint256 <BestBlockHash>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Difficulty>k__BackingField;
    [CompilerGeneratedAttribute]
private decimal <VerificationProgress>k__BackingField;
    [CompilerGeneratedAttribute]
private uint256 <ChainWork>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsPruned>k__BackingField;
    public string Chain { get; internal set; }
    public int Blocks { get; internal set; }
    public int Headers { get; internal set; }
    public uint256 BestBlockHash { get; internal set; }
    public int Difficulty { get; internal set; }
    public decimal VerificationProgress { get; internal set; }
    public uint256 ChainWork { get; internal set; }
    public bool IsPruned { get; internal set; }
    [CompilerGeneratedAttribute]
public string get_Chain();
    [CompilerGeneratedAttribute]
internal void set_Chain(string value);
    [CompilerGeneratedAttribute]
public int get_Blocks();
    [CompilerGeneratedAttribute]
internal void set_Blocks(int value);
    [CompilerGeneratedAttribute]
public int get_Headers();
    [CompilerGeneratedAttribute]
internal void set_Headers(int value);
    [CompilerGeneratedAttribute]
public uint256 get_BestBlockHash();
    [CompilerGeneratedAttribute]
internal void set_BestBlockHash(uint256 value);
    [CompilerGeneratedAttribute]
public int get_Difficulty();
    [CompilerGeneratedAttribute]
internal void set_Difficulty(int value);
    [CompilerGeneratedAttribute]
public decimal get_VerificationProgress();
    [CompilerGeneratedAttribute]
internal void set_VerificationProgress(decimal value);
    [CompilerGeneratedAttribute]
public uint256 get_ChainWork();
    [CompilerGeneratedAttribute]
internal void set_ChainWork(uint256 value);
    [CompilerGeneratedAttribute]
public bool get_IsPruned();
    [CompilerGeneratedAttribute]
internal void set_IsPruned(bool value);
}
public class NBitcoin.RPC.ChangeAddress : object {
    [CompilerGeneratedAttribute]
private Money <Amount>k__BackingField;
    [CompilerGeneratedAttribute]
private BitcoinAddress <Address>k__BackingField;
    public Money Amount { get; public set; }
    public BitcoinAddress Address { get; public set; }
    [CompilerGeneratedAttribute]
public Money get_Amount();
    [CompilerGeneratedAttribute]
public void set_Amount(Money value);
    [CompilerGeneratedAttribute]
public BitcoinAddress get_Address();
    [CompilerGeneratedAttribute]
public void set_Address(BitcoinAddress value);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class NBitcoin.RPC.CreateWalletOptions : object {
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <DisablePrivateKeys>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <Blank>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Passphrase>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <AvoidReuse>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <Descriptors>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <LoadOnStartup>k__BackingField;
    public Nullable`1<bool> DisablePrivateKeys { get; public set; }
    public Nullable`1<bool> Blank { get; public set; }
    public string Passphrase { get; public set; }
    public Nullable`1<bool> AvoidReuse { get; public set; }
    public Nullable`1<bool> Descriptors { get; public set; }
    public Nullable`1<bool> LoadOnStartup { get; public set; }
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_DisablePrivateKeys();
    [CompilerGeneratedAttribute]
public void set_DisablePrivateKeys(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_Blank();
    [CompilerGeneratedAttribute]
public void set_Blank(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public string get_Passphrase();
    [CompilerGeneratedAttribute]
public void set_Passphrase(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_AvoidReuse();
    [CompilerGeneratedAttribute]
public void set_AvoidReuse(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_Descriptors();
    [CompilerGeneratedAttribute]
public void set_Descriptors(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_LoadOnStartup();
    [CompilerGeneratedAttribute]
public void set_LoadOnStartup(Nullable`1<bool> value);
}
public enum NBitcoin.RPC.EstimateSmartFeeMode : Enum {
    public int value__;
    public static EstimateSmartFeeMode Economical;
    public static EstimateSmartFeeMode Conservative;
}
public class NBitcoin.RPC.EstimateSmartFeeResponse : object {
    [CompilerGeneratedAttribute]
private FeeRate <FeeRate>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Blocks>k__BackingField;
    public FeeRate FeeRate { get; public set; }
    public int Blocks { get; public set; }
    [CompilerGeneratedAttribute]
public FeeRate get_FeeRate();
    [CompilerGeneratedAttribute]
public void set_FeeRate(FeeRate value);
    [CompilerGeneratedAttribute]
public int get_Blocks();
    [CompilerGeneratedAttribute]
public void set_Blocks(int value);
}
public class NBitcoin.RPC.FundRawTransactionOptions : object {
    [CompilerGeneratedAttribute]
private BitcoinAddress <ChangeAddress>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <ChangePosition>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludeWatching>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <LockUnspents>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <ReserveChangeKey>k__BackingField;
    [CompilerGeneratedAttribute]
private FeeRate <FeeRate>k__BackingField;
    [CompilerGeneratedAttribute]
private Int32[] <SubtractFeeFromOutputs>k__BackingField;
    public BitcoinAddress ChangeAddress { get; public set; }
    public Nullable`1<int> ChangePosition { get; public set; }
    public bool IncludeWatching { get; public set; }
    public bool LockUnspents { get; public set; }
    public Nullable`1<bool> ReserveChangeKey { get; public set; }
    public FeeRate FeeRate { get; public set; }
    public Int32[] SubtractFeeFromOutputs { get; public set; }
    [CompilerGeneratedAttribute]
public BitcoinAddress get_ChangeAddress();
    [CompilerGeneratedAttribute]
public void set_ChangeAddress(BitcoinAddress value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_ChangePosition();
    [CompilerGeneratedAttribute]
public void set_ChangePosition(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public bool get_IncludeWatching();
    [CompilerGeneratedAttribute]
public void set_IncludeWatching(bool value);
    [CompilerGeneratedAttribute]
public bool get_LockUnspents();
    [CompilerGeneratedAttribute]
public void set_LockUnspents(bool value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_ReserveChangeKey();
    [CompilerGeneratedAttribute]
public void set_ReserveChangeKey(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public FeeRate get_FeeRate();
    [CompilerGeneratedAttribute]
public void set_FeeRate(FeeRate value);
    [CompilerGeneratedAttribute]
public Int32[] get_SubtractFeeFromOutputs();
    [CompilerGeneratedAttribute]
public void set_SubtractFeeFromOutputs(Int32[] value);
}
public class NBitcoin.RPC.FundRawTransactionResponse : object {
    [CompilerGeneratedAttribute]
private Transaction <Transaction>k__BackingField;
    [CompilerGeneratedAttribute]
private Money <Fee>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ChangePos>k__BackingField;
    public Transaction Transaction { get; public set; }
    public Money Fee { get; public set; }
    public int ChangePos { get; public set; }
    [CompilerGeneratedAttribute]
public Transaction get_Transaction();
    [CompilerGeneratedAttribute]
public void set_Transaction(Transaction value);
    [CompilerGeneratedAttribute]
public Money get_Fee();
    [CompilerGeneratedAttribute]
public void set_Fee(Money value);
    [CompilerGeneratedAttribute]
public int get_ChangePos();
    [CompilerGeneratedAttribute]
public void set_ChangePos(int value);
}
public class NBitcoin.RPC.GetAddressInfoResponse : GetAddressInfoScriptInfoResponse {
    [CompilerGeneratedAttribute]
private bool <IsMine>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <Solvable>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private OutputDescriptor <Descriptor>k__BackingField;
    [CompilerGeneratedAttribute]
private GetAddressInfoScriptInfoResponse <Embedded>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Label>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <IsChange>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsWatchOnly>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTimeOffset> <Timestamp>k__BackingField;
    [CompilerGeneratedAttribute]
private KeyPath <HDKeyPath>k__BackingField;
    [CompilerGeneratedAttribute]
private uint160 <HDSeedID>k__BackingField;
    [CompilerGeneratedAttribute]
private uint160 <HDMasterKeyID>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <IsCompressed>k__BackingField;
    public bool IsMine { get; private set; }
    public Nullable`1<bool> Solvable { get; private set; }
    [NullableAttribute("2")]
public OutputDescriptor Descriptor { get; private set; }
    public GetAddressInfoScriptInfoResponse Embedded { get; private set; }
    public string Label { get; private set; }
    public Nullable`1<bool> IsChange { get; private set; }
    public bool IsWatchOnly { get; private set; }
    public Nullable`1<DateTimeOffset> Timestamp { get; private set; }
    public KeyPath HDKeyPath { get; private set; }
    public uint160 HDSeedID { get; private set; }
    public uint160 HDMasterKeyID { get; private set; }
    public Nullable`1<bool> IsCompressed { get; private set; }
    [CompilerGeneratedAttribute]
public bool get_IsMine();
    [CompilerGeneratedAttribute]
private void set_IsMine(bool value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_Solvable();
    [CompilerGeneratedAttribute]
private void set_Solvable(Nullable`1<bool> value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public OutputDescriptor get_Descriptor();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private void set_Descriptor(OutputDescriptor value);
    [CompilerGeneratedAttribute]
public GetAddressInfoScriptInfoResponse get_Embedded();
    [CompilerGeneratedAttribute]
private void set_Embedded(GetAddressInfoScriptInfoResponse value);
    [CompilerGeneratedAttribute]
public string get_Label();
    [CompilerGeneratedAttribute]
private void set_Label(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_IsChange();
    [CompilerGeneratedAttribute]
private void set_IsChange(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public bool get_IsWatchOnly();
    [CompilerGeneratedAttribute]
private void set_IsWatchOnly(bool value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTimeOffset> get_Timestamp();
    [CompilerGeneratedAttribute]
private void set_Timestamp(Nullable`1<DateTimeOffset> value);
    [CompilerGeneratedAttribute]
public KeyPath get_HDKeyPath();
    [CompilerGeneratedAttribute]
private void set_HDKeyPath(KeyPath value);
    [CompilerGeneratedAttribute]
public uint160 get_HDSeedID();
    [CompilerGeneratedAttribute]
private void set_HDSeedID(uint160 value);
    [CompilerGeneratedAttribute]
public uint160 get_HDMasterKeyID();
    [CompilerGeneratedAttribute]
private void set_HDMasterKeyID(uint160 value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_IsCompressed();
    [CompilerGeneratedAttribute]
private void set_IsCompressed(Nullable`1<bool> value);
    public static GetAddressInfoResponse FromJsonResponse(JObject raw, Network network);
    public virtual GetAddressInfoResponse LoadFromJson(JObject raw, Network network);
    private static void SetSubInfo(GetAddressInfoScriptInfoResponse target, JObject raw, Network network);
}
public class NBitcoin.RPC.GetAddressInfoScriptInfoResponse : object {
    [CompilerGeneratedAttribute]
private BitcoinAddress <Address>k__BackingField;
    [CompilerGeneratedAttribute]
private Script <ScriptPubKey>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsScript>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsWitness>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <WitnessVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <WitnessProgram>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Script>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Hex>k__BackingField;
    [CompilerGeneratedAttribute]
private PubKey <PubKey>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<PubKey> <PubKeys>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<UInt32> <SigsRequired>k__BackingField;
    public BitcoinAddress Address { get; internal set; }
    public Script ScriptPubKey { get; internal set; }
    public bool IsScript { get; internal set; }
    public bool IsWitness { get; internal set; }
    public Nullable`1<int> WitnessVersion { get; internal set; }
    public string WitnessProgram { get; internal set; }
    public string Script { get; internal set; }
    public string Hex { get; internal set; }
    public PubKey PubKey { get; internal set; }
    public List`1<PubKey> PubKeys { get; internal set; }
    public Nullable`1<UInt32> SigsRequired { get; internal set; }
    [CompilerGeneratedAttribute]
public BitcoinAddress get_Address();
    [CompilerGeneratedAttribute]
internal void set_Address(BitcoinAddress value);
    [CompilerGeneratedAttribute]
public Script get_ScriptPubKey();
    [CompilerGeneratedAttribute]
internal void set_ScriptPubKey(Script value);
    [CompilerGeneratedAttribute]
public bool get_IsScript();
    [CompilerGeneratedAttribute]
internal void set_IsScript(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsWitness();
    [CompilerGeneratedAttribute]
internal void set_IsWitness(bool value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_WitnessVersion();
    [CompilerGeneratedAttribute]
internal void set_WitnessVersion(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public string get_WitnessProgram();
    [CompilerGeneratedAttribute]
internal void set_WitnessProgram(string value);
    [CompilerGeneratedAttribute]
public string get_Script();
    [CompilerGeneratedAttribute]
internal void set_Script(string value);
    [CompilerGeneratedAttribute]
public string get_Hex();
    [CompilerGeneratedAttribute]
internal void set_Hex(string value);
    [CompilerGeneratedAttribute]
public PubKey get_PubKey();
    [CompilerGeneratedAttribute]
internal void set_PubKey(PubKey value);
    [CompilerGeneratedAttribute]
public List`1<PubKey> get_PubKeys();
    [CompilerGeneratedAttribute]
internal void set_PubKeys(List`1<PubKey> value);
    [CompilerGeneratedAttribute]
public Nullable`1<UInt32> get_SigsRequired();
    [CompilerGeneratedAttribute]
internal void set_SigsRequired(Nullable`1<UInt32> value);
}
public class NBitcoin.RPC.GetBlockRPCResponse : object {
    [CompilerGeneratedAttribute]
private int <Confirmations>k__BackingField;
    [CompilerGeneratedAttribute]
private int <StrippedSize>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Size>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Weight>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Height>k__BackingField;
    [CompilerGeneratedAttribute]
private string <VersionHex>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <MedianTimeUnix>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Difficulty>k__BackingField;
    [CompilerGeneratedAttribute]
private uint256 <ChainWork>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private uint256 <NextBlockHash>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private Block <Block>k__BackingField;
    [CompilerGeneratedAttribute]
private BlockHeader <Header>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<uint256> <TxIds>k__BackingField;
    public int Confirmations { get; public set; }
    public int StrippedSize { get; public set; }
    public int Size { get; public set; }
    public int Weight { get; public set; }
    public int Height { get; public set; }
    public string VersionHex { get; public set; }
    public UInt32 MedianTimeUnix { get; public set; }
    public double Difficulty { get; public set; }
    public uint256 ChainWork { get; public set; }
    [NullableAttribute("2")]
public uint256 NextBlockHash { get; public set; }
    [NullableAttribute("2")]
public Block Block { get; public set; }
    public BlockHeader Header { get; public set; }
    public List`1<uint256> TxIds { get; public set; }
    public DateTimeOffset MedianTime { get; }
    [CompilerGeneratedAttribute]
public int get_Confirmations();
    [CompilerGeneratedAttribute]
public void set_Confirmations(int value);
    [CompilerGeneratedAttribute]
public int get_StrippedSize();
    [CompilerGeneratedAttribute]
public void set_StrippedSize(int value);
    [CompilerGeneratedAttribute]
public int get_Size();
    [CompilerGeneratedAttribute]
public void set_Size(int value);
    [CompilerGeneratedAttribute]
public int get_Weight();
    [CompilerGeneratedAttribute]
public void set_Weight(int value);
    [CompilerGeneratedAttribute]
public int get_Height();
    [CompilerGeneratedAttribute]
public void set_Height(int value);
    [CompilerGeneratedAttribute]
public string get_VersionHex();
    [CompilerGeneratedAttribute]
public void set_VersionHex(string value);
    [CompilerGeneratedAttribute]
public UInt32 get_MedianTimeUnix();
    [CompilerGeneratedAttribute]
public void set_MedianTimeUnix(UInt32 value);
    [CompilerGeneratedAttribute]
public double get_Difficulty();
    [CompilerGeneratedAttribute]
public void set_Difficulty(double value);
    [CompilerGeneratedAttribute]
public uint256 get_ChainWork();
    [CompilerGeneratedAttribute]
public void set_ChainWork(uint256 value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public uint256 get_NextBlockHash();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_NextBlockHash(uint256 value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public Block get_Block();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_Block(Block value);
    [CompilerGeneratedAttribute]
public BlockHeader get_Header();
    [CompilerGeneratedAttribute]
public void set_Header(BlockHeader value);
    [CompilerGeneratedAttribute]
public List`1<uint256> get_TxIds();
    [CompilerGeneratedAttribute]
public void set_TxIds(List`1<uint256> value);
    public DateTimeOffset get_MedianTime();
}
public enum NBitcoin.RPC.GetBlockVerbosity : Enum {
    public int value__;
    public static GetBlockVerbosity WithOnlyTxId;
    public static GetBlockVerbosity WithFullTx;
}
public class NBitcoin.RPC.GetNewAddressRequest : object {
    [CompilerGeneratedAttribute]
private string <Label>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<AddressType> <AddressType>k__BackingField;
    public string Label { get; public set; }
    public Nullable`1<AddressType> AddressType { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Label();
    [CompilerGeneratedAttribute]
public void set_Label(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<AddressType> get_AddressType();
    [CompilerGeneratedAttribute]
public void set_AddressType(Nullable`1<AddressType> value);
}
public class NBitcoin.RPC.GetTxOutResponse : object {
    [CompilerGeneratedAttribute]
private uint256 <BestBlock>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Confirmations>k__BackingField;
    [CompilerGeneratedAttribute]
private TxOut <TxOut>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsCoinBase>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ScriptPubKeyType>k__BackingField;
    public uint256 BestBlock { get; public set; }
    public int Confirmations { get; public set; }
    public TxOut TxOut { get; public set; }
    public bool IsCoinBase { get; public set; }
    public string ScriptPubKeyType { get; public set; }
    [CompilerGeneratedAttribute]
public uint256 get_BestBlock();
    [CompilerGeneratedAttribute]
public void set_BestBlock(uint256 value);
    [CompilerGeneratedAttribute]
public int get_Confirmations();
    [CompilerGeneratedAttribute]
public void set_Confirmations(int value);
    [CompilerGeneratedAttribute]
public TxOut get_TxOut();
    [CompilerGeneratedAttribute]
public void set_TxOut(TxOut value);
    [CompilerGeneratedAttribute]
public bool get_IsCoinBase();
    [CompilerGeneratedAttribute]
public void set_IsCoinBase(bool value);
    [CompilerGeneratedAttribute]
public string get_ScriptPubKeyType();
    [CompilerGeneratedAttribute]
public void set_ScriptPubKeyType(string value);
}
public class NBitcoin.RPC.GetTxOutSetInfoResponse : object {
    [CompilerGeneratedAttribute]
private int <Height>k__BackingField;
    [CompilerGeneratedAttribute]
private uint256 <Bestblock>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Transactions>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Txouts>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Bogosize>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HashSerialized2>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HashSerialized3>k__BackingField;
    [CompilerGeneratedAttribute]
private long <DiskSize>k__BackingField;
    [CompilerGeneratedAttribute]
private Money <TotalAmount>k__BackingField;
    public int Height { get; public set; }
    public uint256 Bestblock { get; public set; }
    public long Transactions { get; public set; }
    public long Txouts { get; public set; }
    public long Bogosize { get; public set; }
    public string HashSerialized { get; }
    [ObsoleteAttribute("Use HashSerialized instead")]
public string HashSerialized2 { get; public set; }
    public string HashSerialized3 { get; public set; }
    public long DiskSize { get; public set; }
    public Money TotalAmount { get; public set; }
    [CompilerGeneratedAttribute]
public int get_Height();
    [CompilerGeneratedAttribute]
public void set_Height(int value);
    [CompilerGeneratedAttribute]
public uint256 get_Bestblock();
    [CompilerGeneratedAttribute]
public void set_Bestblock(uint256 value);
    [CompilerGeneratedAttribute]
public long get_Transactions();
    [CompilerGeneratedAttribute]
public void set_Transactions(long value);
    [CompilerGeneratedAttribute]
public long get_Txouts();
    [CompilerGeneratedAttribute]
public void set_Txouts(long value);
    [CompilerGeneratedAttribute]
public long get_Bogosize();
    [CompilerGeneratedAttribute]
public void set_Bogosize(long value);
    public string get_HashSerialized();
    [CompilerGeneratedAttribute]
public string get_HashSerialized2();
    [CompilerGeneratedAttribute]
public void set_HashSerialized2(string value);
    [CompilerGeneratedAttribute]
public string get_HashSerialized3();
    [CompilerGeneratedAttribute]
public void set_HashSerialized3(string value);
    [CompilerGeneratedAttribute]
public long get_DiskSize();
    [CompilerGeneratedAttribute]
public void set_DiskSize(long value);
    [CompilerGeneratedAttribute]
public Money get_TotalAmount();
    [CompilerGeneratedAttribute]
public void set_TotalAmount(Money value);
}
[JsonObjectAttribute]
public class NBitcoin.RPC.ImportMultiAddress : object {
    [CompilerGeneratedAttribute]
private ScriptPubKeyObject <ScriptPubKey>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTimeOffset> <Timestamp>k__BackingField;
    [CompilerGeneratedAttribute]
private Script <RedeemScript>k__BackingField;
    [CompilerGeneratedAttribute]
private PubKey[] <PubKeys>k__BackingField;
    [CompilerGeneratedAttribute]
private BitcoinSecret[] <Keys>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <Internal>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <WatchOnly>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Label>k__BackingField;
    [CompilerGeneratedAttribute]
private OutputDescriptor <Desc>k__BackingField;
    [CompilerGeneratedAttribute]
private Int32[] <Ranges>k__BackingField;
    [JsonPropertyAttribute]
[JsonConverterAttribute("NBitcoin.RPC.ImportMultiScriptPubKeyConverter")]
public ScriptPubKeyObject ScriptPubKey { get; public set; }
    [JsonPropertyAttribute("timestamp")]
public Nullable`1<DateTimeOffset> Timestamp { get; public set; }
    [JsonPropertyAttribute]
public Script RedeemScript { get; public set; }
    [JsonPropertyAttribute]
public PubKey[] PubKeys { get; public set; }
    [JsonPropertyAttribute]
public BitcoinSecret[] Keys { get; public set; }
    [JsonPropertyAttribute]
public Nullable`1<bool> Internal { get; public set; }
    [JsonPropertyAttribute]
public Nullable`1<bool> WatchOnly { get; public set; }
    [JsonPropertyAttribute]
public string Label { get; public set; }
    [JsonPropertyAttribute]
public OutputDescriptor Desc { get; public set; }
    [JsonPropertyAttribute]
public Int32[] Ranges { get; public set; }
    [JsonIgnoreAttribute]
unknown int Range {public set; }
    [CompilerGeneratedAttribute]
public ScriptPubKeyObject get_ScriptPubKey();
    [CompilerGeneratedAttribute]
public void set_ScriptPubKey(ScriptPubKeyObject value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTimeOffset> get_Timestamp();
    [CompilerGeneratedAttribute]
public void set_Timestamp(Nullable`1<DateTimeOffset> value);
    [CompilerGeneratedAttribute]
public Script get_RedeemScript();
    [CompilerGeneratedAttribute]
public void set_RedeemScript(Script value);
    [CompilerGeneratedAttribute]
public PubKey[] get_PubKeys();
    [CompilerGeneratedAttribute]
public void set_PubKeys(PubKey[] value);
    [CompilerGeneratedAttribute]
public BitcoinSecret[] get_Keys();
    [CompilerGeneratedAttribute]
public void set_Keys(BitcoinSecret[] value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_Internal();
    [CompilerGeneratedAttribute]
public void set_Internal(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_WatchOnly();
    [CompilerGeneratedAttribute]
public void set_WatchOnly(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public string get_Label();
    [CompilerGeneratedAttribute]
public void set_Label(string value);
    [CompilerGeneratedAttribute]
public OutputDescriptor get_Desc();
    [CompilerGeneratedAttribute]
public void set_Desc(OutputDescriptor value);
    [CompilerGeneratedAttribute]
public Int32[] get_Ranges();
    [CompilerGeneratedAttribute]
public void set_Ranges(Int32[] value);
    public void set_Range(int value);
}
internal class NBitcoin.RPC.ImportMultiScriptPubKeyConverter : JsonConverter {
    public virtual bool CanConvert(Type objectType);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
}
public class NBitcoin.RPC.ListUnspentOptions : object {
    [CompilerGeneratedAttribute]
private Nullable`1<decimal> <MinimumAmount>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<decimal> <MaximumAmount>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MaximumCount>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<decimal> <MinimumSumAmount>k__BackingField;
    public Nullable`1<decimal> MinimumAmount { get; public set; }
    public Nullable`1<decimal> MaximumAmount { get; public set; }
    public Nullable`1<int> MaximumCount { get; public set; }
    public Nullable`1<decimal> MinimumSumAmount { get; public set; }
    [CompilerGeneratedAttribute]
public Nullable`1<decimal> get_MinimumAmount();
    [CompilerGeneratedAttribute]
public void set_MinimumAmount(Nullable`1<decimal> value);
    [CompilerGeneratedAttribute]
public Nullable`1<decimal> get_MaximumAmount();
    [CompilerGeneratedAttribute]
public void set_MaximumAmount(Nullable`1<decimal> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_MaximumCount();
    [CompilerGeneratedAttribute]
public void set_MaximumCount(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<decimal> get_MinimumSumAmount();
    [CompilerGeneratedAttribute]
public void set_MinimumSumAmount(Nullable`1<decimal> value);
}
public class NBitcoin.RPC.MempoolAcceptResult : object {
    [CompilerGeneratedAttribute]
private uint256 <TxId>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsAllowed>k__BackingField;
    [CompilerGeneratedAttribute]
private RejectCode <RejectCode>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RejectReason>k__BackingField;
    public uint256 TxId { get; internal set; }
    public bool IsAllowed { get; internal set; }
    public RejectCode RejectCode { get; internal set; }
    public string RejectReason { get; internal set; }
    [CompilerGeneratedAttribute]
public uint256 get_TxId();
    [CompilerGeneratedAttribute]
internal void set_TxId(uint256 value);
    [CompilerGeneratedAttribute]
public bool get_IsAllowed();
    [CompilerGeneratedAttribute]
internal void set_IsAllowed(bool value);
    [CompilerGeneratedAttribute]
public RejectCode get_RejectCode();
    [CompilerGeneratedAttribute]
internal void set_RejectCode(RejectCode value);
    [CompilerGeneratedAttribute]
public string get_RejectReason();
    [CompilerGeneratedAttribute]
internal void set_RejectReason(string value);
}
public class NBitcoin.RPC.MempoolEntry : object {
    [CompilerGeneratedAttribute]
private uint256 <TransactionId>k__BackingField;
    [CompilerGeneratedAttribute]
private int <VirtualSizeBytes>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <Time>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Height>k__BackingField;
    [CompilerGeneratedAttribute]
private int <DescendantCount>k__BackingField;
    [CompilerGeneratedAttribute]
private int <DescendantVirtualSizeBytes>k__BackingField;
    [CompilerGeneratedAttribute]
private int <AncestorCount>k__BackingField;
    [CompilerGeneratedAttribute]
private int <AncestorVirtualSizeBytes>k__BackingField;
    [CompilerGeneratedAttribute]
private uint256 <TransactionIdWithWitness>k__BackingField;
    [CompilerGeneratedAttribute]
private Money <BaseFee>k__BackingField;
    [CompilerGeneratedAttribute]
private Money <ModifiedFee>k__BackingField;
    [CompilerGeneratedAttribute]
private Money <AncestorFees>k__BackingField;
    [CompilerGeneratedAttribute]
private Money <DescendantFees>k__BackingField;
    [CompilerGeneratedAttribute]
private uint256[] <Depends>k__BackingField;
    [CompilerGeneratedAttribute]
private uint256[] <SpentBy>k__BackingField;
    public uint256 TransactionId { get; public set; }
    public int VirtualSizeBytes { get; public set; }
    public DateTimeOffset Time { get; public set; }
    public int Height { get; public set; }
    public int DescendantCount { get; public set; }
    public int DescendantVirtualSizeBytes { get; public set; }
    public int AncestorCount { get; public set; }
    public int AncestorVirtualSizeBytes { get; public set; }
    public uint256 TransactionIdWithWitness { get; public set; }
    public Money BaseFee { get; public set; }
    public Money ModifiedFee { get; public set; }
    public Money AncestorFees { get; public set; }
    public Money DescendantFees { get; public set; }
    public uint256[] Depends { get; public set; }
    public uint256[] SpentBy { get; public set; }
    [CompilerGeneratedAttribute]
public uint256 get_TransactionId();
    [CompilerGeneratedAttribute]
public void set_TransactionId(uint256 value);
    [CompilerGeneratedAttribute]
public int get_VirtualSizeBytes();
    [CompilerGeneratedAttribute]
public void set_VirtualSizeBytes(int value);
    [CompilerGeneratedAttribute]
public DateTimeOffset get_Time();
    [CompilerGeneratedAttribute]
public void set_Time(DateTimeOffset value);
    [CompilerGeneratedAttribute]
public int get_Height();
    [CompilerGeneratedAttribute]
public void set_Height(int value);
    [CompilerGeneratedAttribute]
public int get_DescendantCount();
    [CompilerGeneratedAttribute]
public void set_DescendantCount(int value);
    [CompilerGeneratedAttribute]
public int get_DescendantVirtualSizeBytes();
    [CompilerGeneratedAttribute]
public void set_DescendantVirtualSizeBytes(int value);
    [CompilerGeneratedAttribute]
public int get_AncestorCount();
    [CompilerGeneratedAttribute]
public void set_AncestorCount(int value);
    [CompilerGeneratedAttribute]
public int get_AncestorVirtualSizeBytes();
    [CompilerGeneratedAttribute]
public void set_AncestorVirtualSizeBytes(int value);
    [CompilerGeneratedAttribute]
public uint256 get_TransactionIdWithWitness();
    [CompilerGeneratedAttribute]
public void set_TransactionIdWithWitness(uint256 value);
    [CompilerGeneratedAttribute]
public Money get_BaseFee();
    [CompilerGeneratedAttribute]
public void set_BaseFee(Money value);
    [CompilerGeneratedAttribute]
public Money get_ModifiedFee();
    [CompilerGeneratedAttribute]
public void set_ModifiedFee(Money value);
    [CompilerGeneratedAttribute]
public Money get_AncestorFees();
    [CompilerGeneratedAttribute]
public void set_AncestorFees(Money value);
    [CompilerGeneratedAttribute]
public Money get_DescendantFees();
    [CompilerGeneratedAttribute]
public void set_DescendantFees(Money value);
    [CompilerGeneratedAttribute]
public uint256[] get_Depends();
    [CompilerGeneratedAttribute]
public void set_Depends(uint256[] value);
    [CompilerGeneratedAttribute]
public uint256[] get_SpentBy();
    [CompilerGeneratedAttribute]
public void set_SpentBy(uint256[] value);
}
public class NBitcoin.RPC.NodeAddressInfo : object {
    [CompilerGeneratedAttribute]
private IPEndPoint <Address>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Connected>k__BackingField;
    public IPEndPoint Address { get; internal set; }
    public bool Connected { get; internal set; }
    [CompilerGeneratedAttribute]
public IPEndPoint get_Address();
    [CompilerGeneratedAttribute]
internal void set_Address(IPEndPoint value);
    [CompilerGeneratedAttribute]
public bool get_Connected();
    [CompilerGeneratedAttribute]
internal void set_Connected(bool value);
}
public class NBitcoin.RPC.NoEstimationException : Exception {
    public NoEstimationException(int nblock);
}
public class NBitcoin.RPC.PeerInfo : object {
    [CompilerGeneratedAttribute]
private int <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private EndPoint <Address>k__BackingField;
    [CompilerGeneratedAttribute]
private EndPoint <LocalAddress>k__BackingField;
    [CompilerGeneratedAttribute]
private NodeServices <Services>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <LastSend>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <LastReceive>k__BackingField;
    [CompilerGeneratedAttribute]
private long <BytesSent>k__BackingField;
    [CompilerGeneratedAttribute]
private long <BytesReceived>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <ConnectionTime>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<TimeSpan> <PingTime>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SubVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Inbound>k__BackingField;
    [CompilerGeneratedAttribute]
private int <StartingHeight>k__BackingField;
    [CompilerGeneratedAttribute]
private int <BanScore>k__BackingField;
    [CompilerGeneratedAttribute]
private int <SynchronizedHeaders>k__BackingField;
    [CompilerGeneratedAttribute]
private int <SynchronizedBlocks>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32[] <Inflight>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsWhiteListed>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <PingWait>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Blocks>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <TimeOffset>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Permissions>k__BackingField;
    public int Id { get; internal set; }
    public EndPoint Address { get; internal set; }
    public EndPoint LocalAddress { get; internal set; }
    public NodeServices Services { get; internal set; }
    public DateTimeOffset LastSend { get; internal set; }
    public DateTimeOffset LastReceive { get; internal set; }
    public long BytesSent { get; internal set; }
    public long BytesReceived { get; internal set; }
    public DateTimeOffset ConnectionTime { get; internal set; }
    public Nullable`1<TimeSpan> PingTime { get; internal set; }
    public int Version { get; internal set; }
    public string SubVersion { get; internal set; }
    public bool Inbound { get; internal set; }
    public int StartingHeight { get; internal set; }
    public int BanScore { get; internal set; }
    public int SynchronizedHeaders { get; internal set; }
    public int SynchronizedBlocks { get; internal set; }
    public UInt32[] Inflight { get; internal set; }
    public bool IsWhiteListed { get; internal set; }
    public TimeSpan PingWait { get; internal set; }
    public int Blocks { get; internal set; }
    public TimeSpan TimeOffset { get; internal set; }
    public String[] Permissions { get; public set; }
    [CompilerGeneratedAttribute]
public int get_Id();
    [CompilerGeneratedAttribute]
internal void set_Id(int value);
    [CompilerGeneratedAttribute]
public EndPoint get_Address();
    [CompilerGeneratedAttribute]
internal void set_Address(EndPoint value);
    [CompilerGeneratedAttribute]
public EndPoint get_LocalAddress();
    [CompilerGeneratedAttribute]
internal void set_LocalAddress(EndPoint value);
    [CompilerGeneratedAttribute]
public NodeServices get_Services();
    [CompilerGeneratedAttribute]
internal void set_Services(NodeServices value);
    [CompilerGeneratedAttribute]
public DateTimeOffset get_LastSend();
    [CompilerGeneratedAttribute]
internal void set_LastSend(DateTimeOffset value);
    [CompilerGeneratedAttribute]
public DateTimeOffset get_LastReceive();
    [CompilerGeneratedAttribute]
internal void set_LastReceive(DateTimeOffset value);
    [CompilerGeneratedAttribute]
public long get_BytesSent();
    [CompilerGeneratedAttribute]
internal void set_BytesSent(long value);
    [CompilerGeneratedAttribute]
public long get_BytesReceived();
    [CompilerGeneratedAttribute]
internal void set_BytesReceived(long value);
    [CompilerGeneratedAttribute]
public DateTimeOffset get_ConnectionTime();
    [CompilerGeneratedAttribute]
internal void set_ConnectionTime(DateTimeOffset value);
    [CompilerGeneratedAttribute]
public Nullable`1<TimeSpan> get_PingTime();
    [CompilerGeneratedAttribute]
internal void set_PingTime(Nullable`1<TimeSpan> value);
    [CompilerGeneratedAttribute]
public int get_Version();
    [CompilerGeneratedAttribute]
internal void set_Version(int value);
    [CompilerGeneratedAttribute]
public string get_SubVersion();
    [CompilerGeneratedAttribute]
internal void set_SubVersion(string value);
    [CompilerGeneratedAttribute]
public bool get_Inbound();
    [CompilerGeneratedAttribute]
internal void set_Inbound(bool value);
    [CompilerGeneratedAttribute]
public int get_StartingHeight();
    [CompilerGeneratedAttribute]
internal void set_StartingHeight(int value);
    [CompilerGeneratedAttribute]
public int get_BanScore();
    [CompilerGeneratedAttribute]
internal void set_BanScore(int value);
    [CompilerGeneratedAttribute]
public int get_SynchronizedHeaders();
    [CompilerGeneratedAttribute]
internal void set_SynchronizedHeaders(int value);
    [CompilerGeneratedAttribute]
public int get_SynchronizedBlocks();
    [CompilerGeneratedAttribute]
internal void set_SynchronizedBlocks(int value);
    [CompilerGeneratedAttribute]
public UInt32[] get_Inflight();
    [CompilerGeneratedAttribute]
internal void set_Inflight(UInt32[] value);
    [CompilerGeneratedAttribute]
public bool get_IsWhiteListed();
    [CompilerGeneratedAttribute]
internal void set_IsWhiteListed(bool value);
    [CompilerGeneratedAttribute]
public TimeSpan get_PingWait();
    [CompilerGeneratedAttribute]
internal void set_PingWait(TimeSpan value);
    [CompilerGeneratedAttribute]
public int get_Blocks();
    [CompilerGeneratedAttribute]
internal void set_Blocks(int value);
    [CompilerGeneratedAttribute]
public TimeSpan get_TimeOffset();
    [CompilerGeneratedAttribute]
internal void set_TimeOffset(TimeSpan value);
    [CompilerGeneratedAttribute]
public String[] get_Permissions();
    [CompilerGeneratedAttribute]
public void set_Permissions(String[] value);
}
public class NBitcoin.RPC.RawTransactionInfo : object {
    [CompilerGeneratedAttribute]
private Transaction <Transaction>k__BackingField;
    [CompilerGeneratedAttribute]
private uint256 <TransactionId>k__BackingField;
    [CompilerGeneratedAttribute]
private uint256 <Hash>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <Size>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <VirtualSize>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private LockTime <LockTime>k__BackingField;
    [CompilerGeneratedAttribute]
private uint256 <BlockHash>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <Confirmations>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTimeOffset> <TransactionTime>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTimeOffset> <BlockTime>k__BackingField;
    public Transaction Transaction { get; internal set; }
    public uint256 TransactionId { get; internal set; }
    public uint256 Hash { get; internal set; }
    public UInt32 Size { get; internal set; }
    public UInt32 VirtualSize { get; internal set; }
    public UInt32 Version { get; internal set; }
    public LockTime LockTime { get; internal set; }
    public uint256 BlockHash { get; internal set; }
    public UInt32 Confirmations { get; internal set; }
    public Nullable`1<DateTimeOffset> TransactionTime { get; internal set; }
    public Nullable`1<DateTimeOffset> BlockTime { get; internal set; }
    [CompilerGeneratedAttribute]
public Transaction get_Transaction();
    [CompilerGeneratedAttribute]
internal void set_Transaction(Transaction value);
    [CompilerGeneratedAttribute]
public uint256 get_TransactionId();
    [CompilerGeneratedAttribute]
internal void set_TransactionId(uint256 value);
    [CompilerGeneratedAttribute]
public uint256 get_Hash();
    [CompilerGeneratedAttribute]
internal void set_Hash(uint256 value);
    [CompilerGeneratedAttribute]
public UInt32 get_Size();
    [CompilerGeneratedAttribute]
internal void set_Size(UInt32 value);
    [CompilerGeneratedAttribute]
public UInt32 get_VirtualSize();
    [CompilerGeneratedAttribute]
internal void set_VirtualSize(UInt32 value);
    [CompilerGeneratedAttribute]
public UInt32 get_Version();
    [CompilerGeneratedAttribute]
internal void set_Version(UInt32 value);
    [CompilerGeneratedAttribute]
public LockTime get_LockTime();
    [CompilerGeneratedAttribute]
internal void set_LockTime(LockTime value);
    [CompilerGeneratedAttribute]
public uint256 get_BlockHash();
    [CompilerGeneratedAttribute]
internal void set_BlockHash(uint256 value);
    [CompilerGeneratedAttribute]
public UInt32 get_Confirmations();
    [CompilerGeneratedAttribute]
internal void set_Confirmations(UInt32 value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTimeOffset> get_TransactionTime();
    [CompilerGeneratedAttribute]
internal void set_TransactionTime(Nullable`1<DateTimeOffset> value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTimeOffset> get_BlockTime();
    [CompilerGeneratedAttribute]
internal void set_BlockTime(Nullable`1<DateTimeOffset> value);
}
public class NBitcoin.RPC.RestApiException : Exception {
    [CompilerGeneratedAttribute]
private HttpStatusCode <HttpStatusCode>k__BackingField;
    public HttpStatusCode HttpStatusCode { get; }
    public RestApiException(string message, HttpStatusCode httpStatusCode);
    [CompilerGeneratedAttribute]
public HttpStatusCode get_HttpStatusCode();
}
public class NBitcoin.RPC.RestClient : object {
    private Uri _address;
    private Network _network;
    private static Lazy`1<HttpClient> _Shared;
    private HttpClient _HttpClient;
    public Network Network { get; }
    public HttpClient HttpClient { get; public set; }
    public RestClient(Uri address);
    public RestClient(Uri address, Network network);
    private static RestClient();
    public Network get_Network();
    [AsyncStateMachineAttribute("NBitcoin.RPC.RestClient/<GetBlockAsync>d__6")]
public sealed virtual Task`1<Block> GetBlockAsync(uint256 blockId, CancellationToken cancellationToken);
    public Block GetBlock(uint256 blockId);
    [AsyncStateMachineAttribute("NBitcoin.RPC.RestClient/<GetTransactionAsync>d__8")]
public Task`1<Transaction> GetTransactionAsync(uint256 txId);
    public Transaction GetTransaction(uint256 txId);
    [AsyncStateMachineAttribute("NBitcoin.RPC.RestClient/<GetBlockHeadersAsync>d__10")]
public Task`1<IEnumerable`1<BlockHeader>> GetBlockHeadersAsync(uint256 blockId, int count);
    public IEnumerable`1<BlockHeader> GetBlockHeaders(uint256 blockId, int count);
    [AsyncStateMachineAttribute("NBitcoin.RPC.RestClient/<GetChainInfoAsync>d__12")]
public Task`1<ChainInfo> GetChainInfoAsync();
    [AsyncStateMachineAttribute("NBitcoin.RPC.RestClient/<GetUnspentOutputsAsync>d__13")]
public Task`1<UTxOutputs> GetUnspentOutputsAsync(IEnumerable`1<OutPoint> outPoints, bool checkMempool);
    [AsyncStateMachineAttribute("NBitcoin.RPC.RestClient/<SendRequestAsync>d__14")]
public Task`1<Byte[]> SendRequestAsync(string resource, RestResponseFormat format, String[] parms);
    public HttpClient get_HttpClient();
    public void set_HttpClient(HttpClient value);
    private HttpRequestMessage BuildHttpRequest(string resource, RestResponseFormat format, String[] parms);
    private bool IsPlainText(HttpResponseMessage httpResponse);
    [AsyncStateMachineAttribute("NBitcoin.RPC.RestClient/<GetWebResponse>d__22")]
private Task`1<HttpResponseMessage> GetWebResponse(HttpRequestMessage request);
}
public enum NBitcoin.RPC.RestResponseFormat : Enum {
    public int value__;
    public static RestResponseFormat Bin;
    public static RestResponseFormat Hex;
    public static RestResponseFormat Json;
}
public class NBitcoin.RPC.RPCCapabilities : object {
    [CompilerGeneratedAttribute]
private int <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SupportSignRawTransactionWith>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SupportSegwit>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SupportTaproot>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SupportScanUTXOSet>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SupportGetNetworkInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SupportEstimateSmartFee>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SupportGenerateToAddress>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SupportTestMempoolAccept>k__BackingField;
    public int Version { get; public set; }
    public bool SupportSignRawTransactionWith { get; public set; }
    public bool SupportSegwit { get; public set; }
    public bool SupportTaproot { get; public set; }
    public bool SupportScanUTXOSet { get; public set; }
    public bool SupportGetNetworkInfo { get; public set; }
    public bool SupportEstimateSmartFee { get; public set; }
    public bool SupportGenerateToAddress { get; public set; }
    public bool SupportTestMempoolAccept { get; public set; }
    [CompilerGeneratedAttribute]
public int get_Version();
    [CompilerGeneratedAttribute]
public void set_Version(int value);
    [CompilerGeneratedAttribute]
public bool get_SupportSignRawTransactionWith();
    [CompilerGeneratedAttribute]
public void set_SupportSignRawTransactionWith(bool value);
    [CompilerGeneratedAttribute]
public bool get_SupportSegwit();
    [CompilerGeneratedAttribute]
public void set_SupportSegwit(bool value);
    [CompilerGeneratedAttribute]
public bool get_SupportTaproot();
    [CompilerGeneratedAttribute]
public void set_SupportTaproot(bool value);
    [CompilerGeneratedAttribute]
public bool get_SupportScanUTXOSet();
    [CompilerGeneratedAttribute]
public void set_SupportScanUTXOSet(bool value);
    [CompilerGeneratedAttribute]
public bool get_SupportGetNetworkInfo();
    [CompilerGeneratedAttribute]
public void set_SupportGetNetworkInfo(bool value);
    [CompilerGeneratedAttribute]
public bool get_SupportEstimateSmartFee();
    [CompilerGeneratedAttribute]
public void set_SupportEstimateSmartFee(bool value);
    [CompilerGeneratedAttribute]
public bool get_SupportGenerateToAddress();
    [CompilerGeneratedAttribute]
public void set_SupportGenerateToAddress(bool value);
    [CompilerGeneratedAttribute]
public bool get_SupportTestMempoolAccept();
    [CompilerGeneratedAttribute]
public void set_SupportTestMempoolAccept(bool value);
    public RPCCapabilities Clone(int newVersion);
    public virtual string ToString();
}
public class NBitcoin.RPC.RPCClient : object {
    private static Lazy`1<HttpClient> _Shared;
    private HttpClient _HttpClient;
    private string _Authentication;
    private Uri _address;
    private RPCCredentialString _CredentialString;
    private Network _network;
    private static ConcurrentDictionary`2<Network, string> _DefaultPaths;
    [CompilerGeneratedAttribute]
private RPCCapabilities <Capabilities>k__BackingField;
    private ConcurrentQueue`1<Tuple`2<RPCRequest, TaskCompletionSource`1<RPCResponse>>> _BatchedRequests;
    private static Object[] NoParams;
    [CompilerGeneratedAttribute]
private bool <AllowBatchFallback>k__BackingField;
    private static Encoding NoBOMUTF8;
    private JsonSerializerSettings _JsonSerializer;
    public HttpClient HttpClient { get; public set; }
    public Uri Address { get; }
    public RPCCredentialString CredentialString { get; }
    public Network Network { get; }
    public RPCCapabilities Capabilities { get; public set; }
    public string Authentication { get; }
    public bool AllowBatchFallback { get; public set; }
    private JsonSerializerSettings JsonSerializerSettings { get; }
    public RPCClient(Network network);
    [ObsoleteAttribute("Use RPCClient(ConnectionString, string, Network)")]
public RPCClient(NetworkCredential credentials, string host, Network network);
    public RPCClient(RPCCredentialString credentials, Network network);
    public RPCClient(RPCCredentialString credentials, string host, Network network);
    public RPCClient(RPCCredentialString credentials, Uri address, Network network);
    private static RPCClient();
    public RPCClient(string authenticationString, string hostOrUri, Network network);
    public RPCClient(NetworkCredential credentials, Uri address, Network network);
    public RPCClient(string authenticationString, Uri address, Network network);
    public static string GetRPCAuth(NetworkCredential credentials);
    public HttpClient get_HttpClient();
    public void set_HttpClient(HttpClient value);
    public Uri get_Address();
    public RPCCredentialString get_CredentialString();
    public Network get_Network();
    public static void RegisterDefaultCookiePath(Network network, string path);
    private string GetCookiePath();
    [CompilerGeneratedAttribute]
public RPCCapabilities get_Capabilities();
    [CompilerGeneratedAttribute]
public void set_Capabilities(RPCCapabilities value);
    [AsyncStateMachineAttribute("NBitcoin.RPC.RPCClient/<ScanRPCCapabilitiesAsync>d__29")]
public Task`1<RPCCapabilities> ScanRPCCapabilitiesAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NBitcoin.RPC.RPCClient/<SetVersion>d__30")]
private Task SetVersion(RPCCapabilities capabilities);
    public RPCCapabilities ScanRPCCapabilities();
    [AsyncStateMachineAttribute("NBitcoin.RPC.RPCClient/<CheckSegwitCapabilitiesAsync>d__32")]
private static Task CheckSegwitCapabilitiesAsync(RPCClient rpc, Action`1<bool> setResult, ScriptPubKeyType type, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NBitcoin.RPC.RPCClient/<CheckCapabilities>d__33")]
private static Task CheckCapabilities(Func`1<Task> command, Action`1<bool> setResult);
    private static Task CheckCapabilitiesAsync(RPCClient rpc, string command, Action`1<bool> setResult, CancellationToken cancellationToken);
    public static string GetDefaultCookieFilePath(Network network);
    public static string TryGetDefaultCookieFilePath(Network network);
    private static Uri BuildUri(string hostOrUri, string connectionString, int port);
    public string get_Authentication();
    public RPCClient PrepareBatch();
    public RPCClient Clone();
    public RPCResponse SendCommand(RPCOperations commandName, Object[] parameters);
    public RPCResponse SendCommand(string commandName, Object[] parameters);
    public RPCResponse SendCommand(RPCOperations commandName, CancellationToken cancellationToken, Object[] parameters);
    public RPCResponse SendCommand(string commandName, CancellationToken cancellationToken, Object[] parameters);
    public BitcoinAddress GetNewAddress(CancellationToken cancellationToken);
    public BitcoinAddress GetNewAddress(GetNewAddressRequest request);
    [AsyncStateMachineAttribute("NBitcoin.RPC.RPCClient/<GetNewAddressAsync>d__52")]
public Task`1<BitcoinAddress> GetNewAddressAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NBitcoin.RPC.RPCClient/<GetNewAddressAsync>d__53")]
public Task`1<BitcoinAddress> GetNewAddressAsync(GetNewAddressRequest request, CancellationToken cancellationToken);
    public BitcoinAddress GetRawChangeAddress();
    [AsyncStateMachineAttribute("NBitcoin.RPC.RPCClient/<GetRawChangeAddressAsync>d__55")]
public Task`1<BitcoinAddress> GetRawChangeAddressAsync();
    public Task`1<RPCResponse> SendCommandAsync(RPCOperations commandName, Object[] parameters);
    public Task`1<RPCResponse> SendCommandAsync(RPCOperations commandName, CancellationToken cancellationToken, Object[] parameters);
    public RPCResponse SendCommandWithNamedArgs(string commandName, Dictionary`2<string, object> parameters, CancellationToken cancellationToken);
    public Task`1<RPCResponse> SendCommandWithNamedArgsAsync(string commandName, Dictionary`2<string, object> parameters, CancellationToken cancellationToken);
    public Task`1<RPCResponse> SendCommandAsync(string commandName, Object[] parameters);
    public Task`1<RPCResponse> SendCommandAsync(string commandName, CancellationToken cancellationToken, Object[] parameters);
    public void SendBatch();
    public void CancelBatch();
    [AsyncStateMachineAttribute("NBitcoin.RPC.RPCClient/<StopAsync>d__65")]
public Task StopAsync(CancellationToken cancellationToken);
    public void Stop(CancellationToken cancellationToken);
    public TimeSpan Uptime();
    [AsyncStateMachineAttribute("NBitcoin.RPC.RPCClient/<UptimeAsync>d__68")]
public Task`1<TimeSpan> UptimeAsync(CancellationToken cancellationToken);
    public ScanTxoutSetResponse StartScanTxoutSet(ScanTxoutSetParameters parameters, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NBitcoin.RPC.RPCClient/<StartScanTxoutSetAsync>d__70")]
public Task`1<ScanTxoutSetResponse> StartScanTxoutSetAsync(ScanTxoutSetParameters parameters, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NBitcoin.RPC.RPCClient/<GetStatusScanTxoutSetAsync>d__71")]
public Task`1<Nullable`1<decimal>> GetStatusScanTxoutSetAsync(CancellationToken cancellationToken);
    public Nullable`1<decimal> GetStatusScanTxoutSet();
    [AsyncStateMachineAttribute("NBitcoin.RPC.RPCClient/<AbortScanTxoutSetAsync>d__73")]
public Task`1<bool> AbortScanTxoutSetAsync(CancellationToken cancellationToken);
    public bool AbortScanTxoutSet();
    [AsyncStateMachineAttribute("NBitcoin.RPC.RPCClient/<SendBatchAsync>d__75")]
public Task SendBatchAsync(CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
public bool get_AllowBatchFallback();
    [CompilerGeneratedAttribute]
public void set_AllowBatchFallback(bool value);
    [AsyncStateMachineAttribute("NBitcoin.RPC.RPCClient/<SendBatchAsyncCore>d__80")]
private Task SendBatchAsyncCore(List`1<Tuple`2<RPCRequest, TaskCompletionSource`1<RPCResponse>>> requests, CancellationToken cancellationToken);
    private bool TryRenewCookie();
    [AsyncStateMachineAttribute("NBitcoin.RPC.RPCClient/<SendCommandAsync>d__83")]
public Task`1<RPCResponse> SendCommandAsync(RPCRequest request, CancellationToken cancellationToken);
    private bool IsJson(HttpResponseMessage httpResponse);
    [AsyncStateMachineAttribute("NBitcoin.RPC.RPCClient/<IsWorkQueueFull>d__85")]
private Task`1<bool> IsWorkQueueFull(HttpResponseMessage httpResponse);
    private HttpRequestMessage CreateWebRequest(string json);
    [AsyncStateMachineAttribute("NBitcoin.RPC.RPCClient/<ToMemoryStreamAsync>d__87")]
private Task`1<Stream> ToMemoryStreamAsync(Stream stream);
    public PeerInfo[] GetPeersInfo();
    [AsyncStateMachineAttribute("NBitcoin.RPC.RPCClient/<GetPeersInfoAsync>d__89")]
public Task`1<PeerInfo[]> GetPeersInfoAsync(CancellationToken cancellationToken);
    public void AddNode(EndPoint nodeEndPoint, bool onetry);
    [AsyncStateMachineAttribute("NBitcoin.RPC.RPCClient/<AddNodeAsync>d__91")]
public Task AddNodeAsync(EndPoint nodeEndPoint, bool onetry, CancellationToken cancellationToken);
    public void RemoveNode(EndPoint nodeEndPoint);
    [AsyncStateMachineAttribute("NBitcoin.RPC.RPCClient/<RemoveNodeAsync>d__93")]
public Task RemoveNodeAsync(EndPoint nodeEndPoint, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NBitcoin.RPC.RPCClient/<GetAddedNodeInfoAsync>d__94")]
public Task`1<AddedNodeInfo[]> GetAddedNodeInfoAsync(bool detailed, CancellationToken cancellationToken);
    public AddedNodeInfo[] GetAddedNodeInfo(bool detailed);
    public AddedNodeInfo GetAddedNodeInfo(bool detailed, EndPoint nodeEndPoint);
    [AsyncStateMachineAttribute("NBitcoin.RPC.RPCClient/<GetAddedNodeInfoAync>d__97")]
public Task`1<AddedNodeInfo> GetAddedNodeInfoAync(bool detailed, EndPoint nodeEndPoint, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NBitcoin.RPC.RPCClient/<GetBlockchainInfoAsync>d__98")]
public Task`1<BlockchainInfo> GetBlockchainInfoAsync(CancellationToken cancellationToken);
    public BlockchainInfo GetBlockchainInfo();
    public uint256 GetBestBlockHash();
    [AsyncStateMachineAttribute("NBitcoin.RPC.RPCClient/<GetBestBlockHashAsync>d__101")]
public Task`1<uint256> GetBestBlockHashAsync(CancellationToken cancellationToken);
    public BlockHeader GetBlockHeader(int height);
    public BlockHeader GetBlockHeader(UInt32 height);
    [AsyncStateMachineAttribute("NBitcoin.RPC.RPCClient/<GetBlockHeaderAsync>d__104")]
public Task`1<BlockHeader> GetBlockHeaderAsync(int height, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NBitcoin.RPC.RPCClient/<GetBlockHeaderAsync>d__105")]
public Task`1<BlockHeader> GetBlockHeaderAsync(UInt32 height, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NBitcoin.RPC.RPCClient/<GetBlockAsync>d__106")]
public sealed virtual Task`1<Block> GetBlockAsync(uint256 blockId, CancellationToken cancellationToken);
    public Block GetBlock(uint256 blockId);
    public Block GetBlock(int height);
    public Block GetBlock(UInt32 height);
    [AsyncStateMachineAttribute("NBitcoin.RPC.RPCClient/<GetBlockAsync>d__110")]
public Task`1<Block> GetBlockAsync(int height, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NBitcoin.RPC.RPCClient/<GetBlockAsync>d__111")]
public Task`1<Block> GetBlockAsync(UInt32 height, CancellationToken cancellationToken);
    public BlockHeader GetBlockHeader(uint256 blockHash);
    [AsyncStateMachineAttribute("NBitcoin.RPC.RPCClient/<GetBlockHeaderAsync>d__113")]
public Task`1<BlockHeader> GetBlockHeaderAsync(uint256 blockHash, CancellationToken cancellationToken);
    private BlockHeader ParseBlockHeader(RPCResponse resp);
    public GetBlockRPCResponse GetBlock(uint256 blockHash, GetBlockVerbosity verbosity);
    [AsyncStateMachineAttribute("NBitcoin.RPC.RPCClient/<GetBlockAsync>d__116")]
public Task`1<GetBlockRPCResponse> GetBlockAsync(uint256 blockHash, GetBlockVerbosity verbosity, CancellationToken cancellationToken);
    private GetBlockRPCResponse ParseVerboseBlock(RPCResponse resp, int verbosity);
    public uint256 GetBlockHash(int height);
    public uint256 GetBlockHash(UInt32 height);
    [AsyncStateMachineAttribute("NBitcoin.RPC.RPCClient/<GetBlockHashAsync>d__120")]
public Task`1<uint256> GetBlockHashAsync(int height, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NBitcoin.RPC.RPCClient/<GetBlockHashAsync>d__121")]
public Task`1<uint256> GetBlockHashAsync(UInt32 height, CancellationToken cancellationToken);
    public BlockFilter GetBlockFilter(uint256 blockHash);
    [AsyncStateMachineAttribute("NBitcoin.RPC.RPCClient/<GetBlockFilterAsync>d__123")]
public Task`1<BlockFilter> GetBlockFilterAsync(uint256 blockHash, CancellationToken cancellationToken);
    private BlockFilter ParseCompactFilter(RPCResponse resp);
    public BlockStats GetBlockStats(uint256 blockHash, String[] stats);
    public Task`1<BlockStats> GetBlockStatsAsync(uint256 blockHash, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NBitcoin.RPC.RPCClient/<GetBlockStatsAsync>d__127")]
public Task`1<BlockStats> GetBlockStatsAsync(uint256 blockHash, String[] stats, CancellationToken cancellationToken);
    public int GetBlockCount();
    [AsyncStateMachineAttribute("NBitcoin.RPC.RPCClient/<GetBlockCountAsync>d__129")]
public Task`1<int> GetBlockCountAsync(CancellationToken cancellationToken);
    public MemPoolInfo GetMemPool();
    [AsyncStateMachineAttribute("NBitcoin.RPC.RPCClient/<GetMemPoolAsync>d__131")]
public Task`1<MemPoolInfo> GetMemPoolAsync(CancellationToken cancellationToken);
    public uint256[] GetRawMempool();
    [AsyncStateMachineAttribute("NBitcoin.RPC.RPCClient/<GetRawMempoolAsync>d__133")]
public Task`1<uint256[]> GetRawMempoolAsync(CancellationToken cancellationToken);
    public MempoolEntry GetMempoolEntry(uint256 txid, bool throwIfNotFound);
    [AsyncStateMachineAttribute("NBitcoin.RPC.RPCClient/<GetMempoolEntryAsync>d__135")]
public Task`1<MempoolEntry> GetMempoolEntryAsync(uint256 txid, bool throwIfNotFound, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NBitcoin.RPC.RPCClient/<SaveMempoolAsync>d__136")]
public Task SaveMempoolAsync(CancellationToken cancellationToken);
    public void SaveMempool();
    [NullableContextAttribute("1")]
public MempoolAcceptResult TestMempoolAccept(Transaction transaction, TestMempoolParameters parameters, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
public MempoolAcceptResult TestMempoolAccept(Transaction transaction, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("NBitcoin.RPC.RPCClient/<TestMempoolAcceptAsync>d__140")]
public Task`1<MempoolAcceptResult> TestMempoolAcceptAsync(Transaction transaction, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("NBitcoin.RPC.RPCClient/<TestMempoolAcceptAsync>d__141")]
public Task`1<MempoolAcceptResult> TestMempoolAcceptAsync(Transaction transaction, TestMempoolParameters parameters, CancellationToken cancellationToken);
    public GetTxOutResponse GetTxOut(uint256 txid, int index, bool includeMempool);
    [AsyncStateMachineAttribute("NBitcoin.RPC.RPCClient/<GetTxOutAsync>d__143")]
public Task`1<GetTxOutResponse> GetTxOutAsync(uint256 txid, int index, bool includeMempool, CancellationToken cancellationToken);
    public GetTxOutSetInfoResponse GetTxoutSetInfo();
    [AsyncStateMachineAttribute("NBitcoin.RPC.RPCClient/<GetTxoutSetInfoAsync>d__145")]
public Task`1<GetTxOutSetInfoResponse> GetTxoutSetInfoAsync(CancellationToken cancellationToken);
    [IteratorStateMachineAttribute("NBitcoin.RPC.RPCClient/<GetTransactions>d__146")]
public IEnumerable`1<Transaction> GetTransactions(uint256 blockHash, CancellationToken cancellationToken);
    public IEnumerable`1<Transaction> GetTransactions(int height);
    public Transaction DecodeRawTransaction(string rawHex);
    public Transaction DecodeRawTransaction(Byte[] raw);
    public Task`1<Transaction> DecodeRawTransactionAsync(string rawHex);
    public Task`1<Transaction> DecodeRawTransactionAsync(Byte[] raw);
    public Transaction GetRawTransaction(uint256 txid, bool throwIfNotFound);
    public Task`1<Transaction> GetRawTransactionAsync(uint256 txid, bool throwIfNotFound, CancellationToken cancellationToken);
    public Transaction GetRawTransaction(uint256 txid, uint256 blockId, bool throwIfNotFound);
    [AsyncStateMachineAttribute("NBitcoin.RPC.RPCClient/<GetRawTransactionAsync>d__155")]
public Task`1<Transaction> GetRawTransactionAsync(uint256 txid, uint256 blockId, bool throwIfNotFound, CancellationToken cancellationToken);
    public RawTransactionInfo GetRawTransactionInfo(uint256 txid);
    private Transaction ParseTxHex(string hex);
    [AsyncStateMachineAttribute("NBitcoin.RPC.RPCClient/<GetRawTransactionInfoAsync>d__158")]
public Task`1<RawTransactionInfo> GetRawTransactionInfoAsync(uint256 txId, CancellationToken cancellationToken);
    public uint256 SendRawTransaction(Transaction tx);
    public uint256 SendRawTransaction(Byte[] bytes);
    public Task`1<uint256> SendRawTransactionAsync(Transaction tx, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NBitcoin.RPC.RPCClient/<SendRawTransactionAsync>d__162")]
public Task`1<uint256> SendRawTransactionAsync(Byte[] bytes, CancellationToken cancellationToken);
    public BumpResponse BumpFee(uint256 txid);
    [AsyncStateMachineAttribute("NBitcoin.RPC.RPCClient/<BumpFeeAsync>d__164")]
public Task`1<BumpResponse> BumpFeeAsync(uint256 txid, CancellationToken cancellationToken);
    public EstimateSmartFeeResponse EstimateSmartFee(int confirmationTarget, EstimateSmartFeeMode estimateMode);
    [AsyncStateMachineAttribute("NBitcoin.RPC.RPCClient/<TryEstimateSmartFeeAsync>d__166")]
public Task`1<EstimateSmartFeeResponse> TryEstimateSmartFeeAsync(int confirmationTarget, EstimateSmartFeeMode estimateMode, CancellationToken cancellationToken);
    public EstimateSmartFeeResponse TryEstimateSmartFee(int confirmationTarget, EstimateSmartFeeMode estimateMode);
    [AsyncStateMachineAttribute("NBitcoin.RPC.RPCClient/<EstimateSmartFeeAsync>d__168")]
public Task`1<EstimateSmartFeeResponse> EstimateSmartFeeAsync(int confirmationTarget, EstimateSmartFeeMode estimateMode, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NBitcoin.RPC.RPCClient/<EstimateSmartFeeImplAsync>d__169")]
private Task`1<EstimateSmartFeeResponse> EstimateSmartFeeImplAsync(int confirmationTarget, EstimateSmartFeeMode estimateMode, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
public uint256 SendToAddress(BitcoinAddress address, Money amount, SendToAddressParameters parameters, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
public uint256 SendToAddress(BitcoinAddress address, Money amount, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
public uint256 SendToAddress(Script scriptPubKey, Money amount, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
public Task`1<uint256> SendToAddressAsync(Script scriptPubKey, Money amount, SendToAddressParameters parameters, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
public Task`1<uint256> SendToAddressAsync(Script scriptPubKey, Money amount, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
public uint256 SendToAddress(Script scriptPubKey, Money amount, SendToAddressParameters parameters, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
public Task`1<uint256> SendToAddressAsync(BitcoinAddress address, Money amount, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("NBitcoin.RPC.RPCClient/<SendToAddressAsync>d__177")]
public Task`1<uint256> SendToAddressAsync(BitcoinAddress address, Money amount, SendToAddressParameters parameters, CancellationToken cancellationToken);
    public bool SetTxFee(FeeRate feeRate, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NBitcoin.RPC.RPCClient/<GenerateAsync>d__179")]
public Task`1<uint256[]> GenerateAsync(int nBlocks, CancellationToken cancellationToken);
    public uint256[] Generate(int nBlocks);
    [AsyncStateMachineAttribute("NBitcoin.RPC.RPCClient/<GenerateToAddressAsync>d__181")]
public Task`1<uint256[]> GenerateToAddressAsync(int nBlocks, BitcoinAddress address, CancellationToken cancellationToken);
    public uint256[] GenerateToAddress(int nBlocks, BitcoinAddress address);
    public void InvalidateBlock(uint256 blockhash, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NBitcoin.RPC.RPCClient/<InvalidateBlockAsync>d__184")]
public Task InvalidateBlockAsync(uint256 blockhash, CancellationToken cancellationToken);
    public bool AddPeerAddress(IPAddress ip, int port);
    [AsyncStateMachineAttribute("NBitcoin.RPC.RPCClient/<AddPeerAddressAsync>d__186")]
public Task`1<bool> AddPeerAddressAsync(IPAddress ip, int port, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
[ObsoleteAttribute("This method is being renamed, use SetWalletContext instead")]
public RPCClient GetWallet(string walletName);
    [NullableContextAttribute("1")]
public RPCClient SetWalletContext(string walletName);
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("NBitcoin.RPC.RPCClient/<CreateWalletAsync>d__189")]
public Task`1<RPCClient> CreateWalletAsync(string walletNameOrPath, CreateWalletOptions options, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
public RPCClient CreateWallet(string walletNameOrPath, CreateWalletOptions options);
    [NullableContextAttribute("1")]
public Task`1<RPCClient> LoadWalletAsync(Nullable`1<bool> loadOnStartup);
    [NullableContextAttribute("1")]
public RPCClient LoadWallet(Nullable`1<bool> loadOnStartup);
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("NBitcoin.RPC.RPCClient/<LoadWalletAsync>d__193")]
public Task`1<RPCClient> LoadWalletAsync(string walletName, Nullable`1<bool> loadOnStartup, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
private RPCRequest GetLoadUnloadWalletRequest(string methodName, string walletName, Nullable`1<bool> loadOnStartup);
    [NullableContextAttribute("1")]
public RPCClient LoadWallet(string walletName, Nullable`1<bool> loadOnStartup);
    public void UnloadWallet();
    public void UnloadWallet(Nullable`1<bool> loadOnStartup);
    [NullableContextAttribute("1")]
public Task UnloadWalletAsync(Nullable`1<bool> loadOnStartup);
    [NullableContextAttribute("1")]
public Task UnloadWalletAsync(string walletName, Nullable`1<bool> loadOnStartup, CancellationToken cancellationToken);
    public void BackupWallet(string path);
    [AsyncStateMachineAttribute("NBitcoin.RPC.RPCClient/<BackupWalletAsync>d__201")]
public Task BackupWalletAsync(string path);
    public BitcoinSecret DumpPrivKey(BitcoinAddress address, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NBitcoin.RPC.RPCClient/<DumpPrivKeyAsync>d__203")]
public Task`1<BitcoinSecret> DumpPrivKeyAsync(BitcoinAddress address);
    public FundRawTransactionResponse FundRawTransaction(Transaction transaction, FundRawTransactionOptions options);
    public GetAddressInfoResponse GetAddressInfo(IDestination address);
    [AsyncStateMachineAttribute("NBitcoin.RPC.RPCClient/<GetAddressInfoAsync>d__206")]
public Task`1<GetAddressInfoResponse> GetAddressInfoAsync(IDestination address);
    public Money GetBalance(int minConf, bool includeWatchOnly);
    public Money GetBalance();
    [AsyncStateMachineAttribute("NBitcoin.RPC.RPCClient/<GetBalanceAsync>d__209")]
public Task`1<Money> GetBalanceAsync();
    [AsyncStateMachineAttribute("NBitcoin.RPC.RPCClient/<GetBalanceAsync>d__210")]
public Task`1<Money> GetBalanceAsync(int minConf, bool includeWatchOnly);
    [AsyncStateMachineAttribute("NBitcoin.RPC.RPCClient/<FundRawTransactionAsync>d__211")]
public Task`1<FundRawTransactionResponse> FundRawTransactionAsync(Transaction transaction, FundRawTransactionOptions options, CancellationToken cancellationToken);
    private JObject FundRawTransactionOptionsToJson(FundRawTransactionOptions options);
    private string ToHex(Transaction tx);
    public Money GetReceivedByAddress(BitcoinAddress address);
    [AsyncStateMachineAttribute("NBitcoin.RPC.RPCClient/<GetReceivedByAddressAsync>d__215")]
public Task`1<Money> GetReceivedByAddressAsync(BitcoinAddress address);
    public Money GetReceivedByAddress(BitcoinAddress address, int confirmations);
    [AsyncStateMachineAttribute("NBitcoin.RPC.RPCClient/<GetReceivedByAddressAsync>d__217")]
public Task`1<Money> GetReceivedByAddressAsync(BitcoinAddress address, int confirmations);
    public void ImportPrivKey(BitcoinSecret secret);
    public void ImportPrivKey(BitcoinSecret secret, string label, bool rescan);
    [AsyncStateMachineAttribute("NBitcoin.RPC.RPCClient/<ImportPrivKeyAsync>d__220")]
public Task ImportPrivKeyAsync(BitcoinSecret secret);
    [AsyncStateMachineAttribute("NBitcoin.RPC.RPCClient/<ImportPrivKeyAsync>d__221")]
public Task ImportPrivKeyAsync(BitcoinSecret secret, string label, bool rescan);
    public void ImportAddress(IDestination address);
    public void ImportAddress(IDestination address, string label, bool rescan);
    public void ImportAddress(Script scriptPubKey);
    public void ImportAddress(Script scriptPubKey, string label, bool rescan);
    [AsyncStateMachineAttribute("NBitcoin.RPC.RPCClient/<ImportAddressAsync>d__226")]
public Task ImportAddressAsync(Script scriptPubKey);
    [AsyncStateMachineAttribute("NBitcoin.RPC.RPCClient/<ImportAddressAsync>d__227")]
public Task ImportAddressAsync(Script scriptPubKey, string label, bool rescan);
    [AsyncStateMachineAttribute("NBitcoin.RPC.RPCClient/<ImportAddressAsync>d__228")]
public Task ImportAddressAsync(BitcoinAddress address);
    [AsyncStateMachineAttribute("NBitcoin.RPC.RPCClient/<ImportAddressAsync>d__229")]
public Task ImportAddressAsync(BitcoinAddress address, string label, bool rescan);
    public void ImportMulti(ImportMultiAddress[] addresses, bool rescan);
    [NullableContextAttribute("1")]
public void ImportMulti(ImportMultiAddress[] addresses, bool rescan, ISigningRepository signingRepository);
    [NullableContextAttribute("1")]
public Task ImportMultiAsync(ImportMultiAddress[] addresses, bool rescan);
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("NBitcoin.RPC.RPCClient/<ImportMultiAsync>d__233")]
public Task ImportMultiAsync(ImportMultiAddress[] addresses, bool rescan, ISigningRepository signingRepository, CancellationToken cancellationToken);
    private JsonSerializerSettings get_JsonSerializerSettings();
    [IteratorStateMachineAttribute("NBitcoin.RPC.RPCClient/<ListAddressGroupings>d__237")]
public IEnumerable`1<AddressGrouping> ListAddressGroupings();
    [IteratorStateMachineAttribute("NBitcoin.RPC.RPCClient/<ListSecrets>d__238")]
public IEnumerable`1<BitcoinSecret> ListSecrets();
    public UnspentCoin[] ListUnspent();
    public UnspentCoin[] ListUnspent(int minconf, int maxconf, BitcoinAddress[] addresses);
    [AsyncStateMachineAttribute("NBitcoin.RPC.RPCClient/<ListUnspentAsync>d__241")]
public Task`1<UnspentCoin[]> ListUnspentAsync();
    [AsyncStateMachineAttribute("NBitcoin.RPC.RPCClient/<ListUnspentAsync>d__242")]
public Task`1<UnspentCoin[]> ListUnspentAsync(int minconf, int maxconf, BitcoinAddress[] addresses);
    [AsyncStateMachineAttribute("NBitcoin.RPC.RPCClient/<ListUnspentAsync>d__243")]
public Task`1<UnspentCoin[]> ListUnspentAsync(ListUnspentOptions options, BitcoinAddress[] addresses);
    [AsyncStateMachineAttribute("NBitcoin.RPC.RPCClient/<ListUnspentAsync>d__244")]
public Task`1<UnspentCoin[]> ListUnspentAsync(ListUnspentOptions options, CancellationToken cancellationToken, BitcoinAddress[] addresses);
    [AsyncStateMachineAttribute("NBitcoin.RPC.RPCClient/<ListLockUnspentAsync>d__245")]
public Task`1<OutPoint[]> ListLockUnspentAsync();
    public OutPoint[] ListLockUnspent();
    public void AbandonTransaction(uint256 txId);
    [AsyncStateMachineAttribute("NBitcoin.RPC.RPCClient/<AbandonTransactionAsync>d__248")]
public Task AbandonTransactionAsync(uint256 txId);
    public void LockUnspent(OutPoint[] outpoints);
    public void UnlockUnspent(OutPoint[] outpoints);
    public Task LockUnspentAsync(OutPoint[] outpoints);
    public Task UnlockUnspentAsync(OutPoint[] outpoints);
    private void LockUnspentCore(bool unlock, OutPoint[] outpoints);
    [AsyncStateMachineAttribute("NBitcoin.RPC.RPCClient/<LockUnspentCoreAsync>d__254")]
private Task LockUnspentCoreAsync(bool unlock, OutPoint[] outpoints);
    public void WalletPassphrase(string passphrase, int timeout);
    [AsyncStateMachineAttribute("NBitcoin.RPC.RPCClient/<WalletPassphraseAsync>d__256")]
public Task WalletPassphraseAsync(string passphrase, int timeout);
    public Transaction SignRawTransaction(Transaction tx);
    [AsyncStateMachineAttribute("NBitcoin.RPC.RPCClient/<SignRawTransactionAsync>d__258")]
public Task`1<Transaction> SignRawTransactionAsync(Transaction tx);
    public SignRawTransactionResponse SignRawTransactionWithKey(SignRawTransactionWithKeyRequest request);
    [AsyncStateMachineAttribute("NBitcoin.RPC.RPCClient/<SignRawTransactionWithKeyAsync>d__260")]
public Task`1<SignRawTransactionResponse> SignRawTransactionWithKeyAsync(SignRawTransactionWithKeyRequest request, CancellationToken cancellationToken);
    public SignRawTransactionResponse SignRawTransactionWithWallet(SignRawTransactionRequest request);
    [AsyncStateMachineAttribute("NBitcoin.RPC.RPCClient/<SignRawTransactionWithWalletAsync>d__262")]
public Task`1<SignRawTransactionResponse> SignRawTransactionWithWalletAsync(SignRawTransactionRequest request, CancellationToken cancellationToken);
    public WalletProcessPSBTResponse WalletProcessPSBT(PSBT psbt, bool sign, SigHash hashType, bool bip32derivs);
    [AsyncStateMachineAttribute("NBitcoin.RPC.RPCClient/<WalletProcessPSBTAsync>d__264")]
public Task`1<WalletProcessPSBTResponse> WalletProcessPSBTAsync(PSBT psbt, bool sign, SigHash sighashType, bool bip32derivs);
    public WalletCreateFundedPSBTResponse WalletCreateFundedPSBT(TxIn[] inputs, Tuple`2<Dictionary`2<BitcoinAddress, Money>, Dictionary`2<string, string>> outputs, LockTime locktime, FundRawTransactionOptions options, bool bip32derivs);
    [AsyncStateMachineAttribute("NBitcoin.RPC.RPCClient/<WalletCreateFundedPSBTAsync>d__266")]
public Task`1<WalletCreateFundedPSBTResponse> WalletCreateFundedPSBTAsync(TxIn[] inputs, Tuple`2<Dictionary`2<BitcoinAddress, Money>, Dictionary`2<string, string>> outputs, LockTime locktime, FundRawTransactionOptions options, bool bip32derivs, CancellationToken cancellationToken);
    public WalletCreateFundedPSBTResponse WalletCreateFundedPSBT(TxIn[] inputs, Dictionary`2<BitcoinAddress, Money> outputs, LockTime locktime, FundRawTransactionOptions options, bool bip32derivs);
    public WalletCreateFundedPSBTResponse WalletCreateFundedPSBT(TxIn[] inputs, Dictionary`2<string, string> outputs, LockTime locktime, FundRawTransactionOptions options, bool bip32derivs);
    public string SigHashToString(SigHash value);
    private Money GetMoney(RPCResponse response);
    [CompilerGeneratedAttribute]
internal static IEnumerable`1<FeeRateGroup> <GetMemPoolAsync>g__ExtractFeeRateGroups|131_0(JToken jt);
    [CompilerGeneratedAttribute]
private UnspentCoin <ListUnspent>b__239_0(JToken i);
    [CompilerGeneratedAttribute]
private UnspentCoin <ListUnspent>b__240_1(JToken i);
    [CompilerGeneratedAttribute]
private UnspentCoin <ListUnspentAsync>b__241_0(JToken i);
    [CompilerGeneratedAttribute]
private UnspentCoin <ListUnspentAsync>b__242_1(JToken i);
    [CompilerGeneratedAttribute]
private UnspentCoin <ListUnspentAsync>b__244_1(JToken i);
}
public class NBitcoin.RPC.RPCCredentialString : object {
    [CompilerGeneratedAttribute]
private string <Server>k__BackingField;
    [CompilerGeneratedAttribute]
private string <WalletName>k__BackingField;
    private string _CookieFile;
    private NetworkCredential _UsernamePassword;
    public string Server { get; public set; }
    public bool UseDefault { get; }
    public string WalletName { get; public set; }
    public string CookieFile { get; public set; }
    public NetworkCredential UserPassword { get; public set; }
    public static RPCCredentialString Parse(string str);
    public static bool TryParse(string str, RPCCredentialString& connectionString);
    private static bool TryParseAuth(string str, RPCCredentialString& connectionString);
    [CompilerGeneratedAttribute]
public string get_Server();
    [CompilerGeneratedAttribute]
public void set_Server(string value);
    public bool get_UseDefault();
    [CompilerGeneratedAttribute]
public string get_WalletName();
    [CompilerGeneratedAttribute]
public void set_WalletName(string value);
    public string get_CookieFile();
    public void set_CookieFile(string value);
    private void Reset();
    public NetworkCredential get_UserPassword();
    public void set_UserPassword(NetworkCredential value);
    public virtual string ToString();
}
public class NBitcoin.RPC.RPCError : object {
    [CompilerGeneratedAttribute]
private RPCErrorCode <Code>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    public RPCErrorCode Code { get; public set; }
    public string Message { get; public set; }
    internal RPCError(JObject error);
    [CompilerGeneratedAttribute]
public RPCErrorCode get_Code();
    [CompilerGeneratedAttribute]
public void set_Code(RPCErrorCode value);
    [CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
public void set_Message(string value);
}
public enum NBitcoin.RPC.RPCErrorCode : Enum {
    public int value__;
    public static RPCErrorCode RPC_INVALID_REQUEST;
    public static RPCErrorCode RPC_METHOD_NOT_FOUND;
    public static RPCErrorCode RPC_INVALID_PARAMS;
    public static RPCErrorCode RPC_INTERNAL_ERROR;
    public static RPCErrorCode RPC_PARSE_ERROR;
    public static RPCErrorCode RPC_MISC_ERROR;
    public static RPCErrorCode RPC_FORBIDDEN_BY_SAFE_MODE;
    public static RPCErrorCode RPC_TYPE_ERROR;
    public static RPCErrorCode RPC_INVALID_ADDRESS_OR_KEY;
    public static RPCErrorCode RPC_OUT_OF_MEMORY;
    public static RPCErrorCode RPC_INVALID_PARAMETER;
    public static RPCErrorCode RPC_DATABASE_ERROR;
    public static RPCErrorCode RPC_DESERIALIZATION_ERROR;
    public static RPCErrorCode RPC_VERIFY_ERROR;
    public static RPCErrorCode RPC_VERIFY_REJECTED;
    public static RPCErrorCode RPC_VERIFY_ALREADY_IN_CHAIN;
    public static RPCErrorCode RPC_IN_WARMUP;
    public static RPCErrorCode RPC_METHOD_DEPRECATED;
    public static RPCErrorCode RPC_TRANSACTION_ERROR;
    public static RPCErrorCode RPC_TRANSACTION_REJECTED;
    public static RPCErrorCode RPC_TRANSACTION_ALREADY_IN_CHAIN;
    public static RPCErrorCode RPC_CLIENT_NOT_CONNECTED;
    public static RPCErrorCode RPC_CLIENT_IN_INITIAL_DOWNLOAD;
    public static RPCErrorCode RPC_CLIENT_NODE_ALREADY_ADDED;
    public static RPCErrorCode RPC_CLIENT_NODE_NOT_ADDED;
    public static RPCErrorCode RPC_CLIENT_NODE_NOT_CONNECTED;
    public static RPCErrorCode RPC_CLIENT_INVALID_IP_OR_SUBNET;
    public static RPCErrorCode RPC_CLIENT_P2P_DISABLED;
    public static RPCErrorCode RPC_WALLET_ERROR;
    public static RPCErrorCode RPC_WALLET_INSUFFICIENT_FUNDS;
    public static RPCErrorCode RPC_WALLET_INVALID_ACCOUNT_NAME;
    public static RPCErrorCode RPC_WALLET_KEYPOOL_RAN_OUT;
    public static RPCErrorCode RPC_WALLET_UNLOCK_NEEDED;
    public static RPCErrorCode RPC_WALLET_PASSPHRASE_INCORRECT;
    public static RPCErrorCode RPC_WALLET_WRONG_ENC_STATE;
    public static RPCErrorCode RPC_WALLET_ENCRYPTION_FAILED;
    public static RPCErrorCode RPC_WALLET_ALREADY_UNLOCKED;
    public static RPCErrorCode RPC_WALLET_NOT_FOUND;
    public static RPCErrorCode RPC_WALLET_NOT_SPECIFIED;
    public static RPCErrorCode RPC_WALLET_ALREADY_LOADED;
    public static RPCErrorCode RPC_WALLET_ALREADY_EXISTS;
}
public class NBitcoin.RPC.RPCException : Exception {
    private RPCResponse _RPCResult;
    private RPCErrorCode _RPCCode;
    private string _RPCCodeMessage;
    public RPCResponse RPCResult { get; }
    public RPCErrorCode RPCCode { get; }
    public string RPCCodeMessage { get; }
    public RPCException(RPCErrorCode code, string message, RPCResponse result);
    public RPCResponse get_RPCResult();
    private static string FindMessage(RPCErrorCode code);
    public RPCErrorCode get_RPCCode();
    public string get_RPCCodeMessage();
}
public enum NBitcoin.RPC.RPCOperations : Enum {
    public int value__;
    public static RPCOperations getconnectioncount;
    public static RPCOperations getpeerinfo;
    public static RPCOperations ping;
    public static RPCOperations addnode;
    public static RPCOperations getaddednodeinfo;
    public static RPCOperations getnettotals;
    public static RPCOperations dumpprivkey;
    public static RPCOperations importprivkey;
    public static RPCOperations importaddress;
    public static RPCOperations dumpwallet;
    public static RPCOperations importwallet;
    public static RPCOperations getgenerate;
    public static RPCOperations setgenerate;
    public static RPCOperations generate;
    public static RPCOperations generatetoaddress;
    public static RPCOperations getnetworkhashps;
    public static RPCOperations gethashespersec;
    public static RPCOperations getmininginfo;
    public static RPCOperations prioritisetransaction;
    public static RPCOperations getwork;
    public static RPCOperations getblocktemplate;
    public static RPCOperations submitblock;
    public static RPCOperations estimatefee;
    public static RPCOperations estimatesmartfee;
    public static RPCOperations getnewaddress;
    public static RPCOperations getaccountaddress;
    public static RPCOperations getrawchangeaddress;
    public static RPCOperations setaccount;
    public static RPCOperations getaccount;
    public static RPCOperations getaddressesbyaccount;
    public static RPCOperations sendtoaddress;
    public static RPCOperations signmessage;
    public static RPCOperations verifymessage;
    public static RPCOperations getreceivedbyaddress;
    public static RPCOperations getreceivedbyaccount;
    public static RPCOperations getaddressinfo;
    public static RPCOperations getbalance;
    public static RPCOperations getunconfirmedbalance;
    public static RPCOperations movecmd;
    public static RPCOperations sendfrom;
    public static RPCOperations sendmany;
    public static RPCOperations addmultisigaddress;
    public static RPCOperations createmultisig;
    public static RPCOperations listreceivedbyaddress;
    public static RPCOperations listreceivedbyaccount;
    public static RPCOperations listtransactions;
    public static RPCOperations listaddressgroupings;
    public static RPCOperations listsinceblock;
    public static RPCOperations gettransaction;
    public static RPCOperations backupwallet;
    public static RPCOperations keypoolrefill;
    public static RPCOperations walletpassphrase;
    public static RPCOperations walletpassphrasechange;
    public static RPCOperations walletlock;
    public static RPCOperations encryptwallet;
    public static RPCOperations validateaddress;
    [ObsoleteAttribute("Deprecated in Bitcoin Core 0.16.0 use getblockchaininfo, getnetworkinfo, getwalletinfo or getmininginfo instead")]
public static RPCOperations getinfo;
    public static RPCOperations getwalletinfo;
    public static RPCOperations getblockchaininfo;
    public static RPCOperations getnetworkinfo;
    public static RPCOperations getrawtransaction;
    public static RPCOperations listunspent;
    public static RPCOperations lockunspent;
    public static RPCOperations listlockunspent;
    public static RPCOperations createrawtransaction;
    public static RPCOperations decoderawtransaction;
    public static RPCOperations decodescript;
    public static RPCOperations signrawtransaction;
    public static RPCOperations sendrawtransaction;
    public static RPCOperations gettxoutproof;
    public static RPCOperations verifytxoutproof;
    public static RPCOperations decodepsbt;
    public static RPCOperations combinepsbt;
    public static RPCOperations finalizepsbt;
    public static RPCOperations createpsbt;
    public static RPCOperations convertopsbt;
    public static RPCOperations walletprocesspsbt;
    public static RPCOperations walletcreatefundedpsbt;
    public static RPCOperations getblockcount;
    public static RPCOperations getblockfilter;
    public static RPCOperations getblockstats;
    public static RPCOperations getbestblockhash;
    public static RPCOperations getdifficulty;
    public static RPCOperations settxfee;
    public static RPCOperations getmempoolinfo;
    public static RPCOperations getrawmempool;
    public static RPCOperations testmempoolaccept;
    public static RPCOperations getblockhash;
    public static RPCOperations getblock;
    public static RPCOperations gettxoutsetinfo;
    public static RPCOperations gettxout;
    public static RPCOperations verifychain;
    public static RPCOperations getchaintips;
    public static RPCOperations invalidateblock;
    public static RPCOperations bumpfee;
    public static RPCOperations abandontransaction;
    public static RPCOperations signrawtransactionwithkey;
    public static RPCOperations scantxoutset;
    public static RPCOperations getmempoolentry;
    public static RPCOperations stop;
    public static RPCOperations uptime;
    public static RPCOperations createwallet;
    public static RPCOperations loadwallet;
    public static RPCOperations unloadwallet;
    public static RPCOperations addpeeraddress;
    public static RPCOperations savemempool;
}
public class NBitcoin.RPC.RPCRequest : object {
    [CompilerGeneratedAttribute]
private string <JsonRpc>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Method>k__BackingField;
    [CompilerGeneratedAttribute]
private Object[] <Params>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ThrowIfRPCError>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, object> <NamedParams>k__BackingField;
    public string JsonRpc { get; public set; }
    public int Id { get; public set; }
    public string Method { get; public set; }
    public Object[] Params { get; public set; }
    public bool ThrowIfRPCError { get; public set; }
    public Dictionary`2<string, object> NamedParams { get; public set; }
    public RPCRequest(RPCOperations method, Object[] parameters);
    public RPCRequest(string method, Object[] parameters);
    [CompilerGeneratedAttribute]
public string get_JsonRpc();
    [CompilerGeneratedAttribute]
public void set_JsonRpc(string value);
    [CompilerGeneratedAttribute]
public int get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(int value);
    [CompilerGeneratedAttribute]
public string get_Method();
    [CompilerGeneratedAttribute]
public void set_Method(string value);
    [CompilerGeneratedAttribute]
public Object[] get_Params();
    [CompilerGeneratedAttribute]
public void set_Params(Object[] value);
    [CompilerGeneratedAttribute]
public bool get_ThrowIfRPCError();
    [CompilerGeneratedAttribute]
public void set_ThrowIfRPCError(bool value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, object> get_NamedParams();
    [CompilerGeneratedAttribute]
public void set_NamedParams(Dictionary`2<string, object> value);
    public void WriteJSON(TextWriter writer);
    internal void WriteJSON(JsonTextWriter writer);
    private void WriteValue(JsonTextWriter writer, object obj);
    private void WriteProperty(JsonTextWriter writer, string property, TValue value);
}
public class NBitcoin.RPC.RPCResponse : object {
    [CompilerGeneratedAttribute]
private RPCError <Error>k__BackingField;
    [CompilerGeneratedAttribute]
private JToken <Result>k__BackingField;
    public RPCError Error { get; public set; }
    public JToken Result { get; public set; }
    public string ResultString { get; }
    public RPCResponse(JObject json);
    [CompilerGeneratedAttribute]
public RPCError get_Error();
    [CompilerGeneratedAttribute]
public void set_Error(RPCError value);
    [CompilerGeneratedAttribute]
public JToken get_Result();
    [CompilerGeneratedAttribute]
public void set_Result(JToken value);
    public string get_ResultString();
    public static RPCResponse Load(Stream stream);
    public void ThrowIfError();
}
public class NBitcoin.RPC.RPCTransactionInput : object {
    [CompilerGeneratedAttribute]
private uint256 <TxId>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <vout>k__BackingField;
    [CompilerGeneratedAttribute]
private Sequence <nSequence>k__BackingField;
    [JsonPropertyAttribute]
public uint256 TxId { get; public set; }
    [JsonPropertyAttribute]
public UInt32 vout { get; public set; }
    [JsonPropertyAttribute]
public Sequence nSequence { get; public set; }
    public RPCTransactionInput(TxIn txin);
    [CompilerGeneratedAttribute]
public uint256 get_TxId();
    [CompilerGeneratedAttribute]
public void set_TxId(uint256 value);
    [CompilerGeneratedAttribute]
public UInt32 get_vout();
    [CompilerGeneratedAttribute]
public void set_vout(UInt32 value);
    [CompilerGeneratedAttribute]
public Sequence get_nSequence();
    [CompilerGeneratedAttribute]
public void set_nSequence(Sequence value);
}
public class NBitcoin.RPC.ScanTxoutDescriptor : object {
    [CompilerGeneratedAttribute]
private OutputDescriptor <Descriptor>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <Begin>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <End>k__BackingField;
    public OutputDescriptor Descriptor { get; public set; }
    public Nullable`1<int> Begin { get; public set; }
    public Nullable`1<int> End { get; public set; }
    public ScanTxoutDescriptor(OutputDescriptor desc);
    [CompilerGeneratedAttribute]
public OutputDescriptor get_Descriptor();
    [CompilerGeneratedAttribute]
public void set_Descriptor(OutputDescriptor value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_Begin();
    [CompilerGeneratedAttribute]
public void set_Begin(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_End();
    [CompilerGeneratedAttribute]
public void set_End(Nullable`1<int> value);
}
public class NBitcoin.RPC.ScanTxoutOutput : object {
    [CompilerGeneratedAttribute]
private Coin <Coin>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Height>k__BackingField;
    public Coin Coin { get; public set; }
    public int Height { get; public set; }
    [CompilerGeneratedAttribute]
public Coin get_Coin();
    [CompilerGeneratedAttribute]
public void set_Coin(Coin value);
    [CompilerGeneratedAttribute]
public int get_Height();
    [CompilerGeneratedAttribute]
public void set_Height(int value);
}
public class NBitcoin.RPC.ScanTxoutSetParameters : object {
    [CompilerGeneratedAttribute]
private ScanTxoutDescriptor[] <Descriptors>k__BackingField;
    public ScanTxoutDescriptor[] Descriptors { get; public set; }
    public ScanTxoutSetParameters(OutputDescriptor descriptor, Nullable`1<int> begin, Nullable`1<int> end);
    public ScanTxoutSetParameters(IEnumerable`1<OutputDescriptor> descriptors, Nullable`1<int> begin, Nullable`1<int> end);
    public ScanTxoutSetParameters(ScanTxoutDescriptor[] descriptors);
    [CompilerGeneratedAttribute]
public ScanTxoutDescriptor[] get_Descriptors();
    [CompilerGeneratedAttribute]
public void set_Descriptors(ScanTxoutDescriptor[] value);
}
public class NBitcoin.RPC.ScanTxoutSetResponse : object {
    [CompilerGeneratedAttribute]
private int <SearchedItems>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Success>k__BackingField;
    [CompilerGeneratedAttribute]
private ScanTxoutOutput[] <Outputs>k__BackingField;
    [CompilerGeneratedAttribute]
private Money <TotalAmount>k__BackingField;
    public int SearchedItems { get; internal set; }
    public bool Success { get; internal set; }
    public ScanTxoutOutput[] Outputs { get; public set; }
    public Money TotalAmount { get; public set; }
    [CompilerGeneratedAttribute]
public int get_SearchedItems();
    [CompilerGeneratedAttribute]
internal void set_SearchedItems(int value);
    [CompilerGeneratedAttribute]
public bool get_Success();
    [CompilerGeneratedAttribute]
internal void set_Success(bool value);
    [CompilerGeneratedAttribute]
public ScanTxoutOutput[] get_Outputs();
    [CompilerGeneratedAttribute]
public void set_Outputs(ScanTxoutOutput[] value);
    [CompilerGeneratedAttribute]
public Money get_TotalAmount();
    [CompilerGeneratedAttribute]
public void set_TotalAmount(Money value);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class NBitcoin.RPC.SendToAddressParameters : object {
    [CompilerGeneratedAttribute]
private string <Comment>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CommentTo>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <SubstractFeeFromAmount>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <Replaceable>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <ConfTarget>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<EstimateSmartFeeMode> <EstimateMode>k__BackingField;
    [CompilerGeneratedAttribute]
private FeeRate <FeeRate>k__BackingField;
    public string Comment { get; public set; }
    public string CommentTo { get; public set; }
    public Nullable`1<bool> SubstractFeeFromAmount { get; public set; }
    public Nullable`1<bool> Replaceable { get; public set; }
    public Nullable`1<int> ConfTarget { get; public set; }
    public Nullable`1<EstimateSmartFeeMode> EstimateMode { get; public set; }
    public FeeRate FeeRate { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Comment();
    [CompilerGeneratedAttribute]
public void set_Comment(string value);
    [CompilerGeneratedAttribute]
public string get_CommentTo();
    [CompilerGeneratedAttribute]
public void set_CommentTo(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_SubstractFeeFromAmount();
    [CompilerGeneratedAttribute]
public void set_SubstractFeeFromAmount(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_Replaceable();
    [CompilerGeneratedAttribute]
public void set_Replaceable(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_ConfTarget();
    [CompilerGeneratedAttribute]
public void set_ConfTarget(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<EstimateSmartFeeMode> get_EstimateMode();
    [CompilerGeneratedAttribute]
public void set_EstimateMode(Nullable`1<EstimateSmartFeeMode> value);
    [CompilerGeneratedAttribute]
public FeeRate get_FeeRate();
    [CompilerGeneratedAttribute]
public void set_FeeRate(FeeRate value);
}
public class NBitcoin.RPC.SignRawTransactionRequest : object {
    [CompilerGeneratedAttribute]
private PrevTx[] <PreviousTransactions>k__BackingField;
    [CompilerGeneratedAttribute]
private Transaction <Transaction>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<SigHash> <SigHash>k__BackingField;
    public PrevTx[] PreviousTransactions { get; public set; }
    public Transaction Transaction { get; public set; }
    public Nullable`1<SigHash> SigHash { get; public set; }
    [CompilerGeneratedAttribute]
public PrevTx[] get_PreviousTransactions();
    [CompilerGeneratedAttribute]
public void set_PreviousTransactions(PrevTx[] value);
    [CompilerGeneratedAttribute]
public Transaction get_Transaction();
    [CompilerGeneratedAttribute]
public void set_Transaction(Transaction value);
    [CompilerGeneratedAttribute]
public Nullable`1<SigHash> get_SigHash();
    [CompilerGeneratedAttribute]
public void set_SigHash(Nullable`1<SigHash> value);
}
public class NBitcoin.RPC.SignRawTransactionResponse : object {
    [CompilerGeneratedAttribute]
private Transaction <SignedTransaction>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Complete>k__BackingField;
    [CompilerGeneratedAttribute]
private ScriptError[] <Errors>k__BackingField;
    public Transaction SignedTransaction { get; public set; }
    public bool Complete { get; public set; }
    public ScriptError[] Errors { get; public set; }
    [CompilerGeneratedAttribute]
public Transaction get_SignedTransaction();
    [CompilerGeneratedAttribute]
public void set_SignedTransaction(Transaction value);
    [CompilerGeneratedAttribute]
public bool get_Complete();
    [CompilerGeneratedAttribute]
public void set_Complete(bool value);
    [CompilerGeneratedAttribute]
public ScriptError[] get_Errors();
    [CompilerGeneratedAttribute]
public void set_Errors(ScriptError[] value);
}
public class NBitcoin.RPC.SignRawTransactionWithKeyRequest : SignRawTransactionRequest {
    [CompilerGeneratedAttribute]
private Key[] <PrivateKeys>k__BackingField;
    public Key[] PrivateKeys { get; public set; }
    [CompilerGeneratedAttribute]
public Key[] get_PrivateKeys();
    [CompilerGeneratedAttribute]
public void set_PrivateKeys(Key[] value);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class NBitcoin.RPC.TestMempoolParameters : object {
    [CompilerGeneratedAttribute]
private FeeRate <MaxFeeRate>k__BackingField;
    public FeeRate MaxFeeRate { get; public set; }
    [CompilerGeneratedAttribute]
public FeeRate get_MaxFeeRate();
    [CompilerGeneratedAttribute]
public void set_MaxFeeRate(FeeRate value);
}
[ExtensionAttribute]
public static class NBitcoin.RPC.TxInExtension : object {
    [ExtensionAttribute]
public static RPCTransactionInput ToRPCInputs(TxIn txin);
}
public class NBitcoin.RPC.UnspentCoin : object {
    [CompilerGeneratedAttribute]
private OutPoint <OutPoint>k__BackingField;
    [CompilerGeneratedAttribute]
private BitcoinAddress <Address>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Account>k__BackingField;
    [CompilerGeneratedAttribute]
private Script <ScriptPubKey>k__BackingField;
    [CompilerGeneratedAttribute]
private Script <RedeemScript>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <Confirmations>k__BackingField;
    [CompilerGeneratedAttribute]
private Money <Amount>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsSpendable>k__BackingField;
    public OutPoint OutPoint { get; private set; }
    public BitcoinAddress Address { get; private set; }
    public string Account { get; private set; }
    public Script ScriptPubKey { get; private set; }
    public Script RedeemScript { get; private set; }
    public UInt32 Confirmations { get; private set; }
    public Money Amount { get; private set; }
    public bool IsSpendable { get; private set; }
    internal UnspentCoin(JObject unspent, Network network);
    [CompilerGeneratedAttribute]
public OutPoint get_OutPoint();
    [CompilerGeneratedAttribute]
private void set_OutPoint(OutPoint value);
    [CompilerGeneratedAttribute]
public BitcoinAddress get_Address();
    [CompilerGeneratedAttribute]
private void set_Address(BitcoinAddress value);
    [CompilerGeneratedAttribute]
public string get_Account();
    [CompilerGeneratedAttribute]
private void set_Account(string value);
    [CompilerGeneratedAttribute]
public Script get_ScriptPubKey();
    [CompilerGeneratedAttribute]
private void set_ScriptPubKey(Script value);
    [CompilerGeneratedAttribute]
public Script get_RedeemScript();
    [CompilerGeneratedAttribute]
private void set_RedeemScript(Script value);
    [CompilerGeneratedAttribute]
public UInt32 get_Confirmations();
    [CompilerGeneratedAttribute]
private void set_Confirmations(UInt32 value);
    [CompilerGeneratedAttribute]
public Money get_Amount();
    [CompilerGeneratedAttribute]
private void set_Amount(Money value);
    public Coin AsCoin();
    [CompilerGeneratedAttribute]
public bool get_IsSpendable();
    [CompilerGeneratedAttribute]
private void set_IsSpendable(bool value);
}
public class NBitcoin.RPC.WalletCreateFundedPSBTResponse : object {
    [CompilerGeneratedAttribute]
private PSBT <PSBT>k__BackingField;
    [CompilerGeneratedAttribute]
private Money <Fee>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <ChangePos>k__BackingField;
    public PSBT PSBT { get; internal set; }
    public Money Fee { get; internal set; }
    public Nullable`1<int> ChangePos { get; internal set; }
    [CompilerGeneratedAttribute]
public PSBT get_PSBT();
    [CompilerGeneratedAttribute]
internal void set_PSBT(PSBT value);
    [CompilerGeneratedAttribute]
public Money get_Fee();
    [CompilerGeneratedAttribute]
internal void set_Fee(Money value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_ChangePos();
    [CompilerGeneratedAttribute]
internal void set_ChangePos(Nullable`1<int> value);
}
public class NBitcoin.RPC.WalletProcessPSBTResponse : object {
    [CompilerGeneratedAttribute]
private PSBT <PSBT>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Complete>k__BackingField;
    public PSBT PSBT { get; }
    public bool Complete { get; }
    public WalletProcessPSBTResponse(PSBT psbt, bool complete);
    [CompilerGeneratedAttribute]
public PSBT get_PSBT();
    [CompilerGeneratedAttribute]
public bool get_Complete();
}
public class NBitcoin.RPCTransactionRepository : object {
    private RPCClient _Client;
    public RPCTransactionRepository(RPCClient client);
    public sealed virtual Task`1<Transaction> GetAsync(uint256 txId);
    public Task BroadcastAsync(Transaction tx);
    public sealed virtual Task PutAsync(uint256 txId, Transaction tx);
}
public class NBitcoin.Scope : object {
    private Action close;
    public static IDisposable Nothing { get; }
    public Scope(Action open, Action close);
    public sealed virtual void Dispose();
    public static IDisposable get_Nothing();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NBitcoin.Script : object {
    private static Script _Empty;
    internal Byte[] _Script;
    [NullableAttribute("2")]
private Script _PaymentScript;
    [NullableAttribute("2")]
private ScriptId _Hash;
    [NullableAttribute("2")]
private WitScriptId _WitHash;
    public static Script Empty { get; }
    public int Length { get; }
    public Script PaymentScript { get; }
    public bool IsPushOnly { get; }
    public bool HasCanonicalPushes { get; }
    public ScriptId Hash { get; }
    public WitScriptId WitHash { get; }
    public bool IsMalleable { get; }
    public bool IsUnspendable { get; }
    public bool IsValid { get; }
    public Script(Op[] ops);
    public Script(IEnumerable`1<Op> ops);
    public Script(string script);
    public Script(Byte[] data);
    private Script(Byte[] data, bool unsafe, bool unused);
    public Script(IEnumerable`1<byte> data);
    public Script(Byte[] data, bool compressed);
    private static Script();
    public static Script get_Empty();
    private static Byte[] Parse(string script);
    public static Script FromBytesUnsafe(Byte[] data);
    public static Script FromHex(string hex);
    public int get_Length();
    public Script ExtractScriptCode(int codeSeparatorIndex);
    public ScriptReader CreateReader();
    private Script FindAndDelete(Op op);
    internal Script FindAndDelete(Byte[] pushedData);
    internal Script FindAndDelete(OpcodeType op);
    private Script FindAndDelete(Func`2<Op, bool> predicate);
    public string ToHex();
    public Script get_PaymentScript();
    public virtual string ToString();
    public bool get_IsPushOnly();
    public bool get_HasCanonicalPushes();
    public static Script op_Addition(Script a, IEnumerable`1<byte> bytes);
    public static Script op_Addition(Script a, Op op);
    public static Script op_Addition(Script a, IEnumerable`1<Op> ops);
    public IEnumerable`1<Op> ToOps();
    public UInt32 GetSigOpCount(bool fAccurate);
    public ScriptId get_Hash();
    public WitScriptId get_WitHash();
    public UInt32 GetSigOpCount(Script scriptSig);
    [NullableContextAttribute("2")]
public ScriptTemplate FindTemplate();
    public bool get_IsMalleable();
    public bool IsScriptType(ScriptType type);
    [ObsoleteAttribute("Do not use this, it isn't possible to get a signer's address from a script without taking heuristic which can be gamed by a malicious actor")]
public BitcoinAddress GetSignerAddress(Network network);
    [NullableContextAttribute("2")]
[ObsoleteAttribute("Do not use this, it isn't possible to get a signer's address from a script without taking heuristic which can be gamed by a malicious actor")]
public IAddressableDestination GetSigner();
    public BitcoinAddress GetDestinationAddress(Network network);
    [NullableContextAttribute("2")]
public IAddressableDestination GetDestination();
    public PubKey[] GetDestinationPublicKeys();
    public PubKey[] GetAllPubKeys();
    public Byte[] ToBytes();
    public Byte[] ToBytes(bool unsafe);
    public WitScript ToWitScript();
    public TapScript ToTapScript(TapLeafVersion version);
    public Byte[] ToCompressedBytes();
    [DefaultDllImportSearchPathsAttribute("514")]
private static int VerifyScriptConsensus(Byte[] scriptPubKey, UInt32 scriptPubKeyLen, Byte[] txTo, UInt32 txToLen, UInt32 nIn, ScriptVerify flags, BitcoinConsensusError& err);
    [DefaultDllImportSearchPathsAttribute("514")]
private static int VerifyScriptConsensusWithAmount(Byte[] scriptPubKey, UInt32 scriptPubKeyLen, long amount, Byte[] txTo, UInt32 txToLen, UInt32 nIn, ScriptVerify flags, BitcoinConsensusError& err);
    public static bool VerifyScriptConsensus(Script scriptPubKey, Transaction tx, UInt32 nIn, ScriptVerify flags);
    public static bool VerifyScriptConsensus(Script scriptPubKey, Transaction tx, UInt32 nIn, Money amount, ScriptVerify flags);
    public static bool VerifyScriptConsensus(Script scriptPubKey, Transaction tx, UInt32 nIn, ScriptVerify flags, BitcoinConsensusError& err);
    public static bool VerifyScriptConsensus(Script scriptPubKey, Transaction tx, UInt32 nIn, Money amount, ScriptVerify flags, BitcoinConsensusError& err);
    public bool get_IsUnspendable();
    [NullableContextAttribute("2")]
public static bool IsNullOrEmpty(Script script);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(Script item);
    [NullableContextAttribute("2")]
public static bool op_Equality(Script a, Script b);
    [NullableContextAttribute("2")]
public static bool op_Inequality(Script a, Script b);
    public virtual int GetHashCode();
    public Script Clone();
    public static Script CombineSignatures(Script scriptPubKey, Transaction transaction, int n, Script scriptSig1, Script scriptSig2);
    public static ScriptSigs CombineSignatures(Script scriptPubKey, TransactionChecker checker, ScriptSigs input1, ScriptSigs input2);
    private static Script CombineSignatures(Script scriptPubKey, TransactionChecker checker, Byte[][] sigs1, Byte[][] sigs2, HashVersion hashVersion);
    private static Script CombineMultisig(Script scriptPubKey, TransactionChecker checker, Byte[][] sigs1, Byte[][] sigs2, HashVersion hashVersion);
    private static Script PushAll(Byte[][] stack);
    [NullableContextAttribute("2")]
public static WitScript op_Implicit(Script script);
    private static Byte[][] Max(Byte[][] scriptSig1, Byte[][] scriptSig2);
    public bool get_IsValid();
}
public class NBitcoin.ScriptCoin : Coin {
    [CompilerGeneratedAttribute]
private Script <Redeem>k__BackingField;
    public bool IsP2SH { get; }
    public RedeemType RedeemType { get; }
    public Script Redeem { get; public set; }
    public bool CanGetScriptCode { get; }
    public ScriptCoin(OutPoint fromOutpoint, TxOut fromTxOut, Script redeem);
    public ScriptCoin(Transaction fromTx, UInt32 fromOutputIndex, Script redeem);
    public ScriptCoin(Transaction fromTx, TxOut fromOutput, Script redeem);
    public ScriptCoin(ICoin coin, Script redeem);
    public ScriptCoin(IndexedTxOut txOut, Script redeem);
    public ScriptCoin(uint256 txHash, UInt32 outputIndex, Money amount, Script scriptPubKey, Script redeem);
    private void AssertCoherent(string paramName);
    public bool get_IsP2SH();
    public Script GetP2SHRedeem();
    public RedeemType get_RedeemType();
    public static bool IsCoherent(Script scriptPubKey, Script redeem, String& error);
    [CompilerGeneratedAttribute]
public Script get_Redeem();
    [CompilerGeneratedAttribute]
public void set_Redeem(Script value);
    public virtual Script GetScriptCode();
    public virtual bool get_CanGetScriptCode();
    public virtual HashVersion GetHashVersion();
    public static IAddressableDestination GetRedeemHash(Script scriptPubKey);
}
public class NBitcoin.ScriptCompressor : object {
    private static UInt32 nSpecialScripts;
    private Byte[] _Script;
    public Byte[] ScriptBytes { get; }
    public ScriptCompressor(Script script);
    public Byte[] get_ScriptBytes();
    public Script GetScript();
    private Byte[] Compress();
    private Script Decompress(UInt32 nSize, Byte[] data);
    public sealed virtual void ReadWrite(BitcoinStream stream);
    private int GetSpecialSize(UInt32 nSize);
}
public enum NBitcoin.ScriptError : Enum {
    public int value__;
    public static ScriptError OK;
    public static ScriptError UnknownError;
    public static ScriptError EvalFalse;
    public static ScriptError OpReturn;
    public static ScriptError ScriptSize;
    public static ScriptError PushSize;
    public static ScriptError OpCount;
    public static ScriptError StackSize;
    public static ScriptError SigCount;
    public static ScriptError PubkeyCount;
    public static ScriptError Verify;
    public static ScriptError EqualVerify;
    public static ScriptError CheckMultiSigVerify;
    public static ScriptError CheckSigVerify;
    public static ScriptError NumEqualVerify;
    public static ScriptError BadOpCode;
    public static ScriptError DisabledOpCode;
    public static ScriptError InvalidStackOperation;
    public static ScriptError InvalidAltStackOperation;
    public static ScriptError UnbalancedConditional;
    public static ScriptError NegativeLockTime;
    public static ScriptError UnsatisfiedLockTime;
    public static ScriptError SigHashType;
    public static ScriptError SigDer;
    public static ScriptError MinimalData;
    public static ScriptError SigPushOnly;
    public static ScriptError SigHighS;
    public static ScriptError SigNullDummy;
    public static ScriptError PubKeyType;
    public static ScriptError CleanStack;
    public static ScriptError DiscourageUpgradableNops;
    public static ScriptError WitnessMalleated;
    public static ScriptError WitnessMalleatedP2SH;
    public static ScriptError WitnessProgramEmpty;
    public static ScriptError WitnessProgramMissmatch;
    public static ScriptError DiscourageUpgradableWitnessProgram;
    public static ScriptError WitnessProgramWrongLength;
    public static ScriptError WitnessUnexpected;
    public static ScriptError NullFail;
    public static ScriptError MinimalIf;
    public static ScriptError WitnessPubkeyType;
    public static ScriptError SchnorrSigSize;
    public static ScriptError SchnorrSigHashType;
    public static ScriptError SchnorrSig;
    public static ScriptError TaprootWrongControlSize;
    public static ScriptError DiscourageUpgradableTaprootVersion;
    public static ScriptError TapscriptValidationWeight;
    public static ScriptError DiscourageUpgradablePubKeyType;
    public static ScriptError DiscourageOpSuccess;
}
public class NBitcoin.ScriptEvaluationContext : object {
    private ContextStack`1<Byte[]> _stack;
    [CompilerGeneratedAttribute]
private ScriptVerify <ScriptVerify>k__BackingField;
    [CompilerGeneratedAttribute]
private ExecutionData <ExecutionData>k__BackingField;
    private static byte ANNEX_TAG;
    private static int MAX_STACK_SIZE;
    private static Byte[] vchFalse;
    private static Byte[] vchZero;
    private static Byte[] vchTrue;
    private static int MAX_OPS_PER_SCRIPT;
    private static int MAX_SCRIPT_ELEMENT_SIZE;
    private static int MAX_SCRIPT_SIZE;
    private static long VALIDATION_WEIGHT_PER_SIGOP_PASSED;
    [CompilerGeneratedAttribute]
private ScriptError <Error>k__BackingField;
    private static Byte[] vchMaxModOrder;
    private static Byte[] vchMaxModHalfOrder;
    private List`1<SignedHash> _SignedHashes;
    [CompilerGeneratedAttribute]
private Exception <ThrownException>k__BackingField;
    public ContextStack`1<Byte[]> Stack { get; }
    public ScriptVerify ScriptVerify { get; public set; }
    public ExecutionData ExecutionData { get; public set; }
    public ScriptError Error { get; public set; }
    public IEnumerable`1<SignedHash> SignedHashes { get; }
    public bool Result { get; }
    public Exception ThrownException { get; public set; }
    private static ScriptEvaluationContext();
    public ContextStack`1<Byte[]> get_Stack();
    [CompilerGeneratedAttribute]
public ScriptVerify get_ScriptVerify();
    [CompilerGeneratedAttribute]
public void set_ScriptVerify(ScriptVerify value);
    [CompilerGeneratedAttribute]
public ExecutionData get_ExecutionData();
    [CompilerGeneratedAttribute]
public void set_ExecutionData(ExecutionData value);
    public bool VerifyScript(Script scriptSig, Transaction txTo, int nIn, TxOut spentOutput);
    public bool VerifyScript(Script scriptSig, Script scriptPubKey, TransactionChecker checker);
    public bool VerifyScript(Script scriptSig, WitScript witness, Script scriptPubKey, TransactionChecker checker);
    private bool VerifyWitnessProgram(WitScript witness, WitProgramParameters wit, TransactionChecker checker, bool isP2SH);
    private bool VerifyTaprootCommitment(ReadOnlySpan`1<byte> control, ReadOnlySpan`1<byte> program, uint256 tapleafHash);
    internal static uint256 ComputeTaprootMerkleRoot(ReadOnlySpan`1<byte> control, uint256 tapleafHash);
    private static bool CompareLexicographic(uint256 a, uint256 b);
    private uint256 ComputeTapleafHash(byte leaf_version, Script execScript);
    private bool ExecuteWitnessScript(ContextStack`1<Byte[]> stack, Script scriptPubKey, HashVersion sigversion, TransactionChecker checker);
    private bool IsOpSuccess(OpcodeType code);
    internal bool EvalScript(Script s, TransactionChecker checker, HashVersion hashversion);
    private bool EvalChecksig(Byte[] sig, Byte[] pubkey, Script s, int pbegincodehash, TransactionChecker checker, HashVersion sigversion, Boolean& success);
    private bool EvalChecksigPreTapscript(Byte[] vchSig, Byte[] vchPubKey, Script s, int pbegincodehash, TransactionChecker checker, HashVersion sigversion, Boolean& success);
    private bool EvalChecksigTapscript(Byte[] sig, Byte[] pubkey, TransactionChecker checker, HashVersion sigversion, Boolean& success);
    private bool CheckSequence(CScriptNum nSequence, TransactionChecker checker);
    private bool CheckLockTime(CScriptNum nLockTime, TransactionChecker checker);
    private bool SetSuccess(ScriptError scriptError);
    private bool SetError(ScriptError scriptError);
    private bool IsCompressedOrUncompressedPubKey(Byte[] vchPubKey);
    internal bool CheckSignatureEncoding(Byte[] vchSig);
    private bool CheckPubKeyEncoding(Byte[] vchPubKey, HashVersion sigversion);
    private static bool IsCompressedPubKey(Byte[] vchPubKey);
    private bool IsDefinedHashtypeSignature(Byte[] vchSig);
    private bool IsLowDERSignature(Byte[] vchSig);
    [CompilerGeneratedAttribute]
public ScriptError get_Error();
    [CompilerGeneratedAttribute]
public void set_Error(ScriptError value);
    private bool CheckSignatureElement(Byte[] vchSig, int i, int len, bool half);
    private int CompareBigEndian(Byte[] c1, int ic1, int c1len, Byte[] c2, int c2len);
    private static bool IsValidSignatureEncoding(Byte[] sig);
    private bool CheckMinimalPush(Byte[] data, OpcodeType opcode);
    private static bool CastToBool(Byte[] vch);
    public IEnumerable`1<SignedHash> get_SignedHashes();
    private bool CheckSig(Byte[] vchSig, Byte[] vchPubKey, Script scriptCode, TransactionChecker checker, HashVersion sigversion);
    private void Load(ScriptEvaluationContext other);
    public ScriptEvaluationContext Clone();
    public bool get_Result();
    [CompilerGeneratedAttribute]
public Exception get_ThrownException();
    [CompilerGeneratedAttribute]
public void set_ThrownException(Exception value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NBitcoin.ScriptId : object {
    private uint160 v;
    public Script ScriptPubKey { get; }
    public ScriptId(Byte[] value);
    public ScriptId(uint160 value);
    public ScriptId(string value);
    public ScriptId(Script script);
    public sealed virtual Script get_ScriptPubKey();
    public BitcoinScriptAddress GetAddress(Network network);
    private sealed virtual override BitcoinAddress NBitcoin.IAddressableDestination.GetAddress(Network network);
    public sealed virtual bool IsSupported(Network network);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
public static bool op_Equality(ScriptId a, ScriptId b);
    [NullableContextAttribute("2")]
public static bool op_Inequality(ScriptId a, ScriptId b);
    public virtual int GetHashCode();
    public Byte[] ToBytes();
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class NBitcoin.Scripting.OutputDescriptor : object {
    [CompilerGeneratedAttribute]
private Network <Network>k__BackingField;
    private static Char[] CHECKSUM_CHARSET;
    private static string INPUT_CHARSET_STRING;
    private static Char[] INPUT_CHARSET;
    public Network Network { get; }
    private OutputDescriptor(Network network);
    private static OutputDescriptor();
    [CompilerGeneratedAttribute]
public Network get_Network();
    public static OutputDescriptor NewAddr(IDestination dest, Network network);
    public static OutputDescriptor NewRaw(Script sc, Network network);
    public static OutputDescriptor NewPK(PubKeyProvider pk, Network network);
    public static OutputDescriptor NewPKH(PubKeyProvider pk, Network network);
    public static OutputDescriptor NewWPKH(PubKeyProvider pk, Network network);
    public static OutputDescriptor NewCombo(PubKeyProvider pk, Network network);
    public static OutputDescriptor NewMulti(UInt32 m, IEnumerable`1<PubKeyProvider> pks, bool isSorted, Network network, bool isTapScript);
    public static OutputDescriptor NewSH(OutputDescriptor inner, Network network);
    public static OutputDescriptor NewWSH(OutputDescriptor inner, Network network);
    public static OutputDescriptor NewTr(PubKeyProvider innerPubKey, Network network, TapTree tapTree);
    public static OutputDescriptor NewRawTr(PubKeyProvider outputPubkeyProvider, Network network);
    public bool IsTopLevelOnly();
    public bool TryExpand(UInt32 pos, ISigningRepository repo, List`1& outputScripts, IDictionary`2<UInt32, ExtPubKey> cache);
    public bool TryExpand(UInt32 pos, Func`2<KeyId, Key> privateKeyProvider, ISigningRepository repo, List`1& outputScripts, bool isTaproot, IDictionary`2<UInt32, ExtPubKey> cache);
    private bool ExpandPkHelper(PubKeyProvider pkP, Func`2<KeyId, Key> privateKeyProvider, UInt32 pos, ISigningRepository repo, List`1<Script> outSc, bool isTaproot, IDictionary`2<UInt32, ExtPubKey> cache);
    private bool TryExpand(UInt32 pos, Func`2<KeyId, Key> privateKeyProvider, ISigningRepository repo, List`1<Script> outputScripts, bool isTaproot, IDictionary`2<UInt32, ExtPubKey> cache);
    private List`1<Script> MakeScripts(PubKey key, ISigningRepository repo, bool isTaproot);
    public bool IsSolvable();
    public bool IsRange();
    private static PubKeyProvider InferPubKey(PubKey pk, ISigningRepository repo);
    [NullableContextAttribute("2")]
private Nullable`1<ScriptPubKeyType> InferTemplate(ScriptTemplate template);
    public Nullable`1<ScriptPubKeyType> GetScriptPubKeyType();
    private static PubKeyProvider InferXOnlyPubkey(TaprootPubKey xkey, ISigningRepository repo);
    private static PubKeyProvider InferXOnlyPubkey(TaprootInternalPubKey xkey, ISigningRepository repo);
    private static OutputDescriptor InferMultiA(Script sc, ISigningRepository repo, Network network);
    public static OutputDescriptor InferFromScript(Script sc, ISigningRepository repo, Network network);
    private static OutputDescriptor InferFromScript(Script sc, ISigningRepository repo, Network network, ScriptContext ctx);
    public virtual string ToString();
    public bool TryGetPrivateString(ISigningRepository secretProvider, String& result);
    private bool TryGetPrivateStringHelper(ISigningRepository secretProvider, String& result);
    private string ToStringHelper();
    public static OutputDescriptor Parse(string desc, Network network, bool requireCheckSum, ISigningRepository repo);
    public static bool TryParse(string desc, Network network, OutputDescriptor& result, bool requireCheckSum, ISigningRepository repo);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(OutputDescriptor other);
    public virtual int GetHashCode();
    public static string AddChecksum(string desc);
    public static string GetCheckSum(string desc);
    private static ulong PolyMod(ulong c, int val);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class NBitcoin.Scripting.OutputDescriptorParser : object {
    private static HexEncoder Hex;
    private static Parser`2<char, PubKey> PPubKeyUncompressed;
    private static OutputDescriptorParser();
    [ExtensionAttribute]
private static Parser`2<char, T> InjectRepository(Parser`2<char, T> subParser, ISigningRepository repo);
    private static Parser`2<char, PubKey> PPubKeyCompressed(ISigningRepository repo);
    private static Parser`2<char, TaprootPubKey> PPubkeyXOnly(ISigningRepository repo);
    private static Parser`2<char, PubKey> PPubKey(ISigningRepository repo);
    private static Parser`2<char, BitcoinExtPubKey> PRawXPub(ISigningRepository repo, Network n);
    private static Parser`2<char, RootedKeyPath> PRootedKeyPath(ISigningRepository repo);
    private static Parser`2<char, KeyPath> PKeyPath(ISigningRepository repo);
    private static Parser`2<char, BitcoinSecret> PTryConvertSecret(string secretStr, Network n);
    private static Parser`2<char, PubKey> PWIF(ISigningRepository repo, Network n, bool onlyCompressed);
    private static Parser`2<char, BitcoinExtPubKey> PExtKey(ISigningRepository repo, Network n);
    private static Parser`2<char, PubKeyProvider> PConstPubKeyProvider(ISigningRepository repo, Network n, PubKeyContext ctx);
    private static Parser`2<char, Tuple`2<BitcoinExtPubKey, KeyPath>> PHDPkProviderNoPath(ISigningRepository repo, Network n);
    private static Parser`2<char, Tuple`2<BitcoinExtPubKey, KeyPath>> PHDPkProviderWithpath(ISigningRepository repo, Network n);
    private static Parser`2<char, Tuple`2<BitcoinExtPubKey, KeyPath>> PHDPkProviderCommon(ISigningRepository repo, Network n);
    private static Parser`2<char, PubKeyProvider> PHardendedHDPubKeyProvider(ISigningRepository repo, Network n);
    private static Parser`2<char, PubKeyProvider> PUnHardendedHDPubKeyProvider(ISigningRepository repo, Network n);
    private static Parser`2<char, PubKeyProvider> PStaticHDPubKeyProvider(ISigningRepository repo, Network n);
    private static Parser`2<char, PubKeyProvider> PHDPubKeyProvider(ISigningRepository repo, Network n);
    private static Parser`2<char, PubKeyProvider> POriginPubkeyProvider(ISigningRepository repo, Network n, PubKeyContext ctx);
    internal static Parser`2<char, PubKeyProvider> PPubKeyProvider(ISigningRepository repo, Network n, PubKeyContext ctx);
    private static Parser`2<char, BitcoinAddress> PTryConvertAddr(string addrStr, Network n);
    internal static Parser`2<char, OutputDescriptor> PAddr(Network n);
    internal static Parser`2<char, OutputDescriptor> PRaw(ISigningRepository repo, Network n);
    private static Parser`2<char, OutputDescriptor> PExprHelper(Parser`2<char, string> PName, Parser`2<char, T> pInner, Func`3<T, Network, OutputDescriptor> constructor, Network n);
    private static Parser`2<char, OutputDescriptor> PPKHelper(string name, Func`3<PubKeyProvider, Network, OutputDescriptor> constructor, ISigningRepository repo, Network n, PubKeyContext ctx);
    internal static Parser`2<char, OutputDescriptor> PPK(ISigningRepository repo, Network n, PubKeyContext ctx);
    internal static Parser`2<char, OutputDescriptor> PPKH(ISigningRepository repo, Network n, PubKeyContext ctx);
    internal static Parser`2<char, OutputDescriptor> PWPKH(ISigningRepository repo, Network n);
    internal static Parser`2<char, OutputDescriptor> PCombo(ISigningRepository repo, Network n);
    internal static Parser`2<char, OutputDescriptor> PMulti(ISigningRepository repo, Network n, Nullable`1<UInt32> maxMultisigN, PubKeyContext ctx);
    private static Parser`2<char, PubKeyProvider> PPubKeyProviderForTaproot(ISigningRepository repo, Network n, PubKeyContext ctx);
    private static Parser`2<char, OutputDescriptor> PMultiA(ISigningRepository repo, Network n);
    private static Parser`2<char, OutputDescriptor> PTapLeaf(ISigningRepository repo, Network n);
    private static Parser`2<char, TapTree> PTapScript(ISigningRepository repo, Network n);
    private static Parser`2<char, OutputDescriptor> PTRInner(ISigningRepository repo, Network n);
    private static Parser`2<char, OutputDescriptor> PTapRootNoScriptInner(ISigningRepository repo, Network n);
    private static Parser`2<char, OutputDescriptor> PRawTr(ISigningRepository repo, Network n);
    private static Parser`2<char, OutputDescriptor> PWSHInner(ISigningRepository repo, Network n, PubKeyContext ctx, Nullable`1<UInt32> maxMultisigN);
    private static Parser`2<char, OutputDescriptor> PInner(ISigningRepository repo, Network n, PubKeyContext ctx, Nullable`1<UInt32> maxMultisigN);
    private static Parser`2<char, OutputDescriptor> PWSH(ISigningRepository repo, Network n);
    private static Parser`2<char, OutputDescriptor> PSH(ISigningRepository repo, Network n);
    internal static Parser`2<char, OutputDescriptor> PTR(ISigningRepository repo, Network n);
    private static Parser`2<char, OutputDescriptor> POutputDescriptor(ISigningRepository repo, Network n);
    internal static bool TryParseOD(string str, Network network, OutputDescriptor& result, bool requireCheckSum, ISigningRepository repo);
    [NullableContextAttribute("2")]
private static bool TryParseOD(string str, Network network, String& whyFailure, OutputDescriptor& result, bool requireCheckSum, ISigningRepository repo);
    internal static OutputDescriptor ParseOD(string str, Network network, bool requireCheckSum, ISigningRepository repo);
}
internal interface NBitcoin.Scripting.Parser.IInput`1 {
    public bool AtEnd { get; }
    public int Position { get; }
    public IDictionary`2<object, object> Memos { get; }
    public abstract virtual IInput`1<T> Advance();
    public abstract virtual T GetCurrent();
    public abstract virtual bool get_AtEnd();
    public abstract virtual int get_Position();
    public abstract virtual IDictionary`2<object, object> get_Memos();
}
[ExtensionAttribute]
internal static class NBitcoin.Scripting.Parser.Parse : object {
    private static string ValidHex;
    private static string ValidBase58;
    private static Char[] ValidHexChars;
    private static Char[] ValidBase58Chars;
    public static Parser`2<char, char> AnyChar;
    public static Parser`2<char, char> WhiteSpace;
    public static Parser`2<char, char> Digit;
    public static Parser`2<char, char> Letter;
    public static Parser`2<char, char> LetterOrDigit;
    public static Parser`2<char, char> Hex;
    public static Parser`2<char, char> Base58;
    public static Parser`2<char, char> Numeric;
    public static Parser`2<char, string> Number;
    public static Parser`2<char, string> Decimal;
    private static Parse();
    public static Parser`2<char, char> Char(Func`2<char, bool> predicate, string expected);
    public static Parser`2<char, char> CharExcept(Func`2<char, bool> predicate, string description);
    public static Parser`2<char, char> Char(char c);
    public static Parser`2<char, char> Chars(Char[] c);
    public static Parser`2<char, char> Chars(string c);
    public static Parser`2<char, char> CharExcept(char c);
    public static Parser`2<char, IEnumerable`1<char>> String(string s);
    [ExtensionAttribute]
public static Parser`2<char, T> Token(Parser`2<char, T> parser);
    [ExtensionAttribute]
public static Parser`2<char, string> Text(Parser`2<char, IEnumerable`1<char>> characters);
    private static Parser`2<char, string> DecimalWithoutLeadingDigits(CultureInfo ci);
    private static Parser`2<char, string> DecimalWithLeadingDigits(CultureInfo ci);
    [ExtensionAttribute]
public static Parser`2<TToken, U> Then(Parser`2<TToken, T> first, Func`2<T, Parser`2<TToken, U>> second);
    [ExtensionAttribute]
public static Parser`2<TToken, IEnumerable`1<T>> Many(Parser`2<TToken, T> parser);
    [ExtensionAttribute]
public static Parser`2<TToken, IEnumerable`1<T>> XMany(Parser`2<TToken, T> parser);
    [ExtensionAttribute]
public static Parser`2<TToken, IEnumerable`1<T>> AtLeastOnce(Parser`2<TToken, T> parser);
    [ExtensionAttribute]
public static Parser`2<TToken, IEnumerable`1<T>> Once(Parser`2<TToken, T> parser);
    [ExtensionAttribute]
public static Parser`2<TToken, IEnumerable`1<T>> AtLeastOne(Parser`2<TToken, T> parser);
    [ExtensionAttribute]
public static Parser`2<TToken, IEnumerable`1<T>> XAtLeastOnce(Parser`2<TToken, T> parser);
    public static Parser`2<TToken, T> Return(T v);
    [ExtensionAttribute]
public static Parser`2<TToken, U> Select(Parser`2<TToken, T> parser, Func`2<T, U> convert);
    [ExtensionAttribute]
public static Parser`2<TToken, IEnumerable`1<T>> Sequence(IEnumerable`1<Parser`2<TToken, T>> parserList);
    public static Parser`2<TToken, T> Ref(Func`1<Parser`2<TToken, T>> reference);
    [ExtensionAttribute]
public static Parser`2<TToken, T> Or(Parser`2<TToken, T> first, Parser`2<TToken, T> second);
    [ExtensionAttribute]
public static Parser`2<TToken, T> XOr(Parser`2<TToken, T> first, Parser`2<TToken, T> second);
    [ExtensionAttribute]
public static Parser`2<TToken, IEnumerable`1<T>> Concat(Parser`2<TToken, IEnumerable`1<T>> first, Parser`2<TToken, IEnumerable`1<T>> second);
    public static ParserResult`2<TToken, T> DetermineBestError(ParserResult`2<TToken, T> firstF, ParserResult`2<TToken, T> secondF);
    [ExtensionAttribute]
public static Parser`2<TToken, U> Return(Parser`2<TToken, T> parser, U value);
    [ExtensionAttribute]
public static Parser`2<TToken, T> Except(Parser`2<TToken, T> parser, Parser`2<TToken, U> except);
    [ExtensionAttribute]
public static Parser`2<TToken, T> End(Parser`2<TToken, T> parser);
    [ExtensionAttribute]
public static Parser`2<TToken, IEnumerable`1<T>> Until(Parser`2<TToken, T> parser, Parser`2<TToken, U> until);
    [ExtensionAttribute]
public static Parser`2<TToken, T> Where(Parser`2<TToken, T> parser, Func`2<T, bool> predicate);
    [ExtensionAttribute]
public static Parser`2<TToken, V> SelectMany(Parser`2<TToken, T> parser, Func`2<T, Parser`2<TToken, U>> selector, Func`3<T, U, V> projector);
    [ExtensionAttribute]
public static Parser`2<TToken, U> Bind(Parser`2<TToken, T> parser, Func`2<T, Parser`2<TToken, U>> selector);
    public static Parser`2<TToken, T> ChainOperator(Parser`2<TToken, TOp> op, Parser`2<TToken, T> operand, Func`4<TOp, T, T, T> apply);
    public static Parser`2<TToken, T> XChainOperator(Parser`2<TToken, TOp> op, Parser`2<TToken, T> operand, Func`4<TOp, T, T, T> apply);
    private static Parser`2<TToken, T> ChainOperatorRest(T firstOperand, Parser`2<TToken, TOp> op, Parser`2<TToken, T> operand, Func`4<TOp, T, T, T> apply, Func`3<Parser`2<TToken, T>, Parser`2<TToken, T>, Parser`2<TToken, T>> or);
    public static Parser`2<TToken, T> ChainRightOperator(Parser`2<TToken, TOp> op, Parser`2<TToken, T> operand, Func`4<TOp, T, T, T> apply);
    public static Parser`2<TToken, T> XChainRightOperator(Parser`2<TToken, TOp> op, Parser`2<TToken, T> operand, Func`4<TOp, T, T, T> apply);
    private static Parser`2<TToken, T> ChainRightOperatorRest(T lastOperand, Parser`2<TToken, TOp> op, Parser`2<TToken, T> operand, Func`4<TOp, T, T, T> apply, Func`3<Parser`2<TToken, T>, Parser`2<TToken, T>, Parser`2<TToken, T>> or);
    [ExtensionAttribute]
public static Parser`2<TToken, IEnumerable`1<T>> DelimitedBy(Parser`2<TToken, T> parser, Parser`2<TToken, U> delimiter);
    [ExtensionAttribute]
public static Parser`2<TToken, IEnumerable`1<T>> XDelimitedBy(Parser`2<TToken, T> itemParser, Parser`2<TToken, U> delimiter);
    [ExtensionAttribute]
public static Parser`2<TToken, IEnumerable`1<T>> Repeat(Parser`2<TToken, T> parser, int count);
    [ExtensionAttribute]
public static Parser`2<TToken, IEnumerable`1<T>> Repeat(Parser`2<TToken, T> parser, int minimumCount, int maximumCount);
    internal static Parser`2<char, T> TryConvert(string str, Func`2<string, T> converter);
    internal static Parser`2<char, T> TryConvert(string str, SafeConverter`2<string, T> safeConverter);
    public static Parser`2<ScriptToken, ScriptToken> ScriptToken(Func`2<int, bool> predicate, string expected);
    public static Parser`2<ScriptToken, ScriptToken> ScriptToken(ScriptToken sct, string expected);
    public static Parser`2<ScriptToken, ScriptToken> ScriptToken(int tag);
    public static Parser`2<ScriptToken, ScriptToken> ScriptToken(ScriptToken sct);
}
internal class NBitcoin.Scripting.Parser.Parser`1 : MulticastDelegate {
    public Parser`1(object object, IntPtr method);
    public virtual ParserResult`2<char, TValue> Invoke(IInput`1<char> input);
    public virtual IAsyncResult BeginInvoke(IInput`1<char> input, AsyncCallback callback, object object);
    public virtual ParserResult`2<char, TValue> EndInvoke(IAsyncResult result);
}
internal class NBitcoin.Scripting.Parser.Parser`2 : MulticastDelegate {
    public Parser`2(object object, IntPtr method);
    public virtual ParserResult`2<TToken, TValue> Invoke(IInput`1<TToken> input, Network network);
    public virtual IAsyncResult BeginInvoke(IInput`1<TToken> input, Network network, AsyncCallback callback, object object);
    public virtual ParserResult`2<TToken, TValue> EndInvoke(IAsyncResult result);
}
[ExtensionAttribute]
internal static class NBitcoin.Scripting.Parser.ParserExtension : object {
    [ExtensionAttribute]
internal static ParserResult`2<char, T> TryParse(Parser`2<char, T> parser, string input, Network network);
    [ExtensionAttribute]
internal static T Parse(Parser`2<char, T> parser, string input, Network network);
    [ExtensionAttribute]
internal static ParserResult`2<ScriptToken, T> TryParse(Parser`2<ScriptToken, T> parser, Network network, Script input);
    [ExtensionAttribute]
internal static T Parse(Parser`2<ScriptToken, T> parser, Script input, Network network);
}
internal class NBitcoin.Scripting.Parser.ParserResult`2 : object {
    public TValue Value;
    public IInput`1<TToken> Rest;
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <Expected>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsSuccess>k__BackingField;
    public IEnumerable`1<string> Expected { get; private set; }
    public string Description { get; private set; }
    public bool IsSuccess { get; private set; }
    private ParserResult`2(IInput`1<TToken> rest, TValue value);
    public static ParserResult`2<TToken, TValue> Success(IInput`1<TToken> rest, TValue v);
    public static ParserResult`2<TToken, TValue> Failure(IInput`1<TToken> rest, string description);
    public static ParserResult`2<TToken, TValue> Failure(IInput`1<TToken> rest, IEnumerable`1<string> expected, string description);
    public ParserResult`2<TToken, U> IfSuccess(Func`2<ParserResult`2<TToken, TValue>, ParserResult`2<TToken, U>> next);
    public ParserResult`2<TToken, TValue> IfFailure(Func`2<ParserResult`2<TToken, TValue>, ParserResult`2<TToken, TValue>> next);
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_Expected();
    [CompilerGeneratedAttribute]
private void set_Expected(IEnumerable`1<string> value);
    [CompilerGeneratedAttribute]
public string get_Description();
    [CompilerGeneratedAttribute]
private void set_Description(string value);
    [CompilerGeneratedAttribute]
public bool get_IsSuccess();
    [CompilerGeneratedAttribute]
private void set_IsSuccess(bool value);
    public virtual string ToString();
}
public class NBitcoin.Scripting.Parser.ParsingException : FormatException {
    [CompilerGeneratedAttribute]
private int <Position>k__BackingField;
    public int Position { get; }
    public ParsingException(string message);
    public ParsingException(string message, int position);
    public ParsingException(string message, Exception innerException);
    [CompilerGeneratedAttribute]
public int get_Position();
}
internal class NBitcoin.Scripting.Parser.ScriptInput : object {
    [CompilerGeneratedAttribute]
private ScriptToken[] <Source>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Position>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<object, object> <Memos>k__BackingField;
    public ScriptToken[] Source { get; }
    public int Position { get; }
    public bool AtEnd { get; }
    public IDictionary`2<object, object> Memos { get; }
    public ScriptInput(Script source);
    public ScriptInput(ScriptToken[] source);
    internal ScriptInput(ScriptToken[] source, int position);
    [CompilerGeneratedAttribute]
public ScriptToken[] get_Source();
    [CompilerGeneratedAttribute]
public sealed virtual int get_Position();
    public sealed virtual bool get_AtEnd();
    public sealed virtual ScriptToken GetCurrent();
    public sealed virtual IInput`1<ScriptToken> Advance();
    public sealed virtual IEnumerator`1<ScriptToken> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [CompilerGeneratedAttribute]
public sealed virtual IDictionary`2<object, object> get_Memos();
}
internal class NBitcoin.Scripting.Parser.StringInput : object {
    [CompilerGeneratedAttribute]
private string <Source>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Position>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<object, object> <Memos>k__BackingField;
    public string Source { get; }
    public int Position { get; }
    public bool AtEnd { get; }
    public IDictionary`2<object, object> Memos { get; }
    public StringInput(string source);
    internal StringInput(string source, int position);
    [CompilerGeneratedAttribute]
public string get_Source();
    [CompilerGeneratedAttribute]
public sealed virtual int get_Position();
    public sealed virtual bool get_AtEnd();
    public sealed virtual char GetCurrent();
    public sealed virtual IInput`1<char> Advance();
    public sealed virtual IEnumerator`1<char> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [CompilerGeneratedAttribute]
public sealed virtual IDictionary`2<object, object> get_Memos();
}
internal static class NBitcoin.Scripting.ParserUtil : object {
    internal static Parser`2<char, string> SurroundedByBrackets;
    private static ParserUtil();
}
public abstract class NBitcoin.Scripting.PubKeyProvider : object {
    public static PubKeyProvider NewOrigin(RootedKeyPath keyOrigin, PubKeyProvider inner);
    public static PubKeyProvider NewConst(PubKey pk);
    public static PubKeyProvider NewConst(PubKey pk, bool xonly);
    public static PubKeyProvider NewConst(TaprootPubKey pk);
    public static PubKeyProvider NewConst(TaprootFullPubKey pk);
    public static PubKeyProvider NewConst(TaprootInternalPubKey pk);
    public static PubKeyProvider NewHD(BitcoinExtPubKey extPubKey, KeyPath kp, DeriveType t);
    public PubKey GetPubKey(UInt32 pos, Func`2<KeyId, Key> privateKeyProvider);
    public PubKey GetPubKey(UInt32 pos, Func`2<KeyId, Key> privateKeyProvider, RootedKeyPath& keyOriginInfo);
    public bool TryGetPubKey(UInt32 pos, Func`2<KeyId, Key> privateKeyProvider, RootedKeyPath& keyOriginInfo, PubKey& pubkey);
    public bool IsRange();
    public bool IsCompressed();
    public virtual string ToString();
    internal bool TryGetPrivateString(ISigningRepository secretProvider, String& ret);
    public sealed virtual bool Equals(object obj);
    public sealed virtual bool Equals(PubKeyProvider other);
    public virtual int GetHashCode();
}
[ExtensionAttribute]
public static class NBitcoin.Scripting.ScriptExtensions : object {
    [ExtensionAttribute]
internal static ScriptToken[] ToTokens(Script sc);
    private static ScriptToken GetItem(Op op);
}
internal class NBitcoin.Scripting.ScriptToken : object {
    [CompilerGeneratedAttribute]
private int <Tag>k__BackingField;
    internal static ScriptToken _unique_BoolAnd;
    internal static ScriptToken _unique_BoolOr;
    internal static ScriptToken _unique_Add;
    internal static ScriptToken _unique_Equal;
    internal static ScriptToken _unique_EqualVerify;
    internal static ScriptToken _unique_CheckSig;
    internal static ScriptToken _unique_CheckSigVerify;
    internal static ScriptToken _unique_CheckMultiSig;
    internal static ScriptToken _unique_CheckMultiSigVerify;
    internal static ScriptToken _unique_CheckSequenceVerify;
    internal static ScriptToken _unique_FromAltStack;
    internal static ScriptToken _unique_ToAltStack;
    internal static ScriptToken _unique_Drop;
    internal static ScriptToken _unique_Dup;
    internal static ScriptToken _unique_If;
    internal static ScriptToken _unique_IfDup;
    internal static ScriptToken _unique_NotIf;
    internal static ScriptToken _unique_Else;
    internal static ScriptToken _unique_EndIf;
    internal static ScriptToken _unique_ZeroNotEqual;
    internal static ScriptToken _unique_Size;
    internal static ScriptToken _unique_Swap;
    internal static ScriptToken _unique_Verify;
    internal static ScriptToken _unique_Hash160;
    internal static ScriptToken _unique_Sha256;
    internal int Tag { get; }
    internal static ScriptToken BoolAnd { get; }
    internal static ScriptToken BoolOr { get; }
    internal static ScriptToken Add { get; }
    internal static ScriptToken Equal { get; }
    internal static ScriptToken EqualVerify { get; }
    internal static ScriptToken CheckSig { get; }
    internal static ScriptToken CheckSigVerify { get; }
    internal static ScriptToken CheckMultiSig { get; }
    internal static ScriptToken CheckMultiSigVerify { get; }
    internal static ScriptToken CheckSequenceVerify { get; }
    internal static ScriptToken FromAltStack { get; }
    internal static ScriptToken ToAltStack { get; }
    internal static ScriptToken Drop { get; }
    internal static ScriptToken Dup { get; }
    internal static ScriptToken If { get; }
    internal static ScriptToken IfDup { get; }
    internal static ScriptToken NotIf { get; }
    internal static ScriptToken Else { get; }
    internal static ScriptToken EndIf { get; }
    internal static ScriptToken ZeroNotEqual { get; }
    internal static ScriptToken Size { get; }
    internal static ScriptToken Swap { get; }
    internal static ScriptToken Verify { get; }
    internal static ScriptToken Hash160 { get; }
    internal static ScriptToken Sha256 { get; }
    private ScriptToken(int tag);
    private static ScriptToken();
    [CompilerGeneratedAttribute]
internal int get_Tag();
    internal static ScriptToken get_BoolAnd();
    internal static ScriptToken get_BoolOr();
    internal static ScriptToken get_Add();
    internal static ScriptToken get_Equal();
    internal static ScriptToken get_EqualVerify();
    internal static ScriptToken get_CheckSig();
    internal static ScriptToken get_CheckSigVerify();
    internal static ScriptToken get_CheckMultiSig();
    internal static ScriptToken get_CheckMultiSigVerify();
    internal static ScriptToken get_CheckSequenceVerify();
    internal static ScriptToken get_FromAltStack();
    internal static ScriptToken get_ToAltStack();
    internal static ScriptToken get_Drop();
    internal static ScriptToken get_Dup();
    internal static ScriptToken get_If();
    internal static ScriptToken get_IfDup();
    internal static ScriptToken get_NotIf();
    internal static ScriptToken get_Else();
    internal static ScriptToken get_EndIf();
    internal static ScriptToken get_ZeroNotEqual();
    internal static ScriptToken get_Size();
    internal static ScriptToken get_Swap();
    internal static ScriptToken get_Verify();
    internal static ScriptToken get_Hash160();
    internal static ScriptToken get_Sha256();
    public virtual string ToString();
    public sealed virtual int GetHashCode();
    public sealed virtual bool Equals(object obj);
    public sealed virtual bool Equals(ScriptToken obj);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class NBitcoin.Scripting.TaprootExtensions : object {
    [ExtensionAttribute]
public static Nullable`1<ValueTuple`2<int, List`1<TaprootPubKey>>> FindMultiATemplate(Script sc);
    [ExtensionAttribute]
public static bool InferTaprootTree(TaprootSpendInfo info, TaprootPubKey outputKey, List`1& result);
}
public enum NBitcoin.ScriptPubKeyType : Enum {
    public int value__;
    public static ScriptPubKeyType Legacy;
    public static ScriptPubKeyType Segwit;
    public static ScriptPubKeyType SegwitP2SH;
    public static ScriptPubKeyType TaprootBIP86;
}
public class NBitcoin.ScriptReader : object {
    private Stream _Inner;
    private static Byte[] Scratch;
    [CompilerGeneratedAttribute]
private bool <HasError>k__BackingField;
    public Stream Inner { get; }
    public bool HasError { get; private set; }
    public ScriptReader(Stream stream);
    public ScriptReader(Byte[] data);
    private static ScriptReader();
    public Stream get_Inner();
    public Op Read();
    public bool TryReadOpCode(OpcodeType& opcode);
    private void MoveStream(Stream inner, UInt32 bytes);
    [CompilerGeneratedAttribute]
public bool get_HasError();
    [CompilerGeneratedAttribute]
private void set_HasError(bool value);
    [IteratorStateMachineAttribute("NBitcoin.ScriptReader/<ToEnumerable>d__13")]
public IEnumerable`1<Op> ToEnumerable();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NBitcoin.ScriptSigs : object {
    [CompilerGeneratedAttribute]
private Script <ScriptSig>k__BackingField;
    [CompilerGeneratedAttribute]
private WitScript <WitSig>k__BackingField;
    public Script ScriptSig { get; public set; }
    public WitScript WitSig { get; public set; }
    [CompilerGeneratedAttribute]
public Script get_ScriptSig();
    [CompilerGeneratedAttribute]
public void set_ScriptSig(Script value);
    [CompilerGeneratedAttribute]
public WitScript get_WitSig();
    [CompilerGeneratedAttribute]
public void set_WitSig(WitScript value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class NBitcoin.ScriptTemplate : object {
    public virtual bool CheckScriptPubKey(Script scriptPubKey);
    protected virtual bool FastCheckScriptPubKey(Script scriptPubKey, Boolean& needMoreCheck);
    protected abstract virtual bool CheckScriptPubKeyCore(Script scriptPubKey, Op[] scriptPubKeyOps);
    public virtual bool CheckScriptSig(Script scriptSig, Script scriptPubKey);
    protected virtual bool FastCheckScriptSig(Script scriptSig, Script scriptPubKey, Boolean& needMoreCheck);
    protected abstract virtual bool CheckScriptSigCore(Script scriptSig, Op[] scriptSigOps, Script scriptPubKey, Op[] scriptPubKeyOps);
}
public enum NBitcoin.ScriptType : Enum {
    public int value__;
    public static ScriptType Witness;
    public static ScriptType P2PKH;
    public static ScriptType P2SH;
    public static ScriptType P2PK;
    public static ScriptType P2WPKH;
    public static ScriptType P2WSH;
    public static ScriptType MultiSig;
    public static ScriptType Taproot;
}
[FlagsAttribute]
public enum NBitcoin.ScriptVerify : Enum {
    public UInt32 value__;
    public static ScriptVerify None;
    public static ScriptVerify P2SH;
    public static ScriptVerify StrictEnc;
    public static ScriptVerify DerSig;
    public static ScriptVerify LowS;
    public static ScriptVerify NullDummy;
    public static ScriptVerify SigPushOnly;
    public static ScriptVerify MinimalData;
    public static ScriptVerify DiscourageUpgradableNops;
    public static ScriptVerify CleanStack;
    public static ScriptVerify CheckLockTimeVerify;
    public static ScriptVerify CheckSequenceVerify;
    public static ScriptVerify Witness;
    public static ScriptVerify DiscourageUpgradableWitnessProgram;
    public static ScriptVerify MinimalIf;
    public static ScriptVerify NullFail;
    public static ScriptVerify WitnessPubkeyType;
    public static ScriptVerify ConstScriptCode;
    public static ScriptVerify ForkId;
    public static ScriptVerify Taproot;
    public static ScriptVerify DiscourageUpgradableTaprootVersion;
    public static ScriptVerify DiscourageOpSuccess;
    public static ScriptVerify DiscourageUpgradablePubKeyType;
    public static ScriptVerify Mandatory;
    public static ScriptVerify Standard;
    public static ScriptVerify Consensus;
}
internal class NBitcoin.Secp256k1.BIP340NonceFunction : object {
    [NullableAttribute("1")]
private static RandomNumberGenerator rand;
    private ReadOnlyMemory`1<byte> data32;
    [NullableAttribute("1")]
private static Byte[] ZERO_MASK;
    [NullableAttribute("1")]
private static Byte[] TAG_BIP0340AUX;
    [NullableAttribute("1")]
public static Byte[] TAG_BIP340;
    public BIP340NonceFunction(ReadOnlyMemory`1<byte> auxData32);
    public BIP340NonceFunction(bool random);
    private static BIP340NonceFunction();
    public sealed virtual bool TryGetNonce(Span`1<byte> nonce32, ReadOnlySpan`1<byte> msg32, ReadOnlySpan`1<byte> key32, ReadOnlySpan`1<byte> xonly_pk32, ReadOnlySpan`1<byte> algo);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NBitcoin.Secp256k1.Context : object {
    private static Lazy`1<Context> _Instance;
    [CompilerGeneratedAttribute]
private ECMultContext <EcMultContext>k__BackingField;
    [CompilerGeneratedAttribute]
private ECMultGenContext <EcMultGenContext>k__BackingField;
    public static Context Instance { get; }
    public ECMultContext EcMultContext { get; }
    public ECMultGenContext EcMultGenContext { get; }
    [NullableContextAttribute("2")]
public Context(ECMultContext ctx, ECMultGenContext genCtx);
    private static Context();
    private static Context CreateInstance();
    public static Context get_Instance();
    [CompilerGeneratedAttribute]
public ECMultContext get_EcMultContext();
    [CompilerGeneratedAttribute]
public ECMultGenContext get_EcMultGenContext();
    public ECPrivKey CreateECPrivKey(Scalar& scalar);
    [NullableContextAttribute("0")]
public ECPrivKey CreateECPrivKey(ReadOnlySpan`1<byte> b32);
    [NullableContextAttribute("0")]
public bool TryCreateECPrivKey(ReadOnlySpan`1<byte> b32, ECPrivKey& key);
    public bool TryCreateECPrivKey(Scalar& s, ECPrivKey& key);
    [NullableContextAttribute("0")]
public bool TryCreateXOnlyPubKey(ReadOnlySpan`1<byte> input32, ECXOnlyPubKey& pubkey);
    [NullableContextAttribute("0")]
public ECXOnlyPubKey CreateXOnlyPubKey(ReadOnlySpan`1<byte> input32);
    [NullableContextAttribute("0")]
public ECPubKey CreatePubKey(ReadOnlySpan`1<byte> input);
    [NullableContextAttribute("0")]
public bool TryCreatePubKey(ReadOnlySpan`1<byte> input, ECPubKey& pubkey);
    [NullableContextAttribute("0")]
public bool TryCreatePubKey(ReadOnlySpan`1<byte> input, Boolean& compressed, ECPubKey& pubkey);
    [NullableContextAttribute("0")]
public bool TryCreatePrivKeyFromDer(ReadOnlySpan`1<byte> input, ECPrivKey& privkey);
}
internal class NBitcoin.Secp256k1.DLEQProof : object {
    public Scalar b;
    public Scalar c;
    public DLEQProof(Scalar& b, Scalar& c);
    internal static void secp256k1_dleq_serialize_point(Span`1<byte> buf33, GE& p);
    internal static bool secp256k1_dleq_deserialize_point(ReadOnlySpan`1<byte> buf33, GE& p);
    public static bool TryCreate(ReadOnlySpan`1<byte> in64, DLEQProof& proof);
    public void WriteToSpan(Span`1<byte> out64);
    [NullableContextAttribute("1")]
public Byte[] ToBytes();
}
internal static class NBitcoin.Secp256k1.EC : object {
    public static GE G;
    public static Scalar N;
    public static Scalar NC;
    public static UInt32 CURVE_B;
    private static EC();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NBitcoin.Secp256k1.ECDSA : object {
    private static Lazy`1<ECDSA> _Instance;
    private ECMultContext ctx;
    public static ECDSA Instance { get; }
    [NullableContextAttribute("2")]
public ECDSA(ECMultContext ctx);
    private static ECDSA();
    private static ECDSA CreateInstance();
    public static ECDSA get_Instance();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NBitcoin.Secp256k1.ECDSAEncryptedSignature : object {
    public GE r;
    public GE rp;
    public Scalar sp;
    [CompilerGeneratedAttribute]
private DLEQProof <Proof>k__BackingField;
    public DLEQProof Proof { get; }
    internal ECDSAEncryptedSignature(GE& r, GE& rp, Scalar& sp, DLEQProof proof);
    [CompilerGeneratedAttribute]
public DLEQProof get_Proof();
    public Scalar GetRAsScalar();
    [NullableContextAttribute("0")]
public static bool TryCreate(ReadOnlySpan`1<byte> input162, ECDSAEncryptedSignature& sig);
    public SecpECDSASignature DecryptECDSASignature(ECPrivKey encryptionKey);
    internal static bool TryGetScalar(FE& fe, Scalar& scalar);
    [NullableContextAttribute("0")]
public void WriteToSpan(Span`1<byte> out162);
    public Byte[] ToBytes();
    public bool TryRecoverDecryptionKey(SecpECDSASignature sig, ECPubKey encryptionKey, ECPrivKey& decryptionKey);
}
internal class NBitcoin.Secp256k1.ECMultContext : object {
    [NullableAttribute("1")]
private static Lazy`1<ECMultContext> _Instance;
    private static int ArraySize;
    internal static int WINDOW_G;
    internal static int WINDOW_A;
    internal static int ArraySize_A;
    [NullableAttribute("1")]
internal GEStorage[] pre_g;
    [NullableAttribute("1")]
internal GEStorage[] pre_g_128;
    internal static int WNAFT_SIZE_A;
    private static int WNAF_BITS;
    private static int PIPPENGER_MAX_BUCKET_WINDOW;
    [NullableAttribute("1")]
public static ECMultContext Instance { get; }
    private static ECMultContext();
    [NullableContextAttribute("1")]
private static ECMultContext CreateInstance();
    [NullableContextAttribute("1")]
public static ECMultContext get_Instance();
    internal static int WNAF_SIZE(int w);
    private static int WNAF_SIZE_BITS(int bits, int w);
    private static int ECMULT_TABLE_SIZE(int w);
    internal static GEJ secp256k1_ecmult_multi_simple_var(ECMultContext ctx, Nullable`1& inp_g_sc, ReadOnlySpan`1<Scalar> scalars, ReadOnlySpan`1<GE> points);
    private static void secp256k1_ecmult_endo_split(Scalar& s1, Scalar& s2, GE& p1, GE& p2);
    [NullableContextAttribute("1")]
private static void secp256k1_ecmult_odd_multiples_table_storage_var(int n, GEStorage[] pre, GEJ& a);
    public GEJ Mult(GEJ& a, Scalar& na, Nullable`1& ng);
    public GEJ MultBatch(Nullable`1& inp_g_sc, ReadOnlySpan`1<Scalar> scalars, ReadOnlySpan`1<GE> points, MultBatchOptions options);
    public GEJ MultBatch(Nullable`1& inp_g_sc, ReadOnlySpan`1<Scalar> scalars, ReadOnlySpan`1<GE> points, ECMultiImplementation implementation);
    public GEJ MultBatch(Nullable`1& inp_g_sc, ReadOnlySpan`1<Scalar> scalars, ReadOnlySpan`1<GE> points);
    public GEJ MultBatch(ReadOnlySpan`1<Scalar> scalars, ReadOnlySpan`1<GE> points);
    private static void ECMULT_TABLE_GET_GE_STORAGE(GE& r, Span`1& pre, int n, int w);
    private static void ECMULT_TABLE_GET_GE(GE& r, Span`1& pre, int n, int w);
    internal static int secp256k1_ecmult_wnaf(Span`1<int> wnaf, int len, Scalar& a, int w);
    internal static void secp256k1_ecmult_odd_multiples_table_globalz_windowa(Span`1<GE> pre, FE& globalz, GEJ& a);
    [ConditionalAttribute("SECP256K1_VERIFY")]
private static void VERIFY_CHECK(bool value);
    private static int secp256k1_pippenger_bucket_window(int n);
    internal static void secp256k1_ecmult_pippenger_batch(Nullable`1& inp_g_sc, ReadOnlySpan`1<Scalar> scalarsInput, ReadOnlySpan`1<GE> pointsInput, GEJ& r);
    private static GEJ secp256k1_ecmult_pippenger_wnaf(Span`1<GEJ> buckets, int bucket_window, PippengerState state, ReadOnlySpan`1<Scalar> sc, ReadOnlySpan`1<GE> pt, int num);
    internal GEJ secp256k1_ecmult_strauss_batch(Nullable`1& inp_g_sc, ReadOnlySpan`1<Scalar> scalars, ReadOnlySpan`1<GE> points);
    private GEJ secp256k1_ecmult_strauss_wnaf(StraussState& state, ReadOnlySpan`1& a, ReadOnlySpan`1& na, Nullable`1& ng, int num);
    private static void secp256k1_ge_globalz_set_table_gej(int len, Span`1<GE> r, FE& globalz, Span`1<GEJ> a, Span`1<FE> zr);
    internal static void secp256k1_ecmult_odd_multiples_table(int n, Span`1<GEJ> prej, Span`1<FE> zr, GEJ& a);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NBitcoin.Secp256k1.ECMultGenContext : object {
    private static Lazy`1<ECMultGenContext> _Instance;
    internal GEStorage[0...,0...] prec;
    internal Scalar blind;
    internal GEJ initial;
    public static ECMultGenContext Instance { get; }
    private static ECMultGenContext();
    public static ECMultGenContext get_Instance();
    private static ECMultGenContext CreateInstance();
    [NullableContextAttribute("2")]
public void Blind(Byte[] seed32);
    public GEJ MultGen(Scalar& a);
    [ConditionalAttribute("SECP256K1_VERIFY")]
private static void VERIFY_CHECK(bool v);
}
internal enum NBitcoin.Secp256k1.ECMultiImplementation : Enum {
    public int value__;
    public static ECMultiImplementation Auto;
    public static ECMultiImplementation Pippenger;
    public static ECMultiImplementation Strauss;
    public static ECMultiImplementation Simple;
}
internal class NBitcoin.Secp256k1.ECPrivKey : object {
    internal bool cleared;
    internal Scalar sec;
    [NullableAttribute("1")]
internal Context ctx;
    [NullableContextAttribute("2")]
internal ECPrivKey(Scalar& scalar, Context ctx, bool enforceCheck);
    internal ECPrivKey(ReadOnlySpan`1<byte> b32, Context ctx);
    [NullableContextAttribute("1")]
internal DLEQProof ProveDLEQ(ECPubKey Y, ECPubKey Z);
    [NullableContextAttribute("1")]
internal SecpECDSASignature DecryptECDSASignature(ECDSAEncryptedSignature encryptedSignature);
    private bool secp256k1_dleq_nonce(Span`1<byte> sk32, Span`1<byte> gen2_33, Span`1<byte> p1_33, Span`1<byte> p2_33, Scalar& scalar);
    private bool TryGetNonce(Span`1<byte> nonce, ReadOnlySpan`1<byte> msg32, ReadOnlySpan`1<byte> key32, ReadOnlySpan`1<byte> pk33, Scalar& scalar);
    internal static void secp256k1_dleq_challenge(GE& gen2, GE& r1, GE& r2, GE& p1, GE& p2, Scalar& e);
    [NullableContextAttribute("1")]
private static void secp256k1_dleq_hash_point(SHA256 sha, GE p);
    [NullableContextAttribute("1")]
public static void secp256k1_dleq_pair(ECMultGenContext ecmult_gen_ctx, Scalar& sk, GE& gen2, GE& p1, GE& p2);
    [NullableContextAttribute("1")]
public bool TrySignEncryptedECDSA(ReadOnlySpan`1<byte> msg32, ECPubKey encryptionKey, ECDSAEncryptedSignature& signature);
    [NullableContextAttribute("1")]
internal SchnorrEncryptedSignature SignEncryptedBIP340(ReadOnlySpan`1<byte> msg32, ECPubKey encryptionKey);
    [NullableContextAttribute("1")]
internal SecpSchnorrSignature DecryptBIP340Signature(SchnorrEncryptedSignature encryptedSignature);
    [NullableContextAttribute("1")]
internal SchnorrEncryptedSignature SignEncryptedBIP340(ReadOnlySpan`1<byte> msg32, ECPubKey adaptor, BIP340NonceFunction nonceFunction);
    public static bool TryCreateFromDer(ReadOnlySpan`1<byte> privkey, ECPrivKey& result);
    public static bool TryCreateFromDer(ReadOnlySpan`1<byte> privkey, Context ctx, ECPrivKey& result);
    public static bool TryCreate(ReadOnlySpan`1<byte> b32, ECPrivKey& key);
    public static bool TryCreate(ReadOnlySpan`1<byte> b32, Context context, ECPrivKey& key);
    public static ECPrivKey Create(ReadOnlySpan`1<byte> b32);
    public static ECPrivKey Create(ReadOnlySpan`1<byte> b32, Context context);
    [NullableContextAttribute("1")]
public static bool TryCreate(Scalar& s, ECPrivKey& key);
    [NullableContextAttribute("1")]
public static bool TryCreate(Scalar& s, Context context, ECPrivKey& key);
    [NullableContextAttribute("1")]
public ECPubKey CreatePubKey();
    public ECPrivKey TweakAdd(ReadOnlySpan`1<byte> tweak);
    public bool TryTweakAdd(ReadOnlySpan`1<byte> tweak, ECPrivKey& tweakedPrivKey);
    private bool secp256k1_eckey_privkey_tweak_add(Scalar& key, Scalar& tweak);
    public void WriteDerToSpan(bool compressed, Span`1<byte> derOutput, Int32& length);
    public void WriteToSpan(Span`1<byte> span);
    public SecpECDSASignature SignECDSARFC6979(ReadOnlySpan`1<byte> msg32);
    [ConditionalAttribute("SECP256K1_VERIFY")]
private static void VERIFY_CHECK(bool value);
    public bool TrySignECDSA(ReadOnlySpan`1<byte> msg32, SecpECDSASignature& signature);
    [NullableContextAttribute("2")]
public bool TrySignECDSA(ReadOnlySpan`1<byte> msg32, INonceFunction nonceFunction, SecpECDSASignature& signature);
    [NullableContextAttribute("2")]
public bool TrySignECDSA(ReadOnlySpan`1<byte> msg32, INonceFunction nonceFunction, Int32& recid, SecpECDSASignature& signature);
    [NullableContextAttribute("1")]
internal static bool secp256k1_ecdsa_sig_sign(ECMultGenContext ctx, Scalar& sigr, Scalar& sigs, Scalar& seckey, Scalar& message, Scalar& nonce, Int32& recid);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
public static bool op_Equality(ECPrivKey a, ECPrivKey b);
    [NullableContextAttribute("2")]
public static bool op_Inequality(ECPrivKey a, ECPrivKey b);
    public virtual int GetHashCode();
    public ECPrivKey TweakMul(ReadOnlySpan`1<byte> tweak);
    public bool TryTweakMul(ReadOnlySpan`1<byte> tweak, ECPrivKey& tweakedPrivkey);
    internal static bool secp256k1_eckey_privkey_tweak_mul(Scalar& key, Scalar& tweak);
    protected virtual void Dispose(bool disposing);
    public sealed virtual void Dispose();
    protected virtual override void Finalize();
    public void Clear();
    [NullableContextAttribute("1")]
public ECPrivKey Clone();
    public void AssertNotDisposed();
    public bool TrySignRecoverable(ReadOnlySpan`1<byte> msg32, SecpRecoverableECDSASignature& recoverableSignature);
    [NullableContextAttribute("2")]
public bool TrySignRecoverable(ReadOnlySpan`1<byte> msg32, INonceFunction nonceFunction, SecpRecoverableECDSASignature& recoverableSignature);
    public SecpSchnorrSignature SignBIP340(ReadOnlySpan`1<byte> msg32);
    public SecpSchnorrSignature SignBIP340(ReadOnlySpan`1<byte> msg32, ReadOnlyMemory`1<byte> auxData32);
    public SecpSchnorrSignature SignBIP340(ReadOnlySpan`1<byte> msg32, INonceFunctionHardened nonceFunction);
    public bool TrySignBIP340(ReadOnlySpan`1<byte> msg32, INonceFunctionHardened nonceFunction, SecpSchnorrSignature& signature);
    [NullableContextAttribute("2")]
public bool TrySignBIP340(ReadOnlySpan`1<byte> msg32, ECPubKey pubkey, INonceFunctionHardened nonceFunction, SecpSchnorrSignature& signature);
    internal static Scalar GetBIP340Challenge(ReadOnlySpan`1<byte> msg32, Span`1<byte> R, Span`1<byte> pk);
    [NullableContextAttribute("1")]
public ECXOnlyPubKey CreateXOnlyPubKey();
    [NullableContextAttribute("1")]
public ECXOnlyPubKey CreateXOnlyPubKey(Boolean& parity);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NBitcoin.Secp256k1.ECPubKey : object {
    internal GE Q;
    internal Context ctx;
    internal static FE order_as_fe;
    internal static FE p_minus_order;
    private static string MusigTag;
    [NullableContextAttribute("2")]
public ECPubKey(GE& groupElement, Context context);
    private static ECPubKey();
    public bool TryRecoverDecryptionKey(SecpECDSASignature signature, ECDSAEncryptedSignature encryptedSignature, ECPrivKey& decryptionKey);
    public bool SigVerifyEncryptedECDSA(ECDSAEncryptedSignature encryptedSignature, ReadOnlySpan`1<byte> msg32, ECPubKey encryptionKey);
    public bool VerifyDLEQ(DLEQProof proof, ECPubKey Y, ECPubKey Z);
    public bool TryRecoverDecryptionKey(SecpSchnorrSignature signature, SchnorrEncryptedSignature encryptedSignature, ECPrivKey& decryptionKey);
    public virtual ECXOnlyPubKey ToXOnlyPubKey();
    public virtual ECXOnlyPubKey ToXOnlyPubKey(Boolean& parity);
    [NullableContextAttribute("0")]
public void WriteToSpan(bool compressed, Span`1<byte> output, Int32& length);
    [NullableContextAttribute("0")]
public static void Serialize(GE q, bool compressed, Span`1<byte> output, Int32& length);
    [NullableContextAttribute("0")]
public static ECPubKey Create(ReadOnlySpan`1<byte> input);
    [NullableContextAttribute("0")]
public static ECPubKey Create(ReadOnlySpan`1<byte> input, Context ctx);
    [NullableContextAttribute("0")]
public static bool TryCreate(ReadOnlySpan`1<byte> input, Context ctx, Boolean& compressed, ECPubKey& pubkey);
    [NullableContextAttribute("0")]
public static bool TryCreateRawFormat(ReadOnlySpan`1<byte> input, Context ctx, ECPubKey& pubkey);
    [NullableContextAttribute("0")]
public bool SigVerify(SecpECDSASignature signature, ReadOnlySpan`1<byte> msg32);
    internal static bool secp256k1_ecdsa_sig_verify(ECMultContext ctx, Scalar& sigr, Scalar& sigs, GE& pubkey, Scalar& message);
    public ECPubKey Negate();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
public static bool op_Equality(ECPubKey a, ECPubKey b);
    [NullableContextAttribute("2")]
public static bool op_Inequality(ECPubKey a, ECPubKey b);
    public virtual int GetHashCode();
    [NullableContextAttribute("0")]
public ECPubKey AddTweak(ReadOnlySpan`1<byte> tweak32);
    [NullableContextAttribute("0")]
public bool TryAddTweak(ReadOnlySpan`1<byte> tweak32, ECPubKey& tweakedPubKey);
    [NullableContextAttribute("0")]
internal static bool secp256k1_ec_pubkey_tweak_add_helper(ECMultContext ctx, GE& p, ReadOnlySpan`1& tweak32);
    internal static bool secp256k1_eckey_pubkey_tweak_add(ECMultContext ctx, GE& key, Scalar& tweak);
    public static bool TryCombine(Context ctx, IEnumerable`1<ECPubKey> pubkeys, ECPubKey& combinedPubKey);
    [NullableContextAttribute("0")]
public ECPubKey TweakMul(ReadOnlySpan`1<byte> tweak);
    [NullableContextAttribute("0")]
public bool TryTweakMul(ReadOnlySpan`1<byte> tweak, ECPubKey& tweakedPubKey);
    public Byte[] ToBytes();
    public Byte[] ToBytes(bool compressed);
    private static bool secp256k1_eckey_pubkey_tweak_mul(ECMultContext ctx, GE& key, Scalar& tweak);
    public ECPubKey GetSharedPubkey(ECPrivKey key);
    [NullableContextAttribute("0")]
internal static int secp256k1_memcmp_var(ReadOnlySpan`1<byte> s1, ReadOnlySpan`1<byte> s2, int n);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(ECPubKey other);
    [NullableContextAttribute("0")]
internal static void secp256k1_eckey_pubkey_serialize(Span`1<byte> pub, GE& elem, Int32& size, bool compressed);
    [NullableContextAttribute("0")]
private static void secp256k1_musig_compute_pk_hash(Span`1<byte> pk_hash, ECPubKey[] pk);
    [NullableContextAttribute("0")]
internal static void secp256k1_xonly_ge_serialize(Span`1<byte> output32, GE& ge);
    [NullableContextAttribute("0")]
private static Scalar secp256k1_musig_keyaggcoef_internal(ReadOnlySpan`1<byte> ell, ECPubKey pk, FE& second_pk_x);
    internal static Scalar secp256k1_musig_keyaggcoef(MusigContext pre_session, ECPubKey pk);
    public static ECPubKey MusigAggregate(ECPubKey[] pubkeys);
    internal static ECPubKey MusigAggregate(ECPubKey[] pubkeys, MusigContext preSession);
    public static bool TryRecover(Context ctx, SecpRecoverableECDSASignature recoverableSig, ReadOnlySpan`1<byte> msg32, ECPubKey& pubkey);
    private static bool secp256k1_ecdsa_sig_recover(ECMultContext ctx, Scalar& sigr, Scalar& sigs, GE& pubkey, Scalar& message, int recid);
    [ConditionalAttribute("SECP256K1_VERIFY")]
private static void VERIFY_CHECK(bool value);
}
internal class NBitcoin.Secp256k1.ECXOnlyPubKey : object {
    [NullableAttribute("1")]
internal static Byte[] TAG_BIP0340Challenge;
    internal GE Q;
    [NullableAttribute("1")]
internal Context ctx;
    [NullableContextAttribute("2")]
internal ECXOnlyPubKey(GE& ge, Context context);
    private static ECXOnlyPubKey();
    [NullableContextAttribute("1")]
internal bool SigVerifyEncryptedBIP340(SchnorrEncryptedSignature encryptedSignature, ReadOnlySpan`1<byte> msg32, ECPubKey encryptionKey);
    public static bool TryCreate(ReadOnlySpan`1<byte> input32, ECXOnlyPubKey& pubkey);
    public static bool TryCreate(ReadOnlySpan`1<byte> input32, Context context, ECXOnlyPubKey& pubkey);
    [NullableContextAttribute("1")]
public static bool TryCreate(FE& x, ECXOnlyPubKey& pubkey);
    [NullableContextAttribute("1")]
public static bool TryCreate(FE& x, Context context, ECXOnlyPubKey& pubkey);
    public static ECXOnlyPubKey Create(ReadOnlySpan`1<byte> input32);
    public static ECXOnlyPubKey Create(ReadOnlySpan`1<byte> input32, Context context);
    public bool SigVerifyBIP340(SecpSchnorrSignature signature, ReadOnlySpan`1<byte> msg32);
    public void WriteToSpan(Span`1<byte> output32);
    public bool CheckIsTweakedWith(ECXOnlyPubKey internalPubKey, ReadOnlySpan`1<byte> tweak32, bool expectedParity);
    public ECPubKey AddTweak(ReadOnlySpan`1<byte> tweak);
    public bool TryAddTweak(ReadOnlySpan`1<byte> tweak32, ECPubKey& tweakedPubKey);
    [NullableContextAttribute("1")]
public Byte[] ToBytes();
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(ECXOnlyPubKey other);
    public virtual int GetHashCode();
}
[IsReadOnlyAttribute]
internal class NBitcoin.Secp256k1.FE : ValueType {
    internal UInt32 n0;
    internal UInt32 n1;
    internal UInt32 n2;
    internal UInt32 n3;
    internal UInt32 n4;
    internal UInt32 n5;
    internal UInt32 n6;
    internal UInt32 n7;
    internal UInt32 n8;
    internal UInt32 n9;
    internal int magnitude;
    internal bool normalized;
    private static FE _Zero;
    internal static int NCount;
    [IsReadOnlyAttribute]
public static FE& modreq(System.Runtime.InteropServices.InAttribute) Zero { get; }
    public bool IsZero { get; }
    public bool IsOdd { get; }
    public bool IsQuadVariable { get; }
    public FE(UInt32 a);
    public FE(ReadOnlySpan`1<byte> in32);
    private FE(ReadOnlySpan`1<byte> in32, bool throws, Boolean& isValid);
    public FE(UInt32 n0, UInt32 n1, UInt32 n2, UInt32 n3, UInt32 n4, UInt32 n5, UInt32 n6, UInt32 n7, UInt32 n8, UInt32 n9);
    public FE(UInt32 n0, UInt32 n1, UInt32 n2, UInt32 n3, UInt32 n4, UInt32 n5, UInt32 n6, UInt32 n7, UInt32 n8, UInt32 n9, int magnitude, bool normalized);
    public FE(ReadOnlySpan`1<UInt32> n, int magnitude, bool normalized);
    private static FE();
    public static FE& modreq(System.Runtime.InteropServices.InAttribute) get_Zero();
    public static bool TryCreate(ReadOnlySpan`1<byte> bytes, FE& fieldElement);
    public static FE CONST(UInt32 d7, UInt32 d6, UInt32 d5, UInt32 d4, UInt32 d3, UInt32 d2, UInt32 d1, UInt32 d0);
    public bool NormalizesToZeroVariable();
    public bool EqualsXVariable(GEJ& a);
    public static void Clear(FE& s);
    public FE InverseVariable();
    public bool Sqrt(FE& result);
    public FEStorage ToStorage();
    public int CompareToVariable(FE& b);
    internal UInt32 At(int index);
    public FE Inverse();
    public FE Sqr();
    public FE Sqr(int times);
    [NullableContextAttribute("1")]
public static void InverseAllVariable(FE[] r, FE[] a, int len);
    private FE secp256k1_fe_sqr_inner(int times, int magnitude, bool normalized);
    [ConditionalAttribute("SECP256K1_VERIFY")]
private static void VERIFY_BITS(ulong x, int n);
    public FE Multiply(FE& b);
    public FE Multiply(UInt32 a);
    public FE Add(FE& a);
    private FE secp256k1_fe_mul_inner(FE& b, int magnitude, bool normalized);
    public static void CMov(FE& r, FE a, int flag);
    public void Deconstruct(Span`1<UInt32> n, Int32& magnitude, Boolean& normalized);
    public bool get_IsZero();
    public bool get_IsOdd();
    public bool get_IsQuadVariable();
    public FE Negate(int m);
    public FE NormalizeWeak();
    public static void NormalizeVariable(FE& fe);
    public FE NormalizeVariable();
    public FE Normalize();
    public void WriteToSpan(Span`1<byte> r);
    [ConditionalAttribute("SECP256K1_VERIFY")]
private void VERIFY();
    [ConditionalAttribute("SECP256K1_VERIFY")]
private static void VERIFY_CHECK(bool value);
    public sealed virtual bool Equals(FE b);
    public bool EqualsVariable(FE& b);
    public bool NormalizesToZero();
    public static bool op_Equality(FE& a, FE& b);
    public static bool op_Inequality(FE& a, FE& b);
    public static FE op_Multiply(FE& a, FE& b);
    public static FE op_Multiply(FE& a, UInt32& b);
    public static FE op_Addition(FE& a, FE& b);
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [NullableContextAttribute("1")]
public Byte[] ToBytes();
    [NullableContextAttribute("1")]
public string ToC(string varName);
}
[IsReadOnlyAttribute]
internal class NBitcoin.Secp256k1.FEStorage : ValueType {
    internal UInt32 n0;
    internal UInt32 n1;
    internal UInt32 n2;
    internal UInt32 n3;
    internal UInt32 n4;
    internal UInt32 n5;
    internal UInt32 n6;
    internal UInt32 n7;
    internal static int NCount;
    public FEStorage(UInt32 n0, UInt32 n1, UInt32 n2, UInt32 n3, UInt32 n4, UInt32 n5, UInt32 n6, UInt32 n7);
    public FEStorage(ReadOnlySpan`1<UInt32> n);
    public static FEStorage CONST(UInt32 d7, UInt32 d6, UInt32 d5, UInt32 d4, UInt32 d3, UInt32 d2, UInt32 d1, UInt32 d0);
    public void Deconstruct(UInt32& n0, UInt32& n1, UInt32& n2, UInt32& n3, UInt32& n4, UInt32& n5, UInt32& n6, UInt32& n7);
    public FE ToFieldElement();
    [ConditionalAttribute("SECP256K1_VERIFY")]
private static void VERIFY_CHECK(bool value);
    public static void CMov(FEStorage& r, FEStorage& a, int flag);
    public void Deconstruct(Span`1<UInt32> n);
}
[IsReadOnlyAttribute]
internal class NBitcoin.Secp256k1.GE : ValueType {
    public static byte SECP256K1_TAG_PUBKEY_EVEN;
    public static byte SECP256K1_TAG_PUBKEY_ODD;
    public static byte SECP256K1_TAG_PUBKEY_UNCOMPRESSED;
    public static byte SECP256K1_TAG_PUBKEY_HYBRID_EVEN;
    public static byte SECP256K1_TAG_PUBKEY_HYBRID_ODD;
    internal FE x;
    internal FE y;
    internal bool infinity;
    private static GE _Infinity;
    private static GE _Zero;
    private static int SIZE_MAX;
    private static FE beta;
    [IsReadOnlyAttribute]
public static GE& modreq(System.Runtime.InteropServices.InAttribute) Infinity { get; }
    public bool IsInfinity { get; }
    [IsReadOnlyAttribute]
public static GE& modreq(System.Runtime.InteropServices.InAttribute) Zero { get; }
    public bool IsValidVariable { get; }
    public GE(FE& x, FE& y, bool infinity);
    public GE(FE& x, FE& y);
    private static GE();
    public static GE& modreq(System.Runtime.InteropServices.InAttribute) get_Infinity();
    public static GE CONST(UInt32 a, UInt32 b, UInt32 c, UInt32 d, UInt32 e, UInt32 f, UInt32 g, UInt32 h, UInt32 i, UInt32 j, UInt32 k, UInt32 l, UInt32 m, UInt32 n, UInt32 o, UInt32 p);
    public bool get_IsInfinity();
    public static GE& modreq(System.Runtime.InteropServices.InAttribute) get_Zero();
    public bool get_IsValidVariable();
    public static void SetAllGroupElementJacobianVariable(Span`1<GE> r, ReadOnlySpan`1<GEJ> a, int len);
    [ConditionalAttribute("SECP256K1_VERIFY")]
private static void VERIFY_CHECK(bool value);
    public static bool TryCreateXQuad(FE x, GE& result);
    public static bool TryCreateXOVariable(FE x, bool odd, GE& result);
    public GE MultiplyLambda();
    public GE NormalizeVariable();
    public void Deconstruct(FE& x, FE& y, Boolean& infinity);
    public GE ZInv(GE& a, FE& zi);
    public GE NormalizeY();
    public GE NormalizeXVariable();
    public GE NormalizeYVariable();
    public GE Negate();
    public static bool TryParse(ReadOnlySpan`1<byte> pub, GE& elem);
    public static bool TryParse(ReadOnlySpan`1<byte> pub, Boolean& compressed, GE& elem);
    public GEJ ToGroupElementJacobian();
    public GE ToEvenY(Boolean& parity);
    public GE ToEvenY();
    [NullableContextAttribute("1")]
public string ToC(string varName);
    public GEStorage ToStorage();
    public static GEJ op_Multiply(GE& groupElement, Scalar& scalar);
    public GEJ MultConst(Scalar& q, int bits);
    public static void Clear(GE& groupElement);
    private GE ECMULT_CONST_TABLE_GET_GE(Span`1<GE> pre, int n, int w);
    private static int ECMULT_TABLE_SIZE(int w);
}
[IsReadOnlyAttribute]
internal class NBitcoin.Secp256k1.GEJ : ValueType {
    internal FE x;
    internal FE y;
    internal FE z;
    internal bool infinity;
    private static GEJ _Infinity;
    private static FE fe_1;
    [IsReadOnlyAttribute]
public static GEJ& modreq(System.Runtime.InteropServices.InAttribute) Infinity { get; }
    public bool IsInfinity { get; }
    public bool HasQuadYVariable { get; }
    public bool IsValidVariable { get; }
    public GEJ(FE& x, FE& y, FE& z, bool infinity);
    public GEJ(FE& x, FE& y, FE& z);
    private static GEJ();
    public static GEJ& modreq(System.Runtime.InteropServices.InAttribute) get_Infinity();
    public static GEJ CONST(UInt32 a, UInt32 b, UInt32 c, UInt32 d, UInt32 e, UInt32 f, UInt32 g, UInt32 h, UInt32 i, UInt32 j, UInt32 k, UInt32 l, UInt32 m, UInt32 n, UInt32 o, UInt32 p);
    public bool get_IsInfinity();
    public bool get_HasQuadYVariable();
    public GEJ AddVariable(GE& b);
    public GEJ AddVariable(GE& b, FE& rzr);
    public bool get_IsValidVariable();
    public GE ToGroupElementZInv(FE& zi);
    public GEJ Negate();
    public GEJ AddVariable(GEJ& b);
    public GEJ AddVariable(GEJ& b, FE& rzr);
    public GEJ AddZInvVariable(GE& b, FE& bzinv);
    public static void Clear(GEJ& groupElementJacobian);
    public GEJ DoubleVariable();
    public GEJ DoubleVariable(FE& rzr);
    [ConditionalAttribute("SECP256K1_VERIFY")]
private static void VERIFY_CHECK(bool value);
    public GEJ Double();
    public GE ToGroupElementVariable();
    public GE ToGroupElement();
    public GEJ Add(GE& b);
    public GEJ Rescale(FE& s);
    public static GEJ op_Addition(GEJ& a, GE& b);
    public void Deconstruct(FE& x, FE& y, FE& z, Boolean& infinity);
    [NullableContextAttribute("1")]
public string ToC(string varName);
}
[IsReadOnlyAttribute]
internal class NBitcoin.Secp256k1.GEStorage : ValueType {
    internal FEStorage x;
    internal FEStorage y;
    public GEStorage(FE& x, FE& y);
    public GEStorage(FEStorage& x, FEStorage& y);
    public static GEStorage CONST(UInt32 a, UInt32 b, UInt32 c, UInt32 d, UInt32 e, UInt32 f, UInt32 g, UInt32 h, UInt32 i, UInt32 j, UInt32 k, UInt32 l, UInt32 m, UInt32 n, UInt32 o, UInt32 p);
    public GE ToGroupElement();
    public void Deconstruct(FEStorage& x, FEStorage& y);
    public static void CMov(GEStorage& r, GEStorage& a, int flag);
}
public class NBitcoin.Secp256k1.HMACSHA256 : object {
    [NullableAttribute("2")]
private SHA256 inner;
    [NullableAttribute("2")]
private SHA256 outer;
    public HMACSHA256(ReadOnlySpan`1<byte> key);
    public void Initialize(ReadOnlySpan`1<byte> key);
    public void Write32(ReadOnlySpan`1<byte> data);
    public void Finalize(Span`1<byte> output);
    public sealed virtual void Dispose();
}
internal interface NBitcoin.Secp256k1.INonceFunction {
    public abstract virtual bool TryGetNonce(Span`1<byte> nonce32, ReadOnlySpan`1<byte> msg32, ReadOnlySpan`1<byte> key32, ReadOnlySpan`1<byte> algo16, UInt32 counter);
}
internal interface NBitcoin.Secp256k1.INonceFunctionHardened {
    public abstract virtual bool TryGetNonce(Span`1<byte> nonce32, ReadOnlySpan`1<byte> msg32, ReadOnlySpan`1<byte> key32, ReadOnlySpan`1<byte> xonly_pk32, ReadOnlySpan`1<byte> algo);
}
internal class NBitcoin.Secp256k1.MultBatchOptions : object {
    [CompilerGeneratedAttribute]
private int <PippengerThreshold>k__BackingField;
    [CompilerGeneratedAttribute]
private ECMultiImplementation <Implementation>k__BackingField;
    public int PippengerThreshold { get; public set; }
    public ECMultiImplementation Implementation { get; public set; }
    public MultBatchOptions(ECMultiImplementation implementation);
    [CompilerGeneratedAttribute]
public int get_PippengerThreshold();
    [CompilerGeneratedAttribute]
public void set_PippengerThreshold(int value);
    [CompilerGeneratedAttribute]
public ECMultiImplementation get_Implementation();
    [CompilerGeneratedAttribute]
public void set_Implementation(ECMultiImplementation value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NBitcoin.Secp256k1.Musig.MusigContext : object {
    internal Byte[] pk_hash;
    internal FE second_pk_x;
    internal bool pk_parity;
    internal Scalar scalar_tweak;
    internal Byte[] msg32;
    internal Scalar gacc;
    internal bool processed_nonce;
    [NullableAttribute("2")]
internal SessionValues SessionCache;
    [NullableAttribute("2")]
private MusigPubNonce aggregateNonce;
    private ECPubKey aggregatePubKey;
    private Context ctx;
    [NullableAttribute("2")]
private ECPubKey adaptor;
    private Scalar tacc;
    [NullableAttribute("2")]
public MusigPubNonce AggregateNonce { get; }
    public ECPubKey AggregatePubKey { get; }
    public MusigContext(MusigContext musigContext);
    [NullableContextAttribute("0")]
public MusigContext(ECPubKey[] pubKeys, ReadOnlySpan`1<byte> msg32, ECPubKey signingPubKey);
    [NullableContextAttribute("2")]
public MusigPubNonce get_AggregateNonce();
    public ECPubKey get_AggregatePubKey();
    public MusigContext Clone();
    [NullableContextAttribute("0")]
public ECPubKey Tweak(ReadOnlySpan`1<byte> tweak32);
    [NullableContextAttribute("0")]
public ECPubKey Tweak(ReadOnlySpan`1<byte> tweak32, bool xOnly);
    public void UseAdaptor(ECPubKey adaptor);
    public void ProcessNonces(MusigPubNonce[] nonces);
    public void Process(MusigPubNonce aggregatedNonce);
    [NullableContextAttribute("0")]
internal static void secp256k1_musig_nonce_process_internal(ECMultContext ecmult_ctx, GE& r, Scalar& b, Span`1<GEJ> aggnoncej, ReadOnlySpan`1<byte> qbytes, ReadOnlySpan`1<byte> msg);
    [NullableContextAttribute("0")]
internal static void secp256k1_musig_compute_noncehash(Span`1<byte> noncehash, Span`1<GE> aggnonce, ReadOnlySpan`1<byte> agg_pk32, ReadOnlySpan`1<byte> msg);
    public bool Verify(ECPubKey pubKey, MusigPubNonce pubNonce, MusigPartialSignature partialSignature);
    public SecpSchnorrSignature AggregateSignatures(MusigPartialSignature[] partialSignatures);
    public ValueTuple`2<MusigPartialSignature, MusigPubNonce> DeterministicSign(ECPrivKey privKey);
    public ValueTuple`2<MusigPartialSignature, MusigPubNonce> DeterministicSign(ECPrivKey privKey, Byte[] rand);
    private Scalar det_nonce_hash(Byte[] sk_, MusigPubNonce aggothernonce, ECPubKey aggregatePubKey, ReadOnlySpan`1<byte> msg, int i);
    private Byte[] xor32(Byte[] a, Byte[] b);
    private Byte[] tagged_hash(string tag, Byte[] b);
    public MusigPartialSignature Sign(ECPrivKey privKey, MusigPrivNonce privNonce);
    public SecpSchnorrSignature Adapt(SecpSchnorrSignature signature, ECPrivKey adaptorSecret);
    public ECPrivKey Extract(SecpSchnorrSignature signature, MusigPartialSignature[] partialSignatures);
    public MusigPrivNonce GenerateNonce(ECPubKey signingPubKey);
    public MusigPrivNonce GenerateNonce(ECPubKey signingPubKey, Byte[] sessionId);
    public MusigPrivNonce GenerateNonce(ulong counter, ECPrivKey signingKey);
    public MusigPrivNonce GenerateNonce(ECPubKey signingPubKey, Byte[] sessionId, ECPrivKey signingKey);
    [NullableContextAttribute("2")]
public MusigPrivNonce GenerateNonce(ECPubKey signingPubKey, Byte[] sessionId, ECPrivKey signingKey, Byte[] extraInput);
}
internal class NBitcoin.Secp256k1.Musig.MusigPartialSignature : object {
    internal Scalar E;
    public MusigPartialSignature(Scalar e);
    public MusigPartialSignature(ReadOnlySpan`1<byte> in32);
    public void WriteToSpan(Span`1<byte> in32);
    [NullableContextAttribute("1")]
public Byte[] ToBytes();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NBitcoin.Secp256k1.Musig.MusigPrivNonce : object {
    private static RandomNumberGenerator rand;
    private static Byte[] empty_msg_prefixed;
    private ECPrivKey k1;
    private ECPrivKey k2;
    private ECPubKey pk;
    private bool _IsUsed;
    public ECPrivKey K1 { get; }
    public ECPrivKey K2 { get; }
    public ECPubKey PK { get; }
    public bool IsUsed { get; internal set; }
    internal MusigPrivNonce(ECPrivKey k1, ECPrivKey k2, ECPubKey pk);
    private static MusigPrivNonce();
    [NullableContextAttribute("2")]
public static MusigPrivNonce GenerateMusigNonce(ECPubKey signingPubKey, Context context, Byte[] sessionId, ECPrivKey signingKey, Byte[] msg, ECXOnlyPubKey aggregatePubKey, Byte[] extraInput);
    [NullableContextAttribute("2")]
internal static void secp256k1_nonce_function_musig(Byte[] rand_, Byte[] key32, ReadOnlySpan`1<byte> pk33, Byte[] agg_pk32, Byte[] msg, Byte[] extra_input, Span`1<Scalar> k);
    [NullableContextAttribute("0")]
internal static void ToBE(Span`1<byte> output, long v);
    [NullableContextAttribute("0")]
internal static void secp256k1_nonce_function_musig(Span`1<Scalar> k, ReadOnlySpan`1<byte> rand, ReadOnlySpan`1<byte> msg_prefixed, ReadOnlySpan`1<byte> pk, Byte[] agg_pk, ReadOnlySpan`1<byte> extra_input, int i);
    public ECPrivKey get_K1();
    public ECPrivKey get_K2();
    public ECPubKey get_PK();
    public bool get_IsUsed();
    internal void set_IsUsed(bool value);
    public sealed virtual void Dispose();
    public MusigPubNonce CreatePubNonce();
}
internal class NBitcoin.Secp256k1.Musig.MusigPubNonce : object {
    internal GE K1;
    internal GE K2;
    [NullableContextAttribute("1")]
internal MusigPubNonce(ECPubKey k1, ECPubKey k2);
    internal MusigPubNonce(GE k1, GE k2);
    public MusigPubNonce(ReadOnlySpan`1<byte> in66);
    [NullableContextAttribute("1")]
public static MusigPubNonce Aggregate(MusigPubNonce[] nonces);
    private bool TryParseGE(ReadOnlySpan`1<byte> pub, GE& ge);
    public void WriteToSpan(Span`1<byte> out66);
    [NullableContextAttribute("1")]
public Byte[] ToBytes();
}
internal class NBitcoin.Secp256k1.Musig.SessionValues : object {
    internal Scalar b;
    internal Scalar e;
    internal GE r;
    [NullableContextAttribute("1")]
internal SessionValues Clone();
}
internal class NBitcoin.Secp256k1.PippengerPointState : ValueType {
    internal int skew_na;
    internal int input_pos;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NBitcoin.Secp256k1.PippengerState : ValueType {
    internal Int32[] wnaf_na;
    internal PippengerPointState[] ps;
    public PippengerState(int entries, int wnaf_size);
    public void Dispose();
}
internal class NBitcoin.Secp256k1.PrecomputedNonceFunction : object {
    [NullableAttribute("1")]
private Byte[] nonce;
    [NullableContextAttribute("1")]
public PrecomputedNonceFunction(Byte[] nonce);
    public sealed virtual bool TryGetNonce(Span`1<byte> nonce32, ReadOnlySpan`1<byte> msg32, ReadOnlySpan`1<byte> key32, ReadOnlySpan`1<byte> algo16, UInt32 counter);
}
internal class NBitcoin.Secp256k1.RFC6979HMACSHA256 : object {
    [NullableAttribute("2")]
private Byte[] v;
    [NullableAttribute("2")]
private Byte[] k;
    private bool retry;
    public void Initialize(ReadOnlySpan`1<byte> key);
    public void Generate(Span`1<byte> output);
    public sealed virtual void Dispose();
}
internal class NBitcoin.Secp256k1.RFC6979NonceFunction : object {
    [NullableAttribute("2")]
private Byte[] data;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private static RFC6979NonceFunction <Instance>k__BackingField;
    [NullableAttribute("1")]
public static RFC6979NonceFunction Instance { get; }
    [NullableContextAttribute("2")]
public RFC6979NonceFunction(Byte[] nonceData);
    private static RFC6979NonceFunction();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public static RFC6979NonceFunction get_Instance();
    public sealed virtual bool TryGetNonce(Span`1<byte> nonce32, ReadOnlySpan`1<byte> msg32, ReadOnlySpan`1<byte> key32, ReadOnlySpan`1<byte> algo16, UInt32 counter);
}
[IsReadOnlyAttribute]
internal class NBitcoin.Secp256k1.Scalar : ValueType {
    private static Scalar _Zero;
    private static Scalar _One;
    private static Scalar _MinusOne;
    internal static UInt32 SECP256K1_N_0;
    internal static UInt32 SECP256K1_N_1;
    internal static UInt32 SECP256K1_N_2;
    internal static UInt32 SECP256K1_N_3;
    internal static UInt32 SECP256K1_N_4;
    internal static UInt32 SECP256K1_N_5;
    internal static UInt32 SECP256K1_N_6;
    internal static UInt32 SECP256K1_N_7;
    internal static UInt32 SECP256K1_N_C_0;
    internal static UInt32 SECP256K1_N_C_1;
    internal static UInt32 SECP256K1_N_C_2;
    internal static UInt32 SECP256K1_N_C_3;
    internal static UInt32 SECP256K1_N_C_4;
    internal static UInt32 SECP256K1_N_H_0;
    internal static UInt32 SECP256K1_N_H_1;
    internal static UInt32 SECP256K1_N_H_2;
    internal static UInt32 SECP256K1_N_H_3;
    internal static UInt32 SECP256K1_N_H_4;
    internal static UInt32 SECP256K1_N_H_5;
    internal static UInt32 SECP256K1_N_H_6;
    internal static UInt32 SECP256K1_N_H_7;
    internal UInt32 d0;
    internal UInt32 d1;
    internal UInt32 d2;
    internal UInt32 d3;
    internal UInt32 d4;
    internal UInt32 d5;
    internal UInt32 d6;
    internal UInt32 d7;
    private static ulong M;
    private static Scalar minus_lambda;
    private static Scalar minus_b1;
    private static Scalar minus_b2;
    private static Scalar g1;
    private static Scalar g2;
    private static int DCount;
    [IsReadOnlyAttribute]
public static Scalar& modreq(System.Runtime.InteropServices.InAttribute) Zero { get; }
    [IsReadOnlyAttribute]
public static Scalar& modreq(System.Runtime.InteropServices.InAttribute) One { get; }
    [IsReadOnlyAttribute]
public static Scalar& modreq(System.Runtime.InteropServices.InAttribute) MinusOne { get; }
    public bool IsOverflow { get; }
    public bool IsEven { get; }
    public bool IsHigh { get; }
    public bool IsZero { get; }
    public bool IsOne { get; }
    public Scalar(UInt32 d0, UInt32 d1, UInt32 d2, UInt32 d3, UInt32 d4, UInt32 d5, UInt32 d6, UInt32 d7);
    public Scalar(Span`1<UInt32> d);
    internal Scalar(UInt32 value);
    internal Scalar(ulong value);
    internal Scalar(ReadOnlySpan`1<byte> b32);
    internal Scalar(ReadOnlySpan`1<byte> b32, Int32& overflow);
    private static Scalar();
    public static Scalar& modreq(System.Runtime.InteropServices.InAttribute) get_Zero();
    public static Scalar& modreq(System.Runtime.InteropServices.InAttribute) get_One();
    public static Scalar& modreq(System.Runtime.InteropServices.InAttribute) get_MinusOne();
    public static void CMov(Scalar& r, Scalar a, int flag);
    public static void Clear(Scalar& s);
    internal Scalar CAddBit(UInt32 bit, int flag);
    private static int Reduce(Span`1<UInt32> d, int overflow);
    private static void reduce_512(Span`1<UInt32> d, Span`1<UInt32> l);
    internal int CondNegate(int flag, Scalar& r);
    private static void mul_512(Span`1<UInt32> l, Scalar& a, Scalar& b);
    internal static void sqr_512(Span`1<UInt32> l, Span`1<UInt32> a);
    public Scalar Add(Scalar& b);
    public Scalar Add(Scalar& b, Int32& overflow);
    private static void extract(Span`1<UInt32> acc, UInt32& n);
    [ConditionalAttribute("SECP256K1_VERIFY")]
private static void VERIFY_CHECK(bool value);
    public bool get_IsOverflow();
    internal int CheckOverflow();
    private static int CheckOverflow(Span`1<UInt32> d);
    public void WriteToSpan(Span`1<byte> bin);
    internal UInt32 GetBits(int offset, int count);
    internal UInt32 GetBitsVariable(int offset, int count);
    internal UInt32 At(int index);
    public void Split128(Scalar& r1, Scalar& r2);
    public static Scalar CONST(UInt32 d7, UInt32 d6, UInt32 d5, UInt32 d4, UInt32 d3, UInt32 d2, UInt32 d1, UInt32 d0);
    public bool get_IsEven();
    public bool get_IsHigh();
    public void SplitLambda(Scalar& r1, Scalar& r2);
    public Scalar MultiplyShiftVariable(Scalar& b, int shift);
    public bool get_IsZero();
    public bool get_IsOne();
    public Scalar Sqr();
    public Scalar Sqr(int times);
    public Scalar Inverse();
    public static Scalar op_Multiply(Scalar& a, Scalar& b);
    public Scalar Multiply(Scalar& b);
    public int ShrInt(int n, Scalar& ret);
    public Scalar Negate();
    public static GEJ op_Multiply(Scalar& scalar, GE& groupElement);
    public sealed virtual bool Equals(Scalar b);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public static bool op_Equality(Scalar& a, Scalar& b);
    public static bool op_Inequality(Scalar& a, Scalar& b);
    public static Scalar op_Addition(Scalar& a, Scalar& b);
    public void Deconstruct(Span`1<UInt32> d);
    public virtual int GetHashCode();
    public Scalar InverseVariable();
    [NullableContextAttribute("1")]
public string ToC(string varname);
    [NullableContextAttribute("1")]
public Byte[] ToBytes();
}
internal class NBitcoin.Secp256k1.SchnorrEncryptedSignature : object {
    public GE R;
    public Scalar s_hat;
    public bool need_negation;
    public SchnorrEncryptedSignature(GE R, Scalar s_hat, bool need_negation);
    [NullableContextAttribute("1")]
public bool TryRecoverDecryptionKey(SecpSchnorrSignature signature, ECPubKey encryptionKey, ECPrivKey& decryptionKey);
}
internal class NBitcoin.Secp256k1.SecpECDSASignature : object {
    public Scalar r;
    public Scalar s;
    public static int MaxLength;
    public SecpECDSASignature(Scalar& r, Scalar& s, bool enforceCheck);
    [ConditionalAttribute("SECP256K1_VERIFY")]
private static void VERIFY_CHECK(bool value);
    [NullableContextAttribute("1")]
public Byte[] ToDER();
    [NullableContextAttribute("1")]
public bool TryNormalize(SecpECDSASignature& normalized);
    private static int DerReadLen(ReadOnlySpan`1& sig);
    private static bool DerParseInteger(Scalar& r, ReadOnlySpan`1& sig);
    public static bool TryCreateFromDer(ReadOnlySpan`1<byte> sig, SecpECDSASignature& output);
    public static bool TryCreateFromCompact(ReadOnlySpan`1<byte> in64, SecpECDSASignature& output);
    public bool WriteDerToSpan(Span`1<byte> sig, Int32& size);
    public void WriteCompactToSpan(Span`1<byte> out64);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
public static bool op_Equality(SecpECDSASignature a, SecpECDSASignature b);
    [NullableContextAttribute("2")]
public static bool op_Inequality(SecpECDSASignature a, SecpECDSASignature b);
    public virtual int GetHashCode();
    public void Deconstruct(Scalar& r, Scalar& s);
}
internal class NBitcoin.Secp256k1.SecpRecoverableECDSASignature : object {
    private Scalar r;
    private Scalar s;
    private int recid;
    [NullableContextAttribute("1")]
public SecpRecoverableECDSASignature(SecpECDSASignature sig, int recid);
    private static bool IsValidRecId(int recid);
    public static bool TryCreateFromCompact(ReadOnlySpan`1<byte> in64, int recid, SecpRecoverableECDSASignature& sig);
    public void Deconstruct(Scalar& r, Scalar& s, Int32& recid);
    public void WriteToSpanCompact(Span`1<byte> out64, Int32& recid);
    [NullableContextAttribute("1")]
public SecpECDSASignature ToSignature();
}
internal class NBitcoin.Secp256k1.SecpSchnorrSignature : object {
    public FE rx;
    public Scalar s;
    internal SecpSchnorrSignature(FE& rx, Scalar& s);
    public static bool TryCreate(ReadOnlySpan`1<byte> in64, SecpSchnorrSignature& signature);
    [NullableContextAttribute("1")]
public static bool TryCreate(FE& rx, Scalar& s, SecpSchnorrSignature& signature);
    public void WriteToSpan(Span`1<byte> out64);
    [NullableContextAttribute("1")]
public Byte[] ToBytes();
}
internal class NBitcoin.Secp256k1.SHA256 : object {
    [NullableAttribute("1")]
private SHA256 sha;
    private int _Pos;
    [NullableAttribute("1")]
private Byte[] _Buffer;
    public void Initialize();
    public void InitializeTagged(ReadOnlySpan`1<byte> tag);
    [NullableContextAttribute("1")]
public void InitializeTagged(string tag);
    public void Write(ReadOnlySpan`1<byte> buffer);
    public void Write(byte b);
    private bool ProcessBlockIfNeeded();
    private void ProcessBlock();
    [NullableContextAttribute("1")]
public Byte[] GetHash();
    public void GetHash(Span`1<byte> output);
    public sealed virtual void Dispose();
}
internal class NBitcoin.Secp256k1.StraussPointState : ValueType {
    internal Scalar na_1;
    internal Scalar na_lam;
    [FixedBufferAttribute("System.Int32", "130")]
internal <wnaf_na_1>e__FixedBuffer wnaf_na_1;
    [FixedBufferAttribute("System.Int32", "130")]
internal <wnaf_na_lam>e__FixedBuffer wnaf_na_lam;
    internal int bits_na_1;
    internal int bits_na_lam;
    internal int input_pos;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NBitcoin.Secp256k1.StraussState : ValueType {
    internal GEJ[] prej;
    internal FE[] zr;
    internal GE[] pre_a;
    internal GE[] pre_a_lam;
    internal StraussPointState[] ps;
    public StraussState(int size, int pointStates);
    internal void Dispose();
}
internal static class NBitcoin.Secp256k1.Wnaf : object {
    public static int BITS;
    public static int Const(Span`1<int> wnaf, Scalar s, int w, int size);
    internal static int Fixed(Span`1<int> wnaf, Scalar& s, int w);
    internal static int SIZE(int w);
    internal static int SIZE_BITS(int bits, int w);
    [ConditionalAttribute("SECP256K1_VERIFY")]
private static void VERIFY_CHECK(bool value);
}
public class NBitcoin.Sequence : ValueType {
    public static UInt32 SEQUENCE_LOCKTIME_DISABLE_FLAG;
    public static UInt32 SEQUENCE_LOCKTIME_TYPE_FLAG;
    public static UInt32 SEQUENCE_LOCKTIME_MASK;
    public static UInt32 SEQUENCE_FINAL;
    public static UInt32 MAX_BIP125_RBF_SEQUENCE;
    internal static int SEQUENCE_LOCKTIME_GRANULARITY;
    private UInt32 _ValueInv;
    public static Sequence Final { get; }
    public static Sequence OptInRBF { get; }
    public static Sequence FeeSnipping { get; }
    public UInt32 Value { get; }
    public bool IsRelativeLock { get; }
    public bool IsRBF { get; }
    public SequenceLockType LockType { get; }
    public int LockHeight { get; }
    public TimeSpan LockPeriod { get; }
    public Sequence(UInt32 value);
    public Sequence(int lockHeight);
    public Sequence(TimeSpan period);
    public static Sequence get_Final();
    public static Sequence get_OptInRBF();
    public static Sequence get_FeeSnipping();
    public UInt32 get_Value();
    public bool get_IsRelativeLock();
    public bool get_IsRBF();
    public SequenceLockType get_LockType();
    public static UInt32 op_Implicit(Sequence a);
    public static Sequence op_Implicit(UInt32 a);
    private void AssertRelativeLock();
    public virtual string ToString();
    public int get_LockHeight();
    public TimeSpan get_LockPeriod();
}
public class NBitcoin.SequenceLock : object {
    [CompilerGeneratedAttribute]
private int <MinHeight>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <MinTime>k__BackingField;
    public int MinHeight { get; public set; }
    public DateTimeOffset MinTime { get; public set; }
    public SequenceLock(int minHeight, DateTimeOffset minTime);
    public SequenceLock(int minHeight, long minTime);
    [CompilerGeneratedAttribute]
public int get_MinHeight();
    [CompilerGeneratedAttribute]
public void set_MinHeight(int value);
    [CompilerGeneratedAttribute]
public DateTimeOffset get_MinTime();
    [CompilerGeneratedAttribute]
public void set_MinTime(DateTimeOffset value);
    public bool Evaluate(ChainedBlock block);
}
public enum NBitcoin.SequenceLockType : Enum {
    public int value__;
    public static SequenceLockType Time;
    public static SequenceLockType Height;
}
public enum NBitcoin.SerializationType : Enum {
    public int value__;
    public static SerializationType Disk;
    public static SerializationType Network;
    public static SerializationType Hash;
}
[FlagsAttribute]
public enum NBitcoin.SigHash : Enum {
    public UInt32 value__;
    public static SigHash All;
    public static SigHash None;
    public static SigHash Single;
    public static SigHash AnyoneCanPay;
}
public class NBitcoin.SignedHash : object {
    [CompilerGeneratedAttribute]
private ITransactionSignature <Signature>k__BackingField;
    [CompilerGeneratedAttribute]
private Script <ScriptCode>k__BackingField;
    [CompilerGeneratedAttribute]
private HashVersion <HashVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private uint256 <Hash>k__BackingField;
    public ITransactionSignature Signature { get; internal set; }
    public Script ScriptCode { get; internal set; }
    public HashVersion HashVersion { get; internal set; }
    public uint256 Hash { get; internal set; }
    [CompilerGeneratedAttribute]
public ITransactionSignature get_Signature();
    [CompilerGeneratedAttribute]
internal void set_Signature(ITransactionSignature value);
    [CompilerGeneratedAttribute]
public Script get_ScriptCode();
    [CompilerGeneratedAttribute]
internal void set_ScriptCode(Script value);
    [CompilerGeneratedAttribute]
public HashVersion get_HashVersion();
    [CompilerGeneratedAttribute]
internal void set_HashVersion(HashVersion value);
    [CompilerGeneratedAttribute]
public uint256 get_Hash();
    [CompilerGeneratedAttribute]
internal void set_Hash(uint256 value);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class NBitcoin.SigningOptions : object {
    [CompilerGeneratedAttribute]
private SigHash <SigHash>k__BackingField;
    [CompilerGeneratedAttribute]
private TaprootSigHash <TaprootSigHash>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EnforceLowR>k__BackingField;
    [CompilerGeneratedAttribute]
private PrecomputedTransactionData <PrecomputedTransactionData>k__BackingField;
    public SigHash SigHash { get; public set; }
    public TaprootSigHash TaprootSigHash { get; public set; }
    public bool EnforceLowR { get; public set; }
    public PrecomputedTransactionData PrecomputedTransactionData { get; public set; }
    public SigningOptions(SigHash sigHash);
    [NullableContextAttribute("1")]
public SigningOptions(TaprootSigHash sigHash, TaprootReadyPrecomputedTransactionData precomputedTransactionData);
    public SigningOptions(SigHash sigHash, bool useLowR);
    [CompilerGeneratedAttribute]
public SigHash get_SigHash();
    [CompilerGeneratedAttribute]
public void set_SigHash(SigHash value);
    [CompilerGeneratedAttribute]
public TaprootSigHash get_TaprootSigHash();
    [CompilerGeneratedAttribute]
public void set_TaprootSigHash(TaprootSigHash value);
    [CompilerGeneratedAttribute]
public bool get_EnforceLowR();
    [CompilerGeneratedAttribute]
public void set_EnforceLowR(bool value);
    [CompilerGeneratedAttribute]
public PrecomputedTransactionData get_PrecomputedTransactionData();
    [CompilerGeneratedAttribute]
public void set_PrecomputedTransactionData(PrecomputedTransactionData value);
    [NullableContextAttribute("1")]
public SigningOptions Clone();
}
public class NBitcoin.SlimChain : object {
    private Dictionary`2<uint256, int> _HeightsByBlockHash;
    private uint256[] _BlockHashesByHeight;
    private int _Height;
    private ReaderWriterLock _lock;
    public int Height { get; }
    public uint256 Tip { get; }
    public SlimChainedBlock TipBlock { get; }
    public uint256 Genesis { get; }
    public SlimChain(uint256 genesis);
    public SlimChain(uint256 genesis, int capacity);
    public int get_Height();
    public bool Contains(uint256 blockHash);
    public bool TryGetHeight(uint256 blockHash, Int32& height);
    public bool TryGetHash(int height, uint256& blockHash);
    public void ResetToGenesis();
    public void SetCapacity(int capacity);
    public bool TrySetTip(uint256 newTip, uint256 previous, bool nopIfContainsTip);
    private bool TrySetTipNoLock(uint256& newTip, uint256& previous, bool nopIfContainsTip);
    public BlockLocator GetTipLocator();
    public BlockLocator GetLocator(int height);
    public BlockLocator GetLocator(uint256 blockHash);
    private BlockLocator GetLocatorNoLock(int height);
    public SlimChainedBlock FindFork(BlockLocator blockLocator);
    public uint256 get_Tip();
    public SlimChainedBlock get_TipBlock();
    public SlimChainedBlock GetBlock(int height);
    public SlimChainedBlock GetBlock(uint256 blockHash);
    private SlimChainedBlock CreateSlimBlock(int height);
    public uint256 get_Genesis();
    public void Save(Stream output);
    public void Load(Stream input);
    public virtual string ToString();
}
public class NBitcoin.SlimChainedBlock : object {
    private uint256 _Hash;
    private uint256 _Previous;
    private int _Height;
    public uint256 Hash { get; }
    public uint256 Previous { get; }
    public int Height { get; }
    public SlimChainedBlock(uint256 hash, uint256 prev, int height);
    public uint256 get_Hash();
    public uint256 get_Previous();
    public int get_Height();
    public virtual string ToString();
}
public enum NBitcoin.Socks.SocksErrorCode : Enum {
    public int value__;
    public static SocksErrorCode Success;
    public static SocksErrorCode GeneralServerFailure;
    public static SocksErrorCode ConnectionNotAllowed;
    public static SocksErrorCode NetworkUnreachable;
    public static SocksErrorCode HostUnreachable;
    public static SocksErrorCode ConnectionRefused;
    public static SocksErrorCode TTLExpired;
    public static SocksErrorCode CommandNotSupported;
    public static SocksErrorCode AddressTypeNotSupported;
}
public class NBitcoin.Socks.SocksException : Exception {
    [CompilerGeneratedAttribute]
private SocksErrorCode <SocksErrorCode>k__BackingField;
    public bool IsTransient { get; }
    public SocksErrorCode SocksErrorCode { get; public set; }
    public SocksException(SocksErrorCode errorCode);
    public SocksException(string message);
    public bool get_IsTransient();
    [CompilerGeneratedAttribute]
public SocksErrorCode get_SocksErrorCode();
    [CompilerGeneratedAttribute]
public void set_SocksErrorCode(SocksErrorCode value);
    private static string GetMessageForCode(int errorCode);
}
public class NBitcoin.Socks.SocksHelper : object {
    private static Byte[] SelectionMessageNoAuthenticationRequired;
    private static Byte[] SelectionMessageUsernamePassword;
    private static Encoding NoBOMUTF8;
    private static SocksHelper();
    internal static Byte[] CreateConnectMessage(EndPoint endpoint);
    public static Task Handshake(Socket socket, EndPoint endpoint, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NBitcoin.Socks.SocksHelper/<Handshake>d__5")]
public static Task Handshake(Socket socket, NetworkCredential credentials, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NBitcoin.Socks.SocksHelper/<Handshake>d__6")]
public static Task Handshake(Socket socket, EndPoint endpoint, NetworkCredential credentials, CancellationToken cancellationToken);
}
public static class NBitcoin.StandardScripts : object {
    private static ScriptTemplate[] _StandardTemplates;
    private static StandardScripts();
    public static bool IsStandardTransaction(Transaction tx);
    public static bool AreOutputsStandard(Transaction tx);
    public static ScriptTemplate GetTemplateFromScriptPubKey(Script script);
    public static bool IsStandardScriptPubKey(Script scriptPubKey);
    private static bool IsStandardScriptSig(Script scriptSig, Script scriptPubKey);
}
[ExtensionAttribute]
internal static class NBitcoin.StreamExtensions : object {
    [AsyncStateMachineAttribute("NBitcoin.StreamExtensions/<ReadCancellableAsync>d__0")]
[ExtensionAttribute]
public static Task ReadCancellableAsync(NetworkStream stream, Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NBitcoin.StreamExtensions/<WriteCancellableAsync>d__1")]
[ExtensionAttribute]
public static Task WriteCancellableAsync(NetworkStream stream, Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NBitcoin.StreamExtensions/<FlushCancellableAsync>d__2")]
[ExtensionAttribute]
public static Task FlushCancellableAsync(NetworkStream stream, CancellationToken cancellationToken);
}
public enum NBitcoin.TapLeafVersion : Enum {
    public byte value__;
    public static TapLeafVersion C0;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NBitcoin.TaprootAddress : BitcoinAddress {
    private TaprootPubKey _PubKey;
    public TaprootPubKey PubKey { get; }
    public Bech32Type Type { get; }
    internal TaprootAddress(string str, TaprootPubKey key, Network network);
    internal TaprootAddress(string str, Byte[] key, Network network);
    public TaprootAddress(TaprootPubKey pubKey, Network network);
    public static TaprootAddress Create(string bech32, Network expectedNetwork);
    [NullableContextAttribute("2")]
private static string NotNull(TaprootPubKey pubKey);
    public TaprootPubKey get_PubKey();
    protected virtual Script GeneratePaymentScript();
    public sealed virtual Bech32Type get_Type();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NBitcoin.TaprootBuilder : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private List`1<TaprootNodeInfo> <Branch>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal List`1<TaprootNodeInfo> Branch { get; }
    public bool IsFinalizable { get; }
    public bool HasHiddenNodes { get; }
    [CompilerGeneratedAttribute]
internal List`1<TaprootNodeInfo> get_Branch();
    public static TaprootBuilder WithHuffmanTree(ValueTuple`2[] scriptWeights);
    public TaprootBuilder AddLeaf(UInt32 depth, TapScript script);
    public TaprootBuilder AddHiddenNode(UInt32 depth, uint256 hash);
    public bool get_IsFinalizable();
    public bool get_HasHiddenNodes();
    public TaprootSpendInfo Finalize(TaprootInternalPubKey internalPubKey);
    private TaprootBuilder Insert(TaprootNodeInfo node, UInt32 depth);
}
public static class NBitcoin.TaprootConstants : object {
    internal static long VALIDATION_WEIGHT_OFFSET;
    internal static int TAPROOT_CONTROL_BASE_SIZE;
    internal static int TAPROOT_CONTROL_NODE_SIZE;
    internal static int TAPROOT_CONTROL_MAX_NODE_COUNT;
    internal static int TAPROOT_CONTROL_MAX_SIZE;
    internal static UInt32 TAPROOT_LEAF_MASK;
    internal static UInt32 TAPROOT_LEAF_ANNEX;
    public static UInt32 TAPROOT_LEAF_TAPSCRIPT;
    private static TaprootConstants();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class NBitcoin.TaprootExecutionData : object {
    [CompilerGeneratedAttribute]
private int <InputIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private uint256 <AnnexHash>k__BackingField;
    private TaprootSigHash _SigHash;
    [CompilerGeneratedAttribute]
private HashVersion <HashVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private uint256 <TapleafHash>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <CodeseparatorPosition>k__BackingField;
    public int InputIndex { get; public set; }
    public uint256 AnnexHash { get; public set; }
    public TaprootSigHash SigHash { get; public set; }
    public HashVersion HashVersion { get; }
    public uint256 TapleafHash { get; }
    public UInt32 CodeseparatorPosition { get; public set; }
    public TaprootExecutionData(int inputIndex);
    public TaprootExecutionData(int inputIndex, uint256 tapleaf);
    [CompilerGeneratedAttribute]
public int get_InputIndex();
    [CompilerGeneratedAttribute]
public void set_InputIndex(int value);
    [CompilerGeneratedAttribute]
public uint256 get_AnnexHash();
    [CompilerGeneratedAttribute]
public void set_AnnexHash(uint256 value);
    public static bool IsValidSigHash(byte value);
    public TaprootSigHash get_SigHash();
    public void set_SigHash(TaprootSigHash value);
    [CompilerGeneratedAttribute]
public HashVersion get_HashVersion();
    [CompilerGeneratedAttribute]
public uint256 get_TapleafHash();
    [CompilerGeneratedAttribute]
public UInt32 get_CodeseparatorPosition();
    [CompilerGeneratedAttribute]
public void set_CodeseparatorPosition(UInt32 value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NBitcoin.TaprootFullPubKey : TaprootPubKey {
    [CompilerGeneratedAttribute]
private bool <OutputKeyParity>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private uint256 <MerkleRoot>k__BackingField;
    [NullableAttribute("0")]
[CompilerGeneratedAttribute]
private ReadOnlyMemory`1<byte> <Tweak>k__BackingField;
    [CompilerGeneratedAttribute]
private TaprootInternalPubKey <InternalKey>k__BackingField;
    [CompilerGeneratedAttribute]
private TaprootPubKey <OutputKey>k__BackingField;
    public bool OutputKeyParity { get; }
    [NullableAttribute("2")]
public uint256 MerkleRoot { get; }
    [NullableAttribute("0")]
public ReadOnlyMemory`1<byte> Tweak { get; }
    public TaprootInternalPubKey InternalKey { get; }
    public TaprootPubKey OutputKey { get; }
    private TaprootFullPubKey(ECXOnlyPubKey outputKey, bool outputParity, TaprootInternalPubKey internalKey, uint256 merkleRoot, Byte[] tweak32);
    public static TaprootFullPubKey Create(TaprootInternalPubKey internalKey, uint256 merkleRoot);
    [NullableContextAttribute("0")]
internal static void ComputeTapTweak(TaprootInternalPubKey internalKey, uint256 merkleRoot, Span`1<byte> tweak32);
    [CompilerGeneratedAttribute]
public bool get_OutputKeyParity();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public uint256 get_MerkleRoot();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public ReadOnlyMemory`1<byte> get_Tweak();
    [CompilerGeneratedAttribute]
public TaprootInternalPubKey get_InternalKey();
    [CompilerGeneratedAttribute]
public TaprootPubKey get_OutputKey();
    public bool CheckTapTweak(TaprootInternalPubKey internalPubKey);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NBitcoin.TaprootInternalPubKey : object {
    internal ECXOnlyPubKey pubkey;
    internal TaprootInternalPubKey(ECXOnlyPubKey pubkey);
    [NullableContextAttribute("0")]
public TaprootInternalPubKey(ReadOnlySpan`1<byte> pubkey);
    public TaprootInternalPubKey(Byte[] pubkey);
    public static TaprootInternalPubKey Parse(string hex);
    public static bool TryParse(string hex, TaprootInternalPubKey& result);
    public static bool TryCreate(Byte[] pubkey, TaprootInternalPubKey& result);
    [NullableContextAttribute("0")]
public static bool TryCreate(ReadOnlySpan`1<byte> pubkey, TaprootInternalPubKey& result);
    public TaprootFullPubKey GetTaprootFullPubKey();
    public TaprootFullPubKey GetTaprootFullPubKey(uint256 merkleRoot);
    public TaprootPubKey AsTaprootPubKey();
    public Byte[] ComputeTapTweak(uint256 merkleRoot);
    [NullableContextAttribute("0")]
public void ComputeTapTweak(uint256 merkleRoot, Span`1<byte> tweak32);
    public Byte[] ToBytes();
    [NullableContextAttribute("0")]
public void ToBytes(Span`1<byte> out32);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(TaprootInternalPubKey other);
    public static bool op_Equality(TaprootInternalPubKey a, TaprootInternalPubKey b);
    public static bool op_Inequality(TaprootInternalPubKey a, TaprootInternalPubKey b);
    public virtual int GetHashCode();
    public virtual string ToString();
    public bool VerifyTaproot(uint256 hash, uint256 merkleRoot, SchnorrSignature signature);
    public int CompareTo(TaprootInternalPubKey other);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NBitcoin.TaprootKeyPair : KeyPair {
    [CompilerGeneratedAttribute]
private TaprootFullPubKey <PubKey>k__BackingField;
    [CompilerGeneratedAttribute]
private Key <Key>k__BackingField;
    public TaprootFullPubKey PubKey { get; }
    public Key Key { get; }
    public TaprootKeyPair(Key key, TaprootFullPubKey pubKey);
    [CompilerGeneratedAttribute]
public TaprootFullPubKey get_PubKey();
    [CompilerGeneratedAttribute]
public Key get_Key();
    public TaprootSignature SignTaprootKeySpend(uint256 hash, TaprootSigHash sigHash);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NBitcoin.TaprootKeyPath : object {
    [CompilerGeneratedAttribute]
private uint256[] <LeafHashes>k__BackingField;
    [CompilerGeneratedAttribute]
private RootedKeyPath <RootedKeyPath>k__BackingField;
    public uint256[] LeafHashes { get; }
    public RootedKeyPath RootedKeyPath { get; }
    public TaprootKeyPath(RootedKeyPath rootedKeyPath);
    public TaprootKeyPath(RootedKeyPath rootedKeyPath, uint256[] leafHashes);
    [CompilerGeneratedAttribute]
public uint256[] get_LeafHashes();
    [CompilerGeneratedAttribute]
public RootedKeyPath get_RootedKeyPath();
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NBitcoin.TaprootNodeInfo : object {
    [CompilerGeneratedAttribute]
private uint256 <Hash>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<TaprootScriptLeaf> <Leaves>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasHiddenNodes>k__BackingField;
    internal uint256 Hash { get; }
    internal List`1<TaprootScriptLeaf> Leaves { get; }
    internal bool HasHiddenNodes { get; }
    internal TaprootNodeInfo(uint256 hash, List`1<TaprootScriptLeaf> leaves, bool hasHiddenNodes);
    [CompilerGeneratedAttribute]
internal uint256 get_Hash();
    [CompilerGeneratedAttribute]
internal List`1<TaprootScriptLeaf> get_Leaves();
    [CompilerGeneratedAttribute]
internal bool get_HasHiddenNodes();
    public static TaprootNodeInfo NewLeaf(TapScript script);
    public static TaprootNodeInfo NewHiddenNode(uint256 hash);
    public static TaprootNodeInfo op_Addition(TaprootNodeInfo a, TaprootNodeInfo b);
    private static bool CompareLexicographic(uint256 a, uint256 b);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NBitcoin.TaprootPubKey : object {
    internal ECXOnlyPubKey pubkey;
    [NullableAttribute("2")]
private Script scriptPubKey;
    public Script ScriptPubKey { get; }
    private Script NBitcoin.IDestination.ScriptPubKey { get; }
    internal TaprootPubKey(ECXOnlyPubKey pubkey);
    [NullableContextAttribute("0")]
public TaprootPubKey(ReadOnlySpan`1<byte> pubkey);
    public TaprootPubKey(Byte[] pubkey);
    public static bool TryCreate(Byte[] pubkey, TaprootPubKey& result);
    [NullableContextAttribute("0")]
public static bool TryCreate(ReadOnlySpan`1<byte> pubkey, TaprootPubKey& result);
    public static TaprootPubKey Parse(string hex);
    public Script get_ScriptPubKey();
    public Byte[] ToBytes();
    [NullableContextAttribute("0")]
public void ToBytes(Span`1<byte> out32);
    public TaprootAddress GetAddress(Network network);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
public static bool op_Equality(TaprootPubKey a, TaprootPubKey b);
    [NullableContextAttribute("2")]
public static bool op_Inequality(TaprootPubKey a, TaprootPubKey b);
    public virtual int GetHashCode();
    public bool VerifySignature(uint256 hash, SchnorrSignature signature);
    [NullableContextAttribute("0")]
public bool VerifySignature(ReadOnlySpan`1<byte> hash, SchnorrSignature signature);
    private sealed virtual override BitcoinAddress NBitcoin.IAddressableDestination.GetAddress(Network network);
    private sealed virtual override Script NBitcoin.IDestination.get_ScriptPubKey();
    public virtual string ToString();
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(TaprootPubKey other);
    private sealed virtual override bool NBitcoin.IAddressableDestination.IsSupported(Network network);
    public bool CheckTapTweak(TaprootInternalPubKey internalPubKey, uint256 merkleRoot, bool parity);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NBitcoin.TaprootReadyPrecomputedTransactionData : PrecomputedTransactionData {
    [CompilerGeneratedAttribute]
private uint256 <HashPrevoutsSingle>k__BackingField;
    [CompilerGeneratedAttribute]
private uint256 <HashSequenceSingle>k__BackingField;
    [CompilerGeneratedAttribute]
private uint256 <HashOutputsSingle>k__BackingField;
    [CompilerGeneratedAttribute]
private uint256 <HashAmountsSingle>k__BackingField;
    [CompilerGeneratedAttribute]
private uint256 <HashScriptsSingle>k__BackingField;
    [CompilerGeneratedAttribute]
private TxOut[] <SpentOutputs>k__BackingField;
    public uint256 HashPrevoutsSingle { get; public set; }
    public uint256 HashSequenceSingle { get; public set; }
    public uint256 HashOutputsSingle { get; public set; }
    public uint256 HashAmountsSingle { get; public set; }
    public uint256 HashScriptsSingle { get; public set; }
    public TxOut[] SpentOutputs { get; }
    public TaprootReadyPrecomputedTransactionData(Transaction tx, TxOut[] spentOutputs);
    [CompilerGeneratedAttribute]
public uint256 get_HashPrevoutsSingle();
    [CompilerGeneratedAttribute]
public void set_HashPrevoutsSingle(uint256 value);
    [CompilerGeneratedAttribute]
public uint256 get_HashSequenceSingle();
    [CompilerGeneratedAttribute]
public void set_HashSequenceSingle(uint256 value);
    [CompilerGeneratedAttribute]
public uint256 get_HashOutputsSingle();
    [CompilerGeneratedAttribute]
public void set_HashOutputsSingle(uint256 value);
    [CompilerGeneratedAttribute]
public uint256 get_HashAmountsSingle();
    [CompilerGeneratedAttribute]
public void set_HashAmountsSingle(uint256 value);
    [CompilerGeneratedAttribute]
public uint256 get_HashScriptsSingle();
    [CompilerGeneratedAttribute]
public void set_HashScriptsSingle(uint256 value);
    [CompilerGeneratedAttribute]
public TxOut[] get_SpentOutputs();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NBitcoin.TaprootScriptLeaf : object {
    [CompilerGeneratedAttribute]
private TapScript <Script>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private List`1<uint256> <MerkleBranch>k__BackingField;
    internal TapScript Script { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal List`1<uint256> MerkleBranch { get; }
    public UInt32 Depth { get; }
    public uint256 LeafHash { get; }
    public TaprootScriptLeaf(TapScript script);
    [CompilerGeneratedAttribute]
internal TapScript get_Script();
    [CompilerGeneratedAttribute]
internal List`1<uint256> get_MerkleBranch();
    public UInt32 get_Depth();
    public uint256 get_LeafHash();
}
[FlagsAttribute]
public enum NBitcoin.TaprootSigHash : Enum {
    public UInt32 value__;
    public static TaprootSigHash Default;
    public static TaprootSigHash All;
    public static TaprootSigHash None;
    public static TaprootSigHash Single;
    public static TaprootSigHash AnyoneCanPay;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NBitcoin.TaprootSignature : object {
    [CompilerGeneratedAttribute]
private TaprootSigHash <SigHash>k__BackingField;
    [CompilerGeneratedAttribute]
private SchnorrSignature <SchnorrSignature>k__BackingField;
    public TaprootSigHash SigHash { get; }
    public SchnorrSignature SchnorrSignature { get; }
    public int Length { get; }
    public TaprootSignature(SchnorrSignature schnorrSignature);
    public TaprootSignature(SchnorrSignature schnorrSignature, TaprootSigHash sigHash);
    public static bool TryParse(Byte[] bytes, TaprootSignature& signature);
    public static TaprootSignature Parse(string hex);
    public static bool TryParse(string hex, TaprootSignature& signature);
    public static TaprootSignature Parse(Byte[] bytes);
    [NullableContextAttribute("0")]
public static TaprootSignature Parse(ReadOnlySpan`1<byte> bytes);
    [NullableContextAttribute("0")]
public static bool TryParse(ReadOnlySpan`1<byte> bytes, TaprootSignature& signature);
    [CompilerGeneratedAttribute]
public TaprootSigHash get_SigHash();
    [CompilerGeneratedAttribute]
public SchnorrSignature get_SchnorrSignature();
    public int get_Length();
    public sealed virtual Byte[] ToBytes();
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NBitcoin.TaprootSpendInfo : object {
    [CompilerGeneratedAttribute]
private TaprootInternalPubKey <InternalPubKey>k__BackingField;
    [CompilerGeneratedAttribute]
private TaprootFullPubKey <OutputPubKey>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ConcurrentDictionary`2<TapScript, List`1<List`1<uint256>>> <ScriptToMerkleProofMap>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private uint256 <MerkleRoot>k__BackingField;
    public TaprootInternalPubKey InternalPubKey { get; }
    public TaprootFullPubKey OutputPubKey { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal ConcurrentDictionary`2<TapScript, List`1<List`1<uint256>>> ScriptToMerkleProofMap { get; }
    [NullableAttribute("2")]
public uint256 MerkleRoot { get; }
    public bool IsKeyPathOnlySpend { get; }
    public TaprootSpendInfo(TaprootInternalPubKey internalPubKey, TaprootFullPubKey outputPubKey, Dictionary`2<TapScript, List`1<List`1<uint256>>> scriptToMerkleProofMap, uint256 merkleRoot);
    [CompilerGeneratedAttribute]
public TaprootInternalPubKey get_InternalPubKey();
    [CompilerGeneratedAttribute]
public TaprootFullPubKey get_OutputPubKey();
    [CompilerGeneratedAttribute]
internal ConcurrentDictionary`2<TapScript, List`1<List`1<uint256>>> get_ScriptToMerkleProofMap();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public uint256 get_MerkleRoot();
    public bool get_IsKeyPathOnlySpend();
    public static TaprootSpendInfo CreateKeySpend(TaprootInternalPubKey internalPubKey, uint256 merkleRoot);
    public static TaprootSpendInfo FromNodeInfo(TaprootInternalPubKey internalPubKey, TaprootNodeInfo node);
    public static TaprootSpendInfo WithHuffmanTree(TaprootInternalPubKey internalPubKey, ValueTuple`2[] scriptWeights);
    public bool TryGetControlBlock(TapScript script, ControlBlock& controlBlock);
    public ControlBlock GetControlBlock(TapScript script);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NBitcoin.TapScript : object {
    [CompilerGeneratedAttribute]
private Script <Script>k__BackingField;
    [CompilerGeneratedAttribute]
private TapLeafVersion <Version>k__BackingField;
    [NullableAttribute("2")]
private uint256 _LeafHash;
    public Script Script { get; }
    public TapLeafVersion Version { get; }
    public uint256 LeafHash { get; }
    public TapScript(Script script, TapLeafVersion version);
    public TapScript(TapScript script);
    [CompilerGeneratedAttribute]
public Script get_Script();
    [CompilerGeneratedAttribute]
public TapLeafVersion get_Version();
    public uint256 get_LeafHash();
    internal static uint256 ComputeLeafHash(Script script, TapLeafVersion version);
    [NullableContextAttribute("2")]
public static Script op_Implicit(TapScript script);
    public virtual string ToString();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public static bool op_Equality(TapScript a, TapScript b);
    public static bool op_Inequality(TapScript a, TapScript b);
    public virtual int GetHashCode();
}
public class NBitcoin.Target : object {
    private static Target _Difficulty1;
    private static BigInteger _Difficulty1BigInteger;
    private UInt32 _Target;
    private static BigInteger Ten;
    private Nullable`1<double> _Difficulty;
    public static Target Difficulty1 { get; }
    private static BigInteger Difficulty1BigInteger { get; }
    public double Difficulty { get; }
    public Target(UInt32 compact);
    public Target(Byte[] compact);
    public Target(BigInteger target);
    public Target(uint256 target);
    private static Target();
    public static Target get_Difficulty1();
    private static void InitDifficulty1();
    private static BigInteger get_Difficulty1BigInteger();
    internal static BigInteger ToBigInteger(uint256 target);
    public static Target op_Implicit(UInt32 a);
    public static UInt32 op_Implicit(Target a);
    public double get_Difficulty();
    public virtual bool Equals(object obj);
    public static bool op_Equality(Target a, Target b);
    public static bool op_Inequality(Target a, Target b);
    public virtual int GetHashCode();
    public BigInteger ToBigInteger();
    public UInt32 ToCompact();
    public uint256 ToUInt256();
    internal static uint256 ToUInt256(BigInteger input);
    public virtual string ToString();
}
public class NBitcoin.ThreadSafeCollection`1 : object {
    private ConcurrentDictionary`2<T, T> _Behaviors;
    public IDisposable Add(T item);
    protected virtual void OnAdding(T obj);
    protected virtual void OnRemoved(T obj);
    public bool Remove(T item);
    public void Clear();
    public T FindOrCreate();
    public U FindOrCreate(Func`1<U> create);
    public U Find();
    public void Remove();
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class NBitcoin.ThreadSafeList`1 : object {
    private List`1<T> _Behaviors;
    private object _lock;
    private Lazy`1<List`1<T>> _EnumeratorList;
    private void Modified();
    public IDisposable Add(T item);
    protected virtual void OnAdding(T obj);
    protected virtual void OnRemoved(T obj);
    public bool Remove(T item);
    public void Clear();
    public T FindOrCreate();
    public U FindOrCreate(Func`1<U> create);
    public U Find();
    public void Remove();
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [CompilerGeneratedAttribute]
private List`1<T> <Modified>b__4_0();
}
public class NBitcoin.Transaction : object {
    protected UInt32 nVersion;
    protected TxInList vin;
    protected TxOutList vout;
    protected LockTime nLockTime;
    protected static UInt32 NoDummyInput;
    private uint256[] _Hashes;
    public static UInt32 CURRENT_VERSION;
    public static UInt32 MAX_STANDARD_TX_SIZE;
    internal static int WITNESS_SCALE_FACTOR;
    private static UInt32 MAX_BLOCK_SIZE;
    private static ulong MAX_MONEY;
    internal static byte SIGHASH_OUTPUT_MASK;
    private static byte SIGHASH_INPUT_MASK;
    public bool RBF { get; }
    public UInt32 Version { get; public set; }
    public Money TotalOut { get; }
    public LockTime LockTime { get; public set; }
    public TxInList Inputs { get; }
    public TxOutList Outputs { get; }
    public bool IsCoinBase { get; }
    public bool HasWitness { get; }
    private static Transaction();
    public bool get_RBF();
    public UInt32 get_Version();
    public void set_Version(UInt32 value);
    public static Transaction Create(Network network);
    public static Transaction Parse(string hex, Network network);
    public static bool TryParse(string hex, Network network, Transaction& transaction);
    public static Transaction Load(Byte[] bytes, Network network);
    public static Transaction Load(Byte[] bytes, Nullable`1<UInt32> version, Network network);
    public Money get_TotalOut();
    public LockTime get_LockTime();
    public void set_LockTime(LockTime value);
    public TxInList get_Inputs();
    public TxOutList get_Outputs();
    public virtual void ReadWrite(BitcoinStream stream);
    public uint256 GetHash();
    protected virtual HashStreamBase CreateHashStream();
    protected virtual HashStreamBase CreateSignatureHashStream(HashVersion hashVersion);
    public void PrecomputeHash(bool invalidateExisting, bool lazily);
    public Transaction Clone(bool cloneCache);
    public uint256 GetWitHash();
    private IndexedTxIn GetIndexedInput(ICoin coin);
    public virtual bool get_IsCoinBase();
    public int GetVirtualSize();
    public void Sign(BitcoinSecret key, ICoin coin);
    public void Sign(BitcoinSecret key, IEnumerable`1<ICoin> coins);
    public void Sign(IEnumerable`1<BitcoinSecret> keys, IEnumerable`1<ICoin> coins);
    [NullableContextAttribute("1")]
public TaprootReadyPrecomputedTransactionData PrecomputeTransactionData(ICoin[] spentCoins);
    [NullableContextAttribute("1")]
public TaprootReadyPrecomputedTransactionData PrecomputeTransactionData(TxOut[] spentOutputs);
    [NullableContextAttribute("1")]
public PrecomputedTransactionData PrecomputeTransactionData();
    [NullableContextAttribute("1")]
public virtual PSBT CreatePSBT(Network network);
    [NullableContextAttribute("1")]
public TxPayload CreatePayload();
    [NullableContextAttribute("1")]
public string ToHex();
    public virtual string ToString();
    public virtual Money GetFee(ICoin[] spentCoins);
    public virtual Money GetFee(TxOut[] spentOutputs);
    public FeeRate GetFeeRate(ICoin[] spentCoins);
    public bool IsFinal(ChainedBlock block);
    public bool IsFinal(DateTimeOffset blockTime, int blockHeight);
    public bool CheckSequenceLocks(Int32[] prevHeights, ChainedBlock block, LockTimeFlags flags);
    public SequenceLock CalculateSequenceLocks(Int32[] prevHeights, ChainedBlock block, LockTimeFlags flags);
    private DateTimeOffset Max(DateTimeOffset a, DateTimeOffset b);
    public Transaction WithOptions(TransactionOptions options);
    public virtual bool get_HasWitness();
    public virtual TransactionCheckResult Check();
    public virtual uint256 GetSignatureHashTaproot(TxOut[] spentOutputs, TaprootExecutionData executionData);
    public virtual uint256 GetSignatureHashTaproot(PrecomputedTransactionData cache, TaprootExecutionData executionData);
    public virtual uint256 GetSignatureHash(Script scriptCode, int nIn, SigHash nHashType, TxOut spentOutput, HashVersion sigversion, PrecomputedTransactionData precomputedTransactionData);
    private static void WriteScriptCode(BitcoinStream stream, Script scriptCode);
    public uint256 GetSignatureHash(Script scriptCode, int nIn, SigHash nHashType, TxOut spentOutput, HashVersion sigversion);
    private static uint256 GetHash(BitcoinStream stream);
    internal virtual uint256 GetHashOutputs();
    internal virtual uint256 GetHashSequence();
    internal virtual uint256 GetHashPrevouts();
    internal virtual uint256 GetHashOutputs(HashVersion hashVersion);
    internal virtual uint256 GetHashSequence(HashVersion hashVersion);
    internal virtual uint256 GetHashPrevouts(HashVersion hashVersion);
    internal virtual uint256 GetHashAmounts(HashVersion hashVersion, IEnumerable`1<TxOut> outputsSpents);
    internal virtual uint256 GetHashScripts(HashVersion hashVersion, IEnumerable`1<TxOut> outputsSpents);
    protected BitcoinStream CreateHashWriter(HashVersion version);
    protected BitcoinStream CreateHashWriter(HashVersion version, string tag);
    public virtual ConsensusFactory GetConsensusFactory();
    public Transaction Clone();
    public void FromBytes(Byte[] bytes);
    public void FromBytes(Byte[] bytes, Nullable`1<UInt32> version);
    public TransactionValidator CreateValidator(ICoin[] spentCoins);
    public TxOut[] GetOrderedTxOuts(ICoin[] spentCoins);
    public TransactionValidator CreateValidator(TxOut[] spentOutputs);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NBitcoin.TransactionBuilder : object {
    private List`1<BuilderGroup> _BuilderGroups;
    [NullableAttribute("2")]
private BuilderGroup _CurrentGroup;
    [CompilerGeneratedAttribute]
private Random <ShuffleRandom>k__BackingField;
    [CompilerGeneratedAttribute]
private ICoinSelector <CoinSelector>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DustPrevention>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <OptInRBF>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ShuffleInputs>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ShuffleOutputs>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <MergeOutputs>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <FilterUneconomicalCoins>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private FeeRate <FilterUneconomicalCoinsRate>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Func`2<OutPoint, ICoin> <CoinFinder>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Func`2<Script, KeyPair> <KeyFinder>k__BackingField;
    private LockTime _LockTime;
    private Nullable`1<UInt32> _Version;
    internal List`1<KeyPair> _Keys;
    private static TxNullDataTemplate _OpReturnTemplate;
    [NullableAttribute("2")]
private SendBuilder _LastSendBuilder;
    [CompilerGeneratedAttribute]
private StandardTransactionPolicy <StandardTransactionPolicy>k__BackingField;
    [NullableAttribute("2")]
private string _OpReturnUser;
    [NullableAttribute("2")]
private AssetId _IssuedAsset;
    [CompilerGeneratedAttribute]
private Network <Network>k__BackingField;
    private List`1<Tuple`3<IPubKey, ITransactionSignature, OutPoint>> _KnownSignatures;
    private Dictionary`2<Script, Script> _ScriptPubKeyToRedeem;
    private SigningOptions signingOptions;
    private List`1<BuilderExtension> _Extensions;
    private static int MAX_TX_VSIZE;
    internal BuilderGroup CurrentGroup { get; }
    public Random ShuffleRandom { get; public set; }
    public ICoinSelector CoinSelector { get; public set; }
    public bool DustPrevention { get; public set; }
    public bool OptInRBF { get; public set; }
    public bool ShuffleInputs { get; public set; }
    public bool ShuffleOutputs { get; public set; }
    public bool MergeOutputs { get; public set; }
    public bool FilterUneconomicalCoins { get; public set; }
    [NullableAttribute("2")]
public FeeRate FilterUneconomicalCoinsRate { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Func`2<OutPoint, ICoin> CoinFinder { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Func`2<Script, KeyPair> KeyFinder { get; public set; }
    public StandardTransactionPolicy StandardTransactionPolicy { get; public set; }
    public Network Network { get; }
    public List`1<BuilderExtension> Extensions { get; }
    internal TransactionBuilder(Network network);
    private static TransactionBuilder();
    internal BuilderGroup get_CurrentGroup();
    private void InitExtensions();
    [CompilerGeneratedAttribute]
public Random get_ShuffleRandom();
    [CompilerGeneratedAttribute]
public void set_ShuffleRandom(Random value);
    [CompilerGeneratedAttribute]
public ICoinSelector get_CoinSelector();
    [CompilerGeneratedAttribute]
public void set_CoinSelector(ICoinSelector value);
    [CompilerGeneratedAttribute]
public bool get_DustPrevention();
    [CompilerGeneratedAttribute]
public void set_DustPrevention(bool value);
    [CompilerGeneratedAttribute]
public bool get_OptInRBF();
    [CompilerGeneratedAttribute]
public void set_OptInRBF(bool value);
    [CompilerGeneratedAttribute]
public bool get_ShuffleInputs();
    [CompilerGeneratedAttribute]
public void set_ShuffleInputs(bool value);
    [CompilerGeneratedAttribute]
public bool get_ShuffleOutputs();
    [CompilerGeneratedAttribute]
public void set_ShuffleOutputs(bool value);
    [CompilerGeneratedAttribute]
public bool get_MergeOutputs();
    [CompilerGeneratedAttribute]
public void set_MergeOutputs(bool value);
    [CompilerGeneratedAttribute]
public bool get_FilterUneconomicalCoins();
    [CompilerGeneratedAttribute]
public void set_FilterUneconomicalCoins(bool value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public FeeRate get_FilterUneconomicalCoinsRate();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_FilterUneconomicalCoinsRate(FeeRate value);
    [CompilerGeneratedAttribute]
public Func`2<OutPoint, ICoin> get_CoinFinder();
    [CompilerGeneratedAttribute]
public void set_CoinFinder(Func`2<OutPoint, ICoin> value);
    [CompilerGeneratedAttribute]
public Func`2<Script, KeyPair> get_KeyFinder();
    [CompilerGeneratedAttribute]
public void set_KeyFinder(Func`2<Script, KeyPair> value);
    public TransactionBuilder SetLockTime(LockTime lockTime);
    public TransactionBuilder SetVersion(UInt32 version);
    public TransactionBuilder AddKeys(ISecret[] keys);
    public TransactionBuilder AddKeys(Key[] keys);
    public TransactionBuilder AddKeys(KeyPair[] keyPairs);
    public TransactionBuilder AddKnownSignature(IPubKey pubKey, ITransactionSignature signature, OutPoint signedOutpoint);
    public TransactionBuilder SetOptInRBF(bool rbf);
    public TransactionBuilder AddCoin(ICoin coin);
    public TransactionBuilder AddCoin(ICoin coin, CoinOptions options);
    public TransactionBuilder AddCoins(ICoin[] coins);
    public TransactionBuilder AddCoins(IEnumerable`1<ICoin> coins);
    public TransactionBuilder AddCoins(PSBT psbt);
    public TransactionBuilder SetGroupName(string groupName);
    public TransactionBuilder Send(IDestination destination, Money amount);
    public TransactionBuilder SendAll(IDestination destination);
    public TransactionBuilder SendAll(Script scriptPubKey);
    public TransactionBuilder SendAllRemaining(IDestination destination);
    public TransactionBuilder SendAllRemaining(Script scriptPubKey);
    public TransactionBuilder SendAllRemainingToChange();
    public TransactionBuilder Send(Script scriptPubKey, Money amount);
    public TransactionBuilder SubtractFees();
    public TransactionBuilder Send(IDestination destination, IMoney amount);
    public TransactionBuilder Send(Script scriptPubKey, IMoney amount);
    public TransactionBuilder SendAsset(IDestination destination, AssetMoney asset);
    public TransactionBuilder SendAsset(IDestination destination, AssetId assetId, ulong quantity);
    private void DoShuffleGroups();
    private TxOut SetColoredChange(IMoney changeAmount, TransactionBuildingContext ctx);
    private TxOut SetChange(IMoney changeAmount, TransactionBuildingContext ctx);
    public TransactionBuilder SendAsset(Script scriptPubKey, AssetId assetId, ulong assetQuantity);
    public TransactionBuilder SendAsset(Script scriptPubKey, AssetMoney asset);
    internal Money GetDust();
    internal Money GetDust(Script script);
    public TransactionBuilder SetTransactionPolicy(StandardTransactionPolicy policy);
    [CompilerGeneratedAttribute]
public StandardTransactionPolicy get_StandardTransactionPolicy();
    [CompilerGeneratedAttribute]
public void set_StandardTransactionPolicy(StandardTransactionPolicy value);
    private void AssertOpReturn(string name);
    public TransactionBuilder IssueAsset(IDestination destination, AssetMoney asset);
    public TransactionBuilder IssueAsset(Script scriptPubKey, AssetMoney asset);
    public TransactionBuilder SetSigningOptions(SigningOptions signingOptions);
    public TransactionBuilder SetSigningOptions(SigHash sigHash);
    public TransactionBuilder SetSigningOptions(SigHash sigHash, bool enforceLowR);
    public bool TrySignInput(Transaction transaction, UInt32 index, ITransactionSignature& signature);
    public TransactionBuilder SendFees(Money fees);
    public TransactionBuilder SendEstimatedFees(FeeRate feeRate);
    public TransactionBuilder SendEstimatedFeesSplit(FeeRate feeRate);
    public TransactionBuilder SendFeesSplit(Money fees);
    public TransactionBuilder SetFeeWeight(decimal feeWeight);
    public TransactionBuilder SetChange(IDestination destination, ChangeType changeType);
    public TransactionBuilder SetChange(Script scriptPubKey, ChangeType changeType);
    [CompilerGeneratedAttribute]
public Network get_Network();
    public TransactionBuilder SetCoinSelector(ICoinSelector selector);
    public PSBT BuildPSBT(bool sign);
    public PSBT CreatePSBTFrom(Transaction tx, bool sign);
    private PSBT CreatePSBTFromCore(Transaction tx, bool sign);
    public TransactionBuilder SignPSBT(PSBT psbt);
    public TransactionBuilder SignPSBTInput(PSBTInput psbtInput);
    public TransactionBuilder FinalizePSBT(PSBT psbt);
    public TransactionBuilder FinalizePSBTInput(PSBTInput psbtInput);
    public TransactionBuilder ExtractSignatures(PSBT psbt, Transaction transaction);
    public TransactionBuilder UpdatePSBT(PSBT psbt);
    public Transaction BuildTransaction(bool sign);
    private bool IsEconomical(Coin c);
    private ICoin[] BuildTransaction(TransactionBuildingContext ctx, BuilderGroup group, List`1<Action`1<TransactionBuildingContext>> builders, IEnumerable`1<ICoin> coins);
    protected virtual void AfterBuild(Transaction transaction);
    public Transaction SignTransaction(Transaction transaction);
    public Transaction SignTransactionInPlace(Transaction transaction);
    private static void SetFinalScripts(TransactionSigningContext ctx, Transaction transaction);
    public FeeRate EstimateFeeRate(Transaction tx);
    private void ExtractExistingSignatures(TransactionSigningContext ctx);
    private void SignTransactionContext(TransactionSigningContext ctx);
    private void MergePartialSignatures(TransactionSigningContext ctx);
    private void FinalizeTransactionContext(TransactionSigningContext ctx);
    [IteratorStateMachineAttribute("NBitcoin.TransactionBuilder/<GetSigners>d__143")]
private IEnumerable`1<ISigner> GetSigners(InputSigningContext inputCtx);
    [IteratorStateMachineAttribute("NBitcoin.TransactionBuilder/<GetKeyRepositories>d__144")]
private IEnumerable`1<IKeyRepository> GetKeyRepositories(InputSigningContext inputCtx);
    public ICoin FindSignableCoin(IndexedTxIn txIn);
    public ICoin FindSignableCoin(TxIn txIn);
    private TxOut[] GetSpentOutputs(Transaction tx);
    public bool Verify(Transaction tx);
    public bool Verify(TransactionValidator validator);
    public bool Verify(Transaction tx, Money expectedFees);
    public bool Verify(TransactionValidator validator, Money expectedFees);
    public bool Verify(Transaction tx, FeeRate expectedFeeRate);
    public bool Verify(TransactionValidator validator, FeeRate expectedFeeRate);
    public bool Verify(Transaction tx, TransactionPolicyError[]& errors);
    public bool Verify(TransactionValidator validator, TransactionPolicyError[]& errors);
    public TransactionValidator CreateTransactionValidatorFromCoins(Transaction tx);
    public bool Verify(Transaction tx, Money expectedFees, TransactionPolicyError[]& errors);
    public bool Verify(TransactionValidator validator, Money expectedFees, TransactionPolicyError[]& errors);
    public bool Verify(Transaction tx, FeeRate expectedFeeRate, TransactionPolicyError[]& errors);
    public bool Verify(TransactionValidator validator, FeeRate expectedFeeRate, TransactionPolicyError[]& errors);
    public TransactionPolicyError[] Check(Transaction tx, FeeRate expectedFeeRate);
    public TransactionPolicyError[] Check(Transaction tx, Money expectedFee);
    public TransactionPolicyError[] Check(Transaction tx);
    private CoinNotFoundException CoinNotFound(IndexedTxIn txIn);
    public ICoin FindCoin(OutPoint outPoint);
    internal CoinOptions FindCoinOptions(OutPoint outPoint);
    public ICoin[] FindSpentCoins(Transaction tx);
    public int EstimateSize(Transaction tx);
    public int EstimateSize(Transaction tx, bool virtualSize);
    public void EstimateSizes(Transaction tx, Int32& witSize, Int32& baseSize);
    [NullableContextAttribute("2")]
private TxOut CreateTxOut(Money amount, Script script);
    private void EstimateScriptSigSize(ICoin coin, Int32& witSize, Int32& baseSize);
    public Money EstimateFees(FeeRate feeRate);
    public Money EstimateFees(Transaction tx, FeeRate feeRate);
    private static void AdjustFinalScripts(ICoin coin, PSBTInput txIn);
    internal bool IsCompatibleKeyFromScriptCode(IPubKey pubKey, Script scriptPubKey);
    public TransactionBuilder Then();
    public TransactionBuilder Then(string groupName);
    public TransactionBuilder AddCoins(Transaction transaction);
    public TransactionBuilder AddKnownRedeems(Script[] knownRedeems);
    [ObsoleteAttribute("Use PSBTs rather than raw transactions to combine signatures.")]
public Transaction CombineSignatures(Transaction[] transactions);
    public List`1<BuilderExtension> get_Extensions();
    private ScriptSigs GetScriptSigs(IndexedTxIn indexedTxIn);
    private Script DeduceScriptPubKey(Script scriptSig);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private ICoin <UpdatePSBT>b__130_0(IndexedTxIn i);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NBitcoin.TransactionChecker : object {
    [NullableAttribute("2")]
private PrecomputedTransactionData _PrecomputedTransactionData;
    private Transaction _Transaction;
    private int _Index;
    [NullableAttribute("2")]
private TxOut _SpentOutput;
    public PrecomputedTransactionData PrecomputedTransactionData { get; }
    public Transaction Transaction { get; }
    public TxIn Input { get; }
    public int Index { get; }
    [NullableAttribute("2")]
public TxOut SpentOutput { get; }
    [NullableContextAttribute("2")]
public TransactionChecker(Transaction tx, int index, TxOut spentOutput, PrecomputedTransactionData precomputedTransactionData);
    public TransactionChecker(Transaction tx, int index, TxOut spentOutput);
    public PrecomputedTransactionData get_PrecomputedTransactionData();
    public Transaction get_Transaction();
    public TxIn get_Input();
    public int get_Index();
    [NullableContextAttribute("2")]
public TxOut get_SpentOutput();
    public bool CheckSchnorrSignature(Byte[] sig, Byte[] pubkey_in, HashVersion taproot, ExecutionData executionData, ScriptError& err);
}
public enum NBitcoin.TransactionCheckResult : Enum {
    public int value__;
    public static TransactionCheckResult Success;
    public static TransactionCheckResult NoInput;
    public static TransactionCheckResult NoOutput;
    public static TransactionCheckResult NegativeOutput;
    public static TransactionCheckResult OutputTooLarge;
    public static TransactionCheckResult OutputTotalTooLarge;
    public static TransactionCheckResult TransactionTooLarge;
    public static TransactionCheckResult DuplicateInputs;
    public static TransactionCheckResult NullInputPrevOut;
    public static TransactionCheckResult CoinbaseScriptTooLarge;
}
public class NBitcoin.TransactionNotFoundException : Exception {
    [CompilerGeneratedAttribute]
private uint256 <TxId>k__BackingField;
    public uint256 TxId { get; public set; }
    public TransactionNotFoundException(uint256 txId);
    public TransactionNotFoundException(string message, uint256 txId);
    public TransactionNotFoundException(string message, uint256 txId, Exception inner);
    [CompilerGeneratedAttribute]
public uint256 get_TxId();
    [CompilerGeneratedAttribute]
public void set_TxId(uint256 value);
}
[FlagsAttribute]
public enum NBitcoin.TransactionOptions : Enum {
    public UInt32 value__;
    public static TransactionOptions None;
    public static TransactionOptions Witness;
    public static TransactionOptions All;
}
public class NBitcoin.TransactionSignature : object {
    private static TransactionSignature _Empty;
    private ECDSASignature _Signature;
    private SigHash _SigHash;
    private string _Id;
    public static TransactionSignature Empty { get; }
    public ECDSASignature Signature { get; }
    public SigHash SigHash { get; }
    private string Id { get; }
    public bool IsLowS { get; }
    public TransactionSignature(ECDSASignature signature, SigHash sigHash);
    public TransactionSignature(ECDSASignature signature);
    public TransactionSignature(Byte[] sigSigHash);
    public TransactionSignature(Byte[] sig, SigHash sigHash);
    private static TransactionSignature();
    public static TransactionSignature get_Empty();
    public static bool IsValid(Byte[] sig, ScriptVerify scriptVerify);
    public static bool IsValid(Byte[] sig, ScriptVerify scriptVerify, ScriptError& error);
    public ECDSASignature get_Signature();
    public SigHash get_SigHash();
    public sealed virtual Byte[] ToBytes();
    public static bool ValidLength(int length);
    private string get_Id();
    public virtual bool Equals(object obj);
    public static bool op_Equality(TransactionSignature a, TransactionSignature b);
    public static bool op_Inequality(TransactionSignature a, TransactionSignature b);
    public virtual int GetHashCode();
    public virtual string ToString();
    public bool get_IsLowS();
    public TransactionSignature MakeCanonical();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NBitcoin.TransactionValidator : object {
    [CompilerGeneratedAttribute]
private Transaction <Transaction>k__BackingField;
    [CompilerGeneratedAttribute]
private TxOut[] <SpentOutputs>k__BackingField;
    [CompilerGeneratedAttribute]
private PrecomputedTransactionData <PrecomputedTransactionData>k__BackingField;
    [CompilerGeneratedAttribute]
private ScriptVerify <ScriptVerify>k__BackingField;
    public Transaction Transaction { get; }
    public TxOut[] SpentOutputs { get; }
    public PrecomputedTransactionData PrecomputedTransactionData { get; }
    public ScriptVerify ScriptVerify { get; public set; }
    internal TransactionValidator(Transaction transaction, TxOut[] spentOutputs);
    [CompilerGeneratedAttribute]
public Transaction get_Transaction();
    [CompilerGeneratedAttribute]
public TxOut[] get_SpentOutputs();
    [CompilerGeneratedAttribute]
public PrecomputedTransactionData get_PrecomputedTransactionData();
    [CompilerGeneratedAttribute]
public ScriptVerify get_ScriptVerify();
    [CompilerGeneratedAttribute]
public void set_ScriptVerify(ScriptVerify value);
    public bool TryValidateInput(int index, InputValidationResult& result);
    public InputValidationResult ValidateInput(int index);
    public InputValidationResult[] ValidateInputs();
}
public class NBitcoin.TxIn : object {
    protected OutPoint prevout;
    protected Script scriptSig;
    protected UInt32 nSequence;
    private WitScript witScript;
    public Sequence Sequence { get; public set; }
    public OutPoint PrevOut { get; public set; }
    public Script ScriptSig { get; public set; }
    public WitScript WitScript { get; public set; }
    public bool IsFinal { get; }
    public TxIn(Script scriptSig);
    public TxIn(OutPoint prevout, Script scriptSig);
    public TxIn(OutPoint prevout);
    public Sequence get_Sequence();
    public void set_Sequence(Sequence value);
    public OutPoint get_PrevOut();
    public void set_PrevOut(OutPoint value);
    public Script get_ScriptSig();
    public void set_ScriptSig(Script value);
    [ObsoleteAttribute("Do not use this, it isn't possible to get a signer's address from a script without taking heuristic which can be gamed by a malicious actor")]
public IDestination GetSigner();
    public WitScript get_WitScript();
    public void set_WitScript(WitScript value);
    public virtual void ReadWrite(BitcoinStream stream);
    public bool IsFrom(PubKey pubKey);
    public bool get_IsFinal();
    public virtual ConsensusFactory GetConsensusFactory();
    public virtual TxIn Clone();
    public static TxIn CreateCoinbase(int height);
}
public class NBitcoin.TxInList : UnsignedList`1<TxIn> {
    public TxInList(int capacity);
    public TxInList(Transaction parent);
    public IndexedTxIn FindIndexedInput(OutPoint outpoint);
    public IndexedTxIn FindIndexedInput(int index);
    public TxIn CreateNewTxIn(OutPoint outpoint, Script scriptSig, WitScript witScript, Nullable`1<Sequence> sequence);
    public TxIn Add(OutPoint outpoint, Script scriptSig, WitScript witScript, Nullable`1<Sequence> sequence);
    public TxIn Add(TxIn txIn);
    public IEnumerable`1<IndexedTxIn> AsIndexedInputs();
    public TxIn Add(Transaction prevTx, int outIndex);
    [CompilerGeneratedAttribute]
private IndexedTxIn <AsIndexedInputs>b__8_0(TxIn r, int i);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NBitcoin.TxNullDataTemplate : ScriptTemplate {
    private static TxNullDataTemplate _Instance;
    [CompilerGeneratedAttribute]
private int <MaxScriptSizeLimit>k__BackingField;
    public static int MAX_OP_RETURN_RELAY;
    public static TxNullDataTemplate Instance { get; }
    public int MaxScriptSizeLimit { get; private set; }
    public TxNullDataTemplate(int maxScriptSize);
    private static TxNullDataTemplate();
    public static TxNullDataTemplate get_Instance();
    [CompilerGeneratedAttribute]
public int get_MaxScriptSizeLimit();
    [CompilerGeneratedAttribute]
private void set_MaxScriptSizeLimit(int value);
    protected virtual bool FastCheckScriptPubKey(Script scriptPubKey, Boolean& needMoreCheck);
    protected virtual bool CheckScriptPubKeyCore(Script scriptPubKey, Op[] scriptPubKeyOps);
    public Byte[][] ExtractScriptPubKeyParameters(Script scriptPubKey);
    protected virtual bool CheckScriptSigCore(Script scriptSig, Op[] scriptSigOps, Script scriptPubKey, Op[] scriptPubKeyOps);
    public Script GenerateScriptPubKey(Byte[][] data);
}
public class NBitcoin.TxOut : object {
    protected Script publicKey;
    internal static Money NullMoney;
    private Money _Value;
    private static FeeRate dustRelayFee;
    public Script ScriptPubKey { get; public set; }
    public Money Value { get; public set; }
    public TxOut(Money value, IDestination destination);
    public TxOut(Money value, Script scriptPubKey);
    private static TxOut();
    public Script get_ScriptPubKey();
    public void set_ScriptPubKey(Script value);
    public virtual Money get_Value();
    public virtual void set_Value(Money value);
    public bool IsDust();
    [ObsoleteAttribute("Use IsDust() instead. The minRelayTxFee is now ignored.")]
public bool IsDust(FeeRate minRelayTxFee);
    public virtual Money GetDustThreshold();
    [ObsoleteAttribute("Use GetDustThreshold() instead. The minRelayTxFee is now ignored.")]
public Money GetDustThreshold(FeeRate minRelayTxFee);
    public virtual void ReadWrite(BitcoinStream stream);
    public bool IsTo(IDestination destination);
    public static TxOut Parse(string hex);
    public virtual TxOut Clone();
    public virtual ConsensusFactory GetConsensusFactory();
}
public class NBitcoin.TxOutCompressor : object {
    private TxOut _TxOut;
    public TxOut TxOut { get; }
    public TxOutCompressor(TxOut txOut);
    private ulong CompressAmount(ulong n);
    private ulong DecompressAmount(ulong x);
    public TxOut get_TxOut();
    public sealed virtual void ReadWrite(BitcoinStream stream);
}
public class NBitcoin.TxOutList : UnsignedList`1<TxOut> {
    public TxOutList(int capacity);
    public TxOutList(Transaction parent);
    public IEnumerable`1<TxOut> To(IDestination destination);
    public IEnumerable`1<TxOut> To(Script scriptPubKey);
    public IEnumerable`1<IndexedTxOut> AsIndexedOutputs();
    [IteratorStateMachineAttribute("NBitcoin.TxOutList/<AsCoins>d__6")]
public IEnumerable`1<Coin> AsCoins();
    public TxOut CreateNewTxOut();
    public TxOut CreateNewTxOut(Money money, Script scriptPubKey);
    public TxOut CreateNewTxOut(Money money, IDestination destination);
    public TxOut Add(Money money, Script scriptPubKey);
    public TxOut Add(Money money, IDestination destination);
    public TxOut Add(TxOut txOut);
    [CompilerGeneratedAttribute]
private IndexedTxOut <AsIndexedOutputs>b__5_0(TxOut r, int i);
}
[ExtensionAttribute]
public static class NBitcoin.TxRepoExtensions : object {
    [ExtensionAttribute]
public static Task`1<Transaction> GetAsync(ITransactionRepository repo, string txId);
    [ExtensionAttribute]
public static Task PutAsync(ITransactionRepository repo, Transaction tx);
    [ExtensionAttribute]
public static Transaction Get(ITransactionRepository repo, string txId);
    [ExtensionAttribute]
public static void Put(ITransactionRepository repo, Transaction tx);
    [ExtensionAttribute]
public static Transaction Get(ITransactionRepository repo, uint256 txId);
    [ExtensionAttribute]
public static void Put(ITransactionRepository repo, uint256 txId, Transaction tx);
}
public class NBitcoin.uint160 : object {
    private static uint160 _Zero;
    private static uint160 _One;
    private static HexEncoder Encoder;
    private static int WIDTH_BYTE;
    internal UInt32 pn0;
    internal UInt32 pn1;
    internal UInt32 pn2;
    internal UInt32 pn3;
    internal UInt32 pn4;
    public static uint160 Zero { get; }
    public static uint160 One { get; }
    public int Size { get; }
    public uint160(uint160 b);
    public uint160(ulong b);
    public uint160(Byte[] vch, bool lendian);
    public uint160(string str);
    public uint160(Byte[] vch);
    private static uint160();
    public static uint160 get_Zero();
    public static uint160 get_One();
    public static uint160 Parse(string hex);
    public static bool TryParse(string hex, uint160& result);
    public byte GetByte(int index);
    public virtual string ToString();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(uint160 other);
    public sealed virtual int CompareTo(uint160 other);
    public sealed virtual int CompareTo(object obj);
    public static bool op_Equality(uint160 a, uint160 b);
    public static bool op_LessThan(uint160 a, uint160 b);
    public static bool op_GreaterThan(uint160 a, uint160 b);
    public static bool op_LessThanOrEqual(uint160 a, uint160 b);
    public static bool op_GreaterThanOrEqual(uint160 a, uint160 b);
    private static int Comparison(uint160 a, uint160 b);
    public static bool op_Inequality(uint160 a, uint160 b);
    public static bool op_Equality(uint160 a, ulong b);
    public static bool op_Inequality(uint160 a, ulong b);
    public static uint160 op_Implicit(ulong value);
    public Byte[] ToBytes(bool lendian);
    public MutableUint160 AsBitcoinSerializable();
    public int GetSerializeSize(int nType, Nullable`1<UInt32> protocolVersion);
    public int get_Size();
    public ulong GetLow64();
    public UInt32 GetLow32();
    public virtual int GetHashCode();
}
public class NBitcoin.uint256 : object {
    private static uint256 _Zero;
    private static uint256 _One;
    private static HexEncoder Encoder;
    private static int WIDTH_BYTE;
    internal ulong pn0;
    internal ulong pn1;
    internal ulong pn2;
    internal ulong pn3;
    public static uint256 Zero { get; }
    public static uint256 One { get; }
    public int Size { get; }
    public uint256(uint256 b);
    public uint256(ulong b);
    public uint256(Byte[] vch, bool lendian);
    public uint256(Byte[] vch, int offset, int length, bool lendian);
    public uint256(ReadOnlySpan`1<byte> bytes);
    public uint256(string str);
    public uint256(Byte[] vch);
    private static uint256();
    public static uint256 get_Zero();
    public static uint256 get_One();
    public static uint256 Parse(string hex);
    public static bool TryParse(string hex, uint256& result);
    public byte GetByte(int index);
    public virtual string ToString();
    public int GetBisCount();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(uint256 other);
    public sealed virtual int CompareTo(uint256 other);
    public sealed virtual int CompareTo(object obj);
    public static bool op_Equality(uint256 a, uint256 b);
    public static bool op_LessThan(uint256 a, uint256 b);
    public static bool op_GreaterThan(uint256 a, uint256 b);
    public static bool op_LessThanOrEqual(uint256 a, uint256 b);
    public static bool op_GreaterThanOrEqual(uint256 a, uint256 b);
    private static int Comparison(uint256 a, uint256 b);
    public static bool op_Inequality(uint256 a, uint256 b);
    public static bool op_Equality(uint256 a, ulong b);
    public static bool op_Inequality(uint256 a, ulong b);
    public static uint256 op_Implicit(ulong value);
    public Byte[] ToBytes(bool lendian);
    public void ToBytes(Byte[] output);
    public void ToBytes(Byte[] output, bool lendian);
    public void ToBytes(Span`1<byte> output, bool lendian);
    public MutableUint256 AsBitcoinSerializable();
    public int GetSerializeSize(int nType, Nullable`1<UInt32> protocolVersion);
    public int get_Size();
    public ulong GetLow64();
    public UInt32 GetLow32();
    public virtual int GetHashCode();
}
public class NBitcoin.UnsecureRandom : object {
    private Random _Rand;
    public sealed virtual void GetBytes(Byte[] output);
    public sealed virtual void GetBytes(Span`1<byte> output);
}
[DefaultMemberAttribute("Item")]
public class NBitcoin.UnsignedList`1 : List`1<T> {
    [CompilerGeneratedAttribute]
private Transaction <Transaction>k__BackingField;
    public Transaction Transaction { get; internal set; }
    public T Item { get; public set; }
    public UnsignedList`1(Transaction parent);
    public UnsignedList`1(IEnumerable`1<T> collection);
    public UnsignedList`1(int capacity);
    [CompilerGeneratedAttribute]
public Transaction get_Transaction();
    [CompilerGeneratedAttribute]
internal void set_Transaction(Transaction value);
    public T get_Item(UInt32 index);
    public void set_Item(UInt32 index, T value);
}
public class NBitcoin.Utils : object {
    private static DateTimeOffset unixRef;
    private static Utils();
    internal static void SafeSet(ManualResetEvent ar);
    public static bool ArrayEqual(Byte[] a, Byte[] b);
    public static bool ArrayEqual(Byte[] a, int startA, Byte[] b, int startB, int length);
    private static void Write(MemoryStream ms, Byte[] bytes);
    public static UInt32 DateTimeToUnixTime(DateTimeOffset dt);
    internal static ulong DateTimeToUnixTimeLong(DateTimeOffset dt);
    public static DateTimeOffset UnixTimeToDateTime(UInt32 timestamp);
    public static DateTimeOffset UnixTimeToDateTime(ulong timestamp);
    public static DateTimeOffset UnixTimeToDateTime(long timestamp);
    public static string ExceptionToString(Exception exception);
    public static void Shuffle(T[] arr, Random rand);
    public static void Shuffle(List`1<T> arr, int start, Random rand);
    public static void Shuffle(List`1<T> arr, Random rand);
    public static void Shuffle(T[] arr, int seed);
    public static void Shuffle(T[] arr);
    internal static void SafeCloseSocket(Socket socket);
    public static IPEndPoint EnsureIPv6(IPEndPoint endpoint);
    public static Byte[] ToBytes(UInt32 value, bool littleEndian);
    public static Byte[] ToBytes(ulong value, bool littleEndian);
    public static void ToBytes(UInt32 value, bool littleEndian, Span`1<byte> output);
    public static void ToBytes(ulong value, bool littleEndian, Span`1<byte> output);
    public static UInt32 ToUInt32(Byte[] value, int index, bool littleEndian);
    public static UInt32 ToUInt32(ReadOnlySpan`1<byte> value, bool littleEndian);
    public static int ToInt32(Byte[] value, int index, bool littleEndian);
    public static UInt32 ToUInt32(Byte[] value, bool littleEndian);
    public static ulong ToUInt64(Byte[] value, int offset, bool littleEndian);
    public static ulong ToUInt64(ReadOnlySpan`1<byte> value, bool littleEndian);
    public static ulong ToUInt64(Byte[] value, bool littleEndian);
    public static bool TryParseEndpoint(string hostPort, int defaultPort, EndPoint& endpoint);
    public static EndPoint ParseEndpoint(string hostPort, int defaultPort);
    public static int GetHashCode(Byte[] array);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NBitcoin.WitKeyId : object {
    private uint160 v;
    public Script ScriptPubKey { get; }
    public WitKeyId(Byte[] value);
    public WitKeyId(uint160 value);
    public WitKeyId(string value);
    public sealed virtual Script get_ScriptPubKey();
    public KeyId AsKeyId();
    public BitcoinWitPubKeyAddress GetAddress(Network network);
    private sealed virtual override BitcoinAddress NBitcoin.IAddressableDestination.GetAddress(Network network);
    public sealed virtual bool IsSupported(Network network);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
public static bool op_Equality(WitKeyId a, WitKeyId b);
    [NullableContextAttribute("2")]
public static bool op_Inequality(WitKeyId a, WitKeyId b);
    public virtual int GetHashCode();
    public Byte[] ToBytes();
    public virtual string ToString();
}
internal class NBitcoin.Witness : object {
    private TxInList _Inputs;
    public Witness(TxInList inputs);
    internal bool IsNull();
    internal void ReadWrite(BitcoinStream stream);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NBitcoin.WitProgramParameters : object {
    [CompilerGeneratedAttribute]
private OpcodeType <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <Program>k__BackingField;
    public OpcodeType Version { get; public set; }
    public Byte[] Program { get; public set; }
    public WitProgramParameters(OpcodeType version, Byte[] program);
    [CompilerGeneratedAttribute]
public OpcodeType get_Version();
    [CompilerGeneratedAttribute]
public void set_Version(OpcodeType value);
    [CompilerGeneratedAttribute]
public Byte[] get_Program();
    [CompilerGeneratedAttribute]
public void set_Program(Byte[] value);
    public bool NeedWitnessRedeemScript();
    public bool VerifyWitnessRedeemScript(Script witnessRedeemScript);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class NBitcoin.WitScript : object {
    private Byte[][] _Pushes;
    private static WitScript _Empty;
    public Byte[] Item { get; }
    public IEnumerable`1<Byte[]> Pushes { get; }
    public static WitScript Empty { get; }
    public int PushCount { get; }
    public WitScript(string script);
    public WitScript(Byte[][] script, bool unsafe);
    public WitScript(IEnumerable`1<Byte[]> script, bool unsafe);
    public WitScript(Op[] ops);
    public WitScript(Byte[] script);
    public WitScript(Script scriptSig);
    private static WitScript();
    [NullableContextAttribute("2")]
public static bool IsNullOrEmpty(WitScript witScript);
    public void WriteToStream(BitcoinStream stream);
    public static WitScript Load(BitcoinStream stream);
    private void ReadCore(BitcoinStream stream);
    private static Byte[] ReadPush(BitcoinStream stream);
    public Byte[] get_Item(int index);
    public IEnumerable`1<Byte[]> get_Pushes();
    public static WitScript get_Empty();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(WitScript item);
    [NullableContextAttribute("2")]
public static bool op_Equality(WitScript a, WitScript b);
    [NullableContextAttribute("2")]
public static bool op_Inequality(WitScript a, WitScript b);
    [NullableContextAttribute("2")]
public static WitScript op_Addition(WitScript a, WitScript b);
    [NullableContextAttribute("2")]
public static Script op_Implicit(WitScript witScript);
    public virtual int GetHashCode();
    public Byte[] ToBytes();
    private void Serialize(BitcoinStream stream);
    public int GetSerializedSize();
    public virtual string ToString();
    public Script ToScript();
    public int get_PushCount();
    public Byte[] GetUnsafePush(int i);
    public WitScript Clone();
    [NullableContextAttribute("2")]
[ObsoleteAttribute("Do not use this, it isn't possible to get a signer's address from a script without taking heuristic which can be gamed by a malicious actor")]
public IAddressableDestination GetSigner();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NBitcoin.WitScriptId : object {
    private uint256 v;
    [NullableAttribute("2")]
public ScriptId _HashForLookUp;
    public ScriptId HashForLookUp { get; }
    public Script ScriptPubKey { get; }
    public WitScriptId(Byte[] value);
    public WitScriptId(uint256 value);
    public WitScriptId(string value);
    public WitScriptId(Script script);
    public ScriptId get_HashForLookUp();
    public sealed virtual Script get_ScriptPubKey();
    public BitcoinWitScriptAddress GetAddress(Network network);
    private sealed virtual override BitcoinAddress NBitcoin.IAddressableDestination.GetAddress(Network network);
    public sealed virtual bool IsSupported(Network network);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
public static bool op_Equality(WitScriptId a, WitScriptId b);
    [NullableContextAttribute("2")]
public static bool op_Inequality(WitScriptId a, WitScriptId b);
    public virtual int GetHashCode();
    public Byte[] ToBytes();
    public virtual string ToString();
}
public enum NBitcoin.WordCount : Enum {
    public int value__;
    public static WordCount Twelve;
    public static WordCount Fifteen;
    public static WordCount Eighteen;
    public static WordCount TwentyOne;
    public static WordCount TwentyFour;
}
public class NBitcoin.Wordlist : object {
    private static Wordlist _Japanese;
    private static Wordlist _ChineseSimplified;
    private static Wordlist _ChineseTraditional;
    private static Wordlist _Spanish;
    private static Wordlist _English;
    private static Wordlist _French;
    private static Wordlist _PortugueseBrazil;
    private static Wordlist _Czech;
    private static Dictionary`2<string, Wordlist> _LoadedLists;
    [CompilerGeneratedAttribute]
private static IWordlistSource <WordlistSource>k__BackingField;
    private String[] _words;
    private string _Name;
    private char _Space;
    public static Wordlist Japanese { get; }
    public static Wordlist ChineseSimplified { get; }
    public static Wordlist ChineseTraditional { get; }
    public static Wordlist Spanish { get; }
    public static Wordlist English { get; }
    public static Wordlist French { get; }
    public static Wordlist PortugueseBrazil { get; }
    public static Wordlist Czech { get; }
    public static IWordlistSource WordlistSource { get; public set; }
    public string Name { get; }
    public char Space { get; }
    public int WordCount { get; }
    private static Wordlist();
    public Wordlist(String[] words, char space, string name);
    public static Wordlist get_Japanese();
    public static Wordlist get_ChineseSimplified();
    public static Wordlist get_ChineseTraditional();
    public static Wordlist get_Spanish();
    public static Wordlist get_English();
    public static Wordlist get_French();
    public static Wordlist get_PortugueseBrazil();
    public static Wordlist get_Czech();
    public static Task`1<Wordlist> LoadWordList(Language language);
    internal static string GetLanguageFileName(Language language);
    [AsyncStateMachineAttribute("NBitcoin.Wordlist/<LoadWordList>d__28")]
public static Task`1<Wordlist> LoadWordList(string name);
    [CompilerGeneratedAttribute]
public static IWordlistSource get_WordlistSource();
    [CompilerGeneratedAttribute]
public static void set_WordlistSource(IWordlistSource value);
    public string get_Name();
    public char get_Space();
    public bool WordExists(string word, Int32& index);
    public string GetWordAtIndex(int index);
    public int get_WordCount();
    public static Task`1<Wordlist> AutoDetectAsync(string sentence);
    public static Wordlist AutoDetect(string sentence);
    public static Language AutoDetectLanguage(String[] words);
    public static Language AutoDetectLanguage(string sentence);
    public String[] Split(string mnemonic);
    public virtual string ToString();
    public ReadOnlyCollection`1<string> GetWords();
    public String[] GetWords(Int32[] indices);
    public string GetSentence(Int32[] indices);
    public Int32[] ToIndices(String[] words);
    public Int32[] ToIndices(string sentence);
    public static BitArray ToBits(Int32[] values);
    public static Int32[] ToIntegers(BitArray bits);
    public BitArray ToBits(string sentence);
    public String[] GetWords(string sentence);
    [CompilerGeneratedAttribute]
private string <GetWords>b__52_0(int i);
    [CompilerGeneratedAttribute]
private string <GetWords>b__59_0(int i);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
public static class System.Web.NBitcoin.HttpUtility : object {
    public static string UrlDecode(string str);
    private static void WriteCharBytes(IList buf, char ch, Encoding e);
    public static string UrlDecode(string s, Encoding e);
    private static int GetInt(byte b);
    private static int GetChar(string str, int offset, int length);
    public static string UrlEncode(string str);
    public static string UrlEncode(string s, Encoding Enc);
    public static Byte[] UrlEncodeToBytes(Byte[] bytes, int offset, int count);
}
internal class System.Web.Util.HttpEncoder : object {
    private static Char[] hexChars;
    private static object entitiesLock;
    private static HttpEncoder defaultEncoder;
    private static HttpEncoder currentEncoder;
    private static HttpEncoder();
    internal static Byte[] UrlEncodeToBytes(Byte[] bytes, int offset, int count);
    internal static bool NotEncoded(char c);
    internal static void UrlEncodeChar(char c, Stream result, bool isUnicode);
}
