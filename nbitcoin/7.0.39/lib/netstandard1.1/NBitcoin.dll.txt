[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
internal class NBitcoin.ActionDisposable : object {
    private Action onEnter;
    private Action onLeave;
    public ActionDisposable(Action onEnter, Action onLeave);
    public sealed virtual void Dispose();
}
public abstract class NBitcoin.Base58Data : object {
    protected Byte[] vchData;
    protected Byte[] vchVersion;
    protected string wifData;
    private Network _Network;
    public Network Network { get; }
    protected bool IsValid { get; }
    public Base58Type Type { get; }
    protected Base58Data(Byte[] rawBytes, Network network);
    public sealed virtual Network get_Network();
    protected void Init(string base64, Network expectedNetwork);
    private void SetString(string psz);
    private void SetData(Byte[] vchData);
    protected virtual bool get_IsValid();
    public abstract virtual Base58Type get_Type();
    public string ToWif();
    public Byte[] ToBytes();
    public virtual string ToString();
    public virtual bool Equals(object obj);
    public static bool op_Equality(Base58Data a, Base58Data b);
    public static bool op_Inequality(Base58Data a, Base58Data b);
    public virtual int GetHashCode();
}
public enum NBitcoin.Base58Type : Enum {
    public int value__;
    public static Base58Type PUBKEY_ADDRESS;
    public static Base58Type SCRIPT_ADDRESS;
    public static Base58Type SECRET_KEY;
    public static Base58Type EXT_PUBLIC_KEY;
    public static Base58Type EXT_SECRET_KEY;
    public static Base58Type ENCRYPTED_SECRET_KEY_EC;
    public static Base58Type ENCRYPTED_SECRET_KEY_NO_EC;
    public static Base58Type PASSPHRASE_CODE;
    public static Base58Type CONFIRMATION_CODE;
    public static Base58Type ASSET_ID;
    public static Base58Type COLORED_ADDRESS;
    public static Base58Type BLINDED_ADDRESS;
    public static Base58Type MAX_BASE58_TYPES;
}
public enum NBitcoin.Bech32Type : Enum {
    public int value__;
    public static Bech32Type WITNESS_PUBKEY_ADDRESS;
    public static Bech32Type WITNESS_SCRIPT_ADDRESS;
    public static Bech32Type TAPROOT_ADDRESS;
    public static Bech32Type BLINDED_ADDRESS;
}
public enum NBitcoin.BIP9Deployments : Enum {
    public int value__;
    public static BIP9Deployments TestDummy;
    public static BIP9Deployments CSV;
    public static BIP9Deployments Segwit;
}
public class NBitcoin.BIP9DeploymentsParameters : object {
    public static long AlwaysActive;
    [CompilerGeneratedAttribute]
private int <Bit>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <StartTime>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <Timeout>k__BackingField;
    public int Bit { get; private set; }
    public DateTimeOffset StartTime { get; private set; }
    public DateTimeOffset Timeout { get; private set; }
    public BIP9DeploymentsParameters(int bit, DateTimeOffset startTime, DateTimeOffset timeout);
    public BIP9DeploymentsParameters(int bit, long startTime, long timeout);
    [CompilerGeneratedAttribute]
public int get_Bit();
    [CompilerGeneratedAttribute]
private void set_Bit(int value);
    [CompilerGeneratedAttribute]
public DateTimeOffset get_StartTime();
    [CompilerGeneratedAttribute]
private void set_StartTime(DateTimeOffset value);
    [CompilerGeneratedAttribute]
public DateTimeOffset get_Timeout();
    [CompilerGeneratedAttribute]
private void set_Timeout(DateTimeOffset value);
}
public class NBitcoin.Bitcoin : object {
    [CompilerGeneratedAttribute]
private static Bitcoin <Instance>k__BackingField;
    private ConcurrentDictionary`2<ChainName, Network> _Networks;
    private static ChainName MutinynetName;
    private static ChainName SignetName;
    public static Bitcoin Instance { get; }
    public string CryptoCode { get; }
    public Network Mainnet { get; }
    public Network Mutinynet { get; }
    public Network Regtest { get; }
    public Network Signet { get; }
    public Network Testnet { get; }
    private static Bitcoin();
    internal void Init();
    [CompilerGeneratedAttribute]
public static Bitcoin get_Instance();
    public sealed virtual string get_CryptoCode();
    public sealed virtual Network GetNetwork(ChainName chainName);
    public sealed virtual Network get_Mainnet();
    private Network CreateMainnet();
    private static void assert(bool v);
    public Network get_Mutinynet();
    private Network CreateMutinyNet();
    private static UInt32 GetMutinynetMagic();
    public sealed virtual Network get_Regtest();
    private Network CreateRegtest();
    public Network get_Signet();
    private Network CreateSignet();
    private static UInt32 GetSignetMagic();
    public sealed virtual Network get_Testnet();
    private Network CreateTestnet();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class NBitcoin.BitcoinAddress : object {
    protected string _Str;
    [NullableAttribute("2")]
private Script _ScriptPubKey;
    private Network _Network;
    public Script ScriptPubKey { get; }
    public Network Network { get; }
    protected internal BitcoinAddress(string str, Network network);
    public static BitcoinAddress Create(string str, Network expectedNetwork);
    public sealed virtual Script get_ScriptPubKey();
    protected abstract virtual Script GeneratePaymentScript();
    public BitcoinColoredAddress ToColoredAddress();
    public sealed virtual Network get_Network();
    public virtual string ToString();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
public static bool op_Equality(BitcoinAddress a, BitcoinAddress b);
    [NullableContextAttribute("2")]
public static bool op_Inequality(BitcoinAddress a, BitcoinAddress b);
    public virtual int GetHashCode();
}
public class NBitcoin.BitcoinColoredAddress : Base58Data {
    private BitcoinAddress _Address;
    protected bool IsValid { get; }
    public BitcoinAddress Address { get; }
    public Base58Type Type { get; }
    public Script ScriptPubKey { get; }
    public BitcoinColoredAddress(string base58, Network expectedNetwork);
    public BitcoinColoredAddress(BitcoinAddress address);
    private static Byte[] Build(BitcoinAddress address);
    protected virtual bool get_IsValid();
    public BitcoinAddress get_Address();
    public virtual Base58Type get_Type();
    public sealed virtual Script get_ScriptPubKey();
    public static string GetWrappedBase58(string base58, Network network);
}
public class NBitcoin.BitcoinConfirmationCode : Base58Data {
    private Byte[] _AddressHash;
    private Byte[] _OwnerEntropy;
    private LotSequence _LotSequence;
    private Byte[] _EncryptedPointB;
    public Byte[] AddressHash { get; }
    public bool IsCompressed { get; }
    public Byte[] OwnerEntropy { get; }
    public LotSequence LotSequence { get; }
    private Byte[] EncryptedPointB { get; }
    public Base58Type Type { get; }
    protected bool IsValid { get; }
    public BitcoinConfirmationCode(string wif, Network expectedNetwork);
    public BitcoinConfirmationCode(Byte[] rawBytes, Network network);
    public Byte[] get_AddressHash();
    public bool get_IsCompressed();
    public Byte[] get_OwnerEntropy();
    public LotSequence get_LotSequence();
    private Byte[] get_EncryptedPointB();
    public virtual Base58Type get_Type();
    protected virtual bool get_IsValid();
    public bool Check(string passphrase, BitcoinAddress expectedAddress);
}
public abstract class NBitcoin.BitcoinEncryptedSecret : Base58Data {
    private Byte[] _AddressHash;
    private Byte[] _LastHalf;
    protected int ValidLength;
    public bool EcMultiply { get; }
    public Byte[] AddressHash { get; }
    public bool IsCompressed { get; }
    public Byte[] EncryptedHalf2 { get; }
    protected bool IsValid { get; }
    protected BitcoinEncryptedSecret(Byte[] raw, Network network);
    protected BitcoinEncryptedSecret(string wif, Network expectedNetwork);
    public static BitcoinEncryptedSecret Create(string wif, Network expectedNetwork);
    public static BitcoinEncryptedSecretNoEC Generate(Key key, string password, Network network);
    public bool get_EcMultiply();
    public Byte[] get_AddressHash();
    public bool get_IsCompressed();
    public Byte[] get_EncryptedHalf2();
    protected virtual bool get_IsValid();
    public Key GetKey(string password);
    public abstract virtual bool TryGetKey(string password, Key& key);
    public BitcoinSecret GetSecret(string password);
    internal static PaddedBufferedBlockCipher CreateAES256(bool encryption, Byte[] key);
    internal static Byte[] EncryptKey(Byte[] key, Byte[] derived);
    private static Byte[] EncryptKey(Byte[] keyhalf1, Byte[] keyhalf2, Byte[] derived);
    internal static Byte[] DecryptKey(Byte[] encrypted, Byte[] derived);
    internal static Byte[] EncryptSeed(Byte[] seedb, Byte[] derived);
    internal static Byte[] DecryptSeed(Byte[] encrypted, Byte[] derived);
}
public class NBitcoin.BitcoinEncryptedSecretEC : BitcoinEncryptedSecret {
    private Byte[] _OwnerEntropy;
    private LotSequence _LotSequence;
    private Byte[] _EncryptedHalfHalf1;
    private Byte[] _PartialEncrypted;
    public Byte[] OwnerEntropy { get; }
    public LotSequence LotSequence { get; }
    public Byte[] EncryptedHalfHalf1 { get; }
    public Byte[] PartialEncrypted { get; }
    public Base58Type Type { get; }
    public BitcoinEncryptedSecretEC(string wif, Network expectedNetwork);
    public BitcoinEncryptedSecretEC(Byte[] raw, Network network);
    public Byte[] get_OwnerEntropy();
    public LotSequence get_LotSequence();
    public Byte[] get_EncryptedHalfHalf1();
    public Byte[] get_PartialEncrypted();
    public virtual Base58Type get_Type();
    public virtual bool TryGetKey(string password, Key& key);
    internal static Byte[] HashAddress(BitcoinAddress address);
    internal static Byte[] CalculatePassPoint(Byte[] passfactor);
    internal static Byte[] CalculatePassFactor(string password, LotSequence lotSequence, Byte[] ownerEntropy);
    internal static Byte[] CalculateDecryptionKey(Byte[] Passpoint, Byte[] addresshash, Byte[] ownerEntropy);
}
public class NBitcoin.BitcoinEncryptedSecretNoEC : BitcoinEncryptedSecret {
    private Byte[] _FirstHalf;
    private Byte[] _Encrypted;
    public Byte[] EncryptedHalf1 { get; }
    public Byte[] Encrypted { get; }
    public Base58Type Type { get; }
    public BitcoinEncryptedSecretNoEC(string wif, Network expectedNetwork);
    public BitcoinEncryptedSecretNoEC(Byte[] raw, Network network);
    public BitcoinEncryptedSecretNoEC(Key key, string password, Network network);
    private static string GenerateWif(Key key, string password, Network network);
    public Byte[] get_EncryptedHalf1();
    public Byte[] get_Encrypted();
    public virtual Base58Type get_Type();
    public virtual bool TryGetKey(string password, Key& key);
}
public class NBitcoin.BitcoinExtKey : BitcoinExtKeyBase {
    private ExtKey _Key;
    protected bool IsValid { get; }
    public ExtKey ExtKey { get; }
    public Base58Type Type { get; }
    public Script ScriptPubKey { get; }
    public Key PrivateKey { get; }
    public BitcoinExtKey(string base58, Network expectedNetwork);
    public BitcoinExtKey(ExtKey key, Network network);
    public BitcoinExtKey(BitcoinExtPubKey bitcoinExtPubKey, Key key);
    protected virtual bool get_IsValid();
    public ExtKey get_ExtKey();
    public virtual Base58Type get_Type();
    public virtual Script get_ScriptPubKey();
    public BitcoinExtPubKey Neuter();
    public BitcoinExtKey Derive(UInt32 index);
    private sealed virtual override IHDKey NBitcoin.IHDKey.Derive(KeyPath keyPath);
    public BitcoinExtKey Derive(KeyPath keyPath);
    public ExtKey Derive(RootedKeyPath rootedKeyPath);
    public sealed virtual PubKey GetPublicKey();
    private sealed virtual override bool NBitcoin.IHDKey.CanDeriveHardenedPath();
    public sealed virtual Key get_PrivateKey();
    public static ExtKey op_Implicit(BitcoinExtKey key);
}
public abstract class NBitcoin.BitcoinExtKeyBase : Base58Data {
    public Script ScriptPubKey { get; }
    protected BitcoinExtKeyBase(Byte[] bytes, Network network);
    public abstract virtual Script get_ScriptPubKey();
}
public class NBitcoin.BitcoinExtPubKey : BitcoinExtKeyBase {
    private ExtPubKey _PubKey;
    public ExtPubKey ExtPubKey { get; }
    protected bool IsValid { get; }
    public Base58Type Type { get; }
    public Script ScriptPubKey { get; }
    public BitcoinExtPubKey(string base58, Network expectedNetwork);
    public BitcoinExtPubKey(ExtPubKey key, Network network);
    public ExtPubKey get_ExtPubKey();
    protected virtual bool get_IsValid();
    public virtual Base58Type get_Type();
    public virtual Script get_ScriptPubKey();
    public static ExtPubKey op_Implicit(BitcoinExtPubKey key);
    private sealed virtual override IHDKey NBitcoin.IHDKey.Derive(KeyPath keyPath);
    public BitcoinExtPubKey Derive(UInt32 index);
    public BitcoinExtPubKey Derive(KeyPath keyPath);
    public sealed virtual PubKey GetPublicKey();
    private sealed virtual override bool NBitcoin.IHDKey.CanDeriveHardenedPath();
}
internal class NBitcoin.BitcoinFormatter : object {
    public static BitcoinFormatter Formatter;
    private static BitcoinFormatter();
    public sealed virtual object GetFormat(Type formatType);
    public sealed virtual string Format(string format, object arg, IFormatProvider formatProvider);
}
public class NBitcoin.BitcoinPassphraseCode : Base58Data {
    private LotSequence _LotSequence;
    private Byte[] _OwnerEntropy;
    private Byte[] _Passpoint;
    public LotSequence LotSequence { get; }
    public Byte[] OwnerEntropy { get; }
    public Byte[] Passpoint { get; }
    protected bool IsValid { get; }
    public Base58Type Type { get; }
    public BitcoinPassphraseCode(string passphrase, Network network, LotSequence lotsequence, Byte[] ownersalt);
    public BitcoinPassphraseCode(string wif, Network expectedNetwork);
    private static string GenerateWif(string passphrase, Network network, LotSequence lotsequence, Byte[] ownersalt);
    public LotSequence get_LotSequence();
    public EncryptedKeyResult GenerateEncryptedSecret(bool isCompressed, Byte[] seedb);
    public Byte[] get_OwnerEntropy();
    public Byte[] get_Passpoint();
    protected virtual bool get_IsValid();
    public virtual Base58Type get_Type();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NBitcoin.BitcoinPubKeyAddress : BitcoinAddress {
    private KeyId _KeyId;
    public KeyId Hash { get; }
    public Base58Type Type { get; }
    public BitcoinPubKeyAddress(string base58, Network expectedNetwork);
    public BitcoinPubKeyAddress(string str, KeyId id, Network expectedNetwork);
    public BitcoinPubKeyAddress(KeyId keyId, Network network);
    private static string Validate(string base58, Network expectedNetwork);
    private static string NotNull(KeyId keyId);
    public KeyId get_Hash();
    public sealed virtual Base58Type get_Type();
    protected virtual Script GeneratePaymentScript();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NBitcoin.BitcoinScriptAddress : BitcoinAddress {
    private ScriptId _Hash;
    public ScriptId Hash { get; }
    public Base58Type Type { get; }
    public BitcoinScriptAddress(string base58, Network expectedNetwork);
    public BitcoinScriptAddress(string str, ScriptId id, Network expectedNetwork);
    public BitcoinScriptAddress(ScriptId scriptId, Network network);
    private static string Validate(string base58, Network expectedNetwork);
    private static string NotNull(ScriptId scriptId);
    public ScriptId get_Hash();
    public sealed virtual Base58Type get_Type();
    protected virtual Script GeneratePaymentScript();
}
public class NBitcoin.BitcoinSecret : Base58Data {
    private Key _Key;
    public KeyId PubKeyHash { get; }
    public PubKey PubKey { get; }
    public Key PrivateKey { get; }
    protected bool IsValid { get; }
    public bool IsCompressed { get; }
    public Base58Type Type { get; }
    private Script NBitcoin.IDestination.ScriptPubKey { get; }
    public BitcoinSecret(Key key, Network network);
    public BitcoinSecret(string base58, Network expectedNetwork);
    private static Byte[] ToBytes(Key key);
    public BitcoinAddress GetAddress(ScriptPubKeyType type);
    public virtual KeyId get_PubKeyHash();
    public PubKey get_PubKey();
    public sealed virtual Key get_PrivateKey();
    protected virtual bool get_IsValid();
    public BitcoinEncryptedSecret Encrypt(string password);
    public BitcoinSecret Copy(Nullable`1<bool> compressed);
    public bool get_IsCompressed();
    public virtual Base58Type get_Type();
    private sealed virtual override Script NBitcoin.IDestination.get_ScriptPubKey();
}
[ExtensionAttribute]
public static class NBitcoin.BitcoinSerializableExtensions : object {
    [ExtensionAttribute]
public static void ReadWrite(IBitcoinSerializable serializable, Stream stream, bool serializing, Network network, Nullable`1<UInt32> version);
    [ExtensionAttribute]
public static void ReadWrite(IBitcoinSerializable serializable, Stream stream, bool serializing, ConsensusFactory consensusFactory, Nullable`1<UInt32> version);
    [ExtensionAttribute]
public static int GetSerializedSize(IBitcoinSerializable serializable, Nullable`1<UInt32> version, SerializationType serializationType);
    [ExtensionAttribute]
public static int GetSerializedSize(IBitcoinSerializable serializable, TransactionOptions options);
    [ExtensionAttribute]
public static int GetSerializedSize(IBitcoinSerializable serializable, Nullable`1<UInt32> version);
    [ExtensionAttribute]
public static void ReadWrite(IBitcoinSerializable serializable, Byte[] bytes, Network network, Nullable`1<UInt32> version);
    [ExtensionAttribute]
public static void ReadWrite(IBitcoinSerializable serializable, Byte[] bytes, ConsensusFactory consensusFactory, Nullable`1<UInt32> version);
    [ExtensionAttribute]
public static void FromBytes(IBitcoinSerializable serializable, Byte[] bytes, Nullable`1<UInt32> version);
    [ExtensionAttribute]
public static T Clone(T serializable, Nullable`1<UInt32> version);
    [ExtensionAttribute]
public static Byte[] ToBytes(IBitcoinSerializable serializable, Nullable`1<UInt32> version);
    [ExtensionAttribute]
public static Byte[] ToArrayEfficient(MemoryStream ms);
}
public class NBitcoin.BitcoinStream : object {
    private int _MaxArraySize;
    internal static MethodInfo _ReadWriteTyped;
    private Stream _Inner;
    private bool _Serializing;
    private ConsensusFactory _ConsensusFactory;
    private PerformanceCounter _Counter;
    [CompilerGeneratedAttribute]
private bool <IsBigEndian>k__BackingField;
    private Nullable`1<UInt32> _ProtocolVersion;
    private ProtocolCapabilities _ProtocolCapabilities;
    private TransactionOptions _TransactionSupportedOptions;
    [CompilerGeneratedAttribute]
private SerializationType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private CancellationToken <ReadCancellationToken>k__BackingField;
    private MutableUint256 _MutableUint256;
    private MutableUint160 _MutableUint160;
    public int MaxArraySize { get; public set; }
    public Stream Inner { get; }
    public bool Serializing { get; }
    public ConsensusFactory ConsensusFactory { get; public set; }
    public PerformanceCounter Counter { get; }
    public bool IsBigEndian { get; public set; }
    public Nullable`1<UInt32> ProtocolVersion { get; public set; }
    public ProtocolCapabilities ProtocolCapabilities { get; }
    public TransactionOptions TransactionOptions { get; public set; }
    public SerializationType Type { get; public set; }
    public CancellationToken ReadCancellationToken { get; public set; }
    private static BitcoinStream();
    public BitcoinStream(Stream inner, bool serializing);
    public BitcoinStream(Byte[] bytes, ConsensusFactory consensusFactory);
    public BitcoinStream(Byte[] bytes);
    public BitcoinStream(Byte[] bytes, int offset, int length);
    public int get_MaxArraySize();
    public void set_MaxArraySize(int value);
    public Stream get_Inner();
    public bool get_Serializing();
    public Script ReadWrite(Script data);
    public void ReadWrite(Script& script);
    public T ReadWrite(T data);
    public ConsensusFactory get_ConsensusFactory();
    public void set_ConsensusFactory(ConsensusFactory value);
    public void ReadWriteAsVarString(Byte[]& bytes);
    public void ReadWrite(Type type, Object& obj);
    public void ReadWrite(Byte& data);
    public byte ReadWrite(byte data);
    public void ReadWrite(Boolean& data);
    public void ReadWriteStruct(T& data);
    public void ReadWriteStruct(T data);
    public void ReadWrite(T& data);
    public void ReadWrite(List`1& list);
    public void ReadWrite(TxInList& list);
    public void ReadWrite(TxOutList& list);
    public void ReadWrite(Byte[] arr);
    public void ReadWrite(Byte[] arr, int offset, int count);
    public void ReadWrite(T[]& arr);
    private void ReadWriteNumber(Int64& value, int size);
    private void ReadWriteNumber(UInt64& value, int size);
    internal void ReadWriteBytes(Byte[] data, int offset, int count);
    public PerformanceCounter get_Counter();
    private void ReadWriteByte(Byte& data);
    [CompilerGeneratedAttribute]
public bool get_IsBigEndian();
    [CompilerGeneratedAttribute]
public void set_IsBigEndian(bool value);
    public IDisposable BigEndianScope();
    public Nullable`1<UInt32> get_ProtocolVersion();
    public void set_ProtocolVersion(Nullable`1<UInt32> value);
    public ProtocolCapabilities get_ProtocolCapabilities();
    public TransactionOptions get_TransactionOptions();
    public void set_TransactionOptions(TransactionOptions value);
    public IDisposable ProtocolVersionScope(Nullable`1<UInt32> version);
    public void CopyParameters(BitcoinStream from);
    [CompilerGeneratedAttribute]
public SerializationType get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(SerializationType value);
    public IDisposable SerializationTypeScope(SerializationType value);
    public IDisposable ConsensusFactoryScope(ConsensusFactory consensusFactory);
    [CompilerGeneratedAttribute]
public CancellationToken get_ReadCancellationToken();
    [CompilerGeneratedAttribute]
public void set_ReadCancellationToken(CancellationToken value);
    public void ReadWriteAsVarInt(UInt32& val);
    public void ReadWriteAsVarInt(UInt64& val);
    public void ReadWriteAsCompactVarInt(UInt32& val);
    public void ReadWriteAsCompactVarInt(UInt64& val);
    private void ReadWriteArray(T[]& data);
    private void ReadWriteArray(UInt64[]& data);
    private void ReadWriteArray(UInt16[]& data);
    private void ReadWriteArray(UInt32[]& data);
    public void ReadWrite(UInt64[]& data);
    public void ReadWrite(UInt16[]& data);
    public void ReadWrite(UInt32[]& data);
    public void ReadWrite(uint256& value);
    public void ReadWrite(uint256 value);
    public void ReadWrite(List`1& value);
    public void ReadWrite(uint160& value);
    public void ReadWrite(uint160 value);
    public void ReadWrite(List`1& value);
    public void ReadWrite(UInt64& data);
    public ulong ReadWrite(ulong data);
    public void ReadWrite(UInt16& data);
    public ushort ReadWrite(ushort data);
    public void ReadWrite(UInt32& data);
    public UInt32 ReadWrite(UInt32 data);
    public void ReadWrite(Int64& data);
    public long ReadWrite(long data);
    public void ReadWrite(Int16& data);
    public short ReadWrite(short data);
    public void ReadWrite(Int32& data);
    public int ReadWrite(int data);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NBitcoin.BitcoinWitPubKeyAddress : BitcoinAddress {
    private WitKeyId _Hash;
    public WitKeyId Hash { get; }
    public Bech32Type Type { get; }
    public BitcoinWitPubKeyAddress(string bech32, Network expectedNetwork);
    internal BitcoinWitPubKeyAddress(string str, Byte[] key, Network network);
    public BitcoinWitPubKeyAddress(WitKeyId segwitKeyId, Network network);
    private static string Validate(string bech32, Network expectedNetwork);
    private static string NotNull(WitKeyId segwitKeyId);
    public WitKeyId get_Hash();
    protected virtual Script GeneratePaymentScript();
    public sealed virtual Bech32Type get_Type();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NBitcoin.BitcoinWitScriptAddress : BitcoinAddress {
    private WitScriptId _Hash;
    public WitScriptId Hash { get; }
    public Bech32Type Type { get; }
    public BitcoinWitScriptAddress(string bech32, Network expectedNetwork);
    internal BitcoinWitScriptAddress(string str, Byte[] keyId, Network network);
    public BitcoinWitScriptAddress(WitScriptId segwitScriptId, Network network);
    private static string Validate(string bech32, Network expectedNetwork);
    private static string NotNull(WitScriptId segwitScriptId);
    public WitScriptId get_Hash();
    protected virtual Script GeneratePaymentScript();
    public sealed virtual Bech32Type get_Type();
}
internal class NBitcoin.BitReader : object {
    private BitArray array;
    [CompilerGeneratedAttribute]
private int <Position>k__BackingField;
    public int Position { get; public set; }
    public int Count { get; }
    public BitReader(BitArray array);
    public bool Read();
    [CompilerGeneratedAttribute]
public int get_Position();
    [CompilerGeneratedAttribute]
public void set_Position(int value);
    public int get_Count();
}
internal class NBitcoin.BitStream : object {
    private Byte[] _buffer;
    private int _writePos;
    private int _readPos;
    private int _lengthInBits;
    public BitStream(Byte[] buffer);
    public void WriteBit(bool bit);
    public void WriteBits(ulong data, byte count);
    public void WriteByte(byte b);
    public bool TryReadBit(Boolean& bit);
    public bool TryReadBits(int count, UInt64& bits);
    public bool TryReadByte(Byte& b);
    public Byte[] ToByteArray();
    private void EnsureCapacity();
}
internal class NBitcoin.BitWriter : object {
    private List`1<bool> values;
    private int _Position;
    public int Count { get; }
    public int Position { get; public set; }
    public int get_Count();
    public void Write(bool value);
    internal void Write(Byte[] bytes);
    public void Write(Byte[] bytes, int bitCount);
    public Byte[] ToBytes();
    private static Byte[] ToByteArray(BitArray bits);
    public BitArray ToBitArray();
    public Int32[] ToIntegers();
    private static Byte[] SwapEndianBytes(Byte[] bytes);
    public void Write(UInt32 value, int bitCount);
    public int get_Position();
    public void set_Position(int value);
    internal void Write(BitReader reader, int bitCount);
    public void Write(BitArray bitArray);
    public void Write(BitArray bitArray, int bitCount);
    public void Write(BitReader reader);
    public BitReader ToReader();
    public virtual string ToString();
}
public class NBitcoin.Block : object {
    private BlockHeader header;
    public static UInt32 MAX_BLOCK_SIZE;
    private List`1<Transaction> vtx;
    public List`1<Transaction> Transactions { get; public set; }
    public BlockHeader Header { get; public set; }
    [ObsoleteAttribute("Should use ConsensusFactories")]
public Block(BlockHeader blockHeader);
    public List`1<Transaction> get_Transactions();
    public void set_Transactions(List`1<Transaction> value);
    public MerkleNode GetMerkleRoot();
    public virtual void ReadWrite(BitcoinStream stream);
    public Nullable`1<int> GetCoinbaseHeight();
    private void SetNull();
    public BlockHeader get_Header();
    public void set_Header(BlockHeader value);
    public uint256 GetHash();
    public Transaction AddTransaction(Transaction tx);
    public Block WithOptions(TransactionOptions options);
    public virtual ConsensusFactory GetConsensusFactory();
    public void UpdateMerkleRoot();
    public bool Check();
    public bool CheckProofOfWork();
    public bool CheckMerkleRoot();
    public Block CreateNextBlockWithCoinbase(BitcoinAddress address, int height);
    public Block CreateNextBlockWithCoinbase(BitcoinAddress address, int height, DateTimeOffset now);
    public int GetWeight();
    public Block CreateNextBlockWithCoinbase(PubKey pubkey, Money value, DateTimeOffset now, ConsensusFactory consensusFactory);
    public Block CreateNextBlockWithCoinbase(PubKey pubkey, Money value, ConsensusFactory consensusFactory);
    public static Block Parse(string hex, Network network);
    public static Block Parse(string hex, Consensus consensus);
    public static Block Parse(string hex, ConsensusFactory consensusFactory);
    public static Block Load(Byte[] hex, Network network);
    public static Block Load(Byte[] hex, Consensus consensus);
    public static Block Load(Byte[] hex, ConsensusFactory consensusFactory);
    public MerkleBlock Filter(uint256[] txIds);
    public MerkleBlock Filter(BloomFilter filter);
}
public class NBitcoin.BlockHeader : object {
    internal static int Size;
    private static int CURRENT_VERSION;
    protected uint256 hashPrevBlock;
    protected uint256 hashMerkleRoot;
    protected UInt32 nTime;
    protected UInt32 nBits;
    protected int nVersion;
    protected UInt32 nNonce;
    private uint256[] _Hashes;
    private static BigInteger Pow256;
    public uint256 HashPrevBlock { get; public set; }
    public Target Bits { get; public set; }
    public int Version { get; public set; }
    public UInt32 Nonce { get; public set; }
    public uint256 HashMerkleRoot { get; public set; }
    public bool IsNull { get; }
    public DateTimeOffset BlockTime { get; public set; }
    public BlockHeader(string hex, Network network);
    public BlockHeader(string hex, Consensus consensus);
    public BlockHeader(string hex, ConsensusFactory consensusFactory);
    public BlockHeader(Byte[] data, Network network);
    public BlockHeader(Byte[] data, Consensus consensus);
    public BlockHeader(Byte[] data, ConsensusFactory consensusFactory);
    private static BlockHeader();
    public static BlockHeader Parse(string hex, Network network);
    public static BlockHeader Parse(string hex, Consensus consensus);
    public static BlockHeader Parse(string hex, ConsensusFactory consensusFactory);
    public uint256 get_HashPrevBlock();
    public void set_HashPrevBlock(uint256 value);
    public Target get_Bits();
    public void set_Bits(Target value);
    public int get_Version();
    public void set_Version(int value);
    public UInt32 get_Nonce();
    public void set_Nonce(UInt32 value);
    public uint256 get_HashMerkleRoot();
    public void set_HashMerkleRoot(uint256 value);
    protected internal virtual void SetNull();
    public virtual bool get_IsNull();
    public virtual void ReadWrite(BitcoinStream stream);
    public virtual uint256 GetPoWHash();
    public uint256 GetHash();
    protected virtual HashStreamBase CreateHashStream();
    public void PrecomputeHash(bool invalidateExisting, bool lazily);
    public DateTimeOffset get_BlockTime();
    public void set_BlockTime(DateTimeOffset value);
    public bool CheckProofOfWork();
    public virtual string ToString();
    public void UpdateTime(Network network, ChainedBlock prev);
    public void UpdateTime(Consensus consensus, ChainedBlock prev);
    public void UpdateTime(DateTimeOffset now, Consensus consensus, ChainedBlock prev);
    public void UpdateTime(DateTimeOffset now, Network network, ChainedBlock prev);
    public Target GetWorkRequired(Network network, ChainedBlock prev);
    public Target GetWorkRequired(Consensus consensus, ChainedBlock prev);
}
public class NBitcoin.BlockLocator : object {
    private List`1<uint256> vHave;
    public List`1<uint256> Blocks { get; public set; }
    public List`1<uint256> get_Blocks();
    public void set_Blocks(List`1<uint256> value);
    public sealed virtual void ReadWrite(BitcoinStream stream);
}
public class NBitcoin.BloomFilter : object {
    private static UInt32 MAX_BLOOM_FILTER_SIZE;
    private static UInt32 MAX_HASH_FUNCS;
    [DecimalConstantAttribute("28", "0", "260454100", "3151050610", "1131349103")]
private static decimal LN2SQUARED;
    [DecimalConstantAttribute("28", "0", "375755839", "2180329217", "2860148159")]
private static decimal LN2;
    private Byte[] vData;
    private UInt32 nHashFuncs;
    private UInt32 nTweak;
    private byte nFlags;
    private bool isFull;
    private bool isEmpty;
    public BloomFilter(int nElements, double nFPRate, BloomFlags nFlagsIn);
    public BloomFilter(int nElements, double nFPRate, UInt32 nTweakIn, BloomFlags nFlagsIn);
    private static BloomFilter();
    private UInt32 Hash(UInt32 nHashNum, Byte[] vDataToHash);
    public void Insert(Byte[] vKey);
    public bool Contains(Byte[] vKey);
    public bool Contains(OutPoint outPoint);
    public bool Contains(uint256 hash);
    public void Insert(OutPoint outPoint);
    public void Insert(uint256 value);
    public bool IsWithinSizeConstraints();
    public sealed virtual void ReadWrite(BitcoinStream stream);
    public bool IsRelevantAndUpdate(Transaction tx);
}
[FlagsAttribute]
public enum NBitcoin.BloomFlags : Enum {
    public byte value__;
    public static BloomFlags UPDATE_NONE;
    public static BloomFlags UPDATE_ALL;
    public static BloomFlags UPDATE_P2PUBKEY_ONLY;
    public static BloomFlags UPDATE_MASK;
}
internal abstract class NBitcoin.BouncyCastle.Asn1.Asn1Encodable : object {
    public static string Der;
    public static string Ber;
    public sealed virtual int GetHashCode();
    public sealed virtual bool Equals(object obj);
    public abstract virtual Asn1Object ToAsn1Object();
}
[DefaultMemberAttribute("Item")]
internal class NBitcoin.BouncyCastle.Asn1.Asn1EncodableVector : object {
    private IList v;
    public Asn1Encodable Item { get; }
    [ObsoleteAttribute("Use 'Count' property instead")]
public int Size { get; }
    public int Count { get; }
    public Asn1EncodableVector(Asn1Encodable[] v);
    public static Asn1EncodableVector FromEnumerable(IEnumerable e);
    public void Add(Asn1Encodable[] objs);
    public void AddOptional(Asn1Encodable[] objs);
    public Asn1Encodable get_Item(int index);
    [ObsoleteAttribute("Use 'object[index]' syntax instead")]
public Asn1Encodable Get(int index);
    public int get_Size();
    public int get_Count();
    public sealed virtual IEnumerator GetEnumerator();
}
internal class NBitcoin.BouncyCastle.Asn1.Asn1Exception : IOException {
    public Asn1Exception(string message);
    public Asn1Exception(string message, Exception exception);
}
internal abstract class NBitcoin.BouncyCastle.Asn1.Asn1Generator : object {
    private Stream _out;
    protected Stream Out { get; }
    protected Asn1Generator(Stream outStream);
    protected Stream get_Out();
    public abstract virtual void AddObject(Asn1Encodable obj);
    public abstract virtual Stream GetRawOutputStream();
    public abstract virtual void Close();
}
internal class NBitcoin.BouncyCastle.Asn1.Asn1InputStream : FilterStream {
    private int limit;
    private Byte[][] tmpBuffers;
    public Asn1InputStream(Stream inputStream);
    public Asn1InputStream(Stream inputStream, int limit);
    public Asn1InputStream(Byte[] input);
    internal static int FindLimit(Stream input);
    private Asn1Object BuildObject(int tag, int tagNo, int length);
    internal Asn1EncodableVector BuildEncodableVector();
    internal virtual Asn1EncodableVector BuildDerEncodableVector(DefiniteLengthInputStream dIn);
    internal virtual DerSequence CreateDerSequence(DefiniteLengthInputStream dIn);
    public Asn1Object ReadObject();
    internal static int ReadTagNumber(Stream s, int tag);
    internal static int ReadLength(Stream s, int limit);
    internal static Byte[] GetBuffer(DefiniteLengthInputStream defIn, Byte[][] tmpBuffers);
    internal static Asn1Object CreatePrimitiveDerObject(int tagNo, DefiniteLengthInputStream defIn, Byte[][] tmpBuffers);
}
internal abstract class NBitcoin.BouncyCastle.Asn1.Asn1Null : Asn1Object {
    public virtual string ToString();
}
internal abstract class NBitcoin.BouncyCastle.Asn1.Asn1Object : Asn1Encodable {
    public static Asn1Object FromByteArray(Byte[] data);
    public static Asn1Object FromStream(Stream inStr);
    public sealed virtual Asn1Object ToAsn1Object();
    internal abstract virtual void Encode(DerOutputStream derOut);
    protected abstract virtual bool Asn1Equals(Asn1Object asn1Object);
    protected abstract virtual int Asn1GetHashCode();
    internal bool CallAsn1Equals(Asn1Object obj);
    internal int CallAsn1GetHashCode();
}
internal abstract class NBitcoin.BouncyCastle.Asn1.Asn1OctetString : Asn1Object {
    internal Byte[] str;
    public Asn1OctetStringParser Parser { get; }
    internal Asn1OctetString(Byte[] str);
    public sealed virtual Stream GetOctetStream();
    public Asn1OctetStringParser get_Parser();
    public virtual Byte[] GetOctets();
    protected virtual int Asn1GetHashCode();
    protected virtual bool Asn1Equals(Asn1Object asn1Object);
}
internal interface NBitcoin.BouncyCastle.Asn1.Asn1OctetStringParser {
    public abstract virtual Stream GetOctetStream();
}
[DefaultMemberAttribute("Item")]
internal abstract class NBitcoin.BouncyCastle.Asn1.Asn1Sequence : Asn1Object {
    private IList seq;
    public Asn1SequenceParser Parser { get; }
    public Asn1Encodable Item { get; }
    [ObsoleteAttribute("Use 'Count' property instead")]
public int Size { get; }
    public int Count { get; }
    protected internal Asn1Sequence(int capacity);
    public static Asn1Sequence GetInstance(object obj);
    public virtual IEnumerator GetEnumerator();
    [ObsoleteAttribute("Use GetEnumerator() instead")]
public IEnumerator GetObjects();
    public virtual Asn1SequenceParser get_Parser();
    public virtual Asn1Encodable get_Item(int index);
    [ObsoleteAttribute("Use 'object[index]' syntax instead")]
public Asn1Encodable GetObjectAt(int index);
    public int get_Size();
    public virtual int get_Count();
    protected virtual int Asn1GetHashCode();
    protected virtual bool Asn1Equals(Asn1Object asn1Object);
    private Asn1Encodable GetCurrent(IEnumerator e);
    protected internal void AddObject(Asn1Encodable obj);
}
internal interface NBitcoin.BouncyCastle.Asn1.Asn1SequenceParser {
    public abstract virtual IAsn1Convertible ReadObject();
}
internal class NBitcoin.BouncyCastle.Asn1.Asn1Tags : object {
    public static int Boolean;
    public static int Integer;
    public static int BitString;
    public static int OctetString;
    public static int Null;
    public static int ObjectIdentifier;
    public static int External;
    public static int Enumerated;
    public static int Sequence;
    public static int SequenceOf;
    public static int Set;
    public static int SetOf;
    public static int NumericString;
    public static int PrintableString;
    public static int T61String;
    public static int VideotexString;
    public static int IA5String;
    public static int UtcTime;
    public static int GeneralizedTime;
    public static int GraphicString;
    public static int VisibleString;
    public static int GeneralString;
    public static int UniversalString;
    public static int BmpString;
    public static int Utf8String;
    public static int Constructed;
    public static int Application;
    public static int Tagged;
}
internal class NBitcoin.BouncyCastle.Asn1.DefiniteLengthInputStream : LimitedInputStream {
    private static Byte[] EmptyBytes;
    private int _originalLength;
    private int _remaining;
    internal int Remaining { get; }
    internal DefiniteLengthInputStream(Stream inStream, int length);
    private static DefiniteLengthInputStream();
    internal int get_Remaining();
    public virtual int ReadByte();
    public virtual int Read(Byte[] buf, int off, int len);
    internal void ReadAllIntoByteArray(Byte[] buf);
    internal Byte[] ToArray();
}
internal abstract class NBitcoin.BouncyCastle.Asn1.DerGenerator : Asn1Generator {
    private bool _tagged;
    private bool _isExplicit;
    private int _tagNo;
    protected DerGenerator(Stream outStream);
    protected DerGenerator(Stream outStream, int tagNo, bool isExplicit);
    private static void WriteLength(Stream outStr, int length);
    internal static void WriteDerEncoded(Stream outStream, int tag, Byte[] bytes);
    internal void WriteDerEncoded(int tag, Byte[] bytes);
    internal static void WriteDerEncoded(Stream outStr, int tag, Stream inStr);
}
internal class NBitcoin.BouncyCastle.Asn1.DerInteger : Asn1Object {
    private Byte[] bytes;
    public BigInteger Value { get; }
    public BigInteger PositiveValue { get; }
    public DerInteger(int value);
    public DerInteger(BigInteger value);
    public DerInteger(Byte[] bytes);
    public static DerInteger GetInstance(object obj);
    public BigInteger get_Value();
    public BigInteger get_PositiveValue();
    internal virtual void Encode(DerOutputStream derOut);
    protected virtual int Asn1GetHashCode();
    protected virtual bool Asn1Equals(Asn1Object asn1Object);
    public virtual string ToString();
}
internal class NBitcoin.BouncyCastle.Asn1.DerNull : Asn1Null {
    public static DerNull Instance;
    private Byte[] zeroBytes;
    protected internal DerNull(int dummy);
    private static DerNull();
    internal virtual void Encode(DerOutputStream derOut);
    protected virtual bool Asn1Equals(Asn1Object asn1Object);
    protected virtual int Asn1GetHashCode();
}
internal class NBitcoin.BouncyCastle.Asn1.DerObjectIdentifier : Asn1Object {
    private string identifier;
    private Byte[] body;
    private static long LONG_LIMIT;
    private static DerObjectIdentifier[] cache;
    public string Id { get; }
    public DerObjectIdentifier(string identifier);
    internal DerObjectIdentifier(DerObjectIdentifier oid, string branchID);
    internal DerObjectIdentifier(Byte[] bytes);
    private static DerObjectIdentifier();
    public string get_Id();
    public virtual DerObjectIdentifier Branch(string branchID);
    public virtual bool On(DerObjectIdentifier stem);
    private void WriteField(Stream outputStream, long fieldValue);
    private void WriteField(Stream outputStream, BigInteger fieldValue);
    protected virtual int Asn1GetHashCode();
    protected virtual bool Asn1Equals(Asn1Object asn1Object);
    public virtual string ToString();
    private static bool IsValidBranchID(string branchID, int start);
    private static bool IsValidIdentifier(string identifier);
    private static string MakeOidStringFromBytes(Byte[] bytes);
    internal virtual void Encode(DerOutputStream derOut);
}
internal class NBitcoin.BouncyCastle.Asn1.DerOctetString : Asn1OctetString {
    public DerOctetString(Byte[] str);
    internal virtual void Encode(DerOutputStream derOut);
    internal static void Encode(DerOutputStream derOut, Byte[] bytes, int offset, int length);
}
internal class NBitcoin.BouncyCastle.Asn1.DerOutputStream : FilterStream {
    public DerOutputStream(Stream os);
    private void WriteLength(int length);
    internal void WriteEncoded(int tag, Byte[] bytes);
    internal void WriteEncoded(int tag, byte first, Byte[] bytes);
    internal void WriteEncoded(int tag, Byte[] bytes, int offset, int length);
    internal void WriteTag(int flags, int tagNo);
    internal void WriteEncoded(int flags, int tagNo, Byte[] bytes);
    protected void WriteNull();
    [ObsoleteAttribute("Use version taking an Asn1Encodable arg instead")]
public virtual void WriteObject(object obj);
    public virtual void WriteObject(Asn1Encodable obj);
    public virtual void WriteObject(Asn1Object obj);
}
internal class NBitcoin.BouncyCastle.Asn1.DerSequence : Asn1Sequence {
    public static DerSequence Empty;
    public DerSequence(Asn1Encodable obj);
    public DerSequence(Asn1Encodable[] v);
    public DerSequence(Asn1EncodableVector v);
    private static DerSequence();
    public static DerSequence FromVector(Asn1EncodableVector v);
    internal virtual void Encode(DerOutputStream derOut);
}
internal class NBitcoin.BouncyCastle.Asn1.DerSequenceGenerator : DerGenerator {
    private MemoryStream _bOut;
    public DerSequenceGenerator(Stream outStream);
    public DerSequenceGenerator(Stream outStream, int tagNo, bool isExplicit);
    public virtual void AddObject(Asn1Encodable obj);
    public virtual Stream GetRawOutputStream();
    public virtual void Close();
}
internal interface NBitcoin.BouncyCastle.Asn1.IAsn1Convertible {
    public abstract virtual Asn1Object ToAsn1Object();
}
internal abstract class NBitcoin.BouncyCastle.Asn1.LimitedInputStream : BaseInputStream {
    protected Stream _in;
    private int _limit;
    internal LimitedInputStream(Stream inStream, int limit);
    internal virtual int GetRemaining();
    protected virtual void SetParentEofDetect(bool on);
}
internal class NBitcoin.BouncyCastle.Asn1.Sec.SecNamedCurves : object {
    private static IDictionary objIds;
    private static IDictionary curves;
    private static IDictionary names;
    private static SecNamedCurves();
    private static ECCurve ConfigureCurve(ECCurve curve);
    private static ECCurve ConfigureCurveGlv(ECCurve c, GlvTypeBParameters p);
    private static BigInteger FromHex(string hex);
    private static void DefineCurve(string name, DerObjectIdentifier oid, X9ECParametersHolder holder);
    public static X9ECParameters GetByName(string name);
    public static X9ECParameters GetByOid(DerObjectIdentifier oid);
    public static DerObjectIdentifier GetOid(string name);
    public static string GetName(DerObjectIdentifier oid);
}
internal abstract class NBitcoin.BouncyCastle.Asn1.Sec.SecObjectIdentifiers : object {
    public static DerObjectIdentifier EllipticCurve;
    public static DerObjectIdentifier SecT163k1;
    public static DerObjectIdentifier SecT163r1;
    public static DerObjectIdentifier SecT239k1;
    public static DerObjectIdentifier SecT113r1;
    public static DerObjectIdentifier SecT113r2;
    public static DerObjectIdentifier SecP112r1;
    public static DerObjectIdentifier SecP112r2;
    public static DerObjectIdentifier SecP160r1;
    public static DerObjectIdentifier SecP160k1;
    public static DerObjectIdentifier SecP256k1;
    public static DerObjectIdentifier SecT163r2;
    public static DerObjectIdentifier SecT283k1;
    public static DerObjectIdentifier SecT283r1;
    public static DerObjectIdentifier SecT131r1;
    public static DerObjectIdentifier SecT131r2;
    public static DerObjectIdentifier SecT193r1;
    public static DerObjectIdentifier SecT193r2;
    public static DerObjectIdentifier SecT233k1;
    public static DerObjectIdentifier SecT233r1;
    public static DerObjectIdentifier SecP128r1;
    public static DerObjectIdentifier SecP128r2;
    public static DerObjectIdentifier SecP160r2;
    public static DerObjectIdentifier SecP192k1;
    public static DerObjectIdentifier SecP224k1;
    public static DerObjectIdentifier SecP224r1;
    public static DerObjectIdentifier SecP384r1;
    public static DerObjectIdentifier SecP521r1;
    public static DerObjectIdentifier SecT409k1;
    public static DerObjectIdentifier SecT409r1;
    public static DerObjectIdentifier SecT571k1;
    public static DerObjectIdentifier SecT571r1;
    public static DerObjectIdentifier SecP192r1;
    public static DerObjectIdentifier SecP256r1;
    private static SecObjectIdentifiers();
}
internal class NBitcoin.BouncyCastle.Asn1.X9.X9Curve : Asn1Encodable {
    private ECCurve curve;
    private Byte[] seed;
    private DerObjectIdentifier fieldIdentifier;
    public ECCurve Curve { get; }
    public X9Curve(ECCurve curve);
    public X9Curve(ECCurve curve, Byte[] seed);
    public X9Curve(X9FieldID fieldID, Asn1Sequence seq);
    public ECCurve get_Curve();
    public Byte[] GetSeed();
    public virtual Asn1Object ToAsn1Object();
}
internal class NBitcoin.BouncyCastle.Asn1.X9.X9ECParameters : Asn1Encodable {
    private X9FieldID fieldID;
    private ECCurve curve;
    private X9ECPoint g;
    private BigInteger n;
    private BigInteger h;
    private Byte[] seed;
    public ECCurve Curve { get; }
    public ECPoint G { get; }
    public BigInteger N { get; }
    public BigInteger H { get; }
    public X9Curve CurveEntry { get; }
    public X9FieldID FieldIDEntry { get; }
    public X9ECPoint BaseEntry { get; }
    public X9ECParameters(ECCurve curve, ECPoint g, BigInteger n);
    public X9ECParameters(ECCurve curve, X9ECPoint g, BigInteger n, BigInteger h);
    public X9ECParameters(ECCurve curve, ECPoint g, BigInteger n, BigInteger h);
    public X9ECParameters(ECCurve curve, ECPoint g, BigInteger n, BigInteger h, Byte[] seed);
    public X9ECParameters(ECCurve curve, X9ECPoint g, BigInteger n, BigInteger h, Byte[] seed);
    public ECCurve get_Curve();
    public ECPoint get_G();
    public BigInteger get_N();
    public BigInteger get_H();
    public Byte[] GetSeed();
    public X9Curve get_CurveEntry();
    public X9FieldID get_FieldIDEntry();
    public X9ECPoint get_BaseEntry();
    public virtual Asn1Object ToAsn1Object();
}
internal abstract class NBitcoin.BouncyCastle.Asn1.X9.X9ECParametersHolder : object {
    private X9ECParameters parameters;
    public X9ECParameters Parameters { get; }
    public X9ECParameters get_Parameters();
    protected abstract virtual X9ECParameters CreateParameters();
}
internal class NBitcoin.BouncyCastle.Asn1.X9.X9ECPoint : Asn1Encodable {
    private Asn1OctetString encoding;
    private ECCurve c;
    private ECPoint p;
    public ECPoint Point { get; }
    public bool IsPointCompressed { get; }
    public X9ECPoint(ECPoint p);
    public X9ECPoint(ECPoint p, bool compressed);
    public X9ECPoint(ECCurve c, Byte[] encoding);
    public X9ECPoint(ECCurve c, Asn1OctetString s);
    public Byte[] GetPointEncoding();
    public ECPoint get_Point();
    public bool get_IsPointCompressed();
    public virtual Asn1Object ToAsn1Object();
}
internal class NBitcoin.BouncyCastle.Asn1.X9.X9FieldElement : Asn1Encodable {
    private ECFieldElement f;
    public ECFieldElement Value { get; }
    public X9FieldElement(ECFieldElement f);
    public X9FieldElement(BigInteger p, Asn1OctetString s);
    public X9FieldElement(int m, int k1, int k2, int k3, Asn1OctetString s);
    public ECFieldElement get_Value();
    public virtual Asn1Object ToAsn1Object();
}
internal class NBitcoin.BouncyCastle.Asn1.X9.X9FieldID : Asn1Encodable {
    private DerObjectIdentifier id;
    private Asn1Object parameters;
    public DerObjectIdentifier Identifier { get; }
    public Asn1Object Parameters { get; }
    public X9FieldID(BigInteger primeP);
    public X9FieldID(int m, int k1);
    public X9FieldID(int m, int k1, int k2, int k3);
    public DerObjectIdentifier get_Identifier();
    public Asn1Object get_Parameters();
    public virtual Asn1Object ToAsn1Object();
}
internal abstract class NBitcoin.BouncyCastle.Asn1.X9.X9IntegerConverter : object {
    public static int GetByteLength(ECFieldElement fe);
    public static int GetByteLength(ECCurve c);
    public static Byte[] IntegerToBytes(BigInteger s, int qLength);
}
internal abstract class NBitcoin.BouncyCastle.Asn1.X9.X9ObjectIdentifiers : object {
    internal static string AnsiX962;
    public static DerObjectIdentifier ansi_X9_62;
    public static DerObjectIdentifier IdFieldType;
    public static DerObjectIdentifier PrimeField;
    public static DerObjectIdentifier CharacteristicTwoField;
    public static DerObjectIdentifier GNBasis;
    public static DerObjectIdentifier TPBasis;
    public static DerObjectIdentifier PPBasis;
    [ObsoleteAttribute("Use 'id_ecSigType' instead")]
public static string IdECSigType;
    public static DerObjectIdentifier id_ecSigType;
    public static DerObjectIdentifier ECDsaWithSha1;
    [ObsoleteAttribute("Use 'id_publicKeyType' instead")]
public static string IdPublicKeyType;
    public static DerObjectIdentifier id_publicKeyType;
    public static DerObjectIdentifier IdECPublicKey;
    public static DerObjectIdentifier ECDsaWithSha2;
    public static DerObjectIdentifier ECDsaWithSha224;
    public static DerObjectIdentifier ECDsaWithSha256;
    public static DerObjectIdentifier ECDsaWithSha384;
    public static DerObjectIdentifier ECDsaWithSha512;
    public static DerObjectIdentifier EllipticCurve;
    public static DerObjectIdentifier CTwoCurve;
    public static DerObjectIdentifier C2Pnb163v1;
    public static DerObjectIdentifier C2Pnb163v2;
    public static DerObjectIdentifier C2Pnb163v3;
    public static DerObjectIdentifier C2Pnb176w1;
    public static DerObjectIdentifier C2Tnb191v1;
    public static DerObjectIdentifier C2Tnb191v2;
    public static DerObjectIdentifier C2Tnb191v3;
    public static DerObjectIdentifier C2Onb191v4;
    public static DerObjectIdentifier C2Onb191v5;
    public static DerObjectIdentifier C2Pnb208w1;
    public static DerObjectIdentifier C2Tnb239v1;
    public static DerObjectIdentifier C2Tnb239v2;
    public static DerObjectIdentifier C2Tnb239v3;
    public static DerObjectIdentifier C2Onb239v4;
    public static DerObjectIdentifier C2Onb239v5;
    public static DerObjectIdentifier C2Pnb272w1;
    public static DerObjectIdentifier C2Pnb304w1;
    public static DerObjectIdentifier C2Tnb359v1;
    public static DerObjectIdentifier C2Pnb368w1;
    public static DerObjectIdentifier C2Tnb431r1;
    public static DerObjectIdentifier PrimeCurve;
    public static DerObjectIdentifier Prime192v1;
    public static DerObjectIdentifier Prime192v2;
    public static DerObjectIdentifier Prime192v3;
    public static DerObjectIdentifier Prime239v1;
    public static DerObjectIdentifier Prime239v2;
    public static DerObjectIdentifier Prime239v3;
    public static DerObjectIdentifier Prime256v1;
    public static DerObjectIdentifier IdDsa;
    public static DerObjectIdentifier IdDsaWithSha1;
    public static DerObjectIdentifier X9x63Scheme;
    public static DerObjectIdentifier DHSinglePassStdDHSha1KdfScheme;
    public static DerObjectIdentifier DHSinglePassCofactorDHSha1KdfScheme;
    public static DerObjectIdentifier MqvSinglePassSha1KdfScheme;
    public static DerObjectIdentifier ansi_x9_42;
    public static DerObjectIdentifier DHPublicNumber;
    public static DerObjectIdentifier X9x42Schemes;
    public static DerObjectIdentifier DHStatic;
    public static DerObjectIdentifier DHEphem;
    public static DerObjectIdentifier DHOneFlow;
    public static DerObjectIdentifier DHHybrid1;
    public static DerObjectIdentifier DHHybrid2;
    public static DerObjectIdentifier DHHybridOneFlow;
    public static DerObjectIdentifier Mqv2;
    public static DerObjectIdentifier Mqv1;
    private static X9ObjectIdentifiers();
}
internal abstract class NBitcoin.BouncyCastle.Crypto.AsymmetricKeyParameter : object {
    private bool privateKey;
    public bool IsPrivate { get; }
    protected AsymmetricKeyParameter(bool privateKey);
    public bool get_IsPrivate();
    public virtual bool Equals(object obj);
    protected bool Equals(AsymmetricKeyParameter other);
    public virtual int GetHashCode();
}
internal class NBitcoin.BouncyCastle.Crypto.BufferedBlockCipher : BufferedCipherBase {
    internal Byte[] buf;
    internal int bufOff;
    internal bool forEncryption;
    internal IBlockCipher cipher;
    public string AlgorithmName { get; }
    public BufferedBlockCipher(IBlockCipher cipher);
    public virtual string get_AlgorithmName();
    public virtual void Init(bool forEncryption, ICipherParameters parameters);
    public virtual int GetBlockSize();
    public virtual int GetUpdateOutputSize(int length);
    public virtual int GetOutputSize(int length);
    public virtual int ProcessByte(byte input, Byte[] output, int outOff);
    public virtual Byte[] ProcessByte(byte input);
    public virtual Byte[] ProcessBytes(Byte[] input, int inOff, int length);
    public virtual int ProcessBytes(Byte[] input, int inOff, int length, Byte[] output, int outOff);
    public virtual Byte[] DoFinal();
    public virtual Byte[] DoFinal(Byte[] input, int inOff, int inLen);
    public virtual int DoFinal(Byte[] output, int outOff);
    public virtual void Reset();
}
internal abstract class NBitcoin.BouncyCastle.Crypto.BufferedCipherBase : object {
    protected static Byte[] EmptyBuffer;
    public string AlgorithmName { get; }
    private static BufferedCipherBase();
    public abstract virtual string get_AlgorithmName();
    public abstract virtual void Init(bool forEncryption, ICipherParameters parameters);
    public abstract virtual int GetBlockSize();
    public abstract virtual int GetOutputSize(int inputLen);
    public abstract virtual int GetUpdateOutputSize(int inputLen);
    public abstract virtual Byte[] ProcessByte(byte input);
    public virtual int ProcessByte(byte input, Byte[] output, int outOff);
    public virtual Byte[] ProcessBytes(Byte[] input);
    public abstract virtual Byte[] ProcessBytes(Byte[] input, int inOff, int length);
    public virtual int ProcessBytes(Byte[] input, Byte[] output, int outOff);
    public virtual int ProcessBytes(Byte[] input, int inOff, int length, Byte[] output, int outOff);
    public abstract virtual Byte[] DoFinal();
    public virtual Byte[] DoFinal(Byte[] input);
    public abstract virtual Byte[] DoFinal(Byte[] input, int inOff, int length);
    public virtual int DoFinal(Byte[] output, int outOff);
    public virtual int DoFinal(Byte[] input, Byte[] output, int outOff);
    public virtual int DoFinal(Byte[] input, int inOff, int length, Byte[] output, int outOff);
    public abstract virtual void Reset();
}
internal class NBitcoin.BouncyCastle.Crypto.Check : object {
    internal static void DataLength(bool condition, string msg);
    internal static void DataLength(Byte[] buf, int off, int len, string msg);
    internal static void OutputLength(Byte[] buf, int off, int len, string msg);
}
internal class NBitcoin.BouncyCastle.Crypto.CryptoException : Exception {
    public CryptoException(string message);
    public CryptoException(string message, Exception exception);
}
internal class NBitcoin.BouncyCastle.Crypto.DataLengthException : CryptoException {
    public DataLengthException(string message);
    public DataLengthException(string message, Exception exception);
}
internal abstract class NBitcoin.BouncyCastle.Crypto.Digests.GeneralDigest : object {
    private static int BYTE_LENGTH;
    private Byte[] xBuf;
    private int xBufOff;
    private long byteCount;
    public string AlgorithmName { get; }
    internal GeneralDigest(GeneralDigest t);
    protected void CopyIn(GeneralDigest t);
    public sealed virtual void Update(byte input);
    public sealed virtual void BlockUpdate(Byte[] input, int inOff, int length);
    public void Finish();
    public virtual void Reset();
    public sealed virtual int GetByteLength();
    internal abstract virtual void ProcessWord(Byte[] input, int inOff);
    internal abstract virtual void ProcessLength(long bitLength);
    internal abstract virtual void ProcessBlock();
    public abstract virtual string get_AlgorithmName();
    public abstract virtual int GetDigestSize();
    public abstract virtual int DoFinal(Byte[] output, int outOff);
    public abstract virtual IMemoable Copy();
    public abstract virtual void Reset(IMemoable t);
}
internal class NBitcoin.BouncyCastle.Crypto.Digests.KeccakDigest : object {
    private static UInt64[] KeccakRoundConstants;
    private UInt64[] state;
    protected Byte[] dataQueue;
    protected int rate;
    protected int bitsInQueue;
    protected int fixedOutputLength;
    protected bool squeezing;
    public string AlgorithmName { get; }
    public KeccakDigest(int bitLength);
    public KeccakDigest(KeccakDigest source);
    private static KeccakDigest();
    private void CopyIn(KeccakDigest source);
    public virtual string get_AlgorithmName();
    public virtual int GetDigestSize();
    public virtual void Update(byte input);
    public virtual void BlockUpdate(Byte[] input, int inOff, int len);
    public virtual int DoFinal(Byte[] output, int outOff);
    protected virtual int DoFinal(Byte[] output, int outOff, byte partialByte, int partialBits);
    public virtual void Reset();
    public virtual int GetByteLength();
    private void Init(int bitLength);
    private void InitSponge(int rate);
    protected void Absorb(byte data);
    protected void Absorb(Byte[] data, int off, int len);
    protected void AbsorbBits(int data, int bits);
    private void PadAndSwitchToSqueezingPhase();
    protected void Squeeze(Byte[] output, int offset, long outputLength);
    private void KeccakAbsorb(Byte[] data, int off);
    private void KeccakExtract();
    private void KeccakPermutation();
    public virtual IMemoable Copy();
    public virtual void Reset(IMemoable other);
}
internal abstract class NBitcoin.BouncyCastle.Crypto.Digests.LongDigest : object {
    private int MyByteLength;
    private Byte[] xBuf;
    private int xBufOff;
    private long byteCount1;
    private long byteCount2;
    internal ulong H1;
    internal ulong H2;
    internal ulong H3;
    internal ulong H4;
    internal ulong H5;
    internal ulong H6;
    internal ulong H7;
    internal ulong H8;
    private UInt64[] W;
    private int wOff;
    internal static UInt64[] K;
    public string AlgorithmName { get; }
    internal LongDigest(LongDigest t);
    private static LongDigest();
    protected void CopyIn(LongDigest t);
    public sealed virtual void Update(byte input);
    public sealed virtual void BlockUpdate(Byte[] input, int inOff, int length);
    public void Finish();
    public virtual void Reset();
    internal void ProcessWord(Byte[] input, int inOff);
    private void AdjustByteCounts();
    internal void ProcessLength(long lowW, long hiW);
    internal void ProcessBlock();
    private static ulong Ch(ulong x, ulong y, ulong z);
    private static ulong Maj(ulong x, ulong y, ulong z);
    private static ulong Sum0(ulong x);
    private static ulong Sum1(ulong x);
    private static ulong Sigma0(ulong x);
    private static ulong Sigma1(ulong x);
    public sealed virtual int GetByteLength();
    public abstract virtual string get_AlgorithmName();
    public abstract virtual int GetDigestSize();
    public abstract virtual int DoFinal(Byte[] output, int outOff);
    public abstract virtual IMemoable Copy();
    public abstract virtual void Reset(IMemoable t);
}
internal class NBitcoin.BouncyCastle.Crypto.Digests.RipeMD160Digest : GeneralDigest {
    private static int DigestLength;
    private int H0;
    private int H1;
    private int H2;
    private int H3;
    private int H4;
    private Int32[] X;
    private int xOff;
    public string AlgorithmName { get; }
    public RipeMD160Digest(RipeMD160Digest t);
    private void CopyIn(RipeMD160Digest t);
    public virtual string get_AlgorithmName();
    public virtual int GetDigestSize();
    internal virtual void ProcessWord(Byte[] input, int inOff);
    internal virtual void ProcessLength(long bitLength);
    private void UnpackWord(int word, Byte[] outBytes, int outOff);
    public virtual int DoFinal(Byte[] output, int outOff);
    public virtual void Reset();
    private int RL(int x, int n);
    private int F1(int x, int y, int z);
    private int F2(int x, int y, int z);
    private int F3(int x, int y, int z);
    private int F4(int x, int y, int z);
    private int F5(int x, int y, int z);
    internal virtual void ProcessBlock();
    public virtual IMemoable Copy();
    public virtual void Reset(IMemoable other);
}
internal class NBitcoin.BouncyCastle.Crypto.Digests.Sha1Digest : GeneralDigest {
    private static int DigestLength;
    private UInt32 H1;
    private UInt32 H2;
    private UInt32 H3;
    private UInt32 H4;
    private UInt32 H5;
    private UInt32[] X;
    private int xOff;
    private static UInt32 Y1;
    private static UInt32 Y2;
    private static UInt32 Y3;
    private static UInt32 Y4;
    public string AlgorithmName { get; }
    public Sha1Digest(Sha1Digest t);
    private void CopyIn(Sha1Digest t);
    public virtual string get_AlgorithmName();
    public virtual int GetDigestSize();
    internal virtual void ProcessWord(Byte[] input, int inOff);
    internal virtual void ProcessLength(long bitLength);
    public virtual int DoFinal(Byte[] output, int outOff);
    public virtual void Reset();
    private static UInt32 F(UInt32 u, UInt32 v, UInt32 w);
    private static UInt32 H(UInt32 u, UInt32 v, UInt32 w);
    private static UInt32 G(UInt32 u, UInt32 v, UInt32 w);
    internal virtual void ProcessBlock();
    public virtual IMemoable Copy();
    public virtual void Reset(IMemoable other);
}
internal class NBitcoin.BouncyCastle.Crypto.Digests.Sha224Digest : GeneralDigest {
    private static int DigestLength;
    private UInt32 H1;
    private UInt32 H2;
    private UInt32 H3;
    private UInt32 H4;
    private UInt32 H5;
    private UInt32 H6;
    private UInt32 H7;
    private UInt32 H8;
    private UInt32[] X;
    private int xOff;
    internal static UInt32[] K;
    public string AlgorithmName { get; }
    public Sha224Digest(Sha224Digest t);
    private static Sha224Digest();
    private void CopyIn(Sha224Digest t);
    public virtual string get_AlgorithmName();
    public virtual int GetDigestSize();
    internal virtual void ProcessWord(Byte[] input, int inOff);
    internal virtual void ProcessLength(long bitLength);
    public virtual int DoFinal(Byte[] output, int outOff);
    public virtual void Reset();
    internal virtual void ProcessBlock();
    private static UInt32 Ch(UInt32 x, UInt32 y, UInt32 z);
    private static UInt32 Maj(UInt32 x, UInt32 y, UInt32 z);
    private static UInt32 Sum0(UInt32 x);
    private static UInt32 Sum1(UInt32 x);
    private static UInt32 Theta0(UInt32 x);
    private static UInt32 Theta1(UInt32 x);
    public virtual IMemoable Copy();
    public virtual void Reset(IMemoable other);
}
internal class NBitcoin.BouncyCastle.Crypto.Digests.Sha256Digest : GeneralDigest {
    private static int DigestLength;
    private UInt32 H1;
    private UInt32 H2;
    private UInt32 H3;
    private UInt32 H4;
    private UInt32 H5;
    private UInt32 H6;
    private UInt32 H7;
    private UInt32 H8;
    private UInt32[] X;
    private int xOff;
    private static UInt32[] K;
    public string AlgorithmName { get; }
    public Byte[] MidState { get; }
    public Sha256Digest(Sha256Digest t);
    private static Sha256Digest();
    private void CopyIn(Sha256Digest t);
    public virtual string get_AlgorithmName();
    public Byte[] get_MidState();
    public virtual int GetDigestSize();
    internal virtual void ProcessWord(Byte[] input, int inOff);
    internal virtual void ProcessLength(long bitLength);
    public virtual int DoFinal(Byte[] output, int outOff);
    public virtual void Reset();
    private void initHs();
    internal virtual void ProcessBlock();
    private static UInt32 Sum1Ch(UInt32 x, UInt32 y, UInt32 z);
    private static UInt32 Sum0Maj(UInt32 x, UInt32 y, UInt32 z);
    private static UInt32 Theta0(UInt32 x);
    private static UInt32 Theta1(UInt32 x);
    public virtual IMemoable Copy();
    public virtual void Reset(IMemoable other);
}
internal class NBitcoin.BouncyCastle.Crypto.Digests.Sha384Digest : LongDigest {
    private static int DigestLength;
    public string AlgorithmName { get; }
    public Sha384Digest(Sha384Digest t);
    public virtual string get_AlgorithmName();
    public virtual int GetDigestSize();
    public virtual int DoFinal(Byte[] output, int outOff);
    public virtual void Reset();
    public virtual IMemoable Copy();
    public virtual void Reset(IMemoable other);
}
internal class NBitcoin.BouncyCastle.Crypto.Digests.Sha3Digest : KeccakDigest {
    public string AlgorithmName { get; }
    public Sha3Digest(int bitLength);
    public Sha3Digest(Sha3Digest source);
    private static int CheckBitLength(int bitLength);
    public virtual string get_AlgorithmName();
    public virtual int DoFinal(Byte[] output, int outOff);
    protected virtual int DoFinal(Byte[] output, int outOff, byte partialByte, int partialBits);
    public virtual IMemoable Copy();
}
internal class NBitcoin.BouncyCastle.Crypto.Digests.Sha512Digest : LongDigest {
    private static int DigestLength;
    public string AlgorithmName { get; }
    public Sha512Digest(Sha512Digest t);
    public virtual string get_AlgorithmName();
    public virtual int GetDigestSize();
    public virtual int DoFinal(Byte[] output, int outOff);
    public virtual void Reset();
    public virtual IMemoable Copy();
    public virtual void Reset(IMemoable other);
}
internal class NBitcoin.BouncyCastle.Crypto.EC.CustomNamedCurves : object {
    public static X9ECParameters Secp256k1 { get; }
    private static ECCurve ConfigureCurveGlv(ECCurve c, GlvTypeBParameters p);
    public static X9ECParameters get_Secp256k1();
}
internal class NBitcoin.BouncyCastle.Crypto.Engines.AesFastEngine : object {
    private static Byte[] S;
    private static Byte[] Si;
    private static Byte[] rcon;
    private static UInt32[] T0;
    private static UInt32[] T1;
    private static UInt32[] T2;
    private static UInt32[] T3;
    private static UInt32[] Tinv0;
    private static UInt32[] Tinv1;
    private static UInt32[] Tinv2;
    private static UInt32[] Tinv3;
    private static UInt32 m1;
    private static UInt32 m2;
    private static UInt32 m3;
    private static UInt32 m4;
    private static UInt32 m5;
    private int ROUNDS;
    private UInt32[][] WorkingKey;
    private UInt32 C0;
    private UInt32 C1;
    private UInt32 C2;
    private UInt32 C3;
    private bool forEncryption;
    private static int BLOCK_SIZE;
    public string AlgorithmName { get; }
    public bool IsPartialBlockOkay { get; }
    private static AesFastEngine();
    private static UInt32 Shift(UInt32 r, int shift);
    private static UInt32 FFmulX(UInt32 x);
    private static UInt32 FFmulX2(UInt32 x);
    private static UInt32 Inv_Mcol(UInt32 x);
    private static UInt32 SubWord(UInt32 x);
    private UInt32[][] GenerateWorkingKey(Byte[] key, bool forEncryption);
    public virtual void Init(bool forEncryption, ICipherParameters parameters);
    public virtual string get_AlgorithmName();
    public virtual bool get_IsPartialBlockOkay();
    public virtual int GetBlockSize();
    public virtual int ProcessBlock(Byte[] input, int inOff, Byte[] output, int outOff);
    public virtual void Reset();
    private void UnPackBlock(Byte[] bytes, int off);
    private void PackBlock(Byte[] bytes, int off);
    private void EncryptBlock(UInt32[][] KW);
    private void DecryptBlock(UInt32[][] KW);
}
internal interface NBitcoin.BouncyCastle.Crypto.IAsymmetricBlockCipher {
    public string AlgorithmName { get; }
    public abstract virtual string get_AlgorithmName();
    public abstract virtual void Init(bool forEncryption, ICipherParameters parameters);
    public abstract virtual int GetInputBlockSize();
    public abstract virtual int GetOutputBlockSize();
    public abstract virtual Byte[] ProcessBlock(Byte[] inBuf, int inOff, int inLen);
}
internal interface NBitcoin.BouncyCastle.Crypto.IBlockCipher {
    public string AlgorithmName { get; }
    public bool IsPartialBlockOkay { get; }
    public abstract virtual string get_AlgorithmName();
    public abstract virtual void Init(bool forEncryption, ICipherParameters parameters);
    public abstract virtual int GetBlockSize();
    public abstract virtual bool get_IsPartialBlockOkay();
    public abstract virtual int ProcessBlock(Byte[] inBuf, int inOff, Byte[] outBuf, int outOff);
    public abstract virtual void Reset();
}
internal interface NBitcoin.BouncyCastle.Crypto.IBufferedCipher {
    public string AlgorithmName { get; }
    public abstract virtual string get_AlgorithmName();
    public abstract virtual void Init(bool forEncryption, ICipherParameters parameters);
    public abstract virtual int GetBlockSize();
    public abstract virtual int GetOutputSize(int inputLen);
    public abstract virtual int GetUpdateOutputSize(int inputLen);
    public abstract virtual Byte[] ProcessByte(byte input);
    public abstract virtual int ProcessByte(byte input, Byte[] output, int outOff);
    public abstract virtual Byte[] ProcessBytes(Byte[] input);
    public abstract virtual Byte[] ProcessBytes(Byte[] input, int inOff, int length);
    public abstract virtual int ProcessBytes(Byte[] input, Byte[] output, int outOff);
    public abstract virtual int ProcessBytes(Byte[] input, int inOff, int length, Byte[] output, int outOff);
    public abstract virtual Byte[] DoFinal();
    public abstract virtual Byte[] DoFinal(Byte[] input);
    public abstract virtual Byte[] DoFinal(Byte[] input, int inOff, int length);
    public abstract virtual int DoFinal(Byte[] output, int outOff);
    public abstract virtual int DoFinal(Byte[] input, Byte[] output, int outOff);
    public abstract virtual int DoFinal(Byte[] input, int inOff, int length, Byte[] output, int outOff);
    public abstract virtual void Reset();
}
internal interface NBitcoin.BouncyCastle.Crypto.ICipherParameters {
}
internal interface NBitcoin.BouncyCastle.Crypto.IDigest {
    public string AlgorithmName { get; }
    public abstract virtual string get_AlgorithmName();
    public abstract virtual int GetDigestSize();
    public abstract virtual int GetByteLength();
    public abstract virtual void Update(byte input);
    public abstract virtual void BlockUpdate(Byte[] input, int inOff, int length);
    public abstract virtual int DoFinal(Byte[] output, int outOff);
    public abstract virtual void Reset();
}
internal interface NBitcoin.BouncyCastle.Crypto.IDsa {
    public string AlgorithmName { get; }
    public abstract virtual string get_AlgorithmName();
    public abstract virtual void Init(bool forSigning, ICipherParameters parameters);
    public abstract virtual BigInteger[] GenerateSignature(Byte[] message);
    public abstract virtual bool VerifySignature(Byte[] message, BigInteger r, BigInteger s);
}
internal interface NBitcoin.BouncyCastle.Crypto.IMac {
    public string AlgorithmName { get; }
    public abstract virtual void Init(ICipherParameters parameters);
    public abstract virtual string get_AlgorithmName();
    public abstract virtual int GetMacSize();
    public abstract virtual void Update(byte input);
    public abstract virtual void BlockUpdate(Byte[] input, int inOff, int len);
    public abstract virtual int DoFinal(Byte[] output, int outOff);
    public abstract virtual void Reset();
}
internal class NBitcoin.BouncyCastle.Crypto.InvalidCipherTextException : CryptoException {
    public InvalidCipherTextException(string message);
    public InvalidCipherTextException(string message, Exception exception);
}
internal interface NBitcoin.BouncyCastle.Crypto.ISigner {
    public string AlgorithmName { get; }
    public abstract virtual string get_AlgorithmName();
    public abstract virtual void Init(bool forSigning, ICipherParameters parameters);
    public abstract virtual void Update(byte input);
    public abstract virtual void BlockUpdate(Byte[] input, int inOff, int length);
    public abstract virtual Byte[] GenerateSignature();
    public abstract virtual bool VerifySignature(Byte[] signature);
    public abstract virtual void Reset();
}
internal class NBitcoin.BouncyCastle.Crypto.Macs.HMac : object {
    private static byte IPAD;
    private static byte OPAD;
    private IDigest digest;
    private int digestSize;
    private int blockLength;
    private IMemoable ipadState;
    private IMemoable opadState;
    private Byte[] inputPad;
    private Byte[] outputBuf;
    public string AlgorithmName { get; }
    public HMac(IDigest digest);
    public virtual string get_AlgorithmName();
    public virtual IDigest GetUnderlyingDigest();
    public virtual void Init(ICipherParameters parameters);
    public virtual int GetMacSize();
    public virtual void Update(byte input);
    public virtual void BlockUpdate(Byte[] input, int inOff, int len);
    public virtual int DoFinal(Byte[] output, int outOff);
    public virtual void Reset();
    private static void XorPad(Byte[] pad, int len, byte n);
}
internal class NBitcoin.BouncyCastle.Crypto.Modes.CbcBlockCipher : object {
    private Byte[] IV;
    private Byte[] cbcV;
    private Byte[] cbcNextV;
    private int blockSize;
    private IBlockCipher cipher;
    private bool encrypting;
    public string AlgorithmName { get; }
    public bool IsPartialBlockOkay { get; }
    public CbcBlockCipher(IBlockCipher cipher);
    public IBlockCipher GetUnderlyingCipher();
    public sealed virtual void Init(bool forEncryption, ICipherParameters parameters);
    public sealed virtual string get_AlgorithmName();
    public sealed virtual bool get_IsPartialBlockOkay();
    public sealed virtual int GetBlockSize();
    public sealed virtual int ProcessBlock(Byte[] input, int inOff, Byte[] output, int outOff);
    public sealed virtual void Reset();
    private int EncryptBlock(Byte[] input, int inOff, Byte[] outBytes, int outOff);
    private int DecryptBlock(Byte[] input, int inOff, Byte[] outBytes, int outOff);
}
internal class NBitcoin.BouncyCastle.Crypto.Modes.ParametersWithIV : object {
    private ICipherParameters parameters;
    private Byte[] iv;
    public ICipherParameters Parameters { get; }
    public ParametersWithIV(ICipherParameters parameters, Byte[] iv);
    public ParametersWithIV(ICipherParameters parameters, Byte[] iv, int ivOff, int ivLen);
    public Byte[] GetIV();
    public ICipherParameters get_Parameters();
}
internal class NBitcoin.BouncyCastle.Crypto.OutputLengthException : DataLengthException {
    public OutputLengthException(string message);
    public OutputLengthException(string message, Exception exception);
}
internal interface NBitcoin.BouncyCastle.Crypto.Paddings.IBlockCipherPadding {
    public string PaddingName { get; }
    public abstract virtual void Init(SecureRandom random);
    public abstract virtual string get_PaddingName();
    public abstract virtual int AddPadding(Byte[] input, int inOff);
    public abstract virtual int PadCount(Byte[] input);
}
internal class NBitcoin.BouncyCastle.Crypto.Paddings.PaddedBufferedBlockCipher : BufferedBlockCipher {
    private IBlockCipherPadding padding;
    public PaddedBufferedBlockCipher(IBlockCipher cipher, IBlockCipherPadding padding);
    public PaddedBufferedBlockCipher(IBlockCipher cipher);
    public virtual void Init(bool forEncryption, ICipherParameters parameters);
    public virtual int GetOutputSize(int length);
    public virtual int GetUpdateOutputSize(int length);
    public virtual int ProcessByte(byte input, Byte[] output, int outOff);
    public virtual int ProcessBytes(Byte[] input, int inOff, int length, Byte[] output, int outOff);
    public virtual int DoFinal(Byte[] output, int outOff);
}
internal class NBitcoin.BouncyCastle.Crypto.Paddings.Pkcs7Padding : object {
    public string PaddingName { get; }
    public sealed virtual void Init(SecureRandom random);
    public sealed virtual string get_PaddingName();
    public sealed virtual int AddPadding(Byte[] input, int inOff);
    public sealed virtual int PadCount(Byte[] input);
}
internal class NBitcoin.BouncyCastle.Crypto.Parameters.ECDomainParameters : object {
    internal ECCurve curve;
    internal Byte[] seed;
    internal ECPoint g;
    internal BigInteger n;
    internal BigInteger h;
    public ECCurve Curve { get; }
    public ECPoint G { get; }
    public BigInteger N { get; }
    public BigInteger H { get; }
    public ECDomainParameters(ECCurve curve, ECPoint g, BigInteger n);
    public ECDomainParameters(ECCurve curve, ECPoint g, BigInteger n, BigInteger h);
    public ECDomainParameters(ECCurve curve, ECPoint g, BigInteger n, BigInteger h, Byte[] seed);
    public ECCurve get_Curve();
    public ECPoint get_G();
    public BigInteger get_N();
    public BigInteger get_H();
    public Byte[] GetSeed();
    public virtual bool Equals(object obj);
    protected bool Equals(ECDomainParameters other);
    public virtual int GetHashCode();
}
internal abstract class NBitcoin.BouncyCastle.Crypto.Parameters.ECKeyParameters : AsymmetricKeyParameter {
    private static String[] algorithms;
    private string algorithm;
    private ECDomainParameters parameters;
    public string AlgorithmName { get; }
    public ECDomainParameters Parameters { get; }
    protected ECKeyParameters(string algorithm, bool isPrivate, ECDomainParameters parameters);
    private static ECKeyParameters();
    public string get_AlgorithmName();
    public ECDomainParameters get_Parameters();
    public virtual bool Equals(object obj);
    protected bool Equals(ECKeyParameters other);
    public virtual int GetHashCode();
    internal static string VerifyAlgorithmName(string algorithm);
}
internal class NBitcoin.BouncyCastle.Crypto.Parameters.ECPrivateKeyParameters : ECKeyParameters {
    private BigInteger d;
    public BigInteger D { get; }
    public ECPrivateKeyParameters(BigInteger d, ECDomainParameters parameters);
    public ECPrivateKeyParameters(string algorithm, BigInteger d, ECDomainParameters parameters);
    public BigInteger get_D();
    public virtual bool Equals(object obj);
    protected bool Equals(ECPrivateKeyParameters other);
    public virtual int GetHashCode();
}
internal class NBitcoin.BouncyCastle.Crypto.Parameters.ECPublicKeyParameters : ECKeyParameters {
    private ECPoint q;
    public ECPoint Q { get; }
    public ECPublicKeyParameters(ECPoint q, ECDomainParameters parameters);
    public ECPublicKeyParameters(string algorithm, ECPoint q, ECDomainParameters parameters);
    public ECPoint get_Q();
    public virtual bool Equals(object obj);
    protected bool Equals(ECPublicKeyParameters other);
    public virtual int GetHashCode();
}
internal class NBitcoin.BouncyCastle.Crypto.Parameters.KeyParameter : object {
    private Byte[] key;
    public KeyParameter(Byte[] key);
    public KeyParameter(Byte[] key, int keyOff, int keyLen);
    public Byte[] GetKey();
}
internal class NBitcoin.BouncyCastle.Crypto.Signers.ECDsaSigner : object {
    private static BigInteger Eight;
    protected IDsaKCalculator kCalculator;
    protected ECKeyParameters key;
    protected SecureRandom random;
    protected bool forceLowR;
    public string AlgorithmName { get; }
    public ECDsaSigner(IDsaKCalculator kCalculator, bool forceLowR);
    private static ECDsaSigner();
    public virtual string get_AlgorithmName();
    public virtual void Init(bool forSigning, ICipherParameters parameters);
    public virtual BigInteger[] GenerateSignature(Byte[] message);
    public virtual bool VerifySignature(Byte[] message, BigInteger r, BigInteger s);
    protected virtual BigInteger CalculateE(BigInteger n, Byte[] message);
    protected virtual ECMultiplier CreateBasePointMultiplier();
    protected virtual ECFieldElement GetDenominator(int coordinateSystem, ECPoint p);
    protected virtual SecureRandom InitSecureRandom(bool needed, SecureRandom provided);
}
internal class NBitcoin.BouncyCastle.Crypto.Signers.HMacDsaKCalculator : object {
    private HMac hMac;
    private Byte[] K;
    private Byte[] V;
    private BigInteger n;
    public bool IsDeterministic { get; }
    public HMacDsaKCalculator(IDigest digest);
    public virtual bool get_IsDeterministic();
    public virtual void Init(BigInteger n, SecureRandom random);
    public sealed virtual void Init(BigInteger n, BigInteger d, Byte[] message);
    public virtual BigInteger NextK();
    private BigInteger BitsToInt(Byte[] t);
}
internal interface NBitcoin.BouncyCastle.Crypto.Signers.IDsaKCalculator {
    public bool IsDeterministic { get; }
    public abstract virtual bool get_IsDeterministic();
    public abstract virtual void Init(BigInteger n, SecureRandom random);
    public abstract virtual void Init(BigInteger n, BigInteger d, Byte[] message);
    public abstract virtual BigInteger NextK();
}
internal class NBitcoin.BouncyCastle.Crypto.Signers.RandomDsaKCalculator : object {
    private BigInteger q;
    private SecureRandom random;
    public bool IsDeterministic { get; }
    public virtual bool get_IsDeterministic();
    public virtual void Init(BigInteger n, SecureRandom random);
    public virtual void Init(BigInteger n, BigInteger d, Byte[] message);
    public virtual BigInteger NextK();
}
internal static class NBitcoin.BouncyCastle.Crypto.Utilities.Pack : object {
    internal static void UInt32_To_BE(UInt32 n, Byte[] bs, int off);
    internal static UInt32 BE_To_UInt32(Byte[] bs, int off);
    internal static void BE_To_UInt32(Byte[] bs, int off, UInt32[] ns);
    internal static void UInt64_To_BE(ulong n, Byte[] bs, int off);
    internal static ulong BE_To_UInt64(Byte[] bs, int off);
    internal static void UInt16_To_LE(ushort n, Byte[] bs, int off);
    internal static ushort LE_To_UInt16(Byte[] bs);
    internal static ushort LE_To_UInt16(Byte[] bs, int off);
    internal static Byte[] UInt32_To_LE(UInt32 n);
    internal static void UInt32_To_LE(UInt32 n, Byte[] bs);
    internal static void UInt32_To_LE(UInt32 n, Byte[] bs, int off);
    internal static Byte[] UInt32_To_LE(UInt32[] ns);
    internal static void UInt32_To_LE(UInt32[] ns, Byte[] bs, int off);
    internal static UInt32 LE_To_UInt32(Byte[] bs, int off);
    internal static void UInt64_To_LE(ulong n, Byte[] bs, int off);
    internal static void UInt64_To_LE(UInt64[] ns, int nsOff, int nsLen, Byte[] bs, int bsOff);
    internal static ulong LE_To_UInt64(Byte[] bs, int off);
}
internal class NBitcoin.BouncyCastle.Math.BigInteger : object {
    internal static Int32[][] primeLists;
    internal static Int32[] primeProducts;
    private static long IMASK;
    private static ulong UIMASK;
    private static Int32[] ZeroMagnitude;
    private static Byte[] ZeroEncoding;
    private static BigInteger[] SMALL_CONSTANTS;
    public static BigInteger Zero;
    public static BigInteger One;
    public static BigInteger Two;
    public static BigInteger Three;
    public static BigInteger Ten;
    private static Byte[] BitLengthTable;
    private static int chunk2;
    private static int chunk8;
    private static int chunk10;
    private static int chunk16;
    private static BigInteger radix2;
    private static BigInteger radix2E;
    private static BigInteger radix8;
    private static BigInteger radix8E;
    private static BigInteger radix10;
    private static BigInteger radix10E;
    private static BigInteger radix16;
    private static BigInteger radix16E;
    private static SecureRandom RandomSource;
    private static Int32[] ExpWindowThresholds;
    private static int BitsPerByte;
    private static int BitsPerInt;
    private static int BytesPerInt;
    private Int32[] magnitude;
    private int sign;
    private int nBits;
    private int nBitLength;
    private int mQuote;
    public int BitCount { get; }
    public int BitLength { get; }
    public int IntValue { get; }
    public long LongValue { get; }
    public int SignValue { get; }
    private static BigInteger();
    private BigInteger(int signum, Int32[] mag, bool checkMag);
    public BigInteger(string value);
    public BigInteger(string str, int radix);
    public BigInteger(Byte[] bytes);
    public BigInteger(Byte[] bytes, int offset, int length);
    public BigInteger(int sign, Byte[] bytes);
    public BigInteger(int sign, Byte[] bytes, int offset, int length);
    public BigInteger(int sizeInBits, Random random);
    public BigInteger(int bitLength, int certainty, Random random);
    private static int GetByteLength(int nBits);
    internal static BigInteger Arbitrary(int sizeInBits);
    private static Int32[] MakeMagnitude(Byte[] bytes, int offset, int length);
    public BigInteger Abs();
    private static Int32[] AddMagnitudes(Int32[] a, Int32[] b);
    public BigInteger Add(BigInteger value);
    private BigInteger AddToMagnitude(Int32[] magToAdd);
    public BigInteger And(BigInteger value);
    public BigInteger AndNot(BigInteger val);
    public int get_BitCount();
    public static int BitCnt(int i);
    private static int CalcBitLength(int sign, int indx, Int32[] mag);
    public int get_BitLength();
    internal static int BitLen(int w);
    private bool QuickPow2Check();
    public int CompareTo(object obj);
    private static int CompareTo(int xIndx, Int32[] x, int yIndx, Int32[] y);
    private static int CompareNoLeadingZeroes(int xIndx, Int32[] x, int yIndx, Int32[] y);
    public int CompareTo(BigInteger value);
    private Int32[] Divide(Int32[] x, Int32[] y);
    public BigInteger Divide(BigInteger val);
    public BigInteger[] DivideAndRemainder(BigInteger val);
    public virtual bool Equals(object obj);
    private bool IsEqualMagnitude(BigInteger x);
    public BigInteger Gcd(BigInteger value);
    public virtual int GetHashCode();
    private BigInteger Inc();
    public int get_IntValue();
    public bool IsProbablePrime(int certainty);
    internal bool IsProbablePrime(int certainty, bool randomlySelected);
    private bool CheckProbablePrime(int certainty, Random random, bool randomlySelected);
    public bool RabinMillerTest(int certainty, Random random);
    internal bool RabinMillerTest(int certainty, Random random, bool randomlySelected);
    public static int Jacobi(BigInteger a, BigInteger b);
    public long get_LongValue();
    public BigInteger Max(BigInteger value);
    public BigInteger Min(BigInteger value);
    public BigInteger Mod(BigInteger m);
    public BigInteger ModInverse(BigInteger m);
    private BigInteger ModInversePow2(BigInteger m);
    private static int ModInverse32(int d);
    private static long ModInverse64(long d);
    private static BigInteger ExtEuclid(BigInteger a, BigInteger b, BigInteger& u1Out);
    private static void ZeroOut(Int32[] x);
    public BigInteger ModPow(BigInteger e, BigInteger m);
    private static BigInteger ModPowBarrett(BigInteger b, BigInteger e, BigInteger m);
    private static BigInteger ReduceBarrett(BigInteger x, BigInteger m, BigInteger mr, BigInteger yu);
    private static BigInteger ModPowMonty(BigInteger b, BigInteger e, BigInteger m, bool convert);
    private static Int32[] GetWindowList(Int32[] mag, int extraBits);
    private static int CreateWindowEntry(int mult, int zeroes);
    private static Int32[] Square(Int32[] w, Int32[] x);
    private static Int32[] Multiply(Int32[] x, Int32[] y, Int32[] z);
    private int GetMQuote();
    private static void MontgomeryReduce(Int32[] x, Int32[] m, UInt32 mDash);
    private static void MultiplyMonty(Int32[] a, Int32[] x, Int32[] y, Int32[] m, UInt32 mDash, bool smallMontyModulus);
    private static void SquareMonty(Int32[] a, Int32[] x, Int32[] m, UInt32 mDash, bool smallMontyModulus);
    private static UInt32 MultiplyMontyNIsOne(UInt32 x, UInt32 y, UInt32 m, UInt32 mDash);
    public BigInteger Multiply(BigInteger val);
    public BigInteger Square();
    public BigInteger Negate();
    public BigInteger NextProbablePrime();
    public BigInteger Not();
    public BigInteger Pow(int exp);
    public static BigInteger ProbablePrime(int bitLength, Random random);
    private int Remainder(int m);
    private static Int32[] Remainder(Int32[] x, Int32[] y);
    public BigInteger Remainder(BigInteger n);
    private Int32[] LastNBits(int n);
    private BigInteger DivideWords(int w);
    private BigInteger RemainderWords(int w);
    private static Int32[] ShiftLeft(Int32[] mag, int n);
    private static int ShiftLeftOneInPlace(Int32[] x, int carry);
    public BigInteger ShiftLeft(int n);
    private static void ShiftRightInPlace(int start, Int32[] mag, int n);
    private static void ShiftRightOneInPlace(int start, Int32[] mag);
    public BigInteger ShiftRight(int n);
    public int get_SignValue();
    private static Int32[] Subtract(int xStart, Int32[] x, int yStart, Int32[] y);
    public BigInteger Subtract(BigInteger n);
    private static Int32[] doSubBigLil(Int32[] bigMag, Int32[] lilMag);
    public Byte[] ToByteArray();
    public Byte[] ToByteArrayUnsigned();
    private Byte[] ToByteArray(bool unsigned);
    public virtual string ToString();
    public string ToString(int radix);
    private static void AppendZeroExtendedString(StringBuilder sb, string s, int minLength);
    private static BigInteger CreateUValueOf(ulong value);
    private static BigInteger CreateValueOf(long value);
    public static BigInteger ValueOf(long value);
    public int GetLowestSetBit();
    private int GetLowestSetBitMaskFirst(int firstWordMask);
    public bool TestBit(int n);
    public BigInteger Or(BigInteger value);
    public BigInteger Xor(BigInteger value);
    public BigInteger SetBit(int n);
    public BigInteger ClearBit(int n);
    public BigInteger FlipBit(int n);
    private BigInteger FlipExistingBit(int n);
}
internal class NBitcoin.BouncyCastle.Math.EC.Abc.SimpleBigDecimal : object {
    private BigInteger bigInt;
    private int scale;
    public int IntValue { get; }
    public long LongValue { get; }
    public int Scale { get; }
    public SimpleBigDecimal(BigInteger bigInt, int scale);
    private SimpleBigDecimal(SimpleBigDecimal limBigDec);
    public static SimpleBigDecimal GetInstance(BigInteger val, int scale);
    private void CheckScale(SimpleBigDecimal b);
    public SimpleBigDecimal AdjustScale(int newScale);
    public SimpleBigDecimal Add(SimpleBigDecimal b);
    public SimpleBigDecimal Add(BigInteger b);
    public SimpleBigDecimal Negate();
    public SimpleBigDecimal Subtract(SimpleBigDecimal b);
    public SimpleBigDecimal Subtract(BigInteger b);
    public SimpleBigDecimal Multiply(SimpleBigDecimal b);
    public SimpleBigDecimal Multiply(BigInteger b);
    public SimpleBigDecimal Divide(SimpleBigDecimal b);
    public SimpleBigDecimal Divide(BigInteger b);
    public SimpleBigDecimal ShiftLeft(int n);
    public int CompareTo(SimpleBigDecimal val);
    public int CompareTo(BigInteger val);
    public BigInteger Floor();
    public BigInteger Round();
    public int get_IntValue();
    public long get_LongValue();
    public int get_Scale();
    public virtual string ToString();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class NBitcoin.BouncyCastle.Math.EC.Abc.Tnaf : object {
    private static BigInteger MinusOne;
    private static BigInteger MinusTwo;
    private static BigInteger MinusThree;
    private static BigInteger Four;
    public static sbyte Width;
    public static sbyte Pow2Width;
    public static ZTauElement[] Alpha0;
    public static SByte[][] Alpha0Tnaf;
    public static ZTauElement[] Alpha1;
    public static SByte[][] Alpha1Tnaf;
    private static Tnaf();
    public static BigInteger Norm(sbyte mu, ZTauElement lambda);
    public static SimpleBigDecimal Norm(sbyte mu, SimpleBigDecimal u, SimpleBigDecimal v);
    public static ZTauElement Round(SimpleBigDecimal lambda0, SimpleBigDecimal lambda1, sbyte mu);
    public static SimpleBigDecimal ApproximateDivisionByN(BigInteger k, BigInteger s, BigInteger vm, sbyte a, int m, int c);
    public static SByte[] TauAdicNaf(sbyte mu, ZTauElement lambda);
    public static AbstractF2mPoint Tau(AbstractF2mPoint p);
    public static sbyte GetMu(AbstractF2mCurve curve);
    public static sbyte GetMu(ECFieldElement curveA);
    public static sbyte GetMu(int curveA);
    public static BigInteger[] GetLucas(sbyte mu, int k, bool doV);
    public static BigInteger GetTw(sbyte mu, int w);
    public static BigInteger[] GetSi(AbstractF2mCurve curve);
    public static BigInteger[] GetSi(int fieldSize, int curveA, BigInteger cofactor);
    protected static int GetShiftsForCofactor(BigInteger h);
    public static ZTauElement PartModReduction(BigInteger k, int m, sbyte a, BigInteger[] s, sbyte mu, sbyte c);
    public static AbstractF2mPoint MultiplyRTnaf(AbstractF2mPoint p, BigInteger k);
    public static AbstractF2mPoint MultiplyTnaf(AbstractF2mPoint p, ZTauElement lambda);
    public static AbstractF2mPoint MultiplyFromTnaf(AbstractF2mPoint p, SByte[] u);
    public static SByte[] TauAdicWNaf(sbyte mu, ZTauElement lambda, sbyte width, BigInteger pow2w, BigInteger tw, ZTauElement[] alpha);
    public static AbstractF2mPoint[] GetPreComp(AbstractF2mPoint p, sbyte a);
}
internal class NBitcoin.BouncyCastle.Math.EC.Abc.ZTauElement : object {
    public BigInteger u;
    public BigInteger v;
    public ZTauElement(BigInteger u, BigInteger v);
}
internal abstract class NBitcoin.BouncyCastle.Math.EC.AbstractF2mCurve : ECCurve {
    private BigInteger[] si;
    public bool IsKoblitz { get; }
    protected AbstractF2mCurve(int m, int k1, int k2, int k3);
    public static BigInteger Inverse(int m, Int32[] ks, BigInteger x);
    private static IFiniteField BuildField(int m, int k1, int k2, int k3);
    public virtual bool IsValidFieldElement(BigInteger x);
    [ObsoleteAttribute("Per-point compression property will be removed")]
public virtual ECPoint CreatePoint(BigInteger x, BigInteger y, bool withCompression);
    protected virtual ECPoint DecompressPoint(int yTilde, BigInteger X1);
    private ECFieldElement SolveQuadradicEquation(ECFieldElement beta);
    internal virtual BigInteger[] GetSi();
    public virtual bool get_IsKoblitz();
}
internal abstract class NBitcoin.BouncyCastle.Math.EC.AbstractF2mPoint : ECPointBase {
    protected AbstractF2mPoint(ECCurve curve, ECFieldElement x, ECFieldElement y, bool withCompression);
    protected AbstractF2mPoint(ECCurve curve, ECFieldElement x, ECFieldElement y, ECFieldElement[] zs, bool withCompression);
    protected virtual bool SatisfiesCurveEquation();
    public virtual ECPoint ScaleX(ECFieldElement scale);
    public virtual ECPoint ScaleY(ECFieldElement scale);
    public virtual ECPoint Subtract(ECPoint b);
    public virtual AbstractF2mPoint Tau();
    public virtual AbstractF2mPoint TauPow(int pow);
}
internal abstract class NBitcoin.BouncyCastle.Math.EC.AbstractFpCurve : ECCurve {
    protected AbstractFpCurve(BigInteger q);
    public virtual bool IsValidFieldElement(BigInteger x);
    protected virtual ECPoint DecompressPoint(int yTilde, BigInteger X1);
}
internal abstract class NBitcoin.BouncyCastle.Math.EC.AbstractFpPoint : ECPointBase {
    protected internal bool CompressionYTilde { get; }
    protected AbstractFpPoint(ECCurve curve, ECFieldElement x, ECFieldElement y, bool withCompression);
    protected AbstractFpPoint(ECCurve curve, ECFieldElement x, ECFieldElement y, ECFieldElement[] zs, bool withCompression);
    protected internal virtual bool get_CompressionYTilde();
    protected virtual bool SatisfiesCurveEquation();
    public virtual ECPoint Subtract(ECPoint b);
}
internal class NBitcoin.BouncyCastle.Math.EC.Custom.Sec.SecP256K1Curve : AbstractFpCurve {
    public static BigInteger q;
    private static int SECP256K1_DEFAULT_COORDS;
    protected SecP256K1Point m_infinity;
    public BigInteger QQ { get; }
    public ECPoint Infinity { get; }
    public int FieldSize { get; }
    private static SecP256K1Curve();
    protected virtual ECCurve CloneCurve();
    public virtual bool SupportsCoordinateSystem(int coord);
    public virtual BigInteger get_QQ();
    public virtual ECPoint get_Infinity();
    public virtual int get_FieldSize();
    public virtual ECFieldElement FromBigInteger(BigInteger x);
    protected internal virtual ECPoint CreateRawPoint(ECFieldElement x, ECFieldElement y, bool withCompression);
    protected internal virtual ECPoint CreateRawPoint(ECFieldElement x, ECFieldElement y, ECFieldElement[] zs, bool withCompression);
}
internal class NBitcoin.BouncyCastle.Math.EC.Custom.Sec.SecP256K1Field : object {
    internal static UInt32[] P;
    internal static UInt32[] PExt;
    private static UInt32[] PExtInv;
    private static UInt32 P7;
    private static UInt32 PExt15;
    private static UInt32 PInv33;
    private static SecP256K1Field();
    public static void Add(UInt32[] x, UInt32[] y, UInt32[] z);
    public static void AddExt(UInt32[] xx, UInt32[] yy, UInt32[] zz);
    public static void AddOne(UInt32[] x, UInt32[] z);
    public static UInt32[] FromBigInteger(BigInteger x);
    public static void Half(UInt32[] x, UInt32[] z);
    public static void Multiply(UInt32[] x, UInt32[] y, UInt32[] z);
    public static void MultiplyAddToExt(UInt32[] x, UInt32[] y, UInt32[] zz);
    public static void Negate(UInt32[] x, UInt32[] z);
    public static void Reduce(UInt32[] xx, UInt32[] z);
    public static void Reduce32(UInt32 x, UInt32[] z);
    public static void Square(UInt32[] x, UInt32[] z);
    public static void SquareN(UInt32[] x, int n, UInt32[] z);
    public static void Subtract(UInt32[] x, UInt32[] y, UInt32[] z);
    public static void SubtractExt(UInt32[] xx, UInt32[] yy, UInt32[] zz);
    public static void Twice(UInt32[] x, UInt32[] z);
}
internal class NBitcoin.BouncyCastle.Math.EC.Custom.Sec.SecP256K1FieldElement : ECFieldElement {
    public static BigInteger Q;
    protected internal UInt32[] x;
    public bool IsZero { get; }
    public bool IsOne { get; }
    public string FieldName { get; }
    public int FieldSize { get; }
    public SecP256K1FieldElement(BigInteger x);
    protected internal SecP256K1FieldElement(UInt32[] x);
    private static SecP256K1FieldElement();
    public virtual bool get_IsZero();
    public virtual bool get_IsOne();
    public virtual bool TestBitZero();
    public virtual BigInteger ToBigInteger();
    public virtual string get_FieldName();
    public virtual int get_FieldSize();
    public virtual ECFieldElement Add(ECFieldElement b);
    public virtual ECFieldElement AddOne();
    public virtual ECFieldElement Subtract(ECFieldElement b);
    public virtual ECFieldElement Multiply(ECFieldElement b);
    public virtual ECFieldElement Divide(ECFieldElement b);
    public virtual ECFieldElement Negate();
    public virtual ECFieldElement Square();
    public virtual ECFieldElement Invert();
    public virtual ECFieldElement Sqrt();
    public virtual bool Equals(object obj);
    public virtual bool Equals(ECFieldElement other);
    public virtual bool Equals(SecP256K1FieldElement other);
    public virtual int GetHashCode();
}
internal class NBitcoin.BouncyCastle.Math.EC.Custom.Sec.SecP256K1Point : AbstractFpPoint {
    public SecP256K1Point(ECCurve curve, ECFieldElement x, ECFieldElement y);
    public SecP256K1Point(ECCurve curve, ECFieldElement x, ECFieldElement y, bool withCompression);
    internal SecP256K1Point(ECCurve curve, ECFieldElement x, ECFieldElement y, ECFieldElement[] zs, bool withCompression);
    protected virtual ECPoint Detach();
    public virtual ECPoint Add(ECPoint b);
    public virtual ECPoint Twice();
    public virtual ECPoint TwicePlus(ECPoint b);
    public virtual ECPoint ThreeTimes();
    public virtual ECPoint Negate();
}
internal class NBitcoin.BouncyCastle.Math.EC.ECAlgorithms : object {
    public static bool IsF2mCurve(ECCurve c);
    public static bool IsF2mField(IFiniteField field);
    public static bool IsFpCurve(ECCurve c);
    public static bool IsFpField(IFiniteField field);
    public static ECPoint SumOfMultiplies(ECPoint[] ps, BigInteger[] ks);
    public static ECPoint SumOfTwoMultiplies(ECPoint P, BigInteger a, ECPoint Q, BigInteger b);
    public static ECPoint ShamirsTrick(ECPoint P, BigInteger k, ECPoint Q, BigInteger l);
    public static ECPoint ImportPoint(ECCurve c, ECPoint p);
    public static void MontgomeryTrick(ECFieldElement[] zs, int off, int len);
    public static void MontgomeryTrick(ECFieldElement[] zs, int off, int len, ECFieldElement scale);
    public static ECPoint ReferenceMultiply(ECPoint p, BigInteger k);
    public static ECPoint ValidatePoint(ECPoint p);
    internal static ECPoint ImplShamirsTrickJsf(ECPoint P, BigInteger k, ECPoint Q, BigInteger l);
    internal static ECPoint ImplShamirsTrickWNaf(ECPoint P, BigInteger k, ECPoint Q, BigInteger l);
    internal static ECPoint ImplShamirsTrickWNaf(ECPoint P, BigInteger k, ECPointMap pointMapQ, BigInteger l);
    private static ECPoint ImplShamirsTrickWNaf(ECPoint[] preCompP, ECPoint[] preCompNegP, Byte[] wnafP, ECPoint[] preCompQ, ECPoint[] preCompNegQ, Byte[] wnafQ);
    internal static ECPoint ImplSumOfMultiplies(ECPoint[] ps, BigInteger[] ks);
    internal static ECPoint ImplSumOfMultipliesGlv(ECPoint[] ps, BigInteger[] ks, GlvEndomorphism glvEndomorphism);
    internal static ECPoint ImplSumOfMultiplies(ECPoint[] ps, ECPointMap pointMap, BigInteger[] ks);
    private static ECPoint ImplSumOfMultiplies(Boolean[] negs, WNafPreCompInfo[] infos, Byte[][] wnafs);
}
internal abstract class NBitcoin.BouncyCastle.Math.EC.ECCurve : object {
    public static int COORD_AFFINE;
    public static int COORD_HOMOGENEOUS;
    public static int COORD_JACOBIAN;
    public static int COORD_JACOBIAN_CHUDNOVSKY;
    public static int COORD_JACOBIAN_MODIFIED;
    public static int COORD_LAMBDA_AFFINE;
    public static int COORD_LAMBDA_PROJECTIVE;
    public static int COORD_SKEWED;
    protected IFiniteField m_field;
    protected ECFieldElement m_a;
    protected ECFieldElement m_b;
    protected BigInteger m_order;
    protected BigInteger m_cofactor;
    protected int m_coord;
    protected ECEndomorphism m_endomorphism;
    protected ECMultiplier m_multiplier;
    public int FieldSize { get; }
    public ECPoint Infinity { get; }
    public IFiniteField Field { get; }
    public ECFieldElement A { get; }
    public ECFieldElement B { get; }
    public BigInteger Order { get; }
    public BigInteger Cofactor { get; }
    public int CoordinateSystem { get; }
    protected ECCurve(IFiniteField field);
    public static Int32[] GetAllCoordinateSystems();
    public abstract virtual int get_FieldSize();
    public abstract virtual ECFieldElement FromBigInteger(BigInteger x);
    public abstract virtual bool IsValidFieldElement(BigInteger x);
    public virtual Config Configure();
    public virtual ECPoint ValidatePoint(BigInteger x, BigInteger y);
    [ObsoleteAttribute("Per-point compression property will be removed")]
public virtual ECPoint ValidatePoint(BigInteger x, BigInteger y, bool withCompression);
    public virtual ECPoint CreatePoint(BigInteger x, BigInteger y);
    [ObsoleteAttribute("Per-point compression property will be removed")]
public virtual ECPoint CreatePoint(BigInteger x, BigInteger y, bool withCompression);
    protected abstract virtual ECCurve CloneCurve();
    protected internal abstract virtual ECPoint CreateRawPoint(ECFieldElement x, ECFieldElement y, bool withCompression);
    protected internal abstract virtual ECPoint CreateRawPoint(ECFieldElement x, ECFieldElement y, ECFieldElement[] zs, bool withCompression);
    protected virtual ECMultiplier CreateDefaultMultiplier();
    public virtual bool SupportsCoordinateSystem(int coord);
    public virtual PreCompInfo GetPreCompInfo(ECPoint point, string name);
    public virtual void SetPreCompInfo(ECPoint point, string name, PreCompInfo preCompInfo);
    public virtual ECPoint ImportPoint(ECPoint p);
    public virtual void NormalizeAll(ECPoint[] points);
    public virtual void NormalizeAll(ECPoint[] points, int off, int len, ECFieldElement iso);
    public abstract virtual ECPoint get_Infinity();
    public virtual IFiniteField get_Field();
    public virtual ECFieldElement get_A();
    public virtual ECFieldElement get_B();
    public virtual BigInteger get_Order();
    public virtual BigInteger get_Cofactor();
    public virtual int get_CoordinateSystem();
    protected virtual void CheckPoint(ECPoint point);
    protected virtual void CheckPoints(ECPoint[] points);
    protected virtual void CheckPoints(ECPoint[] points, int off, int len);
    public virtual bool Equals(ECCurve other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    protected abstract virtual ECPoint DecompressPoint(int yTilde, BigInteger X1);
    public virtual ECEndomorphism GetEndomorphism();
    public virtual ECMultiplier GetMultiplier();
    public virtual ECPoint DecodePoint(Byte[] encoded);
}
internal abstract class NBitcoin.BouncyCastle.Math.EC.ECFieldElement : object {
    public string FieldName { get; }
    public int FieldSize { get; }
    public int BitLength { get; }
    public bool IsOne { get; }
    public bool IsZero { get; }
    public abstract virtual BigInteger ToBigInteger();
    public abstract virtual string get_FieldName();
    public abstract virtual int get_FieldSize();
    public abstract virtual ECFieldElement Add(ECFieldElement b);
    public abstract virtual ECFieldElement AddOne();
    public abstract virtual ECFieldElement Subtract(ECFieldElement b);
    public abstract virtual ECFieldElement Multiply(ECFieldElement b);
    public abstract virtual ECFieldElement Divide(ECFieldElement b);
    public abstract virtual ECFieldElement Negate();
    public abstract virtual ECFieldElement Square();
    public abstract virtual ECFieldElement Invert();
    public abstract virtual ECFieldElement Sqrt();
    public virtual int get_BitLength();
    public virtual bool get_IsOne();
    public virtual bool get_IsZero();
    public virtual ECFieldElement MultiplyMinusProduct(ECFieldElement b, ECFieldElement x, ECFieldElement y);
    public virtual ECFieldElement MultiplyPlusProduct(ECFieldElement b, ECFieldElement x, ECFieldElement y);
    public virtual ECFieldElement SquareMinusProduct(ECFieldElement x, ECFieldElement y);
    public virtual ECFieldElement SquarePlusProduct(ECFieldElement x, ECFieldElement y);
    public virtual ECFieldElement SquarePow(int pow);
    public virtual bool TestBitZero();
    public virtual bool Equals(object obj);
    public virtual bool Equals(ECFieldElement other);
    public virtual int GetHashCode();
    public virtual string ToString();
    public virtual Byte[] GetEncoded();
}
internal abstract class NBitcoin.BouncyCastle.Math.EC.ECPoint : object {
    protected static ECFieldElement[] EMPTY_ZS;
    protected internal ECCurve m_curve;
    protected internal ECFieldElement m_x;
    protected internal ECFieldElement m_y;
    protected internal ECFieldElement[] m_zs;
    protected internal bool m_withCompression;
    protected internal IDictionary m_preCompTable;
    public ECCurve Curve { get; }
    protected int CurveCoordinateSystem { get; }
    [ObsoleteAttribute("Use AffineXCoord, or Normalize() and XCoord, instead")]
public ECFieldElement X { get; }
    [ObsoleteAttribute("Use AffineYCoord, or Normalize() and YCoord, instead")]
public ECFieldElement Y { get; }
    public ECFieldElement AffineXCoord { get; }
    public ECFieldElement AffineYCoord { get; }
    public ECFieldElement XCoord { get; }
    public ECFieldElement YCoord { get; }
    protected internal ECFieldElement RawXCoord { get; }
    protected internal ECFieldElement RawYCoord { get; }
    protected internal ECFieldElement[] RawZCoords { get; }
    public bool IsInfinity { get; }
    public bool IsCompressed { get; }
    protected internal bool CompressionYTilde { get; }
    protected ECPoint(ECCurve curve, ECFieldElement x, ECFieldElement y, bool withCompression);
    internal ECPoint(ECCurve curve, ECFieldElement x, ECFieldElement y, ECFieldElement[] zs, bool withCompression);
    private static ECPoint();
    protected static ECFieldElement[] GetInitialZCoords(ECCurve curve);
    protected internal bool SatisfiesCofactor();
    protected abstract virtual bool SatisfiesCurveEquation();
    public ECPoint GetDetachedPoint();
    public virtual ECCurve get_Curve();
    protected abstract virtual ECPoint Detach();
    protected virtual int get_CurveCoordinateSystem();
    public virtual ECFieldElement get_X();
    public virtual ECFieldElement get_Y();
    public virtual ECFieldElement get_AffineXCoord();
    public virtual ECFieldElement get_AffineYCoord();
    public virtual ECFieldElement get_XCoord();
    public virtual ECFieldElement get_YCoord();
    public virtual ECFieldElement GetZCoord(int index);
    public virtual ECFieldElement[] GetZCoords();
    protected internal ECFieldElement get_RawXCoord();
    protected internal ECFieldElement get_RawYCoord();
    protected internal ECFieldElement[] get_RawZCoords();
    protected virtual void CheckNormalized();
    public virtual bool IsNormalized();
    public virtual ECPoint Normalize();
    internal virtual ECPoint Normalize(ECFieldElement zInv);
    protected virtual ECPoint CreateScaledPoint(ECFieldElement sx, ECFieldElement sy);
    public bool get_IsInfinity();
    public bool get_IsCompressed();
    public bool IsValid();
    public virtual ECPoint ScaleX(ECFieldElement scale);
    public virtual ECPoint ScaleY(ECFieldElement scale);
    public virtual bool Equals(object obj);
    public virtual bool Equals(ECPoint other);
    public virtual int GetHashCode();
    public virtual string ToString();
    public virtual Byte[] GetEncoded();
    public abstract virtual Byte[] GetEncoded(bool compressed);
    protected internal abstract virtual bool get_CompressionYTilde();
    public abstract virtual ECPoint Add(ECPoint b);
    public abstract virtual ECPoint Subtract(ECPoint b);
    public abstract virtual ECPoint Negate();
    public virtual ECPoint TimesPow2(int e);
    public abstract virtual ECPoint Twice();
    public abstract virtual ECPoint Multiply(BigInteger b);
    public virtual ECPoint TwicePlus(ECPoint b);
    public virtual ECPoint ThreeTimes();
}
internal abstract class NBitcoin.BouncyCastle.Math.EC.ECPointBase : ECPoint {
    protected internal ECPointBase(ECCurve curve, ECFieldElement x, ECFieldElement y, bool withCompression);
    protected internal ECPointBase(ECCurve curve, ECFieldElement x, ECFieldElement y, ECFieldElement[] zs, bool withCompression);
    public virtual Byte[] GetEncoded(bool compressed);
    public virtual ECPoint Multiply(BigInteger k);
}
internal interface NBitcoin.BouncyCastle.Math.EC.ECPointMap {
    public abstract virtual ECPoint Map(ECPoint p);
}
internal interface NBitcoin.BouncyCastle.Math.EC.Endo.ECEndomorphism {
    public ECPointMap PointMap { get; }
    public bool HasEfficientPointMap { get; }
    public abstract virtual ECPointMap get_PointMap();
    public abstract virtual bool get_HasEfficientPointMap();
}
internal interface NBitcoin.BouncyCastle.Math.EC.Endo.GlvEndomorphism {
    public abstract virtual BigInteger[] DecomposeScalar(BigInteger k);
}
internal class NBitcoin.BouncyCastle.Math.EC.Endo.GlvTypeBEndomorphism : object {
    protected ECCurve m_curve;
    protected GlvTypeBParameters m_parameters;
    protected ECPointMap m_pointMap;
    public ECPointMap PointMap { get; }
    public bool HasEfficientPointMap { get; }
    public GlvTypeBEndomorphism(ECCurve curve, GlvTypeBParameters parameters);
    public virtual BigInteger[] DecomposeScalar(BigInteger k);
    public virtual ECPointMap get_PointMap();
    public virtual bool get_HasEfficientPointMap();
    protected virtual BigInteger CalculateB(BigInteger k, BigInteger g, int t);
}
internal class NBitcoin.BouncyCastle.Math.EC.Endo.GlvTypeBParameters : object {
    protected BigInteger m_beta;
    protected BigInteger m_lambda;
    protected BigInteger[] m_v1;
    protected BigInteger[] m_v2;
    protected BigInteger m_g1;
    protected BigInteger m_g2;
    protected int m_bits;
    public BigInteger Beta { get; }
    public BigInteger Lambda { get; }
    public BigInteger[] V1 { get; }
    public BigInteger[] V2 { get; }
    public BigInteger G1 { get; }
    public BigInteger G2 { get; }
    public int Bits { get; }
    public GlvTypeBParameters(BigInteger beta, BigInteger lambda, BigInteger[] v1, BigInteger[] v2, BigInteger g1, BigInteger g2, int bits);
    public virtual BigInteger get_Beta();
    public virtual BigInteger get_Lambda();
    public virtual BigInteger[] get_V1();
    public virtual BigInteger[] get_V2();
    public virtual BigInteger get_G1();
    public virtual BigInteger get_G2();
    public virtual int get_Bits();
}
internal class NBitcoin.BouncyCastle.Math.EC.F2mCurve : AbstractF2mCurve {
    private static int F2M_DEFAULT_COORDS;
    private int m;
    private int k1;
    private int k2;
    private int k3;
    protected F2mPoint m_infinity;
    public int FieldSize { get; }
    public ECPoint Infinity { get; }
    public int M { get; }
    public int K1 { get; }
    public int K2 { get; }
    public int K3 { get; }
    [ObsoleteAttribute("Use 'Order' property instead")]
public BigInteger N { get; }
    [ObsoleteAttribute("Use 'Cofactor' property instead")]
public BigInteger H { get; }
    public F2mCurve(int m, int k, BigInteger a, BigInteger b);
    public F2mCurve(int m, int k, BigInteger a, BigInteger b, BigInteger order, BigInteger cofactor);
    public F2mCurve(int m, int k1, int k2, int k3, BigInteger a, BigInteger b);
    public F2mCurve(int m, int k1, int k2, int k3, BigInteger a, BigInteger b, BigInteger order, BigInteger cofactor);
    protected F2mCurve(int m, int k1, int k2, int k3, ECFieldElement a, ECFieldElement b, BigInteger order, BigInteger cofactor);
    protected virtual ECCurve CloneCurve();
    public virtual bool SupportsCoordinateSystem(int coord);
    protected virtual ECMultiplier CreateDefaultMultiplier();
    public virtual int get_FieldSize();
    public virtual ECFieldElement FromBigInteger(BigInteger x);
    protected internal virtual ECPoint CreateRawPoint(ECFieldElement x, ECFieldElement y, bool withCompression);
    protected internal virtual ECPoint CreateRawPoint(ECFieldElement x, ECFieldElement y, ECFieldElement[] zs, bool withCompression);
    public virtual ECPoint get_Infinity();
    public int get_M();
    public bool IsTrinomial();
    public int get_K1();
    public int get_K2();
    public int get_K3();
    public BigInteger get_N();
    public BigInteger get_H();
}
internal class NBitcoin.BouncyCastle.Math.EC.F2mFieldElement : ECFieldElement {
    public static int Gnb;
    public static int Tpb;
    public static int Ppb;
    private int representation;
    private int m;
    private Int32[] ks;
    private LongArray x;
    public int BitLength { get; }
    public bool IsOne { get; }
    public bool IsZero { get; }
    public string FieldName { get; }
    public int FieldSize { get; }
    public int Representation { get; }
    public int M { get; }
    public int K1 { get; }
    public int K2 { get; }
    public int K3 { get; }
    public F2mFieldElement(int m, int k1, int k2, int k3, BigInteger x);
    public F2mFieldElement(int m, int k, BigInteger x);
    private F2mFieldElement(int m, Int32[] ks, LongArray x);
    public virtual int get_BitLength();
    public virtual bool get_IsOne();
    public virtual bool get_IsZero();
    public virtual bool TestBitZero();
    public virtual BigInteger ToBigInteger();
    public virtual string get_FieldName();
    public virtual int get_FieldSize();
    public static void CheckFieldElements(ECFieldElement a, ECFieldElement b);
    public virtual ECFieldElement Add(ECFieldElement b);
    public virtual ECFieldElement AddOne();
    public virtual ECFieldElement Subtract(ECFieldElement b);
    public virtual ECFieldElement Multiply(ECFieldElement b);
    public virtual ECFieldElement MultiplyMinusProduct(ECFieldElement b, ECFieldElement x, ECFieldElement y);
    public virtual ECFieldElement MultiplyPlusProduct(ECFieldElement b, ECFieldElement x, ECFieldElement y);
    public virtual ECFieldElement Divide(ECFieldElement b);
    public virtual ECFieldElement Negate();
    public virtual ECFieldElement Square();
    public virtual ECFieldElement SquareMinusProduct(ECFieldElement x, ECFieldElement y);
    public virtual ECFieldElement SquarePlusProduct(ECFieldElement x, ECFieldElement y);
    public virtual ECFieldElement SquarePow(int pow);
    public virtual ECFieldElement Invert();
    public virtual ECFieldElement Sqrt();
    public int get_Representation();
    public int get_M();
    public int get_K1();
    public int get_K2();
    public int get_K3();
    public virtual bool Equals(object obj);
    public virtual bool Equals(F2mFieldElement other);
    public virtual int GetHashCode();
}
internal class NBitcoin.BouncyCastle.Math.EC.F2mPoint : AbstractF2mPoint {
    public ECFieldElement YCoord { get; }
    protected internal bool CompressionYTilde { get; }
    public F2mPoint(ECCurve curve, ECFieldElement x, ECFieldElement y);
    public F2mPoint(ECCurve curve, ECFieldElement x, ECFieldElement y, bool withCompression);
    internal F2mPoint(ECCurve curve, ECFieldElement x, ECFieldElement y, ECFieldElement[] zs, bool withCompression);
    [ObsoleteAttribute("Use ECCurve.Infinity property")]
public F2mPoint(ECCurve curve);
    protected virtual ECPoint Detach();
    public virtual ECFieldElement get_YCoord();
    protected internal virtual bool get_CompressionYTilde();
    public virtual ECPoint Add(ECPoint b);
    public virtual ECPoint Twice();
    public virtual ECPoint TwicePlus(ECPoint b);
    public virtual ECPoint Negate();
}
internal class NBitcoin.BouncyCastle.Math.EC.FpCurve : AbstractFpCurve {
    private static int FP_DEFAULT_COORDS;
    protected BigInteger m_q;
    protected BigInteger m_r;
    protected FpPoint m_infinity;
    public BigInteger Q { get; }
    public ECPoint Infinity { get; }
    public int FieldSize { get; }
    public FpCurve(BigInteger q, BigInteger a, BigInteger b);
    public FpCurve(BigInteger q, BigInteger a, BigInteger b, BigInteger order, BigInteger cofactor);
    protected FpCurve(BigInteger q, BigInteger r, ECFieldElement a, ECFieldElement b);
    protected FpCurve(BigInteger q, BigInteger r, ECFieldElement a, ECFieldElement b, BigInteger order, BigInteger cofactor);
    protected virtual ECCurve CloneCurve();
    public virtual bool SupportsCoordinateSystem(int coord);
    public virtual BigInteger get_Q();
    public virtual ECPoint get_Infinity();
    public virtual int get_FieldSize();
    public virtual ECFieldElement FromBigInteger(BigInteger x);
    protected internal virtual ECPoint CreateRawPoint(ECFieldElement x, ECFieldElement y, bool withCompression);
    protected internal virtual ECPoint CreateRawPoint(ECFieldElement x, ECFieldElement y, ECFieldElement[] zs, bool withCompression);
    public virtual ECPoint ImportPoint(ECPoint p);
}
internal class NBitcoin.BouncyCastle.Math.EC.FpFieldElement : ECFieldElement {
    private BigInteger q;
    private BigInteger r;
    private BigInteger x;
    public string FieldName { get; }
    public int FieldSize { get; }
    public BigInteger Q { get; }
    [ObsoleteAttribute("Use ECCurve.FromBigInteger to construct field elements")]
public FpFieldElement(BigInteger q, BigInteger x);
    internal FpFieldElement(BigInteger q, BigInteger r, BigInteger x);
    internal static BigInteger CalculateResidue(BigInteger p);
    public virtual BigInteger ToBigInteger();
    public virtual string get_FieldName();
    public virtual int get_FieldSize();
    public BigInteger get_Q();
    public virtual ECFieldElement Add(ECFieldElement b);
    public virtual ECFieldElement AddOne();
    public virtual ECFieldElement Subtract(ECFieldElement b);
    public virtual ECFieldElement Multiply(ECFieldElement b);
    public virtual ECFieldElement MultiplyMinusProduct(ECFieldElement b, ECFieldElement x, ECFieldElement y);
    public virtual ECFieldElement MultiplyPlusProduct(ECFieldElement b, ECFieldElement x, ECFieldElement y);
    public virtual ECFieldElement Divide(ECFieldElement b);
    public virtual ECFieldElement Negate();
    public virtual ECFieldElement Square();
    public virtual ECFieldElement SquareMinusProduct(ECFieldElement x, ECFieldElement y);
    public virtual ECFieldElement SquarePlusProduct(ECFieldElement x, ECFieldElement y);
    public virtual ECFieldElement Invert();
    public virtual ECFieldElement Sqrt();
    private ECFieldElement CheckSqrt(ECFieldElement z);
    private BigInteger[] LucasSequence(BigInteger P, BigInteger Q, BigInteger k);
    protected virtual BigInteger ModAdd(BigInteger x1, BigInteger x2);
    protected virtual BigInteger ModDouble(BigInteger x);
    protected virtual BigInteger ModHalf(BigInteger x);
    protected virtual BigInteger ModHalfAbs(BigInteger x);
    protected virtual BigInteger ModInverse(BigInteger x);
    protected virtual BigInteger ModMult(BigInteger x1, BigInteger x2);
    protected virtual BigInteger ModReduce(BigInteger x);
    protected virtual BigInteger ModSubtract(BigInteger x1, BigInteger x2);
    public virtual bool Equals(object obj);
    public virtual bool Equals(FpFieldElement other);
    public virtual int GetHashCode();
}
internal class NBitcoin.BouncyCastle.Math.EC.FpPoint : AbstractFpPoint {
    public FpPoint(ECCurve curve, ECFieldElement x, ECFieldElement y);
    public FpPoint(ECCurve curve, ECFieldElement x, ECFieldElement y, bool withCompression);
    internal FpPoint(ECCurve curve, ECFieldElement x, ECFieldElement y, ECFieldElement[] zs, bool withCompression);
    protected virtual ECPoint Detach();
    public virtual ECFieldElement GetZCoord(int index);
    public virtual ECPoint Add(ECPoint b);
    public virtual ECPoint Twice();
    public virtual ECPoint TwicePlus(ECPoint b);
    public virtual ECPoint ThreeTimes();
    public virtual ECPoint TimesPow2(int e);
    protected virtual ECFieldElement Two(ECFieldElement x);
    protected virtual ECFieldElement Three(ECFieldElement x);
    protected virtual ECFieldElement Four(ECFieldElement x);
    protected virtual ECFieldElement Eight(ECFieldElement x);
    protected virtual ECFieldElement DoubleProductFromSquares(ECFieldElement a, ECFieldElement b, ECFieldElement aSquared, ECFieldElement bSquared);
    public virtual ECPoint Negate();
    protected virtual ECFieldElement CalculateJacobianModifiedW(ECFieldElement Z, ECFieldElement ZSquared);
    protected virtual ECFieldElement GetJacobianModifiedW();
    protected virtual FpPoint TwiceJacobianModified(bool calculateW);
}
internal class NBitcoin.BouncyCastle.Math.EC.LongArray : object {
    private static UInt16[] INTERLEAVE2_TABLE;
    private static Int32[] INTERLEAVE3_TABLE;
    private static Int32[] INTERLEAVE4_TABLE;
    private static Int32[] INTERLEAVE5_TABLE;
    private static Int64[] INTERLEAVE7_TABLE;
    private static string ZEROES;
    internal static Byte[] BitLengths;
    private Int64[] m_ints;
    public int Length { get; }
    public LongArray(int intLen);
    public LongArray(Int64[] ints);
    public LongArray(Int64[] ints, int off, int len);
    public LongArray(BigInteger bigInt);
    private static LongArray();
    public bool IsOne();
    public bool IsZero();
    public int GetUsedLength();
    public int GetUsedLengthFrom(int from);
    public int Degree();
    private int DegreeFrom(int limit);
    private static int BitLength(long w);
    private Int64[] ResizedInts(int newLen);
    public BigInteger ToBigInteger();
    private static long ShiftUp(Int64[] x, int xOff, int count, int shift);
    private static long ShiftUp(Int64[] x, int xOff, Int64[] z, int zOff, int count, int shift);
    public LongArray AddOne();
    private void AddShiftedByBitsSafe(LongArray other, int otherDegree, int bits);
    private static long AddShiftedUp(Int64[] x, int xOff, Int64[] y, int yOff, int count, int shift);
    private static long AddShiftedDown(Int64[] x, int xOff, Int64[] y, int yOff, int count, int shift);
    public void AddShiftedByWords(LongArray other, int words);
    private static void Add(Int64[] x, int xOff, Int64[] y, int yOff, int count);
    private static void Add(Int64[] x, int xOff, Int64[] y, int yOff, Int64[] z, int zOff, int count);
    private static void AddBoth(Int64[] x, int xOff, Int64[] y1, int y1Off, Int64[] y2, int y2Off, int count);
    private static void Distribute(Int64[] x, int src, int dst1, int dst2, int count);
    public int get_Length();
    private static void FlipWord(Int64[] buf, int off, int bit, long word);
    public bool TestBitZero();
    private static bool TestBit(Int64[] buf, int off, int n);
    private static void FlipBit(Int64[] buf, int off, int n);
    private static void MultiplyWord(long a, Int64[] b, int bLen, Int64[] c, int cOff);
    public LongArray ModMultiplyLD(LongArray other, int m, Int32[] ks);
    public LongArray ModMultiply(LongArray other, int m, Int32[] ks);
    public LongArray ModMultiplyAlt(LongArray other, int m, Int32[] ks);
    public LongArray ModReduce(int m, Int32[] ks);
    public LongArray Multiply(LongArray other, int m, Int32[] ks);
    public void Reduce(int m, Int32[] ks);
    private static LongArray ReduceResult(Int64[] buf, int off, int len, int m, Int32[] ks);
    private static int ReduceInPlace(Int64[] buf, int off, int len, int m, Int32[] ks);
    private static void ReduceBitWise(Int64[] buf, int off, int BitLength, int m, Int32[] ks);
    private static void ReduceBit(Int64[] buf, int off, int bit, int m, Int32[] ks);
    private static void ReduceWordWise(Int64[] buf, int off, int len, int toBit, int m, Int32[] ks);
    private static void ReduceWord(Int64[] buf, int off, int bit, long word, int m, Int32[] ks);
    private static void ReduceVectorWise(Int64[] buf, int off, int len, int words, int m, Int32[] ks);
    private static void FlipVector(Int64[] x, int xOff, Int64[] y, int yOff, int yLen, int bits);
    public LongArray ModSquare(int m, Int32[] ks);
    public LongArray ModSquareN(int n, int m, Int32[] ks);
    public LongArray Square(int m, Int32[] ks);
    private static void SquareInPlace(Int64[] x, int xLen, int m, Int32[] ks);
    private static void Interleave(Int64[] x, int xOff, Int64[] z, int zOff, int count, int width);
    private static void Interleave3(Int64[] x, int xOff, Int64[] z, int zOff, int count);
    private static long Interleave3(long x);
    private static long Interleave3_21to63(int x);
    private static void Interleave5(Int64[] x, int xOff, Int64[] z, int zOff, int count);
    private static long Interleave5(long x);
    private static long Interleave3_13to65(int x);
    private static void Interleave7(Int64[] x, int xOff, Int64[] z, int zOff, int count);
    private static long Interleave7(long x);
    private static void Interleave2_n(Int64[] x, int xOff, Int64[] z, int zOff, int count, int rounds);
    private static long Interleave2_n(long x, int rounds);
    private static long Interleave4_16to64(int x);
    private static long Interleave2_32to64(int x);
    public LongArray ModInverse(int m, Int32[] ks);
    public virtual bool Equals(object obj);
    public virtual bool Equals(LongArray other);
    public virtual int GetHashCode();
    public LongArray Copy();
    public virtual string ToString();
}
internal abstract class NBitcoin.BouncyCastle.Math.EC.Multiplier.AbstractECMultiplier : object {
    public virtual ECPoint Multiply(ECPoint p, BigInteger k);
    protected abstract virtual ECPoint MultiplyPositive(ECPoint p, BigInteger k);
}
internal class NBitcoin.BouncyCastle.Math.EC.Multiplier.DoubleAddMultiplier : AbstractECMultiplier {
    protected virtual ECPoint MultiplyPositive(ECPoint p, BigInteger k);
}
internal interface NBitcoin.BouncyCastle.Math.EC.Multiplier.ECMultiplier {
    public abstract virtual ECPoint Multiply(ECPoint p, BigInteger k);
}
internal class NBitcoin.BouncyCastle.Math.EC.Multiplier.FixedPointCombMultiplier : AbstractECMultiplier {
    protected virtual ECPoint MultiplyPositive(ECPoint p, BigInteger k);
    protected virtual int GetWidthForCombSize(int combSize);
}
internal class NBitcoin.BouncyCastle.Math.EC.Multiplier.FixedPointPreCompInfo : object {
    protected ECPoint[] m_preComp;
    protected int m_width;
    public ECPoint[] PreComp { get; public set; }
    public int Width { get; public set; }
    public virtual ECPoint[] get_PreComp();
    public virtual void set_PreComp(ECPoint[] value);
    public virtual int get_Width();
    public virtual void set_Width(int value);
}
internal class NBitcoin.BouncyCastle.Math.EC.Multiplier.FixedPointUtilities : object {
    public static string PRECOMP_NAME;
    private static FixedPointUtilities();
    public static int GetCombSize(ECCurve c);
    public static FixedPointPreCompInfo GetFixedPointPreCompInfo(PreCompInfo preCompInfo);
    public static FixedPointPreCompInfo Precompute(ECPoint p, int minWidth);
}
internal class NBitcoin.BouncyCastle.Math.EC.Multiplier.GlvMultiplier : AbstractECMultiplier {
    protected ECCurve curve;
    protected GlvEndomorphism glvEndomorphism;
    public GlvMultiplier(ECCurve curve, GlvEndomorphism glvEndomorphism);
    protected virtual ECPoint MultiplyPositive(ECPoint p, BigInteger k);
}
internal interface NBitcoin.BouncyCastle.Math.EC.Multiplier.PreCompInfo {
}
internal class NBitcoin.BouncyCastle.Math.EC.Multiplier.WNafL2RMultiplier : AbstractECMultiplier {
    protected virtual ECPoint MultiplyPositive(ECPoint p, BigInteger k);
    protected virtual int GetWindowSize(int bits);
}
internal class NBitcoin.BouncyCastle.Math.EC.Multiplier.WNafPreCompInfo : object {
    protected ECPoint[] m_preComp;
    protected ECPoint[] m_preCompNeg;
    protected ECPoint m_twice;
    public ECPoint[] PreComp { get; public set; }
    public ECPoint[] PreCompNeg { get; public set; }
    public ECPoint Twice { get; public set; }
    public virtual ECPoint[] get_PreComp();
    public virtual void set_PreComp(ECPoint[] value);
    public virtual ECPoint[] get_PreCompNeg();
    public virtual void set_PreCompNeg(ECPoint[] value);
    public virtual ECPoint get_Twice();
    public virtual void set_Twice(ECPoint value);
}
internal abstract class NBitcoin.BouncyCastle.Math.EC.Multiplier.WNafUtilities : object {
    public static string PRECOMP_NAME;
    private static Int32[] DEFAULT_WINDOW_SIZE_CUTOFFS;
    private static Byte[] EMPTY_BYTES;
    private static Int32[] EMPTY_INTS;
    private static ECPoint[] EMPTY_POINTS;
    private static WNafUtilities();
    public static Int32[] GenerateCompactNaf(BigInteger k);
    public static Int32[] GenerateCompactWindowNaf(int width, BigInteger k);
    public static Byte[] GenerateJsf(BigInteger g, BigInteger h);
    public static Byte[] GenerateNaf(BigInteger k);
    public static Byte[] GenerateWindowNaf(int width, BigInteger k);
    public static int GetNafWeight(BigInteger k);
    public static WNafPreCompInfo GetWNafPreCompInfo(ECPoint p);
    public static WNafPreCompInfo GetWNafPreCompInfo(PreCompInfo preCompInfo);
    public static int GetWindowSize(int bits);
    public static int GetWindowSize(int bits, Int32[] windowSizeCutoffs);
    public static ECPoint MapPointWithPrecomp(ECPoint p, int width, bool includeNegated, ECPointMap pointMap);
    public static WNafPreCompInfo Precompute(ECPoint p, int width, bool includeNegated);
    private static Byte[] Trim(Byte[] a, int length);
    private static Int32[] Trim(Int32[] a, int length);
    private static ECPoint[] ResizeTable(ECPoint[] a, int length);
}
internal class NBitcoin.BouncyCastle.Math.EC.Multiplier.WTauNafMultiplier : AbstractECMultiplier {
    internal static string PRECOMP_NAME;
    private static WTauNafMultiplier();
    protected virtual ECPoint MultiplyPositive(ECPoint point, BigInteger k);
    private AbstractF2mPoint MultiplyWTnaf(AbstractF2mPoint p, ZTauElement lambda, PreCompInfo preCompInfo, sbyte a, sbyte mu);
    private static AbstractF2mPoint MultiplyFromWTnaf(AbstractF2mPoint p, SByte[] u, PreCompInfo preCompInfo);
}
internal class NBitcoin.BouncyCastle.Math.EC.Multiplier.WTauNafPreCompInfo : object {
    protected AbstractF2mPoint[] m_preComp;
    public AbstractF2mPoint[] PreComp { get; public set; }
    public virtual AbstractF2mPoint[] get_PreComp();
    public virtual void set_PreComp(AbstractF2mPoint[] value);
}
internal class NBitcoin.BouncyCastle.Math.EC.ScaleXPointMap : object {
    protected ECFieldElement scale;
    public ScaleXPointMap(ECFieldElement scale);
    public virtual ECPoint Map(ECPoint p);
}
internal abstract class NBitcoin.BouncyCastle.Math.Field.FiniteFields : object {
    internal static IFiniteField GF_2;
    internal static IFiniteField GF_3;
    private static FiniteFields();
    public static IPolynomialExtensionField GetBinaryExtensionField(Int32[] exponents);
    public static IFiniteField GetPrimeField(BigInteger characteristic);
}
internal class NBitcoin.BouncyCastle.Math.Field.GenericPolynomialExtensionField : object {
    protected IFiniteField subfield;
    protected IPolynomial minimalPolynomial;
    public BigInteger Characteristic { get; }
    public int Dimension { get; }
    public IFiniteField Subfield { get; }
    public int Degree { get; }
    public IPolynomial MinimalPolynomial { get; }
    internal GenericPolynomialExtensionField(IFiniteField subfield, IPolynomial polynomial);
    public virtual BigInteger get_Characteristic();
    public virtual int get_Dimension();
    public virtual IFiniteField get_Subfield();
    public virtual int get_Degree();
    public virtual IPolynomial get_MinimalPolynomial();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class NBitcoin.BouncyCastle.Math.Field.GF2Polynomial : object {
    protected Int32[] exponents;
    public int Degree { get; }
    internal GF2Polynomial(Int32[] exponents);
    public virtual int get_Degree();
    public virtual Int32[] GetExponentsPresent();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal interface NBitcoin.BouncyCastle.Math.Field.IExtensionField {
    public IFiniteField Subfield { get; }
    public int Degree { get; }
    public abstract virtual IFiniteField get_Subfield();
    public abstract virtual int get_Degree();
}
internal interface NBitcoin.BouncyCastle.Math.Field.IFiniteField {
    public BigInteger Characteristic { get; }
    public int Dimension { get; }
    public abstract virtual BigInteger get_Characteristic();
    public abstract virtual int get_Dimension();
}
internal interface NBitcoin.BouncyCastle.Math.Field.IPolynomial {
    public int Degree { get; }
    public abstract virtual int get_Degree();
    public abstract virtual Int32[] GetExponentsPresent();
}
internal interface NBitcoin.BouncyCastle.Math.Field.IPolynomialExtensionField {
    public IPolynomial MinimalPolynomial { get; }
    public abstract virtual IPolynomial get_MinimalPolynomial();
}
internal class NBitcoin.BouncyCastle.Math.Field.PrimeField : object {
    protected BigInteger characteristic;
    public BigInteger Characteristic { get; }
    public int Dimension { get; }
    internal PrimeField(BigInteger characteristic);
    public virtual BigInteger get_Characteristic();
    public virtual int get_Dimension();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal abstract class NBitcoin.BouncyCastle.Math.Raw.Mod : object {
    private static SecureRandom RandomSource;
    private static Mod();
    public static void Invert(UInt32[] p, UInt32[] x, UInt32[] z);
    public static UInt32[] Random(UInt32[] p);
    public static void Add(UInt32[] p, UInt32[] x, UInt32[] y, UInt32[] z);
    public static void Subtract(UInt32[] p, UInt32[] x, UInt32[] y, UInt32[] z);
    private static void InversionResult(UInt32[] p, int ac, UInt32[] a, UInt32[] z);
    private static void InversionStep(UInt32[] p, UInt32[] u, int uLen, UInt32[] x, Int32& xc);
    private static int GetTrailingZeroes(UInt32 x);
}
internal abstract class NBitcoin.BouncyCastle.Math.Raw.Nat : object {
    private static ulong M;
    public static UInt32 Add(int len, UInt32[] x, UInt32[] y, UInt32[] z);
    public static UInt32 Add33At(int len, UInt32 x, UInt32[] z, int zPos);
    public static UInt32 Add33At(int len, UInt32 x, UInt32[] z, int zOff, int zPos);
    public static UInt32 Add33To(int len, UInt32 x, UInt32[] z);
    public static UInt32 Add33To(int len, UInt32 x, UInt32[] z, int zOff);
    public static UInt32 AddBothTo(int len, UInt32[] x, UInt32[] y, UInt32[] z);
    public static UInt32 AddBothTo(int len, UInt32[] x, int xOff, UInt32[] y, int yOff, UInt32[] z, int zOff);
    public static UInt32 AddDWordAt(int len, ulong x, UInt32[] z, int zPos);
    public static UInt32 AddDWordAt(int len, ulong x, UInt32[] z, int zOff, int zPos);
    public static UInt32 AddDWordTo(int len, ulong x, UInt32[] z);
    public static UInt32 AddDWordTo(int len, ulong x, UInt32[] z, int zOff);
    public static UInt32 AddTo(int len, UInt32[] x, UInt32[] z);
    public static UInt32 AddTo(int len, UInt32[] x, int xOff, UInt32[] z, int zOff);
    public static UInt32 AddWordAt(int len, UInt32 x, UInt32[] z, int zPos);
    public static UInt32 AddWordAt(int len, UInt32 x, UInt32[] z, int zOff, int zPos);
    public static UInt32 AddWordTo(int len, UInt32 x, UInt32[] z);
    public static UInt32 AddWordTo(int len, UInt32 x, UInt32[] z, int zOff);
    public static void Copy(int len, UInt32[] x, UInt32[] z);
    public static UInt32[] Copy(int len, UInt32[] x);
    public static UInt32[] Create(int len);
    public static UInt64[] Create64(int len);
    public static int Dec(int len, UInt32[] z);
    public static int Dec(int len, UInt32[] x, UInt32[] z);
    public static int DecAt(int len, UInt32[] z, int zPos);
    public static int DecAt(int len, UInt32[] z, int zOff, int zPos);
    public static bool Eq(int len, UInt32[] x, UInt32[] y);
    public static UInt32[] FromBigInteger(int bits, BigInteger x);
    public static UInt32 GetBit(UInt32[] x, int bit);
    public static bool Gte(int len, UInt32[] x, UInt32[] y);
    public static UInt32 Inc(int len, UInt32[] z);
    public static UInt32 Inc(int len, UInt32[] x, UInt32[] z);
    public static UInt32 IncAt(int len, UInt32[] z, int zPos);
    public static UInt32 IncAt(int len, UInt32[] z, int zOff, int zPos);
    public static bool IsOne(int len, UInt32[] x);
    public static bool IsZero(int len, UInt32[] x);
    public static void Mul(int len, UInt32[] x, UInt32[] y, UInt32[] zz);
    public static void Mul(int len, UInt32[] x, int xOff, UInt32[] y, int yOff, UInt32[] zz, int zzOff);
    public static UInt32 Mul31BothAdd(int len, UInt32 a, UInt32[] x, UInt32 b, UInt32[] y, UInt32[] z, int zOff);
    public static UInt32 MulWord(int len, UInt32 x, UInt32[] y, UInt32[] z);
    public static UInt32 MulWord(int len, UInt32 x, UInt32[] y, int yOff, UInt32[] z, int zOff);
    public static UInt32 MulWordAddTo(int len, UInt32 x, UInt32[] y, int yOff, UInt32[] z, int zOff);
    public static UInt32 MulWordDwordAddAt(int len, UInt32 x, ulong y, UInt32[] z, int zPos);
    public static UInt32 ShiftDownBit(int len, UInt32[] z, UInt32 c);
    public static UInt32 ShiftDownBit(int len, UInt32[] z, int zOff, UInt32 c);
    public static UInt32 ShiftDownBit(int len, UInt32[] x, UInt32 c, UInt32[] z);
    public static UInt32 ShiftDownBit(int len, UInt32[] x, int xOff, UInt32 c, UInt32[] z, int zOff);
    public static UInt32 ShiftDownBits(int len, UInt32[] z, int bits, UInt32 c);
    public static UInt32 ShiftDownBits(int len, UInt32[] z, int zOff, int bits, UInt32 c);
    public static UInt32 ShiftDownBits(int len, UInt32[] x, int bits, UInt32 c, UInt32[] z);
    public static UInt32 ShiftDownBits(int len, UInt32[] x, int xOff, int bits, UInt32 c, UInt32[] z, int zOff);
    public static UInt32 ShiftDownWord(int len, UInt32[] z, UInt32 c);
    public static UInt32 ShiftUpBit(int len, UInt32[] z, UInt32 c);
    public static UInt32 ShiftUpBit(int len, UInt32[] z, int zOff, UInt32 c);
    public static UInt32 ShiftUpBit(int len, UInt32[] x, UInt32 c, UInt32[] z);
    public static UInt32 ShiftUpBit(int len, UInt32[] x, int xOff, UInt32 c, UInt32[] z, int zOff);
    public static ulong ShiftUpBit64(int len, UInt64[] x, int xOff, ulong c, UInt64[] z, int zOff);
    public static UInt32 ShiftUpBits(int len, UInt32[] z, int bits, UInt32 c);
    public static UInt32 ShiftUpBits(int len, UInt32[] z, int zOff, int bits, UInt32 c);
    public static ulong ShiftUpBits64(int len, UInt64[] z, int zOff, int bits, ulong c);
    public static UInt32 ShiftUpBits(int len, UInt32[] x, int bits, UInt32 c, UInt32[] z);
    public static UInt32 ShiftUpBits(int len, UInt32[] x, int xOff, int bits, UInt32 c, UInt32[] z, int zOff);
    public static ulong ShiftUpBits64(int len, UInt64[] x, int xOff, int bits, ulong c, UInt64[] z, int zOff);
    public static void Square(int len, UInt32[] x, UInt32[] zz);
    public static void Square(int len, UInt32[] x, int xOff, UInt32[] zz, int zzOff);
    public static UInt32 SquareWordAdd(UInt32[] x, int xPos, UInt32[] z);
    public static UInt32 SquareWordAdd(UInt32[] x, int xOff, int xPos, UInt32[] z, int zOff);
    public static int Sub(int len, UInt32[] x, UInt32[] y, UInt32[] z);
    public static int Sub(int len, UInt32[] x, int xOff, UInt32[] y, int yOff, UInt32[] z, int zOff);
    public static int Sub33At(int len, UInt32 x, UInt32[] z, int zPos);
    public static int Sub33At(int len, UInt32 x, UInt32[] z, int zOff, int zPos);
    public static int Sub33From(int len, UInt32 x, UInt32[] z);
    public static int Sub33From(int len, UInt32 x, UInt32[] z, int zOff);
    public static int SubBothFrom(int len, UInt32[] x, UInt32[] y, UInt32[] z);
    public static int SubBothFrom(int len, UInt32[] x, int xOff, UInt32[] y, int yOff, UInt32[] z, int zOff);
    public static int SubDWordAt(int len, ulong x, UInt32[] z, int zPos);
    public static int SubDWordAt(int len, ulong x, UInt32[] z, int zOff, int zPos);
    public static int SubDWordFrom(int len, ulong x, UInt32[] z);
    public static int SubDWordFrom(int len, ulong x, UInt32[] z, int zOff);
    public static int SubFrom(int len, UInt32[] x, UInt32[] z);
    public static int SubFrom(int len, UInt32[] x, int xOff, UInt32[] z, int zOff);
    public static int SubWordAt(int len, UInt32 x, UInt32[] z, int zPos);
    public static int SubWordAt(int len, UInt32 x, UInt32[] z, int zOff, int zPos);
    public static int SubWordFrom(int len, UInt32 x, UInt32[] z);
    public static int SubWordFrom(int len, UInt32 x, UInt32[] z, int zOff);
    public static BigInteger ToBigInteger(int len, UInt32[] x);
    public static void Zero(int len, UInt32[] z);
}
internal abstract class NBitcoin.BouncyCastle.Math.Raw.Nat256 : object {
    private static ulong M;
    public static UInt32 Add(UInt32[] x, UInt32[] y, UInt32[] z);
    public static UInt32 Add(UInt32[] x, int xOff, UInt32[] y, int yOff, UInt32[] z, int zOff);
    public static UInt32 AddBothTo(UInt32[] x, UInt32[] y, UInt32[] z);
    public static UInt32 AddBothTo(UInt32[] x, int xOff, UInt32[] y, int yOff, UInt32[] z, int zOff);
    public static UInt32 AddTo(UInt32[] x, UInt32[] z);
    public static UInt32 AddTo(UInt32[] x, int xOff, UInt32[] z, int zOff, UInt32 cIn);
    public static UInt32 AddToEachOther(UInt32[] u, int uOff, UInt32[] v, int vOff);
    public static void Copy(UInt32[] x, UInt32[] z);
    public static void Copy64(UInt64[] x, UInt64[] z);
    public static UInt32[] Create();
    public static UInt64[] Create64();
    public static UInt32[] CreateExt();
    public static UInt64[] CreateExt64();
    public static bool Diff(UInt32[] x, int xOff, UInt32[] y, int yOff, UInt32[] z, int zOff);
    public static bool Eq(UInt32[] x, UInt32[] y);
    public static bool Eq64(UInt64[] x, UInt64[] y);
    public static UInt32[] FromBigInteger(BigInteger x);
    public static UInt64[] FromBigInteger64(BigInteger x);
    public static UInt32 GetBit(UInt32[] x, int bit);
    public static bool Gte(UInt32[] x, UInt32[] y);
    public static bool Gte(UInt32[] x, int xOff, UInt32[] y, int yOff);
    public static bool IsOne(UInt32[] x);
    public static bool IsOne64(UInt64[] x);
    public static bool IsZero(UInt32[] x);
    public static bool IsZero64(UInt64[] x);
    public static void Mul(UInt32[] x, UInt32[] y, UInt32[] zz);
    public static void Mul(UInt32[] x, int xOff, UInt32[] y, int yOff, UInt32[] zz, int zzOff);
    public static UInt32 MulAddTo(UInt32[] x, UInt32[] y, UInt32[] zz);
    public static UInt32 MulAddTo(UInt32[] x, int xOff, UInt32[] y, int yOff, UInt32[] zz, int zzOff);
    public static ulong Mul33Add(UInt32 w, UInt32[] x, int xOff, UInt32[] y, int yOff, UInt32[] z, int zOff);
    public static UInt32 MulByWord(UInt32 x, UInt32[] z);
    public static UInt32 MulByWordAddTo(UInt32 x, UInt32[] y, UInt32[] z);
    public static UInt32 MulWordAddTo(UInt32 x, UInt32[] y, int yOff, UInt32[] z, int zOff);
    public static UInt32 Mul33DWordAdd(UInt32 x, ulong y, UInt32[] z, int zOff);
    public static UInt32 Mul33WordAdd(UInt32 x, UInt32 y, UInt32[] z, int zOff);
    public static UInt32 MulWordDwordAdd(UInt32 x, ulong y, UInt32[] z, int zOff);
    public static UInt32 MulWord(UInt32 x, UInt32[] y, UInt32[] z, int zOff);
    public static void Square(UInt32[] x, UInt32[] zz);
    public static void Square(UInt32[] x, int xOff, UInt32[] zz, int zzOff);
    public static int Sub(UInt32[] x, UInt32[] y, UInt32[] z);
    public static int Sub(UInt32[] x, int xOff, UInt32[] y, int yOff, UInt32[] z, int zOff);
    public static int SubBothFrom(UInt32[] x, UInt32[] y, UInt32[] z);
    public static int SubFrom(UInt32[] x, UInt32[] z);
    public static int SubFrom(UInt32[] x, int xOff, UInt32[] z, int zOff);
    public static BigInteger ToBigInteger(UInt32[] x);
    public static BigInteger ToBigInteger64(UInt64[] x);
    public static void Zero(UInt32[] z);
}
internal class NBitcoin.BouncyCastle.Security.GeneralSecurityException : Exception {
    public GeneralSecurityException(string message);
    public GeneralSecurityException(string message, Exception exception);
}
internal class NBitcoin.BouncyCastle.Security.InvalidKeyException : KeyException {
    public InvalidKeyException(string message);
    public InvalidKeyException(string message, Exception exception);
}
internal class NBitcoin.BouncyCastle.Security.KeyException : GeneralSecurityException {
    public KeyException(string message);
    public KeyException(string message, Exception exception);
}
internal class NBitcoin.BouncyCastle.Security.SecureRandom : Random {
    internal static Byte[] GetNextBytes(SecureRandom random, int p);
    internal byte NextInt();
    internal void NextBytes(Byte[] cekBlock, int p1, int p2);
}
internal abstract class NBitcoin.BouncyCastle.Utilities.Arrays : object {
    public static bool AreEqual(Byte[] a, Byte[] b);
    public static bool AreEqual(Int32[] a, Int32[] b);
    private static bool HaveSameContents(Byte[] a, Byte[] b);
    private static bool HaveSameContents(Int32[] a, Int32[] b);
    public static int GetHashCode(Byte[] data);
    public static int GetHashCode(Int32[] data);
    public static int GetHashCode(UInt32[] data, int off, int len);
    public static Byte[] Clone(Byte[] data);
    public static Int32[] Clone(Int32[] data);
    internal static UInt32[] Clone(UInt32[] data);
    public static Int64[] Clone(Int64[] data);
    public static void Fill(Byte[] buf, byte b);
}
internal abstract class NBitcoin.BouncyCastle.Utilities.BigIntegers : object {
    private static int MaxIterations;
    public static Byte[] AsUnsignedByteArray(BigInteger n);
    public static Byte[] AsUnsignedByteArray(int length, BigInteger n);
    public static BigInteger CreateRandomInRange(BigInteger min, BigInteger max, SecureRandom random);
}
internal class NBitcoin.BouncyCastle.Utilities.Encoders.Hex : object {
    private static IEncoder encoder;
    private static Hex();
    public static Byte[] Encode(Byte[] data);
    public static Byte[] Encode(Byte[] data, int off, int length);
    public static int Encode(Byte[] data, Stream outStream);
    public static int Encode(Byte[] data, int off, int length, Stream outStream);
    public static Byte[] Decode(Byte[] data);
    public static Byte[] Decode(string data);
    public static int Decode(string data, Stream outStream);
}
internal class NBitcoin.BouncyCastle.Utilities.Encoders.HexEncoder : object {
    protected Byte[] encodingTable;
    protected Byte[] decodingTable;
    protected void InitialiseDecodingTable();
    public sealed virtual int Encode(Byte[] data, int off, int length, Stream outStream);
    private static bool Ignore(char c);
    public sealed virtual int Decode(Byte[] data, int off, int length, Stream outStream);
    public sealed virtual int DecodeString(string data, Stream outStream);
}
internal interface NBitcoin.BouncyCastle.Utilities.Encoders.IEncoder {
    public abstract virtual int Encode(Byte[] data, int off, int length, Stream outStream);
    public abstract virtual int Decode(Byte[] data, int off, int length, Stream outStream);
    public abstract virtual int DecodeString(string data, Stream outStream);
}
internal interface NBitcoin.BouncyCastle.Utilities.IMemoable {
    public abstract virtual IMemoable Copy();
    public abstract virtual void Reset(IMemoable other);
}
internal abstract class NBitcoin.BouncyCastle.Utilities.IO.BaseInputStream : Stream {
    private bool closed;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public sealed virtual bool get_CanRead();
    public sealed virtual bool get_CanSeek();
    public sealed virtual bool get_CanWrite();
    protected virtual void Dispose(bool disposing);
    public sealed virtual void Flush();
    public sealed virtual long get_Length();
    public sealed virtual long get_Position();
    public sealed virtual void set_Position(long value);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public sealed virtual long Seek(long offset, SeekOrigin origin);
    public sealed virtual void SetLength(long value);
    public sealed virtual void Write(Byte[] buffer, int offset, int count);
}
internal class NBitcoin.BouncyCastle.Utilities.IO.FilterStream : Stream {
    protected Stream s;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public FilterStream(Stream s);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    protected virtual void Dispose(bool disposing);
    public virtual void Flush();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual int ReadByte();
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void WriteByte(byte value);
}
internal class NBitcoin.BouncyCastle.Utilities.IO.StreamOverflowException : IOException {
    public StreamOverflowException(string message);
    public StreamOverflowException(string message, Exception exception);
}
internal class NBitcoin.BouncyCastle.Utilities.IO.Streams : object {
    private static int BufferSize;
    public static void Drain(Stream inStr);
    public static Byte[] ReadAll(Stream inStr);
    public static Byte[] ReadAllLimited(Stream inStr, int limit);
    public static int ReadFully(Stream inStr, Byte[] buf);
    public static int ReadFully(Stream inStr, Byte[] buf, int off, int len);
    public static void PipeAll(Stream inStr, Stream outStr);
    public static long PipeAllLimited(Stream inStr, long limit, Stream outStr);
}
internal abstract class NBitcoin.BouncyCastle.Utilities.Platform : object {
    private static CompareInfo InvariantCompareInfo;
    internal static string NewLine;
    private static Platform();
    private static string GetNewLine();
    internal static bool EqualsIgnoreCase(string a, string b);
    internal static string GetEnvironmentVariable(string variable);
    internal static Exception CreateNotImplementedException(string message);
    internal static IList CreateArrayList();
    internal static IList CreateArrayList(int capacity);
    internal static IList CreateArrayList(ICollection collection);
    internal static IList CreateArrayList(IEnumerable collection);
    internal static IDictionary CreateHashtable();
    internal static IDictionary CreateHashtable(int capacity);
    internal static IDictionary CreateHashtable(IDictionary dictionary);
    internal static string ToLowerInvariant(string s);
    internal static string ToUpperInvariant(string s);
    internal static void Dispose(IDisposable d);
    internal static int IndexOf(string source, string value);
    internal static int LastIndexOf(string source, string value);
    internal static bool StartsWith(string source, string prefix);
    internal static bool EndsWith(string source, string suffix);
    internal static string GetTypeName(object obj);
}
public abstract class NBitcoin.BuilderExtensions.BuilderExtension : object {
    public static TransactionSignature DummySignature;
    private static BuilderExtension();
    public abstract virtual bool Match(ICoin coin, PSBTInput input);
    public abstract virtual void Sign(InputSigningContext inputSigningContext, IKeyRepository keyRepository, ISigner signer);
    public abstract virtual Script DeduceScriptPubKey(Script scriptSig);
    public abstract virtual bool CanDeduceScriptPubKey(Script scriptSig);
    public abstract virtual bool CanEstimateScriptSigSize(ICoin coin);
    public abstract virtual int EstimateScriptSigSize(ICoin coin);
    public abstract virtual bool IsCompatibleKey(IPubKey publicKey, Script scriptPubKey);
    public abstract virtual void Finalize(InputSigningContext inputSigningContext);
    public virtual void ExtractExistingSignatures(InputSigningContext inputSigningContext);
    public virtual void MergePartialSignatures(InputSigningContext inputSigningContext);
}
[NullableContextAttribute("1")]
public interface NBitcoin.BuilderExtensions.IKeyRepository {
    public abstract virtual IPubKey FindKey(Script scriptPubKey);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NBitcoin.BuilderExtensions.InputSigningContext : object {
    [CompilerGeneratedAttribute]
private TransactionSigningContext <TransactionContext>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private TxIn <OriginalTxIn>k__BackingField;
    [CompilerGeneratedAttribute]
private BuilderExtension <Extension>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private CoinOptions <CoinOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private ICoin <Coin>k__BackingField;
    [CompilerGeneratedAttribute]
private PSBTInput <Input>k__BackingField;
    internal TransactionSigningContext TransactionContext { get; }
    [NullableAttribute("2")]
public TxIn OriginalTxIn { get; }
    public BuilderExtension Extension { get; }
    [NullableAttribute("2")]
public CoinOptions CoinOptions { get; public set; }
    public ICoin Coin { get; }
    public PSBTInput Input { get; }
    internal InputSigningContext(TransactionSigningContext transactionSigningContext, ICoin coin, CoinOptions coinOptions, PSBTInput input, TxIn originalTxIn, BuilderExtension extension);
    [CompilerGeneratedAttribute]
internal TransactionSigningContext get_TransactionContext();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public TxIn get_OriginalTxIn();
    [CompilerGeneratedAttribute]
public BuilderExtension get_Extension();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public CoinOptions get_CoinOptions();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_CoinOptions(CoinOptions value);
    [CompilerGeneratedAttribute]
public ICoin get_Coin();
    [CompilerGeneratedAttribute]
public PSBTInput get_Input();
}
[NullableContextAttribute("1")]
public interface NBitcoin.BuilderExtensions.ISigner {
    public abstract virtual ITransactionSignature Sign(IPubKey key);
}
public class NBitcoin.BuilderExtensions.OPTrueExtension : BuilderExtension {
    public virtual bool CanDeduceScriptPubKey(Script scriptSig);
    public virtual bool CanEstimateScriptSigSize(ICoin coin);
    private static bool CanSign(Script executedScript);
    public virtual Script DeduceScriptPubKey(Script scriptSig);
    public virtual int EstimateScriptSigSize(ICoin coin);
    public virtual bool IsCompatibleKey(IPubKey publicKey, Script scriptPubKey);
    public virtual void Finalize(InputSigningContext inputSigningContext);
    public virtual bool Match(ICoin coin, PSBTInput input);
    public virtual void Sign(InputSigningContext inputSigningContext, IKeyRepository keyRepository, ISigner signer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NBitcoin.BuilderExtensions.P2MultiSigBuilderExtension : BuilderExtension {
    public virtual bool CanDeduceScriptPubKey(Script scriptSig);
    public virtual bool CanEstimateScriptSigSize(ICoin coin);
    private static bool CanSign(Script scriptPubKey);
    public virtual Script DeduceScriptPubKey(Script scriptSig);
    public virtual int EstimateScriptSigSize(ICoin coin);
    public virtual void Sign(InputSigningContext inputSigningContext, IKeyRepository keyRepository, ISigner signer);
    public virtual bool IsCompatibleKey(IPubKey publicKey, Script scriptPubKey);
    public virtual void Finalize(InputSigningContext inputSigningContext);
    public virtual bool Match(ICoin coin, PSBTInput input);
    public virtual void ExtractExistingSignatures(InputSigningContext inputSigningContext);
    public virtual void MergePartialSignatures(InputSigningContext inputSigningContext);
}
public class NBitcoin.BuilderExtensions.P2PKBuilderExtension : BuilderExtension {
    public virtual bool CanDeduceScriptPubKey(Script scriptSig);
    public virtual bool CanEstimateScriptSigSize(ICoin coin);
    public virtual void Sign(InputSigningContext inputSigningContext, IKeyRepository keyRepository, ISigner signer);
    private static bool CanSign(Script scriptPubKey);
    public virtual Script DeduceScriptPubKey(Script scriptSig);
    public virtual int EstimateScriptSigSize(ICoin coin);
    public virtual bool IsCompatibleKey(IPubKey publicKey, Script scriptPubKey);
    public virtual void Finalize(InputSigningContext inputSigningContext);
    public virtual bool Match(ICoin coin, PSBTInput input);
    public virtual void ExtractExistingSignatures(InputSigningContext inputSigningContext);
}
public class NBitcoin.BuilderExtensions.P2PKHBuilderExtension : BuilderExtension {
    public virtual bool CanDeduceScriptPubKey(Script scriptSig);
    public virtual bool CanEstimateScriptSigSize(ICoin coin);
    private static bool CanSign(Script scriptPubKey);
    public virtual Script DeduceScriptPubKey(Script scriptSig);
    public virtual int EstimateScriptSigSize(ICoin coin);
    public virtual bool IsCompatibleKey(IPubKey publicKey, Script scriptPubKey);
    public virtual void Sign(InputSigningContext inputSigningContext, IKeyRepository keyRepository, ISigner signer);
    public virtual void Finalize(InputSigningContext inputSigningContext);
    public virtual bool Match(ICoin coin, PSBTInput input);
    public virtual void ExtractExistingSignatures(InputSigningContext inputSigningContext);
}
public enum NBitcoin.BuriedDeployments : Enum {
    public int value__;
    public static BuriedDeployments BIP34;
    public static BuriedDeployments BIP65;
    public static BuriedDeployments BIP66;
}
[ExtensionAttribute]
internal static class NBitcoin.ByteArrayExtensions : object {
    [ExtensionAttribute]
internal static bool StartWith(Byte[] data, Byte[] versionBytes);
    [ExtensionAttribute]
internal static Byte[] SafeSubarray(Byte[] array, int offset, int count);
    [ExtensionAttribute]
internal static Byte[] SafeSubarray(Byte[] array, int offset);
    [ExtensionAttribute]
internal static Byte[] Concat(Byte[] arr, Byte[][] arrs);
}
public class NBitcoin.BytesComparer : Comparer`1<Byte[]> {
    private static BytesComparer _Instance;
    public static BytesComparer Instance { get; }
    private static BytesComparer();
    public static BytesComparer get_Instance();
    public virtual int Compare(Byte[] x, Byte[] y);
}
public class NBitcoin.CachedGRCodedStreamReader : GRCodedStreamReader {
    private List`1<ulong> _cachedValues;
    private int _position;
    internal CachedGRCodedStreamReader(BitStream stream, byte p, ulong lastValue);
    public virtual bool TryRead(UInt64& value);
    internal virtual void ResetPosition();
}
public class NBitcoin.CachedNoSqlRepository : NoSqlRepository {
    private NoSqlRepository _InnerRepository;
    private Dictionary`2<string, Byte[]> _Table;
    private HashSet`1<string> _Removed;
    private HashSet`1<string> _Added;
    private ReaderWriterLock lock;
    public NoSqlRepository InnerRepository { get; }
    public CachedNoSqlRepository(NoSqlRepository inner);
    public NoSqlRepository get_InnerRepository();
    [AsyncStateMachineAttribute("NBitcoin.CachedNoSqlRepository/<PutBatch>d__9")]
public virtual Task PutBatch(IEnumerable`1<Tuple`2<string, IBitcoinSerializable>> values);
    protected virtual Task PutBytesBatch(IEnumerable`1<Tuple`2<string, Byte[]>> enumerable);
    [AsyncStateMachineAttribute("NBitcoin.CachedNoSqlRepository/<GetBytes>d__11")]
protected virtual Task`1<Byte[]> GetBytes(string key);
    public void Flush();
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task <>n__0(IEnumerable`1<Tuple`2<string, IBitcoinSerializable>> values);
    [CompilerGeneratedAttribute]
private Tuple`2<string, IBitcoinSerializable> <Flush>b__12_1(string k);
}
public class NBitcoin.CachedTransactionRepository : object {
    private ITransactionRepository _Inner;
    private Dictionary`2<uint256, Transaction> _Transactions;
    private Queue`1<uint256> _EvictionQueue;
    private ReaderWriterLock lock;
    [CompilerGeneratedAttribute]
private int <MaxCachedTransactions>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <WriteThrough>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ReadThrough>k__BackingField;
    public int MaxCachedTransactions { get; public set; }
    public bool WriteThrough { get; public set; }
    public bool ReadThrough { get; public set; }
    public CachedTransactionRepository(ITransactionRepository inner);
    [CompilerGeneratedAttribute]
public int get_MaxCachedTransactions();
    [CompilerGeneratedAttribute]
public void set_MaxCachedTransactions(int value);
    public Transaction GetFromCache(uint256 txId);
    [AsyncStateMachineAttribute("NBitcoin.CachedTransactionRepository/<GetAsync>d__10")]
public sealed virtual Task`1<Transaction> GetAsync(uint256 txId);
    private void EvictIfNecessary(uint256 txId);
    public sealed virtual Task PutAsync(uint256 txId, Transaction tx);
    [CompilerGeneratedAttribute]
public bool get_WriteThrough();
    [CompilerGeneratedAttribute]
public void set_WriteThrough(bool value);
    [CompilerGeneratedAttribute]
public bool get_ReadThrough();
    [CompilerGeneratedAttribute]
public void set_ReadThrough(bool value);
}
public abstract class NBitcoin.ChainBase : object {
    public ChainedBlock Genesis { get; }
    public ChainedBlock Tip { get; }
    public int Height { get; }
    public virtual ChainedBlock get_Genesis();
    public abstract virtual ChainedBlock GetBlock(uint256 id);
    public abstract virtual ChainedBlock GetBlock(int height);
    public abstract virtual ChainedBlock get_Tip();
    public abstract virtual int get_Height();
    public bool Contains(uint256 hash);
    [IteratorStateMachineAttribute("NBitcoin.ChainBase/<ToEnumerable>d__9")]
public IEnumerable`1<ChainedBlock> ToEnumerable(bool fromTip);
    public ChainedBlock SetTip(ChainBase otherChain);
    public bool SetTip(BlockHeader header);
    public bool TrySetTip(BlockHeader header, ChainedBlock& chainedHeader);
    protected abstract virtual IEnumerable`1<ChainedBlock> EnumerateFromStart();
    public bool Contains(ChainedBlock blockIndex);
    public bool SameTip(ChainBase chain);
    public Target GetWorkRequired(Network network, int height);
    public bool Validate(Network network, bool fullChain);
    public ChainedBlock FindFork(ChainBase chain);
    public ChainedBlock FindFork(IEnumerable`1<uint256> hashes);
    public ChainedBlock FindFork(BlockLocator locator);
    public IEnumerable`1<ChainedBlock> EnumerateAfter(uint256 blockHash);
    public IEnumerable`1<ChainedBlock> EnumerateToTip(ChainedBlock block);
    [IteratorStateMachineAttribute("NBitcoin.ChainBase/<EnumerateToTip>d__23")]
public IEnumerable`1<ChainedBlock> EnumerateToTip(uint256 blockHash);
    [IteratorStateMachineAttribute("NBitcoin.ChainBase/<EnumerateAfter>d__24")]
public virtual IEnumerable`1<ChainedBlock> EnumerateAfter(ChainedBlock block);
    public abstract virtual ChainedBlock SetTip(ChainedBlock pindex);
}
public class NBitcoin.ChainedBlock : object {
    private uint256 phashBlock;
    private ChainedBlock pprev;
    private int nHeight;
    private BlockHeader header;
    private object _ChainWork;
    private static BigInteger Pow256;
    private static int nMedianTimeSpan;
    public uint256 HashBlock { get; }
    public ChainedBlock Previous { get; }
    public int Height { get; }
    public bool HasHeader { get; }
    public BlockHeader Header { get; }
    [DebuggerBrowsableAttribute("0")]
[ObsoleteAttribute("Use GetChainWork() instead")]
public uint256 ChainWork { get; }
    public ChainedBlock(BlockHeader header, uint256 headerHash, ChainedBlock previous);
    public ChainedBlock(BlockHeader header, int height);
    private static ChainedBlock();
    public uint256 get_HashBlock();
    public void StripCachedData();
    public void StripHeader();
    public ChainedBlock get_Previous();
    public int get_Height();
    public bool get_HasHeader();
    public bool TryGetHeader(BlockHeader& header);
    public BlockHeader get_Header();
    public uint256 get_ChainWork();
    public uint256 GetChainWork(bool cacheResult);
    private BigInteger GetChainWorkValue(bool cacheResult);
    private BigInteger CalculateChainWork();
    private BigInteger GetBlockProof();
    public BlockLocator GetLocator();
    public virtual bool Equals(object obj);
    public static bool op_Equality(ChainedBlock a, ChainedBlock b);
    public static bool op_Inequality(ChainedBlock a, ChainedBlock b);
    public virtual int GetHashCode();
    [IteratorStateMachineAttribute("NBitcoin.ChainedBlock/<EnumerateToGenesis>d__32")]
public IEnumerable`1<ChainedBlock> EnumerateToGenesis();
    public virtual string ToString();
    public ChainedBlock FindAncestorOrSelf(int height);
    public ChainedBlock FindAncestorOrSelf(uint256 blockHash);
    public Target GetWorkRequired(Network network);
    public Target GetNextWorkRequired(Network network);
    public Target GetNextWorkRequired(Consensus consensus);
    public Target GetNextWorkRequired(BlockHeader block, Network network);
    public Target GetNextWorkRequired(BlockHeader block, Consensus consensus);
    private void AssertHasHeader();
    public Target GetWorkRequired(Consensus consensus);
    public DateTimeOffset GetMedianTimePast();
    private static void assert(object obj);
    public bool Validate(Network network);
    public bool Validate(Consensus consensus);
    public bool CheckProofOfWorkAndTarget(Network network);
    public bool CheckProofOfWorkAndTarget(Consensus consensus);
    public ChainedBlock FindFork(ChainedBlock block);
    public ChainedBlock GetAncestor(int height);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NBitcoin.ChainName : object {
    [CompilerGeneratedAttribute]
private static ChainName <Mainnet>k__BackingField;
    [CompilerGeneratedAttribute]
private static ChainName <Testnet>k__BackingField;
    [CompilerGeneratedAttribute]
private static ChainName <Regtest>k__BackingField;
    private string nameInvariant;
    public static ChainName Mainnet { get; }
    public static ChainName Testnet { get; }
    public static ChainName Regtest { get; }
    private static ChainName();
    public ChainName(string chainName);
    [CompilerGeneratedAttribute]
public static ChainName get_Mainnet();
    [CompilerGeneratedAttribute]
public static ChainName get_Testnet();
    [CompilerGeneratedAttribute]
public static ChainName get_Regtest();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public static bool op_Equality(ChainName a, ChainName b);
    public static bool op_Inequality(ChainName a, ChainName b);
    public virtual int GetHashCode();
    public virtual string ToString();
}
[FlagsAttribute]
public enum NBitcoin.ChangeType : Enum {
    public int value__;
    public static ChangeType All;
    public static ChangeType Colored;
    public static ChangeType Uncolored;
}
[ExtensionAttribute]
internal static class NBitcoin.CharExtensions : object {
    [ExtensionAttribute]
public static bool IsDigit(char c);
}
public class NBitcoin.Coin : object {
    [CompilerGeneratedAttribute]
private OutPoint <Outpoint>k__BackingField;
    [CompilerGeneratedAttribute]
private TxOut <TxOut>k__BackingField;
    protected Script _OverrideScriptCode;
    public bool IsMalleable { get; }
    public bool CanGetScriptCode { get; }
    public OutPoint Outpoint { get; public set; }
    public TxOut TxOut { get; public set; }
    public Money Amount { get; public set; }
    public Script ScriptPubKey { get; public set; }
    private IMoney NBitcoin.ICoin.Amount { get; }
    private OutPoint NBitcoin.ICoinable.Outpoint { get; }
    private TxOut NBitcoin.ICoinable.TxOut { get; }
    public Coin(OutPoint fromOutpoint, TxOut fromTxOut);
    public Coin(Transaction fromTx, UInt32 fromOutputIndex);
    public Coin(Transaction fromTx, TxOut fromOutput);
    public Coin(IndexedTxOut txOut);
    public Coin(uint256 fromTxHash, UInt32 fromOutputIndex, Money amount, Script scriptPubKey);
    public virtual Script GetScriptCode();
    public sealed virtual bool get_IsMalleable();
    public virtual bool get_CanGetScriptCode();
    public virtual HashVersion GetHashVersion();
    public ScriptCoin ToScriptCoin(Script redeemScript);
    public ScriptCoin TryToScriptCoin(Script redeemScript);
    public ScriptCoin TryToScriptCoin(PubKey pubKey);
    public ColoredCoin ToColoredCoin(AssetId asset, ulong quantity);
    public ColoredCoin ToColoredCoin(BitcoinAssetId asset, ulong quantity);
    public ColoredCoin ToColoredCoin(AssetMoney asset);
    [CompilerGeneratedAttribute]
public OutPoint get_Outpoint();
    [CompilerGeneratedAttribute]
public void set_Outpoint(OutPoint value);
    [CompilerGeneratedAttribute]
public TxOut get_TxOut();
    [CompilerGeneratedAttribute]
public void set_TxOut(TxOut value);
    public Money get_Amount();
    public void set_Amount(Money value);
    private void EnsureTxOut();
    public sealed virtual void OverrideScriptCode(Script scriptCode);
    public Script get_ScriptPubKey();
    public void set_ScriptPubKey(Script value);
    private sealed virtual override IMoney NBitcoin.ICoin.get_Amount();
    private sealed virtual override OutPoint NBitcoin.ICoinable.get_Outpoint();
    private sealed virtual override TxOut NBitcoin.ICoinable.get_TxOut();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NBitcoin.CoinNotFoundException : KeyNotFoundException {
    private OutPoint _OutPoint;
    private UInt32 _InputIndex;
    public OutPoint OutPoint { get; }
    public UInt32 InputIndex { get; }
    public CoinNotFoundException(IndexedTxIn txIn);
    public OutPoint get_OutPoint();
    public UInt32 get_InputIndex();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class NBitcoin.CoinOptions : object {
    [CompilerGeneratedAttribute]
private Nullable`1<Sequence> <Sequence>k__BackingField;
    [CompilerGeneratedAttribute]
private KeyPair <KeyPair>k__BackingField;
    public Nullable`1<Sequence> Sequence { get; public set; }
    public KeyPair KeyPair { get; public set; }
    [CompilerGeneratedAttribute]
public Nullable`1<Sequence> get_Sequence();
    [CompilerGeneratedAttribute]
public void set_Sequence(Nullable`1<Sequence> value);
    [CompilerGeneratedAttribute]
public KeyPair get_KeyPair();
    [CompilerGeneratedAttribute]
public void set_KeyPair(KeyPair value);
}
public class NBitcoin.ColoredCoin : object {
    [CompilerGeneratedAttribute]
private AssetMoney <Amount>k__BackingField;
    [CompilerGeneratedAttribute]
private Coin <Bearer>k__BackingField;
    public AssetId AssetId { get; }
    public bool IsMalleable { get; }
    public AssetMoney Amount { get; public set; }
    public Coin Bearer { get; public set; }
    public TxOut TxOut { get; }
    public OutPoint Outpoint { get; }
    public Script ScriptPubKey { get; }
    private AssetId NBitcoin.IColoredCoin.AssetId { get; }
    private Coin NBitcoin.IColoredCoin.Bearer { get; }
    private IMoney NBitcoin.ICoin.Amount { get; }
    private OutPoint NBitcoin.ICoinable.Outpoint { get; }
    private TxOut NBitcoin.ICoinable.TxOut { get; }
    public bool CanGetScriptCode { get; }
    public ColoredCoin(AssetMoney asset, Coin bearer);
    public ColoredCoin(Transaction tx, ColoredEntry entry);
    public AssetId get_AssetId();
    public sealed virtual bool get_IsMalleable();
    [CompilerGeneratedAttribute]
public AssetMoney get_Amount();
    [CompilerGeneratedAttribute]
public void set_Amount(AssetMoney value);
    [CompilerGeneratedAttribute]
public Coin get_Bearer();
    [CompilerGeneratedAttribute]
public void set_Bearer(Coin value);
    public TxOut get_TxOut();
    public OutPoint get_Outpoint();
    public Script get_ScriptPubKey();
    public static IEnumerable`1<ColoredCoin> Find(Transaction tx, ColoredTransaction colored);
    [IteratorStateMachineAttribute("NBitcoin.ColoredCoin/<Find>d__22")]
public static IEnumerable`1<ColoredCoin> Find(uint256 txId, Transaction tx, ColoredTransaction colored);
    public static IEnumerable`1<ColoredCoin> Find(Transaction tx, IColoredTransactionRepository repo);
    public static IEnumerable`1<ColoredCoin> Find(uint256 txId, Transaction tx, IColoredTransactionRepository repo);
    private sealed virtual override AssetId NBitcoin.IColoredCoin.get_AssetId();
    private sealed virtual override Coin NBitcoin.IColoredCoin.get_Bearer();
    private sealed virtual override IMoney NBitcoin.ICoin.get_Amount();
    private sealed virtual override OutPoint NBitcoin.ICoinable.get_Outpoint();
    private sealed virtual override TxOut NBitcoin.ICoinable.get_TxOut();
    public sealed virtual Script GetScriptCode();
    public sealed virtual bool get_CanGetScriptCode();
    public sealed virtual HashVersion GetHashVersion();
    public sealed virtual void OverrideScriptCode(Script scriptCode);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NBitcoin.CompactSignature : object {
    [CompilerGeneratedAttribute]
private int <RecoveryId>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <Signature>k__BackingField;
    public int RecoveryId { get; }
    public Byte[] Signature { get; }
    public CompactSignature(int recoveryId, Byte[] sig64);
    public static bool IsValidRecId(int recid);
    [CompilerGeneratedAttribute]
public int get_RecoveryId();
    [CompilerGeneratedAttribute]
public Byte[] get_Signature();
    public PubKey RecoverPubKey(uint256 hash);
}
public class NBitcoin.ConcurrentChain : ChainBase {
    private Dictionary`2<uint256, ChainedBlock> _BlocksById;
    private ChainedBlock[] _BlocksByHeight;
    private ReaderWriterLock lock;
    private ChainedBlock modreq(System.Runtime.CompilerServices.IsVolatile) _Tip;
    public ChainedBlock Tip { get; }
    public int Height { get; }
    public ConcurrentChain(BlockHeader genesis);
    public ConcurrentChain(Network network);
    public ConcurrentChain(Byte[] bytes, ConsensusFactory consensusFactory);
    public ConcurrentChain(Byte[] bytes, Consensus consensus);
    public ConcurrentChain(Byte[] bytes, Network network);
    [ObsoleteAttribute("Use ConcurrentChain(byte[], ConsensusFactory|Network|Consensus) instead")]
public ConcurrentChain(Byte[] bytes);
    public ConcurrentChain(Byte[] bytes, ConsensusFactory consensusFactory, ChainSerializationFormat format);
    public ConcurrentChain(Byte[] bytes, Consensus consensus, ChainSerializationFormat format);
    public ConcurrentChain(Byte[] bytes, Network network, ChainSerializationFormat format);
    [ObsoleteAttribute("Use ConcurrentChain(byte[], ConsensusFactory|Network|Consensus, ChainSerializationFormat format) instead")]
public ConcurrentChain(Byte[] bytes, ChainSerializationFormat format);
    public void Load(Byte[] chain, Network network, ChainSerializationFormat format);
    public void Load(Byte[] chain, Consensus consensus, ChainSerializationFormat format);
    public void Load(Byte[] chain, ConsensusFactory consensusFactory, ChainSerializationFormat format);
    [ObsoleteAttribute("Use Load(byte[], ConsensusFactory|Network|Consensus, ChainSerializationFormat format) instead")]
public void Load(Byte[] chain, ChainSerializationFormat format);
    public void Load(Byte[] chain, ConsensusFactory consensusFactory);
    public void Load(Byte[] chain, Consensus consensus);
    public void Load(Byte[] chain, Network network);
    [ObsoleteAttribute("Use Load(byte[], ConsensusFactory|Network|Consensus) instead")]
public void Load(Byte[] chain);
    public void Load(Stream stream, ConsensusFactory consensusFactory, ChainSerializationFormat format);
    public void Load(Stream stream, Network network, ChainSerializationFormat format);
    public void Load(Stream stream, Consensus consensus, ChainSerializationFormat format);
    [ObsoleteAttribute("Use Load(Stream, ConsensusFactory|Network|Consensus, ChainSerializationFormat) instead")]
public void Load(Stream stream, ChainSerializationFormat format);
    public void Load(Stream stream);
    public void Load(BitcoinStream stream);
    public void Load(BitcoinStream stream, ChainSerializationFormat format);
    public Byte[] ToBytes();
    public void WriteTo(Stream stream);
    public void WriteTo(Stream stream, ChainSerializationFormat format);
    public void WriteTo(BitcoinStream stream);
    public void WriteTo(BitcoinStream stream, ChainSerializationFormat format);
    public ConcurrentChain Clone();
    public virtual ChainedBlock SetTip(ChainedBlock block);
    private ChainedBlock SetTipNoLock(ChainedBlock block);
    [IteratorStateMachineAttribute("NBitcoin.ConcurrentChain/<EnumerateThisToFork>d__38")]
private IEnumerable`1<ChainedBlock> EnumerateThisToFork(ChainedBlock block);
    public virtual ChainedBlock GetBlock(uint256 id);
    private ChainedBlock GetBlockNoLock(int height);
    private bool TryGetBlocksByHeight(int height, ChainedBlock& result);
    private void RemoveBlocksByHeight(int height);
    private void AddOrReplaceBlocksByHeight(int height, ChainedBlock newBlock);
    public virtual ChainedBlock GetBlock(int height);
    public virtual ChainedBlock get_Tip();
    public virtual int get_Height();
    [IteratorStateMachineAttribute("NBitcoin.ConcurrentChain/<EnumerateFromStart>d__50")]
protected virtual IEnumerable`1<ChainedBlock> EnumerateFromStart();
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NBitcoin.Consensus : object {
    private BuriedDeploymentsArray _BuriedDeployments;
    private BIP9DeploymentsArray _BIP9Deployments;
    private int _SubsidyHalvingInterval;
    private ConsensusFactory _ConsensusFactory;
    private int _MajorityEnforceBlockUpgrade;
    private int _MajorityRejectBlockOutdated;
    private int _MajorityWindow;
    [NullableAttribute("2")]
private uint256 _BIP34Hash;
    [NullableAttribute("2")]
private Target _PowLimit;
    private TimeSpan _PowTargetTimespan;
    private TimeSpan _PowTargetSpacing;
    private bool _PowAllowMinDifficultyBlocks;
    private bool _PowNoRetargeting;
    [NullableAttribute("2")]
private uint256 _HashGenesisBlock;
    [NullableAttribute("2")]
private Byte[] _genesis;
    [NullableAttribute("2")]
private uint256 _MinimumChainWork;
    private int _MinerConfirmationWindow;
    private int _RuleChangeActivationThreshold;
    private int _CoinbaseMaturity;
    private int _CoinType;
    private bool _LitecoinWorkCalculation;
    private bool frozen;
    private bool _SupportTaproot;
    private bool _SupportSegwit;
    private bool _NeverNeedPreviousTxForSigning;
    public static Consensus Main { get; }
    public static Consensus TestNet { get; }
    public static Consensus RegTest { get; }
    public BuriedDeploymentsArray BuriedDeployments { get; }
    public BIP9DeploymentsArray BIP9Deployments { get; }
    public int SubsidyHalvingInterval { get; public set; }
    public ConsensusFactory ConsensusFactory { get; public set; }
    public int MajorityEnforceBlockUpgrade { get; public set; }
    public int MajorityRejectBlockOutdated { get; public set; }
    public int MajorityWindow { get; public set; }
    [NullableAttribute("2")]
public uint256 BIP34Hash { get; public set; }
    [NullableAttribute("2")]
public Target PowLimit { get; public set; }
    public TimeSpan PowTargetTimespan { get; public set; }
    public TimeSpan PowTargetSpacing { get; public set; }
    public bool PowAllowMinDifficultyBlocks { get; public set; }
    public bool PowNoRetargeting { get; public set; }
    public uint256 HashGenesisBlock { get; }
    [NullableAttribute("2")]
public uint256 MinimumChainWork { get; public set; }
    public long DifficultyAdjustmentInterval { get; }
    public int MinerConfirmationWindow { get; public set; }
    public int RuleChangeActivationThreshold { get; public set; }
    public int CoinbaseMaturity { get; public set; }
    public int CoinType { get; public set; }
    public bool LitecoinWorkCalculation { get; public set; }
    public bool SupportTaproot { get; public set; }
    public bool SupportSegwit { get; public set; }
    public bool NeverNeedPreviousTxForSigning { get; public set; }
    public static Consensus get_Main();
    public static Consensus get_TestNet();
    public static Consensus get_RegTest();
    public BuriedDeploymentsArray get_BuriedDeployments();
    public BIP9DeploymentsArray get_BIP9Deployments();
    public int get_SubsidyHalvingInterval();
    public void set_SubsidyHalvingInterval(int value);
    public ConsensusFactory get_ConsensusFactory();
    public void set_ConsensusFactory(ConsensusFactory value);
    public int get_MajorityEnforceBlockUpgrade();
    public void set_MajorityEnforceBlockUpgrade(int value);
    public int get_MajorityRejectBlockOutdated();
    public void set_MajorityRejectBlockOutdated(int value);
    public int get_MajorityWindow();
    public void set_MajorityWindow(int value);
    [NullableContextAttribute("2")]
public uint256 get_BIP34Hash();
    [NullableContextAttribute("2")]
public void set_BIP34Hash(uint256 value);
    [NullableContextAttribute("2")]
public Target get_PowLimit();
    [NullableContextAttribute("2")]
public void set_PowLimit(Target value);
    public TimeSpan get_PowTargetTimespan();
    public void set_PowTargetTimespan(TimeSpan value);
    public TimeSpan get_PowTargetSpacing();
    public void set_PowTargetSpacing(TimeSpan value);
    public bool get_PowAllowMinDifficultyBlocks();
    public void set_PowAllowMinDifficultyBlocks(bool value);
    public bool get_PowNoRetargeting();
    public void set_PowNoRetargeting(bool value);
    internal void SetBlock(Byte[] genesis);
    public uint256 get_HashGenesisBlock();
    [NullableContextAttribute("2")]
public uint256 get_MinimumChainWork();
    [NullableContextAttribute("2")]
public void set_MinimumChainWork(uint256 value);
    public long get_DifficultyAdjustmentInterval();
    public int get_MinerConfirmationWindow();
    public void set_MinerConfirmationWindow(int value);
    public int get_RuleChangeActivationThreshold();
    public void set_RuleChangeActivationThreshold(int value);
    public int get_CoinbaseMaturity();
    public void set_CoinbaseMaturity(int value);
    public int get_CoinType();
    public void set_CoinType(int value);
    public bool get_LitecoinWorkCalculation();
    public void set_LitecoinWorkCalculation(bool value);
    public void Freeze();
    private void EnsureNotFrozen();
    public bool get_SupportTaproot();
    public void set_SupportTaproot(bool value);
    public bool get_SupportSegwit();
    public void set_SupportSegwit(bool value);
    public bool get_NeverNeedPreviousTxForSigning();
    public void set_NeverNeedPreviousTxForSigning(bool value);
    public virtual Consensus Clone();
    public TimeSpan GetExpectedTimeFor(double blockCount);
    public double GetExpectedBlocksFor(TimeSpan timeSpan);
    protected void Fill(Consensus consensus);
}
public class NBitcoin.ConsensusFactory : object {
    private static TypeInfo BlockHeaderType;
    private static TypeInfo BlockType;
    private static TypeInfo TransactionType;
    private static TypeInfo TxInType;
    private static TypeInfo TxOutType;
    private static TypeInfo PSBTType;
    private static ConsensusFactory();
    protected bool IsBlockHeader(Type type);
    protected bool IsTxIn(Type type);
    protected bool IsTxOut(Type type);
    protected bool IsBlock(Type type);
    protected bool IsTransaction(Type type);
    public virtual bool TryCreateNew(Type type, IBitcoinSerializable& result);
    public bool TryCreateNew(T& result);
    public virtual Payload CreatePayload(string command);
    public virtual ProtocolCapabilities GetProtocolCapabilities(UInt32 protocolVersion);
    public virtual Block CreateBlock();
    public virtual BlockHeader CreateBlockHeader();
    public virtual Transaction CreateTransaction();
    public virtual TxIn CreateTxIn();
    public virtual TxOut CreateTxOut();
    protected virtual TransactionBuilder CreateTransactionBuilderCore(Network network);
    internal TransactionBuilder CreateTransactionBuilderCore2(Network network);
}
public class NBitcoin.ContextStack`1 : object {
    private T[] _array;
    private int _position;
    public int Count { get; }
    public ContextStack`1(ContextStack`1<T> stack);
    public ContextStack`1(IEnumerable`1<T> elements);
    public int get_Count();
    public void Push(T item);
    public T Pop();
    public void Clear(int n);
    public T Top(int i);
    public void Swap(int i, int j);
    public void Insert(int position, T value);
    public void Remove(int from);
    public void Remove(int from, int to);
    private void EnsureSize();
    public T[] AsInternalArray();
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    internal void Clear();
}
internal class NBitcoin.Crypto.AesBuilder : object {
    private Byte[] _key;
    private Nullable`1<bool> _forEncryption;
    private Byte[] _iv;
    public AesBuilder SetKey(Byte[] key);
    public AesBuilder IsUsedForEncryption(bool forEncryption);
    public AesBuilder SetIv(Byte[] iv);
    public AesWrapper Build();
}
internal class NBitcoin.Crypto.AesWrapper : object {
    private PaddedBufferedBlockCipher _inner;
    private AesWrapper(PaddedBufferedBlockCipher aes);
    internal static AesWrapper Create();
    public Byte[] Process(Byte[] inputBuffer, int inputOffset, int inputCount);
    internal void Initialize(Byte[] key, Byte[] iv, bool forEncryption);
}
public abstract class NBitcoin.Crypto.BufferedHashStream : HashStreamBase {
    private MemoryStream ms;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public BufferedHashStream(int capacity);
    public static BufferedHashStream CreateFrom(Func`4<Byte[], int, int, Byte[]> calculateHash, int capacity);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Flush();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void WriteByte(byte value);
    public virtual uint256 GetHash();
    protected abstract virtual uint256 GetHash(Byte[] data, int offset, int length);
}
[ExtensionAttribute]
internal static class NBitcoin.Crypto.DeterministicDSAExtensions : object {
    [ExtensionAttribute]
public static void Update(IMac hmac, Byte[] input);
    [ExtensionAttribute]
public static Byte[] DoFinal(IMac hmac);
    [ExtensionAttribute]
public static void Update(IDigest digest, Byte[] input);
    [ExtensionAttribute]
public static void Update(IDigest digest, Byte[] input, int offset, int length);
    [ExtensionAttribute]
public static Byte[] Digest(IDigest digest);
}
internal class NBitcoin.Crypto.DeterministicECDSA : ECDsaSigner {
    private Byte[] _buffer;
    private IDigest _digest;
    public DeterministicECDSA(bool forceLowR);
    public DeterministicECDSA(Func`1<IDigest> digest, bool forceLowR);
    public void setPrivateKey(ECPrivateKeyParameters ecKey);
    public void update(Byte[] buf);
    public Byte[] sign();
    public Byte[] signHash(Byte[] hash);
}
public class NBitcoin.Crypto.ECDSASignature : object {
    private BigInteger _R;
    private BigInteger _S;
    private static string InvalidDERSignature;
    internal BigInteger R { get; }
    internal BigInteger S { get; }
    public bool IsLowS { get; }
    public bool IsLowR { get; }
    internal ECDSASignature(BigInteger r, BigInteger s);
    internal ECDSASignature(BigInteger[] rs);
    public ECDSASignature(Byte[] derSig);
    public ECDSASignature(Stream derSig);
    internal BigInteger get_R();
    internal BigInteger get_S();
    public static bool TryParseFromCompact(Byte[] compactFormat, ECDSASignature& signature);
    public Byte[] ToCompact();
    public Byte[] ToDER();
    public static ECDSASignature FromDER(Byte[] sig);
    public ECDSASignature MakeCanonical();
    public bool get_IsLowS();
    public bool get_IsLowR();
    public static bool IsValidDER(Byte[] bytes);
}
internal class NBitcoin.Crypto.ECKey : object {
    private ECKeyParameters _Key;
    public static BigInteger HALF_CURVE_ORDER;
    public static BigInteger CURVE_ORDER;
    public static ECDomainParameters CURVE;
    public static X9ECParameters _Secp256k1;
    private ECDomainParameters _DomainParameter;
    public ECPrivateKeyParameters PrivateKey { get; }
    public static X9ECParameters Secp256k1 { get; }
    public ECDomainParameters DomainParameter { get; }
    private static ECKey();
    public ECKey(Byte[] vch, bool isPrivate);
    public ECPrivateKeyParameters get_PrivateKey();
    public static X9ECParameters get_Secp256k1();
    public ECDomainParameters get_DomainParameter();
    public ECDSASignature Sign(uint256 hash, bool useLowR);
    private void AssertPrivateKey();
    internal bool Verify(uint256 hash, ECDSASignature sig);
    public PubKey GetPubKey(bool isCompressed);
    public ECPublicKeyParameters GetPublicKeyParameters();
    public static ECKey RecoverFromSignature(int recId, ECDSASignature sig, uint256 message);
    private static ECPoint DecompressKey(BigInteger xBN, bool yBit);
}
public static class NBitcoin.Crypto.Hashes : object {
    public static uint256 DoubleSHA256(Byte[] data);
    public static uint256 DoubleSHA256(Byte[] data, int count);
    public static uint256 DoubleSHA256(Byte[] data, int offset, int count);
    public static Byte[] DoubleSHA256RawBytes(Byte[] data);
    public static Byte[] DoubleSHA256RawBytes(Byte[] data, int offset, int count);
    public static uint160 Hash160(Byte[] data);
    public static uint160 Hash160(Byte[] data, int count);
    public static uint160 Hash160(Byte[] data, int offset, int count);
    public static Byte[] RIPEMD160(Byte[] data);
    public static Byte[] RIPEMD160(Byte[] data, int count);
    public static Byte[] RIPEMD160(Byte[] data, int offset, int count);
    public static Byte[] SHA1(Byte[] data, int offset, int count);
    public static ulong SipHash(ulong k0, ulong k1, uint256 val);
    public static Byte[] SHA256(Byte[] data);
    public static Byte[] SHA256(Byte[] data, int offset, int count);
    public static Byte[] SHA512(Byte[] data);
    public static Byte[] SHA512(Byte[] data, int offset, int count);
    private static UInt32 rotl32(UInt32 x, byte r);
    private static UInt32 fmix(UInt32 h);
    public static UInt32 MurmurHash3(UInt32 nHashSeed, Byte[] vDataToHash);
    public static Byte[] HMACSHA512(Byte[] key, Byte[] data);
    public static Byte[] HMACSHA256(Byte[] key, Byte[] data);
    public static Byte[] BIP32Hash(Byte[] chainCode, UInt32 nChild, byte header, Byte[] data);
}
public class NBitcoin.Crypto.HashStream : HashStreamBase {
    [CompilerGeneratedAttribute]
private bool <SingleSHA256>k__BackingField;
    private Byte[] _Buffer;
    private int _Pos;
    private Sha256Digest sha;
    public bool SingleSHA256 { get; public set; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_SingleSHA256();
    [CompilerGeneratedAttribute]
public void set_SingleSHA256(bool value);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Flush();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void WriteByte(byte value);
    private bool ProcessBlockIfNeeded();
    private void ProcessBlock();
    public virtual uint256 GetHash();
}
public abstract class NBitcoin.Crypto.HashStreamBase : Stream {
    public abstract virtual uint256 GetHash();
    public void InitializeTagged(string tag);
}
internal static class NBitcoin.Crypto.Internal.BitMath : object {
    public static bool IsPositivePowerOf2(int value);
    public static byte ReverseBits(byte value);
}
internal static class NBitcoin.Crypto.Internal.BitPacking : object {
    public static UInt32 UInt24FromLEBytes(Byte[] bytes, int offset);
    public static UInt32 UInt32FromLEBytes(Byte[] bytes, int offset);
    public static void BEBytesFromUInt32(UInt32 value, Byte[] bytes, int offset);
    public static void LEBytesFromUInt24(UInt32 value, Byte[] bytes, int offset);
    public static void LEBytesFromUInt32(UInt32 value, Byte[] bytes, int offset);
}
internal static class NBitcoin.Crypto.Internal.Check : object {
    public static void Bounds(string valueName, Array value, int offset, int count);
    public static void Length(string valueName, Array value, int minimum, int maximum);
    public static void Null(string valueName, T value);
    public static void Range(string valueName, int value, int minimum, int maximum);
}
internal static class NBitcoin.Crypto.Internal.Exceptions : object {
    public static ArgumentException Argument(string valueName, string message, Object[] args);
    public static ArgumentNullException ArgumentNull(string valueName);
    public static ArgumentOutOfRangeException ArgumentOutOfRange(string valueName, string message, Object[] args);
    public static NotSupportedException NotSupported();
}
internal static class NBitcoin.Crypto.Internal.Security : object {
    public static void Clear(Array array);
}
[ObsoleteAttribute("This might disappear in favour of .NET BCL's Rfc2898DeriveBytes class")]
public class NBitcoin.Crypto.Pbkdf2 : Stream {
    private Byte[] _saltBuffer;
    private Byte[] _digest;
    private Byte[] _digestT1;
    private IMac _hmacAlgorithm;
    private int _iterations;
    private long _blockStart;
    private long _blockEnd;
    private long _pos;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    internal Pbkdf2(IMac hmacAlgorithm, Byte[] salt, int iterations);
    public Byte[] Read(int count);
    internal static Byte[] ComputeDerivedKey(IMac hmacAlgorithm, Byte[] salt, int iterations, int derivedKeyLength);
    protected virtual void Dispose(bool disposing);
    private void DisposeHmac();
    private void ComputeBlock(UInt32 pos);
    private void ComputeHmac(Byte[] input, Byte[] output);
    public virtual void Flush();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
}
public static class NBitcoin.Crypto.Salsa20Core : object {
    private static UInt32 R(UInt32 a, int b);
    public static void Compute(int rounds, UInt32[] input, int inputOffset, UInt32[] output, int outputOffset);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NBitcoin.Crypto.SchnorrSignature : object {
    [CompilerGeneratedAttribute]
private BigInteger <R>k__BackingField;
    [CompilerGeneratedAttribute]
private BigInteger <S>k__BackingField;
    internal BigInteger R { get; }
    internal BigInteger S { get; }
    public SchnorrSignature(Byte[] bytes);
    internal SchnorrSignature(BigInteger r, BigInteger s);
    [CompilerGeneratedAttribute]
internal BigInteger get_R();
    [CompilerGeneratedAttribute]
internal BigInteger get_S();
    public static SchnorrSignature Parse(string hex);
    public static bool TryParse(Byte[] in64, SchnorrSignature& sig);
    public Byte[] ToBytes();
}
public static class NBitcoin.Crypto.SCrypt : object {
    private static int hLen;
    public static Byte[] ComputeDerivedKey(Byte[] key, Byte[] salt, int cost, int blockSize, int parallel, Nullable`1<int> maxThreads, int derivedKeyLength);
    public static Byte[] GetEffectivePbkdf2Salt(Byte[] key, Byte[] salt, int cost, int blockSize, int parallel, Nullable`1<int> maxThreads);
    internal static Pbkdf2 GetStream(Byte[] key, Byte[] salt, int cost, int blockSize, int parallel, Nullable`1<int> maxThreads);
    private static Byte[] MFcrypt(Byte[] P, Byte[] S, int cost, int blockSize, int parallel, Nullable`1<int> maxThreads);
    private static void ThreadSMixCalls(UInt32[] B0, int MFLen, int cost, int blockSize, int parallel, int maxThreads);
    private static void SMix(UInt32[] B, int Boffset, UInt32[] Bp, int Bpoffset, UInt32 N, int r);
    private static void BlockMix(UInt32[] B, int Boffset, UInt32[] Bp, int Bpoffset, UInt32[] x, UInt32[] y, UInt32[] scratch, int r);
    public static Byte[] BitcoinComputeDerivedKey(Byte[] password, Byte[] salt, int outputCount);
    public static Byte[] BitcoinComputeDerivedKey2(Byte[] password, Byte[] salt, int outputCount);
    public static Byte[] BitcoinComputeDerivedKey(string password, Byte[] salt);
}
public class NBitcoin.DataEncoders.ASCIIEncoder : DataEncoder {
    public virtual Byte[] DecodeData(string encoded);
    public virtual string EncodeData(Byte[] data, int offset, int count);
}
public class NBitcoin.DataEncoders.Base32Encoder : DataEncoder {
    private static Int32[] decode32_table;
    private static string pbase32;
    private static Base32Encoder();
    public virtual string EncodeData(Byte[] data, int offset, int count);
    private static bool ConvertBits(Action`1<byte> outfn, Byte[] val, int valOffset, int valCount, int frombits, int tobits, bool pad);
    public virtual Byte[] DecodeData(string encoded);
}
public class NBitcoin.DataEncoders.Base58CheckEncoder : Base58Encoder {
    private static Base58Encoder InternalEncoder;
    private static Base58CheckEncoder();
    public virtual bool IsMaybeEncoded(string str);
    public virtual string EncodeData(Byte[] data, int offset, int count);
    public virtual Byte[] DecodeData(string encoded);
    protected virtual Byte[] CalculateHash(Byte[] bytes, int offset, int length);
}
public class NBitcoin.DataEncoders.Base58Encoder : DataEncoder {
    private static Char[] pszBase58;
    private static Int32[] mapBase58;
    private static Base58Encoder();
    public virtual bool IsMaybeEncoded(string str);
    public virtual string EncodeData(Byte[] data, int offset, int count);
    private static void ArrayFill(T[] array, T value, int index, int count);
    public virtual Byte[] DecodeData(string encoded);
}
public class NBitcoin.DataEncoders.Base64Encoder : DataEncoder {
    public virtual Byte[] DecodeData(string encoded);
    public virtual string EncodeData(Byte[] data, int offset, int count);
}
public class NBitcoin.DataEncoders.Bech32Encoder : object {
    private static Int32[] GF1024_EXP;
    private static Int32[] GF1024_LOG;
    protected static Byte[] Byteset;
    private static UInt32[] Generator;
    protected Byte[] _HrpExpand;
    protected Byte[] _Hrp;
    [CompilerGeneratedAttribute]
private bool <StrictLength>k__BackingField;
    public Byte[] HumanReadablePart { get; }
    public bool StrictLength { get; public set; }
    private static Bech32Encoder();
    internal Bech32Encoder(string hrp);
    public Bech32Encoder(Byte[] hrp);
    private UInt32 syndrome(UInt32 residue);
    private Int32[] locate_errors(UInt32 residue, int length);
    public Byte[] get_HumanReadablePart();
    private static UInt32 Polymod(Byte[] values);
    protected virtual bool VerifyChecksum(Byte[] data, int bechStringLen, Bech32EncodingType& encodingType, Int32[]& errorPosition);
    private Byte[] CreateChecksum(Byte[] data, int offset, int count, Bech32EncodingType encodingType);
    public virtual string EncodeData(Byte[] data, int offset, int count, Bech32EncodingType encodingType);
    public static Bech32Encoder ExtractEncoderFromString(string test);
    protected virtual void CheckCase(string hrp);
    public Byte[] DecodeDataRaw(string encoded, Bech32EncodingType& encodingType);
    [CompilerGeneratedAttribute]
public bool get_StrictLength();
    [CompilerGeneratedAttribute]
public void set_StrictLength(bool value);
    protected virtual Byte[] DecodeDataCore(string encoded, Bech32EncodingType& encodingType);
    protected virtual Byte[] ConvertBits(IEnumerable`1<byte> data, int fromBits, int toBits, bool pad);
    public virtual Byte[] Decode(string addr, Byte& witnessVerion);
    public string EncodeRaw(Byte[] data, Bech32EncodingType encodingType);
    public string Encode(byte witnessVerion, Byte[] witnessProgramm);
}
public class NBitcoin.DataEncoders.Bech32EncodingType : object {
    public static Bech32EncodingType BECH32;
    public static Bech32EncodingType BECH32M;
    public static Bech32EncodingType[] All;
    [CompilerGeneratedAttribute]
private int <EncodingConstant>k__BackingField;
    public int EncodingConstant { get; }
    private static Bech32EncodingType();
    public Bech32EncodingType(int encodingConstant);
    [CompilerGeneratedAttribute]
public int get_EncodingConstant();
}
public class NBitcoin.DataEncoders.Bech32FormatException : FormatException {
    [CompilerGeneratedAttribute]
private Int32[] <ErrorIndexes>k__BackingField;
    public Int32[] ErrorIndexes { get; internal set; }
    public Bech32FormatException(string message, Int32[] indexes);
    [CompilerGeneratedAttribute]
public Int32[] get_ErrorIndexes();
    [CompilerGeneratedAttribute]
internal void set_ErrorIndexes(Int32[] value);
}
public abstract class NBitcoin.DataEncoders.DataEncoder : object {
    public static bool IsSpace(char c);
    public string EncodeData(Byte[] data);
    public abstract virtual string EncodeData(Byte[] data, int offset, int count);
    public abstract virtual Byte[] DecodeData(string encoded);
}
public static class NBitcoin.DataEncoders.Encoders : object {
    private static ASCIIEncoder _ASCII;
    private static HexEncoder _Hex;
    private static Base58Encoder _Base58;
    private static Base32Encoder _Base32;
    private static Base58CheckEncoder _Base58Check;
    private static Base64Encoder _Base64;
    public static DataEncoder ASCII { get; }
    public static DataEncoder Hex { get; }
    public static DataEncoder Base58 { get; }
    public static DataEncoder Base32 { get; }
    public static DataEncoder Base58Check { get; }
    public static DataEncoder Base64 { get; }
    private static Encoders();
    public static DataEncoder get_ASCII();
    public static DataEncoder get_Hex();
    public static DataEncoder get_Base58();
    public static DataEncoder get_Base32();
    public static DataEncoder get_Base58Check();
    public static DataEncoder get_Base64();
    public static Bech32Encoder Bech32(string hrp);
    public static Bech32Encoder Bech32(Byte[] hrp);
}
public class NBitcoin.DataEncoders.HexEncoder : DataEncoder {
    private static String[] HexTbl;
    public static Byte[] CharToHexLookup { get; }
    private static HexEncoder();
    public static Byte[] get_CharToHexLookup();
    public virtual string EncodeData(Byte[] data, int offset, int count);
    public virtual Byte[] DecodeData(string encoded);
    public bool IsValid(string str);
    public static int IsDigit(char c);
    private static byte IsDigitCore(char c);
    public static bool IsWellFormed(string str);
}
public class NBitcoin.DecryptionResult : object {
    [CompilerGeneratedAttribute]
private Key <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private LotSequence <LotSequence>k__BackingField;
    public Key Key { get; public set; }
    public LotSequence LotSequence { get; public set; }
    [CompilerGeneratedAttribute]
public Key get_Key();
    [CompilerGeneratedAttribute]
public void set_Key(Key value);
    [CompilerGeneratedAttribute]
public LotSequence get_LotSequence();
    [CompilerGeneratedAttribute]
public void set_LotSequence(LotSequence value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NBitcoin.DefaultCoinSelector : object {
    [NullableAttribute("2")]
private Random _Rand;
    [CompilerGeneratedAttribute]
private bool <GroupByScriptPubKey>k__BackingField;
    [CompilerGeneratedAttribute]
private IMoney <MinimumChange>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Iterations>k__BackingField;
    public bool GroupByScriptPubKey { get; public set; }
    public IMoney MinimumChange { get; public set; }
    public int Iterations { get; public set; }
    public DefaultCoinSelector(int seed);
    [NullableContextAttribute("2")]
public DefaultCoinSelector(Random random);
    [CompilerGeneratedAttribute]
public bool get_GroupByScriptPubKey();
    [CompilerGeneratedAttribute]
public void set_GroupByScriptPubKey(bool value);
    [CompilerGeneratedAttribute]
public IMoney get_MinimumChange();
    [CompilerGeneratedAttribute]
public void set_MinimumChange(IMoney value);
    public sealed virtual IEnumerable`1<ICoin> Select(IEnumerable`1<ICoin> coins, IMoney target);
    private void ArrayFill(T[] array, T value);
    [CompilerGeneratedAttribute]
public int get_Iterations();
    [CompilerGeneratedAttribute]
public void set_Iterations(int value);
    private void ApproximateBestSubset(List`1<OutputGroup> groups, IMoney nTotalLower, IMoney nTargetValue, Boolean[]& vfBest, IMoney& nBest);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NBitcoin.DNSSeedData : object {
    private string name;
    private string host;
    public string Name { get; }
    public string Host { get; }
    public DNSSeedData(string name, string host);
    public string get_Name();
    public string get_Host();
    public virtual string ToString();
}
public class NBitcoin.EncryptedKeyResult : object {
    private BitcoinEncryptedSecretEC _EncryptedKey;
    private Func`1<BitcoinConfirmationCode> _CalculateConfirmation;
    private BitcoinConfirmationCode _ConfirmationCode;
    private BitcoinAddress _GeneratedAddress;
    private Byte[] _Seed;
    public BitcoinEncryptedSecretEC EncryptedKey { get; }
    public BitcoinConfirmationCode ConfirmationCode { get; }
    public BitcoinAddress GeneratedAddress { get; }
    public Byte[] Seed { get; }
    public EncryptedKeyResult(BitcoinEncryptedSecretEC key, BitcoinAddress address, Byte[] seed, Func`1<BitcoinConfirmationCode> calculateConfirmation);
    public BitcoinEncryptedSecretEC get_EncryptedKey();
    public BitcoinConfirmationCode get_ConfirmationCode();
    public BitcoinAddress get_GeneratedAddress();
    public Byte[] get_Seed();
}
public class NBitcoin.ExecutionData : object {
    [CompilerGeneratedAttribute]
private uint256 <AnnexHash>k__BackingField;
    [CompilerGeneratedAttribute]
private uint256 <TapleafHash>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <CodeseparatorPosition>k__BackingField;
    [CompilerGeneratedAttribute]
private long <ValidationWeightLeft>k__BackingField;
    public uint256 AnnexHash { get; public set; }
    public uint256 TapleafHash { get; internal set; }
    public UInt32 CodeseparatorPosition { get; public set; }
    public long ValidationWeightLeft { get; public set; }
    [CompilerGeneratedAttribute]
public uint256 get_AnnexHash();
    [CompilerGeneratedAttribute]
public void set_AnnexHash(uint256 value);
    [CompilerGeneratedAttribute]
public uint256 get_TapleafHash();
    [CompilerGeneratedAttribute]
internal void set_TapleafHash(uint256 value);
    [CompilerGeneratedAttribute]
public UInt32 get_CodeseparatorPosition();
    [CompilerGeneratedAttribute]
public void set_CodeseparatorPosition(UInt32 value);
    [CompilerGeneratedAttribute]
public long get_ValidationWeightLeft();
    [CompilerGeneratedAttribute]
public void set_ValidationWeightLeft(long value);
}
[ExtensionAttribute]
public static class NBitcoin.Extensions : object {
    [ExtensionAttribute]
public static IHDKey AsHDKeyCache(IHDKey hdkey);
    [ExtensionAttribute]
public static IHDScriptPubKey AsHDKeyCache(IHDScriptPubKey hdScriptPubKey);
    [ExtensionAttribute]
public static IHDScriptPubKey AsHDScriptPubKey(IHDKey hdKey, ScriptPubKeyType type);
    [ExtensionAttribute]
public static IHDKey Derive(IHDKey hdkey, UInt32 index);
    [ExtensionAttribute]
public static IHDKey[] Derive(IHDKey hdkey, KeyPath[] keyPaths);
    [AsyncStateMachineAttribute("NBitcoin.Extensions/<WithCancellation>d__5")]
[ExtensionAttribute]
public static Task WithCancellation(Task task, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NBitcoin.Extensions/<WithCancellation>d__6`1")]
[ExtensionAttribute]
public static Task`1<T> WithCancellation(Task`1<T> task, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Block GetBlock(IBlockRepository repository, uint256 blockId);
    [ExtensionAttribute]
public static T ToNetwork(T obj, ChainName chainName);
    [ExtensionAttribute]
public static T ToNetwork(T obj, Network network);
    [ExtensionAttribute]
public static Byte[] ReadBytes(Stream stream, int bytesToRead);
    [ExtensionAttribute]
public static int ReadBytes(Stream stream, int bytesToRead, Byte[] buffer);
    [AsyncStateMachineAttribute("NBitcoin.Extensions/<ReadBytesAsync>d__12")]
[ExtensionAttribute]
public static Task`1<Byte[]> ReadBytesAsync(Stream stream, int bytesToRead);
    [ExtensionAttribute]
public static int ReadBytes(Stream stream, int count, Byte[]& result);
    [ExtensionAttribute]
public static IEnumerable`1<T> Resize(List`1<T> list, int count);
    [ExtensionAttribute]
public static IEnumerable`1<List`1<T>> Partition(IEnumerable`1<T> source, int max);
    [IteratorStateMachineAttribute("NBitcoin.Extensions/<Partition>d__16`1")]
[ExtensionAttribute]
public static IEnumerable`1<List`1<T>> Partition(IEnumerable`1<T> source, Func`1<int> max);
    [ExtensionAttribute]
public static int ReadEx(Stream stream, Byte[] buffer, int offset, int count, CancellationToken cancellation);
    [ExtensionAttribute]
public static void AddOrReplace(IDictionary`2<TKey, TValue> dico, TKey key, TValue value);
    [ExtensionAttribute]
public static TValue TryGet(IDictionary`2<TKey, TValue> dictionary, TKey key);
    [ExtensionAttribute]
public static bool TryAdd(IDictionary`2<TKey, TValue> dictionary, TKey key, TValue value);
    [ExtensionAttribute]
public static int ToUnixTimestamp(DateTime value);
    [ExtensionAttribute]
public static int UnixTimestamp(DateTime ignored);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NBitcoin.ExtKey : object {
    private static int ChainCodeLength;
    private Key key;
    private Byte[] vchChainCode;
    private UInt32 nChild;
    private byte nDepth;
    private HDFingerprint parentFingerprint;
    private static Byte[] hashkey;
    public static int Length;
    private Nullable`1<int> hashcode;
    public byte Depth { get; }
    public UInt32 Child { get; }
    public Byte[] ChainCode { get; }
    public Key PrivateKey { get; }
    public HDFingerprint ParentFingerprint { get; }
    public Script ScriptPubKey { get; }
    public bool IsHardened { get; }
    public ExtKey(BitcoinExtPubKey extPubKey, BitcoinSecret key);
    public ExtKey(ExtPubKey extPubKey, Key privateKey);
    public ExtKey(Key key, Byte[] chainCode, byte depth, HDFingerprint fingerprint, UInt32 child);
    public ExtKey(Key masterKey, Byte[] chainCode);
    public ExtKey(string seedHex);
    private ExtKey(Byte[] bytes, bool isSeed);
    private static ExtKey();
    public static ExtKey Parse(string wif, Network expectedNetwork);
    public byte get_Depth();
    public UInt32 get_Child();
    public Byte[] get_ChainCode();
    public ExtKey Derive(RootedKeyPath rootedKeyPath);
    public static ExtKey CreateFromSeed(Byte[] seed);
    public static ExtKey CreateFromBytes(Byte[] bytes);
    private static Key CalculateKey(Byte[] seed, Byte[]& chainCode);
    public sealed virtual Key get_PrivateKey();
    public ExtPubKey Neuter();
    public bool IsChildOf(ExtKey parentKey);
    public bool IsParentOf(ExtKey childKey);
    public HDFingerprint get_ParentFingerprint();
    public ExtKey Derive(UInt32 index);
    public ExtKey Derive(int index, bool hardened);
    public ExtKey Derive(KeyPath keyPath);
    public BitcoinExtKey GetWif(Network network);
    public Byte[] ToBytes();
    public string ToString(Network network);
    public sealed virtual Script get_ScriptPubKey();
    public bool get_IsHardened();
    public ExtKey GetParentExtKey(ExtPubKey parent);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(ExtKey other);
    private sealed virtual override IHDKey NBitcoin.IHDKey.Derive(KeyPath keyPath);
    public sealed virtual PubKey GetPublicKey();
    private sealed virtual override bool NBitcoin.IHDKey.CanDeriveHardenedPath();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
public static bool op_Equality(ExtKey a, ExtKey b);
    [NullableContextAttribute("2")]
public static bool op_Inequality(ExtKey a, ExtKey b);
    public virtual int GetHashCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NBitcoin.ExtPubKey : object {
    private static int ChainCodeLength;
    internal byte nDepth;
    internal HDFingerprint parentFingerprint;
    internal UInt32 nChild;
    internal PubKey pubkey;
    internal Byte[] vchChainCode;
    public static int Length;
    private int hashcode;
    public byte Depth { get; }
    public UInt32 Child { get; }
    public bool IsHardened { get; }
    public PubKey PubKey { get; }
    public Byte[] ChainCode { get; }
    public HDFingerprint ParentFingerprint { get; }
    public Script ScriptPubKey { get; }
    public ExtPubKey(Byte[] bytes);
    public ExtPubKey(Byte[] bytes, int offset, int length);
    public ExtPubKey(string hex);
    public ExtPubKey(PubKey pubkey, Byte[] chainCode, byte depth, HDFingerprint fingerprint, UInt32 child);
    public ExtPubKey(PubKey masterKey, Byte[] chainCode);
    public static ExtPubKey Parse(string wif, Network expectedNetwork);
    public byte get_Depth();
    public UInt32 get_Child();
    public bool get_IsHardened();
    public PubKey get_PubKey();
    public Byte[] get_ChainCode();
    public bool IsChildOf(ExtPubKey parentKey);
    public bool IsParentOf(ExtPubKey childKey);
    public HDFingerprint get_ParentFingerprint();
    public ExtPubKey Derive(UInt32 index);
    public ExtPubKey Derive(KeyPath derivation);
    public ExtPubKey Derive(int index, bool hardened);
    public BitcoinExtPubKey GetWif(Network network);
    public Byte[] ToBytes();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
public static bool op_Equality(ExtPubKey a, ExtPubKey b);
    [NullableContextAttribute("2")]
public static bool op_Inequality(ExtPubKey a, ExtPubKey b);
    public virtual int GetHashCode();
    public string ToString(Network network);
    private sealed virtual override IHDKey NBitcoin.IHDKey.Derive(KeyPath keyPath);
    public sealed virtual PubKey GetPublicKey();
    private sealed virtual override bool NBitcoin.IHDKey.CanDeriveHardenedPath();
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(ExtPubKey other);
    public sealed virtual Script get_ScriptPubKey();
}
public class NBitcoin.FeeRate : object {
    private Money _FeePerK;
    private static FeeRate _Zero;
    public Money FeePerK { get; }
    public decimal SatoshiPerByte { get; }
    public static FeeRate Zero { get; }
    public FeeRate(Money feePerK);
    public FeeRate(Money feePaid, int size);
    public FeeRate(decimal satoshiPerByte);
    private static FeeRate();
    public Money get_FeePerK();
    public decimal get_SatoshiPerByte();
    public static FeeRate get_Zero();
    public Money GetFee(int virtualSize);
    public Money GetFee(Transaction tx);
    public virtual bool Equals(object obj);
    public virtual string ToString();
    public sealed virtual bool Equals(FeeRate other);
    public sealed virtual int CompareTo(FeeRate other);
    public int CompareTo(object obj);
    public static bool op_LessThan(FeeRate left, FeeRate right);
    public static bool op_GreaterThan(FeeRate left, FeeRate right);
    public static bool op_LessThanOrEqual(FeeRate left, FeeRate right);
    public static bool op_GreaterThanOrEqual(FeeRate left, FeeRate right);
    public static bool op_Equality(FeeRate left, FeeRate right);
    public static bool op_Inequality(FeeRate left, FeeRate right);
    public virtual int GetHashCode();
    public static FeeRate Min(FeeRate left, FeeRate right);
    public static FeeRate Max(FeeRate left, FeeRate right);
}
public class NBitcoin.FeeRateGroup : object {
    [CompilerGeneratedAttribute]
private int <Group>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <Sizes>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <Count>k__BackingField;
    [CompilerGeneratedAttribute]
private Money <Fees>k__BackingField;
    [CompilerGeneratedAttribute]
private FeeRate <From>k__BackingField;
    [CompilerGeneratedAttribute]
private FeeRate <To>k__BackingField;
    public int Group { get; public set; }
    public ulong Sizes { get; public set; }
    public UInt32 Count { get; public set; }
    public Money Fees { get; public set; }
    public FeeRate From { get; public set; }
    public FeeRate To { get; public set; }
    [CompilerGeneratedAttribute]
public int get_Group();
    [CompilerGeneratedAttribute]
public void set_Group(int value);
    [CompilerGeneratedAttribute]
public ulong get_Sizes();
    [CompilerGeneratedAttribute]
public void set_Sizes(ulong value);
    [CompilerGeneratedAttribute]
public UInt32 get_Count();
    [CompilerGeneratedAttribute]
public void set_Count(UInt32 value);
    [CompilerGeneratedAttribute]
public Money get_Fees();
    [CompilerGeneratedAttribute]
public void set_Fees(Money value);
    [CompilerGeneratedAttribute]
public FeeRate get_From();
    [CompilerGeneratedAttribute]
public void set_From(FeeRate value);
    [CompilerGeneratedAttribute]
public FeeRate get_To();
    [CompilerGeneratedAttribute]
public void set_To(FeeRate value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NBitcoin.FlatSigningRepository : object {
    [CompilerGeneratedAttribute]
private ConcurrentDictionary`2<KeyId, ISecret> <Secrets>k__BackingField;
    [CompilerGeneratedAttribute]
private ConcurrentDictionary`2<KeyId, PubKey> <Pubkeys>k__BackingField;
    [CompilerGeneratedAttribute]
private ConcurrentDictionary`2<KeyId, RootedKeyPath> <KeyIdToKeyOrigins>k__BackingField;
    [CompilerGeneratedAttribute]
private ConcurrentDictionary`2<ScriptId, Script> <Scripts>k__BackingField;
    public ConcurrentDictionary`2<KeyId, ISecret> Secrets { get; }
    public ConcurrentDictionary`2<KeyId, PubKey> Pubkeys { get; }
    public ConcurrentDictionary`2<KeyId, RootedKeyPath> KeyIdToKeyOrigins { get; }
    public ConcurrentDictionary`2<ScriptId, Script> Scripts { get; }
    public RootedKeyPath[] KeyOrigins { get; }
    [CompilerGeneratedAttribute]
public ConcurrentDictionary`2<KeyId, ISecret> get_Secrets();
    [CompilerGeneratedAttribute]
public ConcurrentDictionary`2<KeyId, PubKey> get_Pubkeys();
    [CompilerGeneratedAttribute]
public ConcurrentDictionary`2<KeyId, RootedKeyPath> get_KeyIdToKeyOrigins();
    [CompilerGeneratedAttribute]
public ConcurrentDictionary`2<ScriptId, Script> get_Scripts();
    public RootedKeyPath[] get_KeyOrigins();
    public sealed virtual bool TryGetScript(ScriptId scriptId, Script& script);
    public sealed virtual bool TryGetPubKey(KeyId keyId, PubKey& pubkey);
    public sealed virtual bool TryGetKeyOrigin(KeyId keyId, RootedKeyPath& keyOrigin);
    public sealed virtual bool TryGetSecret(KeyId keyId, ISecret& key);
    public sealed virtual void SetScript(ScriptId scriptId, Script script);
    public sealed virtual void SetPubKey(KeyId keyId, PubKey pubkey);
    public sealed virtual void SetSecret(KeyId keyId, ISecret secret);
    public sealed virtual void SetKeyOrigin(KeyId keyId, RootedKeyPath keyOrigin);
    public sealed virtual void Merge(ISigningRepository other);
    private void MergeDict(ConcurrentDictionary`2<U, T> a, ConcurrentDictionary`2<U, T> b);
}
public class NBitcoin.GolombRiceFilter : object {
    internal static byte DefaultP;
    internal static UInt32 DefaultM;
    [CompilerGeneratedAttribute]
private byte <P>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <M>k__BackingField;
    [CompilerGeneratedAttribute]
private int <N>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <Data>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <ModulusP>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <ModulusNP>k__BackingField;
    [CompilerGeneratedAttribute]
private static GolombRiceFilter <Empty>k__BackingField;
    public byte P { get; }
    public UInt32 M { get; }
    public int N { get; }
    public Byte[] Data { get; }
    private ulong ModulusP { get; }
    private ulong ModulusNP { get; }
    public static GolombRiceFilter Empty { get; }
    public GolombRiceFilter(Byte[] data);
    public GolombRiceFilter(Byte[] data, byte p, UInt32 m);
    internal GolombRiceFilter(Byte[] data, int n, byte p, UInt32 m);
    private static GolombRiceFilter();
    [CompilerGeneratedAttribute]
public byte get_P();
    [CompilerGeneratedAttribute]
public UInt32 get_M();
    [CompilerGeneratedAttribute]
public int get_N();
    [CompilerGeneratedAttribute]
public Byte[] get_Data();
    [CompilerGeneratedAttribute]
private ulong get_ModulusP();
    [CompilerGeneratedAttribute]
private ulong get_ModulusNP();
    [CompilerGeneratedAttribute]
public static GolombRiceFilter get_Empty();
    public static GolombRiceFilter Parse(string str);
    internal static UInt64[] ConstructHashedSet(byte P, int n, UInt32 m, Byte[] key, IEnumerable`1<Byte[]> data, int dataCount);
    public uint256 GetHeader(uint256 previousHeader);
    public bool Match(Byte[] data, Byte[] key);
    public bool Match(Byte[] data, Byte[] key, GRCodedStreamReader reader);
    public bool MatchAny(Byte[][] data, Byte[] key);
    public bool MatchAny(IEnumerable`1<Byte[]> data, Byte[] key);
    public bool MatchAny(IEnumerable`1<Byte[]> data, Byte[] key, GRCodedStreamReader reader);
    internal bool MatchAny(IEnumerable`1<Byte[]> data, int dataCount, Byte[] key, GRCodedStreamReader reader);
    private bool InternalMatchAny(IEnumerable`1<Byte[]> data, int dataCount, Byte[] key, GRCodedStreamReader sr);
    public Byte[] ToBytes();
    public virtual string ToString();
    public CachedGRCodedStreamReader GetNewGRStreamReader();
    internal static ulong FastReduction(ulong value, ulong nhi, ulong nlo);
    private static ulong SipHash(ulong k0, ulong k1, Byte[] data);
}
public class NBitcoin.GolombRiceFilterBuilder : object {
    private byte _p;
    private UInt32 _m;
    private Byte[] _key;
    private HashSet`1<Byte[]> _values;
    private static Byte[] EmptyBytes;
    private static GolombRiceFilterBuilder();
    public static GolombRiceFilter BuildBasicFilter(Block block);
    public GolombRiceFilterBuilder SetKey(uint256 blockHash);
    public GolombRiceFilterBuilder SetP(int p);
    public GolombRiceFilterBuilder SetM(UInt32 m);
    public GolombRiceFilterBuilder AddTxId(uint256 id);
    public GolombRiceFilterBuilder AddScriptPubkey(Script scriptPubkey);
    public GolombRiceFilterBuilder AddScriptSig(Script scriptSig);
    public void AddWitness(WitScript witScript);
    public GolombRiceFilterBuilder AddOutPoint(OutPoint outpoint);
    public GolombRiceFilterBuilder AddEntries(IEnumerable`1<Byte[]> entries);
    public GolombRiceFilter Build();
    private static Byte[] Compress(UInt64[] values, byte P);
}
public class NBitcoin.GRCodedStreamReader : object {
    private BitStream _stream;
    private byte _p;
    private ulong _modP;
    private ulong _lastValue;
    internal GRCodedStreamReader(BitStream stream, byte p, ulong lastValue);
    public virtual bool TryRead(UInt64& value);
    internal virtual void ResetPosition();
    private bool TryReadUInt64(UInt64& value);
}
internal class NBitcoin.GRCodedStreamWriter : object {
    private BitStream _stream;
    private byte _p;
    private ulong _modP;
    private ulong _lastValue;
    public GRCodedStreamWriter(BitStream stream, byte p);
    public void Write(ulong value);
}
public class NBitcoin.HardcodedWordlistSource : object {
    private static Dictionary`2<string, string> _WordLists;
    private static HardcodedWordlistSource();
    public sealed virtual Task`1<Wordlist> Load(string name);
}
public enum NBitcoin.HashVersion : Enum {
    public int value__;
    public static HashVersion Original;
    public static HashVersion WitnessV0;
    public static HashVersion Taproot;
    public static HashVersion Tapscript;
}
[IsReadOnlyAttribute]
public class NBitcoin.HDFingerprint : ValueType {
    private UInt32 _Value;
    public HDFingerprint(Byte[] bytes);
    public HDFingerprint(Byte[] bytes, int index);
    public HDFingerprint(UInt32 value);
    public static bool TryParse(string str, HDFingerprint& result);
    public static HDFingerprint Parse(string str);
    public static HDFingerprint FromKeyId(KeyId id);
    public Byte[] ToBytes();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(HDFingerprint x, HDFingerprint y);
    public static bool op_Inequality(HDFingerprint x, HDFingerprint y);
    public virtual string ToString();
}
internal class NBitcoin.HDKeyCache : object {
    private IHDKey hdKey;
    private KeyPath _PathFromRoot;
    private ConcurrentDictionary`2<KeyPath, IHDKey> derivationCache;
    public IHDKey Inner { get; }
    internal int Cached { get; }
    internal HDKeyCache(IHDKey masterKey);
    private HDKeyCache(IHDKey hdKey, KeyPath childPath, ConcurrentDictionary`2<KeyPath, IHDKey> cache);
    public IHDKey get_Inner();
    public sealed virtual IHDKey Derive(KeyPath keyPath);
    internal int get_Cached();
    public sealed virtual PubKey GetPublicKey();
    public sealed virtual bool CanDeriveHardenedPath();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NBitcoin.HDKeyScriptPubKey : object {
    private IHDKey hdKey;
    private ScriptPubKeyType type;
    [NullableAttribute("2")]
private Script _ScriptPubKey;
    public IHDKey HDKey { get; }
    public Script ScriptPubKey { get; }
    public HDKeyScriptPubKey(IHDKey hdKey, ScriptPubKeyType type);
    public IHDKey get_HDKey();
    public sealed virtual Script get_ScriptPubKey();
    public sealed virtual IHDScriptPubKey Derive(KeyPath keyPath);
    public sealed virtual bool CanDeriveHardenedPath();
}
internal class NBitcoin.HDScriptPubKeyCache : object {
    private IHDScriptPubKey hdKey;
    private KeyPath _PathFromRoot;
    private ConcurrentDictionary`2<KeyPath, IHDScriptPubKey> derivationCache;
    public IHDScriptPubKey Inner { get; }
    internal int Cached { get; }
    public Script ScriptPubKey { get; }
    internal HDScriptPubKeyCache(IHDScriptPubKey masterKey);
    private HDScriptPubKeyCache(IHDScriptPubKey hdKey, KeyPath childPath, ConcurrentDictionary`2<KeyPath, IHDScriptPubKey> cache);
    public IHDScriptPubKey get_Inner();
    public sealed virtual IHDScriptPubKey Derive(KeyPath keyPath);
    internal int get_Cached();
    public sealed virtual Script get_ScriptPubKey();
    public sealed virtual bool CanDeriveHardenedPath();
}
public interface NBitcoin.IAddressableDestination {
    public abstract virtual bool IsSupported(Network network);
    public abstract virtual BitcoinAddress GetAddress(Network network);
}
public interface NBitcoin.IBase58Data {
    public Base58Type Type { get; }
    public abstract virtual Base58Type get_Type();
}
public interface NBitcoin.IBech32Data {
    public Bech32Type Type { get; }
    public abstract virtual Bech32Type get_Type();
}
public interface NBitcoin.IBitcoinSerializable {
    public abstract virtual void ReadWrite(BitcoinStream stream);
}
public interface NBitcoin.IBitcoinString {
    public Network Network { get; }
    public abstract virtual Network get_Network();
}
public interface NBitcoin.IBlockRepository {
    public abstract virtual Task`1<Block> GetBlockAsync(uint256 blockId, CancellationToken cancellationToken);
}
public interface NBitcoin.ICoin {
    public IMoney Amount { get; }
    public bool CanGetScriptCode { get; }
    public bool IsMalleable { get; }
    public abstract virtual IMoney get_Amount();
    public abstract virtual Script GetScriptCode();
    public abstract virtual void OverrideScriptCode(Script scriptCode);
    public abstract virtual bool get_CanGetScriptCode();
    public abstract virtual HashVersion GetHashVersion();
    public abstract virtual bool get_IsMalleable();
}
public interface NBitcoin.ICoinable {
    public OutPoint Outpoint { get; }
    public TxOut TxOut { get; }
    public abstract virtual OutPoint get_Outpoint();
    public abstract virtual TxOut get_TxOut();
}
[NullableContextAttribute("1")]
public interface NBitcoin.ICoinSelector {
    public abstract virtual IEnumerable`1<ICoin> Select(IEnumerable`1<ICoin> coins, IMoney target);
}
public interface NBitcoin.IColoredCoin {
    public AssetId AssetId { get; }
    public Coin Bearer { get; }
    public abstract virtual AssetId get_AssetId();
    public abstract virtual Coin get_Bearer();
}
public interface NBitcoin.IDestination {
    public Script ScriptPubKey { get; }
    public abstract virtual Script get_ScriptPubKey();
}
public interface NBitcoin.IHasForkId {
    public UInt32 ForkId { get; }
    public abstract virtual UInt32 get_ForkId();
}
public interface NBitcoin.IHDKey {
    public abstract virtual IHDKey Derive(KeyPath keyPath);
    public abstract virtual PubKey GetPublicKey();
    public abstract virtual bool CanDeriveHardenedPath();
}
public interface NBitcoin.IHDScriptPubKey {
    public Script ScriptPubKey { get; }
    public abstract virtual IHDScriptPubKey Derive(KeyPath keyPath);
    public abstract virtual bool CanDeriveHardenedPath();
    public abstract virtual Script get_ScriptPubKey();
}
public interface NBitcoin.IMoney {
    public abstract virtual IMoney Add(IMoney money);
    public abstract virtual IMoney Sub(IMoney money);
    public abstract virtual IMoney Negate();
    public abstract virtual bool IsCompatible(IMoney money);
    public abstract virtual IEnumerable`1<IMoney> Split(int parts);
}
public class NBitcoin.IndexedTxIn : object {
    [CompilerGeneratedAttribute]
private TxIn <TxIn>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <Index>k__BackingField;
    [CompilerGeneratedAttribute]
private Transaction <Transaction>k__BackingField;
    public TxIn TxIn { get; public set; }
    public UInt32 Index { get; public set; }
    public OutPoint PrevOut { get; public set; }
    public Script ScriptSig { get; public set; }
    public WitScript WitScript { get; public set; }
    public Transaction Transaction { get; public set; }
    [CompilerGeneratedAttribute]
public TxIn get_TxIn();
    [CompilerGeneratedAttribute]
public void set_TxIn(TxIn value);
    [CompilerGeneratedAttribute]
public UInt32 get_Index();
    [CompilerGeneratedAttribute]
public void set_Index(UInt32 value);
    public OutPoint get_PrevOut();
    public void set_PrevOut(OutPoint value);
    public Script get_ScriptSig();
    public void set_ScriptSig(Script value);
    public WitScript get_WitScript();
    public void set_WitScript(WitScript value);
    [CompilerGeneratedAttribute]
public Transaction get_Transaction();
    [CompilerGeneratedAttribute]
public void set_Transaction(Transaction value);
    [NullableContextAttribute("1")]
public bool VerifyScript(TxOut spentOutput, ScriptVerify scriptVerify);
    [NullableContextAttribute("1")]
public bool VerifyScript(TxOut spentOutput, ScriptError& error);
    [NullableContextAttribute("1")]
public bool VerifyScript(TxOut spentOutput, ScriptVerify scriptVerify, ScriptError& error);
    [NullableContextAttribute("1")]
public bool VerifyScript(ICoin spentCoin, ScriptVerify scriptVerify);
    [NullableContextAttribute("1")]
public bool VerifyScript(ICoin spentCoin, ScriptVerify scriptVerify, ScriptError& error);
    [NullableContextAttribute("1")]
public bool VerifyScript(ICoin spentCoin, ScriptVerify scriptVerify, PrecomputedTransactionData precomputedTransactionData, ScriptError& error);
    [NullableContextAttribute("1")]
public bool VerifyScript(TxOut spentOutput, ScriptVerify scriptVerify, PrecomputedTransactionData precomputedTransactionData, ScriptError& error);
    [NullableContextAttribute("1")]
public bool VerifyScript(ICoin coin, ScriptError& error);
    [NullableContextAttribute("1")]
public TransactionSignature Sign(Key key, ICoin coin);
    [NullableContextAttribute("1")]
public TransactionSignature Sign(Key key, ICoin coin, SigningOptions signingOptions);
    [NullableContextAttribute("1")]
public uint256 GetSignatureHash(ICoin coin, SigHash sigHash);
    [NullableContextAttribute("1")]
public uint256 GetSignatureHash(ICoin coin, SigHash sigHash, PrecomputedTransactionData transactionData);
    [NullableContextAttribute("1")]
public uint256 GetSignatureHashTaproot(ICoin coin, TaprootSigHash sigHash, PrecomputedTransactionData transactionData);
}
public class NBitcoin.IndexedTxOut : object {
    [CompilerGeneratedAttribute]
private TxOut <TxOut>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <N>k__BackingField;
    [CompilerGeneratedAttribute]
private Transaction <Transaction>k__BackingField;
    public TxOut TxOut { get; public set; }
    public UInt32 N { get; public set; }
    public Transaction Transaction { get; public set; }
    [CompilerGeneratedAttribute]
public TxOut get_TxOut();
    [CompilerGeneratedAttribute]
public void set_TxOut(TxOut value);
    [CompilerGeneratedAttribute]
public UInt32 get_N();
    [CompilerGeneratedAttribute]
public void set_N(UInt32 value);
    [CompilerGeneratedAttribute]
public Transaction get_Transaction();
    [CompilerGeneratedAttribute]
public void set_Transaction(Transaction value);
    public Coin ToCoin();
}
public interface NBitcoin.INetworkSet {
    public Network Mainnet { get; }
    public Network Testnet { get; }
    public Network Regtest { get; }
    public string CryptoCode { get; }
    public abstract virtual Network GetNetwork(ChainName chainName);
    public abstract virtual Network get_Mainnet();
    public abstract virtual Network get_Testnet();
    public abstract virtual Network get_Regtest();
    public abstract virtual string get_CryptoCode();
}
public class NBitcoin.InMemoryNoSqlRepository : NoSqlRepository {
    private Dictionary`2<string, Byte[]> _Table;
    public InMemoryNoSqlRepository(ConsensusFactory consensusFactory);
    protected virtual Task PutBytesBatch(IEnumerable`1<Tuple`2<string, Byte[]>> enumerable);
    protected virtual Task`1<Byte[]> GetBytes(string key);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NBitcoin.InputValidationResult : object {
    [CompilerGeneratedAttribute]
private int <InputIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<ScriptError> <Error>k__BackingField;
    [CompilerGeneratedAttribute]
private ExecutionData <ExecutionData>k__BackingField;
    public int InputIndex { get; }
    public Nullable`1<ScriptError> Error { get; }
    public ExecutionData ExecutionData { get; }
    internal InputValidationResult(int index, ScriptError error, ExecutionData executionData);
    internal InputValidationResult(int index, ExecutionData executionData);
    [CompilerGeneratedAttribute]
public int get_InputIndex();
    [CompilerGeneratedAttribute]
public Nullable`1<ScriptError> get_Error();
    [CompilerGeneratedAttribute]
public ExecutionData get_ExecutionData();
}
public interface NBitcoin.IPubKey {
}
public interface NBitcoin.IRandom {
    public abstract virtual void GetBytes(Byte[] output);
}
public interface NBitcoin.ISecret {
    public Key PrivateKey { get; }
    public abstract virtual Key get_PrivateKey();
}
[NullableContextAttribute("1")]
public interface NBitcoin.ISigningRepository {
    public abstract virtual bool TryGetScript(ScriptId scriptId, Script& script);
    public abstract virtual bool TryGetPubKey(KeyId keyId, PubKey& pubkey);
    public abstract virtual bool TryGetKeyOrigin(KeyId keyId, RootedKeyPath& keyorigin);
    public abstract virtual bool TryGetSecret(KeyId keyId, ISecret& secret);
    public abstract virtual void SetScript(ScriptId scriptId, Script script);
    public abstract virtual void SetPubKey(KeyId keyId, PubKey pubkey);
    public abstract virtual void SetSecret(KeyId keyId, ISecret secret);
    public abstract virtual void SetKeyOrigin(KeyId keyId, RootedKeyPath keyOrigin);
    public abstract virtual void Merge(ISigningRepository other);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class NBitcoin.ISigningRepositoryExtensions : object {
    [ExtensionAttribute]
[ObsoleteAttribute("Use OutputDescriptor.IsSolvable")]
public static bool IsSolvable(ISigningRepository repo, Script scriptPubKey);
    [ExtensionAttribute]
public static Key GetPrivateKey(ISigningRepository repo, KeyId id);
}
public class NBitcoin.IssuanceCoin : object {
    [CompilerGeneratedAttribute]
private Uri <DefinitionUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private Coin <Bearer>k__BackingField;
    public bool IsMalleable { get; }
    public AssetId AssetId { get; }
    public Uri DefinitionUrl { get; public set; }
    public Money Amount { get; public set; }
    public TxOut TxOut { get; }
    public Script ScriptPubKey { get; }
    public Coin Bearer { get; public set; }
    public OutPoint Outpoint { get; }
    private AssetId NBitcoin.IColoredCoin.AssetId { get; }
    private Coin NBitcoin.IColoredCoin.Bearer { get; }
    private IMoney NBitcoin.ICoin.Amount { get; }
    private OutPoint NBitcoin.ICoinable.Outpoint { get; }
    private TxOut NBitcoin.ICoinable.TxOut { get; }
    public bool CanGetScriptCode { get; }
    public IssuanceCoin(Coin bearer);
    public IssuanceCoin(OutPoint outpoint, TxOut txout);
    public sealed virtual bool get_IsMalleable();
    public AssetId get_AssetId();
    [CompilerGeneratedAttribute]
public Uri get_DefinitionUrl();
    [CompilerGeneratedAttribute]
public void set_DefinitionUrl(Uri value);
    public Money get_Amount();
    public void set_Amount(Money value);
    public TxOut get_TxOut();
    public Script get_ScriptPubKey();
    [CompilerGeneratedAttribute]
public Coin get_Bearer();
    [CompilerGeneratedAttribute]
public void set_Bearer(Coin value);
    public OutPoint get_Outpoint();
    private sealed virtual override AssetId NBitcoin.IColoredCoin.get_AssetId();
    private sealed virtual override Coin NBitcoin.IColoredCoin.get_Bearer();
    private sealed virtual override IMoney NBitcoin.ICoin.get_Amount();
    private sealed virtual override OutPoint NBitcoin.ICoinable.get_Outpoint();
    private sealed virtual override TxOut NBitcoin.ICoinable.get_TxOut();
    public sealed virtual Script GetScriptCode();
    public sealed virtual bool get_CanGetScriptCode();
    public sealed virtual HashVersion GetHashVersion();
    public sealed virtual void OverrideScriptCode(Script scriptCode);
}
public interface NBitcoin.ITransactionRepository {
    public abstract virtual Task`1<Transaction> GetAsync(uint256 txId);
    public abstract virtual Task PutAsync(uint256 txId, Transaction tx);
}
public interface NBitcoin.ITransactionSignature {
    public abstract virtual Byte[] ToBytes();
}
public interface NBitcoin.IWordlistSource {
    public abstract virtual Task`1<Wordlist> Load(string name);
}
public class NBitcoin.JsonConverters.AssetIdJsonConverter : JsonConverter {
    [CompilerGeneratedAttribute]
private Network <Network>k__BackingField;
    public Network Network { get; public set; }
    public AssetIdJsonConverter(Network network);
    public virtual bool CanConvert(Type objectType);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    [CompilerGeneratedAttribute]
public Network get_Network();
    [CompilerGeneratedAttribute]
public void set_Network(Network value);
}
public class NBitcoin.JsonConverters.BitcoinSerializableJsonConverter : JsonConverter {
    [CompilerGeneratedAttribute]
private Network <Network>k__BackingField;
    public Network Network { get; public set; }
    public BitcoinSerializableJsonConverter(Network network);
    [CompilerGeneratedAttribute]
public Network get_Network();
    [CompilerGeneratedAttribute]
public void set_Network(Network value);
    public virtual bool CanConvert(Type objectType);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
}
public class NBitcoin.JsonConverters.BitcoinStringJsonConverter : JsonConverter {
    [CompilerGeneratedAttribute]
private Network <Network>k__BackingField;
    public Network Network { get; public set; }
    public BitcoinStringJsonConverter(Network network);
    public virtual bool CanConvert(Type objectType);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    [CompilerGeneratedAttribute]
public Network get_Network();
    [CompilerGeneratedAttribute]
public void set_Network(Network value);
}
public class NBitcoin.JsonConverters.ChainNameJsonConverter : JsonConverter`1<ChainName> {
    public virtual void WriteJson(JsonWriter writer, ChainName value, JsonSerializer serializer);
    public virtual ChainName ReadJson(JsonReader reader, Type objectType, ChainName existingValue, bool hasExistingValue, JsonSerializer serializer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NBitcoin.JsonConverters.CoinJsonConverter : JsonConverter {
    [CompilerGeneratedAttribute]
private Network <Network>k__BackingField;
    public Network Network { get; public set; }
    public CoinJsonConverter(Network network);
    [CompilerGeneratedAttribute]
public Network get_Network();
    [CompilerGeneratedAttribute]
public void set_Network(Network value);
    public virtual bool CanConvert(Type objectType);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
}
public class NBitcoin.JsonConverters.DateTimeToUnixTimeConverter : JsonConverter {
    public virtual bool CanConvert(Type objectType);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
}
public class NBitcoin.JsonConverters.FeeRateJsonConverter : JsonConverter {
    public virtual bool CanConvert(Type objectType);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
}
public class NBitcoin.JsonConverters.HDFingerprintJsonConverter : JsonConverter {
    public virtual bool CanConvert(Type objectType);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
}
public class NBitcoin.JsonConverters.HexJsonConverter : JsonConverter {
    public virtual bool CanConvert(Type objectType);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
}
[ExtensionAttribute]
internal static class NBitcoin.JsonConverters.JsonConverterUtils : object {
    [ExtensionAttribute]
public static void AssertJsonType(JsonReader reader, JsonToken expectedType);
    [ExtensionAttribute]
public static void AssertJsonType(JsonReader reader, JsonToken[] anyExpectedTypes);
}
public class NBitcoin.JsonConverters.JsonObjectException : Exception {
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    public string Path { get; private set; }
    public JsonObjectException(Exception inner, JsonReader reader);
    public JsonObjectException(string message, JsonReader reader);
    public JsonObjectException(Exception inner, string path);
    public JsonObjectException(string message, string path);
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
private void set_Path(string value);
}
public class NBitcoin.JsonConverters.KeyJsonConverter : JsonConverter {
    public virtual bool CanConvert(Type objectType);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    private static void InverseIfNeeded(Type type, Byte[] bytes);
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
}
public class NBitcoin.JsonConverters.KeyPathJsonConverter : JsonConverter {
    public virtual bool CanConvert(Type objectType);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
}
public class NBitcoin.JsonConverters.LockTimeJsonConverter : JsonConverter {
    public virtual bool CanConvert(Type objectType);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
}
public class NBitcoin.JsonConverters.MoneyJsonConverter : JsonConverter {
    public virtual bool CanConvert(Type objectType);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
}
public class NBitcoin.JsonConverters.NetworkJsonConverter : JsonConverter {
    public virtual bool CanConvert(Type objectType);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
}
public class NBitcoin.JsonConverters.OutpointJsonConverter : JsonConverter {
    public virtual bool CanConvert(Type objectType);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NBitcoin.JsonConverters.OutputDescriptorJsonConverter : JsonConverter {
    private bool _requireChecksum;
    [NullableAttribute("2")]
private ISigningRepository _signingRepository;
    [CompilerGeneratedAttribute]
private Network <Network>k__BackingField;
    public Network Network { get; }
    public OutputDescriptorJsonConverter(Network network, bool requireChecksum, ISigningRepository signingRepository);
    [CompilerGeneratedAttribute]
public Network get_Network();
    public virtual bool CanConvert(Type objectType);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
}
public class NBitcoin.JsonConverters.PSBTJsonConverter : JsonConverter {
    [CompilerGeneratedAttribute]
private Network <Network>k__BackingField;
    public Network Network { get; public set; }
    public PSBTJsonConverter(Network network);
    [CompilerGeneratedAttribute]
public Network get_Network();
    [CompilerGeneratedAttribute]
public void set_Network(Network value);
    public virtual bool CanConvert(Type objectType);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
}
public class NBitcoin.JsonConverters.ScriptJsonConverter : JsonConverter {
    public virtual bool CanConvert(Type objectType);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
}
public class NBitcoin.JsonConverters.SequenceJsonConverter : JsonConverter {
    public virtual bool CanConvert(Type objectType);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
}
public class NBitcoin.JsonConverters.Serializer : object {
    public static void RegisterFrontConverters(JsonSerializerSettings settings, Network network);
    public static T ToObject(string data);
    public static T ToObject(string data, Network network);
    public static string ToString(T response, Network network);
    public static string ToString(T response);
}
public class NBitcoin.JsonConverters.SignatureJsonConverter : JsonConverter {
    public virtual bool CanConvert(Type objectType);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
}
public class NBitcoin.JsonConverters.TxDestinationJsonConverter : JsonConverter {
    public virtual bool CanConvert(Type objectType);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
}
public class NBitcoin.JsonConverters.UInt160JsonConverter : JsonConverter {
    public virtual bool CanConvert(Type objectType);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
}
public class NBitcoin.JsonConverters.UInt256JsonConverter : JsonConverter {
    public virtual bool CanConvert(Type objectType);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
}
internal class NBitcoin.KDTable : object {
    private static Int32[][] _SupportedChars;
    private static string _SubstitutionTable;
    private static KDTable();
    public static string NormalizeKD(string str);
    private static void Substitute(char c, StringBuilder builder);
    private static void Substitute(int pos, StringBuilder builder);
    private static bool Supported(char c);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NBitcoin.Key : object {
    private static int KEY_SIZE;
    private static uint256 N;
    private Byte[] vch;
    internal ECKey _ECKey;
    [CompilerGeneratedAttribute]
private bool <IsCompressed>k__BackingField;
    [NullableAttribute("2")]
private PubKey _PubKey;
    private bool disposed;
    public bool IsCompressed { get; internal set; }
    public PubKey PubKey { get; }
    private Script NBitcoin.IDestination.ScriptPubKey { get; }
    public Key(bool fCompressedIn);
    public Key(Byte[] data, int count, bool fCompressedIn);
    private static Key();
    public static Key Parse(string wif, Network expectedNetwork);
    public static Key Parse(string wif, string password, Network network);
    [CompilerGeneratedAttribute]
public bool get_IsCompressed();
    [CompilerGeneratedAttribute]
internal void set_IsCompressed(bool value);
    public BitcoinAddress GetAddress(ScriptPubKeyType scriptPubKeyType, Network network);
    public IAddressableDestination GetDestination(ScriptPubKeyType scriptPubKeyType);
    public Script GetScriptPubKey(ScriptPubKeyType scriptPubKeyType);
    private static bool Check(Byte[] vch);
    public PubKey get_PubKey();
    public ECDSASignature Sign(uint256 hash, bool useLowR);
    public ECDSASignature Sign(uint256 hash);
    public KeyPair CreateKeyPair();
    public CompactSignature SignCompact(uint256 hash);
    public CompactSignature SignCompact(uint256 hash, bool forceLowR);
    public string Decrypt(string encryptedText);
    public Byte[] Decrypt(Byte[] encrypted);
    public Key Derivate(Byte[] cc, UInt32 nChild, Byte[]& ccChild);
    public BitcoinSecret GetBitcoinSecret(Network network);
    public BitcoinSecret GetWif(Network network);
    public BitcoinEncryptedSecretNoEC GetEncryptedBitcoinSecret(string password, Network network);
    public string ToString(Network network);
    private sealed virtual override Script NBitcoin.IDestination.get_ScriptPubKey();
    public TransactionSignature Sign(uint256 hash, SigningOptions signingOptions);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
public static bool op_Equality(Key a, Key b);
    [NullableContextAttribute("2")]
public static bool op_Inequality(Key a, Key b);
    public virtual int GetHashCode();
    public Byte[] ToBytes();
    public string ToHex();
    public sealed virtual void Dispose();
    private void AssertNotDisposed();
    protected virtual void Dispose(bool disposing);
    protected virtual override void Finalize();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NBitcoin.KeyId : object {
    private uint160 v;
    public Script ScriptPubKey { get; }
    public KeyId(Byte[] value);
    public KeyId(uint160 value);
    public KeyId(string value);
    public sealed virtual Script get_ScriptPubKey();
    public BitcoinPubKeyAddress GetAddress(Network network);
    private sealed virtual override BitcoinAddress NBitcoin.IAddressableDestination.GetAddress(Network network);
    public sealed virtual bool IsSupported(Network network);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
public static bool op_Equality(KeyId a, KeyId b);
    [NullableContextAttribute("2")]
public static bool op_Inequality(KeyId a, KeyId b);
    public virtual int GetHashCode();
    public Byte[] ToBytes();
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NBitcoin.KeyPair : object {
    [CompilerGeneratedAttribute]
private IPubKey <PubKey>k__BackingField;
    [CompilerGeneratedAttribute]
private Key <Key>k__BackingField;
    public IPubKey PubKey { get; }
    public Key Key { get; }
    public KeyPair(Key key, IPubKey pubKey);
    [CompilerGeneratedAttribute]
public IPubKey get_PubKey();
    [CompilerGeneratedAttribute]
public Key get_Key();
    public static KeyPair CreateECDSAPair(Key key);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class NBitcoin.KeyPath : object {
    private static KeyPath _Empty;
    private UInt32[] _Indexes;
    [NullableAttribute("2")]
private string _Path;
    public static KeyPath Empty { get; }
    public UInt32 Item { get; }
    public UInt32[] Indexes { get; }
    public int Length { get; }
    [NullableAttribute("2")]
public KeyPath Parent { get; }
    public bool IsHardened { get; }
    public bool IsHardenedPath { get; }
    public KeyPath(string path);
    public KeyPath(UInt32[] indexes);
    private static KeyPath();
    public static KeyPath Parse(string path);
    public static bool TryParse(string path, KeyPath& keyPath);
    public static KeyPath FromBytes(Byte[] data);
    public Byte[] ToBytes();
    private static bool TryParseCore(string i, UInt32& index);
    public static KeyPath get_Empty();
    public UInt32 get_Item(int index);
    public UInt32[] get_Indexes();
    public int get_Length();
    public KeyPath Derive(int index, bool hardened);
    public KeyPath Derive(string path);
    public KeyPath Derive(UInt32 index);
    public KeyPath Derive(KeyPath derivation);
    [NullableContextAttribute("2")]
public KeyPath get_Parent();
    public KeyPath Increment();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
public static bool op_Equality(KeyPath a, KeyPath b);
    [NullableContextAttribute("2")]
public static KeyPath op_Addition(KeyPath a, KeyPath b);
    public static bool op_Inequality(KeyPath a, KeyPath b);
    public virtual int GetHashCode();
    public virtual string ToString();
    private static string ToString(UInt32 i);
    public bool get_IsHardened();
    public KeyPath GetAddressKeyPath();
    public KeyPath GetAccountKeyPath();
    public bool get_IsHardenedPath();
    public RootedKeyPath ToRootedKeyPath(IHDKey masterKey);
    public RootedKeyPath ToRootedKeyPath(HDFingerprint masterFingerprint);
}
public enum NBitcoin.Language : Enum {
    public int value__;
    public static Language English;
    public static Language Japanese;
    public static Language Spanish;
    public static Language ChineseSimplified;
    public static Language ChineseTraditional;
    public static Language French;
    public static Language PortugueseBrazil;
    public static Language Czech;
    public static Language Unknown;
}
public class NBitcoin.LockTime : ValueType {
    internal static UInt32 LOCKTIME_THRESHOLD;
    private UInt32 _value;
    public static LockTime Zero { get; }
    public DateTimeOffset Date { get; }
    public int Height { get; }
    public UInt32 Value { get; }
    public bool IsHeightLock { get; }
    public bool IsTimeLock { get; }
    public LockTime(DateTimeOffset dateTime);
    public LockTime(int valueOrHeight);
    public LockTime(UInt32 valueOrHeight);
    public static LockTime get_Zero();
    public DateTimeOffset get_Date();
    public int get_Height();
    public UInt32 get_Value();
    public bool get_IsHeightLock();
    public bool get_IsTimeLock();
    public sealed virtual void ReadWrite(BitcoinStream stream);
    public virtual string ToString();
    public static LockTime op_Implicit(int valueOrHeight);
    public static LockTime op_Implicit(DateTimeOffset date);
    public static LockTime op_Implicit(UInt32 valueOrHeight);
    public static DateTimeOffset op_Implicit(LockTime lockTime);
    public static int op_Implicit(LockTime lockTime);
    public static UInt32 op_Implicit(LockTime lockTime);
    public static long op_Implicit(LockTime lockTime);
    public virtual bool Equals(object obj);
    public static bool op_Equality(LockTime a, LockTime b);
    public static bool op_Inequality(LockTime a, LockTime b);
    public virtual int GetHashCode();
}
public class NBitcoin.Logging.FuncLoggerFactory : object {
    private Func`2<string, ILogger> createLogger;
    public FuncLoggerFactory(Func`2<string, ILogger> createLogger);
    public sealed virtual void AddProvider(ILoggerProvider provider);
    public sealed virtual ILogger CreateLogger(string categoryName);
    public sealed virtual void Dispose();
}
public class NBitcoin.Logging.Logs : object {
    [CompilerGeneratedAttribute]
private static ILogger <NodeServer>k__BackingField;
    [CompilerGeneratedAttribute]
private static ILogger <Utils>k__BackingField;
    public static int ColumnLength;
    public static ILogger NodeServer { get; public set; }
    public static ILogger Utils { get; public set; }
    private static Logs();
    public static void Configure(ILoggerFactory factory);
    [CompilerGeneratedAttribute]
public static ILogger get_NodeServer();
    [CompilerGeneratedAttribute]
public static void set_NodeServer(ILogger value);
    [CompilerGeneratedAttribute]
public static ILogger get_Utils();
    [CompilerGeneratedAttribute]
public static void set_Utils(ILogger value);
}
public class NBitcoin.Logging.NullLogger : object {
    [CompilerGeneratedAttribute]
private static NullLogger <Instance>k__BackingField;
    public static NullLogger Instance { get; }
    private static NullLogger();
    [CompilerGeneratedAttribute]
public static NullLogger get_Instance();
    public sealed virtual IDisposable BeginScope(TState state);
    public sealed virtual bool IsEnabled(LogLevel logLevel);
    public sealed virtual void Log(LogLevel logLevel, EventId eventId, TState state, Exception exception, Func`3<TState, Exception, string> formatter);
}
public class NBitcoin.Logging.NullScope : object {
    [CompilerGeneratedAttribute]
private static NullScope <Instance>k__BackingField;
    public static NullScope Instance { get; }
    private static NullScope();
    [CompilerGeneratedAttribute]
public static NullScope get_Instance();
    public sealed virtual void Dispose();
}
public class NBitcoin.LotSequence : object {
    private int _Lot;
    private int _Sequence;
    private Byte[] _Bytes;
    public int Lot { get; }
    public int Sequence { get; }
    private int Id { get; }
    public LotSequence(int lot, int sequence);
    public LotSequence(Byte[] bytes);
    public int get_Lot();
    public int get_Sequence();
    public Byte[] ToBytes();
    private int get_Id();
    public virtual bool Equals(object obj);
    public static bool op_Equality(LotSequence a, LotSequence b);
    public static bool op_Inequality(LotSequence a, LotSequence b);
    public virtual int GetHashCode();
}
public class NBitcoin.MemPoolInfo : object {
    [CompilerGeneratedAttribute]
private int <Size>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Bytes>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Usage>k__BackingField;
    [CompilerGeneratedAttribute]
private double <MaxMemPool>k__BackingField;
    [CompilerGeneratedAttribute]
private double <MemPoolMinFee>k__BackingField;
    [CompilerGeneratedAttribute]
private double <MinRelayTxFee>k__BackingField;
    [CompilerGeneratedAttribute]
private FeeRateGroup[] <Histogram>k__BackingField;
    public int Size { get; public set; }
    public int Bytes { get; public set; }
    public int Usage { get; public set; }
    public double MaxMemPool { get; public set; }
    public double MemPoolMinFee { get; public set; }
    public double MinRelayTxFee { get; public set; }
    public FeeRateGroup[] Histogram { get; public set; }
    [CompilerGeneratedAttribute]
public int get_Size();
    [CompilerGeneratedAttribute]
public void set_Size(int value);
    [CompilerGeneratedAttribute]
public int get_Bytes();
    [CompilerGeneratedAttribute]
public void set_Bytes(int value);
    [CompilerGeneratedAttribute]
public int get_Usage();
    [CompilerGeneratedAttribute]
public void set_Usage(int value);
    [CompilerGeneratedAttribute]
public double get_MaxMemPool();
    [CompilerGeneratedAttribute]
public void set_MaxMemPool(double value);
    [CompilerGeneratedAttribute]
public double get_MemPoolMinFee();
    [CompilerGeneratedAttribute]
public void set_MemPoolMinFee(double value);
    [CompilerGeneratedAttribute]
public double get_MinRelayTxFee();
    [CompilerGeneratedAttribute]
public void set_MinRelayTxFee(double value);
    [CompilerGeneratedAttribute]
public FeeRateGroup[] get_Histogram();
    [CompilerGeneratedAttribute]
public void set_Histogram(FeeRateGroup[] value);
}
public class NBitcoin.MerkleBlock : object {
    private BlockHeader header;
    private PartialMerkleTree _PartialMerkleTree;
    public BlockHeader Header { get; public set; }
    public PartialMerkleTree PartialMerkleTree { get; public set; }
    public MerkleBlock(Block block, BloomFilter filter);
    public MerkleBlock(Block block, uint256[] txIds);
    public BlockHeader get_Header();
    public void set_Header(BlockHeader value);
    public PartialMerkleTree get_PartialMerkleTree();
    public void set_PartialMerkleTree(PartialMerkleTree value);
    public sealed virtual void ReadWrite(BitcoinStream stream);
}
public class NBitcoin.MerkleNode : object {
    [CompilerGeneratedAttribute]
private bool <IsLeaf>k__BackingField;
    private uint256 _Hash;
    [CompilerGeneratedAttribute]
private MerkleNode <Parent>k__BackingField;
    [CompilerGeneratedAttribute]
private MerkleNode <Left>k__BackingField;
    [CompilerGeneratedAttribute]
private MerkleNode <Right>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsMarked>k__BackingField;
    public uint256 Hash { get; public set; }
    public bool IsLeaf { get; private set; }
    public MerkleNode Parent { get; private set; }
    public MerkleNode Left { get; private set; }
    public MerkleNode Right { get; private set; }
    internal bool IsMarked { get; internal set; }
    public MerkleNode(uint256 hash);
    public MerkleNode(MerkleNode left, MerkleNode right);
    public static MerkleNode GetRoot(IEnumerable`1<uint256> leafs);
    public static MerkleNode GetRoot(int leafCount);
    public uint256 get_Hash();
    public void set_Hash(uint256 value);
    public void UpdateHash();
    [CompilerGeneratedAttribute]
public bool get_IsLeaf();
    [CompilerGeneratedAttribute]
private void set_IsLeaf(bool value);
    [CompilerGeneratedAttribute]
public MerkleNode get_Parent();
    [CompilerGeneratedAttribute]
private void set_Parent(MerkleNode value);
    [CompilerGeneratedAttribute]
public MerkleNode get_Left();
    [CompilerGeneratedAttribute]
private void set_Left(MerkleNode value);
    [CompilerGeneratedAttribute]
public MerkleNode get_Right();
    [CompilerGeneratedAttribute]
private void set_Right(MerkleNode value);
    public IEnumerable`1<MerkleNode> EnumerateDescendants();
    public MerkleNode GetLeaf(int i);
    public IEnumerable`1<MerkleNode> GetLeafs();
    [CompilerGeneratedAttribute]
internal bool get_IsMarked();
    [CompilerGeneratedAttribute]
internal void set_IsMarked(bool value);
    [IteratorStateMachineAttribute("NBitcoin.MerkleNode/<Ancestors>d__32")]
public IEnumerable`1<MerkleNode> Ancestors();
    public virtual string ToString();
    public string ToString(bool hierachy);
    private void ToString(StringBuilder builder, int indent);
}
public class NBitcoin.Mnemonic : object {
    private static Int32[] msArray;
    private static Int32[] csArray;
    private static Int32[] entArray;
    private Nullable`1<bool> _IsValidChecksum;
    private Wordlist _WordList;
    private Int32[] _Indices;
    private String[] _Words;
    private static Encoding NoBOMUTF8;
    private string _Mnemonic;
    public bool IsValidChecksum { get; }
    public Wordlist WordList { get; }
    public Int32[] Indices { get; }
    public String[] Words { get; }
    public Mnemonic(string mnemonic, Wordlist wordlist);
    public Mnemonic(Wordlist wordList, Byte[] entropy);
    public Mnemonic(Wordlist wordList, WordCount wordCount);
    private static Mnemonic();
    private static Byte[] GenerateEntropy(WordCount wordCount);
    public bool get_IsValidChecksum();
    private static bool CorrectWordCount(int ms);
    public Wordlist get_WordList();
    public Int32[] get_Indices();
    public String[] get_Words();
    public Byte[] DeriveSeed(string passphrase);
    internal static Byte[] Normalize(string str);
    internal static string NormalizeString(string word);
    public ExtKey DeriveExtKey(string passphrase);
    private static Byte[] Concat(Byte[] source1, Byte[] source2);
    public virtual string ToString();
}
public class NBitcoin.Money : object {
    private static NumberStyles BitcoinStyle;
    private long _Satoshis;
    private static Money _Zero;
    public static long COIN;
    public static long CENT;
    public static long NANO;
    public long Satoshi { get; private set; }
    public static Money Zero { get; }
    [ObsoleteAttribute("You shouldn't use 'int' for a satoshi amount; you should use long/int64, as Int32.MaxValue is only 2,147,483,647, while there can be 21,000,000*100,000,000 satoshis")]
public Money(int satoshis);
    [ObsoleteAttribute("You shouldn't use 'uint' for a satoshi amount; you should use long/int64, as UInt32.MaxValue is only 4,294,967,295, while there can be 21,000,000*100,000,000 satoshis")]
public Money(UInt32 satoshis);
    public Money(long satoshis);
    public Money(ulong satoshis);
    public Money(decimal amount, MoneyUnit unit);
    public Money(long amount, MoneyUnit unit);
    public Money(ulong amount, MoneyUnit unit);
    private static Money();
    public static bool TryParse(string bitcoin, Money& nRet);
    public static Money Parse(string bitcoin);
    public long get_Satoshi();
    private void set_Satoshi(long value);
    public Money Abs();
    [IteratorStateMachineAttribute("NBitcoin.Money/<Split>d__15")]
public IEnumerable`1<Money> Split(int parts);
    private static long DivRem(long a, long b, Int64& result);
    public static Money FromUnit(decimal amount, MoneyUnit unit);
    public decimal ToUnit(MoneyUnit unit);
    public decimal ToDecimal(MoneyUnit unit);
    public static Money Coins(decimal coins);
    public static Money Bits(decimal bits);
    public static Money Cents(decimal cents);
    public static Money Satoshis(decimal sats);
    public static Money Satoshis(ulong sats);
    public static Money Satoshis(long sats);
    public sealed virtual bool Equals(Money other);
    public sealed virtual int CompareTo(Money other);
    public int CompareTo(object obj);
    public static Money op_Subtraction(Money left, Money right);
    public static Money op_UnaryNegation(Money left);
    public static Money op_Addition(Money left, Money right);
    public static Money op_Multiply(int left, Money right);
    public static Money op_Multiply(Money right, int left);
    public static Money op_Multiply(long left, Money right);
    public static Money op_Multiply(Money right, long left);
    public static Money op_Division(Money left, long right);
    public static bool op_LessThan(Money left, Money right);
    public static bool op_GreaterThan(Money left, Money right);
    public static bool op_LessThanOrEqual(Money left, Money right);
    public static bool op_GreaterThanOrEqual(Money left, Money right);
    public static Money op_Implicit(long value);
    [ObsoleteAttribute("You shouldn't use 'int' for a satoshi amount; you should use long/int64, as Int32.MaxValue is only 2,147,483,647, while there can be 21,000,000*100,000,000 satoshis")]
public static Money op_Implicit(int value);
    [ObsoleteAttribute("You shouldn't use 'int' for a satoshi amount; you should use long/int64, as Int32.MaxValue is only 2,147,483,647, while there can be 21,000,000*100,000,000 satoshis")]
public static Money op_Implicit(UInt32 value);
    public static Money op_Implicit(ulong value);
    public static long op_Implicit(Money value);
    public static ulong op_Implicit(Money value);
    public static Money op_Implicit(string value);
    public virtual bool Equals(object obj);
    public static bool op_Equality(Money a, Money b);
    public static bool op_Inequality(Money a, Money b);
    public virtual int GetHashCode();
    public virtual string ToString();
    public string ToString(bool fplus, bool trimExcessZero);
    public static Money get_Zero();
    public bool Almost(Money amount, Money dust);
    public bool Almost(Money amount, decimal margin);
    public static Money Min(Money a, Money b);
    public static Money Max(Money a, Money b);
    private static void CheckLongMinValue(long value);
    private static void CheckMoneyUnit(MoneyUnit value, string paramName);
    private sealed virtual override IMoney NBitcoin.IMoney.Add(IMoney money);
    private sealed virtual override IMoney NBitcoin.IMoney.Sub(IMoney money);
    private sealed virtual override IMoney NBitcoin.IMoney.Negate();
    private sealed virtual override int System.IComparable.CompareTo(object obj);
    private sealed virtual override int System.IComparable<NBitcoin.IMoney>.CompareTo(IMoney other);
    private sealed virtual override bool System.IEquatable<NBitcoin.IMoney>.Equals(IMoney other);
    private sealed virtual override bool NBitcoin.IMoney.IsCompatible(IMoney money);
    private sealed virtual override IEnumerable`1<IMoney> NBitcoin.IMoney.Split(int parts);
}
public class NBitcoin.MoneyBag : object {
    private List`1<IMoney> _bag;
    public MoneyBag(MoneyBag money);
    public MoneyBag(IMoney[] bag);
    private MoneyBag(IEnumerable`1<IMoney> bag);
    private void AppendMoney(MoneyBag money);
    private void AppendMoney(IMoney money);
    public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(IMoney other);
    public sealed virtual bool Equals(MoneyBag other);
    public sealed virtual bool Equals(IMoney other);
    public static MoneyBag op_Subtraction(MoneyBag left, IMoney right);
    public static MoneyBag op_Addition(MoneyBag left, IMoney right);
    private sealed virtual override IMoney NBitcoin.IMoney.Add(IMoney money);
    private sealed virtual override IMoney NBitcoin.IMoney.Sub(IMoney money);
    private sealed virtual override IMoney NBitcoin.IMoney.Negate();
    private sealed virtual override bool NBitcoin.IMoney.IsCompatible(IMoney money);
    public IMoney GetAmount(AssetId assetId);
    public virtual string ToString();
    public sealed virtual IEnumerator`1<IMoney> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [IteratorStateMachineAttribute("NBitcoin.MoneyBag/<Split>d__21")]
public IEnumerable`1<MoneyBag> Split(int parts);
    private sealed virtual override IEnumerable`1<IMoney> NBitcoin.IMoney.Split(int parts);
    public TMoney GetAmount(TMoney zero);
}
[ExtensionAttribute]
public static class NBitcoin.MoneyExtensions : object {
    [ExtensionAttribute]
public static Money Sum(IEnumerable`1<Money> moneys);
    [ExtensionAttribute]
public static IMoney Sum(IEnumerable`1<IMoney> moneys, IMoney zero);
    [ExtensionAttribute]
public static AssetMoney Sum(IEnumerable`1<AssetMoney> moneys, AssetId assetId);
}
public enum NBitcoin.MoneyUnit : Enum {
    public int value__;
    public static MoneyUnit BTC;
    public static MoneyUnit MilliBTC;
    public static MoneyUnit Bit;
    public static MoneyUnit Satoshi;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NBitcoin.Network : object {
    internal Byte[][] base58Prefixes;
    internal Bech32Encoder[] bech32Encoders;
    [CompilerGeneratedAttribute]
private string <UriScheme>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <MaxP2PVersion>k__BackingField;
    private UInt32 magic;
    private List`1<string> vSeeds;
    private List`1<string> vFixedSeeds;
    private Byte[] _GenesisBytes;
    private int nRPCPort;
    private int nDefaultPort;
    private Consensus consensus;
    private string name;
    [NullableAttribute("2")]
private ChainName chainName;
    internal static UInt32 BITCOIN_MAX_P2P_VERSION;
    private static ConcurrentDictionary`2<string, Network> _OtherAliases;
    private static List`1<Network> _OtherNetworks;
    private INetworkSet _NetworkSet;
    [CompilerGeneratedAttribute]
private NetworkStringParser <NetworkStringParser>k__BackingField;
    private Byte[] _MagicBytes;
    public string UriScheme { get; internal set; }
    public UInt32 MaxP2PVersion { get; internal set; }
    public int RPCPort { get; }
    public int DefaultPort { get; }
    public Consensus Consensus { get; }
    public string Name { get; }
    public ChainName ChainName { get; }
    public static Network Main { get; }
    public static Network TestNet { get; }
    public static Network RegTest { get; }
    public INetworkSet NetworkSet { get; }
    internal NetworkStringParser NetworkStringParser { get; internal set; }
    public uint256 GenesisHash { get; }
    public Byte[] MagicBytes { get; }
    public UInt32 Magic { get; }
    private Network(string name, Byte[] genesis, UInt32 magic, string uriScheme, INetworkSet networkSet);
    private static Network();
    [CompilerGeneratedAttribute]
public string get_UriScheme();
    [CompilerGeneratedAttribute]
internal void set_UriScheme(string value);
    [CompilerGeneratedAttribute]
public UInt32 get_MaxP2PVersion();
    [CompilerGeneratedAttribute]
internal void set_MaxP2PVersion(UInt32 value);
    [NullableContextAttribute("2")]
public Bech32Encoder GetBech32Encoder(Bech32Type type, bool throws);
    internal NotSupportedException Bech32NotSupported(Bech32Type type);
    [NullableContextAttribute("2")]
public Byte[] GetVersionBytes(Base58Type type, bool throws);
    internal NotSupportedException Base58NotSupported(Base58Type type);
    internal static string CreateBase58(Base58Type type, Byte[] bytes, Network network);
    internal static string CreateBech32(Bech32Type type, Byte[] bytes, byte witnessVersion, Network network);
    public Transaction CreateTransaction();
    public int get_RPCPort();
    public int get_DefaultPort();
    public Consensus get_Consensus();
    public string get_Name();
    public ChainName get_ChainName();
    public static Network get_Main();
    public static Network get_TestNet();
    public static Network get_RegTest();
    public INetworkSet get_NetworkSet();
    internal static Network Register(NetworkBuilder builder);
    private Block CreateGenesisBlock(UInt32 nTime, UInt32 nNonce, UInt32 nBits, int nVersion, Money genesisReward);
    private Block CreateGenesisBlock(string pszTimestamp, Script genesisOutputScript, UInt32 nTime, UInt32 nNonce, UInt32 nBits, int nVersion, Money genesisReward);
    public BitcoinSecret CreateBitcoinSecret(string base58);
    public BitcoinAddress CreateBitcoinAddress(string base58);
    public BitcoinScriptAddress CreateBitcoinScriptAddress(string base58);
    private Nullable`1<Base58Type> GetBase58Type(string base58);
    private Nullable`1<Base58Type> GetBase58Type(Byte[] bytes, Int32& prefixLength);
    internal static Network GetNetworkFromBase58Data(string base58, Nullable`1<Base58Type> expectedType);
    public T Parse(string str);
    public IBitcoinString Parse(string str);
    public IBitcoinString Parse(string str, Type targetType);
    public static IBitcoinString Parse(string str, Network expectedNetwork, Type targetType);
    public static T Parse(string str, Network expectedNetwork);
    private IBase58Data GetCandidate(string base58, Byte[] decoded);
    [CompilerGeneratedAttribute]
internal NetworkStringParser get_NetworkStringParser();
    [CompilerGeneratedAttribute]
internal void set_NetworkStringParser(NetworkStringParser value);
    public TransactionBuilder CreateTransactionBuilder();
    public TransactionBuilder CreateTransactionBuilder(int seed);
    public Base58CheckEncoder GetBase58CheckEncoder();
    private IBase58Data CreateBase58Data(Base58Type type, string base58);
    private BitcoinColoredAddress CreateColoredAddress(string base58);
    public BitcoinAssetId CreateAssetId(string base58);
    private BitcoinPassphraseCode CreatePassphraseCode(string base58);
    private BitcoinEncryptedSecretNoEC CreateEncryptedKeyNoEC(string base58);
    private BitcoinEncryptedSecretEC CreateEncryptedKeyEC(string base58);
    private Base58Data CreateConfirmationCode(string base58);
    private Base58Data CreateBitcoinExtPubKey(string base58);
    public BitcoinExtKey CreateBitcoinExtKey(ExtKey key);
    public BitcoinExtPubKey CreateBitcoinExtPubKey(ExtPubKey pubkey);
    public BitcoinExtKey CreateBitcoinExtKey(string base58);
    public virtual string ToString();
    public Block GetGenesis();
    public uint256 get_GenesisHash();
    [IteratorStateMachineAttribute("NBitcoin.Network/<GetNetworks>d__86")]
public static IEnumerable`1<Network> GetNetworks();
    public static Network GetNetwork(string name);
    public BitcoinSecret CreateBitcoinSecret(Key key);
    public BitcoinPubKeyAddress CreateBitcoinAddress(KeyId dest);
    private BitcoinScriptAddress CreateBitcoinScriptAddress(ScriptId scriptId);
    public Message ParseMessage(Byte[] bytes, Nullable`1<UInt32> version);
    public Byte[] get_MagicBytes();
    public UInt32 get_Magic();
    public Money GetReward(int nHeight);
    public bool ReadMagic(Stream stream, CancellationToken cancellation, bool throwIfEOF);
}
public class NBitcoin.NetworkBuilder : object {
    internal NetworkStringParser _NetworkStringParser;
    internal string _Name;
    internal ChainName _ChainName;
    internal Dictionary`2<Base58Type, Byte[]> _Base58Prefixes;
    internal Dictionary`2<Bech32Type, Bech32Encoder> _Bech32Prefixes;
    internal List`1<string> _Aliases;
    internal int _RPCPort;
    internal int _Port;
    internal UInt32 _Magic;
    internal Consensus _Consensus;
    internal Byte[] _Genesis;
    internal Nullable`1<UInt32> _MaxP2PVersion;
    internal INetworkSet _NetworkSet;
    internal string _UriScheme;
    public NetworkBuilder SetNetworkSet(INetworkSet networkSet);
    public NetworkBuilder SetUriScheme(string uriScheme);
    public NetworkBuilder SetMaxP2PVersion(UInt32 version);
    public NetworkBuilder SetName(string name);
    public void CopyFrom(Network network);
    public NetworkBuilder SetNetworkStringParser(NetworkStringParser networkStringParser);
    public NetworkBuilder AddAlias(string alias);
    public NetworkBuilder SetRPCPort(int port);
    public NetworkBuilder SetPort(int port);
    public NetworkBuilder SetMagic(UInt32 magic);
    public NetworkBuilder SetConsensus(Consensus consensus);
    public NetworkBuilder SetGenesis(string hex);
    public NetworkBuilder SetBase58Bytes(Base58Type type, Byte[] bytes);
    public NetworkBuilder SetBech32(Bech32Type type, string humanReadablePart);
    public NetworkBuilder SetBech32(Bech32Type type, Bech32Encoder encoder);
    public NetworkBuilder SetChainName(ChainName chainName);
    public Network BuildAndRegister();
}
public abstract class NBitcoin.NetworkSetBase : object {
    private object l;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _Registered;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _Registering;
    private Network _Mainnet;
    private Network _Testnet;
    private Network _Regtest;
    public Network Mainnet { get; }
    public Network Testnet { get; }
    public Network Regtest { get; }
    public string CryptoCode { get; }
    public virtual Network GetNetwork(ChainName chainName);
    public void EnsureRegistered();
    protected virtual void PostInit();
    protected abstract virtual NetworkBuilder CreateMainnet();
    protected abstract virtual NetworkBuilder CreateTestnet();
    protected abstract virtual NetworkBuilder CreateRegtest();
    public sealed virtual Network get_Mainnet();
    public sealed virtual Network get_Testnet();
    public sealed virtual Network get_Regtest();
    public abstract virtual string get_CryptoCode();
    public static void RegisterDefaultCookiePath(Network network, String[] subfolders);
    protected void RegisterDefaultCookiePath(string folderName);
}
public class NBitcoin.NetworkStringParser : object {
    public bool TryParse(string str, Network network, T& result);
    public virtual bool TryParse(string str, Network network, Type targetType, IBitcoinString& result);
    public virtual Base58CheckEncoder GetBase58CheckEncoder();
    public virtual BitcoinPubKeyAddress CreateP2PKH(KeyId keyId, Network network);
    public virtual BitcoinScriptAddress CreateP2SH(ScriptId scriptId, Network network);
    public virtual BitcoinWitPubKeyAddress CreateP2WPKH(WitKeyId witKeyId, Network network);
    public virtual BitcoinWitScriptAddress CreateP2WSH(WitScriptId scriptId, Network network);
}
public abstract class NBitcoin.NoSqlRepository : object {
    [CompilerGeneratedAttribute]
private ConsensusFactory <ConsensusFactory>k__BackingField;
    public ConsensusFactory ConsensusFactory { get; }
    public NoSqlRepository(ConsensusFactory consensusFactory);
    [CompilerGeneratedAttribute]
public ConsensusFactory get_ConsensusFactory();
    public Task PutAsync(string key, IBitcoinSerializable obj);
    public void Put(string key, IBitcoinSerializable obj);
    [AsyncStateMachineAttribute("NBitcoin.NoSqlRepository/<GetAsync>d__6`1")]
public Task`1<T> GetAsync(string key);
    public T Get(string key);
    public virtual Task PutBatch(IEnumerable`1<Tuple`2<string, IBitcoinSerializable>> values);
    protected abstract virtual Task PutBytesBatch(IEnumerable`1<Tuple`2<string, Byte[]>> enumerable);
    protected abstract virtual Task`1<Byte[]> GetBytes(string key);
    protected virtual Task PutBytes(string key, Byte[] data);
}
public class NBitcoin.NoSqlTransactionRepository : object {
    private NoSqlRepository _Repository;
    public NoSqlRepository Repository { get; }
    public NoSqlTransactionRepository(NoSqlRepository repository);
    public NoSqlRepository get_Repository();
    public sealed virtual Task`1<Transaction> GetAsync(uint256 txId);
    private string GetId(uint256 txId);
    public sealed virtual Task PutAsync(uint256 txId, Transaction tx);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NBitcoin.NotEnoughFundsException : Exception {
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <Group>k__BackingField;
    [CompilerGeneratedAttribute]
private IMoney <Missing>k__BackingField;
    [NullableAttribute("2")]
public string Group { get; private set; }
    public IMoney Missing { get; private set; }
    public NotEnoughFundsException(string message, string group, IMoney missing);
    private static string BuildMessage(string message, string group, IMoney missing);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_Group();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private void set_Group(string value);
    [CompilerGeneratedAttribute]
public IMoney get_Missing();
    [CompilerGeneratedAttribute]
private void set_Missing(IMoney value);
}
public class NBitcoin.Op : object {
    internal static Dictionary`2<string, OpcodeType> _OpcodeByName;
    private string _Name;
    private OpcodeType _Code;
    private static Boolean[] _ValidOpCode;
    [CompilerGeneratedAttribute]
private Byte[] <PushData>k__BackingField;
    private static string unknown;
    private static int MAX_SCRIPT_ELEMENT_SIZE;
    [CompilerGeneratedAttribute]
private bool <IsInvalid>k__BackingField;
    public string Name { get; }
    public OpcodeType Code { get; public set; }
    public Byte[] PushData { get; public set; }
    public bool IsInvalid { get; private set; }
    public bool IsSmallUInt { get; }
    public bool IsSmallInt { get; }
    private static Op();
    public static string GetOpName(OpcodeType opcode);
    internal static bool IsPushCode(OpcodeType opcode);
    public static bool GetOpCode(string name, OpcodeType& result);
    public static Op GetPushOp(long value);
    public static Op GetPushOp(Byte[] data);
    public string get_Name();
    private static Boolean[] GetValidOpCode();
    public OpcodeType get_Code();
    public void set_Code(OpcodeType value);
    [CompilerGeneratedAttribute]
public Byte[] get_PushData();
    [CompilerGeneratedAttribute]
public void set_PushData(Byte[] value);
    private void PushDataToStream(Byte[] data, Stream result);
    internal Byte[] ReadData(Stream stream);
    public Byte[] ToBytes();
    public virtual string ToString();
    public void WriteTo(Stream stream);
    internal static Op Read(TextReader textReader);
    public static Op op_Implicit(OpcodeType codeType);
    private static string ReadWord(TextReader textReader);
    [CompilerGeneratedAttribute]
public bool get_IsInvalid();
    [CompilerGeneratedAttribute]
private void set_IsInvalid(bool value);
    public bool get_IsSmallUInt();
    public bool get_IsSmallInt();
    public Nullable`1<int> GetInt();
    public Nullable`1<long> GetLong();
}
public enum NBitcoin.OpcodeType : Enum {
    public byte value__;
    public static OpcodeType OP_0;
    public static OpcodeType OP_FALSE;
    public static OpcodeType OP_PUSHDATA1;
    public static OpcodeType OP_PUSHDATA2;
    public static OpcodeType OP_PUSHDATA4;
    public static OpcodeType OP_1NEGATE;
    public static OpcodeType OP_RESERVED;
    public static OpcodeType OP_1;
    public static OpcodeType OP_TRUE;
    public static OpcodeType OP_2;
    public static OpcodeType OP_3;
    public static OpcodeType OP_4;
    public static OpcodeType OP_5;
    public static OpcodeType OP_6;
    public static OpcodeType OP_7;
    public static OpcodeType OP_8;
    public static OpcodeType OP_9;
    public static OpcodeType OP_10;
    public static OpcodeType OP_11;
    public static OpcodeType OP_12;
    public static OpcodeType OP_13;
    public static OpcodeType OP_14;
    public static OpcodeType OP_15;
    public static OpcodeType OP_16;
    public static OpcodeType OP_NOP;
    public static OpcodeType OP_VER;
    public static OpcodeType OP_IF;
    public static OpcodeType OP_NOTIF;
    public static OpcodeType OP_VERIF;
    public static OpcodeType OP_VERNOTIF;
    public static OpcodeType OP_ELSE;
    public static OpcodeType OP_ENDIF;
    public static OpcodeType OP_VERIFY;
    public static OpcodeType OP_RETURN;
    public static OpcodeType OP_TOALTSTACK;
    public static OpcodeType OP_FROMALTSTACK;
    public static OpcodeType OP_2DROP;
    public static OpcodeType OP_2DUP;
    public static OpcodeType OP_3DUP;
    public static OpcodeType OP_2OVER;
    public static OpcodeType OP_2ROT;
    public static OpcodeType OP_2SWAP;
    public static OpcodeType OP_IFDUP;
    public static OpcodeType OP_DEPTH;
    public static OpcodeType OP_DROP;
    public static OpcodeType OP_DUP;
    public static OpcodeType OP_NIP;
    public static OpcodeType OP_OVER;
    public static OpcodeType OP_PICK;
    public static OpcodeType OP_ROLL;
    public static OpcodeType OP_ROT;
    public static OpcodeType OP_SWAP;
    public static OpcodeType OP_TUCK;
    public static OpcodeType OP_CAT;
    public static OpcodeType OP_SUBSTR;
    public static OpcodeType OP_LEFT;
    public static OpcodeType OP_RIGHT;
    public static OpcodeType OP_SIZE;
    public static OpcodeType OP_INVERT;
    public static OpcodeType OP_AND;
    public static OpcodeType OP_OR;
    public static OpcodeType OP_XOR;
    public static OpcodeType OP_EQUAL;
    public static OpcodeType OP_EQUALVERIFY;
    public static OpcodeType OP_RESERVED1;
    public static OpcodeType OP_RESERVED2;
    public static OpcodeType OP_1ADD;
    public static OpcodeType OP_1SUB;
    public static OpcodeType OP_2MUL;
    public static OpcodeType OP_2DIV;
    public static OpcodeType OP_NEGATE;
    public static OpcodeType OP_ABS;
    public static OpcodeType OP_NOT;
    public static OpcodeType OP_0NOTEQUAL;
    public static OpcodeType OP_ADD;
    public static OpcodeType OP_SUB;
    public static OpcodeType OP_MUL;
    public static OpcodeType OP_DIV;
    public static OpcodeType OP_MOD;
    public static OpcodeType OP_LSHIFT;
    public static OpcodeType OP_RSHIFT;
    public static OpcodeType OP_BOOLAND;
    public static OpcodeType OP_BOOLOR;
    public static OpcodeType OP_NUMEQUAL;
    public static OpcodeType OP_NUMEQUALVERIFY;
    public static OpcodeType OP_NUMNOTEQUAL;
    public static OpcodeType OP_LESSTHAN;
    public static OpcodeType OP_GREATERTHAN;
    public static OpcodeType OP_LESSTHANOREQUAL;
    public static OpcodeType OP_GREATERTHANOREQUAL;
    public static OpcodeType OP_MIN;
    public static OpcodeType OP_MAX;
    public static OpcodeType OP_WITHIN;
    public static OpcodeType OP_RIPEMD160;
    public static OpcodeType OP_SHA1;
    public static OpcodeType OP_SHA256;
    public static OpcodeType OP_HASH160;
    public static OpcodeType OP_HASH256;
    public static OpcodeType OP_CODESEPARATOR;
    public static OpcodeType OP_CHECKSIG;
    public static OpcodeType OP_CHECKSIGVERIFY;
    public static OpcodeType OP_CHECKMULTISIG;
    public static OpcodeType OP_CHECKMULTISIGVERIFY;
    public static OpcodeType OP_CHECKLOCKTIMEVERIFY;
    public static OpcodeType OP_CHECKSEQUENCEVERIFY;
    public static OpcodeType OP_NOP1;
    public static OpcodeType OP_NOP2;
    public static OpcodeType OP_NOP3;
    public static OpcodeType OP_NOP4;
    public static OpcodeType OP_NOP5;
    public static OpcodeType OP_NOP6;
    public static OpcodeType OP_NOP7;
    public static OpcodeType OP_NOP8;
    public static OpcodeType OP_NOP9;
    public static OpcodeType OP_NOP10;
    public static OpcodeType OP_CHECKSIGADD;
}
public class NBitcoin.OpenAsset.AssetId : object {
    internal Byte[] _Bytes;
    private string _Str;
    public AssetId(IDestination assetScriptPubKey);
    public AssetId(BitcoinAssetId assetId);
    public AssetId(Script assetScriptPubKey);
    public AssetId(ScriptId scriptId);
    public AssetId(Byte[] value);
    public AssetId(uint160 value);
    public AssetId(string value);
    public BitcoinAssetId GetWif(Network network);
    public Byte[] ToBytes();
    public Byte[] ToBytes(bool unsafe);
    public virtual bool Equals(object obj);
    public static bool op_Equality(AssetId a, AssetId b);
    public static bool op_Inequality(AssetId a, AssetId b);
    public virtual int GetHashCode();
    public virtual string ToString();
    public string ToString(Network network);
}
public class NBitcoin.OpenAsset.AssetMoney : object {
    private long _Quantity;
    private AssetId _Id;
    public long Quantity { get; private set; }
    public AssetId Id { get; }
    public AssetMoney(AssetId assetId);
    public AssetMoney(IDestination issuer, long quantity);
    public AssetMoney(AssetId assetId, int quantity);
    public AssetMoney(AssetId assetId, UInt32 quantity);
    public AssetMoney(AssetId assetId, long quantity);
    public AssetMoney(AssetId assetId, ulong quantity);
    public AssetMoney(AssetId assetId, decimal amount, int divisibility);
    public long get_Quantity();
    private void set_Quantity(long value);
    private static void CheckLongMinValue(long value);
    public AssetId get_Id();
    public AssetMoney Abs();
    private static int Pow10(int divisibility);
    [IteratorStateMachineAttribute("NBitcoin.OpenAsset.AssetMoney/<Split>d__17")]
public IEnumerable`1<AssetMoney> Split(int parts);
    private static long DivRem(long a, long b, Int64& result);
    public decimal ToDecimal(int divisibility);
    public sealed virtual bool Equals(AssetMoney other);
    internal void CheckAssetId(AssetMoney other, string param);
    public sealed virtual int CompareTo(AssetMoney other);
    public int CompareTo(object obj);
    public static AssetMoney op_Subtraction(AssetMoney left, AssetMoney right);
    public static AssetMoney op_UnaryNegation(AssetMoney left);
    public static AssetMoney op_Addition(AssetMoney left, AssetMoney right);
    public static AssetMoney op_Multiply(int left, AssetMoney right);
    public static AssetMoney op_Multiply(AssetMoney right, int left);
    public static AssetMoney op_Multiply(long left, AssetMoney right);
    public static AssetMoney op_Multiply(AssetMoney right, long left);
    public static bool op_LessThan(AssetMoney left, AssetMoney right);
    public static bool op_GreaterThan(AssetMoney left, AssetMoney right);
    public static bool op_LessThanOrEqual(AssetMoney left, AssetMoney right);
    public static bool op_GreaterThanOrEqual(AssetMoney left, AssetMoney right);
    public virtual bool Equals(object obj);
    public static bool op_Equality(AssetMoney a, AssetMoney b);
    public static bool op_Inequality(AssetMoney a, AssetMoney b);
    public virtual int GetHashCode();
    public virtual string ToString();
    public static AssetMoney Min(AssetMoney a, AssetMoney b);
    private sealed virtual override IMoney NBitcoin.IMoney.Add(IMoney money);
    private sealed virtual override IMoney NBitcoin.IMoney.Sub(IMoney money);
    private sealed virtual override IMoney NBitcoin.IMoney.Negate();
    private sealed virtual override int System.IComparable.CompareTo(object obj);
    private sealed virtual override int System.IComparable<NBitcoin.IMoney>.CompareTo(IMoney other);
    private sealed virtual override bool System.IEquatable<NBitcoin.IMoney>.Equals(IMoney other);
    private sealed virtual override bool NBitcoin.IMoney.IsCompatible(IMoney money);
    private sealed virtual override IEnumerable`1<IMoney> NBitcoin.IMoney.Split(int parts);
}
public class NBitcoin.OpenAsset.BitcoinAssetId : Base58Data {
    private AssetId _AssetId;
    public AssetId AssetId { get; }
    protected bool IsValid { get; }
    public Base58Type Type { get; }
    public BitcoinAssetId(string base58, Network expectedNetwork);
    public BitcoinAssetId(Byte[] raw, Network network);
    public BitcoinAssetId(AssetId assetId, Network network);
    public AssetId get_AssetId();
    protected virtual bool get_IsValid();
    public virtual Base58Type get_Type();
    public static AssetId op_Implicit(BitcoinAssetId id);
}
public class NBitcoin.OpenAsset.CachedColoredTransactionRepository : object {
    private IColoredTransactionRepository _Inner;
    private CachedTransactionRepository _InnerTransactionRepository;
    private Dictionary`2<uint256, ColoredTransaction> _ColoredTransactions;
    private Queue`1<uint256> _EvictionQueue;
    private ReaderWriterLock _lock;
    public int MaxCachedTransactions { get; public set; }
    public bool WriteThrough { get; public set; }
    public bool ReadThrough { get; public set; }
    public CachedTransactionRepository Transactions { get; }
    private ITransactionRepository NBitcoin.OpenAsset.IColoredTransactionRepository.Transactions { get; }
    public CachedColoredTransactionRepository(IColoredTransactionRepository inner);
    public ColoredTransaction GetFromCache(uint256 txId);
    public int get_MaxCachedTransactions();
    public void set_MaxCachedTransactions(int value);
    public bool get_WriteThrough();
    public void set_WriteThrough(bool value);
    public bool get_ReadThrough();
    public void set_ReadThrough(bool value);
    public CachedTransactionRepository get_Transactions();
    private sealed virtual override ITransactionRepository NBitcoin.OpenAsset.IColoredTransactionRepository.get_Transactions();
    private void EvictIfNecessary(uint256 txId);
    [AsyncStateMachineAttribute("NBitcoin.OpenAsset.CachedColoredTransactionRepository/<GetAsync>d__21")]
public sealed virtual Task`1<ColoredTransaction> GetAsync(uint256 txId);
    public sealed virtual Task PutAsync(uint256 txId, ColoredTransaction tx);
}
public class NBitcoin.OpenAsset.ColoredEntry : object {
    private UInt32 _Index;
    private AssetMoney _Asset;
    public UInt32 Index { get; public set; }
    public AssetMoney Asset { get; public set; }
    public ColoredEntry(UInt32 index, AssetMoney asset);
    public UInt32 get_Index();
    public void set_Index(UInt32 value);
    public AssetMoney get_Asset();
    public void set_Asset(AssetMoney value);
    public sealed virtual void ReadWrite(BitcoinStream stream);
    public virtual string ToString();
}
public class NBitcoin.OpenAsset.ColoredTransaction : object {
    private ColorMarker _Marker;
    private List`1<ColoredEntry> _Issuances;
    private List`1<ColoredEntry> _Transfers;
    private List`1<ColoredEntry> _Inputs;
    public static DateTimeOffset FirstColoredDate;
    public ColorMarker Marker { get; public set; }
    public List`1<ColoredEntry> Issuances { get; public set; }
    public List`1<ColoredEntry> Transfers { get; public set; }
    public List`1<ColoredEntry> Inputs { get; public set; }
    public ColoredTransaction(Transaction tx, ColoredCoin[] spentCoins, Script issuanceScriptPubkey);
    public ColoredTransaction(uint256 txId, Transaction tx, ColoredCoin[] spentCoins, Script issuanceScriptPubkey);
    private static ColoredTransaction();
    public static Task`1<ColoredTransaction> FetchColorsAsync(Transaction tx, IColoredTransactionRepository repo);
    public static ColoredTransaction FetchColors(Transaction tx, IColoredTransactionRepository repo);
    public static Task`1<ColoredTransaction> FetchColorsAsync(uint256 txId, IColoredTransactionRepository repo);
    public static ColoredTransaction FetchColors(uint256 txId, IColoredTransactionRepository repo);
    public static ColoredTransaction FetchColors(uint256 txId, Transaction tx, IColoredTransactionRepository repo);
    [AsyncStateMachineAttribute("NBitcoin.OpenAsset.ColoredTransaction/<FetchColorsAsync>d__6")]
public static Task`1<ColoredTransaction> FetchColorsAsync(uint256 txId, Transaction tx, IColoredTransactionRepository repo);
    [AsyncStateMachineAttribute("NBitcoin.OpenAsset.ColoredTransaction/<BulkLoadIfCached>d__7")]
private static Task`1<bool> BulkLoadIfCached(Transaction transaction, IColoredTransactionRepository repo);
    public ColoredEntry GetColoredEntry(UInt32 n);
    public static bool HasIssuance(Transaction tx);
    public ColorMarker get_Marker();
    public void set_Marker(ColorMarker value);
    public List`1<ColoredEntry> get_Issuances();
    public void set_Issuances(List`1<ColoredEntry> value);
    public List`1<ColoredEntry> get_Transfers();
    public void set_Transfers(List`1<ColoredEntry> value);
    public AssetMoney[] GetDestroyedAssets();
    public sealed virtual void ReadWrite(BitcoinStream stream);
    public List`1<ColoredEntry> get_Inputs();
    public void set_Inputs(List`1<ColoredEntry> value);
    public virtual string ToString();
    public string ToString(Network network);
    private static void WriteEntry(Network network, JArray inputs, ColoredEntry entry);
}
[ExtensionAttribute]
public static class NBitcoin.OpenAsset.ColoredTxRepoExtensions : object {
    [ExtensionAttribute]
public static Task`1<ColoredTransaction> GetAsync(IColoredTransactionRepository repo, string txId);
    [ExtensionAttribute]
public static ColoredTransaction Get(IColoredTransactionRepository repo, string txId);
    [ExtensionAttribute]
public static ColoredTransaction Get(IColoredTransactionRepository repo, uint256 txId);
    [ExtensionAttribute]
public static void Put(IColoredTransactionRepository repo, uint256 txId, ColoredTransaction tx);
}
public class NBitcoin.OpenAsset.ColorMarker : object {
    private static ushort Tag;
    private ushort _Version;
    private UInt64[] _Quantities;
    private Byte[] _Metadata;
    private static ulong MAX_QUANTITY;
    private static TxNullDataTemplate _Template;
    public ushort Version { get; public set; }
    public UInt64[] Quantities { get; public set; }
    public Byte[] Metadata { get; public set; }
    public ColorMarker(Script script);
    public ColorMarker(UInt64[] quantities);
    private static ColorMarker();
    public static ColorMarker TryParse(string script);
    public static ColorMarker TryParse(Transaction transaction);
    public static ColorMarker TryParse(Script script);
    private bool ReadScript(Script script);
    private bool ReadData(Byte[] data);
    private static ulong ReadLEB128(BitcoinStream stream);
    private void WriteLEB128(ulong value, BitcoinStream stream);
    public ushort get_Version();
    public void set_Version(ushort value);
    public UInt64[] get_Quantities();
    public void set_Quantities(UInt64[] value);
    public void SetQuantity(UInt32 index, long quantity);
    public void SetQuantity(int index, long quantity);
    public Byte[] get_Metadata();
    public void set_Metadata(Byte[] value);
    public Script GetScript();
    public Byte[] ToBytes();
    public static ColorMarker Get(Transaction transaction);
    public static ColorMarker Get(Transaction transaction, UInt32& markerPosition);
    public sealed virtual void ReadWrite(BitcoinStream stream);
    public static bool HasValidColorMarker(Transaction tx);
    public bool HasValidQuantitiesCount(Transaction tx);
    public Uri GetMetadataUrl();
    public void SetMetadataUrl(Uri uri);
}
[ExtensionAttribute]
public static class NBitcoin.OpenAsset.Extensions : object {
    [ExtensionAttribute]
public static ColoredTransaction GetColoredTransaction(Transaction tx, IColoredTransactionRepository repo);
    [AsyncStateMachineAttribute("NBitcoin.OpenAsset.Extensions/<GetColoredTransactionAsync>d__1")]
[ExtensionAttribute]
public static Task`1<ColoredTransaction> GetColoredTransactionAsync(Transaction tx, IColoredTransactionRepository repo);
    [ExtensionAttribute]
public static ColorMarker GetColoredMarker(Transaction tx);
    [ExtensionAttribute]
public static bool HasValidColoredMarker(Transaction tx);
    [ExtensionAttribute]
public static AssetId ToAssetId(ScriptId id);
}
public interface NBitcoin.OpenAsset.IColoredTransactionRepository {
    public ITransactionRepository Transactions { get; }
    public abstract virtual ITransactionRepository get_Transactions();
    public abstract virtual Task`1<ColoredTransaction> GetAsync(uint256 txId);
    public abstract virtual Task PutAsync(uint256 txId, ColoredTransaction tx);
}
internal class NBitcoin.OpenAsset.NoDuplicateColoredTransactionRepository : object {
    private IColoredTransactionRepository _Inner;
    private Dictionary`2<string, Task> _Tasks;
    private ReaderWriterLock lock;
    public ITransactionRepository Transactions { get; }
    public NoDuplicateColoredTransactionRepository(IColoredTransactionRepository inner);
    public sealed virtual ITransactionRepository get_Transactions();
    public sealed virtual Task`1<ColoredTransaction> GetAsync(uint256 txId);
    public sealed virtual Task PutAsync(uint256 txId, ColoredTransaction tx);
    private sealed virtual override Task`1<Transaction> NBitcoin.ITransactionRepository.GetAsync(uint256 txId);
    public sealed virtual Task PutAsync(uint256 txId, Transaction tx);
    private Task`1<T> Request(string key, Func`1<Task`1<T>> wrapped);
}
public class NBitcoin.OpenAsset.NoSqlColoredTransactionRepository : object {
    private NoSqlRepository _Repository;
    private ITransactionRepository _Transactions;
    public NoSqlRepository Repository { get; }
    public ITransactionRepository Transactions { get; }
    public NoSqlColoredTransactionRepository(ITransactionRepository transactionRepository);
    public NoSqlColoredTransactionRepository(ITransactionRepository transactionRepository, NoSqlRepository repository);
    public NoSqlRepository get_Repository();
    public sealed virtual ITransactionRepository get_Transactions();
    public sealed virtual Task`1<ColoredTransaction> GetAsync(uint256 txId);
    private static string GetId(uint256 txId);
    public sealed virtual Task PutAsync(uint256 txId, ColoredTransaction tx);
}
public class NBitcoin.OpenAsset.NullColoredTransactionRepository : object {
    private ITransactionRepository _Inner;
    public ITransactionRepository Transactions { get; }
    public NullColoredTransactionRepository(ITransactionRepository repo);
    public sealed virtual ITransactionRepository get_Transactions();
    public sealed virtual Task`1<ColoredTransaction> GetAsync(uint256 txId);
    public sealed virtual Task PutAsync(uint256 txId, ColoredTransaction tx);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NBitcoin.OutPoint : object {
    private uint256 hash;
    private UInt32 n;
    public static OutPoint Zero;
    public bool IsNull { get; }
    public uint256 Hash { get; public set; }
    public UInt32 N { get; public set; }
    public OutPoint(uint256 hashIn, UInt32 nIn);
    public OutPoint(uint256 hashIn, int nIn);
    public OutPoint(Transaction tx, UInt32 i);
    public OutPoint(Transaction tx, int i);
    public OutPoint(OutPoint outpoint);
    private static OutPoint();
    public bool get_IsNull();
    public uint256 get_Hash();
    public void set_Hash(uint256 value);
    public UInt32 get_N();
    public void set_N(UInt32 value);
    public static bool TryParse(string str, OutPoint& result);
    public static OutPoint Parse(string str);
    public sealed virtual void ReadWrite(BitcoinStream stream);
    private void SetNull();
    public static bool op_LessThan(OutPoint a, OutPoint b);
    public static bool op_GreaterThan(OutPoint a, OutPoint b);
    [NullableContextAttribute("2")]
public static bool op_Equality(OutPoint a, OutPoint b);
    [NullableContextAttribute("2")]
public static bool op_Inequality(OutPoint a, OutPoint b);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(OutPoint other);
    public virtual int GetHashCode();
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NBitcoin.OutputTooSmallException : NotEnoughFundsException {
    [CompilerGeneratedAttribute]
private ErrorType <Reason>k__BackingField;
    [CompilerGeneratedAttribute]
private Script <Destination>k__BackingField;
    [CompilerGeneratedAttribute]
private Money <Value>k__BackingField;
    public ErrorType Reason { get; }
    public Script Destination { get; }
    public Money Value { get; }
    public OutputTooSmallException(string message, string group, IMoney missing, ErrorType reason, TxOut output);
    [CompilerGeneratedAttribute]
public ErrorType get_Reason();
    [CompilerGeneratedAttribute]
public Script get_Destination();
    [CompilerGeneratedAttribute]
public Money get_Value();
}
public class NBitcoin.PartialMerkleTree : object {
    private UInt32 _TransactionCount;
    private List`1<uint256> _Hashes;
    private BitArray _Flags;
    public UInt32 TransactionCount { get; public set; }
    public List`1<uint256> Hashes { get; }
    public BitArray Flags { get; public set; }
    public PartialMerkleTree(uint256[] vTxid, Boolean[] vMatch);
    public UInt32 get_TransactionCount();
    public void set_TransactionCount(UInt32 value);
    public List`1<uint256> get_Hashes();
    public BitArray get_Flags();
    public void set_Flags(BitArray value);
    public sealed virtual void ReadWrite(BitcoinStream stream);
    private byte ToByte(bool v);
    private static void MarkNodes(MerkleNode root, Boolean[] vMatch);
    private static void MarkToTop(MerkleNode leaf, bool value);
    public MerkleNode GetMerkleRoot();
    public bool Check(uint256 expectedMerkleRootHash);
    private void BuildCore(MerkleNode node, BitWriter flags);
    public IEnumerable`1<uint256> GetMatchedTransactions();
    private IEnumerable`1<uint256> GetMatchedTransactionsCore(MerkleNode node, BitReader flags, IEnumerator`1<uint256> hashes, bool calculateHash);
    public MerkleNode TryGetMerkleRoot();
    public PartialMerkleTree Trim(uint256[] matchedTransactions);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NBitcoin.Payment.BitcoinUrlBuilder : object {
    [CompilerGeneratedAttribute]
private Network <Network>k__BackingField;
    private string scheme;
    private Dictionary`2<string, string> _UnknownParameters;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private BitcoinAddress <Address>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private Money <Amount>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <Label>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    public Network Network { get; }
    public IReadOnlyDictionary`2<string, string> UnknownParameters { get; }
    [ObsoleteAttribute("Use UnknownParameters property")]
public Dictionary`2<string, string> UnknowParameters { get; }
    [NullableAttribute("2")]
public BitcoinAddress Address { get; public set; }
    [NullableAttribute("2")]
public Money Amount { get; public set; }
    [NullableAttribute("2")]
public string Label { get; public set; }
    [NullableAttribute("2")]
public string Message { get; public set; }
    public Uri Uri { get; }
    public BitcoinUrlBuilder(Network network);
    public BitcoinUrlBuilder(Uri uri, Network network);
    public BitcoinUrlBuilder(string uri, Network network);
    [CompilerGeneratedAttribute]
public Network get_Network();
    public IReadOnlyDictionary`2<string, string> get_UnknownParameters();
    public Dictionary`2<string, string> get_UnknowParameters();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public BitcoinAddress get_Address();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_Address(BitcoinAddress value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public Money get_Amount();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_Amount(Money value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_Label();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_Label(string value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_Message();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_Message(string value);
    public Uri get_Uri();
    private static void WriteParameters(Dictionary`2<string, string> parameters, StringBuilder builder);
    public virtual string ToString();
}
internal static class NBitcoin.Payment.UriHelper : object {
    public static Dictionary`2<string, string> DecodeQueryParameters(string uri);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NBitcoin.PayToMultiSigTemplate : ScriptTemplate {
    private static PayToMultiSigTemplate _Instance;
    public static PayToMultiSigTemplate Instance { get; }
    private static PayToMultiSigTemplate();
    public static PayToMultiSigTemplate get_Instance();
    public Script GenerateScriptPubKey(int sigCount, PubKey[] keys);
    public Script GenerateScriptPubKey(int sigCount, bool sort, PubKey[] keys);
    public Script GenerateScriptPubKey(int sigCount, bool sort, bool forceSmallSigCount, PubKey[] keys);
    protected virtual bool CheckScriptPubKeyCore(Script scriptPubKey, Op[] scriptPubKeyOps);
    public PayToMultiSigTemplateParameters ExtractScriptPubKeyParameters(Script scriptPubKey);
    protected virtual bool FastCheckScriptSig(Script scriptSig, Script scriptPubKey, Boolean& needMoreCheck);
    protected virtual bool CheckScriptSigCore(Script scriptSig, Op[] scriptSigOps, Script scriptPubKey, Op[] scriptPubKeyOps);
    public TransactionSignature[] ExtractScriptSigParameters(Script scriptSig);
    public Script GenerateScriptSig(TransactionSignature[] signatures);
    public Script GenerateScriptSig(IEnumerable`1<TransactionSignature> signatures);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NBitcoin.PayToMultiSigTemplateParameters : object {
    [CompilerGeneratedAttribute]
private int <SignatureCount>k__BackingField;
    [CompilerGeneratedAttribute]
private PubKey[] <PubKeys>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[][] <InvalidPubKeys>k__BackingField;
    public int SignatureCount { get; public set; }
    public PubKey[] PubKeys { get; public set; }
    public Byte[][] InvalidPubKeys { get; public set; }
    public PayToMultiSigTemplateParameters(int signatureCount, PubKey[] pubkeys, Byte[][] invalidPubkeys);
    [CompilerGeneratedAttribute]
public int get_SignatureCount();
    [CompilerGeneratedAttribute]
public void set_SignatureCount(int value);
    [CompilerGeneratedAttribute]
public PubKey[] get_PubKeys();
    [CompilerGeneratedAttribute]
public void set_PubKeys(PubKey[] value);
    [CompilerGeneratedAttribute]
public Byte[][] get_InvalidPubKeys();
    [CompilerGeneratedAttribute]
public void set_InvalidPubKeys(Byte[][] value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NBitcoin.PayToPubkeyHashScriptSigParameters : object {
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private TransactionSignature <TransactionSignature>k__BackingField;
    [CompilerGeneratedAttribute]
private PubKey <PublicKey>k__BackingField;
    [NullableAttribute("2")]
public TransactionSignature TransactionSignature { get; public set; }
    public PubKey PublicKey { get; public set; }
    public IAddressableDestination Hash { get; }
    public Script ScriptPubKey { get; }
    public PayToPubkeyHashScriptSigParameters(TransactionSignature transactionSignature, PubKey pubKey);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public TransactionSignature get_TransactionSignature();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_TransactionSignature(TransactionSignature value);
    [CompilerGeneratedAttribute]
public PubKey get_PublicKey();
    [CompilerGeneratedAttribute]
public void set_PublicKey(PubKey value);
    public virtual IAddressableDestination get_Hash();
    public sealed virtual Script get_ScriptPubKey();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NBitcoin.PayToPubkeyHashTemplate : ScriptTemplate {
    private static PayToPubkeyHashTemplate _Instance;
    public static PayToPubkeyHashTemplate Instance { get; }
    private static PayToPubkeyHashTemplate();
    public static PayToPubkeyHashTemplate get_Instance();
    public Script GenerateScriptPubKey(BitcoinPubKeyAddress address);
    public Script GenerateScriptPubKey(PubKey pubKey);
    public Script GenerateScriptPubKey(KeyId pubkeyHash);
    public Script GenerateScriptSig(TransactionSignature signature, PubKey publicKey);
    protected virtual bool FastCheckScriptPubKey(Script scriptPubKey, Boolean& needMoreCheck);
    protected virtual bool CheckScriptPubKeyCore(Script scriptPubKey, Op[] scriptPubKeyOps);
    public KeyId ExtractScriptPubKeyParameters(Script scriptPubKey);
    protected virtual bool CheckScriptSigCore(Script scriptSig, Op[] scriptSigOps, Script scriptPubKey, Op[] scriptPubKeyOps);
    public bool CheckScriptSig(Script scriptSig);
    public PayToPubkeyHashScriptSigParameters ExtractScriptSigParameters(Script scriptSig);
    public Script GenerateScriptSig(PayToPubkeyHashScriptSigParameters parameters);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NBitcoin.PayToPubkeyTemplate : ScriptTemplate {
    private static PayToPubkeyTemplate _Instance;
    public static PayToPubkeyTemplate Instance { get; }
    private static PayToPubkeyTemplate();
    public static PayToPubkeyTemplate get_Instance();
    public Script GenerateScriptPubKey(PubKey pubkey);
    public Script GenerateScriptPubKey(Byte[] pubkey);
    protected virtual bool FastCheckScriptPubKey(Script scriptPubKey, Boolean& needMoreCheck);
    protected virtual bool CheckScriptPubKeyCore(Script scriptPubKey, Op[] scriptPubKeyOps);
    public Script GenerateScriptSig(ECDSASignature signature);
    public Script GenerateScriptSig(TransactionSignature signature);
    public TransactionSignature ExtractScriptSigParameters(Script scriptSig);
    protected virtual bool FastCheckScriptSig(Script scriptSig, Script scriptPubKey, Boolean& needMoreCheck);
    protected virtual bool CheckScriptSigCore(Script scriptSig, Op[] scriptSigOps, Script scriptPubKey, Op[] scriptPubKeyOps);
    public PubKey ExtractScriptPubKeyParameters(Script scriptPubKey);
    public PubKey ExtractScriptPubKeyParameters(Script scriptPubKey, bool deepCheck);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NBitcoin.PayToScriptHashSigParameters : object {
    [CompilerGeneratedAttribute]
private Script <RedeemScript>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[][] <Pushes>k__BackingField;
    public Script RedeemScript { get; public set; }
    public Byte[][] Pushes { get; public set; }
    public PayToScriptHashSigParameters(Script redeemScript, Byte[][] pushes);
    [CompilerGeneratedAttribute]
public Script get_RedeemScript();
    [CompilerGeneratedAttribute]
public void set_RedeemScript(Script value);
    [CompilerGeneratedAttribute]
public Byte[][] get_Pushes();
    [CompilerGeneratedAttribute]
public void set_Pushes(Byte[][] value);
    [NullableContextAttribute("2")]
public TransactionSignature[] GetMultisigSignatures();
    public PubKey[] GetMultisigPubKeys();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NBitcoin.PayToScriptHashTemplate : ScriptTemplate {
    private static PayToScriptHashTemplate _Instance;
    public static PayToScriptHashTemplate Instance { get; }
    private static PayToScriptHashTemplate();
    public static PayToScriptHashTemplate get_Instance();
    public Script GenerateScriptPubKey(ScriptId scriptId);
    public Script GenerateScriptPubKey(Script scriptPubKey);
    protected virtual bool FastCheckScriptPubKey(Script scriptPubKey, Boolean& needMoreCheck);
    protected virtual bool CheckScriptPubKeyCore(Script scriptPubKey, Op[] scriptPubKeyOps);
    public Script GenerateScriptSig(Op[] ops, Script redeemScript);
    public PayToScriptHashSigParameters ExtractScriptSigParameters(Script scriptSig);
    public PayToScriptHashSigParameters ExtractScriptSigParameters(Script scriptSig, ScriptId expectedScriptId);
    [NullableContextAttribute("2")]
public PayToScriptHashSigParameters ExtractScriptSigParameters(Script scriptSig, Script scriptPubKey);
    public Script GenerateScriptSig(Byte[][] pushes, Script redeemScript);
    public Script GenerateScriptSig(TransactionSignature[] signatures, Script redeemScript);
    public Script GenerateScriptSig(ECDSASignature[] signatures, Script redeemScript);
    protected virtual bool CheckScriptSigCore(Script scriptSig, Op[] scriptSigOps, Script scriptPubKey, Op[] scriptPubKeyOps);
    public ScriptId ExtractScriptPubKeyParameters(Script scriptPubKey);
    public Script GenerateScriptSig(PayToScriptHashSigParameters parameters);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NBitcoin.PayToTaprootScriptSigParameters : object {
    [CompilerGeneratedAttribute]
private TaprootSignature <TransactionSignature>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private Byte[] <Annex>k__BackingField;
    public TaprootSignature TransactionSignature { get; public set; }
    [NullableAttribute("2")]
public Byte[] Annex { get; public set; }
    public PayToTaprootScriptSigParameters(TaprootSignature transactionSignature, Byte[] annex);
    [CompilerGeneratedAttribute]
public TaprootSignature get_TransactionSignature();
    [CompilerGeneratedAttribute]
public void set_TransactionSignature(TaprootSignature value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public Byte[] get_Annex();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_Annex(Byte[] value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NBitcoin.PayToTaprootTemplate : ScriptTemplate {
    [NullableAttribute("2")]
private static PayToTaprootTemplate _Instance;
    public static PayToTaprootTemplate Instance { get; }
    public static PayToTaprootTemplate get_Instance();
    [ObsoleteAttribute("Use pubKey.ScriptPubKey instead")]
public Script GenerateScriptPubKey(TaprootPubKey pubKey);
    public TaprootPubKey ExtractScriptPubKeyParameters(Script scriptPubKey);
    protected virtual bool FastCheckScriptPubKey(Script scriptPubKey, Boolean& needMoreCheck);
    protected virtual bool CheckScriptPubKeyCore(Script scriptPubKey, Op[] scriptPubKeyOps);
    protected virtual bool FastCheckScriptSig(Script scriptSig, Script scriptPubKey, Boolean& needMoreCheck);
    protected virtual bool CheckScriptSigCore(Script scriptSig, Op[] scriptSigOps, Script scriptPubKey, Op[] scriptPubKeyOps);
    [ObsoleteAttribute("Use GenerateWitScript(TaprootSignature signature) instead")]
public Script GenerateScriptSig(TaprootSignature signature);
    public PayToTaprootScriptSigParameters ExtractWitScriptParameters(WitScript witScript);
    private bool CheckAnnex(Byte[] annex);
    public WitScript GenerateWitScript(TaprootSignature signature);
    public WitScript GenerateWitScript(TaprootSignature signature, Byte[] annex);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NBitcoin.PayToWitPubkeyHashScriptSigParameters : PayToPubkeyHashScriptSigParameters {
    public IAddressableDestination Hash { get; }
    public PayToWitPubkeyHashScriptSigParameters(TransactionSignature transactionSignature, PubKey pubKey);
    public virtual IAddressableDestination get_Hash();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NBitcoin.PayToWitPubKeyHashTemplate : PayToWitTemplate {
    [NullableAttribute("2")]
private static PayToWitPubKeyHashTemplate _Instance;
    public static PayToWitPubKeyHashTemplate Instance { get; }
    public static PayToWitPubKeyHashTemplate get_Instance();
    public Script GenerateScriptPubKey(PubKey pubKey);
    public Script GenerateScriptPubKey(WitKeyId pubkeyHash);
    public WitScript GenerateWitScript(TransactionSignature signature, PubKey publicKey);
    public Script GenerateScriptPubKey(BitcoinWitPubKeyAddress address);
    public virtual bool CheckScriptPubKey(Script scriptPubKey);
    public WitKeyId ExtractScriptPubKeyParameters(Script scriptPubKey);
    public PayToWitPubkeyHashScriptSigParameters ExtractWitScriptParameters(WitScript witScript);
    private bool CheckWitScriptCore(WitScript witScript);
    public WitScript GenerateWitScript(PayToWitPubkeyHashScriptSigParameters parameters);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NBitcoin.PayToWitScriptHashTemplate : PayToWitTemplate {
    [NullableAttribute("2")]
private static PayToWitScriptHashTemplate _Instance;
    public static PayToWitScriptHashTemplate Instance { get; }
    public static PayToWitScriptHashTemplate get_Instance();
    public Script GenerateScriptPubKey(WitScriptId scriptHash);
    public WitScript GenerateWitScript(Script scriptSig, Script redeemScript);
    public WitScript GenerateWitScript(Op[] scriptSig, Script redeemScript);
    public Script GenerateScriptPubKey(BitcoinWitScriptAddress address);
    public virtual bool CheckScriptPubKey(Script scriptPubKey);
    public WitScriptId ExtractScriptPubKeyParameters(Script scriptPubKey);
    [NullableContextAttribute("2")]
public Script ExtractWitScriptParameters(WitScript witScript, WitScriptId expectedScriptId);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NBitcoin.PayToWitTemplate : ScriptTemplate {
    [NullableAttribute("2")]
private static PayToWitTemplate _Instance;
    public static PayToWitTemplate Instance { get; }
    public static PayToWitTemplate get_Instance();
    public Script GenerateScriptPubKey(OpcodeType segWitVersion, Byte[] data);
    public virtual bool CheckScriptSig(Script scriptSig, Script scriptPubKey);
    public virtual bool CheckScriptPubKey(Script scriptPubKey);
    public static bool ValidSegwitVersion(byte version);
    public IAddressableDestination ExtractScriptPubKeyParameters(Script scriptPubKey);
    public WitProgramParameters ExtractScriptPubKeyParameters2(Script scriptPubKey);
    protected virtual bool CheckScriptPubKeyCore(Script scriptPubKey, Op[] scriptPubKeyOps);
    protected virtual bool CheckScriptSigCore(Script scriptSig, Op[] scriptSigOps, Script scriptPubKey, Op[] scriptPubKeyOps);
}
public class NBitcoin.PerformanceCounter : object {
    private long _WrittenBytes;
    private long _ReadenBytes;
    private DateTime _Start;
    public long WrittenBytes { get; }
    public long ReadenBytes { get; }
    public DateTime Start { get; }
    public TimeSpan Elapsed { get; }
    public long get_WrittenBytes();
    public void AddWritten(long count);
    public void AddReaden(long count);
    public long get_ReadenBytes();
    public PerformanceSnapshot Snapshot();
    public DateTime get_Start();
    public TimeSpan get_Elapsed();
    public virtual string ToString();
    internal void Add(PerformanceCounter counter);
}
public class NBitcoin.PerformanceSnapshot : object {
    private long _TotalWrittenBytes;
    private long _TotalReadenBytes;
    [CompilerGeneratedAttribute]
private DateTime <Start>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <Taken>k__BackingField;
    public long TotalWrittenBytes { get; }
    public long TotalReadenBytes { get; public set; }
    public TimeSpan Elapsed { get; }
    public ulong ReadenBytesPerSecond { get; }
    public ulong WrittenBytesPerSecond { get; }
    public DateTime Start { get; public set; }
    public DateTime Taken { get; public set; }
    public PerformanceSnapshot(long readen, long written);
    public long get_TotalWrittenBytes();
    public long get_TotalReadenBytes();
    public void set_TotalReadenBytes(long value);
    public TimeSpan get_Elapsed();
    public ulong get_ReadenBytesPerSecond();
    public ulong get_WrittenBytesPerSecond();
    public static PerformanceSnapshot op_Subtraction(PerformanceSnapshot end, PerformanceSnapshot start);
    public virtual string ToString();
    private string ToKBSec(ulong bytesPerSec);
    [CompilerGeneratedAttribute]
public DateTime get_Start();
    [CompilerGeneratedAttribute]
public void set_Start(DateTime value);
    [CompilerGeneratedAttribute]
public DateTime get_Taken();
    [CompilerGeneratedAttribute]
public void set_Taken(DateTime value);
}
public class NBitcoin.Policy.DuplicateInputPolicyError : TransactionPolicyError {
    private OutPoint _OutPoint;
    private UInt32[] _InputIndices;
    public OutPoint OutPoint { get; }
    public UInt32[] InputIndices { get; }
    public DuplicateInputPolicyError(IndexedTxIn[] duplicated);
    public OutPoint get_OutPoint();
    public UInt32[] get_InputIndices();
}
public class NBitcoin.Policy.DustPolicyError : TransactionPolicyError {
    private Money _Value;
    private Money _DustThreshold;
    public Money Value { get; }
    public Money DustThreshold { get; }
    public DustPolicyError(Money value, Money dust);
    public Money get_Value();
    public Money get_DustThreshold();
}
public class NBitcoin.Policy.FeeTooHighPolicyError : TransactionPolicyError {
    private Money _Fee;
    private Money _ExpectedMaxFee;
    public Money Fee { get; }
    public Money ExpectedMaxFee { get; }
    public FeeTooHighPolicyError(Money fees, Money max);
    public Money get_Fee();
    public Money get_ExpectedMaxFee();
}
public class NBitcoin.Policy.FeeTooLowPolicyError : TransactionPolicyError {
    private Money _Fee;
    private Money _ExpectedMinFee;
    public Money Fee { get; }
    public Money ExpectedMinFee { get; }
    public FeeTooLowPolicyError(Money fees, Money min);
    public Money get_Fee();
    public Money get_ExpectedMinFee();
}
public class NBitcoin.Policy.InputPolicyError : TransactionPolicyError {
    private OutPoint _OutPoint;
    private UInt32 _InputIndex;
    public OutPoint OutPoint { get; }
    public UInt32 InputIndex { get; }
    public InputPolicyError(string message, IndexedTxIn txIn);
    public OutPoint get_OutPoint();
    public UInt32 get_InputIndex();
}
public interface NBitcoin.Policy.ITransactionPolicy {
    public abstract virtual TransactionPolicyError[] Check(Transaction transaction, ICoin[] spentCoins);
}
public class NBitcoin.Policy.MinerTransactionPolicy : object {
    private static MinerTransactionPolicy _Instance;
    public static MinerTransactionPolicy Instance { get; }
    private static MinerTransactionPolicy();
    public static MinerTransactionPolicy get_Instance();
    public sealed virtual TransactionPolicyError[] Check(Transaction transaction, ICoin[] spentCoins);
    public TransactionPolicyError[] Check(TransactionValidator validator);
}
public class NBitcoin.Policy.NotEnoughFundsPolicyError : TransactionPolicyError {
    [CompilerGeneratedAttribute]
private IMoney <Missing>k__BackingField;
    public IMoney Missing { get; private set; }
    public NotEnoughFundsPolicyError(string message, IMoney missing);
    public NotEnoughFundsPolicyError(string message);
    private static string BuildMessage(string message, IMoney missing);
    [CompilerGeneratedAttribute]
public IMoney get_Missing();
    [CompilerGeneratedAttribute]
private void set_Missing(IMoney value);
    internal Exception AsException();
}
public class NBitcoin.Policy.OutputPolicyError : TransactionPolicyError {
    private int _OutputIndex;
    public int OutputIndex { get; }
    public OutputPolicyError(string message, int outputIndex);
    public int get_OutputIndex();
}
public class NBitcoin.Policy.ScriptPolicyError : InputPolicyError {
    private ScriptError _ScriptError;
    private ScriptVerify _ScriptVerify;
    private Script _ScriptPubKey;
    public ScriptError ScriptError { get; }
    public ScriptVerify ScriptVerify { get; }
    public Script ScriptPubKey { get; }
    public ScriptPolicyError(IndexedTxIn input, ScriptError error, ScriptVerify scriptVerify, Script scriptPubKey);
    public ScriptError get_ScriptError();
    public ScriptVerify get_ScriptVerify();
    public Script get_ScriptPubKey();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class NBitcoin.Policy.StandardTransactionPolicy : object {
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MaxTransactionSize>k__BackingField;
    [CompilerGeneratedAttribute]
private FeeRate <MaxTxFee>k__BackingField;
    [CompilerGeneratedAttribute]
private FeeRate <MinRelayTxFee>k__BackingField;
    [CompilerGeneratedAttribute]
private Money <MinFee>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<ScriptVerify> <ScriptVerify>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CheckFee>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseConsensusLib>k__BackingField;
    public static int MaxScriptSigLength;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private StandardTransactionPolicyStrategy <Strategy>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CheckScriptPubKey>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CheckDust>k__BackingField;
    public Nullable`1<int> MaxTransactionSize { get; public set; }
    public FeeRate MaxTxFee { get; public set; }
    public FeeRate MinRelayTxFee { get; public set; }
    public Money MinFee { get; public set; }
    public Nullable`1<ScriptVerify> ScriptVerify { get; public set; }
    public bool CheckFee { get; public set; }
    public bool UseConsensusLib { get; public set; }
    [NullableAttribute("1")]
public StandardTransactionPolicyStrategy Strategy { get; public set; }
    public bool CheckScriptPubKey { get; public set; }
    public bool CheckDust { get; public set; }
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_MaxTransactionSize();
    [CompilerGeneratedAttribute]
public void set_MaxTransactionSize(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public FeeRate get_MaxTxFee();
    [CompilerGeneratedAttribute]
public void set_MaxTxFee(FeeRate value);
    [CompilerGeneratedAttribute]
public FeeRate get_MinRelayTxFee();
    [CompilerGeneratedAttribute]
public void set_MinRelayTxFee(FeeRate value);
    [CompilerGeneratedAttribute]
public Money get_MinFee();
    [CompilerGeneratedAttribute]
public void set_MinFee(Money value);
    [CompilerGeneratedAttribute]
public Nullable`1<ScriptVerify> get_ScriptVerify();
    [CompilerGeneratedAttribute]
public void set_ScriptVerify(Nullable`1<ScriptVerify> value);
    [CompilerGeneratedAttribute]
public bool get_CheckFee();
    [CompilerGeneratedAttribute]
public void set_CheckFee(bool value);
    [CompilerGeneratedAttribute]
public bool get_UseConsensusLib();
    [CompilerGeneratedAttribute]
public void set_UseConsensusLib(bool value);
    [NullableContextAttribute("1")]
public sealed virtual TransactionPolicyError[] Check(Transaction transaction, ICoin[] spentCoins);
    [NullableContextAttribute("1")]
public TransactionPolicyError[] Check(TransactionValidator validator);
    [NullableContextAttribute("1")]
private static bool IsOpReturn(Byte[] bytes);
    [NullableContextAttribute("1")]
private bool VerifyScript(TransactionValidator validator, int inputIndex, Nullable`1& error);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public StandardTransactionPolicyStrategy get_Strategy();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public void set_Strategy(StandardTransactionPolicyStrategy value);
    [NullableContextAttribute("1")]
public StandardTransactionPolicy Clone();
    [CompilerGeneratedAttribute]
public bool get_CheckScriptPubKey();
    [CompilerGeneratedAttribute]
public void set_CheckScriptPubKey(bool value);
    [CompilerGeneratedAttribute]
public bool get_CheckDust();
    [CompilerGeneratedAttribute]
public void set_CheckDust(bool value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NBitcoin.Policy.StandardTransactionPolicyStrategy : object {
    [CompilerGeneratedAttribute]
private static StandardTransactionPolicyStrategy <Instance>k__BackingField;
    public static StandardTransactionPolicyStrategy Instance { get; }
    private static StandardTransactionPolicyStrategy();
    [CompilerGeneratedAttribute]
public static StandardTransactionPolicyStrategy get_Instance();
    public virtual bool IsStandardOutput(TxOut txout);
}
public class NBitcoin.Policy.TransactionPolicyError : object {
    private string _Message;
    public TransactionPolicyError(string message);
    public virtual string ToString();
}
public class NBitcoin.Policy.TransactionSizePolicyError : TransactionPolicyError {
    private int _ActualSize;
    private int _MaximumSize;
    public int ActualSize { get; }
    public int MaximumSize { get; }
    public TransactionSizePolicyError(int actualSize, int maximumSize);
    public int get_ActualSize();
    public int get_MaximumSize();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NBitcoin.PrecomputedTransactionData : object {
    [CompilerGeneratedAttribute]
private uint256 <HashPrevouts>k__BackingField;
    [CompilerGeneratedAttribute]
private uint256 <HashSequence>k__BackingField;
    [CompilerGeneratedAttribute]
private uint256 <HashOutputs>k__BackingField;
    public uint256 HashPrevouts { get; public set; }
    public uint256 HashSequence { get; public set; }
    public uint256 HashOutputs { get; public set; }
    public PrecomputedTransactionData(Transaction tx);
    [CompilerGeneratedAttribute]
public uint256 get_HashPrevouts();
    [CompilerGeneratedAttribute]
public void set_HashPrevouts(uint256 value);
    [CompilerGeneratedAttribute]
public uint256 get_HashSequence();
    [CompilerGeneratedAttribute]
public void set_HashSequence(uint256 value);
    [CompilerGeneratedAttribute]
public uint256 get_HashOutputs();
    [CompilerGeneratedAttribute]
public void set_HashOutputs(uint256 value);
}
public abstract class NBitcoin.Protocol.BitcoinSerializablePayload`1 : Payload {
    private T _Object;
    public T Object { get; public set; }
    public BitcoinSerializablePayload`1(T obj);
    public T get_Object();
    public void set_Object(T value);
    public virtual void ReadWriteCore(BitcoinStream stream);
}
public class NBitcoin.Protocol.BlockPayload : BitcoinSerializablePayload`1<Block> {
    public string Command { get; }
    public BlockPayload(Block block);
    public virtual string get_Command();
}
public class NBitcoin.Protocol.BlockTxnPayload : Payload {
    private uint256 _BlockId;
    private List`1<Transaction> _Transactions;
    public string Command { get; }
    public uint256 BlockId { get; public set; }
    public List`1<Transaction> Transactions { get; }
    public virtual string get_Command();
    public uint256 get_BlockId();
    public void set_BlockId(uint256 value);
    public List`1<Transaction> get_Transactions();
    public virtual void ReadWriteCore(BitcoinStream stream);
}
public class NBitcoin.Protocol.CmpctBlockPayload : Payload {
    private BlockHeader _Header;
    private ulong _Nonce;
    private List`1<ulong> _ShortIds;
    private List`1<PrefilledTransaction> _PrefilledTransactions;
    private ulong _ShortTxidk0;
    private ulong _ShortTxidk1;
    public string Command { get; }
    public BlockHeader Header { get; public set; }
    public ulong Nonce { get; public set; }
    public List`1<ulong> ShortIds { get; }
    public List`1<PrefilledTransaction> PrefilledTransactions { get; }
    public CmpctBlockPayload(Block block);
    public virtual string get_Command();
    public BlockHeader get_Header();
    public void set_Header(BlockHeader value);
    public ulong get_Nonce();
    public void set_Nonce(ulong value);
    public List`1<ulong> get_ShortIds();
    public List`1<PrefilledTransaction> get_PrefilledTransactions();
    public virtual void ReadWriteCore(BitcoinStream stream);
    private void UpdateShortTxIDSelector();
    public ulong AddTransactionShortId(Transaction tx);
    public ulong AddTransactionShortId(uint256 txId);
    public ulong GetShortID(uint256 txId);
}
public class NBitcoin.Protocol.CompactFilterCheckPointPayload : Payload {
    protected byte _FilterType;
    protected uint256 _StopHash;
    protected List`1<uint256> _FilterHeaders;
    public string Command { get; }
    public FilterType FilterType { get; internal set; }
    public uint256 StopHash { get; public set; }
    public List`1<uint256> FilterHeaders { get; public set; }
    public CompactFilterCheckPointPayload(FilterType filterType, uint256 stopHash, List`1<uint256> filterHeaders);
    public virtual string get_Command();
    public FilterType get_FilterType();
    internal void set_FilterType(FilterType value);
    public uint256 get_StopHash();
    public void set_StopHash(uint256 value);
    public List`1<uint256> get_FilterHeaders();
    public void set_FilterHeaders(List`1<uint256> value);
    public virtual void ReadWriteCore(BitcoinStream stream);
}
public class NBitcoin.Protocol.CompactFilterHeadersPayload : CompactFilterCheckPointPayload {
    private uint256 _PreviousFilterHeader;
    public string Command { get; }
    public uint256 PreviousFilterHeader { get; public set; }
    public virtual string get_Command();
    public virtual void ReadWriteCore(BitcoinStream stream);
    public uint256 get_PreviousFilterHeader();
    public void set_PreviousFilterHeader(uint256 value);
}
public class NBitcoin.Protocol.CompactFilterPayload : Payload {
    private byte _FilterType;
    private Byte[] _FilterBytes;
    private uint256 _BlockHash;
    public string Command { get; }
    public FilterType FilterType { get; internal set; }
    public Byte[] FilterBytes { get; }
    public uint256 BlockHash { get; }
    public CompactFilterPayload(FilterType filterType, uint256 blockhash, Byte[] filterBytes);
    public virtual string get_Command();
    public FilterType get_FilterType();
    internal void set_FilterType(FilterType value);
    public Byte[] get_FilterBytes();
    public uint256 get_BlockHash();
    public virtual void ReadWriteCore(BitcoinStream stream);
}
public abstract class NBitcoin.Protocol.CompactFiltersQueryPayload : Payload {
    private byte _FilterType;
    private UInt32 _StartHeight;
    private uint256 _StopHash;
    public FilterType FilterType { get; internal set; }
    public UInt32 StartHeight { get; }
    public uint256 StopHash { get; }
    protected CompactFiltersQueryPayload(FilterType filterType, UInt32 startHeight, uint256 stopHash);
    public FilterType get_FilterType();
    internal void set_FilterType(FilterType value);
    public UInt32 get_StartHeight();
    public uint256 get_StopHash();
    public virtual void ReadWriteCore(BitcoinStream stream);
}
public class NBitcoin.Protocol.CompactVarInt : object {
    private ulong _Value;
    private int _Size;
    public CompactVarInt(int size);
    public CompactVarInt(ulong value, int size);
    public sealed virtual void ReadWrite(BitcoinStream stream);
    public ulong ToLong();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NBitcoin.Protocol.FeeFilterPayload : Payload {
    private FeeRate _feeRate;
    public string Command { get; }
    public FeeRate FeeRate { get; public set; }
    public virtual string get_Command();
    public FeeRate get_FeeRate();
    public void set_FeeRate(FeeRate value);
    public virtual void ReadWriteCore(BitcoinStream stream);
    public virtual string ToString();
}
public class NBitcoin.Protocol.FilterAddPayload : Payload {
    private Byte[] _Data;
    public string Command { get; }
    public Byte[] Data { get; public set; }
    public FilterAddPayload(Byte[] data);
    public virtual string get_Command();
    public Byte[] get_Data();
    public void set_Data(Byte[] value);
    public virtual void ReadWriteCore(BitcoinStream stream);
}
public class NBitcoin.Protocol.FilterLoadPayload : BitcoinSerializablePayload`1<BloomFilter> {
    public string Command { get; }
    public FilterLoadPayload(BloomFilter filter);
    public virtual string get_Command();
}
public enum NBitcoin.Protocol.FilterType : Enum {
    public byte value__;
    public static FilterType Basic;
}
public class NBitcoin.Protocol.GetAddrPayload : Payload {
    public string Command { get; }
    public virtual string get_Command();
}
public class NBitcoin.Protocol.GetBlocksPayload : Payload {
    private UInt32 version;
    private BlockLocator blockLocators;
    private uint256 _HashStop;
    public string Command { get; }
    public UInt32 Version { get; public set; }
    public BlockLocator BlockLocators { get; public set; }
    public uint256 HashStop { get; public set; }
    public GetBlocksPayload(BlockLocator locator);
    public virtual string get_Command();
    public UInt32 get_Version();
    public void set_Version(UInt32 value);
    public BlockLocator get_BlockLocators();
    public void set_BlockLocators(BlockLocator value);
    public uint256 get_HashStop();
    public void set_HashStop(uint256 value);
    public virtual void ReadWriteCore(BitcoinStream stream);
}
public class NBitcoin.Protocol.GetBlockTxnPayload : Payload {
    private uint256 _BlockId;
    private List`1<int> _Indices;
    public string Command { get; }
    public uint256 BlockId { get; public set; }
    public List`1<int> Indices { get; }
    public virtual string get_Command();
    public uint256 get_BlockId();
    public void set_BlockId(uint256 value);
    public List`1<int> get_Indices();
    public virtual void ReadWriteCore(BitcoinStream stream);
}
public class NBitcoin.Protocol.GetCompactFilterCheckPointPayload : Payload {
    private byte _FilterType;
    private uint256 _StopHash;
    public string Command { get; }
    public FilterType FilterType { get; internal set; }
    public uint256 StopHash { get; }
    public GetCompactFilterCheckPointPayload(FilterType filterType, uint256 stopHash);
    public virtual string get_Command();
    public virtual void ReadWriteCore(BitcoinStream stream);
    public FilterType get_FilterType();
    internal void set_FilterType(FilterType value);
    public uint256 get_StopHash();
}
public class NBitcoin.Protocol.GetCompactFilterHeadersPayload : CompactFiltersQueryPayload {
    public string Command { get; }
    public GetCompactFilterHeadersPayload(FilterType filterType, UInt32 startHeight, uint256 stopHash);
    public virtual string get_Command();
}
public class NBitcoin.Protocol.GetCompactFiltersPayload : CompactFiltersQueryPayload {
    public string Command { get; }
    public GetCompactFiltersPayload(FilterType filterType, UInt32 startHeight, uint256 stopHash);
    public virtual string get_Command();
}
public class NBitcoin.Protocol.GetDataPayload : Payload {
    private List`1<InventoryVector> inventory;
    public string Command { get; }
    public List`1<InventoryVector> Inventory { get; public set; }
    public GetDataPayload(InventoryVector[] vectors);
    public virtual string get_Command();
    public void set_Inventory(List`1<InventoryVector> value);
    public List`1<InventoryVector> get_Inventory();
    public virtual void ReadWriteCore(BitcoinStream stream);
}
public class NBitcoin.Protocol.GetHeadersPayload : Payload {
    private UInt32 version;
    private BlockLocator blockLocators;
    private uint256 hashStop;
    public string Command { get; }
    public UInt32 Version { get; public set; }
    public BlockLocator BlockLocators { get; public set; }
    public uint256 HashStop { get; public set; }
    public GetHeadersPayload(BlockLocator locator);
    public virtual string get_Command();
    public UInt32 get_Version();
    public void set_Version(UInt32 value);
    public BlockLocator get_BlockLocators();
    public void set_BlockLocators(BlockLocator value);
    public uint256 get_HashStop();
    public void set_HashStop(uint256 value);
    public virtual void ReadWriteCore(BitcoinStream stream);
}
public class NBitcoin.Protocol.HaveWitnessPayload : Payload {
    public string Command { get; }
    public virtual string get_Command();
}
public class NBitcoin.Protocol.HeadersPayload : Payload {
    private List`1<BlockHeader> headers;
    public string Command { get; }
    public List`1<BlockHeader> Headers { get; }
    public HeadersPayload(BlockHeader[] headers);
    public virtual string get_Command();
    public List`1<BlockHeader> get_Headers();
    public virtual void ReadWriteCore(BitcoinStream stream);
}
public enum NBitcoin.Protocol.InventoryType : Enum {
    public UInt32 value__;
    public static InventoryType Error;
    public static InventoryType MSG_TX;
    public static InventoryType MSG_BLOCK;
    public static InventoryType MSG_WTX;
    public static InventoryType MSG_FILTERED_BLOCK;
    public static InventoryType MSG_CMPCT_BLOCK;
    public static InventoryType MSG_TYPE_MASK;
    public static InventoryType MSG_WITNESS_FLAG;
    public static InventoryType MSG_WITNESS_BLOCK;
    public static InventoryType MSG_WITNESS_TX;
    public static InventoryType MSG_FILTERED_WITNESS_BLOCK;
}
public class NBitcoin.Protocol.InventoryVector : object {
    private UInt32 type;
    private uint256 hash;
    public InventoryType Type { get; public set; }
    public uint256 Hash { get; public set; }
    public InventoryVector(InventoryType type, uint256 hash);
    public InventoryType get_Type();
    public void set_Type(InventoryType value);
    public uint256 get_Hash();
    public void set_Hash(uint256 value);
    public sealed virtual void ReadWrite(BitcoinStream stream);
    public void ReadWriteCore(BitcoinStream stream);
    public virtual string ToString();
}
public class NBitcoin.Protocol.InvPayload : Payload {
    private List`1<InventoryVector> _Inventory;
    public static int MAX_INV_SZ;
    public string Command { get; }
    public List`1<InventoryVector> Inventory { get; }
    public InvPayload(Transaction[] transactions);
    public InvPayload(Block[] blocks);
    public InvPayload(InventoryType type, uint256[] hashes);
    public InvPayload(InventoryVector[] invs);
    public virtual string get_Command();
    public List`1<InventoryVector> get_Inventory();
    public virtual void ReadWriteCore(BitcoinStream stream);
    public virtual string ToString();
    public sealed virtual IEnumerator`1<InventoryVector> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class NBitcoin.Protocol.MempoolPayload : Payload {
    public string Command { get; }
    public virtual string get_Command();
}
public class NBitcoin.Protocol.MerkleBlockPayload : BitcoinSerializablePayload`1<MerkleBlock> {
    public string Command { get; }
    public MerkleBlockPayload(MerkleBlock block);
    public virtual string get_Command();
}
public class NBitcoin.Protocol.Message : object {
    private UInt32 magic;
    private Byte[] command;
    private Payload _PayloadObject;
    private static Lazy`1<ArrayPool`1<byte>> BigArrayPool;
    private bool _SkipMagic;
    public UInt32 Magic { get; public set; }
    public string Command { get; private set; }
    public Payload Payload { get; public set; }
    private static Message();
    public UInt32 get_Magic();
    public void set_Magic(UInt32 value);
    public string get_Command();
    private void set_Command(string value);
    public Payload get_Payload();
    public void set_Payload(Payload value);
    public bool IfPayloadIs(Action`1<TPayload> action);
    private ArrayPool`1<byte> GetArrayPool(int size);
    public sealed virtual void ReadWrite(BitcoinStream stream);
    public virtual string ToString();
    public static Message ReadNext(Stream stream, Network network, UInt32 version, CancellationToken cancellationToken);
    public static Message ReadNext(Stream stream, Network network, UInt32 version, CancellationToken cancellationToken, PerformanceCounter& counter);
    private IDisposable SkipMagicScope(bool value);
}
public class NBitcoin.Protocol.NotFoundPayload : Payload {
    private List`1<InventoryVector> _Inventory;
    public string Command { get; }
    public List`1<InventoryVector> Inventory { get; }
    public NotFoundPayload(Transaction[] transactions);
    public NotFoundPayload(Block[] blocks);
    public NotFoundPayload(InventoryType type, uint256[] hashes);
    public NotFoundPayload(InventoryVector[] invs);
    public virtual string get_Command();
    public List`1<InventoryVector> get_Inventory();
    public virtual void ReadWriteCore(BitcoinStream stream);
    public virtual string ToString();
    public sealed virtual IEnumerator`1<InventoryVector> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public abstract class NBitcoin.Protocol.Payload : object {
    public string Command { get; }
    public abstract virtual string get_Command();
    public sealed virtual void ReadWrite(BitcoinStream stream);
    public virtual void ReadWriteCore(BitcoinStream stream);
    public virtual string ToString();
}
public class NBitcoin.Protocol.PingPayload : Payload {
    private ulong _Nonce;
    public string Command { get; }
    public ulong Nonce { get; public set; }
    public virtual string get_Command();
    public ulong get_Nonce();
    public void set_Nonce(ulong value);
    public virtual void ReadWriteCore(BitcoinStream stream);
    public PongPayload CreatePong();
    public virtual string ToString();
}
public class NBitcoin.Protocol.PongPayload : Payload {
    private ulong _Nonce;
    public string Command { get; }
    public ulong Nonce { get; public set; }
    public virtual string get_Command();
    public ulong get_Nonce();
    public void set_Nonce(ulong value);
    public virtual void ReadWriteCore(BitcoinStream stream);
    public virtual string ToString();
}
public class NBitcoin.Protocol.PrefilledTransaction : object {
    [CompilerGeneratedAttribute]
private Transaction <Transaction>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Index>k__BackingField;
    public Transaction Transaction { get; public set; }
    public int Index { get; public set; }
    [CompilerGeneratedAttribute]
public Transaction get_Transaction();
    [CompilerGeneratedAttribute]
public void set_Transaction(Transaction value);
    [CompilerGeneratedAttribute]
public int get_Index();
    [CompilerGeneratedAttribute]
public void set_Index(int value);
}
public class NBitcoin.Protocol.ProtocolCapabilities : object {
    [CompilerGeneratedAttribute]
private bool <PeerTooOld>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SupportTimeAddress>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SupportGetBlock>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SupportPingPong>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SupportMempoolQuery>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SupportNodeBloom>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SupportSendHeaders>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SupportWitness>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SupportCompactBlocks>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SupportCheckSum>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SupportUserAgent>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SupportAddrv2>k__BackingField;
    public bool PeerTooOld { get; public set; }
    public bool SupportTimeAddress { get; public set; }
    public bool SupportGetBlock { get; public set; }
    public bool SupportPingPong { get; public set; }
    public bool SupportMempoolQuery { get; public set; }
    public bool SupportNodeBloom { get; public set; }
    public bool SupportSendHeaders { get; public set; }
    public bool SupportWitness { get; public set; }
    public bool SupportCompactBlocks { get; public set; }
    public bool SupportCheckSum { get; public set; }
    public bool SupportUserAgent { get; public set; }
    public bool SupportAddrv2 { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_PeerTooOld();
    [CompilerGeneratedAttribute]
public void set_PeerTooOld(bool value);
    [CompilerGeneratedAttribute]
public bool get_SupportTimeAddress();
    [CompilerGeneratedAttribute]
public void set_SupportTimeAddress(bool value);
    [CompilerGeneratedAttribute]
public bool get_SupportGetBlock();
    [CompilerGeneratedAttribute]
public void set_SupportGetBlock(bool value);
    [CompilerGeneratedAttribute]
public bool get_SupportPingPong();
    [CompilerGeneratedAttribute]
public void set_SupportPingPong(bool value);
    [CompilerGeneratedAttribute]
public bool get_SupportMempoolQuery();
    [CompilerGeneratedAttribute]
public void set_SupportMempoolQuery(bool value);
    [CompilerGeneratedAttribute]
public bool get_SupportNodeBloom();
    [CompilerGeneratedAttribute]
public void set_SupportNodeBloom(bool value);
    [CompilerGeneratedAttribute]
public bool get_SupportSendHeaders();
    [CompilerGeneratedAttribute]
public void set_SupportSendHeaders(bool value);
    [CompilerGeneratedAttribute]
public bool get_SupportWitness();
    [CompilerGeneratedAttribute]
public void set_SupportWitness(bool value);
    [CompilerGeneratedAttribute]
public bool get_SupportCompactBlocks();
    [CompilerGeneratedAttribute]
public void set_SupportCompactBlocks(bool value);
    [CompilerGeneratedAttribute]
public bool get_SupportCheckSum();
    [CompilerGeneratedAttribute]
public void set_SupportCheckSum(bool value);
    public virtual HashStreamBase GetChecksumHashStream();
    public virtual HashStreamBase GetChecksumHashStream(int hintSize);
    [CompilerGeneratedAttribute]
public bool get_SupportUserAgent();
    [CompilerGeneratedAttribute]
public void set_SupportUserAgent(bool value);
    [CompilerGeneratedAttribute]
public bool get_SupportAddrv2();
    [CompilerGeneratedAttribute]
public void set_SupportAddrv2(bool value);
    public static ProtocolCapabilities CreateSupportAll();
    public bool IsSupersetOf(ProtocolCapabilities capabilities);
}
public class NBitcoin.Protocol.ProtocolException : Exception {
    public ProtocolException(string message);
}
public enum NBitcoin.Protocol.RejectCode : Enum {
    public byte value__;
    public static RejectCode MALFORMED;
    public static RejectCode INVALID;
    public static RejectCode OBSOLETE;
    public static RejectCode DUPLICATE;
    public static RejectCode NONSTANDARD;
    public static RejectCode DUST;
    public static RejectCode INSUFFICIENTFEE;
    public static RejectCode CHECKPOINT;
}
public class NBitcoin.Protocol.SendAddrV2Payload : Payload {
    public string Command { get; }
    public virtual string get_Command();
}
public class NBitcoin.Protocol.SendCmpctPayload : Payload {
    private byte _PreferHeaderAndIDs;
    private ulong _Version;
    public string Command { get; }
    public bool PreferHeaderAndIDs { get; public set; }
    public ulong Version { get; public set; }
    public SendCmpctPayload(bool preferHeaderAndIDs);
    public virtual string get_Command();
    public bool get_PreferHeaderAndIDs();
    public void set_PreferHeaderAndIDs(bool value);
    public ulong get_Version();
    public void set_Version(ulong value);
    public virtual void ReadWriteCore(BitcoinStream stream);
}
public class NBitcoin.Protocol.SendHeadersPayload : Payload {
    public string Command { get; }
    public virtual string get_Command();
}
public class NBitcoin.Protocol.TxPayload : Payload {
    private Transaction _Object;
    public string Command { get; }
    public Transaction Object { get; public set; }
    public TxPayload(Transaction transaction);
    public virtual string get_Command();
    public Transaction get_Object();
    public void set_Object(Transaction value);
    public virtual void ReadWriteCore(BitcoinStream stream);
}
public class NBitcoin.Protocol.UnknownPayload : Payload {
    internal string _Command;
    private Byte[] _Data;
    public string Command { get; }
    public Byte[] Data { get; public set; }
    public UnknownPayload(string command);
    public virtual string get_Command();
    public Byte[] get_Data();
    public void set_Data(Byte[] value);
    public virtual void ReadWriteCore(BitcoinStream stream);
}
[ObsoleteAttribute("Use UnknownPayload")]
public class NBitcoin.Protocol.UnknowPayload : UnknownPayload {
}
public class NBitcoin.Protocol.UTxOut : object {
    private UInt32 _version;
    private UInt32 _height;
    private TxOut _txOut;
    public UInt32 Version { get; internal set; }
    public UInt32 Height { get; internal set; }
    public TxOut Output { get; internal set; }
    public UInt32 get_Version();
    internal void set_Version(UInt32 value);
    public UInt32 get_Height();
    internal void set_Height(UInt32 value);
    public TxOut get_Output();
    internal void set_Output(TxOut value);
    public sealed virtual void ReadWrite(BitcoinStream stream);
}
public class NBitcoin.Protocol.UTxOutputPayload : Payload {
    private UTxOutputs _uTxOutputs;
    public string Command { get; }
    public virtual string get_Command();
    public virtual void ReadWriteCore(BitcoinStream stream);
}
public class NBitcoin.Protocol.UTxOutputs : object {
    private VarString _bitmap;
    private int _chainHeight;
    private uint256 _chainTipHash;
    private UTxOut[] _outputs;
    public int ChainHeight { get; internal set; }
    public uint256 ChainTipHash { get; internal set; }
    public BitArray Bitmap { get; }
    public UTxOut[] Outputs { get; internal set; }
    public int get_ChainHeight();
    internal void set_ChainHeight(int value);
    public uint256 get_ChainTipHash();
    internal void set_ChainTipHash(uint256 value);
    public BitArray get_Bitmap();
    public UTxOut[] get_Outputs();
    internal void set_Outputs(UTxOut[] value);
    public sealed virtual void ReadWrite(BitcoinStream stream);
}
public class NBitcoin.Protocol.VarInt : object {
    private ulong _Value;
    public VarInt(ulong value);
    internal void SetValue(ulong value);
    public static void StaticWrite(BitcoinStream bs, ulong length);
    public static ulong StaticRead(BitcoinStream bs);
    public ulong ToLong();
    public sealed virtual void ReadWrite(BitcoinStream stream);
}
public class NBitcoin.Protocol.VarString : object {
    private Byte[] _Bytes;
    public int Length { get; }
    public VarString(Byte[] bytes);
    public int get_Length();
    public Byte[] GetString();
    public Byte[] GetString(bool unsafe);
    public sealed virtual void ReadWrite(BitcoinStream stream);
    internal static void StaticWrite(BitcoinStream bs, Byte[] bytes);
    internal static void StaticRead(BitcoinStream bs, Byte[]& bytes);
}
public class NBitcoin.Protocol.VerAckPayload : Payload {
    public string Command { get; }
    public virtual string get_Command();
    public virtual void ReadWriteCore(BitcoinStream stream);
}
public class NBitcoin.Protocol.WTxIdRelayPayload : Payload {
    public string Command { get; }
    public virtual string get_Command();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NBitcoin.PSBT : object {
    private static Byte[] PSBT_MAGIC_BYTES;
    [NullableAttribute("2")]
internal Byte[] _XPubVersionBytes;
    internal Transaction tx;
    [CompilerGeneratedAttribute]
private SortedDictionary`2<BitcoinExtPubKey, RootedKeyPath> <GlobalXPubs>k__BackingField;
    [CompilerGeneratedAttribute]
private PSBTInputList <Inputs>k__BackingField;
    [CompilerGeneratedAttribute]
private PSBTOutputList <Outputs>k__BackingField;
    internal SortedDictionary`2<Byte[], Byte[]> unknown;
    [CompilerGeneratedAttribute]
private Network <Network>k__BackingField;
    [CompilerGeneratedAttribute]
private PSBTSettings <Settings>k__BackingField;
    private static UInt32 defaultKeyLen;
    private Byte[] XPubVersionBytes { get; }
    public SortedDictionary`2<BitcoinExtPubKey, RootedKeyPath> GlobalXPubs { get; }
    public PSBTInputList Inputs { get; }
    public PSBTOutputList Outputs { get; }
    public Network Network { get; }
    public PSBTSettings Settings { get; public set; }
    private PSBT(Transaction transaction, Network network);
    internal PSBT(BitcoinStream stream, Network network);
    private static PSBT();
    private Byte[] get_XPubVersionBytes();
    [CompilerGeneratedAttribute]
public SortedDictionary`2<BitcoinExtPubKey, RootedKeyPath> get_GlobalXPubs();
    [CompilerGeneratedAttribute]
public PSBTInputList get_Inputs();
    [CompilerGeneratedAttribute]
public PSBTOutputList get_Outputs();
    public static PSBT Parse(string hexOrBase64, Network network);
    public static bool TryParse(string hexOrBase64, Network network, PSBT& psbt);
    public static PSBT Load(Byte[] rawBytes, Network network);
    internal ConsensusFactory GetConsensusFactory();
    [CompilerGeneratedAttribute]
public Network get_Network();
    public PSBT AddCoins(ICoin[] coins);
    public PSBT AddCoins(Transaction[] transactions);
    public PSBT AddTransactions(Transaction[] parentTransactions);
    public PSBT Combine(PSBT other);
    public PSBT UpdateFrom(PSBT other);
    public PSBT CoinJoin(PSBT other);
    public PSBT Finalize();
    public bool TryFinalize(IList`1& errors);
    internal SigningOptions GetSigningOptions(SigningOptions signingOptions);
    public bool IsReadyToSign();
    public bool IsReadyToSign(PSBTError[]& errors);
    [CompilerGeneratedAttribute]
public PSBTSettings get_Settings();
    [CompilerGeneratedAttribute]
public void set_Settings(PSBTSettings value);
    public PSBT SignAll(ScriptPubKeyType scriptPubKeyType, IHDKey accountKey, RootedKeyPath accountKeyPath);
    public PSBT SignAll(ScriptPubKeyType scriptPubKeyType, IHDKey accountKey);
    public PSBT SignAll(IHDScriptPubKey accountHDScriptPubKey, IHDKey accountKey);
    public PSBT SignAll(IHDScriptPubKey accountHDScriptPubKey, IHDKey accountKey, RootedKeyPath accountKeyPath);
    public bool TryGetFee(Money& fee);
    public Money GetFee();
    public bool TryGetEstimatedFeeRate(FeeRate& estimatedFeeRate);
    public bool TryGetVirtualSize(Int32& vsize);
    public FeeRate GetEstimatedFeeRate();
    public PSBT SignWithKeys(ISecret[] keys);
    public PSBT SignWithKeys(Key[] keys);
    public PrecomputedTransactionData PrecomputeTransactionData();
    public TransactionValidator CreateTransactionValidator();
    internal bool TryCreateTransactionValidator(TransactionValidator& validator, IList`1& errors);
    private TxOut[] GetSpentTxOuts(IList`1& errors);
    internal TransactionBuilder CreateTransactionBuilder();
    [IteratorStateMachineAttribute("NBitcoin.PSBT/<GetAllCoins>d__56")]
private IEnumerable`1<ICoin> GetAllCoins();
    public Transaction ExtractTransaction();
    public bool CanExtractTransaction();
    public bool IsAllFinalized();
    public IList`1<PSBTError> CheckSanity();
    public void AssertSanity();
    public bool TryGetFinalizedHash(uint256& hash);
    public void Serialize(BitcoinStream stream);
    public virtual string ToString();
    public Byte[] ToBytes();
    public PSBT Clone();
    public PSBT Clone(bool keepOriginalTransactionInformation);
    public string ToBase64();
    public string ToHex();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(PSBT b);
    public virtual int GetHashCode();
    public static PSBT FromTransaction(Transaction transaction, Network network);
    public PSBT AddScripts(Script[] redeems);
    public Money GetBalance(ScriptPubKeyType scriptPubKeyType, IHDKey accountKey, RootedKeyPath accountKeyPath);
    public Money GetBalance(IHDScriptPubKey accountHDScriptPubKey, IHDKey accountKey, RootedKeyPath accountKeyPath);
    public IEnumerable`1<PSBTCoin> CoinsFor(IHDScriptPubKey accountHDScriptPubKey, IHDKey accountKey, RootedKeyPath accountKeyPath);
    public IEnumerable`1<PSBTHDKeyMatch> HDKeysFor(IHDScriptPubKey accountHDScriptPubKey, IHDKey accountKey, RootedKeyPath accountKeyPath);
    public IEnumerable`1<PSBTHDKeyMatch> HDKeysFor(IHDKey accountKey, RootedKeyPath accountKeyPath);
    public PSBT AddKeyPath(IHDKey masterKey, KeyPath[] paths);
    public PSBT AddKeyPath(IHDKey masterKey, Tuple`2[] paths);
    public PSBT AddKeyPath(PubKey pubkey, RootedKeyPath rootedKeyPath);
    public PSBT AddKeyPath(PubKey pubkey, RootedKeyPath rootedKeyPath, Script scriptPubKey);
    public PSBT RebaseKeyPaths(IHDKey accountKey, RootedKeyPath newRoot);
    public Transaction GetOriginalTransaction();
    public Transaction GetGlobalTransaction();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class NBitcoin.PSBTCoin : object {
    protected SortedDictionary`2<PubKey, RootedKeyPath> hd_keypaths;
    protected SortedDictionary`2<TaprootPubKey, TaprootKeyPath> hd_taprootkeypaths;
    protected SortedDictionary`2<Byte[], Byte[]> unknown;
    [NullableAttribute("2")]
protected Script redeem_script;
    [NullableAttribute("2")]
protected Script witness_script;
    protected PSBT Parent;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private TaprootInternalPubKey <TaprootInternalKey>k__BackingField;
    public PSBT PSBT { get; }
    public SortedDictionary`2<Byte[], Byte[]> Unknown { get; }
    public SortedDictionary`2<PubKey, RootedKeyPath> HDKeyPaths { get; }
    public SortedDictionary`2<TaprootPubKey, TaprootKeyPath> HDTaprootKeyPaths { get; }
    [NullableAttribute("2")]
public TaprootInternalPubKey TaprootInternalKey { get; public set; }
    [NullableAttribute("2")]
public Script RedeemScript { get; public set; }
    [NullableAttribute("2")]
public Script WitnessScript { get; public set; }
    public PSBTCoin(PSBT parent);
    public PSBT get_PSBT();
    public SortedDictionary`2<Byte[], Byte[]> get_Unknown();
    public SortedDictionary`2<PubKey, RootedKeyPath> get_HDKeyPaths();
    public SortedDictionary`2<TaprootPubKey, TaprootKeyPath> get_HDTaprootKeyPaths();
    [IteratorStateMachineAttribute("NBitcoin.PSBTCoin/<EnumerateKeyPaths>d__15")]
public IEnumerable`1<KeyValuePair`2<IPubKey, RootedKeyPath>> EnumerateKeyPaths();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public TaprootInternalPubKey get_TaprootInternalKey();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_TaprootInternalKey(TaprootInternalPubKey value);
    [NullableContextAttribute("2")]
public Script get_RedeemScript();
    [NullableContextAttribute("2")]
public void set_RedeemScript(Script value);
    [NullableContextAttribute("2")]
public Script get_WitnessScript();
    [NullableContextAttribute("2")]
public void set_WitnessScript(Script value);
    public virtual void AddKeyPath(PubKey pubKey, RootedKeyPath rootedKeyPath);
    [NullableContextAttribute("2")]
public abstract virtual Coin GetCoin();
    [NullableContextAttribute("2")]
public Coin GetSignableCoin();
    [NullableContextAttribute("2")]
public virtual Coin GetSignableCoin(String& error);
    [NullableContextAttribute("2")]
internal virtual Script GetRedeemScript();
    [NullableContextAttribute("2")]
internal virtual Script GetWitnessScript();
    public IEnumerable`1<PSBTHDKeyMatch> HDKeysFor(IHDScriptPubKey accountHDScriptPubKey, IHDKey accountKey, RootedKeyPath accountKeyPath);
    [IteratorStateMachineAttribute("NBitcoin.PSBTCoin/<HDKeysFor>d__33")]
internal IEnumerable`1<PSBTHDKeyMatch> HDKeysFor(IHDScriptPubKey accountHDScriptPubKey, IHDKey accountKey, RootedKeyPath accountKeyPath, HDFingerprint accountFingerprint);
    protected abstract virtual PSBTHDKeyMatch CreateHDKeyMatch(IHDKey accountKey, KeyPath addressKeyPath, KeyValuePair`2<IPubKey, RootedKeyPath> kv);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class NBitcoin.PSBTCoinList`1 : object {
    protected List`1<T> _Inner;
    public int Count { get; }
    public T Item { get; }
    public IEnumerable`1<T> CoinsFor(IHDScriptPubKey accountHDScriptPubKey, IHDKey accountKey, RootedKeyPath accountKeyPath);
    public IEnumerable`1<PSBTHDKeyMatch`1<T>> HDKeysFor(IHDScriptPubKey accountHDScriptPubKey, IHDKey accountKey, RootedKeyPath accountKeyPath);
    public IEnumerable`1<PSBTHDKeyMatch`1<T>> HDKeysFor(IHDKey accountKey, RootedKeyPath accountKeyPath);
    internal IEnumerable`1<T> GetPSBTCoins(IHDScriptPubKey accountHDScriptPubKey, IHDKey accountKey, RootedKeyPath accountKeyPath);
    [IteratorStateMachineAttribute("NBitcoin.PSBTCoinList`1/<GetHDKeys>d__4")]
internal IEnumerable`1<PSBTHDKeyMatch`1<T>> GetHDKeys(IHDScriptPubKey hdScriptPubKey, IHDKey accountKey, RootedKeyPath accountKeyPath);
    public sealed virtual int get_Count();
    public sealed virtual T get_Item(int index);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class NBitcoin.PSBTConstants : object {
    [CompilerGeneratedAttribute]
private static Byte[] <PSBT_GLOBAL_ALL>k__BackingField;
    [CompilerGeneratedAttribute]
private static Byte[] <PSBT_IN_ALL>k__BackingField;
    [CompilerGeneratedAttribute]
private static Byte[] <PSBT_OUT_ALL>k__BackingField;
    public static byte PSBT_GLOBAL_UNSIGNED_TX;
    public static byte PSBT_GLOBAL_XPUB;
    public static byte PSBT_IN_NON_WITNESS_UTXO;
    public static byte PSBT_IN_WITNESS_UTXO;
    public static byte PSBT_IN_PARTIAL_SIG;
    public static byte PSBT_IN_SIGHASH;
    public static byte PSBT_IN_REDEEMSCRIPT;
    public static byte PSBT_IN_WITNESSSCRIPT;
    public static byte PSBT_IN_BIP32_DERIVATION;
    public static byte PSBT_IN_SCRIPTSIG;
    public static byte PSBT_IN_SCRIPTWITNESS;
    public static byte PSBT_OUT_TAP_INTERNAL_KEY;
    public static byte PSBT_IN_TAP_KEY_SIG;
    public static byte PSBT_IN_TAP_INTERNAL_KEY;
    public static byte PSBT_IN_TAP_BIP32_DERIVATION;
    public static byte PSBT_OUT_TAP_BIP32_DERIVATION;
    public static byte PSBT_IN_TAP_MERKLE_ROOT;
    public static byte PSBT_OUT_REDEEMSCRIPT;
    public static byte PSBT_OUT_WITNESSSCRIPT;
    public static byte PSBT_OUT_BIP32_DERIVATION;
    public static byte PSBT_SEPARATOR;
    public static Byte[] PSBT_GLOBAL_ALL { get; }
    public static Byte[] PSBT_IN_ALL { get; }
    public static Byte[] PSBT_OUT_ALL { get; }
    private static PSBTConstants();
    [CompilerGeneratedAttribute]
public static Byte[] get_PSBT_GLOBAL_ALL();
    [CompilerGeneratedAttribute]
public static Byte[] get_PSBT_IN_ALL();
    [CompilerGeneratedAttribute]
public static Byte[] get_PSBT_OUT_ALL();
}
public class NBitcoin.PSBTError : object {
    [CompilerGeneratedAttribute]
private UInt32 <InputIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    public UInt32 InputIndex { get; }
    public string Message { get; }
    public PSBTError(UInt32 inputIndex, string errorMessage);
    [CompilerGeneratedAttribute]
public UInt32 get_InputIndex();
    [CompilerGeneratedAttribute]
public string get_Message();
    public virtual string ToString();
}
public class NBitcoin.PSBTException : InvalidOperationException {
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<PSBTError> <Errors>k__BackingField;
    public IReadOnlyList`1<PSBTError> Errors { get; }
    public PSBTException(IEnumerable`1<PSBTError> errors);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<PSBTError> get_Errors();
    private static string GetMessage(IEnumerable`1<PSBTError> errors);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NBitcoin.PSBTHDKeyMatch : object {
    private PSBTCoin _Coin;
    private IPubKey _PubKey;
    private KeyPath _AddressKeyPath;
    private IHDKey _AccountKey;
    private RootedKeyPath _KeyPath;
    public PSBTCoin Coin { get; }
    public IPubKey PubKey { get; }
    public KeyPath AddressKeyPath { get; }
    public IHDKey AccountKey { get; }
    public RootedKeyPath RootedKeyPath { get; }
    internal PSBTHDKeyMatch(PSBTCoin psbtCoin, IHDKey accountKey, KeyPath addressKeyPath, KeyValuePair`2<IPubKey, RootedKeyPath> kv);
    public PSBTCoin get_Coin();
    public IPubKey get_PubKey();
    public KeyPath get_AddressKeyPath();
    public IHDKey get_AccountKey();
    public RootedKeyPath get_RootedKeyPath();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NBitcoin.PSBTHDKeyMatch`1 : PSBTHDKeyMatch {
    private T _Coin;
    public T Coin { get; }
    internal PSBTHDKeyMatch`1(T psbtCoin, IHDKey accountKey, KeyPath addressKeyPath, KeyValuePair`2<IPubKey, RootedKeyPath> kv);
    public T get_Coin();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NBitcoin.PSBTInput : PSBTCoin {
    internal Script originalScriptSig;
    internal WitScript originalWitScript;
    [NullableAttribute("2")]
internal TxOut orphanTxOut;
    [CompilerGeneratedAttribute]
private TxIn <TxIn>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <Index>k__BackingField;
    [NullableAttribute("2")]
private Transaction non_witness_utxo;
    [NullableAttribute("2")]
private TxOut witness_utxo;
    [NullableAttribute("2")]
private Script final_script_sig;
    [NullableAttribute("2")]
private WitScript final_script_witness;
    private SortedDictionary`2<PubKey, TransactionSignature> partial_sigs;
    private Nullable`1<UInt32> sighash_type;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private TaprootSignature <TaprootKeySignature>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private uint256 <TaprootMerkleRoot>k__BackingField;
    private static UInt32 defaultKeyLen;
    internal TxIn TxIn { get; }
    public OutPoint PrevOut { get; }
    public UInt32 Index { get; }
    internal Transaction Transaction { get; }
    [NullableAttribute("2")]
public Transaction NonWitnessUtxo { get; public set; }
    [NullableAttribute("2")]
public TxOut WitnessUtxo { get; public set; }
    public Nullable`1<SigHash> SighashType { get; public set; }
    public Nullable`1<TaprootSigHash> TaprootSighashType { get; public set; }
    [NullableAttribute("2")]
public Script FinalScriptSig { get; public set; }
    [NullableAttribute("2")]
public WitScript FinalScriptWitness { get; public set; }
    [NullableAttribute("2")]
public TaprootSignature TaprootKeySignature { get; public set; }
    [NullableAttribute("2")]
public uint256 TaprootMerkleRoot { get; public set; }
    public SortedDictionary`2<PubKey, TransactionSignature> PartialSigs { get; }
    internal PSBTInput(PSBT parent, UInt32 index, TxIn input);
    internal PSBTInput(BitcoinStream stream, PSBT parent, UInt32 index, TxIn input);
    private static PSBTInput();
    public void SetSequence(ushort sequence);
    [CompilerGeneratedAttribute]
internal TxIn get_TxIn();
    internal IndexedTxIn GetIndexedInput();
    public OutPoint get_PrevOut();
    [CompilerGeneratedAttribute]
public UInt32 get_Index();
    internal Transaction get_Transaction();
    [NullableContextAttribute("2")]
public Transaction get_NonWitnessUtxo();
    [NullableContextAttribute("2")]
public void set_NonWitnessUtxo(Transaction value);
    [NullableContextAttribute("2")]
public TxOut get_WitnessUtxo();
    [NullableContextAttribute("2")]
public void set_WitnessUtxo(TxOut value);
    public Nullable`1<SigHash> get_SighashType();
    public void set_SighashType(Nullable`1<SigHash> value);
    public Nullable`1<TaprootSigHash> get_TaprootSighashType();
    public void set_TaprootSighashType(Nullable`1<TaprootSigHash> value);
    [NullableContextAttribute("2")]
public Script get_FinalScriptSig();
    [NullableContextAttribute("2")]
public void set_FinalScriptSig(Script value);
    [NullableContextAttribute("2")]
public WitScript get_FinalScriptWitness();
    [NullableContextAttribute("2")]
public void set_FinalScriptWitness(WitScript value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public TaprootSignature get_TaprootKeySignature();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_TaprootKeySignature(TaprootSignature value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public uint256 get_TaprootMerkleRoot();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_TaprootMerkleRoot(uint256 value);
    public SortedDictionary`2<PubKey, TransactionSignature> get_PartialSigs();
    public void UpdateFromCoin(ICoin coin);
    public void UpdateFrom(PSBTInput other);
    public uint256 GetSignatureHash(TaprootSigHash sigHash, PrecomputedTransactionData precomputedTransactionData);
    public uint256 GetSignatureHash(SigHash sigHash, PrecomputedTransactionData precomputedTransactionData);
    public bool IsFinalized();
    private Op[] GetPushItems(Script redeem);
    public void ClearForFinalize();
    [NullableContextAttribute("2")]
public Coin GetSignableCoin();
    [NullableContextAttribute("2")]
public virtual Coin GetSignableCoin(String& error);
    [NullableContextAttribute("2")]
internal virtual Script GetRedeemScript();
    [NullableContextAttribute("2")]
internal virtual Script GetWitnessScript();
    public IList`1<PSBTError> CheckSanity();
    public void TrySign(IHDScriptPubKey accountHDScriptPubKey, IHDKey accountKey, RootedKeyPath accountKeyPath);
    internal void TrySign(IHDScriptPubKey accountHDScriptPubKey, IHDKey accountKey, RootedKeyPath accountKeyPath, SigningOptions signingOptions);
    public void AssertSanity();
    public void Serialize(BitcoinStream stream);
    public Byte[] ToBytes();
    internal void Write(JsonTextWriter jsonWriter);
    private string GetName(UInt32 sighashType);
    [NullableContextAttribute("2")]
public TxOut GetTxOut();
    public bool TryFinalizeInput(IList`1& errors);
    internal bool TryFinalizeInput(SigningOptions signingOptions, IList`1& errors);
    internal static bool IsTaprootReady(SigningOptions signingOptions, Coin coin);
    [NullableContextAttribute("2")]
public bool VerifyScript(PrecomputedTransactionData precomputedTransactionData, ScriptError& err);
    [NullableContextAttribute("2")]
public bool VerifyScript(ScriptVerify scriptVerify, PrecomputedTransactionData precomputedTransactionData, ScriptError& err);
    public void FinalizeInput();
    public void Sign(Key key);
    public void Sign(KeyPair keyPair);
    internal void Sign(KeyPair keyPair, SigningOptions signingOptions);
    internal void Sign(Key key, SigningOptions signingOptions);
    private bool SameSigHash(UInt32 a, UInt32 b);
    private void CheckCompatibleSigHash(UInt32 sigHash);
    public bool TrySlimUTXO();
    [NullableContextAttribute("2")]
public virtual Coin GetCoin();
    public virtual string ToString();
    protected virtual PSBTHDKeyMatch CreateHDKeyMatch(IHDKey accountKey, KeyPath addressKeyPath, KeyValuePair`2<IPubKey, RootedKeyPath> kv);
    [CompilerGeneratedAttribute]
private void <TryFinalizeInput>g__Rollback|73_0(<>c__DisplayClass73_0& );
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class NBitcoin.PSBTInputList : PSBTCoinList`1<PSBTInput> {
    private Dictionary`2<OutPoint, PSBTInput> _InputsByOutpoint;
    internal void Add(PSBTInput input);
    public PSBTInput FindIndexedInput(OutPoint prevOut);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NBitcoin.PSBTOutput : PSBTCoin {
    [CompilerGeneratedAttribute]
private TxOut <TxOut>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <Index>k__BackingField;
    private static UInt32 defaultKeyLen;
    internal TxOut TxOut { get; }
    public Script ScriptPubKey { get; }
    public Money Value { get; }
    public UInt32 Index { get; public set; }
    internal Transaction Transaction { get; }
    internal PSBTOutput(PSBT parent, UInt32 index, TxOut txOut);
    internal PSBTOutput(BitcoinStream stream, PSBT parent, UInt32 index, TxOut txOut);
    private static PSBTOutput();
    [CompilerGeneratedAttribute]
internal TxOut get_TxOut();
    public Script get_ScriptPubKey();
    public Money get_Value();
    [CompilerGeneratedAttribute]
public UInt32 get_Index();
    [CompilerGeneratedAttribute]
public void set_Index(UInt32 value);
    internal Transaction get_Transaction();
    public void UpdateFrom(PSBTOutput other);
    public void Serialize(BitcoinStream stream);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public bool Equals(PSBTOutput b);
    public virtual int GetHashCode();
    public Byte[] ToBytes();
    public void UpdateFromCoin(ICoin coin);
    internal void Write(JsonTextWriter jsonWriter);
    public virtual string ToString();
    public virtual Coin GetCoin();
    protected virtual PSBTHDKeyMatch CreateHDKeyMatch(IHDKey accountKey, KeyPath addressKeyPath, KeyValuePair`2<IPubKey, RootedKeyPath> kv);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class NBitcoin.PSBTOutputList : PSBTCoinList`1<PSBTOutput> {
    internal void Add(PSBTOutput item);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NBitcoin.PSBTSettings : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private IEnumerable`1<BuilderExtension> <CustomBuilderExtensions>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsSmart>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SkipVerifyScript>k__BackingField;
    [CompilerGeneratedAttribute]
private SigningOptions <SigningOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private ScriptVerify <ScriptVerify>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AutomaticUTXOTrimming>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IEnumerable`1<BuilderExtension> CustomBuilderExtensions { get; public set; }
    public bool IsSmart { get; public set; }
    public bool SkipVerifyScript { get; public set; }
    public SigningOptions SigningOptions { get; public set; }
    public ScriptVerify ScriptVerify { get; internal set; }
    public bool AutomaticUTXOTrimming { get; public set; }
    [CompilerGeneratedAttribute]
public IEnumerable`1<BuilderExtension> get_CustomBuilderExtensions();
    [CompilerGeneratedAttribute]
public void set_CustomBuilderExtensions(IEnumerable`1<BuilderExtension> value);
    [CompilerGeneratedAttribute]
public bool get_IsSmart();
    [CompilerGeneratedAttribute]
public void set_IsSmart(bool value);
    [CompilerGeneratedAttribute]
public bool get_SkipVerifyScript();
    [CompilerGeneratedAttribute]
public void set_SkipVerifyScript(bool value);
    [CompilerGeneratedAttribute]
public SigningOptions get_SigningOptions();
    [CompilerGeneratedAttribute]
public void set_SigningOptions(SigningOptions value);
    [CompilerGeneratedAttribute]
public ScriptVerify get_ScriptVerify();
    [CompilerGeneratedAttribute]
internal void set_ScriptVerify(ScriptVerify value);
    [CompilerGeneratedAttribute]
public bool get_AutomaticUTXOTrimming();
    [CompilerGeneratedAttribute]
public void set_AutomaticUTXOTrimming(bool value);
    public PSBTSettings Clone();
}
[ExtensionAttribute]
internal static class NBitcoin.PSBTUtils : object {
    [ExtensionAttribute]
public static void WritePropertyValue(JsonWriter writer, string name, TValue value);
    [ExtensionAttribute]
public static void WriteBIP32Derivations(JsonTextWriter jsonWriter, SortedDictionary`2<TaprootPubKey, TaprootKeyPath> hd_keypaths);
    [ExtensionAttribute]
public static void WriteBIP32Derivations(JsonTextWriter jsonWriter, SortedDictionary`2<PubKey, RootedKeyPath> hd_keypaths);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NBitcoin.PubKey : object {
    private ECKey _ECKey;
    private Byte[] vch;
    [NullableAttribute("2")]
private KeyId _ID;
    [NullableAttribute("2")]
private WitKeyId _WitID;
    private Nullable`1<HDFingerprint> fp;
    private Nullable`1<int> hashcode;
    [NullableAttribute("2")]
private Script _ScriptPubKey;
    internal ECKey ECKey { get; }
    public KeyId Hash { get; }
    public WitKeyId WitHash { get; }
    public bool IsCompressed { get; }
    public Script ScriptPubKey { get; }
    public PubKey(string hex);
    private PubKey(ECKey eCKey, Byte[] bytes);
    public PubKey(Byte[] bytes);
    public static bool TryCreatePubKey(Byte[] bytes, PubKey& pubKey);
    internal ECKey get_ECKey();
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(PubKey other);
    public PubKey Compress();
    public PubKey Decompress();
    public static bool SanityCheck(Byte[] data);
    public static bool SanityCheck(Byte[] data, int offset, int count);
    public KeyId get_Hash();
    public WitKeyId get_WitHash();
    public bool get_IsCompressed();
    public BitcoinAddress GetAddress(ScriptPubKeyType type, Network network);
    public HDFingerprint GetHDFingerPrint();
    public bool Verify(uint256 hash, ECDSASignature sig);
    public bool Verify(uint256 hash, Byte[] sig);
    public Script GetScriptPubKey(ScriptPubKeyType type);
    public IAddressableDestination GetDestination(ScriptPubKeyType type);
    public string ToHex();
    public Byte[] ToBytes();
    public Byte[] ToBytes(bool unsafe);
    public virtual string ToString();
    public static PubKey RecoverCompact(uint256 hash, CompactSignature compactSignature);
    public PubKey Derivate(Byte[] cc, UInt32 nChild, Byte[]& ccChild);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(PubKey pk);
    [NullableContextAttribute("2")]
public static bool op_Equality(PubKey a, PubKey b);
    [NullableContextAttribute("2")]
public static bool op_Inequality(PubKey a, PubKey b);
    public virtual int GetHashCode();
    public sealed virtual Script get_ScriptPubKey();
    public PubKey GetSharedPubkey(Key key);
    public string Encrypt(string message);
    public Byte[] Encrypt(Byte[] message);
}
internal class NBitcoin.PubKeyComparer : object {
    [CompilerGeneratedAttribute]
private static PubKeyComparer <Instance>k__BackingField;
    public static PubKeyComparer Instance { get; }
    private static PubKeyComparer();
    [CompilerGeneratedAttribute]
public static PubKeyComparer get_Instance();
    public sealed virtual int Compare(PubKey x, PubKey y);
}
public class NBitcoin.RandomUtils : object {
    [CompilerGeneratedAttribute]
private static bool <UseAdditionalEntropy>k__BackingField;
    [CompilerGeneratedAttribute]
private static IRandom <Random>k__BackingField;
    private static Byte[] modreq(System.Runtime.CompilerServices.IsVolatile) additionalEntropy;
    private static Int32 modreq(System.Runtime.CompilerServices.IsVolatile) entropyIndex;
    public static bool UseAdditionalEntropy { get; public set; }
    public static IRandom Random { get; public set; }
    private static RandomUtils();
    [CompilerGeneratedAttribute]
public static bool get_UseAdditionalEntropy();
    [CompilerGeneratedAttribute]
public static void set_UseAdditionalEntropy(bool value);
    [CompilerGeneratedAttribute]
public static IRandom get_Random();
    [CompilerGeneratedAttribute]
public static void set_Random(IRandom value);
    public static Byte[] GetBytes(int length);
    private static void PushEntropy(Byte[] data);
    public static void AddEntropy(string data);
    public static void AddEntropy(Byte[] data);
    public static uint256 GetUInt256();
    public static UInt32 GetUInt32();
    public static int GetInt32();
    public static ulong GetUInt64();
    public static long GetInt64();
    public static void GetBytes(Byte[] output);
}
internal class NBitcoin.ReaderWriterLock : object {
    private ReaderWriterLockSlim lock;
    public IDisposable LockRead();
    public IDisposable LockWrite();
    internal bool TryLockWrite(IDisposable& locked);
    [CompilerGeneratedAttribute]
private void <LockRead>b__1_0();
    [CompilerGeneratedAttribute]
private void <LockRead>b__1_1();
    [CompilerGeneratedAttribute]
private void <LockWrite>b__2_0();
    [CompilerGeneratedAttribute]
private void <LockWrite>b__2_1();
    [CompilerGeneratedAttribute]
private void <TryLockWrite>b__3_1();
}
public enum NBitcoin.RedeemType : Enum {
    public int value__;
    public static RedeemType P2SH;
    public static RedeemType WitnessV0;
}
public class NBitcoin.RootedKeyPath : object {
    private KeyPath _KeyPath;
    private HDFingerprint _MasterFingerprint;
    public KeyPath KeyPath { get; }
    public HDFingerprint MasterFingerprint { get; }
    public RootedKeyPath(HDFingerprint masterFingerprint, KeyPath keyPath);
    public RootedKeyPath(IHDKey masterKey, KeyPath keyPath);
    public static RootedKeyPath Parse(string str);
    public static bool TryParse(string str, RootedKeyPath& result);
    public KeyPath get_KeyPath();
    public HDFingerprint get_MasterFingerprint();
    public RootedKeyPath Derive(KeyPath keyPath);
    public RootedKeyPath Derive(UInt32 index);
    public RootedKeyPath GetAccountKeyPath();
    public virtual string ToString();
    public string ToStringWithEmptyKeyPathAware();
    public virtual bool Equals(object obj);
    public static bool op_Equality(RootedKeyPath a, RootedKeyPath b);
    public static bool op_Inequality(RootedKeyPath a, RootedKeyPath b);
    public virtual int GetHashCode();
}
public class NBitcoin.RPC.AddressGrouping : object {
    [CompilerGeneratedAttribute]
private BitcoinAddress <PublicAddress>k__BackingField;
    [CompilerGeneratedAttribute]
private Money <Amount>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Account>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<ChangeAddress> <ChangeAddresses>k__BackingField;
    public BitcoinAddress PublicAddress { get; public set; }
    public Money Amount { get; public set; }
    public string Account { get; public set; }
    public List`1<ChangeAddress> ChangeAddresses { get; public set; }
    [CompilerGeneratedAttribute]
public BitcoinAddress get_PublicAddress();
    [CompilerGeneratedAttribute]
public void set_PublicAddress(BitcoinAddress value);
    [CompilerGeneratedAttribute]
public Money get_Amount();
    [CompilerGeneratedAttribute]
public void set_Amount(Money value);
    [CompilerGeneratedAttribute]
public string get_Account();
    [CompilerGeneratedAttribute]
public void set_Account(string value);
    [CompilerGeneratedAttribute]
public List`1<ChangeAddress> get_ChangeAddresses();
    [CompilerGeneratedAttribute]
public void set_ChangeAddresses(List`1<ChangeAddress> value);
}
public enum NBitcoin.RPC.AddressType : Enum {
    public int value__;
    public static AddressType Legacy;
    public static AddressType P2SHSegwit;
    public static AddressType Bech32;
}
public class NBitcoin.RPC.BlockchainInfo : object {
    [CompilerGeneratedAttribute]
private Network <Chain>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <Blocks>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <Headers>k__BackingField;
    [CompilerGeneratedAttribute]
private uint256 <BestBlockHash>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <Difficulty>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <MedianTime>k__BackingField;
    [CompilerGeneratedAttribute]
private float <VerificationProgress>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <InitialBlockDownload>k__BackingField;
    [CompilerGeneratedAttribute]
private uint256 <ChainWork>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <SizeOnDisk>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Pruned>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<SoftFork> <SoftForks>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<Bip9SoftFork> <Bip9SoftForks>k__BackingField;
    public Network Chain { get; public set; }
    public ulong Blocks { get; public set; }
    public ulong Headers { get; public set; }
    public uint256 BestBlockHash { get; public set; }
    public ulong Difficulty { get; public set; }
    public ulong MedianTime { get; public set; }
    public float VerificationProgress { get; public set; }
    public bool InitialBlockDownload { get; public set; }
    public uint256 ChainWork { get; public set; }
    public ulong SizeOnDisk { get; public set; }
    public bool Pruned { get; public set; }
    [ObsoleteAttribute]
public List`1<SoftFork> SoftForks { get; public set; }
    [ObsoleteAttribute]
public List`1<Bip9SoftFork> Bip9SoftForks { get; public set; }
    [CompilerGeneratedAttribute]
public Network get_Chain();
    [CompilerGeneratedAttribute]
public void set_Chain(Network value);
    [CompilerGeneratedAttribute]
public ulong get_Blocks();
    [CompilerGeneratedAttribute]
public void set_Blocks(ulong value);
    [CompilerGeneratedAttribute]
public ulong get_Headers();
    [CompilerGeneratedAttribute]
public void set_Headers(ulong value);
    [CompilerGeneratedAttribute]
public uint256 get_BestBlockHash();
    [CompilerGeneratedAttribute]
public void set_BestBlockHash(uint256 value);
    [CompilerGeneratedAttribute]
public ulong get_Difficulty();
    [CompilerGeneratedAttribute]
public void set_Difficulty(ulong value);
    [CompilerGeneratedAttribute]
public ulong get_MedianTime();
    [CompilerGeneratedAttribute]
public void set_MedianTime(ulong value);
    [CompilerGeneratedAttribute]
public float get_VerificationProgress();
    [CompilerGeneratedAttribute]
public void set_VerificationProgress(float value);
    [CompilerGeneratedAttribute]
public bool get_InitialBlockDownload();
    [CompilerGeneratedAttribute]
public void set_InitialBlockDownload(bool value);
    [CompilerGeneratedAttribute]
public uint256 get_ChainWork();
    [CompilerGeneratedAttribute]
public void set_ChainWork(uint256 value);
    [CompilerGeneratedAttribute]
public ulong get_SizeOnDisk();
    [CompilerGeneratedAttribute]
public void set_SizeOnDisk(ulong value);
    [CompilerGeneratedAttribute]
public bool get_Pruned();
    [CompilerGeneratedAttribute]
public void set_Pruned(bool value);
    [CompilerGeneratedAttribute]
public List`1<SoftFork> get_SoftForks();
    [CompilerGeneratedAttribute]
public void set_SoftForks(List`1<SoftFork> value);
    [CompilerGeneratedAttribute]
public List`1<Bip9SoftFork> get_Bip9SoftForks();
    [CompilerGeneratedAttribute]
public void set_Bip9SoftForks(List`1<Bip9SoftFork> value);
}
internal static class NBitcoin.RPC.BlockExplorerFormatter : object {
    public static string ToString(Transaction transaction);
    private static void WritePropertyValue(JsonWriter writer, string name, TValue value);
    internal static void WriteTransaction(JsonTextWriter writer, Transaction tx);
}
public class NBitcoin.RPC.BlockFilter : object {
    [CompilerGeneratedAttribute]
private GolombRiceFilter <Filter>k__BackingField;
    [CompilerGeneratedAttribute]
private uint256 <Header>k__BackingField;
    public GolombRiceFilter Filter { get; }
    public uint256 Header { get; }
    public BlockFilter(GolombRiceFilter filter, uint256 header);
    [CompilerGeneratedAttribute]
public GolombRiceFilter get_Filter();
    [CompilerGeneratedAttribute]
public uint256 get_Header();
}
public class NBitcoin.RPC.BlockStats : object {
    [CompilerGeneratedAttribute]
private Money <AvgFee>k__BackingField;
    [CompilerGeneratedAttribute]
private Money <AvgFeeRate>k__BackingField;
    [CompilerGeneratedAttribute]
private int <AvgTxSize>k__BackingField;
    [CompilerGeneratedAttribute]
private uint256 <BlockHash>k__BackingField;
    [CompilerGeneratedAttribute]
private Money[] <FeeRatePercentiles>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Height>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Ins>k__BackingField;
    [CompilerGeneratedAttribute]
private Money <MaxFee>k__BackingField;
    [CompilerGeneratedAttribute]
private Money <MaxFeeRate>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxTxSize>k__BackingField;
    [CompilerGeneratedAttribute]
private Money <MedianFee>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <MedianTime>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MedianTxSize>k__BackingField;
    [CompilerGeneratedAttribute]
private Money <MinFee>k__BackingField;
    [CompilerGeneratedAttribute]
private Money <MinFeeRate>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MinTxSize>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Outs>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Subsidy>k__BackingField;
    [CompilerGeneratedAttribute]
private long <SWTotalSize>k__BackingField;
    [CompilerGeneratedAttribute]
private long <SWTotalWeight>k__BackingField;
    [CompilerGeneratedAttribute]
private int <SWTxs>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <Time>k__BackingField;
    [CompilerGeneratedAttribute]
private long <TotalOut>k__BackingField;
    [CompilerGeneratedAttribute]
private long <TotalSize>k__BackingField;
    [CompilerGeneratedAttribute]
private long <TotalWeight>k__BackingField;
    [CompilerGeneratedAttribute]
private Money <TotalFee>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Txs>k__BackingField;
    [CompilerGeneratedAttribute]
private int <UTXOIncrease>k__BackingField;
    [CompilerGeneratedAttribute]
private int <UTXOSizeInc>k__BackingField;
    public Money AvgFee { get; public set; }
    public Money AvgFeeRate { get; public set; }
    public int AvgTxSize { get; public set; }
    public uint256 BlockHash { get; public set; }
    public Money[] FeeRatePercentiles { get; public set; }
    public int Height { get; public set; }
    public int Ins { get; public set; }
    public Money MaxFee { get; public set; }
    public Money MaxFeeRate { get; public set; }
    public int MaxTxSize { get; public set; }
    public Money MedianFee { get; public set; }
    public DateTimeOffset MedianTime { get; public set; }
    public int MedianTxSize { get; public set; }
    public Money MinFee { get; public set; }
    public Money MinFeeRate { get; public set; }
    public int MinTxSize { get; public set; }
    public int Outs { get; public set; }
    public long Subsidy { get; public set; }
    public long SWTotalSize { get; public set; }
    public long SWTotalWeight { get; public set; }
    public int SWTxs { get; public set; }
    public DateTimeOffset Time { get; public set; }
    public long TotalOut { get; public set; }
    public long TotalSize { get; public set; }
    public long TotalWeight { get; public set; }
    public Money TotalFee { get; public set; }
    public int Txs { get; public set; }
    public int UTXOIncrease { get; public set; }
    public int UTXOSizeInc { get; public set; }
    [CompilerGeneratedAttribute]
public Money get_AvgFee();
    [CompilerGeneratedAttribute]
public void set_AvgFee(Money value);
    [CompilerGeneratedAttribute]
public Money get_AvgFeeRate();
    [CompilerGeneratedAttribute]
public void set_AvgFeeRate(Money value);
    [CompilerGeneratedAttribute]
public int get_AvgTxSize();
    [CompilerGeneratedAttribute]
public void set_AvgTxSize(int value);
    [CompilerGeneratedAttribute]
public uint256 get_BlockHash();
    [CompilerGeneratedAttribute]
public void set_BlockHash(uint256 value);
    [CompilerGeneratedAttribute]
public Money[] get_FeeRatePercentiles();
    [CompilerGeneratedAttribute]
public void set_FeeRatePercentiles(Money[] value);
    [CompilerGeneratedAttribute]
public int get_Height();
    [CompilerGeneratedAttribute]
public void set_Height(int value);
    [CompilerGeneratedAttribute]
public int get_Ins();
    [CompilerGeneratedAttribute]
public void set_Ins(int value);
    [CompilerGeneratedAttribute]
public Money get_MaxFee();
    [CompilerGeneratedAttribute]
public void set_MaxFee(Money value);
    [CompilerGeneratedAttribute]
public Money get_MaxFeeRate();
    [CompilerGeneratedAttribute]
public void set_MaxFeeRate(Money value);
    [CompilerGeneratedAttribute]
public int get_MaxTxSize();
    [CompilerGeneratedAttribute]
public void set_MaxTxSize(int value);
    [CompilerGeneratedAttribute]
public Money get_MedianFee();
    [CompilerGeneratedAttribute]
public void set_MedianFee(Money value);
    [CompilerGeneratedAttribute]
public DateTimeOffset get_MedianTime();
    [CompilerGeneratedAttribute]
public void set_MedianTime(DateTimeOffset value);
    [CompilerGeneratedAttribute]
public int get_MedianTxSize();
    [CompilerGeneratedAttribute]
public void set_MedianTxSize(int value);
    [CompilerGeneratedAttribute]
public Money get_MinFee();
    [CompilerGeneratedAttribute]
public void set_MinFee(Money value);
    [CompilerGeneratedAttribute]
public Money get_MinFeeRate();
    [CompilerGeneratedAttribute]
public void set_MinFeeRate(Money value);
    [CompilerGeneratedAttribute]
public int get_MinTxSize();
    [CompilerGeneratedAttribute]
public void set_MinTxSize(int value);
    [CompilerGeneratedAttribute]
public int get_Outs();
    [CompilerGeneratedAttribute]
public void set_Outs(int value);
    [CompilerGeneratedAttribute]
public long get_Subsidy();
    [CompilerGeneratedAttribute]
public void set_Subsidy(long value);
    [CompilerGeneratedAttribute]
public long get_SWTotalSize();
    [CompilerGeneratedAttribute]
public void set_SWTotalSize(long value);
    [CompilerGeneratedAttribute]
public long get_SWTotalWeight();
    [CompilerGeneratedAttribute]
public void set_SWTotalWeight(long value);
    [CompilerGeneratedAttribute]
public int get_SWTxs();
    [CompilerGeneratedAttribute]
public void set_SWTxs(int value);
    [CompilerGeneratedAttribute]
public DateTimeOffset get_Time();
    [CompilerGeneratedAttribute]
public void set_Time(DateTimeOffset value);
    [CompilerGeneratedAttribute]
public long get_TotalOut();
    [CompilerGeneratedAttribute]
public void set_TotalOut(long value);
    [CompilerGeneratedAttribute]
public long get_TotalSize();
    [CompilerGeneratedAttribute]
public void set_TotalSize(long value);
    [CompilerGeneratedAttribute]
public long get_TotalWeight();
    [CompilerGeneratedAttribute]
public void set_TotalWeight(long value);
    [CompilerGeneratedAttribute]
public Money get_TotalFee();
    [CompilerGeneratedAttribute]
public void set_TotalFee(Money value);
    [CompilerGeneratedAttribute]
public int get_Txs();
    [CompilerGeneratedAttribute]
public void set_Txs(int value);
    [CompilerGeneratedAttribute]
public int get_UTXOIncrease();
    [CompilerGeneratedAttribute]
public void set_UTXOIncrease(int value);
    [CompilerGeneratedAttribute]
public int get_UTXOSizeInc();
    [CompilerGeneratedAttribute]
public void set_UTXOSizeInc(int value);
}
public class NBitcoin.RPC.BumpResponse : object {
    [CompilerGeneratedAttribute]
private uint256 <TransactionId>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <OriginalFee>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <Fee>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <Errors>k__BackingField;
    public uint256 TransactionId { get; public set; }
    public ulong OriginalFee { get; public set; }
    public ulong Fee { get; public set; }
    public List`1<string> Errors { get; public set; }
    [CompilerGeneratedAttribute]
public uint256 get_TransactionId();
    [CompilerGeneratedAttribute]
public void set_TransactionId(uint256 value);
    [CompilerGeneratedAttribute]
public ulong get_OriginalFee();
    [CompilerGeneratedAttribute]
public void set_OriginalFee(ulong value);
    [CompilerGeneratedAttribute]
public ulong get_Fee();
    [CompilerGeneratedAttribute]
public void set_Fee(ulong value);
    [CompilerGeneratedAttribute]
public List`1<string> get_Errors();
    [CompilerGeneratedAttribute]
public void set_Errors(List`1<string> value);
}
public class NBitcoin.RPC.ChainInfo : object {
    [CompilerGeneratedAttribute]
private string <Chain>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Blocks>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Headers>k__BackingField;
    [CompilerGeneratedAttribute]
private uint256 <BestBlockHash>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Difficulty>k__BackingField;
    [CompilerGeneratedAttribute]
private decimal <VerificationProgress>k__BackingField;
    [CompilerGeneratedAttribute]
private uint256 <ChainWork>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsPruned>k__BackingField;
    public string Chain { get; internal set; }
    public int Blocks { get; internal set; }
    public int Headers { get; internal set; }
    public uint256 BestBlockHash { get; internal set; }
    public int Difficulty { get; internal set; }
    public decimal VerificationProgress { get; internal set; }
    public uint256 ChainWork { get; internal set; }
    public bool IsPruned { get; internal set; }
    [CompilerGeneratedAttribute]
public string get_Chain();
    [CompilerGeneratedAttribute]
internal void set_Chain(string value);
    [CompilerGeneratedAttribute]
public int get_Blocks();
    [CompilerGeneratedAttribute]
internal void set_Blocks(int value);
    [CompilerGeneratedAttribute]
public int get_Headers();
    [CompilerGeneratedAttribute]
internal void set_Headers(int value);
    [CompilerGeneratedAttribute]
public uint256 get_BestBlockHash();
    [CompilerGeneratedAttribute]
internal void set_BestBlockHash(uint256 value);
    [CompilerGeneratedAttribute]
public int get_Difficulty();
    [CompilerGeneratedAttribute]
internal void set_Difficulty(int value);
    [CompilerGeneratedAttribute]
public decimal get_VerificationProgress();
    [CompilerGeneratedAttribute]
internal void set_VerificationProgress(decimal value);
    [CompilerGeneratedAttribute]
public uint256 get_ChainWork();
    [CompilerGeneratedAttribute]
internal void set_ChainWork(uint256 value);
    [CompilerGeneratedAttribute]
public bool get_IsPruned();
    [CompilerGeneratedAttribute]
internal void set_IsPruned(bool value);
}
public class NBitcoin.RPC.ChangeAddress : object {
    [CompilerGeneratedAttribute]
private Money <Amount>k__BackingField;
    [CompilerGeneratedAttribute]
private BitcoinAddress <Address>k__BackingField;
    public Money Amount { get; public set; }
    public BitcoinAddress Address { get; public set; }
    [CompilerGeneratedAttribute]
public Money get_Amount();
    [CompilerGeneratedAttribute]
public void set_Amount(Money value);
    [CompilerGeneratedAttribute]
public BitcoinAddress get_Address();
    [CompilerGeneratedAttribute]
public void set_Address(BitcoinAddress value);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class NBitcoin.RPC.CreateWalletOptions : object {
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <DisablePrivateKeys>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <Blank>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Passphrase>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <AvoidReuse>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <Descriptors>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <LoadOnStartup>k__BackingField;
    public Nullable`1<bool> DisablePrivateKeys { get; public set; }
    public Nullable`1<bool> Blank { get; public set; }
    public string Passphrase { get; public set; }
    public Nullable`1<bool> AvoidReuse { get; public set; }
    public Nullable`1<bool> Descriptors { get; public set; }
    public Nullable`1<bool> LoadOnStartup { get; public set; }
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_DisablePrivateKeys();
    [CompilerGeneratedAttribute]
public void set_DisablePrivateKeys(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_Blank();
    [CompilerGeneratedAttribute]
public void set_Blank(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public string get_Passphrase();
    [CompilerGeneratedAttribute]
public void set_Passphrase(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_AvoidReuse();
    [CompilerGeneratedAttribute]
public void set_AvoidReuse(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_Descriptors();
    [CompilerGeneratedAttribute]
public void set_Descriptors(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_LoadOnStartup();
    [CompilerGeneratedAttribute]
public void set_LoadOnStartup(Nullable`1<bool> value);
}
public enum NBitcoin.RPC.EstimateSmartFeeMode : Enum {
    public int value__;
    public static EstimateSmartFeeMode Economical;
    public static EstimateSmartFeeMode Conservative;
}
public class NBitcoin.RPC.EstimateSmartFeeResponse : object {
    [CompilerGeneratedAttribute]
private FeeRate <FeeRate>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Blocks>k__BackingField;
    public FeeRate FeeRate { get; public set; }
    public int Blocks { get; public set; }
    [CompilerGeneratedAttribute]
public FeeRate get_FeeRate();
    [CompilerGeneratedAttribute]
public void set_FeeRate(FeeRate value);
    [CompilerGeneratedAttribute]
public int get_Blocks();
    [CompilerGeneratedAttribute]
public void set_Blocks(int value);
}
public class NBitcoin.RPC.FundRawTransactionOptions : object {
    [CompilerGeneratedAttribute]
private BitcoinAddress <ChangeAddress>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <ChangePosition>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludeWatching>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <LockUnspents>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <ReserveChangeKey>k__BackingField;
    [CompilerGeneratedAttribute]
private FeeRate <FeeRate>k__BackingField;
    [CompilerGeneratedAttribute]
private Int32[] <SubtractFeeFromOutputs>k__BackingField;
    public BitcoinAddress ChangeAddress { get; public set; }
    public Nullable`1<int> ChangePosition { get; public set; }
    public bool IncludeWatching { get; public set; }
    public bool LockUnspents { get; public set; }
    public Nullable`1<bool> ReserveChangeKey { get; public set; }
    public FeeRate FeeRate { get; public set; }
    public Int32[] SubtractFeeFromOutputs { get; public set; }
    [CompilerGeneratedAttribute]
public BitcoinAddress get_ChangeAddress();
    [CompilerGeneratedAttribute]
public void set_ChangeAddress(BitcoinAddress value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_ChangePosition();
    [CompilerGeneratedAttribute]
public void set_ChangePosition(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public bool get_IncludeWatching();
    [CompilerGeneratedAttribute]
public void set_IncludeWatching(bool value);
    [CompilerGeneratedAttribute]
public bool get_LockUnspents();
    [CompilerGeneratedAttribute]
public void set_LockUnspents(bool value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_ReserveChangeKey();
    [CompilerGeneratedAttribute]
public void set_ReserveChangeKey(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public FeeRate get_FeeRate();
    [CompilerGeneratedAttribute]
public void set_FeeRate(FeeRate value);
    [CompilerGeneratedAttribute]
public Int32[] get_SubtractFeeFromOutputs();
    [CompilerGeneratedAttribute]
public void set_SubtractFeeFromOutputs(Int32[] value);
}
public class NBitcoin.RPC.FundRawTransactionResponse : object {
    [CompilerGeneratedAttribute]
private Transaction <Transaction>k__BackingField;
    [CompilerGeneratedAttribute]
private Money <Fee>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ChangePos>k__BackingField;
    public Transaction Transaction { get; public set; }
    public Money Fee { get; public set; }
    public int ChangePos { get; public set; }
    [CompilerGeneratedAttribute]
public Transaction get_Transaction();
    [CompilerGeneratedAttribute]
public void set_Transaction(Transaction value);
    [CompilerGeneratedAttribute]
public Money get_Fee();
    [CompilerGeneratedAttribute]
public void set_Fee(Money value);
    [CompilerGeneratedAttribute]
public int get_ChangePos();
    [CompilerGeneratedAttribute]
public void set_ChangePos(int value);
}
public class NBitcoin.RPC.GetAddressInfoResponse : GetAddressInfoScriptInfoResponse {
    [CompilerGeneratedAttribute]
private bool <IsMine>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <Solvable>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private OutputDescriptor <Descriptor>k__BackingField;
    [CompilerGeneratedAttribute]
private GetAddressInfoScriptInfoResponse <Embedded>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Label>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <IsChange>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsWatchOnly>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTimeOffset> <Timestamp>k__BackingField;
    [CompilerGeneratedAttribute]
private KeyPath <HDKeyPath>k__BackingField;
    [CompilerGeneratedAttribute]
private uint160 <HDSeedID>k__BackingField;
    [CompilerGeneratedAttribute]
private uint160 <HDMasterKeyID>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <IsCompressed>k__BackingField;
    public bool IsMine { get; private set; }
    public Nullable`1<bool> Solvable { get; private set; }
    [NullableAttribute("2")]
public OutputDescriptor Descriptor { get; private set; }
    public GetAddressInfoScriptInfoResponse Embedded { get; private set; }
    public string Label { get; private set; }
    public Nullable`1<bool> IsChange { get; private set; }
    public bool IsWatchOnly { get; private set; }
    public Nullable`1<DateTimeOffset> Timestamp { get; private set; }
    public KeyPath HDKeyPath { get; private set; }
    public uint160 HDSeedID { get; private set; }
    public uint160 HDMasterKeyID { get; private set; }
    public Nullable`1<bool> IsCompressed { get; private set; }
    [CompilerGeneratedAttribute]
public bool get_IsMine();
    [CompilerGeneratedAttribute]
private void set_IsMine(bool value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_Solvable();
    [CompilerGeneratedAttribute]
private void set_Solvable(Nullable`1<bool> value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public OutputDescriptor get_Descriptor();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private void set_Descriptor(OutputDescriptor value);
    [CompilerGeneratedAttribute]
public GetAddressInfoScriptInfoResponse get_Embedded();
    [CompilerGeneratedAttribute]
private void set_Embedded(GetAddressInfoScriptInfoResponse value);
    [CompilerGeneratedAttribute]
public string get_Label();
    [CompilerGeneratedAttribute]
private void set_Label(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_IsChange();
    [CompilerGeneratedAttribute]
private void set_IsChange(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public bool get_IsWatchOnly();
    [CompilerGeneratedAttribute]
private void set_IsWatchOnly(bool value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTimeOffset> get_Timestamp();
    [CompilerGeneratedAttribute]
private void set_Timestamp(Nullable`1<DateTimeOffset> value);
    [CompilerGeneratedAttribute]
public KeyPath get_HDKeyPath();
    [CompilerGeneratedAttribute]
private void set_HDKeyPath(KeyPath value);
    [CompilerGeneratedAttribute]
public uint160 get_HDSeedID();
    [CompilerGeneratedAttribute]
private void set_HDSeedID(uint160 value);
    [CompilerGeneratedAttribute]
public uint160 get_HDMasterKeyID();
    [CompilerGeneratedAttribute]
private void set_HDMasterKeyID(uint160 value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_IsCompressed();
    [CompilerGeneratedAttribute]
private void set_IsCompressed(Nullable`1<bool> value);
    public static GetAddressInfoResponse FromJsonResponse(JObject raw, Network network);
    public virtual GetAddressInfoResponse LoadFromJson(JObject raw, Network network);
    private static void SetSubInfo(GetAddressInfoScriptInfoResponse target, JObject raw, Network network);
}
public class NBitcoin.RPC.GetAddressInfoScriptInfoResponse : object {
    [CompilerGeneratedAttribute]
private BitcoinAddress <Address>k__BackingField;
    [CompilerGeneratedAttribute]
private Script <ScriptPubKey>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsScript>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsWitness>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <WitnessVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <WitnessProgram>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Script>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Hex>k__BackingField;
    [CompilerGeneratedAttribute]
private PubKey <PubKey>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<PubKey> <PubKeys>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<UInt32> <SigsRequired>k__BackingField;
    public BitcoinAddress Address { get; internal set; }
    public Script ScriptPubKey { get; internal set; }
    public bool IsScript { get; internal set; }
    public bool IsWitness { get; internal set; }
    public Nullable`1<int> WitnessVersion { get; internal set; }
    public string WitnessProgram { get; internal set; }
    public string Script { get; internal set; }
    public string Hex { get; internal set; }
    public PubKey PubKey { get; internal set; }
    public List`1<PubKey> PubKeys { get; internal set; }
    public Nullable`1<UInt32> SigsRequired { get; internal set; }
    [CompilerGeneratedAttribute]
public BitcoinAddress get_Address();
    [CompilerGeneratedAttribute]
internal void set_Address(BitcoinAddress value);
    [CompilerGeneratedAttribute]
public Script get_ScriptPubKey();
    [CompilerGeneratedAttribute]
internal void set_ScriptPubKey(Script value);
    [CompilerGeneratedAttribute]
public bool get_IsScript();
    [CompilerGeneratedAttribute]
internal void set_IsScript(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsWitness();
    [CompilerGeneratedAttribute]
internal void set_IsWitness(bool value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_WitnessVersion();
    [CompilerGeneratedAttribute]
internal void set_WitnessVersion(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public string get_WitnessProgram();
    [CompilerGeneratedAttribute]
internal void set_WitnessProgram(string value);
    [CompilerGeneratedAttribute]
public string get_Script();
    [CompilerGeneratedAttribute]
internal void set_Script(string value);
    [CompilerGeneratedAttribute]
public string get_Hex();
    [CompilerGeneratedAttribute]
internal void set_Hex(string value);
    [CompilerGeneratedAttribute]
public PubKey get_PubKey();
    [CompilerGeneratedAttribute]
internal void set_PubKey(PubKey value);
    [CompilerGeneratedAttribute]
public List`1<PubKey> get_PubKeys();
    [CompilerGeneratedAttribute]
internal void set_PubKeys(List`1<PubKey> value);
    [CompilerGeneratedAttribute]
public Nullable`1<UInt32> get_SigsRequired();
    [CompilerGeneratedAttribute]
internal void set_SigsRequired(Nullable`1<UInt32> value);
}
public class NBitcoin.RPC.GetBlockRPCResponse : object {
    [CompilerGeneratedAttribute]
private int <Confirmations>k__BackingField;
    [CompilerGeneratedAttribute]
private int <StrippedSize>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Size>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Weight>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Height>k__BackingField;
    [CompilerGeneratedAttribute]
private string <VersionHex>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <MedianTimeUnix>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Difficulty>k__BackingField;
    [CompilerGeneratedAttribute]
private uint256 <ChainWork>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private uint256 <NextBlockHash>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private Block <Block>k__BackingField;
    [CompilerGeneratedAttribute]
private BlockHeader <Header>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<uint256> <TxIds>k__BackingField;
    public int Confirmations { get; public set; }
    public int StrippedSize { get; public set; }
    public int Size { get; public set; }
    public int Weight { get; public set; }
    public int Height { get; public set; }
    public string VersionHex { get; public set; }
    public UInt32 MedianTimeUnix { get; public set; }
    public double Difficulty { get; public set; }
    public uint256 ChainWork { get; public set; }
    [NullableAttribute("2")]
public uint256 NextBlockHash { get; public set; }
    [NullableAttribute("2")]
public Block Block { get; public set; }
    public BlockHeader Header { get; public set; }
    public List`1<uint256> TxIds { get; public set; }
    public DateTimeOffset MedianTime { get; }
    [CompilerGeneratedAttribute]
public int get_Confirmations();
    [CompilerGeneratedAttribute]
public void set_Confirmations(int value);
    [CompilerGeneratedAttribute]
public int get_StrippedSize();
    [CompilerGeneratedAttribute]
public void set_StrippedSize(int value);
    [CompilerGeneratedAttribute]
public int get_Size();
    [CompilerGeneratedAttribute]
public void set_Size(int value);
    [CompilerGeneratedAttribute]
public int get_Weight();
    [CompilerGeneratedAttribute]
public void set_Weight(int value);
    [CompilerGeneratedAttribute]
public int get_Height();
    [CompilerGeneratedAttribute]
public void set_Height(int value);
    [CompilerGeneratedAttribute]
public string get_VersionHex();
    [CompilerGeneratedAttribute]
public void set_VersionHex(string value);
    [CompilerGeneratedAttribute]
public UInt32 get_MedianTimeUnix();
    [CompilerGeneratedAttribute]
public void set_MedianTimeUnix(UInt32 value);
    [CompilerGeneratedAttribute]
public double get_Difficulty();
    [CompilerGeneratedAttribute]
public void set_Difficulty(double value);
    [CompilerGeneratedAttribute]
public uint256 get_ChainWork();
    [CompilerGeneratedAttribute]
public void set_ChainWork(uint256 value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public uint256 get_NextBlockHash();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_NextBlockHash(uint256 value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public Block get_Block();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_Block(Block value);
    [CompilerGeneratedAttribute]
public BlockHeader get_Header();
    [CompilerGeneratedAttribute]
public void set_Header(BlockHeader value);
    [CompilerGeneratedAttribute]
public List`1<uint256> get_TxIds();
    [CompilerGeneratedAttribute]
public void set_TxIds(List`1<uint256> value);
    public DateTimeOffset get_MedianTime();
}
public enum NBitcoin.RPC.GetBlockVerbosity : Enum {
    public int value__;
    public static GetBlockVerbosity WithOnlyTxId;
    public static GetBlockVerbosity WithFullTx;
}
public class NBitcoin.RPC.GetNewAddressRequest : object {
    [CompilerGeneratedAttribute]
private string <Label>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<AddressType> <AddressType>k__BackingField;
    public string Label { get; public set; }
    public Nullable`1<AddressType> AddressType { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Label();
    [CompilerGeneratedAttribute]
public void set_Label(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<AddressType> get_AddressType();
    [CompilerGeneratedAttribute]
public void set_AddressType(Nullable`1<AddressType> value);
}
public class NBitcoin.RPC.GetTxOutResponse : object {
    [CompilerGeneratedAttribute]
private uint256 <BestBlock>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Confirmations>k__BackingField;
    [CompilerGeneratedAttribute]
private TxOut <TxOut>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsCoinBase>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ScriptPubKeyType>k__BackingField;
    public uint256 BestBlock { get; public set; }
    public int Confirmations { get; public set; }
    public TxOut TxOut { get; public set; }
    public bool IsCoinBase { get; public set; }
    public string ScriptPubKeyType { get; public set; }
    [CompilerGeneratedAttribute]
public uint256 get_BestBlock();
    [CompilerGeneratedAttribute]
public void set_BestBlock(uint256 value);
    [CompilerGeneratedAttribute]
public int get_Confirmations();
    [CompilerGeneratedAttribute]
public void set_Confirmations(int value);
    [CompilerGeneratedAttribute]
public TxOut get_TxOut();
    [CompilerGeneratedAttribute]
public void set_TxOut(TxOut value);
    [CompilerGeneratedAttribute]
public bool get_IsCoinBase();
    [CompilerGeneratedAttribute]
public void set_IsCoinBase(bool value);
    [CompilerGeneratedAttribute]
public string get_ScriptPubKeyType();
    [CompilerGeneratedAttribute]
public void set_ScriptPubKeyType(string value);
}
public class NBitcoin.RPC.GetTxOutSetInfoResponse : object {
    [CompilerGeneratedAttribute]
private int <Height>k__BackingField;
    [CompilerGeneratedAttribute]
private uint256 <Bestblock>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Transactions>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Txouts>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Bogosize>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HashSerialized2>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HashSerialized3>k__BackingField;
    [CompilerGeneratedAttribute]
private long <DiskSize>k__BackingField;
    [CompilerGeneratedAttribute]
private Money <TotalAmount>k__BackingField;
    public int Height { get; public set; }
    public uint256 Bestblock { get; public set; }
    public long Transactions { get; public set; }
    public long Txouts { get; public set; }
    public long Bogosize { get; public set; }
    public string HashSerialized { get; }
    [ObsoleteAttribute("Use HashSerialized instead")]
public string HashSerialized2 { get; public set; }
    public string HashSerialized3 { get; public set; }
    public long DiskSize { get; public set; }
    public Money TotalAmount { get; public set; }
    [CompilerGeneratedAttribute]
public int get_Height();
    [CompilerGeneratedAttribute]
public void set_Height(int value);
    [CompilerGeneratedAttribute]
public uint256 get_Bestblock();
    [CompilerGeneratedAttribute]
public void set_Bestblock(uint256 value);
    [CompilerGeneratedAttribute]
public long get_Transactions();
    [CompilerGeneratedAttribute]
public void set_Transactions(long value);
    [CompilerGeneratedAttribute]
public long get_Txouts();
    [CompilerGeneratedAttribute]
public void set_Txouts(long value);
    [CompilerGeneratedAttribute]
public long get_Bogosize();
    [CompilerGeneratedAttribute]
public void set_Bogosize(long value);
    public string get_HashSerialized();
    [CompilerGeneratedAttribute]
public string get_HashSerialized2();
    [CompilerGeneratedAttribute]
public void set_HashSerialized2(string value);
    [CompilerGeneratedAttribute]
public string get_HashSerialized3();
    [CompilerGeneratedAttribute]
public void set_HashSerialized3(string value);
    [CompilerGeneratedAttribute]
public long get_DiskSize();
    [CompilerGeneratedAttribute]
public void set_DiskSize(long value);
    [CompilerGeneratedAttribute]
public Money get_TotalAmount();
    [CompilerGeneratedAttribute]
public void set_TotalAmount(Money value);
}
[JsonObjectAttribute]
public class NBitcoin.RPC.ImportMultiAddress : object {
    [CompilerGeneratedAttribute]
private ScriptPubKeyObject <ScriptPubKey>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTimeOffset> <Timestamp>k__BackingField;
    [CompilerGeneratedAttribute]
private Script <RedeemScript>k__BackingField;
    [CompilerGeneratedAttribute]
private PubKey[] <PubKeys>k__BackingField;
    [CompilerGeneratedAttribute]
private BitcoinSecret[] <Keys>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <Internal>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <WatchOnly>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Label>k__BackingField;
    [CompilerGeneratedAttribute]
private OutputDescriptor <Desc>k__BackingField;
    [CompilerGeneratedAttribute]
private Int32[] <Ranges>k__BackingField;
    [JsonPropertyAttribute]
[JsonConverterAttribute("NBitcoin.RPC.ImportMultiScriptPubKeyConverter")]
public ScriptPubKeyObject ScriptPubKey { get; public set; }
    [JsonPropertyAttribute("timestamp")]
public Nullable`1<DateTimeOffset> Timestamp { get; public set; }
    [JsonPropertyAttribute]
public Script RedeemScript { get; public set; }
    [JsonPropertyAttribute]
public PubKey[] PubKeys { get; public set; }
    [JsonPropertyAttribute]
public BitcoinSecret[] Keys { get; public set; }
    [JsonPropertyAttribute]
public Nullable`1<bool> Internal { get; public set; }
    [JsonPropertyAttribute]
public Nullable`1<bool> WatchOnly { get; public set; }
    [JsonPropertyAttribute]
public string Label { get; public set; }
    [JsonPropertyAttribute]
public OutputDescriptor Desc { get; public set; }
    [JsonPropertyAttribute]
public Int32[] Ranges { get; public set; }
    [JsonIgnoreAttribute]
unknown int Range {public set; }
    [CompilerGeneratedAttribute]
public ScriptPubKeyObject get_ScriptPubKey();
    [CompilerGeneratedAttribute]
public void set_ScriptPubKey(ScriptPubKeyObject value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTimeOffset> get_Timestamp();
    [CompilerGeneratedAttribute]
public void set_Timestamp(Nullable`1<DateTimeOffset> value);
    [CompilerGeneratedAttribute]
public Script get_RedeemScript();
    [CompilerGeneratedAttribute]
public void set_RedeemScript(Script value);
    [CompilerGeneratedAttribute]
public PubKey[] get_PubKeys();
    [CompilerGeneratedAttribute]
public void set_PubKeys(PubKey[] value);
    [CompilerGeneratedAttribute]
public BitcoinSecret[] get_Keys();
    [CompilerGeneratedAttribute]
public void set_Keys(BitcoinSecret[] value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_Internal();
    [CompilerGeneratedAttribute]
public void set_Internal(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_WatchOnly();
    [CompilerGeneratedAttribute]
public void set_WatchOnly(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public string get_Label();
    [CompilerGeneratedAttribute]
public void set_Label(string value);
    [CompilerGeneratedAttribute]
public OutputDescriptor get_Desc();
    [CompilerGeneratedAttribute]
public void set_Desc(OutputDescriptor value);
    [CompilerGeneratedAttribute]
public Int32[] get_Ranges();
    [CompilerGeneratedAttribute]
public void set_Ranges(Int32[] value);
    public void set_Range(int value);
}
internal class NBitcoin.RPC.ImportMultiScriptPubKeyConverter : JsonConverter {
    public virtual bool CanConvert(Type objectType);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
}
public class NBitcoin.RPC.ListUnspentOptions : object {
    [CompilerGeneratedAttribute]
private Nullable`1<decimal> <MinimumAmount>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<decimal> <MaximumAmount>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MaximumCount>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<decimal> <MinimumSumAmount>k__BackingField;
    public Nullable`1<decimal> MinimumAmount { get; public set; }
    public Nullable`1<decimal> MaximumAmount { get; public set; }
    public Nullable`1<int> MaximumCount { get; public set; }
    public Nullable`1<decimal> MinimumSumAmount { get; public set; }
    [CompilerGeneratedAttribute]
public Nullable`1<decimal> get_MinimumAmount();
    [CompilerGeneratedAttribute]
public void set_MinimumAmount(Nullable`1<decimal> value);
    [CompilerGeneratedAttribute]
public Nullable`1<decimal> get_MaximumAmount();
    [CompilerGeneratedAttribute]
public void set_MaximumAmount(Nullable`1<decimal> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_MaximumCount();
    [CompilerGeneratedAttribute]
public void set_MaximumCount(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<decimal> get_MinimumSumAmount();
    [CompilerGeneratedAttribute]
public void set_MinimumSumAmount(Nullable`1<decimal> value);
}
public class NBitcoin.RPC.MempoolAcceptResult : object {
    [CompilerGeneratedAttribute]
private uint256 <TxId>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsAllowed>k__BackingField;
    [CompilerGeneratedAttribute]
private RejectCode <RejectCode>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RejectReason>k__BackingField;
    public uint256 TxId { get; internal set; }
    public bool IsAllowed { get; internal set; }
    public RejectCode RejectCode { get; internal set; }
    public string RejectReason { get; internal set; }
    [CompilerGeneratedAttribute]
public uint256 get_TxId();
    [CompilerGeneratedAttribute]
internal void set_TxId(uint256 value);
    [CompilerGeneratedAttribute]
public bool get_IsAllowed();
    [CompilerGeneratedAttribute]
internal void set_IsAllowed(bool value);
    [CompilerGeneratedAttribute]
public RejectCode get_RejectCode();
    [CompilerGeneratedAttribute]
internal void set_RejectCode(RejectCode value);
    [CompilerGeneratedAttribute]
public string get_RejectReason();
    [CompilerGeneratedAttribute]
internal void set_RejectReason(string value);
}
public class NBitcoin.RPC.MempoolEntry : object {
    [CompilerGeneratedAttribute]
private uint256 <TransactionId>k__BackingField;
    [CompilerGeneratedAttribute]
private int <VirtualSizeBytes>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <Time>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Height>k__BackingField;
    [CompilerGeneratedAttribute]
private int <DescendantCount>k__BackingField;
    [CompilerGeneratedAttribute]
private int <DescendantVirtualSizeBytes>k__BackingField;
    [CompilerGeneratedAttribute]
private int <AncestorCount>k__BackingField;
    [CompilerGeneratedAttribute]
private int <AncestorVirtualSizeBytes>k__BackingField;
    [CompilerGeneratedAttribute]
private uint256 <TransactionIdWithWitness>k__BackingField;
    [CompilerGeneratedAttribute]
private Money <BaseFee>k__BackingField;
    [CompilerGeneratedAttribute]
private Money <ModifiedFee>k__BackingField;
    [CompilerGeneratedAttribute]
private Money <AncestorFees>k__BackingField;
    [CompilerGeneratedAttribute]
private Money <DescendantFees>k__BackingField;
    [CompilerGeneratedAttribute]
private uint256[] <Depends>k__BackingField;
    [CompilerGeneratedAttribute]
private uint256[] <SpentBy>k__BackingField;
    public uint256 TransactionId { get; public set; }
    public int VirtualSizeBytes { get; public set; }
    public DateTimeOffset Time { get; public set; }
    public int Height { get; public set; }
    public int DescendantCount { get; public set; }
    public int DescendantVirtualSizeBytes { get; public set; }
    public int AncestorCount { get; public set; }
    public int AncestorVirtualSizeBytes { get; public set; }
    public uint256 TransactionIdWithWitness { get; public set; }
    public Money BaseFee { get; public set; }
    public Money ModifiedFee { get; public set; }
    public Money AncestorFees { get; public set; }
    public Money DescendantFees { get; public set; }
    public uint256[] Depends { get; public set; }
    public uint256[] SpentBy { get; public set; }
    [CompilerGeneratedAttribute]
public uint256 get_TransactionId();
    [CompilerGeneratedAttribute]
public void set_TransactionId(uint256 value);
    [CompilerGeneratedAttribute]
public int get_VirtualSizeBytes();
    [CompilerGeneratedAttribute]
public void set_VirtualSizeBytes(int value);
    [CompilerGeneratedAttribute]
public DateTimeOffset get_Time();
    [CompilerGeneratedAttribute]
public void set_Time(DateTimeOffset value);
    [CompilerGeneratedAttribute]
public int get_Height();
    [CompilerGeneratedAttribute]
public void set_Height(int value);
    [CompilerGeneratedAttribute]
public int get_DescendantCount();
    [CompilerGeneratedAttribute]
public void set_DescendantCount(int value);
    [CompilerGeneratedAttribute]
public int get_DescendantVirtualSizeBytes();
    [CompilerGeneratedAttribute]
public void set_DescendantVirtualSizeBytes(int value);
    [CompilerGeneratedAttribute]
public int get_AncestorCount();
    [CompilerGeneratedAttribute]
public void set_AncestorCount(int value);
    [CompilerGeneratedAttribute]
public int get_AncestorVirtualSizeBytes();
    [CompilerGeneratedAttribute]
public void set_AncestorVirtualSizeBytes(int value);
    [CompilerGeneratedAttribute]
public uint256 get_TransactionIdWithWitness();
    [CompilerGeneratedAttribute]
public void set_TransactionIdWithWitness(uint256 value);
    [CompilerGeneratedAttribute]
public Money get_BaseFee();
    [CompilerGeneratedAttribute]
public void set_BaseFee(Money value);
    [CompilerGeneratedAttribute]
public Money get_ModifiedFee();
    [CompilerGeneratedAttribute]
public void set_ModifiedFee(Money value);
    [CompilerGeneratedAttribute]
public Money get_AncestorFees();
    [CompilerGeneratedAttribute]
public void set_AncestorFees(Money value);
    [CompilerGeneratedAttribute]
public Money get_DescendantFees();
    [CompilerGeneratedAttribute]
public void set_DescendantFees(Money value);
    [CompilerGeneratedAttribute]
public uint256[] get_Depends();
    [CompilerGeneratedAttribute]
public void set_Depends(uint256[] value);
    [CompilerGeneratedAttribute]
public uint256[] get_SpentBy();
    [CompilerGeneratedAttribute]
public void set_SpentBy(uint256[] value);
}
public class NBitcoin.RPC.NoEstimationException : Exception {
    public NoEstimationException(int nblock);
}
public class NBitcoin.RPC.RawTransactionInfo : object {
    [CompilerGeneratedAttribute]
private Transaction <Transaction>k__BackingField;
    [CompilerGeneratedAttribute]
private uint256 <TransactionId>k__BackingField;
    [CompilerGeneratedAttribute]
private uint256 <Hash>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <Size>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <VirtualSize>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private LockTime <LockTime>k__BackingField;
    [CompilerGeneratedAttribute]
private uint256 <BlockHash>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <Confirmations>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTimeOffset> <TransactionTime>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTimeOffset> <BlockTime>k__BackingField;
    public Transaction Transaction { get; internal set; }
    public uint256 TransactionId { get; internal set; }
    public uint256 Hash { get; internal set; }
    public UInt32 Size { get; internal set; }
    public UInt32 VirtualSize { get; internal set; }
    public UInt32 Version { get; internal set; }
    public LockTime LockTime { get; internal set; }
    public uint256 BlockHash { get; internal set; }
    public UInt32 Confirmations { get; internal set; }
    public Nullable`1<DateTimeOffset> TransactionTime { get; internal set; }
    public Nullable`1<DateTimeOffset> BlockTime { get; internal set; }
    [CompilerGeneratedAttribute]
public Transaction get_Transaction();
    [CompilerGeneratedAttribute]
internal void set_Transaction(Transaction value);
    [CompilerGeneratedAttribute]
public uint256 get_TransactionId();
    [CompilerGeneratedAttribute]
internal void set_TransactionId(uint256 value);
    [CompilerGeneratedAttribute]
public uint256 get_Hash();
    [CompilerGeneratedAttribute]
internal void set_Hash(uint256 value);
    [CompilerGeneratedAttribute]
public UInt32 get_Size();
    [CompilerGeneratedAttribute]
internal void set_Size(UInt32 value);
    [CompilerGeneratedAttribute]
public UInt32 get_VirtualSize();
    [CompilerGeneratedAttribute]
internal void set_VirtualSize(UInt32 value);
    [CompilerGeneratedAttribute]
public UInt32 get_Version();
    [CompilerGeneratedAttribute]
internal void set_Version(UInt32 value);
    [CompilerGeneratedAttribute]
public LockTime get_LockTime();
    [CompilerGeneratedAttribute]
internal void set_LockTime(LockTime value);
    [CompilerGeneratedAttribute]
public uint256 get_BlockHash();
    [CompilerGeneratedAttribute]
internal void set_BlockHash(uint256 value);
    [CompilerGeneratedAttribute]
public UInt32 get_Confirmations();
    [CompilerGeneratedAttribute]
internal void set_Confirmations(UInt32 value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTimeOffset> get_TransactionTime();
    [CompilerGeneratedAttribute]
internal void set_TransactionTime(Nullable`1<DateTimeOffset> value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTimeOffset> get_BlockTime();
    [CompilerGeneratedAttribute]
internal void set_BlockTime(Nullable`1<DateTimeOffset> value);
}
public class NBitcoin.RPC.RestApiException : Exception {
    [CompilerGeneratedAttribute]
private HttpStatusCode <HttpStatusCode>k__BackingField;
    public HttpStatusCode HttpStatusCode { get; }
    public RestApiException(string message, HttpStatusCode httpStatusCode);
    [CompilerGeneratedAttribute]
public HttpStatusCode get_HttpStatusCode();
}
public class NBitcoin.RPC.RestClient : object {
    private Uri _address;
    private Network _network;
    private static Lazy`1<HttpClient> _Shared;
    private HttpClient _HttpClient;
    public Network Network { get; }
    public HttpClient HttpClient { get; public set; }
    public RestClient(Uri address);
    public RestClient(Uri address, Network network);
    private static RestClient();
    public Network get_Network();
    [AsyncStateMachineAttribute("NBitcoin.RPC.RestClient/<GetBlockAsync>d__6")]
public sealed virtual Task`1<Block> GetBlockAsync(uint256 blockId, CancellationToken cancellationToken);
    public Block GetBlock(uint256 blockId);
    [AsyncStateMachineAttribute("NBitcoin.RPC.RestClient/<GetTransactionAsync>d__8")]
public Task`1<Transaction> GetTransactionAsync(uint256 txId);
    public Transaction GetTransaction(uint256 txId);
    [AsyncStateMachineAttribute("NBitcoin.RPC.RestClient/<GetBlockHeadersAsync>d__10")]
public Task`1<IEnumerable`1<BlockHeader>> GetBlockHeadersAsync(uint256 blockId, int count);
    public IEnumerable`1<BlockHeader> GetBlockHeaders(uint256 blockId, int count);
    [AsyncStateMachineAttribute("NBitcoin.RPC.RestClient/<GetChainInfoAsync>d__12")]
public Task`1<ChainInfo> GetChainInfoAsync();
    [AsyncStateMachineAttribute("NBitcoin.RPC.RestClient/<GetUnspentOutputsAsync>d__13")]
public Task`1<UTxOutputs> GetUnspentOutputsAsync(IEnumerable`1<OutPoint> outPoints, bool checkMempool);
    [AsyncStateMachineAttribute("NBitcoin.RPC.RestClient/<SendRequestAsync>d__14")]
public Task`1<Byte[]> SendRequestAsync(string resource, RestResponseFormat format, String[] parms);
    public HttpClient get_HttpClient();
    public void set_HttpClient(HttpClient value);
    private HttpRequestMessage BuildHttpRequest(string resource, RestResponseFormat format, String[] parms);
    private bool IsPlainText(HttpResponseMessage httpResponse);
    [AsyncStateMachineAttribute("NBitcoin.RPC.RestClient/<GetWebResponse>d__22")]
private Task`1<HttpResponseMessage> GetWebResponse(HttpRequestMessage request);
}
public enum NBitcoin.RPC.RestResponseFormat : Enum {
    public int value__;
    public static RestResponseFormat Bin;
    public static RestResponseFormat Hex;
    public static RestResponseFormat Json;
}
public class NBitcoin.RPC.RPCCapabilities : object {
    [CompilerGeneratedAttribute]
private int <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SupportSignRawTransactionWith>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SupportSegwit>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SupportTaproot>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SupportScanUTXOSet>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SupportGetNetworkInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SupportEstimateSmartFee>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SupportGenerateToAddress>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SupportTestMempoolAccept>k__BackingField;
    public int Version { get; public set; }
    public bool SupportSignRawTransactionWith { get; public set; }
    public bool SupportSegwit { get; public set; }
    public bool SupportTaproot { get; public set; }
    public bool SupportScanUTXOSet { get; public set; }
    public bool SupportGetNetworkInfo { get; public set; }
    public bool SupportEstimateSmartFee { get; public set; }
    public bool SupportGenerateToAddress { get; public set; }
    public bool SupportTestMempoolAccept { get; public set; }
    [CompilerGeneratedAttribute]
public int get_Version();
    [CompilerGeneratedAttribute]
public void set_Version(int value);
    [CompilerGeneratedAttribute]
public bool get_SupportSignRawTransactionWith();
    [CompilerGeneratedAttribute]
public void set_SupportSignRawTransactionWith(bool value);
    [CompilerGeneratedAttribute]
public bool get_SupportSegwit();
    [CompilerGeneratedAttribute]
public void set_SupportSegwit(bool value);
    [CompilerGeneratedAttribute]
public bool get_SupportTaproot();
    [CompilerGeneratedAttribute]
public void set_SupportTaproot(bool value);
    [CompilerGeneratedAttribute]
public bool get_SupportScanUTXOSet();
    [CompilerGeneratedAttribute]
public void set_SupportScanUTXOSet(bool value);
    [CompilerGeneratedAttribute]
public bool get_SupportGetNetworkInfo();
    [CompilerGeneratedAttribute]
public void set_SupportGetNetworkInfo(bool value);
    [CompilerGeneratedAttribute]
public bool get_SupportEstimateSmartFee();
    [CompilerGeneratedAttribute]
public void set_SupportEstimateSmartFee(bool value);
    [CompilerGeneratedAttribute]
public bool get_SupportGenerateToAddress();
    [CompilerGeneratedAttribute]
public void set_SupportGenerateToAddress(bool value);
    [CompilerGeneratedAttribute]
public bool get_SupportTestMempoolAccept();
    [CompilerGeneratedAttribute]
public void set_SupportTestMempoolAccept(bool value);
    public RPCCapabilities Clone(int newVersion);
    public virtual string ToString();
}
public class NBitcoin.RPC.RPCClient : object {
    private static Lazy`1<HttpClient> _Shared;
    private HttpClient _HttpClient;
    private string _Authentication;
    private Uri _address;
    private RPCCredentialString _CredentialString;
    private Network _network;
    private static ConcurrentDictionary`2<Network, string> _DefaultPaths;
    [CompilerGeneratedAttribute]
private RPCCapabilities <Capabilities>k__BackingField;
    private ConcurrentQueue`1<Tuple`2<RPCRequest, TaskCompletionSource`1<RPCResponse>>> _BatchedRequests;
    private static Object[] NoParams;
    [CompilerGeneratedAttribute]
private bool <AllowBatchFallback>k__BackingField;
    private static Encoding NoBOMUTF8;
    private JsonSerializerSettings _JsonSerializer;
    public HttpClient HttpClient { get; public set; }
    public Uri Address { get; }
    public RPCCredentialString CredentialString { get; }
    public Network Network { get; }
    public RPCCapabilities Capabilities { get; public set; }
    public string Authentication { get; }
    public bool AllowBatchFallback { get; public set; }
    private JsonSerializerSettings JsonSerializerSettings { get; }
    public RPCClient(Network network);
    [ObsoleteAttribute("Use RPCClient(ConnectionString, string, Network)")]
public RPCClient(NetworkCredential credentials, string host, Network network);
    public RPCClient(RPCCredentialString credentials, Network network);
    public RPCClient(RPCCredentialString credentials, string host, Network network);
    public RPCClient(RPCCredentialString credentials, Uri address, Network network);
    private static RPCClient();
    public RPCClient(string authenticationString, string hostOrUri, Network network);
    public RPCClient(NetworkCredential credentials, Uri address, Network network);
    public RPCClient(string authenticationString, Uri address, Network network);
    public static string GetRPCAuth(NetworkCredential credentials);
    public HttpClient get_HttpClient();
    public void set_HttpClient(HttpClient value);
    public Uri get_Address();
    public RPCCredentialString get_CredentialString();
    public Network get_Network();
    public static void RegisterDefaultCookiePath(Network network, string path);
    private string GetCookiePath();
    [CompilerGeneratedAttribute]
public RPCCapabilities get_Capabilities();
    [CompilerGeneratedAttribute]
public void set_Capabilities(RPCCapabilities value);
    [AsyncStateMachineAttribute("NBitcoin.RPC.RPCClient/<ScanRPCCapabilitiesAsync>d__29")]
public Task`1<RPCCapabilities> ScanRPCCapabilitiesAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NBitcoin.RPC.RPCClient/<SetVersion>d__30")]
private Task SetVersion(RPCCapabilities capabilities);
    public RPCCapabilities ScanRPCCapabilities();
    [AsyncStateMachineAttribute("NBitcoin.RPC.RPCClient/<CheckSegwitCapabilitiesAsync>d__32")]
private static Task CheckSegwitCapabilitiesAsync(RPCClient rpc, Action`1<bool> setResult, ScriptPubKeyType type, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NBitcoin.RPC.RPCClient/<CheckCapabilities>d__33")]
private static Task CheckCapabilities(Func`1<Task> command, Action`1<bool> setResult);
    private static Task CheckCapabilitiesAsync(RPCClient rpc, string command, Action`1<bool> setResult, CancellationToken cancellationToken);
    public static string GetDefaultCookieFilePath(Network network);
    public static string TryGetDefaultCookieFilePath(Network network);
    private static Uri BuildUri(string hostOrUri, string connectionString, int port);
    public string get_Authentication();
    public RPCClient PrepareBatch();
    public RPCClient Clone();
    public RPCResponse SendCommand(RPCOperations commandName, Object[] parameters);
    public RPCResponse SendCommand(string commandName, Object[] parameters);
    public RPCResponse SendCommand(RPCOperations commandName, CancellationToken cancellationToken, Object[] parameters);
    public RPCResponse SendCommand(string commandName, CancellationToken cancellationToken, Object[] parameters);
    public BitcoinAddress GetNewAddress(CancellationToken cancellationToken);
    public BitcoinAddress GetNewAddress(GetNewAddressRequest request);
    [AsyncStateMachineAttribute("NBitcoin.RPC.RPCClient/<GetNewAddressAsync>d__52")]
public Task`1<BitcoinAddress> GetNewAddressAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NBitcoin.RPC.RPCClient/<GetNewAddressAsync>d__53")]
public Task`1<BitcoinAddress> GetNewAddressAsync(GetNewAddressRequest request, CancellationToken cancellationToken);
    public BitcoinAddress GetRawChangeAddress();
    [AsyncStateMachineAttribute("NBitcoin.RPC.RPCClient/<GetRawChangeAddressAsync>d__55")]
public Task`1<BitcoinAddress> GetRawChangeAddressAsync();
    public Task`1<RPCResponse> SendCommandAsync(RPCOperations commandName, Object[] parameters);
    public Task`1<RPCResponse> SendCommandAsync(RPCOperations commandName, CancellationToken cancellationToken, Object[] parameters);
    public RPCResponse SendCommandWithNamedArgs(string commandName, Dictionary`2<string, object> parameters, CancellationToken cancellationToken);
    public Task`1<RPCResponse> SendCommandWithNamedArgsAsync(string commandName, Dictionary`2<string, object> parameters, CancellationToken cancellationToken);
    public Task`1<RPCResponse> SendCommandAsync(string commandName, Object[] parameters);
    public Task`1<RPCResponse> SendCommandAsync(string commandName, CancellationToken cancellationToken, Object[] parameters);
    public void SendBatch();
    public void CancelBatch();
    [AsyncStateMachineAttribute("NBitcoin.RPC.RPCClient/<StopAsync>d__65")]
public Task StopAsync(CancellationToken cancellationToken);
    public void Stop(CancellationToken cancellationToken);
    public TimeSpan Uptime();
    [AsyncStateMachineAttribute("NBitcoin.RPC.RPCClient/<UptimeAsync>d__68")]
public Task`1<TimeSpan> UptimeAsync(CancellationToken cancellationToken);
    public ScanTxoutSetResponse StartScanTxoutSet(ScanTxoutSetParameters parameters, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NBitcoin.RPC.RPCClient/<StartScanTxoutSetAsync>d__70")]
public Task`1<ScanTxoutSetResponse> StartScanTxoutSetAsync(ScanTxoutSetParameters parameters, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NBitcoin.RPC.RPCClient/<GetStatusScanTxoutSetAsync>d__71")]
public Task`1<Nullable`1<decimal>> GetStatusScanTxoutSetAsync(CancellationToken cancellationToken);
    public Nullable`1<decimal> GetStatusScanTxoutSet();
    [AsyncStateMachineAttribute("NBitcoin.RPC.RPCClient/<AbortScanTxoutSetAsync>d__73")]
public Task`1<bool> AbortScanTxoutSetAsync(CancellationToken cancellationToken);
    public bool AbortScanTxoutSet();
    [AsyncStateMachineAttribute("NBitcoin.RPC.RPCClient/<SendBatchAsync>d__75")]
public Task SendBatchAsync(CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
public bool get_AllowBatchFallback();
    [CompilerGeneratedAttribute]
public void set_AllowBatchFallback(bool value);
    [AsyncStateMachineAttribute("NBitcoin.RPC.RPCClient/<SendBatchAsyncCore>d__80")]
private Task SendBatchAsyncCore(List`1<Tuple`2<RPCRequest, TaskCompletionSource`1<RPCResponse>>> requests, CancellationToken cancellationToken);
    private bool TryRenewCookie();
    [AsyncStateMachineAttribute("NBitcoin.RPC.RPCClient/<SendCommandAsync>d__83")]
public Task`1<RPCResponse> SendCommandAsync(RPCRequest request, CancellationToken cancellationToken);
    private bool IsJson(HttpResponseMessage httpResponse);
    [AsyncStateMachineAttribute("NBitcoin.RPC.RPCClient/<IsWorkQueueFull>d__85")]
private Task`1<bool> IsWorkQueueFull(HttpResponseMessage httpResponse);
    private HttpRequestMessage CreateWebRequest(string json);
    [AsyncStateMachineAttribute("NBitcoin.RPC.RPCClient/<ToMemoryStreamAsync>d__87")]
private Task`1<Stream> ToMemoryStreamAsync(Stream stream);
    [AsyncStateMachineAttribute("NBitcoin.RPC.RPCClient/<GetBlockchainInfoAsync>d__88")]
public Task`1<BlockchainInfo> GetBlockchainInfoAsync(CancellationToken cancellationToken);
    public BlockchainInfo GetBlockchainInfo();
    public uint256 GetBestBlockHash();
    [AsyncStateMachineAttribute("NBitcoin.RPC.RPCClient/<GetBestBlockHashAsync>d__91")]
public Task`1<uint256> GetBestBlockHashAsync(CancellationToken cancellationToken);
    public BlockHeader GetBlockHeader(int height);
    public BlockHeader GetBlockHeader(UInt32 height);
    [AsyncStateMachineAttribute("NBitcoin.RPC.RPCClient/<GetBlockHeaderAsync>d__94")]
public Task`1<BlockHeader> GetBlockHeaderAsync(int height, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NBitcoin.RPC.RPCClient/<GetBlockHeaderAsync>d__95")]
public Task`1<BlockHeader> GetBlockHeaderAsync(UInt32 height, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NBitcoin.RPC.RPCClient/<GetBlockAsync>d__96")]
public sealed virtual Task`1<Block> GetBlockAsync(uint256 blockId, CancellationToken cancellationToken);
    public Block GetBlock(uint256 blockId);
    public Block GetBlock(int height);
    public Block GetBlock(UInt32 height);
    [AsyncStateMachineAttribute("NBitcoin.RPC.RPCClient/<GetBlockAsync>d__100")]
public Task`1<Block> GetBlockAsync(int height, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NBitcoin.RPC.RPCClient/<GetBlockAsync>d__101")]
public Task`1<Block> GetBlockAsync(UInt32 height, CancellationToken cancellationToken);
    public BlockHeader GetBlockHeader(uint256 blockHash);
    [AsyncStateMachineAttribute("NBitcoin.RPC.RPCClient/<GetBlockHeaderAsync>d__103")]
public Task`1<BlockHeader> GetBlockHeaderAsync(uint256 blockHash, CancellationToken cancellationToken);
    private BlockHeader ParseBlockHeader(RPCResponse resp);
    public GetBlockRPCResponse GetBlock(uint256 blockHash, GetBlockVerbosity verbosity);
    [AsyncStateMachineAttribute("NBitcoin.RPC.RPCClient/<GetBlockAsync>d__106")]
public Task`1<GetBlockRPCResponse> GetBlockAsync(uint256 blockHash, GetBlockVerbosity verbosity, CancellationToken cancellationToken);
    private GetBlockRPCResponse ParseVerboseBlock(RPCResponse resp, int verbosity);
    public uint256 GetBlockHash(int height);
    public uint256 GetBlockHash(UInt32 height);
    [AsyncStateMachineAttribute("NBitcoin.RPC.RPCClient/<GetBlockHashAsync>d__110")]
public Task`1<uint256> GetBlockHashAsync(int height, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NBitcoin.RPC.RPCClient/<GetBlockHashAsync>d__111")]
public Task`1<uint256> GetBlockHashAsync(UInt32 height, CancellationToken cancellationToken);
    public BlockFilter GetBlockFilter(uint256 blockHash);
    [AsyncStateMachineAttribute("NBitcoin.RPC.RPCClient/<GetBlockFilterAsync>d__113")]
public Task`1<BlockFilter> GetBlockFilterAsync(uint256 blockHash, CancellationToken cancellationToken);
    private BlockFilter ParseCompactFilter(RPCResponse resp);
    public BlockStats GetBlockStats(uint256 blockHash, String[] stats);
    public Task`1<BlockStats> GetBlockStatsAsync(uint256 blockHash, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NBitcoin.RPC.RPCClient/<GetBlockStatsAsync>d__117")]
public Task`1<BlockStats> GetBlockStatsAsync(uint256 blockHash, String[] stats, CancellationToken cancellationToken);
    public int GetBlockCount();
    [AsyncStateMachineAttribute("NBitcoin.RPC.RPCClient/<GetBlockCountAsync>d__119")]
public Task`1<int> GetBlockCountAsync(CancellationToken cancellationToken);
    public MemPoolInfo GetMemPool();
    [AsyncStateMachineAttribute("NBitcoin.RPC.RPCClient/<GetMemPoolAsync>d__121")]
public Task`1<MemPoolInfo> GetMemPoolAsync(CancellationToken cancellationToken);
    public uint256[] GetRawMempool();
    [AsyncStateMachineAttribute("NBitcoin.RPC.RPCClient/<GetRawMempoolAsync>d__123")]
public Task`1<uint256[]> GetRawMempoolAsync(CancellationToken cancellationToken);
    public MempoolEntry GetMempoolEntry(uint256 txid, bool throwIfNotFound);
    [AsyncStateMachineAttribute("NBitcoin.RPC.RPCClient/<GetMempoolEntryAsync>d__125")]
public Task`1<MempoolEntry> GetMempoolEntryAsync(uint256 txid, bool throwIfNotFound, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NBitcoin.RPC.RPCClient/<SaveMempoolAsync>d__126")]
public Task SaveMempoolAsync(CancellationToken cancellationToken);
    public void SaveMempool();
    [NullableContextAttribute("1")]
public MempoolAcceptResult TestMempoolAccept(Transaction transaction, TestMempoolParameters parameters, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
public MempoolAcceptResult TestMempoolAccept(Transaction transaction, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("NBitcoin.RPC.RPCClient/<TestMempoolAcceptAsync>d__130")]
public Task`1<MempoolAcceptResult> TestMempoolAcceptAsync(Transaction transaction, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("NBitcoin.RPC.RPCClient/<TestMempoolAcceptAsync>d__131")]
public Task`1<MempoolAcceptResult> TestMempoolAcceptAsync(Transaction transaction, TestMempoolParameters parameters, CancellationToken cancellationToken);
    public GetTxOutResponse GetTxOut(uint256 txid, int index, bool includeMempool);
    [AsyncStateMachineAttribute("NBitcoin.RPC.RPCClient/<GetTxOutAsync>d__133")]
public Task`1<GetTxOutResponse> GetTxOutAsync(uint256 txid, int index, bool includeMempool, CancellationToken cancellationToken);
    public GetTxOutSetInfoResponse GetTxoutSetInfo();
    [AsyncStateMachineAttribute("NBitcoin.RPC.RPCClient/<GetTxoutSetInfoAsync>d__135")]
public Task`1<GetTxOutSetInfoResponse> GetTxoutSetInfoAsync(CancellationToken cancellationToken);
    [IteratorStateMachineAttribute("NBitcoin.RPC.RPCClient/<GetTransactions>d__136")]
public IEnumerable`1<Transaction> GetTransactions(uint256 blockHash, CancellationToken cancellationToken);
    public IEnumerable`1<Transaction> GetTransactions(int height);
    public Transaction DecodeRawTransaction(string rawHex);
    public Transaction DecodeRawTransaction(Byte[] raw);
    public Task`1<Transaction> DecodeRawTransactionAsync(string rawHex);
    public Task`1<Transaction> DecodeRawTransactionAsync(Byte[] raw);
    public Transaction GetRawTransaction(uint256 txid, bool throwIfNotFound);
    public Task`1<Transaction> GetRawTransactionAsync(uint256 txid, bool throwIfNotFound, CancellationToken cancellationToken);
    public Transaction GetRawTransaction(uint256 txid, uint256 blockId, bool throwIfNotFound);
    [AsyncStateMachineAttribute("NBitcoin.RPC.RPCClient/<GetRawTransactionAsync>d__145")]
public Task`1<Transaction> GetRawTransactionAsync(uint256 txid, uint256 blockId, bool throwIfNotFound, CancellationToken cancellationToken);
    public RawTransactionInfo GetRawTransactionInfo(uint256 txid);
    private Transaction ParseTxHex(string hex);
    [AsyncStateMachineAttribute("NBitcoin.RPC.RPCClient/<GetRawTransactionInfoAsync>d__148")]
public Task`1<RawTransactionInfo> GetRawTransactionInfoAsync(uint256 txId, CancellationToken cancellationToken);
    public uint256 SendRawTransaction(Transaction tx);
    public uint256 SendRawTransaction(Byte[] bytes);
    public Task`1<uint256> SendRawTransactionAsync(Transaction tx, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NBitcoin.RPC.RPCClient/<SendRawTransactionAsync>d__152")]
public Task`1<uint256> SendRawTransactionAsync(Byte[] bytes, CancellationToken cancellationToken);
    public BumpResponse BumpFee(uint256 txid);
    [AsyncStateMachineAttribute("NBitcoin.RPC.RPCClient/<BumpFeeAsync>d__154")]
public Task`1<BumpResponse> BumpFeeAsync(uint256 txid, CancellationToken cancellationToken);
    public EstimateSmartFeeResponse EstimateSmartFee(int confirmationTarget, EstimateSmartFeeMode estimateMode);
    [AsyncStateMachineAttribute("NBitcoin.RPC.RPCClient/<TryEstimateSmartFeeAsync>d__156")]
public Task`1<EstimateSmartFeeResponse> TryEstimateSmartFeeAsync(int confirmationTarget, EstimateSmartFeeMode estimateMode, CancellationToken cancellationToken);
    public EstimateSmartFeeResponse TryEstimateSmartFee(int confirmationTarget, EstimateSmartFeeMode estimateMode);
    [AsyncStateMachineAttribute("NBitcoin.RPC.RPCClient/<EstimateSmartFeeAsync>d__158")]
public Task`1<EstimateSmartFeeResponse> EstimateSmartFeeAsync(int confirmationTarget, EstimateSmartFeeMode estimateMode, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NBitcoin.RPC.RPCClient/<EstimateSmartFeeImplAsync>d__159")]
private Task`1<EstimateSmartFeeResponse> EstimateSmartFeeImplAsync(int confirmationTarget, EstimateSmartFeeMode estimateMode, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
public uint256 SendToAddress(BitcoinAddress address, Money amount, SendToAddressParameters parameters, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
public uint256 SendToAddress(BitcoinAddress address, Money amount, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
public uint256 SendToAddress(Script scriptPubKey, Money amount, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
public Task`1<uint256> SendToAddressAsync(Script scriptPubKey, Money amount, SendToAddressParameters parameters, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
public Task`1<uint256> SendToAddressAsync(Script scriptPubKey, Money amount, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
public uint256 SendToAddress(Script scriptPubKey, Money amount, SendToAddressParameters parameters, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
public Task`1<uint256> SendToAddressAsync(BitcoinAddress address, Money amount, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("NBitcoin.RPC.RPCClient/<SendToAddressAsync>d__167")]
public Task`1<uint256> SendToAddressAsync(BitcoinAddress address, Money amount, SendToAddressParameters parameters, CancellationToken cancellationToken);
    public bool SetTxFee(FeeRate feeRate, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NBitcoin.RPC.RPCClient/<GenerateAsync>d__169")]
public Task`1<uint256[]> GenerateAsync(int nBlocks, CancellationToken cancellationToken);
    public uint256[] Generate(int nBlocks);
    [AsyncStateMachineAttribute("NBitcoin.RPC.RPCClient/<GenerateToAddressAsync>d__171")]
public Task`1<uint256[]> GenerateToAddressAsync(int nBlocks, BitcoinAddress address, CancellationToken cancellationToken);
    public uint256[] GenerateToAddress(int nBlocks, BitcoinAddress address);
    public void InvalidateBlock(uint256 blockhash, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NBitcoin.RPC.RPCClient/<InvalidateBlockAsync>d__174")]
public Task InvalidateBlockAsync(uint256 blockhash, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
[ObsoleteAttribute("This method is being renamed, use SetWalletContext instead")]
public RPCClient GetWallet(string walletName);
    [NullableContextAttribute("1")]
public RPCClient SetWalletContext(string walletName);
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("NBitcoin.RPC.RPCClient/<CreateWalletAsync>d__177")]
public Task`1<RPCClient> CreateWalletAsync(string walletNameOrPath, CreateWalletOptions options, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
public RPCClient CreateWallet(string walletNameOrPath, CreateWalletOptions options);
    [NullableContextAttribute("1")]
public Task`1<RPCClient> LoadWalletAsync(Nullable`1<bool> loadOnStartup);
    [NullableContextAttribute("1")]
public RPCClient LoadWallet(Nullable`1<bool> loadOnStartup);
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("NBitcoin.RPC.RPCClient/<LoadWalletAsync>d__181")]
public Task`1<RPCClient> LoadWalletAsync(string walletName, Nullable`1<bool> loadOnStartup, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
private RPCRequest GetLoadUnloadWalletRequest(string methodName, string walletName, Nullable`1<bool> loadOnStartup);
    [NullableContextAttribute("1")]
public RPCClient LoadWallet(string walletName, Nullable`1<bool> loadOnStartup);
    public void UnloadWallet();
    public void UnloadWallet(Nullable`1<bool> loadOnStartup);
    [NullableContextAttribute("1")]
public Task UnloadWalletAsync(Nullable`1<bool> loadOnStartup);
    [NullableContextAttribute("1")]
public Task UnloadWalletAsync(string walletName, Nullable`1<bool> loadOnStartup, CancellationToken cancellationToken);
    public void BackupWallet(string path);
    [AsyncStateMachineAttribute("NBitcoin.RPC.RPCClient/<BackupWalletAsync>d__189")]
public Task BackupWalletAsync(string path);
    public BitcoinSecret DumpPrivKey(BitcoinAddress address, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NBitcoin.RPC.RPCClient/<DumpPrivKeyAsync>d__191")]
public Task`1<BitcoinSecret> DumpPrivKeyAsync(BitcoinAddress address);
    public FundRawTransactionResponse FundRawTransaction(Transaction transaction, FundRawTransactionOptions options);
    public GetAddressInfoResponse GetAddressInfo(IDestination address);
    [AsyncStateMachineAttribute("NBitcoin.RPC.RPCClient/<GetAddressInfoAsync>d__194")]
public Task`1<GetAddressInfoResponse> GetAddressInfoAsync(IDestination address);
    public Money GetBalance(int minConf, bool includeWatchOnly);
    public Money GetBalance();
    [AsyncStateMachineAttribute("NBitcoin.RPC.RPCClient/<GetBalanceAsync>d__197")]
public Task`1<Money> GetBalanceAsync();
    [AsyncStateMachineAttribute("NBitcoin.RPC.RPCClient/<GetBalanceAsync>d__198")]
public Task`1<Money> GetBalanceAsync(int minConf, bool includeWatchOnly);
    [AsyncStateMachineAttribute("NBitcoin.RPC.RPCClient/<FundRawTransactionAsync>d__199")]
public Task`1<FundRawTransactionResponse> FundRawTransactionAsync(Transaction transaction, FundRawTransactionOptions options, CancellationToken cancellationToken);
    private JObject FundRawTransactionOptionsToJson(FundRawTransactionOptions options);
    private string ToHex(Transaction tx);
    public Money GetReceivedByAddress(BitcoinAddress address);
    [AsyncStateMachineAttribute("NBitcoin.RPC.RPCClient/<GetReceivedByAddressAsync>d__203")]
public Task`1<Money> GetReceivedByAddressAsync(BitcoinAddress address);
    public Money GetReceivedByAddress(BitcoinAddress address, int confirmations);
    [AsyncStateMachineAttribute("NBitcoin.RPC.RPCClient/<GetReceivedByAddressAsync>d__205")]
public Task`1<Money> GetReceivedByAddressAsync(BitcoinAddress address, int confirmations);
    public void ImportPrivKey(BitcoinSecret secret);
    public void ImportPrivKey(BitcoinSecret secret, string label, bool rescan);
    [AsyncStateMachineAttribute("NBitcoin.RPC.RPCClient/<ImportPrivKeyAsync>d__208")]
public Task ImportPrivKeyAsync(BitcoinSecret secret);
    [AsyncStateMachineAttribute("NBitcoin.RPC.RPCClient/<ImportPrivKeyAsync>d__209")]
public Task ImportPrivKeyAsync(BitcoinSecret secret, string label, bool rescan);
    public void ImportAddress(IDestination address);
    public void ImportAddress(IDestination address, string label, bool rescan);
    public void ImportAddress(Script scriptPubKey);
    public void ImportAddress(Script scriptPubKey, string label, bool rescan);
    [AsyncStateMachineAttribute("NBitcoin.RPC.RPCClient/<ImportAddressAsync>d__214")]
public Task ImportAddressAsync(Script scriptPubKey);
    [AsyncStateMachineAttribute("NBitcoin.RPC.RPCClient/<ImportAddressAsync>d__215")]
public Task ImportAddressAsync(Script scriptPubKey, string label, bool rescan);
    [AsyncStateMachineAttribute("NBitcoin.RPC.RPCClient/<ImportAddressAsync>d__216")]
public Task ImportAddressAsync(BitcoinAddress address);
    [AsyncStateMachineAttribute("NBitcoin.RPC.RPCClient/<ImportAddressAsync>d__217")]
public Task ImportAddressAsync(BitcoinAddress address, string label, bool rescan);
    public void ImportMulti(ImportMultiAddress[] addresses, bool rescan);
    [NullableContextAttribute("1")]
public void ImportMulti(ImportMultiAddress[] addresses, bool rescan, ISigningRepository signingRepository);
    [NullableContextAttribute("1")]
public Task ImportMultiAsync(ImportMultiAddress[] addresses, bool rescan);
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("NBitcoin.RPC.RPCClient/<ImportMultiAsync>d__221")]
public Task ImportMultiAsync(ImportMultiAddress[] addresses, bool rescan, ISigningRepository signingRepository, CancellationToken cancellationToken);
    private JsonSerializerSettings get_JsonSerializerSettings();
    [IteratorStateMachineAttribute("NBitcoin.RPC.RPCClient/<ListAddressGroupings>d__225")]
public IEnumerable`1<AddressGrouping> ListAddressGroupings();
    [IteratorStateMachineAttribute("NBitcoin.RPC.RPCClient/<ListSecrets>d__226")]
public IEnumerable`1<BitcoinSecret> ListSecrets();
    public UnspentCoin[] ListUnspent();
    public UnspentCoin[] ListUnspent(int minconf, int maxconf, BitcoinAddress[] addresses);
    [AsyncStateMachineAttribute("NBitcoin.RPC.RPCClient/<ListUnspentAsync>d__229")]
public Task`1<UnspentCoin[]> ListUnspentAsync();
    [AsyncStateMachineAttribute("NBitcoin.RPC.RPCClient/<ListUnspentAsync>d__230")]
public Task`1<UnspentCoin[]> ListUnspentAsync(int minconf, int maxconf, BitcoinAddress[] addresses);
    [AsyncStateMachineAttribute("NBitcoin.RPC.RPCClient/<ListUnspentAsync>d__231")]
public Task`1<UnspentCoin[]> ListUnspentAsync(ListUnspentOptions options, BitcoinAddress[] addresses);
    [AsyncStateMachineAttribute("NBitcoin.RPC.RPCClient/<ListUnspentAsync>d__232")]
public Task`1<UnspentCoin[]> ListUnspentAsync(ListUnspentOptions options, CancellationToken cancellationToken, BitcoinAddress[] addresses);
    [AsyncStateMachineAttribute("NBitcoin.RPC.RPCClient/<ListLockUnspentAsync>d__233")]
public Task`1<OutPoint[]> ListLockUnspentAsync();
    public OutPoint[] ListLockUnspent();
    public void AbandonTransaction(uint256 txId);
    [AsyncStateMachineAttribute("NBitcoin.RPC.RPCClient/<AbandonTransactionAsync>d__236")]
public Task AbandonTransactionAsync(uint256 txId);
    public void LockUnspent(OutPoint[] outpoints);
    public void UnlockUnspent(OutPoint[] outpoints);
    public Task LockUnspentAsync(OutPoint[] outpoints);
    public Task UnlockUnspentAsync(OutPoint[] outpoints);
    private void LockUnspentCore(bool unlock, OutPoint[] outpoints);
    [AsyncStateMachineAttribute("NBitcoin.RPC.RPCClient/<LockUnspentCoreAsync>d__242")]
private Task LockUnspentCoreAsync(bool unlock, OutPoint[] outpoints);
    public void WalletPassphrase(string passphrase, int timeout);
    [AsyncStateMachineAttribute("NBitcoin.RPC.RPCClient/<WalletPassphraseAsync>d__244")]
public Task WalletPassphraseAsync(string passphrase, int timeout);
    public Transaction SignRawTransaction(Transaction tx);
    [AsyncStateMachineAttribute("NBitcoin.RPC.RPCClient/<SignRawTransactionAsync>d__246")]
public Task`1<Transaction> SignRawTransactionAsync(Transaction tx);
    public SignRawTransactionResponse SignRawTransactionWithKey(SignRawTransactionWithKeyRequest request);
    [AsyncStateMachineAttribute("NBitcoin.RPC.RPCClient/<SignRawTransactionWithKeyAsync>d__248")]
public Task`1<SignRawTransactionResponse> SignRawTransactionWithKeyAsync(SignRawTransactionWithKeyRequest request, CancellationToken cancellationToken);
    public SignRawTransactionResponse SignRawTransactionWithWallet(SignRawTransactionRequest request);
    [AsyncStateMachineAttribute("NBitcoin.RPC.RPCClient/<SignRawTransactionWithWalletAsync>d__250")]
public Task`1<SignRawTransactionResponse> SignRawTransactionWithWalletAsync(SignRawTransactionRequest request, CancellationToken cancellationToken);
    public WalletProcessPSBTResponse WalletProcessPSBT(PSBT psbt, bool sign, SigHash hashType, bool bip32derivs);
    [AsyncStateMachineAttribute("NBitcoin.RPC.RPCClient/<WalletProcessPSBTAsync>d__252")]
public Task`1<WalletProcessPSBTResponse> WalletProcessPSBTAsync(PSBT psbt, bool sign, SigHash sighashType, bool bip32derivs);
    public WalletCreateFundedPSBTResponse WalletCreateFundedPSBT(TxIn[] inputs, Tuple`2<Dictionary`2<BitcoinAddress, Money>, Dictionary`2<string, string>> outputs, LockTime locktime, FundRawTransactionOptions options, bool bip32derivs);
    [AsyncStateMachineAttribute("NBitcoin.RPC.RPCClient/<WalletCreateFundedPSBTAsync>d__254")]
public Task`1<WalletCreateFundedPSBTResponse> WalletCreateFundedPSBTAsync(TxIn[] inputs, Tuple`2<Dictionary`2<BitcoinAddress, Money>, Dictionary`2<string, string>> outputs, LockTime locktime, FundRawTransactionOptions options, bool bip32derivs, CancellationToken cancellationToken);
    public WalletCreateFundedPSBTResponse WalletCreateFundedPSBT(TxIn[] inputs, Dictionary`2<BitcoinAddress, Money> outputs, LockTime locktime, FundRawTransactionOptions options, bool bip32derivs);
    public WalletCreateFundedPSBTResponse WalletCreateFundedPSBT(TxIn[] inputs, Dictionary`2<string, string> outputs, LockTime locktime, FundRawTransactionOptions options, bool bip32derivs);
    public string SigHashToString(SigHash value);
    private Money GetMoney(RPCResponse response);
    [CompilerGeneratedAttribute]
internal static IEnumerable`1<FeeRateGroup> <GetMemPoolAsync>g__ExtractFeeRateGroups|121_0(JToken jt);
    [CompilerGeneratedAttribute]
private UnspentCoin <ListUnspent>b__227_0(JToken i);
    [CompilerGeneratedAttribute]
private UnspentCoin <ListUnspent>b__228_1(JToken i);
    [CompilerGeneratedAttribute]
private UnspentCoin <ListUnspentAsync>b__229_0(JToken i);
    [CompilerGeneratedAttribute]
private UnspentCoin <ListUnspentAsync>b__230_1(JToken i);
    [CompilerGeneratedAttribute]
private UnspentCoin <ListUnspentAsync>b__232_1(JToken i);
}
public class NBitcoin.RPC.RPCCredentialString : object {
    [CompilerGeneratedAttribute]
private string <Server>k__BackingField;
    [CompilerGeneratedAttribute]
private string <WalletName>k__BackingField;
    private string _CookieFile;
    private NetworkCredential _UsernamePassword;
    public string Server { get; public set; }
    public bool UseDefault { get; }
    public string WalletName { get; public set; }
    public string CookieFile { get; public set; }
    public NetworkCredential UserPassword { get; public set; }
    public static RPCCredentialString Parse(string str);
    public static bool TryParse(string str, RPCCredentialString& connectionString);
    private static bool TryParseAuth(string str, RPCCredentialString& connectionString);
    [CompilerGeneratedAttribute]
public string get_Server();
    [CompilerGeneratedAttribute]
public void set_Server(string value);
    public bool get_UseDefault();
    [CompilerGeneratedAttribute]
public string get_WalletName();
    [CompilerGeneratedAttribute]
public void set_WalletName(string value);
    public string get_CookieFile();
    public void set_CookieFile(string value);
    private void Reset();
    public NetworkCredential get_UserPassword();
    public void set_UserPassword(NetworkCredential value);
    public virtual string ToString();
}
public class NBitcoin.RPC.RPCError : object {
    [CompilerGeneratedAttribute]
private RPCErrorCode <Code>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    public RPCErrorCode Code { get; public set; }
    public string Message { get; public set; }
    internal RPCError(JObject error);
    [CompilerGeneratedAttribute]
public RPCErrorCode get_Code();
    [CompilerGeneratedAttribute]
public void set_Code(RPCErrorCode value);
    [CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
public void set_Message(string value);
}
public enum NBitcoin.RPC.RPCErrorCode : Enum {
    public int value__;
    public static RPCErrorCode RPC_INVALID_REQUEST;
    public static RPCErrorCode RPC_METHOD_NOT_FOUND;
    public static RPCErrorCode RPC_INVALID_PARAMS;
    public static RPCErrorCode RPC_INTERNAL_ERROR;
    public static RPCErrorCode RPC_PARSE_ERROR;
    public static RPCErrorCode RPC_MISC_ERROR;
    public static RPCErrorCode RPC_FORBIDDEN_BY_SAFE_MODE;
    public static RPCErrorCode RPC_TYPE_ERROR;
    public static RPCErrorCode RPC_INVALID_ADDRESS_OR_KEY;
    public static RPCErrorCode RPC_OUT_OF_MEMORY;
    public static RPCErrorCode RPC_INVALID_PARAMETER;
    public static RPCErrorCode RPC_DATABASE_ERROR;
    public static RPCErrorCode RPC_DESERIALIZATION_ERROR;
    public static RPCErrorCode RPC_VERIFY_ERROR;
    public static RPCErrorCode RPC_VERIFY_REJECTED;
    public static RPCErrorCode RPC_VERIFY_ALREADY_IN_CHAIN;
    public static RPCErrorCode RPC_IN_WARMUP;
    public static RPCErrorCode RPC_METHOD_DEPRECATED;
    public static RPCErrorCode RPC_TRANSACTION_ERROR;
    public static RPCErrorCode RPC_TRANSACTION_REJECTED;
    public static RPCErrorCode RPC_TRANSACTION_ALREADY_IN_CHAIN;
    public static RPCErrorCode RPC_CLIENT_NOT_CONNECTED;
    public static RPCErrorCode RPC_CLIENT_IN_INITIAL_DOWNLOAD;
    public static RPCErrorCode RPC_CLIENT_NODE_ALREADY_ADDED;
    public static RPCErrorCode RPC_CLIENT_NODE_NOT_ADDED;
    public static RPCErrorCode RPC_CLIENT_NODE_NOT_CONNECTED;
    public static RPCErrorCode RPC_CLIENT_INVALID_IP_OR_SUBNET;
    public static RPCErrorCode RPC_CLIENT_P2P_DISABLED;
    public static RPCErrorCode RPC_WALLET_ERROR;
    public static RPCErrorCode RPC_WALLET_INSUFFICIENT_FUNDS;
    public static RPCErrorCode RPC_WALLET_INVALID_ACCOUNT_NAME;
    public static RPCErrorCode RPC_WALLET_KEYPOOL_RAN_OUT;
    public static RPCErrorCode RPC_WALLET_UNLOCK_NEEDED;
    public static RPCErrorCode RPC_WALLET_PASSPHRASE_INCORRECT;
    public static RPCErrorCode RPC_WALLET_WRONG_ENC_STATE;
    public static RPCErrorCode RPC_WALLET_ENCRYPTION_FAILED;
    public static RPCErrorCode RPC_WALLET_ALREADY_UNLOCKED;
    public static RPCErrorCode RPC_WALLET_NOT_FOUND;
    public static RPCErrorCode RPC_WALLET_NOT_SPECIFIED;
    public static RPCErrorCode RPC_WALLET_ALREADY_LOADED;
    public static RPCErrorCode RPC_WALLET_ALREADY_EXISTS;
}
public class NBitcoin.RPC.RPCException : Exception {
    private RPCResponse _RPCResult;
    private RPCErrorCode _RPCCode;
    private string _RPCCodeMessage;
    public RPCResponse RPCResult { get; }
    public RPCErrorCode RPCCode { get; }
    public string RPCCodeMessage { get; }
    public RPCException(RPCErrorCode code, string message, RPCResponse result);
    public RPCResponse get_RPCResult();
    private static string FindMessage(RPCErrorCode code);
    public RPCErrorCode get_RPCCode();
    public string get_RPCCodeMessage();
}
public enum NBitcoin.RPC.RPCOperations : Enum {
    public int value__;
    public static RPCOperations getconnectioncount;
    public static RPCOperations getpeerinfo;
    public static RPCOperations ping;
    public static RPCOperations addnode;
    public static RPCOperations getaddednodeinfo;
    public static RPCOperations getnettotals;
    public static RPCOperations dumpprivkey;
    public static RPCOperations importprivkey;
    public static RPCOperations importaddress;
    public static RPCOperations dumpwallet;
    public static RPCOperations importwallet;
    public static RPCOperations getgenerate;
    public static RPCOperations setgenerate;
    public static RPCOperations generate;
    public static RPCOperations generatetoaddress;
    public static RPCOperations getnetworkhashps;
    public static RPCOperations gethashespersec;
    public static RPCOperations getmininginfo;
    public static RPCOperations prioritisetransaction;
    public static RPCOperations getwork;
    public static RPCOperations getblocktemplate;
    public static RPCOperations submitblock;
    public static RPCOperations estimatefee;
    public static RPCOperations estimatesmartfee;
    public static RPCOperations getnewaddress;
    public static RPCOperations getaccountaddress;
    public static RPCOperations getrawchangeaddress;
    public static RPCOperations setaccount;
    public static RPCOperations getaccount;
    public static RPCOperations getaddressesbyaccount;
    public static RPCOperations sendtoaddress;
    public static RPCOperations signmessage;
    public static RPCOperations verifymessage;
    public static RPCOperations getreceivedbyaddress;
    public static RPCOperations getreceivedbyaccount;
    public static RPCOperations getaddressinfo;
    public static RPCOperations getbalance;
    public static RPCOperations getunconfirmedbalance;
    public static RPCOperations movecmd;
    public static RPCOperations sendfrom;
    public static RPCOperations sendmany;
    public static RPCOperations addmultisigaddress;
    public static RPCOperations createmultisig;
    public static RPCOperations listreceivedbyaddress;
    public static RPCOperations listreceivedbyaccount;
    public static RPCOperations listtransactions;
    public static RPCOperations listaddressgroupings;
    public static RPCOperations listsinceblock;
    public static RPCOperations gettransaction;
    public static RPCOperations backupwallet;
    public static RPCOperations keypoolrefill;
    public static RPCOperations walletpassphrase;
    public static RPCOperations walletpassphrasechange;
    public static RPCOperations walletlock;
    public static RPCOperations encryptwallet;
    public static RPCOperations validateaddress;
    [ObsoleteAttribute("Deprecated in Bitcoin Core 0.16.0 use getblockchaininfo, getnetworkinfo, getwalletinfo or getmininginfo instead")]
public static RPCOperations getinfo;
    public static RPCOperations getwalletinfo;
    public static RPCOperations getblockchaininfo;
    public static RPCOperations getnetworkinfo;
    public static RPCOperations getrawtransaction;
    public static RPCOperations listunspent;
    public static RPCOperations lockunspent;
    public static RPCOperations listlockunspent;
    public static RPCOperations createrawtransaction;
    public static RPCOperations decoderawtransaction;
    public static RPCOperations decodescript;
    public static RPCOperations signrawtransaction;
    public static RPCOperations sendrawtransaction;
    public static RPCOperations gettxoutproof;
    public static RPCOperations verifytxoutproof;
    public static RPCOperations decodepsbt;
    public static RPCOperations combinepsbt;
    public static RPCOperations finalizepsbt;
    public static RPCOperations createpsbt;
    public static RPCOperations convertopsbt;
    public static RPCOperations walletprocesspsbt;
    public static RPCOperations walletcreatefundedpsbt;
    public static RPCOperations getblockcount;
    public static RPCOperations getblockfilter;
    public static RPCOperations getblockstats;
    public static RPCOperations getbestblockhash;
    public static RPCOperations getdifficulty;
    public static RPCOperations settxfee;
    public static RPCOperations getmempoolinfo;
    public static RPCOperations getrawmempool;
    public static RPCOperations testmempoolaccept;
    public static RPCOperations getblockhash;
    public static RPCOperations getblock;
    public static RPCOperations gettxoutsetinfo;
    public static RPCOperations gettxout;
    public static RPCOperations verifychain;
    public static RPCOperations getchaintips;
    public static RPCOperations invalidateblock;
    public static RPCOperations bumpfee;
    public static RPCOperations abandontransaction;
    public static RPCOperations signrawtransactionwithkey;
    public static RPCOperations scantxoutset;
    public static RPCOperations getmempoolentry;
    public static RPCOperations stop;
    public static RPCOperations uptime;
    public static RPCOperations createwallet;
    public static RPCOperations loadwallet;
    public static RPCOperations unloadwallet;
    public static RPCOperations addpeeraddress;
    public static RPCOperations savemempool;
}
public class NBitcoin.RPC.RPCRequest : object {
    [CompilerGeneratedAttribute]
private string <JsonRpc>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Method>k__BackingField;
    [CompilerGeneratedAttribute]
private Object[] <Params>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ThrowIfRPCError>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, object> <NamedParams>k__BackingField;
    public string JsonRpc { get; public set; }
    public int Id { get; public set; }
    public string Method { get; public set; }
    public Object[] Params { get; public set; }
    public bool ThrowIfRPCError { get; public set; }
    public Dictionary`2<string, object> NamedParams { get; public set; }
    public RPCRequest(RPCOperations method, Object[] parameters);
    public RPCRequest(string method, Object[] parameters);
    [CompilerGeneratedAttribute]
public string get_JsonRpc();
    [CompilerGeneratedAttribute]
public void set_JsonRpc(string value);
    [CompilerGeneratedAttribute]
public int get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(int value);
    [CompilerGeneratedAttribute]
public string get_Method();
    [CompilerGeneratedAttribute]
public void set_Method(string value);
    [CompilerGeneratedAttribute]
public Object[] get_Params();
    [CompilerGeneratedAttribute]
public void set_Params(Object[] value);
    [CompilerGeneratedAttribute]
public bool get_ThrowIfRPCError();
    [CompilerGeneratedAttribute]
public void set_ThrowIfRPCError(bool value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, object> get_NamedParams();
    [CompilerGeneratedAttribute]
public void set_NamedParams(Dictionary`2<string, object> value);
    public void WriteJSON(TextWriter writer);
    internal void WriteJSON(JsonTextWriter writer);
    private void WriteValue(JsonTextWriter writer, object obj);
    private void WriteProperty(JsonTextWriter writer, string property, TValue value);
}
public class NBitcoin.RPC.RPCResponse : object {
    [CompilerGeneratedAttribute]
private RPCError <Error>k__BackingField;
    [CompilerGeneratedAttribute]
private JToken <Result>k__BackingField;
    public RPCError Error { get; public set; }
    public JToken Result { get; public set; }
    public string ResultString { get; }
    public RPCResponse(JObject json);
    [CompilerGeneratedAttribute]
public RPCError get_Error();
    [CompilerGeneratedAttribute]
public void set_Error(RPCError value);
    [CompilerGeneratedAttribute]
public JToken get_Result();
    [CompilerGeneratedAttribute]
public void set_Result(JToken value);
    public string get_ResultString();
    public static RPCResponse Load(Stream stream);
    public void ThrowIfError();
}
public class NBitcoin.RPC.RPCTransactionInput : object {
    [CompilerGeneratedAttribute]
private uint256 <TxId>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <vout>k__BackingField;
    [CompilerGeneratedAttribute]
private Sequence <nSequence>k__BackingField;
    [JsonPropertyAttribute]
public uint256 TxId { get; public set; }
    [JsonPropertyAttribute]
public UInt32 vout { get; public set; }
    [JsonPropertyAttribute]
public Sequence nSequence { get; public set; }
    public RPCTransactionInput(TxIn txin);
    [CompilerGeneratedAttribute]
public uint256 get_TxId();
    [CompilerGeneratedAttribute]
public void set_TxId(uint256 value);
    [CompilerGeneratedAttribute]
public UInt32 get_vout();
    [CompilerGeneratedAttribute]
public void set_vout(UInt32 value);
    [CompilerGeneratedAttribute]
public Sequence get_nSequence();
    [CompilerGeneratedAttribute]
public void set_nSequence(Sequence value);
}
public class NBitcoin.RPC.ScanTxoutDescriptor : object {
    [CompilerGeneratedAttribute]
private OutputDescriptor <Descriptor>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <Begin>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <End>k__BackingField;
    public OutputDescriptor Descriptor { get; public set; }
    public Nullable`1<int> Begin { get; public set; }
    public Nullable`1<int> End { get; public set; }
    public ScanTxoutDescriptor(OutputDescriptor desc);
    [CompilerGeneratedAttribute]
public OutputDescriptor get_Descriptor();
    [CompilerGeneratedAttribute]
public void set_Descriptor(OutputDescriptor value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_Begin();
    [CompilerGeneratedAttribute]
public void set_Begin(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_End();
    [CompilerGeneratedAttribute]
public void set_End(Nullable`1<int> value);
}
public class NBitcoin.RPC.ScanTxoutOutput : object {
    [CompilerGeneratedAttribute]
private Coin <Coin>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Height>k__BackingField;
    public Coin Coin { get; public set; }
    public int Height { get; public set; }
    [CompilerGeneratedAttribute]
public Coin get_Coin();
    [CompilerGeneratedAttribute]
public void set_Coin(Coin value);
    [CompilerGeneratedAttribute]
public int get_Height();
    [CompilerGeneratedAttribute]
public void set_Height(int value);
}
public class NBitcoin.RPC.ScanTxoutSetParameters : object {
    [CompilerGeneratedAttribute]
private ScanTxoutDescriptor[] <Descriptors>k__BackingField;
    public ScanTxoutDescriptor[] Descriptors { get; public set; }
    public ScanTxoutSetParameters(OutputDescriptor descriptor, Nullable`1<int> begin, Nullable`1<int> end);
    public ScanTxoutSetParameters(IEnumerable`1<OutputDescriptor> descriptors, Nullable`1<int> begin, Nullable`1<int> end);
    public ScanTxoutSetParameters(ScanTxoutDescriptor[] descriptors);
    [CompilerGeneratedAttribute]
public ScanTxoutDescriptor[] get_Descriptors();
    [CompilerGeneratedAttribute]
public void set_Descriptors(ScanTxoutDescriptor[] value);
}
public class NBitcoin.RPC.ScanTxoutSetResponse : object {
    [CompilerGeneratedAttribute]
private int <SearchedItems>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Success>k__BackingField;
    [CompilerGeneratedAttribute]
private ScanTxoutOutput[] <Outputs>k__BackingField;
    [CompilerGeneratedAttribute]
private Money <TotalAmount>k__BackingField;
    public int SearchedItems { get; internal set; }
    public bool Success { get; internal set; }
    public ScanTxoutOutput[] Outputs { get; public set; }
    public Money TotalAmount { get; public set; }
    [CompilerGeneratedAttribute]
public int get_SearchedItems();
    [CompilerGeneratedAttribute]
internal void set_SearchedItems(int value);
    [CompilerGeneratedAttribute]
public bool get_Success();
    [CompilerGeneratedAttribute]
internal void set_Success(bool value);
    [CompilerGeneratedAttribute]
public ScanTxoutOutput[] get_Outputs();
    [CompilerGeneratedAttribute]
public void set_Outputs(ScanTxoutOutput[] value);
    [CompilerGeneratedAttribute]
public Money get_TotalAmount();
    [CompilerGeneratedAttribute]
public void set_TotalAmount(Money value);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class NBitcoin.RPC.SendToAddressParameters : object {
    [CompilerGeneratedAttribute]
private string <Comment>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CommentTo>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <SubstractFeeFromAmount>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <Replaceable>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <ConfTarget>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<EstimateSmartFeeMode> <EstimateMode>k__BackingField;
    [CompilerGeneratedAttribute]
private FeeRate <FeeRate>k__BackingField;
    public string Comment { get; public set; }
    public string CommentTo { get; public set; }
    public Nullable`1<bool> SubstractFeeFromAmount { get; public set; }
    public Nullable`1<bool> Replaceable { get; public set; }
    public Nullable`1<int> ConfTarget { get; public set; }
    public Nullable`1<EstimateSmartFeeMode> EstimateMode { get; public set; }
    public FeeRate FeeRate { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Comment();
    [CompilerGeneratedAttribute]
public void set_Comment(string value);
    [CompilerGeneratedAttribute]
public string get_CommentTo();
    [CompilerGeneratedAttribute]
public void set_CommentTo(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_SubstractFeeFromAmount();
    [CompilerGeneratedAttribute]
public void set_SubstractFeeFromAmount(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_Replaceable();
    [CompilerGeneratedAttribute]
public void set_Replaceable(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_ConfTarget();
    [CompilerGeneratedAttribute]
public void set_ConfTarget(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<EstimateSmartFeeMode> get_EstimateMode();
    [CompilerGeneratedAttribute]
public void set_EstimateMode(Nullable`1<EstimateSmartFeeMode> value);
    [CompilerGeneratedAttribute]
public FeeRate get_FeeRate();
    [CompilerGeneratedAttribute]
public void set_FeeRate(FeeRate value);
}
public class NBitcoin.RPC.SignRawTransactionRequest : object {
    [CompilerGeneratedAttribute]
private PrevTx[] <PreviousTransactions>k__BackingField;
    [CompilerGeneratedAttribute]
private Transaction <Transaction>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<SigHash> <SigHash>k__BackingField;
    public PrevTx[] PreviousTransactions { get; public set; }
    public Transaction Transaction { get; public set; }
    public Nullable`1<SigHash> SigHash { get; public set; }
    [CompilerGeneratedAttribute]
public PrevTx[] get_PreviousTransactions();
    [CompilerGeneratedAttribute]
public void set_PreviousTransactions(PrevTx[] value);
    [CompilerGeneratedAttribute]
public Transaction get_Transaction();
    [CompilerGeneratedAttribute]
public void set_Transaction(Transaction value);
    [CompilerGeneratedAttribute]
public Nullable`1<SigHash> get_SigHash();
    [CompilerGeneratedAttribute]
public void set_SigHash(Nullable`1<SigHash> value);
}
public class NBitcoin.RPC.SignRawTransactionResponse : object {
    [CompilerGeneratedAttribute]
private Transaction <SignedTransaction>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Complete>k__BackingField;
    [CompilerGeneratedAttribute]
private ScriptError[] <Errors>k__BackingField;
    public Transaction SignedTransaction { get; public set; }
    public bool Complete { get; public set; }
    public ScriptError[] Errors { get; public set; }
    [CompilerGeneratedAttribute]
public Transaction get_SignedTransaction();
    [CompilerGeneratedAttribute]
public void set_SignedTransaction(Transaction value);
    [CompilerGeneratedAttribute]
public bool get_Complete();
    [CompilerGeneratedAttribute]
public void set_Complete(bool value);
    [CompilerGeneratedAttribute]
public ScriptError[] get_Errors();
    [CompilerGeneratedAttribute]
public void set_Errors(ScriptError[] value);
}
public class NBitcoin.RPC.SignRawTransactionWithKeyRequest : SignRawTransactionRequest {
    [CompilerGeneratedAttribute]
private Key[] <PrivateKeys>k__BackingField;
    public Key[] PrivateKeys { get; public set; }
    [CompilerGeneratedAttribute]
public Key[] get_PrivateKeys();
    [CompilerGeneratedAttribute]
public void set_PrivateKeys(Key[] value);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class NBitcoin.RPC.TestMempoolParameters : object {
    [CompilerGeneratedAttribute]
private FeeRate <MaxFeeRate>k__BackingField;
    public FeeRate MaxFeeRate { get; public set; }
    [CompilerGeneratedAttribute]
public FeeRate get_MaxFeeRate();
    [CompilerGeneratedAttribute]
public void set_MaxFeeRate(FeeRate value);
}
[ExtensionAttribute]
public static class NBitcoin.RPC.TxInExtension : object {
    [ExtensionAttribute]
public static RPCTransactionInput ToRPCInputs(TxIn txin);
}
public class NBitcoin.RPC.UnspentCoin : object {
    [CompilerGeneratedAttribute]
private OutPoint <OutPoint>k__BackingField;
    [CompilerGeneratedAttribute]
private BitcoinAddress <Address>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Account>k__BackingField;
    [CompilerGeneratedAttribute]
private Script <ScriptPubKey>k__BackingField;
    [CompilerGeneratedAttribute]
private Script <RedeemScript>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <Confirmations>k__BackingField;
    [CompilerGeneratedAttribute]
private Money <Amount>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsSpendable>k__BackingField;
    public OutPoint OutPoint { get; private set; }
    public BitcoinAddress Address { get; private set; }
    public string Account { get; private set; }
    public Script ScriptPubKey { get; private set; }
    public Script RedeemScript { get; private set; }
    public UInt32 Confirmations { get; private set; }
    public Money Amount { get; private set; }
    public bool IsSpendable { get; private set; }
    internal UnspentCoin(JObject unspent, Network network);
    [CompilerGeneratedAttribute]
public OutPoint get_OutPoint();
    [CompilerGeneratedAttribute]
private void set_OutPoint(OutPoint value);
    [CompilerGeneratedAttribute]
public BitcoinAddress get_Address();
    [CompilerGeneratedAttribute]
private void set_Address(BitcoinAddress value);
    [CompilerGeneratedAttribute]
public string get_Account();
    [CompilerGeneratedAttribute]
private void set_Account(string value);
    [CompilerGeneratedAttribute]
public Script get_ScriptPubKey();
    [CompilerGeneratedAttribute]
private void set_ScriptPubKey(Script value);
    [CompilerGeneratedAttribute]
public Script get_RedeemScript();
    [CompilerGeneratedAttribute]
private void set_RedeemScript(Script value);
    [CompilerGeneratedAttribute]
public UInt32 get_Confirmations();
    [CompilerGeneratedAttribute]
private void set_Confirmations(UInt32 value);
    [CompilerGeneratedAttribute]
public Money get_Amount();
    [CompilerGeneratedAttribute]
private void set_Amount(Money value);
    public Coin AsCoin();
    [CompilerGeneratedAttribute]
public bool get_IsSpendable();
    [CompilerGeneratedAttribute]
private void set_IsSpendable(bool value);
}
public class NBitcoin.RPC.WalletCreateFundedPSBTResponse : object {
    [CompilerGeneratedAttribute]
private PSBT <PSBT>k__BackingField;
    [CompilerGeneratedAttribute]
private Money <Fee>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <ChangePos>k__BackingField;
    public PSBT PSBT { get; internal set; }
    public Money Fee { get; internal set; }
    public Nullable`1<int> ChangePos { get; internal set; }
    [CompilerGeneratedAttribute]
public PSBT get_PSBT();
    [CompilerGeneratedAttribute]
internal void set_PSBT(PSBT value);
    [CompilerGeneratedAttribute]
public Money get_Fee();
    [CompilerGeneratedAttribute]
internal void set_Fee(Money value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_ChangePos();
    [CompilerGeneratedAttribute]
internal void set_ChangePos(Nullable`1<int> value);
}
public class NBitcoin.RPC.WalletProcessPSBTResponse : object {
    [CompilerGeneratedAttribute]
private PSBT <PSBT>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Complete>k__BackingField;
    public PSBT PSBT { get; }
    public bool Complete { get; }
    public WalletProcessPSBTResponse(PSBT psbt, bool complete);
    [CompilerGeneratedAttribute]
public PSBT get_PSBT();
    [CompilerGeneratedAttribute]
public bool get_Complete();
}
public class NBitcoin.RPCTransactionRepository : object {
    private RPCClient _Client;
    public RPCTransactionRepository(RPCClient client);
    public sealed virtual Task`1<Transaction> GetAsync(uint256 txId);
    public Task BroadcastAsync(Transaction tx);
    public sealed virtual Task PutAsync(uint256 txId, Transaction tx);
}
public class NBitcoin.Scope : object {
    private Action close;
    public static IDisposable Nothing { get; }
    public Scope(Action open, Action close);
    public sealed virtual void Dispose();
    public static IDisposable get_Nothing();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NBitcoin.Script : object {
    private static Script _Empty;
    internal Byte[] _Script;
    [NullableAttribute("2")]
private Script _PaymentScript;
    [NullableAttribute("2")]
private ScriptId _Hash;
    [NullableAttribute("2")]
private WitScriptId _WitHash;
    public static Script Empty { get; }
    public int Length { get; }
    public Script PaymentScript { get; }
    public bool IsPushOnly { get; }
    public bool HasCanonicalPushes { get; }
    public ScriptId Hash { get; }
    public WitScriptId WitHash { get; }
    public bool IsMalleable { get; }
    public bool IsUnspendable { get; }
    public bool IsValid { get; }
    public Script(Op[] ops);
    public Script(IEnumerable`1<Op> ops);
    public Script(string script);
    public Script(Byte[] data);
    private Script(Byte[] data, bool unsafe, bool unused);
    public Script(IEnumerable`1<byte> data);
    public Script(Byte[] data, bool compressed);
    private static Script();
    public static Script get_Empty();
    private static Byte[] Parse(string script);
    public static Script FromBytesUnsafe(Byte[] data);
    public static Script FromHex(string hex);
    public int get_Length();
    public Script ExtractScriptCode(int codeSeparatorIndex);
    public ScriptReader CreateReader();
    private Script FindAndDelete(Op op);
    internal Script FindAndDelete(Byte[] pushedData);
    internal Script FindAndDelete(OpcodeType op);
    private Script FindAndDelete(Func`2<Op, bool> predicate);
    public string ToHex();
    public Script get_PaymentScript();
    public virtual string ToString();
    public bool get_IsPushOnly();
    public bool get_HasCanonicalPushes();
    public static Script op_Addition(Script a, IEnumerable`1<byte> bytes);
    public static Script op_Addition(Script a, Op op);
    public static Script op_Addition(Script a, IEnumerable`1<Op> ops);
    public IEnumerable`1<Op> ToOps();
    public UInt32 GetSigOpCount(bool fAccurate);
    public ScriptId get_Hash();
    public WitScriptId get_WitHash();
    public UInt32 GetSigOpCount(Script scriptSig);
    [NullableContextAttribute("2")]
public ScriptTemplate FindTemplate();
    public bool get_IsMalleable();
    public bool IsScriptType(ScriptType type);
    [ObsoleteAttribute("Do not use this, it isn't possible to get a signer's address from a script without taking heuristic which can be gamed by a malicious actor")]
public BitcoinAddress GetSignerAddress(Network network);
    [NullableContextAttribute("2")]
[ObsoleteAttribute("Do not use this, it isn't possible to get a signer's address from a script without taking heuristic which can be gamed by a malicious actor")]
public IAddressableDestination GetSigner();
    public BitcoinAddress GetDestinationAddress(Network network);
    [NullableContextAttribute("2")]
public IAddressableDestination GetDestination();
    public PubKey[] GetDestinationPublicKeys();
    public PubKey[] GetAllPubKeys();
    public Byte[] ToBytes();
    public Byte[] ToBytes(bool unsafe);
    public WitScript ToWitScript();
    public Byte[] ToCompressedBytes();
    [DefaultDllImportSearchPathsAttribute("514")]
private static int VerifyScriptConsensus(Byte[] scriptPubKey, UInt32 scriptPubKeyLen, Byte[] txTo, UInt32 txToLen, UInt32 nIn, ScriptVerify flags, BitcoinConsensusError& err);
    [DefaultDllImportSearchPathsAttribute("514")]
private static int VerifyScriptConsensusWithAmount(Byte[] scriptPubKey, UInt32 scriptPubKeyLen, long amount, Byte[] txTo, UInt32 txToLen, UInt32 nIn, ScriptVerify flags, BitcoinConsensusError& err);
    public static bool VerifyScriptConsensus(Script scriptPubKey, Transaction tx, UInt32 nIn, ScriptVerify flags);
    public static bool VerifyScriptConsensus(Script scriptPubKey, Transaction tx, UInt32 nIn, Money amount, ScriptVerify flags);
    public static bool VerifyScriptConsensus(Script scriptPubKey, Transaction tx, UInt32 nIn, ScriptVerify flags, BitcoinConsensusError& err);
    public static bool VerifyScriptConsensus(Script scriptPubKey, Transaction tx, UInt32 nIn, Money amount, ScriptVerify flags, BitcoinConsensusError& err);
    public bool get_IsUnspendable();
    [NullableContextAttribute("2")]
public static bool IsNullOrEmpty(Script script);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(Script item);
    [NullableContextAttribute("2")]
public static bool op_Equality(Script a, Script b);
    [NullableContextAttribute("2")]
public static bool op_Inequality(Script a, Script b);
    public virtual int GetHashCode();
    public Script Clone();
    public static Script CombineSignatures(Script scriptPubKey, Transaction transaction, int n, Script scriptSig1, Script scriptSig2);
    public static ScriptSigs CombineSignatures(Script scriptPubKey, TransactionChecker checker, ScriptSigs input1, ScriptSigs input2);
    private static Script CombineSignatures(Script scriptPubKey, TransactionChecker checker, Byte[][] sigs1, Byte[][] sigs2, HashVersion hashVersion);
    private static Script CombineMultisig(Script scriptPubKey, TransactionChecker checker, Byte[][] sigs1, Byte[][] sigs2, HashVersion hashVersion);
    private static Script PushAll(Byte[][] stack);
    [NullableContextAttribute("2")]
public static WitScript op_Implicit(Script script);
    private static Byte[][] Max(Byte[][] scriptSig1, Byte[][] scriptSig2);
    public bool get_IsValid();
}
public class NBitcoin.ScriptCoin : Coin {
    [CompilerGeneratedAttribute]
private Script <Redeem>k__BackingField;
    public bool IsP2SH { get; }
    public RedeemType RedeemType { get; }
    public Script Redeem { get; public set; }
    public bool CanGetScriptCode { get; }
    public ScriptCoin(OutPoint fromOutpoint, TxOut fromTxOut, Script redeem);
    public ScriptCoin(Transaction fromTx, UInt32 fromOutputIndex, Script redeem);
    public ScriptCoin(Transaction fromTx, TxOut fromOutput, Script redeem);
    public ScriptCoin(ICoin coin, Script redeem);
    public ScriptCoin(IndexedTxOut txOut, Script redeem);
    public ScriptCoin(uint256 txHash, UInt32 outputIndex, Money amount, Script scriptPubKey, Script redeem);
    private void AssertCoherent(string paramName);
    public bool get_IsP2SH();
    public Script GetP2SHRedeem();
    public RedeemType get_RedeemType();
    public static bool IsCoherent(Script scriptPubKey, Script redeem, String& error);
    [CompilerGeneratedAttribute]
public Script get_Redeem();
    [CompilerGeneratedAttribute]
public void set_Redeem(Script value);
    public virtual Script GetScriptCode();
    public virtual bool get_CanGetScriptCode();
    public virtual HashVersion GetHashVersion();
    public static IAddressableDestination GetRedeemHash(Script scriptPubKey);
}
public class NBitcoin.ScriptCompressor : object {
    private static UInt32 nSpecialScripts;
    private Byte[] _Script;
    public Byte[] ScriptBytes { get; }
    public ScriptCompressor(Script script);
    public Byte[] get_ScriptBytes();
    public Script GetScript();
    private Byte[] Compress();
    private Script Decompress(UInt32 nSize, Byte[] data);
    public sealed virtual void ReadWrite(BitcoinStream stream);
    private int GetSpecialSize(UInt32 nSize);
}
public enum NBitcoin.ScriptError : Enum {
    public int value__;
    public static ScriptError OK;
    public static ScriptError UnknownError;
    public static ScriptError EvalFalse;
    public static ScriptError OpReturn;
    public static ScriptError ScriptSize;
    public static ScriptError PushSize;
    public static ScriptError OpCount;
    public static ScriptError StackSize;
    public static ScriptError SigCount;
    public static ScriptError PubkeyCount;
    public static ScriptError Verify;
    public static ScriptError EqualVerify;
    public static ScriptError CheckMultiSigVerify;
    public static ScriptError CheckSigVerify;
    public static ScriptError NumEqualVerify;
    public static ScriptError BadOpCode;
    public static ScriptError DisabledOpCode;
    public static ScriptError InvalidStackOperation;
    public static ScriptError InvalidAltStackOperation;
    public static ScriptError UnbalancedConditional;
    public static ScriptError NegativeLockTime;
    public static ScriptError UnsatisfiedLockTime;
    public static ScriptError SigHashType;
    public static ScriptError SigDer;
    public static ScriptError MinimalData;
    public static ScriptError SigPushOnly;
    public static ScriptError SigHighS;
    public static ScriptError SigNullDummy;
    public static ScriptError PubKeyType;
    public static ScriptError CleanStack;
    public static ScriptError DiscourageUpgradableNops;
    public static ScriptError WitnessMalleated;
    public static ScriptError WitnessMalleatedP2SH;
    public static ScriptError WitnessProgramEmpty;
    public static ScriptError WitnessProgramMissmatch;
    public static ScriptError DiscourageUpgradableWitnessProgram;
    public static ScriptError WitnessProgramWrongLength;
    public static ScriptError WitnessUnexpected;
    public static ScriptError NullFail;
    public static ScriptError MinimalIf;
    public static ScriptError WitnessPubkeyType;
    public static ScriptError SchnorrSigSize;
    public static ScriptError SchnorrSigHashType;
    public static ScriptError SchnorrSig;
    public static ScriptError TaprootWrongControlSize;
    public static ScriptError DiscourageUpgradableTaprootVersion;
    public static ScriptError TapscriptValidationWeight;
    public static ScriptError DiscourageUpgradablePubKeyType;
    public static ScriptError DiscourageOpSuccess;
}
public class NBitcoin.ScriptEvaluationContext : object {
    private ContextStack`1<Byte[]> _stack;
    [CompilerGeneratedAttribute]
private ScriptVerify <ScriptVerify>k__BackingField;
    [CompilerGeneratedAttribute]
private ExecutionData <ExecutionData>k__BackingField;
    private static byte ANNEX_TAG;
    private static int MAX_STACK_SIZE;
    private static Byte[] vchFalse;
    private static Byte[] vchZero;
    private static Byte[] vchTrue;
    private static int MAX_OPS_PER_SCRIPT;
    private static int MAX_SCRIPT_ELEMENT_SIZE;
    private static int MAX_SCRIPT_SIZE;
    private static long VALIDATION_WEIGHT_PER_SIGOP_PASSED;
    [CompilerGeneratedAttribute]
private ScriptError <Error>k__BackingField;
    private static Byte[] vchMaxModOrder;
    private static Byte[] vchMaxModHalfOrder;
    private List`1<SignedHash> _SignedHashes;
    [CompilerGeneratedAttribute]
private Exception <ThrownException>k__BackingField;
    public ContextStack`1<Byte[]> Stack { get; }
    public ScriptVerify ScriptVerify { get; public set; }
    public ExecutionData ExecutionData { get; public set; }
    public ScriptError Error { get; public set; }
    public IEnumerable`1<SignedHash> SignedHashes { get; }
    public bool Result { get; }
    public Exception ThrownException { get; public set; }
    private static ScriptEvaluationContext();
    public ContextStack`1<Byte[]> get_Stack();
    [CompilerGeneratedAttribute]
public ScriptVerify get_ScriptVerify();
    [CompilerGeneratedAttribute]
public void set_ScriptVerify(ScriptVerify value);
    [CompilerGeneratedAttribute]
public ExecutionData get_ExecutionData();
    [CompilerGeneratedAttribute]
public void set_ExecutionData(ExecutionData value);
    public bool VerifyScript(Script scriptSig, Transaction txTo, int nIn, TxOut spentOutput);
    public bool VerifyScript(Script scriptSig, Script scriptPubKey, TransactionChecker checker);
    public bool VerifyScript(Script scriptSig, WitScript witness, Script scriptPubKey, TransactionChecker checker);
    private bool VerifyWitnessProgram(WitScript witness, WitProgramParameters wit, TransactionChecker checker, bool isP2SH);
    private bool ExecuteWitnessScript(ContextStack`1<Byte[]> stack, Script scriptPubKey, HashVersion sigversion, TransactionChecker checker);
    private bool IsOpSuccess(OpcodeType code);
    internal bool EvalScript(Script s, TransactionChecker checker, HashVersion hashversion);
    private bool EvalChecksig(Byte[] sig, Byte[] pubkey, Script s, int pbegincodehash, TransactionChecker checker, HashVersion sigversion, Boolean& success);
    private bool EvalChecksigPreTapscript(Byte[] vchSig, Byte[] vchPubKey, Script s, int pbegincodehash, TransactionChecker checker, HashVersion sigversion, Boolean& success);
    private bool CheckSequence(CScriptNum nSequence, TransactionChecker checker);
    private bool CheckLockTime(CScriptNum nLockTime, TransactionChecker checker);
    private bool SetSuccess(ScriptError scriptError);
    private bool SetError(ScriptError scriptError);
    private bool IsCompressedOrUncompressedPubKey(Byte[] vchPubKey);
    internal bool CheckSignatureEncoding(Byte[] vchSig);
    private bool CheckPubKeyEncoding(Byte[] vchPubKey, HashVersion sigversion);
    private static bool IsCompressedPubKey(Byte[] vchPubKey);
    private bool IsDefinedHashtypeSignature(Byte[] vchSig);
    private bool IsLowDERSignature(Byte[] vchSig);
    [CompilerGeneratedAttribute]
public ScriptError get_Error();
    [CompilerGeneratedAttribute]
public void set_Error(ScriptError value);
    private bool CheckSignatureElement(Byte[] vchSig, int i, int len, bool half);
    private int CompareBigEndian(Byte[] c1, int ic1, int c1len, Byte[] c2, int c2len);
    private static bool IsValidSignatureEncoding(Byte[] sig);
    private bool CheckMinimalPush(Byte[] data, OpcodeType opcode);
    private static bool CastToBool(Byte[] vch);
    public IEnumerable`1<SignedHash> get_SignedHashes();
    private bool CheckSig(Byte[] vchSig, Byte[] vchPubKey, Script scriptCode, TransactionChecker checker, HashVersion sigversion);
    private void Load(ScriptEvaluationContext other);
    public ScriptEvaluationContext Clone();
    public bool get_Result();
    [CompilerGeneratedAttribute]
public Exception get_ThrownException();
    [CompilerGeneratedAttribute]
public void set_ThrownException(Exception value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NBitcoin.ScriptId : object {
    private uint160 v;
    public Script ScriptPubKey { get; }
    public ScriptId(Byte[] value);
    public ScriptId(uint160 value);
    public ScriptId(string value);
    public ScriptId(Script script);
    public sealed virtual Script get_ScriptPubKey();
    public BitcoinScriptAddress GetAddress(Network network);
    private sealed virtual override BitcoinAddress NBitcoin.IAddressableDestination.GetAddress(Network network);
    public sealed virtual bool IsSupported(Network network);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
public static bool op_Equality(ScriptId a, ScriptId b);
    [NullableContextAttribute("2")]
public static bool op_Inequality(ScriptId a, ScriptId b);
    public virtual int GetHashCode();
    public Byte[] ToBytes();
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class NBitcoin.Scripting.OutputDescriptor : object {
    [CompilerGeneratedAttribute]
private Network <Network>k__BackingField;
    private static Char[] CHECKSUM_CHARSET;
    private static string INPUT_CHARSET_STRING;
    private static Char[] INPUT_CHARSET;
    public Network Network { get; }
    private OutputDescriptor(Network network);
    private static OutputDescriptor();
    [CompilerGeneratedAttribute]
public Network get_Network();
    public static OutputDescriptor NewAddr(IDestination dest, Network network);
    public static OutputDescriptor NewRaw(Script sc, Network network);
    public static OutputDescriptor NewPK(PubKeyProvider pk, Network network);
    public static OutputDescriptor NewPKH(PubKeyProvider pk, Network network);
    public static OutputDescriptor NewWPKH(PubKeyProvider pk, Network network);
    public static OutputDescriptor NewCombo(PubKeyProvider pk, Network network);
    public static OutputDescriptor NewMulti(UInt32 m, IEnumerable`1<PubKeyProvider> pks, bool isSorted, Network network, bool isTapScript);
    public static OutputDescriptor NewSH(OutputDescriptor inner, Network network);
    public static OutputDescriptor NewWSH(OutputDescriptor inner, Network network);
    public bool IsTopLevelOnly();
    public bool TryExpand(UInt32 pos, ISigningRepository repo, List`1& outputScripts, IDictionary`2<UInt32, ExtPubKey> cache);
    public bool TryExpand(UInt32 pos, Func`2<KeyId, Key> privateKeyProvider, ISigningRepository repo, List`1& outputScripts, bool isTaproot, IDictionary`2<UInt32, ExtPubKey> cache);
    private bool ExpandPkHelper(PubKeyProvider pkP, Func`2<KeyId, Key> privateKeyProvider, UInt32 pos, ISigningRepository repo, List`1<Script> outSc, bool isTaproot, IDictionary`2<UInt32, ExtPubKey> cache);
    private bool TryExpand(UInt32 pos, Func`2<KeyId, Key> privateKeyProvider, ISigningRepository repo, List`1<Script> outputScripts, bool isTaproot, IDictionary`2<UInt32, ExtPubKey> cache);
    private List`1<Script> MakeScripts(PubKey key, ISigningRepository repo, bool isTaproot);
    public bool IsSolvable();
    public bool IsRange();
    private static PubKeyProvider InferPubKey(PubKey pk, ISigningRepository repo);
    [NullableContextAttribute("2")]
private Nullable`1<ScriptPubKeyType> InferTemplate(ScriptTemplate template);
    public Nullable`1<ScriptPubKeyType> GetScriptPubKeyType();
    public static OutputDescriptor InferFromScript(Script sc, ISigningRepository repo, Network network);
    private static OutputDescriptor InferFromScript(Script sc, ISigningRepository repo, Network network, ScriptContext ctx);
    public virtual string ToString();
    public bool TryGetPrivateString(ISigningRepository secretProvider, String& result);
    private bool TryGetPrivateStringHelper(ISigningRepository secretProvider, String& result);
    private string ToStringHelper();
    public static OutputDescriptor Parse(string desc, Network network, bool requireCheckSum, ISigningRepository repo);
    public static bool TryParse(string desc, Network network, OutputDescriptor& result, bool requireCheckSum, ISigningRepository repo);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(OutputDescriptor other);
    public virtual int GetHashCode();
    public static string AddChecksum(string desc);
    public static string GetCheckSum(string desc);
    private static ulong PolyMod(ulong c, int val);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class NBitcoin.Scripting.OutputDescriptorParser : object {
    private static HexEncoder Hex;
    private static Parser`2<char, PubKey> PPubKeyUncompressed;
    private static OutputDescriptorParser();
    [ExtensionAttribute]
private static Parser`2<char, T> InjectRepository(Parser`2<char, T> subParser, ISigningRepository repo);
    private static Parser`2<char, PubKey> PPubKeyCompressed(ISigningRepository repo);
    private static Parser`2<char, PubKey> PPubKey(ISigningRepository repo);
    private static Parser`2<char, BitcoinExtPubKey> PRawXPub(ISigningRepository repo, Network n);
    private static Parser`2<char, RootedKeyPath> PRootedKeyPath(ISigningRepository repo);
    private static Parser`2<char, KeyPath> PKeyPath(ISigningRepository repo);
    private static Parser`2<char, BitcoinSecret> PTryConvertSecret(string secretStr, Network n);
    private static Parser`2<char, PubKey> PWIF(ISigningRepository repo, Network n, bool onlyCompressed);
    private static Parser`2<char, BitcoinExtPubKey> PExtKey(ISigningRepository repo, Network n);
    private static Parser`2<char, PubKeyProvider> PConstPubKeyProvider(ISigningRepository repo, Network n, PubKeyContext ctx);
    private static Parser`2<char, Tuple`2<BitcoinExtPubKey, KeyPath>> PHDPkProviderNoPath(ISigningRepository repo, Network n);
    private static Parser`2<char, Tuple`2<BitcoinExtPubKey, KeyPath>> PHDPkProviderWithpath(ISigningRepository repo, Network n);
    private static Parser`2<char, Tuple`2<BitcoinExtPubKey, KeyPath>> PHDPkProviderCommon(ISigningRepository repo, Network n);
    private static Parser`2<char, PubKeyProvider> PHardendedHDPubKeyProvider(ISigningRepository repo, Network n);
    private static Parser`2<char, PubKeyProvider> PUnHardendedHDPubKeyProvider(ISigningRepository repo, Network n);
    private static Parser`2<char, PubKeyProvider> PStaticHDPubKeyProvider(ISigningRepository repo, Network n);
    private static Parser`2<char, PubKeyProvider> PHDPubKeyProvider(ISigningRepository repo, Network n);
    private static Parser`2<char, PubKeyProvider> POriginPubkeyProvider(ISigningRepository repo, Network n, PubKeyContext ctx);
    internal static Parser`2<char, PubKeyProvider> PPubKeyProvider(ISigningRepository repo, Network n, PubKeyContext ctx);
    private static Parser`2<char, BitcoinAddress> PTryConvertAddr(string addrStr, Network n);
    internal static Parser`2<char, OutputDescriptor> PAddr(Network n);
    internal static Parser`2<char, OutputDescriptor> PRaw(ISigningRepository repo, Network n);
    private static Parser`2<char, OutputDescriptor> PExprHelper(Parser`2<char, string> PName, Parser`2<char, T> pInner, Func`3<T, Network, OutputDescriptor> constructor, Network n);
    private static Parser`2<char, OutputDescriptor> PPKHelper(string name, Func`3<PubKeyProvider, Network, OutputDescriptor> constructor, ISigningRepository repo, Network n, PubKeyContext ctx);
    internal static Parser`2<char, OutputDescriptor> PPK(ISigningRepository repo, Network n, PubKeyContext ctx);
    internal static Parser`2<char, OutputDescriptor> PPKH(ISigningRepository repo, Network n, PubKeyContext ctx);
    internal static Parser`2<char, OutputDescriptor> PWPKH(ISigningRepository repo, Network n);
    internal static Parser`2<char, OutputDescriptor> PCombo(ISigningRepository repo, Network n);
    internal static Parser`2<char, OutputDescriptor> PMulti(ISigningRepository repo, Network n, Nullable`1<UInt32> maxMultisigN, PubKeyContext ctx);
    private static Parser`2<char, OutputDescriptor> PWSHInner(ISigningRepository repo, Network n, PubKeyContext ctx, Nullable`1<UInt32> maxMultisigN);
    private static Parser`2<char, OutputDescriptor> PInner(ISigningRepository repo, Network n, PubKeyContext ctx, Nullable`1<UInt32> maxMultisigN);
    private static Parser`2<char, OutputDescriptor> PWSH(ISigningRepository repo, Network n);
    private static Parser`2<char, OutputDescriptor> PSH(ISigningRepository repo, Network n);
    private static Parser`2<char, OutputDescriptor> POutputDescriptor(ISigningRepository repo, Network n);
    internal static bool TryParseOD(string str, Network network, OutputDescriptor& result, bool requireCheckSum, ISigningRepository repo);
    [NullableContextAttribute("2")]
private static bool TryParseOD(string str, Network network, String& whyFailure, OutputDescriptor& result, bool requireCheckSum, ISigningRepository repo);
    internal static OutputDescriptor ParseOD(string str, Network network, bool requireCheckSum, ISigningRepository repo);
}
internal interface NBitcoin.Scripting.Parser.IInput`1 {
    public bool AtEnd { get; }
    public int Position { get; }
    public IDictionary`2<object, object> Memos { get; }
    public abstract virtual IInput`1<T> Advance();
    public abstract virtual T GetCurrent();
    public abstract virtual bool get_AtEnd();
    public abstract virtual int get_Position();
    public abstract virtual IDictionary`2<object, object> get_Memos();
}
[ExtensionAttribute]
internal static class NBitcoin.Scripting.Parser.Parse : object {
    private static string ValidHex;
    private static string ValidBase58;
    private static Char[] ValidHexChars;
    private static Char[] ValidBase58Chars;
    public static Parser`2<char, char> AnyChar;
    public static Parser`2<char, char> WhiteSpace;
    public static Parser`2<char, char> Digit;
    public static Parser`2<char, char> Letter;
    public static Parser`2<char, char> LetterOrDigit;
    public static Parser`2<char, char> Hex;
    public static Parser`2<char, char> Base58;
    public static Parser`2<char, char> Numeric;
    public static Parser`2<char, string> Number;
    public static Parser`2<char, string> Decimal;
    private static Parse();
    public static Parser`2<char, char> Char(Func`2<char, bool> predicate, string expected);
    public static Parser`2<char, char> CharExcept(Func`2<char, bool> predicate, string description);
    public static Parser`2<char, char> Char(char c);
    public static Parser`2<char, char> Chars(Char[] c);
    public static Parser`2<char, char> Chars(string c);
    public static Parser`2<char, char> CharExcept(char c);
    public static Parser`2<char, IEnumerable`1<char>> String(string s);
    [ExtensionAttribute]
public static Parser`2<char, T> Token(Parser`2<char, T> parser);
    [ExtensionAttribute]
public static Parser`2<char, string> Text(Parser`2<char, IEnumerable`1<char>> characters);
    private static Parser`2<char, string> DecimalWithoutLeadingDigits(CultureInfo ci);
    private static Parser`2<char, string> DecimalWithLeadingDigits(CultureInfo ci);
    [ExtensionAttribute]
public static Parser`2<TToken, U> Then(Parser`2<TToken, T> first, Func`2<T, Parser`2<TToken, U>> second);
    [ExtensionAttribute]
public static Parser`2<TToken, IEnumerable`1<T>> Many(Parser`2<TToken, T> parser);
    [ExtensionAttribute]
public static Parser`2<TToken, IEnumerable`1<T>> XMany(Parser`2<TToken, T> parser);
    [ExtensionAttribute]
public static Parser`2<TToken, IEnumerable`1<T>> AtLeastOnce(Parser`2<TToken, T> parser);
    [ExtensionAttribute]
public static Parser`2<TToken, IEnumerable`1<T>> Once(Parser`2<TToken, T> parser);
    [ExtensionAttribute]
public static Parser`2<TToken, IEnumerable`1<T>> AtLeastOne(Parser`2<TToken, T> parser);
    [ExtensionAttribute]
public static Parser`2<TToken, IEnumerable`1<T>> XAtLeastOnce(Parser`2<TToken, T> parser);
    public static Parser`2<TToken, T> Return(T v);
    [ExtensionAttribute]
public static Parser`2<TToken, U> Select(Parser`2<TToken, T> parser, Func`2<T, U> convert);
    [ExtensionAttribute]
public static Parser`2<TToken, IEnumerable`1<T>> Sequence(IEnumerable`1<Parser`2<TToken, T>> parserList);
    public static Parser`2<TToken, T> Ref(Func`1<Parser`2<TToken, T>> reference);
    [ExtensionAttribute]
public static Parser`2<TToken, T> Or(Parser`2<TToken, T> first, Parser`2<TToken, T> second);
    [ExtensionAttribute]
public static Parser`2<TToken, T> XOr(Parser`2<TToken, T> first, Parser`2<TToken, T> second);
    [ExtensionAttribute]
public static Parser`2<TToken, IEnumerable`1<T>> Concat(Parser`2<TToken, IEnumerable`1<T>> first, Parser`2<TToken, IEnumerable`1<T>> second);
    public static ParserResult`2<TToken, T> DetermineBestError(ParserResult`2<TToken, T> firstF, ParserResult`2<TToken, T> secondF);
    [ExtensionAttribute]
public static Parser`2<TToken, U> Return(Parser`2<TToken, T> parser, U value);
    [ExtensionAttribute]
public static Parser`2<TToken, T> Except(Parser`2<TToken, T> parser, Parser`2<TToken, U> except);
    [ExtensionAttribute]
public static Parser`2<TToken, T> End(Parser`2<TToken, T> parser);
    [ExtensionAttribute]
public static Parser`2<TToken, IEnumerable`1<T>> Until(Parser`2<TToken, T> parser, Parser`2<TToken, U> until);
    [ExtensionAttribute]
public static Parser`2<TToken, T> Where(Parser`2<TToken, T> parser, Func`2<T, bool> predicate);
    [ExtensionAttribute]
public static Parser`2<TToken, V> SelectMany(Parser`2<TToken, T> parser, Func`2<T, Parser`2<TToken, U>> selector, Func`3<T, U, V> projector);
    [ExtensionAttribute]
public static Parser`2<TToken, U> Bind(Parser`2<TToken, T> parser, Func`2<T, Parser`2<TToken, U>> selector);
    public static Parser`2<TToken, T> ChainOperator(Parser`2<TToken, TOp> op, Parser`2<TToken, T> operand, Func`4<TOp, T, T, T> apply);
    public static Parser`2<TToken, T> XChainOperator(Parser`2<TToken, TOp> op, Parser`2<TToken, T> operand, Func`4<TOp, T, T, T> apply);
    private static Parser`2<TToken, T> ChainOperatorRest(T firstOperand, Parser`2<TToken, TOp> op, Parser`2<TToken, T> operand, Func`4<TOp, T, T, T> apply, Func`3<Parser`2<TToken, T>, Parser`2<TToken, T>, Parser`2<TToken, T>> or);
    public static Parser`2<TToken, T> ChainRightOperator(Parser`2<TToken, TOp> op, Parser`2<TToken, T> operand, Func`4<TOp, T, T, T> apply);
    public static Parser`2<TToken, T> XChainRightOperator(Parser`2<TToken, TOp> op, Parser`2<TToken, T> operand, Func`4<TOp, T, T, T> apply);
    private static Parser`2<TToken, T> ChainRightOperatorRest(T lastOperand, Parser`2<TToken, TOp> op, Parser`2<TToken, T> operand, Func`4<TOp, T, T, T> apply, Func`3<Parser`2<TToken, T>, Parser`2<TToken, T>, Parser`2<TToken, T>> or);
    [ExtensionAttribute]
public static Parser`2<TToken, IEnumerable`1<T>> DelimitedBy(Parser`2<TToken, T> parser, Parser`2<TToken, U> delimiter);
    [ExtensionAttribute]
public static Parser`2<TToken, IEnumerable`1<T>> XDelimitedBy(Parser`2<TToken, T> itemParser, Parser`2<TToken, U> delimiter);
    [ExtensionAttribute]
public static Parser`2<TToken, IEnumerable`1<T>> Repeat(Parser`2<TToken, T> parser, int count);
    [ExtensionAttribute]
public static Parser`2<TToken, IEnumerable`1<T>> Repeat(Parser`2<TToken, T> parser, int minimumCount, int maximumCount);
    internal static Parser`2<char, T> TryConvert(string str, Func`2<string, T> converter);
    internal static Parser`2<char, T> TryConvert(string str, SafeConverter`2<string, T> safeConverter);
    public static Parser`2<ScriptToken, ScriptToken> ScriptToken(Func`2<int, bool> predicate, string expected);
    public static Parser`2<ScriptToken, ScriptToken> ScriptToken(ScriptToken sct, string expected);
    public static Parser`2<ScriptToken, ScriptToken> ScriptToken(int tag);
    public static Parser`2<ScriptToken, ScriptToken> ScriptToken(ScriptToken sct);
}
internal class NBitcoin.Scripting.Parser.Parser`1 : MulticastDelegate {
    public Parser`1(object object, IntPtr method);
    public virtual ParserResult`2<char, TValue> Invoke(IInput`1<char> input);
    public virtual IAsyncResult BeginInvoke(IInput`1<char> input, AsyncCallback callback, object object);
    public virtual ParserResult`2<char, TValue> EndInvoke(IAsyncResult result);
}
internal class NBitcoin.Scripting.Parser.Parser`2 : MulticastDelegate {
    public Parser`2(object object, IntPtr method);
    public virtual ParserResult`2<TToken, TValue> Invoke(IInput`1<TToken> input, Network network);
    public virtual IAsyncResult BeginInvoke(IInput`1<TToken> input, Network network, AsyncCallback callback, object object);
    public virtual ParserResult`2<TToken, TValue> EndInvoke(IAsyncResult result);
}
[ExtensionAttribute]
internal static class NBitcoin.Scripting.Parser.ParserExtension : object {
    [ExtensionAttribute]
internal static ParserResult`2<char, T> TryParse(Parser`2<char, T> parser, string input, Network network);
    [ExtensionAttribute]
internal static T Parse(Parser`2<char, T> parser, string input, Network network);
    [ExtensionAttribute]
internal static ParserResult`2<ScriptToken, T> TryParse(Parser`2<ScriptToken, T> parser, Network network, Script input);
    [ExtensionAttribute]
internal static T Parse(Parser`2<ScriptToken, T> parser, Script input, Network network);
}
internal class NBitcoin.Scripting.Parser.ParserResult`2 : object {
    public TValue Value;
    public IInput`1<TToken> Rest;
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <Expected>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsSuccess>k__BackingField;
    public IEnumerable`1<string> Expected { get; private set; }
    public string Description { get; private set; }
    public bool IsSuccess { get; private set; }
    private ParserResult`2(IInput`1<TToken> rest, TValue value);
    public static ParserResult`2<TToken, TValue> Success(IInput`1<TToken> rest, TValue v);
    public static ParserResult`2<TToken, TValue> Failure(IInput`1<TToken> rest, string description);
    public static ParserResult`2<TToken, TValue> Failure(IInput`1<TToken> rest, IEnumerable`1<string> expected, string description);
    public ParserResult`2<TToken, U> IfSuccess(Func`2<ParserResult`2<TToken, TValue>, ParserResult`2<TToken, U>> next);
    public ParserResult`2<TToken, TValue> IfFailure(Func`2<ParserResult`2<TToken, TValue>, ParserResult`2<TToken, TValue>> next);
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_Expected();
    [CompilerGeneratedAttribute]
private void set_Expected(IEnumerable`1<string> value);
    [CompilerGeneratedAttribute]
public string get_Description();
    [CompilerGeneratedAttribute]
private void set_Description(string value);
    [CompilerGeneratedAttribute]
public bool get_IsSuccess();
    [CompilerGeneratedAttribute]
private void set_IsSuccess(bool value);
    public virtual string ToString();
}
public class NBitcoin.Scripting.Parser.ParsingException : FormatException {
    [CompilerGeneratedAttribute]
private int <Position>k__BackingField;
    public int Position { get; }
    public ParsingException(string message);
    public ParsingException(string message, int position);
    public ParsingException(string message, Exception innerException);
    [CompilerGeneratedAttribute]
public int get_Position();
}
internal class NBitcoin.Scripting.Parser.ScriptInput : object {
    [CompilerGeneratedAttribute]
private ScriptToken[] <Source>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Position>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<object, object> <Memos>k__BackingField;
    public ScriptToken[] Source { get; }
    public int Position { get; }
    public bool AtEnd { get; }
    public IDictionary`2<object, object> Memos { get; }
    public ScriptInput(Script source);
    public ScriptInput(ScriptToken[] source);
    internal ScriptInput(ScriptToken[] source, int position);
    [CompilerGeneratedAttribute]
public ScriptToken[] get_Source();
    [CompilerGeneratedAttribute]
public sealed virtual int get_Position();
    public sealed virtual bool get_AtEnd();
    public sealed virtual ScriptToken GetCurrent();
    public sealed virtual IInput`1<ScriptToken> Advance();
    public sealed virtual IEnumerator`1<ScriptToken> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [CompilerGeneratedAttribute]
public sealed virtual IDictionary`2<object, object> get_Memos();
}
internal class NBitcoin.Scripting.Parser.StringInput : object {
    [CompilerGeneratedAttribute]
private string <Source>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Position>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<object, object> <Memos>k__BackingField;
    public string Source { get; }
    public int Position { get; }
    public bool AtEnd { get; }
    public IDictionary`2<object, object> Memos { get; }
    public StringInput(string source);
    internal StringInput(string source, int position);
    [CompilerGeneratedAttribute]
public string get_Source();
    [CompilerGeneratedAttribute]
public sealed virtual int get_Position();
    public sealed virtual bool get_AtEnd();
    public sealed virtual char GetCurrent();
    public sealed virtual IInput`1<char> Advance();
    public sealed virtual IEnumerator`1<char> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [CompilerGeneratedAttribute]
public sealed virtual IDictionary`2<object, object> get_Memos();
}
internal static class NBitcoin.Scripting.ParserUtil : object {
    internal static Parser`2<char, string> SurroundedByBrackets;
    private static ParserUtil();
}
public abstract class NBitcoin.Scripting.PubKeyProvider : object {
    public static PubKeyProvider NewOrigin(RootedKeyPath keyOrigin, PubKeyProvider inner);
    public static PubKeyProvider NewConst(PubKey pk);
    public static PubKeyProvider NewConst(PubKey pk, bool xonly);
    public static PubKeyProvider NewHD(BitcoinExtPubKey extPubKey, KeyPath kp, DeriveType t);
    public PubKey GetPubKey(UInt32 pos, Func`2<KeyId, Key> privateKeyProvider);
    public PubKey GetPubKey(UInt32 pos, Func`2<KeyId, Key> privateKeyProvider, RootedKeyPath& keyOriginInfo);
    public bool TryGetPubKey(UInt32 pos, Func`2<KeyId, Key> privateKeyProvider, RootedKeyPath& keyOriginInfo, PubKey& pubkey);
    public bool IsRange();
    public bool IsCompressed();
    public virtual string ToString();
    internal bool TryGetPrivateString(ISigningRepository secretProvider, String& ret);
    public sealed virtual bool Equals(object obj);
    public sealed virtual bool Equals(PubKeyProvider other);
    public virtual int GetHashCode();
}
[ExtensionAttribute]
public static class NBitcoin.Scripting.ScriptExtensions : object {
    [ExtensionAttribute]
internal static ScriptToken[] ToTokens(Script sc);
    private static ScriptToken GetItem(Op op);
}
internal class NBitcoin.Scripting.ScriptToken : object {
    [CompilerGeneratedAttribute]
private int <Tag>k__BackingField;
    internal static ScriptToken _unique_BoolAnd;
    internal static ScriptToken _unique_BoolOr;
    internal static ScriptToken _unique_Add;
    internal static ScriptToken _unique_Equal;
    internal static ScriptToken _unique_EqualVerify;
    internal static ScriptToken _unique_CheckSig;
    internal static ScriptToken _unique_CheckSigVerify;
    internal static ScriptToken _unique_CheckMultiSig;
    internal static ScriptToken _unique_CheckMultiSigVerify;
    internal static ScriptToken _unique_CheckSequenceVerify;
    internal static ScriptToken _unique_FromAltStack;
    internal static ScriptToken _unique_ToAltStack;
    internal static ScriptToken _unique_Drop;
    internal static ScriptToken _unique_Dup;
    internal static ScriptToken _unique_If;
    internal static ScriptToken _unique_IfDup;
    internal static ScriptToken _unique_NotIf;
    internal static ScriptToken _unique_Else;
    internal static ScriptToken _unique_EndIf;
    internal static ScriptToken _unique_ZeroNotEqual;
    internal static ScriptToken _unique_Size;
    internal static ScriptToken _unique_Swap;
    internal static ScriptToken _unique_Verify;
    internal static ScriptToken _unique_Hash160;
    internal static ScriptToken _unique_Sha256;
    internal int Tag { get; }
    internal static ScriptToken BoolAnd { get; }
    internal static ScriptToken BoolOr { get; }
    internal static ScriptToken Add { get; }
    internal static ScriptToken Equal { get; }
    internal static ScriptToken EqualVerify { get; }
    internal static ScriptToken CheckSig { get; }
    internal static ScriptToken CheckSigVerify { get; }
    internal static ScriptToken CheckMultiSig { get; }
    internal static ScriptToken CheckMultiSigVerify { get; }
    internal static ScriptToken CheckSequenceVerify { get; }
    internal static ScriptToken FromAltStack { get; }
    internal static ScriptToken ToAltStack { get; }
    internal static ScriptToken Drop { get; }
    internal static ScriptToken Dup { get; }
    internal static ScriptToken If { get; }
    internal static ScriptToken IfDup { get; }
    internal static ScriptToken NotIf { get; }
    internal static ScriptToken Else { get; }
    internal static ScriptToken EndIf { get; }
    internal static ScriptToken ZeroNotEqual { get; }
    internal static ScriptToken Size { get; }
    internal static ScriptToken Swap { get; }
    internal static ScriptToken Verify { get; }
    internal static ScriptToken Hash160 { get; }
    internal static ScriptToken Sha256 { get; }
    private ScriptToken(int tag);
    private static ScriptToken();
    [CompilerGeneratedAttribute]
internal int get_Tag();
    internal static ScriptToken get_BoolAnd();
    internal static ScriptToken get_BoolOr();
    internal static ScriptToken get_Add();
    internal static ScriptToken get_Equal();
    internal static ScriptToken get_EqualVerify();
    internal static ScriptToken get_CheckSig();
    internal static ScriptToken get_CheckSigVerify();
    internal static ScriptToken get_CheckMultiSig();
    internal static ScriptToken get_CheckMultiSigVerify();
    internal static ScriptToken get_CheckSequenceVerify();
    internal static ScriptToken get_FromAltStack();
    internal static ScriptToken get_ToAltStack();
    internal static ScriptToken get_Drop();
    internal static ScriptToken get_Dup();
    internal static ScriptToken get_If();
    internal static ScriptToken get_IfDup();
    internal static ScriptToken get_NotIf();
    internal static ScriptToken get_Else();
    internal static ScriptToken get_EndIf();
    internal static ScriptToken get_ZeroNotEqual();
    internal static ScriptToken get_Size();
    internal static ScriptToken get_Swap();
    internal static ScriptToken get_Verify();
    internal static ScriptToken get_Hash160();
    internal static ScriptToken get_Sha256();
    public virtual string ToString();
    public sealed virtual int GetHashCode();
    public sealed virtual bool Equals(object obj);
    public sealed virtual bool Equals(ScriptToken obj);
}
public enum NBitcoin.ScriptPubKeyType : Enum {
    public int value__;
    public static ScriptPubKeyType Legacy;
    public static ScriptPubKeyType Segwit;
    public static ScriptPubKeyType SegwitP2SH;
    [ObsoleteAttribute("TaprootBIP86 is unavailable in .net framework")]
public static ScriptPubKeyType TaprootBIP86;
}
public class NBitcoin.ScriptReader : object {
    private Stream _Inner;
    private static Byte[] Scratch;
    [CompilerGeneratedAttribute]
private bool <HasError>k__BackingField;
    public Stream Inner { get; }
    public bool HasError { get; private set; }
    public ScriptReader(Stream stream);
    public ScriptReader(Byte[] data);
    private static ScriptReader();
    public Stream get_Inner();
    public Op Read();
    public bool TryReadOpCode(OpcodeType& opcode);
    private void MoveStream(Stream inner, UInt32 bytes);
    [CompilerGeneratedAttribute]
public bool get_HasError();
    [CompilerGeneratedAttribute]
private void set_HasError(bool value);
    [IteratorStateMachineAttribute("NBitcoin.ScriptReader/<ToEnumerable>d__13")]
public IEnumerable`1<Op> ToEnumerable();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NBitcoin.ScriptSigs : object {
    [CompilerGeneratedAttribute]
private Script <ScriptSig>k__BackingField;
    [CompilerGeneratedAttribute]
private WitScript <WitSig>k__BackingField;
    public Script ScriptSig { get; public set; }
    public WitScript WitSig { get; public set; }
    [CompilerGeneratedAttribute]
public Script get_ScriptSig();
    [CompilerGeneratedAttribute]
public void set_ScriptSig(Script value);
    [CompilerGeneratedAttribute]
public WitScript get_WitSig();
    [CompilerGeneratedAttribute]
public void set_WitSig(WitScript value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class NBitcoin.ScriptTemplate : object {
    public virtual bool CheckScriptPubKey(Script scriptPubKey);
    protected virtual bool FastCheckScriptPubKey(Script scriptPubKey, Boolean& needMoreCheck);
    protected abstract virtual bool CheckScriptPubKeyCore(Script scriptPubKey, Op[] scriptPubKeyOps);
    public virtual bool CheckScriptSig(Script scriptSig, Script scriptPubKey);
    protected virtual bool FastCheckScriptSig(Script scriptSig, Script scriptPubKey, Boolean& needMoreCheck);
    protected abstract virtual bool CheckScriptSigCore(Script scriptSig, Op[] scriptSigOps, Script scriptPubKey, Op[] scriptPubKeyOps);
}
public enum NBitcoin.ScriptType : Enum {
    public int value__;
    public static ScriptType Witness;
    public static ScriptType P2PKH;
    public static ScriptType P2SH;
    public static ScriptType P2PK;
    public static ScriptType P2WPKH;
    public static ScriptType P2WSH;
    public static ScriptType MultiSig;
    public static ScriptType Taproot;
}
[FlagsAttribute]
public enum NBitcoin.ScriptVerify : Enum {
    public UInt32 value__;
    public static ScriptVerify None;
    public static ScriptVerify P2SH;
    public static ScriptVerify StrictEnc;
    public static ScriptVerify DerSig;
    public static ScriptVerify LowS;
    public static ScriptVerify NullDummy;
    public static ScriptVerify SigPushOnly;
    public static ScriptVerify MinimalData;
    public static ScriptVerify DiscourageUpgradableNops;
    public static ScriptVerify CleanStack;
    public static ScriptVerify CheckLockTimeVerify;
    public static ScriptVerify CheckSequenceVerify;
    public static ScriptVerify Witness;
    public static ScriptVerify DiscourageUpgradableWitnessProgram;
    public static ScriptVerify MinimalIf;
    public static ScriptVerify NullFail;
    public static ScriptVerify WitnessPubkeyType;
    public static ScriptVerify ConstScriptCode;
    public static ScriptVerify ForkId;
    public static ScriptVerify Taproot;
    public static ScriptVerify DiscourageUpgradableTaprootVersion;
    public static ScriptVerify DiscourageOpSuccess;
    public static ScriptVerify DiscourageUpgradablePubKeyType;
    public static ScriptVerify Mandatory;
    public static ScriptVerify Standard;
    public static ScriptVerify Consensus;
}
public class NBitcoin.Sequence : ValueType {
    public static UInt32 SEQUENCE_LOCKTIME_DISABLE_FLAG;
    public static UInt32 SEQUENCE_LOCKTIME_TYPE_FLAG;
    public static UInt32 SEQUENCE_LOCKTIME_MASK;
    public static UInt32 SEQUENCE_FINAL;
    public static UInt32 MAX_BIP125_RBF_SEQUENCE;
    internal static int SEQUENCE_LOCKTIME_GRANULARITY;
    private UInt32 _ValueInv;
    public static Sequence Final { get; }
    public static Sequence OptInRBF { get; }
    public static Sequence FeeSnipping { get; }
    public UInt32 Value { get; }
    public bool IsRelativeLock { get; }
    public bool IsRBF { get; }
    public SequenceLockType LockType { get; }
    public int LockHeight { get; }
    public TimeSpan LockPeriod { get; }
    public Sequence(UInt32 value);
    public Sequence(int lockHeight);
    public Sequence(TimeSpan period);
    public static Sequence get_Final();
    public static Sequence get_OptInRBF();
    public static Sequence get_FeeSnipping();
    public UInt32 get_Value();
    public bool get_IsRelativeLock();
    public bool get_IsRBF();
    public SequenceLockType get_LockType();
    public static UInt32 op_Implicit(Sequence a);
    public static Sequence op_Implicit(UInt32 a);
    private void AssertRelativeLock();
    public virtual string ToString();
    public int get_LockHeight();
    public TimeSpan get_LockPeriod();
}
public class NBitcoin.SequenceLock : object {
    [CompilerGeneratedAttribute]
private int <MinHeight>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <MinTime>k__BackingField;
    public int MinHeight { get; public set; }
    public DateTimeOffset MinTime { get; public set; }
    public SequenceLock(int minHeight, DateTimeOffset minTime);
    public SequenceLock(int minHeight, long minTime);
    [CompilerGeneratedAttribute]
public int get_MinHeight();
    [CompilerGeneratedAttribute]
public void set_MinHeight(int value);
    [CompilerGeneratedAttribute]
public DateTimeOffset get_MinTime();
    [CompilerGeneratedAttribute]
public void set_MinTime(DateTimeOffset value);
    public bool Evaluate(ChainedBlock block);
}
public enum NBitcoin.SequenceLockType : Enum {
    public int value__;
    public static SequenceLockType Time;
    public static SequenceLockType Height;
}
public enum NBitcoin.SerializationType : Enum {
    public int value__;
    public static SerializationType Disk;
    public static SerializationType Network;
    public static SerializationType Hash;
}
[FlagsAttribute]
public enum NBitcoin.SigHash : Enum {
    public UInt32 value__;
    public static SigHash All;
    public static SigHash None;
    public static SigHash Single;
    public static SigHash AnyoneCanPay;
}
public class NBitcoin.SignedHash : object {
    [CompilerGeneratedAttribute]
private ITransactionSignature <Signature>k__BackingField;
    [CompilerGeneratedAttribute]
private Script <ScriptCode>k__BackingField;
    [CompilerGeneratedAttribute]
private HashVersion <HashVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private uint256 <Hash>k__BackingField;
    public ITransactionSignature Signature { get; internal set; }
    public Script ScriptCode { get; internal set; }
    public HashVersion HashVersion { get; internal set; }
    public uint256 Hash { get; internal set; }
    [CompilerGeneratedAttribute]
public ITransactionSignature get_Signature();
    [CompilerGeneratedAttribute]
internal void set_Signature(ITransactionSignature value);
    [CompilerGeneratedAttribute]
public Script get_ScriptCode();
    [CompilerGeneratedAttribute]
internal void set_ScriptCode(Script value);
    [CompilerGeneratedAttribute]
public HashVersion get_HashVersion();
    [CompilerGeneratedAttribute]
internal void set_HashVersion(HashVersion value);
    [CompilerGeneratedAttribute]
public uint256 get_Hash();
    [CompilerGeneratedAttribute]
internal void set_Hash(uint256 value);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class NBitcoin.SigningOptions : object {
    [CompilerGeneratedAttribute]
private SigHash <SigHash>k__BackingField;
    [CompilerGeneratedAttribute]
private TaprootSigHash <TaprootSigHash>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EnforceLowR>k__BackingField;
    [CompilerGeneratedAttribute]
private PrecomputedTransactionData <PrecomputedTransactionData>k__BackingField;
    public SigHash SigHash { get; public set; }
    public TaprootSigHash TaprootSigHash { get; public set; }
    public bool EnforceLowR { get; public set; }
    public PrecomputedTransactionData PrecomputedTransactionData { get; public set; }
    public SigningOptions(SigHash sigHash);
    [NullableContextAttribute("1")]
public SigningOptions(TaprootSigHash sigHash, TaprootReadyPrecomputedTransactionData precomputedTransactionData);
    public SigningOptions(SigHash sigHash, bool useLowR);
    [CompilerGeneratedAttribute]
public SigHash get_SigHash();
    [CompilerGeneratedAttribute]
public void set_SigHash(SigHash value);
    [CompilerGeneratedAttribute]
public TaprootSigHash get_TaprootSigHash();
    [CompilerGeneratedAttribute]
public void set_TaprootSigHash(TaprootSigHash value);
    [CompilerGeneratedAttribute]
public bool get_EnforceLowR();
    [CompilerGeneratedAttribute]
public void set_EnforceLowR(bool value);
    [CompilerGeneratedAttribute]
public PrecomputedTransactionData get_PrecomputedTransactionData();
    [CompilerGeneratedAttribute]
public void set_PrecomputedTransactionData(PrecomputedTransactionData value);
    [NullableContextAttribute("1")]
public SigningOptions Clone();
}
public class NBitcoin.SlimChain : object {
    private Dictionary`2<uint256, int> _HeightsByBlockHash;
    private uint256[] _BlockHashesByHeight;
    private int _Height;
    private ReaderWriterLock _lock;
    public int Height { get; }
    public uint256 Tip { get; }
    public SlimChainedBlock TipBlock { get; }
    public uint256 Genesis { get; }
    public SlimChain(uint256 genesis);
    public SlimChain(uint256 genesis, int capacity);
    public int get_Height();
    public bool Contains(uint256 blockHash);
    public bool TryGetHeight(uint256 blockHash, Int32& height);
    public bool TryGetHash(int height, uint256& blockHash);
    public void ResetToGenesis();
    public void SetCapacity(int capacity);
    public bool TrySetTip(uint256 newTip, uint256 previous, bool nopIfContainsTip);
    private bool TrySetTipNoLock(uint256& newTip, uint256& previous, bool nopIfContainsTip);
    public BlockLocator GetTipLocator();
    public BlockLocator GetLocator(int height);
    public BlockLocator GetLocator(uint256 blockHash);
    private BlockLocator GetLocatorNoLock(int height);
    public SlimChainedBlock FindFork(BlockLocator blockLocator);
    public uint256 get_Tip();
    public SlimChainedBlock get_TipBlock();
    public SlimChainedBlock GetBlock(int height);
    public SlimChainedBlock GetBlock(uint256 blockHash);
    private SlimChainedBlock CreateSlimBlock(int height);
    public uint256 get_Genesis();
    public void Save(Stream output);
    public void Load(Stream input);
    public virtual string ToString();
}
public class NBitcoin.SlimChainedBlock : object {
    private uint256 _Hash;
    private uint256 _Previous;
    private int _Height;
    public uint256 Hash { get; }
    public uint256 Previous { get; }
    public int Height { get; }
    public SlimChainedBlock(uint256 hash, uint256 prev, int height);
    public uint256 get_Hash();
    public uint256 get_Previous();
    public int get_Height();
    public virtual string ToString();
}
public static class NBitcoin.StandardScripts : object {
    private static ScriptTemplate[] _StandardTemplates;
    private static StandardScripts();
    public static bool IsStandardTransaction(Transaction tx);
    public static bool AreOutputsStandard(Transaction tx);
    public static ScriptTemplate GetTemplateFromScriptPubKey(Script script);
    public static bool IsStandardScriptPubKey(Script scriptPubKey);
    private static bool IsStandardScriptSig(Script scriptSig, Script scriptPubKey);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NBitcoin.TaprootAddress : BitcoinAddress {
    private TaprootPubKey _PubKey;
    public TaprootPubKey PubKey { get; }
    public Bech32Type Type { get; }
    internal TaprootAddress(string str, TaprootPubKey key, Network network);
    internal TaprootAddress(string str, Byte[] key, Network network);
    public TaprootAddress(TaprootPubKey pubKey, Network network);
    public static TaprootAddress Create(string bech32, Network expectedNetwork);
    [NullableContextAttribute("2")]
private static string NotNull(TaprootPubKey pubKey);
    public TaprootPubKey get_PubKey();
    protected virtual Script GeneratePaymentScript();
    public sealed virtual Bech32Type get_Type();
}
public static class NBitcoin.TaprootConstants : object {
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class NBitcoin.TaprootExecutionData : object {
    [CompilerGeneratedAttribute]
private int <InputIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private uint256 <AnnexHash>k__BackingField;
    private TaprootSigHash _SigHash;
    [CompilerGeneratedAttribute]
private HashVersion <HashVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private uint256 <TapleafHash>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <CodeseparatorPosition>k__BackingField;
    public int InputIndex { get; public set; }
    public uint256 AnnexHash { get; public set; }
    public TaprootSigHash SigHash { get; public set; }
    public HashVersion HashVersion { get; }
    public uint256 TapleafHash { get; }
    public UInt32 CodeseparatorPosition { get; public set; }
    public TaprootExecutionData(int inputIndex);
    public TaprootExecutionData(int inputIndex, uint256 tapleaf);
    [CompilerGeneratedAttribute]
public int get_InputIndex();
    [CompilerGeneratedAttribute]
public void set_InputIndex(int value);
    [CompilerGeneratedAttribute]
public uint256 get_AnnexHash();
    [CompilerGeneratedAttribute]
public void set_AnnexHash(uint256 value);
    public static bool IsValidSigHash(byte value);
    public TaprootSigHash get_SigHash();
    public void set_SigHash(TaprootSigHash value);
    [CompilerGeneratedAttribute]
public HashVersion get_HashVersion();
    [CompilerGeneratedAttribute]
public uint256 get_TapleafHash();
    [CompilerGeneratedAttribute]
public UInt32 get_CodeseparatorPosition();
    [CompilerGeneratedAttribute]
public void set_CodeseparatorPosition(UInt32 value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NBitcoin.TaprootInternalPubKey : object {
    private Byte[] pubkey;
    public TaprootInternalPubKey(Byte[] pubkey);
    public static bool TryCreate(Byte[] pubkey, TaprootInternalPubKey& result);
    public Byte[] ToBytes();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(TaprootInternalPubKey other);
    public static bool op_Equality(TaprootInternalPubKey a, TaprootInternalPubKey b);
    public static bool op_Inequality(TaprootInternalPubKey a, TaprootInternalPubKey b);
    public virtual int GetHashCode();
    public virtual string ToString();
    public int CompareTo(TaprootInternalPubKey other);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NBitcoin.TaprootKeyPath : object {
    [CompilerGeneratedAttribute]
private uint256[] <LeafHashes>k__BackingField;
    [CompilerGeneratedAttribute]
private RootedKeyPath <RootedKeyPath>k__BackingField;
    public uint256[] LeafHashes { get; }
    public RootedKeyPath RootedKeyPath { get; }
    public TaprootKeyPath(RootedKeyPath rootedKeyPath);
    public TaprootKeyPath(RootedKeyPath rootedKeyPath, uint256[] leafHashes);
    [CompilerGeneratedAttribute]
public uint256[] get_LeafHashes();
    [CompilerGeneratedAttribute]
public RootedKeyPath get_RootedKeyPath();
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NBitcoin.TaprootPubKey : object {
    private Byte[] pubkey;
    [NullableAttribute("2")]
private Script scriptPubKey;
    public Script ScriptPubKey { get; }
    private Script NBitcoin.IDestination.ScriptPubKey { get; }
    public TaprootPubKey(Byte[] pubkey);
    public static bool TryCreate(Byte[] pubkey, TaprootPubKey& result);
    public Script get_ScriptPubKey();
    public Byte[] ToBytes();
    public TaprootAddress GetAddress(Network network);
    public virtual bool Equals(object obj);
    public static bool op_Equality(TaprootPubKey a, TaprootPubKey b);
    public static bool op_Inequality(TaprootPubKey a, TaprootPubKey b);
    public virtual int GetHashCode();
    private sealed virtual override BitcoinAddress NBitcoin.IAddressableDestination.GetAddress(Network network);
    private sealed virtual override Script NBitcoin.IDestination.get_ScriptPubKey();
    public virtual string ToString();
    public sealed virtual int CompareTo(TaprootPubKey other);
    private sealed virtual override bool NBitcoin.IAddressableDestination.IsSupported(Network network);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NBitcoin.TaprootReadyPrecomputedTransactionData : PrecomputedTransactionData {
    [CompilerGeneratedAttribute]
private uint256 <HashPrevoutsSingle>k__BackingField;
    [CompilerGeneratedAttribute]
private uint256 <HashSequenceSingle>k__BackingField;
    [CompilerGeneratedAttribute]
private uint256 <HashOutputsSingle>k__BackingField;
    [CompilerGeneratedAttribute]
private uint256 <HashAmountsSingle>k__BackingField;
    [CompilerGeneratedAttribute]
private uint256 <HashScriptsSingle>k__BackingField;
    [CompilerGeneratedAttribute]
private TxOut[] <SpentOutputs>k__BackingField;
    public uint256 HashPrevoutsSingle { get; public set; }
    public uint256 HashSequenceSingle { get; public set; }
    public uint256 HashOutputsSingle { get; public set; }
    public uint256 HashAmountsSingle { get; public set; }
    public uint256 HashScriptsSingle { get; public set; }
    public TxOut[] SpentOutputs { get; }
    public TaprootReadyPrecomputedTransactionData(Transaction tx, TxOut[] spentOutputs);
    [CompilerGeneratedAttribute]
public uint256 get_HashPrevoutsSingle();
    [CompilerGeneratedAttribute]
public void set_HashPrevoutsSingle(uint256 value);
    [CompilerGeneratedAttribute]
public uint256 get_HashSequenceSingle();
    [CompilerGeneratedAttribute]
public void set_HashSequenceSingle(uint256 value);
    [CompilerGeneratedAttribute]
public uint256 get_HashOutputsSingle();
    [CompilerGeneratedAttribute]
public void set_HashOutputsSingle(uint256 value);
    [CompilerGeneratedAttribute]
public uint256 get_HashAmountsSingle();
    [CompilerGeneratedAttribute]
public void set_HashAmountsSingle(uint256 value);
    [CompilerGeneratedAttribute]
public uint256 get_HashScriptsSingle();
    [CompilerGeneratedAttribute]
public void set_HashScriptsSingle(uint256 value);
    [CompilerGeneratedAttribute]
public TxOut[] get_SpentOutputs();
}
[FlagsAttribute]
public enum NBitcoin.TaprootSigHash : Enum {
    public UInt32 value__;
    public static TaprootSigHash Default;
    public static TaprootSigHash All;
    public static TaprootSigHash None;
    public static TaprootSigHash Single;
    public static TaprootSigHash AnyoneCanPay;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NBitcoin.TaprootSignature : object {
    [CompilerGeneratedAttribute]
private TaprootSigHash <SigHash>k__BackingField;
    [CompilerGeneratedAttribute]
private SchnorrSignature <SchnorrSignature>k__BackingField;
    public TaprootSigHash SigHash { get; }
    public SchnorrSignature SchnorrSignature { get; }
    public int Length { get; }
    public TaprootSignature(SchnorrSignature schnorrSignature);
    public TaprootSignature(SchnorrSignature schnorrSignature, TaprootSigHash sigHash);
    public static bool TryParse(Byte[] bytes, TaprootSignature& signature);
    public static TaprootSignature Parse(string hex);
    public static bool TryParse(string hex, TaprootSignature& signature);
    public static TaprootSignature Parse(Byte[] bytes);
    [CompilerGeneratedAttribute]
public TaprootSigHash get_SigHash();
    [CompilerGeneratedAttribute]
public SchnorrSignature get_SchnorrSignature();
    public int get_Length();
    public sealed virtual Byte[] ToBytes();
    public virtual string ToString();
}
public class NBitcoin.Target : object {
    private static Target _Difficulty1;
    private static BigInteger _Difficulty1BigInteger;
    private UInt32 _Target;
    private static BigInteger Ten;
    private Nullable`1<double> _Difficulty;
    public static Target Difficulty1 { get; }
    private static BigInteger Difficulty1BigInteger { get; }
    public double Difficulty { get; }
    public Target(UInt32 compact);
    public Target(Byte[] compact);
    public Target(BigInteger target);
    public Target(uint256 target);
    private static Target();
    public static Target get_Difficulty1();
    private static void InitDifficulty1();
    private static BigInteger get_Difficulty1BigInteger();
    internal static BigInteger ToBigInteger(uint256 target);
    public static Target op_Implicit(UInt32 a);
    public static UInt32 op_Implicit(Target a);
    public double get_Difficulty();
    public virtual bool Equals(object obj);
    public static bool op_Equality(Target a, Target b);
    public static bool op_Inequality(Target a, Target b);
    public virtual int GetHashCode();
    public BigInteger ToBigInteger();
    public UInt32 ToCompact();
    public uint256 ToUInt256();
    internal static uint256 ToUInt256(BigInteger input);
    public virtual string ToString();
}
public class NBitcoin.ThreadSafeList`1 : object {
    private List`1<T> _Behaviors;
    private object _lock;
    private Lazy`1<List`1<T>> _EnumeratorList;
    private void Modified();
    public IDisposable Add(T item);
    protected virtual void OnAdding(T obj);
    protected virtual void OnRemoved(T obj);
    public bool Remove(T item);
    public void Clear();
    public T FindOrCreate();
    public U FindOrCreate(Func`1<U> create);
    public U Find();
    public void Remove();
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [CompilerGeneratedAttribute]
private List`1<T> <Modified>b__4_0();
}
public class NBitcoin.Transaction : object {
    protected UInt32 nVersion;
    protected TxInList vin;
    protected TxOutList vout;
    protected LockTime nLockTime;
    protected static UInt32 NoDummyInput;
    private uint256[] _Hashes;
    public static UInt32 CURRENT_VERSION;
    public static UInt32 MAX_STANDARD_TX_SIZE;
    internal static int WITNESS_SCALE_FACTOR;
    private static UInt32 MAX_BLOCK_SIZE;
    private static ulong MAX_MONEY;
    internal static byte SIGHASH_OUTPUT_MASK;
    private static byte SIGHASH_INPUT_MASK;
    public bool RBF { get; }
    public UInt32 Version { get; public set; }
    public Money TotalOut { get; }
    public LockTime LockTime { get; public set; }
    public TxInList Inputs { get; }
    public TxOutList Outputs { get; }
    public bool IsCoinBase { get; }
    public bool HasWitness { get; }
    private static Transaction();
    public bool get_RBF();
    public UInt32 get_Version();
    public void set_Version(UInt32 value);
    public static Transaction Create(Network network);
    public static Transaction Parse(string hex, Network network);
    public static bool TryParse(string hex, Network network, Transaction& transaction);
    public static Transaction Load(Byte[] bytes, Network network);
    public static Transaction Load(Byte[] bytes, Nullable`1<UInt32> version, Network network);
    public Money get_TotalOut();
    public LockTime get_LockTime();
    public void set_LockTime(LockTime value);
    public TxInList get_Inputs();
    public TxOutList get_Outputs();
    public virtual void ReadWrite(BitcoinStream stream);
    public uint256 GetHash();
    protected virtual HashStreamBase CreateHashStream();
    protected virtual HashStreamBase CreateSignatureHashStream(HashVersion hashVersion);
    public void PrecomputeHash(bool invalidateExisting, bool lazily);
    public Transaction Clone(bool cloneCache);
    public uint256 GetWitHash();
    private IndexedTxIn GetIndexedInput(ICoin coin);
    public virtual bool get_IsCoinBase();
    public int GetVirtualSize();
    public void Sign(BitcoinSecret key, ICoin coin);
    public void Sign(BitcoinSecret key, IEnumerable`1<ICoin> coins);
    public void Sign(IEnumerable`1<BitcoinSecret> keys, IEnumerable`1<ICoin> coins);
    [NullableContextAttribute("1")]
public TaprootReadyPrecomputedTransactionData PrecomputeTransactionData(ICoin[] spentCoins);
    [NullableContextAttribute("1")]
public TaprootReadyPrecomputedTransactionData PrecomputeTransactionData(TxOut[] spentOutputs);
    [NullableContextAttribute("1")]
public PrecomputedTransactionData PrecomputeTransactionData();
    [NullableContextAttribute("1")]
public virtual PSBT CreatePSBT(Network network);
    [NullableContextAttribute("1")]
public TxPayload CreatePayload();
    [NullableContextAttribute("1")]
public string ToHex();
    public virtual string ToString();
    public virtual Money GetFee(ICoin[] spentCoins);
    public virtual Money GetFee(TxOut[] spentOutputs);
    public FeeRate GetFeeRate(ICoin[] spentCoins);
    public bool IsFinal(ChainedBlock block);
    public bool IsFinal(DateTimeOffset blockTime, int blockHeight);
    public bool CheckSequenceLocks(Int32[] prevHeights, ChainedBlock block, LockTimeFlags flags);
    public SequenceLock CalculateSequenceLocks(Int32[] prevHeights, ChainedBlock block, LockTimeFlags flags);
    private DateTimeOffset Max(DateTimeOffset a, DateTimeOffset b);
    public Transaction WithOptions(TransactionOptions options);
    public virtual bool get_HasWitness();
    public virtual TransactionCheckResult Check();
    public virtual uint256 GetSignatureHashTaproot(TxOut[] spentOutputs, TaprootExecutionData executionData);
    public virtual uint256 GetSignatureHashTaproot(PrecomputedTransactionData cache, TaprootExecutionData executionData);
    public virtual uint256 GetSignatureHash(Script scriptCode, int nIn, SigHash nHashType, TxOut spentOutput, HashVersion sigversion, PrecomputedTransactionData precomputedTransactionData);
    private static void WriteScriptCode(BitcoinStream stream, Script scriptCode);
    public uint256 GetSignatureHash(Script scriptCode, int nIn, SigHash nHashType, TxOut spentOutput, HashVersion sigversion);
    private static uint256 GetHash(BitcoinStream stream);
    internal virtual uint256 GetHashOutputs();
    internal virtual uint256 GetHashSequence();
    internal virtual uint256 GetHashPrevouts();
    internal virtual uint256 GetHashOutputs(HashVersion hashVersion);
    internal virtual uint256 GetHashSequence(HashVersion hashVersion);
    internal virtual uint256 GetHashPrevouts(HashVersion hashVersion);
    internal virtual uint256 GetHashAmounts(HashVersion hashVersion, IEnumerable`1<TxOut> outputsSpents);
    internal virtual uint256 GetHashScripts(HashVersion hashVersion, IEnumerable`1<TxOut> outputsSpents);
    protected BitcoinStream CreateHashWriter(HashVersion version);
    protected BitcoinStream CreateHashWriter(HashVersion version, string tag);
    public virtual ConsensusFactory GetConsensusFactory();
    public Transaction Clone();
    public void FromBytes(Byte[] bytes);
    public void FromBytes(Byte[] bytes, Nullable`1<UInt32> version);
    public TransactionValidator CreateValidator(ICoin[] spentCoins);
    public TxOut[] GetOrderedTxOuts(ICoin[] spentCoins);
    public TransactionValidator CreateValidator(TxOut[] spentOutputs);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NBitcoin.TransactionBuilder : object {
    private List`1<BuilderGroup> _BuilderGroups;
    [NullableAttribute("2")]
private BuilderGroup _CurrentGroup;
    [CompilerGeneratedAttribute]
private Random <ShuffleRandom>k__BackingField;
    [CompilerGeneratedAttribute]
private ICoinSelector <CoinSelector>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DustPrevention>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <OptInRBF>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ShuffleInputs>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ShuffleOutputs>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <MergeOutputs>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <FilterUneconomicalCoins>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private FeeRate <FilterUneconomicalCoinsRate>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Func`2<OutPoint, ICoin> <CoinFinder>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Func`2<Script, KeyPair> <KeyFinder>k__BackingField;
    private LockTime _LockTime;
    private Nullable`1<UInt32> _Version;
    internal List`1<KeyPair> _Keys;
    private static TxNullDataTemplate _OpReturnTemplate;
    [NullableAttribute("2")]
private SendBuilder _LastSendBuilder;
    [CompilerGeneratedAttribute]
private StandardTransactionPolicy <StandardTransactionPolicy>k__BackingField;
    [NullableAttribute("2")]
private string _OpReturnUser;
    [NullableAttribute("2")]
private AssetId _IssuedAsset;
    [CompilerGeneratedAttribute]
private Network <Network>k__BackingField;
    private List`1<Tuple`3<IPubKey, ITransactionSignature, OutPoint>> _KnownSignatures;
    private Dictionary`2<Script, Script> _ScriptPubKeyToRedeem;
    private SigningOptions signingOptions;
    private List`1<BuilderExtension> _Extensions;
    private static int MAX_TX_VSIZE;
    internal BuilderGroup CurrentGroup { get; }
    public Random ShuffleRandom { get; public set; }
    public ICoinSelector CoinSelector { get; public set; }
    public bool DustPrevention { get; public set; }
    public bool OptInRBF { get; public set; }
    public bool ShuffleInputs { get; public set; }
    public bool ShuffleOutputs { get; public set; }
    public bool MergeOutputs { get; public set; }
    public bool FilterUneconomicalCoins { get; public set; }
    [NullableAttribute("2")]
public FeeRate FilterUneconomicalCoinsRate { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Func`2<OutPoint, ICoin> CoinFinder { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Func`2<Script, KeyPair> KeyFinder { get; public set; }
    public StandardTransactionPolicy StandardTransactionPolicy { get; public set; }
    public Network Network { get; }
    public List`1<BuilderExtension> Extensions { get; }
    internal TransactionBuilder(Network network);
    private static TransactionBuilder();
    internal BuilderGroup get_CurrentGroup();
    private void InitExtensions();
    [CompilerGeneratedAttribute]
public Random get_ShuffleRandom();
    [CompilerGeneratedAttribute]
public void set_ShuffleRandom(Random value);
    [CompilerGeneratedAttribute]
public ICoinSelector get_CoinSelector();
    [CompilerGeneratedAttribute]
public void set_CoinSelector(ICoinSelector value);
    [CompilerGeneratedAttribute]
public bool get_DustPrevention();
    [CompilerGeneratedAttribute]
public void set_DustPrevention(bool value);
    [CompilerGeneratedAttribute]
public bool get_OptInRBF();
    [CompilerGeneratedAttribute]
public void set_OptInRBF(bool value);
    [CompilerGeneratedAttribute]
public bool get_ShuffleInputs();
    [CompilerGeneratedAttribute]
public void set_ShuffleInputs(bool value);
    [CompilerGeneratedAttribute]
public bool get_ShuffleOutputs();
    [CompilerGeneratedAttribute]
public void set_ShuffleOutputs(bool value);
    [CompilerGeneratedAttribute]
public bool get_MergeOutputs();
    [CompilerGeneratedAttribute]
public void set_MergeOutputs(bool value);
    [CompilerGeneratedAttribute]
public bool get_FilterUneconomicalCoins();
    [CompilerGeneratedAttribute]
public void set_FilterUneconomicalCoins(bool value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public FeeRate get_FilterUneconomicalCoinsRate();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_FilterUneconomicalCoinsRate(FeeRate value);
    [CompilerGeneratedAttribute]
public Func`2<OutPoint, ICoin> get_CoinFinder();
    [CompilerGeneratedAttribute]
public void set_CoinFinder(Func`2<OutPoint, ICoin> value);
    [CompilerGeneratedAttribute]
public Func`2<Script, KeyPair> get_KeyFinder();
    [CompilerGeneratedAttribute]
public void set_KeyFinder(Func`2<Script, KeyPair> value);
    public TransactionBuilder SetLockTime(LockTime lockTime);
    public TransactionBuilder SetVersion(UInt32 version);
    public TransactionBuilder AddKeys(ISecret[] keys);
    public TransactionBuilder AddKeys(Key[] keys);
    public TransactionBuilder AddKeys(KeyPair[] keyPairs);
    public TransactionBuilder AddKnownSignature(IPubKey pubKey, ITransactionSignature signature, OutPoint signedOutpoint);
    public TransactionBuilder SetOptInRBF(bool rbf);
    public TransactionBuilder AddCoin(ICoin coin);
    public TransactionBuilder AddCoin(ICoin coin, CoinOptions options);
    public TransactionBuilder AddCoins(ICoin[] coins);
    public TransactionBuilder AddCoins(IEnumerable`1<ICoin> coins);
    public TransactionBuilder AddCoins(PSBT psbt);
    public TransactionBuilder SetGroupName(string groupName);
    public TransactionBuilder Send(IDestination destination, Money amount);
    public TransactionBuilder SendAll(IDestination destination);
    public TransactionBuilder SendAll(Script scriptPubKey);
    public TransactionBuilder SendAllRemaining(IDestination destination);
    public TransactionBuilder SendAllRemaining(Script scriptPubKey);
    public TransactionBuilder SendAllRemainingToChange();
    public TransactionBuilder Send(Script scriptPubKey, Money amount);
    public TransactionBuilder SubtractFees();
    public TransactionBuilder Send(IDestination destination, IMoney amount);
    public TransactionBuilder Send(Script scriptPubKey, IMoney amount);
    public TransactionBuilder SendAsset(IDestination destination, AssetMoney asset);
    public TransactionBuilder SendAsset(IDestination destination, AssetId assetId, ulong quantity);
    private void DoShuffleGroups();
    private TxOut SetColoredChange(IMoney changeAmount, TransactionBuildingContext ctx);
    private TxOut SetChange(IMoney changeAmount, TransactionBuildingContext ctx);
    public TransactionBuilder SendAsset(Script scriptPubKey, AssetId assetId, ulong assetQuantity);
    public TransactionBuilder SendAsset(Script scriptPubKey, AssetMoney asset);
    internal Money GetDust();
    internal Money GetDust(Script script);
    public TransactionBuilder SetTransactionPolicy(StandardTransactionPolicy policy);
    [CompilerGeneratedAttribute]
public StandardTransactionPolicy get_StandardTransactionPolicy();
    [CompilerGeneratedAttribute]
public void set_StandardTransactionPolicy(StandardTransactionPolicy value);
    private void AssertOpReturn(string name);
    public TransactionBuilder IssueAsset(IDestination destination, AssetMoney asset);
    public TransactionBuilder IssueAsset(Script scriptPubKey, AssetMoney asset);
    public TransactionBuilder SetSigningOptions(SigningOptions signingOptions);
    public TransactionBuilder SetSigningOptions(SigHash sigHash);
    public TransactionBuilder SetSigningOptions(SigHash sigHash, bool enforceLowR);
    public bool TrySignInput(Transaction transaction, UInt32 index, ITransactionSignature& signature);
    public TransactionBuilder SendFees(Money fees);
    public TransactionBuilder SendEstimatedFees(FeeRate feeRate);
    public TransactionBuilder SendEstimatedFeesSplit(FeeRate feeRate);
    public TransactionBuilder SendFeesSplit(Money fees);
    public TransactionBuilder SetFeeWeight(decimal feeWeight);
    public TransactionBuilder SetChange(IDestination destination, ChangeType changeType);
    public TransactionBuilder SetChange(Script scriptPubKey, ChangeType changeType);
    [CompilerGeneratedAttribute]
public Network get_Network();
    public TransactionBuilder SetCoinSelector(ICoinSelector selector);
    public PSBT BuildPSBT(bool sign);
    public PSBT CreatePSBTFrom(Transaction tx, bool sign);
    private PSBT CreatePSBTFromCore(Transaction tx, bool sign);
    public TransactionBuilder SignPSBT(PSBT psbt);
    public TransactionBuilder SignPSBTInput(PSBTInput psbtInput);
    public TransactionBuilder FinalizePSBT(PSBT psbt);
    public TransactionBuilder FinalizePSBTInput(PSBTInput psbtInput);
    public TransactionBuilder ExtractSignatures(PSBT psbt, Transaction transaction);
    public TransactionBuilder UpdatePSBT(PSBT psbt);
    public Transaction BuildTransaction(bool sign);
    private bool IsEconomical(Coin c);
    private ICoin[] BuildTransaction(TransactionBuildingContext ctx, BuilderGroup group, List`1<Action`1<TransactionBuildingContext>> builders, IEnumerable`1<ICoin> coins);
    protected virtual void AfterBuild(Transaction transaction);
    public Transaction SignTransaction(Transaction transaction);
    public Transaction SignTransactionInPlace(Transaction transaction);
    private static void SetFinalScripts(TransactionSigningContext ctx, Transaction transaction);
    public FeeRate EstimateFeeRate(Transaction tx);
    private void ExtractExistingSignatures(TransactionSigningContext ctx);
    private void SignTransactionContext(TransactionSigningContext ctx);
    private void MergePartialSignatures(TransactionSigningContext ctx);
    private void FinalizeTransactionContext(TransactionSigningContext ctx);
    [IteratorStateMachineAttribute("NBitcoin.TransactionBuilder/<GetSigners>d__143")]
private IEnumerable`1<ISigner> GetSigners(InputSigningContext inputCtx);
    [IteratorStateMachineAttribute("NBitcoin.TransactionBuilder/<GetKeyRepositories>d__144")]
private IEnumerable`1<IKeyRepository> GetKeyRepositories(InputSigningContext inputCtx);
    public ICoin FindSignableCoin(IndexedTxIn txIn);
    public ICoin FindSignableCoin(TxIn txIn);
    private TxOut[] GetSpentOutputs(Transaction tx);
    public bool Verify(Transaction tx);
    public bool Verify(TransactionValidator validator);
    public bool Verify(Transaction tx, Money expectedFees);
    public bool Verify(TransactionValidator validator, Money expectedFees);
    public bool Verify(Transaction tx, FeeRate expectedFeeRate);
    public bool Verify(TransactionValidator validator, FeeRate expectedFeeRate);
    public bool Verify(Transaction tx, TransactionPolicyError[]& errors);
    public bool Verify(TransactionValidator validator, TransactionPolicyError[]& errors);
    public TransactionValidator CreateTransactionValidatorFromCoins(Transaction tx);
    public bool Verify(Transaction tx, Money expectedFees, TransactionPolicyError[]& errors);
    public bool Verify(TransactionValidator validator, Money expectedFees, TransactionPolicyError[]& errors);
    public bool Verify(Transaction tx, FeeRate expectedFeeRate, TransactionPolicyError[]& errors);
    public bool Verify(TransactionValidator validator, FeeRate expectedFeeRate, TransactionPolicyError[]& errors);
    public TransactionPolicyError[] Check(Transaction tx, FeeRate expectedFeeRate);
    public TransactionPolicyError[] Check(Transaction tx, Money expectedFee);
    public TransactionPolicyError[] Check(Transaction tx);
    private CoinNotFoundException CoinNotFound(IndexedTxIn txIn);
    public ICoin FindCoin(OutPoint outPoint);
    internal CoinOptions FindCoinOptions(OutPoint outPoint);
    public ICoin[] FindSpentCoins(Transaction tx);
    public int EstimateSize(Transaction tx);
    public int EstimateSize(Transaction tx, bool virtualSize);
    public void EstimateSizes(Transaction tx, Int32& witSize, Int32& baseSize);
    [NullableContextAttribute("2")]
private TxOut CreateTxOut(Money amount, Script script);
    private void EstimateScriptSigSize(ICoin coin, Int32& witSize, Int32& baseSize);
    public Money EstimateFees(FeeRate feeRate);
    public Money EstimateFees(Transaction tx, FeeRate feeRate);
    private static void AdjustFinalScripts(ICoin coin, PSBTInput txIn);
    internal bool IsCompatibleKeyFromScriptCode(IPubKey pubKey, Script scriptPubKey);
    public TransactionBuilder Then();
    public TransactionBuilder Then(string groupName);
    public TransactionBuilder AddCoins(Transaction transaction);
    public TransactionBuilder AddKnownRedeems(Script[] knownRedeems);
    [ObsoleteAttribute("Use PSBTs rather than raw transactions to combine signatures.")]
public Transaction CombineSignatures(Transaction[] transactions);
    public List`1<BuilderExtension> get_Extensions();
    private ScriptSigs GetScriptSigs(IndexedTxIn indexedTxIn);
    private Script DeduceScriptPubKey(Script scriptSig);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private ICoin <UpdatePSBT>b__130_0(IndexedTxIn i);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NBitcoin.TransactionChecker : object {
    [NullableAttribute("2")]
private PrecomputedTransactionData _PrecomputedTransactionData;
    private Transaction _Transaction;
    private int _Index;
    [NullableAttribute("2")]
private TxOut _SpentOutput;
    public PrecomputedTransactionData PrecomputedTransactionData { get; }
    public Transaction Transaction { get; }
    public TxIn Input { get; }
    public int Index { get; }
    [NullableAttribute("2")]
public TxOut SpentOutput { get; }
    [NullableContextAttribute("2")]
public TransactionChecker(Transaction tx, int index, TxOut spentOutput, PrecomputedTransactionData precomputedTransactionData);
    public TransactionChecker(Transaction tx, int index, TxOut spentOutput);
    public PrecomputedTransactionData get_PrecomputedTransactionData();
    public Transaction get_Transaction();
    public TxIn get_Input();
    public int get_Index();
    [NullableContextAttribute("2")]
public TxOut get_SpentOutput();
}
public enum NBitcoin.TransactionCheckResult : Enum {
    public int value__;
    public static TransactionCheckResult Success;
    public static TransactionCheckResult NoInput;
    public static TransactionCheckResult NoOutput;
    public static TransactionCheckResult NegativeOutput;
    public static TransactionCheckResult OutputTooLarge;
    public static TransactionCheckResult OutputTotalTooLarge;
    public static TransactionCheckResult TransactionTooLarge;
    public static TransactionCheckResult DuplicateInputs;
    public static TransactionCheckResult NullInputPrevOut;
    public static TransactionCheckResult CoinbaseScriptTooLarge;
}
public class NBitcoin.TransactionNotFoundException : Exception {
    [CompilerGeneratedAttribute]
private uint256 <TxId>k__BackingField;
    public uint256 TxId { get; public set; }
    public TransactionNotFoundException(uint256 txId);
    public TransactionNotFoundException(string message, uint256 txId);
    public TransactionNotFoundException(string message, uint256 txId, Exception inner);
    [CompilerGeneratedAttribute]
public uint256 get_TxId();
    [CompilerGeneratedAttribute]
public void set_TxId(uint256 value);
}
[FlagsAttribute]
public enum NBitcoin.TransactionOptions : Enum {
    public UInt32 value__;
    public static TransactionOptions None;
    public static TransactionOptions Witness;
    public static TransactionOptions All;
}
public class NBitcoin.TransactionSignature : object {
    private static TransactionSignature _Empty;
    private ECDSASignature _Signature;
    private SigHash _SigHash;
    private string _Id;
    public static TransactionSignature Empty { get; }
    public ECDSASignature Signature { get; }
    public SigHash SigHash { get; }
    private string Id { get; }
    public bool IsLowS { get; }
    public TransactionSignature(ECDSASignature signature, SigHash sigHash);
    public TransactionSignature(ECDSASignature signature);
    public TransactionSignature(Byte[] sigSigHash);
    public TransactionSignature(Byte[] sig, SigHash sigHash);
    private static TransactionSignature();
    public static TransactionSignature get_Empty();
    public static bool IsValid(Byte[] sig, ScriptVerify scriptVerify);
    public static bool IsValid(Byte[] sig, ScriptVerify scriptVerify, ScriptError& error);
    public ECDSASignature get_Signature();
    public SigHash get_SigHash();
    public sealed virtual Byte[] ToBytes();
    public static bool ValidLength(int length);
    private string get_Id();
    public virtual bool Equals(object obj);
    public static bool op_Equality(TransactionSignature a, TransactionSignature b);
    public static bool op_Inequality(TransactionSignature a, TransactionSignature b);
    public virtual int GetHashCode();
    public virtual string ToString();
    public bool get_IsLowS();
    public TransactionSignature MakeCanonical();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NBitcoin.TransactionValidator : object {
    [CompilerGeneratedAttribute]
private Transaction <Transaction>k__BackingField;
    [CompilerGeneratedAttribute]
private TxOut[] <SpentOutputs>k__BackingField;
    [CompilerGeneratedAttribute]
private PrecomputedTransactionData <PrecomputedTransactionData>k__BackingField;
    [CompilerGeneratedAttribute]
private ScriptVerify <ScriptVerify>k__BackingField;
    public Transaction Transaction { get; }
    public TxOut[] SpentOutputs { get; }
    public PrecomputedTransactionData PrecomputedTransactionData { get; }
    public ScriptVerify ScriptVerify { get; public set; }
    internal TransactionValidator(Transaction transaction, TxOut[] spentOutputs);
    [CompilerGeneratedAttribute]
public Transaction get_Transaction();
    [CompilerGeneratedAttribute]
public TxOut[] get_SpentOutputs();
    [CompilerGeneratedAttribute]
public PrecomputedTransactionData get_PrecomputedTransactionData();
    [CompilerGeneratedAttribute]
public ScriptVerify get_ScriptVerify();
    [CompilerGeneratedAttribute]
public void set_ScriptVerify(ScriptVerify value);
    public bool TryValidateInput(int index, InputValidationResult& result);
    public InputValidationResult ValidateInput(int index);
    public InputValidationResult[] ValidateInputs();
}
public class NBitcoin.TxIn : object {
    protected OutPoint prevout;
    protected Script scriptSig;
    protected UInt32 nSequence;
    private WitScript witScript;
    public Sequence Sequence { get; public set; }
    public OutPoint PrevOut { get; public set; }
    public Script ScriptSig { get; public set; }
    public WitScript WitScript { get; public set; }
    public bool IsFinal { get; }
    public TxIn(Script scriptSig);
    public TxIn(OutPoint prevout, Script scriptSig);
    public TxIn(OutPoint prevout);
    public Sequence get_Sequence();
    public void set_Sequence(Sequence value);
    public OutPoint get_PrevOut();
    public void set_PrevOut(OutPoint value);
    public Script get_ScriptSig();
    public void set_ScriptSig(Script value);
    [ObsoleteAttribute("Do not use this, it isn't possible to get a signer's address from a script without taking heuristic which can be gamed by a malicious actor")]
public IDestination GetSigner();
    public WitScript get_WitScript();
    public void set_WitScript(WitScript value);
    public virtual void ReadWrite(BitcoinStream stream);
    public bool IsFrom(PubKey pubKey);
    public bool get_IsFinal();
    public virtual ConsensusFactory GetConsensusFactory();
    public virtual TxIn Clone();
    public static TxIn CreateCoinbase(int height);
}
public class NBitcoin.TxInList : UnsignedList`1<TxIn> {
    public TxInList(int capacity);
    public TxInList(Transaction parent);
    public IndexedTxIn FindIndexedInput(OutPoint outpoint);
    public IndexedTxIn FindIndexedInput(int index);
    public TxIn CreateNewTxIn(OutPoint outpoint, Script scriptSig, WitScript witScript, Nullable`1<Sequence> sequence);
    public TxIn Add(OutPoint outpoint, Script scriptSig, WitScript witScript, Nullable`1<Sequence> sequence);
    public TxIn Add(TxIn txIn);
    public IEnumerable`1<IndexedTxIn> AsIndexedInputs();
    public TxIn Add(Transaction prevTx, int outIndex);
    [CompilerGeneratedAttribute]
private IndexedTxIn <AsIndexedInputs>b__8_0(TxIn r, int i);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NBitcoin.TxNullDataTemplate : ScriptTemplate {
    private static TxNullDataTemplate _Instance;
    [CompilerGeneratedAttribute]
private int <MaxScriptSizeLimit>k__BackingField;
    public static int MAX_OP_RETURN_RELAY;
    public static TxNullDataTemplate Instance { get; }
    public int MaxScriptSizeLimit { get; private set; }
    public TxNullDataTemplate(int maxScriptSize);
    private static TxNullDataTemplate();
    public static TxNullDataTemplate get_Instance();
    [CompilerGeneratedAttribute]
public int get_MaxScriptSizeLimit();
    [CompilerGeneratedAttribute]
private void set_MaxScriptSizeLimit(int value);
    protected virtual bool FastCheckScriptPubKey(Script scriptPubKey, Boolean& needMoreCheck);
    protected virtual bool CheckScriptPubKeyCore(Script scriptPubKey, Op[] scriptPubKeyOps);
    public Byte[][] ExtractScriptPubKeyParameters(Script scriptPubKey);
    protected virtual bool CheckScriptSigCore(Script scriptSig, Op[] scriptSigOps, Script scriptPubKey, Op[] scriptPubKeyOps);
    public Script GenerateScriptPubKey(Byte[][] data);
}
public class NBitcoin.TxOut : object {
    protected Script publicKey;
    internal static Money NullMoney;
    private Money _Value;
    private static FeeRate dustRelayFee;
    public Script ScriptPubKey { get; public set; }
    public Money Value { get; public set; }
    public TxOut(Money value, IDestination destination);
    public TxOut(Money value, Script scriptPubKey);
    private static TxOut();
    public Script get_ScriptPubKey();
    public void set_ScriptPubKey(Script value);
    public virtual Money get_Value();
    public virtual void set_Value(Money value);
    public bool IsDust();
    [ObsoleteAttribute("Use IsDust() instead. The minRelayTxFee is now ignored.")]
public bool IsDust(FeeRate minRelayTxFee);
    public virtual Money GetDustThreshold();
    [ObsoleteAttribute("Use GetDustThreshold() instead. The minRelayTxFee is now ignored.")]
public Money GetDustThreshold(FeeRate minRelayTxFee);
    public virtual void ReadWrite(BitcoinStream stream);
    public bool IsTo(IDestination destination);
    public static TxOut Parse(string hex);
    public virtual TxOut Clone();
    public virtual ConsensusFactory GetConsensusFactory();
}
public class NBitcoin.TxOutCompressor : object {
    private TxOut _TxOut;
    public TxOut TxOut { get; }
    public TxOutCompressor(TxOut txOut);
    private ulong CompressAmount(ulong n);
    private ulong DecompressAmount(ulong x);
    public TxOut get_TxOut();
    public sealed virtual void ReadWrite(BitcoinStream stream);
}
public class NBitcoin.TxOutList : UnsignedList`1<TxOut> {
    public TxOutList(int capacity);
    public TxOutList(Transaction parent);
    public IEnumerable`1<TxOut> To(IDestination destination);
    public IEnumerable`1<TxOut> To(Script scriptPubKey);
    public IEnumerable`1<IndexedTxOut> AsIndexedOutputs();
    [IteratorStateMachineAttribute("NBitcoin.TxOutList/<AsCoins>d__6")]
public IEnumerable`1<Coin> AsCoins();
    public TxOut CreateNewTxOut();
    public TxOut CreateNewTxOut(Money money, Script scriptPubKey);
    public TxOut CreateNewTxOut(Money money, IDestination destination);
    public TxOut Add(Money money, Script scriptPubKey);
    public TxOut Add(Money money, IDestination destination);
    public TxOut Add(TxOut txOut);
    [CompilerGeneratedAttribute]
private IndexedTxOut <AsIndexedOutputs>b__5_0(TxOut r, int i);
}
[ExtensionAttribute]
public static class NBitcoin.TxRepoExtensions : object {
    [ExtensionAttribute]
public static Task`1<Transaction> GetAsync(ITransactionRepository repo, string txId);
    [ExtensionAttribute]
public static Task PutAsync(ITransactionRepository repo, Transaction tx);
    [ExtensionAttribute]
public static Transaction Get(ITransactionRepository repo, string txId);
    [ExtensionAttribute]
public static void Put(ITransactionRepository repo, Transaction tx);
    [ExtensionAttribute]
public static Transaction Get(ITransactionRepository repo, uint256 txId);
    [ExtensionAttribute]
public static void Put(ITransactionRepository repo, uint256 txId, Transaction tx);
}
public class NBitcoin.uint160 : object {
    private static uint160 _Zero;
    private static uint160 _One;
    private static HexEncoder Encoder;
    private static int WIDTH_BYTE;
    internal UInt32 pn0;
    internal UInt32 pn1;
    internal UInt32 pn2;
    internal UInt32 pn3;
    internal UInt32 pn4;
    public static uint160 Zero { get; }
    public static uint160 One { get; }
    public int Size { get; }
    public uint160(uint160 b);
    public uint160(ulong b);
    public uint160(Byte[] vch, bool lendian);
    public uint160(string str);
    public uint160(Byte[] vch);
    private static uint160();
    public static uint160 get_Zero();
    public static uint160 get_One();
    public static uint160 Parse(string hex);
    public static bool TryParse(string hex, uint160& result);
    public byte GetByte(int index);
    public virtual string ToString();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(uint160 other);
    public sealed virtual int CompareTo(uint160 other);
    public sealed virtual int CompareTo(object obj);
    public static bool op_Equality(uint160 a, uint160 b);
    public static bool op_LessThan(uint160 a, uint160 b);
    public static bool op_GreaterThan(uint160 a, uint160 b);
    public static bool op_LessThanOrEqual(uint160 a, uint160 b);
    public static bool op_GreaterThanOrEqual(uint160 a, uint160 b);
    private static int Comparison(uint160 a, uint160 b);
    public static bool op_Inequality(uint160 a, uint160 b);
    public static bool op_Equality(uint160 a, ulong b);
    public static bool op_Inequality(uint160 a, ulong b);
    public static uint160 op_Implicit(ulong value);
    public Byte[] ToBytes(bool lendian);
    public MutableUint160 AsBitcoinSerializable();
    public int GetSerializeSize(int nType, Nullable`1<UInt32> protocolVersion);
    public int get_Size();
    public ulong GetLow64();
    public UInt32 GetLow32();
    public virtual int GetHashCode();
}
public class NBitcoin.uint256 : object {
    private static uint256 _Zero;
    private static uint256 _One;
    private static HexEncoder Encoder;
    private static int WIDTH_BYTE;
    internal ulong pn0;
    internal ulong pn1;
    internal ulong pn2;
    internal ulong pn3;
    public static uint256 Zero { get; }
    public static uint256 One { get; }
    public int Size { get; }
    public uint256(uint256 b);
    public uint256(ulong b);
    public uint256(Byte[] vch, bool lendian);
    public uint256(Byte[] vch, int offset, int length, bool lendian);
    public uint256(string str);
    public uint256(Byte[] vch);
    private static uint256();
    public static uint256 get_Zero();
    public static uint256 get_One();
    public static uint256 Parse(string hex);
    public static bool TryParse(string hex, uint256& result);
    public byte GetByte(int index);
    public virtual string ToString();
    public int GetBisCount();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(uint256 other);
    public sealed virtual int CompareTo(uint256 other);
    public sealed virtual int CompareTo(object obj);
    public static bool op_Equality(uint256 a, uint256 b);
    public static bool op_LessThan(uint256 a, uint256 b);
    public static bool op_GreaterThan(uint256 a, uint256 b);
    public static bool op_LessThanOrEqual(uint256 a, uint256 b);
    public static bool op_GreaterThanOrEqual(uint256 a, uint256 b);
    private static int Comparison(uint256 a, uint256 b);
    public static bool op_Inequality(uint256 a, uint256 b);
    public static bool op_Equality(uint256 a, ulong b);
    public static bool op_Inequality(uint256 a, ulong b);
    public static uint256 op_Implicit(ulong value);
    public Byte[] ToBytes(bool lendian);
    public void ToBytes(Byte[] output);
    public void ToBytes(Byte[] output, bool lendian);
    public MutableUint256 AsBitcoinSerializable();
    public int GetSerializeSize(int nType, Nullable`1<UInt32> protocolVersion);
    public int get_Size();
    public ulong GetLow64();
    public UInt32 GetLow32();
    public virtual int GetHashCode();
}
public class NBitcoin.UnsecureRandom : object {
    private Random _Rand;
    public sealed virtual void GetBytes(Byte[] output);
}
[DefaultMemberAttribute("Item")]
public class NBitcoin.UnsignedList`1 : List`1<T> {
    [CompilerGeneratedAttribute]
private Transaction <Transaction>k__BackingField;
    public Transaction Transaction { get; internal set; }
    public T Item { get; public set; }
    public UnsignedList`1(Transaction parent);
    public UnsignedList`1(IEnumerable`1<T> collection);
    public UnsignedList`1(int capacity);
    [CompilerGeneratedAttribute]
public Transaction get_Transaction();
    [CompilerGeneratedAttribute]
internal void set_Transaction(Transaction value);
    public T get_Item(UInt32 index);
    public void set_Item(UInt32 index, T value);
}
public class NBitcoin.Utils : object {
    private static DateTimeOffset unixRef;
    private static Utils();
    internal static void SafeSet(ManualResetEvent ar);
    public static bool ArrayEqual(Byte[] a, Byte[] b);
    public static bool ArrayEqual(Byte[] a, int startA, Byte[] b, int startB, int length);
    private static void Write(MemoryStream ms, Byte[] bytes);
    internal static Byte[] BigIntegerToBytes(BigInteger b, int numBytes);
    internal static Byte[] BigIntegerToBytes(BigInteger num);
    internal static BigInteger BytesToBigInteger(Byte[] data);
    public static UInt32 DateTimeToUnixTime(DateTimeOffset dt);
    internal static ulong DateTimeToUnixTimeLong(DateTimeOffset dt);
    public static DateTimeOffset UnixTimeToDateTime(UInt32 timestamp);
    public static DateTimeOffset UnixTimeToDateTime(ulong timestamp);
    public static DateTimeOffset UnixTimeToDateTime(long timestamp);
    public static string ExceptionToString(Exception exception);
    public static void Shuffle(T[] arr, Random rand);
    public static void Shuffle(List`1<T> arr, int start, Random rand);
    public static void Shuffle(List`1<T> arr, Random rand);
    public static void Shuffle(T[] arr, int seed);
    public static void Shuffle(T[] arr);
    public static Byte[] ToBytes(UInt32 value, bool littleEndian);
    public static Byte[] ToBytes(ulong value, bool littleEndian);
    public static UInt32 ToUInt32(Byte[] value, int index, bool littleEndian);
    public static int ToInt32(Byte[] value, int index, bool littleEndian);
    public static UInt32 ToUInt32(Byte[] value, bool littleEndian);
    public static ulong ToUInt64(Byte[] value, int offset, bool littleEndian);
    public static ulong ToUInt64(Byte[] value, bool littleEndian);
    public static int GetHashCode(Byte[] array);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NBitcoin.WitKeyId : object {
    private uint160 v;
    public Script ScriptPubKey { get; }
    public WitKeyId(Byte[] value);
    public WitKeyId(uint160 value);
    public WitKeyId(string value);
    public sealed virtual Script get_ScriptPubKey();
    public KeyId AsKeyId();
    public BitcoinWitPubKeyAddress GetAddress(Network network);
    private sealed virtual override BitcoinAddress NBitcoin.IAddressableDestination.GetAddress(Network network);
    public sealed virtual bool IsSupported(Network network);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
public static bool op_Equality(WitKeyId a, WitKeyId b);
    [NullableContextAttribute("2")]
public static bool op_Inequality(WitKeyId a, WitKeyId b);
    public virtual int GetHashCode();
    public Byte[] ToBytes();
    public virtual string ToString();
}
internal class NBitcoin.Witness : object {
    private TxInList _Inputs;
    public Witness(TxInList inputs);
    internal bool IsNull();
    internal void ReadWrite(BitcoinStream stream);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NBitcoin.WitProgramParameters : object {
    [CompilerGeneratedAttribute]
private OpcodeType <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <Program>k__BackingField;
    public OpcodeType Version { get; public set; }
    public Byte[] Program { get; public set; }
    public WitProgramParameters(OpcodeType version, Byte[] program);
    [CompilerGeneratedAttribute]
public OpcodeType get_Version();
    [CompilerGeneratedAttribute]
public void set_Version(OpcodeType value);
    [CompilerGeneratedAttribute]
public Byte[] get_Program();
    [CompilerGeneratedAttribute]
public void set_Program(Byte[] value);
    public bool NeedWitnessRedeemScript();
    public bool VerifyWitnessRedeemScript(Script witnessRedeemScript);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class NBitcoin.WitScript : object {
    private Byte[][] _Pushes;
    private static WitScript _Empty;
    public Byte[] Item { get; }
    public IEnumerable`1<Byte[]> Pushes { get; }
    public static WitScript Empty { get; }
    public int PushCount { get; }
    public WitScript(string script);
    public WitScript(Byte[][] script, bool unsafe);
    public WitScript(IEnumerable`1<Byte[]> script, bool unsafe);
    public WitScript(Op[] ops);
    public WitScript(Byte[] script);
    public WitScript(Script scriptSig);
    private static WitScript();
    [NullableContextAttribute("2")]
public static bool IsNullOrEmpty(WitScript witScript);
    public void WriteToStream(BitcoinStream stream);
    public static WitScript Load(BitcoinStream stream);
    private void ReadCore(BitcoinStream stream);
    private static Byte[] ReadPush(BitcoinStream stream);
    public Byte[] get_Item(int index);
    public IEnumerable`1<Byte[]> get_Pushes();
    public static WitScript get_Empty();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(WitScript item);
    [NullableContextAttribute("2")]
public static bool op_Equality(WitScript a, WitScript b);
    [NullableContextAttribute("2")]
public static bool op_Inequality(WitScript a, WitScript b);
    [NullableContextAttribute("2")]
public static WitScript op_Addition(WitScript a, WitScript b);
    [NullableContextAttribute("2")]
public static Script op_Implicit(WitScript witScript);
    public virtual int GetHashCode();
    public Byte[] ToBytes();
    private void Serialize(BitcoinStream stream);
    public int GetSerializedSize();
    public virtual string ToString();
    public Script ToScript();
    public int get_PushCount();
    public Byte[] GetUnsafePush(int i);
    public WitScript Clone();
    [NullableContextAttribute("2")]
[ObsoleteAttribute("Do not use this, it isn't possible to get a signer's address from a script without taking heuristic which can be gamed by a malicious actor")]
public IAddressableDestination GetSigner();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NBitcoin.WitScriptId : object {
    private uint256 v;
    [NullableAttribute("2")]
public ScriptId _HashForLookUp;
    public ScriptId HashForLookUp { get; }
    public Script ScriptPubKey { get; }
    public WitScriptId(Byte[] value);
    public WitScriptId(uint256 value);
    public WitScriptId(string value);
    public WitScriptId(Script script);
    public ScriptId get_HashForLookUp();
    public sealed virtual Script get_ScriptPubKey();
    public BitcoinWitScriptAddress GetAddress(Network network);
    private sealed virtual override BitcoinAddress NBitcoin.IAddressableDestination.GetAddress(Network network);
    public sealed virtual bool IsSupported(Network network);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
public static bool op_Equality(WitScriptId a, WitScriptId b);
    [NullableContextAttribute("2")]
public static bool op_Inequality(WitScriptId a, WitScriptId b);
    public virtual int GetHashCode();
    public Byte[] ToBytes();
    public virtual string ToString();
}
public enum NBitcoin.WordCount : Enum {
    public int value__;
    public static WordCount Twelve;
    public static WordCount Fifteen;
    public static WordCount Eighteen;
    public static WordCount TwentyOne;
    public static WordCount TwentyFour;
}
public class NBitcoin.Wordlist : object {
    private static Wordlist _Japanese;
    private static Wordlist _ChineseSimplified;
    private static Wordlist _ChineseTraditional;
    private static Wordlist _Spanish;
    private static Wordlist _English;
    private static Wordlist _French;
    private static Wordlist _PortugueseBrazil;
    private static Wordlist _Czech;
    private static Dictionary`2<string, Wordlist> _LoadedLists;
    [CompilerGeneratedAttribute]
private static IWordlistSource <WordlistSource>k__BackingField;
    private String[] _words;
    private string _Name;
    private char _Space;
    public static Wordlist Japanese { get; }
    public static Wordlist ChineseSimplified { get; }
    public static Wordlist ChineseTraditional { get; }
    public static Wordlist Spanish { get; }
    public static Wordlist English { get; }
    public static Wordlist French { get; }
    public static Wordlist PortugueseBrazil { get; }
    public static Wordlist Czech { get; }
    public static IWordlistSource WordlistSource { get; public set; }
    public string Name { get; }
    public char Space { get; }
    public int WordCount { get; }
    private static Wordlist();
    public Wordlist(String[] words, char space, string name);
    public static Wordlist get_Japanese();
    public static Wordlist get_ChineseSimplified();
    public static Wordlist get_ChineseTraditional();
    public static Wordlist get_Spanish();
    public static Wordlist get_English();
    public static Wordlist get_French();
    public static Wordlist get_PortugueseBrazil();
    public static Wordlist get_Czech();
    public static Task`1<Wordlist> LoadWordList(Language language);
    internal static string GetLanguageFileName(Language language);
    [AsyncStateMachineAttribute("NBitcoin.Wordlist/<LoadWordList>d__28")]
public static Task`1<Wordlist> LoadWordList(string name);
    [CompilerGeneratedAttribute]
public static IWordlistSource get_WordlistSource();
    [CompilerGeneratedAttribute]
public static void set_WordlistSource(IWordlistSource value);
    public string get_Name();
    public char get_Space();
    public bool WordExists(string word, Int32& index);
    public string GetWordAtIndex(int index);
    public int get_WordCount();
    public static Task`1<Wordlist> AutoDetectAsync(string sentence);
    public static Wordlist AutoDetect(string sentence);
    public static Language AutoDetectLanguage(String[] words);
    public static Language AutoDetectLanguage(string sentence);
    public String[] Split(string mnemonic);
    public virtual string ToString();
    public ReadOnlyCollection`1<string> GetWords();
    public String[] GetWords(Int32[] indices);
    public string GetSentence(Int32[] indices);
    public Int32[] ToIndices(String[] words);
    public Int32[] ToIndices(string sentence);
    public static BitArray ToBits(Int32[] values);
    public static Int32[] ToIntegers(BitArray bits);
    public BitArray ToBits(string sentence);
    public String[] GetWords(string sentence);
    [CompilerGeneratedAttribute]
private string <GetWords>b__52_0(int i);
    [CompilerGeneratedAttribute]
private string <GetWords>b__59_0(int i);
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public MaybeNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[AttributeUsageAttribute("10368")]
internal class System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <ParameterName>k__BackingField;
    public string ParameterName { get; }
    public NotNullIfNotNullAttribute(string parameterName);
    [CompilerGeneratedAttribute]
public string get_ParameterName();
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.NotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public NotNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsReadOnlyAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
public static class System.Web.NBitcoin.HttpUtility : object {
    public static string UrlDecode(string str);
    private static void WriteCharBytes(IList buf, char ch, Encoding e);
    public static string UrlDecode(string s, Encoding e);
    private static int GetInt(byte b);
    private static int GetChar(string str, int offset, int length);
    public static string UrlEncode(string str);
    public static string UrlEncode(string s, Encoding Enc);
    public static Byte[] UrlEncodeToBytes(Byte[] bytes, int offset, int count);
}
internal class System.Web.Util.HttpEncoder : object {
    private static Char[] hexChars;
    private static object entitiesLock;
    private static HttpEncoder defaultEncoder;
    private static HttpEncoder currentEncoder;
    private static HttpEncoder();
    internal static Byte[] UrlEncodeToBytes(Byte[] bytes, int offset, int count);
    internal static bool NotEncoded(char c);
    internal static void UrlEncodeChar(char c, Stream result, bool isUnicode);
}
